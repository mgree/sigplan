{"article_publication_date": "05-17-2002", "fulltext": "\n Extended Static Checking for Java * Cormac Flanagan K. Rustan M. Leino Mark Lillibridge Greg Nelson \nJames B. Saxe Raymie Stata Compaq Systems Research Center 130 Lytton Ave. Palo Alto, CA 94301, USA ABSTRACT \nSoftware development and maintenance are costly endeav\u00adors. The cost can be reduced if more software \ndefects are detected earlier in the development cycle. This paper in\u00adtroduces the Extended Static Checker \nfor Java (ESC/Java), an experimental compile-time program checker that .nds common programming errors. \nThe checker is powered by veri.cation-condition generation and automatic theorem\u00adproving techniques. \nIt provides programmers with a sim\u00adple annotation language with which programmer design de\u00adcisions can \nbe expressed formally. ESC/Java examines the annotated software and warns of inconsistencies between \nthe design decisions recorded in the annotations and the actual code, and also warns of potential runtime \nerrors in the code. This paper gives an overview of the checker architecture and annotation language \nand describes our experience applying the checker to tens of thousands of lines of Java programs.  Categories \nand Subject Descriptors D.2.1 [Software Engineering]: Requirements/Speci.cations; D.2.4 [Software Engineering]: \nProgram Veri.cation  General Terms Design, Documentation, Veri.cation  Keywords Compile-time program \nchecking 1. INTRODUCTION Over the last decade, our group at the Systems Research Center has built and \nexperimented with two realizations of a new program checking technology that we call extended * Current \naddress: Microsoft Research, One Microsoft Way, Redmond, WA 98052. Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 02, June 17-19, 2002, Berlin, Germany. \nCopyright 2002 ACM 1-58113-463-0/02/0006 ...$5.00. coverage decidability ceiling  effort Figure 1: Static \ncheckers plotted along the two di\u00admensions coverage and e.ort (not to scale). static checking (ESC): \nstatic because the checking is per\u00adformed without running the program, and extended be\u00adcause ESC catches \nmore errors than are caught by conven\u00adtional static checkers such as type checkers. ESC uses an automatic \ntheorem-prover to reason about the semantics of programs, which allows ESC to give static warnings about \nmany errors that are caught at runtime by modern program\u00adming languages (null dereferences, array bounds \nerrors, type cast errors, etc.). It also warns about synchronization er\u00adrors in concurrent programs (race \nconditions, deadlocks). Finally, ESC allows the programmer to record design de\u00adcisions in an annotation \nlanguage, and issues warnings if the program violates these design decisions. Our .rst ex\u00adtended static \nchecker, ESC/Modula-3, has been described elsewhere [8]. This paper provides an overview of our sec\u00adond \nchecker, ESC/Java. It is not our goal in this paper to give a complete description of ESC/Java, but rather \nto give an overview that includes citations to more complete descriptions of particular aspects of the \nchecker. Static checking can improve software productivity because the cost of correcting an error is \nreduced if it is detected early. Figure 1 compares ESC with other static checkers on two important dimensions: \nthe degree of error coverage ob\u00adtained by running the tool and the cost of running the tool. In the upper \nright corner is full functional program veri.ca\u00adtion, which theoretically catches all errors, but is \nextremely expensive. In the lower left corner are static checking tech\u00adniques that are widely used, which \nrequire only modest ef\u00adfort, but catch only a limited class of errors: conventional type checkers and \ntype-checker-like tools such as lint [23]. These two corners of Figure 1 exercise a magnetic fascina\u00adtion \non programming researchers, but we suggest that the middle of the diagram is promising, and it is there \nthat we position ESC: we hope to produce a cost-e.ective tool by catching more errors than a type system \nor lint-like tool at a cost much less than full functional program veri.cation. The horizontal line in \nFigure 1 labeled the decidability ceiling re.ects the well-known fact that the static detec\u00adtion of many \nerrors of engineering importance (including array bounds errors, null dereferences, etc.)is undecidable. \nNevertheless, we aim to catch these errors, since in our en\u00adgineering experience, they are targets of \nchoice after type errors have been corrected, and the kinds of programs that occur in undecidability \nproofs rarely occur in practice. To be of value, all a checker needs to do is handle enough simple cases \nand call attention to the remaining hard cases, which can then be the focus of a manual code review. \nA distinguishing feature of our work is that ESC/Modu\u00adla-3 and ESC/Java both perform modular checking: \nthat is, they operate on one piece of a program at a time it is not necessary to have the source of the \nwhole program in order to run the checker. In our case, a piece is a single routine (method or constructor). \nWhether an automatic checker or manual checking like code reviews is used, modular checking is the only \nchecking that scales. Consequently we consider modular checking to be an essential requirement. The cost \nof modular checking is that annotations are need\u00aded to provide speci.cations of the routines that are \ncalled by the routine being checked. We argue that, in the absence of an automatic checker, manual checking \ndepends on these same annotations, typically in the form of English comments (which, not being machine \ncheckable, easily get out of synch with the source code over the life of a program). Unlike the complicated \npredicate logic speci.cations that seem to be required for full functional veri.cation, ESC annotations \nare straightforward statements of programmer design deci\u00adsions. Indeed, we are excited about the prospect \nthat the use of ESC in the classroom may help in the notoriously di.cult job of teaching students to \nwrite good comments, since ESC is a practical tool that gives error messages of the form missing comment \nand inaccurate comment . Two attributes of an ideal static checker are (1)if the program has any errors \nthen the checker will report some error (called soundness by mathematical logicians); and (2)every reported \nerror is a genuine error rather than a false alarm (called completeness by mathematical logi\u00adcians). \nIn extended static checking, we do not take either of these attributes to be a requirement. After all, \nthe com\u00adpeting technologies (manual code reviews and testing)are neither sound nor complete. Certainly \nfalse alarms are un\u00addesirable, since winnowing through the warnings to .nd the real errors is an added \ncost of running the tool, and cer\u00adtainly soundness is desirable, since every missed error is a lost opportunity \nfor the checker to be useful, but insisting that the checker meet either ideal is mistaken on engineering \ngrounds: if the checker .nds enough errors to repay the cost of running it and studying its output, then \nthe checker will be cost-e.ective, and a success. To achieve a cost-e.ective tool requires making good \nengineering trade-o.s between a variety of factors, including: missed errors (unsoundness), spurious \nwarnings (incompleteness), annotation overhead, and performance. The major novelty of ESC/Java compared \nto ESC/Mod\u00adula-3 is that ESC/Java has a simpler annotation language. An important innovation contributing \nto this simplicity is 1: class Bag { 2: int size ; 3: int[] elements ; // valid: elements[0..size-1] \n4: 5: Bag(int[] input) { 6: size = input.length ; 7: elements = new int[size]; 8: System.arraycopy(input, \n0, elements, 0, size); 9: } 10: 11: int extractMin() { 12: int min = Integer.MAX VALUE ; 13: int minIndex \n=0; 14: for (int i =1; i <= size ; i ++) { 15: if (elements[i] < min) { 16: min = elements[i]; 17: minIndex \n= i ; 18: } 19: } 20: size --; 21: elements[minIndex]= elements[size]; 22: return min ; 23: } 24: } Figure \n2: Original version of Bag.java. the object invariant, an annotation construct that will be described \nlater. The simpler annotation language, together with the fact that ESC/Java targets a more popular pro\u00adgramming \nlanguage, has allowed us to get more user experi\u00adence with ESC/Java than we did with ESC/Modula-3. This \nin turn has led us to engineer a number of improvements in the usability of the checker, for example \nexecution-trace information in warning messages. 2. AN EXAMPLE OF USING ESC/JAVA Perhaps the simplest \nway to impart a feeling for what it s like to use ESC/Java is to present an example in some detail. Figure \n2 shows a small skeleton of a class of integer bags (aka multisets). The class provides only two operations: \na bag may be constructed from an array of integers, and the smallest element of a bag may be extracted. \nTo invoke our checker, the user invokes it just as she would the Java compiler, but with escjava replacing \nthe name of the compiler on the command line: escjava Bag.java. In response, over about the next ten \nseconds on a 200 MHz Pentium Pro PC, ESC/Java produces 5 warnings: Bag.java:6: Warning: Possible null \ndereference (Null) size = input.length; ^ Bag.java:15: Warning: Possible null dereference (Null) if (elements[i] \n< min) { ^ Bag.java:15: Warning: Array index possibly too large (... if (elements[i] < min) { ^ Bag.java:21: \nWarning: Possible null dereference (Null) elements[minIndex] = elements[size]; ^ Bag.java:21: Warning: \nPossible negative array index (... elements[minIndex] = elements[size]; ^ The .rst of the warnings is \na complaint that the Bag constructor may dereference null (if it is called with a null argument). There \nare two reasonable responses to this: ei\u00adther bulletproof the constructor so it can be called with null \n(producing an empty bag), or forbid calling the constructor with null. For this example, we assume the \nuser chooses the second response. Traditionally, this would involve adding an English comment This constructor \nmay not be called with null and hoping that programmers writing code that uses Bag obey this requirement. \nInstead, with ESC/Java the user inserts (after line 4)a checker-readable comment (called an annotation)expressing \nthesamething: 4a: //@ requires input != null The @-sign at the start of this Java comment tells ESC/Java \nthat it is an ESC/Java annotation. This annotation tells the checker that the constructor has a precondition \nof input != null. When ESC/Java checks a routine, it assumes that the routine s preconditions hold on \nentry; at a call site, ESC/Java issues a warning if it cannot verify the preconditions of the called \nroutine. For Bag users, the annotation both provides documentation and lets them use ESC/Java to check \nthat they are using Bag correctly. The second and fourth warnings complain (for di.erent execution paths)that \nmethod extractMin may dereference null (if called when the .eld elements is null). These warn\u00adings may \nseem spurious: the constructor sets elements to a non-null value initially and extractMin does not assign \nto elements. Note, however, that elements is not a private .eld so that client code and (future)subclasses \nmay modify it. These warnings would be arguably spurious if elements was declared private: no use of \nBag could cause the warned about errors. Unfortunately, detecting this requires exam\u00adining all the other \ncode of Bag to make sure that there is no assignment of null to elements, which ESC/Java cannot do because \nit checks methods in isolation. Although annoy\u00ading in this case, in more realistic cases where determining \nif any code assigns null to elements can be di.cult for a human reader, these warnings serve the useful \npurpose of complaining about missing useful documentation. To specify the design decision that elements \nis always non\u00adnull, the user annotates the declaration of elements (line 3): 3. : /*@non null*/ int[] \nelements ; // ... ESC/Java generates a warning whenever it appears that code may assign null to a .eld \ndeclared non-null; it also checks that constructors initialize such .elds to non-null val\u00adues. Parameters \nmay also be declared non-null; for example, instead of adding line 4a, the user could have changed line \n5: 5.: Bag(/*@non null*/ int[] input) { Indeed, we recommend that users use non null where possible, \nboth because it is easier to type, and because, being a specialized form, it is easier to verify and \nproduce precise warning messages for. The remaining two warnings complain of possible sub\u00adscript errors. \nThe checker is worried that future code might set size to a bad value. Here we need an object invariant: \n2a: //@ invariant 0 <= size &#38;&#38; size <= elements.length An object invariant is a property that \nthe programmer in\u00adtends to hold at every routine boundary for every initialized instance of a class. \nThe checker will now attempt to prove that the size .eld is correct after a Bag is initially con\u00adstructed \nand that calling the extractMin method preserves its correctness. The checker will now also be able to \nuse the invariant to reason that subscript errors cannot occur because the size .eld was incorrect on \nentry to extractMin.  Having made these changes, the user reruns the checker to check for more possible \nerrors. Surprise! The checker again complains about possible subscript errors the same two warnings in \nfact (which in Figure 2 are lines 15 and 21). Looking more closely at the warning for line 15, the user \nrecalls that Java arrays are indexed from 0, and changes: 14: for (int i =1; i <= size ; i ++) { to: \n14.: for (int i =0; i < size ; i ++) { What about the warning that size may be negative at line 21? We \nknow that size is at least 0 when extractMin is called. But what if extractMin is called when the bag \nis empty? Then size will be -1 by that line because of the decrement statement on the previous line. \nOops! The user inserts a guard for the assignment to .x things: 20a: if (size >=0) { 21: elements[minIndex]= \nelements[size]; 21a: } Running the checker yields a new warning, complaining that extractMin fails to \nreestablish the object invariant: Bag.java:26: Warning: Possible violation of object in\u00ad variant } ^ \nAssociated declaration is \"Bag.java\", line 3, col 6: //@ invariant 0 <= size &#38;&#38; size <= elements.length \n^ Possibly relevant items from the counterexample context: brokenObj == this (brokenObj* refers to the \nobject for which the invariant is broken.) This warning has three parts. The .rst says that an invari\u00adant \nmay be broken at the end of method extractMin.The second says which invariant is involved. The third \nsays that the object whose invariant may be broken is this rather than some other bag. The programmer \nacted too hastily; the if statement just inserted also needs to protect the decrement of size: 19a: if \n(size > 0) { 20: size --; 21: elements[minIndex]= elements[size]; 21a: } Now, rerunning the checker yields \nno warnings. This means that the checker is unable to .nd more potential er\u00adrors, not necessarily that \nthe program is bug free.  3. ARCHITECTURE ESC/Java is the second extended static checker developed at \nthe Systems Research Center. Its architecture is similar to that of the earlier checker [8], which targeted \nthe Modula-3 language. Like that of traditional compilers, ESC/Java s ar\u00adchitecture is best thought of \nas a pipeline of data processing stages (see Figure 3). We describe each stage in turn. Front End. ESC/Java \ns front end acts similarly to that of a normal (Java)compiler, but parses and type checks ESC/Java annotationsaswellasJava \nsourcecode. The Annotated Java Program Abstract Syntax TreesType\u00ad (ASTs) specific Background Guarded \nCommandsPredicate (GCs) Verification Conditions (VCs) Universal Background Predicate (UBP) Output to \nUser Figure 3: The basic steps in ESC/Java s operation. front end produces abstract syntax trees (ASTs)as \nwell as a type-speci.c background predicate for each class whose rou\u00adtines are to be checked. The type-speci.c \nbackground pred\u00adicate is a formula in .rst-order logic encoding information about the types and .elds \nthat routines in that class use. For example, the type-speci.c background predicate for a .nal class \nT or any client of a .nal class T will include the conjunct ( . S :: S <: T . S = T ). Translator. The \nnext stage translates each routine body to be checked into a simple language based on Dijkstra s guarded \ncommands (GCs)[10]. ESC/Java s guarded com\u00admand language includes commands of the form assert E, where \nE is a boolean expression. An execution of a guarded command is said to go wrong if control reaches a \nsubcom\u00admand of the form assert E when E is false. Ideally the body of a routine R should translate into \na guarded com\u00admand G such that (1) G has at least one potential execution that starts in a state satisfying \nthe background predicate of R s class and goes wrong, if and only if (2)there is at least one way that \nR can be invoked from a state satisfying its speci.ed preconditions and then behave erroneously by, for \nexample, dereferencing null or terminating in a state that violates its speci.ed postconditions. In practice, \nthe translation is incomplete and unsound, so neither the if nor the only if above always holds. We mention \na few sources of inaccuracy in translation here. For a more extensive discussion of incompleteness and \nunsound\u00adness in ESC/Java, see appendix C of the ESC/Java user s manual [33]. Modular checking. In accordance \nwith the principle of modular checking, when ESC/Java produces the guarded command for a routine R, it \ntranslates each routine call in R according to the speci.cation, rather than the imple\u00admentation, of \nthe called routine. Consequently, the result\u00ading (nondeterministic)guarded command G may be able to go \nwrong in ways involving behaviors of called routines that are permitted by their speci.cation, but can \nnever oc\u00adcur with the actual implementations. Of course, modular checking has the advantage that if R \nis correct with respect to the speci.cations of the routines it calls, it will continue to behave correctly \nafter the implementations are replaced or overridden, so long as the new implementations continue to \nmeet the speci.cations. Over.ow. We do not model arithmetic over.ow because allowing the checker to consider \ncases such as adding positive integers and getting a negative sum leads to many spurious warnings. Loops. \nA precise semantics for loops can be de.ned us\u00ading weakest .xpoints of predicate transformers [10]; unfortu\u00adnately, \n.xpoints are not merely uncomputable but di.cult to compute in many practical cases. Therefore, ESC/Java \napproximates the semantics of loops by unrolling them a .xed number of times and replacing the remaining \nitera\u00adtions by code that terminates without ever producing an error. This misses errors that occur only \nin or after later iterations of a loop. Command-line options let the user control the amount of loop \nunrolling or substitute a sound alternative translation for loops that relies on the user to supply explicit \nloop in\u00advariants. By default, we unroll loops one and a half times (the half refers to an additional \nexecution of the loop guard): Using two unrollings on ESC/Java s front end, Javafe (see section 6.3), \nproduced only one plausibly interesting new warning but took 20% longer; .ve unrollings doubled the time \nbut produced no new non-spurious warnings. We have found that even expert users have di.culty providing \ncor\u00adrect and su.ciently strong loop invariants. VC Generator. The next stage generates veri.cation conditions \n(VCs)for each guarded command. A VC for a guarded command G is a predicate in .rst-order logic that holds \nfor precisely those program states from which no exe\u00adcution of the command G can go wrong. The computation \nof a VC is similar to the computation of a weakest precondi\u00adtion [10], but ESC/Java s VC-generation includes \noptimiza\u00adtions [19] to avoid the exponential blow-up inherent in a naive weakest-precondition computation. \nESC/Modula-3 also used guarded commands as an inter\u00admediate stage rather than deriving VCs directly from \nASTs. ESC/Java goes a step further in factoring the software com\u00adplexity of VC generation by using a \nsugared form of the GC language (not shown)as an intermediate stage between ASTs and the basic GC language \nthat is input to the VC generator. The initial step of translating ASTs to sugared GCs is bulky and tedious, \nincorporating many Java-speci.c details, but need only be written once. The desugaring step and the .nal \nVC-generation step are much simpler and easily rewritten as we explore di.erent soundness/incompleteness \ntradeo.s and possible performance improvements. For fur\u00adther discussion see [35]. Theorem Prover. For \neach routine R, the next stage invokes our automatic theorem prover, Simplify [9], on the conjecture \nUBP . BPT . VCR (1) where VCR is the VC for R,BPT is the type-speci.c back\u00adground predicate for the class \nT in which R is de.ned, and UBP is the universal background predicate, which encodes some general facts \nabout the semantics of Java for exam\u00adple, that the subtype relation is re.exive, antisymmetric, and transitive; \nand that all array types are subtypes of java.lang.Object. Subject to the translation limitations already \ndiscussed, the conjecture (1)will be valid i. the rou\u00adtine R has no errors. For a complete background \npredicate for a simple object-oriented language, see [27]. Postprocessor. The .nal stage postprocesses \nthe theo\u00adrem prover s output, producing warnings when the prover is unable to prove veri.cation conditions. \nSimplify, originally designed for use by ESC/Modula-3 and later evolved for use by ESC/Java, has several \nproperties that aid the postproces\u00adsor in constructing user-sensible warning messages, rather than just \nmarking a routine as possibly being erroneous. Counterexample contexts and labels. When it fails to .nd \na proof for a conjecture, Simplify normally .nds and reports one or more counterexample contexts, each \ncounterexample context being a conjunction of conditions that (1)collec\u00adtively imply the negation of \nthe conjecture and (2)have not been shown by the prover to be mutually inconsistent. The input to Simplify \ncan include positive and negative labels on some of its subformulas. A label has no e.ect on its subfor\u00admula \ns logical value, but each counterexample includes pos\u00aditive labels of true subformulas and negative labels \nof false subformulas deemed heuristically relevant to that counterex\u00adample. By carrying information \nabout source code locations through the various stages of processing, ESC/Java is able to label each \nruntime check with su.cient information to produce a detailed warning including the type of error and \nits location. For example, the postprocessor generates the .rst warning in the example of Section 2 from \nthe label in: (LBLNEG |Null@0.6.16| (NEQ |input:0.5.12| null)) within the VC for the Bag constructor. \nUnlike ESC/Modula-3, ESC/Java attaches labels not only to pieces of the VC that correspond to error conditions, \nbut also to pieces of the VC that correspond to the execution of particular fragments of the source code; \nby using these labels, it can construct an execution trace indicating a pos\u00adsible dynamic path to the \npotential error [38]. Multiple counterexample contexts. Although a given rou\u00adtine may be able to fail \nin multiple interesting ways, a dif\u00adferent counterexample may be required to demonstrate how each failure \ncan occur. We have modi.ed Simplify to gener\u00adate multiple counterexample contexts for a given conjecture \nwhen possible. This allows us to generate multiple warnings per routine. Simplify keeps track of the \nlabels reported with counterexample contexts and uses this information to keep from generating multiple \ncounterexamples that would turn into too-similar warning messages. Time and counterexample limits. We \nlimit the time Sim\u00adplify spends on each routine (5 minutes by default)as well as the number of counterexample \ncontexts Simplify may pro\u00adduce (10 by default). If either limit is exceeded, ESC/Java issues a caution \nto the user indicating that the routine might not have been fully checked. The counterexample limit safe\u00adguards \nagainst the possibility that ESC/Java might issue a .ood of apparently distinct warnings all arising \nfrom a single underlying problem with the program. Incompleteness. ESC/Java VCs are formulas in a theory \nthat includes .rst-order predicate calculus, which is only semi-decidable: any procedure that proves \nall valid formu\u00adlas loops forever on some invalid ones. By allowing Simplify to sometimes report a counterexample \nthat might, with more e.ort, have been shown to be inconsistent, it is able to produce more counterexamples \nwithin the time allotted. Such spurious counterexamples lead to spurious warnings. While Simplify is \nnot guaranteed to be bug-free, it incor\u00adporates no intentional unsoundnesses, which would lead to missed \nwarnings.  4. ANNOTATION LANGUAGE The largest di.erence between ESC/Java and ESC/Mod\u00adula-3 lies in the \nannotation language. In this section, we describe the main features of the ESC/Java annotation lan\u00adguage. \nThe full annotation language is described in the ESC/Java user s manual [33]. 4.1 General design considerations \nAn important design decision for the annotation language has been to make it as Java-like as possible. \nThis has two major advantages: it makes ESC/Java easier to learn, en\u00adcouraging .rst-time use; and it \nmakes the annotations more readable to non-ESC/Java users, increasing their value as primary documentation. \nTo a .rst approximation, annotations appear like other Java declarations, modi.ers, or statements, but \nenclosed in Java comments that begin with an @-sign. Expressions con\u00adtained in annotations are side-e.ect \nfree Java expressions, with a few additional keywords and functions. Beyond the syntactic issues lie \ndeeper design problems of which annotations to include and what they should mean. Ideally, the annotations \ncapture signi.cant programmer de\u00adsign decisions, and do so succinctly. Equally important, and of more \ndi.culty in the design of the annotation language, is that users not be required to document properties \nthat are tedious to specify and don t signi.cantly enable the de\u00adtection of important software errors. \nOur annotation language has also been shaped by a col\u00adlaborative e.ort with Gary Leavens et al. to make \nthe Java Modeling Language (JML [25, 26])and the ESC/Java anno\u00adtation language as similar as feasible. \nThe goals of ESC/Java and JML are di.erent: JML is intended to allow full spec\u00adi.cation of programs, \nwhereas ESC/Java is intended only for light-weight speci.cation. Therefore, some di.erences in the two \nlanguages remain, both syntactic and semantic. However, many programs annotated with ESC/Java anno\u00adtations \nare amenable to processing with tools targeting JML and sometimes vice versa, and programmers who learn \none language should have little trouble picking up the other. 4.2 Data abstraction vs. object invariants \nThe speci.cation language for ESC/Modula-3 included general data abstraction [32]. Abstract variables \ncould be declared (including abstract object .elds), which were un\u00adknown to the compiler and used only \nfor the purposes of the speci.cation language. The exact meaning of an abstract variable is given by \na representation declaration , which speci.es the value of the abstract variable as a function of other \nvariables (abstract or concrete)[22]. General data abstraction is very powerful. In ESC/Mod\u00adula-3 veri.cations, \nwe found that it was generally used in a very stylized way that we call the state/validity paradigm. \nIn this paradigm, two abstract variables are declared as .elds of each object type: valid and state. \nThe idea is that x.valid means that the object x satis.es the internal validity invariant of x s type, \nand x.state represents the ab\u00adstract state of the object x. In a full functional correctness veri.cation, \nthere would be many, many speci.cations to write about state, but in a typical ESC/Modula-3 veri.cation, \nvery little is said about it: it appears in the modi.es list of those operations that can change it, \nand the concrete variables that are part of its representation are declared to so be (by means of an \nabstraction dependency). In contrast to state, ESC/Modula-3 checking depends heav\u00adily on valid: almost \nall operations on an object x have x.valid as a precondition; initialization operations on x have x.valid \nas a postcondition; and any operations that destroy the va\u00adlidity of x (e.g., an operation to close .le \nx)have x.valid in their modi.es list, indicating that they are not guaranteed to preserve validity. These \nuses of valid enforce a protocol on a client using the type: the client must call a proper initializa\u00adtion \noperation before using the object, and may continue to use the object up until the object s validity \nis compromised. The representation declaration for valid de.nes the mean\u00ading of validity in concrete \nterms. This declaration is typi\u00adcally placed in the implementation where it is required. In verifying \nthe implementation of an operation on the type, the precondition x.valid is translated into concrete \nterms by the usual process of data abstraction, since the repre\u00adsentation is in scope. The occurrences \nof valid in client\u00advisible speci.cations enforce proper behavior on the part of the client, even though \nthe representation is invisible to the client, because the representation matters only to the im\u00adplementation, \nnot the client. General data abstraction is sweetly reasonable, but it is more complicated than we would \nlike (by about a hun\u00addred pages [32]). Mindful of the principle that perfection is achieved not when \nthere is nothing left to add but when there is nothing left to remove, we decided to leave data abstraction \nout of ESC/Java. In ESC/Modula-3, data ab\u00adstraction was used almost exclusively in the state/validity \nparadigm. ESC/Java object invariants provide much of the checking that is provided by the abstract variable \nvalid in the valid/state paradigm. And the checking provided by the abstract variable state did not .nd \nmany real errors. ESC/Java does support ghost .elds (see section 4.5), which are known only to the checker, \nnot to the compiler. Ghost .elds can be used as a substitute for abstract .elds, but while abstract .elds \nchange automatically when their repre\u00adsentation changes, ghost .elds must be updated by an ex\u00adplicit \nassignment: Consider the case of concrete c,abstract a,and rep a = c*c. We could mimic this situation \nwith ghost .eld g and an explicit ghost assignment set g = c*c whenever c changes. Adding the object \ninvariant g = c*c will provide protection against the error that the update to g is inadvertently omitted. \nBut this requires considerably more annotation than the abstract variable approach. The practical manifestation \nof these remarks is that the abstract variable state/validity paradigm has an advantage over object invariants \nin its ability to accurately specify methods that destroy validity. Close methods are a source of false \nalarms in ESC/Java, and while they could in principle be avoided soundly by introducing a ghost .eld \nvalid and updating it in close and init methods, it is more common simply to suppress these warnings, \nwhich provides no check\u00ading against the error that the invalid object is later passed to a method that \nrequires validity. In spite of the remarks in the previous paragraphs, our judgment in retrospect is \nthat the decision to remove ab\u00adstract variables and introduce object invariants and ghost variables was \non the whole a successful step towards the goal of producing a cost-e.ective engineering tool. 4.3 Routine \nspeci.cations Routine speci.cations can contain any or all of the fol\u00adlowing parts: requires P, modi.es \nM , ensures Q,and exsures (Tx) R, where the precondition P,normalpost\u00adcondition Q, and exceptional postcondition \nR for exception type T are boolean speci.cation expressions, and the mod\u00adi.es list M is a list of lvalues \n(like o.f ).In Q,the keyword \\result refers to the value returned, if any. In R,the vari\u00adable x refers \nto the exception thrown. In both Q and R, an expression of the form \\old(E)refers to the value of the \nexpression E in the pre-state. The modi.es list speci.es which .elds the routine may modify. Implicit \nin this list is that every routine is allowed to modify the .elds of any objects allocated since the \nstart of the routine invocation. At a call site, ESC/Java assumes that only those variables indicated \nby the modi.es list are changed by the call. However, ESC/Java does not check that an implementation \nobeys its modi.es list. This unsoundness is motivated as follows: writing down all the variables that \na routine may modify is impossible, since many of these variables may be out of scope and some of them \nmay even reside in subclasses yet to be written. This fundamental and underappreciated problem can be \nsolved with data abstraction [32] as we did in ESC/Mod\u00adula-3. One of the costs of omitting data abstraction \nin ESC/Java is that we are unable, in general, to check modi\u00ad.es lists. There are a variety of approaches \nthat a checking tool can take with respect to modi.es lists: ESC/Modula-3 took a theoretically sound \napproach at the cost of complex\u00adity in the annotation language. ESC/Java takes the other extreme: modi.es \nlists are assumed to be given correctly by the programmer the tool uses but does not check them. Recent \nwork suggests that theoretically sound solutions may still be feasible in a practical checker, by imposing \nsome re\u00adstrictions on the programming model [39, 34]. Overriding methods inherit speci.cations from the \nmeth\u00adods they override. Users may also strengthen the postcondi\u00adtionsof overrides(using also ensures \nand also exsures), which is sound. Strengthening the precondition or extend\u00ading the modi.es list would \nnot be sound [28]. Nevertheless, because ESC/Java does not provide any data abstraction, it seemed more \nprudent to allow the unsound also modi.es than not: this lets users express design decisions about what \nvariables a method override may modify, even though the corresponding checking would not be sound. We \nwere much less compelled to add also requires, because we deemed its use a probable programmer error \n(some programmers design their programs as if it would be sound to strengthen pre\u00adconditions in subclasses). \nHowever, again due to the lack of abstraction features, we do allow also requires in one special case, \nas described in the user s manual [33]. In addition to single-inheritance subclassing, Java features \nmultiple inheritance from interfaces. A sound way to com\u00adbine multiple inherited speci.cations for a \nmethod is to take their mathematical join in the lattice of conjunctive predi\u00adcate transformers [47, \n31], as is done in JML [25]. However, this approach leads to problems like how to explain pre-and postcondition \nviolations in warning messages. ESC/Java uses the simpler, but unsound, approach of taking the union \nof all speci.cation parts inherited from overridden methods.    4.4 Object invariants Designing a \ngood, mechanically-checkable object invariant system is a complicated task. For space reasons, we discuss \nonly brie.y some of the more important issues involved. Operation boundaries. Conceptually, the object \nin\u00advariants for an object o may be broken only during an op\u00aderation on o. The question arises of what \nto consider an operation. The simplest approach, which we have largely adopted, is to consider each routine \nby itself to be a separate operation. In particular, we do not consider the subroutines called by a routine \nto be part of the same operation; this means that the routine must restore any invariants it has broken \nbefore it may call any subroutines. One exception is that users may mark methods with the modi.er helper; \nsuch methods are considered part of the operation of the routine calling them. This is achieved by inlining \ncalls to helpers, which goes beyond modular check\u00ading. This annotation is useful in some cases, but is \nexpensive if used excessively. Invariant enforcement. In practice, enforcing invari\u00adants on all operation \nboundaries is too strict: a method could not call even so harmless a function as square root while an \ninvariant is broken. Although the called code will expect all invariants to hold, it is usually safe \nto allow sub\u00adroutine calls so long as the code being called cannot even indirectly reach the object(s)whose \ninvariants are broken. Because this property is not locally checkable without an un\u00adwieldy amount of \nannotation, ESC/Java checks invariants at call sites only for arguments and static .elds. This heuristic \ndisallows calls likely to be an error (e.g., passing an invalid object as an argument)and allows the \ncalls like square root that are almost always okay. Invariant placement. Because the entire program may \nnot be available, it is not possible to get the e.ect of check\u00ading all invariants without adopting restrictions \nabout where invariants are declared [32, 36]. Roughly, an invariant men\u00adtioning a .eld f must be visible \nwhenever f is. This usually means that the invariant must be declared in the class that declares f . \nWe have some understanding of the restrictions needed, but ESC/Java does not enforce them. Constructors. \nWe do not require this to satisfy its in\u00advariants in the case where a constructor terminates excep\u00adtionally; \nthis is unsound in the rare case where a copy of this survives the constructor termination. 4.5 Ghost \n.elds ESC/Java s lack of data abstraction simpli.es the anno\u00adtation language and checker, but reduces \nthe expressiveness of the annotation language. Nevertheless, it is sometimes useful to describe the behavior \nof a class in terms of some additional state that the Java program leaves implicit. For this purpose, \nESC/Java provides ghost .elds, which are like ordinary .elds in Java, except that the compiler does not \nsee them. Ghost .elds can also be used to specify behavior depen\u00addent on the abstract state of an object, \nfor which abstract variables would be less suitable. For example, the usage pro\u00adtocol for the hasMoreElements \nand getNextElement meth\u00adods of the Enumeration class can be expressed in terms of a boolean ghost .eld \ndenoting the condition that more ele\u00adments are available. A common use of ghost .elds in ESC/Java is \nto make up for the absence of generic types (parametric polymorphism) in Java. For example, a class Vector \ncan introduce a ghost .eld elementType: //@ ghost public \\TYPE elementType The special type \\TYPE in \nESC/Java denotes the type of Java types. Using ghost .eld elementType,the methods of class Vector can \nbe speci.ed. For example, the methods for adding and retrieving an element from a vector can be speci.ed \nas follows: //@ requires \\typeof (obj ) <: elementType public void addElement(Object obj ); //@ ensures \n\\typeof (\\result) <: elementType public Object elementAt(int index); A client of Vector would set the \nelementType ghost .eld using ESC/Java s set annotation before using a vector. For example, Vector v = \nnew Vector(); //@ set v.elementType = \\type(String); creates a vector v intendedtoholdstrings. 4.6 Escape \nhatches We have designed ESC/Java s annotation language and checking so that common programmer design \ndecisions can easily be expressed. However, situations arise where con\u00advincing the checker about the \ncorrectness of the design re\u00adquires more powerful annotation features and checking than are provided. \nFor these situations, one needs escape hatches to get around the strictness of the static checking system. \nESC/Java s nowarn annotation suppresses selected warn\u00adings about the source line where it appears. ESC/Java \ns -nowarn command-line switch turns o. selected warnings for the entire program, allowing users to customize \nthe degree of checking. One use of this is to turn o. all warnings except those for violations of pre-conditions, \npost-conditions, and object invariants in order to check if a program is consistent with a user-speci.ed \nprotocol; see [29] for an example. A more precise escape hatch is the statement annotation //@ assume \nP which causes ESC/Java to blindly assume that condition P holds at this program point without checking \nit. Uses of assume and nowarn make good focused targets for manual code reviews. Sometimes simple properties \nof a routine (e.g.,not deref\u00aderencing null)depend on more complex properties of the rou\u00adtines it calls. \nIn such cases, judicious use of escape hatches can save users from speci.cation creep that otherwise \ntends inexorably toward the upper right corner of Figure 1.  5. PERFORMANCE ESC/Java checks each routine \nby invoking the automatic theorem prover Simplify. Since theorem proving is often expensive, and undecidable \nin the worst case, a potential problem with ESC/Java is that it could be too slow for in\u00adteractive use. \nWe therefore put considerable e.ort (some of which was spent already in the ESC/Modula-3 project)into \nimprov\u00ading the performance of the theorem prover, into encoding background predicates in a form that \nplays to the strengths   Routine #of Percentage checked within time limit size routines 0.1s 1s 10s \n1min 5mins Annotation type    non null 8 6 invariant 14 10 requires 28 16 ensures 26 2 modifies 0 \n11 0 4 1 total 94 48 1720 27 90 100 100 100 525 1 74 99 100 100 20 50 162 0 33 94 99 100 50 100 35 \n0 0 74 94 100 100 200 17 0 0 53 82 94 200 500 5 0 0 0 80 100 500 1000 1 0 0 0 0 100 total 2331 20 \n80 98 > 99 > 99      Figure 4: Percentage of routines of various sizes in the Java front end benchmark \nthat can be checked within a given per-routine time limit. of the theorem prover, and into generating \nVCs in a form that is more amenable to e.cient proving. The combined result of these various optimizations \nis that the performance of ESC/Java is su.cient for the majority of cases. We have applied ESC/Java to \na variety of programs, and we report on the performance of ESC/Java on the largest of these programs, \nJavafe, ESC/Java s Java front end. This program contain 41 thousand lines of code (KLOC)and 2331 routines. \nFigure 4 illustrates the performance of ESC/Java on this program using a 667 MHz Alpha processor. The \nroutines in Javafe are categorized according to their size (in lines of code). For each category, the \n.gure shows the num\u00adber of routines in that category, together with the percent\u00adage of those routines \nthat can be checked within a particular per-routine time limit. The results show that most of the routines \nare fairly small (under 50 lines), and that ESC/Java can check the great majority of these routines in \nless than 10 seconds. Thus, the performance of ESC/Java is satis\u00adfactory, except for a small number of \nparticularly complex routines. There is only one routine (of the 2331 routines in this program)that ESC/Java \nis unable to verify within the default .ve-minute time limit.  6. EXPERIENCE This section describes \nsome of our experience applying ESC/Java to a variety of programs. These programs in\u00adclude the Java front \nend Javafe, portions of the web crawler Mercator [21], and an assortment of smaller programs. 6.1 Annotation \noverhead ESC/Java is an annotation-based checker, which relies on the programmer to provide annotations \ngiving lightweight speci.cations for each routine. Thus, one of the costs of us\u00ading ESC/Java is the overhead \nof writing the necessary anno\u00adtations. In most cases, these annotations are straightforward and they \ndocument basic design decisions, for example, that a method argument should never be null, or that an \ninteger variable should be a valid index to a particular array. Our experience in annotating Javafe and \nMercator indi\u00adcates that roughly 40 100 annotations are required per thou\u00adsand lines of code. Figure \n5 illustrates the number and kinds of annotations required for these programs. For both of these programs, \nthe annotations were inserted after the program was written using an iterative process: The program was \n.rst annotated based on an inspection of the program code and a rough understanding of its behavior; \nFigure 5: Number and kinds of annotations required in the benchmarks. this initial set of annotations \nwas subsequently re.ned based on feedback produced by ESC/Java when checking the an\u00adnotated program. \nTypically, we found that a programmer could annotate 300 to 600 lines of code per hour of an ex\u00adisting, \nunannotated program. This overhead is expensive for larger programs and is an obstacle to using ESC/Java \nto catch defects in large, unannotated programs. While it is possible to use ESC/Java only on selected \nmodules, it is still necessary to annotate all the routines called in other modules. We are investigating \nannotation inference tech\u00adniques [17, 16] that help reduce the annotation burden on legacy code. Instead \nof writing annotations after the program has been developed, a better strategy for using ESC/Java is \nto write appropriate annotations and run the checker as early as pos\u00adsible in the development cycle, \nperhaps after writing each method or class. Used in this manner, ESC/Java has the potential to catch \nerrors much earlier than testing, which can only catch errors after the entire program or an appro\u00adpriate \ntest harness has been written. Since catching errors earlier makes them cheaper to .x, we suggest that \nusing ESC/Java in this manner may reduce software development costs in addition to increasing program \nreliability. The following subsections illustrate ESC/Java s ability to .nd software defects that have \nproven di.cult to catch using testing. 6.2 Mercator The authors of the web crawler Mercator, Allan Heydon \nand Marc Najork, used ESC/Java to check portions of Mer\u00adcator. Since Heydon and Najork were not involved \nwith the ESC/Java project, their experience may be typical of average ESC/Java users. Heydon and Najork \nannotated and checked 4 packages from Mercator containing 7 KLOC in roughly 6 hours. To\u00adward the end, \nESC/Java caught a previously-undetected bug in a hash table implementation. This hash table is im\u00adplemented \nasanarrayindexed by hashcode with eachentry in this array pointing to a secondary array of values with \nthat hash code. It is possible for an entry in the main array to be null. However, the checkpointing \ncode, which writes the hash table to disk, failed to check for a null pointer in the main array. This \ndefect did not show up during testing since the hash table is checkpointed only after it is heavily loaded, \nand thus all entries in the main array are likely to be non-null. This defect may also be missed during \na code review, especially if the design decision that entries in the main array may be null is not documented. \nBecause ESC/Java requires explicating design decisions such as these, it can detect defects where these \ndecisions are not respected. 6.3 Javafe One of us (Lillibridge)spent about 3 weeks annotating ESC/Java \ns front end, which at that time measured about 30,000 lines. This process found about half a dozen previ\u00adously \nundetected errors. Lillibridge assessed these errors as not having been worth 3 weeks to discover, but \nthe bene.t of the annotations had just started. Since that time, we have run ESC/Java on Javafe before \nchecking in any changes, re\u00advealing an additional half dozen errors, each of which was detected shortly \nafter it was introduced. Next, we ll describe one particularly interesting experience. One of us (Leino)performed \na major piece of surgery on the complicated class in Javafe that correlates source code locations with \npositions in an input stream. After .nishing the edits, Leino ran the compiler, launched ESC/Java on \nthe Javafe sources, and logged o. for the day. The next morning, the Javafe regression suite had passed, \nbut running ESC/Java with the new front end on even simple programs caused it to crash. After spending \n2+ hours pinpointing the error, Leino won\u00addered why ESC/Java had not detected it. He had forgotten to \ncheck ESC/Java s output before starting to debug. In\u00addeed, ESC/Java had found the error a failure to \nestablish a precondition that a stream be marked and ESC/Java s output also revealed the same error at \na di.erent call site. In this case, ESC/Java s output could have saved 2+ hours in tracking down the \nproblem. The entire run of ESC/Java on Javafe had taken 73 minutes, but would have used less than 3 minutes \nhad it been applied only to the .le containing the errors. Correcting the errors was also tricky, and \nLeino was able to insert annotations and run ESC/Java to check his understanding of the various state \nchanges in the program. We draw two conclusions from our experience with Javafe. First, keeping machine-checkable \ndesign decisions in a pro\u00adgram provides a payo. during code maintenance, which is valuable because the \ncost of maintenance can easily outweigh the cost of the initial code development. Second, several of \nthe errors that ESC/Java detected in Javafe were violations of design decisions that are not easily extracted \nfrom the code. These include protocol designs like call this routine only on streams that have been marked \n. ESC/Java provides a .exible and powerful framework for checking such protocol errors. In fact, some \nmay consider using ESC/Java in a mode where it checks only for viola\u00adtions of user-supplied annotations, \nnot for crashes that the language will catch at runtime [29]. 6.4 Other user experience ESC/Java is \navailable for download at research.compaq. com/SRC/esc. In the last year, we have received more than \n100 emails from users, and the stream of questions seems to increase rather than subside. We have heard \nsome success stories where ESC/Java has found errors in code, several times surprising the authors of \nthe code. Some other users, pulled by the magnetic fascination in the upper right corner of Figure 1, \nhave attempted to use ESC/Java to perform full functional correctness veri.cation. In a way we are .attered, \nbut we are not surprised that most of them have run into di.culties caused by incompletenesses in Simplify, \nwhich was engineered to be automatic rather than complete. We believe that learning when to give up and \nput in an assume annotation will lead to more cost\u00ade.ective use of ESC.  7. RELATED WORK The closest \nwork related to ESC/Java is our previous work on extended static checking, ESC/Modula-3 [8]. Whereas \nthe research on ESC/Modula-3 can be summarized as an\u00adswering (a.rmatively)the question, can an extended \nstatic checker .nd bugs and be made automatic? , ESC/Java has focused on the questions how simple can \nthe annotation language be? and is the checker cost-e.ective? . Besides targeting a di.erent and more \npopular language, ESC/Java incorporates many innovations over ESC/Modula-3, includ\u00ading: greater similarity \nbetween source and annotation lan\u00adguages, use of object invariants instead of data abstraction, execution \ntraces [38], multiple warnings per method, time\u00adouts, generation of suggestions for how to respond to \nwarn\u00adings (not described in this paper), di.erent treatments of loops, a multi-stage translation to guarded \ncommands [35], a di.erent VC generation from guarded commands [19], di.er\u00adently chosen engineering trade-o.s, \na comprehensive user s manual [33], a variety of new annotations including helper, and a variety of internal \nimprovements. Overall, we believe we have produced a tool that is simpler to use, at the price of missing \nmore errors than ESC/Modula-3 did. For a per\u00adspective on the building of ESC/Modula-3 and ESC/Java, see \n[30]. A goal that is several decades old is providing in a pro\u00adgramming language features to write down \nmore informa\u00adtion than is strictly needed for compilation. The earliest serious attempt we know of is \nEuclid [24], which included constructs to express, for example, pre-and postconditions of procedures. \nThe motivation was to enable programs to be veri.ed, but the formal language semantics did not reach \nmachine-checkable maturity. Instead, pre-and postcondi\u00adtions, and other assertions, were checked at runtime. \nA newer and more widely used language in this spirit is the object-oriented language Ei.el [37], whose \npre-and post\u00adconditions and object invariants are also checked at runtime. A language in progress is \nVault [7], whose promising ideas include using type-like features to take a next step in pre\u00adventing \ncertain kinds of resource-management programming errors. Another research area related to extended static \ncheck\u00ading is re.nement types. A re.nement type is essentially a restricted form of object invariant. \nRe.nement types have been investigated mostly for functional programming lan\u00adguages (e.g., Xi and Pfenning \n[50]), but some work has been done recently for imperative languages [49]. There are other compile-time \ntechniques for .nding er\u00adrors in programs. Unlike the ESC approach which uses programmer-supplied annotations \nfor documenting design decisions, most other techniques have gone in the direc\u00adtion of completely eliminating \nannotation overhead, often to the extent that annotations cannot be supplied. Another di.erence between \nESC and these other techniques is that the others do not build in modular checking from the start; rather, \nthey are typically applied to the entire program. We mention three such techniques: Symbolic execution \nis the underlying technique of the suc\u00adcessful bug-.nding tool PRE.x for C and C++ programs [3]. For \neach procedure, PRE.x synthesizes a set of execution paths, called a model. Models are used to reason \nabout calls, which makes the process somewhat modular, except that .x\u00adpoints of models are approximated \niteratively for recursive and mutually recursive calls. PRE.x gets by with an ad hoc constraint solver, \nrather than a theorem prover and an underlying logic. There is no annotation language, but due to a scheme \nfor associat\u00ading a weight with each warning (and surely also due to the large number of possible errors \nin C and C++), users can sort warnings by weight, thereby easily ignoring less relevant warnings. Abstract \ninterpretation [6] is a more established technique; it uses heuristics to iteratively build up an abstract \nmodel of a program. The absence of errors in the abstract program implies the absence of errors in the \ngiven program. Abstract interpretation has been applied successfully in many appli\u00adcations, including \nspace-rocket controllers [44]. Symbolic model checking [2] is a technique whose success in .nding hardware \ndesign errors has rubbed o. on the soft\u00adware checking community. A popular idea is to use predi\u00adcate \nabstraction [20] to reason about a given (in.nite-state) program as a .nite-state system that is model \nchecked. An intriguing system based on this idea, including an automatic engine for incrementally inferring \nthe predicates used in the abstraction, is SLAM [1]. Other tools that verify properties of software systems \nusing .nite-state models are Bandera [5] and Java PathFinder 2 [46]. In addition to these three techniques, \nthere are other tools that have been useful in program development. For exam\u00adple, the LCLint tool [15] \nhas become a part of the environ\u00adment for building Linux. Some tools have focused on check\u00ading for particular \nkinds of errors, like concurrency errors: Warlock [43] to mention one, but see our ESC/Modula-3 re\u00adport \n[8] which reports on our experience with extended static checking for .nding concurrency errors and mentions \nseveral other pieces of related work in this .eld. Recent work by En\u00adgler et al. shows that a surprisingly \ne.ective technique for .nding errors is a heuristic scan for irregularities in program source code [12]. \nGoing beyond the bug-.nding tools are tools geared to\u00adward the full veri.cation of programs. While most \nsuch systems have remained in academic labs where they have been applied to small textbook programs or \nthe veri.cation of speci.c algorithms, some systems have been applied to actual safety-critical programs. \nA successful example is the B system [48], which was used to construct a part of the Metro subway system \nin Paris. Another example of a full\u00adveri.cation tool is Perfect Developer for the object-oriented language \nEscher [14]. Both the B and Escher systems re\u00adstrict the programming language to various extents and \nre\u00adquire some manual guidance of their underlying theorem provers. A big brother of the ESC/Java annotation \nlanguage, the Java Modeling Language (JML)[25] allows for fuller spec\u00adi.cations of Java programs. As \nmentioned in Section 4.1, through a collaboration with the designers of JML, we have tried to smooth \nout any gratuitous di.erences between the two speci.cation languages, more or less making ESC/Java a \nsubset of JML. The LOOP tool [45] translates JML-annotated Java into veri.cation conditions that can \nbe used as input to the theorem prover PVS [41]. The relation between JML, LOOP, and ESC/Java is described \nin some more detail in a short paper [26]. The similarities of the tools was an asset in specifying and \nchecking the JavaCard interface [42] and an electronic purse application [4]. The similarities have also \nallowed JML and ESC/Java to be used in concert in teaching a software engineering course at Kansas State \nUni\u00adversity [11]. Finally, we mention some intriguing work built on top of ESC/Java. Michael Ernst et \nal. have investigated the dynamic inference of likely program invariants [13]. Re\u00adcently, this inference \nhas been used to produce ESC/Java annotations [40]. Another annotation inference system for ESC/Java \nis Houdini [17, 16], which uses ESC/Java as a subroutine in inferring annotations. 8. CONCLUSIONS Over \nthe past two years, ESC/Java has been used to check a variety of programs, including moderately large \nsys\u00adtems such as Javafe and Mercator. The experience of both ESC/Java developers and other users supports \nthe thesis that ESC/Java can detect real and signi.cant software de\u00adfects. In addition, the performance \nof ESC/Java is su.cient for interactive use on all but the most complex of methods. ESC/Java s design \nincorporates a trade-o. between sound\u00adness and usefulness, and in some cases sacri.ces soundness to reduce \nthe annotation cost or to improve performance. Ex\u00adamples of unsound features include loop unrolling and \nthe partial enforcement of object invariants. By and large, our experience supports this limited introduction \nof unsound\u00adness as a technique that clearly reduces the cost of using the checker, and we believe the \nnumber of bugs missed due to these features is small. Our ongoing research continues to tackle some of \nthe more signi.cant sources of unsound\u00adness, including loops (by loop invariant inference [18])and modi.es \nlists [34]. ESC/Java s annotation language is Java-like and uses ob\u00adject invariants (as opposed to ESC/Modula-3 \ns use of data abstraction). Both of these design decisions helped keep the annotation language intuitive. \nObject invariants are some\u00adwhat less expressive than data abstraction, but this limita\u00adtion did not appear \nto cause problems in practice. Despite ESC/Java s success at .nding real errors, feed\u00adback from our users \nsuggests that the tool has not reached the desired level of cost e.ectiveness. In particular, users complain \nabout an annotation burden that is perceived to be heavy, and about excessive warnings about non-bugs, \npar\u00adticularly on unannotated or partially-annotated programs. However, these users retroactively annotated \nand checked existing programs, rather than using ESC/Java to support development throughout a project \ns life-cycle. At this point, it is uncertain if, over the lifetime of a soft\u00adware project, ESC/Java is \na cost-e.ective tool for use by mainstream programmers. Certainly, our experience over the past two years \nin using ESC/Java to support develop\u00adment of Javafe has been encouraging, and it is possible that ESC/Java \nwould be useful to highly-disciplined program\u00adming teams. We are hopeful that additional research on \nreducing spuri\u00adous warnings and lowering the perceived annotation burden (for example, by annotation \ninference, both statically as in Houdini [17] and dynamically as in Daikon [13])may yield an extended \nstatic checking tool that could add signi.cant value to the process of engineering software. In the mean\u00adtime, \nwe believe ESC/Java is suitable for use in a classroom setting as a resource for reinforcing lessons \non modularity, good design, and veri.cation. 9. ACKNOWLEDGMENTS Todd Millstein, as a research intern \nat Compaq SRC, im\u00adplemented the reporting of execution traces in ESC/Java s output. Caroline Tice and \nRajeev Joshi lent helping hands in programming and porting. Additionally, we re grateful to Allan Heydon, \nMarc Najork, and other ESC/Java users who have shared their experiences of using the tool and given us \nfeedback. 10. REFERENCES [1] T. Ball and S. K. Rajamani. Automatically validating temporal safety properties \nof interfaces. In M. B. Dwyer, editor, Proc. 8th SPIN Workshop,volume 2057 of LNCS, pages 103 122. Springer, \nMay 2001. [2] J. R. Burch et al. Symbolic model checking: 1020 states and beyond. Information and Computation, \n98(2):142 170, 1992. [3] W. R. Bush, J. D. Pincus, and D. J. Siela.. A static analyzer for .nding dynamic \nprogramming errors. SP&#38;E, 30(7):775 802, June 2000. [4] N. Cata no and M. Huisman. Formal speci.cation \nof Gemplus electronic purse case study. In Proc. of Formal Methods Europe (FME 2002). Springer-Verlag, \n2002. To Appear. [5] J. Corbett et al. Bandera: Extracting .nite-state models from Java source code. \nIn Proc. 22nd ICSE, June 2000. [6] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed lattice \nmodel for static analysis of programs by construction or approximation of .xpoints. In Proc. 4th POPL, \npages 238 252. ACM, 1977. [7] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low-level \nsoftware. In Proc. PLDI 2001, pages 59 69, 2001. [8] D.L.Detlefs, K. R.M.Leino,G. Nelson, andJ. B. Saxe. \nExtended static checking. Research Report 159, Compaq SRC, Dec. 1998. [9] D.L.Detlefs, G.Nelson, andJ. \nB.Saxe. Atheorem prover for program checking. Research Report 178, Compaq SRC, 2002. In preparation. \n [10] E. W. Dijkstra. A Discipline of Programming. Prentice Hall, Englewood Cli.s, NJ, 1976. [11] M. \nDwyer, J. Hatcli., and R. Howell. CIS 771: Software speci.cation. Kansas State Univ., Dept. of Comp. \nand Inf. Sciences, Spring 2001. [12] D. Engler et al. Bugs as deviant behavior: A general approach to \ninferring errors in systems code. In Proc. 18th SOSP, pages 57 72. ACM, 2001. [13] M. D. Ernst et al. \nDynamically discovering likely program invariants to support program evolution. In Proc. ICSE 1999, pages \n213 224. ACM, 1999. [14] Escher Technologies, Inc. Getting started with Perfect. Available from www.eschertech.com, \n2001. [15] D. Evans, J. V. Guttag, J. J. Horning, and Y. M. Tan. LCLint: A tool for using speci.cations \nto check code. In D. S. Wile, editor, Proc. 2nd SIGSOFT FSE, pages 87 96. ACM, 1994. [16] C. Flanagan, \nR. Joshi, and K. R. M. Leino. Annotation inference for modular checkers. Inf. Process. Lett., 77(2 4):97 \n108, Feb. 2001. [17] C. Flanagan and K. R. M. Leino. Houdini, an annotation assistant for ESC/Java. In \nJ. N. Oliveira and P. Zave, editors, FME 2001: Formal Methods for Increasing Software Productivity, volume \n2021 of LNCS, pages 500 517. Springer, Mar. 2001. [18] C. Flanagan and S. Qadeer. Predicate abstraction \nfor software veri.cation. In Proc. 29th POPL, page to appear. ACM, Jan. 2002. [19] C. Flanagan and J. \nB. Saxe. Avoiding exponential explosion: Generating compact veri.cation conditions. In Proc. 28th POPL, \npages 193 205. ACM, 2001. [20] S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs via PVS. \nIn O. Grumberg, editor, Proc. 9th CAV, volume 1254 of LNCS, pages 72 83. Springer, 1997. [21] A. Heydon \nand M. A. Najork. Mercator: A scalable, extensible web crawler. World Wide Web, 2(4):219 229, Dec. 1999. \n[22] C. A. R. Hoare. Proof of correctness of data representations. Acta Inf., 1(4):271 81, 1972. [23] \nS. C. Johnson. Lint, a C program checker. Comp. Sci. Tech. Rep. 65, Bell Laboratories, 1978. [24] B. \nW. Lampson, J. J. Horning, R. L. London, J. G. Mitchell, and G. J. Popek. Report on the programming language \nEuclid. Technical Report CSL-81-12, Xerox PARC, Oct. 1981. [25] G. T. Leavens, A. L. Baker, and C. Ruby. \nPreliminary design of JML: A behavioral interface speci.cation language for Java. Technical Report 98-06f, \nDept. of Comp. Sci., Iowa State Univ., July 1999. [26] G. T. Leavens, K. R. M. Leino, E. Poll, C. Ruby, \nand B. Jacobs. JML: notations and tools supporting detailed design in Java. In OOPSLA 2000 Companion, \npages 105 106. ACM, 2000. [27] K. R. M. Leino. Ecstatic: An object-oriented programming language with \nan axiomatic semantics. In FOOL 4, 1997. [28] K. R. M. Leino. Data groups: Specifying the modi.cation \nof extended state. In Proc. OOPSLA 98, pages 144 153. ACM, 1998. [29] K. R. M. Leino. Applications of \nextended static checking. In P. Cousot, editor, 8th Intl. Static Analysis Symp., volume 2126 of LNCS, \npages 185 193. Springer, July 2001. [30] K. R. M. Leino. Extended static checking: A ten-year perspective. \nIn R. Wilhelm, editor, Informatics 10 Years Back, 10 Years Ahead, volume 2000 of LNCS, pages 157 175. \nSpringer, Jan. 2001. [31] K. R. M. Leino and R. Manohar. Joining speci.cation statements. Theoretical \nComp. Sci., 216(1 2):375 394, Mar. 1999. [32] K. R. M. Leino and G. Nelson. Data abstraction and information \nhiding. Research Report 160, Compaq SRC, Nov. 2000. [33] K. R. M. Leino, G. Nelson, and J. B. Saxe. ESC/Java \nuser s manual. Tech. Note 2000-002, Compaq SRC, Oct. 2000. [34] K. R. M. Leino, A. Poetzsch-He.ter, and \nY. Zhou. Using data groups to specify and check side e.ects. In Proc. PLDI 2002, 2002. [35] K. R. M. \nLeino, J. B. Saxe, and R. Stata. Checking Java programs via guarded commands. In B. Jacobs et al.,editor, \nFormal Techniques for Java Programs, Tech. Report 251. Fernuniversit\u00a8at Hagen, May 1999. [36] K. R. M. \nLeino and R. Stata. Checking object invariants. Tech. Note 1997-007, DEC SRC, Jan. 1997. [37] B. Meyer. \nObject-oriented software construction.Series in Computer Science. Prentice-Hall Intl., 1988. [38] T. \nMillstein. Toward more informative ESC/Java warning messages. In J. Mason, editor, Selected 1999 SRC \nsummer intern reports, Tech. Note 1999-003. Compaq SRC, 1999. [39] P. M\u00a8uller, A. Poetzsch-He.ter, and \nG. T. Leavens. Modular speci.cation of frame properties in JML. Technical Report 02-02, Dept. of Comp. \nSci., Iowa State Univ., Feb. 2002. To appear in Concurrency, Practice and Experience. [40] J. W. Nimmer \nand M. D. Ernst. Automatic generation and checking of program speci.cations. Technical Report 823, MIT \nLab for Computer Science, Aug. 2001. [41] S. Owre, S. Rajan, J. M. Rushby, N. Shankar, and M. K. Srivas. \nPVS: Combining speci.cation, proof checking, and model checking. In R. Alur and T. A. Henzinger, editors, \nProc. 8th CAV, volume 1102 of LNCS, pages 411 414. Springer, 1996. [42] E. Poll, J. van den Berg, and \nB. Jacobs. Speci.cation of the JavaCard API in JML. In J. Domingo-Ferrer, D. Chan, and A. Watson, editors, \nFourth Smart Card Research and Advanced Application Conference (CARDIS 2000), pages 135 154. Kluwer Acad. \nPubl., 2000. [43] N. Sterling. WARLOCK a static data race analysis tool. In Proc. Winter 1993 USENIX \nConf., pages 97 106. USENIX Assoc., Jan. 1993. [44] M. Turin, A. Deutsch, and G. Gonthier. La v\u00b4eri.cation \ndes programmes d ariane. Pour la Science, 243:21 22, Jan. 1998. (In French). [45] J. van den Berg and \nB. Jacobs. The LOOP compiler for Java and JML. In Proc. TACAS, volume 2031 of LNCS, pages 299 312. Springer, \n2001. [46] W. Visser, K. Havelund, G. Brat, and S. Park. Model checking programs. In International Conference \non Automated Software Engineering, Sept. 2000. [47] J. M. Wing. A Two-Tiered Approach to Specifying Programs. \nPhD thesis, MIT Laboratory for Computer Science, May 1983. (Available as MIT LCS tech. report no. 229). \n[48] J. B. Wordsworth. Software Engineering with B. Addison-Wesley, 1996. [49] H. Xi. Imperative programming \nwith dependent types. In Proc. 15th LICS, pages 375 387, June 2000. [50] H. Xi and F. Pfenning. Dependent \ntypes in practical programming. In Proc. 26th POPL, pages 214 227. ACM, Jan. 1999.   \n\t\t\t", "proc_id": "512529", "abstract": "Software development and maintenance are costly endeavors. The cost can be reduced if more software defects are detected earlier in the development cycle. This paper introduces the Extended Static Checker for Java (ESC/Java), an experimental compile-time program checker that finds common programming errors. The checker is powered by verification-condition generation and automatic theorem-proving techniques. It provides programmers with a simple annotation language with which programmer design decisions can be expressed formally. ESC/Java examines the annotated software and warns of inconsistencies between the design decisions recorded in the annotations and the actual code, and also warns of potential runtime errors in the code. This paper gives an overview of the checker architecture and annotation language and describes our experience applying the checker to tens of thousands of lines of Java programs.", "authors": [{"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP14187273", "email_address": "", "orcid_id": ""}, {"name": "K. Rustan M. Leino", "author_profile_id": "81100225265", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP42050498", "email_address": "", "orcid_id": ""}, {"name": "Mark Lillibridge", "author_profile_id": "81100001867", "affiliation": "Compaq Systems Research, Palo Alto, CA", "person_id": "P190619", "email_address": "", "orcid_id": ""}, {"name": "Greg Nelson", "author_profile_id": "81100407919", "affiliation": "Compaq Systems Research, Palo Alto, CA", "person_id": "PP31040964", "email_address": "", "orcid_id": ""}, {"name": "James B. Saxe", "author_profile_id": "81100392578", "affiliation": "Compaq Systems Research, Palo Alto, CA", "person_id": "P133439", "email_address": "", "orcid_id": ""}, {"name": "Raymie Stata", "author_profile_id": "81332529385", "affiliation": "Compaq Systems Research, Palo Alto, CA", "person_id": "PP43124852", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512558", "year": "2002", "article_id": "512558", "conference": "PLDI", "title": "Extended static checking for Java", "url": "http://dl.acm.org/citation.cfm?id=512558"}