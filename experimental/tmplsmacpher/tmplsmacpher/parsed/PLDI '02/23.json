{"article_publication_date": "05-17-2002", "fulltext": "\n Maya: Multiple-Dispatch Syntax Extension in Java Jason Baker and Wilson C. Hsieh University of Utah \n ABSTRACT We have designed and implemented Maya, a version of Java that al\u00adlows programmers to extend \nand reinterpret its syntax. Maya gen\u00aderalizes macro systems by treating grammar productions as generic \nfunctions, and semantic actions on productions as multimethods on the corresponding generic functions. \nProgrammers can write new generic functions (i.e., grammar productions) and new multi\u00admethods (i.e., \nsemantic actions), through which they can extend the grammar of the language and change the semantics \nof its syntactic constructs, respectively. Maya s multimethods are compile-time metaprograms that transform \nabstract syntax: they execute at pro\u00adgram compile-time, because they are semantic actions executed by \nthe parser. Maya s multimethods can be dispatched on the syntac\u00adtic structure of the input, as well as \nthe static, source-level types of expressions in the input. In this paper we describe what Maya can do \nand how it works. We describe how its novel parsing techniques work and how Maya can statically detect \ncertain kinds of errors, such as code that gen\u00aderates references to free variables. Finally, to demonstrate \nMaya s expressiveness, we describe how Maya can be used to implement the MultiJava language, which was \ndescribed by Clifton et al. at OOPSLA 2000.  Categories and Subject Descriptors D.3.3 [Programming Languages]: \nLanguage Constructs and Fea\u00adtures General Terms Languages  Keywords Java, metaprogramming, macros, \ngenerative programming 1. INTRODUCTION Syntax extension can be used to embed a domain-speci.c language \nwithin an existing language. For example, embedded SQL extends Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 02, June 17-19, 2002, Berlin, Germany. \nCopyright 2002 ACM 1-58113-463-0/02/0006 ...$5.00. Extension Library Extension Source Compiled Extensions \nApplication Source Compiled Application Figure 1: Compiling language extensions and extended pro\u00adgrams \nwith the Maya compiler, mayac its host language with database query syntax. Syntax extension can also \nbe used to add language features when they are found to be necessary. For example, design patterns [19] \ncan be viewed as work-arounds for specialized features missing from general-purpose languages: the visitor \npattern implements multiple dispatch in a single-dispatch language. Some language designers have chosen \nto specialize their languages to support certain patterns: the C# [25] language includes explicit support \nfor the state/observer pattern and delegation. However, unless we are willing to wait for a new lan\u00adguage \neach time a new design pattern is identi.ed, such an ap\u00adproach is unsatisfactory. Instead, a language \nshould admit program\u00admer-de.ned syntax extensions. Macro systems [13, 27, 30] support a limited form \nof syntax ex\u00adtension. In most systems, a macro call consists of the macro name followed by zero or more \narguments. Such systems do not allow macros to de.ne in.x operators. In addition, macros cannot change \nthe meaning of the base language s syntax. Even in Scheme, which has an extremely powerful macro system, \na macro cannot rede.ne the procedure application syntax. Other kinds of systems allow more sophisticated \nforms of syntax rewriting than simple macro systems. These systems range from aspect-oriented languages \n[31] to compile-time metaobject proto\u00adcols (MOPs) [10, 29]. Compile-time MOPs allow a metaclass to rewrite \nsyntax in the base language. However, these systems typi\u00adcally have limited facilities for de.ning new \nsyntax. This paper describes an extensible version of Java called Maya, which supports both the extension \nof its syntax and the extension of its base semantics. Figure 1 shows how Maya is used. Exten\u00adsions, \nwhich are called Mayans, are written as code that generates abstract syntax trees (ASTs). After Mayans \nhave been compiled, they can be loaded into the Maya compiler and used while compil\u00ading applications. \nMayans are dispatched from the parser at applica\u00adtion compile-time; they can reinterpret or extend Maya \nsyntax by expanding it to other Maya syntax. Maya has the following combination of features: Mayans \noperate on abstract syntax. Maya can ensure that Mayans produce valid ASTs, because AST nodes are well \ntyped. Since Mayans do not operate on .at token streams, they are not subject to precedence errors that \noccur in typi\u00adcal macro systems. For example, the Java Syntactic Extender (JSE) [2] allows macros to \nbe de.ned with a case statement that matches concrete syntax against patterns. Because JSE macros operate \non concrete syntax, they can generate many of the same parse and precedence errors that C macros gen\u00aderate. \n Maya treats grammar productions as generic functions, and semantic actions (Mayans) as multimethods \non those generic functions. Mayans can be dispatched on a rich set of pa\u00adrameter specializers: AST node \ntypes, the static types of ex\u00adpressions, the concrete values of tokens, and the syntactic structure of \nAST nodes. Multiple dispatch allows users to extend the semantics of the language by overriding Maya \ns base semantic actions.  Maya allows programmers to generate ASTs with templates, a facility like quasiquote \nin Lisp [28]. Maya templates can be used to build arbitrary pieces of abstract syntax. Most other systems \nprovide less general template mechanisms (<big\u00adwig>[6] is an exception). For example, JTS [5] is a frame\u00adwork \nfor building Java preprocessors that provides limited support for templates, in that it only de.nes template \nsyntax corresponding to a .xed subset of the JTS grammar s nonter\u00adminals.  Like Java classes, Mayans \nare lexically scoped. Local Ma\u00adyan declarations can capture the state of enclosing instances. In addition, \nMayan de.nitions are separate from imports. Imported Mayans are only applicable within the scope of their \nimport. These features allow great .exibility in the way that syntax transformers share state and are \nexposed to the base code. In comparison, compile-time metaobject proto\u00adcols such as OpenJava [29] typically \nprovide .xed relation\u00adships between transformers, state, and the lexical structure of base code.  To \nsupport these features, Maya makes use of three new imple\u00admentation techniques: 1. To support dispatch \non static types, Maya interleaves lazy type checking with lazy parsing. That is, types and abstract syntax \ntrees are computed on demand. Lazy type check\u00ading allows a Mayan to dispatch on the static types of some \narguments, and create variable bindings that are visible to other arguments. The latter arguments must \nhave their types checked lazily, after the bindings are created. Lazy parsing allows Mayans to be imported \nat any point in a program. Syntax that follows an imported Mayan must be parsed lazily, after the Mayan \nde.nes any new productions. The lazy eval\u00aduation of syntax trees is exposed explicitly to the Maya pro\u00adgrammer, \nso that the effects of laziness can be controlled. 2. Maya uses a novel parsing technique that we call \npattern parsing to statically check the bodies of templates for syn\u00adtactic correctness. The pattern parsing \ntechnique allows a programmer to use quasiquote to generate any valid AST.  3. Maya supports hygiene \nand referential transparency in tem\u00adplates through a compile-time renaming step.1 This renam\u00ading is possible \nbecause binding constructs must be explic\u00aditly declared as such in Maya s grammar. Maya s implemen\u00adtation \nof hygiene detects most references to free variables when templates are compiled, but it does not support \nDylan\u00adlike implicit parameters. The rest of this paper is organized as follows. Section 2 reviews some \nof the systems that we compare Maya against. Section 3 in\u00adtroduces the basics of the Maya language with \nan extended exam\u00adple. Section 4 describes the high-level design and implementation of the Maya compiler, \nincluding how Mayans are compiled and integrated into the Maya parser, how lazy parsing and type check\u00ading \nwork, how templates are parsed, and how hygiene and dispatch work. Section 5 sketches how Maya can be \nused to implement an interesting language extension: namely, open classes and mul\u00adtimethods as de.ned \nin MultiJava by Clifton et al. [12]. Section 6 describes related work, and Section 7 summarizes our conclusions. \n 2. BACKGROUND In this section we describe three systems that are closely related to Maya, and to which \nwe compare Maya in the rest of the paper: JSE, JTS, and OpenJava. JSE [2] is a port of Functional Objects \nprocedural Dylan macros to Java. JSE macros are de.ned using Dylan patterns, but a macro s expansion \nis computed by JSE code rather than by pattern substitu\u00adtion. JSE macros must follow one of two syntactic \nforms: method\u00adlike and statement-like macros. JSE recognizes macro keywords through a class naming convention. \nJSE provides a quasiquote mechanism to build macro return val\u00adues. However, because macros operate on \nunparsed trees of tokens and matching delimiters, JSE cannot statically check that quasi\u00adquotes produce \nsyntactically correct output. In addition, macro ex\u00adpansion does not honor precedence. JTS [5] is a framework \nfor writing Java preprocessors that op\u00aderate on ASTs. JTS and Maya approach the problem of extensible \nlanguages from opposite directions, and make different tradeoffs between .exibility and expressiveness. \nWhereas Maya can be used to implement macros, it is impractical to de.ne a simple macro by building a \nJTS preprocessor. JTS language extensions can de.ne new productions, AST node types, and grammar symbols. \nJTS extensions are also free to mutate syntax trees, since typechecking is performed by a standard Java \ncompiler, after extensions have run to completion. JTS provides great .exibility at the syntactic level \nbut ignores static semantics. OpenJava [29] is a compile-time metaobject protocol for Java. It allows \nmetaclasses to be associated with classes in the base pro\u00adgram. A class declares its metaclass with an \ninstantiates clause, which appears after implements in a class declaration. Metaclasses inherit introspection \nmethods similar to the Java re\u00ad.ection API, and control translation to Java through the visitor pat\u00adtern. \nOpenJava provides for two kinds of macro expansion: caller\u00adside translation allows a metaclass to expand \nexpressions involving its instance types through visit methods on various expression and declaration \nforms, and callee-side translation allows a metaclass to 1Hygiene means that variable references in Mayans \ncannot by de\u00adfault capture variables in scope at the use of a Mayan; referen\u00adtial transparency means \nthat variable references in Mayans capture variables in scope at the de.nition of a Mayan [13]. As is \ncommon in the literature, we use the single term hygiene to mean both hygiene and referential transparency. \nmodify instance class declarations. OpenJava also permits limited extensions to the syntax of instantiatesand \ntype names. OpenJava controls syntax translation based on the static types of expressions, but imposes \nsome limitations. Metaclasses must be explicitly associated with base-level classes through the instan\u00adtiates \nclause. As a result, primitive and array types cannot be used to dispatch syntax expanders. Additionally, \ncaller-side ex\u00adpanders override visit methods de.ned on a subset of Java syntax. OpenJava lacks some \nfeatures that make compile-time metapro\u00adgrams robust: Its macros can generate illegal pieces of syntax, \nbe\u00adcause they allow metaprograms to convert arbitrary strings to syn\u00adtax. In addition, OpenJava metaclasses \ninspect nodes through ac\u00adcessor methods rather than pattern matching. Finally, OpenJava does not support \nhygiene.  3. MAYA OVERVIEW Maya can be used to implement simple macros as well as language extensions \nsuch as MultiJava and aspects [4]. Maya provides a macro library that includes features such as assertions, \nprintf-style string formatting, comprehension syntax for building arrays and collections, and foreach \nsyntax for walking them. This section describes the features that a foreachmacro should have, and the \nway that these features can be implemented in Maya. In the exam\u00adples that follow, we use bold text for \nkeywords, and italic text for binding instance names. Given a Hashtable variable h, the following use \nof for\u00adeach: h.keys().foreach(String st){ System.err.println(st + \"=\"+ h.get(st)); } should expand to: \nfor (Enumeration enumVar$ = h.keys(); enumVar$.hasMoreElements(); ) { String st; st = (String) enumVar$.nextElement(); \n System.err.println(st + \"=\"+ h.get(st)); } where the identi.er emumVar$does not appear in source program. \nMany macro systems support exactly this sort of macro. Although JSE cannot express our chosen concrete \nsyntax, it allows a similar macro to be written. OpenC++ [10] includes speci.c support for member statements \nsuch as foreach. Macro overloading is useful with statements such as foreach. We might want a version \nof foreachthat works on arrays. Alter\u00adnatively, we might want overloading for optimization. For instance, \nthe following code: maya.util.Vector v; v.elements().foreach(String st){ System.err.println(st); } \ncould be expanded to more ef.cient code with a specialized version of foreach: maya.util.Vector v; { \nVector v$ =v; int len$ = v$.size(); Object[] arr$ = v$.getElementData(); for (int i$= 0;i$ < len$; i++){ \nString st = (String) arr$[i$]; System.err.println(st); } } This code can avoid both object allocation \nand method calls be\u00adcause maya.util.Vector exposes its underlying object array by overriding Vector.getElementData(). \nTo support the optimization of foreachon a vector s elements, Maya allows semantic actions (called Mayans) \nto be dispatched on both the structure and static types of arguments. For this ex\u00adample, the left-hand \nside of the specialized foreach must be a call to elements() and the receiver of the call must have type \nmaya.util.Vector. Although macro systems such as Scheme syntax-rules [21] and JSE support syntactic pattern \nmatch\u00ading, and although compile-time MOPs such as OpenJava dispatch on static types, Maya is the .rst \ncompile-time metaprogramming system to unify these features. Maya s multiple-dispatch model provides \nbene.ts over the case statements of syntax-case[17] and JSE in that the behavior of a syntactic form \ncan be extended without modifying the original de.nition. This example shows the central challenge in \nproviding .exible macro dispatching. The foreachstatement s expansion depends on the static type of v.elements(), \nyet the loop body cannot be type checked until the foreachstatement is expanded and the variable stis \ndeclared. Some code cannot even be parsed until sur\u00adrounding Mayans have been expanded. Maya addresses \nthis chal\u00adlenge through lazy parsing and lazy type checking. 3.1 Production Declarations In Maya, a \nsyntax extension is de.ned in two parts. First, a new LALR(1) production may need to be added, if the \nnew syntax is not accepted by the existing grammar. Second, Mayans de.ne se\u00admantic actions for a production, \nand are dispatched based on values on the production s right-hand side. Before Mayans can be de.ned to \nimplement foreach, we must extend the grammar to accept the foreachsyntax. The following production would \nsuf.ce (the concrete Maya syntax for describing this production is given in the next paragraph): Statement \n. MethodName ( Formal ) lazy-block We choose this syntax to avoid making foreacha reserved word in this \ncontext. The MethodName nonterminal matches everything left of ( in a method invocation. In particular, \nMethodName matches the Expression . Identi.er sequence accepted by for\u00adeach. In this example, lazy-block \nmatches a Java block that is lazily parsed: it is not parsed or type checked until its syntax tree is \nneeded. The production above is declared in Maya by the following code: import maya.tree.*; import maya.grammar.*; \nimport java.util.*; abstract Statement syntax(MethodName(Formal) lazy(BraceTree, BlockStmts)); The \nproduction is introduced through the abstractand syn\u00adtax keywords. The syntax keyword indicates that \na grammar production or Mayan is being de.ned. (Recall that a Mayan is a se\u00admantic action in the grammar.) \nThe abstractkeyword indicates that a production is being de.ned. Intuitively, a production is like an \nabstract method in that it de.nes an interface; a corresponding Mayan is a concrete method that implements \nthe interface. Statement is the return type of the production (i.e., the left\u00adhand side); it is also \nthe return type of any corresponding Mayans (semantic actions). The arguments to the production are the \nright\u00adhand side of the production. The lazy keyword indicates lazy  1 Statement syntax 2 EForEach(Expression:Enumeration \nenumExp 3 \\. foreach(Formal var) 4 lazy(BraceTree, BlockStmts) body) 5 { 6 final StrictTypeName castType \n7 = StrictTypeName.make(var.getType()); 8 9 return new Statement { 10 for (Enumeration enumVar = $enumExp; \n11 enumVar.hasMoreElements(); ) { 12 $(DeclStmt.make(var)) 13 $(Reference.makeExpr(var.getLocation())) \n14 = ($castType) enumVar.nextElement(); 15 $body 16 } 17 }; 18 }  Figure 2: The Mayan that implements \nforeachon Enumer\u00adations parsing. The particular use of lazy above means that a Brace\u00adTree(a portion of \ncode surrounded by braces) is to be lazily parsed into a BlockStmts(a block of statements). Most symbols \nin the Maya grammar are AST node types such as Statement. Productions and Mayans may only be de.ned on \nnode-type symbols. Maya also supports several kinds of param\u00adeterized grammar symbols that are used to \nde.ne repetition and control lazy parsing. lazy(BraceTree, BlockStmts),is an example of the use of a \nparameterized grammar symbol.  3.2 Mayan Declarations After we de.ne the production for foreach, we \ncan declare Ma\u00adyans to translate various kinds of foreachstatements to standard Maya syntax. Note that \nif no Mayans are declared on a new pro\u00adduction (that is, no semantic actions are present on the production), \nan error is signaled on input causes the production to reduce. A Mayan declaration differs from a production \ndeclaration in three ways: Mayan parameters have specializers and names; Ma\u00adyan declarations have bodies; \nand Mayans do not begin with the abstractkeyword. Figure 2 shows the EForEachMayan that implements foreach \nfor Enumerations (not the optimized version). The EForEach Mayan is de.ned on the LALR(1) production \ndescribed earlier, which takes the left-hand side of a method invoca\u00adtion followed by a formal parameter \nand a block. Maya determines that this production corresponds to EForEach when the EFor-Eachparameter \nlist is parsed. A Mayan parameter list serves two purposes. First, it determines which occurrences of \nsyntax a Ma\u00adyan can be applied to. Second, it binds formal parameters to actual arguments and their substructure. \nMayan parameter lists and case patterns in functional languages serve similar purposes. In fact, Maya \ns pattern matching facility is made available through a syn\u00adtax casestatement as well as through Mayan \ndispatch. Parameter specializers are used to narrow Mayan applicability: EForEach only applies to MethodName \nnodes that contain an explicit receiver expression. The receiver expression is bound to enumExpand must \nhave the static type Enumeration. The .nal identi.er in the MethodNamesyntax is also specialized to a \npar\u00adticular token value: namely, foreach. Maya s ability to dispatch on the values of identi.ers such \nas foreachallows macros to be de.ned without introducing reserved words. EForEachbinds the loop variable \nand loop body to varand bodyrespectively. The body of a Mayan is Maya code that generates an AST. For \nexample, EForEach s body consists of a local variable declaration and a return statement. The return \nvalue is computed using a tem\u00adplate expression that builds ASTs. Template can be used to build the ASTs \nfrom concrete syntax. For example, a template contain\u00ading 1+2*3 builds the corresponding tree. A template \nmay also contain expressions unquoted with $ : the values of these ex\u00adpressions are substituted into \nthe resulting AST when the template is evaluated. Templates are statically parsed to ensure syntactic \ncorrectness. Maya s templates provide automatic hygiene for lexically scoped names; programmers are given \nmechanisms to explicitly break hy\u00adgiene and to explicitly generate fresh names if they so desire. In \nthe case of EForEach, hygiene ensures two things: .rst, that the loop variable will not interfere with \nreferences to other variables called enumVarin the loop body; second, that the loop variable will have \nthe speci.c type java.util.Enumeration, regardless of the calling context. Like OpenJava metaclasses, \nMayans have access to a variant of the Java re.ection API. References to Type objects are avail\u00adable \nthrough methods such as VarDeclaration.getType() and Expression.getStaticType(). Typeobjects support \njava.lang.Class s introspection API and a limited form of intercession that allows member declarations \nto be added to a class body. Mayans can use the re.ection API to insulate themselves from some details \nof Maya s AST representation. For example, the ab\u00adstract syntax trees for String[] args and String args[] \nhave different shapes, but both declare variables of the same type. EForEach uses the re.ection API in \ntwo places. First, line 7 of Figure 2 builds a StrictTypeName node from the object that represents the \ntype of a variable. Second, line 13 generates a ref\u00aderence to a local variable directly, rather than \ngenerating an oc\u00adcurrence of the variable s name. Reference.makeExpr also allows .elds to be referenced \nwhen they are shadowed by local variables. Line 12 translates a formal parameter declaration into a form \nthat may be used in a statement context.  3.3 Using Mayans Maya decouples Mayan de.nition from use: \na Mayan is not implic\u00aditly loaded into the compiler at the point of declaration, but must be loaded explicitly. \nThis feature allows a Mayan to be compiled in\u00addependent of its uses, and allows local Mayans to use any \nvalue in their environments. A Mayan declaration, such as EForEach in Figure 2, is com\u00adpiled to a class \nthat implements MetaProgram. An instance of the class is allocated when a Mayan is imported. A programmer \nuses the use directive to import MetaProgram instances into a lexical scope; the argument to use can \nbe any class that imple\u00adments MetaProgram. For example, EForEachcan be used in a method body as follows: \nvoid showEm(Enumeration e){ use EForEach; e.foreach(Object o) { System.out.println(o); } } Imports \nof Mayans are lexically scoped. In this example, the scope of the translation de.ned by EForEach consists \nonly of the me\u00adthod body of showEm. The use directive is also valid in class bodies and at the top level. \nAdditionally, Maya provides a -use command line option that allows a programmer to compile a .le using \ndifferent Mayan implementations.  abstract Statement syntax(typedef(Identifier = StrictClassName) lazy(BraceTree, \nBlockStmts));  public Statement syntax Typedef(typedef(Identifier var=StrictClassName val) lazy(BraceTree, \nBlockStmts) body) { // a local Mayan StrictName syntax Subst(Identifier id) { if (id.getName() == \nvar.getName()) // substitute the type variable return val; else // resolve this name normally return \nnextRewrite(); } // Construct a statement node that exposes // an instance of Subst to the typedef body \nreturn new UseStmt(new Subst(), body); }  Figure 3: Local Mayans, as well as local classes, may refer \nto arguments of an enclosing Mayan or method. Since Mayans are typically small units of code, they can \nbe ag\u00adgregated into larger metaprograms. An instance of such a class is allocated, and its run method \nis called to update the environ\u00adment. For example, the class maya.util.ForEach de.nes a single runmethod, \nwhich instantiates and runs each built-in for\u00adeachMayan in turn. As a result, a programmer need only \nusethe maya.util.ForEach class to import all of the built-in for\u00adeachMayans. Like class declarations, \nMayan declarations can appear within method bodies. Local Mayan instances are closed over their lexi\u00adcal \nenvironment in the same way as local class instances. Because a local Mayan de.nition can use any value \nin its environment, it cannot be imported until these values exist. As a result, local Ma\u00adyans can never \nbe imported with use; however, local Mayans can be instantiated and run by other metaprograms. The advantage \nof local Mayans is that one Mayan can expose state to other Mayans without resorting to templates that \nde.ne Mayans. As a result, non\u00adtrivial metaprograms can be structured as a group of classes and a few \nsmall Mayans, rather than as a series of macro de.nitions. Figure 3 demonstrates the use of local Mayans. \nThe Type\u00addef Mayan de.nes an alternate name for a class within a block of statements. Type variables \nare substituted by a local Mayan that compares each identi.er in the block against the argument to Typedef. \nA local Mayan type, Subst, is de.ned within Type\u00addef. Like a local class, this type can only be refered \nto in its lexical scope. Typedefallocates an instance of Subst, and ex\u00adposes that instance to bodythrough \na UseStmtnode. (The code use EForEach; ... in the previous example is translated into a UseStmtnode.) \nUseStmtnodes contain the metaprogram that is imported and the list of statements in which it is visible. \n  4. DESIGN AND IMPLEMENTATION Translating Maya source code to a fully expanded syntax tree in\u00advolves \ndispatching and running Mayans. Dispatch may require type checking, while executing Mayans may change \nthe types of sub\u00adtrees. This mutual recursion precludes parsing and type checking in one pass; Mayan \ndispatch requires that they be interleaved. Maya file names file names class declarations file class \nnames files Figure 4: Overview of Maya s internal architecture satis.es these constraints by parsing \nand type checking lazily, i.e., computing syntax trees and their types on demand. Figure 4 shows the \nmajor components of our Maya compiler, mayac. The .le reader reads class declarations from source .les. \nOur compiler then processes each class declaration in two addi\u00adtional stages. The class shaper parses \nthe class body and computes member types; the class compiler parses member initializers, in\u00adcluding method \nand constructor bodies. The parser is invoked in all three steps to incrementally re.ne a declaration \ns AST. To com\u00adpute the shape of a class C, all super-types of C and the types of all members of C must \nbe found. Similarly, to compile C, the shapes of all types referred to by C s code must be known. Maya \nprovides class-processing hooks that execute user-de.ned code as a class declaration leaves the shaper. \nThe stream lexer enables lazy parsing by generating a tree of to\u00adkens rather than a .at stream. Speci.cally, \nthe stream lexer creates a subtree for each pair of matching delimiters: parentheses, braces, and brackets. \nThese subtrees are called lexers since they can pro\u00advide input to the parser. The stream lexer resembles \na Lisp reader in that it builds trees from a simple context-free language. This tree structure allows \nthe Maya compiler to quickly .nd the end of a me\u00adthod body or .eld initializer without full parsing. \nMaya processes toplevel declarations and class bodies in phases so that forward ref\u00aderences can be resolved \nand typechecking can be performed within the parser. Unless otherwise noted, all arcs coming into the \nparser are lex\u00aders and all arcs going out are ASTs. The parser builds ASTs with the help of the Mayan \ndispatcher: on each reduction, the dispatcher executes the appropriate Mayan to build an AST node. Mayan \ndis\u00adpatch may involve recursive parsing, as shown in Figure 4. The pattern parser is used when compiling \nMayans and tem\u00adplates. It takes a stream of both terminal and nonterminal input symbols, and returns \na partial parse tree. The remainder of this section describes several of Maya s fea\u00adtures. Section 4.1 \ndiscusses Maya s lazy grammar and how new productions can be written to extend it. Section 4.2 discusses \npat\u00adtern matching in Mayan parameter lists, AST templates, and the parsing techniques used to implement \nthese language features. Sec\u00adtion 4.3 describes Maya s static approach to hygiene. Section 4.4 discusses \nMaya s dispatching rules in detail. Finally, Section 4.5 compares Maya s features to those of related \nJava extensions. Statement MethodName (Formal) lazy(BraceTree, BlockSmts) Figure 5: The structure of \nEForEach s formal parameters 4.1 Parsing Maya productions are written in a high-level metagrammar that \nex\u00adplicitly supports laziness. Users can de.ne general-purpose pro\u00adductions on any builtin nonterminal \nof the Maya grammar. User\u00adde.ned productions are indistinguishable from those built into Ma\u00adya. In addition, \nparameterized grammar symbols may implicitly de.ne productions on new nonterminals. Production arguments \n(right-hand sides) consist of token literals, node types, matching-delimiter subtrees, or parameterized \nsym\u00adbols. (lazy(BraceTree, BlockStmts) is an example of a parameterized symbol.) The former two symbol \ntypes are used di\u00adrectly by the LALR(1) grammar, while the latter two require special handling. When \na subtree or parameterized symbol is encountered, Maya ensures that the corresponding production is de.ned \nin the LALR(1) grammar, and uses the left-hand side in the outer produc\u00adtion. For instance, the production \nused by foreachincludes both a subtree and a parameterized symbol: abstract Statement syntax(MethodName(Formal) \n lazy(BraceTree, BlockStmts)); It is translated to the set of productions below: Statement . MethodName \nG0 G1 G0 . ParenTree G1 . BraceTree Semantic actions (which are not shown) on G0 and G1 produce AST \nnodes from unstructured subtrees. The semantic action for G0 recursively parses the ParenTreeto a Formal, \nwhich is men\u00adtioned explicitly in the production. The action for G1 delays the parsing of the BraceTree, \nas speci.ed by the lazy symbol. If the productions and actions already exist in the grammar, they are \nnot added again. For example, the production and action for G0 are used to parse both foreach and catch \nclauses; those for G1 are used throughout the Maya grammar. A production is valid if it does not introduce \ncon.icts into the grammar. The Maya parser generator attempts to resolve con.icts with operator precedence \nrelations. Unlike YACC, Maya does not resolve shift/reduce con.icts in favor of shifts or reduce/reduce \ncon.icts based on the lexical order of productions. The parser gen\u00aderator rejects grammars that contain \nunresolved LALR(1) con.icts.  4.2 Pattern Parsing Maya uses patterns in two ways: .rst, to establish \nbindings in Ma\u00adyan parameter lists and caseclauses; and second, to compile tem\u00adplates that dynamically \nconstruct AST nodes. Although these uses are very different, they involve the same data structure: a \npartial parse tree built from a sequence of both terminal and nonterminal input symbols. The pattern \nparser differs from a standard parser in that its input may include nonterminals as well as tokens. Just \nas the pattern parser accepts nonterminal input symbols, it also gener\u00adates parse trees that may contain \nnonterminal leaves. Recall that EForEachin Figure 2 is de.ned on the production given in Section 3.1. \nThe pattern parser must infer the structure of EForEach s argument list, which is shown in Figure 5. \nSince EForEach is a semantic action, it takes three actual arguments: a MethodName, a parenthesized Formal, \nand a lazily parsed block. However, the .rst argument does not explicitly appear in EForEach s formal \nparameter list. The pattern parser infers the structure of the .rst argument by parsing the symbols in \nthe argu\u00adment list. The pattern parser also parses template bodies. Maya guarantees that a template is \nsyntactically correct by parsing its body when the template is compiled. The pattern parser generates \na parse tree from a sequence of tokens that may be interleaved with expressions unquoted with $ . An \nunquote expression s grammar symbol is determined by its static type or an explicit coercion operator. \nThe template parse tree is compiled into code that performs the same sequence of shifts and reductions \nthe parser would have per\u00adformed on the template body. Templates honor laziness: sub-tem\u00adplates that \ncorrespond to lazy syntax are compiled into local thunk classes that are expanded when the corresponding \nsyntax would be parsed. While some systems have developed ad hoc approaches for tem\u00adplate parsing [5, \n10, 26, 29, 30], Maya opts for a more general solution. Our pattern-parsing algorithm allows Mayans to \nbe de\u00ad.ned on any nonterminal node type, and templates can generate both nonterminal node types and parameterized \nsymbols. A proof of this algorithm s correctness is available elsewhere [3]. The Parsing Algorithm. The \ndescription of the pattern pars\u00ading algorithm uses the function names and lexical conventions of Aho \net al. [1, \u00a74.4]: upper-case letters are nonterminal symbols, lower-case Greek letters are strings of \nterminals and nonterminals, lower case Roman letters are strings of terminals, and FIRST maps a string \nof symbols to the set of all terminals that appear .rst in some derivation. The pattern parser uses parse \ntables in much the same way as a normal LALR(1) parser. Terminal input symbols are shifted onto the stack \nor trigger reductions normally. However, nonterminal symbols require some special handling. Figure 6 \nprovides concrete examples of how nonterminals can be parsed. When the pattern parser encounters a syntactically \nvalid input X., there must be a production Y . aX\u00df in the grammar, and the parser must be in some state \ns0 such that one of the following cases holds: 1. s0 contains an item Y . a.X\u00df: actions on FIRST(X) are \nall shifts, and s0 contains a goto for X that leads to some state sn. In this case, X is shifted onto \nthe stack, and the goto is followed. That is, the current parsing state will accept an X because there \nis an entry in the goto table. Figure 6(b) illustrates this case, given the grammar in Fig\u00adure 6(a). \nIn this example, the metavariable X corresponds to A; Y corresponds to S; a corresponds to D e; and \u00df \nand . correspond to . 2. s0 contains an item Z . d., where Z is a nonterminal such *  that a . .Z, \nand the actions on FIRST(X.) all reduce the same rule Z . d. In this case, the stack is reduced, which \nleads to a state s1 in which one of the above conditions holds. That is, the current parsing state will \naccept an X because we can perform a reduction on the input before X. 6(c) illustrates this case, again \ngiven the grammar in Fig\u00adure 6(a). In this example, X corresponds to A; Y corre\u00adsponds to S; a and Z \ncorrespond to F ; and \u00df, ., and . correspond to . input: de.A input: d Ainput: f.A input:.f A e. state \n= 56 state = 674 state = 67 state = 33 stack: stack: stack: stack: A . a | b | c D . d F . f S . D \neA | FA (a) A simple grammar (b) A goto can be followed if present (c) Otherwise, FIRST(A) serves as \nlookahead Figure 6: Pattern parsing example e D   A e D   f   F  If neither case holds, the \ninput must not be valid. Note that X could be invalid in the second case, and that the pattern parser \nmay not detect the error until it has performed some reductions.  4.3 Hygiene Maya supports compile-time \ndetermination of variable hygiene in templates, unlike most macro systems. Maya s static approach to \nhygiene detects references to unbound variables when a template is compiled, rather than when it is executed. \nIn general hygiene deci\u00adsions can only be made when the syntactic role of each identi.er is known. In \nmost systems, this information is only available after all macros have been expanded. The key to Maya \ns hygiene rules is that a Mayan writer must make explicit which identi.ers are bound and which are not: \nproductions that establish lexically scoped bind\u00adings must use special nonterminals such as UnboundLocal. \nMaya examines trees produced by the pattern parser to decide where hygienic and referentially transparent \nrenaming should oc\u00adcur. Referential transparency in Mayan parameter lists ensures that a class name matches \nnodes that denote the same fully quali.ed name, and that class names in templates refer to the appropriate \nclasses. Maya implements referential transparency by generating nodes that refer to classes directly. \nMaya s implementation of hygiene relies on direct generation of bytecode. Maya assigns fresh names to \nlocal variable declarations generated by Mayans. The names that Maya generates contain the character \n$ and are guaranteed to be unique within a compilation unit. In a source-to-source translator, hygiene \nwould have to be implemented through a more complicated mechanism. As an aside, implementing referential \ntransparency in a trans\u00adlation to Java source code would be dif.cult, since class names can be completely \ninaccessible in certain packages. For instance, java.lang.System cannot be referenced inside the package \nbelow, due to Java s name rules: package p; class java {} class System {} Maya provides mechanisms both \nto explicitly generate unique names and to explicitly break hygiene. Environment.make-Id() generates \na fresh Identifier. Mayans can violate hy\u00adgiene by unquoting Identifier-valued expressions in templates, \nrather than embedding literal names. Referential transparency can also be bypassed through the introspection \nAPI. Maya s hygiene rules do not support implicit parameters that are only shared be\u00adtween a Mayan and \nits point of use: names are either fully hygienic or fully unhygienic.  MethodName (Formal) lazy(BraceTree, \nBlockSmts)  CallExpr . Identifier  list(Expression, , ) Figure 7: The structure of VForEach s formal \nparameters 4.4 Dispatch Mayan dispatching is at the core of Maya. Each time a production is reduced, \nthe parser dispatches to the appropriate Mayan. This Mayan is selected by .rst .nding all Mayans applicable \nto the pro\u00adduction s right-hand side, then choosing the most applicable Mayan from this set. While multiple \ndispatch is present in many languages such as Cecil [9], CLOS [28], and Dylan [27], the exact formula\u00adtion \nof Maya s rules is fairly unique. Mayan dispatching is based on the runtime types of AST nodes, but also \nconsiders secondary parameter attributes. As described earlier, the pattern parser builds Mayan parameter \ntrees from un\u00adstructured lists of tokens and named parameters. A Mayan parame\u00adter consists of a node \ntype and an optional secondary attribute. This attribute may contain subparameters, a token value, a \nstatic expres\u00adsion type, or a class literal type. For example, in Figure 5, EFor-Each specializes MethodName \non its structure, Expression on its static type, and Identifieron the token value foreach. Secondary \nattributes are used to compare formal parameters with identical node types. Static expression types are \ncompared using subtype relationships; substructure is compared recursively; class types and token values \nmust match exactly. For example, the fol\u00adlowing optimized foreachde.nition Statement syntax VForEach(Expression:maya.util.Vector \nv \\.elements()\\.foreach(Formal var) lazy(BraceTree, BlockStmts) body) { /*... */ } overrides EForEach \nfor certain input values. The structure of VForEach s formal parameters is shown in Figure 7. VForEach \nis more speci.c than EForEachbecause the foreach receiver is specialized on the CallExprnode type, while \nEForEachdoes not specialize the receiver node type. Mayan dispatching is symmetric. If two Mayans are \nmore spe\u00adci.c than each other on different arguments, neither is more speci.c overall, and an error is \nsignaled. This approach avoids the surpris\u00ading behavior described by Ducournau et al. [16], and is consistent \nwith Java s static overloading semantics. Maya supports an unusual form of lexical tie breaking among \nMayans that are equally speci.c: Mayans that are imported later override earlier Mayans. Lexical tie-breaking \nallows several Ma\u00adyans to be imported with identical argument lists. Where several Mayans are equal according \nto the argument lists, the last Mayan imported with use is considered most applicable. For example, many \nof the Mayans that we have written do not specialize their arguments. Such Mayans are more applicable \nthan the built-in Ma\u00adyans only because the built-in Mayans are imported .rst. Maya provides an operator \nthat is necessary to support the layer\u00ading of macros. The nextRewrite operator calls the next-most\u00adapplicable \nMayan, and is analogous to super calls in methods. This operator may only be used within Mayan bodies, \nwhereas other Maya features such as templates may be used in any Maya code. 4.5 Discussion Maya s expressiveness \ncan be compared to that of the other lan\u00adguages discussed in Section 2. Neither JSE, JTS, nor OpenJava \nsupport automatic hygiene. JSE and JTS do not provide static type information, while JSE and OpenJava \nprovide limited facilities for de.ning new syntax. JTS allows extensions to de.ne arbitrary new productions, \nwhile Maya only allows general-purpose productions to be de.ned on a .xed set of left-hand sides. JTS \nextensions are also free to extend the abstract syntax tree format. Since Maya must be able assign standard \nJava meaning to every syntax tree, only a few speci.c node types may be subclassed by users.2 Finally, \nJTS extensions may walk syntax trees in any order and perform mutation. In contrast, Mayans are executed \nby the par\u00adser, and can only mutate class declaration by adding and removing members when certain dynamic \nconditions are met. This restric\u00adtion ensures that class updates cannot change the results of previous \ntype checking and Mayan dispatch. OpenJava and Maya both allow some form of syntax extension, dispatch \nbased on static information, and the association of syn\u00adtax transformation code with the lexical structure \nof the program. Maya provides more .exibility in these areas. OpenJava allows three extensions to declaration \nsyntax: new modi.ers may be de.ned, clauses may be added to the class dec\u00adlaration syntax, and suf.xes \nmay be added to the type in a variable declaration. In all cases, a keyword signals the presence of ex\u00adtended \nsyntax, and the metaclass must provide a parsing routine. In contrast, Maya allows new productions to \nbe de.ned on any gram\u00admar symbol, and does not require that keywords be used. OpenJava dispatches caller-side \nvisit methods to transform an input program based on its static types. However, visit methods are only \nde.ned for a few expression and declaration forms. In contrast, Mayans may be de.ned on all productions \nin the base grammar, as well as user-de.ned productions. OpenJava associates syntax transformation methods \nwith class declarations through the instantiatesclause. A metaclass is free to examine and modify the \nbodies of its instance classes. Al\u00adthough Maya does not provide a similar mechanism, local Mayan de.nitions \nand imports allow user-de.ned metaobjects to be cre\u00adated easily. These metaobjects need not be associated \nwith classes. 2This restriction is not currently enforced in the implementation.  5. MULTIJAVA To evaluate \nMaya, we implemented MultiJava, an extension to Java that Clifton et al. have speci.ed [12]. The .rst \nauthor s thesis [3] contains several smaller examples of how Maya can be used; it also discusses the \nMultiJava implementation in greater detail. MultiJava adds generic functions to Java through two new \ncon\u00adstructs: open classes and multimethods. Open classes allow meth\u00adods to be declared at the top level, \nand multimethods allow dispatch based on the runtime types of all method arguments. MultiJava s formulation \nof open classes and multimethods supports separate compilation. 5.1 MultiJava Overview Open classes in \nMultiJava offer an alternative to the visitor design pattern. Rather than maintaining a visit method \non each class in a hierarchy and a separate hierarchy of visitor classes, one can simply augment the \nvisited class hierarchy with externally de.ned meth\u00adods. External methods can be added without recompiling \nthe vis\u00adited class hierarchy, but a class can override external methods that it inherits. Within an external \nmethod, this is bound to the receiver in\u00adstance. However, external methods in MultiJava may not access \nprivate .elds of this, nor can they access nonpublic .elds of thisif the receiver class is de.ned in \nanother package. MultiJava de.nes a compilation strategy and type checking rules that together allow \nexternal methods and their receiver classes to be compiled separately. Essentially, an external virtual \nfunction is compiled to a dispatcher class, and calls to an external method are replaced with calls to \na method in the dispatcher class. In addition to open classes, MultiJava supports multimethods. Multimethods \nallow a class to de.ne several methods with the same name and signature, but distinct parameter specializers. \nEach vir\u00adtual function is treated as a generic function, so that multiple dis\u00adpatch and static overloading \ncan be used together. A super call in a multimethod (to the same generic function) selects the next applicable \nmethod, rather than the method de.ned by a superclass. MultiJava imposes some restrictions on parameter \nspecializers to support separate compilation. First, only class-typed parame\u00adters may be specialized, \nand they may only be specialized by sub\u00adclasses. Second, a concrete class must de.ne or inherit multimeth\u00adods \nfor all argument types (including abstract types). These restric\u00adtions allow MultiJava to statically \nensure that there is exactly one most applicable method for every possible call to a generic func\u00adtion. \n 5.2 Maya Implementation We implemented MultiJava with a mixture of class and Mayan de.\u00adnitions. The \nmajority of code is de.ned in ordinary methods, rather than in Mayan bodies. Maya provides several features \nthat make a MultiJava implementation practical: The full power of Maya s extensible LALR(1) grammar is \nused to extend Java s concrete syntax in two ways. First, MultiJava allows methods to be declared outside \nof their re\u00adceiver class. These methods declarations include the receiver class name immediately after \ntheir return type. abstract Declaration syntax(list(Modifier) LazyTypeName QualifiedName\\.Identifier \n(FormalList) Throws lazy(BraceTree, BlockStmts)); Second, MultiJava allows method parameters to be \ndeclared with both a base type that determines the method s virtual function and a type specializer that \nnarrows the method s ap\u00adplicability at runtime. A parameter specializer appears after an @ in a parameter \ndeclaration. abstract Formal syntax(list(Modifier) LazyTypeName @ LazyTypeName LocalDeclarator); \n Maya s lexical tie-breaking rule lets MultiJava transparently change the translation of base Java syntax. \nOur MultiJava implementation examines every ordinary method declaration to determine whether its parameters \ninclude specializers, and whether it overrides an external method. Maya dispatches to these Mayans rather \nthan built-in Mayans because of the dispatcher s lexical tie-breaking rule.  Maya provides standard \nJava type information to Mayans, which MultiJava needs to enforce its type checking rules.  Semantic \nactions are implemented as local Mayans, which allows them to share state.  The lexical scoping of imported \nMayans is used to limit the scope of translations.  Local Mayan declarations and lexically scoped imports \nallow our MultiJava implementation to be structured hierarchically into high-level constructs. For example, \nour implementation instanti\u00adates classes named MultiMethod and GenericFunction to keep track of MultiJava \nlanguage constructs. These objects are sim\u00adilar to instances of metaclasses in OpenJava; unlike metaclasses, \nour classes are not a .xed part of the Maya language. Multi-Methodand GenericFunctionstore information \nthat is used to ensure that generic function de.nitions cannot produce dispatch errors, and to compute \nthe method of super sends from multi\u00admethods. The actual translation of super sends is performed by a \nmethod-local Mayan de.ned in MultiMethod. This Mayan relies on its enclosing MultiMethod instance, and \nis exported locally within a multimethod body. GenericFunctiongenerates code to dispatch multimethods. \nFor example, if Dis a subclass of C, class D extends C{ int m(Cc) { return 0; } // a multimethod: \nexecutes if c is dynamically // aD int m(C@D c){ return 1; } } D will be translated as follows, with \nthe Java method m generated by GenericFunction: class D extends C{ private int m$1(C c){ return 0; \n} private int m$2(D c){ return 1; } int m(C c){ return c instanceof D ? m$2((D) c) : m$1(c); } } \nThe body of m is generated by a recursive method, Generic\u00adFunction.dispatchArg(). A simpli.ed version \nof this me\u00adthod, which does not perform error checking or support voidmeth\u00adods, is shown in Figure 8. \n  5.3 Discussion Clifton [11] implemented MultiJava by modifying the Kopi [15] Java compiler, kjc. He \nadded or materially altered 20,000 of the  // Applicable methods are sorted from most to // least specific. \nMultiMethod m = (MultiMethod) applicable.elementAt(0); return dispatchCall(vars, m); } // For each \ntype specializer on the nth // argument, find all methods that may be // applicable when that type is \nencountered. // Sort the array of specializers and methods so // that subtypes come before supertypes. \nThis // gives us a valid order in which to perform // instanceof tests. Map.Entry[] ents = sortOnArg(applicable, \nn); // Generate dispatch code from right to left, // i.e., generate superclass cases first. int specInd \n= ents.length -1; Vector v = (Vector) ents[specInd].getValue(); Expression ret = dispatchArg(vars, v,n+1); \nfor (specInd--; specInd >= 0; specInd--) { Type t = (Type) ents[specInd].getKey(); Vector app = (Vector)ents[specInd].getValue(); \nret = new Expression { ($(as Expression Reference.make(vars[n])) instanceof $(StrictTypeName.make(t))) \n? $(dispatchArg(vars, app, n + 1)) : $ret }; } return ret; }  Figure 8: Simpli.ed version of code \nto that generates mulit\u00admethod dispatching expressions. 50,000 lines in kjc. In contrast, our MultiJava \nimplementation is less than 2,500 noncomment, nonblank lines of code. It should be noted that Clifton \ns MultiJava implementation involved .xing bugs and implementing standard Java features in kjc. One might \nconsider implementing MultiJava in the languages described in Section 2. It is hard to imagine a MultiJava \nimple\u00admentation in a macro system such as JSE, because JSE macros cannot transparently expand method \ndeclarations. JTS is a more viable option: since JTS allows the Java grammar to be extended and reinterpreted, \nit is certainly powerful enough to express Multi-Java. However, one would have to implement Java s standard \ntype checking rules along with MultiJava s rules, since JTS relies on javacfor its type checking. OpenJava \nprovides some of the features that one would need. OpenJava allows the translation of a class to be changed \nwhen its declaration is annotated with an instantiatesclause. A sim\u00adple extension to OpenJava might allow \nthe default metaclass to be changed transparently. OpenJava also exposes static type informa\u00adtion to \nmetaprograms, and supports lexical scoping through callee\u00adside translation. However, OpenJava supports \nvery a limited form of syntax extension that cannot express new kinds of declarations such as external \nmethods. OpenJava s model of lexically scoped macros is also a poor match for MultiJava, since OpenJava \nsup\u00adports class, but not method, metaobjects.  6. RELATED WORK Most multiple-dispatch systems allow \ndispatch on more than just types. For instance, CLOS [28] dispatches on argument values us\u00ading eqlspecializers, \nand Dylan [27] generalizes this feature with singleton and union types. Maya s dispatching rules bear \na partic\u00adular resemblance to the grand uni.ed dispatcher (GUD) in Dubi\u00adous [18]. Like GUD, Maya uses \npattern matching. Additionally, GUD allows dispatch on user-de.ned predicates whereas Maya al\u00adlows dispatch \non the static types of expressions. Languages such as Dubious and Cecil [9] perform static checks to \nensure that all generic function invocations unambiguously dispatch to a method. Maya defers these checks \nto expansion time. A* [23] is a family of languages for writing preprocessors: it extends Awk to operate \non syntax trees for particular source lan\u00adguages. A* supports a limited form of pattern matching: a case \nguard may be either a boolean expression or a YACC production. A production case matches nodes generated \nby the corresponding production in A* s parser, and introduces new syntax for accessing the node s children. \nUnlike Maya s patterns, A* patterns cannot contain substructure or additional attributes such as identi.er \nval\u00adues or expression types. Maya is certainly not the only syntax manipulation system to support pattern \nmatching. Scheme s syntax-rules[21] and its descendants [17, 27] allow macros to be de.ned using case \nanaly\u00adsis. Maya borrows many ideas from high-level macro systems such as Chez Scheme s syntax-case[17], \nDylan [27], and XL [24]. However, Maya makes a different set of tradeoffs than these sys\u00adtems. Speci.cally, \nMaya s ability to statically check template syn\u00adtax comes at the cost of hygienic implicit parameters, \nand local Mayans can share state more easily than local macros. Chez Scheme s syntax-caseprovides programmable \nhygien\u00adic macros with lexical scoping. Unlike Chez Scheme, Maya sep\u00adarates the concepts of local macro \nde.nition and local macro im\u00adport. This separation allows Mayans to share context directly. In syntax-case, \ncontext can only be shared indirectly: data must be encoded as literals and exposed to inner macros through \nlet\u00adsyntaxbindings. This technique can be cumbersome in any lan\u00adguage, and is particularly unattractive \nin languages such as Java that limit literals to numbers, strings, and arrays of literals. McMicMac [22] \nis an extended macro facility for Scheme that overcomes some of these limitations. McMacMic allows macros \nto explicitly pass inherited attributes as arguments and synthetic attributes as multiple return values. \nMcMicMac also allows macros to be de.ned on special grammar constructs such as procedure application, \nbut it is less powerful than Maya s multiple-dispatch model. MS2 [30] is essentially Common Lisp s defmacro \nfor the C language. Macro functions are evaluated by a C interpreter and may expand declarations, statements, \nor expressions. As in Dylan, macro keywords are recognized by the lexer, and macro parameters may be \nrecursively parsed according to their syntactic types. MS2 de.nes template syntax for building ASTs and \nsupports a polymorphic unquote operator, $ . Maya shares these features. When parsing templates, MS2 \ntype checks $ expressions to de\u00adtermine the grammar symbols they produce. In MS2, templates can only \ngenerate declarations, statements, and expressions, but three additional node types can be unquoted: \nidenti.ers, numeric liter\u00adals, and type speci.ers. MS2 s recursive-descent parser is written to accept \nmacro calls and unquoted expressions at these few well\u00adde.ned places. MacroML [20] extends ML with a \ntype-safe macro system. In MacroML, macro expansion cannot produce type errors. Macro return values are \nstatically checked for both syntactic correctness and type safety. In contrast, Maya checks the syntactic \nstructure of a template at compile-time, but only type checks the resulting tree when a template is expanded. \nMacroML supports three macro forms. Function macros consist of the macro name followed by one or more \narguments, and may not establish bindings. Lambda-like macros consist of the macro name, a variable name, \nand a body in which the variable is bound. Finally, let-style macros consist of the letkeyword, the macro \nname, a variable name and initializer, and a body in which the variable is bound. Since MacroML makes \nbindings explicit in a macro s form, it can make hygiene decisions statically. Cardelli et al. [8] de.ne \nan extensible LL(1) parsing package with macro-like features. A semantic action may not contain arbi\u00adtrary \ncode. Instead, it consists of calls to a prede.ned set of AST node constructors and references to parameters \non the production s right hand side. Semantic actions in a language extension can also be de.ned through \ntemplates written in the base language syntax. This system takes an unusual approach to hygiene and referential \ntransparency: hygienic names must be explicitly declared as lo\u00adcal, but referential transparency is provided \nautomatically. <bigwig> [6] includes an unusual pattern-based macro facil\u00adity in which macro expansion \nis guaranteed to terminate. <big\u00adwig>macros de.ne new productions in an extended LL(1) gram\u00admar. Macro \nproductions consist of a macro keyword followed by zero or more terminal and nonterminal arguments. <bigwig>also \nallows the programmer to de.ne new nonterminal symbols called metamorphs. Metamorphs are named and can \nbe mutually recur\u00adsive, features not present in Maya s parameterized grammar sym\u00adbols. A <bigwig> macro \nbody is a template that contains concrete syntax and references to nonterminal arguments. <bigwig> al\u00adlows \nall nonterminals to appear in macro arguments and templates (as Maya does), but Brabrand and Schwartzbach \ndo not indicate whether their template implementation uses extra grammar produc\u00adtions or direct parser \nsupport. <bigwig> s extended LL(1) parser de.nes two con.ict resolu\u00adtion rules. First, longer rules are \nchosen over shorter rules. Second, smaller FIRST sets are considered more speci.c than larger ones. This \nsecond rule handles identi.ers used as keywords elegantly, but has farther-reaching implications. <bigwig> \ns de.nition of well\u00adformed grammars would allow: S . aa| T b T . a| b even though <bigwig>cannot parse \na b . Maya s LALR(1) par\u00adser can accept this language, but more importantly, Maya signals an error when \ngrammar con.icts cannot be resolved. Maya s parsing strategy offers several advantages over <big\u00adwig> \ns. First, it allows parsing and type checking to be interleaved. Second, it uses standard LALR(1) parsing \ntechniques, which are more .exible than LL(1). Finally, Maya rejects grammars that it cannot recognize. \nCamlp4 [14] is a preprocessor for the OCaml programming lan\u00adguage. Camlp4 parses OCaml source code using \na variant of LL(1) parsing. Macros may extend the OCaml grammar, but as in <big\u00adwig>, con.icts are not \ndetected. Camlp4 allows syntax trees to be generated through quotations that are similar to Maya s templates. \nQuotations can also be used in pattern matching. Maya provides similar functionality through the syntax \ncasestatement. Maya differs from Camlp4 in that it exposes static type information to macros and that \nit rejects grammar extensions that produce con\u00ad.icts. ELIDE [7] is a Java preprocessor that allows programmers \nto de.ne new declaration modi.ers in terms of syntax transformer classes. Like OpenJava and Maya, ELIDE \nallows syntax trans\u00adformers to modify declarations through an extension of the Java re.ection API. OpenJava \nand ELIDE are also similar in that they allow strings to be dynamically converted to syntax objects and \ndo not support general syntax extensions. However, where OpenJava allows a single metaclass to control \nthe compilation of a class dec\u00adlaration, ELIDE allows an arbitrary number of modi.ers. 7. CONCLUSIONS \nWe have described Maya, a version of Java that supports user\u00adde.ned syntax extensions. These extensions \nare written as mul\u00adtimethods on generic functions, which makes them expressive and powerful. Local Mayan \ndeclarations and lexically scoped imports allow great .exibility in how language extensions are structured. \nSeveral implementation mechanisms make Maya s macros easy to write: Pattern parsing is a novel technique \nfor clean and general quasiquoting in languages like Java.  Lazy type checking allows Maya to dispatch \narbitrary Ma\u00adyans based on static type information, even though Mayans may create variable bindings. \n Lazy parsing allows lexically scoped Mayans to change the grammar.  Maya s static template parsing \nand hygienic renaming allows large classes of macro errors to be detected: syntax errors are detected \nin parsing, and references to unbound variables are detected during hygiene analysis.  While Maya is \nwell suited to implement language extensions such as aspect weaving [4] and MultiJava, it is equally \nwell suited for smaller tasks such as the foreach macro described in Sec\u00adtion 3. The Maya compiler and \nour MultiJava implementation are available at http://www.cs.utah.edu/ jbaker/maya. Acknowledgments We \nthank Eric Eide for his many comments on drafts of this paper. We also thank Sean McDirmid and John Regehr \nfor their feedback. This research was supported in part by the National Science Foun\u00addation under CAREER \naward CCR 9876117 and the Defense Ad\u00advanced Research Projects Agency and the Air Force Research Lab\u00adoratory \nunder agreement number F33615 00 C 1696. The U.S. Government is authorized to reproduce and distribute \nreprints for Governmental purposes notwithstanding any copyright annotation hereon. 8. REFERENCES [1] \nA. Aho, R. Sethi, and J. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley, 1986. \n [2] J. Bachrach and K. Playford. The Java syntactic extender (JSE). In Proceedings of the Conference \non Object-Oriented Programming Systems, Languages, and Applications 01, pages 31 42, Tampa Bay, FL, Oct. \n2001. [3] J. Baker. Macros that play: Migrating from Java to Maya. Master s thesis, University of Utah, \nDec. 2001. http:// www.cs.utah.edu/ jbaker/maya/thesis.html. [4] J. Baker and W. C. Hsieh. Runtime aspect \nweaving through metaprogramming. In Proceedings of the First International Conference on Aspect-Oriented \nSoftware Development, Enschede, The Netherlands, Apr. 2002. [5] D. Batory, B. Lofaso, and Y. Smaragdakis. \nJTS: Tools for implementing domain-speci.c languages. In Proc. of the 5th International Conference on \nSoftware Reuse, pages 143 153, Victoria, Canada, 1998. [6] C. Brabrand and M. Schwartzbach. Growing languages \nwith metamorphic syntax macros. In Proceedings of the Workshop on Partial Evaluation and Semantics-Based \nProgram Manipulation 02, Portland, OR, Jan. 2002. http://www.brics/dk/ mis/macro.ps. [7] A. Bryant, A. \nCatton, K. De Volder, and G. C. Murphy. Explicit programming. In Proceedings of the First International \nConference on Aspect-Oriented Software Development, Enschede, The Netherlands, Apr. 2002. [8] L. Cardelli, \nF. Matthes, and M. Abadi. Extensible syntax with lexical scoping. Technical Report 121, DEC SRC, Feb. \n1994. [9] C. Chambers. The Cecil Language Speci.cation and Rationale: Version 2.0, 1995. [10] S. Chiba. \nA metaobject protocol for C++. In Proceedings of the Conference on Object-Oriented Programming Systems, \nLanguages, and Applications 95, pages 285 299, Austin, TX, 1995. [11] C. Clifton. The MultiJava project. \nhttp://www.cs.iastate.edu/ cclifton/ multijava/index.shtml. [12] C. Clifton, G. Leavens, C. Chambers, \nand T. Millstein. MultiJava: Modular open classes and symmetric multiple dispatch for Java. In Proceedings \nof the Conference on Object-Oriented Programming Systems, Languages, and Applications 00, pages 130 146, \nMinneapolis, MN, Oct. 2000. [13] W. Clinger and J. Reese. Macros that work. In Proceedings of the 18th \nAnnual ACM Symposium on Principles of Programming Languages, pages 155 162, Toronto, Ontario, Jan. 1991. \n[14] D. de Rauglaudre. Camlp4 reference manual. http://caml.inria.fr/camlp4/manual/, Jan. 2002. [15] \nW. Divoky, C. Forgione, T. Graf, C. Laborde, A. Lemonnier, and E. Wais. The Kopi project. http://www.dms.at/kopi/index.html. \n[16] R. Ducournau, M. Habib, M. Huchard, and M. Mugnier. Monotonic con.ict resolution mechanisms for \ninheritance. In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and \nApplications 92, pages 16 24, Vancouver, BC, Oct. 1992. [17] R. K. Dybvig, R. Hieb, and C. Bruggeman. \nSyntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):pp. 295 326, 1993. [18] M. Ernst, \nC. Kaplan, and C. Chambers. Predicate dispatching: A uni.ed theory of dispatch. In Proceedings of the \nConference on Object-Oriented Programming Systems, Languages, and Applications 98, pages 186 211, Vancouver, \nBC, Oct. 1998. [19] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Addison Wesley, Massachusetts, 1994. [20] S. Ganz, A. Sabry, and W. Taha. Macros \nas multi-stage computations: Type-safe, generative, binding macros in MacroML. In Proceedings of the \nInternational Conference on Functional Programming 01, pages 74 85, Florence, Italy, Sept. 2001. [21] \nR. Kelsey, W. Clinger, and J. Rees (Eds.). The revised5 report on the algorithmic language Scheme. ACM \nSIGPLAN Notices, 33(9), Sept. 1998. [22] S. Krishnamurthi. Linguistic Reuse. PhD thesis, Rice University, \n2001. [23] D. A. Ladd and J. C. Ramming. A*: A language for implementing language processors. IEEE Transactions \non Software Engineering, 21(11):894 901, Nov. 1995. [24] W. Maddox. Semantically-sensitive macroprocessing. \nMaster s thesis, University of California, Berkeley, 1989. [25] Microsoft. C# language speci.cation. \nhttp://msdn.microsoft.com/library/ dotnet/csspec/vclrfcsharpspec_Start.htm. [26] M. Poletto, W. Hsieh, \nD. Engler, and M. Kaashoek. C and tcc: A Language and Compiler for Dynamic Code Generation . ACM Transactions \non Programming Languages and Systems, 21(2):324 369, 1999. [27] A. Shalit. Dylan Reference Manual. Addison-Wesley, \n1996. [28] G. Steele Jr. Common Lisp, the Language. Digital Press, second edition, 1990. [29] M. Tatsubori, \nS. Chiba, M. Killijian, and K. Itano. OpenJava: A class-based macro system for Java. In Proceedings of \nthe OOPSLA 00 Re.ection and Software Engineering Workshop, Minneapolis, MN, Oct. 2000. [30] D. Weise \nand R. Crew. Programmable syntax macros. In Proceedings of the SIGPLAN 93 Conference on Programming Language \nDesign and Implementation, pages 156 165, Albuquerque, NM, June 1993. [31] Xerox. The AspectJ programming \nguide. http: //www.aspectj.org/doc/dist/progguide/.  \n\t\t\t", "proc_id": "512529", "abstract": "We have designed and implemented Maya, a version of Java that allows programmers to extend and reinterpret its syntax. Maya generalizes macro systems by treating grammar productions as generic functions, and semantic actions on productions as multimethods on the corresponding generic functions. Programmers can write new generic functions (i.e., grammar productions) and new multimethods (i.e., semantic actions), through which they can extend the grammar of the language and change the semantics of its syntactic constructs, respectively. Maya's multimethods are compile-time metaprograms that transform abstract syntax: they execute at program compile-time, because they are semantic actions executed by the parser. Maya's multimethods can be dispatched on the syntactic structure of the input, as well as the static, source-level types of expressions in the input. In this paper we describe what Maya can do and how it works. We describe how its novel parsing techniques work and how Maya can statically detect certain kinds of errors, such as code that generates references to free variables. Finally, to demonstrate Maya's expressiveness, we describe how Maya can be used to implement the MultiJava language, which was described by Clifton et al. at OOPSLA 2000.", "authors": [{"name": "Jason Baker", "author_profile_id": "81538833456", "affiliation": "University of Utah", "person_id": "PP14096139", "email_address": "", "orcid_id": ""}, {"name": "Wilson C. Hsieh", "author_profile_id": "81100546684", "affiliation": "University of Utah", "person_id": "P300415", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512562", "year": "2002", "article_id": "512562", "conference": "PLDI", "title": "Maya: multiple-dispatch syntax extension in Java", "url": "http://dl.acm.org/citation.cfm?id=512562"}