{"article_publication_date": "05-17-2002", "fulltext": "\n Region-Based Memory Management in Cyclone * Dan Grossman Greg Morrisett Trevor Jim Michael Hicks Yanling \nWang James Cheney Computer Science Department AT&#38;T Labs Research Cornell University 180 Park Avenue \nIthaca, NY 14853 Florham Park, NJ 07932 {danieljg,jgm,mhicks,wangyl,jcheney}@cs.cornell.edu trevor@research.att.com \nABSTRACT Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone \nis to let program\u00admers control data representation and memory management without sacri.cing type-safety. \nIn this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. \nThe design incorporates several ad\u00advancements, including support for region subtyping and a coherent \nintegration with stack allocation and a garbage col\u00adlector. To support separate compilation, Cyclone \nrequires programmers to write some explicit region annotations, but a combination of default annotations, \nlocal type inference, and a novel treatment of region e.ects reduces this burden. As a result, we integrate \nC idioms in a region-based frame\u00adwork. In our experience, porting legacy C to Cyclone has required altering \nabout 8% of the code; of the changes, only 6% (of the 8%) were region annotations.  Categories and Subject \nDescriptors D.3.3 [Programming Languages]: Language Constructs and Features dynamic storage management \n General Terms Languages 1. INTRODUCTION Many software systems, including operating systems, de\u00advice \ndrivers, .le servers, and databases require .ne-grained * This research was supported in part by Sloan \ngrant BR\u00ad3734; NSF grant 9875536; AFOSR grants F49620-00-1\u00ad0198, F49620-01-1-0298, F49620-00-1-0209, \nand F49620-01\u00ad1-0312; ONR grant N00014-01-1-0968; and NSF Graduate Fellowships. Any opinions, .ndings, \nand conclusions or rec\u00adommendations expressed in this publication are those of the authors and do not \nre.ect the views of these agencies. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies control over data representation (e.g., .eld layout) \nand re\u00adsource management (e.g., memory management). The de facto language for coding such systems is \nC. However, in providing low-level control, C admits a wide class of danger\u00adous and extremely common \n safety violations, such as incorrect type casts, bu.er overruns, dangling-pointer deref\u00aderences, and \nspace leaks. As a result, building large systems in C, especially ones including third-party extensions, \nis per\u00adilous. Higher-level, type-safe languages avoid these draw\u00adbacks, but in so doing, they often fail \nto give programmers the control needed in low-level systems. Moreover, porting or extending legacy code \nis often prohibitively expensive. Therefore, a safe language at the C level of abstraction, with an easy \nporting path, would be an attractive option. Toward this end, we have developed Cyclone [6, 19], a language \ndesigned to be very close to C, but also safe. We have written or ported over 110,000 lines of Cyclone \ncode, including the Cyclone compiler, an extensive library, lexer and parser generators, compression \nutilities, device drivers, a multimedia distribution overlay network, a web server, and many smaller \nbenchmarks. In the process, we identi.ed many common C idioms that are usually safe, but which the C \ntype system is too weak to verify. We then augmented the language with modern features and types so that \nprogram\u00admers can still use the idioms, but have safety guarantees. For example, to reduce the need for \ntype casts, Cyclone has features like parametric polymorphism, subtyping, and tagged unions. To prevent \nbounds violations without mak\u00ading hidden data-representation changes, Cyclone has a va\u00adriety of pointer \ntypes with di.erent compile-time invariants and associated run-time checks. Other projects aimed at making \nlegacy C code safe have addressed these issues with somewhat di.erent approaches, as discussed in Section \n7. In this paper, we focus on the most novel aspect of Cy\u00adclone: its system for preventing dangling-pointer \nderefer\u00adences and space leaks. The design addresses several seem\u00adingly con.icting goals. Speci.cally, \nthe system is: Sound: Programs never dereference dangling pointers.  Static: Dereferencing a dangling \npointer is a compile\u00adtime error. No run-time checks are needed to deter\u00admine if memory has been deallocated. \n bear this notice and the full citation on the .rst page. To copy otherwise, to Convenient: We minimize \nthe need for explicit pro\u00ad republish, to post on servers or to redistribute to lists, requires prior \nspeci.c grammer annotations while supporting many C id\u00ad permission and/or a fee. ioms. In particular, \nmany uses of the addresses of local PLDI 02, June 17-19, 2002, Berlin, Germany. Copyright 2002 ACM 1-58113-463-0/02/0006 \n...$5.00. variables require no modi.cation. Exposed: Programmers control where objects are allo\u00adcated \nand how long they live. As usual, local variables are always allocated on the stack.  Comprehensive: \nWe treat all memory uniformly, in\u00adcluding the stack, the heap (which can optionally be garbage-collected), \nand growable regions.  Scalable: The system supports separate compilation, as all analyses are intraprocedural. \n Following the seminal work of Tofte and Talpin [28], the system is region-based: each object lives \nin one region and, with the exception that a distinguished heap region may be garbage collected, a region \ns objects are all deallocated si\u00admultaneously. As a static system for an explicitly typed, low-level \nlanguage, Cyclone s region framework makes sev\u00aderal technical contributions over previous work, notably: \n Region subtyping: A last-in-.rst-out discipline on re\u00adgion lifetimes induces an outlives relationship \non re\u00adgions, which, in turn, allows us to provide a useful subtyping discipline on pointer types.  Simple \ne.ects: We eliminate the need for e.ect vari\u00adables (which complicate interfaces) through the use of a \nregions_of type operator.  Default annotations: We combine a local inference al\u00adgorithm with a system \nof defaults to reduce the need for explicit region annotations.  Integration of existential types: The \ncombination of region subtyping and simple e.ects makes the integra\u00adtion of .rst-class abstract data \ntypes relatively simple.  We have found Cyclone s region system su.ciently ex\u00adpressive for porting legacy \nC code and writing new applica\u00adtions. In our experience, porting C code has required alter\u00ading about \n8% of the code, and the vast majority of changes have not been region annotations. Furthermore, Cyclone \nperformed as well as C for the network applications we con\u00adsidered, and within a factor of three for \nmore computation\u00adally intense programs. In this paper, we demonstrate our contributions, begin\u00adning with \na general description of the system suitable for programmers (Section 2). We then present a more techni\u00adcal \ndiscussion of our novel e.ect system and its interaction with existential types (Section 3). We continue \nwith a core formal language that we have proven sound (Section 4), an overview of our implementation \n(Section 5), and a study of the burden of porting C code to Cyclone and the resulting performance (Section \n6). We discuss related work in Sec\u00adtion 7 and future work in Section 8. 2. USING CYCLONE REGIONS This \nsection presents the programmer s view of Cyclone s memory-management system. It starts with the constructs \nfor creating regions, allocating objects, and so on this part is simple because the departure from C \nis small. We next present the corresponding type system, which is more involved because every pointer \ntype carries a region annota\u00adtion. Then we show how regions lifetimes induce subtyping on pointer types. \nAt that point, the type syntax is quite ver\u00adbose, so we explain the features that, in practice, eliminate \nalmost all region annotations. Throughout, we take the lib\u00aderty of using prettier syntax (e.g., Greek \nletters) than actual Cyclone. For the ASCII syntax and a less region-oriented introduction to Cyclone, \nsee the user s manual [6]. 2.1 Basic Operations In Cyclone, all memory is in some region, of which there \nare three kinds: A single heap region, which conceptually lives forever  Stack regions, which correspond \nto local-declaration blocks, as in C  Dynamic regions, which have lexically scoped lifetimes but permit \nunlimited allocation into them  Static data objects reside in the heap. Primitives malloc and new create \nnew heap objects. The new operation is like malloc except that it takes an expression and initial\u00adizes \nthe memory with it. There is no explicit mechanism for reclaiming heap-allocated objects (e.g., free). \nHowever, Cyclone programs may optionally link against the Boehm-Demers-Weiser conservative garbage collector \n[4] to reclaim unreachable heap-allocated objects implicitly. The interac\u00adtion of the collector with \nregions is discussed in Section 5. Stack regions correspond directly to C s local-declaration blocks: \nentering a block with local declarations creates stor\u00adage with a lifetime corresponding to the lexical \nscope of the block. Function parameters are in a stack region correspond\u00ading to the function s lifetime. \nIn short, Cyclone local dec\u00adlarations and function parameters have exactly the same layout and lifetime \nas in C. Dynamic regions are created with the construct region r{s},where r is an identi.er and s is \na statement. The region s lifetime is the execution of s.In s, r is bound to aregion handle, which primitives \nrmalloc and rnew use to allocate objects into the associated region. For example, rnew(r) 3 returns a \npointer to an int allocated in the re\u00adgion of handle r and initialized to 3. Handles are .rst-class values; \na caller may pass a handle to a function to allow it to allocate into the associated region. A prede.ned \nconstant heap_region is a handle for the heap. Like a declaration block, a dynamic region is deallocated \nprecisely when execution leaves the body of the enclosed statement. Execution can leave due to unstructured \njumps (continue, goto,etc.), a return, or via an exception. Sec\u00adtion 5 explains how we compile dynamic-region \ndeallocation. The region system imposes no changes on the represen\u00adtation of pointers or the meaning \nof operators such as &#38; and *. There are no hidden .elds or reference counts for maintaining region \ninformation at run-time. Pointers to ar\u00adrays of unknown size (denoted t ?) are implemented with extra \n.elds to support bounds-checks, but this design is or\u00adthogonal to regions. All the infrastructure for \npreventing dangling-pointer dereferences is in the static type system, making such dereferences a compile-time \nerror. 2.2 Basic Type System Region Annotations. All pointers point into exactly one region. In principle, \npointer types are annotated with the region name of the region they point into, though in practice we \neliminate most annotations. Ignoring subtyping, int*. describes a pointer to an int that is in the region \nwhose char?. strcpy<., .2>(char?. d, const char?.2 s); char?.H strdup<.>(const char?. s); char?. rstrdup<., \n.2>(region_t<.>,const char?.2 s); size_t strlen<.>(const char?. s); Figure 1: Cyclone string library \nprototypes name is .. The invariant that pointers have a particular region is the basic restriction we \nimpose to make the unde\u00adcidable problem of detecting dangling-pointer dereferences tractable. Pointer \ntypes with di.erent region names are dif\u00adferent types. A handle for a region corresponding to . has the \ntype region_t<.>. Region names fall into four categories. The region name for the heap is .H . A block \nlabeled L (e.g., L:{int x=0;s}) has name .L and refers to the stack region that the block creates. Similarly, \nthe arguments of a function f are stored in the stack region .f . Finally, the statement region r {s} \nde.nes region name .r for the created region. So r has type region_t<.r >. In all cases, the scope of \na region name corresponds to the lifetime of the corresponding region. We can now give types to some \nsmall examples. If e1 has type region_t<.> and e2 has type t ,then rnew (e1) e2 has type t *..If int \nx is declared in block L,then &#38;x has type int*.L. Similarly, if e has type t *.,then &#38;*e has \ntype t *.. Preventing dangling-pointer dereferences. To derefer\u00adence a pointer, safety demands that its \nregion be live. Our goal is to determine at compile-time that no code follows a dangling pointer. It \noften su.ces to ensure that pointer types region names are in scope. For example, this code is ill-typed: \n1. int*.L p; 2.L:{ int x =0; 3. p=&#38;x; 4. }  5.*p =42; The code creates storage for x at line 2 \nand deallocates it at line 4, so the assignment of &#38;x to p creates a dangling pointer that is dereferenced \nin line 5. Cyclone rejects this code be\u00adcause .L is not in scope when p is declared. If we change the \ndeclaration of p to another region, then the assignment p=&#38;x fails to type-check because &#38;x has \ntype int*.L. However, Cyclone s advanced features, notably existential and universal polymorphism, conspire \nto allow pointers to escape the scope of their regions, just as closures allow point\u00aders to escape in \nthe original Tofte-Talpin work. Therefore, in general, we cannot rely on simple scoping mechanisms to \nensure soundness. Instead, we must track the set of live re\u00adgion names at each control-.ow point. To \nkeep the analysis intraprocedural, we use a novel type-and-e.ects system to track interprocedural liveness \nrequirements. We delay the full discussion of e.ects until Section 3. Region Polymorphism. Functions \nin Cyclone are region\u00adpolymorphic; they can abstract the actual regions of their arguments or results. \nThat way, functions can manipulate pointers regardless of whether they point into the stack, the heap, \nor a dynamic region. Figure 1 presents some prototypes from the Cyclone string library, including strcpy, \nstrdup,and strlen, and a region\u00adallocating function rstrdup.The ? is Cyclone notation for a pointer to \na dynamically sized array. These functions all exhibit region polymorphism. In strcpy, the parameters \nregion names . and .2 are abstracted by the syntax <., .2>, meaning they can be instantiated with any \nactual region name when the function is called. So we can write code like: L:{ char buf[20]; strcpy<.L,.H \n>(buf,\"a heap pointer\"); } Here, the syntax <.L,.H > in the call instantiates .2 with the heap region \n.H and . with the stack region .L, allowing one to copy a string from the heap to the stack. Region polymorphism \ncan guarantee region equalities of unknown regions by using the same region names. For ex\u00adample, in strcpy \nthe region names of the .rst argument and the return value are the same, so the returned pointer must \npoint to the same region as the .rst argument. Region-name equalities are also important for dynamic \nregions. For exam\u00adple, the rstrdup function is a version of strdup that copies the source string into \na dynamic region. In its prototype, theregion nameof the returned value . matches the region name of \nthe dynamic region handle region_t<.>.In fact, we implement strdup by just calling rstrdup: char?.H strdup<.>(const \nchar?. s) { return rstrdup<.H ,.>(heap_region,s); } Polymorphic Recursion. It is often valuable to instanti\u00adate \nthe region parameters of a recursive function call with di.erent names than the function s own region \narguments. As an example, this contrived program has a function fact that abstracts a region . and takes \nas arguments a pointer into . and an integer. void fact<.>(int*. result, int n) { L: {int x =1; if(n \n> 1) fact<.L>(&#38;x,n-1); *result = x*n; } } int g= 0; int main() { fact<.H >(&#38;g,6); return g; \n} When executed, the program returns the value 720. In main,wepass fact a heap pointer (&#38;g), so \nthe type of fact is instantiated with .H for .. In contrast, the recursive call instantiates . with .L, \nwhich is the name of the stack region. At run time, the .rst call to fact modi.es g;eachrecursive call \nmodi.es the value of x in its caller s stack frame. Type De.nitions. Because struct de.nitions can contain \npointers, Cyclone allows these de.nitions to be parameter\u00adized by region names. For example, here is \na declaration for lists of pointers to ints: struct Lst<.1,.2>{ int*.1 hd; struct Lst<.1,.2>*.2 tl; }; \nIgnoring subtyping, a value of type struct Lst<.1,.2> is a list with hd .elds that point into .1 and \ntl .elds that point into .2. Other invariants are possible: If the type of tl were struct Lst<.2,.1>* \n.2, the declaration would char?. strcpy(char?. d, const char? s); char? strdup(const char? s); char?. \nrstrdup(region_t<.>,const char? s); size_t strlen(const char? s); Figure 2: Cyclone prototypes minimally-annotated \ndescribe lists where the regions for hd and tl alternated at each element. Type abbreviations using typedef \ncan also have region parameters. For example, we can de.ne region-allocated lists of heap-allocated pointers \nwith: typedef struct Lst<.H ,.>*. list_t<.>; 2.3 Subtyping Although the type system we have described \nthus far is quite powerful, it is not expressive enough in some cases. For example, it is common to de.ne \na local variable to al\u00adternatively hold the value of one of its arguments: void f<.1,.2>(int b, int*.1 \np1, int*.2 p2) { L: { int*.L p; if(b) p = p1; else p=p2; /* ... do something with p ... */} } It appears \nthat the program should fail to type-check be\u00adcause neither p1 nor p2 has type int*.L. If we change the \ntype of p to int*.1 or int*.2, then one of the assignments is illegal. To solve this problem, we observe \nthat if the region cor\u00adresponding to .1 outlives the region corresponding to .2, then it is sound to \nuse a value of type t*.1 whereweex\u00adpect one of type t*.2. Cyclone supports such coercions implicitly. \nThe last-in-.rst-out region discipline makes such outlives relationships common: when we create a region, \nwe know every region currently alive will outlive it. Simple sub\u00adtyping based on this outlives relationship \nallows the above program to type-check. Region-polymorphic functions can specify outlives rela\u00adtionships \namong their arguments with explicit preconditions that express partial orders on region lifetimes. In \npractice, we have very rarely used this feature, because the local out\u00adlives information has su.ced. \nTo ensure soundness, we do not allow casting t1*.to t2*., even if t1 is a subtype of t2, as this cast \nwould allow putting a t2 in a location where other code expects a t1.(This prob\u00adlem is the usual one \nwith covariant subtyping on references.) However, Cyclone does allow casts from t1*.to const t2*.2 when \nt1 is a subtype of t2. To ensure soundness, we must enforce read-only access for const values (unlike \nC). This support for deep subtyping, when combined with poly\u00admorphic recursion, is powerful enough to \nallow stack alloca\u00adtion of some recursive structures of arbitrary size. 2.4 Eliminating Annotations \nAlthough Cyclone is explicitly typed in principle, we use a combination of inference and well-chosen \ndefaults to reduce dramatically the number of annotations needed in practice. We emphasize that our approach \nto inference is purely in\u00adtraprocedural and that prototypes for functions are never inferred. Rather, \nwe use a default completion of partial prototypes to minimize region annotations. This approach permits \nseparate compilation. When writing a pointer type (e.g., int*), the region an\u00adnotation is always optional; \nthe compiler deduces an appro\u00adpriate annotation based on context: 1. For local declarations, a uni.cation-based \ninference en\u00adgine infers the annotation from the declaration s (in\u00adtraprocedural) uses. This local inference \nworks well in practice, especially when declarations have initializers. 2. Omitted region names in argument \ntypes are .lled in with fresh region names that are generalized implic\u00aditly. So by default, functions \nare region polymorphic without any region equalities. 3. In all other contexts (return types, globals, \ntype de.ni\u00adtions), omitted region names are .lled in with .H (i.e., the heap). This default works well \nfor global variables and for functions that return heap-allocated results. However, it fails for functions \nlike strcpy that return one of their parameters. Without looking at the func\u00adtion body, we cannot determine \nwhich parameter (or component of a parameter) the function might return.  In addition, when calling \na region-polymorphic function, the programmer can omit the explicit region-name instan\u00adtiation and the \ninference engine discovers it. As a result of these devices, our fact example can become annotation-free: \nvoid fact(int* result, int n) { intx =1; if(n > 1) fact(&#38;x,n-1); *result = x*n; } Put another way, \nthe function above, when treated as C code, ports to Cyclone with no modi.cation. Figure 2 shows the \nsame string-library functions as Figure 1, but minimally annotated. In all cases, the lack of a region \nannotation on the argument s means the type-checker would insert a fresh region name for the pointer \ntype, and generalize it. The lack of an annotation on the return type of strdup defaults to the heap. \nIn total, .ve region annotations were removed and all generalization became implicit. While the default \nannotations and inference engine reduce the burden on the programmer and make porting easier, it is still \nnecessary to put in some explicit annotations to express equalities necessary for safety. For example, \nif we write: void f2(int** pp, int* p) {*pp=p;} then the code elaborates to: void f2<.1,.2,.3>(int *.1*.2 \npp, int *.3 p) {*pp=p;} which fails to type-check because int*.1 int*.3.The = programmer must insert \nan explicit region annotation to assert an appropriate equality relation on the parameters: void f2(int*.* \npp, int*. p){*pp =p;} Finally, we employ another technique that greatly reduces annotations in practice, \nwith regard to type de.nitions. We can partially apply parameterized type de.nitions; elided arguments \nare .lled in via the same rules used for pointer types. Here is an aggressive use of this feature: typedef \nstruct Lst<.1,.2>*.2 l_t<.1,.2>; l_t heap_copy(l_t l) { l_t ans = NULL; for(l_t l2 = l; l2 != NULL; l2 \n= l2->tl) ans = new Lst(new *l2->hd,ans); return ans; } Because of defaults, the parameter type is l_t<.1,.2> \nand the return type is l_t<.H ,.H >. Because of inference, the compiler gives ans the type l_t<.H ,.H \n> (the return state\u00adment requires ans to have the function s return type) and l2 the type l_t<.1,.2> \n(l2 s initializer (l) has this type).  3. EFFECTS We argued in Section 2.2 that the scope restrictions \non re\u00adgion names prevent pointers from escaping the scope of their region. In particular, a function \nor block cannot return or assign a value of type t*.outside the scope of . s de.nition, simply because \nyou cannot write down a (well-formed) type for the result. Indeed, if Cyclone had no mechanisms for type \nabstraction, this property would hold. But if there is some way to hide a pointer s type in a result, \nthen the pointer could escape the scope of its region. For instance, if Cyclone had (upwards-escaping) \nclosures, then one could hide a pointer to a local variable in the closure s environment, and return \nthe closure outside the scope of the variable, thereby introducing a dangling pointer. This, in and of \nitself, is not a problem, but if the closure is later in\u00advoked, then it might dereference the dangling \npointer. This is the critical problem that Tofte and Talpin address for functional languages. Cyclone \ndoes not have closures, but it has other typing constructs that hide regions. In particular, Cyclone \nprovides existential types [22, 14], which su.ce to encode closures [21] and simple forms of objects \n[5]. Therefore, it is possible in Cyclone for pointers to escape the scope of their regions. To address \nthis problem, the Cyclone type system keeps track of the subset of region names that are considered live \nat each control-.ow point. Following Walker, Crary, and Morrisett [29], we call the set of live regions \nthe capability. To allow dereferencing a pointer, the type system ensures that the associated region \nname is in the capability. Simi\u00adlarly, to allow a function call, Cyclone ensures that regions the function \nmight access are all live. To this end, func\u00adtion types carry an e.ect that records the set of regions \nthe function might access. The idea of using e.ects to en\u00adsure soundness is due to Tofte and Talpin (hereafter \nTT). However, our treatment of e.ects di.ers substantially from previous work. The .rst major departure \nfrom TT is that we calculate default e.ects from the function prototype alone (instead of inferring them \nfrom the function body) in order to preserve separate compilation. The default e.ect includes the set \nof region names that appear in the argument or result types. For instance, given the prototype: int*.1 \nf(int*, int*.1*); which elaborates to: int*.1 f<.1,.2,.3>(int*.2, int*.1*.3); the default e.ect is {.1,.2,.3}. \nIn the absence of poly\u00admorphism, this default e.ect is a conservative bound on the regions the function \nmight access. As with region names in prototypes, the programmer can override the default with an explicit \ne.ect. For example, if f never dereferences its .rst argument, we can strengthen its prototype by adding \nan explicit e.ect as follows: int*.1 f(int*.2, int*.1*.3;{.1,.3}); In practice, we have found default \ne.ects extremely useful. Indeed, for the 110,000 lines of Cyclone code we have thus far, we have written \none non-default e.ect. The second major departure from TT is that we do not have e.ect variables. E.ect \nvariables are used by TT for three purposes: (1) to simulate subtyping in a uni.cation\u00adbased inference \nframework, (2) to abstract the set of regions that a closure might need to access, and (3) to abstract \nthe set of regions hidden by an abstract type. In our original Cyclone design, we tried to use TT-style \ne.ect variables. However, we found that the approach does not work well in an explicitly typed language \nfor two rea\u00adsons. First, the e.ect variables introduced by TT to support e.ect subtyping could occur \nfree in only one location, and all e.ect variables had to be prenex quanti.ed [26]. Their uni\u00ad.cation \nalgorithm depended crucially upon these structural invariants. In an explicitly typed language, we found \nthat enforcing these constraints was di.cult. Furthermore, the prenex quanti.cation restriction prevented \n.rst-class poly\u00admorphic functions, which Cyclone supports. Second, we needed e.ect variables in some \nlibrary inter\u00adfaces, making the libraries harder to understand and use. Consider, for instance, a type \nfor polymorphic sets: struct Set<a,.,E>{ list_t<a,.> elts; int (*cmp)(a,a; E); } A Set consists of a \nlist of a elements, with the spine of the list in region .. We do not know where the elements are allocated \nuntil we instantiate a. The comparison function cmp is used to determine set membership. Because the \ntype of the elements is not yet known, the type of the cmp function must use an e.ect variable E to abstract \nthe set of regions that it might access when comparing the two a values. And this e.ect variable, like \nthe type and region variable, must be abstracted by the Set structure. Suppose the library exports the \nSet structure to clients abstractly (i.e., without revealing its de.nition): struct Set<a,.,E>; The client \nmust somehow discern the connection between a and E,namely that E is meantto abstractthe setof regions \nwithin a that the hidden comparison function might access. 3.1 Avoiding Effect Variables To simplify \nthe system while retaining the bene.t of e.ect variables, we use a type operator, regions_of(t).This \nnovel operator is just part of the type system; it does not existatrun time. Intuitively, regions_of(t) \nrepresents the set of regions that occur free in t.In particular: regions_of(int) = \u00d8 regions_of(t*.) \n= {.} .regions_of(t) regions_of((t1,...,tn) .t)= regions_of(t1) .\u00b7\u00b7\u00b7.regions_of(tn) .regions_of(t) For \ntype variables, regions_of(a) is treated as an abstract set of region variables, much like e.ect variables. \nFor ex\u00adample, regions_of(a*.) = {.} . regions_of(a).The default e.ect of a function that has a in its \ntype simply includes regions_of(a). With the addition of regions_of, wecan rewritethe Set example as \nfollows: struct Set<a, .>{ list_t<a,.> elts; int (*cmp)(a,a; regions_of(a)); } Now the connection between \nthe type parameter a and the comparison function s e.ect is apparent, and the data struc\u00adture no longer \nneeds to be parameterized by an e.ect vari\u00adable. Moreover, regions_of(a) is the default e.ect for int \n(*cmp)(a,a), so we need not write it. Now suppose we wish to build a Set<int*.1,.2> value using a particular \ncomparison function: int cmp_ptr<.1>(int*.1 p1, int*.1 p2) { return (*p1) == (*p2); } Set<int*.1,.2> \nbuild_set(list_t<int*.1 ,.2>e){ return Set{.elts = e, .cmp = cmp_ptr<.1>}; } The default e.ect for cmp_ptr \nis {.1}. After instantiating a with int*.1, the e.ect of cmp becomes regions_of(int*.1 ), which equals \n{.1}. As a result, the function build_set type\u00adchecks. In fact, using any function with a default e.ect \nwill always succeed. Consequently, programmers need not ex\u00adplicitly mention e.ects when designing or \nusing libraries. In addition, unifying function types becomes somewhat easier with default e.ects because, \ngiven the same argument and result types, two functions have the same default e.ect. 3.2 Interaction \nwith Existential Types As mentioned above, Cyclone supports existential types, which allow programmers \nto encode closures. For example, we can give a type for call-backs that return an int: struct IntFn .a \n{ int (*func)(a env); a env;}; Here, the call-back consists of a function pointer and some abstracted \nstate that should be passed to the function. The a is existentially bound: Various objects of type struct \nIntFn can instantiate a di.erently. When a struct IntFn object is created, the type-checker ensures there \nis a type for a such that the .elds are initialized correctly. To access the .elds of an existential \nobject, we need to open them by giving a name to the bound type variable. For example, we can write (in \nadmittedly alien syntax): int apply_intfn(struct IntFn pkg) { let IntFn{<\u00df> .func = f,.env = y} = pkg; \nreturn f(y); } The let form binds f to pkg.func with type int (*)(\u00df) and y to pkg.env with type \u00df. So \nthe function call appears well-typed. However, the e.ect for f is regions_of(\u00df) and we have no evidence \nthat these regions are still live, even though \u00df is in scope. Indeed, the regions may not be live as \nthe following code demonstrates: int read<.>(int*. x) { return *x; } struct IntFn dangle() { L:{int x \n= 0; struct IntFn ans = {<int*.L> .func = read<.L>, .env = &#38;x}; return ans; } } Here, the abstracted \ntype a is instantiated with int*.L be\u00adcause the call-back s environment is a pointer to an int in region \n.L. The function for the call-back just dereferences the pointer it is passed. When packaged as an existential, \nthe int*.L is hidden and thus the result is well-typed de\u00adspite the fact that the call-back has a dangling \npointer. In short, to use struct IntFn objects, we must leak enough information to prove a call is safe. \nRather than re\u00adsorting to e.ect variables, we give regions_of(a) a bound: struct IntFn<.> .a:>. { ... \n}; The bound means regions_of(a) must all outlive .;the type-checker rejects an instantiation of a in \nwhich the bound may not hold. Therefore, if pkg has type struct IntFn<.>, then we can call f so long \nas . is live. In practice, bounds reduce the e.ect of a call-back to a single region.  4. FORMAL SOUNDNESS \nIn a separate technical report [15], we have de.ned an operational model of Core Cyclone, formalized \nthe type sys\u00adtem, and proven type soundness. Space constraints prevent us from including the material \nhere, so we summarize the salient details. Core Cyclone includes all of the features relevant to mem\u00adory \nmanagement, including stack allocation, dynamic re\u00adgions, polymorphism, and existential types. The operational \nsemantics is a small-step, deterministic rewriting relation (.) from machine states to machine states. \nA machine state is a triple (G, S, s) consisting of a garbage stack G, astack S, and a statement s. The \nstacks are lists mapping region names (.)to regions (R), whichinturnare maps from locations (x)to values \n(v). The garbage stack G is a technical device to record the deallocated storage so that the program \nstays closed despite dangling pointers. Note, however, that the abstract machine becomes stuck if the \nprogram attempts to read or write a location in the garbage stack. The primary goal of the formalism \nis to prove that well-typed programs cannot get stuck, so the garbage stack (the deallocated regions) \nneed not exist during execution. 4.1 Syntax Figure 3 gives BNF de.nitions for the syntax of the state\u00adments, \nexpressions, and types for Core Cyclone. Construc\u00adtors (t ) de.ne syntax for both types and regions. \nWe use a kind discipline to determine whether a type variable repre\u00adsents a type (T ) or a region (R). \nTypes include pairs (t1\u00d7t2) to model structs. Like structs, pairs are passed by value (i.e., copied). \nWe do not dupli\u00adcate polymorphic code, so pair types cannot instantiate type variables because their \nvalues are larger than those of other types (i.e., they are at least two words). Types also include type \nvariables, universal types, and existential types. The quanti.ers can range over types or regions and \ninclude re\u00adgion constraints, which are used to specify partial orders on region lifetimes. A region constraint \n(.)is a listof primitive kinds . ::= T|R type andregionvars a,. region sets E ::= a1 .\u00b7\u00b7\u00b7.an .{.1,...,.m}region \nconstraints . ::= \u00d8|., E<: . :constructors t ::= a|int |t1 .t2 |t1 \u00d7t2 |t *.|handle(.) |.a:.C..t |.a:.C..t \nexpressions e ::= x. |v |e(t)|(e1,e2) |e.i|*e|rnew(e1)e2 |e1(e2) |&#38;e|e1 = e2 |pack [t1,e] as t2 values \nv ::= i|f |&#38;p|region(.) |(v1,v2) |pack [t1,v] as t2 paths p ::= x. |p.i : functions f ::= .:(t1 \nx.) .t2 = {s}|.a:.C..f statements s ::= e|return e|s1; s2 |if (e) s1 else s2 |while (e) s|.:{tx. = e; \ns}|region(.)x. s|.:{open [a,x.]= e; s}|spop[.] Figure 3: Abstract Syntax of Core Cyclone constraints \nof the form E<: . where E is a region set, and . is a region. Intuitively, the constraint means that \nif . is live, then any of the regions in Eare live. Region sets can in\u00adclude region variables (.)or the \nregions_of atypevariable. (We omit the regions_of for conciseness.) Finally, function types include a \nregion set (E), which speci.es the function s e.ect (i.e., the set of regions that must be live before \ncalling the function). Statements consist of expressions, return statements, com\u00adposition, if statements, \nand while statements. In addition, they include blocks (. : {tx. = e; s}) for declaring a new stack region \nand a variable within that region, dynamic\u00adregion declarations (region(.)x. s), and a form for opening \nvalues of existential type. Finally, statements include a spe\u00adcial form spop[.] that, when executed, \nevaluates s to a terminal state and then deallocates (moves to the garbage stack) the region .. This \nform is not available to source programs; it is used internally by the abstract machine as a marker to \nindicate when to deallocate a region. Expressions include variables x., which double as loca\u00adtions. Each \nvariable x lives in a given region .; formally x. makes this fact explicit. Other expressions are integers, \nfunctions, pointer dereference, function calls, the address-of operator, and assignment as in C. In addition, \nexpressions include type instantiation, pairs, projection, rnew,and ex\u00adistential packages. Lastly, region \nhandles (region(.)) are a special form not available to source programs; creating a dynamic region with \nregion(.)x. s binds x. to region(.). Rather than model individual memory locations, paths provideasymbolic \nway torefer toacomponent of acom\u00adpound object. For instance, if the location x. contains the value ((3,4),(5,6)), \nthen the path x..1 refers to (3,4), and x..1.2 refers to 4. As in C, if p is a path, then &#38;p is a \nvalue.  4.2 Static Semantics The most important typing judgment is the one for state\u00adments. It has the \nform: .; G; .; E; t fstmt s Here, . records the type and region variables that are in scope, G records \nthe value variables in scope and their types, . records partial-order constraints relating region lifetimes, \nE records the capability (i.e., which regions in . are con\u00adsidered live), and t records the type that \ne must have in any statement of the form return e. We present just a few interesting rules. Type-checking \nstatements requires checking that expres\u00adsions have the correct types. For example, the rule for return \nstatements is: .; G; .; E fe: t .; G; .; E; t fstmt return e Expressions must access only memory that \ncan be proven live from E and .. Here are two example rules: . fE.. .; G; .; E fe: t *.. fE .. .; G; \n.; Efx. :G(x.) .; G; .; E f*e: t We use . fE .. to prove . is live. Informally, we need a .' .E such \nthat the partial order . shows . outlives .'.Of course, ..E su.ces. We use the same idea for our subsumption \nrule: .; G; .; Efe: t *.1 . f.2 ..1 .; G; .; Efe: t *.2 To type-check function calls, we use . fE .E1 \nto mean every a and . in E1 can beproven livefrom E and ..The rule is otherwise standard: :1 .; G; .; \nE fe1 : t2 .t .; G; .; Efe2 : t2 . fE .E1 .; G; .; Efe1(e2): t Here is the rule for type instantiation: \n.; G; .; E fe: .a:.C.1.t2 . ft1 : .. f.1[t1/a] .; G; .; Efe(t1): t2[t1/a] The only novelty is ensuring \nthat . establishes the con\u00adstraints .1 used when type-checking e. The judgment . f.' just means for every \nE<: .in .',we can show . f..E.By abuse of notation, we write t2[t1/a] for the capture-avoiding substitution \nof t1 for a in t2 and .1[t1/a] for the substitu\u00adtion of regions of(t1)for a in .1. Another necessary \njudgment for statements is fret s It ensures that if execution of s terminates, then the ter\u00adminal state \nwill have the form return v for some value v. This judgment, de.ned via a simple syntax-directed analy\u00adsis, \nenforces that functions must not fall o. they always return values. To set up the proof of soundness, \nwe de.ne a judgment to assert that a garbage stack G and stack S can be described by the context .; G; \n.: fheap (G, S) : .;G; . Here, . is the set of region names that are bound in either G or S; G records \nthe types of the locations bound in either G or S;and . records the regions relative lifetimes. In par\u00adticular, \n. describes the total order of the regions in S.This judgment is used to connect assumptions that a statement \nmight make with the reality of the current heap. With these judgments, we can state the Soundness Theo\u00adrem \nfor Core Cyclone: Theorem 4.1 (Soundness). If: 1. fheap (\u00d8, [.H . . R]) : .;G; ., 2. fret s, 3. .; G; \n.; {.H };int fstmt s,and 4. s contains no pop statements  then either (G, S, s) runs forever or there \nexists a G ' , R ' and i such that (G, [.H .(G ' , [.H . R ' ], return i). . R],s) . * . In plain English, \nif we start with an empty garbage heap, and a stack that contains a single heap region ([.H . . R]) that \nis well-formed, and if statement s doesn t fall o., and s is well-formed with respect to the type of \nthe initial heap and returns only integers, and s does not contain pop statements, then the program cannot \nget stuck from type errors or dangling-pointer dereferences. Furthermore, if the program terminates, \nall of the regions it allocated will have been freed and the program will return an integer. The soundness \nproof, available in our companion techni\u00adcal report [15], uses long and tedious progress and preserva\u00adtion \n(subject-reduction) lemmas. Here we just sketch two complications from the proof of preservation. First, \nour operational semantics uses type substitution, for example (G, S, (.a:.C ..f)(t )) . (G, S, f[t/a]). \nAs usual, we need a substitution lemma in order to conclude the well-typedness of f[t/a] given the well-typedness \nof .a:.C..f.Because of explicit e.ects and partial orders, proving the necessary substitution lemma requires \nseveral auxiliary lemmas, for example . f E1 . E2 implies .[E3/a] f E1[E3/a] . E2[E3/a]. Second, we must \nweaken the theorem s assumptions that the heap has one region and s has no pop statements, while still \nproving that the program properly deallocates all the regions it allocates. To do so, we assume that \ngiven (G, S, s), we can partition S into S1S2 such that s deallocates all re\u00adgions in S2 (in last-in-.rst-out \norder) and none of the regions in S1. (To see this assumption is a proper weakening, let S1 =[.H .= . \nR]and S2 \u00d8.) This assumption (formalized as another judgment on statements) implies enough about the \nposition of pop statements in s to prove that the pro\u00adgram s ' resulting from a rewriting step properly \ndeallocates exactly all of the live regions not in S1. In other words, the ability to partition S such \nthat the necessary properties hold is preserved under evaluation.  5. IMPLEMENTING CYCLONE REGIONS The \ncode-generation and run-time support for Cyclone regions is very simple. Heap and stack manipulation \nare exactly as in C. Dynamic regions are represented as linked lists of pages where each page is twice \nthe size of the pre\u00advious one. A region handle points to the beginning of the list and the current allocation \npoint on the last page, where rnew or rmalloc place the next object. If there is insu.\u00adcient space for \nan object, a new page is allocated. Region deallocation simply frees each page of the list. When the \ngarbage collector is included, dynamic-region list pages are acquired from the collector. The collector \nsupports explicit deallocation, which we use to free regions. It is important to note that the collector \nsimply treats the region pages as large objects. As they are always reachable from the stack, they are \nscanned and any pointers to heap\u00adallocated objects are found, ensuring that these objects are preserved. \nThe advantage of this interface is its simplicity, but at some cost: At collection time, every object \nin every dynamic region appears reachable, and thus all (live) dy\u00adnamic regions must be scanned, and \nno objects within (or reachable from) dynamic regions are reclaimed. The code generator ensures that \nregions are deallocated even when their lifetimes end due to unstructured control .ow. For each intraprocedural \njump or return,it is easy to determine statically how many regions should be deallocated before transferring \ncontrol. When throwing an exception, the number of regions to deallocate is not known statically. Therefore, \nwe store region handles and exception handlers in an integrated list that operates in a last-in-.rst-out \nmanner. When an exception is thrown, we traverse the list deallocat\u00ading regions until we reach an exception \nhandler. We then transfer control with longjmp. In this fashion, we ensure that a region is always deallocated \nwhen control returns.  6. EXPERIMENTAL RESULTS To simplify porting to and programming in Cyclone, we \nhave sought to minimize the number of required region an\u00adnotations. Just as important, we have sought \nto achieve good performance. In Sections 6.1 and 6.2, we analyze the burden of porting, in terms of added \nannotations, and .nd that annotations impose negligible burden on the applica\u00adtion writer, but a somewhat \nlarger burden on the library writer. In Section 6.3, we present a comparison of Cyclone s performance \nto that of C for our ported applications, and .nd that while networking programs essentially perform \nthe same as C, compute-bound applications are up to a factor of three slower due to run-time checks and \npointer represen\u00adtations. 6.1 Porting Application Code We ported a number of applications and compared \nthe di.erences in source code between the original and the Cy\u00adclone version. We picked several networking \napplications because they are part of the systems domain in which controlling data representation is \nimportant. These include a web server (mini_httpd), some web utilities (http_get, http_post, http_ping,and \nhttp_load), and a simple client (finger). We also used some computationally intense, older C applications \nthat make heavy use of arrays and pointers; these include cfrac, grobner,and tile. Finally, we ported \nthe compression utilities cacm and ncompress. We took two approaches to porting. First, we changed all \nthe programs as little as possible to make them correct Cyclone programs. Then, for cfrac and mini_httpd,we \nregionized the code: We made functions more region poly\u00admorphic and, where possible, eliminated heap \nallocation in Program LOC C Cyc di.s annotatotal tions lines cacm 340 360 41 0 0 cfrac 4218 4215 134 \n2 2 .nger 158 161 17 3 3 grobner 3260 3401 452 71 40 http get 529 530 44 4 4 http load 2072 2058 121 \n15 13 http ping 1072 1082 33 1 1 http post 607 609 51 8 8 matxmult 57 53 11 3 1 mini httpd 3005 3027 \n266 4 4 ncompress 1964 1986 134 10 9 tile 1345 1365 148 2 2 total 18627 18847 1452 124 86 regionized \nbenchmarks cfrac 4218 4192 503 158 107 mini httpd 3005 2986 531 88 54 total 7223 7178 1034 246 161 Table \n1: Benchmark code di.erences favor of dynamic region allocation with rnew. We also added compiler-checked \nnot null annotations to pointer types where possible to avoid some null checks. Our results are summarized \nin Table 1. For each pro\u00adgram, Table 1 shows the number of lines of C and Cyclone code, the number of \ndi.erences between the two, and the region annotations required in Cyclone. The di.s column indicates \nthe number of lines added or changed in porting from C to Cyclone. For the annotations, the total column \nis the number of individual region-related alterations, includ\u00ading per-variable annotations and occurrences \nof region r {s} and rnew.The lines column is the total number of lines in the .le that changed due to \nthese annotations. There are two interesting results regarding the di.culty of minimal porting. First, \nthe overall changes in the programs are relatively small less than 10% of the program code needed to \nbe changed. The vast majority of the di.erences arise from pointer-syntax alterations. These changes \nare typically easy to make e.g., the type of strings are changed from char * to char ?. We are currently \nexperimenting with interpreting char * as a safe null-terminated string type by default; doing so allows \nmany fewer changes. The most encouraging result is that the number of region annotations is small: only \n124 changes (which account for roughly 6% of the total changes) in more than 18,000 lines of code. The \nmajority of these changes were completely triv\u00adial, e.g., many programs required adding .H annotations \nto argv so that arguments could be stored in global variables. The program that required the most changes \nwas grobner. Interestingly, the majority of these changes arose from the fact that in one place a stack \npointer was being stored in a struct type. We therefore parameterized the struct de.ni\u00adtion with a region \nvariable, and this parameterization then propagated through the rest of the code. However, the de\u00adfault \nannotation still worked in many cases: out of 133 total variable declarations of the parameterized struct \ntype, only 38 required annotations. The cost of porting a program to use dynamic regions was also reasonable; \nin this case roughly 13% of the total di.er\u00adences were region-related. For the web server, we were able \nto eliminate heap allocation entirely. Because it is event- LOC proto rnew region string.h 139 57 0 0 \nstring-max.h 139 135 0 0 string.cyc 739 68 14 2 list.h 364 85 0 0 list-max.h 364 171 0 0 list.cyc 819 \n74 38 0 Table 2: Region annotations in libraries driven, handling each request as it comes in, we changed \nthe main handler function to create a dynamic region and then pass the region handle to its subroutines \nin a request structure. After the request is serviced, the region is freed. The majority of the overall \nchanges arose from moving global variables into the request structure and adding the structure as a parameter \nto various functions. This request structure is parameterized by a region, so many of the functions need \nannotations to connect the region of the request structure to that of another argument or return value. \nWe were less successful in regionizing cfrac.As in the web server, we changed many functions to allocate \nusing region-handle parameters. It was easy to do dynamic region allocation and deallocation as part \nof the algorithm s main iteration, but for large inputs, it was di.cult to keep regions from growing \nlarge before deallocation. We conclude that garbage collection is a better match for this code, but others \nhave had more success with regions [12].  6.2 Porting Library Code We have ported a signi.cant subset \nof the C and Caml libraries to Cyclone. Two illustrative cases are the Cyclone list and string libraries, \nported from Caml and C respec\u00adtively. Table 2 summarizes the region annotations in the in\u00adterfaces and \nimplementations of these libraries. As a rough measure of the e.ectiveness of default region annotations, \nwe also provide results for maximally annotated versions of the interfaces (list-max.h and string-max.h, \nrespectively). The proto column lists the number of region type annota\u00adtions that were necessary in function \nprototypes; the rnew column lists the number of uses of rnew,and the region col\u00adumn lists the number \nof uses of dynamic regions. We found that library code requires more region annota\u00adtions than application \ncode, but most of these annotations are for the sake of convenience and generality rather than necessity. \nLibrary functions that perform allocation often come in two .avors: a heap allocating function that has \nthe same signature as the corresponding C or Caml function, and a version that takes an additional region \nhandle for gen\u00aderality; most annotations occur in the latter. Most of the changes are to function prototypes; \nno explicit region anno\u00adtations were necessary in the bodies of functions. The max\u00adimally annotated interfaces \nrequire 2 2.4 times more region annotations; that is, the default region annotations su.ce 50 60% of \nthe time. Most of the non-default region anno\u00adtations were needed to express a same-region relationship \nbetween arguments and return types or to allow the func\u00adtion to allocate into an arbitrary region; the \nremainder were needed in type de.nitions. Moreover, no e.ect annotations whatsoever were necessary. Most \nimportantly, our applications, such as the compiler, use the libraries extensively and region instantiation \nis im\u00ad Test Ctime(s) Cyclone time checked(s) factor unchecked(s) factor cacm 0.12 \u00b1 0.00 0.15 \u00b1 0.00 \n1.25\u00d7 0.14 \u00b1 0.00 1.17\u00d7 cfrac 2.30 \u00b1 0.00 5.57 \u00b1 0.01 2.42\u00d7 4.77 \u00b1 0.01 2.07\u00d7 .nger 0.54 \u00b1 0.42 0.48 \n\u00b1 0.15 0.89\u00d7 0.53 \u00b1 0.16 0.98\u00d7 grobner 0.03 \u00b1 0.00 0.07 \u00b1 0.00 2.85\u00d7 0.07 \u00b1 0.00 2.49\u00d7 http get 0.32 \n\u00b1 0.03 0.33 \u00b1 0.02 1.03\u00d7 0.32 \u00b1 0.06 1.00\u00d7 http load 0.16 \u00b1 0.00 0.16 \u00b1 0.00 1.00\u00d7 0.16 \u00b1 0.00 1.00\u00d7 \nhttp ping 0.06 \u00b1 0.02 0.06 \u00b1 0.02 1.00\u00d7 0.06 \u00b1 0.01 1.00\u00d7 http post 0.04 \u00b1 0.01 0.04 \u00b1 0.00 1.00\u00d7 0.04 \n\u00b1 0.01 1.00\u00d7 matxmult 1.37 \u00b1 0.00 1.50 \u00b1 0.00 1.09\u00d7 1.37 \u00b1 0.00 1.00\u00d7 mini httpd-1.15c 2.05 \u00b1 0.00 2.09 \n\u00b1 0.00 1.02\u00d7 2.09 \u00b1 0.00 1.02\u00d7 ncompress-4.2.4 0.14 \u00b1 0.01 0.19 \u00b1 0.00 1.36\u00d7 0.18 \u00b1 0.00 1.29\u00d7    \nCompiled with the garbage collector regionized benchmarks cfrac 2.30 \u00b1 0.00 5.22 \u00b1 0.01 2.27\u00d7 4.56 \u00b1 \n0.01 1.98\u00d7 mini httpd 2.30 \u00b1 0.00 2.35 \u00b1 0.00 1.02\u00d7 2.35 \u00b1 0.00 1.02\u00d7 Table 3: Benchmark performance \nplicit throughout them. The vast majority of library calls in ported C code require no changes; malloc, \nrealloc, memcpy, etc., are essentially the only exceptions.  6.3 Performance Table 3 shows the performance \nof the original C versions of our benchmark programs together with the Cyclone ver\u00adsions with or without \nbounds-checks and null-checks. We ran each benchmark twenty-one times on a 750 MHz Pen\u00adtium III with \n256MB of RAM, running Linux kernel 2.2.16\u00ad12, using gcc 2.96 as a back end. The gcc optimization .ags \nused for compiling both the original C code and the output of the Cyclone compiler were -O3 -march=i686.Because \nwe observed skewed distributions for the http benchmarks, we report medians and semi-interquartile ranges \n(SIQR).1 For the non-web benchmarks (and some of the web bench\u00admarks) the median and mean were essentially \nidentical, and the standard deviation was at most 2% of the mean. The factor columns for the Cyclone \nprograms show the slowdown factor relative to the C versions. We achieve near-zero overhead for network \nor I/O bound applications such as the http clients and servers, but we pay a substantial penalty for \ncompute-intensive benchmarks; the worst is grobner, which is almost a factor of three slower than the \nC version. We have seen slowdowns of a factor of six in pathological scenarios involving pointer arithmetic \nin some microbenchmarks. Two common sources of overhead in safe languages are garbage collection and \nbounds checking. Garbage-collection overhead is not easy to measure in Cyclone, because re\u00adgionizing \na program can require signi.cant work. As shown in Table 3, only a few of our benchmarks needed garbage \ncollection. Pro.ling the garbage collected version of cfrac suggests that garbage collection accounts \nfor approximately half of its overhead. Partially regionizing cfrac resulted in an 6% improvement. On \nthe other hand, http_load and tile make relatively little use of dynamic allocation, so they have almost \nno garbage-collection overhead. Therefore, we 1The semi-interquartile range is the di.erence between \nthe high quartile and the low quartile divided by 2. This is a measure of variability, similar to standard \ndeviation, recommended by Jain [18] for skewed distributions. expect that the overhead will vary widely \nfor di.erent pro\u00adgrams depending on their memory-usage patterns. As Table 3 demonstrates, bounds-checks \nare also an im\u00adportant component of the overhead, but less than we ex\u00adpected. We found that a major cost \nis due to the repre\u00adsentation of fat pointers. A fat pointer is represented with three words: the base \naddress, the bounds address, and the current pointer location (essentially the same representation used \nby McGary s bounded pointers [20]). The result is a larger space overhead, larger cache footprint, more \nparame\u00adter passing and return-value copying, and increased register pressure, especially on the register-impoverished \nx86. Because fat pointers are currently the only pointer types in Cyclone that support pointer arithmetic \nand dynamically sized arrays, good fat-pointer performance is crucial to many Cyclone programs. We found \nthat slight changes to fat pointer operations and gcc .ags relating to instruction selec\u00adtion could have \na huge impact on performance. In particular, replacing inlined pointer operations with macros and setting \nthe architecture-speci.c instruction-selection .ag properly doubled the speed of some applications. \n 7. RELATED WORK In this paper, we have concentrated on the region-based type system for Cyclone, which \nnaturally supports C-style stack allocation, conventional heap allocation, and dynamic region allocation. \nWe feel that Cyclone is a unique and promising point in the programming-language design-space, but many \nother systems share some features with Cyclone. Making C Safe. Many systems, including but certainly \nnot limited to LCLint [10, 9], SLAM [3], Safe-C [2], and CCured [25], aim to make C code safe. Some of \nthese sys\u00adtems, such as LCLint, are meant to be static bug-.nding tools. Like Cyclone, they usually require \nrestricted coding idioms or additional annotations, but unlike Cyclone, they o.er no soundness guarantees. \nIn this way, these static tools reduce false positives. In contrast, Cyclone uses a combina\u00adtion of a \nstatic type system (for memory management) and run-time checks (for bounds violations) to minimize false \npositives. Other systems, such as Safe-C and CCured, ensure sound\u00adness by rewriting the code and adding \nrun-time checks, at least whenever an implementation-dependent static analy\u00adsis cannot eliminate the \nchecks. The primary advantage of these systems is that they require (almost) no changes to the C code, \nunlike Cyclone. However, they do not pre\u00adserve the same data representations and lifetimes for ob\u00adjects. \n(Cyclone s t ? pointers also use a wide representa\u00adtion, but the use of these pointers is under programmer \ncontrol.) Furthermore, memory errors are caught at run time instead of compile time. For instance, when \nan object is freed under CCured, the (entire) storage is not immedi\u00adately reclaimed, but rather marked \nas inaccessible. Subse\u00adquent accesses check the mark and signal an error when the object is dereferenced. \nUltimately, the mark is reclaimed with a garbage collector to avoid leaks. Moreover, CCured may move \nsome stack-allocated objects to the heap to avoid dangling-pointer dereferences. Static Regions. Tofte \nand Talpin s seminal work [28] on implementing ML with regions provides the foundation for regions in \nthe ML Kit [27]. Programming with the Kit is convenient, as the compiler automatically infers all region \nannotations. However, small changes to a program can have drastic, unintuitive e.ects on object lifetimes. \nThus, to pro\u00adgram e.ectively, one must understand the analysis and try to control it indirectly by using \ncertain idioms [27]. More recent work for the ML Kit includes optional support for garbage collection \nwithin regions [16]. A number of extensions to the basic Tofte-Talpin frame\u00adwork can avoid the constraints \nof LIFO region lifetimes. As examples, the ML Kit includes a reset-region primitive [27]; Aiken et al. \nprovide an analysis to free some regions early [1]; and Walker et al. [29, 30] propose general systems \nfor free\u00ading regions based on linear types. All of these systems are more expressive than our framework. \nFor instance, the ideas in the Capability Calculus were used to implement type-safe garbage collectors \nwithin a language [31, 23]. However, these systems were not designed for source-level programming. They \nwere designed as compiler intermediate languages or analyses, so they can ignore issues such as minimizing \nan\u00adnotations or providing control to the user. Two other recent projects, Vault [7] and the work of Hen\u00adglein \net al. [17] aim to provide safe source-level control over memory management using regions. Vault s powerful \ntype system allows a region to be freed before it leaves scope and its types can enforce that code must \nfree a region. To do so, Vault restricts region aliasing and tracks more .ne\u00adgrained e.ects. As a result, \nprogramming in Vault requires more annotations. Nevertheless, we .nd Vault an extremely promising direction \nand hope to adapt some of these ideas to Cyclone. Henglein et al. [17] have designed a .exible region \nsystem that does not require LIFO behavior. However, the system is monomorphic and .rst-order; it is \nunclear how to extend it to support polymorphism or existential types. Finally, both TAL [24] and the \nMicrosoft CIL [13] provide some support for type-safe stack allocation. But neither sys\u00adtem allows programmers \nto mix stack and heap pointers, and both systems place overly strong restrictions on how stack pointers \ncan be used. For instance, the Microsoft CIL pre\u00advents such pointers from being placed in data structures \nor returned as results features that language implementors need for e.ective compilation [8]. Regions \nin C. Perhaps the most closely related work is Gay and Aiken s RC [12] compiler and their earlier system, \nC@ [11]. As they note, region-based programming in C is an old idea; they contribute language support \nfor e.cient refer\u00adence counting to detect if a region is deallocated while there remain pointers to it \n(that are not within it). This dynamic system has no apriori restrictions on regions lifetimes and a \npointer can point anywhere, so the RC approach can en\u00adcode more memory-management idioms. Like Cyclone, \nthey provide pointer annotations. These annotations are never required, but they are often crucial for \nperformance because they reduce the need for reference counting. One such an\u00adnotation is very similar \nto our notion of region subtyping. RC uses reference counting only for dynamic regions. In fact, one \nannotation enforces that a pointer never points into a dynamic region, so no reference counting is needed. \nAs a result, RC allows dangling pointers into the stack or heap. Other kinds of type errors also remain. \nIndeed, we found a number of array-bounds bugs in two of the benchmarks used to evaluate RC: grobner \nand tile. Finally, RC cannot support the kind of polymorphism that Cyclone does be\u00adcause the RC compiler \nmust know statically which objects are pointers. In summary, some of these systems are more convenient \nto use than Cyclone (e.g., CCured and the MLKit) but take away control over memory management. Some of \nthe static systems (e.g., the Capability Calculus) provide more pow\u00aderful region constructs, but were \ndesigned as intermediate languages and do not have the programming convenience of Cyclone. Other systems \n(e.g., RC, Safe-C) are more .exible but o.er no static guarantees. 8. FUTURE WORK A great deal of work \nremains to achieve our goals of pro\u00advidingatooltomove legacy codetoatype-safe environment easily and \nproviding a type-safe language for building sys\u00adtems where control over data representations and memory \nmanagement is an issue. In the near future, we hope to incorporate support for deallocating dynamic regions \nearly. We have experimented brie.y with linear type systems in the style of the Capability Calculus or \nVault, but have found that this approach is gen\u00aderally too restrictive, especially in the context of \nexceptions. Instead, we are currently developing a traditional intrapro\u00adcedural .ow analysis to track \nregion aliasing and region life\u00adtimes. Again, for the interprocedural case, we expect to add support \nfor explicit annotations, and to use experimental evidence to drive the choice of defaults. We also expect \nto incorporate better support for .rst-class regions, in the style of RC. The goal is to give programmers \na su.cient range of options that they can use the statically checked regions most of the time, but fall \nback on the dy\u00adnamically checked regions when needed. In addition to enhancements to the region system, \nwork is needed in other areas. For instance, we have seen run-time overheads ranging from 1x to 3x for \nthe benchmarks pre\u00adsented here, and overheads as high as 6x for some compute\u00adintensive microbenchmarks. \nWe are currently working to identify the bottlenecks, but a clear problem is with our representation \nof pointers to dynamically sized arrays (? pointers). To support dynamically sized arrays and bounds\u00adchecks, \nwe tag such arrays with implicit size information. Similarly, to support type-safe, discriminated unions, \nwe add implicit tags. We are adapting ideas from DML [33] and Xanadu [32] to make these tags explicit \nso that pro\u00adgrammers can control where these tags are placed. We hope doing so will make it easier to \ninterface with legacy C code or devices that do not expect these tags on the data, and to support time-saving \nand space-saving optimizations. How\u00adever, we have found that the DML framework does not easily extend \nto imperative languages such as Cyclone. In partic\u00adular, there are subtle issues involving existential \ntypes and the address-of (&#38;) operator [14]. Acknowledgments We would like to thank David Walker for \nfruitful discussions, and Steve Zdancewic and Je. Vinocur for proofreading this manuscript. 9. REFERENCES \n[1] A. Aiken, M. F\u00a8ahndrich, and R. Levien. Better static memory management: Improving region-based analysis \nof higher-order languages. In ACM Conference on Programming Language Design and Implementation,pages \n174 185, La Jolla, CA, 1995. [2] T. M. Austin, S. E. Breach, and G. S. Sohi. E.cient detection of all \npointer and array access errors. In ACM Conference on Programming Language Design and Implementation, \npages 290 301, Orlando, FL, June 1994. [3] T. Ball and S. K. Rajamani. Automatically validating temporal \nsafety properties of interfaces. In SPIN 2001, Workshop on Model Checking of Software, volume 2057 of \nLecture Notes in Computer Science, pages 103 122, Toronto, Canada, May 2001. Springer-Verlag. [4] H.-J. \nBoehm and M. Weiser. Garbage collection in an uncooperative environment. Software Practice and Experience, \n18(9):807 820, 1988. [5] K. B. Bruce, L. Cardelli, and B. C. Pierce. Comparing object encodings. Information \nand Computation, 155:108 133, 1999. [6] Cyclone user s manual. Technical Report 2001-1855, Department \nof Computer Science, Cornell University, Nov. 2001. Current version at http://www.cs.cornell.edu/projects/cyclone/. \n[7] R. DeLine and M. F\u00a8ahndrich. Enforcing high-level protocols in low-level software. In ACM Conference \non Programming Language Design and Implementation,pages 59 69, Snowbird, UT, June 2001. [8] T. Dowd, \nF. Henderson, and P. Ross. Compiling Mercury to the .NET common language runtime. In N. Benton and A. \nKennedy, editors, BABEL 01: First International Workshop on Multi-Language Infrastructure and Interoperability,volume \n59.1 of Electronic Notes in Theoretical Computer Science, Florence, Italy, Sept. 2001. [9] D. Evans. \nLCLint user s guide. http://lclint.cs.virginia.edu/guide/. [10] D. Evans. Static detection of dynamic \nmemory errors. In ACM Conference on Programming Language Design and Implementation, pages 44 53, Philadelphia, \nPA, May 1996. [11] D. Gay and A. Aiken. Memory management with explicit regions. In ACM Conference on \nProgramming Language Design and Implementation, pages 313 323, Montreal, Canada, June 1998. [12] D. Gay \nand A. Aiken. Language support for regions. In ACM Conference on Programming Language Design and Implementation, \npages 70 80, Snowbird, UT, June 2001. [13] A. D. Gordon and D. Syme. Typing a multi-language intermediate \ncode. In Twenty-Eighth ACM Symposium on Principles of Programming Languages, pages 248 260, London, United \nKingdom, Jan. 2001. [14] D. Grossman. Existential types for imperative languages. In Eleventh European \nSymposium on Programming,pages 21 35, Grenoble, France, Apr. 2002. [15] D. Grossman,G. Morrisett, Y. \nWang, T.Jim,M.Hicks, and J. Cheney. Formal type soundness for Cyclone s region system. Technical Report \n2001-1856, Department of Computer Science, Cornell University, Nov. 2001. [16] N. Hallenberg, M. Elsman, \nand M. Tofte. Combining region inference and garbage collection. In ACM Conference on Programming Language \nDesign and Implementation, Berlin, Germany, June 2002. This volume. [17] F. Henglein, H. Makholm, and \nH. Niss. A direct approach to control-.ow sensitive region-based memory management. In Third International \nConference on Principles and Practice of Declarative Programming, Florence, Italy, Sept. 2001. [18] R. \nJain. The Art of Computer Systems Performance Analysis. Wiley, 1991. [19] T. Jim, G. Morrisett, D. Grossman, \nM. Hicks, J. Cheney, and Y. Wang. Cyclone: A safe dialect of C. In USENIX Annual Technical Conference, \nMonterey, CA, June 2002. [20] G. McGary. Bounds checking projects. http: //www.gnu.org/software/gcc/projects/bp/main.html. \n[21] Y. Minamide, G. Morrisett, and R. Harper. Typed closure conversion. In Twenty-Third ACM Symposium \non Principles of Programming Languages, pages 271 283, St. Petersburg, FL, Jan. 1996. [22] J. Mitchell \nand G. Plotkin. Abstract types have existential type. ACM Transactions on Progamming Languages and Systems, \n10(3):470 502, 1988. Preliminary version in Twelfth ACM Symposium on Principles of Programming Languages, \n1985. [23] S. Monnier, B. Saha, and Z. Shao. Principled scavenging. In ACM Conference on Programming \nLanguage Design and Implementation, pages 81 91, Snowbird, UT, June 2001. [24] G. Morrisett, K. Crary, \nN. Glew, and D. Walker. Stack-based typed assembly language. In Workshop on Types in Compilation, volume \n1473 of Lecture Notes in Computer Science, pages 28 52, Kyoto, Japan, Mar. 1998. Springer-Verlag. [25] \nG. C. Necula, S. McPeak, and W. Weimer. CCured: Type-safe retro.tting of legacy code. In Twenty-Ninth \nACM Symposium on Principles of Programming Languages, pages 128 139, Portland, OR, Jan. 2002. [26] M. \nTofte and L. Birkedal. A region inference algorithm. ACM Transactions on Progamming Languages and Systems, \n20(4):734 767, July 1998. [27] M. Tofte, L. Birkedal, M. Elsman, N. Hallenberg, T. H. Olesen, and P. \nSestoft. Programming with regions in the ML Kit (for version 4). Technical report, IT University of Copenhagen, \nSept. 2001. [28] M. Tofte and J.-P. Talpin. Region-based memory management. Information and Computation, \n132(2):109 176, 1997. [29] D. Walker, K. Crary, and G. Morrisett. Typed memory management in a calculus \nof capabilities. ACM Transactions on Progamming Languages and Systems, 24(4):701 771, July 2000. [30] \nD. Walker and K. Watkins. On regions and linear types. In Sixth ACM International Conference on Functional \nProgramming, pages 181 192, Florence, Italy, Sept. 2001. [31] D. C. Wang and A. W. Appel. Type-preserving \ngarbage collectors. In Twenty-Eighth ACM Symposium on Principles of Programming Languages, pages 166 \n178, London, United Kingdom, Jan. 2001. [32] H. Xi. Imperative programming with dependent types. In Fifteenth \nIEEE Symposium on Logic in Computer Science, pages 375 387, Santa Barbara, CA, June 2000. [33] H. Xi \nand F. Pfenning. Dependent types in practical programming. In Twenty-Sixth ACM Symposium on Principles \nof Programming Languages, pages 214 227, San Antonio, TX, Jan. 1999.  \n\t\t\t", "proc_id": "512529", "abstract": "Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone is to let programmers control data representation and memory management without sacrificing type-safety. In this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. The design incorporates several advancements, including support for region subtyping and a coherent integration with stack allocation and a garbage collector. To support separate compilation, Cyclone requires programmers to write some explicit region annotations, but a combination of default annotations, local type inference, and a novel treatment of region effects reduces this burden. As a result, we integrate C idioms in a region-based framework. In our experience, porting legacy C to Cyclone has required altering about 8% of the code; of the changes, only 6% (of the 8%) were region annotations.", "authors": [{"name": "Dan Grossman", "author_profile_id": "81405594870", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP43120334", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP43136279", "email_address": "", "orcid_id": ""}, {"name": "Trevor Jim", "author_profile_id": "81100065932", "affiliation": "AT&T Labs Research, Florham Park, NJ", "person_id": "P285104", "email_address": "", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP40023253", "email_address": "", "orcid_id": ""}, {"name": "Yanling Wang", "author_profile_id": "81328490934", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP45029887", "email_address": "", "orcid_id": ""}, {"name": "James Cheney", "author_profile_id": "81100057679", "affiliation": "Cornell University, Ithaca, NY", "person_id": "PP14031182", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512529.512563", "year": "2002", "article_id": "512563", "conference": "PLDI", "title": "Region-based memory management in cyclone", "url": "http://dl.acm.org/citation.cfm?id=512563"}