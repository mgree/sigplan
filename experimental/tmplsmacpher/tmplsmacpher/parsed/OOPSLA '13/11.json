{"article_publication_date": "10-29-2013", "fulltext": "\n Interacting with Dead Objects Robin Salkeld Gregor Kiczales University of British Columbia, Vancouver, \nBC, Canada {rsalkeld, gregor}@cs.ubc.ca Abstract Debugging and analyzing a snapshot of a crashed program \ns memory is far more dif.cult than working with a live pro\u00adgram, because debuggers can no longer execute \ncode to help make sense of the program state. We present an architec\u00adture that supports the restricted \nexecution of ordinary code starting from the snapshot, as if the dead objects within it had been restored, \nbut without access to their original exter\u00adnal environment. We demonstrate the feasibility of this ap\u00adproach \nvia an implementation for Java that does not require a custom virtual machine, show that it performs \ncompeti\u00adtively with live execution, and use it to diagnose an unre\u00adsolved memory leak in a mature mainstream \napplication. Categories and Subject Descriptors D.3.4 [Programming Languages]: Processors Run-time environments \nKeywords programming languages, meta-programming, re.ection, runtime analysis, Java, virtualization 1. \nIntroduction When systems fail, sometimes the clues as to what happened are only found within the logs, \nevent databases, stack traces, and various other remnants left behind by the system. Be\u00adcause it offers \nhigh .delity, a snapshot of a process at the time of a failure is a nearly omnipresent feature, and for \nmany modern languages this translates into a heap dump .le that contains the state of every live object \nand its connec\u00adtions to other objects. A number of tools can parse this .le and present the developer \nwith an interactive, browsable tree of values. This interface is familiar and useful for develop\u00aders, \nas it parallels how a debugger models the state of a live system. Unlike live debugging, however, the \ndeveloper cannot ex\u00adecute any of their own code in the context of the failure, Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than ACM \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509543 which is a critical \npiece of functionality. The sheer size and complexity of the object graph makes navigating and un\u00adderstanding \nit without any higher-level, application-speci.c computation painful and time-consuming. Even obtaining \na simple, human-readable representation of an object using utility code is not generally possible without \na live process to evaluate on. Heap dump analysis tools attempt to imi\u00adtate this feature, but require \nthe application developers to re\u00adimplement the relevant application code using the meta-level interface \nfor reading the heap dump. To address this issue, this paper presents an architec\u00adture that enables additional \nexecution on the objects, as if a live, debuggable process had been restored from the snap\u00adshot. This \nallows developers to invoke any code present in the original process, or even to load new analysis code \ninto the emulated process, with no need for meta-programming. This functionality is implemented as an \nordinary library, and does not require a custom language runtime. The execution is made sound by forbidding \nthe recorded objects from ac\u00adcessing state external to the snapshot, since the original en\u00advironment \nhas been lost and cannot be accurately emulated. We hence refer to these objects as holographic objects: \naccu\u00adrate recreations that cannot interact directly with the outside world. The main contributions of \nthis paper are: a summary of the shortcomings of analyzing raw ma\u00adchine state such as heap dumps via \nre.ective APIs;  an architecture for holographic objects, which enable re\u00adstricted execution starting \nfrom the state captured in a heap dump;  a description of how holographic execution must be re\u00adstricted \nto ensure safety;  evidence that this architecture can be ef.ciently imple\u00admented in a statically-typed \nlanguage on an unmodi.ed commodity language virtual machine;  and evidence for the utility of holographic \nobjects by using them to diagnose an unsolved memory leak in a mature mainstream application.  The \nimplementation discussed here supports the Java programming language and runs on the Java Virtual Ma\u00adchine \n(JVM). The general approach based on emulating language semantics, however, is applicable to other lan\u00adguage \nruntimes as well. In fact, our implementation op\u00aderates on JVM bytecode and is hence not limited to Java. \nOur implementation is available at https://github.com/ robinsalkeld/retrospect/. 2. Motivation We .rst \ndescribe the approach many heap dump analysis tools use to work around the inability to execute code, \nwhich is to force developers to program analysis using the re.ective heap dump model, and examine the \nproblems we intend to solve with our architecture. Consider a Java developer browsing the object graph \nin a heap dump, who has identi.ed an object that implements the built-in java.util.Map interface. This \nimplies that the ob\u00adject implements an associative mapping from keys to values. Suppose the developer \nneeds to know what value a certain key is mapped to. When debugging a live process this is as simple \nas evaluating the expression map.get(key), but the task is surprisingly involved with a dead process. \nEven if the concrete type of the map was a well-known class such as java.util.HashMap, an implementation \nbacked by a straight\u00adforward hash table, .nding the right key-value pair involves manually searching \nthrough the internal representation of a potentially massive hash table to .nd the matching entry. Not \nbeing able to execute code also means there is also no way to invoke the method Object.toString. This \nmethod is de.ned at the top of the Java class hierarchy with a default implementation and therefore callable \non any object, and is used to create human-readable text describing the object. The Eclipse debugging \nperspective, for example, includes a window dedicated to displaying the result of calling toString on \nobjects in other windows, and it is exactly this basic functionality that is missing in a heap dump browser. \nThe tools used to interact with heap dumps attempt to ad\u00address this issue by providing utilities to automate \nthese tasks. The Eclipse Memory Analyzer Tool (MAT) [2], which we use to represent the current state-of-the-art, \nincludes several dozen actions for navigating the object graph, and Extract Hash Entries is one such \nutility. To implement this utility, however, the tool developer must include handler code for every single \nsubclass of java.util.Map that might be encoun\u00adtered in the object graph.1 Since the tool cannot possibly \nhandle all possible types in arbitrary application code, the utility must be pluggable so that developers \nwishing to analyze their heap dumps can contribute handlers for the types of objects in them. Ulti\u00admately \nthis means that those developers are faced with the job of re-implementing the semantics of a non-trivial \npor\u00adtion of application code using the meta-level represented by the heap dump model. 1 The standard \nlibrary alone includes several dozen, such as Concurren\u00adtHashMap, LinkedHashMap, TreeMap, and so on. \n Listing 1. An example of working with an associative map\u00adping using application code. p u b l i c S \nt r i n g g e t P r o p e r t y ( S e r v i c e P r o p e r t i e s m a p , S t r i n g k e y ) { r e \nt u r n ( S t r i n g ) m a p . g e t ( k e y ) ; } Listing 2. The same example as in Listing 1, but \nusing the meta-level interface of a heap dump model. p u b l i c S t r i n g g e t P r o p e r t y M \ne t a ( I O b j e c t m a p , S t r i n g k e y ) { S t r i n g [ ] k e y s = n u l l ; S t r i n g [ \n] v a l u e s = n u l l ; I O b j e c t o b j e c t = m a p . r e s o l v e V a l u e ( \" h e a d e r \ns \" ) ; I O b j e c t A r r a y a r r a y = ( I O b j e c t A r r a y ) h e a d e r s ; i f ( a r r a \ny ! = n u l l ) { long [] keyAddrs = a r r a y . g e t R e f e r e n c e A r r a y ( ) ; i f ( k e y \nA d d r s ! = n u l l ) { / / C a l l h e l p e r m e t h o d t o d e r e f e r e n c e / / a d d r e \ns s e s t o S t r i n g o b j e c t s k e y s = g e t S e r v i c e P r o p e r t i e s ( k e y A d d \nr s ) ; } } / * S i m i l a r l y f o r \" v a l u e s \" f i e l d * / i f ( k e y s = = n u l l | | v \na l u e s = = n u l l ) return null; f o r ( i n t i = 0 ; i < k e y s . l e n g t h ; i + + ) { i f \n( k e y s [ i ] . e q u a l s ( k e y ) ) { r e t u r n v a l u e s [ i ] ; } } return null ; } Listing \n1 contains an example of base code that retrieves the value a key is mapped to in one particular type \nof map, and Listing 2 contains an example of MAT source code that achieves same thing using the re.ective \nheap dump API. This snippet is part of a large submodule responsible for reconstructing the state of \nthe Equinox OSGi Java module system [9] from a heap dump; this code is only concerned with the con.guration \nproperties, a mapping from strings to strings, for a particular service. The con.guration is stored as \na pair of parallel arrays, and this code .rst resolves the object references contained in each, then \niterates through the list of keys until it .nds a match. This example illustrates a number of disadvantages \ninherent to this approach. Complex: The complexity inherent in reproducing the behaviour of a polymorphic \nmethod such as Map.get is high. Meta-level code is inevitably much more verbose than the equivalent base-level \ncode, and reproducing higher-level language features such as polymorphic method dispatch and .eld shadowing \ncorrectly at this level is challenging. Type-unsafe: If the analysis code makes a type error, it will \nnot cause an error until further downstream reads fail to .nd the .elds they are expecting, if an error \noccurs at all. This makes tracking down coding errors much more dif.\u00adcult. In Listing 2 the meta-level \ncode assumes that the prop\u00ad erty values are strings when in fact they can be other types, and in the \nbase-level code a cast is necessary to make the code compile. Guarding against such errors through explicit \nmeta-level type checks requires programmer discipline, con\u00adtributes greatly to code bulk, and as shown \nin the example are often omitted. Brittle: In Listing 2, the code expects the properties to be stored \nin two parallel arrays. In more recent versions of Equinox, however, these .elds no longer exist, and \nthe prop\u00aderties are instead stored in a single special-purpose Servi\u00adceProperties object. Because of \nthe various null checks in this code, likely present to prevent this exact problem from crashing the \noverall analysis, no error is raised, and the ser\u00advice object appears to have no properties. The fact \nthat meta\u00adlevel analysis accesses datatype internals directly means that the analysis can very easily \nbreak, or even worse silently pro\u00adduce incorrect results, when run against a dump produced by a newer \nversion of the target code. Since this approach in\u00advolves a second, redundant implementation of the function\u00adality \nin the application, it introduces an ongoing maintenance burden. Insecure: The access control mechanisms \nbuilt into a lan\u00adguage, such as declaring types or .elds private or protected in Java, are generally \nmore easily circumvented within its own re.ection facilities. They are lost entirely, however, when traversing \na heap dump model; in the example above the code reads from two private .elds with no extra dif\u00ad.culty. \nThis contributes towards the brittleness of analysis code as above, since it is easy to refer to internal \ndetails that are likely to change in the future, but it also means that sensi\u00adtive data is easy to read, \nwhether by accident or on purpose. Unfamiliar: Developers familiar with base-level (ordi\u00adnary) programming \nin a language must learn an additional paradigm to understand and effectively work with the meta\u00adlevel \nobject model. In addition, because application values frequently refer to datatypes from libraries, reimplementing \napplication-level code requires understanding and reimple\u00admenting library code as well, since the encapsulation \nthat normally hides those details from clients has been lost. Tool developers can alleviate some of this \nburden by handling the most common functionality, but handling even a small per\u00adcentage of the code a \nuser is likely to encounter is impracti\u00adcal. Most debugging and analysis tools that are capable of reading \nsnapshots or core dumps share these limitations. The GNU Project Debugger (GDB), for example, supports \nauto\u00admated debugging through Python scripts, but these scripts operate on a similar meta-level representation \nof program state. 3. Holographic Virtual Machines Ultimately all of these dif.culties would be resolved \nif a heap dump analysis tool could execute code on the objects in the dead process, as if the execution \noccurred on the live process immediately after the snapshot was taken. We aim to provide this functionality \nthrough holographic objects, which are virtual objects that re.ect the state and behaviour of the dead \nobjects recorded in the snapshot. This section describes the high-level architecture we have used to \nmake this possible. To implement holographic objects, we require a re.ective API for accessing the state \nof the dead objects, and an exe\u00adcution environment that implements the semantics of nor\u00admal execution \nwith respect to the re.ective API instead of in-memory native objects. For example, an instruction that \naccesses a .eld of an object should have the effect of access\u00ading that .eld from the holographic object \nin the heap dump via our re.ective API. Holographic objects should behave like the dead objects they \nimitate, or else any analysis performed on them may produce incorrect results. Any code in the control \n.ow of holographic execution that cannot be exactly reproduced based on the information in the heap dump \nmust result in an explicit exception. This includes any attempt to access or mutate the external environment \nof the original process, such as other processes, the .le system, the network, and so on. This also implies \nthat holographic objects must be completely sandboxed: it must be impossible for them to obtain references \nto any objects in the host VM, or vice versa. Holographic objects are hence encapsulated inside a holographic \nvirtual machine. Values may only be passed between the guest and host VMs using explicit re.ective methods, \nand only primitive values2 are permitted to avoid leaking references. Figure 1 contrasts an ordinary \nVM with a holographic VM running inside another ordinary VM. 3.1 Mirrors To support creating holographic \nobjects on top of multiple snapshot formats, or indeed to other sources of object state, we de.ne our \nre.ective API using an independent set of re\u00ad.ective interfaces. The core functionality of the re.ective \naccess we need is apparent if we compare the heap dump model to existing re.ective APIs. The Java platform \nincludes two such APIs: a set of built-in re.ective methods such as Class.getFields, and the Java Debugging \nInterface (JDI) pro\u00advided by the Java Platform Debugger Architecture [16], on which remote Java debuggers \nare built. Each API provides similar functionality backed by different state: the built-in Java re.ection \nmethods re.ect on the state of the current 2 In the case of the JVM, String values are permitted despite \nbeing objects, as they are a core type whose implementation must be immutable.  Figure 1. The overall \nholographic objects architecture. On the left is an ordinary virtual machine and its interactions with \nthe .le system and external environment. On the right a holographic VM simulates the behaviour of a VM \nrestored from a heap dump. A holographic VM is only permitted to read class .les from disk and interact \nwith the VM emulating it through re.ective methods. It is otherwise forbidden from interacting with its \nenvironment. VM, the JDI re.ects on the state of a separate VM being debugged, and the heap dump model \nre.ects on the past in\u00adstantaneous state of another VM. Bracha and Ungar [5] label such pluggable, independent \nre.ection interfaces as mirrors, and we adopt their termi\u00adnology here. We de.ne a central interface named \nVirtual-MachineMirror, which encapsulates an entire object graph, including all loaded classes and hence \nall executable code in the system. Other interfaces represent objects, classes, .elds, methods, arrays, \nand so on. A holographic VM is then represented as a VirtualMa\u00adchineHolograph wrapper that refers to \nan underlying Vir\u00adtualMachineMirror instance and implements that interface itself. This achieves our \ngoal of making holographic ob\u00adjects a general-purpose library, as the wrapper can be ap\u00adplied to any \nrepresentation of VM state that can be used to implement the generic mirrors API. The library provides \nsimilar holographic wrappers for the other related mirror in\u00adterfaces. Most importantly, the holographic \nimplementation of MethodMirror.invoke does not delegate to the wrapped method mirror, but instead emulates \nthe semantics of that method s de.nition as described above.  3.2 Mutations Although holographic execution \nis not allowed to read from or write to the state of the outside world, many useful expres\u00adsions that \nare semantically functional will have internal side\u00adeffects that attempt to modify the internal object \ngraph. For example, looking up a string key in a HashMap as described earlier requires calculating the \nstring s hash code, and the implementation of string hashing caches the result in an in\u00adstance .eld of \nthe string the .rst time it is calculated. This means if the method was not previously called on a string \nin the original VM, or if the string was newly-created as part of holographic execution, the method will \nattempt to set a new value on the mirror. The heap dump model is read-only, as many potential mirror \nimplementations will be, and hence this will trigger an exception. To support mutation in holographic \nexecution, the holo\u00adgraphic adapters superimpose a mutable mirror graph over the wrapped, potentially \nimmutable graph. Each wrapper is initially empty, exposing state identical to that of the wrapped object. \nAs values are written to the holographic ob\u00adjects they are stored in the wrapping object, and future \nreads will return those values. The same approach applies for other more subtle side-effects on the mirrors \nAPI, such as expand\u00ading the set of classes loaded by a class loader by de.ning a new class. Maintaining \nmutations on the object graph independently in this way also offers .exibility in the semantics of multi\u00adple \nsuccessive sessions of holographic execution. If the same holographic VM instance is used for each, the \nside-effects of prior executions will potentially affect future executions. This is consistent with a \ndeveloper s experience when eval\u00aduating expressions in a normal debugging client. Alterna\u00adtively, a new \nholographic VM can instantiated for each eval\u00aduation, to restore the same pristine initial snapshot state. \nThis is equivalent to experimenting with a live process by repeat\u00adedly forking a new sandboxed process \nthat can be perturbed in arbitrary ways and then discarded. p u b l i c c l a s s E m p l o y e e { \nprivate int age; p u b l i c s t a t i c S e t < E m p l o y e e > o v e r 4 0 ( E m p l o y e e [ ] \ni n p u t ) { S e t < E m p l o y e e > r e s u l t = n e w H a s h S e t < E m p l o y e e > ( ) ; f \no r ( E m p l o y e e e : i n p u t ) { if (e.age > 40) { result . add (e); } } return result ; } } \n(a) Original Java Code p u b l i c c l a s s E m p l o y e e { private I age p u b l i c s t a t i c \no v e r 4 0 ( [ L E m p l o y e e ; ) L S e t ; L 0 NEW HashSet D U P 1 ) | I N V O K E S P E C I A \nL H a s h S e t . < i n i t > ( ) V ASTORE 1 L 1 ALOAD 0 D U P ASTORE 5 2)| ARRAYLENGTH ISTORE 4 I C \nO N S T _ 0 ISTORE 3 G O T O L 2 L 3 ALOAD 5 ILOAD 3 3)| AALOAD ASTORE 2 L 4 ALOAD 2 4 ) | G E T F I \nE L D E m p l o y e e . a g e : I BIPUSH 40 IF_ ICMPLE L5 L 6 ALOAD 1 ALOAD 2 5 ) | I N V O K E I N \nT E R F A C E S e t . a d d ( L O b j e c t ; ) Z P O P L 5 IINC 3 1 L 2 ILOAD 3 ILOAD 4 IF_ ICMPLT L3 \n L 7 ALOAD 1 A R E T U R N } (b) Original JVM Bytecode p u b l i c c l a s s h o l o g r a m / E m \np l o y e e e x t e n d s O b j e c t H o l o g r a m { / / I n h e r i t e d f r o m O b j e c t H o \nl o g r a m : / / p u b l i c L O b j e c t M i r r o r ; m i r r o r p u b l i c f i n a l s t a t i \nc L C l a s s M i r r o r ; c l a s s M i r r o r p u b l i c s t a t i c o v e r 4 0 ( L h o l o g r \na m a r r a y 1 / E m p l o y e e ; ) Lhologram / Set ; L 0 LINENUMBER 17 L0 N E W h o l o g r a m / \nH a s h S e t D U P 1 ) | G E T S T A T I C h o l o g r a m / H a s h S e t . c l a s s M i r r o r \n| : LClassMirror; | I N V O K E I N T E R F A C E C l a s s M i r r o r . n e w R a w I n s t a n c e \n| ( ) L I n s t a n c e M i r r o r ; | I N V O K E S P E C I A L h o l o g r a m / H a s h S e t . < \ni n i t > | ( L I n s t a n c e M i r r o r ; ) V ASTORE 1 L 1 ALOAD 0 D U P ASTORE 5 2 ) | I N V O \nK E I N T E R F A C E A r r a y M i r r o r . l e n g t h ( ) I ISTORE 4 I C O N S T _ 0 ISTORE 3 GOTO \nL2 L 3 ALOAD 5 ILOAD 3 3 ) | I N V O K E S T A T I C O b j e c t A r r a y H o l o g r a m . g e t H \no l o g r a m | ( L O b j e c t A r r a y M i r r o r ; I ) L H o l o g r a m ; | C H E C K C A S T h \no l o g r a m / E m p l o y e e ASTORE 2 L 4 ALOAD 2 4 ) | G E T S T A T I C h o l o g r a m / E m p \nl o y e e . c l a s s M i r r o r | : LClassMirror; | LDC \"age\" | I N V O K E S T A T I C I n s t a n \nc e H o l o g r a m . g e t I n t F i e l d | ( L H o l o g r a m ; L C l a s s M i r r o r ; L S t r \ni n g ; ) I B I P U S H 4 0 I F _ I C M P L E L 5 L 6 ALOAD 1 ALOAD 2 5 ) | I N V O K E I N T E R F \nA C E h o l o g r a m / S e t . a d d | (LHologram;)Z P O P L 5 IINC 3 1 L 2 ILOAD 3 ILOAD 4 I F _ I \nC M P L T L 3 L 7 ALOAD 1 A R E T U R N } (c) Translated JVM Hologram Bytecode Figure 2. A example \nof how JVM bytecode is translated into hologram bytecode, which operates on mirror classes and interfaces. \nModi.ed instructions are numbered in both the original and translated bytecode listings. Only object \nand array instructions are modi.ed; control .ow and primitive instructions are left untouched. Note that \ndowncasts such as the one in 3) are often necessary to ensure type safety.  3.3 Translating Code The \nmost obvious approach to implementing holographic execution would be customizing a language runtime to \nsup\u00adport it, but this would be non-portable. We instead chose the implementation strategy of translating \nprograms into lifted versions equivalent to holographic object semantics. Each instance of a core language \noperation is mapped to methods of the mirrors API, and the implementors of those interfaces thus determine \nthe runtime behaviour of the language. Our particular implementation targets the JVM, and hence the source \nlanguage it translates is JVM bytecode, us\u00ading the ASM bytecode processing framework [6]. We label the \ntranslated versions as hologram classes. These classes are encapsulated within the holographic VM API \nand never directly exposed to developers or tools using holographic objects. All instance .eld declarations \nin the original classes are replaced with a single ObjectMirror instance .eld, and the individual bytecode \ninstructions are lifted to operate on those instances. The transformations are all local and context \nfree, although a single instruction will frequently be trans\u00adlated into multiple instructions. Figure \n2 contains a small example of how bytecode is transformed. The semantics of holographic execution imply \nthat holo\u00adgraphic object references require two orthogonal dimensions of polymorphism: the original class \nhierarchy for virtual and overloaded method invocations, and the virtual mirror in\u00adterface methods for \nobject state access. We have chosen to map the original hierarchy into an isomorphic hierarchy of hologram \ntypes which preserve the subtype relation, allow\u00ading method invocation to operate as in the original \nbytecode. Our techniques are similar in several respects to those used by Factor et. al. [8] to transparently \nrename classes in or\u00ad der to support instrumentation of core Java classes. Note that another valid approach \nwould be to replace object refer\u00adences with direct mirror references and implement dynamic method dispatch \nmanually instead. This could be evaluated in future work, but we suspect that the overhead of handling \nmethod dispatch is likely equal to or worse than the overhead of wrapping mirrors with hologram class \ninstances. Each source type is usually mapped to exactly one inter\u00adnal type, but in some cases maintaining \nthe subtyping rela\u00adtionship in user-level code requires splitting the type into a concrete class and \nan interface. The mapping function be\u00adtween hierarchies is therefore actually de.ned by two func\u00adtions: \nH C , which is guaranteed to be a concrete, instantiable class, and H T , which may be an interface. \nFor all types C and D in the original bytecode, we have: H C (C) <: H T (C) C <: D H T (C) <: H T (D) \n In general, H C (C) is used wherever new instances of C are created, or when C is used as the superclass \nof another class, whereas H T (C) is used wherever C is used as a reference type for local variable, \nmethod parameters, and so on. The cases where the two functions differ are outlined below. Interfaces: \nObject is both the base class of all concrete classes and the top of the subtyping lattice, and hence \na su\u00adpertype of interfaces as well. References of type Object are mapped to a Hologram interface, which \nall hologram classes and interfaces implement and extend, and which has a single getMirror() method. \nWhere Object appears as a superclass, however, an ObjectHologram class is used instead, which actually \ndeclares the mirror .eld and implements getMir\u00adror(). Arrays: Each distinct array type, which is normally \ncre\u00adated automatically in the JVM without requiring explicit class de.nitions in source, is mapped to \na distinct class type; although there is no virtual method dispatch on arrays, ar\u00adray types can still \ncreate valid method overrides when used as parameter types. These must also be split, since they must \nbe concrete and instantiable but also support multiple inheri\u00adtance because of covariance, meaning that \nfor each interface A that B implements, the hologram type for B[] must be a subtype of the hologram type \nfor A[]. If T is an array type with reference element type E and n dimensions (i.e. the type E[][]...(n)...[]), \nwe use H AC (E , n) and H AT (E , n) to refer to H C (T ) and H T (T ), which will be a class and an \ninterface, respectively. The extends and implements clauses for these types are de.ned as follows: H \nAC (E, n) implements H AT (E, n) E extends C H AT (E , n) implements H AT (C, n) E implements I H AT \n(E, n) implements H AT (I , n) n > 0 H AT (Object, n) implements H AT (Object, n - 1) The last implication \nabove arises from the combina\u00adtion of array subtyping covariance and the fact that Ob\u00adject[] <: Object. \nNote that H AT (Object, 0) is simply hologramT ype(Object), which is the Hologram interface. Since the \nresults of translating bytecode will be the same for successive holographic VMs on the same heap dump, \nour system caches translated bytecode on disk to improve perfor\u00admance. The cache is isomorphic to a fast \nassociative map\u00adping keyed by class name with sequential separate chain\u00ading to handle multiple classes \nwith the same name. This ap\u00adproach is effective since the name of a class is by far its most speci.c \ncharacteristic, but still handles multiple classes with the same name occurring in a single VM. Holographic \nJVMs also provide an optional prepare op\u00aderation that iterates through all currently loaded classes and \neagerly generates the translated bytecode for each, which will pre-populate the cache. This will often \nbe the preferred work.ow: a holographic JVM could be prepared in advance and the cached bytecode distributed \nalong with the heap dump. 4. Scope There are several obstacles that may prevent holographic ex\u00adecution \nfrom emulating live execution soundly. All are direct results of missing information in the snapshot, \nalthough in most cases these can be solved by additional con.guration provided by the user. This section \noutlines the factors that limit the completeness of this technique and the extent to which we are able \nto overcome them in our implementation. 4.1 Missing Bytecode The most immediate obstacle to holographic \nexecution on the JVM is the fact that heap dumps generally do not contain any bytecode, as most JVM implementations \nmaintain class de.nitions in a separate area of memory. We must some\u00adhow recover the de.nitions of the \nclasses in the heap dump in order to execute any code. Class de.nition on the JVM is dynamic: the core \nClassLoader class and its subclasses are used to dynamically locate the bytecode for a requested class \nname at runtime. The implementation of these class loaders can be arbitrarily complex and is often non-trivial \nin pop\u00adular application containers such as OSGi, and so providing the missing bytecode in a holographic \nVM though manual con.guration is not feasible. Our solution is to leverage the fact that nearly all class \nloaders eventually load bytecode from a class .le on the .le system, and more speci.cally one that matches \nthe requested class name. We use holographic execution itself to call the appropriate method on the class \nloader to read the contents of the matching class .le. This approach is valid for the vast majority of \nJava code, but for full generality this piece of the architecture is pluggable so that more unusual class \nloaders that dynamically modify or generate bytecode can be handled when the generic solution fails to \nlocate a class .le. Since the state of the original .le system at execution time is also not captured \nin the heap dump, an exception would normally be thrown when this mechanism attempts to ac\u00adcess the .le \nsystem. However, the con.guration of a holo\u00adgraphic VM includes a simple .nite mapping from paths in \nthe original .le system to paths in the .le system of the host machine, creating what we call a holographic \n.le system. Whenever holographic execution attempts to access the orig\u00adinal .le system, the path is remapped \nonto the host .le sys\u00adtem. This approach also works for paths inside compressed class .le archives ( \njar .les), and could theoretically be ex\u00adtended to support more atypical sources such as URLs. Assuming \nthat the developer using this system can pro\u00advide a copy of the same version of the compiled class .les, \nwhich should not be dif.cult given the prevalence of source version control systems in software development, \nthe holo\u00adgraphic .le system allows any class loading logic to read the correct bytecode from disk. This \nsolution also allows the holographic VM to load classes that were available to the original VM but not \nyet loaded, which is often neces\u00adsary when holographic execution hits code that hadn t yet been executed \nin the original VM. Furthermore, another workaround for the problem of unusual class loaders above is \nto pre-generate the relevant bytecode as class .les in the mapped .le system.  4.2 Native Methods Many \nprogramming language platforms feature standard runtime libraries that are impure, in that some of the \npro\u00advided features are not implemented in the language but in\u00adstead handled by the runtime itself, with \nno corresponding source code. In the case of the JVM, many low-level meth\u00adods in the core Java Runtime \nEnvironment (JRE) library are native methods, which means they have no bytecode but are instead handled \ndirectly in the JVM. Such native methods cannot be called directly on holographic objects, but holographic \nexecution will inevitably encounter them. Even calling a toString method as described earlier is al\u00admost \nguaranteed to hit the native System.arraycopy method somewhere in its control .ow. Native methods may \nhave arbitrary effects on the ex\u00adternal environment of the VM, and hence some cannot be called in holographic \nexecution. Many are purely functional in behaviour, however, and are only implemented in native code \nfor ef.ciency. The holographic VM architecture in\u00adcludes another pluggable mechanism for providing semanti\u00adcally \nequivalent, mirror-based native methods (MNMs), and includes such implementations for the most commonly \nen\u00adcountered native methods in the JRE. In most cases the implementations of MNMs can be quite naive \nand unoptimized. In the context of supporting post-hoc debugging and analysis the raw ef.ciency of the \nimplemen\u00adtation is not the primary concern, so long as the methods semantics can be accurately reproduced. \nSee Section 5.2 for a discussion of the ef.ciency of our architecture. Native methods can be left unimplemented, \nor they can be expressly marked as forbidden because their semantics re\u00adquire accessing their external \nenvironment. In either case the unsupported native method is replaced with an MNM stub that throws an \nexception. This means that classes with unim\u00adplemented or forbidden native methods can still be loaded \nand used in holographic execution, so long as those native methods are not actually called. This is critical \nsince the classes in the JRE include over 1000 native methods, many of which involve some form of input \nfrom or output to the external environment. Note that application classes outside of the standard lan\u00adguage \nruntime can also include native methods, and so if a developer wishes to execute holograph code that \nwill hit those methods they must provide the required MNMs them\u00adselves. Native methods are much less \nprevalent in appli\u00adcation code than in the core JRE, however, and the bur\u00adden of providing these alternate \nimplementations is far less than the burden of re-implementing everyday code as in the re.ection-based \nanalysis approach.  4.3 Class Initialization Class initialization occurs in Java when a class is .rst \nused, and involves invoking a special static method in the class bytecode called an initializer. This \ncan have arbitrary effects on the object graph, and holographic execution must pre\u00adserve this behaviour \nby invoking the initializer of any unini\u00adtialized class before accessing it. Like a class bytecode, however, \nthe initialization .ag is not present in most heap dumps, so there is no direct way to tell if a class \nwas de.ned but not yet initialized at the time of the dump. Since failing to initialize an uninitialized \nclass can lead to inconsistent, unsound errors, holographic execution must raise an exception if it attempts \nto load a class whose initialization status is indeterminate. We observe that in almost all cases the \ninitialization sta\u00adtus of a class can be automatically inferred from other data, based on the rules for \nwhen initialization must occur. Be\u00adfore class initialization, every non-constant static .eld has a default \nvalue: false for boolean .elds, null for object ref\u00aderences, and so on. Setting a value on a static .eld \nforces initialization, so a non-constant static .eld in the heap dump with a non-default value implies \nthat the class must be ini\u00adtialized. Conversely, if the execution of a class initializer has the de.nite \neffect of setting a non-default value on a .eld but that .eld has the default value in the heap dump, \nthe class must not be initialized. In addition, given the de.nition of each class initializer, we can \nde.ne a preordering A . B to mean the initialization of class A forces the initialization of class B. \nIf we use initialized(A) to symbolize that class A is initialized, we have two additional judgements \nwe can use to infer whether a class is initialized: initialized(A) . A . B \u00acinitialized(B) . A . B initialized(B) \n\u00acinitialized(A) To take advantage of these rules, when a class initializer method is encountered while \ntranslating bytecode, the holo\u00adgraphic VM architecture performs a conservative analysis of the effects \nof the method. We use an abstract interpre\u00adtation [7] similar to the type inferencing algorithm used \nby JVMs to verify bytecode, where the abstract values are three\u00advalued booleans indicating whether a \nvalue is a default value, is not, or could be either. The output of this data-.ow analy\u00adsis is both a \nthree-valued boolean for each static .eld and the set of classes the method s execution is guaranteed \nto force the initialization of. When it is necessary to check if a holo\u00adgraphic class A is initialized, \nthe class static .eld values are compared with the static analysis results as described above. All classes \nB for which A . B are also checked recursively, and if any are de.nitely uninitialized A is determined \nto be uninitialized as well. This analysis is sound but not complete: classes may still be encountered \nfor which the rules above are not enough to infer whether it is initialized. We further observe, how\u00adever, \nthat many class initializers are idempotent, in that they may be executed more than once without any \nadditional side\u00adeffects. This means they can safely be run on classes that may already be initialized. \nThe architecture thus includes an\u00adother pluggable mechanism for users to mark speci.c classes as having \nidempotent class initialization. In Section 5.3 we provide evidence that this necessity should be relatively \nrare. It is also possible for a class to have non-inferable initializa\u00adtion status and a non-idempotent \ninitializer, but we have yet to encounter such a case. 4.4 Concurrency Our holographic VM implementation \nis currently limited to single-threaded execution, but there are no assumptions in the architecture that \nwould prevent concurrent holographic execution. Like the JDI model, executing code in a holo\u00adgraphic \nVM happens in the context of a speci.c thread mir\u00adror from the heap dump, and uses a dedicated native \nthread in the host VM to execute the translated bytecode. The seman\u00adtics are identical to invoking a \nmethod on a paused thread while debugging a live process. In order to support multiple native threads \nsimulating multiple holographic thread executions, the data structures used in the mutable object graph \nlayer described in Sec\u00adtion 3.2 simply need to be replaced with their appropriately synchronized equivalents: \nreplacing HashMap instances with ConcurrentHashMap instances, for example. The syn\u00adchronization overhead \nwill have a negative impact on per\u00adformance, which should be the subject of future evaluations, but this \nwill enable more complex post-hoc application sim\u00adulation. 5. Evaluation This section evaluates two primary \nresearch questions: 1. To what extent does the holographic VM architecture improve on the re.ection-based \napproach to heap dump analysis? 2. Is holographic execution responsive enough for a typical heap dump \nanalysis scenario?  5.1 Case Study: Diagnosing a Memory Leak To evaluate the feasibility and utility \nof object holographs, we augmented the Eclipse MAT to leverage them as much as possible, and then used \nthe modi.ed tool to diagnose a real world memory leak contributed by an end user. 5.1.1 Extending the \nEclipse MAT A large portion of the Eclipse MAT user interface cen\u00adtres around navigating and summarizing \nthe object graph through prede.ned parameterized queries, some of which are directly analogous to source-level \noperations; Extract List Values, for example, iterates through a list s entries in the same way as list \niterator objects do. Our primary aug\u00admentation of the tool was to de.ne two additional generic queries \nwhose implementation used holographic execution. The .rst is Evaluate Expression, which parses and eval\u00aduates \na given code snippet in the context of the each ob\u00adject selected in the tool. This is accomplished by \nadapting a holographic VM to the JDI and reusing the implementation of the Eclipse debugging UI. It supports \neither evaluating the expression once for each selected object or collecting all selected objects into \na single Collection through a boolean\u00advalued aggregate parameter. The second is Load and Run Code, which \nevaluates the contents of a speci.ed method from a given class .le on disk. This is accomplished by using \nholographic execution to cre\u00adate a new class loader instance, pass the class bytecode into the appropriate \nmethod to make the class loader de.ne the new class, and then actually invoke the target method. This \nallows users to de.ne more complicated queries via addi\u00adtional code compiled against the original application \nbina\u00adries. This query also supports the same aggregate parame\u00adter. We also replaced several existing \nqueries with equivalent versions that used holographic execution. The Extract List Values query, for \nexample, was reimplemented to invoke the iterator() method on any collection and use the result to iterate \nover the collection s elements. This not only in\u00adcreased the generality of the resulting queries, in \nthis case allowing it to work on any Collection rather than only spe\u00adci.c List subtypes, but also enabled \nthem to accept newly created holographic objects as well as existing heap dump objects. Replacing these \nre.ection-based query implemen\u00adtations also eliminated thousands of lines of code, showing that holographic \nexecution also simpli.es tool development.  5.1.2 Debugging Experience The Juno release of the Eclipse \nC and C++ Development Tools (CDT) contained a memory leak3: indexing a large project caused the Eclipse \nruntime to exhaust all available memory, where the same project was successfully indexed in previous \nversions of the CDT. The user reporting the bug was able to upload a 1 gigabyte heap dump from the time \nof failure, but because the project that caused the error contained proprietary code they were not allowed \nto provide the actual project source. This hindered attempts by the CDT contributors in the following \nmonths to reproduce the problem, despite multiple other users reporting the same bug. 3 https://bugs.eclipse.org/bugs/show_bug.cgi?id=400073 \n Listing 3. Analysis code used to diagnose the Eclipse CDT memory leak bug p u b l i c s t a t i c M \na p < S t r i n g , I n t e g e r > f i n d D u p l i c a t e s ( C o l l e c t i o n < C P P A S T N \na m e > n a m e s ) { S o r t e d M a p < S t r i n g , I n t e g e r > c o u n t s = n e w T r e e M \na p < S t r i n g , I n t e g e r > ( ) ; f o r ( C P P A S T N a m e n : n a m e s ) { String nKey \n=n+\"-\" + A r r a y s . t o S t r i n g ( n . g e t N o d e L o c a t i o n s ( ) ) ; I n t e g e r c \no u n t = c o u n t s . g e t ( n K e y ) ; i f ( c o u n t = = n u l l ) { count = 0; } c o u n t s \n. p u t ( n K e y , c o u n t + 1 ) ; } return counts ; } The CDT contributors were able to determine \nthat ap\u00adproximately 80% of the heap was retained by over 1.8 mil\u00adlion instances of the class CPPASTName \nand their related child objects. This class is used to represent unique occur\u00adrences of symbols in C++ \nsource code after preprocessing, and the bug reporter s estimate of the actual number of such symbols \nin their code was smaller by a factor of six. Our initial theory for the memory leak was that the indexing \npro\u00adcess was creating multiple duplicate name objects represent\u00ading the same locations in the source \ncode. A straightforward way to investigate this theory is to iterate over all of the name objects and \ngroup them by their locations, in order to detect multiple names from the same location. Obtaining the \nnecessary bytecode for the relevant classes in the uploaded heap dump was not dif.cult in this case: \nwe only required the appropriate versions of the Java 6 JRE and the Juno Eclipse distribution. We then \nauthored a small helper method, built against the matching version of the CDT source code, which iterates \nover a sequence of CPPASTName objects and populates a map keyed by a string representation of their locations. \nSee Figure 3 for the relevant source code. This analysis would be very time\u00adconsuming to implement using \nre.ection: although the CP-PASTName class has a .eld for storing its location, it is lazily calculated \non request using several related datatypes, and so for the majority of the objects in the heap dump this \n.eld contains null. We executed this code using the Load and Run Code query described above on the .rst \n100,000 CPPASTName objects in the heap dump, resulting in a new holographic HashMap object. To examine \nits contents in the Eclipse MAT UI, we executed a holographic query to extract the key and value pairs \nfrom any Map instance. The results con.rmed our theory that there were many sets of duplicates, in many \ncases over a dozen symbols with the same name and location. Given that many of the most duplicated symbols \nwere from a common library, our next theory was that the indexer was creating a separate symbol instance \nevery time a header .le was included. We selected one of the most duplicated symbols and began to test \nthis new theory by writing code to print out the path of include declarations for each. The .rst step \nwas traversing the parse tree to .nd the compilation unit containing each name, which we achieved using \nthe Evalu\u00adate Expression query on the string getTranslationUnit() . We were surprised to .nd that each \nsymbol came from separate compilation units. Executing getFilePath() on each revealed that they were \nall for the same source .le. From this point it was relatively simple to use existing MAT queries to \n.nd the references keeping the extra parse trees from being collected by the garbage collector, in particular \na thread local that was not cleared after use. This analysis was presented on the online bug report, \nand a .x was submitted shortly after by one of the project contributors.  5.2 Performance To determine \nwhether holographic execution is performant enough for its intended use, we created a test harness that \niterates through every object in a VirtualMachineMirror and executes the toString method on each one, \nmeasuring the time taken to return from the invocation. This benchmark was chosen because it is easy \nto implement and applicable to any Java codebase, and yet exercises a surprising amount of code; even \nvery simple implementations of toString are often only the tip of the iceberg when all of the methods \nthat are ultimately used in their control .ow are included. We ran our benchmark against three sample \napplications. jre only is a stub application including only an empty main class, for the purpose of benchmarking \nonly the contents of the JRE. tomcat is the Apache Tomcat web server, version 7.0.37, after serving the \ninitial welcome page. eclipse is the Eclipse IDE, build 20130614-0229, with a minimum of plugins installed \nin order to keep the total class and object count manageable. For each sample application, we used the \nJDI to connect to and pause the live process, captured a single heap dump, and then ran the benchmark \nagainst both the live process and the snapshot. We used the performance of remote execution on a live \nprocess as the baseline, measuring the performance of holographic execution as a kind of overhead compared \nto this baseline. These experiments were performed on a MacBook Pro laptop with a 2.4 GHz Intel Core \n2 Duo CPU and 8 GB of RAM, running Mac OS X version 10.7.4. Figure 3 presents our results. Since there \nis no convenient method for uniquely identi\u00adfying objects in Java, and hence no convenient way to corre\u00adlate \nthe object mirrors in the two different VM mirrors, the data are analyzed as two independent sets. It \nwould be in\u00adstructive in future work to develop an algorithm for matching objects between VMs, possibly \nusing structural comparison or raw memory addresses, in order to match times and ana\u00adlyze the average \noverhead. We were surprised to discover that holographic execution is actually faster in all cases than \nremote execution using the JDI. This is due to the fact that the JDI relies on inter\u00adprocess communication \nto pass values between the target and source VMs, whereas a holographic VM s state resides in memory \nwith the caller, and for relatively simple objects this invocation overhead is greater than the time \nneeded for the execution itself. A future evaluation could connect the JDI to a remote holographic VM \ninstead of a local one to normalize this difference, but this would require additional engineering to \naccomplish. In addition, since a holographic VM does not have to reside in a separate process, the lower \nlatency of re.ective calls is in fact observed in tooling, although traded off by the overhead of keeping \nthe object graph in memory locally. The most expensive aspects of holograph execution are fetching the \nbytecode for the original classes as described in Section 4.1 and translating that bytecode to produce \nholo\u00ad gram classes as described in Section 3.3. When the extra step of loading a heap dump and preparing \nthe holographic VM are included, the total times to run the benchmark on either a live or dead process \nare similar. Since the results of this process for each class in the heap dump are cached on disk, however, \nsuccessive analysis runs can avoid this processing time. Our experience shows that the translation time \nis con\u00adsistently about 5 seconds per megabyte of class .le content. Preprocessing the entire Java Runtime \nEnvironment (JRE), which consists of over 20,000 classes and over 60 MB of bytecode, can be done in just \nunder .ve minutes. 5.3 Completeness The major limitation on completeness in this system is the possibility \nthat the execution of useful code could encounter unsupported or illegal native methods. Our experimentation \nhas initially targeted the Mac OS X distribution of Java 7 re\u00adlease 5, and for every native method in \nthat JVM s runtime we have either provided a mirror-based alternate implemen\u00adtation or explicitly determined \nthat it requires illegal access to the external environment and marked it as forbidden. Ap\u00adpendix A lists \nour categorization of these native methods. Our implementation currently includes 99 alternative im\u00adplementations \nof native methods, with a total of 1443 source lines of code. This serves as a rough evaluation of the \nef\u00adfort involved in supporting a particular VM implementation. Only those methods in the sun.misc.Unsafe \nclass are speci.c to the exact JVM implementation we used, as they involve raw memory addressing that \ndepends on the exact memory layout of its objects. There are also a handful of platform\u00adspeci.c classes \nsuch as UNIXFileSystem that contain native methods, but this is only a super.cial platform dependency \nsince the actual MNMs for such methods are only trivially different. 187 legal native methods are not \nyet implemented Figure 3. Results of executing Object.toString on every object in a VM, comparing performance \non a holographic VM versus a live VM via the Java Debugging Interface. Although the time to translate \nthe bytecode for all classes in the VMs is signi.cant, once loaded the local holographic VM actually \nexecutes these methods faster than the remote process. In all cases the minimum toString() time was 0ms, \nas several classes de.ne the method to simply return a constant or recalculated value, and hence return \nessentially instantaneously. Application jre only tomcat eclipse Classes Objects 456 2249 2657 46387 \n7610 99452 Live VM Avg. toString time (ms) Max. toString time (ms) Std. Dev. toString time (ms) 15.9 \n1748 74.4 25.9 22041 279.3 33.2 80234 512.6 Holographic VM Prepare time (s) Avg. toString time (ms) Max. \ntoString time (ms) Std. Dev. toString time (ms) 44 5.4 1279 38.7 171 2.5 8804 78.7 340 7.4 55867 325.6 \n in our prototype, as they were not encountered in our exper\u00adiments, but these are all either trivial \nvariations on other im\u00adplemented methods, such as alternatives for different prim\u00aditive types, or alternative \nways of accessing the re.ective properties already supported by the mirrors API. The other limitation \non completeness is the possibility of encountering classes in the heap dump with indetermi\u00adnate initialization \nstatus. In the process of supporting our ex\u00adperiments we encountered nine such classes. We explicitly \nmarked these as having class initializers that were safe to re\u00adrun, implying they could safely be executed \neven if they may have already run; these are listed in Appendix B. 6. Related Work 6.1 Mirror-based \nBehavioral Intercession Prior work has examined the idea of customizing the be\u00adhaviour of a language \ns objects via implicit mirror imple\u00admentations. Such objects have been called mirages [15] or virtual \nvalues [4], and have largely been studied in the con\u00ad text of behavioural intercession, or augmenting \nor replacing behaviours on existing objects. Holographic objects are sim\u00adilar in implementation, but \nfocus instead on reproducing the behaviour of base objects with no actual base object avail\u00adable in the \nruntime to provide the base behaviour. In our case behavioural intercession is limited to the case of \nreplacing native methods, with the speci.c requirement of not deviat\u00ading from base behaviour, and is \nnot exposed to developers that use the library. In addition, prior work has presented implementations \nof such objects in dynamic languages, and doing the same in a statically-typed language such as JVM bytecode \nwithout requiring a custom language runtime presents fundamental challenges that affect the design of \nthe interfaces to those objects. The Jikes Research Virtual Machine [3] also imple\u00ad ments the behaviour \nof a JVM on another JVM, and the ma\u00adjority of its code is ordinary Java. Its object model is not intended \nto be pluggable, however, and although it could be made so this would not necessarily be any easier than \ncus\u00adtomizing any other JVM implementation. Lorenz and Vlissides [13] describe how pluggable re.ec\u00ad tion \nenables more .exible language tools, using a documen\u00adtation generator and an object-to-component generator \nas ex\u00adamples. A holographic language runtime represents another client of a language s pluggable re.ective \nAPI, and allows the language s implementation itself to be decoupled from the representation of its runtime \nstate. Unlike Lorenz and Vlissides examples, holographic execution requires a re\u00ad.ective API that represent \ncomputation and not just code, a distinction clari.ed by Bracha and Ungar [5]. 6.2 Reproducing Past \nState and Behaviour The idea of checkpointing and resuming execution recurs in several contexts, notably \nin operating system or hardware virtualization. Some language runtimes also support resum\u00ading from a \nsnapshot [1], and Java itself includes a small amount of this behaviour in its shared memory class .le \ncache feature. In all of these cases the restored process is a normal, unrestricted instance, and care \nmust be taken to ensure that invalid references to the outside world are not created. By contrast holographic \nexecution as described in this paper is intended to support diagnosis and analysis of the state of a \nsystem in the past. It requires no foresight, but at the cost of restricting additional execution and \nhence not truly restoring a dead process. It also does not currently sup\u00adport resuming execution from \nthe exact time of the snapshot, although this is conceivably possible if a more precise snap\u00adshot such \nas a core dump were used, along with techniques for recreating the captured call stack via program slicing \n[18]. 6.3 Heap Dump Analysis Several other approaches have been used to analyse heap dumps, usually \nin the context of identifying the source of memory leaks. Maxwell et. al. [14] use graph mining to locate \npotential leak candidates. As we have illustrated in Section 5.1, holographic execution is a complementary \ntech\u00ad nique which does not preclude the use of the re.ective API on a heap dump. For example, the aforementioned \nwork in\u00adcludes a case study of a memory leak in a scripting language parser. The graph mining technique \nidenti.es a non-standard linked-list implementation containing a long series of regu\u00adlar expression matches, \nwhich is helpful but does not fully diagnose the root cause. We postulate that applying holo\u00adgraphic \nexecution to print out the semantic contents of this list could be extremely useful in diagnosing the \nactual source of the leak.  6.4 Static Code Analysis Kozen and Stillerman [12] use a static analysis \nof class ini\u00ad tializers similar to ours to initialize classes eagerly, in or\u00adder to improve startup performance \nand catch errors ear\u00adlier. Their algorithm ignores initializer effects with respect to static .elds, \nbut is .ow-sensitive and hence calculates a more precise de.nition of initialization dependencies than \nour cur\u00adrent implementation. Integrating their approach in the future may improve the success rate of \nour algorithm and hence re\u00adduce the number of initializers that must be marked safely repeatable. 7. \nFuture Work Object holographs appear applicable to several other sources of object behaviour other than \nheap dumps. When debugging a live, remote JVM using the JDI, ob\u00adject holographs could be used to evaluate \nexpressions in a separate client JVM instead of on the target, eliminating the possibility of accidentally \nperturbing the debugged process.  More advanced forms of execution capture, such as om\u00adniscient debugging \n[17], present the state of a process at a single point in time using a similar re.ective model equally \nincompatible with evaluating expressions.  Deterministic replay (DR) is a very active area of re\u00adsearch \n[10] [11] [19] that aims to reproduce a prior execu\u00ad tion of a system by recording some subset of the \nsystem s behaviour, and then instrumenting the system to force non-deterministic operations to behave \nas they previously did. Triggering additional execution in a DR process via a debugger can easily cause \nthe replay to diverge due to the fragile nature of the techniques involved. Using holo\u00adgraphic execution \nto avoid perturbing the DR process ap\u00adpears to be an ideal solution.  An important optimization direction \nis to improve the bytecode loading and translating work.ow. Ideally it should be possible to produce \nhologram bytecode once for each ver\u00adsion of a class as it is developed, rather than repeatedly for each \nheap dump it occurs in. The translation process can\u00adnot currently be applied to a single class .le in \nisolation, however, as the standard JVM bytecode type inferencing al\u00adgorithm requires access to the context \nof the class hierar\u00adchy. Additional engineering effort should make it possible to remove this dependency, \npossibly by abstracting the type inferencing to leave placeholder types and replacing them with actual \ntypes only after caching the translated bytecode. 8. Conclusion We have presented an architecture for \nholographic objects, which enables restricted execution starting from the state captured in a heap dump. \nWe have shown that this architec\u00adture supports analysis that is simple, type-safe, robust, se\u00adcure, and \nfamiliar. It provides a good .t for analysis that depends on application-speci.c semantics, but also \ncom\u00adplements meta-level analysis by supporting a hybrid ap\u00adproach. Our initial experience with our implementation \nfor Java bytecode suggests that this architecture can be effec\u00adtively realized without having to customize \na JVM, and is feasible for heap dump debugging and analysis, as we have presented evidence that holographic \nexecution is competi\u00adtive with live execution. We have also applied this prototype implementation to \ndiagnose a real-world memory leak bug that went unsolved for several months. While this research is still \nrelatively young, we are excited about continuing to build on these initial promising results. Acknowledgments \nWe are extremely grateful for the feedback and encourage\u00adment received from Andrew War.eld, Ronald Garcia, \nand Adrian Kuhn on this work. We also thank the anonymous OOPSLA reviewers for their insightful comments. \nA portion of this work was funded by an NSERC PGS D award and the Institute for Computing, Information \nand Cognitive Systems (ICICS) at UBC. References [1] Clozure cl documentation -4.9. saving applications. \nhttp://ccl.clozure.com/manual/chapter4.9.html# Saving-Applications. [2] Eclipse memory analyzer open \nsource project. http://www. eclipse.org/mat/. [3] B. Alpern, S. Augart, S. Blackburn, M. Butrico, A. \nCocchi, P. Cheng, J. Dolby, S. Fink, D. Grove, M. Hind, et al. The jikes research virtual machine project: \nbuilding an open-source re\u00adsearch community. IBM Systems Journal, 44(2):399 417, 2005. [4] T. Austin, \nT. Disney, and C. Flanagan. Virtual values for language extension. In OOPSLA, pages 921 938. 2011. [5] \nG. Bracha and D. Ungar. Mirrors: design principles for meta\u00adlevel facilities of object-oriented programming \nlanguages. In OOPSLA, pages 331 344. ACM, 2004.  [6] E. Bruneton, R. Lenglet, and T. Coupaye. ASM: a \ncode ma\u00adnipulation tool to implement adaptable systems. In Adaptable and extensible component systems, \n2002. [7] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed lattice model for static analysis \nof programs by construction or approximation of .xpoints. In POPL, pages 238 252, 1977. [8] M. Factor, \nA. Schuster, and K. Shagin. Instrumentation of standard libraries in object-oriented languages: the twin \nclass hierarchy approach. In OOPSLA, pages 288 300, 2004. [9] O. Gruber, B. Hargrave, J. McAffer, P. \nRapicault, and T. Wat\u00adson. The eclipse 3.0 platform: adopting osgi technology. IBM Systems Journal, 44(2):289 \n299, 2005. [10] J. Huang and C. Zhang. Lean: simplifying concurrency bug reproduction via replay-supported \nexecution reduction. In OOPSLA, pages 451 466, 2012. [11] J. Huang, P. Liu, and C. Zhang. LEAP: lightweight \ndetermin\u00adistic multi-processor replay of concurrent java programs. In FSE, pages 207 216, 2010. [12] \nD. Kozen and M. Stillerman. Eager class initialization for java. In FTRTFT, pages 71 80, 2002. [13] D. \nH. Lorenz and J. Vlissides. Pluggable re.ection: decou\u00adpling meta-interface and implementation. In ICSE, \npages 3 13, May 2003. [14] E. K. Maxwell, G. Back, and N. Ramakrishnan. Diagnosing memory leaks using \ngraph mining on heap dumps. In KDD, pages 115 124, 2010. [15] S. Mostinckx, T. Van Cutsem, S. Timbermont, \nand E. Tanter. Mirages: Behavioral intercession in a mirror-based architec\u00adture. In DLS, pages 89 100, \n2007. [16] Oracle. Java platform debugger architecture. http: //docs.oracle.com/javase/7/docs/technotes/ \nguides/jpda/index.html. \u00b4querying for scalable back-in-time debugging. In ECOOP, pages 558 582, 2011. \n[17] G. Pothier and E. Tanter. Summarized trace indexing and [18] G. Xu, A. Rountev, Y. Tang, and F. \nQin. Ef.cient checkpoint\u00ading of java software using context-sensitive capture and re\u00adplay. In ESEC-FSE, \npages 85 94, 2007. [19] Z. Yang, M. Yang, L. Xu, H. Chen, and B. Zang. ORDER: object centric deterministic \nreplay for java. In USENIX, 2011. A. Illegal Native Methods in the JRE This appendix contains our classi.cation \nof all illegal native methods in the JRE. See Figure 4 for the complete list. B. Idempotent Class Initializers \nThis appendix contains the list of classes we found it nec\u00adessary to manually mark as having idempotent \ninitialization, because their initialization state could not be automatically inferred. As mentioned \nin Section 5.3, it is likely that further re.nement of the inference algorithm will eliminate some of \nthese cases. 1. java.lang.re.ect.Modi.er 2. java.net.AbstractPlainSocketImpl 3. java.net.URLClassLoader \n 4. java.security.KeyFactory 5. java.security.SecureClassLoader 6. org.eclipse.equinox.weaving.hooks.Abstract-WeavingHook \n 7. org.eclipse.e4.core.di.internal.extensions.Event-ObjectSupplier 8. org.eclipse.ui.internal.misc.Policy \n 9. sun.re.ect.UnsafeStaticFieldAccessorImpl   Category Class Method Core Class Initialization * registerNatives \njava.lang.System initProperties java.util.concurrent.atomic.AtomicLong VMSupportsCS8 sun.misc.VM initialize \nDrivers sun.print.* * sun.security.smartcardio.* * GUI apple.laf.* * com.apple.eawt.* * com.apple.laf.* \n* com.sun.java.swing.plaf.gtk.* * java.awt.*, sun.awt.* * sun.lwawt.* * Graphics com.sun.imageio.plugins.jpeg.* \n* sun.dc.pr.* * sun.font.* * sun.java2d.* * IO JIT Compilation com.apple.eio.* * com.sun.java.util.jar.pack.NativeUnpack \n* java.io.*, java.nio.*, sun.nio.* * java.util.logging.FileHandler * java.util.prefs.* * sun.misc.MessageUtils \n* java.lang.Compiler * Java 7 Method Handles java.lang.invoke.* * Management com.sun.demo.jvmti.hprof.* \n* oracle.jrockit.jfr.* * sun.management.* * sun.misc.Perf * sun.tracing.dtrace.JVM * Media com.sun.media.sound.* \n* Native Libraries java.lang.ClassLoader$NativeLibrary * java.lang.System mapLibraryName Network java.net.*, \nsun.net.* * sun.rmi.* * Security Shared superclass apple.security.*, sun.security.* * java.lang.Object \n* java.lang.Throwable * System apple.applescript.* * apple.launcher.* * com.apple.concurrent.* * com.apple.jobjc.* \n* com.apple.resources.LoadNativeBundleAction * com.sun.management.* * java.lang.ProcessEnvironment environ \njava.lang.Runtime * java.lang.UNIXProcess * java.util.TimeZone * sun.misc.GC * sun.misc.NativeSignalHandler \n* sun.misc.Signal * Figure 4. Categorization of forbidden methods in the Java Runtime Environment. \n  \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Debugging and analyzing a snapshot of a crashed program's memory is far more difficult than working with a live program, because debuggers can no longer execute code to help make sense of the program state. We present an architecture that supports the restricted execution of ordinary code starting from the snapshot, as if the dead objects within it had been restored, but without access to their original external environment. We demonstrate the feasibility of this approach via an implementation for Java that does not require a custom virtual machine, show that it performs competitively with live execution, and use it to diagnose an unresolved memory leak in a mature mainstream application.</p>", "authors": [{"name": "Robin Salkeld", "author_profile_id": "81487654071", "affiliation": "University of British Columbia, Vancouver, Canada", "person_id": "P4290336", "email_address": "rsalkeld@cs.ubc.ca", "orcid_id": ""}, {"name": "Gregor Kiczales", "author_profile_id": "81100495415", "affiliation": "University of British Columbia, Vancouver, Canada", "person_id": "P4290337", "email_address": "gregor@cs.ubc.ca", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509543", "year": "2013", "article_id": "2509543", "conference": "OOPSLA", "title": "Interacting with dead objects", "url": "http://dl.acm.org/citation.cfm?id=2509543"}