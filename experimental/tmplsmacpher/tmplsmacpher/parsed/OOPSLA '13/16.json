{"article_publication_date": "10-29-2013", "fulltext": "\n Ironclad C++ A Library-Augmented Type-Safe Subset of C++ Christian DeLozier Richard Eisenberg Santosh \nNagarakatte Peter-Michael Osera Milo M. K. Martin Steve Zdancewic Computer and Information Science Department, \nUniversity of Pennsylvania Computer Science Department, Rutgers University {delozier, eir, posera, milom, \nstevez}@cis.upenn.edu santosh.nagarakatte@cs.rutgers.edu Abstract The C++ programming language remains \nwidely used, de\u00adspite inheriting many unsafe features from C features that often lead to failures of \ntype or memory safety that manifest as buffer over.ows, use-after-free vulnerabilities, or abstrac\u00adtion \nviolations. Malicious attackers can exploit such viola\u00adtions to compromise application and system security. \nThis paper introduces Ironclad C++, an approach to bringing the bene.ts of type and memory safety to \nC++. Ironclad C++ is, in essence, a library-augmented, type-safe subset of C++. All Ironclad C++ programs \nare valid C++ programs that can be compiled using standard, off-the-shelf C++ compilers. However, not \nall valid C++ programs are valid Ironclad C++ programs: a syntactic source-code val\u00adidator statically \nprevents the use of unsafe C++ features. To enforce safety properties that are dif.cult to check statically, \nIronclad C++ applies dynamic checks via templated smart pointer classes. Using a semi-automatic refactoring \ntool, we have ported nearly 50K lines of code to Ironclad C++. These benchmarks incur a performance overhead \nof 12% on average, compared to the original unsafe C++ code. Categories and Subject Descriptors D.3.3 \n[Language Constructs and Features]: Dynamic storage management General Terms Languages, Performance, \nReliability, Se\u00adcurity Keywords C++; type safety; memory safety; local pointers Permission to make digital \nor hard copies of part or all of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for third-party components of this work must be honored. \nFor all other uses, contact the owner/author(s). OOPSLA 13, October 29, 2013, Indianapolis, IN, USA. \nCopyright &#38;#169; 2013. Copyright is held by the owner/author(s). ACM 978-1-4503-2374-1/13/10. 1. \nIntroduction C and C++ are widely used programming languages for im\u00adplementing web browsers, native mobile \napplications, com\u00adpilers, databases, and other infrastructure software [33]. C and C++ provide ef.ciency \nand low-level control, but these advantages come at the well-known cost of lack of memory and type safety. \nThis unsafety allows programming errors such as buffer over.ows (accessing location beyond the ob\u00adject \nor array bounds), use-after-free errors (accessing mem\u00adory locations that have been freed), and erroneous \ntype casts to cause arbitrary memory corruption and break program\u00adming abstractions. More dangerously, \nmalicious attackers exploit such bugs to compromise system security [29]. Recognizing this problem, many \napproaches have been proposed to prevent memory safety violations or enforce full memory safety in C \nand C-like languages [2, 4, 9, 10, 12, 14, 17, 23 25, 31, 36]. Collectively, these prior works iden\u00adti.ed \nseveral key principles for bringing safety ef.ciently to C. However, one challenge in making C memory \nsafe is that C provides limited language support for creating type\u00adsafe programming abstractions. In \ncontrast, although C++ includes many unsafe features, C++ also provides advanced constructs that enable \ntype-safe programming, such as tem\u00adplates and dynamically checked type-casts. Ironclad C++ is our proposal \nto bring comprehensive memory and type safety to C++. Ironclad C++ is, in essence, a library-augmented \n[32] type-safe subset of C++. As such, an Ironclad C++ program is a valid C++ program (but not all C++ \nprograms are valid Ironclad C++ programs). Dynamic checking is implemented in a smart pointer library, \nso no language extensions or compiler changes are required. Iron\u00adclad C++ uses a syntactic static validation \ntool to ensure the code conforms to the Ironclad C++ subset of C++, and the code is then compiled using \nan unmodi.ed off-the-shelf C++ compiler (see Figure 1). This paper describes Ironclad C++ and reports \non our ex\u00adperience programming in this type-safe subset of C++, in\u00adcluding: http://dx.doi.org/10.1145/2509136.2509550 \n Figure 1. Work.ow for coding with Ironclad C++ a C++ smart pointer library that ef.ciently and compre\u00adhensively \nenforces strong typing and bounds safety,  a hybrid static dynamic checking technique that prevents \nuse-after-free errors for stack objects, without requiring costly heap allocation,  an opt-in, source-level \nheap-precise garbage collector de\u00adsigned to reduce memory leaks due to conservative GC,  tools for semi-automated \nrefactoring of existing C and C++ code into the Ironclad subset of C++ and a validator that enforces \ncompliance with that subset, and  experimental evaluation of the performance overheads of this approach \nto enforce memory safety.  To evaluate practicality and performance, we refactored several C/C++ programs \nover 50K lines in total into Ironclad C++. We performed this translation with a semi\u00adautomatic refactoring \ntool we created to assist in this conversion, and we report our experiences converting these programs. \nWe also converted multiple test suites designed for evaluating memory safety bug detectors, which con\u00ad.rmed \nthat Ironclad C++ does successfully detect memory access violations. Using performance-oriented benchmarks, \nwe measured an average performance overhead of 12% for enforcing complete type and memory safety. 2. \nOverview and Approach Type-safe languages such as Java and C# enforce type safety through a combination \nof static and dynamic enforce\u00adment mechanisms such as static typing rules, dynamically checked type casts, \nnull dereference checking, runtime bounds checking, and safe dynamic memory management. In such languages, \nviolations of type safety are prevented by either rejecting the program at compile time (type errors) \nor raising an exception during execution. The aim of Ironclad C++ is to use this same set of familiar \nstatic/dynamic enforcement mechanisms to bring type-safety to C++ while retaining much of the syntax, \nperformance, and ef.ciency of C++. To provide context on how these enforcement mechanisms apply to C/C++, \nthis section overviews some key principles of ef.cient type safety for C, surveys their implementations \nin prior work, and describes how these principles can be brought to C++ by leveraging existing language \nfeatures. Differentiating array pointers from non-array point\u00aders. Several prior memory safety proposals \nhave recognized the performance bene.t of distinguishing between a pointer to an array (which requires \nbounds information) versus a pointer to non-array (a.k.a. singleton) object (which does not). Doing so \nautomatically has typically relied on whole\u00adprogram analysis at compile time or introduced language ex\u00adtensions. \nFor example, CCured [25] uses a whole-program type inference at compile time to distinguish between sin\u00adgleton \nand array pointers, Cyclone [17] introduces different type decorators, and some pool allocation approaches \n[9] create type-homogeneous pools of singleton objects. Sys\u00adtems without such differentiation implicitly \ntreat all pointers as array pointers, adding unnecessary space and time over\u00adheads for bounds checking. \nIronclad C++ captures this differentiation between single\u00adton and array pointers without language extension \nor whole\u00adprogram analysis during each compilation by using the well\u00adknown C++ technique of smart pointers \n[1, 2, 8]. Smart pointers leverage C++ s template and operator overloading constructs, and they have \npreviously been used to dynam\u00adically insert safety checks [2] or perform reference count\u00ading [8] on pointer \noperations. Ironclad C++ requires that all bare C++ pointer types be replaced with one from a suite of \nsmart pointers, some of which include bounds information and thus support pointer arithmetic and indexing \n(for array pointers) and some that avoid the bounds checking overhead (for singleton pointers). The distinction \nbetween singleton and array smart pointer types allows their overloaded oper\u00adators to perform the minimum \ndynamic checking necessary to detect bounds violations based on the type of the pointer. Enforcing strong \ntyping. C s use of void* and unchecked type casts results in either pessimistic typing assumptions, which \ncan signi.cantly increase the overhead of dynamic checking [23, 27], and/or the failure to detect all \nmemory safety violations. Disallowing unsafe casts in C reduces checking overhead, but doing so has typically \nrequired augmenting the C language in some way. For example, Cyclone found it necessary to support generics, \nCCured adds RTTI (run-time type information) pointers, and both support structural subtyping. However, \nC++ already provides alternatives to C s unsafe constructs (for example, templates and class hierarchies). \nYet, to facilitate adoption, C++ inherited many of C s unsafe constructs. Ironclad C++ takes a different \napproach and explicitly enforces strong typing by disallowing legacy type-unsafe constructs and requiring \nthat all pointer type-cast operations are either known to be safe statically or checked dynamically (by \nbuilding upon C++ s existing dynamic_cast construct). Heap-safety through conservative garbage collection. \nIronclad C++ s smart pointers provide strong typing and bounds safety, but they do not prevent use-after-free \ner\u00adrors. To avoid the overhead of reference counting [12] or use-after-free checking [2, 24, 36], Ironclad \nC++ facilitates the use of conservative garbage collection [7] by targeting a key challenge of using \nconservative GC to enforce safety: conservative collection can lead to non-deterministic memory leaks \n(due to non-pointer data that looks like a pointer) [5, 30]. To reduce such memory leaks due to conservative \ngarbage collection, Ironclad C++ supports heap-precise garbage collection. Inspired by prior work on \nmostly-copying and more-precise conservative garbage collection [3, 11, 15, 30], Ironclad s collector \ntreats the roots conservatively but supports the precise identi.cation of pointers in heap objects by \nemploying mark() class methods to precisely identify pointer .elds and pointer containing members. Facilitating \nstack-allocation safety. Garbage collection does not prevent dangling pointers to stack objects. In recog\u00adnition \nof this problem, CCured prevents use-after-free errors to stack objects by selectively converting escaping \nstack\u00adallocated objects into heap-allocated objects (a.k.a. heapi\u00ad.cation), which unfortunately introduces \nsigni.cant perfor\u00admance overheads in some programs [25]. To prevent use\u00adafter-free errors for stack allocated \nmemory without the per\u00adformance penalties of heapi.cation, this paper introduces hybrid static-dynamic \nchecking of stack pointer lifetimes. The hybrid checking in Ironclad C++ avoids the perfor\u00admance overheads \nof heapi.cation with simple static check\u00ading and limited dynamic checking. Validating conformance statically. \nStatically validating that code conforms to the rules of Ironclad C++ is paramount for ensuring safety. \nWithout some form of static validation, smart pointer schemes cannot alone provide a guarantee of safety \nbecause unsafe constructs can still be used outside of the use of smart pointers, and smart pointers \ncan be used incorrectly. Our current prototype divides this responsibility between two checkers. First, \nwe created a static code valida\u00adtor that checks basic syntactic properties of the program to ensure that \nit conforms to the Ironclad C++ subset (e.g., no raw pointers). Second, after carefully precluding unsafe \ncon\u00adstructs with the validator, we then leverage the existing C++ type checker to complete the remaining \nchecking of type safety. This use of strong static validation distinguishes Iron\u00adclad C++ s approach \nfrom other non-validated smart pointer approaches [2, 8] and mark() methods for precise garbage collection \n[3, 30]. 3. Bounds Checking &#38; Strong Static Typing The Ironclad dialect of C++ is formed by .rst \nproviding safe idioms via the Ironclad C++ library (e.g., the smart point\u00aders described in Table 1) and \nthen disallowing the use of unsafe language features (e.g., disallowing the use of raw pointers). In \nthis way, Ironclad C++ brings memory and type safety to C++ using a combination of static code validation, \nthe standard C++ type checker, and dynamic safety checks. A code validator, described in Section 7, statically \nenforces that disallowed constructs are not used. This section .rst de- : Arbitrary pointer arithmetic \nis permitted because a bounds check occurs before an aptr is dereferenced. Type Capabilities Safety Checks \nptr Dereference Null Check aptr Dereference Index Arithmetic Bounds Check Bounds Check No Check lptr \nDereference Receive address-of object Receive this pointer Null Check Lifetime Check Lifetime Check laptr \nDereference Receive address-of object Receive this pointer Hold static-sized array Index Arithmetic Bounds \nCheck Lifetime Check Lifetime Check Lifetime Check Bounds Check No Check Table 1. This table describes \nthe capabilities and safety checks performed by each pointer type. As more letters are added to the type, \nthe capabilities increase, but the overhead also increases due to additional required checks. scribes \nsafety without considering arrays or memory deallo\u00adcation (Section 3.1), it then describes support for \nreferences (Section 3.2), arrays, and pointer arithmetic (Section 3.3). Further sections discuss memory \ndeallocation safety for the heap (Section 4) and stack (Section 5). 3.1 Strong Static Typing with ptr<T> \nIronclad C++ requires replacing all raw C++ pointer types with templated smart pointer types. For referring \nto singleton (non-array) objects, Ironclad C++ provides the ptr<T> class. Because new returns a raw pointer, \nIronclad C++ provides a replacement for performing heap allocation, new_obj<T>(...), which uses new internally \nbut returns a ptr<T> (rather than returning a T*). Similarly, calls to delete are replaced by destruct(), \nwhich calls the pointed-to object s destructor (but it does not neces\u00adsarily deallocate the underlying \nmemory, as described in Section 4). Accordingly, the following C++ code: Rectangle* p = new Rectangle(2, \n5); ... delete p; Would be rewritten in Ironclad C++ as: ptr<Rectangle> p = new_obj<Rectangle>(2, 5); \n... p.destruct(); C++11 s variadic templates allow new_obj to accept arbi\u00adtrary arguments to pass along \nto the underlying object con\u00adstructor. Rule (Pointers). All pointer types are transformed to ptr<T> (or \none of its variants, described below) provided by the Ironclad C++ library. Raw pointers are disallowed. \n Example: Strong Static Typing float radius(Shape* shape) { Circle* circle = static_cast<Circle>(shape); \nreturn circle->radius; } float radius(ptr<Shape> shape) { ptr<Circle> circle = cast<Circle>(shape); return \ncircle->radius; } Example: Bounds Checking float* computeArea(Shape* shapes, int N) { float* areas = \nnew float[N]; for(int i = 0; i < N; ++i) { float r = radius(shapes); areas[i] = PI * (r * r); shapes++; \n} return areas; } aptr<float> computeArea(aptr<Shape> shapes, int N) { aptr<float> areas = new_array<float>(N); \nfor(int i = 0; i < N; ++i) { float r = radius(shapes); areas[i] = PI * (r * r); shapes++; } return areas; \n} Figure 2. Comparison of C++ syntax (left) and Ironclad C++ syntax (right). Supporting type casts safely. \nBy disallowing raw pointers, Ironclad C++ also implicitly disallows both void* pointers and unsafe pointer-to-pointer \ncasts. To support safe pointer-to-pointer casts, Ironclad C++ provides a cast<T> function template to \nsafely cast a ptr<S> to a ptr<T>. Figure 2 shows an example of casting from a ptr<Shape> to a ptr<Circle>. \nThe cast<T>(...) function is a wrapper over C++ s existing dynamic_cast operation, which is used to cast \nbetween members of a class hierarchy. Casts between incompatible types will be caught either: (1) dur\u00ading \ncompilation when the template is instantiated (e.g., when attempting a cast that can be proven invalid \nduring type-checking) or (2) when the underlying dynamic_cast fails at runtime due to an incompatible \ntype, setting the resulting pointer to NULL. Casting from void* or integers to a pointer is not supported \nby C++ s dynamic_cast, so this use of dynamic_cast statically enforces that a ptr cannot be created from \nan integer or void* pointer. Uses of void* pointers can generally be eliminated by refactoring the code \nto use inheritance or templates (e.g., to implement generic containers, which is one use-case of void*). \nNote that Ironclad C++ does not restrict cast operations (type conversions) among non-pointer types, \nsuch as ints and doubles, because such type conversions are well-de.ned and do not violate memory safety. \nFor example, if a variable is cast from a negative int to an unsigned int and then used as an index into \nan array, the possibly out-of-bounds index will be caught by Ironclad C++ s dynamic checks. Thus, type-conversions \ndo not violate memory safety in Ironclad C++. Rule (Pointer Casts). Pointer casts must use cast<T>(...), \nprovided by the Ironclad C++ library. C-style unions are not allowed in Ironclad C++ because, unlike \ntype-casts on non-pointer types, the implicit cast be\u00adtween types that occurs through the use of a union \ncan lead to unde.ned behavior [16]. Unions are less prevalent in C++ compared to C because only POD (plain \nold data) types can be used in unions. Rule (Unions). Unions are disallowed in Ironclad C++. Dynamic \nNULL checking. As ptr<T> pointers may point only to singleton objects (arrays and pointer arithmetic \nare handled in the next subsection), the ptr<T> class explic\u00aditly does not overload the operators for \nperforming array indexing and pointer arithmetic, so the standard C++ type checker disallows such operations \nduring compilation. How\u00adever, dereferencing a NULL pointer is an illegal memory oper\u00adation. To prevent \nthis, the overloaded dereference operations (* and ->) in ptr check for NULL prior to performing the \ndereference. Although many NULL dereferences would result in a segmentation fault, the explicit check \nis still necessary. Consider a program in which p is NULL and is a pointer to type struct Foo{int a[1000000]; \nint x;}. Without an explicit NULL check, the expression p->x would attempt to address at address 1000000*sizeof(int), \nwhich could result in arbitrary memory corruption. Checking for NULL before dereference also catches \nthe dereference of a ptr that resulted from an invalid dynamically checked pointer cast. 3.2 C++ References \nReferences in C++ (T&#38;) are similar to pointers but differ in a few ways that allow them to be treated \ndifferently in Iron\u00adclad C++. References must be initialized when declared, as shown below. Object&#38; \nr = *p; // p has type ptr<Object> Once a reference has been initialized, the location that the reference \npoints to cannot change. In Ironclad C++, the NULL check performed during the dereference of a pointer \n( *p in the above code) prevents the creation of NULL references. By preventing the creation of NULL \nreferences, there is no need to perform a NULL check on the use of a reference. Thus, unlike raw pointers, \nwhich must be wrapped using smart pointers, C++ style references are allowed in Ironclad C++. References \nwill be further dis\u00adcussed in Section 5.3.  3.3 Bounds Checking with aptr<T> Ironclad C++ supports \nstatic-sized arrays, dynamic-sized ar\u00adrays, and pointer arithmetic by providing the array<T,N> and aptr<T> \n( array pointer ) classes. For static-sized ar\u00adrays, the Ironclad C++ library provides a templated array \nclass array<T,N>. This class overrides the index operator and checks that the requested index (an unsigned \nint) is less than N before returning the requested element. To create an array<T,N>, the size N of the \nallocated array must be known at compile time. Rule (Static-sized Arrays). All static-sized arrays must \nbe replaced by array<T,N>. To support dynamic-sized arrays, Ironclad C++ provides an aptr<T> class. The \naptr<T> class replaces raw pointers for referring to either dynamically or statically sized arrays. To \nperform the necessary bounds checking, each aptr is a three-element fat pointer with a pointer to the \nbase of the array, the current index, and the maximum index. A bounds check is performed on each dereference \nor array index oper\u00adation. This bounds check will fail if the pointer is NULL, so a separate NULL check \nis not needed. Arbitrary pointer arith\u00admetic is allowed, and the bounds check during dereference and \narray indexing are suf.cient to detect invalid pointer arithmetic. To heap allocate new dynamically sized \narrays, the Ironclad C++ library provides new_array<T>(size) function, which returns an aptr<T> created \nby calling new. Accordingly, the following C++ code: Foo* p = new Foo[number]; ... delete[] p; Would \nbe rewritten in Ironclad C++ as: aptr<Foo> p = new_array<Foo>(number); ... p.destruct(); Figure 2 shows \nan example of creating and using an array in Ironclad C++. As shown, only the type and allocation of \nthe array must be rewritten to conform to Ironclad C++; all other array pointer operations are performed \nusing overloaded op\u00aderators. Rule (Array Pointers). Pointers to dynamic and static arrays must be replaced \nby aptr<T>. Ironclad C++ provides both ptr<T> and aptr<T> be\u00adcause they provide different tradeoffs: \nptr does not provide indexing or pointer arithmetic operators, but it avoids the performance and storage \noverheads incurred by the bounds checking for aptr. The Ironclad C++ library provides an im\u00adplicit conversion \nfrom aptr<T> to ptr<T>, allowing a ptr to point to a single element of an array. During such a con\u00adversion, \nif the aptr is invalid (not in bounds) the ptr is set to NULL. 3.4 Pointer Initialization If pointers \nwere allowed to be uninitialized, a pointer could contain garbage and point to arbitrary memory. Therefore, \nIronclad C++ ensures that pointers are properly initialized by setting the underlying raw pointer to \nNULL in the default constructor for each smart pointer class. In one particularly insidious corner case, \nthe order of ini\u00adtialization of members of a class may allow a smart pointer to be dereferenced before \nits constructor has been called: class Foo { int x; ptr<int> p; Foo() : x(*p) // initializer list { ... \n// body of constructor } }; To ensure proper initialization, the initializer expression for any data \nmember must not use a smart pointer data member .eld that was declared subsequent to the data member \nbe\u00ading initialized (in C++ the order of initialization of .elds is determined by the order in which they \nwere declared in the class declaration). To enforce the above rule, Ironclad C++ also disallows the use \nof the this pointer and method calls within any initializer list expression for a data member .eld that \nwas declared prior to any smart pointer data member .eld. The static validator enforces these requirements. \nRule (Init.). A ptr<T> must be initialized before use. 3.5 The C Standard Library The C Standard Library \ncontains utility functions, standard types, I/O functions, functions on C-strings (char *), and other \nfunctionality. To ensure safety, Ironclad C++ disallows the use of some of the available headers (e.g., \n<csetjmp>) and replaces others with safe versions. A few of the C stan\u00addard library headers contain functions \nthat consume C-string parameters without checking to see if the C-string is properly null terminated \nor large enough to perform the operation. Even the functions in <cstring> that take a size parame\u00adter, \nsuch as strncpy, can violate memory safety if the size parameter is incorrect. Ironclad C++ provides \nsafe functions to replace each of these unsafe functions. These functions take aptr<char> parameters \ninstead of char* and check that the inputs are null-terminated and within the speci.ed bounds. Two spe\u00adci.c \nfunctions memset and memcpy are unsafe in C++. Calling memset can accidentally overwrite virtual pointers; \nmemcpy ignores any effects that copy constructors might have. Ironclad C++ replaces memset and memcpy \nwith the functions zero<T> and copy<T>. The zero function iter\u00adates through the input array and sets \neach element to 0. The copy function assigns each element of the source array to the corresponding element \nin the destination array. To im\u00adprove performance, the zero and copy functions have hand\u00adoptimized template \nspecializations for standard data types, such as char.  The <cstdio> header contains C-style variable \nargument functions that rely on the programmer to provide a correct format string. In C++11, the unsafe \nuse of va_list can be replaced by the type-safe use of variadic templates. Using variadic templates, \nIronclad C++ checks that the number and type of arguments provided to functions such as printf and scanf \nmatches the arguments expected by the format string. Rule (C Standard Library Functions). Uses of unsafe \nC Standard Library functions must be replaced with their corresponding safe variant (e.g., strlen(const \nchar *) with safe_strlen(aptr<const char>)). 4. Heap-Precise Garbage Collection Along with strong typing \nand bounds checking, dealloca\u00adtion safety (i.e., no dangling pointers) is the .nal require\u00adment for comprehensive \ntype and memory safety. In many languages, including C++, pointers can refer to both heap\u00adallocated and \nstack-allocated objects. In standard C++, heap\u00adallocated objects are created using new and explicity \ndeallo\u00adcated using delete. Stack-allocated objects are automati\u00adcally allocated and deallocated on function \nentry and exit, respectively. Ironclad C++ uses separate mechanisms for enforcing deallocation safety \nfor heap-allocated and stack\u00adallocated objects. For heap-allocated objects, Ironclad C++ relies on a \nconservative garbage collector to delay the deal\u00adlocation of heap objects until a time at which it is \nknown to be safe (i.e., no references to the object remain). 4.1 Conservative Collection For many applications, \na conservative, mark-sweep garbage collector prevents dangling pointers for heap allocations with reasonable \nperformance overheads. Unlike reference counting [12] (which requires work on every pointer assignment), \ndynamic allocation checking [2, 24] (which requires work on every pointer dereference), and precise garbage \ncollection (which requires work to provide safe points), conservative garbage collection performs work \nonly when the allocator requires more free memory than is currently available. At that time, the collector \nconservatively scans the program roots (e.g., stack, registers, and globals) for pointers to heap allocations \nand pushes each identi.ed address onto a mark stack. Collection then proceeds by (1) popping an address \nto an allocation off of the mark stack, (2) discarding the address if it has already been marked, (3) \nperforming the marking operation by conservatively scanning the allocation region for any values that \nare potential pointers, (4) pushing all such values onto the mark stack, and (5) recording that the allocation \nhas been marked. This process repeats until the mark stack is empty. Finally, the collector frees all \nallocations that were not recorded as having been marked [19].  class Circle : // Inherits from Shape \n&#38; IroncladPreciseGC public Shape, public IroncladPreciseGC { private: Color color; ptr<Point> center; \ndouble radius; public: void mark() { Shape::mark(); // Marks the base class color.mark(); // Marks the \ncolor object center.mark(); // Enqueues on mark stack // radius is primitive, no need to mark } }; Figure \n3. Example of mark() methods for heap-precise collection. Calling mark() on the ptr<Point> object pushes \nits address onto the mark stack to ensure that the col\u00adlector marks the referred to Point object. Although \nconservative garbage collection exhibited low runtime and memory overheads on many programs (includ\u00ading \nmost of the benchmarks we use for evaluations in Sec\u00adtion 9), some programs suffer from large memory \nover\u00adheads due to a well-known weakness of conservative collec\u00adtion in which memory leaks can occur due \nto non-pointer data (such as .oating-point numbers) that looks like a pointer [15, 30, 34]. Several approaches \nhave been proposed to mitigate this problem. The Boehm-Demers-Weiser col\u00adlector performs blacklisting \nto avoid allocating on pages that have previously been pointed to by non-pointer data [7]. It also provides \nan interface for providing precise pointer iden\u00adti.cation bitmap descriptors for allocated data [5]. \nA pro\u00adposal was put forth (although not accepted) for C++11 that would have added keywords to C++ for \nprecise identi.ca\u00adtion of speci.ed gc_strict classes [6]. Prior approaches have proposed methods for \nprecisely identifying pointers in the heap either by tracking pointers on creation and destruc\u00adtion [11] \nor calling tool-generated or user-de.ned methods for precisely identifying an object s pointer and pointer \ncon\u00adtaining members [3, 30].  4.2 Heap-Precise Collection Building on these prior works, Ironclad C++ \nadopts opt-in heap-precise garbage collection. To enable heap-precise col\u00adlection, a class (1) provides \na mark() method that precisely identi.es all of the pointers in the allocation and (2) inherits non-virtually \nfrom IroncladPreciseGC, which is used as a type tag to inform the collector (i.e., in new_obj<T>(...)) \nto call the mark() method when scanning the allocation. Like the conservative collector, heap-precise \ncollection begins by conservatively scanning the program roots for pointers to the heap and pushing each \nidenti.ed address onto the mark stack. The collector then proceeds as usual by popping an address to \nan allocation off of the mark stack, discarding the address if it has already been marked. To perform \nthe marking operation, the collector invokes the mark() method on the object, which precisely identi.es \nall pointers in the allocation and pushes them onto the mark stack. If the type of the allocation does \nnot inherit from the IroncladPreciseGC class, the collector falls back to us\u00ading the conservative marking \nstrategy. Like the conservative collector, once the allocation has been processed, the alloca\u00adtion is \nrecorded as having been marked. This process repeats until the mark stack is empty, and the collector \nfrees all allo\u00adcations that have not been marked.  4.3 Requirements for Precise Marking For an object \nto be precisely marked, all of the objects that it directly contains (i.e., not pointers to objects) \nand all of its base classes must de.ne mark() methods because the heap-precise collector must be aware \nof all pointers in the physical layout of the marked object. A class s mark() is responsible for adding \nall pointers contained in the object to the mark stack, including all pointer that are data member .elds, \nin object .elds, or in an inherited-from base class. The mark() method accomplishes this task by calling \nmark() on all smart pointers data members, on all object data member .elds, and on all inherited-from \nbase classes. The mark() method of each smart pointer class pushes the address onto the mark stack. The \nmark() methods of the object s data members will in turn subsequently call mark() methods on their .elds, \nresulting in all pointers contained by the alloca\u00adtion being added to the mark stack. Primitive non-pointer \ntypes need not be marked. Figure 3 provides an example mark() method for a simple class hierarchy. Calling \nthe mark() method on class that does not actually contain point\u00aders is unlikely to hurt performance because \nsuch mark() methods will be empty and de.ned in the class s header .le, allowing them to be optimized \naway by the compiler s in\u00adlining pass. The heap-precise collector uses template spe\u00adcialized mark() methods \nfor arrays of primitive data types. Primitive types do not contain pointers, so these methods do nothing \nand thus avoid the overhead of scanning an array when it clearly does not contain pointers. In Ironclad \nC++, the mark() methods are supplied by the programmer and part of the program s permanent source code. \nTo ensure safety, the mark() methods are checked for conformance with the above rules by the Ironclad \nC++ validator (Section 7), unlike prior systems that utilize programmer-supplied marking [3, 30]. To \nassist the programmer, the Ironclad C++ refactoring tool can automatically generate mark() methods in \nmany cases.  4.4 Object Destruction In C++, calling delete on a heap-allocated object will de\u00adstruct \nthe object and reclaim the memory in which the object had been allocated. In Ironclad C++, the garbage \ncollector reclaims memory only once an object becomes unreachable. Therefore, Ironclad C++ divides the \nfunctionality otherwise provided by delete between the garage collector, which re\u00adclaims the object s \nmemory, and the destruct() method (provided by ptr and aptr), which explicitly calls the ob\u00adject s destructor. \nThis approach avoids the problem of calling destructor asynchronously, but it has the disadvantage that \nIronclad C++ does not prevent a program from accessing an object after its destructor has been called. \nSuch an access although certainly a bug in the program does not violate type safety because the garbage \ncollector ensures the under\u00adlying memory is still valid (i.e., has not be reclaimed) and thus remains \nproperly typed. 5. Stack Deallocation Safety via lptr Although garbage collection prevents all dangling \npointers to objects on the heap, it does not protect against dangling pointers to stack-allocated objects. \nOne way to prevent such errors is to forgo some of the ef.ciency bene.ts of stack allo\u00adcation by limiting \nthe use of stack allocation to non-escaping objects only (a.k.a. heapi.cation). To avoid the performance \npenalties of heapi.cation, Ironclad C++ provides additional templated smart pointers that, cooperatively \nwith the static code validator and C++ type checker, uses dynamic lifetime checking to prevent use-after-free \nerrors for stack allocations while avoiding heapi.cation in almost all cases. 5.1 Heapi.cation A common \napproach for preventing use-after-free errors for stack allocations in a garbage collected system is \nsimply to restrict stack allocations by employing heapi.cation [25], which is the process of heap-allocating \nan object that was originally allocated on the stack. Heapi.cation enforces deallocation safety by conservatively \ndisallowing any object whose address might escape the function from being allo\u00adcated on the stack. For \nexample, without inter-procedural analysis, heapi.cation requires heap allocation of any object whose \naddress is passed into a function. This is a particular challenge for C++ code, because object methods \nand constructors are implicitly passed the address of the object (the this pointer), thus disallowing \nstack allocation of almost all objects unless inter-procedural analysis could prove otherwise. Unfortunately, \nheapi.cation results in signi.cant performance degradations in some cases (see Section 9.5).  5.2 Dynamic \nLifetime Checking Ironclad C++ reduces the need for heapi.cation by focusing on preventing the two causes \nof dangling pointers to stack al\u00adlocations: stack addresses that escape to the heap or globals and stack \naddresses that escape to longer-living stack frames. To prevent dangling pointers to the stack, Ironclad \nC++ identi.es, tracks, and prevents the unsafe escape of stack addresses using two additional templated \npointer classes, lptr<T> and laptr<T>, called local pointers. Prior work on preventing use-after-free \nerrors has introduced some no\u00adtion of a local pointer [10, 21], but these efforts have been focused on \npurely static enforcement through sophisticated program analyses.  To prevent stack addresses from escaping \nto the heap or globals (example shown in Figure 4(a)), Ironclad C++ com\u00adbines static restrictions on \nwhere stack addresses may exist in memory with a dynamic check on assignment between lo\u00adcal pointers \nand non-local pointers (ptr and aptr). Ironclad C++ does not place any restrictions on where ptr and \naptr can be allocated; ptr and aptr can both exist on the heap or as globals. Therefore, it is unsafe \nfor a ptr or aptr to hold the address of a stack allocation. In C++, the address of a stack allocation \ncan be initially accessed by using the address-of operator (&#38;), using the this pointer of a stack \nallocated object, or by implicitly con\u00adverting from a stack allocated array to a pointer. Although operations \nsuch as address-of may also produce a non-stack address (i.e. if applied to a global variable), Ironclad \nC++ requires that the result of any operation that may produce a stack address be held by an lptr or \nlaptr. More concretely, Ironclad C++ requires that stack addresses can only be held by lptr and laptr. \nRule (Stack Pointers). Any pointer to stack object must be held by an lptr or laptr. Given that local \npointers can hold stack addresses, and stack addresses should not be allowed to escape to the heap or \nglobals, it follows that local pointers cannot be stored in the heap or globals. That is, local pointers \nare limited to use as local variables and function parameters. Rule (Local Pointer Location). A local \npointer may only exist on the stack. Although it is unsafe for a non-local pointer to point to a stack \nallocation, a local pointer can safely point to the heap or globals. Further, the address held by a local \npointer can be safely assigned into a ptr or aptr if the address refers to the heap or globals. When \nassigning to a ptr or aptr from an lptr or laptr, the assignment operator performs a dynamic check to \nensure the address being written into the ptr or aptr is actually a heap or global address; if the address \nis a stack address, the check fails and an exception is raised. No such check is required when assigning \na ptr into a ptr (or aptr into an aptr). Dangling pointers to stack-allocated objects can occur even \nwithout placing a pointer to a stack object in the heap or globals. As illustrated in Figure 4(b), a \nstack address es\u00adcaping to longer living stack frames can also cause a dan\u00adgling pointer error. To prevent \ndangling pointers from one stack frame to another, local pointers record a lower bound on stack addresses \nto which they may point.1 Local point\u00aders are allowed to point only to stack allocations at the same \nlevel or above in the call stack. Local pointers ensure that 1 The use of lower here assumes that a stack \ngrows down through its memory region. each assignment into or out of the local pointer will not cre\u00adate \na dangling pointer. Overall, Ironclad C++ enforces the following invariant to ensure deallocation safety \nwith regard to stack allocations. Invariant (Pointer lifetime). The lifetime of a pointer may not exceed \nthe lifetime of the value that it points to. To more concretely explain the dynamic checks applied by \nlocal pointers, we give a case-by-case analysis of the non\u00adtrivial assignments between lptr and ptr. \nCase: Assign from ptr<T> into lptr<T> In this case, the address being assigned into the lptr points to \nthe heap or globals. Therefore, the address can be safely assigned into the lptr. Case: Assign from lptr<T> \ninto ptr<T> To assign from an lptr into a ptr, the address currently held by the lptr must point to a \nheap or global value. A dynamic check is performed to ensure that the address held by the lptr points \nto a heap or global value. If the lptr points to a stack value, the check fails. Case: Assign from lptr<T> \ninto lptr<T> In this case, the address held by the source lptr is as\u00adsigned into the destination lptr. \nIf the source lptr cur\u00adrently points to a heap or global value, execution pro\u00adceeds as in the .rst case. \nIf not, the destination lptr must check that the address held by the source lptr is not be\u00adlow the minimum \naddress allowed to be held by the des\u00adtination lptr, which is de.ned by the destination lptr s lower \nbound. To ensure the correct use of local pointers, Ironclad C++ places a few restrictions on where local \npointers may be used. First, a function may not return a local pointer. Sec\u00adond, as noted earlier, a \nlocal pointer may not be allocated on the heap. From the second restriction, it follows that a local \npointer may not be declared in a struct or class because Iron\u00adclad C++ does not restrict in which memory \nspace an object may be allocated. Rule (Local Pointer Return). A local pointer may not be returned from \na function. With the dynamic lifetime checks described above and these few restrictions placed on the \nstatic use of local point\u00aders, Ironclad C++ provides deallocation safety for stack ob\u00adjects without the \nneed for heapi.cation in most situations. For example, stack-allocated arrays can be passed to nested \nfunctions without requiring heapi.cation. For the code we examined, the single example requiring heapi.cation \noc\u00adcurred in our conversion of the benchmark leveldb. The relevant code is shown in Figure 5. Here, the \naddress of a stack value is stored in the .eld of a heap object, which is disallowed by the rules for \nlocal pointers. Even though the code does not actually create a dangling reference, Iron\u00ad  (A) Stack \nAddress Escapes to Global Scope int* global = NULL; void f() { g(); cout << *global; // dangling pointer \ndereference } void g() { int y = 1; int* q = &#38;y; global = q; // Puts stack pointer into a global \n} ptr<int> global = NULL; void f() { g(); cout << *global; // Prevented by check in g() } void g() { \nint y = 1; lptr<int> q = &#38;y; // check passes global = q; // \"ptr = lptr\" check fails } (B) Stack \nAddress Escapes to Longer Living Stack Frame void f() { int* p = NULL; g(&#38;p); cout << *p; // dangling \npointer dereference } void g(int** ptr_to_p) { int y = 1; int* q = &#38;y; *ptr_to_p = q; // Sets p to \npoint to y } void f() { lptr<int> p = NULL; g(&#38;p); cout << *p; // Prevented by check in g() } void \ng(lptr<lptr<int>> ptr_to_p) { int y = 1; lptr<int> q = &#38;y; // check passes *ptr_to_p = q; // \"lptr \n= lptr\" check fails } Figure 4. Examples of unsafe operations that are prevented by local pointers. \nvoid Acquire(Logger* logger) { obj->logger = logger; } void Release() { obj->logger = NULL; } void f() \n{ Logger logger; Acquire(&#38;logger); ... Release(); } Figure 5. Case in leveldb under which dynamic \nlifetime checking could not avoid heapi.cation clad C++ could not provide this guarantee. Therefore, \nthe programmer must heap-allocate the object to ensure safety.  5.3 References C++ references behave \nsimilarly to local pointers. However, references cannot be reassigned after initialization and there\u00adfore \ndo not need to track a lower bound like local pointers. If a reference points to valid memory when it \nis initialized, it will point to valid memory for its lifetime. Unlike local pointers, Ironclad C++ allows \nreferences to be used as function return values, mainly to support common code idioms, including chaining \nfunction or method calls on an object (e.g., std::cout) but restricts the expressions that can be returned \nas references. In general, any value with a lifetime that will persist through the function or method \ncall may be returned safely. The result of the dereference of an aptr or a ptr can be returned as a reference \nbecause the referred location must be in the heap or globals. Ironclad C++ limits the expressions that \nmay be returned by reference to the dereference of an aptr or a ptr, reference function parameters, the \ndereference of the this pointer, and class members (of the class that the method was called on). In\u00adtuitively, \nthese expressions are allowed because the location they point to must have a lifetime that is at least \nas long as the lifetime of the return value. Rule (Reference Return Values). A reference return value \nmay only be initialized from the dereference of an aptr or a ptr, from a reference function parameter, \nfrom the derefer\u00adence of the this pointer, or from a class member. Although we did not identify any such \ncases in our bench\u00admarks, it is possible that a valid program will not conform to the above static restrictions \non reference return values. For any such cases, Ironclad C++ provides the ref<T> class, which is used \nas a return value. The ref<T> class provides nothing other than an implicit conversion to a T&#38;, which \nper\u00adforms a dynamic check, similar to the local pointer dynamic check, to ensure that the location held \nby the ref<T> refers to valid memory.  Ironclad C++ prohibits the use of reference class mem\u00adbers due \nto the possible unsafety from initializer lists. Other\u00adwise, a class member with reference type of an \nobject on the heap could be initialized to point to a stack location through the use of a constructor \ninitializer list. Reference class mem\u00adbers are rare in C++ code and generally discouraged because the \nfact that they cannot be reseated makes them in.exible. For example, an assignment operator cannot properly \nassign a new location to a reference. We encountered only a sin\u00adgle case in astar in which we refactored \na reference class member to be a ptr instead. Rule (Reference Class Members). Reference class members \nare disallowed. 6. Formalizing the Pointer Lifetime Invariant To ensure that this collection of rules \nsatis.es the pointer lifetime invariant, we prove that the invariant is maintained during execution using \na formalism of a core fragment of Ironclad C++ called Core Ironclad. In the name of simplic\u00adity, Core \nIronclad omits most language features of C++ that do not directly impinge on this part of the system. \nFor exam\u00adple, inheritance, templates, and overloading do not interact with pointer lifetimes, so they \nare left out. References are also excluded in the interest of simplicity as the interesting interactions \nwith references arise in conjunction with other language features that are not in the formalism, e.g. \nover\u00adloading. What is left is a small, C++-like core calculus with just enough features to cover the \ninteresting parts of Iron\u00adclad s pointer lifetime checking system. For a complete account of Core Ironclad, \nincluding a complete language description and full proofs of type safety, please see our technical report \n[28]. 6.1 Locations and the Store Figure 6 gives the syntax of Core Ironclad. The language consists of \nstatements s and expressions e, evaluated in a context . that contains the program s set of class de.nitions. \nThe store S contains both the stack and the heap which maps locations \u00a3 to values v. The only values \nthat need to be for\u00admalized to verify the pointer lifetime invariant are pointers ptr and lptr and objects \nof class type C. Within the store, a value is tagged as being either a ptr or an lptr. These contain \na pointer-value, pv, which is either a valid location or null or the head of an object of type C. Locations \nhave the form xn@y1 .. ym, where xn is a base location with name x and store level n, and y1 .. ym is \na path in the style of Rossie and Friedman [18]. The heap is located at store index 0 and the stack grows \nwith increasing indices starting at index 1. The store height index n disambiguates between two variables \nthat have the same name but exist in different stack frames. The type-checking and evaluation relations \nappear in Fig\u00adure 7. All of these judgments keep track of the current store height to ensure that variable \nlookup picks out the appro\u00adpriate values. . is the store typing which maps locations to types t. Objects \nare represented in the store using paths. For ex\u00adample, consider the following class de.nitions: struct \nC {ptr(C)a; }; struct B {C c; }; A declaration B x; in the main function creates a B object that lives \nat base location x1 with value tag B. The .elds of this object are represented as locations with paths \nrooted at x1. For example, the location x1@c refers to the C sub-object within x, and x1@c.a refers to \nthe pointer within that sub\u00adobject. A curious feature of Core Ironclad is that all expressions evaluate \nto locations. The value denoted by an expression is stored at the location the expression evaluates to. \nThis greatly simpli.es the evaluation semantics in several places. Notably, assignment simply copies \nthe location denoted by the right-hand side into the location denoted by the left-hand side. As the only \nprimitive values that we have are point\u00aders, this amounts to making the left-hand pointer refer to the \nsame location referred to by the right-hand side. We discuss these rules in more detail in Section 6.3. \n 6.2 Method Calls Core Ironclad embeds the active call frame within the term language using an internal \nframe expression {s; returne}rather than using continuations or a separate stack syntax. This is similar \nin style to Core Cyclone [13]. For example, the (abbreviated) rule for method calls . E VA L E X P M \nE T H . . S' = . . . [thisn+1@ . lptr (\u00a31)] n (S, \u00a31.f (x2n2 @p2)) -. .(S' ,{s; returne}) exp replaces \na method invocation with an appropriate frame ex\u00adpression. While the this pointer cannot be wrapped in \na smart pointer in the implementation, the Ironclad validator ensures that the this pointer behaves like \na lptr. Consequently, Core Ironclad treats the this pointer as a lptr rather than a third pointer type \ndistinct from ptr and lptr. The remaining premises (not shown) look up the appropriate method body to \ninvoke and set up the arguments and local variable decla\u00adrations in the store. Because the method body \nis evaluated at any index n, we typecheck the method at index 0 (i.e., has no dependence on prior stack \nframes) and prove a lemma that shows we can lift that result to the required index n. When the statement \nof a frame expression steps, the stack count must be one higher than that of the frame expression  Types \nt : : = ptr(t) | lptr(t) | C Expression variables x,y Surface exprs e : : = x | null | e.x | e1.f (e2) \nLocations \u00a3 : : = xn@y1 .. ym | new C() | &#38;e | *e Pointer values pv : : = \u00a3 | bad ptrInternal exprs \ne : : = \u00a3 | {s; returne} | error Values v : : = ptr (pv) | lptr (pv) | C Statements s : : = e1 = e2 | \ns1; s2 Store S : : = \u00b7 | S[\u00a3 . v] | skip | error Store typing . : : = \u00b7 | .[\u00a3 : t] Class decls cls : \n: = structC {ti xi;imet hs}; Class context . : : = {cls1 .. clsm}Methods meth : : = t1 f (t2 x){ti xi \ni; s; return e} Programs prog : : = .; void main() {s} Figure 6. Core Ironclad Syntax expressions statements \ntyping . .;n exp e : t . .;n stmt sok evaluation (S,e) -. exp n .(S' , e ' ) (S,s) -. stmt n .(S' ,s \n' ) Figure 7. Typing judgments and evaluation relations to re.ect the new stack frame: E VA L E X P \nB O DY C O N G 1 (S, s) -. n+1(S' ,s ' ) stmt . n (S,{s; returne}) -. .(S' ,{s ' ; returne}) exp Finally, \nwhen a frame expression returns, the frame expres\u00adsion is replaced with the location of the return value. \nE VA L E X P B O DY R E T xn fresh for S S2 = copy store(S, \u00a3, xn) S' = S S2\\(n + 1) n (S,{skip; return\u00a3}) \n-. .(S' ,xn@ ) exp The premises copy the return value \u00a3 into a fresh base loca\u00adtion xn in the caller \ns frame (taking care to copy additional locations if the returned value is an object) and pop the stack. \nThe result of the method call then becomes that fresh loca\u00adtion. Note that no dynamic check (say, to \nmake sure that the value stored in xn is valid after the function returns) is needed here because the \ntype system enforces that the returned value cannot be a lptr in this rule: T Y P E E X P B O DY .t' \n.t= lptr(t' ) . .;n+1 . .;n+1 stmt sok exp e : t .;n . {s; returne} : t exp  6.3 Pointer Semantics With \nrespect to the pointer lifetime invariant, the most inter\u00adesting rules concern the assignment of pointers \nas well as the constraints we place on their values in the store. The simplest case is when we assign \nbetween two ptr values where we simply overwrite the left-hand pointer with the right-hand pointer in \nthe store. E VA L S T M T A S S I G N P T R P T R S(\u00a31) = ptr (pv1) S(\u00a32) = ptr (pv2) S' = S[\u00a31 . ptr \n(pv2)] n (S, \u00a31 = \u00a32) -. .(S' , skip) stmt When assigning a (non-null) lptr to a ptr, we verify that \nthe lptr does indeed point to the heap by checking that the store index of the location referred to by \nthe lptr is 0. E VA L S T M T A S S I G N P T R L P T R S(\u00a31) = ptr (pv1) S(\u00a32) = lptr (x0@p) S' = S[\u00a31 \n. ptr (x0@p)] n (S, \u00a31 = \u00a32) -. .(S' , skip) stmt When the lptr does not point to the heap, we raise \nan error. E VA L S T M T A S S I G N P T R L P T R E R R S(\u00a31) = ptr (pv1) n ' = 0 S(\u00a32) = lptr (xn \n' @p2) n (S, \u00a31 = \u00a32) -. .(S, error) stmt Finally, when assigning (non-null) lptrs, the dynamic check \nensures that the lptr being assigned to out-lives the location it receives by comparing the appropriate \nstore indices. E VA L S T M T A S S I G N L P T R L P T R S(x1n1 @p1) = lptr (pv1) S(\u00a32) = lptr (x2n2 \n@p2) S' = S[x1n1 @p1 . lptr (x2n2 @p2)] n2 = n1 n (S,x1n1 @p1 = \u00a32) -. .(S' ,skip) stmt If the lptr does \nnot out-live its new location, we raise an error like the ptr-lptr case above. In addition to standard \ntyping rules for statements and expressions, Core Ironclad enforces a consistency judgment over the store \nthrough the store typing. Two of these binding consistency rules for pointers capture the pointer lifetime \ninvariant.  The .rst rule concerns ptrs and requires that the location pointed to by the ptr is on the \nheap (at index 0). C O N S B I N D I N G P T R 'n ' S(xn@p) = ptr (x ' @p' ) n = 0 .(x 'n ' @p' ) = t \n.;S st1 xn@p : ptr(t)ok The second rule concerns lptrs and requires that lptrs only exist at base locations \nwithout paths (not embedded within an object) and that the location pointed to by a particular lptr is \nin the same stack frame or a lower one. C O N S B I N D I N G L P T R S(xn@ ) = lptr (x 'n ' @p' ) n \n' = n 'n .(x ' @p' ) = t .;S st1 xn@ : lptr(t)ok  6.4 The Pointer Lifetime Invariant Invariant (Pointer \nlifetime). For all bindings of the form [x1n1 @p1 . ptr (pv)] and [x1n1 @p1 . lptr (pv)] in S, if pv \n= x2n2 @p2 (i.e., is non-null) then n2 = n1. We can now present our theorem that states that the pointer \nlifetime invariant is preserved by execution. We make use of the summary judgment wf (.,.,S,k), which \nasserts that the class and method context ., the store typing ., and the store S are all consistent with \none another and contain only bindings at or below stack height k. These checks also include the pointer \nlifetime invariant. Therefore, wf (.,., S,k) implies that the pointer lifetime invariant holds for S. \nTheorem (Pointer lifetime invariant is preserved). If .;n n wf (.,., S,k), . s ok, and (S,s) -. .(S' \n,s ' ), where stmt stmt k is the maximum stack height used within the statement s, then the pointer lifetime \ninvariant holds in the store S' . This theorem is a straightforward corollary of a standard type preservation \nlemma. That is, preservation tells us that the wf judgment is preserved by evaluation. Lemma 1 (Preservation). \nn 1. If wf (.,.,S,|s|+n), . .stmt ;n sok, and (S, s) -. .(S' ,s ' ), stmt then there exists .' such that \nwf (.,.' ,S' , |s| + n), .;n . stmt s ' ok, and . .n .' . n 2. If wf (.,.,S, |e|+n), . .;n e : t, and \n(S,e) -. .(S' ,e ' ), exp exp .;n then there exists .' such that wf (.,.' ,S' ,|e|+n), .' exp e ' : t, \nand . .n .' . Core Ironclad also supports a standard progress lemma, completing the proof of type safety. \nLemma 2 (Progress). .;n 1. If . sok and . Sok then s is skip, error, or stmt st n (S, s) -. .(S' , s \n' ). stmt 2. If . .;n e : t and . st Sok then e is \u00a3, error, or (S,e) -. exp exp n .(S' ,e ' ). In Core \nIronclad, well-formed terms take a step or step to error. error terms arise only when an attempted pointer \nassignment breaks the pointer lifetime invariant. This corre\u00adsponds to the dynamic checks outlined in \nSection 6.3. We prove preservation at stack height |s|+n (respectively |e| + n) where n is the height \nof the stack up to statement s (respectively e) and |s| (respectively |e|) is the number of additional \nstack frames embedded in the subject of the eval\u00aduation. The extra condition . .n .' says that new store \ntyp\u00ading .' has all the bindings of the old store typing . up to stack height n. The complete details \nof the proofs of these theorems can be found in our companion technical report. 7. Validator for Ironclad \nC++ Although many of the rules of Ironclad C++ are simple enough for a well-intentioned programmer to \nfollow un\u00adaided, ensuring safety requires the use of a static syntactic validation tool to certify the \ncode s conformance to the Iron\u00adclad C++ subset. The role of the validator is to ensure that any violations \nof memory/type safety will be caught by ei\u00adther: (1) the standard C++ static type checker or (2) the \ndy\u00adnamic type cast and bounds checks performed by the smart pointers. For example, the validator ensures \nthat no raw pointer or union types remain. For heap-precise garbage col\u00adlection, the validator ensures \nthat user-de.ned mark() meth\u00adods correctly identify all pointers, pointer-containing mem\u00adbers, and inherited \nbase classes of each precisely marked class. To prevent dangling pointers to stack objects via dy\u00adnamic \nlifetime checking, the validator checks that all uses of address-of, the this pointer, and conversions \nfrom stack arrays to pointers immediately enter an lptr or laptr. The syntactic validator examines the \ninitializer lists for each class constructor to ensure that pointer class members are safely initialized. \nThe validator ensures that references are not used as class members. Finally, the validator ensures that \nexpres\u00adsions returned by reference match one of the following con\u00adstructs: dereference of an aptr or \nptr, a reference parame\u00adter, the dereference of the this pointer, or a class member. Once the code passes \nthe static syntactic validator, the C++ type-checker then statically enforces the remaining type safety \nproperties. For example, unsafe casts and void* will not type-check in validated code because Ironclad \nC++ smart pointers explicitly do not support them. Similarly, array indexing and pointer arithmetic operators \nare not de.ned on ptr<T> objects, ensuring the disallowed use of such operators will be caught during \ncompilation. Our implementation of the static validator builds upon LLVM s Clang compiler front-end [20]. \nStatic validation is performed on the AST after both preprocessing and template instantiation have been \nperformed by the Clang front-end. The Ironclad C++ validator applies simple, local checks to Figure 8. \nCommon refactoring to remove void* pointers. First we manually add templates. Then the refactoring tool \nadds ptrs.  void f(void*); . (Manual) template<typename T> void f(T*); . (Refactoring Tool) template<typename \nT> void f(ptr<T>); type declarations and expressions. None of the checks used by the static validator \nrequire complicated analysis. Although currently implemented as a stand-alone check\u00ading tool, an alternative \nimplementation would be to integrate the static validation into a compiler such that the validator can \nbe invoked with a command line .ag during compila\u00adtion (much as GCC s -std= .ag ensures the code conforms \nto a speci.c language standard). 8. Experiences Refactoring to Ironclad C++ To evaluate the usability \nand applicability of Ironclad C++, we refactored multiple performance benchmarks (from the SPEC and Parsec \nsuites) and an open-source key-store database written in C++ to Ironclad C++. The open-source database, \nleveldb, was developed at Google and uses custom data structures, including a skip list and a LRU cache. \nTable 2 characterizes the C++ language features used by these applications and details the nature of \nthe code changes performed to refactor to Ironclad C++. Overall, we were able to successfully refactor \n50K lines of C/C++ code to Ironclad C++. We performed a series of manual and au\u00adtomated refactoring steps \nto transform these programs, and the majority of the code transformations were performed by our semi-automatic \nrefactoring tool (Section 8.3). 8.1 Step 1: Moving from C to C++ Ironclad C++ requires the use of a C++ \ncompiler to com\u00adpile all our benchmarks. C++, unlike C, does not allow a void* to be implicitly converted \nto a T*. Hence, three C benchmarks from the SPEC benchmark suite could not be compiled using a C++ compiler \nwithout a few manual mod\u00adi.cations. We manually added explicit casts to the offending expressions. In \nsjeng, we changed the name of a variable named this , which is a C++ keyword. Once all of the programs \ncould be compiled using a C++ compiler, we fur\u00adther modi.ed them to use C++ s new function for allocation \nrather than C s malloc, which requires unsafe casts from void*. To match new, we also replaced free with \ndelete. 8.2 Step 2: Increasing Type-safety After refactoring the code to compile with a C++ compiler \nand use C++ allocation and deallocation functions, we per\u00adformed a few additional code modi.cations to \nprepare the code for automated refactoring. As noted in Section 3.1, void* pointers are not permitted \nby Ironclad C++. The pro\u00adcess of replacing void* pointers with type-safe constructs is not generally \nautomatable because it may require recogniz\u00ading and extracting an inheritance hierarchy or adding tem\u00adplate \nparameters for more than one type. Rather than at\u00adtempting to perform this refactoring automatically, \nwe in\u00adstead chose to manually replace occurrences of void*, as shown in Figure 8. A few additional benchmark-speci.c \ncode modi.cations were necessary, but these modi.cations were typically simple and did not require any \ndeep under\u00adstanding of the algorithms or the data structures used in the benchmarks. For example, lbm \nused an errant cast from a double*** to a double** that was .xed by correcting the pointer types to allow \ncompilation without an unsafe cast. 8.3 Step 3: Automated Refactoring Once we manually modi.ed the benchmarks \nto use type\u00adsafe features, we applied a custom automated refactoring tool to the code. This refactoring \ntool performs simple au\u00adtomated code modi.cations, including modifying pointer type declarations (T* \nto ptr<T>), allocation and dealloca\u00adtion sites (new T(...) to new_obj<T>(...) and delete p to p.destruct()), \nand type-casts ((T*)p to cast<T>(p)). As shown in Table 2, the majority of the code modi.cations necessary \nto refactor C and C++ code to Ironclad C++ are performed by the refactoring tool. The refactoring tool \nis meant to be used only once to aid the initial transformation. The refactoring tool is built upon LLVM \ns Clang compiler front-end. The refactoring tool could simply use aptr<T> as a re\u00adplacement for every \nT*, but doing so results in unnecessary dynamic checks whenever a more-ef.cient ptr<T> would suf.ce. \nThus, the refactoring tool implements a best-effort analysis similar to the whole program pointer type \ninference in CCured [25] to determine whether to replace a T* with an aptr<T> or a ptr<T>. This whole \nprogram analysis is run once, during refactoring, and it is not required for fu\u00adture validation or further \nmanual refactoring. The refactor\u00ading tool analysis accounts for the use of address-of, this, and assignments \nfrom stack allocated arrays to determine which pointers require dynamic lifetime checking (lptr and laptr). \nThe refactoring tool can also optionally generate mark() methods for heap-precise garbage collection. \n 8.4 Step 4: Post-Refactoring Modi.cations Considering that C++ is a large language with many cor\u00adner \ncases, the refactoring tool does not automatically han\u00addle every possible code modi.cation. We also performed \na few manual code changes following refactoring. Given that Table 2. Characterization of the evaluated \nprograms. From left to right, benchmark name, source language, number of class\u00ades/structs, % pointer \ndeclarations, % reference declarations, lines of code, manually refactored lines of code, and automatically \nrefactored lines of code.  Benchmark Lang Class Ptrs Refs LoC Manual Code Changes Automated Code Changes \nC++ Alloc Pre Post Ptr Types SysFunc Alloc Casts blackscholes C 1 20% N/A 405 0 5 4 2 5 5 4 0 bzip2 C \n2 47% N/A 5731 16 41 28 14 224 21 30 30 lbm C 1 57% N/A 904 1 3 20 6 49 7 2 4 sjeng C 2 46% N/A 10544 \n45 24 164 158 310 82 30 0 astar C++ 25 7% 35% 4280 0 60 2 7 72 15 76 2 canneal C++ 3 27% 29% 2817 0 0 \n2 9 72 3 2 1 .uidanimate C++ 4 7% 7% 2785 0 1 0 2 85 7 44 1 leveldb C++ 66 49% 24% 16188 0 0 160 149 \n1028 69 195 33 namd C++ 15 46% 7% 3886 0 0 0 44 265 11 69 10 streamcluster C++ 5 37% 0% 1767 0 25 2 2 \n63 17 9 21 swaptions C++ 1 39% 0% 1095 0 11 1 12 63 3 0 9 refactoring is intended to be performed only \nonce, the num\u00adber of lines modi.ed post-refactoring was relatively small in most cases. For example, \nour pointer type inference im\u00adplementation sometimes missed a nested increment opera\u00adtion on an array \npointer and inferred that the pointer was therefore a singleton. This error is easily caught through \nthe type-checking done by the C++ compiler (ptr<T> does not overload the increment operator). A more \nmature refactoring tool would avoid these minor refactoring errors. Two notable outliers required more \nmanual refactor\u00ading than the rest of the refactored programs (sjeng and leveldb). We describe the code \nmodi.cations below. sjeng In sjeng, there were 154 uses of f(&#38;A[0]) to pass a pointer to the .rst \nelement of a stack allocated array as an argument to a function f. In Ironclad C++, the lptr<T> con\u00adstructed \nfrom the result of &#38;A[0] contains no information about the size of A and therefore assumes that is \nhas size 1. We modi.ed the code to use f(A) instead, which retains the correct array size information. \nWhere &#38;A[i] is used with some non-zero index i, the A.offset(i) method provided by the array and \narray pointer classes was used to create a new array pointer with the correct offset and size. In addition, \nthe gen function stores a pointer to a stack al\u00adlocated array in a global variable, which is not permitted \nin Ironclad C++. This global variable is set on each entry to the gen function and used by other functions \nthat were called from gen. In place of the unsafe use of the global variable, we modi.ed the code to \nsimply pass the pointer parameter from gen to the rest of the functions that required it. This change \nwas conceptually straightforward but required mod\u00adifying 137 lines of code. leveldb leveldb required \na larger number of manual code modi.cations compared to the benchmarks with fewer to\u00adtal lines of code. \nIn particular, the Slice class in leveldb contains a constructor that accepts a const char *. Refac\u00adtoring \nthis constructor to Ironclad C++ converts the param\u00adeter to type aptr<const char>. However, in cases \nwhere a string literal was originally used to call a function with a Slice parameter, the Ironclad C++ \ncode required more than the one implicit user-de.ned conversion allowed by the C++ standard [16]. Thus, \nwe added an explicit conversion from string literals to aptr<const char> at each call site.  8.5 Step \n5: Performance Tuning Finally, we identi.ed modi.cations to three of the bench\u00admark programs as examples \nof performance tuning that can reduce the performance penalty of providing memory safety. These optimizations \nserve as starting points for other source\u00adlevel optimizations that the Ironclad C++ API could provide. \nbzip2 In bzip2, the generateMTFValues function cre\u00adates a temporary pointer to a stack allocated array \nin a doubly nested loop. In the Ironclad C++ version of this code, the temporary pointer becomes an laptr, \nwhich must initial\u00adize its lowerBound on each iteration of the outer loop. Fur\u00adther, the temporary pointer \nwas used in pointer arithmetic, which is relatively expensive (compared to the array index operator, \nwhich does not need to check a lower bound) for Ironclad C++ aptr and laptr types. To improve the perfor\u00admance \nof this code, we replaced the temporary pointer with an integer index and used array indexing off of \nthe orig\u00adinal stack allocated array instead of pointer arithmetic on the temporary. This optimization \nreduced the performance penalty from 53% to 35%. streamcluster The streamcluster benchmark spends the \nmajority of its runtime in the distance function, which computes the pointwise distance between two vectors. \nDue to the use of a tight for-loop with repeated indexing into the input vectors, our initial Ironclad \nC++ version of this benchmark suffered from unnecessarily high bounds checking overheads of 70%. To reduce \nthis overhead, we replaced the loop with a call to a reduce function, provided by the Ironclad C++ library, \nthat simply bounds checks the start and end indices of the reduction on both input arrays, and then runs \nthe computation at unchecked speeds. With this optimization, the streamcluster benchmark executes with \nno measurable overhead compared to the original.  swaptions Swaptions spends most of its runtime per\u00adforming \noperations on vectors and matrices of .oating pointer numbers. For matrix structures, swaptions uses \nan array-of-array-pointers to approximate a two-dimensional array (i.e., aptr<aptr<double>>). These structures \nare inef.cient in two ways. First, creating the structure requires multiple memory allocations. Second, \ndue to the additional metadata used by aptr, each two-dimensional index op\u00aderation (i.e., A[i][j]) must \n.rst load the address, current index, and size stored in the .rst level array and then load the double \nstored in the second level array. We replaced the aptr<aptr<double>> structures with a matrix<double>. \nThe matrix class provides a proper two-dimensional ar\u00adray by overloading operator() (unsigned int x, \nunsigned int y). In this way, the matrix class performs two bounds checks (one on each index) and then \nreturns the data, avoiding the additional indirection required by the aptr<aptr<double>> structure. This \noptimization reduced the performance penalty from 67% to 45%.  8.6 Libraries The C++ STL The C++ Standard \nTemplate Library (STL) provides common containers and algorithms. The under\u00adlying implementations of \nthese containers use unchecked pointer operations and are not safe by default. Only a few of our benchmarks \nused the STL (canneal and leveldb), so instead of refactoring the entire STL (approximately 100k lines \nof code) to conform to Ironclad C++, we modi.ed key parts of the STL to emulate the checking that a fully \nrefactored version would perform. We performed four major modi.cations on the containers used in our \nbenchmarks. First, we changed the default allocator to be the gc_allocator. Second, we inserted bounds \nchecks on all array operations, including the indexing operators for string and vector. Third, we modi.ed \nmethods that accepted or returned raw pointers to instead use Ironclad C++ smart pointers. Finally, we \nmodi.ed the iterators to each container to avoid accessing invalid memory. For string and vector, this \nwas as simple as replacing the raw pointer iterator with an aptr. For map and set, we modi.ed the tree_iterator \nto avoid iterating past the root or end nodes of the tree. Atomics In C++11, atomic operations on primitive \ndata types and pointers were introduced as part of the STL. To support atomic operations on pointers, \nIronclad C++ pro\u00advides template specializations for the atomic<T> type for ptr and aptr; lptr and laptr \ndo not require support for atomic operations because pointers to them cannot escape a thread s stack. \nThe template specialization for ptr mirrors the standard atomic pointer implementation because ptr contains \na single pointer .eld. Unlike ptr, the template spe\u00adcialization of atomic for aptr requires the use of \na lock or transaction to atomically update the three .elds of the aptr. Using these atomic pointers, \nany program that was data\u00adrace free prior to using Ironclad C++ remains data-race free. External Libraries \nIdeally, library source-code would also be refactored to Ironclad C++, but we acknowledge that it may \nnot always be feasible. In such cases, Ironclad C++ pro\u00adtects what it can, while begrudgingly allowing \nthe program to call unsafe library code through methods on the smart pointer classes that allow the underlying \nraw pointer to be passed to a library call. This functionality is provided for the case where refactoring \nis not possible, similarly to how Java provides the JNI for access to unsafe C/C++ code. This behavior \nis optional and can be disabled.  8.7 Bug Detection Effectiveness As a coarse sanity check on the implementation \nof the Iron\u00adclad C++ library, we tested Ironclad C++ on multiple suites of known bugs, including selected \nprograms from BugBench (gzip, man, ncompress, and polymorph) [22], thirty array\u00adout-of-bounds vulnerability \ntest cases from the NIST Juliet Suite [26], and the Wilander test suite [35]. As expected, Ironclad C++ \nsafely aborted on all buggy inputs. We note that these tests are not de.nitive proof of Ironclad C++ \ns soundness or correctness, of course. 9. Experimental Evaluation The previous section established the \nfeasibility of bringing full type and memory safety to C++ at the cost of refactor\u00ading programs to conform \nto the Ironclad C++ rules, but it did not evaluate the performance and memory usage cost of enforcing \nsuch safety at runtime. This section describes our prototype implementation and presents runtime overhead \nre\u00adsults, including experiments to isolate the overhead added by the various aspects of Ironclad C++. \nIn addition, we present results that indicated the overheads from garbage collec\u00adtion are low, that heap-precise \ncollection reduces memory consumption versus purely conservative collection, and dy\u00adnamic lifetime checking \nis faster than heapi.cation. 9.1 Implementation and Experimental Methods We use the programs refactored \nand optimized in the pre\u00advious section (from the SPEC benchmark suite, the Parsec benchmark suite, and \nan open-source database leveldb) to evaluate the runtime overheads of enforcing safety. The benchmarks \nwere compiled using LLVM/Clang version 3.2 C++ compiler, and our test system contains an Intel 2.66Ghz \nCore2 processor. The Ironclad C++ library includes imple\u00admentations of the various smart pointer classes \nand safe versions of various C standard library functions. We mod\u00adi.ed the libcxx STL implementation \nto provide safe itera\u00adtors, bounds-checked array access operations, and interfaces that accept and return \nsmart pointers instead of raw point\u00adFigure 9. Normalized runtimes for refactored Ironclad C++ code with \n(adding checking from left to right): no checking, bounds checked arrays, safe stack allocations, safe \nheap allocations, and heap-precise garbage collection.   ers. To reduce overhead, the smart pointer \nimplementation uses Clang s always_inline function attribute to ensure the compiler inlines the dereference \nand indexing operators. We used Valgrind s Massif tool to measure memory usage overheads. We used the \nBoehm-Demers-Weiser conservative garbage collector both as the baseline garbage collector and as the \nbasis for the heap-precise garbage collector [7]. To im\u00adplement the heap-precise collector, we extended \nthe marking implementation of the Boehm-Demers-Weiser collector to call the mark() method of allocations \ninitialized for precise collection rather than pushing the allocation s address onto the conservative \ncollector s mark stack. Any addresses passed back to the collector from mark() are added to the mark \nstack. Each potential address passes through the existing checks employed by the Boehm-Demers-Weiser \ncollector for duplicate marking and blacklisting.  9.2 Overall Performance The overall performance overhead \nfor bringing type and memory safety to the refactored programs is just 12% on average. Figure 9 shows \nthese results, and it also includes re\u00adsults for multiple con.gurations to show the impact of each aspect \nof Ironclad C++. The left-most bar in each group ( Translated ) shows the normalized execution time of \nthe fully refactored, strongly typed benchmarks when dynamic bound checking, dynamic lifetime checking, \nand the garbage collector are all disabled. These results indicate there is negligible overhead from \nreplacing raw pointers with smart pointers. The second bar from the left in each group of Fig\u00adure 9 ( \nBounds ) shows bounds checking is by far the most signi.cant contributor to the overall performance overhead. \n 9.3 Overheads of Garbage Collection Figure 9 shows that the runtime overhead of garbage collec\u00adtion \nis negligible in our benchmarks. Although perhaps sur\u00adprising, our benchmarks are not typical of programs \nused in garbage collection studies, which are generally selected for their frequent allocation behavior. \nFor example, several of our benchmarks allocate memory only during initialization and do not deallocate \nmemory resulting in extremely rare collection invocation (less than once per second for many benchmarks). \nThe benchmark that collects most frequently (six hundred times per second), swaptions, incurs an addi\u00adtional \n23% performance penalty due to garbage collection. The garbage collector increases memory usage by 14% \non average and up to 85% for leveldb-fillseq (Fig\u00adure 10) when compared to explicit deallocation with \nthe same underlying memory allocator. One caveat is that the allocator underlying the conservative collector \nuses more space on average than Clang s default memory allocator (by 29%) even when operating in explicit \nmemory deallocation mode; if this overhead is included, the total memory over\u00adhead of GC rises to 43% \n(not shown on Figure 10).  9.4 Bene.ts of Heap-Precise Collection Figure 10 also shows the impact of \nIronclad s heap-precise extension to the garbage collector. In most cases, the heap-precise collector \nprovides no appreciable reduc\u00adtion of memory usage, but in two cases astar and leveldb-fillseq the \npure-conservative collector suffers due to imprecise identi.cation of heap pointers. When applying heap-precise \ncollection, these programs memory usage is reduced by 28% and 66%, respectively, compared to the unmodi.ed \nconservative collector. The memory overheads of bzip2 and namd do not improve under heap-precise collection \ndue to stack-allocated arrays (which are not tagged) with elements that are misidenti.ed as pointers. \nThe overall average memory overhead of GC vs. explicit memory allocation drops from 14% to 9% with the \naddition of heap-precise collection.  We observe a 2% performance penalty for heap-precise garbage \ncollection. Upon investigation, we found this penalty is not due to slower tracing time using mark() \nmethods during garbage collection; the penalty is a result of changes in data layout introduced by our \nimplementation of heap-precise collection (which wraps each allocation with a templated wrapper class \nwith a virtual table pointer for calling the correct mark() method). We con.rmed this hypothesis by including \nthe same header when using the completely conservative collector, which yielded the same runtime overheads. \n 9.5 Bene.ts of Dynamic Lifetime Checking Dynamic lifetime checking incurs less than 1% overhead over \nthe baseline of providing no safety checking for stack deallocation. We originally observed overheads \nof 17% in bzip2, but these overheads were due to the creation of an laptr temporary in a tight loop. \nThe optimization described in Section 8.5 eliminated the overhead from dynamic life\u00adtime checking in \nbzip2. In Figure 11, we compare dynamic lifetime checking to the other notable alternative for stack \nallocation safety: heapi.cation. On average, heapi.cation is 2\u00d7 slower than dynamic lifetime checking. \nWe observed two situations in which heapi.cation lead to increased performance overheads: a stack-allocated \narray escaping to a function (occurs in sjeng) and calling a method on a stack-allocated object (occurs \nin leveldb). As a result, dynamic lifetime checking is faster than heapi.cation by 27.5\u00d7 (sjeng), 6.2\u00d7 \n(ldb-fseq), 9.1\u00d7 (ldb-rreverse), and 6.4\u00d7 (ldb-rhot). In almost all cases, dynamic lifetime checking \navoids the use of heapi.cation for enforcing stack deallocation safety. The runtime performance of dynamic \nlifetime checking is nearly identical to the performance of code with no safety checking for stack deallocation. \n10. Conclusion Ironclad C++ brings type safety to C++ at a runtime over\u00adhead of 12%. We demonstrated \nthe feasibility of refactor\u00ading C and C++ code to Ironclad C++ with the help of a semi-automatic refactoring \ntool. With heap-precise garbage collection, Ironclad C++ provides an optional interface for precisely \nidentifying heap pointers, which was shown to de\u00adcrease average memory usage of garbage collection. We \nin\u00advestigated both heapi.cation and dynamic lifetime check\u00ading for enforcing stack deallocation safety \nand found that dynamic lifetime checking offered .exibility, memory con\u00adtrol, and limited source code \nmodi.cations as compared to heapi.cation. Overall, our experiences and experimental re\u00adsults indicate \nthat Ironclad C++ has the potential to be an effective, low-overhead, and pragmatic approach for bring\u00ading \ncomprehensive memory safety to C++. Acknowledgments We would like to thank Emery Berger, Mathias Payer, \nand John Regehr for their comments and suggestions about this work. This research was funded in part \nby the U.S. Gov\u00adernment by ONR award N000141110596 and NSF grants CNS-1116682 and CCF-1065166. The views \nand conclu\u00adsions contained in this document are those of the authors and should not be interpreted as \nrepresenting the of.cial policies, either expressed or implied, of the U.S. Government. References [1] \nA. Alexandrescu. Modern C++ Design: Generic Program\u00adming and Design Patterns Applied. Addison-Wesley, \nBoston, MA, 2001. [2] T. M. Austin, S. E. Breach, and G. S. Sohi. Ef.cient Detection of All Pointer and \nArray Access Errors. In Proceedings of the SIGPLAN 1994 Conference on Programming Language Design and \nImplementation, June 1994. [3] J. Bartlett. Mostly-Copying Garbage Collection Picks Up Generations and \nC++. Technical report, DEC, 1989. [4] E. D. Berger and B. G. Zorn. DieHard: Probabilistic Memory Safety \nfor Unsafe Languages. In Proceedings of the SIGPLAN 2006 Conference on Programming Language Design and \nIm\u00adplementation, pages 158 168, June 2006.  [5] H.-J. Boehm. Space Ef.cient Conservative Garbage Collec\u00adtion. \nIn Proceedings of the SIGPLAN 1993 Conference on Programming Language Design and Implementation, pages \n197 206, June 1993. [6] H.-J. Boehm and M. Spertus. Garbage collection in the next C++ standard. In Proceedings \nof the 2009 International Sym\u00adposium on Memory Management, pages 30 38, June 2009. [7] H.-J. Boehm and \nM. Weiser. Garbage Collection in an Unco\u00adoperative Environment. Software Practice &#38; Experience, \n18(9):807 820, Sept. 1988. [8] D. Colvin, G. and Adler, D. Smart Pointers -Boost 1.48.0. Boost C++ Libraries, \nJan. 2012. www.boost.org/docs/ libs/1_48_0/libs/smart_ptr/smart_ptr.htm. [9] D. Dhurjati and V. Adve. \nBackwards-Compatible Array Bounds Checking for C with Very Low Overhead. In Proceed\u00adings of the 28th \nInternational Conference on Software Engi\u00adneering (ICSE), pages 162 171, 2006. [10] D. Dhurjati, S. Kowshik, \nV. Adve, and C. Lattner. Memory Safety Without Runtime Checks or Garbage Collection. In Proceedings of \nthe 2003 ACM SIGPLAN Conference on Lan\u00adguage, Compiler, and Tool for Embedded Systems (LCTES), pages \n69 80, 2003. [11] D. Edelson and I. Pohl. A Copying Collector for C++. In Proceedings of The 18th ACM \nSIGPLAN/SIGACT Symposium on Principles of Programming Languages (POPL), pages 51 58, Jan. 1991. [12] \nD. Gay, R. Ennals, and E. Brewer. Safe Manual Memory Man\u00adagement. In Proceedings of the 2007 International \nSympo\u00adsium on Memory Management, Oct. 2007. [13] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, \nand J. Cheney. Region-Based Memory Management in Cyclone. In Proceedings of the SIGPLAN 2002 Conference \non Pro\u00adgramming Language Design and Implementation, June 2002. [14] R. Hastings and B. Joyce. Purify: \nFast Detection of Mem\u00adory Leaks and Access Errors. In Proc. of the Winter Usenix Conference, 1992. [15] \nM. Hirzel and A. Diwan. On the type accuracy of garbage col\u00adlection. In Proceedings of the 2000 International \nSymposium on Memory Management, pages 1 11, Oct. 2004. [16] International Standard ISO/IEC 14882:2011. \nProgramming Languages C++. International Organization for Standards, 2011. [17] T. Jim, G. Morrisett, \nD. Grossman, M. Hicks, J. Cheney, and Y. Wang. Cyclone: A Safe Dialect of C. In Proceedings of the 2002 \nUSENIX Annual Technical Conference, June 2002. [18] J. Jonathan G. Rossie and D. P. Friedman. An Algebraic \nSe\u00admantics of Subobjects. In Proceedings of the 17th SIGPLAN Conference on Object-Oriented Programming, \nSystems, Lan\u00adguages and Application (OOPSLA), Nov. 2002. [19] R. Jones and R. Lins. Garbage Collection: \nAlgorithms for Au\u00adtomatic Dynamic Memory Management. John Wiley &#38; Sons, 1996. [20] C. Lattner and \nV. Adve. LLVM: A Compilation Framework for Lifelong Program Analysis &#38; Transformation. In Proceed\u00adings \nof the International Symposium on Code Generation and Optimization, page 75, 2004. [21] D. Lomet. Making \nPointers Safe in System Programming Languages. IEEE Transactions on Software Engineering, pages 87 96, \nJan. 1985. [22] S. Lu, Z. Li, F. Qin, L. Tan, P. Zhou, and Y. Zhou. Bug\u00adbench: Benchmarks for Evaluating \nBug Detection tools. In In PLDI Workshop on the Evaluation of Software Defect De\u00adtection Tools, June \n2005. [23] S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. Zdancewic. SoftBound: Highly Compatible and \nComplete Spatial Mem\u00adory Safety for C. In Proceedings of the SIGPLAN 2009 Con\u00adference on Programming \nLanguage Design and Implementa\u00adtion, June 2009. [24] S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. \nZdancewic. CETS: Compiler Enforced Temporal Safety for C. In Pro\u00adceedings of the 2010 International Symposium \non Memory Management, June 2010. [25] G. C. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer. CCured: \nType-Safe Retro.tting of Legacy Soft\u00adware. ACM Transactions on Programming Languages and Systems, 27(3), \nMay 2005. [26] NIST Juliet Test Suite for C/C++. NIST, 2010. http://samate.nist.gov/SRD/testCases/suites/ \nJuliet-2010-12.c.cpp.zip. [27] Y. Oiwa. Implementation of the Memory-safe Full ANSI-C Compiler. In Proceedings \nof the SIGPLAN 2009 Confer\u00adence on Programming Language Design and Implementation, pages 259 269, June \n2009. [28] P.-M. Osera, R. Eisenberg, C. DeLozier, S. Nagarakatte, M. M. K. Martin, and S. Zdancewic. \nCore Ironclad. Technical Report MS-CIS-13-06, University of Pennsylvania, 2013. [29] J. Pincus and B. \nBaker. Beyond Stack Smashing: Recent Ad\u00advances in Exploiting Buffer Overruns. IEEE Security &#38; Pri\u00advacy, \n2(4):20 27, 2004. [30] J. Rafkind, A. Wick, M. Flatt, and J. Regehr. Precise Garbage Collection for C. \nIn Proceedings of the 2009 International Symposium on Memory Management, June 2009. [31] M. S. Simpson \nand R. K. Barua. MemSafe: Ensuring the Spatial and Temporal Memory Safety of C at Runtime. In IEEE International \nWorkshop on Source Code Analysis and Manipulation, pages 199 208, 2010. [32] B. Stroustrup. A Rationale \nfor Semantically Enhanced Library Languages. In Library-Centric Software Design, page 44, 2005. [33] \nB. Stroustrup. Software Development for Infrastructure. Com\u00adputer, 45:47 58, Jan. 2012. [34] E. Unger. \nSevere memory problems on 32-bit Linux, April 2012. https://groups.google.com/d/topic/ golang-nuts/qxlxu5RZAI0/discussion. \n[35] J. Wilander and M. Kamkar. A Comparison of Publicly Avail\u00adable Tools for Dynamic Buffer Over.ow \nPrevention. In Pro\u00adceedings of the Network and Distributed Systems Security Symposium, 2003. [36] W. \nXu, D. C. DuVarney, and R. Sekar. An Ef.cient and Backwards-Compatible Transformation to Ensure Memory \nSafety of C Programs. In Proceedings of the 12th ACM SIG-SOFT International Symposium on Foundations \nof Software Engineering (FSE), pages 117 126, 2004.    \n\t\t\t", "proc_id": "2509136", "abstract": "<p>The C++ programming language remains widely used, despite inheriting many unsafe features from C---features that often lead to failures of type or memory safety that manifest as buffer overflows, use-after-free vulnerabilities, or abstraction violations. Malicious attackers can exploit such violations to compromise application and system security.</p> <p>This paper introduces Ironclad C++, an approach to bringing the benefits of type and memory safety to C++. Ironclad C++ is, in essence, a library-augmented, type-safe subset of C++. All Ironclad C++ programs are valid C++ programs that can be compiled using standard, off-the-shelf C++ compilers. However, not all valid C++ programs are valid Ironclad C++ programs: a syntactic source-code validator statically prevents the use of unsafe C++ features. To enforce safety properties that are difficult to check statically, Ironclad C++ applies dynamic checks via templated ``smart pointer'' classes.</p> <p>Using a semi-automatic refactoring tool, we have ported nearly 50K lines of code to Ironclad C++. These benchmarks incur a performance overhead of 12% on average, compared to the original unsafe C++ code.</p>", "authors": [{"name": "Christian DeLozier", "author_profile_id": "83358804557", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4290357", "email_address": "delozier@cis.upenn.edu", "orcid_id": ""}, {"name": "Richard Eisenberg", "author_profile_id": "81542549256", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4290358", "email_address": "eir@cis.upenn.edu", "orcid_id": ""}, {"name": "Santosh Nagarakatte", "author_profile_id": "81435608524", "affiliation": "Rutgers University, New Brunswick, NJ, USA", "person_id": "P4290359", "email_address": "santosh.nagarakatte@cs.rutgers.edu", "orcid_id": ""}, {"name": "Peter-Michael Osera", "author_profile_id": "81496688473", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4290360", "email_address": "posera@cis.upenn.edu", "orcid_id": ""}, {"name": "Milo M.K. Martin", "author_profile_id": "81100426086", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4290361", "email_address": "milom@cis.upenn.edu", "orcid_id": ""}, {"name": "Steve Zdancewic", "author_profile_id": "81384616728", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P4290362", "email_address": "stevez@cis.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509550", "year": "2013", "article_id": "2509550", "conference": "OOPSLA", "title": "Ironclad C++: a library-augmented type-safe subset of c++", "url": "http://dl.acm.org/citation.cfm?id=2509550"}