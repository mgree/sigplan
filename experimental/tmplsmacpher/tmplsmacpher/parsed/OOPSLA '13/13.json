{"article_publication_date": "10-29-2013", "fulltext": "\n Forsaking Inheritance: Supercharged Delegation in DelphJ Prodromos Gerakios Aggelos Biboudis Yannis \nSmaragdakis Department of Informatics University of Athens, 15784, Greece {pgerakios,biboudis,smaragd}@di.uoa.gr \nAbstract We propose DelphJ: a Java-based OO language that eschews inheritance completely, in favor of \na combination of class morphing and (deep) delegation. Compared to past delega\u00adtion approaches, the novel \naspect of our design is the abil\u00adity to emulate the best aspects of inheritance while retaining maximum \n.exibility: using morphing, a class can select any of the methods of its delegatee and export them (if \ndesired) or transform them (e.g., to add extra arguments or modify type signatures), yet without needing \nto name these meth\u00adods explicitly and handle them one-by-one. Compared to past work on morphing, our \napproach adopts and adapts ad\u00advanced delegation mechanisms, in order to add late binding capabilities \nand, thus, provide a full substitute of inheritance. Additionally, we explore complex semantic issues \nin the in\u00adteraction of delegation with late binding. We present our lan\u00adguage design both informally, \nwith numerous examples, and formally in a core calculus. Categories and Subject Descriptors D.1.2 [Program\u00adming \nTechniques]: Automatic Programming; D.3.3 [Pro\u00adgramming Languages]: Language Constructs and Features; \n D.2.13 [Software Engineering]: Reusable Software General Terms Languages Keywords meta-programming; \nlanguage extensions; mor\u00adphing; object composition; delegation; static re.ection 1. Introduction Inheritance \nis the major feature that Object-Oriented lan\u00adguage designers love to hate. It is the main mechanism \nfor code reuse in most OO languages: a class C inheriting from another class S means that C can simultaneously \nboth see Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, \nUSA. Copyright &#38;#169; 2013 ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509535 \nall the members of S and export them to the outside world (.ltered by preset access policies). At the \nsame time, inheri\u00adtance has often been criticized in the research literature (e.g., [5, 6]), and specialty \npress (e.g., [9]). Brie.y: Inheritance confuses the role of a class as a model for object behavior and \nits role as an organizational unit of code. When C wants to reuse code from S it does not necessarily \nneed to play the role of S to the out\u00adside world. The result is either chaotic automatic reuse of members \nor limiting the ability to reuse code. Lan\u00adguages such as C++ distinguish inheritance for code reuse \n(or plain subclassing) and inheritance for subtyp\u00ading (or subclassing combined with subtyping). Multiple \nstyle guides for C++ programming explicitly warn pro\u00adgrammers to always use inheritance for subtyping \n. It is one of the main OO principles (effectively a corollary of the Liskov substitutability principle) \nthat inheritance without subtyping is brittle, low-level, and generally dan\u00adgerous. Accordingly, languages \nlike Java only support in\u00adheritance for subtyping, from the perspective of the type system. Of course, \nno type system can ensure that pro\u00adgrammers de.ne proper subtypes, in a behavioral sense. OO programmers \nare taught to never reuse code for con\u00advenience when the subclass is not truly usable wherever the superclass \nis (i.e., when the subclass is not a true sub\u00adtype).  Inheritance is a coarse-grained mechanism for \ncode reuse: C may need to reuse only a subset of the members of S, yet is forced to inherit all of them. \nThis aspect of inheritance also exhibits itself as an annoying resistance to composition. If inheritance \nis primarily a code reuse mechanism, it seems that the .rst requirement would be for the ability to reuse \ncode from multiple places. Never\u00adtheless, multiple inheritance is a standard thorny feature of OO languages: \nnaming con.icts, constructor ambigui\u00adties, and inadvertent double-state problems arise. Modern OO languages \nsuch as Java, C#, and Scala have explicitly abandoned multiple inheritance.  Inheritance is rigid: in \nits base form, the relationship between a class and its superclass is determined at the time of writing \nthe code for the subclass. Mechanisms   such as mixins and traits [3, 6, 28] attempt to remedy this \nshortcoming by adding much needed .exibility. The mechanism of method delegation is often used as a more \ndisciplined substitute of inheritance: the programmer explicitly creates a reference to a delegatee object \nand meth\u00ad ods that forward their arguments to the appropriate method of the delegatee object. In this \nway, the programmer is in full control of the code reuse mechanisms, circumventing many of the surprising \naspects of (single or multiple) inheritance. Nevertheless, delegation is a primitive mechanism, afford\u00ad \ning none of the convenience and automatic code reuse of in\u00ad 1 2 heritance. More advanced delegation mechanisms \nhave been 3 proposed [19, 26] but either suffer from the coarse-grained 4 reuse problem of inheritance \nor do not support automatic reuse of code without naming reused members explicitly. 5 6 7 In past work \nwe have proposed the idea of class morphing 8 [10 12], which provides a glimpse at a possible full substi\u00ad \n9 tute of inheritance. Morphing is a programming construct that allows a program class or module to have \nnon-.xed 10 11 12 contents. E.g., instead of a class declaring a speci.c set of methods, it may declare \nthat its methods match one-to-one (with appropriate changes based on a .xed pattern) those of another \nclass. For instance, a morphed class Listify may statically iterate over all the methods of another class, \nSubj, pick those that have a single argument, and offer isomor\u00ad phic methods: whenever Subj has a method \nwith argument A,Listify accepts a List<A>. (The implementation of ev\u00ad ery method in Listify can then, \ne.g., iterate over all list elements, and manipulate them using Subj s methods.) The MorphJ programming \nlanguage is an extension of Java that serves as the reference embodiment of morphing principles. The \ndescribed Listify functionality in MorphJ is shown below: 1 class Listify { 2 Subj ref; 3 Listify(Subj \ns) {ref = s;} 4 5 <R,A>[m] for (public R m(A): Subj.methods) 6 public R m (List<A> a) { 7 ... /* e.g., \ncall m for all elements */ 8 } 9 } Everything but line 5 looks like plain Java code, but it is line 5 \nthat determines what lines 6-8 really mean. Lines 5-8 form a re.ective declaration block: line 5 de.nes \nthe range of elements being iterated over; lines 6-8 are the method being declared once for each element \nin the iteration range. The iteration happens statically. Line 5 says that we want to iterate over all \nmethods of Subj that match the pattern public R m (A) , where R,A, and m are pattern variables (declared \nbefore the keyword for). R and A are pattern type variables, where R and A match any type except void; \nm is a name variable, and matches any identi.er. Thus, this block iterates over all public methods of \nSubj that take one argument of any type and have non-void returns. For each such method, lines 6-8 declare \na method with the same return type, name, and argument types equal to a list of the original argument \ntype. Morphing can be used to transform delegation into a mechanism that is as transparent and convenient \nas inher\u00aditance, without sacri.cing programmer control. A client class, C, may want to transparently \nsupport all methods from class S and also supply methods foo and bar. The straight\u00adforward way to do \nthis is to just use a static iteration over S s methods and give implementations for foo and bar: class \nC { S ref; C(S s){ref = s;} // to initialize ref <R,A*>[m] for (public R m(A) : S.methods) public R m \n(A a) { ... return ref.m(a); } void foo(...) {...} // anything void bar(...) {...} } (We use a new primitive \nin this example: the star after type parameter A means that it can match any number of arguments.) Morphing-plus-delegation \nstill does not equal inheri\u00adtance, however! The problem is that the above combination does not support \nthe late binding properties of inheritance. What if a method from S was also de.ned in C, i.e., if S \nde.ned (and used) methods foo or bar? In an inheritance setting, the method is overridden: method calls \ninside S are late-bound, so that they may dispatch to methods in C in\u00adstead. Importantly, this can be \nperformed in already com\u00adpiled code. Yet no such late binding occurs when morphed class C uses S as a \nmere external client. The facility of late binding is essential in the context of morphing. As a result, \nit requires us to introduce the concept of a strong bond between a morphed class and its delegatee. We \nuse a special keyword, subobject, to signify such a bond. As we show, this is similar to past work on \ndelegation mechanisms [19], yet with the subtlety that morphing allows strong bonds between objects and \ntheir subobjects without any obligation for automatically inheriting code or exporting members to clients \nany automation desired can be selec\u00adtively introduced by the programmer using a static iteration (a morphing \nfor loop) instead of implicitly. The result of this work is a Java-like language design that presents \na full substitute of inheritance through delegation and morphing. At the same time, the in.exibility, \ncoarse\u00adgranularity, etc. problems of inheritance are addressed di\u00adrectly. The contributions of our work \nare as follows: We show mechanisms that address the traditional prob\u00adlems of inheritance without sacri.cing \nautomation. Com\u00adpared to past work on delegation mechanisms, we dis\u00adsociate the concept of late binding \nfrom the concept of reusing members of a delegatee, resulting in a clean sep\u00adaration with many .exibility \nmechanisms. Compared to past work on morphing mechanisms, we add the essential capability of late binding, \nwhich allows delegation to be a full substitute of inheritance. 1  Our language, DelphJ,1 supports a \nunique combination 2 of features yielding great power: subtyping (i.e., interface 3 4 conformance and \ndynamic substitutability of subtype ob\u00ad 5 6 jects for supertype objects) but not inheritance; delega\u00adtion \nwith late binding; programmer control over all reuse 7 8 without sacri.cing automation; and modular type \ncheck-9 ing in the case of generic classes. 10 We present our design both through informal examples 11 \n(which elucidate some of the dif.culties of late binding for delegation e.g., versions of the fragile \nbase class problem) and through a formal model based on Feather\u00adweight GJ (which makes our design decisions \nfully pre\u00adcise). In the rest of the paper, we present our language design informally, via examples (Section \n2), discuss the deep issues concerning the addition of delegation (Section 3), detail a formalism that \ncaptures the essence of our approach (Sec\u00adtion 4), compare to related work (Section 5), and conclude \n(Section 6). 2. Morphing and Late Binding Class-based inheritance provided by popular languages such \nas Java is often not .exible enough to support agile behav\u00adior sharing mechanisms between objects and \nto represent dynamic object evolution. It can also introduce problems that arise either accidentally, \nas in the case of the accidental method overriding problem, or due to poor design decisions and documentation, \nas in the case of the fragile base class problem [24] or the circle-ellipse problem [16]. Our work avoids \ninheritance-related shortcomings, by eliminating class-based inheritance in favor of a more .ex\u00adible \nmodel, where code reuse is separated from subtyping: conformance to an externally visible interface is \ncompletely dissociated from the ability to reuse implementations. In this section, we show the design \nof our language, DelphJ, via in\u00adformal examples. These will show how object composition via delegation, \nlate binding, interface subtyping and mor\u00adphing can be combined. The presentation emphasizes the points \nof difference between DelphJ and Java. That is, for features not mentioned it is typically safe to assume \nthat they are handled as in Java. Example 1 (Consultation). The combination of morph\u00ading ideas with \ntraditional delegation in mainstream OO lan-1 guages can express a pattern often called consultation \nor for-3 2 warding [19, 21]. In DelphJ, consultation is expressed (and 4 1DelphJ is just MorphJ augmented \nwith delegation features (and eliminat\u00ading inheritance), as described in this paper. In all ways not \nrelating to dele\u00adgation (esp. morphing features) the languages are identical. has been since the original \nMorphJ work) via static-for loops as shown in the class below that logs method invocations be\u00adfore performing \nthem: class Logger { Subj ref; Logger(Subj s) {ref = s;} // initialize <R,A*>[m] for (public R m(A) : \nSubj.methods) public R m (A a) { System.out.println(\"method \" + m.name + \" called with arg \" + a); return \nref.m(a); } } In this example, a client of Logger calls methods that are eventually forwarded to Subj. \nConsultation is an automatic mechanism to forward method calls and morphing allows its .exible use. We \ndo not sacri.ce automation (since a single static-for use can imple\u00adment forwarding for any number of \nmethods) yet the user also has complete control over which method calls get for\u00adwarded (via the pattern \nemployed in the static-for). This is in contrast to past language constructs for consultation, where \nautomatic forwarding applied indiscriminately to all meth\u00adods. Example 2 (Late binding). As already mentioned \nin the Introduction, consultation is not always the mechanism one may want to employ, because it lacks \nlate binding capabili\u00adties. In our Logger example, if class Subj has two methods foo and bar, such that \nfoo invokes bar, both methods will be logged, but the call of bar inside foo will not. The addition of \na late binding facility is a major one in the DelphJ language and has signi.cant implications, as we \nalso discuss in detail in Section 3. Automatic mechanisms for for\u00adwarding method calls together with \nlate binding are often called just delegation [22] in the research literature, but we will use the term \ndeep delegation to avoid confusion with ex\u00adisting mainstream facilities. Deep delegation consists of \nthe automatic method call forwarding from a child to a parent object, when the self reference is bound \nto the method re\u00adceiver (the child). Consultation, on the other hand, is also an automatic method forwarding \nmechanism, however self is bound to the method holder (the parent). Informally speak\u00ading, deep delegation \ncan emulate inheritance, while consul\u00adtation is merely an automation mechanism. Our late-binding facility \napplies on a per-.eld basis. We introduce a new modi.er, subobject, to indicate .elds with implicit support \nfor late binding. Our earlier Logger class only needs to declare that its ref .eld refers to a subobject. \nclass Logger { subobject Subj ref; ... // as before } Methods of Subj are overridden if they are designated \nas public and not .nal, and are also declared in the Logger class. Therefore, Logger can now properly \nintercept and morphing. At the same time it gives the programmer full control over which method calls \nwill be forwarded.  log all public method invocations, including those internal to Subj. The following \nexample illustrates a multilevel wrapper case. More speci.cally, we have two levels of wrappers, but \nthis can be generalized to any number of levels. 1 class Wrapper1 { 2 subobject Subj ref = ... 3 4 <R,A*>[m] \n5 for (public R m(A): Subj.methods) 6 public R m (A a) { 1 7 ... 2 8 return ref.m(a); 3 9 } 4 10 } 5 \n11 class Wrapper2 { 6 12 subobject Wrapper1 ref = ... 7 13 8 14 <R,A*>[m] 9 15 for (public R m(A):Wrapper1.methods) \n10 16 public R m (A b) { 11 17 ... 12 18 return ref.m(b); 13 19 } 14 20 } 15 16 Assuming that we invoke \na method on an instance of 17 Wrapper2, ref.m(b) will be called, which in turn calls 18 ref.m(a) within \nthe body of the .rst wrapper. Eventually, 19 20 the actual implementation of method m will be invoked. \nThe 21 object path through which the actual implementation of m 22 is reached is termed access path and \nhas a crucial role in DelphJ. In the example above, the path that m(b) (inside 23 24 25 Subj)is accessed \nfrom is Wrapper2 -Wrapper1 - Subj (in a simpli.ed form, showing only the types of each object on the \npath) . The dynamic dispatch algorithm utilizes the access path in order to locate the appropriate method \nto dispatch to. Intuitively, when an object o is accessed through subobject .elds, the reference to o \nis not merely a pointer to it, but the full list of object pointers and subobject .eld identi.ers that \nhas led to o. Section 3 discusses in more detail the access path and how it is formed during execution. \nDeep delegation and subclassing discussion. Several lan\u00ad guage and software designers have criticized \nthe use of inheritance and have instead promoted delegation, which, however, lacks much of the inheritance \nconvenience delegated methods need to be explicitly named one-by-one, resulting in brittleness and verbosity. \nAt the opposite end, past mechanisms for deep delegation support both late bind\u00ad ing and automatic forwarding \nof method calls using a single keyword (e.g., delegatee [19, 21]). In DelphJ we dissociate the two concepts \ncompletely. Our subobject annotation does not imply any automatic for\u00ad warding of method calls to the \nsubobject reference. Instead, the user of the mechanism is responsible for establishing forwarding as \ndesired using morphing capabilities. This ap\u00ad proach achieves automation e.g., it reduces the impact \nof the fragile base class problem, as modi.cations to a base class are automatically propagated to the \nchild classes via Example 3 (Multiple parents). Delegation can be com\u00adbined with late binding in DelphJ \nto emulate multiple in\u00adheritance, but without any loss of control. As a standard ex\u00adample of multiple \ncode reuse, the following GradStudent class has subobjects of type both Employee and Student, thus reusing \nthe functionality of both. class GradStudent { subobject Student sref; subobject Employee eref; GradStudent(Student \ns, Employee e) { sref = s; eref = e; } // initialize <R,A*>[m] for (public R m(A): Student.methods; \nno R m(A): Employee.methods) public R m (A a) { ... } // handle methods only in Student <R,A*>[m] for \n(public R m(A): Employee.methods; no R m(A): Student.methods) public R m (A a) { ... } // handle methods \nonly in Employee <R,A*>[m] for (public R m(A): Employee.methods; some public R m(A): Student.methods) \npublic R m (A a) { ... } // handle methods in both } The example de.nes three static-for loops. The .rst \nin\u00adcludes methods from Student but not Employee, the sec\u00adond does the converse, and the third includes \nmethods com\u00admon to both. The listing showcases an important feature of DelphJ (inherited transparently \nfrom MorphJ [10]): nested patterns (via the no and some keywords). We use them above to select methods \nfrom one subobject that are/are not present in the other. The DelphJ type system ensures that the re.ective \nblocks produce non-con.icting methods, i.e., the user receives a type error if overlapping cases exist. \n(In\u00adtuitively, con.icts are detected in two steps: .rst by trying to unify the pattern describing methods \ngenerated by each static-for loop, and, second, by checking whether the pri\u00admary and nested patterns \nare enough to ensure that seem\u00adingly con.icting methods will never have the same name or argument types.) \nWe, thus, see that morphing ensures convenient code reuse but without relinquishing control over method \nfor\u00adwarding. Also, although our examples focus on meth\u00adods, the same handling applies to .elds (e.g., \nthe code could specify a pattern over Student.fields instead of Student.methods). Example 4 (Dynamic \nobject evolution). Acommon issue with class-based inheritance is that it fails to capture dy\u00adnamic object \nevolution. For instance, it is not possible to change the functionality of base classes at run-time (hot\u00adswapping) \n[23]. DelphJ permits dynamic delegation [20], where subobject .elds may be safely mutated without having \nto re-compile the original code. This feature also raises semantic complexities, which we defer discussing \nun\u00adtil Section 3. The example below modi.es the subobject .eld, ref, dynamically. Method Window.draw \noverrides the draw method of its Rendering subobject. The invoca\u00adtion of w.setWidget alters the behavior \nof object w dynam\u00adically and from this point on the draw implementation of SmoothDrawing is used.  1 \ninterface Rendering { 2 public void draw(); 3 } 4 5 class Window { 6 subobject Rendering 7 ref = new \nDefaultRenderer(); 8 public void draw() { return ref.draw();} 9 10 void setWidget(Rendering newRef) \n11 { ref = newRef; } 12 } 13 ... 14 Window w = new Window(); 15 w.draw(); //Dispatching to ref s draw. \n16 w.setWidget(new SmoothDrawing()); 17 w.draw(); //Altered behavior. 18 ... Example 5 (Subtyping). Our \nlanguage design eliminates inheritance and subclassing, but fully supports subtyping. This is effected \nthrough interfaces. DelphJ supports nominal subtyping and a class/interface can be a subtype of multiple \ninterfaces. As in Java, interfaces are organized hierarchically and conformance of a class to an interface \nis designated by the keyword implements. An object of class C implement\u00ading an interface I can be used \nwhere a value of type I is expected, satisfying the Liskov substitution principle. Inter\u00adfaces can also \nbe used as types of subobject .elds. Since we have dissociated reuse of code from subtyp\u00ading, there is \nno requirement that method signatures of subobject .elds of C also exist in the interface imple\u00admented \nby C, but the programmer can easily effect this if desired by using a static-for construct. In the example \nbe\u00adlow, the interface, I, of the subobject of type Subj is also supported by the Wrapper class, and even \nextended with ex\u00adtra members (which are in interface IPlus). Class Wrapper showcases that a) a class \ncan use a pattern to delegate to some methods of a subobject; b) a class can override other methods of \nthe subobject with explicit de.nitions; c) a class can provide extra methods, thus extending its interface. \n 1 interface I { 2 void foo(); 3 void bar(); 4 void baz(); 5 } 6 interface IBasic { 7 void foo(); 8 \n9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 2 3 4 5 6 7 8 9 10 11 1 2 3 4 } interface IPlus extends \nI { void foobaz(); } class Subj implements I {...} class Wrapper implements IPlus { subobject Subj ref; \nWrapper(Subj s) {ref = s;} // initialize <R,A*>[m] for (public R m(A) : I.methods; no R m(A) : IBasic.methods) \npublic R m (A a) { return ref.m(a) } // delegate methods in Subj but not in IBasic void foo() {...} // \nhandle the IBasic method void foobaz() {...} // handle any extra methods } Example 6 (Generics and modular \ntype safety). All our examples so far contained known types. Static-for loops were thus merely a syntactic \nconvenience. The hallmark fea\u00adture of morphing is that the same capabilities exist even over type parameters. \nThat is, we can de.ne generic classes that take other types as yet-to-be-determined parameters. Our ex\u00adamples \nwould all work even when the types involved (e.g., the type Subj of the subobject reference) were unknown. \nFor instance, our earlier Logger class would most likely be written in a fully generic form: class Logger<X> \n{ X ref; Logger(X x) {ref = x;} // initialize <R,A*>[m] for (public R m(A) : X.methods) public R m (A \na) { System.out.println(\"method \" + m.name + \" called with arg \" + a); return ref.m(a); } } The ability \nto have generic types offers great power in DelphJ. For instance, we can de.ne as a single, reusable \ngeneric type a static computation yielding the public inter\u00adface of any class: interface PublicInterface<X> \n{ <R,A*>[m] for (public R m(A) : X.methods) public R m (A); } For any class C, PublicInterface<C> yields \na new interface containing C s public members. The interesting feature of DelphJ (and MorphJ before it) \nwith respect to generics is that it maintains modular type safety. This means that a generic class is \ntype-checked once\u00adand-for-all and, if it passes type-checking, it will yield type\u00adsafe code for any type \nparameter passed to it that respects the stated obligations of type parameters. For instance, in our \nearlier generic Logger<X> class, the type system veri.es that the call ref.m(a) is always possible, regardless \nof the type of ref, i.e., regardless of what X has been passed as a type parameter. In cases of complex \npatterns and mixes efforts in this direction have been made (e.g., [31]) though not with a formally proven \ntype system for generic aspects.  of pattern-based and hand-coded methods, this capability is invaluable \nfor the debugging of generic code. An even more interesting example comes from general\u00ad izing our earlier \nscenario of a class that has two subobjects ( multiple parents ) and overrides methods from either of \nthem using different strategies. The generic class below cap\u00ad tures such a general skeleton. For convenience, \nit .rst de.nes a generic interface that computes the difference of the inter\u00ad faces of two given types. \nIt then (for the sake of the example) just dispatches to the unique methods of either subobject and uses \na .lter to decide how to handle common methods. 1 interface SetMinus<X,Y> { 2 <R,A*>[m] for (public R \nm(A) : X.methods; 3 no R m(A) : Y.methods) 4 public R m (A); 5 } 6 7 class C<X,Y> { 8 subobject X parent1 \n= ... 9 subobject Y parent2 = ... 10 11 <R,A*>[m] 12 for (public R m(A): // only in X 13 SetMinus<X,Y>.methods) \n14 public R m (A a) { return parent1.m(a);} 15 16 <R,A*>[m] 17 for (public R m(A): // only in Y 18 SetMinus<Y,X>.methods) \n19 public R m (A a) { return parent2.m(a);} 20 21 <R,A*>[m] 22 for (public R m(A): X.methods; 23 some \npublic R m(A): Y.methods) 24 public R m (A a) { 25 return Coin.flip()?parent1.m(a):parent2.m(a); 26 } \n27 } This generic combination of functionality from two sub\u00ad objects is still type checked modularly. \nThe important check here is for the non-con.icting de.nitions of methods. The DelphJ type system ensures \nthat declared methods do not con.ict (i.e., there are no duplicate de.nitions with the same argument \ntypes), for any values of unknown type parameters X and Y. The type system manages to do this by leveraging \nthe patterns (including nested patterns) in the above code. Aspect-oriented features discussion. Morphing \ndoes not just supercharge delegation but also captures many common needs for aspect-oriented programming \n[18]. Using static\u00ad for loops, we can de.ne common behavior for a set of methods. This behavior can play \nthe role of before-advice, after-advice, or around-advice [17]. However, the empha\u00ad sis of morphing is \non modular reasoning and modular type\u00ad checking: as we saw in our last examples, the language is designed \nin such a way that a morphed generic class can be type-checked and its well-formedness can be ensured \nre\u00ad gardless of the code it is applied to. In contrast, standard aspect-oriented constructs offer no \nwell-formedness guaran\u00ad tees when the code they apply to is unknown. Some research 3. Subtleties of \nDelegation The previous section showcased our overall programming model, i.e., the use of morphing together \nwith deep dele\u00adgation as a full substitute of inheritance and an overall ex\u00adpressive, modular mechanism. \nWe next focus more deeply on the subtleties of deep delegation and the relevant design decisions in DelphJ. \nNominal subtyping via interfaces. Interfaces are orga\u00adnized in a hierarchy and serve two purposes: .rst, \nthey act as supertypes of classes, designated via the implements clause; second, interfaces can be employed \nas subobject .eld types to provide .ne-grained method visibility and overriding for objects stored in \nsuch .elds. Our overriding strategy is that a wrapper class can only override non-.nal methods of a subobject \n.eld if the methods are present in the static (i.e., declared) .eld type. Since in DelphJ subtyping only \noccurs via interfaces, when we use an interface as the static type of a subobject .eld, we are limiting \nthe potential for late binding to methods de\u00ad.ned in the interface (and not all methods in the object \nthat the subobject .eld currently references). This design de\u00adcision has the rationale that classes can \nbe developed sepa\u00adrately from their subobject .elds classes, and a wrapper class should never be able \nto override a method it does not know about. This feature prevents accidental method overriding by wrapper \nclasses as in Figure 1. Let us assume that classes Widget and ThirdParty have been independently devel\u00adoped \nand only method checkBounds should be overrid\u00adden, as indicated by IThirdParty. Widget obtains the checkBounds \nfunctionality by delegating checkBounds invocations to a ThirdParty object. Both Widget and ThirdParty \nindependently implement method checkRes, thus Widget is unaware of the checkRes implementation in ThirdParty. \nIn this code, overriding the behavior of ThirdParty.checkRes would result in a runtime excep\u00adtion. Our \npolicy of requiring that overridden methods in a subobject be both non-.nal and declared in the static \ntype of the subobject .eld yields .ne-grained control, for both parties in the subobject relationship. \nThe wrapper class can control what it overrides, allowing for the possibility of non\u00adinterfering, unknown \nsubobject methods. The subobject s class can also prevent overriding of a method by declaring it to be \n.nal: a method that is declared in a wrapper class, but is not a non-.nal method of a subobject .eld \ntype will be ignored by the dynamic dispatch algorithm. Access paths and late binding. The access path \nof an ob\u00adject o is an important concept in our language design and is de.ned as the ordered sequence \nof subobjects through case of subj the access path is trivial, i.e., contains a single member subj is \na direct reference to object s1, just like in Java.) Thus, the dynamic dispatch behavior is different \nfor methods invoked via alias compared to methods invoked via subj.  Figure 1 Accidental method overriding \n(avoided). 1 interface IThirdParty { 2 public void checkBounds(); 3 } 4 5 class ThirdParty { 6 public \nvoid checkBounds(){ 7 if(checkRes() > 1024) 8 throw new InvalidResolution(); 9 else ... 10 } 11 public \nint checkRes() { ... } 12 } 13 14 class Widget { 15 subobject IThirdParty impl; 16 public Widget(IThirdParty \ni){ impl = i; } 17 public void checkBounds(){ impl.checkBounds(); } 18 public int checkRes() { return \n2048; } 19 } 20 21 new Widget(new ThirdParty()).checkBounds(); which o is accessed. Intuitively, the \naccess path is the path to be searched to implement dynamic dispatch. A way of un\u00ad derstanding access \npaths is to regard them as substitutes of this: if (o1 -f1 . . . -fn on).m() is invoked, where o1 to \non is the access path, then method lookup within m and for m itself will consider the entire path o1 \nto on for .nding the appropriate method. (The suf.xes on the arrows in the above representation identify \nthe .eld of the object through which the subobject is accessed, since its type matters for dispatch, \nper our preceding discussion.) The intuition is that the most recent version of m will be selected, which \nimplies selecting the left-most element of the path that overrides m. A key point is that access paths \ndo not pertain to objects but to references. The same object can have multiple access paths: one for \neach reference (a.k.a. alias) to the object. We will use the following example to explicate the concept: \n1 class Wrapper { 2 subobject Subj ref; 3 Wrapper (Subj s) { ref = s; } 4 ... 5 } 6 7 Subj subj = new \nSubj(); // object s1 8 Wrapper w1 = new Wrapper(subj); // object o1 9 Wrapper w2 = new Wrapper(subj); \n// object o2 10 Subj alias = w2.ref; The example gives names (s1, o1, o2)to the three dis\u00ad tinct objects \ncreated. Objects o1 and o2 share s1 as a sub\u00ad object. This means that the value of reference w1.ref is \nnot just a pointer to s1 (as would typically be in Java) but a representation of the access path (o1 \n-ref s1). Similarly, the value of reference w2.ref is (o2 -ref s1) and not just s1. Additionally, the \ntwo references subj and alias are not equivalent, although they refer to the same object (s1), because \nthey evaluate to different access paths. (In the Fundamentally, the reason that references hold access \npaths, and not merely object pointers, in our language de\u00adsign is that our objects do not own their subobjects, \nunlike in a language with inheritance. The concept of a subobject also exists in inheritance-based languages \nthe term is especially common for languages with multiple inheritance: an object of class C with superclasses \nS and T is said to contain S and T subobjects. However, an object in an inheritance-based lan\u00adguage owns \nits superclass subobject. That is, every object of class C can be thought of as having a unique, non-aliasable \nreference to a full object of C s superclass. (This also pre\u00advents circular references. In our language \nmodel it is the re\u00adsponsibility of the programmer to avoid circular references, or a run-time error ensues.) \nAt the implementation level, this ownership typically translates into embedding the superclass subobject \ninside the object. In our design, however, since subobjects can be aliased, they need a per-alias record \nof how they are accessed, in order to implement dynamic dis\u00adpatch properly. (In other delegation-based \napproaches [20], object access through a subobject .eld does not evaluate to the entire access path but \nto a single reference to the ob\u00adject, limiting the generality of dynamic dispatch.) Our references can \nbe passed around as arguments or re\u00adturn values, stored in local variables, etc. The only seman\u00adtic question \narising is how access paths are built. The gen\u00aderal syntax of a .eld access (object .eld read) is obj \n= obj2.fld . If obj2 already encodes a non-trivial access path, then this path is augmented with the \n(pointer) value of .eld fld and the resulting access path is the value of obj. This can be viewed as \nmerging access paths. That is, if we view .eld fld as storing the full access path of the last ref\u00aderence \nthat was assigned to it, then during the .eld read op\u00aderation obj = obj2.fld the access path stored in \nfld is ignored, except for the last object itself, which is appended to the access path of obj2. For \ninstance, with the de.nition of class Wrapper as in our previous example, let us de.ne references as \nfollows: 1 Subj subj1 = new Subj(); // object s1 2 Subj subj2 = new Subj(); // object s2 3 Wrapper wrap1 \n= new Wrapper(subj1); // object o1 4 Wrapper wrap2 = new Wrapper(subj2); // object o2 5 Subj aliasForS2 \n= wrap2.ref; 6 wrap1.ref = aliasForS2; 7 Subj subj3 = wrap1.ref; The access path for reference wrap1 \nis o1 (a trivial path), while the access path for reference aliasForS2 is (o2 -ref s2). After the assignment \nof the next-to-last line, .eld ref of object o1 holds the access path (o2 -ref s2) (exact copy of the \nvalue of aliasForS2). After the last line, however, reference subj3 holds the access path (o1 -ref s2): \nthe only part of the access path (o2 -ref s2) kept is the object being referenced (s2), and that object \nis appended to the access path of wrap1. 1  The above is the main interesting semantic issue of our \n2 3 deep delegation approach. Reads from .elds is both the 4 5 way to form more complex access paths \nand the only case an access path is not copied when references are assigned. 6 In all other cases, access \npaths are propagated unchanged. 7 8 Our above discussion of access path merging also closely 9 10 matches \nthe main rule of our operational semantics in Sec\u00ad tion 4. As we discuss later, an actual implementation \ncan 11 12 optimize away access paths for references stored in object 13 .elds only local variables (of \na reference type) need to 14 15 store access paths. 16 Mutability of subobject .elds. As we saw, a signi.cant \n17 18 difference between our deep delegation approach and tradi-19 tional inheritance is that our objects \ndo not own their sub\u00ad 20 objects. A further difference is that if a subobject .eld is 21 not declared \nto be final, it can be mutated. As discussed 22 23 in Section 2, this is a desirable capability since \nit allows dy\u00ad 24 25 namic object evolution. However, mutability of subobject .elds (dynamic delegation \n[20]) raises interesting issues. 26 27 Our design decisions described earlier in this section (use 28 \nof static type of subobject reference in overriding, associat\u00ad 29 ing access path with references) address \nthe issue: an object may change its subobject, yet a reference always holds the access path that allows \nit to perform the operations that its type allows, ensuring type soundness. This aspect is worth elucidating \nsince it is key to our approach. Access paths are values in DelphJ. They are im\u00admutable, although the \nreferences between objects are muta\u00adble. Consider an access path (o1 -ref o2) stored in refer\u00adence variable \nv. Even if the linking of objects changes (e.g., o1 now points through .eld ref to o3 instead of o2) \nthe ac\u00adcess path inside variable v remains (o1 -ref o2). This does not, however, mean that variable v \nis immutable it can be set to point to any other object, just like reference variables in Java can. If \naccess paths were not immutable values but subobject references could be mutated, several type or se\u00admantic \nsoundness violations would arise. To see the issue, consider the example of Figure 2. (The example has \nbeen minimized yet remains involved, hence it is easier to follow it via our explanation below.) Interface \nS de.nes two methods, foo and baz. Two classes, S1 and S2, implement S. The implementation of S1.foo \ninvokes baz and the private method bar. Notice that S2 also declares bar with a different type signature. \nFinally, the wrapper class C, overrides the two methods of S and swaps the implementations of S1 and \nS2 when baz is invoked. The main program invokes C.foo, which dele\u00adgates the call to S1.foo. The next \nmethod to be invoked is baz, which is overridden by C.baz. The execution of C.baz causes the mutation \nof the impl subobject reference, replac-Figure 2 Mutable subobject .elds may violate type safety. interface \nS { public int foo(); public void baz(); } class S1 implements S { final public int foo() { this.baz(); \nreturn this.bar(); } public void baz() { ... } int bar() { ... } } class S2 implements S { final public \nint foo() { ... } public void baz() { ... } String bar() { ... } } class C { subobject S impl; public \nC(){impl = new S1();} public void baz(){impl = new S2();} public int foo(){return impl.foo();} } ... \nint result = new C().foo(); ... ing an S2 object in the place of an S1. The C.baz method re\u00adturns to \nits caller (S1.foo) which then invokes bar. A naive delegation semantics would invoke bar on the replaced \nsub\u00adobject (S2.bar)which would cause a runtime type error. Even if S2.bar returned an integer (i.e., \nwas type compat\u00adible with S1.bar), the naive delegation semantics would cause a semantic error as there \nwould be a partial state up\u00addate of both S1 and S2. Our delegation semantics binds this of method foo2 \nto the immutable access path C -impl S1, and therefore, invokes the right version of bar. Implementation \nconsiderations. We have implemented DelphJ in a prototype compiler,3 with front-end support for the syntax \nand back-end translation to Java bytecode, us\u00ading the JastAdd framework [7]. The back-end issues for \nthe language are signi.cant, however, and are clearly hinted at from our preceding discussion concerning \naccess paths and their semantics. The interesting elements we have discussed above are: Access paths \nare immutable.  References in DelphJ may refer to access paths and not directly to objects.  2The binding \nis done at invocation time, as in the usual handling of this in OO languages e.g., implemented via passing \nan extra method argument for this. 3Available at https://github.com/plast-lab/DelphJ .  Access paths \nare built/manipulated during .eld reads.  Method dispatch needs to traverse an access path.  This suggests \nsome inef.ciencies of the DelphJ program\u00adming model compared to plain Java: every method invoca\u00adtion \nhas to suffer extra overhead .rstly for manipulating ac\u00adcess paths (building them during .eld reads) \nand also to per\u00adform lookup in the access path data structure, instead of just making a (highly-optimized \nin modern VMs) virtual method call. (In contrast, there is no extra overhead in reference as\u00adsignments: \naccess paths are immutable so creating extra ref\u00aderences to an access path does not entail copying it.) \nAn interesting note is that, in contrast to our earlier step\u00adby-step description, object .elds (of a \nreference type) do not need to store access paths: all objects except the last one on the access path \nwill be ignored, no matter which alias is used to access the .eld. Consider a fragment of our earlier \nexample: ... wrap1.ref = aliasForS2; Subj subj3 = wrap1.ref; No matter what access path aliasForS2 stores, \nit is unnecessary to store all of it inside .eld ref of the object referenced by wrap1. It is suf.cient \nto only store the last object in the access path, which is the only part of the access path to be later \nused in any.eld dereference e.g., appended to the access path of wrap1 in the last line of the above \nexample. The consequence of the above discussion is that access paths are values for stack references \nonly, while references inside the heap (i.e., in .elds) can be direct pointers, just like in Java. Our \ncurrent implementation does not try to eliminate the above overheads. Instead, our back-end de.nes a \nplain Java library that performs the look up and access path merging operations, and our front-end translates \nDelphJ code to use such library operations. In the future, it is interesting to consider optimizations \nso that these overheads can be brough to aminimum, possibly with low-level data structure support and \nspecial-case treatment of references inside a dedicated DelphJ virtual machine. 4. Formalization We next \nformalize our above informal semantic discussion to make the design decisions more precise. We capture \nthe main features of DelphJ and sketch type soundness through a formalism, FDJ, based on FGJ [13] and \nadapting our earlier morphing formalism, FMJ [10, 11]. 4.1 Syntax Our formalism captures the salient \nfeatures of DelphJ but eliminates unnecessary complexity: we model both classes and interfaces (as classes \nwith no .elds and with all their methods having empty bodies). All .elds are implicitly subobject .elds \nin FDJ. Following FMJ, we also restrict similarly our treatment of morphing: single nested patterns are \npermitted as long as theydo not use pattern type or name variables that are not bound by their primary \npattern. There can be only one name variable in a pattern, and keyword 7 is used for name vari\u00adables \nand re.ective de.nitions. Re.ecting over a statically known type, using a constant name in re.ective \npatterns, re\u00ad.ectively declared .elds, static name pre.xes, casting ex\u00adpressions, polymorphic methods \nand method overloading are not formalized. Method overriding is invariant: covariant return types or \ncontravariant argument types are not allowed. The syntax of FDJ is presented in Figure 3. We adopt (or \nstraightforwardly adapt) manyof the notational conven\u00adtions of FGJ: C,D denote constant class names; \nX,Y,Z denote type variables; N,P,Q,R denote non-variable types (which may be constructed from type variables); \nS,T,U,V,W denote types; f denotes .eld names; m denotes non-variable method names; x,y denote argument \nnames. . and . are shorthands for the keywords implements and return, respectively. All classes or interfaces \nmust implement, or extend, re\u00adspectively, an interface, which can be the empty interface, Interface. \nHereon, we overload the term class to also mean interface. The method notation of FDJ slightly di\u00adverges \nfrom standard FGJ: methods accept a single argu\u00adment, and method type signature F and name n are syntac\u00adtically \ndistinct from the method body b, which can either be empty or of the form {x.e;}. The former case permits \nthe speci.cation of interfaces. In the latter case variable x is bound inside the method body. Amethod \ncan be pre.xed with a standard FMJ static for loop R. More speci.cally, notations borrowed from FMJ are: \n7 denotes a variable method name; n denotes either variable or non-variable names; o denotes a nested \ncondition opera\u00adtor (either +or -for the keywords some or no,respectively). We use the shorthand T for \na sequence of types T0,T1, ...,Tn;x for unique variable sequence x0,x1,...,xn; : for sequence concatenation, \ne.g., S:T is a sequence that begins with S, followed by T; and . to denote an empty sequence and sequence/set \nmembership, respectively; and ... for values (one or anynumber, respectively) of no sig\u00adni.cance to a \nrule. For notational convenience, we assume that all our de.nitions are overloaded to apply to sequences \nof arguments of the original expected type, instead of just one argument. We also de.ne A, the re.ective \niteration en\u00advironment, which has the form .Rp ,oRn., where Rp is the primary pattern, and oRn the nested \npattern (o can be + or -). Rp and Rn have the form (T, <Y.P>F). T is the re.ec\u00adtive type, over whose \nmethods Rp iterates. Y are pattern type variables, bounded by P, and F is a method pattern of the form \nU -U0. [ R] constructs the A corresponding to the re\u00ad.ective declaration R. Access paths are represented \nas ordered lists of new C<T>(v), whose elements are connected by ::i , with i be\u00ading the index of the \nsubobject .eld. Access paths are val\u00adues (v) but valid source programs must not contain values they are \nonly included in the syntax since they arise dur\u00ading evaluation. The empty access path is denoted as \n.. Note that access paths in our formalism are shown in inverse or\u00adder compared to those in our informal \ndiscussion of Sec\u00adtion 3: new C<T>(v) ::i new C <T '>(v ') ::0 . in the formalism corresponds to new \nC <T '>(v ') -fi new C<T>(v) in the notation of Section 3 the formal\u00adism maximizes the ease of deconstructing \nlists while the in\u00adformal discussion optimizes exposition.  A program in FDJ is an (e, CT ) pair, where \ne is an FDJ expression, and CT is the class table. Each class declaration has an entry in CT (except \nInterface) and the subtyping relation derived from CT must be acyclic.  4.2 Operational Semantics Figure \n4 de.nes the operational semantics of FDJ. All con\u00adgruence rules are standard. Reduction rules introduce \nor transform values. As we already saw informally, access paths are ordered sequences of object values \nand are used by the dynamic dispatch algorithm in order to select the most recent method overriding another \nmethod. The .rst element of an access path can be considered as the object on which .eld and method accesses \nare performed. An access path can be constructed by either reaching an object through a se\u00adquence of \nsubobject .eld accesses or by allocating a new object. In the former case, the object stored in a subobject \n.eld is itself an access path, whose tail (i.e., its former access path) is ignored and its head is appended \nto the current ac\u00adcess path. This is shown in rule R-FIELD, which reads .eld fi by reading the i-th constructor \nparameter vi of the .rst el\u00adement (new C<T>(v)) of the access path. Notice that the left-hand-side of \na .eld access must be a value. vi is then deconstructed to a head and a tail (i.e., the former access \npath of the head) and the head is appended to its new access path. Therefore, this implements the path \nelimination strat\u00adegy discussed in the previous section. The append operator is annotated with i, denoting \nthat the head was accessed by the next element of the access path through .eld fi. In the case of allocating \na new object, reduction rule R-NEW transforms a new C<T>(v) expression, whose argu\u00adments have been evaluated \nto values, to a value: a singleton access path consisting of the new expression itself. The ap\u00adpend operator \nis annotated with zero (an arbitrary choice) and the next element is the empty access path (.). Rule \nR-INVK expects an access path, performs method lookup (mbody) using the method name m and the access \npath v. The lookup operation returns the formal parameter list (x), the method body e and a suf.x of \nthe input access ' ' path v of v such that m belongs in the head of v and there is no other object after \nthe head element that overrides m. Figure 5 de.nes the method body lookup rules necessary for the operational \nsemantics, which are only de.ned for constant method names (m). It is not meaningful to de.ne method \nbody lookup for variable method names (7) we are looking up the de.nition by the name of an actual method \nbeing called, although the lookup may need to consult a re.ective iteration block to .nd the method body. \nFunction method performs method lookup in a single class. It takes two arguments, the method name m and \nthe class type C<T>, looks up m only in C<T> and returns the en\u00adtire method de.nition M having substituted \ntype and pattern variables for concrete types. A detailed discussion regard\u00ading the semantics of method \nis deferred until the following section. Predicate validOverride satis.es the condition de\u00adscribed in \nSection 3: a method call over a subobject can be dynamically dispatched to the holder of the subobject \nref\u00aderence only if it belongs in the static type of the subobject .eld programs cannot override methods \nthey cannot see. More speci.cally, it establishes that a method of an object (i.e. last argument) is \nlegally overridden by a method of an\u00adother object, when the latter object (a) has the same method name \nand type signature as the overridden method (i.e. .rst premise) and (b) accesses the former object via \na .eld whose type contains a method with the same name and type sig\u00adnature as the overridden method (i.e. \nsecond premise). No\u00adtice that the re.ective de.nitions and the method bodies in validOverride premises \nare irrelevant for determining whether a method is legally overridden. Finally, function mbody performs \nthe lookup, by travers\u00ading the input access path, employs method for extracting the de.nition of m, uses \nvalidOverride to establish legal overrides and returns the method formal parameter, method body and a \nsuf.x of the access path, such that the head of the returned access path and the returned method body \nbe\u00adlong to the same class. The .rst two rules MB-CLASS-S1 and MB-CLASS-S2, represent the case where the \nhead is not followed by any other object that legally overrides m. There\u00adfore, the input access path \nis returned along with the method parameter and body. The last rule MB-CLASS-S3, detects that the successor \nof the access path head legally overrides m so it removes the head from the access path and continues \nthe search for other successors that may legally override m. Notice the last two rules of mbody get stuck \nwhen .eld T '' i (speci.ed by operator ::i ) does not exist in C ', the second element of the access \npath.  4.3 Static Semantics The main typing rules of FDJ are presented in Figure 6. There are three \nenvironments used in typing judgments: A, . and r. The latter two are standard, mapping type vari\u00adables \nto upper bounds and variables to types respectively. A serves a twofold purpose. Firstly, it acts as \na distinct typ\u00ading environment, mapping pattern variables to their bounds. Pattern variables can never \nbe instantiated explicitly, as op\u00adposed to type variables declared in class de.nitions. There\u00adfore, . \ndoes not contain pattern variables. Secondly, it main\u00adtains patterns (i.e., structural constraints) for \ntypes in Rp and Rn that must hold over a re.ective block. Every type variable must be bounded by an interface \ntype. Function bound .;A(T) returns the upper bound of T, when T is a type variable, otherwise it returns \nT. It must be noted that, for notational convenience, we assume pattern and ordinary type variables have \nglobally unique names and that pattern variables are only used in the patterns of the re.ective block \nthat introduced them. Furthermore, we assume that logical connective operands that are unde.ned (e.g., \nwhen a func\u00adtion subexpression is unde.ned) implicitly evaluate to false. Similarly, premises whose value \ndepends on distinct condi\u00adtions are grouped in a case statement (tall left brace). Each line represents \na case with some side conditions. When a left brace evaluates to a particular case then the following \nhold:  Figure 3 FDJ: Syntax T ::= X | N N ::= C<T> | Interface CL ::= class C<X.N> . N {T f; M} R ::= \n<X . N>for(Mp;oMn) | F ::= T-T M ::= R n:F b o ::= + | - M ::= n:F in T.methods e ::= x | e.f | e.n(e) \n| new C<T>(e)| v b ::= {x.e;} | v ::= . | new C<T>(v) ::i v n ::= m | 7 Figure 4 FDJ: Reduction Rules \nReduction Rules: (new vi = new C ' <T ' >(v ' ) ::. ' v ' C<T>(v) ::. v).fi --new C ' <T ' >(v ' ) ::i \n(new C<T>(v) ::. v) (R-FIELD) new C<T>(v) --new C<T>(v) ::0 . (R-NEW) mbody (m, v)=(x,e,v '' ) v.m(v \n' )--[v ' /x, v '' /this]e (R-INVK) e0 --e ' 0 e0.f --e ' 0.f (RC-FIELD) e0 --e ' 0 e0.m(e) --e ' 0.m(e) \n(RC-INV-RECV) e --e ' v.m(e) --v.m(e ' ) (RC-INV-ARG) new ei --e ' i C<T>(v1,...,vi-1,ei,...) --new C<T>(v1,...,vi-1,e \n' i,...) (RC-NEW-ARG) (a) the side condition of the particular case is satis.ed and (b) for each of \nthe previous cases either their side condition does not hold or the actual result is unde.ned. In the \nfollowing sections we discuss key aspects of our type system: access path typing, re.ective range containment-disjointness, \ninterface and class typing, and method invocation typing. 4.3.1 Access path typing Access paths v cannot \nexist in the original source code as they are intermediate values, but they must be typed for proving \nmetatheorems. Access paths are typed via rule T-VAL. Empty access paths . are not typable. Non-empty \nac\u00adcess paths are of the form new C<T>(v) ::i v. The .rst premise of T-VAL says that new C<T>(v) must \nbe well\u00ad ' typed (and thus concrete ). It also says that the head of vi,  ' where v is the ith constructor \nargument of the head of v, i Figure 5FDJ: Method body lookup rules. Valid override: \u00d8; \u00d8.method(m, C<T>) \n= \u00d8; \u00d8.method(m, Ti) = validOverride(C<T>, Ti, m:F m:F m:F ) (V-CLASS) Method body lookup: v = new C<T>(v) \n::i . \u00d8; \u00d8.method(m, C<T>) = R m:F {x.e;}mbody(m, v)=(x,e,v) (MB-CLASS-S1) v = new C ' <T ' >(v ' ) ::. \nv ' \u00d8; \u00d8..elds(C ' <T ' >)=T '' f \u00d8; \u00d8.method(m, C<T>) = M = R m:F {x.e;}\u00acvalidOverride(C ' <T ' >, T \n'' i , M) mbody(m, new C<T>(v) ::i v)=(x,e,new C<T>(v) ::i v) (MB-CLASS-S2) v = new C ' <T ' >(v ' ) \n::. v ' \u00d8; \u00d8..elds(C ' <T ' >)=T '' \u00d8; \u00d8.method(m, C<T>)= M validOverride(C ' <T ' >, T '' i , mbody(m, \nnew C<T>(v) ::i v)=mbody(m, v) f M) (MB-CLASS-S3) Figure 6FDJ: Typing Rules Expression typing: .;A;r \nok .;A;r.x .r(x) (T-VAR) .;A;r.e0.T0 .; A ..elds(bound.;A(T0))=T .;A;r.e0.fi.Ti f (T-FIELD) .;A;r.e . \nT .;A;r.e ' . T ''' .; A .T ' -T '' .; A .mtype(n, T)=T ' -T '' .; A .T ''' <:T ' .;A;r.e.n(e ' ).T '' \nok (T-INVK) .; A .C<T> .;A;r.e.T '' ok .;A;r ok .; A ..elds(C<T>)=T ' f .; A .T '' <:T ' .; A .concrete(C<T>,true) \n.;A;r.new C<T>(e).C<T> (T-NEW) v=new C ' <T ' >(v ' ) ::. v ' .;A;r.new C<T>(v).C<T> implies (v ' i=new \nC<T>(v) ::k v '' .;A;r.new C<T>(v) ::i v.C<T> and .;A;r.v.C ' <T ' >) (T-VAL) Method typing: n=m . R= \n[ R]]=A .;A;r b={x.e;} implies (.;A;r,x.-T ' .e .;r.R n:T ' -T ok .; A .T,T ' ok .T '' and .; A .T '' \n<:T) b OK (T-METH) Class typing: .=X<:N r=this.-C<X> .;\u00d8.C<X>:T ok for all Ri ni:Fi bi, Rj nj:Fj bj . \nM, .;r.Ri ni:Fi bi OK ..validRange([[Ri] , N) and i .= j implies (..disjoint([[Ri] , [ Rj]]) and ni =nj \n=7 or Ri =Rj = and ni =m and nj =m ' ) class C<X.N>.N { T f; M} OK (T-CLASS)  Figure 7FDJ: Method type \nlookup. Specializing re.ective environment: .;[W/Y].A.A.Rp,oRn. .;A;[W/Y].specialize(7, .Rp,oRn.) (SP1) \n.;A.mtype(m, T0)=[W/Y]F1 .; A .W<:P .;A.mtype(m, T1)=[W/Y]F2 . o=+ .;A;[W/Y].specialize(m, .(T0, <Y.P>F1),o(T1, \n<Y.P>F2).) (SP2) Method lookup: [ C] ]=X<:N;N R n ' :F b .CT (C) Ad=[T/X][[R] [W/Y]={ [W/Y] if .;A;[W/Y].specialize(n, \nAd) otherwise n=n ' =m and Ad =\u00d8 .;A.method(n, C<T>)=[T/X][W/Y](R n:F [n/n ' ]b) (M-CLASS) Method type \nlookup:{ .; A .mtype(n, bound.;A(X))=F otherwise (+(X, <Y.P>F),7).A\u00d7{n} .;A.mtype(n, X)=F { .;A.method(n, \nC<T>)=R n:F b otherwise .; A .concrete(C<T>,false) and [ C] ]=X<:N;N and .; A .mtype(n, N)=F (MT-VAR) \n.; A .mtype(n, C<T>)=F (MT-CLASS) Figure 8FDJ: Containment and disjointness rules. Re.ective range containment: \n{ .; . Rn .R [W/Y]R ' if o = + n .;[W/Y].Rp.RR ' p .; . [W/Y]R ' otherwise n .R Rn .;[W/Y]..Rp,oRn..A.R \n' ,oR ' . (SB-A) p n Single range containment: R1=(T1, <X.Q>F1) R2=(T2, <Y.P>F2) .;\u00d8.T2<:T1 F1=[W/Y]F2 \nW<:S<X<:Q .;\u00d8.S<: P .;[W/Y].R1.RR2 (SB-R) Re.ective range disjointness: ' R ' ..+R ' ' R ' ..+Rp\u00aeo \nor \u00aeoRn or ..oRn\u00aeo np n ..disjoint(.Rp ,oRn., .R ' ,o ' R ' .) (DS-A) p n Mutually exclusion of range \nconditions: { .;[W/X].R1.RR2 if o = + ' o. =o .;[W/X].R2.RR1 otherwise ..oR1 \u00ae o ' R2 (ME) Figure \n9FDJ: Well-formness rules and auxiliary de.nitions. Well-formed typing context: ..A ok .; A .range(r) \n: range(.) .;A;r ok ok (WF-TYCON) Well-formed types: .; A .Interface ok (WF-INTER) X.dom(.):X A=.(T1, \n<X.N>F1),(T2, .; A .X ok <X.N>F2). (WF-VAR) .; A .T ok [ C] ]=X<:N;N .; A .concrete(N:N,false) .;A.T<:[T/X]N \n..implement(C<T>) X<:N;\u00d8.N:N ok X not in .,A .; A .concrete(C<T>,true) or .; A .concrete(C<T>,false) \n.; A .C<T> ok (WF-CLASS) .; A .T1,T2 .; A .T1 -T2 ok ok (WF-FTYP) Well-formed Re.ective Environments: \nA=.(T1, <X.N>F1),o(T2, <X.N>F2). implies .; A .concrete(N,false) .;\u00d8.N:T1,2 ok . .A ok dom(.) n X = \u00d8 \n.; A .F1,2 ok (WF-A) Figure 10 FDJ: Subtyping rules. Subtyping rules: .; A .T<:T (S-REFL) A=.(T1, <X.N>F1),(T2, \n<X.N>F2). .; A .X <: . ' (X) . ' =.:X<:N (S-VAR) .; A .T1<:T2 .; A .T3<:T4 . .T1<:T4 (S-TRANS) [ C] ]=X<:N;N \n.; A .fields[T/X]N= .; A .C<T> <:[T/X]N (S-CLASS) ' must be structurally equal to new C<T>(v) (i.e., \nvi=new C<T>(v) ::k v ''). Therefore a relation is established via op\u00aderator ::i between its left and \nright element (i.e., the head of the access path is the ith .eld of the head s successor). If the remaining \naccess path v is not empty, then it must also be well-typed. Notice that the type assigned to an access \npath is identical to the type of its head element.  4.3.2 Disjointness and Containment One of the core \naspects of FDJ is the ability to invoke, over\u00adride, and declare re.ective methods. In order to safely \nin\u00advoke or override a method from another method, the re\u00ad.ective environment of the latter method must \nbe con\u00adtained in the re.ective environment of the former method. (This is a conservative restriction, \nused to make reasoning over containment more manageable.) We use the predicate .;[W/Y]..Rp,oRn ..A.R \n' ,oR ' . (de.ned in Figure 8) to p n denote that .Rp,oRn. is contained in .R ' ,oR ' .. Notice p n that \nboth environments must share the same sign o. W de\u00adnote the pattern variables of the left operand of \n.A that must be substituted for the pattern variables Y of the right operand in order for operand containment \nto hold (i.e., [W/Y] can be seen as the outcome of a uni.cation process). Re.ec\u00adtive environment containment \nis expressed as range contain\u00adment denoted as .;[W/Y].R1.RR2 between the ranges of re.ective environments. \nWhen o is of the form -then the Figure 11 FDJ: Auxiliary de.nitions.  Translation Functions: Mp =n:F1 \nin T.methods Mf =n:F2 in T ' .methods [ ]  <Y.P>for (Mp;oMf) =.(T, <Y.P>F1),o(T ' , <Y.P>F2). [ ] =\u00d8 \nCT (C)=class C<X.N>.N { ... } [ C] = X<:N;N Subtype range validity: for all C<T>,n .;\u00d8.N<:C<T> and .;A.method(n, \nC<T>)=R n:F b implies A=\u00d8 .R= and (R.implies .;[W/Y].A.A[ R] or ..disjoint([[R] , = A)) . .validRange(A, \nN) Concrete classes: \u00acarg implies .; A ..elds(N)= \u00d8 for all R n:F b . CT (N) (b .= . arg) .; A .concrete(N,arg) \nField lookup: .;A.[T/X]S ok N=Interface and S f= or N=C<T> and CT (C)=class C<X.N>.N {S f; ...} .; A \n..elds(N)=[T/X]S f Implement relation: for all T,A,n .; A .N<:T and .; A .mtype(n, T)=F implies .; A \n.mtype(n, N)=F . .implement(N) order of nested ranges is swapped. The two candidate pairs for range containment \n(Rp,R ' ) and (Rn ,R ' ) (or (R ' ,Rn), p nn if swapped) must satisfy the containment condition for the \nsame substitution map [W/Y]. Two ranges R and R ' are con\u00adtained when their method signatures match once \npattern sub\u00adstitution is performed and the statically iterated type of the latter range is a subtype \nof the statically iterated type of the former range. Re.ective methods share the same name 7. Therefore, \nthe type system employs re.ective method disjointness (de\u00ad.ned in Figure 8) to guarantee absence of re.ective \nmethod con.icts in class declarations. Disjointness between two re\u00ad.ective environments is expressed \nin terms of containment: two re.ective environments are disjoint when there exists a pair of ranges from \neach re.ective environment such that ranges have opposite signs and one range is contained in the other \nrange. (This condition is conservative and can be weakened. In the full language, two positive ranges \ncan be disjoint, e.g., by exploiting the fact that two concrete types int and Object are guaranteed distinct, \nhence patterns iter\u00adating over signatures that contain them will never have com\u00admon members. We chose \nnot to model this aspect in FDJ as it is orthogonal to the core reasoning.)  4.3.3 Interface and class \ntyping An important predicate for typing classes and interfaces is concrete (de.ned in Figure 11), taking \ntwo parame\u00adters, a type T and a boolean .ag. When the .ag is set to true the predicate holds when there \nexists no method with empty body in T. When the .ag is false, then T must have the properties of an interface: \nit must only contain meth\u00adods (no .elds) with empty bodies. (Thus, concrete(C<T>, false) is not the negation \nof concrete(C<T>, true).) There\u00adfore, premise concrete in rule T-NEW enforces the invari\u00adant that only \nconcrete classes with full method implemen\u00adtations can be instantiated. concrete is also used in class \nwell-formedness requiring that type upper bounds (includ\u00ading parent classes) be interfaces. Classes must \nimplement all methods of their parent interface. This is enforced by predi\u00adcate implement, de.ned in \nFigure 11. T-CLASS, the rule for typing classes, enforces the fol\u00adlowing invariants: (a) classes can \neither contain re.ective or standard method declarations but not both (b) stan\u00addard method declarations \nhave distinct names (c) re.ective method declarations are disjoint (d) each re.ective declara\u00adtion is \neither disjoint or contained with respect to the re\u00ad.ective declarations of the class supertypes (using \npredi\u00adcate validRange ) (e) each method must be well-typed using rule T-METH, which performs conditional \ntype-checking to the method body b, when it is non-empty and (f) well\u00adformedness of declared types and \nthe typing context (de.ned in Figure 9).  4.3.4 Method Invocation Typing Function invocations are typed \nvia T-INVK, which employs function mtype in order to determine the type signature F of a method n, member \nof some type T. The de.nition of function mtype is provided in Figure 7. Rule MT-VAR is applied for method \nsignature lookup inside type or pattern variables. The lookup algorithm .rst visits the upper bound of \nthe speci.ed type variable and on failure it looks up positive structural constraints entailing the requested \nvariable in the re.ective environment. Rule MT-CLASS is applied when looking up a method signature in \na class type. The lookup algorithm attempts to extract the type signature from the speci.ed class type, \nusing function method and on failure it continues the lookup on the parent class provided that the speci.ed \nclass in an interface. Function method , de.ned in rule M-CLASS, selects a method such that a pattern \nvariable substitution map [W/Y] exists for the method s re.ective environment R. It returns the selected \nmethod having substituted class-local type and pattern variables for variables of the typing context \nas well as the method name. If the class contains standard methods then the substitution environment \nis empty and the requested method name must match the method s name. Otherwise, the class contains re.ective \nmethods (recall that a class cannot contain both standard and re.ective methods) and predicate specialize \nis employed for determining the pattern variable substitution map. The form of rule M-CLASS may at .rst \nseem strange. In order to reach the otherwise clause, one needs to prove that the specialize predicate \ncannot hold. This is easy to establish via syntactic conditions, however, since, for an empty R (i.e., \nfor non-re.ective methods), Ad will be empty, and thus can never match an outcome of a rule that establishes \nspecialize . If the requested method name is variable, i.e., of the form 7, then the re.ective environment \nof R must contain the re\u00ad.ective environment of the typing context (rule SP1). Oth\u00aderwise, rule SP2 applies \nand mtype is employed on the .rst element of the primary range corresponding to R. The type signature \nreturned by mtype must be equal to the method signature speci.ed by the second element of the primary \nrange modulo the substitution map [W/Y]. If the secondary range is positive then mtype must return the \nsame substi\u00adtution map. Otherwise, mtype is either unde.ned or the re\u00adturned substitution map does not \nmatch the map of the pri\u00admary range.  4.4 Soundness In this section, we state the soundness of FDJ as \na result of Subject Reduction and Progress lemmas for an expression e. Theorem 1 (Subject Reduction). \nIf \u00d8;\u00d8;\u00d8. e . T and e \u00ade ', then for some S, \u00d8;\u00d8;\u00d8. e ' . S and \u00d8;\u00d8. S <: T. Proof sketch. By structural \ninduction on the reduction rules. In the case of rules RC-INV-ARG and RC-NEW-ARG, their subterms make \na step and are well-typed by inversion of T-INVK and T-NEW respectively. The induction hypothesis is \nthen applied and the new subterm typing derivations are substituted in the premises of T-INVK and T-NEW, \nrespec\u00adtively. In the case of R-NEW the proof is immediate by us\u00ading \u00d8;\u00d8;\u00d8. new C<T>(v) . C<T> and T-VAL. \nIn R-FIELD we have that vi and new C<T>(v) ::. v are well-typed, by inversion of \u00d8;\u00d8;\u00d8. (new C<T>(v) \n::. v).fi . T. There\u00adfore, new C ' <T ' >(v ' ) ::i (new C<T>(v) ::. v) is well\u00adtyped by T-VAL. The type \nof new C ' <T ' >(v ' ), which is identical to the type of vi, is a subtype of T by T-NEW. In RC-FIELD, \nthe application of the induction hy\u00adpothesis implies the new subterm is well-typed with a subtype S1 \nof the original subterm type T1. T1 has at least one .eld, thus the concrete predicate holds. It suf\u00ad.ces \nto show that if \u00d8;\u00d8..elds(bound \u00d8;\u00d8(T1))=T f, then \u00d8;\u00d8..elds(bound \u00d8;\u00d8(S1))=T f. S1 and T1 can only be \nidentical as a consequence of the well-formedness rela\u00adtion: all supertypes of a type have no .elds. \nIn RC-INV-RECV, the new subterm is well-typed with S1, a well-formed subtype of the original subterm \ntype T1, using the induc\u00adtion hypothesis. It suf.ces to show that if \u00d8;\u00d8.mtype (n, T1)=T ' -T ' ' , then \n\u00d8;\u00d8.mtype (n, S1)=T ' -T ' ' . The well\u00adformedness of S1 implies \u00d8.implement(S1), which com\u00adpletes the \nproof. In the case of R-INVK, the typing deriva\u00adtion of v and mbody (m, v)=(x,e,v '' ) imply that v '' \nis well\u00adtyped with T ' =D<T> and \u00d8;\u00d8.method (m, T ' )=M, where M is the concrete method to be executed. \nT-METH implies the body e of M is well-typed: X<:N;Ad;this.-T ' ,x.-T1.e .T2, where T2 is a subtype of \nM s return type. Us\u00ading the type variable substitution lemma we have that \u00d8;\u00d8;[T/X](this.-T ' ,x.-T1).[T/X][m/7]e \n.[T/X]T2. No\u00ad tice that method variables are also substituted in this step and ' Ad is removed. T-INVK \nimplies v is well-typed for some subtype of [T/X]T1. The proof is completed by applying the variable \nsubstitution lemma. Theorem 2 (Progress). If \u00d8;\u00d8;\u00d8. e . T holds, then e is ei\u00adther a value v or it can \nbe evaluated to another expression ' e . Proof sketch. By structural induction on the typing deriva\u00adtion \nof e. In the case of T-VAL the proof is immediate. T-VAR does not apply as the typing context is empty. \nIn the case of T-NEW, we perform case analysis on the shape of e. If e is of the form new C<T>(v), rule \nR-NEW applies. Otherwise, the induction hypothesis to the .rst non-value argument is applied and the \nproof is complete by rule RC-NEW-ARG. Similar reasoning is applied for T-FIELD us\u00ading R-FIELD and RC-FIELD \nand T-INVK when e is not of the form v.m(v ' ) using RC-INV-RECV and RC-INV-ARG respectively. The last \ncase of T-INVK is when e is of the form v.m(v ' ). We use the value lemma saying that when \u00d8;\u00d8;\u00d8. v . \nT ' and \u00d8;\u00d8.mtype (m, T ' ) then mbody (m, v) is de.ned and rule R-INVK is employed to perform a step. \n * ' Theorem 3 (Type Soundness). If \u00d8; \u00d8; \u00d8.e.T and e--e , ' then e is either a value v or it can be \nevaluated to another ' ' expression e . Proof sketch. Conclusion follows from Theorem 1 and The\u00adorem \n2 5. Related Work The aspects of our language design discussed in Sections 2 and 3 make it unique. Nevertheless, \nthere are several ap\u00adproaches that relate to different facets of our design. Delegation has been proposed \nfor both class-based and object-based languages. Object-based languages (e.g., Javascript) do not support \nclass-based inheritance or sub\u00adtyping and behavior sharing is realized between objects by explicitly \nsetting in runtime their parents. Self [32] is an object-based language that implements forwarding of \nmes\u00adsages. Each object can understand messages that correspond to an object s slot, or, if any slots \nare indicated as parents, forward the message to them. However, this approach suffers from potential \nruntime errors when invocations can produce missing method exceptions, due to the lack of static-typing \nguarantees. Furthermore, there is a fundamental difference between dispatch chaining in dynamic languages \nand our ap\u00adproach. In object-based languages, the dispatch mechanism depends on an object knowing its \nparents, whereas in our case the dispatch chain is different for different references to the same object. \nKniesel [19] proposed the DARWIN model using delega\u00adtion as a complement of forwarding-based object composi\u00adtion. \nIn this model, child objects extend the behavior of par\u00adent objects, by employing both delegation and \nconsultation during message dispatch. The implementation of DARWIN, LAVA, supports dynamic delegation: \ntwo independently de\u00adveloped components can be composed at runtime in a type\u00adand semantically sound manner, \nby restricting the declared parent type to conform to a certain interface. The DARWIN model does not \nprovide full late binding support for meth\u00adods of composed objects. Therefore it is impossible to use \nrede.ned objects that delegate method invocations with their self rebound. Generic Wrappers [4] support \nstatic delegation between wrappers and wrappees via statically declared wraps clauses. Thus, the wrapper-wrappee \nrelationship is .xed, just as in class-based inheritance. Delegation Layers [25] combine delegation and \nvirtual classes to provide polymorphic runtime composition and on\u00adthe-.y extensibility. Extensions have \nonly a local effect thus both the original and the modi.ed behaviors are accessible. The desired behavior \ncan be selected by referring to a col\u00adlaborating object via variables of different static type. In our \napproach, a new access path is created when accessing an object through subobject .elds of wrapper objects. \nThis strategy keeps the semantics simple and gives a clearer view to the programmer of when an object \ns behavior is extended. The Compound Reference (CR) model proposed by [26, 27] introduces a mechanism \nto complement ordinary refer\u00adences using redirection semantics. A CR is in general a path of object references \nin an object tree. Once the path is con\u00adstructed, it is considered immutable as a whole. The CR has a \nstatic type and a temporary type. The static type of the CR is the static type of its tail and the temporary \ntype is updated every time a .eld update takes place. Thus, CRs are incre\u00admentally composed as a sequence \nof regular references to objects that are immutable as a whole, while the access path can change over \ntime due to instance variable changes. Over\u00adriding in a class C is realized through implicit methods \nthat are created over every .eld f. Method calls are dispatched (from C to f), based on these implicit \nmethods. In the CR model, self messages will not be dispatched to wrapper ob\u00adjects; hence the model does \nnot support late binding, in the sense of our work. The implicit methods of the CR model can be encoded \nin DelphJ using static-for patterns. The FeatherWeight Wrap Java work [2], presents a formal semantics \nfor a simple wrapper-based language. The lan\u00adguage focuses on two aspects: wrapping precedence order \nand the binding of self. However, FeatherWeight Wrap Java employs method specialization and not complete \noverrid\u00ading of a wrapper object as in DelphJ. Additionally, a class in [2] cannot wrap more than one \nobject. In our work, the functionality of the delegate after and delegate before special keywords from \nFeatherWeight Wrap Java can be eas\u00adily encoded using static-for patterns. Bettini et al. [1] implement \nan object composition mecha\u00adnism that uses structural subtyping, while maintaining nomi\u00adnal subtyping \n(extends relationship) among types. That work has similarities with our concept of access paths. Bettini \net al. s subobjects are shared and their access paths coun\u00adterparts are extended using a special composition \noperator, which allocates a new object representing the new access path. In our work, when subobject \n.elds are read no allo\u00adcation takes place. In addition, it is possible to re-compose objects, by updating \ntheir .elds. Accidental method overriding can arise from poor de\u00adsign decisions in class hierarchies, \nor more complex sce\u00adnarios that involve mixins. MixedJava [8], McJava [14] and improved variants [15] \ndeal with this problem extensively through context aware con.icting method resolution mean\u00ading that run-time \ncontext information is used, called view, to determine which method should be invoked when an acci\u00addental \noverriding exist. Bettini et al. [1] also propose a similar solution. In DelphJ, we adopt the strategy \ninitially proposed by Kniesel [20]: only non-.nal methods declared in subobject .eld types can be overridden. \n Schippers et al. [29, 30] have developed a delegation\u00adbased machine model for aspect-oriented programming. \nThey present semantic mappings of four high-level programs to their machine model that ensures semantic \nequivalence between source and the delegation-enabled translation. A Proxy object is the basic abstraction \nentity that is responsi\u00adble for receiving messages directed to an object and delegat\u00ading them to the \nactual receiver. Proxy objects are inserted and removed in delegation chains (a concept similar to the \nsubobject access path) by static and dynamic weaving. The dispatch algorithm maintains a list of messages \nalong with their implementations, as well as a constant function Deli, which determines the address of \nthe delegate of an object at some address. (The function is prepared statically and main\u00adtained dynamically.) \nThis function is updated when the store of objects is updated. A Look function which recursively traverses \nthe delegation list, uses the Deli function. 6. Conclusions Inheritance has primary importance in most \nOO languages, yet its value is routinely questioned. Despite the shortcom\u00adings of inheritance, there \nhas not been a replacement pro\u00adposed that addressed them without sacri.ces. We have pre\u00adsented a language \ndesign that aspires to do so. Our design eliminates inheritance without sacri.cing ease of code reuse. \nOur language supports subtyping (via interfaces), morph\u00ading (for controlled automatic forwarding of method \ncalls) and deep delegation (for late binding semantics and re.ne\u00adment of existing code). Through our \nexploration of the com\u00adbination of these features, we showed interesting subtleties in supporting .exible \n(per-.eld) late binding semantics and discussed design choices that address common problems. We believe \nthat our design can inspire OO languages that move beyond inheritance to achieve highly .exible, modular \nprogramming without sacri.cing either power or control. Acknowledgments We gratefully acknowledge funding \nby the Greek Secretariat for Research and Technology under the MorphPL Excel\u00adlence (Aristeia) award; \nand by the European Union under a Marie Curie International Reintegration Grant and a Euro\u00adpean Research \nCouncil Starting/Consolidator grant. References [1] Lorenzo Bettini, Viviana Bono, and Betti Venneri. \nDelegation by object composition. Science of Computer Programming, 76(11):992 1014, November 2011. [2] \nLorenzo Bettini, Sara Capecchi, and Elena Giachino. Feath\u00aderweight wrap java. In Proc. Symp. on Applied \nComputing (SAC), pages 1094 1100, Seoul, Republic of Korea, 2007. [3] Gilad Bracha and William Cook. \nMixin-based inheritance. In Proc. European Conference on Object-Oriented Program\u00adming (ECOOP), volume \n25, pages 303 311, 1990. [4] Martin Buchi\u00a8and Wolfgang Weck. Generic wrappers. In Proc. European Conference \non Object-Oriented Pro\u00adgramming (ECOOP), pages 201 225, Sophia Antipolis and Cannes, France, 2000. [5] \nWilliam R. Cook, Walter Hill, and Peter S. Canning. In\u00adheritance is not subtyping. In Proc. Symp. on \nPrinciples of Programming Languages (POPL), pages 125 135, San Fran\u00adcisco, USA, 1989. [6] Stphane Ducasse, \nOscar Nierstrasz, Nathanael Schrli, Roel Wuyts, and Andrew P. Black. Traits: A mechanism for .ne\u00adgrained \nreuse. ACM Transactions on Programming Lan\u00adguages and Systems, 28(2):331 388, 2006. [7] Torbj \u00a8orn Ekman \nand G\u00a8orel Hedin. The JastAdd extensible Java compiler. In Proc. of Object-Oriented Programming, Systems, \nLanguages, and Applications (OOPSLA), pages 1 18, New York, NY, 2007. [8] Matthew Flatt, Shriram Krishnamurthi, \nand Matthias Felleisen. Classes and mixins. In Proc. Symp. on Principles of Programming Languages (POPL), \npages 171 183, San Diego, USA, 1998. [9] Allen Holub. Why extends is evil: Improve your code by replacing \nconcrete base classes with inter\u00adfaces. http://www.javaworld.com/javaworld/jw-08-2003/jw\u00ad0801-toolbox.html, \nAugust 2003. [10] Shan Shan Huang and Yannis Smaragdakis. Expressive and safe static re.ection with MorphJ. \nIn Proc. Conf. on Pro\u00adgramming Language Design and Implementation (PLDI), vol\u00adume 43, pages 79 89, Tucson, \nAZ, USA, 2008. [11] Shan Shan Huang and Yannis Smaragdakis. Morphing: Struc\u00adturally shaping a class by \nre.ecting on others. ACM Transac\u00adtions on Programming Languages and Systems, 33(2):1 44, February 2011. \n[12] Shan Shan Huang, David Zook, and Yannis Smaragdakis. Morphing: Safely shaping a class in the image \nof others. In Erik Ernst, editor, Proc. European Conference on Object-Oriented Programming (ECOOP), volume \n4609 of LNCS, pages 303 329, July 2007. [13] Atshushi Igarashi, Benjamin Pierce, and Philip Wadler. Feath\u00aderweight \njava: A minimal core calculus for Java and GJ. ACM Transactions on Programming Languages and Systems, \n23(3):396 450, 2001. [14] Tetsuo Kamina and Tetsuo Tamai. McJava a design and implementation of java \nwith mixin-types. In Proc. of Asian Programming Languages and Systems Symp. (APLAS), pages 4 6, Taipei, \nTaiwan, 2004. [15] Tetsuo Kamina and Tetsuo Tamai. Selective method combina\u00adtion in mixin-based composition. \nIn Proc. Symp. on Applied Computing (SAC), pages 1269 1273, Santa Fe, New Mexico, 2005. [16] Majorinc \nKazimir. Ellipse-circle dilemma and inverse inheri\u00adtance. In Proceedings of the 20th International Conference \non Information Technology Interfaces, Pula, Croatia, 1998.  [17] Gregor Kiczales, Erik Hilsdale, Jim \nHugunin, Mik Kersten, Jeffrey Palm, and William G. Griswold. An overview of AspectJ. In Proc. European \nConference on Object-Oriented Programming (ECOOP), pages 327 353, London, UK, 2001. [18] Gregor Kiczales, \nJohn Lamping, Anurag Menhdhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Ir\u00adwin. Aspect-oriented \nprogramming. In Proc. European Con\u00adference on Object-Oriented Programming (ECOOP), volume 1241, pages \n220 242. Springer, Heidelberg, Germany, and New York, 1997. [19] G\u00a8unter Kniesel. Type-safe delegation \nfor run-time component adaptation. In Proc. European Conference on Object-Oriented Programming (ECOOP), \npages 351 366, Lisbon, Portugal, 1999. [20] G \u00a8unter Kniesel. Dynamic object-based inheritance with sub\u00adtyping. \nPhD thesis, Universit \u00a8at Bonn Institut f\u00a8ur Informatik III, 2000. [21] G \u00a8unter Kniesel, Mechthild Rohen, \nand Armin B. Cremers. A management system for distributed knowledge base applica\u00adtions. In Verteilte \nK\u00a8 unstliche Intelligenz und kooperatives Ar\u00ad beiten, 4. Internationaler GI-Kongress Wissensbasierte \nSys\u00ad teme, pages 65 76, 1991. [22] Henry Lieberman. Using prototypical objects to implement shared behavior \nin object-oriented systems. In Proc. of Object-Oriented Programming, Systems, Languages, and Ap\u00adplications \n(OOPSLA), pages 214 223, New York, NY, USA, 1986. [23] Mira Mezini. Dynamic object evolution without \nname col\u00adlisions. In Proc. European Conference on Object-Oriented Programming (ECOOP), pages 190 219, \nJyv\u00a8askyl\u00a8a, Finland, 1997. [24] Leonid Mikhajlov and Emil Sekerinski. A study of the fragile base class \nproblem. In Proc. European Conference on Object-Oriented Programming (ECOOP), pages 355 382, Brussels, \nBelgium, 1998. [25] Klaus Ostermann. Dynamically composable collaborations with delegation layers. In \nProc. European Conference on Object-Oriented Programming (ECOOP), pages 89 110, Nantes, France, 2006. \n[26] Klaus Ostermann and Mira Mezini. Object-oriented composi\u00adtion untangled. In Proc. of Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), pages 283 299, New York, NY, USA, 2001. [27] \nKlaus Ostermann and Mira Mezini. Blurring the borders be\u00adtween object composition, inheritance, and delegation. \nIn Pro\u00adceedings of the Inheritance Workshop at the 16th European Conference on Object-Oriented Programming, \npages 65 68, 2008. [28] Nathanael Scharli, Stephane Ducasse, Oscar Nierstrasz, and Andrew Black. Traits: \nComposable units of behavior. In Proc. European Conference on Object-Oriented Program\u00adming (ECOOP), Darmstadt, \nGermany, 2003. [29] Hans Schippers, Michael Haupt, and Robert Hirschfeld. An implementation substrate \nfor languages composing modular\u00adized crosscutting concerns. In Proc. Symp. on Applied Com\u00adputing (SAC), \nSAC 09, pages 1944 1951, New York, NY, USA, 2009. [30] Hans Schippers, Dirk Janssens, Michael Haupt, \nand Robert Hirschfeld. Delegation-based semantics for modularizing crosscutting concerns. In Proc. of \nObject-Oriented Pro\u00adgramming, Systems, Languages, and Applications (OOPSLA), pages 525 542, New York, \nNY, USA, 2008. [31] Marcelo Sihman and Shmuel Katz. Superimpositions and aspect-oriented programming. \nThe Computer Journal, 46(5):529 541, 2003. [32] David Ungar and Randall B. Smith. Self: The power of \nsimplicity. In Proc. of Object-Oriented Programming, Sys\u00adtems, Languages, and Applications (OOPSLA), \npages 227 242, New York, NY, USA, 1987.   \n\t\t\t", "proc_id": "2509136", "abstract": "<p>We propose DelphJ: a Java-based OO language that eschews inheritance completely, in favor of a combination of class morphing and (deep) delegation. Compared to past delegation approaches, the novel aspect of our design is the ability to emulate the best aspects of inheritance while retaining maximum flexibility: using morphing, a class can select any of the methods of its delegatee and export them (if desired) or transform them (e.g., to add extra arguments or modify type signatures), yet without needing to name these methods explicitly and handle them one-by-one. Compared to past work on morphing, our approach adopts and adapts advanced delegation mechanisms, in order to add late binding capabilities and, thus, provide a full substitute of inheritance. Additionally, we explore complex semantic issues in the interaction of delegation with late binding. We present our language design both informally, with numerous examples, and formally in a core calculus.</p>", "authors": [{"name": "Prodromos Gerakios", "author_profile_id": "81453657331", "affiliation": "University of Athens, Athens, Greece", "person_id": "P4290346", "email_address": "pgerakios@di.uoa.gr", "orcid_id": ""}, {"name": "Aggelos Biboudis", "author_profile_id": "83358848957", "affiliation": "University of Athens, Athens, Greece", "person_id": "P4290347", "email_address": "biboudis@di.uoa.gr", "orcid_id": ""}, {"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "University of Athens, Athens, Greece", "person_id": "P4290348", "email_address": "smaragd@di.uoa.gr", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509535", "year": "2013", "article_id": "2509535", "conference": "OOPSLA", "title": "Forsaking inheritance: supercharged delegation in DelphJ", "url": "http://dl.acm.org/citation.cfm?id=2509535"}