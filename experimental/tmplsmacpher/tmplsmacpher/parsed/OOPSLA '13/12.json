{"article_publication_date": "10-29-2013", "fulltext": "\n Joe Gibbs Politz Providence, RI, USA joe@cs.brown.edu Sumner Warren Providence, RI, USA jswarren@cs.brown.edu \nPython: The Full Monty A Tested Semantics for the Python Programming Language Alejandro Martinez La \nPlata, BA, Argentina amtriathlon@gmail.com Daniel Patterson Providence, RI, USA dbpatter@cs.brown.edu \nMatthew Milano Providence, RI, USA matthew@cs.brown.edu Junsong Li Beijing, China ljs.dark.sh@gmail.com \nAnand Chitipothu Bangalore, India anandology@gmail.com Abstract We present a small-step operational \nsemantics for the Python programming language. We present both a core language for Python, suitable for \ntools and proofs, and a translation process for converting Python source to this core. We have tested \nthe composition of translation and evaluation of the core for conformance with the primary Python implementa\u00adtion, \nthereby giving con.dence in the .delity of the seman\u00adtics. We brie.y report on the engineering of these \ncompo\u00adnents. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern \nthat even impacts features that might be considered orthogonal. Categories and Subject Descriptors J.3 \n[Life and Medical Sciences]: Biology and Genetics Keywords serpents 1. Motivation and Contributions The \nPython programming language is currently widely used in industry, science, and education. Because of \nits popular- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, \nUSA. Copyright &#38;#169; 2013 ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509536 \nShriram Krishnamurthi Providence, RI, USA sk@cs.brown.edu ity it now has several third-party tools, \nincluding analyzers that check for various potential error patterns [2, 5, 11, 13]. It also features \ninteractive development environments [1, 8, 14] that offer a variety of features such as variable-renaming \nrefactorings and code completion. Unfortunately, these tools are unsound: for instance, the simple eight-line \nprogram shown in the appendix uses no dynamic features and con\u00adfuses the variable renaming feature of \nthese environments. The dif.culty of reasoning about Python becomes even more pressing as the language \nis adopted in increasingly im\u00adportant domains. For instance, the US Securities and Ex\u00adchange Commission \nhas proposed using Python as an ex\u00adecutable speci.cation of .nancial contracts [12], and it is now being \nused to script new network paradigms [10]. Thus, it is vital to have a precise semantics available for \nanalyzing programs and proving properties about them. This paper presents a semantics for much of Python \n(sec\u00adtion 5). To make the semantics tractable for tools and proofs, we divide it into two parts: a core \nlanguage, .p, with a small number of constructs, and a desugaring function that trans\u00adlates source programs \ninto the core.1 The core language is a mostly traditional stateful lambda-calculus augmented with features \nto represent the essence of Python (such as method lookup order and primitive lists), and should thus \nbe familiar to its potential users. 1 The term desugaring is evocative but slightly misleading, because \nours is really a compiler to a slightly different language. Nevertheless, it is more suggestive than \na general term like compiler . We blame Arjun Guha for the confusing terminology.   Figure 2: Let-binding \nidenti.ers, and looking up references Figure 3: .p reduction rules for creating objects operation looks \nlike, take constructing a list. This takes the values that should populate the list, store them in the \nheap, and return a pointer to the newly-created reference:  E-List is a good example for understanding \nthe shape of evaluation in .p. The general form of the reduction relation is over expressions , global \nenvironments , and heaps  In the E-List rule, we also use evaluation contexts to en\u00adforce an order \nof operations and eager calling semantics. This is a standard application of Felleisen-Hieb-style small\u00adstep \nsemantics [4]. Saliently, a new list value is populated from the list expression via the metafunction, \nthis is allocated in the store, and the resulting value of the expres\u00adsion is a pointer to that new \nlist. Similar rules for objects in general, tuples, and sets are shown in .gure 3. Lists, tuples, and \nsets are given their own expression forms because they need to evaluate their subexpressions and have \ncorresponding evaluation contexts. Figure 5: .p reduction rules for references 2.2 Accessing Built-in \nValues Now that we ve created a list, we should be able to perform some operations on it, like look up \nits elements. .p de.nes a number of builtin primitives that model Python s internal operators for manipulating \ndata, and these are used to access the contents of a given object s . We formalize these builtin primitives \nin a metafunction d. A few selected cases of the d function are shown in .gure 4. This metafunction lets \nus, for example, look up values on builtin lists: Since d works over object values themselves, and not \nover references, we need a way to access the values in the store. .p has the usual set of operators for \naccessing and updating mutable references, shown in .gure 5. Thus, the real .p program corresponding \nto the one above would be:  Similarly, we can use and  to update the values in lists, and to allocate \nthe return values of primitive operations.  Figure 4: A sample of .p primitives We desugar to patterns \nlike the above from Python s actual surface operators for accessing the elements of a list in expressions \nlike mylist[2]. 2.3 Updating and Accessing Fields So far, the dictionary part of .p objects have always \nbeen empty. Python does, however, support arbitrary .eld assign\u00adments on objects. The expression  has \none of two behaviors, de.ned in .gure 6. Both behaviors work over references to objects, not over objects \nthemselves, in contrast to . If is a string object that is already a member of , that .eld is imperatively \nupdated with If the string is not present, then a new .eld is added to the object, with a newly-allocated \nstore position, and the object s location in the heap is updated.  The simplest rule for accessing .elds \nsimply checks in the object s dictionary for the provided name and returns the ap\u00adpropriate value, shown \nin E-GetField in .gure 6. E-GetField also works over reference values, rather than objects directly. \n 2.4 First-class Functions Functions in Python are objects like any other. They are de.ned with the keyword \ndef, which produces a callable object with a mutable set of .elds, whose class is the built-in class. \nFor example a programmer is free to write: def f(): return f.x f.x = -1 f() # ==> -1  We model functions \nas just another kind of object value, with a type of that looks like the usual functional .: The  \nindicates whether the function is variable\u00adarity: if is of the form , then if the function is called \nwith more arguments than are in its list of variables , they are allocated in a new tuple and bound \nto in the body. Since these rules are relatively unexciting and verbose, we defer their explanation to \nthe appendix.  2.5 Loops, Exceptions, and Modules We defer a full explanation of the terms in .gure \n1, and the entire reduction relation, to the appendix. This includes a mostly-routine encoding of control \noperators via special evaluation contexts, and a mechanism for loading new code via modules. We continue \nhere by focusing on cases in .p that are unique in Python. 3. Classes, Methods, and Desugaring Python \nhas a large system with .rst-class methods, implicit receiver binding, multiple inheritance, and more. \nIn this sec\u00adtion we discuss what parts of the class system we put in .p, and which parts we choose to \neliminate by desugaring. 3.1 Field Lookup in Classes In the last section, we touched on .eld lookup in \nan object s local dictionary, and didn t discuss the purpose of the class position at all. When an object \nlookup doesn t .nd  in the local dictionary , it defers to a lookup algorithm on the class value . \nMore speci.cally, it uses the (short for method resolution order) .eld of the class to determine which \nclass dictionaries to search for the .eld. This .eld is visible to the Python programmer: class C(object): \npass # a class that does nothing print(C.__mro__) # (<class C >, <class object >) Field lookups on objects \nwhose class value is  will .rst look in the dictionary of , and then in the dictionary of the built-in \nclass . We de.ne this lookup algorithm within .p as , shown in .gure 7 along with the reduction rule \nfor .eld access that uses it. This rule allows us to model .eld lookups that defer to a superclass (or \nindeed, a list of them). But programmers don t explicitly de.ne .elds; rather, they use higher\u00adlevel \nlanguage constructs to build up the inheritance hier\u00adarchy the instances eventually use. 3.2 Desugaring \nClasses Most Python programmers use the special class form to create classes in Python. However, class \nis merely syntac\u00ad  Figure 6: Simple .eld access and update in .p Figure 7: Class lookup tic sugar for \na use of the builtin Python function type. 3 The documentation states explicitly that the two following \nforms [sic] produce identical type objects: class X: a = 1 X = type( X , (object,), dict(a=1)) This \nmeans that to implement classes, we merely need to understand the built-in function type, and how it \ncreates 3 http://docs.python.org/3/library/functions.html#type new classes on the .y. Then it is a simple \nmatter to desugar class forms to this function call. The implementation of type creates a new object \nvalue for the class, allocates it, sets the .eld to be the computed inheritance graph,4 and sets the \n.elds of the class to be the bindings in the dictionary. We elide some of the verbose detail in the iteration \nover by using the  syn\u00adtactic abbreviation, which expands into the desired iteration: 4 This uses an \nalgorithm that is implementable in pure Python: http://www.python.org/download/releases/2.3/mro/.  This \nfunction, along with the built-in type class, suf.ces for bootstrapping the object system in .p. 3.3 \nPython Desugaring Patterns Python objects can have a number of so-called magic .elds that allow for overriding \nthe behavior of built-in syntactic forms. These magic .elds can be set anywhere in an object s inheritance \nhierarchy, and provide a lot of the .exibility for which Python is well-known. For example, the .eld \naccesses that Python programmers write are not directly translated to the rules in .p. Even the execution \nof o.x depends heavily on its inheritance hierarchy. This program desugars to: For objects that don t \noverride the .eld, the built-in object class s implementation does more than simply look up the property \nusing the .eld access rules we presented earlier. Python allows for attributes to imple\u00adment special \naccessing functionality via properties, 5 which can cause special functions to be called on property \naccess. The function of checks if the value of the .eld it accesses has a special method, and if it does, \ncalls it:  This pattern is used to implement a myriad of features. For example, when accessing function \nvalues on classes, the method of the function binds the self argument: class C(object): def f(self): \nreturn self c = C() # constructs a new C instance g = c.f # accessing c.f creates a # method object \nclosed over c g() is c # ==> True # We can also bind self manually: self_is_5 = C.f.__get__(5) self_is_5() \n# ==> 5  5 http://docs.python.org/3/library/functions.html#property Thus, very few object-based primitives \nare needed to create static class methods and instance methods. Python has a number of other special \nmethod names that can be overridden to provide specialized behavior. .p tracks Python this regard; it \ndesugars surface expressions into calls to methods with particular names, and provides built-in im\u00adplementations \nof those methods for arithmetic, dictionary access, and a number of other operations. Some examples: \no[p] desugars to... n + m desugars to... fun(a) desugars to...  With the basics of type and object \nlookup in place, getting these operations right is just a matter of desugaring to the right method calls, \nand providing the right built-in versions for primitive values. This is the form of much of our desugaring, \nand though it is labor-intensive, it is also the straightforward part of the process. 4. Python: the \nHard Parts Not all of Python has a semantics as straightforward as that presented so far. Python has \na unique notion of scope, with new scope operators added in Python 3 to provide some features of more \ntraditional static scoping. It also has powerful control .ow constructs, notably generators. 4.1 Generators \nPython has a built-in notion of generators, which provide a control-.ow construct, yield, that can implement \nlazy or generative sequences and coroutines. The programmer in\u00adterface for creating a generator in Python \nis straightforward: any function de.nition that uses the yield keyword in its body is automatically converted \ninto an object with a gener\u00adator interface. To illustrate the easy transition from function to generator, \nconsider this simple program: def f(): x = 0 while True: x += 1 return x f() # ==> 1 f() # ==> 1 # ... \n When called, this function always returns 1. Changing return to yield turns this into a generator. As \na result, applying f() no longer immediately evaluates the body; instead, it creates an object whose \nnext method evaluates the body until the next yield statement, stores its state for later resumption, \nand returns the yielded value: def f(): x = 0 while True: x += 1 yield x gen = f() gen.__next__() # \n==> 1 gen.__next__() # ==> 2 gen.__next__() # ==> 3 # ... Contrast this with the following program, \nwhich seems to perform a simple abstraction over the process of yielding: def f(): def do_yield(n): yield \nn x = 0 while True: x += 1 do_yield(x) Invoking f() results in an in.nite loop. That is because Python \nstrictly converts only the innermost function with a yield into a generator, so only do_yield is a generator. \nThus, the generator stores only the execution context of do_yield, not of f. Failing to Desugar Generators \nwith (Local) CPS The experienced linguist will immediately see what is going on. Clearly, Python has \nmade a design decision to store only local continuations. This design can be justi.ed on the grounds \nthat converting a whole program to continuation\u00adpassing style (CPS) can be onerous, is not modular, can \nimpact performance, and depends on the presence of tail\u00adcalls (which Python does not have). In contrast, \nit is natural to envision a translation strategy that performs only a local conversion to CPS (or, equivalently, \nstores the local stack frames) while still presenting a continuation-free interface to the rest of the \nprogram. From the perspective of our semantics, this is a potential boon: we don t need to use a CPS-style \nsemantics for the whole language! Furthermore, perhaps generators can be handled by a strictly local \nrewriting process. That is, in the core language generators can be rei.ed into .rst-class functions and \napplications that use a little state to record which function is the continuation of the yield point. \nThus, generators seem to .t perfectly with our desugaring strategy. To convert programs to CPS, we take \noperators that can cause control-.ow and reify each into a continuation func\u00adtion and appropriate application. \nThese operators include simple sequences, loops combined with break and con\u00adtinue, try-except and try-finally \ncombined with raise, and return. Our CPS transformation turns every expression into a function that accepts \nan argument for each of the above control operators, and turns uses of control op\u00aderators into applications \nof the appropriate continuation in\u00adside the function. By passing in different continuation argu\u00adments, \nthe caller of the resulting function has complete con\u00adtrol over the behavior of control operators. For \nexample, we might rewrite a try-except block from try: raise Exception() except e: print(e)  to def \nexcept_handler(e): print(e) except_handler(Exception())  In the case of generators, rewriting yield \nwith CPS would involve creating a handler that stores a function hold\u00ading the code for what to do next, \nand rewriting yield ex\u00adpressions to call that handler: def f(): x = 1 yield x x += 1 yield x g = f() \ng.__next__() # ==> 1 g.__next__() # ==> 2 g.__next__() # throws \"StopIteration\"  would be rewritten \nto something like:6 def f(): def yielder(val, rest_of_function): next.to_call_next = rest_of_function \nreturn val def next(): return next.to_call_next() def done(): raise StopIteration() def start(): x = \n1 def rest(): x += 1 return yielder(x, done) return yielder(x, rest) next.to_call_next = start return \n{ next : next } 6 This being a sketch, we have taken some liberties for simplicity. g = f() g[ next \n]() # ==> 1 g[ next ]() # ==> 2 g[ next ]() # throws \"StopIteration\" We build the yielder function, \nwhich takes a value, which it returns after storing a continuation argument in the to_call_next .eld. \nThe next function always returns the result of calling this stored value. Each yield statement is rewritten \nto put everything after it into a new function def\u00adinition, which is passed to the call to yielder. In \nother words, this is the canonical CPS transformation, applied in the usual fashion. This rewriting is \nwell-intentioned but does not work. If this program is run under Python, it results in an error: x += \n1 UnboundLocalError: local variable x This is because Python creates a new scope for each func\u00adtion \nde.nition, and assignments within that scope create new variables. In the body of rest, the assignment \nx += 1 refers to a new x, not the one de.ned by x = 1 in start. This runs counter to traditional notions \nof functions that can close over mutable variables. And in general, with multiple assignment statements \nand branching control .ow, it is en\u00adtirely unclear whether a CPS transformation to Python func\u00adtion de.nitions \ncan work. The lesson from this example is that the interaction of non-traditional scope and control .ow \nmade a traditional translation not work. The straightforward CPS solution is thus incorrect in the presence \nof Python s mechanics of variable binding. We now move on to describing how we can express Python s scope \nin a more traditional lexical model. Then, in section 4.3 we will demonstrate a working transformation \nfor Python s generators. 4.2 Scope Python has a rich notion of scope, with several types of variables \nand implicit binding semantics that depend on the block structure of the program. Most identi.ers are \nlocal; this includes function parameters and variables de.ned with the = operator. There are also global \nand nonlocal vari\u00adables, with their own special semantics within closures, and interaction with classes. \nOur core contribution to explaining Python s scope is to give a desugaring of the nonlocal and global \nkeywords, along with implicit local, global and instance identi.ers, into traditional lexically scoped \nclosures. Global scope is still handled specially, since it ex\u00adhibits a form of dynamic scope that isn \nt straightforward to capture with traditional let-bindings.7 7 We actually exploit this dynamic scope \nin bootstrapping Python s object system, but defer an explanation to the appendix. We proceed by describing \nPython s handling of scope for local variables, the extension to nonlocal, and the interaction of both \nof these features with classes. 4.2.1 Declaring and Updating Local Variables In Python, the operator \n= performs local variable binding: def f(): x = local variable return x f() # ==> local variable The \nsyntax for updating and creating a local variable are identical, so subsequent = statements mutate the \nvariable created by the .rst. def f(): x = local variable x = reassigned x = reassigned again return \nx f() # ==> reassigned again Crucially, there is no syntactic difference between a state\u00adment that \nupdates a variable and one that initially binds it. Because bindings can also be introduced inside branches \nof conditionals, it isn t statically determinable if a variable will be de.ned at certain program points. \nNote also that vari\u00adable declarations are not scoped to all blocks here they are scoped to function de.nitions: \ndef f(y): if y > .5: x = big else : pass return x f(0) # throws an exception f(1) # ==> \"big\" Handling \nsimple declarations of variables and updates to variables is straightforward to translate into a lexically\u00adscoped \nlanguage. .p has a usual let form that allows for lexical binding. In desugaring, we scan the body of \nthe function and accumulate all the variables on the left-hand side of assignment statements in the body. \nThese are let\u00adbound at the top of the function to the special form, which evaluates to an exception \nin any context other than a let\u00adbinding context (section 2). We use x := e as the form for variable assignment, \nwhich is not a binding form in the core. Thus, in .p, the example above rewrites to: In the .rst application \n(to 0) the assignment will never hap\u00adpen, and the attempt to look up the -valued   in the return statement \nwill fail with an exception. In the second applica\u00adtion, the assignment in the then-branch will change \nthe value of in the store to a non- string value, and the string  will be returned. The algorithm for \ndesugaring scope is so far: For each function body:  Collect all variables on the left-hand side of \n in a set locals, stopping at other function boundaries,  For each variable  in locals, wrap the \nfunction body in a -binding of  to . This strategy works for simple assignments that may or may not \noccur within a function, and maintains lexical structure for the possibly-bound variables in a given \nscope. Unfortu\u00adnately, this covers only the simplest cases of Python s scope. 4.2.2 Closing Over Variables \nBindings from outer scopes can be seen by inner scopes: def f(): x = closed-over def g(): return x return \ng f()() # ==> closed-over However, since = de.nes a new local variable, one cannot close over a variable \nand mutate it with what we ve seen so far; = simply de.nes a new variable with the same name: def g(): \nx = not affected def h(): x = inner x return x return (h(), x) g() # ==> ( inner x , not affected ) \n This is mirrored in our desugaring: each function adds a new let-binding inside its own body, shadowing \nany bindings from outside. This was the underlying problem with the attempted CPS translation from the \nlast section, highlighting the consequences of using the same syntactic form for both variable binding \nand update. Closing over a mutable variable is, however, a common and useful pattern. Perhaps recognizing \nthis, Python added a new keyword in Python 3.0 to allow this pattern, called nonlocal. A function de.nition \ncan include a nonlocal declaration at the top, which allows mutations within the function s body to refer \nto variables in enclosing scopes on a per-variable basis. If we add such a declaration to the previous \nexample, we get a different answer: def g(): x = not affected by h def h(): nonlocal x x = inner x return \nx return (h(), x) g() # ==> ( inner x , inner x ) The nonlocal declaration allows the inner assignment \nto x to see the outer binding from g. This effect can span any nesting depth of functions: def g(): x \n= not affected by h def h(): def h2(): nonlocal x x = inner x return x return h2 return (h()(), x) g() \n# ==> ( inner x , inner x ) Thus, the presence or absence of a nonlocal declara\u00adtion can change an assignment \nstatement from a binding oc\u00adcurrence of a variable to an assigning occurrence. We aug\u00adment our algorithm \nfor desugaring scope to re.ect this: For each function body:  Collect all variables on the left-hand \nside of  in a set locals, stopping at other function boundaries,  Let locals be locals with any variables \nin nonlocal declarations removed,  For each variable  in locals , wrap the function body in a -binding \nof  to . Thus the above program would desugar to the following, which does not let-bind inside the \nbody of the function assigned to . def f(x, y): print(x); print(y); print(\"\") class c: x = 4 print(x); \nprint(y) print(\"\") def g(self): print(x); print(y); print(c) return c f(\"x-value\", \"y-value\")().g() \n# produces this result: x-value y-value 4 y-value x-value y-value <class __main__.c > Figure 8: An example \nof class and function scope interacting  The assignment to inside the body of  behaves as a typical \nassignment statement in a closure-based language like Scheme, mutating the let-bound de.ned in .  4.2.3 \nClasses and Scope We ve covered some subtleties of scope for local and nonlo\u00adcal variables and their \ninteraction with closures. What we ve presented so far would be enough to recover lexical scope for a \nCPS transformation for generators if function bodies contained only other functions. However, it turns \nout that we observe a different closure behavior for variables in a class de.nition than we do for variables \nelsewhere in Python, and we must address classes to wrap up the story on scope. Consider the example \nin .gure 8. Here we observe an interesting phenomenon: in the body of g, the value of the Figure 9: Interactions \nbetween class bodies and function scope variable x is not 4, the value of the most recent apparent assignment \nto x. In fact, the body of g seems to \"skip\" the scope in which x is bound to 4, instead closing over \nthe outer scope in which x is bound to \"x-value\". At .rst glance this does not appear to be compatible \nwith our previous notions of Python s closures. We will see, however, that the correct desugaring is \ncapable of expressing the semantics of scope in classes within the framework we have already established \nfor dealing with Python s scope. Desugaring classes is substantially more complicated than handling simple \nlocal and nonlocal cases. Consider the example from .gure 8, stripped of print statements: def f(x, y): \nclass c: x = 4 def g(self): pass return c f(\"x-value\", \"y-value\")().g() In this example, we have three \nlocal scopes: the body of the function f, the body of the class de.nition c, and the body of the function \ng. The scopes of c and g close over the same scope as f, but have distinct, non-nesting scopes themselves. \nFigure 9 shows the relationship graphically. Algorithmically, we add new steps to scope desugaring: For \neach function body: For each nested class body: - Collect all the function de.nitions within the class \nbody. Let the set of their names be and the set of the expressions be , - Generate a fresh variable for \neach vari\u00adable in . Add assignment statements to the function body just before the class de.nition as\u00ad \n signing each to the corresponding ex\u00adpression in , - Change each function de.nition in the body of \nthe class to Collect all variables on the left-hand side of in a set locals, stopping at other function \nboundaries,  Let locals be locals with any variables in nonlocal declarations removed,  For each \nvariable  in locals , wrap the function body in a -binding of  to . Recalling that the instance variables \nof a class desugar roughly to assignments to the class object itself, the function desugars to the following: \n This achieves our desired semantics: the bodies of func\u00adtions de.ned in the class C will close over \nthe x and y from the function de.nition, and the statements written in c-scope can still see those bindings. \nWe note that scope desugaring yields terms in an intermediate language with a key\u00adword. In a later desugaring \nstep, we remove the class key\u00adword as we describe in section 3.2. 4.2.4 Instance Variables When we introduced \nclasses we saw that there is no apparent difference between classes that introduce identi.ers in their \nbody and classes that introduce identi.ers by .eld assign\u00adment. That is, either of the following forms \nwill produce the same class C: class C: x = 3 # or ... class C: pass C.x = 3 We do, however, have to \nstill account for uses of the in\u00adstance variables inside the class body, which are referred to with the \nvariable name, not with a .eld lookup like c.x. We perform a .nal desugaring step for instance variables, \nwhere we let-bind them in a new scope just for evaluating the class body, and desugar each instance variable \nassign\u00adment into both a class assignment and an assignment to the variable itself. The full desugaring \nof the example is shown in .gure 10.  We have now covered Python classes scope seman\u00adtics: function \nbodies do not close over the class body s scope, class bodies create their own local scope, state\u00adments \nin class bodies are executed sequentially, and de.\u00adnitions/assignments in class bodies result in the \ncreation of class members. The nonlocal keyword does not require further special treatment, even when \npresent in class bodies.  4.3 Generators Redux With the transformation to a lexical core in hand, we \ncan return to our discussion of generators, and their implemen\u00adtation with a local CPS transformation. \nTo implement generators, we .rst desugar Python down to a version of .p with an explicit yield statement, \npassing yields through unchanged. As the .nal stage of desugar\u00ading, we identify functions that contain \nyield, and convert them to generators via local CPS. We show the desugaring machinery around the CPS \ntransformation in .gure 11. To desugar them, in the body of the function we construct a generator object \nand store the CPS-ed body as a ___re\u00adsume attribute on the object. The __next__ method on the generator, \nwhen called, will call the ___resume clo\u00adsure with any arguments that are passed in. To handle yield\u00ading, \nwe desugar the core yield expression to update the ___resume attribute to store the current normal continua\u00adtion, \nand then return the value that was yielded. Matching Python s operators for control .ow, we have .ve \ncontinuations, one for the normal completion of a state\u00adment or expression going onto the next, one for \na return statement, one each for break and continue, and one for the exception throwing raise. This means \nthat each CPSed expression becomes an anonymous function of .ve arguments, and can be passed in the appropriate \nbehavior for each control operator. We use this con.gurability to handle two special cases: Throwing \nan exception while running the generator  Running the generator to completion   def f(x ...): body-with-yield \ndesugars to... where... class generator(object): def __init__(self, init): init(self) def __next__(self): \nreturn self.___resume(None) def send(self, arg): return self.___resume(arg) def __iter__(self): return \nself def __list__(self): return [x for x in self] Figure 11: The desugaring of generators In the latter \ncase, the generator raises a StopItera\u00adtion exception. We encode this by setting the initial nor\u00admal \ncontinuation to a function that will update ___re\u00adsume to always raise StopIteration, and then to raise \nthat exception. Thus, if we evaluate the entire body of the generator, we will pass the result to this \ncontinuation, and the proper behavior will occur. Similarly, if an uncaught exception occurs in a generator, \nthe generator will raise that exception, and any subsequent calls to the generator will result in StopIteration. \nWe handle this by setting the initial raise continuation to be code that updates ___resume to always \nraise StopIt\u00aderation, and then we raise the exception that was passed to the continuation. Since each \ntry block in CPS installs a new exception continuation, if a value is passed to the top\u00adlevel exception \nhandler it means that the exception was not caught, and again the expected behavior will occur. 5. Engineering \n&#38; Evaluation Our goal is to have desugaring and .p enjoy two properties: Desugaring translates all \nPython source programs to .p (totality).  Desugared programs evaluate to the same value as the source \nwould in Python (conformance).  The second property, in particular, cannot be proven because there \nis no formal speci.cation for what Python does. We therefore tackle both properties through testing. \nWe discuss various aspects of implementing and testing below. 5.1 Desugaring Phases Though we have largely \npresented desugaring as an atomic activity, the paper has hinted that it proceeds in phases. Indeed, \nthere are four: Lift de.nitions out of classes (section 4.2.3).  Let-bind variables (section 4.2.2). \nThis is done sec\u00adond to correctly handle occurrences of nonlocal and global in class methods. The result \nof these .rst two steps is an intermediate language between Python and the core with lexical scope, but \nstill many surface constructs.  Desugar classes, turn Python operators into method calls, turn for loops \ninto guarded  loops, etc.  Desugar generators (section 4.3).  These four steps yield a term in our \ncore, but it isn t ready to run yet because we desugar to open terms. For instance, print(5) desugars \nto  which relies on free variables and .  5.2 Python Libraries in Python We implement as many libraries \nas possible in Python8 aug\u00admented with some macros recognized by desugaring. For ex\u00adample, the builtin \ntuple class is implemented in Python, but getting the length of a tuple defers to the d function: class \ntuple(object): def __len__(self): return ___delta(\"tuple-len\", self) ... All occurrences of ___delta(str, \ne, ...) are desug\u00adared to directly. We only do this for library .les, so normal Python programs can \nuse ___delta as the valid identi.er it is. As another example, after the class de.nition of tuples, we \nhave the statement ___assign(\"%tuple\", tuple) which desugars to an assignment statement . Since %-pre.xed \nvariables aren t valid in Python, this gives us an private namespace of global variables that are un-tamperable \nby Python. Thanks to these decisions, this project produces far more readable desugaring output than \na previous effort for JavaScript [6]. 5.3 Performance .p may be intended as a formal semantics, but \ncomposed with desugaring, it also yields an implementation. While the performance does not matter for \nsemantic reasons (other than programs that depend on time or space, which would be ill-suited by this \nsemantics anyway), it does greatly affect how quickly we can iterate through testing! The full process \nfor running a Python program in our semantics is: 1. Parse and desugar roughly 1 KLOC of libraries imple\u00admented \nin Python 2. Parse and desugar the target program 3. Build a syntax tree of several built-in libraries, \ncoded by building the AST directly in Racket 4. Compose items 1-3 into a single .p expression 5. Evaluate \nthe .p expression  Parsing and desugaring for (1) takes a nontrivial amount of time (40 seconds on \nthe .rst author s laptop). Because this work is needlessly repeated for each test, we began caching the \nresults of the desugared library .les, which reduced the testing time into the realm of feasibility for \nrapid develop\u00adment. When we .rst performed this optimization, it made running 100 tests drop from roughly \n7 minutes to 22 sec\u00adonds. Subsequently, we moved more functionality out of .p 8 We could not initially \nuse existing implementations of these in Python for bootstrapping reasons: they required more of the \nlanguage than we supported. Feature # of tests LOC Built-in Datatypes 81 902 Scope 39 455 Exceptions \n25 247 (Multiple) Inheritance 16 303 Properties 9 184 Iteration 13 214 Generators 9 129 Modules 6 58 \nTotal 205 2636 Figure 12: Distribution of passing tests  and into verbose but straightforward desugaring, \ncausing se\u00adrious performance hit; running 100 tests now takes on the order of 20 minutes, even with the \noptimization. 5.4 Testing Python comes with an extensive test suite. Unfortunately, this suite depends \non numerous advanced features, and as such was useless as we were building up the semantics. We therefore \nwent through the test suite .les included with CPython, April 2012,9 and ported a representative suite \nof 205 tests (2600 LOC). In our selection of tests, we focused on orthogonality and subtle corner-cases. \nThe distribution of those tests across features is reported in .gure 12. On all these tests we obtain \nthe same results as CPython. It would be more convincing to eventually handle all of Python s own unittest \ninfrastructure to run CPython s test suite unchanged. The unittest framework of CPython unfortunately \nrelies on a number of re.ective features on modules, and on native libraries, that we don t yet cover. \nFor now, we manually move the assertions to simpler if-based tests, which also run under CPython, to \ncheck conformance. 5.5 Correspondence with Redex We run our tests against .p., not against the Redex-de.ned \nreduction relation for .p. We can run tests on .p, but per\u00adformance is excruciatingly slow: it takes \nover an hour to run complete individual tests under the Redex reduction relation. Therefore, we have \nbeen able to perform only limited test\u00ading for conformance by hand-writing portions of the envi\u00adronment \nand heap (as Redex terms) that the Python code in the test uses. Fortunately, executing against Redex \nshould be parallelizable, so we hope to increase con.dence in the Re\u00addex model as well. 9 http://www.python.org/getit/releases/3.2.3/ \n 6. Future Work and Perspective As section 5 points out, there are some more parts of Python we must \nre.ect in the semantics before we can run Python s test cases in their native form. This is because Python \nis a large language with extensive libraries, a foreign-function interface, and more. Libraries aside, \nthere are some interesting features in Python left to tackle. These include special .elds, such as the \nproperties of function objects that compute the content of closures, complex cases of destructuring assignments, \na few re.ective features like the metaclass form, and others. More interestingly, we are not done with \nscope! Consider locals, which returns a dictionary of the current variable bindings in a given scope: \ndef f(x): y = 3 return locals() f(\"val\") # ==> { x : val , y : 3} This use of locals can be desugared \nto a clever combi\u00adnation of assignments into a dictionary along with variable assignments, which we do. \nHowever, this desugaring of lo\u00adcals relies on it being a strictly local operation (for lack of a better \nword). But worse, locals is a value! def f(x, g): y = 3 return g() f(\"x-val\", locals) # ==> { x : x-val \n, y : 3, # g : <builtin function locals>} Thus, any application could invoke locals. We would therefore \nneed to deploy our complex desugaring every\u00adwhere we cannot statically determine that a function is not \nlocals, and change every application to check for it. Other built-in values like super and dir exhibit \nsimilar behavior. On top of this, import can splice all identi.ers (*) from a module into local scope. \nFor now, we handle only imports that bind the module object to a single identi.er. Indeed, even Python \n3 advises that import * should only be used at module scope. Finally, we do not handle exec, Python s \neval (though the code-loading we do for modules comes close). Related efforts on handling similar operators \nin JavaScript [6] are sure to be helpful here. We note that most traditional analyses would be seriously \nchallenged by programs that use functions like locals in a higher-order way, and would probably bene.t \nfrom checking that it isn t used in the .rst place. We don t see the lack of full support for such functions \nas a serious weakness of .p, or an impediment to reasoning about most Python programs. Rather, it s an \ninteresting future challenge to handle a few of these remaining esoteric features. It s also useful to \nsimply call out the weirdness of these operators, which are liable to violate the soundness of otherwise-sound \nprogram tools. Overall, what we have learned most from this effort is how central scope is to understanding \nPython. Many of its features are orthogonal, but they all run afoul on the shoals of scope. Whether this \nis intentional or an accident of the con\u00adtorted history of Python s scope is unclear (for example, see \nthe discussion around the proposal to add nonlocal [15]), but also irrelevant. Those attempting to improve \nPython or create robust sub-languages of it whether for teaching or for specifying asset-backed securities \nwould do well to put their emphasis on scope .rst, because this is the feature most likely to preclude \nsound analyses, correctness-preserving refactorings, and so on. 7. Related Work We are aware of only \none other formalization for Python: Smeding s unpublished and sadly unheralded master s the\u00adsis [9]. \nSmeding builds an executable semantics and tests it against 134 hand-written tests. The semantics is \nfor Python 2.5, a language version without the complex scope we han\u00addle. Also, instead of de.ning a core, \nit directly evaluates (a subset of) Python terms. Therefore, it offers a weaker ac\u00adcount of the language \nand is also likely to be less useful for certain kinds of tools and for foundational work. There are \na few projects that analyze Python code. They are either silent about the semantics or explicitly eschew \nde.ning one. We therefore do not consider these related. Our work follows the path laid out by .JS [7] \nand its follow-up [6], both for variants of JavaScript. Acknowledgments We thank the US NSF and Google \nfor their support. We thank Caitlin Santone for lending her graphical expertise to .gure 9. The paper \ntitle is entirely due to Benjamin Lerner. We are grateful to the Artifact Evaluation Committee for their \nexcellent and detailed feedback, especially the one re\u00adviewer who found a bug in iteration with generators. \nThis paper was the result of an international collaboration resulting from an on-line course taught by \nthe .rst and last authors. Several other students in the class also contributed to the project, including \nRamakrishnan Muthukrishnan, Bo Wang, Chun-Che Wang, Hung-I Chuang, Kelvin Jackson, Victor Andrade, and \nJesse Millikan. Bibliography [1] Appcelerator. PyDev. 2013. http://pydev.org/ [2] Johann C. Rocholl. \nPEP 8 1.4.5. 2013. https:// pypi.python.org/pypi/pep8 [3] Matthias Felleisen, Robert Bruce Findler, \nand Matthew Flatt. Semantics Engineering with PLT Redex. 2009.  [4] Matthias Felleisen and Robert Hieb. \nThe Revised Re\u00adport on the Syntactic Theories of Sequential Control and State. Theoretical Computer Science \n103(2), 1992. [5] Phil Frost. Py.akes 0.6.1. 2013. https://pypi. python.org/pypi/pyflakes [6] Joe Gibbs \nPolitz, Matthew J. Carroll, Benjamin S. Lerner, Justin Pombrio, and Shriram Krishnamurthi. A Tested Semantics \nfor Getters, Setters, and Eval in JavaScript. In Proc. Dynamic Languages Symposium, 2012. [7] Arjun Guha, \nClaudiu Saftoiu, and Shriram Krishna\u00admurthi. The Essence of JavaScript. In Proc. European Conference \non Object-Oriented Programming, 2010. [8] JetBrains. PyCharm. 2013. http://www. jetbrains.com/pycharm/ \n [9] Gideon Joachim Smeding. An executable operational semantics for Python. Universiteit Utrecht, 2009. \n [10] James McCauley. About POX. 2013. http://www. noxrepo.org/pox/about-pox/ [11] Neal Norwitz. PyChecker \n0.8.12. 2013. https:// pypi.python.org/pypi/PyChecker [12] Securities and Exchange Commission. Release \nNos. 33-9117; 34-61858; File No. S7-08-10. 2010. https://www.sec.gov/rules/proposed/ 2010/33-9117.pdf \n [13] Sylvain Thenault. PyLint 0.27.0. 2013. https:// pypi.python.org/pypi/pylint [14] Wingware. Wingware \nPython IDE. 2013. http:// wingware.com/ [15] Ka-Ping Yee. Access to Names in Outer Spaces. 2009. http://www.python.org/dev/peps/ \npep-3104/ Appendix: Confusing Rename Refactorings This program: def f(x): class C(object): x = \"C s \nx\" def meth(self): return x + , + C.x return C f( input x )().meth() # ==> input x, C s x  confuses \nthe variable rename refactoring of all the Python IDEs we tried. We present these weaknesses to show \nthat getting a scope analysis right in Python is quite hard! We found these tools by following recommendations \non Stack-Over.ow, a trusted resource. Two of the tools we tested, Py-Charm and WingWare IDE, are products \nthat developers ac\u00adtually purchase to do Python development (we performed this experiment in their free \ntrials). For PyCharm, if we rename the x parameter to y, the class variable x also gets changed to y, \nbut the access at C.x does not. This changes the program to throw an error. If we instead select the \nx in C.x and refactor to y, The class variable and use of x change, but the original de.nition s parameter \ndoes not. This changes the behavior to an error again, as y is an unbound identi.er in the body of meth. \nPyDev has the same problem as PyCharm with renaming the function s parameter. If we instead try rename \nthe x in the body of C, it gets it mostly right, but also renames all the instances of x in our strings \n(something that even a parser, much less a lexical analyzer should be able to detect): def f(x): class \nC(object): y = \"C s y\" # we highlighed the x before = above # and renamed to y def meth(self): return \nx +  + C.y return C f( input y )().meth() # ==> input y, C s y WingWare IDE for Python is less obviously \nwrong: it pops up a dialog with different bindings and asks the user to check the ones they want rewritten. \nHowever, if we try to refactor based on the x inside the method, it doesn t give us an option to rename \nthe function parameter, only the class variable name and the access at C.x. In other cases it provides \na list that contains a superset of the actual identi.ers that should be renamed. In other words, it not \nonly overapproximates (which in Python may be inevitable), it also (more dangerously) undershoots.  \n  \n\t\t\t", "proc_id": "2509136", "abstract": "<p>We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.</p>", "authors": [{"name": "Joe Gibbs Politz", "author_profile_id": "81488660325", "affiliation": "Providence, RI, USA, Providence, RI, USA", "person_id": "P4290338", "email_address": "joe@cs.brown.edu", "orcid_id": ""}, {"name": "Alejandro Martinez", "author_profile_id": "83358820057", "affiliation": "La Plata, BA, Argentina, La Plata, Argentina", "person_id": "P4290339", "email_address": "amtriathlon@gmail.com", "orcid_id": ""}, {"name": "Matthew Milano", "author_profile_id": "83358868857", "affiliation": "Providence, RI, USA, Providence, RI, USA", "person_id": "P4290340", "email_address": "matthew@cs.brown.edu", "orcid_id": ""}, {"name": "Sumner Warren", "author_profile_id": "83358903757", "affiliation": "Providence, RI, USA, Providence, RI, USA", "person_id": "P4290341", "email_address": "jswarren@cs.brown.edu", "orcid_id": ""}, {"name": "Daniel Patterson", "author_profile_id": "83358797557", "affiliation": "Providence, RI, USA, Providence, RI, USA", "person_id": "P4290342", "email_address": "dbpatter@cs.brown.edu", "orcid_id": ""}, {"name": "Junsong Li", "author_profile_id": "83358925657", "affiliation": "Beijing, China, Beijing, China", "person_id": "P4290343", "email_address": "ljs.darkfish@gmail.com", "orcid_id": ""}, {"name": "Anand Chitipothu", "author_profile_id": "83358966957", "affiliation": "Bangalore, India, Bangalore, India", "person_id": "P4290344", "email_address": "anandology@gmail.com", "orcid_id": ""}, {"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Providence, RI, USA, Providence, RI, USA", "person_id": "P4290345", "email_address": "sk@cs.brown.edu", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509536", "year": "2013", "article_id": "2509536", "conference": "OOPSLA", "title": "Python: the full monty", "url": "http://dl.acm.org/citation.cfm?id=2509536"}