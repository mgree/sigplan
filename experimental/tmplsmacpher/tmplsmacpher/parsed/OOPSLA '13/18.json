{"article_publication_date": "10-29-2013", "fulltext": "\n Semi-Automatic Rename Refactoring for JavaScript Asger Feldthaus Aarhus University asf@cs.au.dk Abstract \nModern IDEs support automated refactoring for many pro\u00adgramming languages, but support for JavaScript \nis still prim\u00aditive. To perform renaming, which is one of the fundamental refactorings, there is often \nno practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives \nhave been developed, they are limited by whole\u00adprogram assumptions and poor scalability. We propose a \ntechnique for semi-automatic refactor\u00ading for JavaScript, with a focus on renaming. Unlike tra\u00additional \nrefactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction \nwith the programmer. With this pragmatic approach, we can provide scalable and effective refactoring \nsupport for real\u00adworld code, including libraries and incomplete applications. Through a series of experiments \nthat estimate how much manual effort our technique demands from the programmer, we show that our approach \nis a useful improvement com\u00adpared to search-and-replace tools. Categories and Subject Descriptors D.2.7 \n[Distribution, Maintenance, and Enhancement]: Restructuring, reverse en\u00adgineering, and reengineering \nGeneral Terms Languages Keywords Refactoring, Dynamic Programming Languages, Program Analysis 1. Introduction \nRefactoring is the process of transforming the source code of a program to enhance its internal structure \nwhile preserv\u00ading its external behavior. Many kinds of refactoring are used in modern software development, \nfor example, renaming of .elds or methods, extracting blocks of code into separate methods, or moving \ncode from one package to another [4]. Refactoring tools in IDEs assist the programmer in perform\u00ading \nthe necessary source code transformations and check- Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting \nwith credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. Request permissions from permissions@acm.org. OOPSLA \n13, October 29 31, 2013, Indianapolis, Indiana, USA. Copyright c &#38;#169; 2013 ACM 978-1-4503-2374-1/13/10. \n. . $15.00. http://dx.doi.org/10.1145/2509136.2509520 Anders M\u00f8ller Aarhus University amoeller@cs.au.dk \n ing that the program behavior is preserved. However, the most powerful existing techniques that provide \nsuch auto\u00admated support for refactoring have been developed for stat\u00adically typed programming languages, \nsuch as Java and C#. As those techniques critically depend on static information about class hierarchies, \npackages, and types of .elds and methods, they cannot easily be adapted to dynamically typed languages. \nIn JavaScript, for example, the object properties change at runtime, and classes and packages are at \nbest mim\u00adicked by meta-programming in libraries, which are dif.cult to reason about statically. The refactoring \ntechniques that ex\u00adist for dynamically typed languages, in particular JavaScript, remain primitive or \nimpractical: (1) One approach, introduced in the Smalltalk Refactor\u00ading Browser [9], is to use runtime \ninstrumentation to detect the consequences of tentative program transformations. This requires extensive \ntest suites to ensure that the program be\u00adhavior is preserved, and we are not aware of this approach \nbeing used in practice for JavaScript. (2) In previous work [3], we showed that static points-to information \ncan be used in lieu of static types as the founda\u00adtion for automated refactoring for JavaScript. Although \nthis approach works well in many situations, we have observed some practical limitations. Pointer analysis \nis hard to scale to large JavaScript programs without sacri.cing the necessary precision. Despite much \neffort, no existing pointer analy\u00adsis can handle typical JavaScript programs that use libraries. Moreover, \nthe technique only works for complete programs, which means it cannot reliably be applied to library \ncode, except if a comprehensive test suite is available, or to ap\u00adplication code that is under development \nwhere parts of the code have not yet been written. (3) If we consider one of the most common kinds of \nrefactoring renaming an object property the working programmer s best tool is still search-and-replace. \nThis can be based on the plain text or the abstract syntax tree of the program source code, in either \ncase without any consid\u00aderation toward its semantics. If the programmer wishes to rename an object property, \nhe may choose to rename all occurrences of the selected symbol in one fell swoop, or pick one-by-one \nthe occurrences he wishes to rename. The former is prone to errors since unrelated objects may have properties \nwith the same name, while the latter can be rather tedious if there are many occurrences.   Several \nIDEs exist for JavaScript programming, includ\u00ading Eclipse JSDT, Eclipse Orion, NetBeans, Visual Studio \nfor Web, Komodo IDE, Cloud9, and WebStorm. Among all these, we .nd only one WebStorm1 that supports rename \nrefactoring for JavaScript. While this tool is quite effec\u00adtive for renaming local variables, it seems \nto fall back to search-and-replace when renaming object properties. Based on brief experimentation, it \nappears that it always replaces all occurrences of the given object property name. Web-Storm is closed \nsource and its algorithms are not publicly documented, so we cannot verify how the tool works. In this \nwork, we propose a semi-automatic technique for renaming object properties in JavaScript programs. Renam\u00ading \nis among the most common kinds of refactoring [8, 12]. Making better tool support for renaming than search-and\u00adreplace \nrequires information about how object property ac\u00adcess operations in the program code are related to \neach other. Such information is also fundamental for other refactorings, for example, property encapsulation \n[3]. Our approach may be seen as a middle ground between fully automated refac\u00adtoring and tedious one-by-one \nsearch-and-replace. When the programmer decides that some occurrence of an object prop\u00aderty x in the \nprogram needs to be renamed to y, we use a lightweight static analysis to divide all occurrences of x \ninto groups. Two occurrences of x are placed in the same group if the analysis infers that they are related \nin the sense that they must either both be renamed or neither be renamed. The refactoring tool then asks \nthe programmer whether each group should be renamed entirely or left unchanged. In this way, the programmer \ngets one question for each group, and each question only mentions one occurrence of x. Compared to traditional \nsearch-and-replace, this approach requires less effort by the programmer since we avoid asking questions \nwhere the answer can be inferred from previous answers. Compared to the fully automated approach from \nour pre\u00advious work, we circumvent the computationally expensive pointer analysis and the whole-program \nassumption. For an incomplete program for example, a library or an application under development ultimately \nonly the pro\u00adgrammer knows whether two object property operations are related or not, given that no formal \nspeci.cation exists of the desired program behavior. Still, we can de.ne an informal notion of soundness \nfor our static analysis: if the heuristics employed by the analysis group together two occurrences of \nx, then it should not be the case that the programmer wants one of them to be renamed but not the other, \nsince he only gets a question for one of them. Our static analysis therefore aims to compute a lower \napproximation of relatedness. The converse case, dividing the occurrences of x into too many groups, \nis tolerable although undesirable, since the program\u00admer must then answer more questions to complete \nthe refac\u00adtoring. For complete programs, which have a well-de.ned meaning, it is reasonable to assume \nthat two occurrences of 1http://www.jetbrains.com/webstorm/ x are related if they refer to the same object \nproperty in some execution of the program. This makes our analysis akin to alias analysis, but designed \nto work also on incomplete pro\u00adgrams. The analysis is expressed as a set of rules reminiscent of a type \nsystem. We evaluate how it works on incomplete programs by measuring the stability of the analysis behavior \nwhen source code is added or removed from the codebase. The analysis is theoretically unsound, but our \nexperiments indicate that it is sound in practice. Some refactoring tools follow a tradition of performing \nsafety checks to ensure that the program behavior will re\u00admain unchanged when performing refactorings. \nIf a precon\u00addition is violated, such tools will abort or issue a warning to the programmer. For example, \na common precondition for renaming a .eld in a Java program is that it does not cause a name clash. These \nsafety checks are usually not sound in practice. Java refactoring tools typically ignore the possibil\u00adity \nof re.ection, while refactoring for JavaScript may give some leeway regarding use of the eval function. \nIn the op\u00adposite end of the spectrum, other refactoring tools assume that programmer knows what he is \ndoing, so no safety check\u00ading is performed. We follow the latter approach. The fore\u00admost rationale for \nthis decision is that proper precondition checking requires static analysis that scales to large real\u00adworld \ncodebases, has high precision, and works on incom\u00adplete programs, which is beyond the capabilities of \nexisting JavaScript analysis techniques. We argue that this decision is not as detrimental to safety \nfor semi-automatic refactor\u00ading as it would be for a fully automatic tool: the programmer will observe \na number of proposed changes in the code while interacting with the tool, so he is more likely to detect \nprob\u00adlematic situations. Re.ective property access is common in JavaScript. Such expressions access an \nobject property whose name is com\u00adputed at runtime. Re.ective property accesses cannot be re\u00adnamed directly, \nsince the source code does not mention the property name explicitly, and it lies beyond the scope of \nour proposed algorithm to update the relevant string operations that compute the property name. Our algorithm \nwill only re\u00adname identi.er tokens in the source code, and the user is expected to know this. Apart from \nthis assumption, the in\u00adternals of our proposed algorithm do not concern the pro\u00adgrammer when performing \nrefactorings. Our contributions can then be summarized as follows: We present a novel approach to semi-automatic \nrefactor\u00ading, based on an algorithm for .nding groups of related identi.er tokens. A key component of \nthis algorithm is a type inference technique reminiscent of alias analysis.  We present experiments \nthat evaluate the practical use\u00adfulness of the approach. The results show that (1) it asks signi.cantly \nfewer questions than search-and-replace, (2) it scales to large real-world codebases, (3) it does not \nre\u00adquire the whole program to be useful, and (4) although unsound in theory, the unsoundness rarely manifests \nin practice.   In Section 2 we motivate our technique using a real-world code snippet. In Section 3 \nwe present the algorithm and demonstrate it on a few examples, and in Section 4 we present research questions \nand results of the experimental evaluation. Related work is discussed in Section 5, and our conclusions \nand suggestions for further work are given in Section 6. 2. Motivating Example Renaming a local variable \nis trivial in most cases, as the scoping rules in JavaScript let us .nd all tokens that refer to the \nvariable. However, renaming object properties is non\u00adtrivial. In this section, we will demonstrate some \nof the chal\u00adlenges involved in renaming object properties. Consider the code fragment in Figure 1, taken \nfrom the popular jQuery library.2 We shall intentionally withhold in\u00adformation about the rest of jQuery \nfor now, and see what we can learn about the code without providing any context. The code fragment contains \na top-level statement that cre\u00adates a new object with six properties, three of which are initialized \nto function expressions. The new object is then stored in the prototype property of the jQuery.Event \nobject. The prototype property has a special meaning in JavaScript: informally, objects created using \na construc\u00adtor call new jQuery.Event will inherit the properties of jQuery.Event.prototype. We will now \ndiscuss how an editor with our refactor\u00ading technique reacts to various renaming request from a programmer, \nassuming the code in Figure 1 is the only code open in the editor. Although refactoring a fragment of \njQuery is an unusual scenario, the code in Figure 1 is representative of some of the issues we generally \nencounter when refactoring incomplete programs. Consider the three preventDefault tokens on lines 2, \n6, and 7. Suppose the programmer has decided to rename the token on line 2. It is not immediately evident \nwhether the tokens on line 6 and 7 should be renamed as well. The IDE therefore asks the programmer whether \nthe token on line 6 should be renamed also. However, regardless of the answer, the IDE will not ask a \nsecond time whether the token on line 7 should be renamed. Clearly, if one of these tokens were to be \nrenamed, the other must also be renamed. We call such tokens related. In this particular case, our technique \nwill determine that they are related because they both occur as the name of a property accessed on the \ne variable. In short, we say they access the same property on e. The originalEvent tokens on lines 4 \nand 14 access a property on this but in different functions. Technically, any function can be invoked \nwith an arbitrary this argument, and thus the two uses of this could refer to very differ\u00adent objects \nthat just happen to both have a property called originalEvent. In practice, though, such a scenario is \nun\u00adlikely. Due to the function call semantics of JavaScript, the 2http://jquery.com/ 1 jQuery.Event.prototype \n= { 2 preventDefault : function() { 3 this.isDefaultPrevented = returnTrue; 4 var e = this.originalEvent \n; 5 if ( !e ) { return; } 6 if ( e.preventDefault ) { 7 e.preventDefault (); 8 } else { 9 e.returnValue \n= false; 10 } 11 }, 12 stopPropagation : function() { 13 this.isPropagationStopped = returnTrue; 14 \nvar e = this.originalEvent ; 15 if ( !e ) { return; } 16 if ( e.stopPropagation ) { 17 e.stopPropagation \n(); 18 } 19 e.cancelBubble = true; 20 }, 21 stopImmediatePropagation : function() { 22 this.isImmediatePropagationStopped \n23 = returnTrue; 24 this.stopPropagation (); 25 }, 26 isDefaultPrevented : returnFalse , 27 isPropagationStopped \n: returnFalse, 28 isImmediatePropagationStopped : returnFalse 29 }; Figure 1. A fragment of jQuery (any \nversion after 1.5.1). object on which a function is stored is often the this ar\u00adgument or a prototype \nthereof. Hence our analysis will de\u00adtermine that the two originalEvent tokens are related. By similar \nreasoning, the isDefaultPrevented tokens on lines 3 and 26 are also considered related. Consider now \nstopPropagation on lines 12, 16, 17, and 24. The tokens on lines 16 and 17 are considered related, as \nare those on lines 12 and 24. But it is not evident whether these two groups are also related to each \nother. Two of them access a property on a jQuery event object or its prototype, while the other two access \na property on e, which is an alias for this.originalEvent. There is no reliable indicator as to whether \nthese refer to the same kind of object. The call on line 17 could be a recursive call to the function \nde.ned on line 12, or it could be a call to a lower-level event object whose method happens to have the \nsame name. Our analysis considers the two groups of tokens unrelated from each other, and to rename the \nfour tokens the programmer must thus answer two questions, one for each group. In jQuery, the originalEvent \nproperty happens to refer to a native event object, created by the browser. As such, the stopPropagation \ntokens on lines 16 and 17 refer to a prop\u00aderty on a native event object, while the tokens on lines 12 \nand 24 refer to a property on jQuery s own event objects, which function as wrappers around the native \nevent objects.  Indeed, it is possible to rename the stopPropagation prop\u00aderty on jQuery s event objects \nby updating the tokens on lines 12 and 24 and one other token elsewhere in jQuery (outside the code shown \nin Figure 1), while leaving the to\u00adkens on lines 16 and 17 unaltered. The result is a refactored version \nof the jQuery library that remains compatible with most jQuery applications. Only applications that explicitly \ninvoke stopPropagation on a jQuery event object are in\u00adcompatible with the new version. In this way, \nthe program\u00admer remains responsible for ensuring backward compatibil\u00adity in case a renaming interferes \nwith the public API of the library, but our technique makes it easier for the programmer to perform the \ndesired refactorings of the library code. Moreover, consider what would happen if we were to up\u00addate \nevery stopPropagation token in the previous exam\u00adple, that is, including those on lines 16 and 17. The \ncall on line 17 would then no longer work as intended, because the browser would still use the name stopPropagation \nwhen creating native event objects, regardless of any source code transformation we have performed. As \ndiscussed previously, our technique does not perform safety checking, so we trust that the programmer \ndoes not attempt to perform such refac\u00adtorings. This allows our technique to work without modeling the \nbrowser API. A .nal concern when renaming a property is that all references to the property must be updated \nconsistently. For instance, suppose we renamed only the stopPropagation token on line 12. Clearly, the \ncall on line 24 would then fail. In this particular case, our technique groups these tokens together, \nand it is thus impossible for the programmer to perform the erroneous renaming using our refactoring \ntool. But this is not always the case; in general, the consistency of a renaming depends on the programmer \nanswering correctly to the questions posed by the refactoring tool, which is no different than ordinary \nsearch-and-replace. While our tool does not actively prevent inconsistent re\u00adnamings, it should be able \nto carry out any consistent re\u00adnaming that can be done by renaming of identi.er tokens, assuming the \nprogrammer answers its questions correctly. To demonstrate the importance of this criterion, suppose \nour technique incorrectly determined that all four stop-Propagation tokens in Figure 1 were related. \nIn this case, the previously mentioned refactoring of jQuery would not have been possible, because it \ninvolves renaming only a sub\u00adset of these tokens. Indeed, if the programmer decided to rename the token \non line 12, he would not get the opportu\u00adnity to tell the tool not to rename those on lines 16 and 17, \nleading to a different refactoring that was intended. When working with a large codebase, the programmer \nmight not immediately notice that his renaming did not go as intended, thereby introducing a bug in his \ncode. Such behavior is there\u00adfore highly undesirable, and while our technique is not im\u00adpervious to this \ntype of failure, our evaluation shows that it is unlikely to occur in practice. This example demonstrates \nthat we need a static analysis that is able to approximate how object property tokens are related in \nJavaScript programs. This analysis must be sound in practice to avoid undesired refactorings, it must \nbe suf.\u00adciently precise to enable a signi.cant reduction of program\u00admer effort compared to traditional \nsearch-and-replace, and it must be scalable and fast to be usable during program\u00adming. In addition, we \nwant the analysis to work robustly on incomplete programs, such as libraries or applications under development. \nAs we discuss in Section 5, no existing static analysis analysis satis.es these requirements, which moti\u00advates \nthe design of our new analysis described in the follow\u00ading section. 3. Finding Related Identi.er Tokens \nOur proposed refactoring algorithm depends on a reliable method for .nding related tokens in the program \ncode. We de.ne an ad-hoc type inference system, based on how ob\u00adjects appear to be used. Unlike most \ntype systems, ours does not perform type checking, that is, there is no such thing as a static type error; \nall programs can be typed. A program typing is an equivalence relation between expressions, de\u00adnoting \nwhich expressions have the same type. Given two occurrences of expressions, e1 .f and e2 .f , we can \nsubse\u00adquently say that the two f tokens are related if e1 and e2 have the same type. The type inference \nis considered sound if it is never the case that two tokens are found to be related while the programmer \nonly intends to rename one and not the other. The type inference is performed in two phases, denoted \nbasic type inference and receiver type inference. Each phase traverses the abstract syntax tree once, \ngenerating a set of constraints. At the end of each phase, these constraints are saturated under a collection \nof closure rules using an aug\u00admented union-.nd data structure. Our type analysis is reminiscent of alias \nanalysis, in par\u00adticular, the Steensgaard style [11], however, with important differences. Alias analysis \ndetermines which expressions in a program are aliased, that is, refer to the same object. The most common \nkind is may-alias analysis, which .nds pairs of expressions that may, in some execution, evaluate to \nthe same object. Given two expressions e1 .f and e2 .f , one might consider the two f tokens to be related \nif e1 and e2 are may-aliased. However, may-alias analysis is conserva\u00adtive in the direction opposite \nof what we want: it may report some expression pairs as may-aliased even if they can, in fact, never \nbe aliased. When this happens, unrelated tokens may be classi.ed as related, which, as previously mentioned, \nis highly undesirable. Instead, one may consider must-alias analysis, which .nds pairs of expressions \nthat are aliases in every execution. This will result in a sound construction of related tokens, however, \nthe resulting precision will be poor, even for a perfectly precise must-alias analysis. As an ex\u00adample, \nconsider a composite expression x.f + y.f where x and y are aliases in some program executions but not \nin others. In this case, using a must-alias analysis will result in the two f tokens to be considered \nnon-related. However, we would like to treat them as related, because there exists an execution where \nthey refer to the same object property. This means that we wish to design a must-sometimes-alias analysis \nthat .nds pairs of expressions that must be aliases in some execution. We are not aware of existing analyses \nof that kind.  Moreover, our analysis must account for object proto\u00adtypes, which JavaScript uses for \nmimicking inheritance, and certain common programming patterns, such as, prototype methods and object \nextension functions. For reasons ex\u00adplained in the following sections, these patterns indicate re\u00adlatedness \nwithout involving aliasing, so we refer to our anal\u00adysis as a type inference rather than an alias analysis. \n 3.1 Constraint Syntax The constraints generated are of form t1 = t2 where t1 , t2 are terms. A term \nmay either be an expression e, or a com\u00adpound e.f representing the f property on expression e. The = \nrelation is called the same-type relation. We say that two terms, t1 and t2 , have the same type when \nt1 = t2 . As an example, x . f = y means that the variable x points to an object with an f property that \nhas the same type as the vari\u00adable y. The schema below summarizes the syntax and our nam\u00ading conventions: \no, v, e . expressions g . function bodies f . identi.ers t . terms t ::= e |e .f = . terms \u00d7 terms We \nreserve the meta-variable o for object literals, v for pro\u00adgram variables, and e for any type of expression. \nThe no\u00adtion of an expression is used quite liberally, but the meaning should be clear from the context: \nWe use it primarily when referring to an occurrence of a JavaScript expression in the abstract syntax \ntree; thus, identical expressions at different positions in the program code are considered distinct. \nIn a slight abuse of terminology, we also refer to variable decla\u00adrations, such as a var statement or \nthe token of a parame\u00adter name, as expressions. Finally, we include the following pseudo-expressions: \nglob: expression representing the global object ret(g): expression representing return value of function \ng this(g): expression representing this inside function g Unlike expressions, the notion of an identi.er \ndoes not de\u00adnote a speci.c occurrence in the abstract syntax tree; two identi.ers are indistinguishable \nif they consist of the same string of characters. We will use the notion of tokens when different occurrences \nof the same identi.er should be con\u00ad statement or expression e constraints variable v e =decl(v) property \ne1 .f e = e1 .f dyn. prop. e1 [e2 ] see text *assignment e1 =e2 e = e1 = e2 *conditional e1 ? e2 : e3 \ne = e2 = e3 *logical or e1 || e2 e = e1 = e2 logical and e1 &#38;&#38; e2 e = e2 this this e =this(fun(e)) \nreturn return e1 e1 =ret(fun(e)) call e1 (ee2 ) see text new-call new e1 (ee2 ) see text function function \nf (ev){ . . . } see text array literal [ e1 ,e2 , . . . ] e .[array] = ei object literal { . . . } see \nbelow member of object literal o constraints initializer f :e1 o .f = e1 getter get f (){g . . . } o \n.f =ret(g) o =this(g) setter set f (v){g . . . } o .f = v o =this(g) Figure 2. Constraints for basic \ntype inference. A star * indicates that an exception to the rule is described in the text. sidered distinct. \nThe arti.cial identi.er [array] refers to array entries.  3.2 Saturation At the end of each phase, we \nsaturate the = relation until it satis.es a collection of closure rules. In particular, we ensure that \n=is an equivalence relation: (re.) t1 = t2 (sym) t1 = t2 t2 = t3 (trans) t = t t2 = t1 t1 = t3 and that \n=moreover satis.es the following rule: e1 = e2 (prty) e1 .f = e2 .f Informally, the prty rule states \nthat same-typed expressions have same-typed properties. Examples in the next section demonstrate the \nconsequence of the saturation rules. We present an ef.cient algorithm for performing the saturation in \nSection 3.5.  3.3 Basic Type Inference In the .rst phase we traverse the abstract syntax tree and for \neach expression generate constraints according to Figure 2. We use the notation e1 = e2 = e3 as shorthand \nfor the two constraints e1 = e2 and e2 = e3. We also introduce the following two auxiliary de.nitions: \ndecl(v): the declaration of v, or glob.v if v is global fun(e): the innermost function containing e We \nwill now discuss each rule in detail.  Variable For an expression e that is a variable v, we add the \nconstraint that v should have the same type as its declaration: e = decl(v). By transitivity, all uses \nof the variable will thereby have the same type. Example The three uses of v below will have same type \nas the declaration of v on line 30 due to the variable rule. After saturation (Section 3.2), they will \nthen all have the same type due to transitivity, and thus the two x tokens will ultimately be considered \nrelated: 30 function f(v) { 31 v.x = v.y; 32 return v.x; 33 } Property When a property expression e \nof form e1 .f is encountered, we add the constraint e = e1 . f . Due to the prty rule, if f is accessed \non a similarly typed expression, the two accesses will then be given the same type. Example As per the \nprevious example, the three uses of v below are same-typed. We use subscripts to name tokens in the example \ncode: 34 function f(v) { 35 v1.x.y3 = v.y; 36 return v2.x.y4; 37 } Because v1 = v2 , the prty rule yields \nthe typing v1 . x = v2 . x. Since v1 .x = v1 . x and v2 .x = v2 . x were generated while traversing the \nabstract syntax tree, we get by transitivity that the two v.x expressions are same-typed. Thus, y3 and \ny4 will ultimately be considered related. Dynamic property An expression of form e1 [ e2 ] per\u00adforms \nan array access or a re.ective property access on e1 (technically, they are the same in JavaScript). \nThe name of the property being accessed depends on the value of e2 at runtime. If e2 is a string constant \n\"f \" we treat the expres\u00adsion as e1 .f ; in all other cases, we ignore the expression. Assignment For \nan expression e of form e1 = e2 , we add the constraints e = e1 and e = e2 . There is an exception to \nthis rule, however. Consider this chain assignment: 38 x = y = null; Such a statement is often employed \nas a compact way to clear the value of several variables, but is generally not a good indicator of the \nvariables x and y having the same type. Indeed, no object could be assigned to both x and y by executing \nthe statement. We classify certain expressions as primitive when they de.nitely cannot evaluate to an \nob\u00adject. Null expressions are primitive, and an assignment ex\u00adpression is primitive if its right-hand \nside is primitive. If the right-hand side of an assignment is primitive, then we dis\u00adregard the above \nrule for assignments and generate no con\u00adstraints. No constraints are generated for compound assign\u00adment \noperators, such as, +=. Conditional An expression e of form e1 ? e2 : e3 evaluates e1 and then evaluates \nand returns the value of either e2 or e3 , depending on whether e1 was true or false. We therefore add \nthe constraints e = e2 and e = e3 . There is an exception to the above rule, however, since programmers \noccasionally use the ?: operator in situations where an if-statement would have been appropriate. The \nfol\u00adlowing two statements are semantically equivalent: 39 if (b) x = y else z = w; 40 b ? (x = y) : (z \n= w); In the latter case, the result of the ?: expression is immedi\u00adately discarded. We say that such \nexpressions occur in void context. When a ?: expression occurs in void context, we disregard the rule \nabove and generate no constraints. Other\u00adwise, x and y would have been considered same-typed with z and \nw after saturation due to transitivity. Logical or An expression e of form e1 || e2 will at run\u00adtime \nevaluate e1 , and then if e1 is false, it will evaluate e2 and return its result. If e1 is true, the \nresult of e1 is returned. Although the operator is called logical or, its result need not be a boolean. \nObjects are considered to be true when co\u00aderced to a boolean value. Hence, an object from either e1 or \ne2 may be returned; we therefore add the constraints e = e1 and e = e2 . As for the ?: operator, we disregard \nthis rule when e occurs in void context. Logical and An expression e of form e1 &#38;&#38; e2 will at \nrun\u00adtime evaluate e1 . If e1 is true, it will then evaluate e2 and re\u00adturn the result of e2 , and otherwise \nit will return the value of e1 . Since objects cannot be false when coerced to a boolean, only objects \nfrom e2 may be returned. Thus, we add the con\u00adstraint e = e2 . The void context exception could be applied \nto this rule as well, but in this case it makes no difference, since e = e1 is not generated either way. \nThis For an expression e of form this we add the con\u00adstraint that e should have the same type as the \nthis argu\u00adment in the enclosing function: e = this(fun(e)). Thus, all uses of this in a given function \nwill be given the same type. Return For a return statement e of form return e1 , we add the constraint \ne1 = ret(fun(e)). This ensures that all returned expressions will have the same type. Example In the \nfunction below, a and b will be same-typed because they are both returned within the same function. Thus \nthe two x tokens will ultimately be considered related: 41 function minX(a,b) { 42 if (a.x < b.x) return \na; 43 else return b; 44 } Call and new Most function calls are ignored by our al\u00adgorithm. Precise inference \nof function types is complicated for a language such as JavaScript. If a call graph were avail\u00adable, \nwe could connect arguments to parameters and return values to results, but if done in a context-insensitive \nmanner, the transitivity of the = relation would in practice declare too many expressions as same-typed, \nwhich, as previously discussed, is highly undesirable. If done context-sensitively, scalability would \nbe jeopardized. In our setting, the conser\u00advative action is to exclude constraints rather than include \nthem, and as such, ignoring function calls can be tolerated.  One particular type of function call is \neasily handled, however. JavaScript programs often use one-shot closures to obtain encapsulation: 45 \n(function(self) { 46 var x; // x not visible in outer scope 47 /* ... */ 48 })(this); A function call \ne of form e0(e1 ,e2, . . . ) in which e0 is an anonymous function expression is easily handled for two \nreasons: (a) the called function is known, and (b) no other call can invoke that function. For this type \nof call, we add the constraint ei = vi for each corresponding argument ei and parameter vi . Likewise, \nwe add the constraint ret(e0 )= e. If the call was made with the new keyword, we further add the constraint \nthis(e0 )= e, and otherwise this(e0 )=globsince the global object is passed as this argument in that \ncase. Example One-shot closures are often used together with for-loops as in the following example: 49 \nfor (var i=0; i<10; i++) { 50 var panel = panels[i]; 51 var handler = (function(panel) { 52 return function() \n{ 53 panel.activated(true); 54 } 55 })(panel); 56 panel.button.addEvent(\"click\", handler); 57 panel.activated(false); \n58 } If the one-shot closure was not used, all ten event handlers would refer to the same panel variable, \nso the ith event han\u00addler would invoke activated on the last panel, rather than the ith panel. By handling \none-shot closures, our analysis .nds that the two uses of panel on lines 53 and 57 have the same type, \ndespite referring to different variables. Thus, the two activated tokens are ultimately considered related. \nFunction Functions are .rst-class objects in JavaScript, and thus may themselves have properties. One \nproperty of particular interest is the prototype property of a function object. When a function is invoked \nusing the new keyword, a newly created object is passed as the this argument. This object has its internal \nprototype link initialized to the object pointed to by the prototype property of the function object, \neffectively inheriting the properties of this object. For any function expression e with body g, we therefore \nadd the constraint e .prototype = this(g). For named functions, we similarly add the constraint v . prototype \n= this(g) where v is the function name declaration. Using the prototype property for a purpose other \nthan inheritance is highly unusual, even for functions that are never invoked using new. Thus, the constraint \nwill typically have no impact for functions that are not intended to be invoked using new. Example In \nthe code below, a string builder function is de.ned, and two functions are placed on its prototype object. \nDue to the above rule, this on line 60 will have the same type as StringBuilder.prototype on line 62, \nand the two clear tokens will thus be considered related: 59 function StringBuilder () { 60 this.clear(); \n61 } 62 StringBuilder .prototype.clear = function() { 63 this.array = []; 64 }; 65 StringBuilder .prototype.append \n= function(x) { 66 this.array.push(x); 67 }; 68 StringBuilder .prototype.toString = function() { 69 return \nthis.array.join(\"\"); 70 }; During the second phase of the algorithm, which we describe in Section 3.4, \nthe three uses of this on lines 63, 66 and 69 will also get the same type, and the three array tokens \nwill thus also become related. Array literal An array literal e of form [e1 ,e2 , . . . ] cre\u00adates a \nnew array object, initialized with the value ei in its ith entry. We assume such array objects are intended \nto be homogeneous, and add the constraint e .[array] = ei for each i. A homogeneous array is an array \nfor which all ele\u00adments have the same type. Not all arrays are intended to be homogeneous, but we found \nthat those created using array literals typically are. Note that the arti.cial [array] property is not \nreferenced by any of the other rules. In particular, there is no rule that handles array access expressions, \nsince such expressions are hard to distinguish from re.ective property accesses, and the array being \naccessed might not be homogeneous. Example Array literals are often used to write out constant tables \nin JavaScript source code, as in the below snippet taken from Mozilla s JavaScript PDF reader: 71 var \nQeTable = [ 72 {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1} 73 ,{qe: 0x3401, nmps: 2, nlps: 6, switchFlag: \n0} 74 ,{qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0} 75 /* ... */ 76 ]; Since each member of the array \nis assigned the same type, each qe token will be considered related, and likewise for the three other \nproperty names.  Object literal An object literal o is an expression of form { . . . } containing zero \nor more object literal members. Such an expression creates a new object, with the object literal members \ndenoting the initial values of its properties. There are three types of members: initializers, getters, \nand setters. An initializer is of form f : e1 and assigns the value of e1 to the f property of the new \nobject. For each such initializer, we add the constraint o .f = e1. A getter is of form get f (){ . . \n. }. This assigns a getter function for the f property on the new object. Whenever the f property is \nread from the object, the getter is invoked, and the value it returns is seen as the value of the f property. \nFor each getter, we add the constraint o . f = ret(g), where g denotes the getter function s body. We \nalso add o =this(g), since the object is passed as this argument when the getter is invoked. A setter \nis of form set f (v){ . . . }. This assigns a setter function for the f property. Whenever the f property \nis assigned to on the object, the setter is invoked with the new value passed as argument. We therefore \nadd the constraints o . f = v and o = this(g), where g denotes the setter function s body. Getter and \nsetters were introduced in ECMAScript 5 [2] and are now used in many applications; other recently intro\u00adduced \nlanguage features are ignored by our analysis.  3.4 Receiver Type Inference In the second phase, we \nclassify certain functions as methods and add additional type constraints accordingly. However, reliably \nclassifying functions as methods requires knowl\u00adedge of namespace objects, as we shall discuss shortly. \nWe need the same-type relation inferred during the previous phase to detect such namespace objects, hence \nthe division into two phases. We will now motivate the informal concepts of methods as namespaces, and \nthen discuss the type infer\u00adence algorithm for this phase. JavaScript has no .rst-class concept of methods \nor con\u00adstructors, only functions and invocation conventions that let programmers mimic these features. \nFunction calls of form e.f ( . . . ) will receive the value of e as the this argument, while calls of \nform new e( . . . ) and new e.f ( . . . ) receive a newly created object as the this argument. Although \npro\u00adgrammers may mix and match these invocation types for any one function, most functions are in practice \ndesigned to be called exclusively one way or the other. Functions de\u00adsigned to be called with new are \nreferred to as constructors. Likewise, a non-constructor function stored in a property on some object \nis sometimes referred to as a method of that ob\u00adject. JavaScript also has no built-in support for namespaces, \npackages, or modules. This has led to a tradition of using objects to mimic namespaces. When a function \nis stored in some property of a namespace object, it may be wrong to consider it a method on the namespace, \nas it could just as well be a constructor. 77 obj.onmouseover = function() { 78 this.active = true; 79 \n}; 80 obj.onmouseout = function() { 81 this.active = false; 82 }; (a) 83 util.Rect = function(x1,y1,w,h) \n{ 84 this.x = x1; 85 this.y = y1; 86 this.width = w; 87 this.height = h; 88 }; 89 util.Vector2 = function(x1,y1) \n{ 90 this.x = x1; 91 this.y = y1; 92 }; 93 /* ... */ 94 new util.Vector2(0,10); (b) Figure 3. Functions \nstored as (a) methods on an object, and (b) constructors in a namespace. Figure 3 demonstrates examples \nof methods and con\u00adstructors stored on objects. To motivate the need to distin\u00adguish these cases, suppose \nthe programmer has decided to rename the active token on line 78. For this type of code, it is generally \nsafe to assume that the active token on line 81 is related to the one on line 78. However, if instead \nthe programmer had decided to re\u00adname the x token on line 84, it is not generally safe to assume that \nthe x token on line 90 should be renamed as well. The key difference is that Rect and Vector2 are constructors, \nand thus their this arguments are not related to the object on which the function is stored. Unfortunately, \nthe two cases are structurally quite similar. Given a statement of form e.f =function( . . . ){ . . . \n}, we cannot immediately tell if the function is a method or a constructor. In this phase, we exploit \ntwo indicators of a function be\u00ading a constructor. The most direct indicator is that it is in\u00advoked using \nthe new keyword. The second indicator is that the source code mentions its prototype property. As previ\u00adously \nmentioned, this property has a special meaning when used on functions, and is typically only used for \nconstructor functions. Generally detecting how a function is called is a hard problem involving call \ngraph construction, but our situa\u00adtion is much simpler than that. We are primarily interested in functions \nthat are accessed through namespace objects, which we can easily recognize statically using the following \nheuristic.  Namespace detection After the constraints from the prior phase have been generated, we saturate \nthe =relation under the closure rules in Section 3.2. Then, for any expression of form new e.f ( . . \n. ) or e.f .prototype we mark the type of e as a namespace type. Any expression with same type as e will \nbe considered to be a namespace. Namespaces are not considered to have any methods. Using the above heuristic, \nthe Rect function in Figure 3 will not be considered a method on the util object, because util has been \nmarked as a namespace by the new-call on line 94. There is an inherent whole-program assumption in this \nheuristic. If the programmer has created a namespace with two functions intended to be used as constructors, \nbut is not yet using any of them, the heuristic may fail to detect the namespace object. For example, \nif the new call on line 94 were not yet written, the two x tokens in Figure 3(b) would be treated as \nbeing related. The practical implications of this are discussed in the evaluation section. Method de.nition \nOnce namespaces have been identi.ed, we look for method de.nitions. For an expression of form e1 .f = \ne2 where e1 was not marked as a namespace and e2 is a function expression, we say e2 is a method de.nition \nwith e1 as its host expression. Likewise, for an initializer f : e2 inside an object literal o, we say \ne2 is a method de.nition with o as its host expression. For any method de.nition with body g and host \nexpression e, we add the constraint e =this(g). Example (prototype method) In the code below, the baz \nfunction is considered a method on Foo.prototype, hence its this argument will get the same type as Foo.prototype. \nSince this inside the Foo function also has the same type as Foo.prototype by the function rule from \nthe prior phase, the two uses of this have the same type. Hence, the two uses of x will ultimately be \nconsidered related. 95 function Foo(x1) { 96 this.x = x1; 97 } 98 Foo.prototype.baz = function() { 99 \nalert(this.x); 100 }; 101 new Foo(5).baz(); // alerts \"5\" Example (extend function) The code below uses \nthe extend function commonly found in third-party libraries, which copies all properties from one object \nto another. The host object of the baz method is thus a temporary object that ex\u00adists only brie.y until \nits properties have been copied onto the Foo object. Even though this temporary object is never actually \npassed as this to the baz method on line 105, the method de.nition constraint ensures that the object \nliteral has the same type as this, which has the desired effect: the two uses of x will be considered \nrelated. 102 var Foo = {}; 103 Object.extend(Foo, { 104 x: 5, 105 baz: function() { 106 alert(this.x); \n107 } 108 }); 109 Foo.baz(); // alerts \"5\" This example, as well as the following one, also demon\u00adstrates \nwhy our analysis is technically not an alias analysis: the this expression on line 106 is not an alias \nof the object literal, so if we used a precise alias analysis instead of our type inference, the two \nuses of x would not be considered related. Example (class system) The code below uses a popular class \nsystem provided by the prototype.js library3 to simulate the creation of a class. As with the extend \nfunction, the host object for the two methods is in fact not passed as this to either method, but again, \nreceiver type inference has the desired effect: the two uses of x become related. 110 var Foo = Class.create({ \n111 initialize : function(x1) { 112 this.x = x1; 113 }, 114 baz : function() { 115 alert(this.x); 116 \n} 117 }); 118 new Foo(5).baz(); // alerts \"5\"  3.5 Saturation Algorithm At the end of each phase, the \n= relation is saturated until it satis.es the closure rules in Section 3.2. Since the result is an equivalence \nrelation, it can be represented ef.ciently using a union-.nd data structure [1]. In the following, we \nassume the reader is familiar with union-.nd and associated terminology. The only rule not immediately \nsatis.ed by virtue of the traditional union-.nd algorithm is the prty rule. We aug\u00adment the union-.nd \ndata structure such that each node has a prty .eld, in addition to the standard parent pointer and rank \n.elds. The prty .eld holds a map from strings (property names) to nodes of the union-.nd data structure. \nInitially, one union-.nd node is created for each program expression, including the pseudo-expressions \nde.ned in Section 3.1. We informally refer to these nodes as types, since two expres\u00adsions have the same \ntype exactly if their nodes have a com\u00admon representative. The type of a term e . f is the node pointed \nto by the f entry in the prty map of the representa\u00adtive of e. If no such node exists, then e .f is not \nsame-typed with any other term. 3http://prototypejs.org/  When two nodes n1 , n2 are uni.ed, such that \nn1 becomes the new root, their prty maps are merged by the following procedure. For property names present \nonly in n2 s prty map, the corresponding entry is copied over to n1 s prty map. For property names present \nin both maps, the nodes they refer to are recorded in a worklist of node-pairs that should be uni.ed. \nAs a simple and effective optimization to this procedure, we initially swap n1 and n2 s prty pointers \nif n2 s prty map is bigger than n1 s, so fewer entries need to be copied. At the end of each phase, node \npairs are removed from the worklist and uni.ed until the worklist is empty. We also store an isNamespace \nboolean on each node, for marking nodes as namespaces during the second phase. The namespace detection \ncan be done while traversing the abstract syntax tree in the .rst phase. A pseudo-code implementation \nof the augmented union\u00ad.nd data structure is given in Figure 4. The code does not include the generation \nof constraints during traversal of the abstract syntax tree. When a constraint of form e1 = e2 is discovered, \nwe invoke the unify method with the corresponding nodes. For a constraint of form e1 .f = e2 , we invoke \nunifyPrty instead. The constraints need not be stored explicitly; invoking the corresponding method on \nthe Uni.er instance is suf.cient. At the end of each phase, we invoke the complete method to ensure that \nthe prty closure rule is satis.ed. 4. Evaluation We implemented a renaming plugin4 for Eclipse, based \non the algorithm described in the previous section. We use the same underlying implementation for this \nevaluation. Ideally, the primary metric of usefulness of a refactoring tool is its impact on programmer \nproductivity. This is unfor\u00adtunately hard to de.ne and dif.cult to measure directly, so we base our evaluation \non the following more tangible met\u00adrics, which we consider good indicators of usefulness: Manual Effort: \nHow many questions must the programmer answer to complete a renaming? Since the programmer need only \nconsider a single token per question, a ques\u00adtion issued by our tool is no more dif.cult than the corre\u00adsponding \nsearch-and-replace question. Soundness: If given correct answers by the programmer, how likely is it \nthat a renaming is ultimately inconsistent? In other words, is the analysis sound in practice? Delay: \nHow long must the programmer sit idle while wait\u00ading for the tool to .nish a computation? Whole-Program: \nDoes the tool apply to library code, with\u00adout having application code available? Does it apply to 1 class \nUnifyNode: 2 .eld parent = this 3 .eld rank = 0 4 .eld prty = <empty map> .eld isNamespace = false 6 \n7 def rep(): 8 if parent != this: 9 parent = parent.rep() return parent 11 12 class Uni.er: 13 .eld \nqueue = <empty queue> 14 def unify(x,y): 16 x = x.rep() 17 y = y.rep() 18 if x == y: 19 return if x.rank \n< y.rank: 21 swap x, y 22 else if x.rank == y.rank: 23 x.rank += 1 24 y.parent = x x.isNamespace |= y.isNamespace \n26 if x.prty.size < y.prty.size: 27 swap x.prty, y.prty 28 for k,v in y.prty: 29 if k in x.prty: unifyLater(x.prty[k], \nv) 31 else: 32 x.prty[k] = v 33 y.prty = null 34 def unifyPrty(x,k,y): 36 x = x.rep() 37 if k in x.prty: \n38 unify(x.prty[k], y) 39 else: x.prty[k] = y 41 42 def unifyLater(x,y): 43 queue.add(x,y) 44 def complete(): \n46 while queue is not empty: 47 (x,y) = queue.pop() 48 unify(x,y) incomplete application code, such as, \ncode under devel- Figure 4. Python-like pseudo-code implementation of the opment or applications without \nlibraries? augmented union-.nd data structure. 4http://www.brics.dk/jsrefactor/plugin.html  We collected \n24 JavaScript applications for use as bench\u00admarks. Third-party libraries are used in 19 of the applica\u00adtions, \nconstituting a total of 9 distinct libraries (some li\u00adbraries are used by more than one application) \nthat we also include as benchmarks. Of these 24 applications, 10 were taken from the 10k Event Apart \nChallenge,5 10 were taken from Chrome Experiments,6 and 4 were found at GitHub.7 When selecting benchmarks, \nwe aimed for diversity in com\u00adplexity, functionality, and use of libraries. The benchmark collection \nis available online.8 To evaluate our technique along the above metrics, we perform a series of experiments \non these applications. The benchmarks and experimental results are shown in Table 1. In the following, \nwe describe which experiments were used to evaluate the various metrics, and the meaning of the columns \nin Table 1. 4.1 Manual Effort For both our technique and search-and-replace, the total number of questions \nasked during a refactoring is indepen\u00addent of whether the programmer answers yes or no to each question. \nIt is also independent of the new name for the iden\u00adti.er. This means there is a simple way to compute \nthe num\u00adber of questions each tool will ask, given the name of the property to rename. For our approach, \nwe can count the num\u00adber of groups of related tokens with the given name, and for search-and-replace \nwe can count the number of tokens. To\u00adkens that refer to local variables are ignored in this statistic. \nRenaming tools are typically invoked by selecting an identi.er token in the editor and then choosing \nthe rename action from a menu or using a shortcut. There is no reason to ask a question for this initially \nselected token, so we subtract one question per property name to represent this question that is answered \nfor free. Thus, the tool may potentially ask zero questions to complete a refactoring. However, we shall \ndisregard properties that are only mentioned once in the source code, so search-and-replace will by design \nalways ask at least once. We also disregard the special property name prototype since it is easily recognized \nas a built-in property and is thus not renamed in practice. To measure effort, we compare the number \nof questions issued per benchmark by search-and-replace versus our ap\u00adproach, simulating one rename refactoring \non each distinct property name appearing in the benchmark. Application de\u00advelopers are unlikely to want \nto rename properties inside third-party libraries, and vice versa, so we separate the set of renaming \ntasks for application code and library code. How\u00adever, we allow our refactoring tool to analyze the applica\u00adtion \nand library code together as a whole, to avoid interfer\u00ad 5http://10k.aneventapart.com/ 6http://www.chromeexperiments.com/ \n7http://www.github.com/ 8http://www.brics.dk/jsrefactor/renaming-benchmarks.zip Figure 5. Number of questions \nasked by search-and-replace (x axis) versus our tool (y axis). Each point represents a property name \nin a benchmark. Figure 6. Percentage of identi.er tokens (y axis) belonging to groups of size N (segment). \nence with the whole-program metric that we address in Sec\u00adtion 4.4. In Figure 5, each simulated renaming \nis plotted as a point positioned according to the number of questions asked by search-and-replace and \nby our tool, respectively. The diago\u00adnal highlights the place where the two tools are equally ef\u00adfective. \nThe plot has been clamped to a limit of 100 ques\u00adtions, since the majority of points lie in this range. \nThe most extreme outliers excluded from the plot are the property names c and f in pdfjs, which require \n6,092 questions with search-and-replace and 14 questions with our tool. A total of 4,943 renamings were \nsimulated in this experiment. Figure 6 shows how tokens are distributed in groups of various sizes during \nthe simulated renamings. To estimate the effect per benchmark, we sum the total number of questions for \neach property name in each bench\u00admark. In Table 1, the effect column denotes the reduced pro\u00adgrammer \neffort, based on this estimate. It is computed using this formula: #search-replace-questions -#our-questions \neffect = #search-replace-questions  Figure 7. Number of property names (y-axis) renamable with =3questions, \nrelative to the number of candidate prop\u00aderty names in each benchmark. The bottom graph focuses on the \nset of property names that search-and-replace cannot re\u00adname with =3questions, showing how many can be \nhandled with our technique using =3questions. Thus, if our tool asks the same number of questions as \nsearch-and-replace, we get an effect of 0%, while if we ask no questions at all, we get an effect of \n100%. The effect is in most cases between 40% and 70% but reaches 17% and 97% in extreme cases. The average \nand median effect are both approximately 57.1%. Two thirds of the benchmarks show an effect of more than \n50%. Each library that is used by multiple applications is an\u00adalyzed together with each client application. \nIn each case, we observe that the effect is exactly the same regardless of which application is used. \nAlthough this indicates a signi.cant reduction in the ef\u00adfort required to perform renamings, it may be \nthat the num\u00adber of questions remains so high that programmers deem the refactoring too costly and choose \nto omit an otherwise desirable renaming altogether. If we regard renaming tasks that require more than \nthree questions as hard and renam\u00ading tasks that require at most three as easy, we can consider how many \nrenaming tasks are easy when using search-and\u00adreplace versus our tool. Figure 7 (top) shows how many \nproperties can be re\u00adnamed using at most three questions. All benchmarks ben\u00ade.t from the new technique, \nand in many cases we observe a substantial increase in the number of easy renamings. In 7spade jslinux \n Figure 8. Number of property names (y-axis) renamable with =N questions (x-axis). The horizontal line \nindicates the number of candidate property names in the benchmark. Figure 7 (bottom) we focus on the \nproperty names for which search-and-replace requires more than three questions. This plot demonstrates \nthat many of the renamings that are hard when using search-and-replace are easy when using our tool. \nFor two thirds of the benchmarks, more than half of the hard renamings become easy. In Figure 8 we vary \nthe number of questions allowed, while focusing on two benchmarks, one with low and one with high effect. \nWhile the bound of three questions in Fig\u00adure 7 was arbitrary, these .gures indicate similar improve\u00adments \nfor other bounds as well. These .gures indicate that even programmers who are un\u00adwilling to invest much \ntime in renaming tasks may bene.t from our tool. In summary, this part of the evaluation indi\u00adcates a \nsubstantial reduction of programmer effort compared to traditional search-and-replace.  4.2 Soundness \nAs described in Section 3, our program analysis is theo\u00adretically unsound, but designed to work soundly \non com\u00admon programming patterns. We de.ne a failure as a situ\u00adation where unsoundness occurs in practice, \nthat is, where our technique classi.es two identi.er tokens as related, even though they were not intended \nto refer to the same property. To estimate how likely this is to happen, we used a combi\u00adnation of dynamic \nanalysis and manual inspection. We exercise instrumented versions of each application, including the \nlibraries they use, and record aliasing informa\u00adtion at runtime. In these executions, we manually provide \nuser input to each application, aiming to use all of its fea\u00adtures at least once. High coverage is desirable, \nas it reduces the amount of manual inspection we must do afterward. Given two expressions e1.f and e2 \n.f , if e1 and e2 evalu\u00adate to the same object at some point in the execution, then we have strong evidence \nto support that the two f tokens should indeed be related. If our technique classi.es these as related, \nwe therefore consider the classi.cation as correct.  wh ole isolated fragme nted Applications lines \nlibraries used effect failure .effect failure .effect failure 7spade airstrike bpmster bytesjack .lm-buffr \nnspiration phrase space-mahjong sun-calc top-of-the-world ball-pool .uid-simulation google-gravity htmleditor \nminesweeper procedural-.ower sketchtoy texter webgl-water ztype impress.js demo jsgb jslinux pdfjs 959 \n1,508 990 685 203 575 176 344 589 158 347 484 6,621 1,835 562 2,215 959 246 1,627 3,581 448 3,815 10,054 \n38,958 prototype jquery jquery, typekit jquery, typekit jquery, typekit jquery, typekit jquery, typekit \njquery, typekit box2d, prototype codemirror, esprima jquery dat.gui jquery, show_ads dat.gui show_ads \ntwitter_widgets show_ads 29.3% 68.5% 49.6% 52.7% 29.3% 35.1% 60.4% 17.2% 67.1% 49.1% 55.5% 97.0% 71.1% \n43.9% 90.8% 67.9% 61.0% 64.3% 57.4% 72.3% 57.1% 44.9% 80.4% 72.5% ------------------------ ---0.41 pp \n-0.15 pp --0.70 pp ------------------ ------------------------ --0.03 pp -0.63 pp ---1.60 pp -------0.05 \npp -------0.06 pp ---0.27 pp -0.02 pp --X --------------------- Libraries jquery typekit prototype box2d \nesprima codemirror dat.gui show_ads twitter_widgets 6,098 1,359 4,954 6,081 3,074 5,008 2,149 590 2,965 \n48.4% 51.1% 48.7% 72.1% 63.9% 52.0% 58.8% 54.1% 41.7% ----X ---- --------- ----(X) ---- -0.03 pp -0.04 \npp -0.15 pp -0.03 pp --0.03 pp ---0.22 pp X ---(X) ---- Table 1. Experimental results. The effect column \ndenotes reduced programmer effort (higher is better). The .effect columns are in percentage points (pp), \nrelative to the effect column (zero is better). An X denotes a potential failure discussed in the text. \nThe symbol - indicates zero. In situations where our tool classi.es two tokens as re\u00adlated, but the dynamic \nalias information does not provide evidence supporting this relationship, we resort to manual inspection. \nThis may happen because of incompleteness in the concrete execution, or more commonly, because of meta\u00adprogramming \npatterns in which properties are copied be\u00adtween objects, which our dynamic analysis cannot detect. This \nexperiment uncovers a single potential failure, which takes place in the esprima library a JavaScript \nparser writ\u00adten in JavaScript. This library represents abstract syntax trees with objects, and all such \nobjects have a type property de\u00adnoting the type of the node it represents. Different types of nodes occasionally \nhave same-named properties; a property name, such as, value is quite common among these. How\u00adever, an \nesprima developer might hypothetically want to re\u00adname the value property for some AST nodes, but not \nall of them. Such a renaming could be done consistently, but our technique will not permit such a refactoring, \nbecause dif\u00adferently typed AST nodes are occasionally returned from within the same function, hence regarded \nas same-typed. This potential failure is marked with an X in the leftmost failure column in Table 1. \nExcept for this single case, the experiments con.rm that our analysis is sound in practice when the complete \nprogram code is available.  4.3 Delay For each application, we measure the time required to ana\u00adlyze \nthe application code together with its library code. We analyze each benchmark eleven times, discard \nthe timings from the initial warm-up run, and record the average time of the other ten runs.  The analysis \ntakes less than one second in every case, with 780 milliseconds for pdfjs being the slowest. Alto\u00adgether, \nour implementation handles an average of around 50,000 lines per second on a 3.00 GHz PC running Linux. \nWhen the user initiates a renaming, he must .rst enter a new name for the renamed property. The parsing \nand anal\u00adysis do not depend on this new name and can therefore be performed in the background while the \nuser is typing. As long as the user takes more than one second to type in the new name, there should \ntherefore be no observable delay in practice when using our renaming technique.  4.4 Whole-Program For \nthe experiments described in the preceding sections, our static analyzer has an entire application available. \nHowever, library developers will typically not have a range of client applications ready for when they \nwant to rename something. To measure how well our tool works for library code, we repeat the experiment \nfrom Section 4.1, except that each li\u00adbrary is now analyzed in isolation. As result, we observe no difference \nin the effect for any library compared to the previ\u00adous experiment, in which the application code was \nincluded. This is indicated in the isolated/.effect column of Table 1. For completeness, we also did \nthe converse experiment: we analyze the applications without their libraries, even though application \ndevelopers will typically have a copy of their libraries available. For three applications, the effect \ndiminishes slightly, but never by more than a single per\u00adcentage point. In the most pronounced case, \nthe effect drops from 35.1% to 34.6% in the nspiration application. These experimental results indicate \nthat our approach is effective without a whole-program assumption. We also want to support refactoring \nof code that is under development, which we call incomplete code. Such code might have radically different \ncharacteristics than .nished code. To estimate how well our tool works on incomplete code, once again \nwe repeat the experiment from Section 4.1, ex\u00adcept now with random pieces of code removed from each benchmark. \nWe say the source code has been fragmented. Concretely, we replace random function bodies with empty \nbodies, which simulates incomplete code while avoiding in\u00adtroduction of syntax errors. For each benchmark, \nwe pro\u00adduce ten fragmented versions randomly, each being roughly half the size of the original version. \nFor each fragmented version, we then compute groups of related identi.er tokens and compare these with \nthe corresponding groups from the original version. We then record which token pairs were no longer considered \nrelated after fragmentation and compute the difference in effect accordingly (while only considering \ntokens that were not removed). As result, the effect diminishes for seven applications and six libraries, \nin each case only slightly. The largest change is for a fragmented version of nspiration, in which the \neffect drops from 69.8% to 66.7% (again, for identi.er tokens that were not removed in the fragmentation). \nThe fragmented/.effect column in Table 1 shows the reduction in effect, averaged over the ten fragmented \nversions. The numbers demonstrate that our analysis is robust, even when major parts of the code are \nomitted. This experiment also exposes a type of unsoundness caused by our namespace detection mechanism \ndiscussed in Section 3.4. The benchmarks bpmster and jquery both contain constructor functions in namespace \nobjects. After fragmentation, all the new calls that allowed us to classify these functions as constructors \nwere occasionally deleted, causing the receiver type inference phase to treat the con\u00adstructors as methods. \nThis in turn causes some unrelated to\u00adkens to be classi.ed as related. As discussed in Section 3.4, the \nnamespace detection uses a whole-program assumption, which surfaces in these few cases where the relevant \ncode is not available to the analysis. In principle, these failures could be averted by allowing the \nprogrammer to provide a single namespace annotation to each benchmark, marking a few global variables \nas namespaces.  4.5 Threats to Validity The validity of these encouraging experimental results may be \nthreatened by several factors. Most importantly, the sim\u00adulated refactorings may not be representative \nof actual use cases. An alternative evaluation approach would be to con\u00adduct extensive user studies, \nbut that would be major endeav\u00adour in itself, which is also the reason why most literature on refactoring \nalgorithms settle for automated experiments. The fragmented code we produce might not be represen\u00adtative \nof code under development. Revision histories from version control systems might provide a more faithful \nrepre\u00adsentation of incomplete code, but we did not have access to such data for most of our benchmarks. \nFinally, our selection of benchmarks might not represent all mainstream JavaScript coding styles, although \nthey have been selected from different sources and vary in complexity, functionality, and use of libraries. \nAll our benchmarks are browser-based. However, our approach works without any model of the host environment \nAPI, so it seems reasonable that it should work well also for other platforms. 5. Related Work In previous \nwork [3], we showed that points-to information can be used to perform various refactorings on JavaScript \nprograms, fully automatically and with safety checks to en\u00adsure that program behavior is preserved. That \ntechnique, however, has some practical limitations regarding scalability and whole-program assumptions \nof the points-to analysis, as discussed in the introduction. Our new more pragmatic ap\u00adproach requires \nmore manual effort from the user, but applies to a wider range of codebases. Fast alias analyses in the \nstyle of Steensgaard [11] use union-.nd data structures to ef.ciently .nd aliased expres\u00adsions in a program. \nOur type inference system is inspired by this kind of analysis, but as discussed in Section 3, it is \ntechnically not an alias analysis, since we occasionally want non-aliased expressions to have the same \ntype.  Several related static analysis techniques have been de\u00adveloped speci.cally for JavaScript. The \ntype analysis by Jensen et al. [6] is based on .ow-sensitive data.ow analy\u00adsis, Vardoulakis [13] uses \na pushdown .ow analysis to infer type information, and the .ow analysis by Guha et al. [5] relies on \nreasoning about control .ow. The notion of types we use here is different, and the application of our \nanaly\u00adsis is not type checking but refactoring. Sridharan et al. [10] have made advancements toward analyzing \nlibrary code with points-to analysis, and Madsen et al. [7] have devised a prac\u00adtical technique for analyzing \napplication code without in\u00adcluding library source code or modeling external APIs. None of all these \napproaches scale to JavaScript programs of the size we consider here. Moreover, these analyses are conser\u00advative \nin the direction opposite of what we want: what they classify as spurious .ow translates into unsoundness \nin our setting, and vice versa. 6. Conclusion We have presented a technique for semi-automatic refactor\u00ading \nof property names in JavaScript programs, based on a static analysis for .nding related identi.er tokens. \nThe anal\u00adysis is easy to implement, and our experiments demonstrate that it is fast enough to be usable \nin IDEs. By simulating renaming tasks, our technique reduces the manual effort re\u00adquired to rename object \nproperties by an average of 57% compared to the search-and-replace technique in existing JavaScript IDEs. \nThis substantial improvement diminishes only slightly when used on incomplete code, and seemingly not \nat all when used on libraries without client code. Although the analysis is theoretically unsound, the \nexper\u00adiments show that it is sound in practice, except for a few rare cases, most of which could be eliminated \nentirely with sim\u00adple source code annotations. Our technique is based on a set of typing rules reminis\u00adcent \nof alias analysis. While we have focused on renaming so far, we would like to explore further applications \nof these typing rules in future work, such as, other refactorings, code completion, and documentation, \nto provide additional IDE support for JavaScript programmers. Acknowledgements This work was supported \nby the Dan\u00adish Research Council for Technology and Production. We thank Max Sch\u00e4fer for his comments \non a draft of this paper. References [1] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction \nto Algorithms. MIT Press, 2009. [2] ECMA. ECMAScript Language Speci.cation, 5th edition, 2009. ECMA-262. \n[3] A. Feldthaus, T. Millstein, A. M\u00f8ller, M. Sch\u00e4fer, and F. Tip. Tool-supported refactoring for JavaScript. \nIn Proc. ACM SIGPLAN Conference on Object-Oriented Programming, Sys\u00adtems, Languages, and Applications \n(OOPSLA), October 2011. [4] M. Fowler. Refactoring: Improving the Design of Existing Code. Addison-Wesley, \n1999. [5] A. Guha, C. Saftoiu, and S. Krishnamurthi. Typing local control and state using .ow analysis. \nIn Proc. 20th European Symposium on Programming (ESOP), 2011. [6] S. H. Jensen, A. M\u00f8ller, and P. Thiemann. \nType Analysis for JavaScript. In Proc. 16th International Static Analysis Symposium (SAS), volume 5673 \nof LNCS. Springer-Verlag, August 2009. [7] M. Madsen, B. Livshits, and M. Fanning. Practical static anal\u00adysis \nof JavaScript applications in the presence of frameworks and libraries. MSR-TR-2012-66, Microsoft Research, \n2012. [8] E. R. Murphy-Hill, C. Parnin, and A. P. Black. How we refactor, and how we know it. IEEE Trans. \nSoftware Eng., 38(1):5 18, 2012. [9] D. B. Roberts, J. Brant, and R. Johnson. A Refactoring Tool for \nSmalltalk. Theory and Practice of Object Systems, 3(4): 253 263, 1997. [10] M. Sridharan, J. Dolby, S. \nChandra, M. Sch\u00e4fer, and F. Tip. Correlation tracking for points-to analysis of JavaScript. In Proc. \n26th European Conference Object-Oriented Program\u00adming (ECOOP), 2012. [11] B. Steensgaard. Points-to analysis \nin almost linear time. In Proc. 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages \n(POPL), 1996. [12] M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar, B. P. Bai\u00adley, and R. E. Johnson. \nUse, disuse, and misuse of automated refactorings. In Proc. 34th International Conference on Soft\u00adware \nEngineering (ICSE), 2012. [13] D. Vardoulakis. CFA2: Pushdown Flow Analysis for Higher-Order Languages. \nPh.D. thesis, Northeastern University, 2012.   \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Modern IDEs support automated refactoring for many programming languages, but support for JavaScript is still primitive. To perform renaming, which is one of the fundamental refactorings, there is often no practical alternative to simple syntactic search-and-replace. Although more sophisticated alternatives have been developed, they are limited by whole-program assumptions and poor scalability.</p> <p>We propose a technique for semi-automatic refactoring for JavaScript, with a focus on renaming. Unlike traditional refactoring algorithms, semi-automatic refactoring works by a combination of static analysis and interaction with the programmer. With this pragmatic approach, we can provide scalable and effective refactoring support for real-world code, including libraries and incomplete applications. Through a series of experiments that estimate how much manual effort our technique demands from the programmer, we show that our approach is a useful improvement compared to search-and-replace tools.</p>", "authors": [{"name": "Asger Feldthaus", "author_profile_id": "81490694597", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "P4290369", "email_address": "asf@cs.au.dk", "orcid_id": ""}, {"name": "Anders M&#248;ller", "author_profile_id": "81100071429", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "P4290370", "email_address": "amoeller@cs.au.dk", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509520", "year": "2013", "article_id": "2509520", "conference": "OOPSLA", "title": "Semi-automatic rename refactoring for JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2509520"}