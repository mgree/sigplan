{"article_publication_date": "10-29-2013", "fulltext": "\n Effective Race Detection for Event-Driven Programs Veselin Raychev Martin Vechev Manu Sridharan ETH \nZ\u00a8ETH Z\u00a8IBM T.J. Watson Research Center urich urich veselin.raychev@inf.ethz.ch martin.vechev@inf.ethz.ch \n Abstract 1. Introduction Like shared-memory multi-threaded programs, event-driven programs such as \nclient-side web applications are suscep\u00adtible to data races that are hard to reproduce and debug. Race \ndetection for such programs is hampered by their per\u00advasive use of ad hoc synchronization, which can \nlead to a prohibitive number of false positives. Race detection also faces a scalability challenge, as \na large number of short\u00adrunning event handlers can quickly overwhelm standard vector-clock-based techniques. \nThis paper presents several novel contributions that ad\u00address both of these challenges. First, we introduce \nrace cov\u00aderage, a systematic method for exposing ad hoc synchroniza\u00adtion and other (potentially harmful) \nraces to the user, signif\u00adicantly reducing false positives. Second, we present an ef\u00ad.cient connectivity \nalgorithm for computing race coverage. The algorithm is based on chain decomposition and lever\u00adages the \nstructure of event-driven programs to dramatically decrease the overhead of vector clocks. We implemented \nour techniques in a tool called EV E N T-RAC E R and evaluated it on a number of public web sites. The \nresults indicate substantial performance and precision improvements of our approach over the state-of-the-art. \nUs\u00ading EV E N T RAC E R, we found many harmful races, most of which are beyond the reach of current techniques. \nCategories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: Software/Program Veri.cation; D.2.5 \n[Software Engineering]: Testing and Debugging Testing tools; F.3.1 [Logics and Meaning of Programs]: \nSpecifying and Verify\u00ading and Reasoning about Programs General Terms Algorithms, Veri.cation Keywords \nAsynchrony; Concurrency; Nondeterminism; Race Detection; Web Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. Copyrights for components of this work owned by others than ACM must \nbe honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, USA. Copyright c &#38;#169; \n2013 ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509538 Event-driven \napplications are vulnerable to concurrency er\u00adrors similar to those in standard multi-threaded applications. \nIn a typical event-driven program, event handlers are exe\u00adcuted by an event dispatcher as a result of \nevent .ring. Event handlers usually execute atomically in a single thread, so handler code can assume \nthat no other handlers execute con\u00adcurrently. However, such systems allow for events to be .red non-deterministically \n(due to user actions, I/O timing, etc.), which may cause the corresponding event handlers to run in a \nnon-deterministic order. This non-determinism can cause serious errors when event handlers share mutable \nstate. Client-side web applications are an important class of event-driven programs susceptible to such \nerrors, as dis\u00adcussed in recent work [15]. Modern web applications make extensive use of asynchrony, \nvia so-called AJAX requests and also of asynchronous code loading to speed up per\u00adceived page load time. \nThis asynchrony can lead to non\u00addeterministic errors, which can have severe consequences for users: e.g., \nthe Hotmail email service was temporarily bro\u00adken in the Firefox web browser due to a data race, potentially \ncausing loss of message content [11]. The web platform provides few synchronization primi\u00adtives to programmers. \nHence, web applications are forced to coordinate event handler execution via standard shared variables, \ni.e., ad hoc synchronization. The atomic execution of event handlers makes such coordination safe. However, \nlacking knowledge of this synchronization, existing dynamic race detectors [4, 15, 16] report an overwhelming \nnumber of races on web applications, exceeding 3000 for some of the sites we tested. The vast majority \nof these races are harm\u00adless: they are either used for ad hoc synchronization or are infeasible. Manual \nexamination of such a large set of races is nearly impossible, particularly due to the complex control \n.ow typically found in event-driven programs. In this paper, we present two advances in concurrency analysis \nfor event-driven applications, making dynamic race detection for such applications more practical. We \n.rst in\u00adtroduce the notion of race coverage and show how it can be used to quickly expose ad hoc synchronization. \nIntuitively, race a covers race b iff treating a as synchronization elim\u00adinates b as a race. Importantly, \nuncovered races are de.ned and computed in a way which guarantees that both execution orderings of the \ncorresponding memory accesses are possi\u00adble. Since synchronization is employed to handle multiple possible \nexecution orderings, this guarantee makes it very likely that races on synchronization variables will \nbe uncov\u00adered. By inspecting uncovered races .rst, a user can quickly identify races on synchronization \nvariables and completely avoid inspecting false positives covered by those races. Our evaluation found \nthe set of variables with uncovered races to be 14X smaller on average than the set of all variables \nwith races, and we found that many uncovered races were in fact harmful.  Second, we present a dynamic \nanalysis algorithm that ef\u00ad.ciently computes races in event-driven programs by keep\u00ading the width of \nits vector clocks much smaller than the standard approach. Our technique employs chain decompo\u00adsition \n[7] to discover cases where different event handlers can safely re-use the same vector clock slot. This \noptimiza\u00adtion dramatically reduces the sizes of the vector clocks in practice, signi.cantly improving \nperformance. Using this algorithm as a building block, we present a second algo\u00adrithm which ef.ciently \ndiscovers all variables with uncov\u00adered races in an execution trace. To further reduce triage effort \nfor races in web applica\u00adtions, we performed an extensive study of thousands of races and developed six \n.lters for common types of harmless or synchronization races. In our experiments, the .lters addi\u00adtionally \n(beyond coverage) reduced the number of races to inspect by a factor of 2.5. We implemented our dynamic \nanalysis by .rst modifying the WebKit browser [20] to log a trace of relevant events from a web application \nrun to disk. Then, our tool ana\u00adlyzes the log, computes coverage, classi.es discovered races based on \nour .lters, and displays results in a rich browser\u00adbased user interface. In our experimental evaluation, \nwe ran the tool on a wide variety of web sites. Despite the obfus\u00adcated code on many of the sites, we \nwere able to inspect the uncovered races and manually identify many harmful races and synchronization \nvariables. Using EV E N T RAC E R, we have found harmful races on the front pages of 21 For\u00adtune 100 \ncompanies. Our tool is usable by web developers, scalable to real web applications, and available open \nsource at http://www.eventracer.org. We believe that the techniques described in this work may be applicable \nin other settings which involve heavy user interface manipulations (e.g. Android, iOS). Main Contributions \nThe contributions of this work are: We introduce the concept of race coverage, which en\u00adables identi.cation \nof ad hoc synchronization and greatly reduces the number of false positive races reported in event-driven \nprograms.  We present a fast dynamic race detection algorithm based on vector clocks which uses chain \ndecomposition to re\u00adduce the width of the used vector clocks signi.cantly.  Based on the above algorithm, \nwe present a fast algorithm that computes uncovered races in an execution of an event-driven program. \n We describe a set of .lters for common harmless or synchronization races in web applications.  We \npresent an extensive evaluation of race coverage and .lters on a large set of web sites. Our experimental \nresults con.rm that variables with uncovered, un.ltered races are more than 35 times fewer than all variables \nwith races. We also found 75 harmful races in the set of web sites which we analyzed.  The paper is \norganized as follows. Section 2 motivates the problem and describes a core language that enables us to \ncleanly capture the essential features of event-driven pro\u00adgrams. It also shows how to adapt existing \nstate-of-the-art dynamic race detectors to our language and discusses their limitations. Section 3 formalizes \nthe concept of race cov\u00aderage and states an important theorem on the feasibility of uncovered races. \nSection 4 discusses ef.cient connectivity algorithms for .nding uncovered races. In Section 5, we dis\u00adcuss \nour implementation in WebKit as well as our race .l\u00adters. Experimental results are discussed and summarized \nin Section 6. Finally, Section 7 discusses related work and Sec\u00adtion 8 concludes. 2. Setting In this \nsection, we .rst give a small example web application to motivate our techniques. Then, we de.ne a simple \nparallel language called Event which enables us to cleanly model the essential concepts necessary for \nour analysis. We also de.ne necessary preliminaries such as races and vector clocks. Finally, we show \nhow to adapt current state-of-the-art race detection algorithms to Event, and discuss their limitations. \n 2.1 Example Consider the example in Fig. 1. The web page has an input button, two script nodes with \nJavaScript code, and many other elements which have been elided. Web browsers inter\u00adleave HTML parsing \nwith handling of other events like user actions; here, this means that the button can be clicked as soon \nas the input element is parsed, potentially before or between execution of the other scripts. This leads \nto po\u00adtential timing-dependent behaviors: If the button is clicked before the .rst script runs, the \nf function invoked by the button s onclick handler will not yet have been declared, causing a JavaScript \ninter\u00adpreter crash. The interpreter crash is not directly visible to the user; however, the user will \nsee no effect from the button click, a usability bug.  If the click occurs between execution of the \ntwo scripts, \"not ready\" will be displayed, as init is still false.   <html >< body > < i n p u t t \ny p e = \" b u t t o n \" i d = \" b 1 \" o n c l i c k = \" j a v a s c r i p t : f ( ) \" > . . . < ! --m \na n y e l e m e n t s --> Browser User <script > function f() { Parse input type= button if (init) \na l e r t ( y . g ) ;  show button e l s e a l e r t ( \" n o t r e a d y \" ) ; } click v a r i n i \nt = f a l s e , y = n u l l ; f() -crash! </ script > . . . Parse script <script > de.ne f y={g: 42 \n}; init = true ; </ script > </ body ></ html > Figure 1. Example web page with both a harmful race \nand ad hoc synchronization. The trace on the right shows the harmful interleaving. If the click occurs \nafter the two scripts run, 42 will be displayed. Ideally, a race detection tool would ef.ciently expose \nissues like the potential crash in this example to the user, without showing too many false positives. \nIn our work we focused on building a dynamic race detector which works by taking as input a program trace \nand then tries to .nd (harmful) races between concurrent operations in that trace. We shall discuss challenges \nin building such a tool at the end of the section, after introducing some terminology.  2.2 Language \nNext, we introduce a simple parallel language, called Event as shown in Fig. 2. This language cleanly \ncaptures the es\u00adsential features of event-driven applications (like web appli\u00adcations) that are necessary \nfor our analysis. Sections 3 and 4 formulate our race detection techniques for Event programs, and then \nSection 5.1 shows in more detail how a web appli\u00adcation execution trace can be translated to a trace \nof an Event program. A program in Event consists of a top-level event action, which can read or write \nshared variables and create (fork) other event actions. This language is more restricted than a general \nfork-join parallel language. In particular, an event action can begin execution only following the completion \nof another event action, and all event actions execute atom\u00adically, without interruption. However, it \nis still possible to have multiple event actions available for execution at any point in the program \nexecution, and the choice for which of these actions to schedule next is non-deterministic. The sequential \nparts of the language such as de.nitions of condi\u00adtionals, loops and expressions are standard and are \nomitted for brevity. We consider only the following relevant opera\u00adtions: S ::= S; S | rd(t, x) | wr(t, \nx) |f ork(t, u, E ventAction) E ventAction ::= J oins; begin(t); S; end(t) J oins ::= J oins; J oins \n| j oin(t, u) P rogram ::= E ventAction Operation ::= rd(t, x) | wr(t, x) | begin(t) | end(t) |f ork(t, \nu, E ventAction) | j oin(t, u) t, u . E ventI ds x . V ars a, b . Operation Figure 2. The Event language \n rd(t, x) denotes that event action t performs a read of a shared variable x. Similarly, wr(t, x) denotes \nwriting to x.  f ork(t, u, E ventAction) means that event action t forks an event action u with the \noperations that u must execute speci.ed in E ventAction.  j oin(t, u) denotes that event action t must \nwait until another event action u completes.  begin(t) and end(t) denote the beginning and ending of \nan event action. At any time, up to one event action can be executing. That is, event action execution \nis atomic. Note that in our language, all reads, writes and forks always occur between begin and end. \n As an example of translating a web program to Event, consider again the example in Fig. 1. In web programs, \nonly parsing of individual HTML tags is atomic, to enable a quick response to interleaved events like \nuser clicks. For Fig. 1, the parsing of the input tag and each script tag gets translated to a separate \nevent action. Element ordering is captured by adding appropriate f ork operations to tag-parsing event \nactions; for the example, the parsing event action for the input tag forks the script-parsing event action. \nAn event action represents event handler execution for each user click on the button, and such actions \njoin on the input-parsing event action (as the button must be present to be clicked). The variable accesses \nin the scripts translate to wr and rd operations in the event actions executing the scripts. We also \ngenerate a wr operation for creation of the f function, and a rd operation for the access of f from the \nbutton s onclick handler. Fig. 3 shows an execution of the application from Fig. 1 translated to Event. \nIn this execution, the web application is loaded and one click of the button with id b1 is performed. \nSome details of the full translation are omitted for clarity (e.g. parsing of the html or body tags generates \nevent actions that are omitted). In the execution in Fig. 3, event action 4 is a click that happens after \nthe script in event action Figure 3. Example trace for the program in Fig. 1 translated to the Event \nlanguage. Some details are missing for clarity.    2 has executed. However, the click could have happened \nbefore the script is parsed, leading to an exception because javascript:f() would then call an unde.ned \nfunction. Our tool detects this race by performing a dynamic analysis of a single execution trace (i.e. \nlike the one in Fig. 3).  2.3 Order, Races, and Vector Clocks The execution of a program is de.ned via \ntraces, where a .nite trace p = a0 \u00b7a1 \u00b7...\u00b7an . Operation* (with n = 0) is a sequence of operations \nin our language. Here, we abstract away the con.gurations (states) of the program and only keep the operations. \nWe use the notation [ P] to denote the set of all traces for a given program P. Trace Order For a given \ntrace p, if operation a occurs before operation b in p, we say that a <p b. To simplify exposition we \nassume that each operation appears only once in the trace (if it appears multiple times, we can always \nassign a unique identi.er to each appearance). Similarly, we say that event action t precedes event action \nu in the trace, denoted t <p u (we overload the operator), if begin(t) <p begin(u). Happens-Before Given \na trace p, the happens-before rela\u00adtion j over pairs of event actions t and u in p is the minimal transitively \nclosed relation, such that t j u holds if t = u, fork(t, u, ) . p, or join(u, t) . p (here we used to \nmean any value is allowed). We denote the event action of an oper\u00adation a by ev(a). Given a trace p, \na happens-before relation between two operations a and b occurring in the trace, de\u00adnoted ajb (again, \nwe overload the operator), is true if: ev(a) = ev(b) and ev(a)jev(b), or  ev(a) = ev(b) and a <p b \n The j relation (for operations) is transitive due to transitivity of j (for event actions) and <p . \nWhen a j b is false we write a jb. De.nition 2.1 (Race). Given a trace p and operations a and b where \na <p b, a race R = (a, b) is a pair where both operations access the same variable, at least one is a \nwrite and a jb. Intuitively, if a trace contains a race R, it means that the order between racing operations \nmay change in other traces. Depending on the kind of operations participating in the race, we refer to \nit as a read-write, write-read or a write-write race. Vector clocks One approach for capturing the happens\u00adbefore \nrelation is using vector clocks [10]. A vector clock V C : T . Nholds a natural number for each element \nin T . An important function on vector clocks is the join function ( U ). Additionally, we de.ne a minimal \nelement (.V ) and a function inct for incrementing the t-th component of a vector clock (similar notation \nappears elsewhere [4]): V C1 U V C2 = .t.max(V C1(t), V C2(t)) .V = .t.0 inct(V C) = .u. if t = u then \nV C(u) + 1 else V C(u) For simplicity, we de.ne join on a set of vector clocks {V Ci} by U{V Ci} to be \nV C1 U V C2 U ... for a non-empty set {V Ci} and .V otherwise.  2.4 Adapting Existing Online Dynamic \nRace Detectors A na\u00a8ive approach to applying existing vector-clock based online dynamic race detectors \nto our language is to create a happen-before order between begin and end operations encountered in the \ntrace (essentially, mapping these opera\u00adtions to global lock/unlock operations). However, while this \ntranslation maintains the atomic execution of event actions, no races will be reported as all operations \nwill be treated as ordered by a standard race detector. Another, more fruitful approach is to: i) avoid \nintroducing happens-before arcs be\u00adtween begin and end operations of different event actions, and ii) \nonly explore traces where event actions do not in\u00adterleave. In this way, the race detector will not introduce \nun\u00adwanted orderings and it will not observe infeasible interleav\u00adings. Limitations Two problems arise \nwhen applying online race detectors to event-driven programs, which our tech\u00adniques address: Too many \nraces In our experiments, we found that applying race detectors to web programs directly leads to too \nmany races reported by the analysis (in the thousands). Many of these races implement ad hoc synchronization \nor are infeasible. For Fig. 1, the init variable is used for ad hoc synchronization, to ensure y is initialized \nbefore it is dereferenced. However, unaware of this synchronization, a standard race detector would report \nan infeasible race for the accesses to y.  Number of threads A state-of-the art detector such as FA \nS T-TR AC K [4] keeps track of vector clocks for each thread and for some of the variables. In FA S T \nTR AC K, a vector clock requires O(n) space and vector clock operations require O(n) time, where n is \nthe number of threads. We found that for our programs, n (the number of event actions) grows into the \nthousands, hurting scalability. The number of event actions can grow very quickly due to .ne-grained \natomic actions, e.g., the parsing of each HTML tag (see Section 2.2) and short-running event han\u00addlers. \nThe concepts presented in the next section (Section 3) aim to address the .rst limitation. The second \nlimitation is addressed in Section 4. 3. Race coverage In this section we address a key problem which \narises in race detection: the race detector produces too many races to be practically useful. This problem \nis signi.cantly exacerbated for programs in languages such as Event, as Event has no synchronization \nprimitives except joining to other event ac\u00adtions. This means that any synchronization between event \nactions needs to be implemented by coordinating via shared variables, which in turns means that a race \ndetector will pro\u00adduce many false positives. These false positives can be cate\u00adgorized as follows: Synchronization \nraces: these are races which implement synchronization and are required for the program to work correctly. \n Races covered by synchronization: these are races that can never occur since other synchronization \nraces in fact introduce a happens-before edge.  Indeed, in our experiments in Section 6, we found that \nthe vast majority of races on a web site reported by a standard race detector are false positives: many \nof them are either syn\u00adchronization races or they are covered by synchronization races. The total number \nof races is often so large that manu\u00adally inspecting all of them is almost impossible. Ideally, we would \nlike to focus only on real races, which are not ordered by synchronization. Using race coverage, we were \nable to report only races uncovered by synchronization, decreasing the number of races reported by an \norder of magnitude. 3.1 Race coverage and multi-coverage Next we de.ne what it means for a race to be \ncovered. Intuitively, a race R = (a, b) is covered if there is some other race S = (c, d) such that if \nwe treat S as synchronization and Figure 4. An example of race coverage based on Fig. 1. Race R = (a, \nb) is covered by race S = (c, d), since with a happens-before edge from c to d, R would clearly not be \na race.  Figure 5. An example with a race R = (a, b) covered by two races S1 = (c1, d1) and S2 = (c2, \nd2) create a happens-before edge between c and d, then the race R will disappear, that is, R will no \nlonger be a race. De.nition 3.1 (Covered race). We say that a race R = (a, b) is covered by race S = \n(c, d) if the following conditions hold: 1. ev(a)jev(c), and 2. djb  We denote that race S covers race \nR by {S} . R. Note that we need d j b and it is not enough to say ev(d) j ev(b) as d must come before \nb, even if they are part of the same event action. Similarly, if we say a j c, then that would be too \nrestrictive as c can come before a if they are in the same event action. Example Fig. 4 shows an example \nof the conditions in the above de.nition, based on the scripts in Fig. 1. The dashed lines denote the \ntwo races. On its own, the race R on y may seem harmful: if the read of y.f executes before initialization, \nan exception will be thrown. However, the synchronization on variable init (the covering race S) prevents \nR from ever executing in a bad order, i.e., R is not really a race. Next, we generalize De.nition 3.1 \nto the case where a race is covered by multiple races. The intuition behind this generalization in that \nenforced ordering constraints via (multiple) synchronization races are transitive. De.nition 3.2 (Multi-covered \nrace). We say that a race R = (a, b) is covered by a set of races {Si = (ci, di)}n if i=1 the following \nconditions hold: 1. ev(a)jev(c1) 2. for every i . [1, n), ev(di)jev(ci+1). 3. dn jb   We denote multi-coverage \nby {Si}n i=1 . R. The example in Fig. 5 shows a fragment of an execution with one race R covered by two \nother races S1 and S2. Let races(p) denote the set of all races which occur in a trace p. An uncovered \nrace is one for which no combination of races in the trace p cover it. We denote the set of all uncovered \nraces by: uncovered(p) = {R |R . races(p), .C . races(p): C . R}  3.2 Guarantees Next, we show that \nall uncovered races are feasible (i.e., cannot be eliminated) in the sense that the racing operations \nof an uncovered race can appear in arbitrary order. This property is important because such races are \nlikely to be of greater interest to the programmer, as they cannot be eliminated regardless of which \nother races are considered as synchronization. First, we de.ne the possible re-orderings of a trace p, \nreferred to as [ p] . Recall that the notation [ P] means the set of all program traces of a program \nP. De.nition 3.3 (Equivalence Class). For a trace p, [ p] . [ P] is a set of program traces such that \nfor every trace p1 . [ p] , the following conditions hold: 1. if operation a . p1, then a . p. 2. if \noperations a, b . p, b . p1, and ajb, then a . p1 and a <p1 b. 3. if operations a, b . p, b . p1, and \nrace R = (a, b) is a race in p, then either:  (a) a . p1 and a <p1 b, or (b) a . p1 and b is the last \noperation of p1.  Intuitively, the set [ p] includes the traces that satisfy the happens-before relation \nj and where all races in p are resolved in the same way in each trace in [ p] , that is, racing accesses \nfollow the same order in the trace. The set [ p] allows for one case where a race in p1 is not resolved \nin the same way as in p. This occurs when condition 3(a) does not hold, but condition 3(b) holds. We \ncall such a race an accessible race: De.nition 3.4 (Accessible race). A race R = (a, b) in a trace p \nis accessible, if there exists a trace p1 . [ p] , such that b . p1, but a . p1. From both de.nitions, \nit follows that operation b must be the last operation of p1. Intuitively, this is because after an accessed \nrace occurs, we may not be always able to reason about the behavior of the program only based on the \ntrace p. The next two theorems discuss the connection between uncovered and accessible races. Theorem \n3.5. If a race R . races(p)\\uncovered(p), then R is not accessible. The above theorem states that if \na race R is covered, then for the equivalence class [ p] , the race is inaccessible. The intuitive reason \nis that as R is covered by some other race S, the operations in S will always occur in the same order \nin any trace in [ p] which would force R s operations to follow the same order as well, meaning that \nthe operations of R cannot be re-ordered in any of the traces in [ p] . The next theorem states that \nany uncovered race is acces\u00adsible. This means that any race that we report as uncovered is guaranteed \nto exist for some trace. Theorem 3.6. For a trace p, if R . uncovered(p), then R is an accessible race. \nUsing the de.nition of a multi-covered race, it can be shown that for a trace p, races(p) = \u00d8 iff uncovered(p) \n= \u00d8. Then the following is a direct corollary from Theorem 3.5 and Theorem 3.6. Corollary 3.7. A trace \np is race-free ([ p] has no accessible races) iff races(p) = \u00d8. This result is useful as it tells us \nthat if we do not .nd a race in a given trace, then it means that there are no races for the other traces \nin [ p] . Conversely, Theorem 3.6 tells us that certain races always exist and cannot be eliminated. \nIn the next section, we will show algorithms for comput\u00ading the set of uncovered races. 4. Computation \nof Uncovered Races In this section, we present algorithms which compute uncov\u00adered races. These algorithms \nreport at least one uncovered race per variable on which there are uncovered races in the execution. \nWe present our algorithms using graph terminol\u00adogy and discuss how they can be realized both in an online \nas well as in an of.ine setting. 4.1 Happens-Before via Graph Connectivity Happens-before queries can \nbe answered as connectivity queries in a graph. Given a trace p, we build a graph G = (V, E) where the \nnodes V . EventIds represent all event actions in the trace and the arcs E . EventIds\u00d7EventIds are such \nthat for any pair of nodes t and u, there is a path from t to u in G iff t ju. That is, given a trace \np, we de.ne: V = {t | begin(t) . p}, and  E = {(t, u) | fork(t, u, ) . p or join(u, t) . p}  The graph \nG is a directed acyclic graph and the sequence of event actions in any valid trace p is a topological \nordering traversal of G. Then, given a trace p, 1 by .rst building the graph G (which represents the \nhappens-before relation j ) we can determine if a pair of operations which access the same variable (with \nat least one operation being a write) are racing by checking whether their corresponding two event actions \n(two nodes) are connected in G. 1 In an online detector, the trace can be partial.  (a) (b) Figure \n6. Example showing vector clocks with and without chain decomposition. Next, we discuss four orthogonal \nalgorithms for perform\u00ading graph connectivity. All of these algorithms are later evaluated on graphs \nobtained from traces of web programs (see Table 3 in Section 6). 4.1.1 Breadth-.rst search (BFS) A standard \nalgorithm for connectivity checking between a pair of nodes performs a breadth-.rst or depth-.rst graph \ntraversal of G. Then, each connectivity check has a maxi\u00admum time complexity of O(|E|), but many checks \ncomplete faster. While the algorithm has the advantage of low space complexity, our experiments indicate \nthat such an algorithm performs on average orders of magnitude slower (than our .\u00adnal algorithm) and \nis unable to complete execution on some web applications in a reasonable amount of time. 4.1.2 Vector \nClocks Many race detection algorithms determine connectivity us\u00ading vector clocks, described previously \nin Section 2.3. Each node is assigned a vector clock of width |V |, with one slot per node. The vector \nclock vc(t) for node t is de.ned as: vc(t) = inct(U{vc(u) | u = t, (u, t) . E}) Since the graph G is \nacyclic, the function vc is well de.ned. For a pair of nodes t and u, tju holds iff vc(t)[t] = vc(u)[t] \n(see the reachability theorem in [7]). Hence, given a pre\u00adcomputed vc function for each node, a reachability \nquery takes one integer comparison, which is constant time. As an example, Fig. 6(a) shows a small graph \nand the corresponding vector clocks for each node (the node number is its vector-clock index). Given \nthe vector clocks, we can see, e.g., that event 1 does not happen before event 2, since vc(1)[1] > vc(2)[1]. \nThe above algorithm has O(|V |2) space complexity, and since our event graphs can have thousands of nodes \nor more, this leads to a blowup in practice. We evaluated a sim\u00adple vector-clock-based algorithm and \nfound it to run out of memory for some of our applications (see Section 6). 4.1.3 Vector clocks with \nBit Vectors An interesting observation is that if each node uses its own vector clock entry, vector clocks \ncan be represented com\u00adpactly using bit vectors, as each entry will always be 0 or 1 (as in Fig. 6(a)). \nHowever, even with this optimization, the algorithm required more than a gigabyte of memory to han\u00addle \nlarger applications in our experiments. 4.1.4 Vector clocks with chain decomposition We propose an improved \ngraph connectivity algorithm which combines vector clocks with chain decomposition similar to the one \nproposed by Jagadish et al. [7] and Awar\u00adgal and Garg [1]. A chain decomposition optimization sug\u00adgests \ncovering the nodes of a graph with a minimal number of chains for performing fast connectivity queries. \nA chain is a set of nodes {ai}m , such that there is a path from ai to i=1 ai+1 in G for every i . [1, \nm). Let C I ds denote the set of all chains. Then, we assign every node in G to a chain via the function \ncid : E ventI ds . C I ds. For example, Fig. 6(b) shows a chain decomposition of the example graph, using \ntwo chains, one in dark grey and one in light grey. Given the chain assignment, we allocate one vector \nclock of width |C I ds| (in this case V C : C I ds . N) for every node t in the graph and assign the \nvector clock values ac\u00adcording to a modi.ed function vc : E ventI ds . V C : vc(t) = inccid(t)(U{vc(u) \n| u = t, (u, t) . E}) Since the number of chains is typically much smaller than the number of nodes (over \n33X smaller on average in our experimental evaluation, as shown in Table 3), this technique can dramatically \nreduce the size of vector clocks. Fig. 6(b) shows how vector clocks of width 2 are assigned to the nodes \nusing the chain decomposition. Note that with chains, vector clocks can no longer be represented using \nbit vectors. Computing optimal chain decomposition has O(|V |3) time complexity, but a greedy technique \n(which we use in this work) typically produces as few chains [7]. The space complexity of our connectivity \nalgorithm is O(|C I ds|\u00b7|V |), and the time complexity for each query is O(1). Representing the Graph \nG We note that vector clock con\u00adnectivity algorithms do not explicitly store the graph G. They only maintain \nthe map from nodes to vector clocks (as well as the cid function for the algorithm in Section 4.1.4) \nwhich is used to answer reachability queries.  4.2 Computation of initial set of races Next, we describe \nthe .rst step in computing uncovered races. One way to compute uncovered races is to .rst com\u00adpute the \nset of all races. Using one of the four connectivity algorithms above, we can compute the set of all \nraces by checking pairs of write operations or pairs of a read and a write operation on the same variable. \nHowever, .rst comput\u00ading the set of all races may be an unnecessary overhead. For example, a variable \nwith n writes may contain up to n\u00b7(n-1) races if all of its writes are unordered by the j relation. \n Reduced starting set of races We next discuss how to discover uncovered races by .rst computing a smaller \nset of initial races. We refer to this set as UncoveredCandidates. Consider a pair of races on the same \nvariable R1 = (a, c) and R2 = (b, c) such that a j b. In this case, if R1 covers any other race R1, then \nR2 also covers R1. Hence, we do not need to obtain R1 if we can obtain R2. Similarly to multi-coverage, \nthe idea can be extended as follows. We do not need to obtain a race R = (a, b) for which there is a \nset of other races on the same variable Si = (ci, di), Si = R, i . [1, n] where the following hold: \na = c1 or ajc1, and  di = ci+1 or di jci+1 for all i . [1, n), and  dn = b or dn jb  If the above \nconditions hold, from De.nition 3.1 and De.nition 3.2, it follows that for any R1, if {R} . R1 , then \n{Si}n . R1 and hence we need not discover R1 as i=1 there are other races (Si) that will be found. That \nis, the set UncoveredCandidates is the set of all races minus the set of races which satisfy the above \nconditions. Computation of UncoveredCandidates Consider a vari\u00adable with p writes w1, w2, ..., wp (here \nwrite wi happens be\u00adfore wi+1 in the trace) and q reads r1, r2, ..., rq (here read ri happens before \nri+1 in the trace). Below we de.ne candi\u00addate pairs which we check for whether they participate in a \nrace: all pairs (wi, wi+1), i . [1, p);  for each ri, i . [1, q], where wpredi is the last write before \nri occurred (if one exists).  for each ri, i . [1, q], the pair (ri, wsucci ) where wsucci is the write \nright after ri occurred (if one exists).  For each of the above pairs (a, b), if ajb (checked using \none of the four algorithms described earlier), we add the pair to the set UncoveredCandidates. This approach \nproduces at most p - 1 + 2 \u00b7 q races per variable, a signi.cant reduction from the maximum number of \npossible races per variable p \u00b7 (p + q - 1).  4.3 Computation of uncovered races Next, based on UncoveredCandidates, \nwe present an algo\u00adrithm for .nding all variables with uncovered races. 1. We .rst eliminate all races \nwhich are covered by only one race. We sort the set UncoveredCandidates = {Ri = (ai, bi)}n according \nto the order in which their second i=1 operation appears in the trace p, that is, if bi <p bj , then \ni < j . According to condition 2 of De.nition 3.1, every race Ri may cover only races Rj such that i \n< j . Given this sorted order, for every remaining race r, we remove all of the subsequent races in the \nordering that r covers according to De.nition 3.1 (checking this requires two connectivity queries for \nthe two conditions). Let the remaining set of races be RemainingCandidates. 2. Next, we present an algorithm \nfor .nding the set of uncovered races, which also excludes races covered by more than one race from the \nset RemainingCandidates. We build a graph G1 = (V 1, E 1) with nodes representing races generated from \nthe previous step: V 1 = RemainingCandidates  E1 = {((a, b), (c, d)) | ev(b)jev(c)}Then, for every \nrace R = (c, d) . V 1, if there exists a pair of nodes S1 = (a1, b1) . V 1 and S2 = (a2, b2) . V 1, such \nthat ev(c) j ev(a1), b2 j d, and there is a path from S1 to S2 in G1, then R is a covered race. The reason \nR is covered is that the set of races in the path from S1 to S2 will cover R. After removing all such \n races from RemainingCandidates, the remaining races are uncovered races. The correctness of the algorithm \nfollows from the fact that for every race R, if R is covered by a set of other races, then it is covered \nby a set of uncovered races, which form a path in G1 and the above algorithm will .nd that path. Time \ncomplexity Let |UncoveredCandidates| = n and |RemainingCandidates| = m. Assuming the time com\u00adplexity \nof the connectivity query is constant-time (which is true for all three vector-clock connectivity algorithms), \nthen computation of uncovered races has time complexity O(n \u00b7 m + m3). As we will see in our experimental \nresults, this procedure usually takes less than a second.  4.4 Online Analysis In an online setting \nwhere we do not store the trace p, all of the described algorithms can be realized as follows. First, \nchain decomposition can be used online as a direct replacement of na\u00a8ive vector clocks. Because connectivity \nqueries can be made while the graph is not fully built, the online setting requires us to use a greedy \nchain assignment, e.g. for every node added to the graph, we assign to it the .rst possible chain (if \nsuch a chain exists), or to a new chain otherwise. Second, we can augment an existing vector clocks based \nrace detector to produce the set UncoveredCandidates. This only requires the race detector to keep reporting \nraces on a variable even after it .nds the .rst race. Finally, to .nd uncovered races we maintain the \nmap vc (the mapping from nodes to vector clocks), which is instru\u00admented state that standard race detectors \nalready maintain. We also maintain the graph G1 whose size is a small fraction of the size of vc.  \n4.5 Of.ine Analysis To use the described algorithms in an of.ine setting, we need to store the trace \np. To mitigate the potential space overhead from storing the full trace, we avoid storing some of the \nop\u00aderations. In our setting, if there are multiple races for one variable between operations in the same \npairs of event ac\u00adtions, we report only one race. This means that if an event action contains multiple \nreads or multiple writes of one vari\u00adable, it is enough to store the .rst read and the .rst write. This \noptimization is sound and does not affect the correct\u00adness of the races we .nd or the guarantees provided \nby race coverage. With this optimization, our experiments (in Sec\u00adtion 6.2) show that the size of trace \nlog .les is acceptable and storing the entire trace in memory requires space com\u00adparable to the space \nconsumed by vector clocks for the graph connectivity algorithm. 5. Implementation Here we describe the \nimplementation of EV E N T RAC E R, which performs race detection of.ine on a trace in the Event language \n(see Fig. 2), generated by an instrumented Web-Kit browser. We chose to implement an of.ine race detector \nsince recorded traces enable apples-to-apples comparisons of the different connectivity algorithms based \non which race coverage is computed (since each algorithm runs on the same trace) and other detailed analyses; \nscalability of the of.ine approach was not an issue (see Section 6.2). In this section, we discuss the \ntranslation of web page executions to the Event language, our implementation of the race detec\u00adtor, and \nsome additional race .lters that do useful automatic categorization speci.c to web races. 5.1 Translation \nof a web application to Event A translation from a web application to the Event language consists of \ntwo main parts: 1. generating the read and write operations. 2. generating event actions and f ork and \nj oin operations between them.  Here we outline the main principles of our translation. Our translation \nbuilds on the modelling of web semantics in Petrov et al. [15], but we exploit the structure of Web-Kit \nitself to achieve greater simplicity and generality when generating event actions. Memory accesses Our \nmodeling of memory accesses is largely identical to that of Petrov et al. [15], but we handle more cases \nlike JavaScript arrays; we describe it here brie.y. The web platform provides a high-level declarative \nlanguage for creating user interface elements (HTML and CSS) and a scripting language for the application \ncode (JavaScript). The languages are linked by the Document Object Model (DOM) APIs, which enable reading \nand modifying user interface elements from JavaScript. When translating to the Event 1 < h t m l > < \nb o d y > 2 < i n p u t t y p e = \" b u t t o n \" i d = \" b 1 \" > 3 < i n p u t t y p e = \" b u t t o \nn \" i d = \" b 2 \" 4 o n c l i c k = \" j a v a s c r i p t : f ( ) \" > 5 < s c r i p t > 6 v a r l i k \ne L o c a l , l a z y ; 7 f u n c t i o n f ( ) { 8 l i k e L o c a l = 5 ; 9 i f ( ! l a z y ) { 10 \nl a z y = 9 + l i k e L o c a l ; 11 } 12 } 13 d o c u m e n t . g e t E l e m e n t B y I d ( b 1 \n) 14 . a d d E v e n t L i s t e n e r ( \" c l i c k \" , f ) ; 15 < / s c r i p t > < / b o d y > < / \nh t m l > Figure 7. An example web application with several races. Figure 8. Example trace for the \nprogram in Fig. 7, which in\u00adcludes several races. Solid arrows represent happens-before, dashed lines \nshow some of the races. Note: some details are omitted for clarity. language, we de.ne logical memory \nlocations representing the state of the DOM tree, in addition to the straightforward translation of JavaScript \nvariables to Event variables. We translated memory accesses to Event as follows: Reads and writes of \nJavaScript variables, object .elds, and functions were directly translated to rd or wr opera\u00adtions in \nEvent. (At the lowest level, all these entities are in fact object .elds in JavaScript, simplifying the \nimple\u00admentation.) DOM API methods were modeled as rd or wr operations of the appropriate logical memory \nloca\u00adtions.  Some DOM nodes have a list of event listeners for the possible events on corresponding \nUI elements. Any mu\u00adtation of this list (e.g., via a call to addEventListener or setting an on<X> attribute \nfor event <X>) is translated to a wr operation of a corresponding logical memory location  l. Firing \nan event, which causes execution of all attached event listeners, is translated as rd operation on l. \n  A special type of memory locations for DOM elements is the set of all DOM node identi.ers. The DOM \ntree allows querying for elements by their id and such a query is translated to a rd operation in the \nEvent language. Creation of an element with an id attribute or writing the id .eld of a DOM object is \na modi.cation to the set of DOM identi.ers and translates to a wr operation on a variable representing \nthe DOM id.  JavaScript arrays are a special case of JavaScript vari\u00adables. Arrays provide reads and \nwrites from an index that we translate to rd and wr of the corresponding index like regular variables. \nAdditionally, arrays provide methods that append to the end of an array, iterate over elements, remove \nan interval of elements or get its length. To han\u00addle these methods, we added an additional logical mem\u00adory \nlocation for the entire array. All operations that read the size of the array or access a cells are considered \nreads, while all operations that add or remove cells are consid\u00adered writes of this memory location. \n The example program in Fig. 7 contains accesses of the JavaScript variables f, likeLocal and lazy, \nthe click event handler of buttons b1 and b2, and the set of DOM identi.ers. Fig. 8 shows an execution \ntrace for Fig. 7 with the relevant memory accesses translated to the Event language. Event Actions, Forks \nand Joins The work of Petrov et al. [15] speci.ed a detailed happens-before relation for the web, with \nspeci.c rules for constructs like scripts, images, etc. Rather than instrumenting the handling of each \nsuch construct, we exploited the fact that WebKit itself is struc\u00adtured as an event-driven program by \ntranslating WebKit s internal event-driven structure directly to Event, we could handle a wider variety \nof HTML constructs than what was speci.ed in previous work with a relatively small amount of code. We \ncan do this, because ordering constraints be\u00adtween events are typically enforced only by the browser. \nThis means that even if an external agent like a server tries to order events, the order is likely not \nenforced at the client side due to the network. The implementation of WebKit contains event handler code \nfor each unit of work in rendering a web page: parsing an HTML element, executing a script, handling \nuser input, etc. We translated each of these handlers to an event action in Event. Many WebKit event \nactions are ordered via internal timers: starting a timer event action u from event action t is translated \nto f ork(t, u). Similarly, an event action t starting a network request with response event action u \nis modeled as f ork(t, u). We also introduce f ork(t, u) where t creates a UI element e and u handles \nsome event on e. The trace in Fig. 8 shows possible event actions for parsing each HTML tag and event \nactions for user clicks on the two buttons from one possible execution run. We found that WebKit itself \nuses ad hoc synchronization to order certain event actions, which we translated to Event using the j \noin construct to capture the induced happens\u00adbefore. Here are examples of ad hoc synchronization vari\u00adables \nin WebKit: 1. A counter in each document for the number of child iframe HTML documents being loaded. \nEach created iframe increments this counter, while .nishing the load\u00ading of an iframe decrements it. \nA load completion event is triggered only after this counter decreases to zero. 2. A counter in each \ndocument for the number of child resources like images or scripts that are currently loading. The use \nof this counter is similar to the iframe counter. 3. A counter in each document for the number of pending \nscripts to execute. 4. A queue of the pending tags to parse.  By translating WebKit s core event structure \ndirectly in\u00adstead of separately handling each HTML feature, our transla\u00adtion is able to cover a bigger \npart of HTML5 than what was described in [15], including newer features like video and audio tags and \nmodi.cation listener events. Our approach is mostly applicable to other browser engines, as they are \nalso implemented as event-based systems (the event-driven struc\u00adture is speci.ed in HTML5 [5]). Minor \nchanges to the engine may be needed to disable optimizations that merge multiple web-level events, as \nthis merging may hide races. For Web-Kit, we disabled the ability to parse more than one HTML element \nin an event action. Our modi.cations worked across several versions of WebKit that we tested, and our \nexperiments were done us\u00ading SVN version 116000 of the code.2 Our reasoning about the WebKit implementation \nin terms of our Event language shows the generality of our techniques. In fact, one could imagine using \nour techniques to build a race detector for the WebKit implementation, with race coverage exposing the \nad hoc synchronization we discovered manually.  5.2 Race analyzer Our browser based on modi.ed WebKit \nproduces a program trace, which is logged to a .le, together with debug informa\u00adtion describing the types \nof events, JavaScript scope infor\u00admation, the values of the JavaScript variables and the source code \nof any executed JavaScript. Our race analyzer takes the Event program trace augmented with the debug \ninformation as input. The user interface for the race analyzer is implemented as a web server providing \ninteractive views of the execution trace and detected races. The user can inspect reads and writes of \nany memory location in the trace, the happens\u00adbefore graph, and all corresponding JavaScript code (even \nwhen the code was dynamically generated). For discovered races, the UI shows race coverage information \nand .lters out covered races in its default view. Initially showing only 2 http://svn.webkit.org/repository/webkit/trunk \n uncovered races is a sensible default, as the user can easily identify synchronization races and avoid \ninspection of races covered by synchronization (see Section 3). We shall show in Section 6 that in practice, \nonly a small subset of all races are uncovered, so this default also signi.cantly reduces triage effort. \n 5.3 Race .lters To further improve the usability of EV E N T RAC E R, we im\u00adplemented several .lters \nfor common race patterns speci.c to web applications. These .lters automatically categorize certain uncovered \nraces as either likely synchronization or likely to be harmless. A user can .rst investigate the uncate\u00adgorized \nraces, which are more likely to be harmful, and then quickly study the .ltered races to con.rm that the \nautomatic categorization is appropriate. The automatic categorizations are based on extensive experience \ninspecting thousands of race reports across real-world web sites. It is possible for a .lter to be inaccurate, \ne.g., by .agging a harmful race as likely to be harmless. However, we manually inspected many .ltered \nraces during our experimental evaluation, and we did not observe any inaccuracy, so we expect this to \nbe rare in practice. Writing same value When a memory location has only write-write uncovered races and \nthe racing operations write the same value to the variable, the races are .agged as likely to be harmless. \nWeb sites often have multiple scripts that initialize a variable to the same value, and this .lter captures \nthat pattern. The variable likeLocal in Fig. 7 matches this pattern. The f function is executed when \neither button is clicked, and thus the value 5 will be written to likeLocal no matter which button is \nclicked .rst. Only local reads In some cases, a JavaScript global vari\u00adable is essentially used as a \nlocal: any read of the variable gets a value from a preceding write in the same event ac\u00adtion. In such \ncases, we .ag races on the variable as likely to be harmless. For these races, the user may want to .x \nthe code by reducing the visibility of the variable, as adding a read without a preceding write to new \ncode could cause a harmful race. The variable likeLocal in Fig. 7 matches this pattern as well. The value \nof the variable is read only in the same event action after it is written. Late attachment of event handler \nWe .ag write-read and read-write races on event handlers as a separate class of races. This type of race \nis speci.c to the web and common in sites using libraries like jQuery.3 Such sites enable many event \nhandlers only after the page has completed some ini\u00adtial loading, in order to reduce perceived page load \ntime. This practice can lead to many race reports, since the user can interact with a partially-loaded \npage. For example, if a click handler is attached only after the page loads, user 3 http://jquery.com/ \nclicks while the page is not fully loaded will not be pro\u00adcessed. While this is certainly a race, it \nis a common pattern in web applications and typically viewed as an acceptable degradation of the user \nexperience. The click handler for the button b1 in Fig. 7 matches this pattern: if the user clicks b1 \nbefore the code at line 13 runs, the f function will not execute. Lazy initialization When a JavaScript \nvariable has only one write, only one read of the value undefined (or the value null) preceding the write \nin the same event action, and multiple other reads in other event actions following the write in the \ntrace, we assume this variable is used as lazy initialization. Such a variable may have races, but we \nassume every read to be checking for undefined and be harmless. This .lter is only a best-effort guess \nthat races on a variable are harmless. In our experience, the races it caught were always harmless, but \nit may hide a real bug, so the races may merit more careful inspection. A common code pattern for such \nvariables is similar to the one shown for variable lazy in Fig. 7: the racing accesses check if the variable \nis initialized and only the .rst one initializes it. Commuting operations Races on certain memory loca\u00adtions \nlike cookie and className of DOM nodes typically oc\u00adcur from commuting methods like addClass, removeClass, \nhasClass, etc.. We .lter these races as we discovered they are often harmless. Race with page unload \nWe classify variables having only races with a memory access in the page unload event handler separately. \nThe harm of such races to a web application is limited to only the unload event and any error will likely \nnot be visible to the user. Most of these races were in libraries, but in cases when a developer adds \nlogic in the unload events, these races may be worth investigating.  5.4 Likely harmful races We also \ncreated .lters for two types of races that are likely to be harmful; EV E N T RAC E R automatically .ags \nthese races as important for the user. Note that both these .lters are only applied to variables that \nhave not already been .agged by the .lters described in Section 5.3. Uninitialized values This .lter \nidenti.es races that may involve a use of an uninitialized location. The .lter se\u00adlects variables v with \nuncovered races where for all writes {wi}n of v in the trace that precede a read r, the pairs i=1 (wi, \nr) are uncovered races. For races that pass this crite\u00adrion, we can show via Theorem 3.6 that it is possible \nto build a trace such that the read r can read an uninitialized value (since no write is ordered before \nthe read). Such a race is harmful when the code that performs the read does not check for an uninitialized \nvalue. In our experimental evalua\u00adtion, we manually inspected races .agged by this .lter, and we found \nsome of them to be harmful.  An example of such a race is for the variable f in Fig. 7. In this case, \na user with a slow network connection may execute the click handler before the script is loaded and the \nfunction f is initialized, causing an unhandled exception in the click handler. readyStateChange handler \nThis .lter selects variables v with uncovered races (a, b) such that at least one of ev(a) or ev(b) is \nan event handler for the readyStateChange event. These are typically response handlers for asynchronous \nAJAX or resource load requests, which are error-prone due to possible wide variance in network response \ntime. We manually inspected races from this .lter and found some of them to be harmful. 6. Evaluation \nHere we present an experimental evaluation of EV E N T-RAC E R, which implements the optimized race detector, \ncov\u00aderage techniques, and .lters described earlier. Our evaluation tested the following experimental \nhypotheses: 1. Race coverage (Section 3) and our other .lters (Sec\u00adtion 5.3) dramatically reduce the \nnumber of races the user must initially inspect. 2. If a site contains harmful races, those races are \noften contained in the initial set of uncovered, un.ltered races shown to the user. 3. Race detection \nthat constructs vector clocks based on chain decomposition (see Section 4.1.4) performs signif\u00adicantly \nbetter than standard vector-clock-based race de\u00adtection.  Section 6.1 presents a usability experiment \nto test the .rst and second hypotheses, and Section 6.2 describes a perfor\u00admance evaluation to evaluate \nthe third hypothesis. As in previous work [15], we evaluated EV E N T RAC E R on the home pages of the \ncompanies in the Fortune 100. To automatically exercise some basic site functionality, we also implemented \nan automatic exploration technique similar to that of WE B RAC E R [15, \u00a75.2.2]. The automatic exploration \nperforms simple actions like typing in text boxes, hovering the mouse, etc., which can expose additional \nraces. Auto\u00admatic exploration cannot deeply explore a rich web applica\u00adtion; in future work, we plan \nto integrate our techniques with a tool like Artemis [2] to expose more races in such sites. Note that \nsince the Fortune 100 sites change frequently, and we do not have the exact site versions used in the \nWE B -RAC E R work [15], the numbers presented here cannot be compared directly to those in the WE B \nRAC E R paper. We have preserved and will make available the site traces used in the current work, to \nenable future comparisons. We ran our experiments on a Core i7 2700K machine with 16GB of RAM, running \nUbuntu 12.04. EV E N T RAC E R was implemented in C++ and compiled with GCC 4.6. We Table 1. Usability \nmetrics of EV E N T RAC E R on the Fortune 100 sites. Metric Number of variables with races Mean Me\u00ad90-th \nMax dian %-ile All 634.6 461 1568 3460 Removed by single coverage (De.nition 3.1) 581.1 419 1542 3389 \nRemoved by multi-coverage (De.nition 3.2) 8.2 2 30 55 Remaining with uncovered races 45.3 29 103 331 \nFiltering methods Writing same value 0.75 0 3 12 Only local reads 3.42 2 8 43 Late attachment of event \nhandler 16.7 8 41 117 Lazy initialization 4.3 0 11 61 Commuting operations -className, cookie 4.0 1 8 \n80 Race with unload 1.1 0 2 33 Remaining after .lters from Section 5.3 17.8 10 38 261 Uninitialized values \n1.9 0 5 36 readyStateChange handler 1.3 0 2 64 fetched each website and ran our auto-exploration for \n15 seconds. 6.1 Race Detector Usability To evaluate the usability of EV E N T RAC E R, we studied the \nnumber and type of races reported across our benchmarks. Here we .rst discuss the effectiveness of our \nautomatic tech\u00adniques for reducing the number of races shown to the user, race coverage (Section 3) and \n.lters (Section 5.3). Then, we present results from a manual classi.cation of the remaining races, including \na discussion of observed harmful races and synchronization patterns. Automatic Techniques Table 1 presents \nresults showing the effectiveness of our automatic techniques for reducing the number of races shown \nto the user. As is standard in race detection work, we give the number of memory locations that have \nat least one race of the provided type. Only showing variables with uncovered races (as de\u00ad.ned in De.nition \n3.2 to include multi-coverage) reduces the number of displayed variables with races by a factor of 14, \nfrom 634.6 per site on average to 45.3. Most of the re\u00adduction comes from races covered by a single other \nrace, but multi-coverage also plays a signi.cant role in comparison to the number of remaining races. \nThis large reduction, along with the guarantee that both orderings of any uncovered race are in fact \nfeasible (Theorem 3.6), is strong evidence for the usefulness of race coverage in practice. Together, \nthe .lters from Section 5.3 yield roughly another 2.5X reduction in number of variables with races, down \nto 17.8 per site on av\u00aderage. The Late attachment of event handler .lter is most effective, indicating \nthe frequent usage of this pattern on real sites. Most of the other .lters are also useful: each of them \ncatches more than ten races on at least one site. Note that for some variables, multiple .lters may apply. \nManual Classi.cation We performed a manual classi.ca\u00adtion of those uncovered races that did not match \nthe .lters for likely harmless races described in Section 5.3, and matched our .lters for likely harmful \nraces described in Section 5.4.  There were 314 such variables with races, which we man\u00adually classi.ed \nas a synchronization operation, harmful, or harmless. Table 2 summarizes the results of our classi.ca\u00adtion. \nAlong with totals, we separately give the number of DOM variables and JavaScript variables in each category. \nDue to code obfuscation, we could not classify the races on nine variables. Synchronization races 178 \nof the variables with races we inspected were synchronization operations, with spe\u00adcial logic to enforce \norderings based on the variable s value. This large amount of synchronization in the uncovered races \nfurther validates the utility of race coverage, as (false) races covered by this ad hoc synchronization \nare completely hid\u00adden from the user. For DOM synchronization races, typically the applica\u00adtion had logic \nthat delayed or disabled some action if the appropriate DOM node was present. For JavaScript syn\u00adchronization \nraces, many idioms were observed. In some cases, a conditional checked for an unde.ned value before the \nread was performed. In other cases, the possible excep\u00adtion from reading an uninitialized value was caught \nin an exception handler, which started a timer to retry the opera\u00adtion later. A third common type of \nsynchronization was per\u00adformed by using data structures: for example, one event ac\u00adtion would store a \nJavaScript object in an array, and another action would periodically execute code for each element in \nthe array. This type of synchronization often occurred in commonly-used libraries like jQuery. Harmful \nraces We identi.ed 75 variables with harmful races in 21 sites. In many cases, the harm was limited to \nan uncaught JavaScript exception, e.g., a ReferenceError caused by trying to read a .eld from the undefined \nvalue. Most browsers are con.gured not to display such exceptions, and only inspection of the event log \nwill show them. How\u00adever, they still degrade the user experience, as they often cause user interface \nglitches (e.g., a mouse click that does nothing and must be repeated). Using EV E N T RAC E R, we also \nfound more severe bugs that were too complex to investigate using previous tools like WE B RAC E R [15]. \nIn fact, we found that some of the races described in the work of [15, \u00a72.3] were covered by other harmful \nor synchronization races. EV E N T RAC E R hides many of the false positives, enabling the user to focus \non analyzing important races. Here are brief descriptions of some new issues we discovered in various \nweb sites: ford.com: a script waited until a certain DOM node x was present, and then initialized handlers \nfor another DOM node y. Here, x was used for ad hoc synchroniza\u00adtion, which EV E N T RAC E R exposed \nas an uncovered race. However, EV E N T RAC E R showed that the race on x un\u00adexpectedly did not cover \na race on y. Hence, there was a bad interleaving of accesses to y, which we found to cause all of the \nsite s menus to be non-operational until the page was reloaded. verizon.com: a drop-down menu lets the \nuser control whether a personal or business account should be used for login. If the user made the selection \ntoo soon, an unseen exception was thrown, due to a race involving access to a function de.ned in a later \nscript. The user was then forced to wait for a full page load, select the opposite account type, and \nthen switch back in order to continue the login.  adm.com: we found a harmful race that may be an is\u00adsue \nin the ASP.NET framework itself.4 HTML forms have an action attribute to hold the URL to which the form \ndata should be submitted. A form s action at\u00adtribute was only URL escaped by JavaScript code in the page \ns onload handler. Hence, if a user submitted the form before the page load completed, the submission \ncould fail due to invalid characters in the form s URL. As the relevant HTML and JavaScript code appeared \nto be auto-generated by ASP.NET, this issue could be shared by any site using the framework s AJAX functionality. \n unitedhealthgroup.com: we observed a form with a hidden token ID .eld that was set only once the page \ns onload event .red. If the user submitted the form before the loading completed, the server would not \nsee the token ID and hence might not be able to record the user data.  fedex.com: the page loaded two \nversions of the jQuery library in a non-deterministic order! The version that loaded last would control \nthe relevant global variables exposing jQuery functionality. While we could not .nd any broken functionality \ndue to this non-determinism, using only one version of jQuery would certainly reduce the site s load \ntime.  Overall, race coverage enabled us to .nd many harmful bugs in these sites, despite the fact that \nthe code in most of the sites has already been well-tested and was obfuscated. We believe that EV E N \nT RAC E R will be even more useful to the actual website developers who have access to non\u00adobfuscated \nversions of the code. Harmless races We discovered 52 variables with only harmless races (roughly 16% \nof those inspected), due to application-speci.c semantics. Given this low false positive rate, we believe \nEV E N T RAC E R is already a very useful tool for web developers.  6.2 Race Detector Performance The \nperformance evaluation of EV E N T RAC E R consists of two parts: the performance overhead in the modi.ed \nweb browser, and the performance of the of.ine race analyzer. We study these issues in turn. 4 http://www.asp.net \n Total Synchronization Harmful Harmless Unknown 314 178 (59 / 119) 75 (33 / 42) 52 (2 / 50) 9 Metric \nMean Median Max Number of event actions 5868 2496 114900 Number of edges 6822 2873 122240 Number of chains \n175 134 792 Table 2. Number of variables with races of different types, based on manual classi.cation. \nNumbers for each race type are presented as X (Y / Z) , where X is the total, Y is the number of DOM \nvariables, and Z is the number of JavaScript variables. Instrumentation Overhead Our modi.cations of \nWebKit to generate traces for race detection add some performance overhead. JavaScript execution suffers \nthe biggest overhead, as we log many variable reads and writes. Furthermore, as in previous work [15], \nour technique disables the JavaScript just-in-time compiler, as the WebKit interpreter is much eas\u00adier \nto instrument. We observed a roughly 95X slowdown for the SunSpider benchmarks5 with our instrumented \ninter\u00adpreter as compared to Google s V8 JavaScript engine run in Chrome 25.6 However, when browsing in \npractice, network latency and other rendering operations often consume much more time than JavaScript \nexecution. In our experience us\u00ading the instrumented browser, it seemed fast and responsive, and there \nwas no signi.cant slowdown in the load times or the user interface of the sites we browsed. Race Analyzer \nSpeed To evaluate the performance of our of.ine race detector, we ran the detector using the four different \ntechniques for answering reachability queries on the happens-before relation, the most costly computation \nduring race detection (see Section 4.1): 1. a tuned breadth-.rst search (BFS) of the happens-before graph; \n 2. a standard vector-clock-based technique, where each event action is given a unique thread ID; 3. \nvector-clock-based technique with bit-vectors; 4. our .nal optimized vector clocks algorithm based on \nchain decomposition.  For the vector clocks used with chain decomposition, we used 16-bit integers for \neach entry, and we employed SSE instructions to speed vector clock computation. We ensured that the integers \nnever over.owed by modifying the chain decomposition procedure to never produce chains with more than \n216 - 1 nodes. Table 3 summarizes the running times for computing un\u00adcovered races (Section 4.3) in a \nloaded trace and presents some metrics over the site traces that help explain the per\u00adformance differences. \nFor each technique, we give the mean, median, and max\u00adimum running times across our benchmark sites. \nOur exper\u00ad 5 http://www.webkit.org/perf/sunspider/sunspider.html 6 WE B RAC E R [15] reported a 500X \nslowdown for the same benchmarks. WE B RAC E R did online race detection, but since E V E N T RAC E R \ns optimized race detector usually runs in a fraction of a second, E V E N T RAC E R s overall execution \ntime for race detection is lower. Connectivity algorithm Running time in seconds Breadth-.rst search \n>22.2 >0.4 TIMEOUT Vector clocks w/o chain decomposition >0.068 >0.011 OOM Bit vector clocks 0.081 0.008 \n3.381 Vector clocks + chain decomposition 0.043 0.007 2.395 Table 3. Performance metrics of EV E N T \nRAC E R on .nding uncovered races in the Fortune 100 sites. Metric Mean Median Max Trace .le size (uncompressed) \n7.9MB 3.7MB 129.5MB Trace .le size (gzip compressed) 1.4MB 0.7MB 16.3MB Vector clocks memory consumption \nVector clocks w/o chain decomposition 544MB 12MB 25181MB Bit vector clocks 33MB 1MB 1573MB Vector clocks \n+ chain decomposition 5MB 1MB 171MB Table 4. Memory consumption of different race detection techniques. \niments show that BFS is too slow to be run in practice for some of the web sites and ran above .ve minutes \non three of the sites. We classi.ed these runs as timeout, which allowed us to only underapproximate \nthe mean and median running times of the algorithm. On the other hand, vector clock based approaches \ntend to be very fast, but na\u00a8ive implementations run out of memory. Memory consumption In Table 4 we \n.rst show the storage space needed for the traces of our of.ine analysis, which was quite low (a maximum \nof 16.3MB for compressed traces). Next, we show the memory consumption of the vector clocks for the connectivity \nchecks in EV E N T RAC E R using na\u00a8ive vector clocks, bit vector clocks, and vector clocks with chain \ndecomposition.7 These algorithms store one vector clock per node of the connectivity graph and their \nmemory consump\u00adtion is proportional to the number of nodes and the width of the vector clocks. Chain \ndecomposition is particularly useful for the larger tests, reducing maximum memory con\u00adsumption from \n1573MB for bit vector clocks to 171MB. For deeper testing of large-scale web applications, we believe \nthe memory reductions from chain decomposition will become even more important. The reported memory results \nare usable as a lower bound for many existing online race detection techniques. For ex\u00adample, FA S T \nTR AC K needs one vector clock per event ac\u00adtion to store the connectivity information like in our of.ine \nrace detector (FA S T TR AC K does not use chain decomposi\u00adtion, but can be improved to use it). This \nalso means that the of.ine nature of EV E N T RAC E R was not a disadvantage, as the memory needed for \nvector clocks is not greater than the memory required to store a trace. 7 These numbers were computed \nanalytically rather than measuring actual memory consumption, enabling us to handle cases where the na\u00a8ive \nvector clocks ran out of memory.  7. Related work In this section, we discuss related work that is closest \nto ours. The work of Petrov et al. [15] presents a happens-before re\u00adlation [9] for web applications \nand uses it as a basis for a dynamic race detector. While their work found many races, it suffered from \ntwo key drawbacks: the race detector could miss races [15, \u00a75.1], and worse, by default it reported many \ninfeasible races. The authors worked around the second is\u00adsue via ad hoc .lters that reduced the number \nof reported races [15, \u00a75.3]. However, those .lters hid most races on JavaScript variables, thereby hiding \nthe ad hoc synchroniza\u00adtion necessary to avoid reporting infeasible races. FA S T TR AC K [4], a state-of-the \nart online race detector was already discussed at various places throughout the pa\u00adper. Ad hoc synchronization \nin the form of spin-locks has been detected in a number of multi-threaded scenarios [8, 12]. However, \nsuch techniques are often based on running a program multiple times on a modi.ed thread scheduler. For \nweb applications, modifying the thread scheduler would be very challenging, and collecting multiple runs \nthat manipu\u00adlated the UI would be laborious for testers. Shi et al. detect patterns of harmful races \n[19], but they also strongly rely on executing the application multiple times to extract invariants. \nNetzer and Miller [13, 14] discuss the feasibility of races in parallel programs. Similar to our work, \nthey start from the set of all races and produce a set of feasible races. However their work has two \nimportant drawbacks: .rst, they cannot always produce the actual set of feasible races in some cases \nthey produce sets of tangled races such that at least one race from each set is feasible. Second, their \nwork produces actual feasible races only in case the interleaving events are single-access [14] while \nweb event actions almost always consist of multiple memory accesses. Ide et al. [6] discuss the existence \nof web races, but pro\u00adpose no actual analysis. Zhang et al. [21] provide a static analysis for some of \nthe concurrency bugs in AJAX appli\u00adcations, but their technique does not handle all web races, and it \nsuffers from dif.culties in performing a precise static analysis of JavaScript [17]. An optimization \nof the vector clocks width called accor\u00addion clocks is proposed in [3]. However, this approach de\u00adcreases \nvector clock width only when all objects accessed by a thread are deleted, which does not happen in web \nappli\u00adcations that typically access long-lived DOM objects. 8. Conclusion and Future Work We have presented \nnovel techniques for performing ef.\u00adcient and usable dynamic race detection for event-driven programs. \nShowing uncovered races improves usability by exposing important races to the user .rst, particularly \nthose that re.ect ad hoc synchronization. For ef.ciency, our race detection algorithm employs chain decomposition \ntechniques to avoid bloating the size of key vector clock data structures. We implemented these techniques \nin a tool EV E N T RAC E R for detecting races in web applications, and showed that they lead to large \nperformance and usability improvements in an experimental evaluation. While exposing uncovered races \nimproves usability, our current technique still cannot automatically determine which races are on synchronization \nvariables. In future work, we plan to address this limitation, based on previous ap\u00adproaches [12, 18] \nand on static analysis techniques. We also plan to study techniques for automatically .xing some types \nof harmful races. References [1] AG A RWA L , A., A N D GAR G , V. K. Ef.cient dependency tracking for \nrelevant events in shared-memory systems. In PODC (2005). [2] ART ZI , S., DO L BY, J., JE NSEN, S. H., \nM\u00d8 L L ER , A., AND TI P, F. A Framework for Automated Testing of JavaScript Web Applications. In ICSE \n(May 2011). [3] CH R I S T IAE NS, M., A N D BO S S CH ER E , K. D. Accordion clocks: Logical clocks \nfor data race detection. In Euro-Par (2001). [4] FL ANAG AN, C., AN D FR EU N D , S. N. FastTrack: ef.cient \nand precise dynamic race detection. In PLDI (2009). [5] HTML5 speci.cation. http://www.w3.org/TR/html5/. \n[6] ID E , J., BO D I K, R., A N D KI ME L M AN, D. Concurrency concerns in rich Internet applications. \nIn EC2 (2009). [7] JAGA D I SH, H. V. A compression technique to materialize transitive closure. ACM \nTrans. Database Syst. 15, 4 (Dec. 1990), 558 598. [8] KA S IK C I, B., ZA M FIR , C., A N D CA N D E \nA , G. Data races vs. data race bugs: telling the difference with Portend. In ASPLOS (2012). [9] LAMPO \nRT, L. Time, clocks, and the ordering of events in a distributed system. In ACM Operating Systems (1978). \n[10] MAT T E R N , F. Virtual time and global states of distributed systems. In Proc. Workshop on Parallel \nand Distributed Algorithms (1989), C. M. et al., Ed. [11] Bug 538892 -Replying to or forwarding emails \non Hotmail no longer works properly: message content is often lost. https: //bugzilla.mozilla.org/show_bug.cgi?id=538892. \n[12] NAR AYA NA S AMY, S., WA NG, Z., TIGAN I , J., EDWAR D S , A., A N D CAL DE R , B. Automatically \nclassifying benign and harmful data races using replay analysis. In PLDI (2007). [13] NE TZE R, R. H. \nB., AND MI LLE R, B. P. Improving the accuracy of data race detection. In PPOPP (1991). [14] NE TZE R, \nR. N., A ND MI L L E R , B. P. Detecting data races in parallel program executions. In LCPC (1989). [15] \nPE T ROV, B., VE C H E V, M., SRI D H A R A N , M., AND DO L B Y, J. Race detection for web applications. \nIn PLDI (2012). [16] POZ NI A N S KY, E., A N D SC H U ST E R, A. Ef.cient on-the-.y data race detection \nin multithreaded c++ programs. In PPoPP (2003).  [17] RICHARDS, G., LEBRESNE, S., BURG, B., AND VITEK, \nJ. An analysis of the dynamic behavior of JavaScript programs. In PLDI (2010). [18] SEN, K. Race directed \nrandom testing of concurrent pro\u00adgrams. In PLDI (2008), pp. 11 21. [19] SHI, Y., PARK, S., YIN, Z., LU, \nS., ZHOU, Y., CHEN, W., AND ZHENG, W. Do i use the wrong de.nition?: Defuse: de.nition-use invariants \nfor detecting concurrency and se\u00adquential bugs. In OOPSLA (2010). [20] WebKit. http://www.webkit.org/. \n[21] ZHENG, Y., BAO, T., AND ZHANG, X. Statically locat\u00ading web application bugs caused by asynchronous \ncalls. In WWW 2011 (2011). Appendix: Proofs Theorem 3.5. If a race R . races(p) \\ uncovered(p), then \nR is not an accessible race. Sketch of Proof: Assume that a covered race R = (a, b) is an accessible \nrace in p. This means that there is trace p1 . [ p] , such that b is the last operation in p1 and a . \np1 . Let R be covered by {Si = (ci, di)}n . Then dn j b and from i=1 condition 2 in De.nition 3.3 . dn \n. p1 . Let us denote a = d0. We will show that for every i . [0, n], di . p1 and di is not the last operation \nof p1 . For i = n, we have shown it already. From di not being the last operation of p1 and from condition \n3 (a) . ci . p1 . But ev(ci) = ev(b) and because the trace p1 is valid, end(ev(ci)) . p1 . But from ev(di-1)jev(ci) \nand end(ev(ci)) . p1 . di-1 . p1 . From d0 = a . p1 , follows that R is not a accessible race in p. Theorem \n3.6. Any race R . uncovered(p) is an accessi\u00adble race in p. Sketch of Proof: Let R = (a, b) . uncovered(p). \nFor each of the remaining races are not always after R, let their corresponding pairs of event actions \nbe: X = {(ev(c), ev(d))|S = (c, d) . races(p), S = R, bjd} We build the smallest transitively closed \nrelation B* , from the set B, which joins the happens-before relation with X (B = j .X). We will analyze \nB as a directed acyclic graph. Then we will build a consistent trace p1 , following a topological order \nof B* . First we will show that, z = (ev(a), ev(b)) . B* . Let us assume z . B* . R is a race . z .j. \nThen there is a path p from a to b in B, for which at least one arc from the path is in X and the remaining \narcs are inj. Let us take the races of arcs of p in X and put them in the set {Si}n . Then all the i=1 \nconditions in De.nition 3.2 are satis.ed and {Si}n . R. i=1 This is a contradiction with R . uncovered(p), \nso z . B* . From z . B* , we can traverse the nodes of B* in an order, such that we traverse b before \ntraversing a. We will build a trace p1 by adding the operations from p in this order, such that b is \nthe last operation of p1 . Then we need to verify if the constructed p1 satis.es the conditions of De.nition \n3.3. Condition 1 is satis.ed by construction, condition 2 is satis.ed becausej. B* and condition 3 is \nsatis.ed because X . B* . Following standard semantics of operations, it can be shown that p1 . [ P] \n. Then p1 . [ p] . But a . p1 , which means that R = (a, b) is an accessible race.    \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Like shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug. Race detection for such programs is hampered by their pervasive use of ad hoc synchronization, which can lead to a prohibitive number of false positives. Race detection also faces a scalability challenge, as a large number of short-running event handlers can quickly overwhelm standard vector-clock-based techniques.</p> <p>This paper presents several novel contributions that address both of these challenges. First, we introduce <i>race coverage</i>, a systematic method for exposing ad hoc synchronization and other (potentially harmful) races to the user, significantly reducing false positives. Second, we present an efficient connectivity algorithm for computing race coverage. The algorithm is based on <i>chain decomposition</i> and leverages the structure of event-driven programs to dramatically decrease the overhead of vector clocks.</p> <p>We implemented our techniques in a tool called <i>EventRacer</i> and evaluated it on a number of public web sites. The results indicate substantial performance and precision improvements of our approach over the state-of-the-art. Using <i>EventRacer</i>, we found many harmful races, most of which are beyond the reach of current techniques.</p>", "authors": [{"name": "Veselin Raychev", "author_profile_id": "81474700236", "affiliation": "ETH Z&#252;rich, Z&#252;rich, Switzerland", "person_id": "P4290325", "email_address": "veselin.raychev@inf.ethz.ch", "orcid_id": ""}, {"name": "Martin Vechev", "author_profile_id": "81100269652", "affiliation": "ETH Z&#252;rich, Z&#252;rich, Switzerland", "person_id": "P4290326", "email_address": "martin.vechev@inf.ethz.ch", "orcid_id": ""}, {"name": "Manu Sridharan", "author_profile_id": "81548007966", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P4290327", "email_address": "msridhar@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509538", "year": "2013", "article_id": "2509538", "conference": "OOPSLA", "title": "Effective race detection for event-driven programs", "url": "http://dl.acm.org/citation.cfm?id=2509538"}