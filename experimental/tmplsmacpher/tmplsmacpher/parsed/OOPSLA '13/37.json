{"article_publication_date": "10-29-2013", "fulltext": "\n The Latency, Accuracy, and Battery (LAB) Abstraction: Programmer Productivity and Energy Ef.ciency for \nContinuous Mobile Context Sensing Aman Kansal Scott Saponas A.J. Bernheim Brush Kathryn S. McKinley \nTodd Mytkowicz Ryder Ziola Microsoft Research kansal@microsoft.com Abstract Emerging mobile applications \nthat sense context are poised to delight and entertain us with timely news and events, health tracking, \nand social connections. Unfortunately, sens\u00ading algorithms quickly drain the phone s battery. Develop\u00aders \ncan overcome battery drain by carefully optimizing con\u00adtext sensing but that makes programming with context \nardu\u00adous and ties applications to current sensing hardware. These types of applications embody a twist \non the classic tension between programmer productivity and performance due to their combination of requirements. \nThis paper identi.es the latency, accuracy, battery (LAB) abstraction to resolve this tension. We implement \nand eval\u00aduate LAB in a system called Senergy. Developers specify their LAB requirements independent of \ninference algorithms and sensors. Senergy delivers energy ef.cient context while meeting the requirements \nand adapts as hardware changes. We demonstrate LAB s expressiveness by using it to imple\u00adment 22 context \nsensing algorithms for four types of con\u00adtext (location, driving, walking, and stationary) and six di\u00adverse \napplications. To demonstrate LAB s energy optimiza\u00adtions, we show often an order of magnitude improvements \nin energy ef.ciency on applications compared to prior ap\u00adproaches. This relatively simple, priority based \nAPI, may serve as a blueprint for future API design in an increasingly complex design space that must \ntradeoff latency, accuracy, and ef.ciency to meet application needs and attain portabil\u00adity across evolving, \nsensor-rich, heterogeneous, and power constrained hardware. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. Copyrights for components of this work owned by others than the author(s) \nmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. Request permissions from \npermissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, USA. Copyright is held by \nthe owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509541 \n Categories and Subject Descriptors H.3.4 [Systems and Software]: Performance evaluation (ef.ciency and \neffective\u00adness) Keywords sensor API, mobile sensing 1. Introduction Emerging personalized mobile applications \nand operating system services based on user context have the potential to revolutionize the mobile experience, \nbut only if they do not render your phone powerless. Mobile context sensing can in\u00adfer your location \n[24], movements [14], social situation [20], mood [28], and stress levels [27]. Applications [16] and \nop\u00aderating system services [39] can sense context in the back\u00adground and act when the user transitions \ninto a relevant con\u00adtext. For example on iOS and Android, applications can re\u00adquest a callback when the \nuser reaches a speci.ed location using OS APIs. Unfortunately, continuously computing context drains \nmobile batteries quickly. We found Android s addProximityAlert API on HTC Desire S reduces battery standby \ntime from 430 to 12 hours. Since mobile devices do more than sense location and users expect at least \n16 hours of battery life [1], context sensing is not yet energy ef.cient enough for continuous use. Context \nsensing can however be made energy ef.cient. For example, if an application can tolerate sensing every \none minute instead of continuously, the standby battery life on the Android HTC Desire S doubles to 24 \nhours. Optimiza\u00adtions such as using the accelerometer for a few seconds ev\u00adery minute to detect user \nmovement and then trigger location sensing only if the user is mobile further increases battery life \nby 300%, to over two days. In fact, prior research pro\u00adposed a range of energy ef.cient continuous context \nsensing algorithms [4, 7, 14, 18, 19, 24, 38, 40]. The problem is that not all available techniques bene.t \nevery scenario. The application developer must choose the appropriate algorithm and its parameters. Developers \ncould potentially implement and characterize these algorithms and determine which one is most ef.cient \nfor their application, but this approach increases the programming burden and some developers lack the \nresources, time, or expertise. Even when a motivated developer implements the right sensing al\u00adgorithm, \nit only serves one application and other applications may continue to drain the battery performing the \nsame task. To make context sensing both ef.cient and widely useful to programmers requires an appropriate \nabstraction. This paper identi.es, implements, and evaluates the La\u00adtency, Accuracy, and Battery life \n(LAB) abstraction, which seeks to simultaneously obtain programmer productivity and ef.ciency for continuous \ncontext sensing. Applications con\u00advey priorities and requirements on the latency at which a context change \nis detected, the accuracy of the inferred con\u00adtext, and battery consumed. The implementation of the ab\u00adstraction \nselects and tunes its context sensing algorithms to meet the constraints and optimizes battery life by \nadjusting sensing frequency, modality, complexity of signal process\u00ading, communication with cloud services, \netc. This abstrac\u00adtion simply expresses the tradeoffs between latency, accu\u00adracy, and battery life. We \nimplement and evaluate this abstraction in a proto\u00adtype continuous context sensing OS service, named \nSenergy. We implement 22 context algorithms and six example appli\u00adcations. While a user study of programmer \nproductivity is beyond the scope of this paper, we do show that the LAB abstraction captures a wide variety \nof application require\u00adments and simpli.es context programming. We further show that Senergy ef.ciently \nsatis.es application constraints by choosing among the multiple algorithms and that Senergy may optimize \nfor multiple simultaneous applications. This work makes the following contributions. 1. We identify and \npropose the LAB context sensing ab\u00adstraction in which applications specify latency, accuracy, and battery \nlife priorities and requirements, independent of any particular context algorithm. We implement this \nabstraction in Senergy and demonstrate how applications use the Senergy API in simple and sophisticated \nways. 2. We characterize the tradeoff in latency, accuracy, and en\u00adergy offered by 22 location and activity \n(driving, walk\u00ading, stationary) context inference algorithms. Based on the quanti.ed tradeoffs, we describe \nhow Senergy selects the most appropriate context-inference approach at run\u00adtime to simultaneously satisfy \napplication requirements whenever possible and optimize resource use within and across applications. \n 3. We evaluate Senergy using six applications with varying latency and accuracy requirements. The results, \nusing over 4,200 usage hours of real-world data traces collected from 49 participants, show that Senergy \nreduces energy use, often by an order of magnitude, while satisfying application requirements.  As the \ncomplexity of hardware and software continues to explode, operating system APIs will carry a much higher \nburden. In particular, emerging mobile applications are using sensors, search, history, and inference \nto give you ever richer personalized services while at the same time the sensor-rich mobile hardware \noffers substantially better and new features with every generation. We believe that the priorities and \nrequirements speci.cation in Senergy s API is a promising blueprint for managing this complexity. 2. \nMotivation Current systems for continuously sensing context achieve either programmability or energy \nef.ciency, but not both. To achieve both goals requires a new abstraction. A good programming abstraction \nsuccinctly expresses functionality, such that developers convey what they need, but not how to do it. \nThe application programming interface (API) correctly and ef.ciently implements the abstraction. For \ninstance, the MapReduce API expresses a parallel data processing ab\u00adstraction [8]. Developers specify \nwhat tasks are parallel and the runtime determines how to parallelize those tasks. For continuous location \nand activity context, we propose the LAB abstraction which expresses: latency: how long the system takes \nto detect a context change; accuracy: correct\u00adness of the detected change; and battery: what fraction \nof the battery context sensing may consume over a day. These properties ensure application developers \nexpress what they need from context sensing, but they do not overly constrain how the implementation \nmeets these requirements. We show that this abstraction is suf.cient to communicate a wide variety of \napplication requirements for continuous context. Furthermore, we show that the system has suf.cient .exibility \nto simultaneously meet these requirements when possible, optimize for ef.ciency, and optimize across \nmulti\u00adple applications. Section 3 discusses how we implement this abstraction in the Senergy API. Figure \n1: Location Tracking. Latency-energy tradeoffs for six algorithms averaged over four devices. The GPS \nalgo\u00adrithm only uses GPS data, FC uses network Fingerprints over a Cellular data connection, and FW uses \nFingerprints over a WiFi connection. The m, * versions sense location only if they .rst detect movement \nusing accelerometer data. Figure 2: Ef.ciency and productivity tradeoff for possible context APIs. However, \nattaining ef.ciency remains a challenging prob\u00adlem in its own right. Selecting the best algorithms requires \nanalyzing latency, accuracy, and battery on a myriad of mo\u00adbile devices and user behaviors. Consider \nFigure 1, which shows the energy latency tradeoff for six continuous location tracking algorithms that \nwe implement. Variability in latency and energy (x and yaxes, respectively) makes the choice of algorithm \ncomplex. The best algorithm for a particular ap\u00adplication depends on its latency requirements, available \nsen\u00adsors, and (not shown) user behavior. For example, consider two location applications. BuyGro\u00adceries \nnoti.es my spouse with a text message if I stop at a grocery store for over 5 minutes, asking for any \nadditions to our list. WalkHome texts parents the location of middle school students when school ends \nand then updates it every minute until they arrive home. Due to their different latency requirements \n(300 and 60 seconds), Figure 1 shows that dif\u00adferent algorithms are optimal. Sections 4-7 discusses how \nSenergy uses existing context sensing algorithms to meet ap\u00adplication speci.cations and deliver ef.ciency. \n3. Senergy API Design The Senergy API seeks to give mobile-application develop\u00aders an intuitive and stable \nAPI for context that maximizes programming productivity and to give API developers the opportunity to \noptimize energy. We describe the limitations of existing and other potential API design alternatives \nand then describe how Senergy addresses these limitations. 3.1 Context Sensing API Design Space Figure \n2 depicts the programmability and ef.ciency of the range of choices in the context sensing API design \nspace. 3.1.1 Raw The OS makes raw sensor data available to the developer. Android, iOS, and Windows \nPhone provide this API. Devel\u00adopers must implement their own context algorithms using the raw data. As \nFigure 2 highlights, in theory this approach can be very energy ef.cient since applications can perform \nthe minimum sensing required for their needs. In practice, it is quite dif.cult for developer to optimize \nenergy ef.ciency because they have limited access to energy measurements across multiple devices and \nuser behaviors. Multiple appli\u00adcations that need the same context and run on the same de\u00advice will duplicate \nfunctionality and waste energy. On the programmability axis, this approach is the most burdensome for \ndevelopers.  3.1.2 One Default The OS implements one default sensing algorithm for each context, tuned \nto some expected application use. The An\u00addroid and iOS platforms provide such a default for location \nproximity. A single default has the potential to improve pro\u00adgrammer productivity. It can also be energy \nef.cient if the context sensing algorithm matches the needs of applications. Unfortunately, as shown \nin Figure 1, location tracking algo\u00adrithms have a wide range of latency and energy character\u00adistics. \nFor instance, the Android API addProximityAlert is tuned for low latency and for applications that do \nnot need low latency, this default wastes energy. If Android changes the default settings to reduce energy \nusage, it may break ap\u00adplications tested with the current low latency setting. 3.1.3 Fixed Prede.ned \nModes Providing multiple .xed modes could overcome the limita\u00adtions of one default. For instance, the \nOS may offer three modes: energy ef.cient , low latency , and high accu\u00adracy. Fixed Modes fall between \nRaw and Default in terms of productivity because developers do not have to implement their own algorithms, \nbut they do need to understand and choose among the modes. Fixed Modes improve energy ef.\u00adciency over \nDefault because one of the modes is likely closer to the application requirements than the single default. \nThe disadvantage of Fixed Modes is that they still close off too much of the design space. For example, \nsuppose an application needs high accuracy and can tolerate high la\u00adtency, but no mode exposes that choice. \nFixed modes also shoehorn the OS into rigid contracts and limit extensibil\u00adity. If a new algorithm emerges \nthat dramatically improves energy ef.ciency but slightly violates the latency contract in the existing \nenergy ef.cient mode, the OS cannot use it without introducing a new mode or violating the contract. \n 3.1.4 Catalog The OS could expose all its algorithms to applications. A developer then chooses an algorithm \nand sets its parameters. This type of API can achieve high ef.ciency since develop\u00aders may select the \nmost appropriate algorithm and settings for their purpose. Catalog improves programmer productiv\u00adity \nover Raw because a developer need not implement algo\u00adrithms from scratch. However, developers must still \ndeter\u00admine the best choice and parameter settings for their appli\u00adcations. Choosing is challenging because \nit may depend on the user s environment, behavior, and device characteristics. If a better context algorithm \nis added to the Catalog, devel\u00adopers must change their application. If two applications run simultaneously \nand need the same context, but choose dif\u00adferent algorithms, they perform redundant work and waste energy. \n  3.2 Senergy API Speci.cation Our goal is an API design that increases both programmer productivity \nand energy ef.ciency. We organize our design based on two insights. (1) Specifying a priority order among \naccuracy, latency, and energy use (battery) gives developers a simple way to express many application \nconstraints and gives the implementation .exibility to optimize. (2) A par\u00adtial quantitative speci.cation \nof latency and/or battery con\u00adsumption gives developers a more powerful and expressive API, since priorities \ndo not promise speci.c values. Because accuracy requires ground truth from the user or other source, \nguaranteeing or quantifying context accuracy at runtime is beyond our scope, and therefore, developers \ncannot specify a quantitative accuracy value. We show that this LAB (la\u00adtency, accuracy, battery) abstraction \nis suf.cient for a wide range of context applications. We implement the LAB abstraction in the Senergy \nAPI, which exposes location and activity context through an asyn\u00adchronous method, ChangeAlert. The application \nregisters a callback method, and Senergy invokes it each time Senergy detects the speci.ed change in \nlocation or activity. Applica\u00adtions may unsubscribe with UnsubscribeAlert . Table 1 lists the API and \narguments. The .rst method ar\u00adgument speci.es the context, which consists of locations and activities \nin Senergy. We leave other types of context (e.g., mood, attentiveness) to future work. Location and \nactivity by themselves are extremely powerful for many applications including movement tracking, health \nmonitoring, and safe phone interactions while driving. Furthermore, their detec\u00adtion algorithms expose \na range of tradeoffs that we use to explore the latency, accuracy, and energy optimization space. Location \nelements are geographic coordinates. Activities are values in an enumerated type and currently include \nall, driving, walking, and stationary. Since each activity is a pa\u00adrameter, adding new activities is \ntransparent to existing ap\u00adplications. The not operator signi.es exiting a location or activity. For \ninstance, Activity.DRIVING detects the be\u00adginning of driving and .Activity.WALK detects when the user \nstops walking. The parameter values Activity.ALL and Location.ALL result in a callback on all activity \nand location changes respectively. For instance, ChangeAlert (Location.ALL ) continuously tracks user \nlocation. The second and subsequent arguments are optional. The second argument speci.es the highest \npriority choice of ac\u00adcuracy, latency, or energy. The optional third argument either speci.es the next \nhighest priority dimension or quanti.es the prioritized dimension for either latency (seconds) or energy \n(% battery over 24 hr). Subsequent arguments are used sim\u00adilarly. For example, the application may quantify \nlatency at 120 s or battery at 5% of total capacity. Applications cannot Arguments Argument description \nChangeAlert Context[] collection of locations or activities to detect ChangeAlert Context[] collection \nof locations or activities to detect FirstPriority one of accuracy, latency, or battery ChangeAlert Context[] \ncollection of locations or activities to detect FirstPriority one of accuracy, latency, or battery Value \nquantitative constraint for .rst dimension* ChangeAlert Context[] collection of locations or activities \nto detect FirstPriority one of accuracy, latency, or battery SecondPriority one of accuracy, latency, \nor battery ChangeAlert . . . variable number of optional arguments ChangeAlert Context[] collection of \nlocations or activities to detect FirstPriority one of accuracy, latency, or battery Value quantitative \nconstraint for .rst dimension* SecondPriority one of accuracy, latency, or battery Value quantitative \nconstraint for second dimension* ThirdPriority one of accuracy, latency, or battery Value quantitative \nconstraint for third dimension* Table 1: Senergy API. All arguments use custom data types, except for \nconstraint values which uses a double. *Quantitative constraint is not used for accuracy priority. quantify \naccuracy, as discussed above, but including an accu\u00adracy priority in.uences context algorithm selection. \nFor in\u00adstance, if the highest priority dimension is latency, followed by accuracy, then the available \ncontext sensing algorithms are .rst ranked by latency and then accuracy. If accuracy priority is omitted, \nSenergy ranks algorithms by battery ef.\u00adciency instead of accuracy. Senergy defaults unspeci.ed constraints \nto the most bat\u00adtery ef.cient algorithm, subject to OS determined thresholds on useful accuracy and latency. \nThe thresholds are used be\u00adcause a very low energy algorithm that simply hardcodes the location to planet \nearth is not useful context. Context sensing algorithms meet constraints probabilisti\u00adcally on average \nacross large populations. Sensor, network, user, and device variation may prevent the system from meeting \nconstraints systematically or on occasion. Senergy satis.es as many constraints as possible in priority \norder. Applications or the OS may wrap ChangeAlert in or\u00adder to track a particular context state over \ntime or distance (e.g., time spent at work or distance moved while in driving); obtain current context \nwithout initiating continuous sensing; or to expose certain special cases for backward compatibil\u00adity \n(e.g., addProximityAlert which is simply a call to ChangeAlert with a single location as the .rst parameter). \n  3.3 Example API Usage Senergy supports developers with a range of expertise levels, from those who \nsimply use defaults to advanced developers who tune context to match their application needs. We ex\u00adplore \nthis range of programmability with three examples. Example 1. To detect when the user starts walking \nwith\u00adout any constraints, an application invokes Activity[] activities = {Activity.WALKING}; ChangeAlert(activities); \nSenergy uses its default activity algorithm for walking, which provides low battery drain subject to \nminimum thresh\u00adolds on accuracy and latency. This usage minimizes pro\u00adgrammer effort, and is equivalent \nto specifying battery as the only priority. Example 2. To detect each time a user starts driving and \ncount car trips, assuming the application can tolerate a 5 minute latency for the start driving noti.cation, \nsince most driving trips will last at least 5 minutes, it invokes Activity[] acts = {Activity.DRIVING}; \nChangeAlert(acts, Priority.Latency, 300); Senergy selects an algorithm that detects driving at 300 s \nla\u00adtency with high probability. Among all such feasible options it chooses the most energy ef.cient algorithm \nthat respects a minimum accuracy threshold. This algorithm meets the pro\u00adgrammer speci.cation, but it \nmay not provide the most ac\u00adcurate context feasible. We believe that specifying only the critical constraints \nimproves programmer productivity. Example 3. With the same objective as above, the developer now also \nwants to restrict the battery impact of the application to 1% over 24 hours, to help ensure users choose \nto keep it installed. The developer still prefers a 5 minute latency, and would additionally like the \nhighest possible accuracy. The application invokes ChangeAlert(acts, Priority.BATTERY, 1, Priority.Latency, \n300, Priority.Accuracy); Senergy chooses an algorithm that satis.es as many con\u00adstraints as possible. \nIf multiple choices meet the 1% battery and 300 s latency constraints, Senergy chooses the one with the \nhighest expected accuracy. If no algorithm achieves 5 minute latency within 1% battery budget, it uses \na longer latency, since battery is the highest priority. Specifying all constraints requires extra programmer \neffort but much less than implementing an algorithm from scratch, or manually selecting an algorithm \nfrom a catalog. 4. Senergy Resource Optimization The API design described above gives the OS signi.cant \n.exibility for optimizing and evolving context sensing algo\u00adrithms, without exposing implementation details \nand forc\u00ading unnecessary constraints. We implement Senergy on top of existing sensing capabilities in \nmobile devices. Figure 3 shows the overall architecture. The hardware abstraction layer (HAL) consists \nof components that already exist in mo\u00adbile OSs: raw sensor drivers and a location stack that can ob\u00adtain \nlocation using GPS or network .ngerprints (WiFi access points, cellular base station IDs, and their signal \nstrengths), using an Internet service to convert .ngerprints to location. Figure 3: Senergy architecture. \n Senergy needs multiple algorithms for each context type since they offer different accuracy, latency, \nand energy ef.\u00adciency. At runtime, Senergy selects the most suitable algo\u00adrithms and parameter values \nbased on application needs. For these purposes, we add three components: two context mon\u00aditoring components, \ndenoted Activity Context and Location Context, that include multiple algorithms to continuously sense \nand infer user context in the background, and the run\u00adtime algorithm selection and tuning component that \nimple\u00adments the runtime logic to select appropriate algorithms and tune their parameters, based on application \nrequirements. These three components comprise the bulk of the Senergy implementation and are described \nin the next three sections. Application developers need not understand any of these im\u00adplementation details \nto use the API. Algorithms: A variety of context inference algorithms for movement activity and location \nmonitoring are avail\u00adable [3, 7, 14, 18, 23, 24, 30, 32, 37, 40]. We select rep\u00adresentative ones and \nstudy the tradeoffs in their energy, ac\u00adcuracy, and latency. We choose general algorithms that are as \nindependent as possible of particular user behaviors and their environments. For instance, we do not \ninclude methods that require the sensor to be mounted on a particular position on the body [37] or constant \nWiFi availability, and do not as\u00adsume that users will park a minimum distance from their des\u00adtination, \nwork and live in two different locations, etc. Some algorithms exploit non-universal infrastructure where \navail\u00adable to improve ef.ciency, but have fall backs for other en\u00advironments. 5. Activity Context We \nimplement (1) three binary classi.ers that detect the presence or absence of driving, walking, and stationary, \nand (2) a multi-state activity classi.er that infers if the user is Algorithm Sensor Features D-ACC \nAccelerometer magnitude (0.5-3 Hz), magnitude (20-25 Hz), variance D-GPS Assisted GPS speed D-AG ACC \nand GPS D-ACC and D-GPS D-CELL Cellular .ngerprint new towers in window compared to past windows D-CA \nCELL and ACC D-CELL and D-ACC D-GC GPS and CELL D-GPS and D-CELL D-AGC ACC, GPS, CELL combines all algorithms \n Table 2: Driving detection algorithms. driving, walking, or stationary. For applications that require \na single movement state, the binary detectors deliver higher accuracy, while the multi-state classi.er \nis better when all states are to be distinguished. Activity inference algorithms employ a typical machine \nlearning approach: sense over a time window, compute fea\u00adtures from the sensor data (e.g., features listed \nin Table 2 for driving), and classify the data using a model previously trained on ground truth. In Senergy \nwe use a Na\u00a8ive Bayes classi.er with supervised discretization. We chose this tech\u00adnique for simplicity \nof implementation and because it gener\u00adates posterior probabilities that may be used as a con.dence measure \nby applications. We expect other classi.ers to also work well (e.g., decision tree, support vector machine). \n5.1 Driving Activity Table 2 lists seven algorithms that we implemented for driv\u00ading detection, using \nthe accelerometer, cellular, and GPS data [23, 30, 32, 37]. Algorithm D-ACC is based on the accelerometer, \nusing features from [30]. D-GPS uses speed sensed using GPS. D-CELL is largely inspired by [32] but differs \nin that we only consider changes in detected towers (we do not consider features based on signal strength \nas we did not .nd them effective in our environment). The remain\u00ading algorithms combine multiple sensors \nto achieve better accuracy or enhance generality. We tuned the feature sets of all the activity algorithms \nto improve their accuracy based on our multiple user deployments in indoor, outdoor, urban, and suburban \nenvironments.  5.2 Driving Activity Tradeoffs These algorithms provide a design space that Senergy uses \nto tradeoff accuracy, latency, and energy. We quantify these tradeoffs below to select the best operating \npoint. We consider continuous background sensing while the device is not in active use, since active \ntime is only a small fraction of the total time for which the device is carried by the user. For background \nsensing, energy drain includes not just the sensors but also the processing or storage compo\u00adnents used \nto drive the sensors and infer context. Figure 4 shows a sample accelerometer power trace on a Samsung \nFo-  Figure 4: Background accelerometer power OS Platform Devices Android OS 2.3.2 HTC Desire Nexus \nS Windows Phone 7.1 Samsung Focus Asus E600 Table 3: Experimental mobile devices. cus smartphone. We \nmeasure power by connecting a power meter to the phone s battery terminals. Power includes the accelerometer \nsensor, processor, and all active motherboard components when the accelerometer collects data. We measure \nenergy on the four devices listed in Table 3. Table 4 lists the sensing energy for each sensor used in \nactivity detection algorithms. Our measurements are similar to previous ones on Nokia N95 [24], Android \nG1 and ATT Tilt [18, 40], and iPhone [35]. All our experimental phones use assisted GPS (a-GPS). With \na-GPS, cold and warm start burn about the same amount of energy, and we report a single number. The total \nenergy of a context inference algorithm depends on which sensors it uses and how often. For instance, \nD-CELL collects the cellular .ngerprint multiple times to infer if the user is driving, and actual inference \nenergy is higher than the single sample energy listed in Table 4. Since accuracy, latency and energy \ncharacteristics of con\u00adtext algorithms vary signi.cantly with user behavior and en\u00advironment, we collected \nseveral experimental data sets (de\u00adscribed in Section 8) across multiple participants in different environments. \nWhile none of our participants may exactly match a particular user s behavior or environment, our data \nprovides a statistical estimate of the tradeoffs between algo\u00adrithms. It would be ideal to learn the \ntradeoffs individually on every user but computing accuracy requires ground truth labels that are dif.cult \nto obtain for every user. Figures 5a and 5b report the accuracy and latency trade\u00adoffs with energy for \nthe seven algorithms. For three of the al\u00adgorithms, latencies lower than 600 s are not feasible, truncat\u00ading \nthose curves. All algorithms have reasonable accuracy, precision, and recall, although the higher energy \nalgorithms do better. Here we also measured precision and recall, since accuracy alone can be misleading. \nFor instance, when users drive only a small fraction of the time, an algorithm that al\u00adways outputs not-driving \nwill be accurate. However, this al\u00adgorithm has poor recall. Accuracy refers to how closely the values \nreturned by the sensing algorithms match the ground truth. Precision is tp/(tp + f p) where tp are true \npositives (b) Latency Figure 5: Driving Detection accuracy, latency and energy tradeoffs. Accuracy, \nprecision, and recall points at one en\u00adergy level correspond to the same algorithm label. Standard deviations \n(not shown for readability) on all users are be\u00adlow 5% except for D-CELL, where they are as high as 15%. \nSection 7 describes the solid gray lines. (a) Latency and Energy (b) Accuracy Figure 6: Walking detection \nlatency, energy, and accuracy tradeoffs. The highest energy point uses a latency of 5 s. Logarithmic \nscale is used for the energy axis to capture the wide range of tradeoff points. 6. ALL Sensor Avg. \nEnergy (mJ) Std. Dev. (mJ) Fingerprint scan, WiFi+Cell 565 NA 3G Internet 10592 1393 WiFi Internet 738 \n15 Fingerprint location Cell (FC) 11157 1393 Fingerprint location WiFi (FW) 1303 15 Table 5: Energy used \nby location primitives averaged across multiple devices. Fingerprint energy is measured only on Asus \nE600. Since accuracy is not correlated with energy, Senergy cannot tradeoff accuracy for energy. Hence, \nSenergy .rst attempts to update location using GPS and if that fails, it uses network .ngerprint based \nlocation. Location Proximity. If an application does not require all location changes but only proximity \nto speci.c locations, then Senergy performs an additional optimization. We re\u00adduce the number of location \nupdates based on the current distance from the nearest interesting location. The intuition is that if \nthe nearest interesting location is a distance x away, and the maximum speed of movement is vmax, then \nit will take the user at least tmin = x/vmax time to reach the new location. The value of vmax could \nuse the maximum speed limit in the country, except when the previous location is near an air strip where \nmaximum aircraft speed may be used. Hence, the next location update may happen after a wait of slightly \nless than tmin. If tmin is smaller than the delay toler\u00adated by the application, Senergy will use the \ntolerable delay. If tmin is so large that a location update at that interval is cheaper in energy than \nperiodically sensing movement, the movement sensing is dropped until tmin reduces. Whenever Senergy updates \nlocation, the algorithm checks if the loca\u00adtion is within a speci.c radius of one or more of interest\u00ading \nlocations and noti.es the application accordingly. When the number of interesting locations is very large \nand there is always some interesting location nearby, tmin becomes the application speci.ed latency and \nthe algorithm reduces to continuous location tracking. 6.1 Location Tradeoffs Table 5 shows energy measurements \nfor the additional sen\u00adsor primitives required for location. The actual energy con\u00adsumption depends on \nwhich of these primitives are used and how often. We found in our test data that most users move less \nthan 16% of the time during a day. Assuming that mo\u00adtion is detected every two minutes, Figure 1 shows \nthe la\u00adtency and energy tradeoff for tracking location for six dif\u00adferent options. Senergy uses this \nanalysis to select the most appropriate algorithm at runtime. The actual energy use for a user over a \nday will vary since Senergy will dynamically switch between GPS and .ngerprint based location as ap\u00adpropriate. \nLocation accuracy is not considered here since the Figure 8: Accuracy for multi-class activity detection. \n choice of .ngerprint and GPS depends on availability and user permissions. 7. Runtime Algorithm Selection \nThe quantitative trade-off graphs show that certain algo\u00adrithms do not yield a measurable advantage in \nany dimen\u00adsion. For instance, D-CA is very similar to D-ACC in ac\u00adcuracy (Figure 5) but D-ACC provides \nmuch lower latency. Hence, we eliminate D-CA, and similarly, W-GPS. However, many algorithms are better \nthan others on some dimension and no single obvious choice serves all scenarios. For instance, Figure \n5a shows that algorithms that are worse on battery use are in fact better in accuracy. For the same energy \ndrain, a lower accuracy algorithm can provide better latency, and vice versa. Senergy selects the appropriate \nal\u00adgorithm at runtime when an application makes an API call specifying its requirements. Once the requirements \nare available, the selection of the best approach is simply a matter of limiting the search space to \nthose requirements, in the order of prior\u00adity listed in the API call. As an example, suppose the API \ncall is ChangeAlert (Activity.DRIVING, Battery, 5, Priority.LATENCY, 300, Priority.ACCURACY). Fig\u00adure \n5b shows that with these battery and latency constraints (shown as gray lines) algorithm D-ACC, D-GPS, \nand D-AG are the available choices. Considering the last argument re\u00adquesting an accuracy priority, Senergy \nselects D-AG, that has the highest accuracy among feasible options. Selecting the algorithm at runtime \nhas the advantages that (1) as con\u00adtext algorithms evolve and tradeoffs improve, such as by us\u00ading low \npower processors [17, 26], better algorithms will get selected, transparently bene.ting applications, \nand (2) run\u00adtime conditions can be exploited, such as ignoring the battery constraint if the phone is \nplugged in. Senergy defaults to maximizing energy ef.ciency when the API call is under-constrained. For \ninstance, if the third priority request for accuracy was absent from the above API call, Senergy would \nchoose D-ACC, the most battery ef\u00ad.cient option satisfying the .rst two constraints. If over\u00adconstrained, \nSenergy ignores the lowest priority constraints. The API call returns a list of the constraints expected \nto be ignored based on the algorithm tradeoffs at runtime. In fu\u00adture work, we plan to return con.dence \nintervals with ev\u00adery context change callback, to the extent such error can be estimated. In future work, \nwe plan to return con.dence intervals with every context change callback, to the extent such error can \nbe estimated. For example, error estimates could be based on posterior probabilities returned by the \nin\u00adference algorithms or error data from sensor drivers (e.g., Horizontal dilution of precision (HDoP) \nfrom GPS) or the sensing service (e.g., .ngerprint based location services re\u00adturn a server computed \nerror). Error conditions could also be estimated from sensor operating conditions such as GPS satellite \ncount, user permissions for microphone and camera, etc. that affect the validity of sensor data. Compile \ntime fea\u00adsibility checks are undesirable because future improvements to the context stack may expand \nthe feasible search space. 7.1 Multiple Simultaneous Applications If multiple applications are simultaneously \nactive, Senergy considers the constraints jointly and enforces the tightest constraints. Of course, constraint \nspaces from different ap\u00adplications may not overlap. We do not assume that any one application has a \nhigher priority. Instead, we use a default priority order on the constraints. We .rst drop any battery \nrelated constraints and attempt to satisfy the accuracy and latency requirements alone. If even these \nare con.icting, we prioritize latency and drop the accuracy requirement. Prefer\u00adring accuracy and latency \nover energy is based on the intu\u00adition that application functionality may be more important than the \nrecharge interval. Among accuracy and latency, we prioritize latency for timeliness. Other priority orders \namong the three dimensions may be implemented, such as when ap\u00adplications belong to different priority \nclasses. 8. Evaluation This section shows how Senergy improves ef.ciency com\u00adpared to other API design \nchoices while meeting application requirements. In particular, the proposed API yields multiple orders \nof magnitude savings compared to the existing con\u00adtext API (addProximityAlert ). 8.1 Datasets used in \nEvaluation We collected over 4,200 usage hours of mobile sensor data from 49 participants, as follows. \nDriving Data. Ten people labeled when they were Driving for up to 5 days each. Driving trips were primarily \ncommutes with a few side trips. Users tapped a button in our logging application when they entered and \nexited their car. Intermittent stops due to traf.c control and congestion are considered driving. A background \nservice continuously col\u00adlected accelerometer, GPS, and network .ngerprint scans. Multi-Activity Data. \nWe collected ground truth data for 10 participants for driving, walking, and sitting in one hour guided \nsessions by accompanying participants and manually recording ground truth on a separate time synchronized \nde\u00advice. Each participant carried three phones: in their pocket, backpack, and hand/cup-holder. We use \nthis data to evaluate all of our activity sensing algorithms and application scenar\u00adios involving multiple \nactivities. Routine Location Data. We collected location and ac\u00adcelerometer data from 18 participants \nrunning our logging application on their own mobile device for 1 to 12 days. This data set contains a \ntotal of 124 days of user traces. To ensure the mobile device batteries last at least a day, we collect \ndata for 5 seconds in every minute. We test location algorithms and applications with this data. Workday \nData. We logged continuous accelerometer data from 11 participants for 6-8 hours on one workday each; \na total of 69 hours of participant data. We use this data to evaluate activity applications at extremely \nlow latency set\u00adtings, which is not possible on the other, larger but duty cy\u00adcled, datasets.  8.2 \nAPI Con.gurations We compare Senergy with the other API choices (from Sec\u00adtion 3) implemented as follows. \nRaw: We implement simple algorithms over raw sensor data, such as checking location periodically to infer \nif the user is near a desired location. We optimize the frequency of checks based on expected context \nrequirements (speci\u00ad.ed below for each activity). In theory, developers could im\u00adplement the best algorithms \nin Senergy, in which case the energy consumption is the same, unless the user executes multiple background \napplications where Senergy has the ad\u00additional advantage of sharing context. Default: We emulate existing \nimplementations in the An\u00addroid OS. For instance, for detecting proximity to a set of lo\u00adcations, we \nuse the Android approach of periodically check\u00ading location. For activity contexts (e.g., driving, walking) \nthat have no current Android API, we created a default algo\u00adrithm that senses continuously with the lowest \nlatency anal\u00adogous to the implementation of addProximityAlert . Fixed Modes: In .xed mode, the system \noffers multiple defaults. We implement three representative modes that each prioritize one of energy, \naccuracy and latency. Fixed-E: The Fixed-E mode prioritizes energy ef.ciency. It assumes a two minute \nlatency is acceptable for all appli\u00adcations. It uses the lowest energy inference algorithm that is suf.ciently \naccurate to be included in the OS. For instance, location tracking uses the low power sensors every two \nmin\u00adutes to detect movement. If the user is moving, it updates the location at two minute intervals. \nFixed-A: The Fixed-A mode prioritizes accuracy by us\u00ading the most accurate inference algorithm available. \nIt as\u00adsumes that a one minute latency is acceptable for all appli\u00adcations. For instance when tracking \nlocation, Fixed-A does not use the low power sensors to .rst detect user movement, since the errors in \nmovement detection may miss periods of movement and increase the overall error in location. Fixed-L: \nThe Fixed-L mode prioritizes latency by sup\u00adplying the lowest possible latency, which on our platforms \nis 5 s and is the lowest latency at which a-GPS may obtain a location .x. Fixed-L tracks location using \nthe low power sensors to detect movement at the 5 s interval before sensing location. Senergy con.gurations: \nFor the purposes of this evalua\u00adtion, we choose two Senergy con.gurations for each appli\u00adcation out of \nthe wide range of priorities and constraints that developers may specify: Senergy-S: The application \ndeveloper expresses one pri\u00admary priority, either energy, accuracy, or latency, and option\u00adally a quantitative \nconstraint. Senergy-M: The application developer expresses multi\u00adple priorities and constraint values. \nWe now consider six different applications. Three appli\u00adcations use location context and three use activity \ncontext. 8.3 Location Context Case Studies ClubPoint. After purchasing a mattress, Alice realized she \ncould have saved 15% if she had remembered to use her AAA Club card. Alice writes the ClubPoint application \nto remind her to show her card at participating stores. She sets latency to 5 minutes (300 s) since she \nonly wants noti.cations when she stays in a store long enough to buy something. The Senergy-S (single \npriority) call is: Location[] locations = GetAAALocations(); ChangeAlert(locations, Priority.LATENCY, \n300) Using the algorithm from Section 6, Senergy-S checks for movement using the accelerometer and if \nthe user is moving, it updates the location at the speci.ed latency. Alice explores the API further and \ndecides to add a battery budget of 5% daily consumption and request high accuracy as a third priority. \nThis multiple con\u00adstraint Senergy API call (Senergy-M) for ClubPoint is: ChangeAlert (locations, Priority.BATTERY, \n5, Priority.LATENCY, 300, Priority.ACCURACY) Because there is a 5% battery budget, Senergy can sense \nmovement more frequently than the default 2 minutes. Since our Routine Location Data indicates that most \npeople move up to 16% of the time over a 24 hour window, Senergy reserves suf.cient battery out of the \n5% to update location every 300 s for 16% of 24 hours, and uses the remaining budget to check user movement \nvia the accelerometer. Using the energy measurements for location sensing, with a mix of indoor and outdoor \nlocations, as well as low power movement sensing (Tables 4 and 5), we obtain a movement sensing frequency \nof 54 s. The third requirement of high Accuracy priority is ignored since increasing accuracy by avoiding \nthe error from movement sensing is not feasible within the 5% battery budget. Figure 9 compares ClubPoint \ncon.gurations for Raw, De\u00adfault, Fixed, Senergy-S, and Senergy-M. It plots average en\u00adergy for 18 participants \nwith their routine movement patterns (Routine Location Data). Log scale is used for clarity. The error \nbars show the standard deviation in energy usage across multiple participants. Fixed-A, Raw, and Default \ndo not de\u00adpend on user behavior and have zero standard deviation. Default, the existing implementation, \nrequires 177% of the battery in a 24 hour day, exhausting the battery in less than 24 hours. All other \nchoices reduce battery drain. Fixed-L (latency mode) reduces energy draw to 73.4%. This sav\u00adings come \nfrom checking for movement every 5 s (the smallest latency) and activating the GPS only when the user \nis mobile, rather than continuously. Fixed-A (accuracy mode) saves energy because it only checks for \nlocation every minute rather than continuously. Fixed-E (energy mode) op\u00aderates within 4% of the battery, \nbut it is still wasteful since it updates location every two minutes and does not exploit the application \ns latency tolerance of 5 minutes. Raw checks for location every 5 minutes, but does not use movement \nsens\u00ading .rst, and thus burns slightly more battery than Fixed- E. Senergy-S provides the lowest energy \ndraw, using only 2.7% of the battery capacity over a 24 hr period. Senergy-Muses more battery, 4.5% because \nthe developer speci.ed up to 5%. Senergy-M exploits the allowed battery budget to offer higher accuracy \nby checking for movement more often. SimplySave. Jason installs SimplySave, a coupon ap\u00adplication that \nalerts him whenever he passes by a business that offers a discount. Unlike ClubPoint, SimplySave wishes \nto detect proximity to participating locations with a lower latency of 60 s, since the user may not spend \nmuch time at each location. The Senergy-S API call is ChangeAlert (locations, Priority.LATENCY, 60) Senergy-S \nupdates location every 60 s and optimizes energy over accuracy by .rst checking for movement every minute \nand only checking location if the user is mobile. The Senergy-M API call constrains battery budget to \n5%: ChangeAlert (locations, Priority.LATENCY, 60, Priority.BATTERY, 5) Senergy-M uses 60 s as the latency \nlimit and the optimizes energy. Given latency is the higher priority, the expected energy usage is not \nbelow 5% and therefore the battery constraint and any subsequent ones are ignored. The SimplySave bars \nin Figure 9 show Fixed-E is not ap\u00adplicable because its two minute latency does not satisfy the application \ns latency requirements. Default, Fixed-A, and Fixed-L for SimplySave do not use any of the application \nspeci.c information and thus are the same as ClubPoint. The Raw implementation checks location every \nminute, resulting in 28% battery drain. Senergy-S SimplySave however uses more energy, 8.04%, compared \nto ClubPoint, since it deliv\u00aders the lower 60 s latency. Senergy-M and Senergy-S behave the same for \nSimplySave because the additional constraints from the developer are not achievable. GeoReminder. Jim \nuses GeoReminder to add a loca\u00adtion based reminder to pick up a book when he passes the bookstore on \nhis way to the bus stop. GeoReminder requires low latency because Jim will only be near the store brie.y. \nThe key difference from the previous scenario is that Sen\u00adergy only needs to detect one location. Even \nthough Geo-Reminder needs low latency, Senergy only needs to update location at that latency when the \nuser is close to the desired location. For instance, if Jim lives 10 miles away from the store, then \nfor a large part of the day, Senergy only updates location every 10 minutes, assuming it takes at least \n10 min-Figure 9: Location context application energy on a log scale with Routine Location Data, averaged \nover four platforms. Values greater more than 100% indicate the battery is ex\u00adhausted in less than a \nday. Error bars show standard devia\u00adtion in behavior across 18 participants.  utes to move 10 miles. \nThe API calls are the same as for SimplySave. Figure 9 shows Senergy uses lower energy on average for \nGeoReminder than for SimplySave. 8.4 Activity Context Case Studies This section presents three activity \ncontext applications. For the Raw API, the developer must implement an activity inference algorithm, \nwhich could be the same as the one in Senergy. Hence we omit comparing to the Raw option. DriverMode. \nDriverMode activates a driver-mode user experience on the phone when it detects the user is in a moving \nvehicle. For example, it suppress non\u00adcritical noti.cations, turns on voice only, and allows family members \nand close friends to observe that the user is driving. A simple Senergy-S API call is ChangeAlert (Activity.DRIVING, \nthat only asks Priority.ACCURACY) for high accuracy. Senergy-S uses its default latency (2 minutes) \nand uses the highest accuracy algorithm, D-AG within that latency. Another developer may de\u00adcide that \nthe application should act quickly once the user starts driving, and use a more sophisticated call (Senergy-M) \nspecifying three constraints, prioritized: latency 60 s, 5% of the battery per day, and high accuracy \nas ChangeAlert(Activity.DRIVING, Priority.LATENCY, 60, Priority.BATTERY, 5, Priority.ACCURACY) Senergy-M \nchecks for driving activity every minute but will use the lower energy algorithm D-ACC, since D-AG is \nnot feasible within the requested battery budget. The third priority requirement, accuracy, is ignored. \nThe Default approach continually senses and infers activity, similar to what existing OSs do for location \ncontext. Fixed-A checks Figure 10: DriverMode and RadioGuide energy with Driving Data.  for activity \nonce every 60 s, Fixed-E checks every 120 s, and Fixed-L every 5 s. Figure 10 compares the energy use \nfor all API choices for DriverMode. While Default and Fixed-L use more than 100% battery and are impractical \nfor real deployment, Fixed-A and Senergy-S both provide high accuracy at sig\u00adni.cantly lower energy, \ndue to increased latency. Specifying a battery constraint of 5% with Senergy-M reduces battery consumption \nto 3.6% by switching the algorithm to D-ACC from D-AG, which degrades accuracy (see Figure 5). Fixed-E \ngoes even lower due to increased latency. RadioGuide. RadioGuide publishes free local ra\u00addio station \nschedules. In return, users allow the ap\u00adplication to anonymously track when they drive and listen to \nthe radio, to aid radio stations in optimizing their schedules. Because radio stations are most in\u00adterested \nin drives longer than 5 minutes, RadioGuide sets its latency to 5 minutes. The Senergy-S API call is: \nChangeAlert (Activity.DRIVING, Priority.LATENCY, 300) Senergy-S checks for driving every 5 minutes. Since \nenergy and accuracy are unspeci.ed, Senergy-S defaults to saving energy and uses the lowest energy algorithm, \nD-ACC. The Senergy-M con.guration uses the same latency, restricts battery use to 5%, and requests high \naccuracy: ChangeAlert(Activity.DRIVING, Priority.LATENCY, 300, Priority.BATTERY, 5, Priority.ACCURACY) \nSenergy determines that both D-ACC and D-AG are feasible within the allowed battery budget at this latency, \nand chooses D-AG since RadioGuide speci.es high accuracy. Figure 10 compares the energy use for the various \nAPI choices. Senergy-M does use less energy than the other APIs, but more than Senergy-S, since it improves \naccuracy within the developer speci.ed budget. FitnessTracker. FitnessTracker counts a user s daily steps \nto estimate calorie use. It is representative of mobile applications that track .tness related activities \nto help motivate a more active lifestyle [6]. FitnessTracker wants (a) Energy (b) Error  Figure 11: \nFitnessTracker energy and accuracy trade-offs using Workday Location Data. a callback whenever the OS \ndetects walking and will then access the accelerometer data to start counting steps until the user stops \nwalking. To not miss short walks, the devel\u00adoper requests a 10 s latency with the Senergy-S API call: \nChangeAlert(Activity.WALKING, Priority.LATENCY, 10) Senergy senses every 10 s using the W-ACC algo\u00adrithm \nwhich has the lowest energy. To control battery use, the FitnessTracker Senergy-M call includes a 5% \nbattery limit as the .rst priority constraint, keeps la\u00adtency as its second priority, and requests high \naccuracy: ChangeAlert(Activity.WALKING, Priority.BATTERY, 5, Priority.LATENCY, 10, Priority.ACCURACY) \nSenergy computes that for this battery constraint, the fastest it can sense is every 44 s using the lowest \nenergy walking detection algorithm, and thus ignores the lower priority constraints of latency and accuracy. \nThe other modes use their .xed settings. Figure 11a compares the energy use. While in Radio-Guide, the \nlatency goal was to simply satisfy the applica\u00adtions latency requirement, in FitnessTracker, the actual \nla\u00adtency affects the accuracy of walk time and step counting. Figure 11b plots accuracy of walk detection. \nLower latency does improve the accuracy signi.cantly, especially for two users in our Workday Location \nData who take many short walks (not shown), though at the expense of extra energy. Default and Fixed-L \ndo not miss any short walks (no error). The error inherent to the walk detection is not included since \nit is same across all API choices.  8.5 Multiple Simultaneous Applications Finally we illustrate the \nsavings when multiple context track\u00ading applications are running simultaneously. As a baseline, we assume \nthat each application was written by an expert and was individually optimized using the same techniques \nas Senergy. However, using Senergy is still advantageous. With Senergy, energy is spent on the sensors \nonce and the sensor data is used to compute all context outputs needed by the various applications as \nopposed to each application ac\u00adcessing the sensors at the time that it wakes up. Secondly, if the algorithm \nused for one application suf.ces for others, even though it uses a different sensor, then Senergy does \nnot use the other sensors or algorithms (e.g., if one application is repeatedly using GPS while another \none was using the ac\u00adcelerometer to detect movement before activating GPS, then Senergy turns off the \naccelerometer since GPS is anyway being used). Finally, if one algorithm senses with more ac\u00adcuracy or \nlower latency for any one of the applications, all other applications bene.t from it. Figure 12 shows \nthe savings for four illustrative combina\u00adtions of applications. Loc. apps consists of all three location \napplications (ClubPoint, SimplySave, and GeoReminder de\u00adscribed in Section 8.3) executing at the same \ntime. Act. apps consists of the three activity context based applications (DriverMode, RadioGuide, and \nFitnessTracker) executing at the same time. All apps denotes all six of these applications. Senergy-M \nsatis.es all these requirements in all instances. For example with the location applications, Senergy-M \nsat\u00adis.es all of the latency and accuracy constraints in all three groups by using the accelerometer \nto .rst detect movement, and therefore delivers substantial energy gains of about 70% compared to each \nof the three applications waking up at its speci.ed latency and reading the accelerometer. The fourth \nset of applications, Acc. loc. consists of the same three location applications where ClubPoint and Geo-Reminder \nuse the same settings, but a modi.ed version of SimplySave that instead requests the highest accuracy \nset\u00adting. This setting requires using GPS rather than sensing with the accelerometer .rst. This fourth \nset demonstrates the savings when Senergy-M turns off the accelerometer sensor, which although best to \nuse for ClubPoint and GeoReminder, is redundant with the GPS which high accuracy SimplySave now is using. \nComparing All Apps with Acc. Loc. shows that even with a relatively higher demand energy application, \nSenergy optimizes by reusing the GPS reading, and eliminat\u00ading the accelerometer reading in the other \napplications with lower demands. In summary, using these realistic applications and mixes of applications, \nwe show that with an expressive, .exible API the OS approach implemented by Senergy can trade\u00adoff energy, \naccuracy, and latency for both individual appli\u00adcations and for multiple applications executing concurrently. \nSenergy offers programmers a simple and intuitive API that does not require understanding the underlying \nruntime op-timizations. We show that given single and multiple appli\u00adcation requirements, the system \nmeets the requirements and delivers reduced energy consumption by orders of magni\u00adtude compared to the \nstate-of-the-art APIs in current mobile operating systems.  9. Discussion Based on our experiences designing \nand implementing this API, we discuss a number of issues that future systems should consider. 9.1 Hardware \nArchitectures New mobile-processors offer an additional smaller, lower\u00adpower core, that can run certain \ncontext-sensing tasks much more ef.ciently [17, 26]. New hardware broadens the range of choices available \nto Senergy and it may consequently sat\u00adisfy more application constraints. The tradeoff space should be \ncharacterized to include these options. The API does not change, but applications transparently bene.t \nfrom hardware advances. If hardware advances make new types of context and activities feasible, such \nas identifying human voices, the API again does not change but starts delivering these addi\u00adtional context \ntypes to applications that request them. 9.2 Predictive and Historic Context Senergy does not maintain \nhistorical state. Any long term modeling must be performed by the application. However, if Senergy records \ncontext, it could learn user behavior models and use them to optimize context sensing. If Senergy records \ncontext over time and users give applications access to their historical data, it may empower applications \nto be more use\u00adful immediately after install. For example, if the user installs a .tness application, \nand Senergy has already been tracking activity context for another reason, it can give this historical \ninformation to the .tness application, which could immedi\u00adately compute .tness levels and adjust the \nuser experience based on this history. Furthermore, if users provide ground truth labels the system can \nuse auto-tuning approaches to adapt itself to a speci.c user s environment and behavior.  9.3 Reporting \nLatency We de.ned latency as the delay in detecting and reporting a context change to the application. \nAdditional optimization opportunities arise by decoupling the detection and reporting latency. For instance, \nto track location changes at 5 minute latency, an ef.cient algorithm may obtain network .nger\u00adprints \nevery 5 minutes but not contact the Internet based lo\u00adcation server to convert the .ngerprints to location \ncoordi\u00adnates until the device is plugged in, resulting in a reporting latency of several hours. This \ncon.guration may suf.ce for some applications, for example, if the application displays a map of the \nlocations the user visited over the past week. Since capturing the .ngerprint is low energy, this optimiza\u00adtion \nwill yield signi.cant energy savings. The API would evolve to add a reporting latency.  9.4 Privacy \nWhile we have not included any privacy related parameters in the API design, a real system may also wish \nenforce privacy guarantees based on user settings. When Senergy operates in a battery ef.cient mode that \nsatis.es multiple simultaneous applications, the accuracy achieved may not be appropriate for all applications. \nFor instance, a .tness application may need high accuracy location context data while the user may only \nwant to expose lower accuracy data to a nearby friend .nder application. If the .tness application is \nalready running, it does not consume any extra battery to sense higher accuracy location for the friend \n.nder app in this case. However, the system may speci.cally add noise to the context data exposed to \nthe friend .nder application to protect user privacy. 10. Related Work Prior research has recognized \nthe energy ef.ciency chal\u00adlenge for continuously sensing context. Several groups have created low-power \nstrategies such as combining location re\u00adquests, adaptive sampling, and chaining low-power sensors with \nhigher power ones [3, 7, 14, 18, 24, 40], as well as ap\u00adplication speci.c energy optimization techniques \n[35]. Prior work has explored energy-ef.cient approaches to detect\u00ading human activities, such as walking, \nresting, and meet\u00ading [38]. In Jigsaw [19], energy spent on inference is min\u00adimized by suppressing the \nhigher energy stages in the infer\u00adence pipeline using lower energy stage results. Our goal is to encapsulate \nsuch techniques for energy optimization under\u00adneath a developer friendly API, so developers may bene.t \nfrom this work without being tied to the underlying methods that may evolve over time. A few researchers \nhave suggested language support for optimizing energy [5, 33]. In the Eon programming lan\u00adguage and runtime \n[33], programmers express quality of ser\u00advice (latency) and energy constraints and the runtime system \nadjusts based on available energy. With energy types [5], programmers encode the expected energy requirements \nby adding energy hints (e.g., low vs high power) to a function. The runtime can use these hints to, for \nexample, throttle a CPU to a low power mode when a function with that desig\u00adnation runs. While it may \nbe possible to implement our API in extended versions these languages, our current implement considers \na more complicated trade-off space (e.g., energy, accuracy and latency) than these systems address. \nOther systems have also proposed techniques to facili\u00adtate context based programming. Kobe [4] considered \nthe latency, energy, and accuracy tradeoff for mobile sensing but for designing inference algorithms. \nKobe accepts train\u00ading data from the developer and generates an optimized in\u00adference pipeline, using \nmultiple classi.er con.gurations and cloud of.oad. SymPhoney [11] accepts a data .ow graph from a developer \nthat speci.es low level operations such as sensing, feature extraction, and classi.ers, and then de\u00adtermines \nan optimal resource allocation. Senergy could use such methods internally for designing its context sensing \nal\u00adgorithms. While Kobe and SymPhoney are targeted at de\u00advelopers building or specifying their own machine \nlearn\u00ading algorithms, Senergy exposes ready to use context, com\u00adpletely decoupling the inference algorithm \ndetails from ap\u00adplications. Code in the Air [29] and the Context Toolkit [31] enhance programmer productivity \nthrough re-usable and en\u00adergy ef.cient context sensing code but are based on the cat\u00adalog approach without \nexposing battery and performance trade-offs. SeeMon [12] and Orchestrator [13] optimize re\u00adsource use \nby converting context queries from multiple ap\u00adplications into lower layer sensing and processing primi\u00adtives, \nand then selecting the most ef.cient set of such primi\u00adtives to satisfy all queries. While this work \noptimizes energy use, it does not expose battery and context quality trade-off to the developer through \na .exible API. Other related APIs include location APIs speci.ed by W3C [25] and existing mobile OSs, \nand cloud based loca\u00adtion tracking APIs for backend processing [10]. These APIs do not consider the energy \nef.ciency challenges that we ad\u00address. In summary, our approach allows developers to specify latency, \naccuracy, and battery requirements for their context needs. The novel aspect of our approach is that \nit provides the OS and runtime with the information necessary to opti\u00admize resource use without requiring \napplication developers to understand energy intricacies or inference algorithms. 11. Conclusions We identi.ed \nthe LAB abstraction and showed how to use it to implement energy-ef.cient continuous context sensing \nand how it improves programmer productivity. We described a prototype implementation using 22 activity \nand location tracking algorithms. We illustrated how the Senergy runtime uses the energy, latency, and \naccuracy requirements speci\u00ad.ed by applications and the algorithm tradeoffs to deliver energy ef.cient \ncontext sensing under a wide variety of ac\u00adcuracy and latency requirements. We showed for six realis\u00adtic \napplications, how Senergy uses a small amount of appli\u00adcation .exibility to reduce the battery drain \nto much more practical levels, compared to using existing APIs. The re\u00adsulting system gives application \ndevelopers ef.cient context without becoming experts in energy optimization or context inference. Whereas \nin most current mobile systems context is too costly in energy to use regularly, we believe that with \nSenergy s signi.cant reductions in battery use for continu\u00adous context tracking that developers will \nbe able to deliver new context-aware applications that delight. References [1] N. Banerjee, A. Rahmati, \nM. D. Corner, S. Rollins, and L. Zhong. Users and batteries: Interactions and adaptive en\u00adergy management \nin mobile systems. In Ubicomp, 2007. [2] G. Challen and M. Hempstead. The case for power-agile computing. \nIn HotOS, 2011. [3] Y. Chon, E. Talipov, H. Shin, and H. Cha. Mobility prediction\u00adbased smartphone energy \noptimization for everyday location monitoring. In Sensys, 2011. ISBN 978-1-4503-0718-5. [4] D. Chu, N. \nD. Lane, T. T.-T. Lai, C. Pang, X. Meng, Q. Guo, F. Li, and F. Zhao. Balancing energy, latency and accuracy \nfor mobile sensor data classi.cation. In ACM SenSys, 2011. [5] M. Cohen, H. S. Zhu, E. E. Senem, and \nY. D. Liu. Energy types. SIGPLAN Not., 47(10):831 850, Oct. 2012. ISSN 0362-1340. [6] S. Consolvo, D. \nW. McDonald, T. Toscos, M. Y. Chen, J. Froehlich, B. Harrison, P. Klasnja, A. LaMarca, L. LeGrand, R. \nLibby, I. Smith, and J. A. Landay. Activity sensing in the wild: A .eld trial of ubi.t garden. In CHI, \n2008. [7] I. Constandache, S. Gaonkar, M. Sayler, R. Choudhury, and L. Cox. Enloc: Energy-ef.cient localization \nfor mobile phones. In IEEE Infocom, pages 2716 2720, April 2009. [8] J. Dean and S. Ghemawat. MapReduce: \nSimpli.ed data pro\u00adcessing on large clusters. In OSDI, 2004. [9] E. Ertin, N. Stohs, S. Kumar, A. Raij, \nM. al Absi, and S. Shah. AutoSense: Unobtrusively wearable sensor suite for inferring the onset, causality, \nand consequences of stress in the .eld. In SenSys, 2011. [10] M. Haridasan, I. Mohomed, D. Terry, C. \nA. Thekkath, and L. Zhang. Startrack next generation: A scalable infrastructure for track-based applications. \nIn OSDI, 2010. [11] Y. Ju, Y. Lee, J. Yu, C. Min, I. Shin, and J. Song. Symphoney: A coordinated sensing \n.ow execution engine for concurrent mobile sensing applications. In Proceedings of the 10th ACM Conference \non Embedded Network Sensor Systems, SenSys 12, pages 211 224, New York, NY, USA, 2012. ACM. ISBN 978-1-4503-1169-4. \n[12] S. Kang, J. Lee, H. Jang, H. Lee, Y. Lee, S. Park, T. Park, and J. Song. SeeMon: Scalable and energy-ef.cient \ncontext monitoring framework for sensor-rich mobile environments. In Proceedings of the 6th international \nconference on Mobile systems, applications, and services, MobiSys 08, pages 267 280, New York, NY, USA, \n2008. ACM. ISBN 978-1-60558\u00ad139-2. [13] S. Kang, Y. Lee, C. Min, Y. Ju, T. Park, J. Lee, Y. Rhee, and \nJ. Song. Orchestrator: An active resource orchestration framework for mobile context monitoring in sensor-rich \nmo\u00adbile environments. In Pervasive Computing and Communi\u00adcations (PerCom), 2010 IEEE International Conference \non, pages 135 144, 2010. [14] D. H. Kim, Y. Kim, D. Estrin, and M. B. Srivastava. Sensloc: Sensing everyday \nplaces and paths using less energy. In ACM SenSys, 2010. [15] M. B. Kjaergaard, J. Langdal, T. Godsk, \nand T. Toftkjaer. En\u00adtracked: Energy-ef.cient robust position tracking for mobile devices. In MobiSys, \n2009. [16] N. D. Lane, E. Miluzzo, H. Lu, D. Peebles, T. Choudhury, and A. T. Campbell. Asurvey of mobile \nphone sensing. Comm. Mag., 48:140 150, September 2010. [17] F. X. Lin, Z. Wang, R. LiKamWa, and L. Zhong. \nRe.ex: Using low-power processors in smartphones without knowing them. In ASPLOS, 2012. [18] K. Lin, \nA. Kansal, D. Lymberopoulos, and F. Zhao. Energy\u00adaccuracy trade-off for continuous mobile device location. \nIn MobiSys, pages 285 298, 2010. [19] H. Lu, J. Yang, Z. Liu, N. D. Lane, T. Choudhury, and A. T. Campbell. \nThe Jigsaw continuous sensing engine for mobile phone applications. In SenSys, 2010. [20] H. Lu, A. J. \nB. Brush, B. Priyantha, A. K. Karlson, and J. Liu. Speakersense : Energy ef.cient unobtrusive speaker \nidenti.cation on mobile phones. Pervasive Computing, 6696: 188 205, 2011. [21] M. Mun, D. Estrin, J. \nBurke, and M. Hansen. Parsimonious mobility classi.cation using gsm and wi. traces. In HotEm-Nets, 2008. \n[22] S. Nath. Ace: exploiting correlation for energy-ef.cient and continuous context sensing. In Mobisys, \n2012. [23] T. Nick, E. Coersmeier, J. Geldmacher, and J. Goetze. Clas\u00adsifying means of transportation \nusing mobile sensor data. In The 2010 International Joint Conference on Neural Networks (IJCNN), 2010. \n[24] J. Paek, J. Kim, and R. Govindan. Energy-ef.cient rate\u00adadaptive gps-based positioning for smartphones. \nIn MobiSys, New York, NY, USA, 2010. [25] A. Popescu. Geolocation api speci.cation. http://www. w3.org/TR/geolocation-API/. \n[26] B. Priyantha, D. Lymberopoulos, and J. Liu. LittleRock: En\u00adabling energy-ef.cient continuous sensing \non mobile phones. IEEE Pervasive Computing, 10(2), 2011. [27] M. Rabbi, S. Ali, T. Choudhury, and E. \nBerke. Passive and in-situ assessment of mental and physical well-being using mobile sensors. In Ubicomp, \n2011. [28] K. K. Rachuri, M. Musolesi, C. Mascolo, P. J. Rentfrow, C. Longworth, and A. Aucinas. Emotionsense: \na mobile phones based adaptive platform for experimental social psy\u00adchology research. In Ubicomp, 2010. \n [29] L. Ravindranath, A. Thiagarajan, H. Balakrishnan, and S. Madden. Code in the air: simplifying sensing \nand coor\u00addination tasks on smartphones. In Proceedings of the Twelfth Workshop on Mobile Computing Systems \n&#38;#38; Applications, HotMobile 12, pages 4:1 4:6, New York, NY, USA, 2012. ACM. ISBN 978-1-4503-1207-3. \n[30] S. Reddy, M. Mun, J. Burke, D. Estrin, M. Hansen, and M. Sri\u00advastava. Using mobile phones to determine \ntransportation modes. ACM Trans. Sen. Netw., 6(2):13:1 13:27, Mar. 2010. ISSN 1550-4859. [31] D. Salber, \nA. K. Dey, and G. D. Abowd. The context toolkit: aiding the development of context-enabled applications. \nIn Proceedings of the SIGCHI conference on Human Factors in Computing Systems, CHI 99, pages 434 441, \nNew York, NY, USA, 1999. ACM. ISBN 0-201-48559-1. [32] T. Sohn, A. Varshavsky, A. Lamarca, M. Y. Chen, \nT. Choud\u00adhury, I. Smith, S. Consolvo, J. Hightower, W. G. Griswold, and E. D. Lara. Mobility detection \nusing everyday gsm traces. In Ubicomp, 2006. [33] J Sorber, A. Kostandinov, M. Garber, M. Brennan, M.D. \nCor\u00adner, and E. D. Berger. Eon: A language and runtime system for perpetual systems, In SenSys, 2007. \n [34] S. P. Tarzia, R. P. Dick, P. A. Dinda, and G. Memik. Sonar\u00adbased measurement of user presence and \nattention. In Ubi\u00adcomp, 2009. [35] A. Thiagarajan, L. Ravindranath, K. LaCurts, S. Madden, H. Balakrishnan, \nS. Toledo, and J. Eriksson. Vtrack: Accu\u00adrate, energy-aware road traf.c delay estimation using mobile \nphones. In SenSys, 2009. [36] TI. OMAP 5 mobile application platform, 2011. [37] A. B. Waluyo, W.-S. \nYeoh, I. Pek, Y. Yong, and X. Chen. Mo\u00adbisense: Mobile body sensor network for ambulatory moni\u00adtoring. \nACM Trans. Embed. Comput. Syst., 10(1):13:1 13:30, Aug. 2010. ISSN 1539-9087. [38] Y. Wang, J. Lin, M. \nAnnavaram, Q. A. Jacobson, J. Hong, B. Krishnamachari, and N. Sadeh. A framework of energy ef.cient mobile \nsensing for automatic user state recognition. In MobiSys, 2009. [39] T. Yan, D. Chu, D. Ganesan, A. Kansal, \nand J. Liu. Fast app launching for mobile devices using predictive user context. In Mobisys, 2012. [40] \nZ. Zhuang, K.-H. Kim, and J. P. Singh. Improving energy ef.ciency of location sensing on smartphones. \nIn MobiSys, 2010.     \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Emerging mobile applications that sense context are poised to delight and entertain us with timely news and events, health tracking, and social connections. Unfortunately, sensing algorithms quickly drain the phone's battery. Developers can overcome battery drain by carefully optimizing context sensing but that makes programming with context arduous and ties applications to current sensing hardware. These types of applications embody a twist on the classic tension between programmer productivity and performance due to their combination of requirements.</p> <p>This paper identifies the latency, accuracy, battery (LAB) abstraction to resolve this tension. We implement and evaluate LAB in a system called Senergy. Developers specify their LAB requirements independent of inference algorithms and sensors. Senergy delivers energy efficient context while meeting the requirements and adapts as hardware changes. We demonstrate LAB's expressiveness by using it to implement 22 context sensing algorithms for four types of context (location, driving, walking, and stationary) and six diverse applications. To demonstrate LAB's energy optimizations, we show often an order of magnitude improvements in energy efficiency on applications compared to prior approaches. This relatively simple, priority based API, may serve as a blueprint for future API design in an increasingly complex design space that must tradeoff latency, accuracy, and efficiency to meet application needs and attain portability across evolving, sensor-rich, heterogeneous, and power constrained hardware.</p>", "authors": [{"name": "Aman Kansal", "author_profile_id": "81100330131", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290433", "email_address": "kansal@microsoft.com", "orcid_id": ""}, {"name": "Scott Saponas", "author_profile_id": "81309501293", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290434", "email_address": "ssaponas@microsoft.com", "orcid_id": ""}, {"name": "A.J. Bernheim Brush", "author_profile_id": "81332491415", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290435", "email_address": "ajbrush@microsoft.com", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290436", "email_address": "mckinley@microsoft.com", "orcid_id": ""}, {"name": "Todd Mytkowicz", "author_profile_id": "81100300026", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290437", "email_address": "toddm@microsoft.com", "orcid_id": ""}, {"name": "Ryder Ziola", "author_profile_id": "81311480811", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P4290438", "email_address": "ryder@ryderziola.ca", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509541", "year": "2013", "article_id": "2509541", "conference": "OOPSLA", "title": "The latency, accuracy, and battery (LAB) abstraction: programmer productivity and energy efficiency for continuous mobile context sensing", "url": "http://dl.acm.org/citation.cfm?id=2509541"}