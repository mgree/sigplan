{"article_publication_date": "10-29-2013", "fulltext": "\n Option Contracts  Christos Dimoulas Robert Bruce Findler Matthias Felleisen Harvard University Northwestern \nUniversity Northeastern University chrdimo@seas.harvard.edu robby@eecs.northwestern.edu matthias@ccs.neu.edu \n Abstract Many languages support behavioral software contracts so that programmers can describe a component \ns obligations and promises via logical assertions in its interface. The con\u00adtract system monitors program \nexecution, checks whether the assertions hold, and, if not, blames the guilty component. Pinning down \nthe violator gets the debugging process started in the right direction. Quality contracts impose a serious \nrun\u00adtime cost, however, and programmers therefore compromise in many ways. Some turn off contracts for \ndeployment, but then contracts and code quickly get out of sync during main\u00adtenance. Others test contracts \nrandomly or probabilistically. In all cases, programmers have to cope with lack of blame information \nwhen the program eventually fails. In response, we propose option contracts as an addition to the contract \ntool box. Our key insight is that in ordinary contract systems, server components impose their contract \non client components, giving them no choice whether to trust the server s promises or check them. With \noption contracts, server components may choose to tag a contract as an option and clients may choose \nto exercise the option or accept it, in which case they also shoulder some responsibility. We show that \noption contracts permit programmers to specify .exible checking policies, that their cost is reasonable, \nand that they satisfy a complete monitoring theorem. Categories and Subject Descriptors D.2.4 [Software \nVeri\u00ad.cation]: Programming by contract Keywords programming language design; behavioral soft\u00adware contracts; \nrandom testing; probabilistic spot checking 1. The High Costs of Contracts Large programs consist of \nmany collaborating components. Interfaces describe these collaborations, speci.cally the promises that \neach component makes and the obligations that it imposes on its clients for use of its services. The \nsim- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. Copyrights for components of \nthis work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, \nor republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. Request permissions from permissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, \nUSA. Copyright &#38;#169; 2013 ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509548 \nplest interfaces specify statically checked types. One step up, programmers employ behavioral also called \nfunctional software contracts to supplement types [2]. Conceptually, a behavioral contract re.nes the \ndomain and/or range types of a method with logical constraints. Most contract systems allow programmers \nto express these constraints as boolean-typed expressions in the underlying programming language itself; \na few also include additional logical connectors [22]. While some research-oriented com\u00adbinations of \nlanguages and IDEs support a degree of static veri.cation of contracts [1, 13, 32], most systems com\u00adpile \nthe logical assertions into run-time checks. When these checks discover a contract violation, they raise \nan excep\u00adtion to stop the program and send along information that explains which component violated which \ncontract and how. This information provides programmer with a starting point for their debugging efforts. \nRun-time monitoring means run-time cost. Thus, while contracts allow programmers to express the obligations \nand promises of a method in as much detail as desired, they also impose a serious cost. To avoid these \ncosts, programmers compromise in two major ways. One common compromise is to turn off contracts for de\u00adployment. \nCompilers tend to support appropriate switches for this purpose. Unfortunately, when not if the program \nfails eventually, the maintenance programmer will not re\u00adceive any information from the contract system \nto narrow down the search for the error. Consider this system fragment: The Board component exports \ngraphs arranged on a grid that satisfy certain conditions. The State component includes the grid, together \nwith other game elements, in an internal state representation, which the game Admininstrator uses to \ntrack a play. Player components, contributed by third\u00adparty programmers, get to manipulate a part of \nthe game state via an appropriate interface, though they probably hand on their arguments to strategy \ncomponents.  To ensure the integrity of the central game piece, a pro\u00adgrammer may impose a contract \non the grid. This contract makes sure that the grid preserves its invariants as it .ows through State \nand Administrator to Player and Strategy. Turning off this contract for deployment implicates all .ve \ncomponents when something goes wrong. Also, when main\u00adtenance programmers .x code, they may forget to \nupdate the contracts. Alternatively, the programmer moves the con\u00adtract from board to the border between \nAdmininstrator and Player and keep it around during deployment. This arrange\u00adment, however, violates \nbasic design principles keep the contract with the matching component and it may harm de\u00adbugging during \ndevelopment when State or Administrator accidentally violate the grid s invariants. Another common compromise \nis to use random testing in contracts. Consider this contract for a binary search method: <T> Maybe[Integer] \nbS(T v, T[] d) pre for all i < d.size-1 : d[i] <= d[i+1] post @bS.isJust() ==> 0 <= @bS &#38;&#38; @bs \n< d.size() It speci.es that the component supplies the bS function. Its pre-condition says that the second \nargument d is an array of values sorted by <= (for type T). The post-condition promises that the result \n@bS is an optional integer and, if it is an integer, it is a valid index into d. The latter suggests \nd[@bS] == v, though the programmer chooses not to promise this fact. Of course, ensuring that the entire \nvector d is sorted changes the algorithmic complexity of bS. In response, a programmer may weaken the \ncontract as follows: <T> Maybe[Integer] bS(T v, T[] d) pre for some random 0 < i &#38;&#38; i < d.size()-1: \n d[i-1] <= d[i] &#38;&#38; d[i] <= d[i+1] post @bS.isJust() ==> 0 <= @bS &#38;&#38; @bs < d.size() The \nrandomly checked pre-condition is an algorithmic spot checker [9]. Programmers tend to use such sophisticated \nalgorithms in lieu of an expensive contract to reduce the cost of contract checking and to obtain some \nassurance that the contract s speci.cation holds. Like turning off contracts for deployment, weakening \nas\u00adsertions via random testing or spot checking poses prob\u00adlems when programs or contracts eventually \nfail. If compo\u00adnent A uses a service from component B with a randomly checked result and A then passes \nthe result to C, a contract failure between these two will blame A in all existing con\u00adtract systems \neven though B s randomly checked contract does not truly absolve it from its obligations. 2. Reducing \nCosts with Option Contracts When Meyer proposed behavioral software contracts [24], he described contracts \nwith analogies to the business world. In a nutshell, a component offers its services together with a \ncontract that makes promises about its services and obliges client components to behave in certain ways \nif they wish to use these services. Our linguistic solution to the above problems is to bor\u00adrow another \nidea from the business world: option contracts. When a server component supplies its services with an \nop\u00adtion contract, a client component may accept it in two ways. On the one hand, it can exercise the \noption and live up to its conditions. If something goes wrong with the services, the contract system \ncontinues to blame the server component as if it had chosen a conventional contract. On the other hand, \nclients may accept objects monitored by an option contract on an as is basis. If a client transfers such \nan object to a third party, the contract system tracks this .ow and names the client as a party to any \nfuture contract violation con\u00adcerning this contract. With option contracts, programmers have the infrastructure \nto mark spot checking in contracts, and they can codify one contract checking policy for devel\u00adopment \nand another one for deployment. Indeed, program\u00admers can develop dynamic changes to the contract monitor\u00ading \npolicies so that systems can reduce monitoring activities as core components learn to trust some components. \nThe rest of the paper introduces option contracts, .rst with an informal speci.cation and then in the \ncontext of some non-trivial examples. The .fth section uses experimen\u00adtal setups to demonstrate the performance \nbene.ts of option contracts. The sixth section presents a formal speci.cation in the form of a semantic \nmodel; the semantics satis.es a com\u00adpleteness theorem [7], the key property of contract systems. The \nlast two sections place our work in context. 3. Exploring Option Contracts Option contracts extend contract \nsystems in a straightfor\u00adward manner; they introduce one new mechanism for stating contracts in an interface \nand several different client-side op\u00aderations. In this section, we .rst introduce option contracts abstractly, \nin a language-neutral manner, and then make this presentation concrete with Racket code snippets; for \na pre\u00adcise semantics, see section 6. 3.1 Option Contracts, Abstractly Adding options to an existing \ncontract system requires at least three changes. The .rst one allows programmers to annotate a contract \nfor objects not basic values such as booleans or numbers in a server component as an option. When an \nobject O .ows through such an option contract C, the contract system checks the applicable portions of \nC and then wraps O in an option-contract object, which includes C. The second change allows an importing \nclient to exercise an option contract. Doing so extracts O and C; it combines these two in a regular \ncontract wrapper that checks every access to O according to C. If the option is not exercised, O is accessed \nas if it had no wrapper. The third change concerns the relationship among clients. When a client accepts \nan object with an option-contract  Figure 1: Option contracts by example wrapper, it may re-export \nit in two different ways. First, it may transfer the wrapped object to its own clients. If it chooses \nthis alternative, it and its client avoid an additional contract wrapper object but they both accept \nsome respon\u00adsibility for the object s behavior. Second, the client may re-export the object through a \nregular contract boundary in which case it shoulders no responsibility for the object s be\u00adhavior but \nimposes a performance penalty on its clients. Let us illustrate option contracts with the .rst example \nfrom the introduction. Figure 1 presents the revised view. As discussed, the Board component exports \na grid object. It choose to offer an option contract and State transfers grid to Admin. This arrangement \nsigni.cantly reduces the cost of contract checking for Board and Admin because grid is wrapped in just \none contract layer. Since Player is foreign code, it is natural that the option contract is exercised \nand passed on to Strategy via a regular export. That way Player and Strategy do not need to accept any \nblame if the grid object misbehaves. In addition to these operations, our option contract system also \nprovides a mechanism for stripping, which extracts the underlying object from an option-contract wrapper. \nWhile stripping removes all contract overhead, it also prevents fu\u00adture clients from exercising the option \nand protecting them\u00adselves. In short, stripping chooses raw performance over any form of protection. \n 3.2 Racket Contracts, a Refresher The Racket programming language [14] comes with a com\u00adprehensive \ncontract system, including contracts for higher\u00adorder values [12]. While contracts for .rst-order values \nand methods require little support from the programming lan\u00adguage or its implementation, higher-order \ncontracts force language designers to think of contract speci.cations as bor\u00adderlines between two parties \n[28]. In this section, we introduce Racket s contract system via a DrRacket component. DrRacket is Racket \ns IDE, and its code base is already enriched with contracts. DrRacket s text coloring component interactively \ncolors programs as the user edits the program. It differentiates lexemes such as strings and identi.ers \nwith different colors and even identi\u00ad.es misspelled words. The implementation uses stream pro\u00adcessing \nfunctions that accept an input port. Unlike ordinary input ports, these ports are built from the contents \nof the ed\u00aditor to get ef.cient and re-usable stream processing. The fol\u00adlowing function contract speci.es \nhow lexers behave: (define plain-lexer/c (-> input-port? any/c (values symbol? (maybe/c natural-number/c) \n(maybe/c natural-number/c) any/c))) Lexers are functions that accept two inputs: the input port and a \nmode value that the lexer can use as an accumulator to transmit information forward in the stream. The \nresult consists of four values: a symbol that describes the token, two numbers that determine the position \nof the token in the input stream or #f if EOF has been reached, and a new mode value, which is passed \nback into the lexer when processing the next token. While this contract speci.es the basic behavior, \nlexer functions satisfy a number of additional invariants and the speci.cations of those require dependent \ncontracts.1 Racket uses ->i for dependent contracts; its syntax is similar to that of ->, except that \neach place where a contract appears in a -> expression, an ->i expression has a name and a contract: \n(define dep-lexer/c (->i ([in input-port?] [mode any/c]) (values [tok symbol?] [start (tok end) (and \n(not (equal? eof tok)) (and/c natural-number/c (</c end)))] [end (tok) (and (not (equal? eof tok)) natural-number/c)] \n[new-mode any/c]))) 1 This contract is signi.cantly simpli.ed from the actual contract for lexers. The \ncurious reader may want to inspect the full contract in Racket v.5.3.5.  In essence, this contract says \nthat the function still accepts the same two arguments, but now gives them names: in and mode. Similarly \nthe results are now named tok, start, end, and new-mode. The ->i combinator speci.es a dependency of \none part of the contract on other parts by placing the names of the latter in parentheses between the \nname and the associated contract. Here end s contract depends on the value of tok and speci.es that returning \n#f is acceptable if tok is the symbol eof. Otherwise, end is a natural number. Similarly, start can be \n#f only if the tok symbol is eof, and start is additionally constrained to be strictly less than end. \nThe .ow of a higher-order value (closure, object) through a contract establishes a boundary between the \nvalue and its surroundings. Each one of the two parties, the server and the client, become responsible \nfor some pieces of the contract. For .rst-order contracts, such as dep-lexer/c, the client is responsible \nfor providing arguments that meet the pre\u00adconditions of the contract and the server is responsible for \nproducing results that meet the post-conditions. Consider the following simple lexer: (define (bogus-lexer \nin mode) (values bogus 10 2 #f)) We use the define/contract construct [27] to attach a con\u00adtract to \nbogus-lexer: (define/contract bogus-lexer-with-contract dep-lexer/c bogus-lexer) Evaluating this de.nition \nsends bogus-lexer through dep\u00adlexer/c. The resulting value is associated with the name bogus-lexer-with-contract. \nIts wrapper monitors all .ow of values between it and its context, the rest of the module. If the context \nof bogus-lexer-with-contract does not respect the pre-condition, the contract system raises a contract \nerror that assigns blame to the caller of the function: > (bogus-lexer-with-contract \"[\" #f) bogus-lexer-with-contract: \ncontract violation expected: input-port? given: \"[\" in: the in argument of (->i ((in input-port?) (mode \nany/c)) (values (tok symbol?) (start (tok end) ...) (end (tok) ...) (new-mode any/c))) contract from: \n(de.nition bogus-lexer-with-contract) blaming: top-level In case the context respects its obligations, \nthis lexer does not live up to its post-condition. Hence, the contract system points to bogus-lexer-with-contract \nfor the violation: > (bogus-lexer-with-contract (open-input-string \"[\") #f) bogus-lexer-with-contract: \nbroke its contract promised: (and/c natural-number/c (</c 2)) produced: 10 which isn t: (</c 2) in: the \nstart result of (->i ((in input-port?) (mode any/c)) (values (tok symbol?) (start (tok end) ...) (end \n(tok) ...) (new-mode any/c))) contract from: (de.nition bogus-lexer-with-contract) blaming: (de.nition \nbogus-lexer-with-contract) The view of a contract as an agreement between two parties scales naturally \nto higher-order functions, borrowing notation for expressing contracts for higher-order functions from \ntypes for higher-order functions. For example, here is a higher-order lexer-tester with its contract: \n(define/contract (lexer-tester lexer) (-> dep-lexer/c boolean?) (lexer (open-input-string \"[\") #f) #t) \n The tester applies the lexer on a single character stream and if the lexer returns, the tester returns \n#t. However, the contract system wraps the argument lexer with a proxy that checks dep-lexer/c for uses \nof the argument in the body of lexer-tester. Thus the tester s contract makes sure that for the lexer \nto return succesfully, its result must satisfy the post-condition of dep-lexer/c. As far for blame assignment \nin this case, the contract system passes information about the two responsible parties to the proxy that \nenforces dep-lexer/c. More speci.cally, it turns the two initial parties for the contract on lexer-tester \nto parties for dep-lexer/c. Since the caller of lexer is the body of lexer-tester and the provider of \nlexer is the caller of lexer-tester, the contract system swaps the roles of the original parties; lexer-tester \nbecomes the client for the argument and the context of lexer-tester the server: > (lexer-tester bogus-lexer) \nlexer-tester: contract violation expected: (and/c natural-number/c (</c 2)) given: 10 which isn t: (</c \n2) in: the start result of  the 1st argument of (-> (->i ((in input-port?) (mode any/c)) (values (tok \nsymbol?) (start (tok end) ...) (end (tok) ...) (new-mode any/c))) boolean?) contract from: (function \nlexer-tester) blaming: top-level In a nutshell, contracts for higher-order functions generalize those \nfor .rst-order functions; they establish a boundary be\u00adtween two parties and the contract system starts \nmonitoring the values that go through the boundary. When the contract system detects a contract violation, \nit assigns blame to the party that does not conform with the obligations imposed by the boundary; the \nclient for the negative pieces of the con\u00adtract and the server for the positive ones.  3.3 Introducing \nOptions A dependent contract introduces a non-trivial overhead when DrRacket processes an editor as the \nuser types. Hence, it is a natural candidate for an option contract. Here is the code that builds an \noption contract based on dep-lexer/c: (define lexer/c (option/c dep-lexer/c #:tester (. (l) (try-random-inputs \nl)))) The option/c contract combinator accepts an ordinary con\u00adtract as its .rst argument and, optionally \nvia the #:tester keyword argument, a function that may examine the con\u00adtracted value in arbitrary ways. \nIntuitively, the tester provides a minimum amount of val\u00adidation of any value that .ows through this \ncontract. For Dr-Racket, the tester ensures that lexer is a function of two ar\u00adguments, and it applies \nthis function to 10 streams of random lowercase characters: (define (try-random-inputs lexer) (for ([attempt \n(in-range 10)]) (define n (random 50)) (define s (build-string n lc-letters)) (lexer (open-input-string \ns) #f))) (define (lc-letters _) (integer->char (+ 97 (random 26)))) When the lexer is passed to the \ntester, it is wrapped in the contract, so calling it with some random inputs ensures that it obeys the \ncontract for at least a few streams. A de.nition that imposes lexer/c on broken-lexer from above immediately \nexposes it as a fraud: (define/contract (broken-lexer in mode) lexer/c (values bogus 10 2 #f)) broken-lexer: \nbroke its contract promised: (and/c natural-number/c (</c 2)) produced: 10 which isn t: (</c 2) in: \nthe start result of ... (option/c (->i ((in input-port?) (mode any/c)) (values (tok symbol?) (start \n(tok end) ...) (end (tok) ...) (new-mode any/c))) #:tester #<procedure>) contract from: (function broken-lexer) \nblaming: (function broken-lexer) As the lexer gets tested on a number of random inputs, its contract \nwrapper discover that its start result is too large.  3.4 Exercising and Waiving Options Once contracted \nvalues have passed the tester s exami\u00adnation, the option contract wrapper technically, a proxy value \n[28] no longer checks any properties. Instead, it transparently stores the underlying contract with the \nvalue for future use, leaving dep-lexer/c inactive for now. For instance, here is a .awed lexer that \npasses the tests in the #:tester because they supply only lowercase letters: (define/contract (less-broken-lexer \nin mode) lexer/c (define c (read-char in)) (cond [(eof-object? c) (values eof #f #f #f)] [(equal? c \n#\\[) (values bogus 10 2 #f)] [else (values symbol 1 2 #f)])) This lexer does misbehave if its input port \ndelivers a #\\[ character. Once the #:tester function has checked this function on its 100 random lowercase \nstrings, however, even the presence of #\\[ does not lead to a contract violation: > (less-broken-lexer \n(open-input-string \"[\") #f) bogus 10 2 #f  Since the contract on less-broken-lexer is still present, \nhowever, we can activate it by exercising the option: > ((exercise-option less-broken-lexer) (open-input-string \n\"[\") #f) less-broken-lexer: broke its contract promised: (and/c natural-number/c (</c 2)) produced: \n10 which isn t: (</c 2) in: the start result of the option of (option/c (->i ((in input-port?) (mode \nany/c)) (values (tok symbol?) (start (tok end) ...) (end (tok) ...) (new-mode any/c))) #:tester #<procedure>) \ncontract from: (function less-broken-lexer) blaming: (function less-broken-lexer) The result of exercise-option \nis a function that behaves as if the original contract, dep-lexer/c, had been put directly on less-broken-lexer. \nPassing the same arguments to this contracted lexer thus results in a contract violation. The dual to \nexercise-option is waive-option: > ((waive-option less-broken-lexer) (open-input-string \"[\") #f) bogus \n10 2 #f More speci.cally, the result of waive-option is a func\u00adtion that behaves as if less-broken-lexer \nhad been de.ned without a contract. In particular, exercise-option cannot activate dep-lexer/c for the \nresult of waive-option. At the same time, calling less-broken-lexer after waiving the op\u00adtion is cheaper \nthan calling less-broken-lexer directly, be\u00adcause it is no longer protected by a proxy.  3.5 Transferring \nOptions In addition to exercising and waiving an option, a function may decide to shoulder responsibility \nfor the contract with\u00adout applying the contract again. For example, the following de.nition returns one \nof our earlier lexers, but instead of us\u00ading lexer/c for the result contract, it uses transfer/c: (define/contract \n(pick-a-lexer b) (-> boolean? transfer/c) (if b broken-lexer less-broken-lexer)) When the option is \neventually exercised the pick-a-lexer function agrees to take on joint responsibility for its result, \ntogether with the original option-contract server: > ((exercise-option (pick-a-lexer #f)) (open-input-string \n\"[\") #f) less-broken-lexer: broke its contract promised: (and/c natural-number/c (</c 2)) produced: \n10 which isn t: (</c 2) in: the start result of the option of (option/c (->i ((in input-port?) (mode \nany/c)) (values (tok symbol?) (start (tok end) ...) (end (tok) ...) (new-mode any/c))) #:tester #<procedure>) \ncontract from: (function less-broken-lexer) blaming multiple parties: (function pick-a-lexer) (function \nless-broken-lexer) In contrast, if pick-a-lexer were to specify lexer/c as its co-domain, only less-broken-lexer \nwould have been blamed but at the cost of checking the same contract twice: (define/contract (pick-a-lexer \nb) (-> boolean? lexer/c) (if b broken-lexer less-broken-lexer)) > ((exercise-option (pick-a-lexer #f)) \n(open-input-string \"[\") #f) pick-a-lexer: broke its contract promised: (and/c natural-number/c (</c \n2)) produced: 10 which isn t: (</c 2) in: the start result of the option of the range of (-> boolean? \n(option/c (->i ((in input-port?) (mode any/c)) (values (tok symbol?)  (start (tok end) ...) (end (tok) \n...) (new-mode any/c))) #:tester #<procedure>)) contract from: (function pick-a-lexer) blaming: (function \npick-a-lexer)  3.6 Options and Spot-Checkers As mentioned in section 1, programmers tend to use random \ntests and spot checkers, their sophisticated siblings, to re\u00adplace expensive contracts. Since the contract \nsystem does not provide support for substituting contracts with spot check\u00aders, programmers do so in \nad-hoc ways such as the contract of binary-search from section 1. Option contracts offer the necessary \nhooks for systemat\u00adically using spot checkers and random tests as part of con\u00adtracts. The following simple \nsyntax re-writing rule, declares a spot checker contract for data structures such as vectors: (define-syntax-rule \n(spotchecker/c c inv spot) (option/c c #:invariant inv #:tester spot)) The form (spotchecker/c c inv \nspot) expands into an option contract. The latter uses contract c as the cheap con\u00adtract that each element \nmust satisfy, e.g., that each element is of a speci.c data type; inv as the expensive invariant that \nshould really be monitored; and spot as the spot checker that weakens the invariant for the sake of performance. \nWe can use spotchecker/c to express the spot checker of the example of the introduction: (define binary-search/c \n(->i ([k V?] [D (spotchecker/c (vectorof V?) (sorted? V<) mostly-sorted?)]) [index-of-k-in-D (D) (maybe/c \n(</c (vector-length D)))])) Besides providing a concise way to express the contract weakening, the spotchecker/c \nabstraction makes the con\u00adtract system aware of the fact that a spot checker replaces a precise contract. \nHence a client component can use trans\u00adfer/c to share this information with its clients or exercise\u00adoption \nto activate the full contract in cases where correct\u00adness is more important than performance. 4. Option \nContracts in Practice The key test of a design idea such as option contracts is its application to non-trivial \nsoftware systems. To demonstrate the value of option contracts, we employed option contracts in three \nrealistic settings: the Typed Racket implementation, DrRacket s text coloring mechanism, and a game called \nAc\u00adquire. The .rst two are critical parts of the standard distribu\u00adtion of Racket. The third is a semester \nproject for a course on program design at Northeastern University. 4.1 Maintenance of Typed Racket Typed \nRacket [30] is a statically typed dialect of Racket. It is designed to accommodate common idioms of Racket \npro\u00adgrammers [31] and to enable the sound co-operation of typed and untyped Racket components [29]. Both \ndesign goals are pivotal for creating a pathway for porting components from the untyped to the typed \nworld, gradually and without sig\u00adni.cant re-programming effort. The type system is sophisti\u00adcated and \nRacket programmers currently pay for this sophis\u00adtication in the running time of the type checker. The \nimplementation of Typed Racket de.nes a series of data structures for storing and propagating type information. \nSome, such as variants of a type environment, are similar to those of any type checker. Others, such \nas .lters, are speci.c to features of Typed Racket s type system. The correctness of the type checker \nrelies on the proper use and behavior of functions that access and modify the contents of type repre\u00adsentations. \nFor instance, the following function typechecks recursive functions and its correctness depends on the \nappro\u00adpriate calls to with-lexical-env-extend, which extends the type environment, and make-arr and make-Function \nwhich together construct the type of the recursive function based on the types of its arguments and results: \n(define (tc/rec-lambda formals body name args return) (with-lexical-env/extend (syntax->list formals) \nargs (let* ([r (tc-results->values return)] [t (make-arr args r)] [ft (make-Function (list t))]) (with-lexical-env/extend \n(list name) (list ft) (begin (tc-exprs/check (syntax->list body) return) (ret ft)))))) To enforce the \nnecessary discipline for working in such a stringently structured environment, the developers of Typed \nRacket attach contracts to the data structures and functions of the type checker libraries. Thus, the \n(simpli.ed) contract header of make-arr looks like this: (define/contract (make-arr args r) (-> (listof \nType/c) Type/c) ...) They also add contracts to the functions of the type checker proper, such as tc/rec-lambda, \nto obtain .ne-grained blame information: (define/contract (tc/rec-lambda f b n a r) (-> syntax? syntax? \nsyntax? tc-results/c tc-results/c) ...) The contracts in the implementation of Typed Racket do not check \nbehavioral properties but are limited to structural, type-like properties. Although no contract individually \nper\u00adforms expensive computation, the sheer size of the code base and the number of contracts creates \na signi.cant overhead due to contract checking. More precisely, even for small Typed Racket programs \nthe time spent in contract checking can dominate type checking. For that reason, the developers of Typed \nRacket use a con.guration module to remove con\u00adtracts from deployment code and add them back only during \ndevelopment. Alas, it turns out that constantly enabling and disabling contract checking is error-prone \nand slows down the development cycle. Hence, the developers seldomly re\u00adcon.gure the code base when extending \nor .xing problems in the implementation; they reinstate contracts only when debugging broken code without \ncontracts becomes dif.cult.  Unsurprisingly, software developers do not update dis\u00adabled contracts as \nthey evolve the code base. Over the course of three months, we spotted numerous changes to the Typed \nRacket implementation that broke its contracted version. The problems range from syntactic errors in \ncontracts to function arity problems and module dependency omissions. Our observation suggests that contracts \nin the Typed Racket implementation should always be checked to some degree. To implement this idea without \nimposing a perfor\u00admance penalty, we formulated all function contracts in the Typed Racket code base as \noption contracts, e.g., (define/contract (make-arr ... ) (option/c (-> (listof Type/c) Type/c) #:tester \n(. (x) #t)) ...) Our options contracts come with a trivial tester that en\u00adforces the validation of the \n.rst-order properties of the val\u00adues attached to the contracts but no more contract checking takes place \nafter that. Moreover, we use waive-option to re\u00admove all the overhead of option contracts. Thus we made \nthe access to the contracted functions as cheap as if con\u00adtracts had not been applied. As a consequence, \ntype checking with option contracts results in a reduced overhead even for type checking computationally \nintensive modules (on aver\u00adage less than 15%, see section 5 for details) while perform\u00ading the syntactic, \narity and dependencies checks that would prevent the discrepancies we discovered. Our study shows that \noption contracts provide adequate infrastructure for gradually increasing the amount of con\u00adtract checking \nin the implementation of Typed Racket with\u00adout restructuring its code. At the level of our study, option \ncontracts perform basic checks. The developers can now en\u00adrich speci.c testers with deeper behavioral \nor random and probabilistic tests, increasing their assurance as they see .t.  4.2 Contract Checking \nOnly Where Necessary Acquire is a market-based board game. Players try to max\u00adimize pro.t from purchasing, \ntrading and expanding ho\u00adtel franchises. An implementation of Acquire can be con\u00adceptually divided into \nthree independent pieces, a Player, a Strategy and a Game component. The Game component can be further \nsplit into sub-components that implement the Board with its pieces, the State of the game between rounds \nand the game Administrator that interacts with the State in the name of each Player; diagrammatically, \nwe have: In the context of a program design course project, stu\u00addents implement the game, players and \nstrategies. For the .nal evaluation of the course, players, strategies and game implementations from \ndifferent students are combined to play a tournament. For this purpose, an additional Factory component \nis inserted between the Administrator and the Player components that composes strategies with players \nbefore linking them to the game Administrator. This set-up naturally gives rise to a world where pro\u00adgrammers \ncombine third-party components to obtain work\u00ading systems. Of course, a successful simulation requires \nthat all components correctly implement agreed-upon interfaces. In addition, for a component to compete \nsuccessfully in the competition, it must make sure that it protects itself from partners that do not \nrespect their interfaces. In our implementation, we enforce the components inter\u00adfaces with contracts. \nFor instance, a simpli.ed version of the contract for the interface of Strategy is: (define strategy/c \n(->i ([board (board-well-formed)] [player-s-tiles (listof tile?)] [cash cash?] [available-shares shares?] \n[available-hotels (board) (open-hotels board)]) (values [tile (board player-s-tiles) (good-placement \nboard player-s-tiles)] [hotel (board available-hotels tile) (good-hotel board available-hotels tile)] \n[shares (board cash tile hotel) (correct-purchase board cash tile hotel)]))) The contract speci.es that \na strategy function consumes a valid Board, the tiles of the Player, the Player s cash, and the administrator \ns hotel Shares, and a list of the hotels that the Player may still found. Given this information, the \nstrategy function returns to the Player the elements of the next move: a valid tile for the Player to \nplace on the board, an available hotel to found or acquire, and a purchase order for shares whose price \ndepends on the State of the game and the tiles placement. The Player component de.nes players as instances \nof the class player%. The module also provides the function create, which instantiates player% to obtain \ninstances that execute a given Strategy:  (define/contract (create name strategy) (-> string? strategy/c \n(instanceof/c player/c)) ...) The alert reader may have noticed that both Strategy and Player use strategy/c \nin the contracts of their interface, and thus the strategy argument of create is subjected to strategy/c \ntwice: once when it is exported from Strategy and once when it is passed to create. This may seem re\u00addundant \nbut in fact it is necessary in a world of third-party components. Since a third component, Factory, brings \nto\u00adgether Player and Strategy, imposing the contract twice is necessary; otherwise, the contract system \nmay blame Fac\u00adtory instead of Strategy when something goes wrong. If strategy/c were missing from Strategy, \nthere is no con\u00adtract boundary between Factory and Strategy from the per\u00adspective of the contract system, \nand in case of a violation, Factory is identi.ed as the source of the problem because it provided the \nmisbehaving value. Similarly if strategy/c was missing from the pre-condition of create, the contract \nsystem may shift blame from Player to Factory. In effect, the two contracts signal to the contract system \nthat Factory is a medium that simply passes values between Player and Strategy and should not get blamed \nfor them. In turn, this helps the programmer to localize the source of a violation of strategy/c. The \nprice for the protection of Factory is the double-checking of the contract. In addition to the contracts \non the interfaces of Player, Strategy and Administrator, our implementation comes with interfaces and \ncontracts for all the components of the game. These contracts enforce internal invariants of the com\u00adponents \nbut they are not critical after the implementation en\u00adters a stable phase. Like the Typed Racket contracts, \nthey result in signi.cant slowdown when running games. Option contracts can help improve the implementation \nin two different ways. First we employ option contracts to con\u00adtrol the cost of checking non-critical \ncontracts. These are all contracts except those between the Player component and, respectively, Strategy \nand Administrator. Second, with transfer/c and exercise-option, we eliminate the cost of checking strategy/c \non the pre-condition of create with\u00adout completely losing the ability to track misbehaving strate\u00adgies \nback to the strategy component. Hence, strategy/c becomes an option contract: (define strategy/c (option/c \n(->i ( ... ) ... ))) and strategy/c is replaced with transfer/c in the pre\u00adcondition of create: (define/contract \n(create name strategy) (-> string? transfer/c (instanceof/c player/c)) ...) The transfer/c contract recognizes \nthe option contract, adding Factory to the responsible providers and Player to the clients of the strategy \nfunction as it .ows to create. Now, with exercise-option we can activate contract checking for strategy/c \nwhen instantiating the player% class to obtain a player object: (define (create n strategy) (new player% \n[name n] [choice (exercise-option strategy)])) The contract system monitors the exercised strategy function \nfor the exercise/c contract in Player. If it detects a viola\u00adtion of the contract s post-condition it \nassigns blame both to Strategy and Factory and explains that blame informa\u00adtion concerns multiple parties \ndue to the transfer of the strat\u00adegy function from Factory to Player. Thus the programmer can follow \nthe transfer links back to the actual source of the problem in Strategy. Our analysis of the Acquire \nimplementation reveals how the features of the options library allow us to turn off con\u00adtract checking \nfor ef.ciency and selectively turn it on based on static information about the way components exchange \ncritical values. The next subsection explains how we can en\u00adrich these policies with dynamic information. \n 4.3 Contract Checking Only When Necessary Since exercise-option is a plain Racket function, Racket \nprograms can call it when a dynamically checked condition holds. DrRacket exploits this ability to selectively \nexercise option contracts to enforce contracts only for speci.c lexers that color the contents of the \nDrRacket editor pane. Racket is a family of languages, one of which is called racket. Each of these languages \ncomes with its own lexer and DrRacket needs a way to recognize the language of the contents of an editor \nin order to call the appropriate lexer. Each Racket .le, therefore, begins with a #lang speci.ca\u00adtion \nto indicate which of the Racket-based programming lan\u00adguages the program uses. For example, a .le containing \ncode in the Racket language should begin with #lang racket In contrast, document generating programs \nsuch as this subsection are implemented in the scribble language and their .les start with #lang scribble/base \n To support syntax coloring that is sensitive to the #lang speci.cation, DrRacket comes with a lexer \nfor just this line; its result is the lexer for the language. Once the latter is found, DrRacket dynamically \nlinks to the lexer and uses it for the rest of the module. Lexers for languages of the Racket family \nimplement an interface speci.ed as a contract. We have already discussed a simpli.ed version of this \ncontract in section 2: (define dep-lexer/c (->i ([in input-port?] [mode any/c]) (values [tok symbol?] \n[start (tok end) (if (equal? eof tok) #f (and/c natural-number/c (</c end)))] [end (tok) (if (equal? \neof tok) #f natural-number/c)] [new-mode any/c]))) Checking dep-lexer/c causes signi.cant overhead, espe\u00adcially \nwhen the lexer tries to color a .le as the programmer edits it. Since lexers such as the ones for Racket \nand Scribble are well-tested and have been found bug-free for a few years, we can consider them trusted \nand use an option contract to silence their contracts. The following option contract around lexer/c also \nuses a tester that generates a few random inputs to try out the lexer and thus re-establish trust: (define \nlexer/c (option/c dep-lexer/c #:tester (. (l) (try-random-streams l)))) In contrast to racket and scribble, \nmost of the other lex\u00aders distributed with Racket, for example, the lexers that are part of the datalog \nand algol60 implementations, are not trusted. The predicate trusted-lexer? consumes a lexer and checks \nif the lexer is in the pre-de.ned list of trusted lexers of DrRacket. For the lexers that trusted-lexer \nreturns #f, DrRacket should use the dep-lexer/c contract. Unfortunately, we have now two different contracts \nfor lexers; one with the option for the trusted lexers and one without it for the untrusted lexers. As \na result the information about which lexers DrRacket trusts, and which not is spread all over the code \nbase of Racket and requires error-prone and intrusive infrastructure to maintain and update. One possible \nsolution is to modify the structure of the #lang-line lexer. Instead of having that lexer call directly \nthe language lexers, we could insert a lexer manager function that accesses the list of trusted lexers \nand attaches to each lexer an appropriate contract. In Racket we can implement this idea easily with \nwith-contract, a construct for creating nested contract regions inside a component [27]: (define (lexer-manager \nlexer) (if (trusted-lexer? lexer) (with-contract new-lexer #:result lexer/c lexer) (with-contract new-lexer \n#:result dep-lexer/c lexer))) Despite its simplicity, the above solution has a shortcom\u00ading. Since we \nseparate the lexers and their speci.cation, the contract system does not have enough information to track \nthe error back to the language lexer implementation in case of a contract violation. In particular, from \nthe perspective of the contract system, the contract dep-lexer/c is not between an untrusted lexer and \nits clients but rather between the con\u00adtract region labeled new-lexer and its context. Thus, if the post-condition \nof dep-lexer/c fails, the contract system as\u00adsigns blame to new-lexer which resides in the module of \nthe #lang-line lexer and not the module that de.nes the bro\u00adken lexer. In short, this kind of violation \nreport misleads the programmer because it requires an additional search for the guilty party. With option \ncontracts, we can solve the problem elegantly. First, we use lexer/c as the interface for every lexer, \nkeeping lexers and their speci.cation together. Sec\u00adond, we employ exercise-option and waive-option to \nac\u00adtivate the contract on untrusted lexers and remove the options related overhead for trusted ones, \nrespectively: (define (lexer-manager lexer) (if (trusted-lexer? lexer) (waive-option lexer) (exercise-option \nlexer))) This de.nition of lexer-manager takes advantage of the op\u00adtion contract associated with the \nlexer. It activates it only as necessary. If a lexer violates its exercised contract, the con\u00adtract system \ncan now assign blame to the lexer itself and pro\u00advide the programmer with precise debugging information. \nThe options-based solution is part of the latest Racket implementation. Option contracts have made it \npossible to reduce the cost of coloring text in DrRacket when trusted lexers are used. Conversely option \ncontracts permit to moni\u00adtor the contract on untrusted lexers and pinpoint faults when contracts are \nviolated. 5. Performance Evaluation The preceding section shows how option contracts make it straight-forward \nto implement a variety of contract checking policies. In this section, we provide experimental evidence \nto support this claim. Speci.cally, we use the results from measuring three benchmark suites based on \nour three case studies to make our case. Each measurement compares the execution time of the benchmarks \nwithout contracts, with plain contracts and with option contracts. Our measurements  Normalized average \nof cpu time of 30 runs. The length of the bars denotes the width of the 95% con.dence interval for the \nslowdown. Measurements performed on an Intel Core i5-3550S CPU @ 3.00GHz X 4 with 4 GiB memory running \n32-bit Ubuntu 13.04 and Racket 5.3.4.7. Figure 1: Experimental Results for Typed Racket con.rm that option \ncontracts signi.cantly reduce the slow\u00addown in.icted on programs from contract checking. 5.1 Typed Racket \nIn the setting of Typed Racket, we measure the cost of type\u00adchecking 60 different .les from the Racket \ndistribution that are implemented in Typed Racket. These modules range from tests for the Typed Racket \nimplementation to pieces of the math and plot libraries of Racket. Of the sixty modules, twenty are those \nwith the highest typechecking time, twenty are closest to the median time and the remaining twenty are \nthe most popular, i.e., those that are imported most fre\u00adquently by other modules in the code base. Each \nbenchmark consists of a call to the compiler for the corresponding .le and a call to the garbage collector. \nThe latter helps us to account for the memory use during compilation. Without it, our benchmark script \nmay terminate before all of the allocated memory has been involved in a collection, unfairly lowering \nthe price of the allocation. We run our benchmarks in three major modes: without contracts, with the \nplain contracts that the Typed Racket developers specify, and with all these contracts turned into option \ncontracts as described in sub-section 4.1. In addition to measuring the cost of the option contracts \nmechanism, we run the benchmarks in the any/c mode where all contracts are replaced by a trivial, never \nfailing contract. This mode measures the vanilla cost of applying contracts to values. The chart of .les \nto slowdown in .gure 1 displays the results of our measurements. To each .le, which de.nes one of the \nmodules in our benchmarks set, correspond up three error bars. For every .le except two, discussed below \nthe error bars show up in the same order: the bottom one (gray) shows the slowdown due to contract application, \nthat is the cost of the any/c mode, the middle one (black) shows the cost of option contracts, and the \ntop one (light gray) shows the cost of plain contracts. All of the numbers are normalized to the no-contracts \nmode, which serves as our baseline and the width of each bar indicates the length of the 95% con.dence \ninterval for the slowdown establishing the signi.cance of our results.2 We can read a few general insights \nfrom the chart. First, the overall overhead from option contracts .uctuates be\u00adtween 1% and 27%. In all \nbut three benchmarks, it is be\u00adlow 20%, and in all but eight benchmarks, it is below 15%. In all but \none case, the overall cost of option contracts is smaller than that of plain contracts by 5% to 127%. \nSecond, since the bars in the chart are sorted by the overhead of plain contract checking, the cost of \noption contracts does not scale with the cost of plain contract checking. Third, a good proportion of \nthe cost of option contracts comes from contract application (0% 17%), i.e., the cost of of the any/c \nmode. We have further analyzed the source of the raw cost of option contracts, i.e., the cost of the \noption contracts mode minus the cost of the any/c mode. This cost ranges between 1% and 10%. Our measurements \nshow that a small percentage of this cost is due to creating option contracts (1 4%, 50ms out of 1100ms \nin the worst case) while the rest is due to the cost of waiving option contracts together with the cost \nof the .rst-order checks that options perform. We omit the details of these measurement here for conciseness. \n2 We follow the methodology of George [15, Section 4.2.4] for the statisti\u00adcal analysis of slowdowns. \n Acquire contracts option contracts 1.62 (0.02) 1.01 (0.01) Normalized average of cpu time of 30 runs. \nThe numbers in parenthesis denote the width of the 95% con.dence interval for the slowdown. Mea\u00adsurements \nperformed on an Intel Core i5-3550S CPU @ 3.00GHz X 4 with 4 GiB memory running 32-bit Ubuntu 13.04 and \nRacket 5.3.4.7. Figure 2: Experimental Results for Acquire The chart exhibits two anomalies. First, in \nmodule types (the last column) the any/c mode is less expensive than the without contracts mode by a \nsmall amount, 9ms out of 1820ms. We do not have a good explanation for this in\u00adversion. Second, module \nsample (second from the right) is the only case where the option contracts mode takes longer that the \nfull contracts mode. Again the absolute difference is small, 34ms out of 1850ms. Type-checking this particular \nmodule is trivial in terms of performance, despite the fact that the type-checker constructs 700 contracts. \nThe cost of creating and waiving these contracts is a plausible explana\u00adtion for the extra cost of the \noption contracts mode. We also looked more carefully into the cost that the any/c contract imposes relative \nto the no-contracts baseline and discovered that most of this cost comes in the form of in\u00adhibited optimizations, \nas the code that the contract library generates can confuse the compiler s analysis. Currently the cost \nof using option contracts instead of dis\u00adabling contract checking is prohibitive for integrating option \ncontracts with Typed Racket s typechecker. However, since most of this cost comes from contract application, \nwe antic\u00adipate that performance improvements to the contract system of Racket will allow us in the near \nfuture to make option contracts the default mechanism for controlling the contract checking overhead \nin the implementation of Typed Racket.  5.2 Acquire Our Acquire benchmark runs four complete games with \nthree, four, .ve and six players respectively. We measure the performance of the simulation in three \ndifferent modes: without contracts in the implementation of the game, with plain contracts on the interfaces \nof all the components of the game, and with all these contracts replaced by option con\u00adtracts. In the \nlatter case, we use exercise-option to activate contracts between Player and Administrator; following \nthe description in section 4.2, we also replace strategy/c in the contract of create with transfer/c \nand apply exercise\u00adoption to activate the option contract on the strategy func\u00adtion within create. The \ntable in .gure 2 shows the results of our measure\u00adments. Contract checking results in 62% slowdown and \nop\u00adtion contracts manage to bring it down to 1% even though the critical contracts between Strategy, \nPlayer and Admin\u00adistrator are checked.  5.3 DrRacket s Lexer For DrRacket s code coloring infrastructure, \nwe construct two benchmarks. The .rst loads a 5,000-line racket .le and measures the time it takes to \ncolor the lexemes of the .le while treating the lexer of the Racket language as a trusted lexer. The \nsecond carries out the same task but considering the lexer as untrusted. Similar to the Acquire benchmarks, \nwe run the two benchmarks without contracts, with plain contracts and with option contracts. For the \nwith contracts mode, all the lexers involved (the #lang-line lexer and the racket lexer) are equipped \nwith the dep-lexer/c contract mentioned in section 4.3. For the with option mode, we use the lexer/c \noption contract. The tester of this contract tries the given lexer on ten stream inputs of random size \nbetween zero and a hundred characters. The table in .gure 3 shows the results of our measure\u00adments. Contract \nchecking results in 21% slowdown. In the trusted case, option contracts eliminate this overhead almost \nentirely (1%), which implies that the cost from the random tests of the option contracts are insigni.cant. \nIn the untrusted case, we get a 14% slowdown from option contracts. Since the lexer/c contract is exercised \nfor the Racket lexer, the contract system monitors this contract while the lexer colors the .le. The \n7% improvement compared to the plain con\u00adtracts mode is due to the fact that the #lang-line lexer is \nstill considered trusted and its option contract is not exercised. DrRacket s Lexer contracts option \ncontracts trusted 1.21 (0.02) 1.01 (0.01) untrusted 1.21 (0.02) 1.14 (0.01) Normalized average of cpu \ntime of 30 runs. The numbers in parenthesis denote the width of the 95% con.dence interval for the slowdown. \nMea\u00adsurements performed on an Intel Core i5-3550S CPU @ 3.00GHz X 4 with 4 GiB memory running 32-bit \nUbuntu 13.04 and Racket 5.3.4.7. Figure 3: Experimental Results for Racket s Lexer 6. Option Contracts \nin Theory Like type systems, contract systems should satisfy some ba\u00adsic universal properties so programers \ncan rely on their feed\u00adback [7]. Speci.cally, (1) when a contract system blames a component for a violation, \nthe component must be able to affect the .ow of values through the violated contract boundary and (2) \ncontract systems must be able to moni\u00adtor all the channels of communication between components so that \nno unchecked value may migrate into a seemingly protected component. As history has shown, it is easy \nfor a language designer to violate these conditions [6, 7]. This section shows that option contracts \nsatisfy these properties.  We specify the semantics of option contracts as an ex\u00adtension to CPCF, called \nOCPCF. In turn, CPCF [5] extends Plotkin s PCF [26] with generic constructs for formulat\u00ading and monitoring \ncontracts. Unlike Racket, CPCF is a simply-typed higher-order functional language; we use a typed model \nto expose the orthogonality of types and con\u00adtracts and to help the designers of typed languages with \nimporting option contracts into their world.. A contract ex\u00adpresses computable properties of values at \nany level in the type hierarchy. Monitors interpose contracts between value producers and consumers and, \nat runtime, unfold into code that enforces the properties. Types t = o | t.t | con(t) o = I | B d Contracts \nc = flat(e) | c .(.x.c) d | option(c .(.x.c),e) | transfer Terms e = v | x | e e | \u00b5x:t.e | e+e | e-e \n| e.e | e.e | zero?(e) l,l | if e e e | M(c,e) l | exercise(e) | waive(e) Comp. Values v * = .x:t.e Values \nv = b | v * Base Values b = 0 | 1 | - 1 | . . . | tt | ff Figure 4: OCPCF: source syntax Figure 4 shows \nthe source syntax for OCPCF. Like CPCF, OCPCF is a typed language that comes with predicate con\u00adtracts \nfor primitive values, written flat(e), and contracts for d higher-order functions, written c1 .(.x.c2) \nwhere the pre\u00adcondition c1 is the contract on the argument and the post\u00adcondition c2 is the contract \non the result. The latter is a dependent function contract where the argument to the func\u00adtion is bound \nto x making it visible in the post-condition of the contract and allowing for properties of the result \nto de\u00adpend on the argument. In addition, OCPCF offers two more kinds of contracts: option contracts and \ntransfer contracts. Concretely, option(c, e) pairs a function contract c with a tester e that exercises \nthe function; like our Racket imple\u00admentation, OCPCF syntax restricts option contracts to func\u00adtion contracts. \nA transfer contract tags a value as trusted and never signals a contract violation. If the value comes \nwith an option contract, the consumer is added to its list of responsible client parties and the provider \nto the responsible server parties. The programmer can apply a contract c to a compo\u00adnent e using Mkj \n,l (c,e). Such a monitor separates two com\u00adponents: the service provider e and its surrounding context, \nthe client. It corresponds to Racket s define/contract and with/contract forms. The labels k, l and j \nserve as iden\u00adti.ers for the exporting component; dubbed the server; the importing component, the client, \nand the contract itself, re\u00adspectively. In source code, monitors have only one server and client label, \nbut due to option contracts monitors may accumulate multiple server and client labels during evalu\u00adation. \nThese sets of labels represent those components that have endorsed a value with an option contract. A \ncomponent can use exercise(e) to remove the option contract from the value of e (if any) and replace \nit with the underlying contract. The waive(e) expression discards the option contract (if any) from the \nvalue of e. Here is an example contract for a derivative operator: d c = c1 .(. f .option(c2,t est er)) \nc1 = .(.x.posit ive)posit ive d c2 = .(.x.close-to-slope-of-f@x) posit ive d The post-condition of c2 \nasserts that the slope of f around x is close to the result of d eriv applied to f at x. The op\u00adtion \ncontract for c2 performs some random testing on f as speci.ed in the t est er predicate. Component e1, \nnamed k1, imports deriv with contract c and applies it to a function f : s,k1 e1 = (M(c,deriv)) f j1 \nThen e1 does not exercise the option contract, but transfers its result to a client e2, named k2: k1,k2 \ne2 = (M(transfer,e1)) 0 j2 Component e2 imports the result of e1, trusts the random testing and opts \nout of any further checks related to c2. In other words, e2 uses the result of e1 without any con\u00adtract \nchecking. By importing a transfered value, client e2 acknowledges responsibility as a client of the randomly \nchecked result of e1. Moreover, since e1 transfers its result to e2, it deliberately chooses to become \na server for this value. A different client e3, labeled k3, imports e1 and exercises the option: k1,k3 \ne3 = (exercise(M(transfer,e1))) 0 j3 Let f' denote the derivative function of f and c'2 and t est er' \nthe result of substituting f for x in c2 and t est er, respectively, which is necessary due to the dependent \nnature of c. Client e3 considers c'2, the contract of f', to be critical and thus decides not to trust \nthe random testing. Since e3 applies f' to a value that violates the precondition of c'2, the contract \nsystem detects the violation and blames the components that imported f', in this case e1 and e3 and reports \ntheir labels k1 and k3, respectively, in the contract error message. If e3 provided to f' a value that \ndoes not violate the precondition of c'2 and the contract system detected a violation of the post\u00adcondition \nof c'2, it would blame all the responsible servers of f' and report their labels, namely s and k1. Finally, \na client e4 deems that c'2 is not a critical property to monitor and decides to waive the option contract \non f'.  The waive expression allows e4 to use the function without paying for the overhead of the option \ncontract monitor: k1,k4 e4 = waive(M(transfer,e1)) 0 j4 The waive operator frees the value from the monitor \nand the ' application proceeds as if f had never had a contract. In order to prove the fundamental soundness \ntheorem for our contract system, we formulate a reduction semantics. In\u00adterested readers can .nd the \nconcrete de.nition of the se\u00admantics in appendix A.1. What we need to know here is that the semantics \nspeci.es a reduction relation . whose transitive closure .* reduces the program to its .nal value (if \nany). The relation requires an additional kind of term syntax so-called option guards Olj ,k(c,e) to \nexpress val\u00adues with option contracts wrapped around them. To demonstrate the workings of our semantics, \nwe revisit our examples from above. Under the semantics of the model, e2 reduces as follows: k1,k2 s,k1 \ne2 .* (M(transfer,M(option(c ' 2,t est er ' ), f ' ))) 0 j2 j1 k1,k2 s,k1 .* (M(transfer,O(c ' 2, f \n' ))) 0 j2 j1 {k1,s},{k2,k1} .* (O(c ' 2, f ' )) 0 j1 . f ' 0 Since the option contract is not exercised \nthe result of e1 does not come with a monitor around it and the application proceeds without any contract \nchecking. In short, the use of 0 does not result in a violation of c ' 2. In the case of e3, the reduction \nproceeds differently: k1,k3 s,k1 e3 .* (exercise(M(transfer,O(c ' 2, f ' )))) 0 j3 j1 {k1,s},{k3,k1} \n' .* (exercise(O(c2, f ' ))) 0 j3 {k1,s},{k3,k1} .* (M(c ' 2, f ' )) 0 j1 Since e3 chooses to exercise \nthe option contract, the applica\u00adtion involves checking c ' 2 and thus results in a contract error. The \ncontract system blames the components labeled k1 and k3, meaning e1 and e3, the components that imported \nf ' : {k3,k1} e3 . * error j1 The last example e4 shows how waive discards an option guard around a value: \n{k1,s},{k4,k1} ' e5 .* waive(O(c2, f ' )) 0 . f ' 0 j1 As the examples point out, our model introduces \na pol\u00adicy for assigning blame that somewhat deviates from the Findler-Felleisen model. Instead of blaming \none compo\u00adnent for violating its contractual obligations, our new model assigns blame to potentially \nmany components. Moreover, transfer contracts permit values to entirely bypass con\u00adtract checks, undermining \nthe ability of the contract system to detect contract violations. Considering the dif.culties of getting \nblame assignment correct for the Findler-Felleisen version of contracts [6], these changes call for a \nformal investigation of the correctness of our contract system. In particular, we must prove that our \ncontract system is able to: disallow values to bypass contract checks, unless they are explicitly transferred \nfrom one component to another,  keep track of transferred values, and  on contract violation, report \nall the parties that created the value or were involved in a transfer. These informal criteria can be \nformalized as a variant of a basic correctness property for contract systems, dubbed complete monitoring \n[7]. TH E O R E M 1. . satis.es complete monitoring for OCPCF PRO O F. A detailed account of the proof \ntechnique and the proof itself is provided in appendix A.2 and A.3. 7. Related Work Eiffel [23, 25] .rst \npopularized software contracts and in\u00adtroduced the design-by-contract paradigm. The latter builds on \na view of the world of software components as a market where software contracts play the role of business \ncontracts, imposing obligations and making promises about compo\u00adnents. Option contracts take this analogy \none step further introducing notions that correspond to .nancial options to\u00adgether with actions such \nas transfer and exercise. Since Eiffel introduced contracts, contracts have been used both for extended \nstatic checking [1, 3, 10, 16, 33], runtime monitoring of higher-order programs [12, 18], and even a \nmixture of the two approaches [17, 21]. Nowadays, contracts in one form or another are part of many mainstream \nlanguages and libraries. Option contracts live in the world of dynamically enforced contracts and build \non a decade of linguistic research on software contracts [12]. The designers of languages with software \ncontracts rec\u00adognize the performance impact of contract checking and pro\u00advide compile-time mechanisms \nthat disable contract check\u00ading entirely or partially. For example, Ada [20] program\u00admers can use the \nbuilt-in pragma Assert for this purpose. Eiffel [8] programmers can modify the Assert options of the \nEiffel compiler to enable or disable speci.c kinds of as\u00adsertions. For instance, the \"Supplier Precondition\" \noption addresses interaction with trusted libraries, disabling all as\u00adsertions for these libraries except \npre-conditions. Racket pro\u00adgrammers implement such compile time mechanisms with macros. As discussed, \nthe Typed Racket developers achieve a reasonably .exible use of the contracts in their imple\u00admentation. \nUnfortunately, all these methods for controlling contract checking permit only static, all-or-nothing \npolicies either at the component or the contract level. Option con\u00adtracts offer another alternative, \nnamely, .ne-grained con\u00adtrol of contract checking without weakening the precision of blame assignment. \nMoreover, option contracts can also be used to implement dynamic contract-checking policies, as demonstrated \nin our DrRacket example.  8. Conclusion Software contracts are notorious for their cost. Given the economic \nincentives for performance, any given program\u00admer routinely disablesf contracts for product deployment, \nacting, as Hoare [19] puts it, [as] a sailing enthusiast who wears his lifejacket when training on dry \nland, but takes it off as soon as he goes to sea. Our work tackles this prob\u00adlem, giving programmers \nnew powers to create new policies of contract checking, avoiding some performance overhead and the code \nbase skew that results from disabled contracts. With this new expressive power of option contracts, pro\u00adgrammers \nacquire new responsibilities. Client-side program\u00admers must adapt their programming style to option contracts. \nThe creators of server components cannot remove option an\u00adnotations from contracts in a lighthearted \nmanner because doing so may have serious performance implications. The Racket community has just begun \nits experimentation with options, and we hope to report our insights in the future. Acknowledgments Thanks \nto Amal Ahmed and Amr Sabry for the inspiring exchange that triggered this research. Sam Tobin-Hochstadt \ncoined the phrase option contracts. AFOSR supported the exploration of contracts for Dimoulas and Felleisen \nin the past; NSF provides support for Findler. References [1] M. Barnett, K. R. M. Leino, and W. Schulte. \nThe Spec# programming system. In CASSIS, pages 49 69, 2004. [2] A. Beugnard, J.-M. J\u00e9z\u00e9quel, N. Plouzeau, \nand D. Watkins. Making components contract aware. IEEE Computer, 32(7): 38 45, July 1999. [3] D. L. Detlefs, \nK. R. M. Leino, G. Nelson, and J. B. Saxe. Extended static checking. Technical Report 158, Compaq SRC \nResearch Report, 1998. [4] C. Dimoulas. Foundations for Behavioral Higher-Order Con\u00adtracts. PhD thesis, \nNortheastern University, 2012. [5] C. Dimoulas and M. Felleisen. On contract satisfaction in a higher-order \nworld. ACM Transactions on Programming Languages and Systems, 33(5):16:1 16:29, 2011. [6] C. Dimoulas, \nR. B. Findler, C. Flanagan, and M. Felleisen. Correct blame for contracts: No more scapegoating. In POPL, \npages 215 226, 2011. [7] C. Dimoulas, S. Tobin-Hochstadt, and M. Felleisen. Complete monitors for behavioral \ncontracts. In ESOP, pages 211 230, 2012. [8] Standard ECMA-367 Eiffel: Analysis, Design and Program\u00adming \nLanguage. Ecma International, 2006. [9] F. Erg\u00fcn, S. Kannan, S. R. Kumar, R. Rubinfeld, and M. Viswanathan. \nSpot-checkers. Journal of Computer and System Sciences, 60(3):717 751, 200. [10] M. F\u00e4hndrich, M. Barnett, \nand F. Logozzo. Embedded con\u00adtract languages. In SAC, pages 2103 2110, 2010. [11] M. Felleisen, R. B. \nFindler, and M. Flatt. Semantics Engineer\u00ading with PLT Redex. MIT Press, 2009. [12] R. B. Findler and \nM. Felleisen. Contracts for higher-order functions. In ICFP, pages 48 59, 2002. [13] C. Flanagan, K. \nR. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. \nIn PLDI, pages 234 245, 2002. [14] M. Flatt and PLT. Reference: Racket. Reference Manual PLT\u00adTR2010-reference-v5.3.3, \nPLT Design Inc., February 2013. URL http://racket-lang.org/techreports/. [15] A. George. Three Pitfalls \nin Java Performance Evaluation. PhD thesis, Ghent University, 2008. [16] M. Greenberg, B. C. Pierce, \nand S. Weirich. Contracts made manifest. In POPL, pages 353 364, 2010. [17] J. Gronski and C. Flanagan. \nUnifying hybrid types and con\u00adtracts. In TFP, pages 54 69, 2007. [18] R. Hinze, J. Jeuring, and A. L\u00f6h. \nTyped contracts for func\u00adtional programming. In FLOPS, pages 208 235, 2006. [19] C. A. R. Hoare. Hints \non programming language design. Technical report, Stanford University, 1973. [20] Ada 2012 Language Reference \nManual. International Organi\u00adzation for Standardization, 2012. [21] K. Knowles, A. Tomb, J. Gronski, \nS. N. Freund, and C. Flanagan. Sage: Uni.ed hybrid checking for .rst-class types, general re.nement types, \nand dynamic, 2006. URL http://sage.soe.ucsc.edu/. [22] G. T. Leavens, A. L. Baker, and C. Ruby. JML: \nA notation for detailed design. In Behavioral Speci.cations of Businesses and Systems, pages 175 188. \n1999. [23] B. Meyer. Design by contract. In Advances in Object-Oriented Software Engineering, pages 1 \n50. Prentice Hall, 1991. [24] B. Meyer. Applying design by contract. IEEE Computer, 25 (10):40 51, 1992. \n[25] B. Meyer. Eiffel: The Language. Prentice Hall, 1992. [26] G. D. Plotkin. LCF considered as a programming \nlanguage. Theoretical Computer Science, 5(3):223 255, 1977. [27] T. S. Strickland and M. Felleisen. Nested \nand dynamic con\u00adtract boundaries. In IFL, pages 141 158, 2009. [28] T. S. Strickland, S. Tobin-Hochstadt, \nR. B. Findler, and M. Flatt. Chaperones and impersonators. In OOPSLA, pages 943 962, 2012. [29] S. Tobin-Hochstadt \nand M. Felleisen. Interlanguage migra\u00adtion: from scripts to programs. In DLS, pages 964 974, 2006. [30] \nS. Tobin-Hochstadt and M. Felleisen. The design and imple\u00admentation of Typed Scheme. In POPL, pages 395 \n407, 2008. [31] S. Tobin-Hochstadt and M. Felleisen. Logical types for un\u00adtyped languages. In ICFP, pages \n117 128, 2010. [32] S. Tobin-Hochstadt and D. V. Horn. Higher-order symbolic execution via contracts. \nIn OOPSLA, pages 537 554, 2012. [33] D. Xu, S. Peyton Jones, and K. Claessen. Static contract checking \nfor Haskell. In POPL, pages 41 52, 2009.  A. Appendix This appendix presents a proof of complete monitoring \n[7] for OCPCF, a model of a typed variant of Racket with option contracts. Complete monitoring guarantees \nthat the contract system assigns blame accurately and protects components effectively. A complete monitoring \ntheorem is thus the min\u00adimal standard that a contract system should satisfy. Unfortunately, the OCPCF \nmodel does not come with the necessary infrastructure to prove complete monitoring. We deal with this \nissue via an indirect approach. We .rst de.ne another model *OCPCF, which has the required hooks for \nestablishing complete monitoring. After that we show that the two models are observably equivalent. The \n.rst section of this appendix introduces a suitable re\u00adduction semantics [11] of OCPCF. While the second \nsection presents *OCPCF, the third one proves that it satis.es com\u00adplete monitoring and bi-simulates \nOCPCF.   A.1 Reduction Semantics for OCPCF Figures 5 through 7 present the evaluation syntax of OCPCF \nas an extention to its source syntax (.gure 4) plus its eval\u00aduation contexts and reduction rules. The \nrules that do not involve contracts are the same as those for Plotkin s PCF. The evaluation syntax of \nOCPCF comes with two kinds k,l k,l of monitors: Mj (c,e) and Oj (c,e). The .rst correspond to components \nwhose result the contract system monitors for c while the second denote components whose result the contract \nsystem does not monitor for c but they contain c and enable the use of exercise or transfer. Terms Guards \ne mg = | = ... | checkl\u00af l (e,v) | tryl\u00af l (e,e) error l\u00af l | mg | og Ml\u00af ,l\u00af l (c,e) og = Ol\u00af ,l\u00af l \n(c,e) Values MGV : OGV : mgv ogv = = Ml\u00af ,l\u00af l (c,v *) Ol\u00af ,l\u00af l (c,v *) v * = ... | mgv | og Figure \n5: OCPCF: evaluation syntax The monitor expression Mkj ,l (flat(e),b) reduces to a check that tests whether \npredicate e holds for b. If the check succeeds, it returns b; else it raises a contract violation k error \nj that blames component k for violating contract j. k,l d The monitor expression Mj (c1 .(.x.c2),v) uses \na moni\u00adtor guard to protect the function v during future applications. When the guard is applied, the \nreduction rule decomposes the contract, creates a guard that monitors the argument with c1 and then applies \nv to the guard. The responsible reduction rule also constructs a guard that monitors the result of the \napplication with c2. The monitor of the argument .ips the server and client labels while the monitor \nof the result leaves them as they are. The label swap signals that the precondi\u00adtion becomes the responsibility \nof the client, which after all provides the argument, while the post-condition remains the responsibility \nof the server. For the dependent aspect of the contract, the rule implements the indy semantics [6], \nmean\u00ading x in c2 is replaced by the argument monitored by c1 where j replaces k. The intuition behind \nthe labels selection is that the original client l is responsible for the argument s post-condition but \nthe contract j is responsible for the treat\u00adment of the argument inside the contract s code. Finally, \nMkj ,l (option(c,e),v) employs try to test whether a guard for v with c satis.es the tester e. Since \ne is part of the contract itself, the monitor for the test carries j as its client label. If the test \ndoes not lead to a contract error, try returns an option guard, Okj ,l (c,v), which is a value that stores \nv together with c and the labels of the original monitor. An option guard represents a partially checked \nfunc\u00adtion; it keeps track of the contract so that a component may exercise the option. In addition, it \naccumulates the labels of the components that accept the option guard to accurately assign blame when \ncontract checking detects a contract breach. A component may use an option guard like any other function. \nIn particular, the application Okj ,l (c, v f ) v reduces to an ordinary application vf v. E = [ ] | \nE e | v E | E +e | v+E | E -e | v-E | E .e | v.E | E .e | v.E | zero?(E ) k\u00af,l\u00af \u00af k l\u00af | if E e e | \nM j (c, E ) | checkl (E ,v) | tryl (E ,v) | exercise(E ) | waive(E ) Figure 6: OCPCF: evaluation contexts \nWhen a monitoring expression employs transfer as a contract, guarded values experience a change of labels. \nk,l h,q Speci.cally, M(transfer,O(c,v)) updates the option j' j guard s labels; it adds the server and \nclient labels of the monitor to the server and client labels of the guard to pro\u00ad kh,lq duce O(c,v). \nThis labeling shows how the consumer of j the guard takes responsibility as a client and the exporting \ncomponent as a server. Monitors of transfer contracts do not affect other kind of values; they simply \npass them on. Exercising an option transforms an option guard Okj ,l (c,v) into a monitored guard, Mkj \n,l (c, v). Due to transfer contracts and exercise, monitor guards carry a pair of sets of labels instead \nof one server and one client label. This implies that in case of a contract failure check blames all \nthe labels at the server position on the guard, i.e., it blames all the components that accepted responsibility \nfor the guarded value. Like exercise, waive affects only guards. It extracts v \u00afl\u00af from Okj ,(c, v) and \notherwise passes on all other values.  E [\u00b7\u00b7\u00b7] . E [\u00b7\u00b7\u00b7] the term is not embedded in an appropriate \nmonitor, then the contract system allows values to leak from one component to another without inspection. \nPut positively, if a contract system manages to enforce a single-owner policy through\u00adout program execution, \ni.e., every value has a single owner, it allows preogrammers to protect components completely. As for \nblame assignment, a correct contract system should blame a component only if it breaks one of its promises. \nWe therefore mark the pieces of a contract that a component needs to live up to with obligation annotations. \nEquipped with this machinery, we can specify what it means for a contract system to assign blame correctly. \nA contract system may blame a component only if one of its values violates one of its contractual obligations. \nAdding ownership and obligations annotations to OCPCF directly poses a challenge. Monitors for transfer \ncontracts allow values to circumvent the contract system as they mi\u00adgrate from one component to another. \nThus a naive anno\u00adtation of the OCPCF semantics with ownership labels vi\u00adolates the single-owner policy \nand breaks complete moni\u00adtoring. Fortunately, we can construct an extension of CPCF with annotations \n[7] that is equivalent to OCPCF and tracks uninspected values. We call the new language *OCPCF. dl\u00af Contracts \nc = ... | loption(c.(.x.c),e)j| transfer Terms e = ... | exercise(e) | waive(e) G;l l e G;l l e G;l l \ne G;l l exercise(e) G;l l waive(e) G; \u00afk;l\u00af; j [ c G;k\u00af;l\u00af; j [ transfer G;k\u00af; l\u00af; j [ c G; j l e k\u00af \nG; k\u00af;l\u00af; j [ loption(c, |e|j)j Figure 8: *OCPCF: Well-formed source programs The syntax of *OCPCF extends \nannotated CPCF with ownership and obligations annotations; see top of .gure 8. The bottom of the .gure \nadds rules for well-formed source programs and contracts to those of CPCF. The most inter\u00adesting rules \nare those for contracts. Transfer contracts never fail and thus do not impose obligations and are always \nwell\u00adformed. In contrast, option contracts may raise a contract violation due to a failed test and thus \nthey impose obliga\u00adtions like .at contracts. Also, an option contract must own its tester term. In addition \nto try and check, the evaluation syntax of *OCPCF (.gure 9) introduces a small ecosystem of guards. We \ngroup guards in three categories: monitor guards M, op\u00ad n1 +n2 n1 -n2 zero?(0) zero?(n) v1 .v2 v1 .v2 \nif tt e1 e2 if ff e1 e2 .x.e v \u00b5x.e . n where n1 + n2 . n where n1 - n2 . tt . ff if n= 0 . v where v1 \n. v2 . v where v1 . v2 . e1 . e2 . {v/x}e . {\u00b5x.e/x}e = n = n = v = v \u00af k,l\u00af k\u00af M j (flat(e),b) . check \nj(e b,b) \u00af k,ll\u00af M (option(c,e),v) j \u00af\u00af k\u00afk, jl\u00af k,ll\u00af try j(e M (c,v), O (c,v)) j j kk\u00af,l\u00af d Mj (c1 \n.(.x.c2),vf ) v . kk\u00af,l\u00af l\u00af , jk\u00afl\u00af ,kk\u00af M({M(c1,v)/x}c2,vf M(c1,v)) jj j k,l Mj (transfer,v) . v if \nv . OGV k\u00af,l\u00af h\u00af,q\u00afk\u00afh\u00af,l\u00af q\u00af M (transfer,O (c,v)) . O (c,v) j' j j k\u00af check j(tt, v) . v k\u00afk\u00af check \nj(ff, v) . error j k\u00af try j(tt,v) . v \u00af tryk\u00afj(ff,v) . error k j exercise(v) . v if v . OGV exercise(O \n\u00afh, \u00afq j (c,v)) . Mk\u00afh,l \u00afq j (c,v) waive(v) . v if v . OGV waive(O \u00afh, \u00afq j (c,v)) . v O \u00afk,l\u00af j (c,vf \n) v . vf v k\u00afk\u00af E [error j] . error j Figure 7: OCPCF: reduction semantics  A.2 *OCPCF: A Theorem-Friendly \nSemantics Complete monitoring requires that we decorate OCPCF pro\u00adgrams with annotations for ownership \nand obligations [7]. Ownership and obligations are tools for reasoning about the behavior of the contract \nsystem independently of monitors. An obligation annotation lflat(e)jl\u00af denotes that compo\u00adnents l\u00af are \nresponsible for meeting the contract flat(e). An ownership annotation |e|l indicates that component l \nowns e. Ownership provides a mechanism for tracking the migra\u00adtion history of values and thus helps establish \nthat the con\u00adtract system offers suf.cient protection. A revised semantics propagates ownership annotations. \nIf the ownership annota\u00adtion of a term is different than the owner of its context and  l\u00af l\u00af Terms e \n= ... | error | tryl (e,e) l | mg | og | wg l,l Guards mg = M(c,e) | * Ml,l (e) | |mg|l l l,l og = O(c,e) \n| * Ol,l (e) | |og|l l wg = Wl,l (e) | |wg|l Values l,l MGV : mgv = M(c,v *) | * Ml,l (v *) | |mgv|l \nl l,l OGV : ogv = O(c,v *) | * Ol,l (v *) | |ogv|l l W GV : wgv = Wl,l (v *) | |wgv|l v * = ... | mgv \n| ogv | wgv Figure 9: *OCPCF: Evaluation syntax tion guards O, and waived guards W . We use waived guards \nto mark an unchecked value as foreign inside a component when the value crosses the component s boundary \nwithout the contract system s protection but with its approval. Un\u00adlike OCPCF, both monitor and option \nguards carry only two labels rather than two sets of labels. However, the star ver\u00adsions of the guards, \n*M and *O allow us to record multiple components that have accepted an option guard. For instance a stack \nof star-option guards with an option guard at the bot\u00adtom in *OCPCF, * Ok1,l1 (... j (c,v))...), corresponds \n* Okn,ln (Oh,q k1...knh,l1...lnq to a single option guard O(c,v) in OCPCF. Stacks j of guards have the \nadvantage of introducing separate bound\u00adaries between components that have accepted an option guard. \nThis allows the guards to accommodate ownership annotations without breaking the single-owner policy. \n\u00af\u00af\u00af El k k k = ... | checkl (Elo ,v) | checkh(El ,v) | tryl (Elo ,v) k\u00af | tryh(El ,v) | exercise(El ) \n| waive(El ) l,k h,k | Mj (c, Elo ) | M(c,El ) | * Ml,k(Elo ) | * Mh,k(El ) j l,k h,k | Oj (c, Elo ) \n| O(c,El ) | * Ol,k(Elo ) | * Oh,k(El ) j | Wl,k(Elo ) | Wh,k(El ) Elo = ... | exercise(Elo ) | waive(Elo \n) Figure 10: *OCPCF: Evaluation contexts The guards, together with the check and try con\u00adstructs, introduce \npoints where ownership changes. Hence, they affect the ownership of the hole of evaluation con\u00adtexts \nchanges. Figure 10 de.nes the evaluation contexts of *OCPCF as an extension of those of CPCF. Before \nwe present the semantics of *OCPCF, we need to add another case to the special contract substitution \nfunction so that it handles option contracts: l\u00af {e/cx}loption(c,|e ' |k)j= l\u00af loption({e/cx}c,{|e|k/x}|e \n' |k)j The reduction semantics for *OCPCF adopts some rules from the semantics of CPCF and adds a few. \nFigures 11, 12 and 13 show the rules that replace or add to those of CPCF. Rules for check and try are \nsimilar to those of OCPCF except that now they come with ownership annotations. When a stack of waived \nguards holds a basic value, the reduction eliminates the guards and delivers the value after removing \nall ownership annotations. After all, basic values are safe for the context to absorb. Applying a function \nwrapped in a stack of waived guards reduces to an application wrapped with the same guards. The argument \nis wrapped with a reversed stack of guards plus ownership annotations. The labels on the guards for the \nar\u00adgument are swapped just as for monitors for function con\u00adtracts. An application of a stack of option \nguards reduces to an application of a homomorphic waived guard. The waived guard marks the function as \na foreign value but does not add any contract-related constraints on its use. Figure 12 displays the \nreduction rules for exercise and waive. They are in spirit the same as the corresponding rules of OCPCF \nwith two differences: they operate on stacks of guards rather than a single guard and waive does not \nrelease the value that resides in a stack of option guards but instead turns the option guards into waived \nones. Other than that, the rules transform guards in a way that is analogous to the rules of OCPCF but \nleave ownership annotations intact. Figure 13 presents the complex rules for manipulating stacks of monitor \nguards. These rules also cover the cases where there is just a single monitor around a value instead \nEl [\u00b7\u00b7\u00b7] . El [\u00b7\u00b7\u00b7] k\u00af check j(||tt|| j,v) . v \u00af k\u00afk check j(||ff|| j,v) . error j k\u00af try j (||tt|| \nj,v) . v \u00af k\u00afk try j (||ff|| j,v) . error j wg . b if wg = Wk1,l1 (...||Wkn,ln (||Wm,p(||b||r)||h)||qn \n...) ||wgv||l ||v||l . ||wg||l if ||wgv||l = ||Wk1,l1 (...||Wkn,ln (||Wm,p(v ' )||h)||qn ...)||q1 where \n||wg||l = ||Wk1,l1 (...||Wkn,ln (||Wm,p(v ' wgv ' )||h)||qn ...)||q1 and wgv ' = W p,m(||Wln,kn (||...Wl1,k1 \n(|||v|l ||q1 )...||qn )||h) ||ogv||l ||v||l . ||wgv||l ||v||l m,p if ||ogv||l = ||* Ok1,l1 (...||* Okn,ln \n(||Or (c,v)||s)||qn ...)||q1 and where ||wgv||l = ||Wk1,l1 (...||Wkn,ln (||Wm,p(v ' )||s)||qn ...)||q1 \nFigure 11: *OCPCF: Annotated semantics (part 1)  El [\u00b7\u00b7\u00b7] El [\u00b7\u00b7\u00b7] exercise(||v||l ) . ||v||l if v . \nOGV exercise(||ogv||l ) . mgv m,p if ||ogv||l = ||* Ok1,l1 (...||* Okn,ln (||Or (c,v)||s)||qn ...)||q1 \nand where m,p ||mgv||l = ||* Mk1,l1 (...||* Mkn,ln (||Mr (c,v)||s)||qn ...)||q1 waive(||v||l ) . ||v||l \nif v . OGV waive(||ogv||l ) . wgv m,p if ||ogv||l = ||* Ok1,l1 (...||* Okn,ln (||Or (c,v)||s)||qn ...)||q1 \nand where ||wgv||l = ||Wk1,l1 (...||Wkn,ln (||Wm,p(v)||s)||qn ...)||q1 Figure 12: *OCPCF: Annotated semantics \n(part 2) of a stack of star-monitors. Thus they subsume the corre\u00adsponding rules of CPCF. If the bottom \nof the stack is a guard for a .at contract on a basic value, the stack reduces to a check where the blame \nlabels are all the labels in server position on the stack of the guards. If the check fails, the contract \nsystem blames all the components that accepted responsibility for that value. If the bottom of the stack \nis a guard for an option contract, the stack reduces to a try where the test term applies the tester \nof the contract to the stack of monitors. To get the correct indy semantics, the rule replaces the client \nlabel of the top of the stack with j. If the test succeeds, try returns an option guard like the original \none but without the option around the contract; else it raises a contract error blaming all the labels \nin server position on the stack of the guards. An application of a stack of monitor guards depends on \nthe value at the bottom of the stack. If it is a stack of option guards, the reduction activates the \noption by turning the op\u00adtion guards into corresponding monitors and then performs the application. If \nnot, the application is similar to that of waived guards. The difference is that the rule also decom\u00adposes \nthe function contract at the bottom of the stack and uses the pre-condition as the contract at the bottom \nof the argument stack and the post-condition as the contract at the bottom of the application stack. \nFurthermore, the stack of guards substituted in the post-condition uses the contract la\u00adbel, namely j, \nas the client label on the top star-guard. The rules for stacks of monitors for transfer contracts are \nlike those of OCPCF. Accepting a stack of option guards ogv results in a star-option stack of guards \naround ogv that uses the same labels as the stack of monitors for the transfer contract. All other value \nare passed through. Before we prove complete monitoring for *OCPCF, we go back to the example e3 of section \n6 and examine how its behavior changes under the semantics of our new model. We omit obligation annotations, \nbecause they do not affect computation, and we focus on well-formed ownership anno\u00adtations and guards. \nIn terms of the syntax of *OCPCF, the example s terms become: s,k1 e1 = |M(c,|deriv|s) f |k1 j1 k1,k3 \ne3 = |exercise(M(transfer, e1)) 0|k3 j2 El [\u00b7\u00b7\u00b7] El [\u00b7\u00b7\u00b7] k1...knm mg . check(e b,b) j if mg = m,p l\u00af \n* Mk1,l1 (...||* Mkn,ln (||M(lflat(e)j,||b||r)||k)||qn ...) j k1...knm mg . try (e mg ' ,og) j if mg \n= m,p l\u00af * Mk1,l1 (...||* Mkn,ln (||M(loption(c,e)j,v)||k)||qn ...) j m,p and where mg ' = * Mk1, j(...||* \nMkn,ln (||M(c,v)||k)||qn ...) j m,p and og = * Ok1,l1 (...||* Okn,ln (||O(c,v)||k)||qn ...) j ||mgv||l \n||v||l . ||mg||l if ||mgv||l = m,p d ||* Mk1,l1 (...||* Mkn,ln (||M(c1 .(.x.c2),v ' )||h)||qn ...)||q1 \nj and where ||mg||l = m,p ||* Mk1,l1 (...||* Mkn,ln (||M({mg '' /cx}c2,v ' mg ' )||h)||qn ...)||q1 j \nl1,k1 and mg ' = * Mp,m(||* Mln,kn (||...M(c1,|||v|l ||q1 )...||qn )||h) j l1,k1 and mg '' = * Mp, j(||* \nMln,kn (||...M(c1,|||v|l ||q1 )...||qn )||h) j mg . Wk1,l1 (...||Wkn,ln (||Wm,p(v)||k)||qn ...) m,p if \nmg = * Mk1,l1 (...||* Mkn,ln (||M(transfer,v)||k)||qn ...) j and v . OGV mg . og ' m,p if mg = * Mk1,l1 \n(...||* Mkn,ln (||M(transfer,ogv)||k)||qn ...) j k1 ' ,l' kn ' ,l' m ,p where ogv = ||* O1 (...||* On \n(||O' ' (c,v)||k' )||qn ' ...)||q1 j' k1 ' ,l' kn ' ,l' ,p ' and og ' = * O1 (...||* On (||* Om ' (ogv)||k)||qn \n...) Figure 13: *OCPCF: Annotated semantics (part 3) The execution of e3 leads to an application of a \nstack of waived guards: k1,k3 s,k1 e3 * |exercise(M(transfer,|O(c2 ' ,| f ' |s)|k1 )) 0|k3 j2 j1 s,k1 \n* |exercise(* Ok1,k3 (|O(c ' 2,| f ' |s)|k1 )) 0|k3 j1 s,k1 * |(|* Mk1,k3 (|M(c ' 2,| f ' |s)|k1 )|k2 \n) 0|k3 j1 k3,k1 As in section 6, e3 reduces to a contract error error . j1 Notice how the ownership annotations \nremain well-formed during evaluation. This is the key insight that we are going to use to prove that \n*OCPCF is well-formed.  A.3 Complete Monitoring for *OCPCF The de.nition of complete monitoring for \n*OCPCF is simi\u00adlar to that for CPCF except that the case for failures of .at contracts is slightly different \nand there is an additional case for failed option contract tests. DE FI N I T I O N 2 (Complete Monitoring \nfor *OCPCF). A re\u00adduction relation y . is a complete monitor for *OCPCF if for all terms e0 such that \n\u00d8;lo l e0, .* e0 yv,  for all e1 such that e0 y.* e1 there exists e1 y. e2,  .* .* e0 ye1 yerror h\u00afj \nand there is at least an e1 such that k,ln+1 e1 = El [* Ml2,l1 (...||* Mln+1,ln (||M j (c,v)||ln+1 )||ln \n...)] \u00af and for all such terms e1, v = |v1|k , h = l2...ln+1k, k . l, \u00af l\u00af l\u00af and c = lflat(e)jor loption(c \n' ,e)j. First, the de.nition requires the absence of stuck states due to any violation of the single-owner \npolicy. Second, the cases for contract failures guarantee that if the contract sys\u00adtem raises a blame \nerror, then the blamed components are all the components that accepted responsibility for the mon\u00aditor \nguards. In addition, the de.nition requires that the .at or option contract at the bottom of the stack \nis amongst the obligations of one of the blamed components, speci.cally of the .rst component that took \nresponsibility for the value. The proof of complete monitoring for *OCPCF follows the proof of Dimoulas \net al. [7]. We develop a subject that generalizes well-formedness and use a progress-and\u00adpreservation \nsubject reduction technique. The additional well-formedness rules cover the terms of the evaluation syn\u00adtax \nof *OCPCF. Especially for stacks of guards they make sure that appropriate ownership annotations are \npresent in between each guard layer. Moreover the rules for moni\u00adtors and stacks of guards use a generalized \nnotion of well\u00adformedness to inspect terms inside the bottom guard of the stack of guards. This extention \nis needed because beta\u00adreduction introduces terms that temporarily deviate from well-formedness [6]. \nThe generalized well-formedness per\u00admits us to handle these temporarily out-of-order terms with\u00adout disturbing \nthe single-ownership and obligations princi\u00adples. Some modi.cations are also necessarry for the rules \nfor well-formed .at and option contracts. Since monitors for transfer monitors dynamically change the \ncomponents that are responsible for meeting a contract, statically deter\u00admined obligations cannot provide \nan accurate prediction of the blamable parties. Nevertheless, obligations can still tell us that the \ninitially responsible component for a contract is amongst the components that get blamed if the contract \nfails. The proof technique and corresponding de.nitions are sim\u00adilar to that of Dimoulas [4, ch. 6] and \nwe ommit them here due to lack of space. With the extended de.nition for well-formedness in hand, we \nprove that de.nes a complete monitor. TH E O R E M 3. is a complete monitor for *OCPCF. A.3.1 Complete \nMonitoring for OCPCF The introduction of *OCPCF is a detour to prove complete monitoring for OCPCF. To \ntransfer the result to OCPCF, we prove a bisimulation theorem between the two lan\u00adguages. Figure 14 speci.es \nthe relation between OCPCF and *OCPCF terms. e~ e ' e~ct x e ' e~ct x e ' e ~ |e ' |l e~ Wk,l (e ' ) \ne ~ct x e ' c~ct x c ' k1...knk,l1...lnl M(c, e) ~ j k,l * Mk1,l1 (...||* Mkn,ln (||Mj (c ' ,e ' )||l \n)||ln ...) e ~ct x e ' c~ct x c ' k1...knk,l1...lnl O(c, e) ~ j k,l * Ok1,l1 (...||* Okn,ln (||Oj (c \n' ,e ' )||l )||ln ...) c~ c ' e~ct x v~ct x c~ c ' e ' v ' l\u00af option(c,e)~ loption(c ' ,e ' )je~ct x \ne ' l\u00af flat(e) ~ lflat(e ' )j Figure 14: OCPCF -*OCPCF bisimulation TH E O R E M 4. Let e a term of OCPCF \nand e* a term of *OCPCF. If \u00d8;lo l e * and e ~ct x e * then * e.* v iff e* v * and v ~ct x v * and, k\u00af* \nk \u00af e.* error j iff e* error j.   \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Many languages support behavioral software contracts so that programmers can describe a component's obligations and promises via logical assertions in its interface. The contract system monitors program execution, checks whether the assertions hold, and, if not, blames the guilty component. Pinning down the violator gets the debugging process started in the right direction. Quality contracts impose a serious run-time cost, however, and programmers therefore compromise in many ways. Some turn off contracts for deployment, but then contracts and code quickly get out of sync during maintenance. Others test contracts randomly or probabilistically. In all cases, programmers have to cope with lack of blame information when the program eventually fails.</p> <p>In response, we propose <i>option contracts</i> as an addition to the contract tool box. Our key insight is that in ordinary contract systems, server components impose their contract on client components, giving them no choice whether to trust the server's promises or check them. With option contracts, server components may choose to tag a contract as an option and clients may choose to exercise the option or accept it, in which case they also shoulder some responsibility. We show that option contracts permit programmers to specify flexible checking policies, that their cost is reasonable, and that they satisfy a complete monitoring theorem.</p>", "authors": [{"name": "Christos Dimoulas", "author_profile_id": "81413601733", "affiliation": "Harvard University, Cambridge, MA, USA", "person_id": "P4290400", "email_address": "chrdimo@seas.harvard.edu", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P4290401", "email_address": "robby@eecs.northwestern.edu", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P4290402", "email_address": "matthias@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509548", "year": "2013", "article_id": "2509548", "conference": "OOPSLA", "title": "Option contracts", "url": "http://dl.acm.org/citation.cfm?id=2509548"}