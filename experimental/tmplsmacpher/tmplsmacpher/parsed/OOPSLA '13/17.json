{"article_publication_date": "10-29-2013", "fulltext": "\n Flexible Access Control for JavaScript  Gregor Richards1 Christian Hammer2 Francesco Zappa Nardelli3 \nSuresh Jagannathan1 Jan Vitek1 1 Purdue University 2 Saarland University 3 INRIA Abstract Providing security \nguarantees for systems built out of un\u00adtrusted components requires the ability to de.ne and enforce access \ncontrol policies over untrusted code. In Web 2.0 ap\u00adplications, JavaScript code from different origins \nis often combined on a single page, leading to well-known vulner\u00adabilities. We present a security infrastructure \nwhich allows users and content providers to specify access control policies over subsets of a JavaScript \nprogram by leveraging the con\u00adcept of delimited histories with revocation. We implement our proposal \nin WebKit and evaluate it with three policies on 50 widely used websites with no changes to their JavaScript \ncode and report performance overheads and violations. Categories and Subject Descriptors D.3.3 [Software]: \nPro\u00adgramming Languages Language Constructs and Features Keywords JavaScript; Access control; Security \n1. Introduction Many popular Web applications mix content from different sources, such as articles coming \nfrom a newspaper, a search bar provided by a search engine, advertisements served by a commercial partner, \nand included third-party libraries to enrich the user experience. The behavior of such a web site depends \non all of its parts working, especially so if it is .\u00adnanced by ads. Yet, not all parts are equally trusted. \nTypi\u00adcally, the main content provider is held to a higher standard than the embedded third-party elements. \nA number of well publicized attacks have shown that ads and third-party com\u00adponents can introduce vulnerabilities \nin the overall applica\u00adtion. Readers of the New York Times online version were subject to a scareware \nattack originating from code provided by a previously trustworthy ad agency.1 Similarly, German 1 www.nytimes.com/2009/09/15/technology/internet/15adco.html, \nwww.h-online.com/security/features/Tracking-down-malware-949079. html. Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. Copyrights for components of this work owned by others than the \nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to \npost on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. Request \npermissions from permissions@acm.org. OOPSLA 13, October 29 31, 2013, Indianapolis, Indiana, USA. Copyright \nis held by the owner/author(s). Publication rights licensed to ACM. ACM 978-1-4503-2374-1/13/10. . . \n$15.00. http://dx.doi.org/10.1145/2509136.2509542 newspapers were attacked by malware from a legitimate \nad\u00advertisement service which delegated some ads to second-tier agencies. Other attacks leverage the extension \nfacilities of some popular web sites. Facebook, for example, encourages third party extensions to be \ndelivered as JavaScript plugins. Taxonomies of these attacks are emerging [19]. Attacks such as cross \nsite scripting, cookie stealing, location hijacking, clickjacking, history snif.ng and behavior tracking \nare be\u00ading catalogued, and the .eld is rich and varied.2 Barth et al. even proposed a name for this threat \nmodel: the Gadget At\u00adtacker [2, 5]. What makes the JavaScript platform challenging is that applications \nthat run in a single client-side browser are com\u00adposed on the .y, their source code is assembled from \ndif\u00adferent sources and run in the same environment with little isolation. Moreover JavaScript is very \ndynamic; text can be turned into code at any time and very few properties can be statically guaranteed \n[30]. Our study of real-world Java-Script behavior demonstrated that this dynamism is widely used [31]. \nWeb browsers offer two lines of defense for end\u00ad users: The .rst is a sandbox that protects the operating \nsys\u00adtem from JavaScript code. The second is known as the same origin policy(SOP); it segregates components \ninto trust do\u00admains based on their origin (a combination of host name, port and protocol) and enforces \naccess control restriction on elements of the web page with a different origin. However, the SOP is not \nuniformly applied to all resources (e.g. im\u00adages may come from different origins, potentially leaking \nin\u00adformation in their URLs), and it is too coarse-grained. While the SOP prevents scripts in one frame \nfrom accessing con\u00adtent in another, many web sites choose not to use frames as this form of isolation \nis highly restrictive, and far from fool\u00adproof [5]. Thus much third-party code is simply included in \nthe body of the web page [26]. The majority of attempts to strengthen the security of Web 2.0 applications \nrely on isolating trusted from un\u00adtrusted code and limiting the dynamism of JavaScript, either through \nstatic analysis techniques which reject programs that do not meet certain static criteria or by de.ning \na subset of the language that is easier to verify [12, 13, 23 25]. These approaches have been adopted \nby the industry as exempli.ed by Facebook JavaScript, Yahoo s AdSafe, or Google Caja. However, these \ntechniques can be circumvented [34] and can 2 www.webappsec.org/projects/threat, www.owasp.org/index.php/Category:Attack. \n miss attacks due to peculiarities and leniencies of different browsers JavaScript parsers, and they \nare so restrictive that many valid legacy programs would be rejected. This paper proposes a novel security \ninfrastructure for dealing with the Gadget Attacker threat model. We extend JavaScript objects with dynamic \nownership annotations and break up a web site s computation at ownership changes, that is to say when \ncode belonging to a different owner is exe\u00adcuted, into delimited histories. Subcomputations performed \non behalf of untrusted code are executed under a special regime in which most operations are recorded \ninto histo\u00adries. Then, at the next ownership change, or at other well de.ned points, these histories \nare made available to user\u00adcon.gurable security policies which can, if the history vio\u00adlates some safety \nrule, issue a revocation request. Revocation undoes all the computational effects of the history, reverting \nthe state of the heap to what it was before the computation. Delimiting histories is crucial for our \ntechnique to scale to real web sites. While JavaScript pages can generate millions of events, histories \nare typically short, and .t well within the computation model underlying Web 2.0 applications: once the \nhistory of actions of an untrusted code fragment is vali\u00addated, the history can be discarded. Histories \nallow policies to reason about the impact of an operation within a scope by giving policies a view on \nthe outcome of a sequence of com\u00adputational steps. Consider storing a secret into an object s .eld. This \ncould be safe if the modi.cation was subsequently overwritten and replaced by the .eld s original value. \nTradi\u00adtional access control policies would reject the .rst write, but policies in our framework can postpone \nthe decision and ob\u00adserve if this is indeed a leak. While policies of interest could stretch all the \nway to dynamic information .ow tracking, we focus on access control in this paper. Targeting Web applications \nmeans that we must deal with the idiosyncrasies of modern web browsers and propose a security model that \ncould be deployed without disrupting the ecosystem. Our main design constraint was thus back\u00adwards compatibility \nwith the web. For this reason our design carefully avoids extending the syntax of JavaScript and does \nnot require changes to code that is already well-behaved. Our proposal can be integrated into a web browser \nwith no modi.cations of the implementation of existing web sites. We leverage the existing SOP policy \nand use it as a build\u00ading block in our infrastructure. Our secondary goal was to demonstrate acceptable \nperformance. While many of the overheads of a proof-of-concept implementation can be op\u00adtimized away, \nmassive slowdown would make adoption un\u00adlikely. We address this by an in-browser implementation and a \ncareful selection of the properties being recorded. This pa\u00adper makes the following contributions: A \nnovel security infrastructure: Access control decisions for untrusted code are based on delimited histories. \nRevo\u00adcation can restore the program to a consistent state. The enforceable security policies are a superset \nof [33] as re\u00ad vocation allows access decisions based on future events.  Support of existing JavaScript \nbrowser security mecha\u00adnisms: All JavaScript objects are owned by a principal. Ownership is integrated \nwith the browser s same origin principle for backwards compatibility with Web 2.0 ap\u00adplications. Code \nowned by an untrusted principal is exe\u00adcuted in a controlled environment, but the code has full access \nto the containing page. This ensures compatibility with existing code.  Browser integration: Our system \nwas implemented in the WebKit library. We instrument all means to create scripts in the browser at runtime, \nso if untrusted code creates another script we add its security principal to the new script as well. \nAdditionally, we treat the eval function as untrusted and always monitor it.  Flexible policies: Our \nsecurity policies allow enforce\u00adment of semantic properties based on the notion of secu\u00adrity principals \nattached to JavaScript objects, rather than mere syntactic properties like method or variable names that \nprevious approaches generally rely on. Policies can be combined, allowing for both provider-speci.ed \nsecu\u00adrity and user-de.ned security.  Empirical Evaluation: We validated our approach on 50 real web \nsites and two representative policies. The results suggest that our model is a good .t for securing web \nad content and third-party extensions, with less than 10% of sites major functionality broken. Our policies \nhave suc\u00adcessfully prevented dangerous operations performed by third-party code. The observed performance \noverheads were between 11% and 106% in the interpreter.  Our work builds on and combines ideas from \nthe literature. History-based access control [1] extends the stack inspec\u00ad tion security model of Java \nto include a history of methods called. Inline reference monitors [33, 37] dynamically en\u00ad force a security \npolicy by monitoring system execution with security automata. We build on their insight and record a \nwider selection of operations. The design of our policy lan\u00adguage is informed by Polymer [6]. While the \nnotion of revo\u00ad cation is inspired by research on transactional memory [16], we avoid the transactional \nmemory terminology because de\u00adlimited histories depart from transactions in that they do not guarantee \nisolation, they do not perform con.ict detection, they do not re-execute aborted histories, do not support \nnest\u00ading of histories, and record different sets of operations. 2. JavaScript and Security JavaScript \nis a prototype-based object-oriented language which is extremely dynamic. Objects can be (and, as shown \nin [31], are) modi.ed in arbitrary ways after their creation. Moreover, text can be turned into executable \ncode by the eval function (which is more frequently used than we would like [30]). A JavaScript object \nis a set of properties, a mu\u00ad table map from strings to values. A property that evaluates to a closure \nand is called using the context of its parent ob\u00adject plays the role of a method in Java. Each object \nhas a prototype, which refers to another object. As a result, it is dif.cult to constrain the behavior \nof any given object, as either it or any of its prototypes could be modi.ed at any time. A JavaScript \nprogram running in a browser executes in an event-driven fashion. The browser .res events in re\u00adsponse \nto end-user interactions such as cursor movements and clicks, timer events, networks replies, and other \npre\u00adde.ned browser happenings. Each event may trigger the ex\u00adecution of a JavaScript function. When the \nfunction returns, the system is able to handle the next event. The timing and order of events depend \non the particular browser, network la\u00adtency, timer accuracy, and other environmental factors. The JavaScript \ncode interacts with the browser, the network, and in a very limited way, persistent storage through native \nop\u00aderations. 2.1 Threat Model Web browsers have standardized on the same origin policy to isolate content \nfrom different providers. Figure 1 illus\u00ad trates the situation where a single web page is built out of \na mixture of trusted and untrusted components kept at bay by the browser s SOP. Web pages are served \nby a provider. Each party has its goals. The host provider s interests are to retain the user s trust \nand to maximize ad revenues. Users want access to the content while restricting, as much as pos\u00adsible, \nthe behavior of ads and other untrusted elements. For the purposes of this paper, we focus on threats \noriginating from third party scripts such as ads and widgets that are em\u00adbedded in an otherwise trusted \npage. While there are plugins that block undesired content, this practice hurts web pages funding, and \nit is also based on syntactic properties (a black\u00adlist of resources not be loaded) instead of a semantic \nsecurity policy. A typical attack is easy to construct. Imagine a host which uses a third-party ad service. \nThe ads are loaded by includ- Figure 1: Web applications are made up of components of multiple origins. \nEnd-users typically trust the main provider, but do not have a relationship with ad providers. The browser \ns same origin policy attempts to isolate the different components of a web page. ing a dynamically-created \nscript into the host page. If the ad service is malicious or has been corrupted then it may do much more \nthan simply display ads. For instance, in this sce\u00adnario there is no built-in security mechanism in the \nbrowser which prevents the script from installing a handler for key\u00adpress events and silently intercepting \nand logging everything the user types, such as login credentials for the host site. Although the same \norigin policy is intended to prevent the script from then communicating this data to an untrusted host, \nthere are ways to work around it, such as encoding the logged data into a source URL for an image tag. \nSec\u00adtion 5 reports on some real-world attacks. For concreteness, consider Figure 2. The host, mysite.com, \nuses a third-party ad-supported login service, happylogins.com, with ads from evilads.com. The login \nservice is loaded in an iframe in hopes of isolating it from the host. mysite.com also stores private \nin\u00adformation of the user, in a variable secret. The ad is able to leak the secret by taking advantage \nof subtle .aws: 1 <script> 2 var secret = \"supersecret\"; 3 document.addEventListener(\"message\", 4 function(e) \n{ 5 var resp = eval(e.data); 6 // handle the response 7 }, false); 8 </script> 9 Please log in: 10 <iframe \nsrc=\"http://happylogins.com/login\"> 11 </iframe> (a) http://mysite.com/ 1 <script src=\"http://evilads.com/ad.js\"> \n2 </script> 3 <script> 4 var okMsg = \"({loginOK: true})\"; 5 function login(u) { 6 if (loginOK(u)) 7 window.parent.postMessage(okMsg, \n\"*\"); 8 } 9 </script> 10 <input type=\"text\" id=\"name\"> 11 <button onclick=\"login(this.value);\"> 12 Log \nIn</button> (b) http://happylogins.com/login 1 window.addEventListener(\"load\", function() { 2 okMsg = \n\"new Image().src = \" + 3 \" http://evilads.com/evil?p= \" + 4 \"+secret;\"; 5 }, false); (c) http://evilads.com/ad.js \n Figure 2: okMsg is a vulnerability; it allows any component loaded on the login service s page to run \ncode on the host page.  The host trusts the login service to provide JSON.  The login service trusts \nthe ad not to corrupt its heap.  The ad is not loaded in a frame, and as such is not subject to the \nSOP.  The host code adds an event listener for message events, which are triggered by the postMessage \ncommand. This is the only means of communication between frames of differ\u00adent origins, and messages can \nonly be strings. In this case, the message is expected to be an object serialized in JSON. A widely used \nmechanism for deserializing JSON is eval, which the host assumes is safe because the message can be veri.ed \nto have originated from the login service s origin. The login function checks whether the login information \nis correct, and sends back a canned message that will set the property loginOK to true. With these two \npieces of code in isolation, the communication is secure. The ad code, how\u00adever, is able to create an \nevent that .res when the frame fully loads, which replaces the canned JSON login OK message with a string \nof JavaScript code which will, when executed, send the secret variable in the host to evilads.com. Although \nthe secret could not be sent via an asynchronous web re\u00adquest, images are allowed to come from any source, \nand so the request is allowed.  2.2 Out-of-scope Threats We do not consider covert channels, as we believe \nthat users would not adopt a technology that would be overly restric\u00adtive. We do not consider .aws in \nthe browser; attacks that trigger buffer over.ows or heap-spraying attacks are not covered by our infrastructure. \nThey are orthogonal to the ideas we are exploring. Attacks based on other browser tech\u00adnologies, the \nbrowser s layout engine, plugins, social engi\u00adneering etc. are not in the scope of this work. We assume \nthat the host page is trustworthy and do not prevent poten\u00adtially malicious behavior stemming from the \nhost, including most forms of cross site scripting. Other research has tar\u00adgeted these issues. 3. Delimited \nHistories with Revocation The security infrastructure we propose applies security poli\u00adcies to portions \nof a program s execution. We start with a high-level description; we will discuss later how this inte\u00adgrates \nin a JavaScript engine. DEFINITION 1. The execution state of web application con\u00adsists of the state of \na JavaScript engine P and an environ\u00adment E. A step of execution is captured by a transition rela\u00ad a \ntion P |E -. P '|E' where a is a label. A label denotes either an action aE initiated by the environ\u00adment \nor an action aP performed by the JavaScript engine. aE EVT n REP v External event of type n Return value \nv from a native call aP APP f v RET v GET v w p v1 SET v p v1 v2 NEW f v INV f v Call function f with \narguments v Return value v from a call Member v.p found in w holds v1 Update v.p from v1 to v2 Create \nan object with constructor f Invoke native operation f The latter set comprises function calls (including \ncalls to eval) and returns, properties reads and writes, object alloca\u00adtion, and calls to native functions. \nThe former set comprises external events (for some set of events ranged by n) and re\u00adturns from calls \nto native functions. DEFINITION 2 (Trace). A trace T = a1 :: \u00b7 \u00b7 \u00b7 :: an corre\u00ad a1an sponds to an execution \nP |E -. . . . -. P '|E'. We write P |E f T, P '|E' when execution of a con.guration P |E yields trace \nT and con.guration P '|E'. Security policies are applied at decision points and suspen\u00adsion points. Decision \npoints represent the end of an un\u00adtrusted subcomputation, suspension points denote calls to native functions \n(e.g. XMLHttpRequest.send). Native func\u00adtions potentially have irreversible side effects: suspension \npoints enable policies to catch these early, preventing infor\u00admation leaks before they become irrevocable. \nPrograms are run with a pair of policies (PS, PD) such that PS is applied at suspension points and PD \nis applied at decision points. Policy decisions are based on the state of the computation P and a subset \nof trace T which we call a delimited history, denoted [ T ] . We represent the outcome of applying a \npolicy as a label aS in the set {OK, REV}. DEFINITION 3 (Policy application). Given a policy P = (PS, \nPD) and a computation P |E f T, P '|E' with a de\u00adlimited history [ T ] , applying the policy can yield \neither the trace P |E f T :: OK, P ' | E' if P(P ', [ T ]]) = OK, or the trace P |E f T :: REV, P | E' \nif P(P ', [ T ]]) = REV. If the policy returns REV, we say that the delimited history [ T ] has been \nrevoked. This has the side effect of reverting the JavaScript state of the computation P ' to its original \nstate P , the state before the call was made. None of the changes to the memory and internal state of \nthe JavaScript program are retained. On the other hand, the environment E' is not rolled back (as there \nis no practical way to undo network traf.c). As mentioned above, a policy may use suspension points to \nprevent external effects from happening at the cost of having to make access control decisions early. \nWe tie the start of a delimited history and the associated decision point to the principal on whose behalf \na script is run. The SOP policy de.nes a notion of principal based on three components of a web page \n the application layer pro\u00adtocol, the domain name, and the TCP port of the URL the .le originated from. \nSince any call to eval may, potentially, take as an argument an untrusted string and be subject to dis\u00adtinguished \npolicies, we extend the de.nition of ownership to include the string passed to eval; for normal code \nexecution this .eld is empty and our ownership coincides with the def\u00adinition of principal of SOP. DEFINITION \n4 (Ownership). Every JavaScript object is as\u00adsociated with an ownership record o, which is a quadruple \n(protocol, domain, port, eval). We call host page the web page obtained from the URL in the location \nbar of the browser. In JavaScript, functions and scopes are objects, thus they are naturally tagged with \nan ownership record. The default ownership record is that of the host page. It would be reasonable to \nstart a delimited history whenever code originating from any page other than the host page is executed. \nOne could simply start recording when the browser encounters a <script> tag from a different origin and \nplace a decision point at the matching end tag. Unfortunately many ads install callbacks (via setTimeout \nor an event handler) or install functions in the global object which can be called by the host page s \ncode. Calls to eval must also be taken into account. This justi.es the following de.nition. DEFINITION \n5 (Recording). For a page with ownership o = (p, d, r, E), recording of a history [ T ] starts at a call \nAPP f v or NEW f v if no recording is in progress and any ' of the following holds: (i) the owner o of \nfunction f is not o, ' (ii) the previous label was a EVT script o ' and o = o, or (iii) ' the function \nf is eval, and o = (p, d, r, v). The history is said to be owned by o ' . A decision point occurs at \nthe matching return unless the history was revoked at a suspension. Every object created during recording \nis tagged with the owner of ' the history, o . A delimited history thus starts at either a script tag, \nthe invocation of function object (either directly or through an event handler), or a call to eval. The \nowner of the function is used to tag all objects created while the history is active. Ownership is invariant \nduring the course of execution, so calling into another function with a different owner does not affect \nthe tag associated by objects that the function creates. The history [ T ] contains the following: last([[T \n]]) is the last label in the trace which, in case of a suspension point, is of the form INV f v. rd([[T \n]]) is the sequence of all prop\u00aderty accesses GET v w p v1 to all locations (v,p). fwr([[T ]]) is the \nsequence of writes SET v p v1 v 2 derived from the .rst write SET v p v1 v2 and last write SET v p v \n1 v 2 to any (v,p) pair. Only the original value and most recently written value are necessary for updates; \nin practice, the last value may simply be read from the live heap and need not be recorded. Observe that \nGET and SET are used for both prop\u00aderty accesses on objects and variable access within scopes. These \nnotions are con.ated in JavaScript: the global scope is also an object, window, there thus is little \ndistinction between the two. As is customary with JavaScript, there are subtleties. When reading a property, \nsuch as x.foo, lookup starts with the object referenced by x, but may potentially traverse the prototype \nchain. In a label GET v w p v1, vis the target of the property lookup, and w is the object where the \nproperty was found. The object NONE is used when the property was not found. For writes SET v p v1 v2, \nJavaScript semantics does not specify prototype traversal3 , i.e. the only object that may change due \nto a SET is v. There are three cases to consider: (a) the property p is found in v and its old value \nv1 is updated to v2, (b) the property did not exist in v, the property will be added to the object (this \ncase is denoted by v1 = NONE), (c) the property was deleted from v by the JavaScript delete operation \n(v2 = NONE). With this information, revocation of a history entails going through fwr to revert properties \nto their original values and, in the process, create and delete properties as appropriate.  Suspension \npoints must also be added to property ac\u00adcesses which may be rerouted to a native getter or setter method. \nFor example, setting the src property of an image tag in the DOM will trigger the download of the image \nat that URL. For pragmatic reasons the implementation main\u00adtains a whitelist of functions that are deemed \nsafe and do not introduce a suspension point. Any other native function is a suspension point. In both \nthe SOP and our delimited history model, each frame is considered an independent entity, and so code \nrun\u00adning within it is owned by the frame s origin, and not the original page s origin. 3.1 Example To \nmake this design more clear, reconsider Figure 2. We will step through this example assuming an empty \npolicy that always yields OK. When mysite.com loads, its script tag (lines 2-7) will be executed. Since \nthe source comes from the same origin as the site itself, no recording of history needs to be started. \nThe owner of the callback function it produces will therefore also have the same owner. The iframe tag \nwill cause happylogins to load, but in an isolated environment protected by the browsers SOP. As such, \nthe host owner for that code is happylogins, not mysite. Its .rst script tag refers to evilads, so history \nrecording starts. The .le ad.js has only one statement, and it will result in a GET window addEventListener \nf1, followed by NEW Function f2, the second argument to addEventListener. Because the function is created \nwhile within a history owned by evilads, its owner will be evilads. Then a APP f1 event is produced with \nthe provided arguments which installs f2 as a callback function. The execution continues with the second \nscript tag on happylogins. As its owner is the host of the iframe, it is not recorded, and the function \nlogin is owned by the happylogins. When happylogins has .nished loading, it will .re a load event. In \nthis case, evilads has registered a load event listener, 3 Setter functions are represented as a GETfollowed \nby an APP.  Figure 3: Data .ow through the web site detailed in Figure 2. f2. Because f2 is owned by \nevilads, its execution will be recorded in a history. Its execution consists of a single event (line \n2), SET window okMsg v v with the previous string v (set by happylogins) and its new string v, containing \na cross\u00adsite scripting attack. When a user clicks the Log In button, the login function set by happylogins \nwill be executed. Since its owner is the host origin of that frame, it will not be recorded. Assuming \nthe login is OK, the message it sends, okMsg, will be the one set by evilads. Until this point, the primary \nhost, mysite, has been idle. Having been sent a message from the login frame, its message handler (lines \n4-7) will be executed, with the message as an argument (in e.data). Because the message handler s owner \nis mysite, it will not be recorded. It will retrieve the attack string that evilads produced, and use \nit as an argument for eval. eval d strings are always recorded. In this case, the code yields the following \nbehavior: NEW Image () SET v1 src unde.ned with the new URL, where v1 is the image produced previously. \n As setting src calls a native function and performs I/O, the execution suspends for policy checking. \n Since an empty policy was applied in this example, the secret will in fact be leaked. This attack could \nhave been stopped in several points, which will be discussed in Section 4. 4. Security Policies We now \nturn to the policies that can be expressed in our infrastructure. Policies are written in C++, the implemen\u00adtation \nlanguage of WebKit. A library of policies is linked dynamically to the instrumented browser at startup. \nUsing C++ gives policy developers the opportunity to write low\u00adlevel code that will have predictable \nperformance. A clear demarcation line between the policy language and JavaScript makes it somewhat easier \nto ensure that policies will not be tempered with. We considered expressing policies in Java-Script but \nwere discouraged by concerns of ef.ciency and the challenges of enforcing isolation. To improve readabil\u00adity, \nwe present policies in idealized pseudo-code. 4.1 Policy API Our infrastructure includes a number of \nsimple data struc\u00adtures used by security policies. Pseudo-code for these can be found in Figure 4. The \nclass Owner encodes the ownership information required by our variant of the SOP. The enu\u00admeration Suggestion \ncontains three values: IGNORE to de\u00adnote cases where a history is irrelevant to a policy, OK if a history \nabides by a policy, and REVOKE for policy viola\u00adtion which should be revoked. The abstract class Op has \nsub\u00adclasses for all operations recorded in a history, these include GetOp, SetOp, CallOp, and DownloadOp \namong others. A de\u00adlimited history is an instance of the History class which holds a suggestion (by default \nIGNORE) and has methods to return the last operation in the history, an array of read operations, an \narray of writes, and method originalValue(op) which, for a Get or Set operation, will return the value \nof the .eld at the start of the history. A security policy is represented at runtime by an instance of \na subclass of Policy created at page load time and re\u00ad 1 class Owner { 2 var port : number, domain : \nstring, 3 protocol : string, evalstr : string; 4 } 5 enum Suggestion { 6 IGNORE, OK, REVOKE 7 } 8 class \nHistory { 9 var suggestion : Suggestion; 10 fun last() : Op; 11 fun reads() : Op[]; 12 fun writes() \n: Op[]; 13 fun ops() : Op[]; 14 fun originalValue(op : Op) : any; 15 } 16 class Policy { 17 var owner \n: string; 18 Policy(args : string[]) {} 19 fun setOwner(o : string) : void {owner=o;} 20 fun querySuspend \n: History (history : History, op : Op) { 21 return queryEnd(history); 22 } 23 fun queryEnd(history : \nHistory) : History { return history;} 24 fun cleanup(history : History) : void {} 25 } Figure 4: Pseudo-code \nfor the Policy APIs. Class Policy must be extended to de.ne security policies. Class History is the delimited \nhistory recorded while executing an untrusted script. claimed when the page is destroyed. Every policy \nhas a ref\u00aderence to the immutable Owner record describing the ori\u00adgin of the code being executed. Policy \nclasses have meth\u00adods: querySuspend() is called at each suspension point and is passed a history and \nthe reason for suspension. It must reply by returning a history with a suggestion. queryEnd() is called \nwhen the end of a history is reached. cleanup() is called with the .nal history and suggestion to request \nthat the policy clean up any state variables it may have used, unless the suggestion was IGNORE. cleanup() \nis merely a simpli.\u00adcation; querySuspend() could clean up whenever it returned REJECT, and queryEnd() \ncould clean up universally. Policies are composed by building policy combinator objects with sub-policies \nembedded within them. We will now proceed with some examples of policies that have been implemented for \nour experiments. 4.1.1 Controlling changes to the Global Object In JavaScript, the global object is a \ndumping ground for vari\u00adables de.ned at the top level and serves as a communica\u00adtion channel between \nscripts. We show a policy that lets un\u00adtrusted scripts extend the global object, but not change ex\u00adisting \nvalues or objects of a different owner. While this does not prevent breaking the host page, it does prevent \nsubvert\u00ading the host s functionality. The ad could install a new func\u00adtion tricking the host into executing \nit. However, the function would be run in a delimited history due to its ownership. The policy in Figure \n5 extends the base policy class by de.ning a queryEnd() method which iterates over the operations in \nthe write set of the history (line 3). For each of the write opera\u00adtions it tests if the owner of the \nobject differs from the owner of the history (line 4). If the write updates an existing prop\u00aderty in \nthe global object (lines 5-6), then the suggestion is set to REVOKE. The querySuspend function is not \ndistinct from queryEnd, as the writes need to be checked in the same way.  4.1.2 Hygienic Policy One \nmight want to adjust the add-only policy above to allow writes as long the original value is restored \nbefore the de\u00adcision point. The policy in Figure 6 checks if all properties of objects that are not owned \nby the history s owner are re\u00adstored to their original values by the end of the history. This 1 class \nAddOnly : Policy { 2 fun queryEnd(history) { 3 foreach op in history.writes() 4 if (di.erentOwner(op) \n&#38;&#38; 5 op.target.isGlobalObject() &#38;&#38; 6 history.originalValue(op) != NONE)) 7 history.suggestion \n= REVOKE; 8 return history; 9 } 10 } Figure 5: Restricting global object property updates. 1 class \nSameValue : Policy { 2 fun querySuspend(history, op) {} 3 fun queryEnd(history) { 4 foreach op in history.writes() \n5 if (di.erentOwner(op) &#38;&#38; 6 op.value() != history.originalValue(op)) 7 history.suggestion = \nREVOKE; 8 return history; 9 } 10 } Figure 6: Ensuring that values of objects belonging to other own\u00aders \nare returned to their original state. 1 class Blocker : Policy { 2 var blacklist; 3 Blocker(args){super(args); \nblacklist=args;} 4 fun queryEnd(history) { 5 if (blacklist.contains(owner)) 6 history.suggestion = REVOKE; \n7 return history; 8 } 9 } Figure 7: Blocking scripts from speci.ed servers. policy is an example that \nsemantically looks into the future to assess whether an event needs to be prevented. 4.1.3 Script blocking \nOne possible use of our infrastructure would be to de.ne a trivial policy that blocks either all scripts \nor those from a selected group. The policy of Figure 7 is created with a user supplied argument that \nlists disallowed sites, any query will check the history s owner against the list. 4.1.4 Send After \nRead Restriction The lifetime of a policy is tied to that of the page, encom\u00adpassing possibly multiple \ninvocations of untrusted opera\u00adtions. The policy can retain some security state across mul\u00adtiple suspension \npoints and across multiple histories. This is needed to prevent leakage of con.dential information via \nHTTP requests. Pseudocode of this policy appears in Fig\u00adure 8. It disallows events which transmit data \nover the In\u00ad ternet after read events have been performed on data owned by another principal. It also \nprevents transmission after en\u00adabling event listeners, as knowing when events .re is a leak of potentially-private \ninformation. The policy maintains some internal security state. The variable pos tracks how much of the \nhistory has already been checked, which is up\u00addated at every query. The default behavior of querySuspend() \nis to call queryEnd(). The pos variable is reset by cleanup(), which is only called if one of the queries \nreturned something other than IGNORE. The hasread variable is a bit of security state that is retained \nacross different histories. This prevents a two stage attack where one script (running with one his\u00ad \n 1 class SendAfterRead : Policy { 2 var hasread = false; 3 var violation = false 4 var pos = 0; 5 fun \nqueryEnd(history) { 6 foreach op in truncate(history.ops(), pos) { 7 if (op.isGetOp()) { 8 hasread |= \ndi.erentOwner(op); 9 } else if (op.isCallOp()) { 10 if (op.isNative() &#38;&#38; 11 op.name.is(\"addEventListener\")) \n12 hasread = true; 13 } else if (op.isDownloadOp()) { 14 violation |= hasread; 15 } 16 } 17 pos = history.ops().length(); \n18 if (violation) history.suggestion=REVOKE; 19 else history.suggestion=OK; 20 return history; 21 } 22 \nfun cleanup(history){violation=false; pos=0;}} Figure 8: Preventing send after read. tory) reads information \nand the second script (running in an\u00adother history) performs a HTTP request leaking that value. By retaining \nstate across histories we can ensure that the pol\u00adicy will remember that some script has read protected \ndata and prevent the send.  4.2 Composing and Selecting Policies Policies can be composed by combinators, \nobjects that in\u00advoke query and cleanup methods of sub-policies. As com\u00adbinators are policies themselves, \nthey have access to his\u00adtories and can, for example, .lter histories to hide some events deemed safe. \nCombinators can also override policies to, for instance, take into account user preferences over site\u00adspeci.ed \npolicies. Figure 9 illustrates a binary combinator which takes the conjunction of two policies. Policies \nare speci.ed by name and created by makePolicy.  4.3 Policy Combinators: White Listing Many sites use \nsecondary servers for storing static content, including JavaScript. For instance, youtube.com s JavaScript \nis hosted on ytimg.com. For these sites, the same origin pol\u00adicy is too stringent, as it would treat \nthe secondary server as untrusted. The Whitelist class is a combinator which modi\u00ad.es the owner of subpolicies \nso as to give the same owner to all scripts coming from secondary servers. Figure 10 shows a simpli.ed \nversion of the whitelist combinator. The setOwner method is overridden to tag an object with the main \nhost\u00adname instead of the name of a secondary server. The list of secondary servers is passed to the constructor \nin the parame\u00adter list. .ndPrimary returns the name of the primary server if the current host is in the \nlist of secondary servers. 1 class Conjunction : Policy { 2 var p1, p2; 3 var s1, s2; 4 Conjunction(name1, \nargs1, name2, args2) { 5 p1=makePolicy(name1,args1); 6 p2=makePolicy(name2,args2); 7 } 8 fun setOwner(o) \n{ 9 p1.setOwner(o); 10 p2.setOwner(o); 11 } 12 fun join(s1,s2) { 13 if (s1 < s2) return s2; 14 else \nreturn s1; 15 } 16 fun queryEnd(history) { 17 h1 = p1.queryEnd(history); 18 s1 = join(s1,h1.suggestion); \n19 h2 = p2.queryEnd(history); 20 s2 = join(s2,h2.suggestion); 21 h2.suggestion = join(s1,s2); 22 return \nh2; 23 } 24 fun cleanup(history){ 25 if (s1 != IGNORE) p1.cleanup(history); 26 if (s2 != IGNORE) p2.cleanup(history); \n27 } 28 } Figure 9: A simple Policy combinator. 1 class Whitelist : Policy { 2 var p, list; 3 Whitelist(name, \nargs, list) { 4 p=makePolicy(name,args); 5 this.list=list;} 6 fun setOwner(o) { 7 var o2=.ndPrimary(o) \n8 super.setOwner(o2); 9 p.setOwner(o2);} 10 fun queryEnd(h) {return p.queryEnd(h);} 11 fun querySuspend(h) \n{ return p.querySuspend(h);} 12 fun cleanup(h){ p.cleanup(h);} 13 } Figure 10: A simple Whitelist combinator. \n 4.4 Breadth of Security Policies A survey of policies found in the research literature appeared in \nthe ConScript paper [25]. We discuss whether these poli\u00ad cies .t into our framework. Their .rst policy \ndisallows all scripts. The related policy that disallows inline scripts (i.e. scripts embedded in attributes \nof html tags) does not .t our SOP-based model, as inline scripts would have the same owner as the host \ncode and thus are not monitored. We could of course change our notion of principal but this would likely \ncause more mismatches with legacy code; we believe these .rst two policies are over-restrictive. Most \nof the policies collected in [25] are syntactic. For example, all policies that restrict access to potentially \nhazardous methods (maybe in\u00advolving some form of black-or whitelisting) can be triv\u00adially implemented \nas a policy in our framework. At suspen\u00adsion points the policy needs to check whether the method to be \ncalled matches a given signature, whether the argu\u00adments have certain properties like a given type, and \nwhether the signature and/or arguments are valid according some black-or whitelist. For methods which \ndo not trigger sus\u00adpension points, blacklisting can be implemented by checking the history at a decision \npoint. A strength of our approach is that while we can handle syntactic properties (modulo dead code), \nwe also can reason about the side-effects that untrusted scripts may induce and their potential for putting \nthe trusted host code s security at risk. Therefore, the poli\u00adcies presented in this section have a different \nquality than those summarized in [25]. As the next section will elabo\u00ad rate, many real attacks can be \nprevented with a handful of simple policies.  4.5 Rectifying Errors Ideally, policies would never incorrectly \nrevoke the behav\u00adior of non-malicious code, but in practice, policies may be overly restrictive, preventing \nvalid code from proceeding. Consider as a possible example ads on a social networking site such as Facebook. \nFacebook stores information on the user, and much of it may be accessible in JavaScript objects. With \nno policy in place, an ad may look into that object, and it may be considered non-malicious for the ad \nto use non\u00adspeci.c information such as the user s postal code and sex, which the ad could then use to \ntarget the user more specif\u00adically. If Facebook added a policy which prevented access to all objects \nwith user information, this ad would cease to function. The ad cannot detect programmatically whether \nsuch a policy is in place, and even if it could, it could not anticipate all possible policies, so it \nis not possible to generally write third-party code to account for such changes in policy. Because our \ntechnique is based on recording histories, it is possible to determine quite speci.cally what the offending \ncode has done wrong when its behavior is revoked4. This could be as easily detected by the ad agency \nas by Face\u00adbook, or indeed any Facebook user. With the speci.c of\u00adfense known, the ad could be modi.ed \nto avoid violating the policy, or the policy could be modi.ed to support the ad. For instance, in the \nexample given, Facebook could modify their policy to disallow all access to user information except for \nsex and postal code, or even more generally to, for in\u00adstance, allow ads to read user information so \nlong as they don t then send any data, or allow ads to read no more than a particular number of sensitive \n.elds. We imagine that the precise changes to be made would be negotiated between the ad agency and the \nsite in question. 4 Being an academic prototype, the current version of the software does not present \nthis information adequately, but it is available. 5. Empirical Evaluation We evaluate our proposed security \ninfrastructure along sev\u00aderal dimensions. Based on an implementation in a produc\u00adtion browser, we start \nby considering real attacks, then we run sample policies on real web sites and lastly we measure performance \nand scalability. 5.1 Implementation We implemented our system in the open source rendering engine WebKit, \nwhich is used in the Safari browser. To that end, we modi.ed 29 .les: 20 in the JavaScriptCore pack\u00adage, \nwhich implements the core JavaScript interpreter and is independent of the actual browser integration, \nand 9 in We\u00adbCore, which accounts for the browser-speci.c JavaScript like the DOM. We added 588 lines \nof code to these 29 .les. Apart from that, new classes added 4697 LOC. The biggest change was in the \nInterpreter class, which we instrumented to intercept all relevant events. In particular, we instrumented \nall opcodes where object properties are accessed (read, store and delete), or objects are created. We \nalso intercept the be\u00adginning and ending of script execution, calls, returns, and abrupt termination \ndue to exceptions. The call stack is the basis for determining the policy s decision points. An event \nis forwarded to a .lter class that decides whether history needs to recorded based on the call stack \nand the owners of involved functions. In case we are recording a delimited history, events are relayed \nto a bookkeeping class that han\u00addles all policy-independent tasks. Newly created objects are tagged with \nthe owner of the current history (whereas the owner of objects created outside a history defaults to \nthe owner of the host page). The owner of the current history and the associated global object are recorded \nfor that pur\u00adpose. Furthermore, the bookkeeping class records operations including the read and write \nsets and maintains a list of poli\u00adcies to be checked. For each call to a function, the bookkeep\u00ading class \ndetermines whether this function has a native im\u00adplementation, and if so, whether that function is contained \nin a whitelist of side-effect free functions. If not, a suspension point is triggered and we iterate \nover all installed polices to query if the call is allowed or needs to be prevented. In the latter case, \na .ag is returned to the interpreter to not call the native function and abort execution of the script. \nFor get\u00adter and setter methods invoked as a result of property access we adopt a different strategy5. \nWhen calling into a setter or getter function results in reaching native code where a side\u00adeffect like \nnetwork access or database storage is about to take place, we generate a synthetic download or storage \nevent and pass that to the .lter before triggering the side-effect. If we are currently in a delimited \nhistory these events are suspen\u00adsion points that will be passed along to the policy, which then decides \nwhether the side-effect is permitted or not. In 5 In WebKit, a native getter or setter may be called \nfor optimization pur\u00adposes, but in the majority of the cases a standard interpreter function is called, \nwhich makes it impossible to distinguish the external code. the latter case the native code will basically \nthrow an excep\u00adtion instead of executing the side-effect that is subsequently caught at the invocation \npoint of the setter or getter. Revocation is a rather tricky business as there are two sep\u00adarate call \nstacks maintained by the interpreter, and both need to be popped to the point where history recording \nstarted. First, the interpreter maintains a stack modeling the Java-Script call stack which needs to \nbe reverted to the level when the history started, before restoring the program counter and resuming \nexecution from there. However, some native calls like eval alter the underlying C++ call stack in addition \nto the JavaScript call stack. Therefore, when a call frame contains WebKit s HostCallFrameFlag, which \nsigni.es the invocation of the interpreter loop function, we need to return from that C++ function and \nresume unrolling of the JavaScript call stack of the interpreter loop of the previous C++ call frame. \nThe unwinding of call stacks does not trigger execution of .nally blocks. Once the system determines \nthat a script is going to ter\u00adminate, be it normally or due to an exception or violation of a security \npolicy, it triggers the decision point check in the bookkeeping class. This iterates over all policies \ncheck\u00ading whether a violation has happened in the recorded his\u00adtory. If a policy signals a violation, \nall writes in the write set are rolled-back according to JavaScript semantics, any thrown exception is \ncaught and the unde.ned value is re\u00adturned. While the completion value will be ignored for his\u00adtories \nstarted by a script tag, eval expressions might use the return value for further computations, which \nmust be pre\u00advented for aborted scripts.  5.2 Attack Vectors 5.2.1 Samy worm The Samy worm6 is a Cross \nSite Scripting/Cross-site request forgery (CSRF) worm developed to propagate through the MySpace social \nnetworking site. While MySpace .ltered the HTML that users add to their sites, the worm exploited holes \nin the .ltering process to inject code into the pro.le of each person that viewed an infected page. The \nmain hole in the .ltering was that some browsers allow JavaScript within CSS tags. MySpace tried to prevent \nthis but failed due the rather lenient JavaScript parsers found in many browsers. For instance, splitting \na keyword (such as javascript) across line boundaries as shown in the following code snippet was enough \nto defeat MySpace s .lters: <div id=mycode style=\"background:url( java script:eval(document.all.mycode.expr) \n)\"...> The injection mechanism relies on eval since both single and double quotes are already taken. \nWriting any meaningful JavaScript code inside the style tag is dif.cult. But it suf.ces to add the text \nof the attack to a property of the div tag, called expr, and access this property in the eval expression. \nThe at\u00ad 6 http://namb.la/popular/tech.html  tack itself consists of reading several pieces of information \nfrom e.g. the document s location and the document itself and using them as parameters to subsequent \nAJAX requests that inject the malicious code into the pro.le of a viewer. The key steps involved: (1) \neval( document.body.inne + rHTML ) to access the content of the website in a way that circumvented the \n.lter mechanism; (2) redirect from pro.le.myspace.com to www.myspace.com, as the SOP would block AJAX \ncalls; (3) html.indexOf( Mytoken ) to access the random hash from a pre-POST page for the subsequent \nAJAX request; and (4) sending an AJAX request. While our approach does not primarily target code injec\u00adtion \nattacks, it can prevent this CSRF attack. We are sand\u00adboxing JavaScript code originating from an eval \nexpression and any other means to dynamically create code. Thus the SendAfterRead policy prevents reading \nprivate data on the page (like Mytoken) and subsequently sending the AJAX re\u00adquest. Blocking the AJAX \nrequest prohibits CSRF attacks as they rely on the requests being sent out with the user s cre\u00addentials. \nWe validated this claim experimentally by embed\u00adding the Samy worm in a test page and running it with \nthe SendAfterRead policy. When running in an uninstrumented Safari browser, the page containing the Samy \nworm sends out all AJAX requests necessary to infect the viewer of the pro.le. With our system, this \nAJAX request is prevented as the script had read the document location. This read is con\u00adsidered private \ndata, so the policy prevents subsequent Inter\u00adnet requests. 5.2.2 Clickjacking A clickjacking attack \nlures the user into clicking on a link of an invisible element. The attacker needs to have access to \nthe current page to create the invisible element, which is usually an iframe, and move that element over \na legitimate link on the page. The attack may have a different origin than the host page, and, as the \nuser authorizes the operation with a click, it will be executed with all the user s credentials. For \nexample, if the user is logged into Facebook, the attacker can add an application to the user s Facebook \naccount. The click will send any authorization data (e.g. a cookie) along with the request. Even worse, \nwhen automatic password .ll\u00adin is turned on in the browser, the user might be tricked into logging in, \nand a subsequent click will execute the malicious operation without the user even noticing an attack \nhas occurred. Our approach does not prevent mouse clicks on a link, but as the attack requires addition \nof an event handler, that script will be monitored. Consider the following as an example: function updatebox(evt) \n{ var mouseX=evt.clientX; var mouseY=evt.clientY; var f = document.getElementById( open ); f.style.left=mouseX-10; \nf.style.top=mouseY-25; }  If third-party code wanted to inject a clickjacking attack into a host, a \npolicy that prevents updates to objects from a different owner, such as the SameValue policy would prevent \nthis attack, as the callback function will have the third-party owner, such that the updates performed \nto f.style are revoked by the policy.  5.2.3 History Snif.ng It took more than 10 years7 until an attack \nknown as history snif.ng was addressed by browser manufacturers. History snif.ng infers the browser s \nhistory through the style of links (visited links are displayed in a different color). While newer browsers \nare immune to the basic form of history snif.ng (including the CSS-only variant), this attack is being \nused in practice [19] and it has been shown that it can be abused very effectively, detecting as many \nas 30,000 links per second [18]. The SendAfterRead policy would prevent most snif.ng attacks. We will \nreturn to this with an in depth example in Section 5.3 5.2.4 Key-logging If third party scripts run \nunmonitored they may even install key-or mouse-loggers threatening user security. For exam\u00adple, a keylogger \nmight attempt to intercept login credentials or other sensitive data provided to the host page. Figure \n11 shows an example keylogger that sends out the log period\u00adically via its reportLog function. The SendAfterRead \npolicy prevents these kinds of attacks, as installing an event han\u00addler is considered by the policy to \nbe another reason to reject send events. This is because knowing when events .re is a leak of potentially-private \ninformation. 1 window.addEventListener(\"keypress\", 2 function(event) { 3 log.push(event.which); 4 if \n(log.length >= 1024) reportLog(log);}, 5 false); Figure 11: Attack by keylogger in untrusted code.  \n 5.2.5 Storage Recently, a new attack against user privacy has been pro\u00adposed based on replicating user \ntracking data in a set of stor\u00adage mechanisms other than traditional cookies. In particu\u00adlar, HTML5 proposes \nthree more storage containers apart from cookies: Session and local storage and database stor\u00adage. Session \nstorage is accessible to any page from the same site opened in that window, while local storage spans \nmul\u00adtiple windows and lasts beyond the current session. Both of these mechanisms provide a key/value \nstorage interface to JavaScript. Even more powerful is the database storage mechanism that provides an \nSQL interface persisting mul\u00adtiple sessions. All these storage mechanisms represent side\u00ad 7 https://bugzilla.mozilla.org/show_bug.cgi?id=57351 \n effects that potentially threaten security, as data stored in one session can be accessed and e.g. \nsent out over the Internet at a later time, which would invalidate policies like NoRe\u00adadSend. An extension \nof the SendAfterRead policy in Fig\u00adure 8 where StorageEvents trigger a violation after reading (in analogy \nto DownloadEvents) prevents third-party code from changing storage of the host page, as well as reading \nthat storage and sending out information later on.  5.3 Case Study: Snif.es We present a real attack \nfound on zaycev.net, a .le and news sharing site in Russia (#1390 on the Alexa list). The host page loads \nadvertisements from a third-party ad server, but included along with the ads is a history-snif.ng attack \nwhich determines how many of a list of sites the user has visited in the past. It works by setting CSS \nstyles for visited links, then checking if they are active on links that the attacker is interested in. \nThe code reads data it should not have access to (the style of links) and sends the information to a \nforeign web server. Figure 12 is a reduced version of the attack seen on the site. 1 function ucv(c, \nd) { 2 var a = document.createElement(\"a\"); 3 a.href = c; d.appendChild(d); 4 return (a.style.color == \n\"#.0000\"); 5 } 6 var d = document.createElement(\"div\"), seen = []; 7 addStyle(d, \"a:visited { color: \n#.0000 }\"); 8 if (ucv(\"qwe.ru\", d)) seen.push(\"qwe.ru\"); 9 //... same for other servers 10 seen = seen.join(\",\"); \n11 // send seen to the ad server Figure 12: Excerpt of a history-snif.ng attack Although the SendAfterReadpolicy \ncould prevent a history\u00adsnif.ng attack, we devised an extension to the add-only pol\u00adicy which furthermore \nrestricts what the foreign ad is al\u00adlowed to read, and what functions it is allowed to call. The functions \nit is allowed to call are those which add to the page, instead of reading data from the page (e.g. the \ndata that must be read to sniff history), which is consistent with the add-only policy. The ad is allowed \nto read from the global state and even from the DOM, but not from the CSS style or from text nodes in \nthe DOM. For certain targets it is only allowed to call certain functions: for document: write, getElementById, \ncreateElement, getElementsByTagName; for window: setTimeout, parseInt, open, encodeURIComponent, escape; \nfor other DOM elements: setAttribute, appendChild; all functions are ok for Date; none for all other \ntargets. These functions are suf.\u00adcient for a conventionally-written ad script to add its adver\u00adtisement \nto the page, and in fact the history-snif.ng ad in question conforms to this policy if the history-snif.ng \nat\u00adtack itself is removed. Because none of these functions read information from a page, only adding \ninformation, they are 1 class Sni.es : Policy { 2 fun queryEnd(history) { 3 foreach op in history.writes() \n4 if (di.erentOwner(op) &#38;&#38; 5 (!op.target.isGlobalObject() || 6 history.originalValue(op) != NONE))) \n7 history.suggestion = REVOKE; 8 foreach op in history.reads() 9 if (di.erentOwner(op) &#38;&#38; 10 \n(!op.target.isGlobalObject()) &#38;&#38; 11 (!op.target.isHTMLDOMObject())) 12 history.suggestion = REVOKE; \n13 foreach op in history.calls() 14 if (di.erentOwner(op) &#38;&#38; 15 (!isWhitelistedFunction(op.target, \nop.func))) 16 history.suggestion = REVOKE; 17 return history;}} Figure 13: Restricting reads and calls. \n a reasonably privacy-preserving subset of the DOM API. Using document.write is .ne in our system as \nscripts that are thus created will be monitored by the security policy, as well. Further restrictions, \nlike allowing access to a DOM node only if that was intended by the host [22] are possible. This is important \nfor targeted ads that are allowed to process public parts of the page but not the sensitive information. \n 5.4 Real-Site Behavior We applied security policies to unmodi.ed web sites to eval\u00aduate how restrictive \nthe policies are for legacy code, code that was not speci.cally designed to abide by a particular policy. \nFigure 14 shows the results of applying three poli\u00ad cies to the top 50 web sites (as displayed on alexa.com \non 20-Mar-2013). We report the count of untrusted scripts ex\u00adecuted, and thus the number of histories \ncreated by our in\u00adfrastructure and of decision points where policies are eval\u00aduated. The number ranges \nbetween 0 and 417. One web\u00adsite, wikipedia, did not load any untrusted code. In detail, we recorded how \nmany times the same behavior occurred (Count), the owner of the page or iframe (Host Origin), the owner \nthe code (Script Origin), the reason why a history is being recorded (Cause) which can be one of eval, \nsource, and function with different owner, the number of suspension points (Suspend), the total number \nof revocations (Revoke), the size of the read and write set in the history (R/W). For space reason we \ndo not list the entire ownership informa\u00adtion but rather part of the URL. Note that for a given site \nthe host for frames may differ from that site s URL and that host would still be a trusted host, as frames \nare protected by the SOP in the browser. It is striking to observe the size of the scripts. None are \nsmall, ranging from 192KB to 2.8MB of JavaScript code executed during our short runs. On average, 84 \ndelimited histories were recorded per site, but that number and the behavior of the actual histories \nvaries considerably between these sites. Inspection of the code revealed that Google does not load any \nthird-party code, but twenty-one eval statements were executed. None was suspended or revoked. Manual \ninspec\u00adtion suggests that Google uses eval to deserialize JSON ob\u00adjects. Facebook uses some alternate \ndomains to store static content, which we had to whitelist. While it ran no third\u00adparty code, delimited \nhistories were created due to eval, one of which was revoked. Most of this code do not explicitly read \nor write properties; three of the evals create and de.ne objects via JSON and pass them back to the host. \nSince none of the objects owned by the host are changed in that process, all of these are allowed, as \nwell. Youtube needs whitelisting of a static content domain s.ytimg.com. With that in place, the page \nlooks and feels like the original even though some advertisement services and third-party functionality \nare re\u00adjected. For example, we found that a script from 2mdn.net tries to install a global function isValid, \nhowever a function with that name had already been de.ned by the host code in the global scope. Therefore, \nallowing the untrusted code to install the function may put the functionality of the host in jeopardy; \nin the worst case a malicious script may subvert the security of the host code. Our policy rejects that \nscript and reverts its side-effects. Yahoo structures its services into several subdomains and maintains \na number of hosts for static content, which we whitelisted. We found frames dis\u00adplaying ads from different \nhosts. Some scripts were revoked due to updates to a .eld owned by the host. In a realistic set\u00adting \nthe frame content provider would specify the hosts to be whitelisted so that their scripts would work \nas expected. Ya\u00adhoo also loads scripts from Facebook. These scripts change the href property of a link \nnot owned by the third-party script, which means that its side-effect are revoked at the next sus\u00adpension \npoint. We categorized subjectively the behavior of the site with security enabled and report on the results \nin Figure 15. We .rst applied, as a sanity check, the Empty policy which Policy Empty SendAfterRead AddOnly \nFunctional 50 22 12 No auto-complete 0 8 15 Ads blocked 0 7 8 Partial 0 9 10 Broken 0 4 5 Figure 15: \nCategorization of 50 benchmarks. Functional: The site worked in its entirety. No auto-complete: Form \nauto-completion functionality was broken, but otherwise the site was fully func\u00adtional. This is a common \nfailure case due to how auto-completion is frequently implemented. Ads blocked: The site worked, but \nits ads did not. Although acceptable to clients, this is not acceptable to servers, since ads are a revenue \nsource. Partial: The important or vital features of the site worked, but minor or secondary features \nother than auto-completion or ads did not work. Broken: The site is mostly nonfunctional. Count Suspend \nR/W Host / Script Origin Cause Revoke google (16 .les, 272KB) 1 google / google s 0 0 2/0 21 google / \ngoogle e 1 0 5172/572 1 google / ssl.gstatic s 7 0 2745/293 11 google / clients1.google s 1 0 14476/1708 \n55 google / clients1.google f 0 0 14928/1477 1 google / clients1.google f 1 0 8/2 2 google / ssl.gstatic \ns 1 0 2/0 facebook (48 .les, 2.8MB) 33 facebook / facebook e 1 0 15101/1778 30 facebook / facebook f \n0 0 11858/1336 2 facebook / facebook s 0 0 10/2 2 facebook / facebook s 1 1 20/4 youtube (16 .les, 1.1MB) \n5 youtube / youtube e 1 0 22/4 17 ad-g.doubleclick / youtube s 0 0 7574/945 1 ad-g.doubleclick / youtube \ns 15 0 0/0 1 ad-g.doubleclick / youtube s 2 0 0/0 1 ad-g.doubleclick / youtube s 1 1 2745/293 1 ad-g.doubleclick \n/ youtube s 3 1 10/2 1 ad-g.doubleclick / s0.2mdn s 17 0 10/2 1 ad-g.doubleclick / youtube s 4 1 10/2 \n1 ad-g.doubleclick / s0.2mdn s 19 0 10/2 3 ad-g.doubleclick / s0.2mdn s 0 0 2352/262 4 youtube / s0.2mdn \ns 3 0 38/8 1 youtube / s0.2mdn s 18 0 10/2 2 youtube / s0.2mdn s 2 0 2326/260 1 youtube / s0.2mdn s 4 \n0 10/2 7 youtube / s0.2mdn s 0 0 2418/271 6 youtube / s0.2mdn s 1 0 2354/268 1 youtube / s0.2mdn s 5 \n1 2313/258 qq (44 .les, 1.1MB) 4 qq / qq s 0 0 26/6 1 qq / pingjs.qq s 0 0 0/0 1 qq / pingjs.qq f 4 1 \n0/0 1 qq / adsrich.qq s 8 0 0/0 1 qq / mat1.gtimg s 2 0 0/0 2 qq / mat1.gtimg f 1 1 2745/293 3 qq / mat1.gtimg \nf 0 0 2818/408 1 qq / mat1.gtimg f 5 1 0/0 1 qq / adsrich.qq s 1 1 10/2 27 qq / s 0 0 9561/1079 1 qq \n/ s 2 0 2331/259 3 qq / adsrich.qq s 0 0 30/6 1 qq / s 1 1 10/2 1 qq / qq s 1 1 2313/258 1 qq / qq s \n0 0 10/2 1 soso / soso.qstatic s 0 0 10/2 1 soso / soso s 0 0 10/2 1 soso / adsrich.qq s 0 0 2308/258 \nyahoo (23 .les, 928KB) 2 yahoo / yahoo s 1 1 2/0 1 yahoo / ucs.query.yahoo s 0 0 0/0 1 yahoo / sugg.us.search.yahoo \ns 2 1 0/0 Count Suspend R/W Host / Script Origin Cause Revoke wikipedia (14 .les, 800KB) live (24 .les, \n1.6MB) 1 login.live / login.live s 2 1 2/0 baidu (19 .les, 192KB) 2 baidu / s1.bdstatic s 1 1 2/0 2 baidu \n/ s1.bdstatic s 0 1 0/0 7 baidu / baidu e 1 0 5563/701 2 baidu / s1.bdstatic s 0 0 20/4 amazon (34 .les, \n616KB) 1 amazon / ad.doubleclick s 1 1 2/0 7 amazon / amazon s 1 0 4965/511 1 amazon / amazon e 1 0 0/0 \n3 amazon / ad.doubleclick s 0 0 20/7 52 s3l3lkinz3f56t.cloudfront / amazon s 0 0 17949/2265 5 s3l3lkinz3f56t.cloudfront \n/ amazon s 1 1 38/8 132 s3l3lkinz3f56t.cloudfront / amazon s 1 0 64837/7210 1 s3l3lkinz3f56t.cloudfront \n/ amazon s 5 1 10/2 9 s3l3lkinz3f56t.cloudfront / amazon s 3 0 2388/274 1 s3l3lkinz3f56t.cloudfront / \namazon s 17 0 8/2 7 s3l3lkinz3f56t.cloudfront / amazon s 2 0 2281/261 7 s3l3lkinz3f56t.cloudfront / amazon \ns 3 1 575/261 1 amazon / amazon f 1 0 0/1 1 amazon / amazon f 0 0 0/1 1 amazon / amazon f 6 0 0/1 1 amazon \n/ amazon f 20 0 3/2 1 amazon / amazon f 5 0 841/74 1 amazon / amazon f 10 1 29/1 59 view.atdmt / amazon \ns 0 0 9820/7661 1 view.atdmt / b.voice.ve s 4 1 179/25 5 view.atdmt / amazon s 1 1 0/472 2 view.atdmt \n/ amazon s 3 0 3054/298 93 view.atdmt / amazon s 1 0 21661/6189 5 view.atdmt / amazon s 2 0 745/324 3 \nview.atdmt / amazon s 3 1 0/9 1 view.atdmt / amazon s 0 0 3/2 1 view.atdmt / amazon s 7 0 20/0 13 view.atdmt \n/ amazon s 6 0 7375/2184 2 view.atdmt / b.voice.ve s 0 0 487/95 taobao (48 .les, 804KB) 1 taobao / a.tbcdn.cn \ns 2 0 2/0 12 taobao / a.tbcdn.cn f 2 1 7954/972 1 taobao / z.alimama s 1 0 0/0 1 taobao / a.tbcdn.cn \nf 2 0 0/0 4 taobao / a.tbcdn.cn f 0 0 10/2 4 taobao / a.tbcdn.cn s 2 1 2348/264 80 taobao / a.tbcdn.cn \ns 0 0 32609/3524 4 taobao / p.tanx s 0 0 4677/520 4 taobao / p.tanx s 1 1 40/8 1 taobao / s 1 1 8/2 1 \ntaobao / taobao s 2 1 0/0 24 s.taobao / a.tbcdn.cn s 0 0 7193/817 3 s.taobao / a.tbcdn.cn f 0 0 2352/262 \n1 s.taobao / a.tbcdn.cn s 1 1 10/2 1 s.taobao / a.tbcdn.cn s 2 1 10/2 Figure 14: Dynamic characteristics \nof untrusted code for each of the top 10 site. places no constraints on the code. Not surprisingly, \nno degra\u00addation of behavior could be observed. In our tests, we ob\u00adserved one very common failure case, \nthe elimination of auto-completion features from form .elds. In most cases, this was due to auto-completion \nbeing loaded either through eval or from a separate domain, and either whitelisting or a more .nessed \npolicy could have retained that behavior. For the remainder of this description, we consider that particu\u00adlar \nfailure case as inconsequential. The SendAfterRead pol\u00adicy performed admirably, with 60% of web pages \nfully func\u00adtional or with only auto-completion failing, and 14% of web pages functioning but with ads \nblocked, terminating the ex\u00adecution of the ad without affecting the site. In 18% of the pages the site \nbroadly worked with minor features missing. The AddOnly policy is slightly more restrictive. Only 54% \nof sites were fully functional or only had auto-completion failures, with 20% having other missing features \nand 16% have some ads blocked. This shows that even with generic policies and unmodi.ed code, our infrastructure \nis able to provide an acceptable user experience in 70% of the top 50 sites. In a realistic deployment \none can expect customized policies and modi.cation in the JavaScript code to yield sig\u00adni.cantly smaller \nfalse positive rates. For all runs we used a policy combinator to add the Whitelist policy to treat sec\u00adondary \nservers as trusted. Figure 16 is a poster child for global namespace pollu\u00ad tion: it uses a variable \ni as a counter, but since the code ex\u00adecutes in global scope, the variable is global. We reject the script \nas variable i was already de.ned by the host code. 1 var links = document.getElementsByTagName( a ); \n2 for (var i = 0; i < links.length; i++) { 3 links[i].onclick = function() { 4 if (document.images) { \n5 var href = unescape(this.href).split( /article.aspx? ); 6 var pic =new Image(1, 1); 7 pic.src = http://www.af.com/Af.PartnerSite/ \n8 + Tracker.aspx?event=ararequest&#38;purl= 9 + this.href + &#38; + href[href.length-1]; 10 } }; } Figure \n16: ARAtracker.js at .ickr.com.  5.5 Performance To evaluate overheads, we arranged for our browser \nto load three web sites and to .re a deterministic sequence of events on each of these. We measured the \nexecution time, both with and without our instrumentation. The sites were cached in a proxy to avoid \ninconsistency between runs. Our system is currently limited to WebKit s interpreter, so the JIT was not \nused. Five runs of each site for each mode were performed. The measurements were performed with the empty \npolicy, as it has all of the instrumentation overhead needed to record policies but is semantically identical \nto running uninstru\u00admented. The machine had a 3GHz six-core AMD Phenom 1075T processor and 16GB 667MHz \nDDR3 RAM. Our in\u00adstrumentation is based on WebKit revision 92569, and the same revision was used for \nthe uninstrumented runs. The three measured sites span the spectrum of history usage: MSNBC (www.msnbc.msn.com) \nruns nearly all of its code through eval, and so 98.41% of the traceable events were run in a history, \nYouTube (www.youtube.com) substantially less so (only 0.62%), and Google Maps (maps.google.com) has no \nhistories at all. Figure 17 shows the results. MSNBC which is a worst case scenario with most of the \nexecution being recorded, has an overhead slightly of 115%. The execution records 17 histories accounting \nfor 424 suspensions, 117,328 read events and 22,924 write events. In most sites we expect the amount \nof controlled code to be much less than the amount of host code as Figure 14 suggests. YouTube and GMaps \nare more typical with 13% to 15% overheads. Our YouTube benchmark ran 22 transactions accounting for \n28 suspensions, 705 read events and 773 write events, and our Google Maps benchmark ran 48 transactions \naccounting for 3 suspensions, 33 read events and 122 write events. Instrumented Uninstrumented Over- \nSite Avg. Std. dev. Avg. Std. dev. head MSNBC 275.8 7.29 128.2 3.77 115.1% YouTube 155.2 1.30 137.8 1.64 \n12.6% GMaps 224.2 4.32 195.4 1.14 14.7% Figure 17: Runtimes (ms) with and without instrumentation.  \n Although the interpreter overhead running the empty pol\u00adicy is suf.cient to gauge the overheads of our \nsystem, in Figure 18 we additionally provide measurements using the JIT (with no instrumentation, as \nwe have not implemented instrumentation on the JIT) and with our two standard poli\u00adcies, AddOnly and \nSendAfterRead. Due to an early revo\u00adcation on MSNBC in both policies, the runtime is actually considerably \nless with the realistic policies than the empty one; on the other sites, the runtime is not greatly affected \nby the choice of policy. JIT AddOnly SendAfterRead Site Avg. Std. dev. Avg. Std. dev. Avg. Std. dev. \nMSNBC 27.0 4.24 47.4 0.55 50.0 1.22 YouTube 15.6 0.54 156.4 1.14 154.8 0.84 GMaps 35.2 1.30 199.4 3.65 \n215.4 1.67 Figure 18: Runtimes (ms) with JIT, AddOnly, SendAfterRead.  6. Related Work Improving the \nsecurity of JavaScript programs on modern web browsers has attracted much interest. Many problems come \nfrom the pervasive sharing of data and code in Java-Script. While a browser could be viewed as an operating \nsystem for web applications, unlike a traditional OS it is quite common to execute components with little \nor no iso\u00adlation. This leads to, amongst others, Confused Deputy at\u00adtacks [4], where a trusted program \nunknowingly exercises its authority to perform an action on the behest of an adversary. Many authors \nhave proposed to draw stronger boundaries between components [12, 17, 29]. Library-based approaches tried \nto limit the interface between components [10]. Intru\u00ad sion detection techniques were proposed to detecting \nmis\u00adbehavior [14, 15, 35]. Considerable effort was invested in restricting the behavior of JavaScript \nprograms. The highly dynamic nature of the language steered research towards a combination of .ltering \nand rewriting [23]. Static analy\u00ad sis can .lter programs before execution, while rewriting is used to \ninline reference monitors [25, 27, 28, 36]. Browser-Shield [28] underlines the dif.culty of detecting \nmalicious scripts. Differences between JavaScript parsers led to false positives or missed attacks. Carefully \ncrafted subsets of JavaScript [23, 24] allow the separation of programs into statically veri.able components \nand others that must be checked at run-time. This was re.ned into the staged in\u00adformation .ow veri.er \nof [8] which reduced the false posi\u00ad tive rate down to 33%. De.ning two subsets of JavaScript, a trivially \nstatically analyzable one and a run-time checked subset, reduced the false positive rate to 22% [13]. \nAs de\u00ad tecting malicious scripts remains tricky, some authors have advocated extending browsers. Security \npolicies can, for in\u00adstance, by embedded in web pages [20] with a 15% slow\u00ad down for a native implementation, \nand 10x slowdowns for a purely JavaScript implementation. However, it was shown that neither white-or \nblacklisting approaches are impervious to attacks [3]. Off-loading the execution of untrusted code to \nanother JavaScript engine is another alternative to impose isolation. This has been show to have 69% \noverhead [22] with the drawback of preventing many of valid interactions present in legacy code. Dhawan \net al. [11] look at the use of Software Transc\u00ad tional Memory for similar purposes as our delimited histo\u00adries. \nIn [11], the authors offered an implementation in the Mozilla Firefox JavaScript engine. While the two \nproposals share the idea of using histories for access control decisions, we will argue for our proposal. \nDhawan s work does not ex\u00adtend objects with ownership, and thus it can not leverage changes of ownership \nto determine decision points. Instead a new keyword is added to the language and web applica\u00adtion programers \nmust change their code to add transaction boundaries. Security, in their approach, crucially depends \non programmers adding transactions at all points where un\u00adtrusted code can run. This is done by encapsulating \nuntrusted code in transaction {...}, the ellipsis stands for the code to run transactionally. Then the \nuser must write code to run and check the results of the transaction. This means that to adopt the approach \non legacy websites would require refactoring them. Also, their approach may capture trusted code in a \ntransaction which would lead to a policy being applied to code that actually is allowed to perform sensitive \noperations. Their approach also requires con.ict detection for the heap. Performance overhead of their \napproach is between 1.6x and 6.5x on tiny applications and up to 26x on microbenchmarks. No results are \nreported on real web sites. This makes the systems hard to compare, and since both proposal are im\u00adplemented \nin JavaScript interpreters (and not JITs), perhaps comparing performance is premature. Dhawan s work \nsup\u00adport transactions on DOM objects, in our work we view these as external operations. The advantage \nof being able to undo DOM operation is that security policies need not worry about suspension points \nat DOM operations. Other uses of similar ideas include: Birgisson et al. [7] base enforcement of authorization \npolicies in concurrent programs on ideas from transaction memory to eliminate race conditions related \nto security checks. Rudys and Wal\u00adlach [32] proposed transactional rollback as a way to im\u00ad plement safe \ntermination of misbehaving codelets in Java. Speculative execution [21] takes a similar approach (specu\u00ad \nlation and rollback) but is built on top of a binary rewriting tool and reports slowdowns of up to 3000\u00d7. \nDe Groef et al. propose FlowFox, a version of Firefox that enforce security based on information .ow \ncontrol [9]. Their approach is based on secure multi-execution: the idea that the program is executed \nonce for each security level with values that do not belong to that security level stubbed out. We considered \ndynamic information .ow tracking but even\u00adtually discarded the idea because of the fundamental limi\u00adtations \nof information .ow tracking. Basically, information .ow tries to detect causal dependencies between actions \nexe\u00adcuted at different security levels. Consider the following ex\u00adample of two instructions in a sequence: \n1 H.foo.bar = 1; // secret 2 L.fum = 1; // public The .rst line assigns 1 to .eld of a secret variable, \nthe second line stores 1 in the .eld of a public variable. One would expect that there is no information \nleak in this trivial program. Yet, if H.foo is unde.ned then an exception will be thrown and the second \nline will not be executed. A sound information .ow policy would have to reject this program. Information \n.ow control is still a research topic and it is possible that better solutions will be found. Our policies \nare closely related to inline reference mon\u00aditors (IRMs) [33, 37]. IRMs oversee system execution with \nsecurity automata. IRMs typically apply a security policy P before the execution of each event and terminate \nthe program if the policy is violated. Decisions cannot depend on future events. In contrast, revocation \nlets us base access control de\u00adcisions on events that are yet to happen: having seen only a pre.x T of \nthe execution, whose last event a might vio\u00adlate security, we do not need to decide at that point whether \nthe pre.x T is benign or malign. Instead, we speculatively execute to the next decision point. Only then \ndo we need to check the policy, and revocation ensures that no side-effects of a are visible if a policy \nviolation is detected. Decision and suspension points give well de.ned point in the computation where \naccess control decision are made. 7. Conclusions This paper presented a security mechanism for monitoring \nuntrusted code in JavaScript based on delimited histories with revocation. When security policies can \nre.ect upon se\u00adquences of operations performed by a computation, it is pos\u00adsible to support semantic \nproperties rather than the more limited syntactic checks of traditional rewriting or wrapping approaches. \nMost prominently, it is possible to write poli\u00adcies to detect side-effects that jeopardize con.dentiality \nor integrity, like sending out private data to untrusted servers or updating sensitive data structures. \nBy extending the same origin policy and tagging objects as well as code with own\u00aders we obtain a robust \nnotion of principal which can leverage to add our new security mechanism in a non-intrusive man\u00adner. \nWhenever control is transferred across an ownership boundary, security policies are activated. For that \nreason, trust boundaries become implicit and we can apply policies to unmodi.ed JavaScript code and have \nsigni.cant success with legacy code. Our evaluation in the WebKit JavaScript engine demonstrates its \neffectiveness in preventing realistic attack vectors like internet worms, as well as applicability and \nscalability to realistic web sites exempli.ed by the 50 most popular pages. We see promising direction \nfor future work. Performance can be improved by integrating the monitoring mechanism with a trace-based \njust-in-time compiler and specializing the code generated to the policy. A better treatment of eval will \ngreatly reduce the size of histories, especially in the case of pathological web sites that run entirely \nin eval. A second strand of work will investigate a mixture of static and dynamic checking to target \ninformation .ow policies. In particular, we are interested in seeing if we can get a handle of quantitative \n.ows by re.ecting on histories. Lastly, we intend to investigate high-level declarative languages for \nspecifying polices to allow for policy-carrying web pages. Acknowledgments This work was supported by \nin part by Google Research Award HAJS: High-Assurance JavaScript , by NSF Grant CT-ER: Controlled Declassi.cation \nwith Software Transac\u00adtional Memory and by the German Ministry for Education and Research (BMBF) through \nfunding for the Center for IT-Security, Privacy and Accountability (CISPA). References [1] M. Abadi and \nC. Fournet. Access control based on execution history. In Network and Distributed System Security Symp. \n(NDSS), 2003. [2] D. Akhawe, A. Barth, P. E. Lam, J. Mitchell, and D. Song. Towards a formal foundation \nof web security. In Computer Security Foundations Symposium (CSF), 2010. [3] E. Athanasopoulos, V. Pappas, \nand E. P. Markatos. Code\u00adinjection attacks in browsers supporting policies. In W2SP 2009: WEB 2.0 Security \nand Privacy, 2009. [4] A. Barth, C. Jackson, and W. Li. Attacks on javascript mashup communication. In \nW2SP 2009: WEB 2.0 Security and Pri\u00advacy, 2009. [5] A. Barth, C. Jackson, and J. C. Mitchell. Securing \nframe communication in browsers. Commun. ACM, 52(6), 2009. [6] L. Bauer, J. Ligatti, and D. Walker. Composing \nexpressive runtime security policies. ACM Trans. Softw. Eng. Methodol., 18:9:1 9:43, 2009. [7] A. Birgisson, \nM. Dhawan, U. Erlingsson, V. Ganapathy, and L. Iftode. Enforcing authorization policies using transactional \nmemory introspection. In Conference on Computer and com\u00admunications security (CCS), 2008. [8] R. Chugh, \nJ. A. Meister, R. Jhala, and S. Lerner. Staged infor\u00admation .ow for JavaScript. In Conference on Programming \nlanguage design and implementation (PLDI), 2009. [9] W. De Groef, D. Devriese, N. Nikiforakis, and F. \nPiessens. FlowFox: a web browser with .exible and precise information .ow control. In Computer and Communications \nSecurity (CCS), 2012. [10] F. De Keukelaere, S. Bhola, M. Steiner, S. Chari, and S. Yoshi\u00adhama. Smash: \nsecure component model for cross-domain mashups on unmodi.ed browsers. In Conference on World Wide Web \n(WWW), 2008. [11] M. Dhawan, C.-c. Shan, and V. Ganapathy. Enhancing JavaScript with transactions. In \nECOOP-Object-Oriented Programming, 2012. [12] A. Felt, P. Hooimeijer, D. Evans, and W. Weimer. Talking \nto strangers without taking their candy: isolating proxied con\u00adtent. In Workshop on Social Network Systems \n(SocialNets), 2008. [13] S. Guarnieri and B. Livshits. Gatekeeper: Mostly static en\u00adforcement of security \nand reliability policies for JavaScript code. In USENIX Security Symposium, 2009. [14] A. Guha, S. Krishnamurthi, \nand T. Jim. Using static analysis for Ajax intrusion detection. In Conference on World wide web (WWW), \n2009. [15] O. Hallaraker and G. Vigna. Detecting malicious JavaScript Code in Mozilla. In Conference \non Engineering of Complex Computer Systems (ICECCS), 2005. [16] M. Herlihy and J. E. B. Moss. Transactional \nmemory: archi\u00adtectural support for lock-free data structures. In International Symposium on Computer \narchitecture (ISCA), 1993. [17] J. Howell, C. Jackson, H. J. Wang, and X. Fan. MashupOS: operating system \nabstractions for client mashups. In Work\u00adshop on Hot topics in Operating Systems (HOTOS), 2007. [18] \nA. Janc and L. Olejnik. Feasibility and real-world implica\u00adtions of web browser history detection. In \nProceedings of the 2010 Workshop on Web 2.0 Security and Privacy, 2010. [19] D. Jang, R. Jhala, S. Lerner, \nand H. Shacham. An empiri\u00adcal study of privacy-violating information .ows in JavaScript web applications. \nIn Conference on Computer and communi\u00adcations security (CSS, 2010. [20] T. Jim, N. Swamy, and M. Hicks. \nDefeating script injection attacks with browser-enforced embedded policies. In Interna\u00adtional conference \non World Wide Web (WWW), 2007. [21] M. E. Locasto, A. Stavrou, G. F. Cretu, and A. D. Keromytis. From \nSTEM to SEAD: Speculative execution for automated defense. In USENIX Annual Technical Conference, 2007. \n[22] M. T. Louw, K. T. Ganesh, and V. Venkatakrishnan. AdJail: Practical enforcement of con.dentiality \nand integrity policies on web advertisements. In USENIX Security Symposium, 2010. [23] S. Maffeis, J. \nMitchell, and A. Taly. Isolating JavaScript with .lters, rewriting, and wrappers. In Computer Security \n(ESORICS), 2009. [24] S. Maffeis and A. Taly. Language-based isolation of untrusted JavaScript. In Symposium \non Computer Security Foundations (CSF), 2009. [25] L. A. Meyerovich and B. Livshits. ConScript: specifying \nand enforcing .ne-grained security policies for JavaScript in the browser. In Symposium on Security and \nPrivacy (S&#38;P), 2010. [26] N. Nikiforakis, L. Invernizzi, A. Kapravelos, S. Van Acker, W. Joosen, \nC. Kruegel, F. Piessens, and G. Vigna. You are what you include: Large-scale evaluation of remote JavaScript \ninclusions. In Computer and Communications Security (CCS), 2012. [27] P. H. Phung, D. Sands, and A. Chudnov. \nLightweight self\u00adprotecting JavaScript. In International Symposium on Infor\u00admation, Computer, and Communications \nSecurity (ASIACCS), 2009. [28] C. Reis, J. Dunagan, H. J. Wang, O. Dubrovsky, and S. Es\u00admeir. Browsershield: \nVulnerability-driven .ltering of dynamic HTML. ACM Trans. Web, 1(3):11, 2007. [29] C. Reis and S. D. \nGribble. Isolating web programs in modern browser architectures. In European Conference on Computer Systems \n(EUROSYS), 2009. [30] G. Richards, C. Hammer, B. Burg, and J. Vitek. The eval that men do a large-scale \nstudy of the use of eval in JavaScript applications. In ECOOP Object-oriented Pro\u00adgramming, 2011. [31] \nG. Richards, S. Lebresne, B. Burg, and J. Vitek. An analysis of the dynamic behavior of JavaScript programs. \nIn Confer\u00adence on Programming Language Design and Implementation (PLDI), 2010. [32] A. Rudys and D. S. \nWallach. Transactional rollback for language-based systems. In Conference on Dependable Sys\u00adtems and \nNetworks (DSN), 2002. [33] F. B. Schneider. Enforceable security policies. ACM Trans. Inf. Syst. Secur., \n3:30 50, February 2000. [34] A. Taly, \u00da. Erlingsson, J. C. Mitchell, M. S. Miller, and J. Na\u00adgra. Automated \nAnalysis of Security-Critical JavaScript APIs. In Symposium on Security and Privacy (S&#38;P), 2011. \n [35] K. Vikram, A. Prateek, and B. Livshits. Ripley: automatically securing web 2.0 applications through \nreplicated execution. In Conference on Computer and Communications Security (CCS), 2009. [36] D. Yu, \nA. Chander, N. Islam, and I. Serikov. JavaScript instru\u00admentation for browser security. In Symposium \non Principles of programming languages (POPL), 2007. [37] \u00dalfar Erlingsson. The Inlined Reference Monitor \nApproach to Security Policy Enforcement. PhD thesis, Cornell University, 2004. A. Availability The prototype \nimplementation described in this paper has been reviewed by the OOPSLA Artifact Evaluation Com\u00admittee \nand found to meet expectations . The software is re\u00adleased in open source and is available at: http://dumbo.cs.purdue.edu/webkit-ifc-5f893ccea10c. \ntar.bz2 B. Implementation of SendAfterRead We report below the complete C++ implementation of the SendAfterRead \npolicy; the correspondence between the pseudo-code of Figure 8 and the actual implementation is obvious. \nWe point out that while the pseudo-code relies on the standard implementation of querySuspend which in\u00adcludes \na call to queryEnd, the C++ implementation provides optimized code for querySuspend, which does not traverse \nthe whole delimited history but only checks the last event. It is also worth observing that reads to \ncertain classes, in this case, HTMLDocument, Navigator and Location, are not considered as potentially \nharmful: Checking for members of document and navigator is a common technique to de\u00adtermine what features \nthe browser or its JavaScript engine offers, and reading the current web page s URL is generally considered \nacceptable for analytics or targeting purposes. Note that these checks are shallow, so, for example, \nallow\u00ading reads to document does not allow arbitrary reads within document.body or other sensitive portions \nof the DOM. 1 /* 2 * SendAfterReadPolicy.cpp 3 */ 4 #include \"con.g.h\" 5 #include \"SendAfterReadPolicy.h\" \n6 #include \"Threading.h\" 7 #include \"InstrEvent.h\" 8 #include \"AccessSet.h\" 9 #include \"EventGenerator.h\" \n 10 #include \"JSObject.h\" 11 #include \"JSFunction.h\" 12 13 namespace JSC { 14 SendAfterReadPolicy::SendAfterReadPolicy() \n{ 15 hasread = false; 16 } 17 18 SendAfterReadPolicy::~SendAfterReadPolicy() {} 19  20 bool SendAfterReadPolicy::queryEnd(History&#38; \nhistory) { 21 if (history.ops().isEmpty()) return false; 22 Vector<Event*>::const_iterator end = history.ops().end(); \n23 history.addSuggestion(OK); 24 bool violation = false; 25 ExecState* exec = history.execState(); 26 \nfor (Vector<Event*>::const_iterator it = history.ops().begin(); 27 it != end; ++it) { 28 Event* ev = \n*it; 29 if (ev->type() == Event::Read) { 30 violation |= readEvent(static_cast<ReadEvent*>(ev)); 31 } \nelse if (ev->type() == Event::Call) { 32 violation |= callEvent(static_cast<CallEvent*>(ev), exec); 33 \n} else if (ev->type() == Event::Download) { 34 violation |= downloadEvent(static_cast<DownloadEvent*>(ev)); \n35 } 36 } 37 if (!violation) return false; 38 history.addSuggestion(REVOKE); // violation 39 return true; \n40 } 41 42 bool SendAfterReadPolicy::querySuspend(Event *ev, History&#38; history) { 43 history.addSuggestion(OK); \n44 bool violation = queryEnd(history); 45 if (ev->type() == Event::Read) { 46 violation |= readEvent(static_cast<ReadEvent*>(ev)); \n47 } else if (ev->type() == Event::Call) { 48 violation |= callEvent(static_cast<CallEvent*>(ev), 49 \nhistory.execState()); 50 } else if (ev->type() == Event::Download) { 51 violation |= downloadEvent(static_cast<DownloadEvent*>(ev)); \n52 } 53 if (!violation) return false; 54 history.addSuggestion(REVOKE); // violation 55 return true; \n56 } 57 58 bool SendAfterReadPolicy::readEvent(ReadEvent* event) { 59 if (!event->getObject().isCell()) \nreturn false; 60 Owner owner = event->getObject().asCell()->getOwner(); 61 bool read = false; 62 if (owner \n== Owner()) { 63 if (event->getObject().isObject()) { 64 JSObject* obj = asObject(event->getObject()); \n65 read = obj->className() == \"HTMLDocument\" || 66 obj->className() == \"Location\" || 67 obj->className() \n== \"Navigator\"; 68 } 69 } else { 70 read = m_owner != owner; 71 } 72 if (read) hasread = true; //got \n.eld of a di.erent owner 73 return false; 74 } 75 76 bool SendAfterReadPolicy::callEvent(CallEvent* event, \nExecState* exec) { 77 if (! event->isNative()) return false; 78 InternalFunction *i. = asInternalFunction(event->getFunction()); \n79 if (i.->name(exec) == \"addEventListener\") 80 hasread = true; // callback has access to DOM object \n81 return false; 82 } 83 84 bool SendAfterReadPolicy::downloadEvent(DownloadEvent* event) { 85 UNUSED_PARAM(event); \n86 return hasread; 87 } 88 }    \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Providing security guarantees for systems built out of untrusted components requires the ability to define and enforce access control policies over untrusted code. In Web 2.0 applications, JavaScript code from different origins is often combined on a single page, leading to well-known vulnerabilities. We present a security infrastructure which allows users and content providers to specify access control policies over subsets of a JavaScript program by leveraging the concept of delimited histories with revocation. We implement our proposal in WebKit and evaluate it with three policies on 50 widely used websites with no changes to their JavaScript code and report performance overheads and violations.</p>", "authors": [{"name": "Gregor Richards", "author_profile_id": "81438595000", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P4290363", "email_address": "gr@purdue.edu", "orcid_id": ""}, {"name": "Christian Hammer", "author_profile_id": "81339502918", "affiliation": "Saarland University, Saarbr&#252;cken, Germany", "person_id": "P4290364", "email_address": "hammer@cs.uni-saarland.de", "orcid_id": ""}, {"name": "Francesco Zappa Nardelli", "author_profile_id": "81453660213", "affiliation": "INRIA, Paris, France", "person_id": "P4290365", "email_address": "Francesco.Zappa_Nardelli@inria.fr", "orcid_id": ""}, {"name": "Suresh Jagannathan", "author_profile_id": "81100208907", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P4290366", "email_address": "suresh@cs.purdue.edu", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P4290367", "email_address": "jv@cs.purdue.edu", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509542", "year": "2013", "article_id": "2509542", "conference": "OOPSLA", "title": "Flexible access control for javascript", "url": "http://dl.acm.org/citation.cfm?id=2509542"}