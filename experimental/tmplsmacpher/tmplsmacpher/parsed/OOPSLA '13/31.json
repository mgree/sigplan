{"article_publication_date": "10-29-2013", "fulltext": "\n Fully Concurrent Garbage Collection of Actors on Many-Core Machines Sylvan Clebsch and Sophia Drossopoulou \nDepartment of Computing, Imperial College, London {sc5511, scd}@doc.ic.ac.uk Abstract Disposal of dead \nactors in actor-model languages is as im\u00adportant as disposal of unreachable objects in object-oriented \nlanguages. In current practice, programmers are required to either manually terminate actors, or they \nhave to rely on garbage collection systems that monitor actor mutation through write barriers, thread \ncoordination through locks etc. These techniques, however, prevent the collector from being fully concurrent. \nWe developed a protocol that allows garbage collection to run fully concurrently with all actors. The \nmain challenges in concurrent garbage collection is the detection of cycles of sleeping actors in the \nactors graph, in the presence of con\u00adcurrent mutation of this graph. Our protocol is solely built on \nmessage passing: it uses deferred direct reference count\u00ading, a dedicated actor for the detection of \n(cyclic) garbage, and a con.rmation protocol (to deal with the mutation of the actor graph). We present \nour ideas informally through an example, and then present a formal model, prove soundness and argue completeness. \nWe have implemented the protocol as part of a runtime library. As a preliminary performance evaluation, \nwe discuss the performance of our approach as currently used at a .nancial institution, and use four \nbenchmarks from the literature to compare our approach with other actor\u00admodel systems. These preliminary \nresults indicate that the overhead of our approach is small. Categories and Subject Descriptors D.3.2 \n[Programming Languages]: Language Classi.cations -concurrent, distrib\u00aduted, and parallel languages; D.3.4 \n[Programming Lan- Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. Copyrights \nfor components of this work owned by others than the author(s) must be honored. Abstracting with credit \nis permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. Request permissions from permissions@acm.org. OOPSLA 13, October \n29 31, 2013, Indianapolis, Indiana, USA. Copyright is held by the owner/author(s). Publication rights \nlicensed to ACM. ACM 978-1-4503-2374-1/13/10. . . $15.00. http://dx.doi.org/10.1145/2509136.2509557 \nguages]: Processors -Memory management (garbage col\u00ad lection). Keywords actors; message passing; concurrency; \nmany\u00adcore; garbage collection 1. Introduction The actor-model uses actors as the unit of computation. \nAct\u00adors encapsulate messaging, memory, and a thread of execu\u00adtion into a single entity, providing a powerful \nmodel for con\u00adcurrent computation [1, 2]. Actor-model languages must know when an actor has terminated \nin order to free resources dedicated to the actor. Most existing actor-model languages and libraries \ndo not at\u00adtempt to solve this problem, instead requiring the program\u00admer to explicitly manage every actor \ns lifetime [3 7]. The languages that do garbage collect actors require hardware features that adversely \nimpact performance, such as cache coherency, expensive software techniques that may require hardware \nsupport, such as mutation monitoring through write barriers, and use approaches that are not based on \nthe message passing paradigm at the heart of the actor-model [14, 15]. The very problems that actor-model \nprogramming excels at addressing (including concurrency, scalability, and simplicity) have made actor \ngarbage collection problematic, due to the dif.culty of observing the global state of a pro\u00adgram. As \na result, actor-model systems in applications which create many short-lived actors become either more \ndif.cult to program (when they require manually terminating actors) or encounter performance problems \n(when they have actor garbage collection that is not fully concurrent). A language which does not provide \ngarbage collection of actors will require a facility to explicitly terminate actors. This will also require \nthe language to provide a default behaviour when a message is sent to a terminated actor, the ability \nto distinguish at runtime between terminated and non\u00adterminated actors, and possibly noti.cation mechanisms \nfor actor termination. In this paper, we present a technique for garbage collec\u00adtion of actors, which \nwe call Message-based Actor Collec\u00adtion (MAC), that satis.es the following goals: 1. Soundness: the \ntechnique collects only dead actors. 2. Completeness: the technique collects all dead actors eventually. \n 3. Concurrency: the technique does not require a stop\u00adthe-world step, thread coordination, actor introspection, \nshared memory, read/write barriers or cache coherency.  When an actor has completed local execution \nand has no pending messages on its queue, it is blocked. An actor is dead if it is blocked and all actors \nthat have a reference to it are blocked, transitively. Collection of dead actors depends on being able \nto collect closed cycles of blocked actors. Our approach is inspired by previous work on distributed \ngarbage collection of passive objects using distributed refer\u00adence counting and a secondary mechanism \nto collect cyclic garbage [22 25]. Detection of cycles of objects is based on their topology, which is \nessentially the number of incoming references and the identities of all outgoing references. We adopt \nthis approach so that the topology of an actor con\u00adsists of the number of incoming references from actors, \nthe set of outgoing references to actors, and a .ag indicating whether the actor is blocked. A dedicated \nactor, called the cycle detector, keeps track of the actor topology and detects any cycles. The challenge \nwe face is that the true topology of an actor is a concept distributed across all of the actors: it changes \nnot only when the actor mutates, but also when other actors mutate. An actor s view of its topology may \nbe out of sync with the true topology, and the cycle detector s view of an actor s topology may be out \nof sync with the actor s view of its topology. This differs radically from previous work on distributed \nobject cycle detection, where objects must either be immutable or cycle detection must monitor mutation \n[26 28]. Our technique uses the message passing paradigm at the heart of the actor-model: when an actor \nblocks, it sends a snapshot of its view of its topology to the cycle detector. The cycle detector in \nturn detects cycles based on its view of the topology of blocked actors. Because the cycle detector operates \non its own view of the blocked actor topology rather than stopping execution or monitoring mutation, \ncycles may be detected based on a view of the topology that is out of date. This is overcome with a con.rmation \nprotocol that allows the cycle detector to determine whether or not its view of the blocked actor topology \nis the same as the true topology, without stopping execution, monitoring mutation, or examining any actor \ns heap. Contributions The key contribution of this paper is a sys\u00adtem for ef.cient concurrent garbage \ncollection of actors. More speci.cally, we present: An informal explanation of Message-based Actor Collec\u00adtion \n(MAC).  A formal model of garbage collection with MAC ex\u00adpressed through an operational semantics. \n A proof of soundness for MAC.  Preliminary performance results which indicate MAC has a small overhead \nover manual collection -if any.  Garbage collection systems are often presented without soundness proofs \n[8, 9, 16, 18, 26 28]. Where proofs are provided, they often do not address cyclic garbage [24] or mutation \n[22, 23], or require synchronous collection [10]. We developed suitable abstractions to be able to make \nour soundness proof. These abstractions also helped us develop a simpler presentation of protocol based \non the consistency of the perceived topologies. Outline We discuss the background on garbage collection \nof actors in section 3. We present the design of our sys\u00adtem informally in section 4, formalise it in \nsection 5, and provide a proof of soundness in section 6. We report on our implementation in section \n7, and conclude and discuss fur\u00adther work in section 8. 2. Motivation Even though actors are extensively \nused in the distributed setting, they can address massively concurrent program\u00adming, a major challenge \ncurrently, attracting a signi.cant amount of research. Moreover, actors are often used without distribution. \nFor example, in [11] the software from repos\u00aditory [12] is studied. From around 750 programs, 16 are \nisolated as representative of \"real-world actor programs\". Of these, only 7 are distributed applications. \nOf these 7, only 3 use remote actors for distributed computation. Within the concurrent setting, our \nwork is best applicable to the style of concurrency where a multitude of lightweight actors are continuously \ncreated and discarded, rather than where actors are a few large entities that logically persist during \nprogram execution (e.g. vats). Applications of the latter style have less need for actor GC. Applications \nof the former style of concurrency are encountered in, for example, trading applications, social simulations, \nand network traf.c analysis, and motivate the need to reclaim actors. Our system is currently in use \nin such an application (cf. section 7). Moreover, such a style of concurrency will be supported by the \nmany cores forecast in hardware development [13]. 3. Background on Garbage Collection of Actors Actor \nCollection Existing actor-model languages and lib\u00adraries use three approaches to garbage collection of \nactors. The .rst approach is to require the programmer to manu\u00adally terminate actors. Many existing actor-model \nlanguages and libraries, such as Erlang [3], Scala [4], AmbientTalk [5], SALSA 2.0 [6], Kilim [7], and \nAkka, do not garbage col\u00adlect actors at all. All of these except Kilim support actors on distributed \nnodes, although only SALSA supports manual migration of actors to new nodes. None support distributed \nscheduling or automatic migration. The second approach is to transform the actor graph into an object \ngraph and use a tracing garbage collector to collect actors [8 10], as done in ActorFoundry [14]. This \nrequires shared memory, cache coherency, and a stop-the-world step. This approach allows actors to be \ncollected using the same collector used for passive objects, but cannot be used across distributed nodes. \nThe third approach, used in SALSA 1.0 [15], uses ref\u00aderence listing (whereby an actor keeps a complete \nlist of every other actor that references it) and monitoring of actor mutation to build conservative \nlocal snapshots which are as\u00adsembled into a global snapshot. This requires write barriers for actor mutation \n(which requires shared memory and cache coherency), a global synchronisation agent, and coordina\u00adtion \nof local snapshots within an overlapping time range. These snapshots are used with the pseudo-root algorithm, \nwhich additionally requires acknowledgement messages for all asynchronous messages, inverse reference \nlisting, and a multiple-message protocol for reference passing [16 18]. Like SALSA 2.0, SALSA 1.0 supports \ndistributed nodes and manual actor migration. None of these approaches provides a fully concurrent method \nfor garbage collection of actors. Distributed Passive Object Collection The literature on distributed \npassive object collection is vast, and so we will only brie.y mention key differences. Our approach has \nbeen inspired not just by previous work in actor collection, but also by work in concurrent cycle detection \n[23] and dis\u00adtributed reference counting [22, 24 28] for passive object collection. Some of these approaches \ndo not address cyclic garbage [24, 25]. Others require either immutable passive objects or a synchronisation \nmechanism between the cycle detector and the mutator, which makes them inapplicable to actor collection \n[22, 23, 26 28]. MAC differs signi.cantly from previous work. Unlike distributed passive object collection, \nno restrictions on actor mutation or monitoring of mutation are required in order to detect cyclic garbage, \nand no reference listing, indirection cells, or diffusion trees (a technique whereby nodes keep a trail \nof object references they have passed, which can lead to zombie nodes) are required. Unlike the pseudo-root \nap\u00adproach, acknowledgement messages are only required when actors are actually collected, no reference \nlisting is required, no message round-trips are required, and no snapshot integ\u00adration or time ranges \nare required. As a result, MAC requires signi.cantly less overhead. Because MAC does not require thread \ncoordination or cache coherency, it does not become less ef.cient as core count increases. Some approaches \nto distributed passive object collection are fault-tolerant [21]. In order to make distributed garbage \ncollection fault-tolerant, it is necessary to detect and handle failure and often also to track a global \nview of time. Our work is targeted at the many-core environment rather than the distributed environment \nand relies on guaranteed mes\u00adsage delivery, which obviates the need for failure detection. In addition, \nour reliance on causal messaging (cf. section 4) obviates the need for a global view of time. 4. Message-based \nActor Collection In this section we explain Message-based Actor Collection (MAC) informally. We introduce \nour additions on top of the actor-model, including causal messaging, external sets for tracking potentially \nreachable actors, and the reference count invariant and the protocol for maintaining it. We also intro\u00adduce \nour cycle detector, including perceived cycles for de\u00adtecting possible cycles, and the conf-ack protocol \nfor con\u00ad.rming perceived cycles. The operational semantics of MAC are formalised in section 5, and a \nproof of soundness is provided in section 6. Actors The actor-model stipulates that an actor can [1, \n2]: 1. Send a .nite number of asynchronous, buffered messages to other actors, with guaranteed delivery \nbut no ordering or fairness guarantees. 2. Select a behaviour to be executed in response to the next \nmessage. 3. Create a .nite number of new actors.  We additionally require that an actor s message queue \nis FIFO ordered, and message delivery is causal (de.ned be\u00adlow). Moreover, each actor has a local heap. \nIn this paper, we are only concerned with actor references, but in general the heap would also contain \npassive objects, and an actor would have a stack while performing local execution. Application Messages \nWe model application-level mes\u00adsages as a single message type (APP) that allows an actor .1 to send a \nset of actors .s to another actor .2. In general, there would be multiple application message types, \nwhich could contain passive objects as well as actors. Topology The true topology of the system is the \ndirected graph of actor reachability. Because actors execute concur\u00adrently, it is not possible to ef.ciently \ntrack the true topology. Instead, each actor maintains a view of its own topology, consisting of a reference \ncount (indicating the number of in\u00adcoming graph edges) and an external set of potentially reach\u00adable \nactors (the outgoing edges). The actor s view can disagree with the true topology. When an actor .1 sends \na reference to itself to another actor .2, it can immediately update its reference count, maintain\u00ading \nagreement with the true topology. However, if .2 drops its reference to .1, .2 cannot directly mutate \n.1 s reference count. Now .1 s reference count is out of sync. To correct this, .2 sends a reference \ncount decrement message (DEC) to .1. When .1 processes that message, it updates its view to restore agreement \nwith the true topology. Similarly, if .2 sends a reference to .1 to a third actor .3, it .rst sends \na reference count increment message (INC) to .1. This INC represents the reference to .1 held by the \nmessage. These INC and DEC messages allow the actor s view of its topology to be eventually consistent \nwith the true topology. Deferred Reference Counting The external set is an over\u00adapproximation of the \nset of actor references contained in some actor s heap. It differs from the heap in order to allow reference \ncounting to be lazy. Rather than tracking all ref\u00aderences from .1 to .2, a single reference exists if \n.2 appears one or more times in .1 s heap. The external set contains all actors that have been in the \nactor s heap or received in a message since the last local garbage collection cycle. When an actor performs \nlocal garbage collection, the external set is compacted so as to contain only the actors remaining in \nthe heap. Actors removed from the external set when it is compacted represent dropped references, and \nare sent DEC. Similarly, when an actor .1 receives another actor .2 in a message, .1 adds .2 to its external \nset. If .2 is not present in .1 s external set, the reference held by the message is transferred to .1 \nand .2 s view of its topology remains in agreement with the true topology. If .2 is already present in \n.1 s external set, .1 already has an outgoing edge to .2. To maintain the reference count invariant of \n.2, .1 sends DEC to .2, which allows .2 to eventually update its view of its own topology. Our approach \nis based on, but differs from, deferred in\u00adcrements [19], where ephemeral reference count updates can \nbe skipped, and update coalescing, where redundant ref\u00aderence count updates are combined for ef.ciency \n[20]. In our work, reference counts are not updated when references are created or destroyed on the stack \nor in the heap, but only when references are sent in messages and when local garbage collection indicates \nno references to an actor remain in a heap. The messages act as the mechanism for deferring increments \nand the external set in combination with local garbage collection acts as the mechanism for coalescing \nup\u00addates. Cycle Detection As in any reference counting system, cyc\u00adlic garbage cannot be collected by \nreference counting alone. Our system uses a cycle detector that has a message queue like an actor, and \ncan both send and receive messages. When an actor has no pending messages on its queue, it is blocked. \nWhen an actor blocks, it sends a block message (BLK) to the cycle detector containing the actor s view \nof its topology, i.e. its reference count and its external set. When a blocked actor processes a message, \nit becomes unblocked and sends an unblock message (UNB) to the cycle detector, informing the cycle detector \nthat its view of that actor s topology is invalid and that actor is no longer blocked. This allows the \ncycle detector to maintain a view of the topology of all blocked actors that is eventually consistent \nwith each actor s view of its topology, which is in turn eventually consistent with the true topology. \n It would be possible but not ef.cient for application actors to perform cycle detection when no messages \nare pending on their queue (i.e. just before blocking): this would require every actor in the system \nto maintain a view of every other actor s topology, which for n actors would require n messages upon \neach block and unblock and duplication of blocked actor topology in every actor. A separate cycle de\u00adtector \nreduces this to one message upon block or unblock regardless of the number of actors. Dead Actors An \nactor is dead if it is blocked and all actors that have a reference to it are blocked, transitively. \nBecause messaging is required to be causal (de.ned below), a blocked actor with a reference count of \nzero is unreachable by any other actor and is therefore dead (acyclic garbage). For cyclic garbage, the \ncycle detector uses a standard cycle detection algorithm to .nd isolated cycles in its view of the topology \nof blocked actors. However, the cycle detector s view of the topology may disagree with an actor s view \nof its topology (when a BLK or UNB message is on the cycle detector s queue but as yet unprocessed), \nand the actor s view of its topology may in turn disagree with the true topology (when an INC or DEC \nmessage is on the actor s queue but as yet unprocessed). If cyclic garbage is detected on the basis of \na view of the topology that disagrees with the true topology, that cycle must not be collected. We call \na cycle that has been detected a perceived cycle and a cycle that has been detected using a view of the \ntopology that agrees with the true topology a true cycle. Example 1. A perceived cycle that is not a \ntrue cycle. This is shown in .gure 1. 1. Given three actors (.1, .2 and .3), .1 and .2 reference each \nother and .2 and .3 reference each other. 2. .1 blocks, sending BLK (.1, 1, {.2}) to the cycle detector. \nWhen the cycle detector processes this, its view of the topology becomes [.1 . (1, {.2})]. 3. .2 wishes \nto send a reference to .1 to .3. It sends INC to .1 and then AP P (.1) to .3. .2 then drops its reference \nto .3 , collects garbage locally, and sends DEC to .3. The cycle detector s view of the topology does \nnot change. 4. .3 processes AP P (.1), adding .1 to its external set. .3 then drops its reference to \n.2 , collects garbage locally, and sends DEC to .2.The cycle detector s view of the topology does not \nchange. 5. .2 processes DEC , then blocks, sending BLK (.2, 1, {.1}) to the cycle detector. When the \ncycle detector pro\u00adcesses this, its view of the topology becomes [.1 . (1, {.2}), .2 . (1, {.1})]. 6. \nThe cycle detector perceives a cycle {.1, .2}, even though .1 is reachable from .3. This is because .1 \nhas a pending INC that it has not processed.   (a) Initial state, as in step 1 (b) .1 blocks, as in \nstep 2   (e) .2 blocks, as in step 5. The per\u00adceived cycle is incorrect due to .1 s pending INC. Figure \n1: Diagram of example 1. Boxes display the reference count (.), and queue (Q) of actors, with round corners \nindicating unblocked and square corners indicating blocked. The arrows indicate references, eg. .1 references \n.2, which implicitly shows the external set. Conf-Ack Protocol When a perceived cycle is detected, the \ncycle detector must determine whether or not the view of the topology used to detect the cycle agrees \nwith the true topology. To do so, we introduce a conf-ack step to our protocol. When the cycle detector \ndetects a perceived cycle, it sends a con.rm message (CNF) with a token uniquely identifying the perceived \ncycle to each actor in the cycle. When an actor receives CNF, it sends an acknowledgement message (ACK \n) with the token to the cycle detector without regard to the actor s view of its topology. If the cycle \ndetector receives ACK from an actor in a per\u00adceived cycle without receiving UNB, then that actor did \nnot unblock between blocking and the detection of the perceived cycle, which tells us that the actor \ns view of its topology when the perceived cycle was detected was the same as the cycle detector s view \nof that actor s topology used to detect the perceived cycle. Such an actor is con.rmed. Conversely, if \nan actor in a cycle changes state, it will send UNB before it sends ACK. Because messaging is causal, \nthe cycle detector will receive the UNB before it receives the ACK. When the cycle detector receives \nUNB for an actor, it cancels all per\u00adceived cycles containing the newly unblocked actor, since they were \ndetected with an incorrect view of that actor s to\u00adpology. Further, if all actors in a perceived cycle \nare con.rmed, then, at the time the cycle was detected, each actor in the cycle had a view of its topology \nthat agreed with the true topology. As a result, the perceived cycle is a true cycle and can be collected. \nExample 2. Expanding example 1 with the conf-ack pro\u00adtocol. This is shown in .gure 2. 7. The cycle detector \nsends CNF (t) to .1 and .2, where t is a token uniquely identifying this perceived cycle.  (a) Cycle \ndetector sends CNF, as in step 6. (b) .1 unblocks, as in step 8. The per\u00adceived cycle is correctly cancelled, \nas in step 9. Figure 2: Diagram of example 2. Boxes display the refer\u00adence count (.), and queue (Q) of \nactors, with round corners indicating unblocked and square corners indicating blocked. The arrows indicate \nreferences, eg. .1 references .2, which implicitly shows the external set. 8. .1 processes the pending \nINC from example 1 before CNF (t), due to causal messaging, and sends UNB(.1) to .. 9. .1 processes \nCNF (t ) and sends ACK (.1, t ) to the cycle detector.  10. . processes UNB(.1) before ACK (.1, t ), \ndue to causal messaging, and correctly cancels the perceived cycle.  Explanation The conf-ack protocol \nworks by providing the cycle detector with con.rmation that the view of the to\u00adpology used to detect \na cycle (which was sent to the cycle detector as a snapshot of each actor s view of its topology) agreed \nwith the true topology when the cycle was detec\u00adted. This approach allows the cycle detector to work \ncon\u00adcurrently with other actors, without shared memory, locks, read/write barriers, cache coherency, \nor any other form of thread-coordination. Causal Messaging In order to maintain the actor s ref\u00aderence \ncount invariant, message delivery must be causal. When an actor .1 sends INC to an actor .2 before includ\u00ading \nit in a message to an actor .3, .2 must process that INC before any DEC message sent by .3. Each message \nis an ef\u00adfect, and every message the sending actor has previously sent or received is a cause of that \neffect. Messaging is causal if every cause is enqueued before the effect. Causality propag\u00adates forward: \nthe causes of an effect are also causes for any secondary effect. Example 3. Causal messaging. 1. .1 \nsends msg1 to .2. 2. .1 sends msg2 to .3 . 3. After receiving msg2, .3 sends msg3 to .2. 4. To preserve \ncausality, .2 must receive msg1 before msg3.  Causality is easy to achieve in a many-core setting. Sending \na message and enqueuing it at the destination can be done with a single atomic operation. As a result, \ncausality is a natural consequence of lock-free, wait-free FIFO message queues, and has no overhead. \nConsistency Model Our approach requires only weak memory consistency. In particular, when a message is \nsent, all writes to the contents of the message must be visible to the receiver of the message. This \ncan be implemented with a release barrier on message send. On the x86 architecture, this release barrier \nis implicit on all writes, so no fence is re\u00adquired. Moreover, because MAC requires no shared memory \nother than the contents of messages, no consistency model is necessary for other writes, e.g. when the \ncycle detector updates its view of blocked actor topology. 5. Formal Model In this section we present \na formal model, expressed as an operational semantics for MAC. Types and identi.er conven\u00adtions are presented \nin .gure 3, and the steps that rewrite the con.guration are presented in .gures 4 to 7. A con.guration \ncontains a queue, a cycle detector and a set of actors. While an actor logically contains its own queue, \nwe represent the queue as a global entity that maps an actor ID to a message sequence. The cycle detector \nis composed of the cycle detector s view of the blocked actor topology (PT), the set of perceived cycles \nthat are awaiting con.rmation (PC), and the next token that will be used to identify a perceived cycle \n(t ). The cycle detector s identi.er is .. Each actor is composed of its identi.er, a view of its topology \n(. and .), its heap, and a .ag indicating whether or not it is blocked. We treat an actor s heap as a \nset of actor IDs for convenience, but it stands in for a normal heap. Messages can be sent and received \nby actors and the cycle detector. Each message is composed of a message identi.er and arguments. The \nAPP message represents all application level messages that are sent by actors, and its parameter represents \nthe set of actor identi.ers included in the message. All of the other messages are internal. They are \nused to describe the protocol, but would not be exposed in a programming language that used MAC.  cf \ng . C onf iguration = Queue \u00d7 C ycleDetector \u00d7 Actors Q . Queue = (I D . {.}) . (M essage)* M essage \n= AP P (.s)|I N C |DE C |BLK (., ., .)|U N B (.)|C N F (t)|AC K (., t ) C D . C ycleDetector = P erceivedT \nopo \u00d7 P erceivedC ycles \u00d7 T oken . . C ycleDetectorI D P T . P erceivedT opo = I D . (Ref C ount \u00d7 E \nxS et) P C . P erceivedC ycles = T oken . (I D . Boolean) as . Actors = P(Actor) a . Actor = I D \u00d7 Ref \nC ount \u00d7 E xS et \u00d7 H eap \u00d7 Blocked . . I D .s . I Ds = P(I D) . . E xSet = P(I D) h . H eap = P(I D) \n. . Ref C ount = I nteger \u00df . Blocked = Boolean t . T oken = I nteger Figure 3: Types and identi.er \nconventions In example 1, the initial con.guration looks like this: P op(Q, .) \u00a3 Q', msg where Q(.) = \nmsg : rest and Q' = Q[. . rest] cf g1 = (Q1, C D1, {a1, a2, a3}) where = e P ush(Q, ., UNB(.)) if \u00df \nUnblock (Q, ., \u00df) \u00a3 Q1 Q if \u00ac\u00dfC D1 = (e, e, 0) a1 = (.1, 1, {.2}, {.2}, f alse) We use C losed to refer \nto a closed cycle of blocked actors a2 = (.2, 2, {.1, .3}, {.1, .3}, f alse) in a perceived topology. \n= (.3, 1, {.2}, {.2}, f alse)a3 . . ....s :') .2. .' ..s. Notation In this paper, we make use of some \nadditional notation for convenience. C losed(.s, P T ) . ... ..'...P T (. ... P T (.) .1 = We treat \nvalues in the context of sets as singleton sets, eg. . . ., .s \\ . have the expected meaning.  We use \nset operations on the domains of mappings.  x . map . x . dom(map) map \\ {x1..xn} \u00a3 map[x1 . ., ..xn \n. .] We use set operations between actors and actor identi.\u00aders. as \\ .s \u00a3 as \\ {a|a = (., _, _, _, \n_) . . . .s} . . as . (., _, _, _, _) . as We use an index operation to examine a queue and an append \noperation to modify a queue. Q(.)[k] is the kth message on Q(.). Q(.)++msg appends msg to the end of \nQ(.).  We use P ush, P op, and Unblock to manipulate the queue.  P ush(Q, {.1...n}, msg) \u00a3 Q[.1 . Q(.1)++msg, \n...n . Q(.n)++msg] |{.'|.' ..s, . .P T (.') .2}| We guarantee causality with FIFO message queues that \nprovide both guaranteed and atomic delivery. This is ex\u00adpressed in the operational semantics by using \na single op\u00aderation on the queue (P ush) to both send and enqueue a message. Using an intermediate container \nof messages that have been sent by an actor but not yet enqueued by the re\u00adceiving actor would make delivery \nnon-atomic, even though messages would still be FIFO ordered. We will now discuss the operational semantics. \nActor Local Execution Rather than present a program\u00adming language for actors, the rules in .gure 4 describe \nthe effects of local execution on the entities of our protocol. As usual in concurrency, execution is \nnon-deterministic. In each rule, the active actor is indicated by (., ., ., h, f alse). ' CR E AT E \nCreate a new actor. The newly created actor ahas identi.er .', a reference count of one (because the \ncreating actor . has a reference to it), an empty external set and heap, and is unblocked. The new actor \na' is added to the set of actors, and its identi.er .' is added to the external set of the active actor. \n SE N D Send an APP message, possibly containing actor IDs, to another actor . '. The active actor .rst \nsends an INC message each actor (other than the sender and the re\u00adceiver) in .s, and then sends APP(.s) \nto . '. If the sender includes itself in a message, it increments its own refer\u00adence count. AD D RE F, \nD E L RE F Add and delete references to actors in its local heap, representing heap changes during program \nexecution. GC Garbage collect locally, compacting its external set. Actors that are removed from the \nexternal set (i.e. .s) are sent DEC. BL O C K When an actor .nishes responding to a message and has no \npending messages, it sends BLK to the cycle detector with a snapshot of the its topology and sets its \nblocked .ag to true. In example 1, step 2 applies rule BL O C K, rewriting the con.guration to: ' cf \ng2 = (Q2, C D1, {a1, a2, a3}) where Q2 = [. . (BLK (.1, 1, {.2}))] ' a = (.1, 1, {.2}, {.2}, true) 1 \nIt then applies rule RE C V BL K (de.ned below), rewriting the con.guration to: ' cf g3 = (Q3, C D2, \n{a1, a2, a3}) where Q3 = e C D2 = ([.1 . (1, {.2})], e, 0) Step 3 then applies rules SE N D, D E L RE \nF and GC, rewrit\u00ading to: ' ' cf g4 = (Q4, C D2, {a1, a 2, a3}) where Q4 = [.1 . (I N C ), .3 . (AP P \n(.1), DE C )] ' a = (.2, 2, {.1}, {.1}, f alse) 2 Actor Message Receipt As shown in .gure 5, an actor \ncan receive messages regardless of whether or not it is blocked. An actor can receive four types of message: \nRE C VAP P When an actor receives an application message APP, each actor contained in the message (i.e. \n.s) other than the receiver (i.e. .s \\ .) that is already present in the receiving actor s external set \n(i.e. (.s \\ .) n .) is sent DEC. Those not present in the external set are added to it. A blocked actor \nthat receives APP unblocks. RE C V IN C When an actor receives INC, it increments its reference count \nby one. A blocked actor that receives INC unblocks. RE C V DE C When an actor receives DEC, it decrements \nits reference count by one. A blocked actor that receives DEC unblocks. RE C V CN F When an actor receives \nCNF, it echoes the token in the message back to the cycle detector in an ACK message. A blocked actor \nthat receives CNF does not unblock. In example 1, step 4 applies rules RE C VAP P, RE C V DE C, DE L \nRE F and GC, rewriting to: ' ' ' cf g5 = (Q5, C D2, {a1, a 2, a 3}) where Q5 = [.1 . (I N C ), .2 . (DEC \n)] ' a = (.3, 0, {.1}, {.1}, f alse) 3 Step 5 then applies rules R E C V DEc and BL O C K , rewrit\u00ading \nto: ' '' ' cf g6 = (Q6, C D2{a1, a 2 , a 3}) where Q6 = [.1 . (I N C ), . . (BLK (.2, 1, {.1}))] ' a \n= (.2, 1, {.1}, {.1}, true) 2 It then applies rule RE C V BL K (de.ned below), rewriting to: ' '' ' \ncf g7 = (Q7, C D3, {a1, a 2 , a 3}) where Q7 = [.1 . (I N C )] C D3 = ([.1 . (1, {.2}), .2 . (1, {.1})], \ne, 0) Cycle Detector Local Execution We now consider the ac\u00adtions of the cycle detector. As shown in \n.gure 6, the cycle detector can: DE T E C T An isolated cycle of blocked actors is detected and mapped \nto a unique token. The actors in the newly detec\u00adted perceived cycle are initially uncon.rmed (mapped \nto f alse), and are therefore sent a CNF request. CO L L E C T A dead cycle of con.rmed actors is garbage \ncol\u00adlected. They are removed from the set of actors. In example 1, step 6 applies part of rule DE T E \nC T, rewriting to: ' '' ' cf g8 = (Q7, C D3, {a1, a 2 , a 3}) where C D3 = ([.1 . (1, {.2}), .2 . (1, \n{.1})], [0 . [.1 . f alse, .2 . f alse]], 1) And in example 2, step 7 applies the remainder of rule \nDE T E C T, rewriting to: ' '' ' cf g9 = (Q8, C D3, {a1, a 2 , a 3}) where Q8 = [.1 . (I N C, C N F \n(0)), .2 . (C N F (0))] Cycle Detector Message Receipt As shown in .gure 7, the cycle detector can receive \nthree types of message: RE C V BL K The cycle detector maps the actor (.) to the topology snapshot (., \n.) in the message. RE C V UN B The cycle detector removes the actor (.) from the map of perceived topology \nand removes all perceived cycles that contain the newly unblocked actor. RE C VAC K If the perceived \ncycle identi.ed by the token in the message still exists, the acknowledging actor is con.rmed (mapped \nto true) in that perceived cycle. ' . ' . as a = (. ' , 1, \u00d8, \u00d8, f alse) (CR E AT E) Q, C D, (., ., \n., h, f alse) . as . Q, C D, {(., ., . . . ' , h, f alse), a '} . as . + 1 if . . .s . ' . . .s . (. \n. .) . ' = . if . . .s (SE N D) Q ' = P ush(Q, .s \\ {., . ' }, I N C ) Q '' = P ush(Q ' , . ' , AP P \n(.s)) Q, C D, (., ., ., h, f alse) . as . Q '' , C D, (., . ' , ., h, f alse) . as . ' . . . . (AD D \nRE F) Q, C D, (., ., ., h, f alse) . as . Q, C D, (., ., ., h . . ' , f alse) . as . ' . h (DE L RE \nF) Q, C D, (., ., ., h, f alse) . as . Q, C D, (., ., ., h \\ . ' , f alse) . as .s . {. ' |. ' . . . \n. ' . h} Q ' = P ush(Q, .s, DEC ) (GC) Q, C D, (., ., ., h, f alse) . as . Q ' , C D, (., ., . \\ .s, \nh, f alse) . as Q(.) = () Q ' = P ush(Q, ., B LK (., ., .)) (BL O C K) Q, C D, (., ., ., h, f alse) \n. as . Q ' , C D, (., ., ., h, true) . as Figure 4: Operational semantics of actor local execution Q \n' , AP P (.s) = P op(Q, .) Q '' Q ''' = P ush(Q ' , (.s \\ .) n ., DE C ) = U nblock(Q '' , ., \u00df) (RE \nC VAP P) Q, C D, (., ., ., h, \u00df ) . as . Q ''' , C D, (., ., . . (.s \\ .), h ' , f alse) . as Q '' Q \n' , I N C = P op(Q, .) = U nblock(Q ' , ., \u00df) (RE C V IN C) Q, C D, (., ., ., h, \u00df) . as . Q '' , C \nD, (., . + 1, ., h, f alse) . as Q '' Q ' , DE C = P op(Q, .) = U nblock(Q ' , ., \u00df) (RE C V DE C) \nQ, C D, (., ., ., h, \u00df) . as . Q '' , C D, (., . - 1, ., h, f alse) . as Q ' , C N F (t) = P op(Q, .) \nQ '' = P ush(Q ' , ., AC K (., t )) (RE C V CN F) Q, C D, (., ., ., h, \u00df) . as . Q '' , C D, (., ., \n., h, \u00df) . as Figure 5: Operational semantics of actor message receipt C losed({.1...n}, P T ) ' P C \n= P C [t . [.1 . f alse, ...n . f alse]] (DE T E C T) Q ' = P ush(Q, {.1...n}, C N F (t)) Q, (P T , \nP C, t ), as . Q ' , (P T , P C ' , t + 1), as .s = {.1...n} = dom(P C (t ' )) Q1 = Q .i . 1..n.P C (t \n' )(.i) . Qi+1 = P ush(Qi, P T (.i) .2 \\.s, DE C ) (CO L L E C T) Q, (P T , P C, t ), as . Qi+1, (P T \n\\ .s, P C \\ t ' , t ), as \\ .s Figure 6: Operational semantics of cycle detector local execution  Q \n' , BLK (., ., .) = P op(Q, .) (RE C V BL K) Q, (P T , P C, t ), as . Q ' , (P T [. . (., .)], P C, \nt ), as ' Q ' , U N B(.) = P op(Q, .) P C = P C \\ {t ' |. . P C (t ' )} (RE C V UN B) Q, (P T , P C, \nt ), as . Q ' , (P T \\ ., P C ' , t ), as Q ' , AC K (., t ' ) = P op(Q, .) '' P C [t . P C (t ' )[. \n. true]] if t . P C ' P C = (RE C VAC K) P C if t ' . P C Q, (P T , P C, t ), as . Q ' , (P T , P C \n' , t ), as Figure 7: Operational semantics of cycle detector message receipt In example 2, step 8 applies \nstep R E C V IN C, rewriting to: '' '' ' cf g10 = (Q9, C D3, {a1 , a 2 , a 3}) where Q9 = [.1 . (C N \nF (0)), .2 . (C N F (0)), . . (U N B(.1))] '' a = (.1, 2, {.2}, {.2}, f alse) 1 Step 9 applies step RE \nC V CN F, rewriting to: '' '' ' cf g11 = (Q10, C D3, {a1 , a 2 , a 3}) where Q10 = [.2 . (C N F (0)), \n. . (U N B(.1), AC K (.1, 0))] Step 10 applies step RE C V UN B, rewriting to: '' '' ' cf g12 = (Q11, \nC D4, {a1 , a 2 , a 3}) where Q11 = [.2 . (C N F (0)), . . (AC K (.1, 0))] C D4 = ([.2 . (1, {.1})], \ne, 1) Completeness If a cycle of blocked actors exists, each actor will have sent BLK to the cycle detector. \nThe cycle detector will eventually execute RE C V BL K for each blocked actor, and will eventually execute \nD E T E C T and begin a con\u00ad.rmation process that will result in executing CO L L E C T. This process \nis non-deterministic, but it is theoretically pos\u00adsible to detect a cycle as soon as it appears. If all \nactors are blocked, the system will .nd all cycles. The program terminates when it is not possible to \napply any rule. This occurs when no actors are executing (prevent\u00ading any actor local execution rules \nfrom being applied), the queue is empty (preventing any actor or cycle detector mes\u00adsage receipt rules \nfrom being applied), and no cycles are de\u00adtected (preventing any cycle detector local execution rules \nfrom being applied). Robustness As presented, MAC is sound and does not have exceptional conditions. \nHowever, the protocol is robust even if failure is introduced. If the cycle detector fails, cycles of \ndead actors will not be collected, but no live actor will be collected. If an actor fails, the result \ndepends on whether or not the cycle detector s view of the failed actor s topology is in agreement with \nthe failed actor s view of its own topology. If it is, the failed actor can be considered blocked, and \nthe system will function normally. If the cycle detector s view of the failed actor s topology is not \nin sync, then there is no way to determine what other actors the failed actor referenced. As a result, \nactors the failed actor held a reference to will not receive DEC messages for those references and will \nnot be collected. However, it remains the case that the cycle detector will continue to collect other \ndead cycles, and no live actor will be collected. Moreover, failure of actors or the cycle detector does \nnot jeopardise termination of the overall system. Namely, collection of all actors is not required in \norder to reach a quiescent state where no rules can be applied. This allows the program to terminate \neven when some dead actors have not been collected. As a result, failure results in uncollected dead \nactors but does not impact soundness or robustness. Failure of individual messages, where a message is \nsent but not received while future messages from the same sender are successful, impacts the system differently \ndepending on the message type. A failed DEC results in an actor with an excess reference count that will \nnot be collected. A failed CNF or ACK message that pertains to a dead cycle results in the failure to \ncollect that dead cycle, but if the message pertains to a live cycle, there is no impact on the system. \nA failed BLK message results in an actor never being collected if the actor is blocked from that point \non, but has no impact on the system if the actor ever unblocks. A failed APP message will result in excess \nreference counts for actors in the message, with the result that those actors will not be collected. \nThe two messages that can impact soundness on failure are INC and UNB. A failed INC message results in \nan actor that has a reference count that is too low. As a result, the cycle detector may .nd perceived \ncycles that are smaller than the true cycle. If the actors in the perceived cycle are all blocked, the \ncycle may be collected while an unblocked actor retains a reference to a collected actor. A failed UNB \nmessage for an actor in a perceived cycle can cause the cycle to be incorrectly collected if all other \nactors in the cycle are blocked. The sender of the failed UNB message . . will now respond with an ACK \nwithout having unblocked, |{. ' |. ' .as, . .H eap(. ' )}|+ |{(. ' , k)|Q(. ' )[k] = APP(.s), ..... and \nthe cycle detector will incorrectly perceive it as having con.rmed. T rueT opo(., cf g) \u00a3 However, \nthe actor-model requires guaranteed message ...s, . ' .as\\.}|, H eap(.) \\ ., ..... delivery [2]. Failure \nof an individual message that cannot be corrected with buffering, retries, or other techniques, can thus \nbe treated as failure of the sending actor. If a failed mes\u00adsage results in all future messages from \nthe sender also fail\u00ading, no form of failure impacts either soundness or robust\u00adness. 6. Proof of Soundness \nOutline To prove soundness, we will show that when every actor in a perceived cycle has con.rmed, the \nperceived cycle is a true cycle. To do so, we will show in theorem 1 that if the cycle detector s view \nof the topology of actors in the per\u00adceived cycle is the true topology, the perceived cycle is a true \ncycle. Then we will show in theorem 2 that when a single actor con.rms, the cycle detector s view of \nits topology, the actor s view of its topology, and the actor s true topology agreed at the time when \nthe perceived cycle was detected. Finally, we will show in theorem 3 that when every actor has con.rmed, \nthe perceived cycle is a true cycle. We will present each with an informal proof here. Formal proofs \nare Q(.) = CNF (_)* T rulyC losed(.s, cf g) . ....s : .. ' ...H eap(. ' ) . . ' ..s . Q(.) = e For example, \nafter step 3 of example 1, T opo(.1, cf g) = (1, {.2}, true), but T rueT opo(.1, cf g) = (2, {.2}, f \nalse). This is because Q(.1) = INC , which both indicates an additional reference (in this case, from \n.3) and that .1 has pending messages other than CNF, and so will unblock. We require three things from \na well-formed con.gura\u00adtion. First, it maintains the reference count invariant that an actor s true reference \ncount is equal to the actor s view of its own reference count, adjusted for INC and DEC messages in the \nactor s queue. Second, an actor identi.er appears only once in the set of actors. Third, an actor in \na perceived cycle (P C (t )) is also in the cycle detector s view of blocked actor topology (PT). De.nition \n2 (A well-formed con.guration). We say that a con.guration cf g = (Q, (P T , P C, _), as) is well-formed, \nformally W F (cf g), if: . . presented in the appendix. As we already said in the introduction, the development \n 1. T rueT opo(., cf g) .1 = T opo(., cf g) .1 + .. |{k | Q(.)[k] = INC }|-|{k | Q(.)[k] = DEC }| 2. \n...|{a | a .as, a = (., _, _, _, _)}| = 1 3. .t . P C.P C (t ) . P T  We now de.ne a history of con.gurations. \nThe history of con.gurations is ghost state that we use to denote the times at which various events took \nplace. A history maps time 0 to a con.guration that contains a single actor. De.nition 3 (History). We \nde.ne H, a history of con.gur\u00adations. H . H istory = T ime . C onf iguration  H(0) = (\u00d8, (\u00d8, \u00d8, 0), \n{(., 0, \u00d8, \u00d8, f alse)})  H(t) . H(t + 1)  De.nition 4. We expect every con.guration to be well\u00adformed \nimplicitly. The initial con.guration is well-formed, and from lemma 1 in the appendix we know that execution \npreserves well-formedness. With these de.nitions, we can present our .rst theorem. We establish that, \nfor a given perceived cycle, if the cycle detector s view of the topology of the actors in the cycle \nis the same as their true topology, the perceived cycle is a true cycle. Theorem 1 (A PC is truly closed \nif the CD s view of the topology is the true topology). Given a con.guration cf g = (_, (P C, P T , _), \n_): of the soundness proof helped us better understand the al\u00ad gorithm itself and the central role of \nthe relation between the different views of the topology. Moreover, our initial intu\u00adition about the \nreason the algorithm was correct was slightly wrong. Namely, instead of the property outlined in theorem \n2 above, we thought that only after all actors had con.rmed would we know that the cycle detector s view \ncoincided with the true topology. The property from theorem 2 is stronger, and easier to prove. We believe \nthat the concepts we de\u00adveloped for the proof of MAC will be useful to prove other protocols as well. \nDetailed Arguments In order to express these theorems, we de.ne T opo as the actor s view of its topology, \nT rueT opo as the true topology based on inspecting the heaps and queues of all actors, and T rulyC losed \nas a property of a set of actors which holds when these actors form a closed cycle in the true topology. \nT rueT opo allows only CNF messages in . s queue because all other messages cause an actor to unblock \nwhen they are received. Because a T rulyC losed cycle encompasses all references to all actors in the \ncycle, it is not possible for actors in a T rulyC losed cycle to receive messages in the future. De.nition \n1 (Topology, true topology, and true cycles). Given cf g = (Q, _, as), we de.ne: H eap(.) \u00a3 h . (., \n_, _, h, _) . as  T opo(., cf g) \u00a3 (., ., \u00df) . (., ., ., _, \u00df) . as  .. . P C (t).(P T (.), true) \n= T rueT opo(., cf g) . T rulyC losed(dom(P C (t), cf g)) Proof. When the cycle detector detects a perceived \ncycle (P C (t )) based on the cycle detector s view of the blocked actor topology (PT), that cycle is \nclosed (C losed(dom(P C (t)), P T )). If the cycle detector s view of a blocked actor s topology (P T \n(.)) is the same as the actors true topology (T rueT opo(.)), then we can substitute the true topology \nof the actor for the cycle detector s view of the actor s topology in the de.nition of C losed. If we \ndo this for all actors in a perceived cycle, we arrive at the de.nition .t3 = t.N ewP C tT rueT opot(.) \n3 H3 H (.), true) = (.) = around FIFO message queues and the resultant ordering of events. Using these \nde.nitions and lemmas, we can present the remaining two theorems. First, we establish that con.rm\u00adation \nfrom a single actor indicates that the con.rmed actor s view of the its topology was the same as the \ncycle detector s view of that actor s topology when the perceived cycle was detected. Theorem 2 (A con.rmed \nactor implies the CD s view of its topology, the actor s view of its topology, and its true 3 H topology \nagreed when the PC was detected). (t ) . (P T t t H 3 H (t)(.) . T opot P C of T rulyC losed for the \nperceived cycle. In order to be able to describe at which time certain events  Proof. Because actor \n. is con.rmed (P C t H (t)(.)), we know took place, we now de.ne the elements of a con.guration, the \ncycle detector consumed an acknowledgement message topology, and events in the con.guration history. \nThe queue 5 H from . (.t5 = t.C onsumet. consumed a con.rmation message from the cycle detector (., \nACK (., t ))), and therefore at time t in history H is referred to as Q t H , and the same notation is \nused for P T, and as. An actor . s , P Cview of its topology at time t in history H is referred to as \nt H t Ht Ht H , t 4 H 4 H = t5.C onsumetledgement message in response (P ostt, This in turn means the \ncycle detector sent the con.rmation (.t4 (., CNF (t ))) and sent an acknow\u00ad (., ACK (., t ))). (.), and \nthe same notation is used for T rueT opo T opo t H t H t H and T rulyC losed t H . Similarly, P ost \n t H C losed (., msg) 3 H 3 H message (.t3 = t4 . P osttperceived cycle containing . was detected (N \newP C tThis implies . is in the cycle detector s view of the blocked (., CNF (t ))), which means the \ndenotes the time at which message msg was posted to actor ., C onsume t H (., msg) denotes the time at \nwhich message (t )). msg was consumed by actor ., and N ewP C t H (t) denotes the time at which the perceived \ncycle identi.ed by t was 3 H topology (. . P T tsumed a block message from . ), which means the cycle \ndetector con\u00ad detected. H 2 H = t3.C onsumetDe.nition 5 (Con.guration, topology and events in the his-sumed \nan unblock message from . % (.t2 (., BLK (., ., .))) and has not con\u00ad (.t ' .t2 = t ' (., UNB(.))). \nThis in turn = t.\u00acC onsumetde.ne: indicates that . sent a block message tory). Given H and t, if H(t) \n= (Q, (P T , P C, t ), as) we H 1 H t2.P ostt unblock message before sending an acknowledgement mes\u00ad \n% (.t1 (., BLK (., ., .))) and did not send an = t H \u00a3 Q, The elements of a con.guration at time t: \nQ H \u00a3 P T , P C= t4.\u00acP ostt Actor and cycle topology at time t: . s view of its own topology did not \nchange during that t H % \u00a3 P C , t\u00a3 t , as\u00a3 as t H t Ht H P T sage (.t ' .t1 = t ' (., UNB(.))), which \nmeans 1 H t4.T opotT opot the perceived cycle was detected on the basis of the to\u00adtime (.t ' .t1 = t \n' (.)). Since = (.) = (.) \u00a3 T opo(., H (t)) T opo t H (.) \u00a3 T rueT opo(., H (t)) pology in the block \nmessage and was detected before the t H T rueT opo acknowledgement message was sent, we know . s view \nof (.s) \u00a3 C losed(.s, P T t H ) C losed t H its topology at the time the perceived cycle was detected \nt H (.s) \u00a3 T rulyC losed(.s, H (t))T rulyC losed was the same as the cycle detector s view of . s topology \nH H %% = t4.(P T t(.), true) = T opotIf . s view of its reference count was not the same as its (.t \n' .t2 = t ' (.)). Predicates denoting the times at which events occurred. H H (., msg) . Qt-1 C onsume(., \nmsg) . Qt-1 t H t H (.) = q . Q P ost (.) = q.msg 3 H 3 H true reference count (T opotT rueT opotthen, \ngiven the reference count invariant, . s queue must (.) .1),(.) .1 = t Ht H (.) = msg.q.Q (.) = 3 H \ncontain either INC or DEC (QtIf that were true, we know that . would consume INC or (.) 3 (INC . DEC \n) ). q H P C t-1 For example, in example 1, P ost t Ht H .. t ./. t . N ewP C (t) P C DEC before CNF \n(t), which would mean . would send an t H t H C losed (dom(P C (t ))) unblock message before sending \nan acknowledgement mes\u00ad (.1, INC ) indicates the sage, which we know to be untrue because . is con.rmed. \nt H time when .2 sends INC to .1, and Therefore, . s view of its reference count is its true reference \nC onsume t H (.3, APP(.s)) indicates the time when .3 re-count. ceives APP(.s) from .2. Similarly, N \newP C t H (0) indicates If . s view of its external set was not the same as its 3 H 3 H true external \nset (T opotT rueT opot. must have taken a step that rewrites its external set. By the time when the cycle \ndetector detects the cycle {.1, .2}. In the appendix we present a series of short lemmas that (.) .2), \nthen (.) .2 = establish the underlying behaviour of the system, revolving case analysis, . must unblock \nto change its external set, which would mean . would send an unblock message before sending an acknowledgement \nmessage, which we know to be untrue because . is con.rmed. Therefore, . s view of its external set is \nits true external set. If . s view of its blocked state was not the same as its true memory allocation \nfrom per-actor heaps, precise passive ob\u00adject garbage collection, and an extension of the system de\u00adscribed \nin this paper for collecting passive objects that have been passed or shared across actor heaps. Actors \nare currently written in C on top of the runtime. blocked state (T opot H 3 (.) .3 = T rueT opot H 3 \n (.) .3), the . s We do not have a full actor-model programming language queue must contain a message \nother than CNF (Qt H 3 (.) = yet. Programming using our library does not offer full type CNF (_)*). \nIf this were true, we know that . would consume a message other than CNF before CNF (t), which would \nmean . would send an unblock message before sending an acknowledgement message, which we know to be untrue \nbecause . is con.rmed. Therefore, . s view of its blocked state is its true blocked state. Therefore, \nfor each actor . in the perceived cycle, the cycle detector s view of . s topology, . s view of its topology \nand . s true topology agree when the perceived cycle was 33 safety and is thus error prone. However, \nthe library and pro\u00adgrams written in C are suf.cient to investigate the perform\u00adance of our approach. \nCurrent deployment The library is currently in use at a large .nancial institution as the concurrency \ncore of a high\u00adthroughput, low-latency application. The application pro\u00adcesses thousands of requests \nper second under peak usage and each request potentially creates dozens of new actors. These actors are \nshort-lived, surviving only for the duration detected (.. . P C t H (t ).(P T t% (.), true) = T opot \nH H (.) = of the request, which results in regular garbage collection of T rueT opot H 3 (.)). actors. \nThe application is relatively long-lived, running for We now establish that con.rmation from all actors \nindic\u00adates, for every actor in the cycle, that the actor s view of its topology is the same as the true \ntopology of the actor. In combination with theorem 2, this tells us that the cycle de\u00adtector s view of \nthe topology of the actors in the cycle is also the same as the true topology. In combination with theorem \n1, this tells us that the perceived cycle is a true cycle and can be safely collected. Theorem 3 (A fully \ncon.rmed cycle is a true cycle). .. . P C t (t).P C t (t )(.) . T rulyC losedt (dom(P C t (t))) HH HH \nProof. Since every actor in the perceived cycle is con.rmed, we know from theorem 2 that when the perceived \ncycle was detected (.t3 = t.N ewP C t H 3 (t)) every for actor . in a week at a time. Performance has \nbeen nearly linear with core count for this application, resulting in approximately a 31.5x speed-up \non a 32-core machine. These numbers indic\u00adate that hundreds of thousands of actors is a realistic number \nfor some classes of production software, that short-lived act\u00adors are a useful approach to concurrency, \nand that our imple\u00admentation of actor collection does not impede performance. Implementation considerations \nCausal messaging is guar\u00adanteed on a single host (multi-or many-core) using FIFO ordered message queues \nwith guaranteed atomic deliv\u00adery, implemented as lock-free wait-free multiple-producer single-consumer \nqueues. Sending a message requires ap\u00adproximately 10 nanoseconds. Because the only message that requires \nan acknowledgement is the con.rmation message the perceived cycle, the cycle detector s view of the topo\u00adfrom \nthe cycle detector, no message round trips are required logy of ., . s view of its topology, and . s \ntrue topology during normal execution. During collection, a round trip is agreed (.. . 3 H P C t(t).(P \nT t H 3 (.), true) = T opot H 3 (.) = only required if the actor is indeed ready to be collected, T \nrueT opot 3 H therefore truly closed at time t3 (.)). We know from theorem 1 that P C (t) was in which \ncase the CNF message requiring acknowledgment is the only message on the actor s queue, resulting in \nthe (T rulyC losedt H 3 (dom(P C t H 3 (t)))), and a truly closed cycle fastest possible response. Otherwise, \nan UNB message asso\u00adcan be collected. 7. Implementation  ciated with an earlier rule execution will \nbe received by the cycle detector, short circuiting the round trip. As a result, the overhead of the \nConf-Ack protocol is very low. In this section we discuss the practical implications of imple\u00admenting \nMAC. We .rst report on its current deployment in an actor runtime deployed at a large .nancial institution, \nwhere the good performance (linear speedup with the number of cores) indicates that MAC imposed a negligible \nperformance overhead. We then discuss implementation considerations affecting the overhead of MAC, and \nsome implementation details. Finally, we compare with four benchmarks proposed for Erlang, Scala, Akka, \nand libcppa, and .nd that MAC s performance is competitive. We have implemented message-based actor collection \nas part of a runtime library written in C. The library also in\u00adcludes asynchronous messaging, work-stealing \nscheduling, The overhead of BLK and UNB messages is similarly low, introducing only an additional 10 \nnanoseconds of latency when an actor unblocks and another 10 nanoseconds when an actor blocks. This cost \nis only paid when an actor has no other pending work. An optimisation we have made in the implementation \nallows an actor to notify the cycle detector of a reference count change when it processes INC or DEC \nwithout unblocking, accomplishing with one message what would otherwise take two. The formalisation and \nproof lead directly to an addi\u00adtional optimisation in the implementation: as speci.ed in the GC rule \nin the operational semantics, the subset of actors checked for cycles and the timing of those checks \nis non\u00addeterministic. This allows the cycle detector to defer detec\u00adtion, performing orders of magnitude \nless work. This can be seen in Table 5, where cycle detection attempts are signi.c\u00adantly less common \nthan BLK messages. Weighted reference counting We have implemented a lim\u00adited form of weighted reference \ncounting to eliminate some of the INC and DEC messages required when sending and receiving APP. This \nrequires the external set to become an external map. The external map associates actors with num\u00adbers, \nsuch that each actor can keep a reference weight for any other actor. When an actor .0 receives an APP \nmessage containing an actor .1, the reference weight of .1 in the external map of .0 is incremented. \nAs a result, when an actor receives an APP message, it no longer needs to send DEC messages to actors \ncontained in the message that are already in the receiver s external map. On the other hand, when .0 \nsends a reference to .1 to some actor .2 and the reference weight of .1 in the external map of .0 is \ngreater than one, the reference weight is decremented and no INC message is sent. In that case, we say \nthat a refer\u00adence to .1 is split across .0 and .2. However, when .0 sends a reference to .1 to some actor \n.2 and the reference weight of .1 in the external map of .0 is one, then an INC message has to be sent \nto .1, because the single reference cannot be split. In this case, an INC message with an arbitrary additional \nref\u00aderence weight is sent from .0 to .1. This additional reference weight is added to the reference weight \nof .1 in the external map of .0. When .1 receives the INC message, the additional reference weight is \nalso added to the reference count of .1. In this way, the number of INC messages required is signi\u00ad.cantly \nreduced. When the heap of .0 no longer contains a reference to .1, .0 sends a DEC message to .1 that \nincludes the reference weight of .1 in the external map of .0. When .1 receives the DEC message, the \nreference weight is subtracted from the reference count of .1. Finally, when an actor blocks, it includes \nits reference count and its external map in the BLK message sent to the cycle detector. The de.nitions \nof C losed and T rueT opo are changed to account for the reference weight in the external map, and cycle \ndetection proceeds as before. Benchmarks and preliminary comparisons with Erlang, Scala, Akka, and libccpa \nCurrently, MAC can collect hun\u00addreds of thousands to millions of actors (in various cyclic topologies) \nper second on current x64 hardware (2.5 to 3.5 ghz, 4 to 32 cores). In comparison, the pseudo-root approach \nused in SALSA 1.0 collects thousands of actors per second on a dual-processor Solaris machine [16]. We \nhave evaluated programs written against our runtime library with both manual actor termination and MAC. \nWe present a summary of preliminary experimental results in Tables 1 to 4. A break down of cycle detector \nattempts Language Time (s) Throughput (msg/s) Erlang OTP ~9 ~333,333 Erlang ~7 ~428,571 Scala (react) \n~9 ~333,333 libcppa ~5.5 ~545,454 MAC, disable CD 0.24 12,500,000 MAC, normal CD 0.24 12,500,000 MAC, \nforce CD 0.24 12,500,000  Table 1: Message handling: 3 million messages, 2 cores Language Time (s) Throughput \n(actors/s) Erlang ~10 ~52,429 Scala (react) ~10 ~52,429 Scala (Akka) ~18 ~29,127 libcppa ~18 ~29,127 \nMAC, disable CD 2.9 180,788 MAC, normal CD 7.5 69,905 MAC, force CD 9.5 55,188 Table 2: Actor creation: \n219 actors, 4 cores Language Time (s) Throughput (msgs/s) Erlang ~16 ~1,250,000 Scala (react) ~45 ~444,444 \nScala (Akka) ~30 ~666,666 libcppa ~15 ~1,333,333 MAC, disable CD 5.2 3,846,153 MAC, normal CD 5.2 3,846,153 \nMAC, force CD 5.2 3,846,153 Table 3: Mailbox performance: 20 million messages, 4 cores Language Time \n(s) Throughput (msgs/s) Erlang ~125 ~400,000 Scala (react) ~120 ~416,666 Scala (Akka) ~60 ~833,333 libcppa \n~80 ~625,000 MAC, disable CD 45.7 1,094,091 MAC, normal CD 77.3 646,830 MAC, force CD 78.4 637,755 Table \n4: Mixed scenario: 50 million messages plus factorisa\u00adtion, 4 cores and successes and message counts \nfor each test scenario is presented in Table 5. These tests are taken from a series of benchmarks made \navailable for a collection of existing actor languages and libraries [29] with publicly available source \ncode [30]. The benchmarks are designed to stress speci.c aspects of actor\u00admodel languages such as message \nperformance and actor creation performance. To match the hardware and methodo\u00adlogy of the existing benchmark \nresults, we executed the .rst test on a 2 core 2.67 GHz i7 and the other three tests on a 4 core 2.27 \nGHz Xeon, with the average of .ve runs being presented. In Tables 1 to 4, we present the results previously \nreported in the existing benchmarks [29] and add the results we obtained for MAC. For MAC, we present \nresults in three con.gurations: with cycle detection disabled, with cycle detection enabled (de\u00adtecting \ntermination via quiescence), and forcing cycle detec\u00adtion (detecting termination via all actors in the \nsystem hav\u00ading been collected). We include test results for forced cycle detection in order to evaluate \nworst-case behaviour. The message handling benchmark spawns a counter actor and a worker actor. The worker \nactor sends three million messages to the counter actor asking it to increment its counter, followed \nby a single get-and-reset message retriev\u00ading the counter. This tests raw message performance, but not \nactor creation or concurrency. The actor creation benchmark spawns 219 actors, ar\u00adranged in a doubly-linked \ntree, forming a single cyclic graph. This is a good stress test for the cycle detector. The mailbox performance \nbenchmark spawns a single receiver and twenty senders, each of which send one mil\u00adlion messages to the \nreceiver. This tests concurrent message performance, as the senders are scheduled simultaneously across \ncores. The mixed scenario spawns twenty rings of .fty actors each. Each ring sends 500,000 messages around \nthe ring while a worker actor performs expensive factorisation. This is repeated .ve times, resulting \nin .fty million messages and 100 factorisation runs. This tests combining expensive calculation with \na heavy message load. Discussion of preliminary implementation results We note that all MAC versions \nperform the same in message handling and in mailbox performance. This may be so be\u00adcause in both these \ntests the actors involved are constantly sending or receiving messages, and as a result they only block \nat the end of the test. The preliminary results are highly encouraging. We chose to reuse existing benchmarks \nrather than design new ones in order to both provide a direct comparison between our work and existing \nactor-model languages and libraries and to avoid inadvertently tailoring benchmarks to our own ap\u00adproach. \nOn the other hand, an aspect that might be underrep\u00adresented in these benchmarks is passing references \nto actors in messages. We plan to investigate more in future work. 8. Conclusion and Further Work We \nhave presented Message-based Actor Collection (MAC), a system for fully concurrent garbage collection \nof actors, including an operational semantics in section 5 and a proof of soundness in section 6. Speci.cally, \nwe have addressed our goals: 1. Soundness: our three theorems show that after complet\u00ading the conf-ack \nprotocol, a perceived cycle is a true cycle and can be safely collected. 2. Completeness: our operational \nsemantics show that all dead actors are eventually collected, allowing the system to terminate when all \nactors have been collected. 3. Concurrency: our technique is entirely message-based, and does not require \nclocks, timestamps, shared memory, locking, read/write barriers, or any particular threading or scheduling \nsystem.  The soundness result has been proven for MAC in the many\u00adcore setting. To transfer to the distributed \nsetting, we will need to address the following issues: 1) causal messaging across distributed nodes, \n2) potential message loss, 3) po\u00adtential node failure. We plan to fully address these issues in further \nwork, but we argue here that MAC can be adapted to this setting. Namely, for (1) nodes can be structured \nas a tree, which can ef.ciently provide communication paths that are always causal. For (2), we can use \na guaranteed delivery network protocol paired with a buffer of sent messages that can be used to replay \nmessages when a connection is dropped and reestablished. This buffer can be reset by lazy, asynchron\u00adous \nacknowledgement of receipt of a batch of messages by a node. For (3), Erlang-like actor monitors can \nbe coupled with periodic reference renewal to allow noti.cation of fail\u00adure and eventual consistency \nof actor reference counts. We plan to investigate the application of MAC in a dis\u00adtributed environment. \nSpeci.cally, we are interested in ef.\u00ad  Test CD Attempts Cycles Collected APP Msgs BLK Msgs UNBLK Msgs \nOther MAC Msgs Message handling 1 1 3,000,000 3 1 11 Actor creation 9 1 1,048,575 707,492 183,205 524,288 \nMailbox performance 1 1 20,000,000 21 0 66 Mixed scenario 49 20 50,005,124 50,004,818 49,999,898 10,372 \n Table 5: Cycle detector and message statistics for tests for MAC, force CD cient causal messaging across \ndistributed nodes, improving distributed cycle detection by using multiple local cycle de\u00adtectors, and \nrobustness in the presence of message, actor, or node failure. We also plan to extend this work to collect \npassive ob\u00adjects that are shared across actor heaps as well as separate collection of each heap. When \nan actor .nishes handling an application message (whether or not additional messages are pending on the \nqueue), that actor has no stack. By extending MAC so that it uses a message-based system for passive \nob\u00adject collection, the point at which an actor .nishes handling an application message establishes a \nsafe-point without in\u00adstrumentation. This will allow local and distributed passive object garbage collection \nwithout read or write barriers. Acknowledgements We are grateful to the anonymous referees for their \npertinent and helpful feedback. We would like to thank the SLURP reading group at Imperial College London \nfor their extensive feedback, as well as the anonymous referees at ECOOP and ESOP for their constructive \ncomments on earlier versions of this paper. We would also like to thank Harry Richardson and Andrew McNeil \nfor their helpful discussions of imple\u00admentation considerations. References [1] G. Agha and C. Hewitt. \nConcurrent programming using actors: Exploiting large-scale parallelism. In LNCS 1985. [2] G. Agha. Actors: \nA Model of Concurrent Computa\u00adtion in Distributed Systems. MIT Press, 1986. [3] J. Armstrong. A history \nof Erlang. In HOPL III, 2007. [4] P. Haller and M. Odersky. Scala actors: Unifying thread-based and event-based \nprogramming. In TCS 2008. [5] T. Van Cutsem. Ambient References: Object Desig\u00adnation in Mobile Ad hoc \nNetworks. PhD thesis, Vrije Universiteit Brussel, 2008. [6] C. Varela, G. Agha, Wei-Jen Wang, et al. \nThe SALSA Programming Language 2.0.0alpha Release Tutorial. Rensselaer Polytechnic Institute, 2009. [7] \nS. Srinivasan and A. Mycroft. Kilim: Isolation-Typed Actors for Java (A Million Actors, Safe Zero-Copy \nCommunication). In ECOOP 2008. [8] D. Kafura, D. Washabaugh, J. Nelson. Garbage col\u00adlection of actors. \nIn OOPSLA 1990. [9] A. Vardhan, G. Agha. Using passive object garbage collection algorithms for garbage \ncollection of active objects. In ISMM 2002 [10] Wei-Jen Wang, et al. Actor Garbage Collection Using Vertex-Preserving \nActor-to-Object Graph Transform\u00adations. In GPC 2010. [11] S. Tasharo., P. Dinges, R. Johnson. Why Do \nScala Developers Mix the Actor Model with Other Concur\u00adrency Models? In ECOOP 2013. [12] http://actor-applications.cs.illinois. \nedu/ [13] http://www.gotw.ca/publications/ concurrency-ddj.htm [14] http://osl.cs.uiuc.edu/af/ [15] C. \nVarela and G. Agha. Programming Dynamic\u00adally Recon.gurable Open Systems with SALSA. In OOPSLA 2001. [16] \nWei-Jen Wang and C. Varela. Distributed Garbage Collection for Mobile Actor Systems: The Pseudo Root \nApproach. In GPC 2006. [17] Wei-Jen Wang. Distributed Garbage Collection for Large-Scale Mobile Actor \nSystems. PhD thesis, Rensselaer Polytechnic Institute, 2006. [18] Wei-Jen Wang. Conservative snapshot-based \nactor garbage collection for distributed mobile actor sys\u00adtems. In Telecommunication Systems, 2011. [19] \nH. Baker. Minimizing reference count updating with deferred and anchored pointers for functional data \nstructures. In ACM SIGPLAN, Sept. 1994. [20] Y. Levanoni, E. Petrank. An On-the-Fly Reference-Counting \nGarbage Collector for Java. In OOPSLA 2001. [21] M. Shapiro, D. Plainfoss\u00e9. A Survey of Distributed Garbage \nCollection Techniques. In IWMM 1995. [22] F. Dehne and R. Lins. Distributed Cyclic Reference Counting. \nIn LNCS 1994. [23] D. Bacon and V.T. Rajan. Concurrent Cycle Collec\u00adtion in Reference Counted Systems. \nIn ECOOP 2001. [24] L. Moreau and J. Duprat. A Construction of Distrib\u00aduted Reference Counting. In Acta \nInformatica 2001. [25] L. Moreau, P. Dickman, and R. Jones. Birrell s Dis\u00adtributed Reference Listing \nRevisited. In TOPLAS 2005. [26] R. Jones and R. Lins. Cyclic Weighted Reference Counting Without Delay. \nIn PARLE 1993. [27] R. Lins. Lazy Cyclic Reference Counting. In JUCS 2003. [28] A. Formiga and R. Lins. \nA New Architecture for Concurrent Lazy Cyclic Reference Counting on Multi-Processor Systems. In JUCS \n2007. [29] http://libcppa.blogspot.co.uk/search/ label/benchmark [30] https://github.com/Neverlord/ cppa-benchmarks \nA. Lemmas Lemma 1. A well-formed con.guration progresses to a well-formed con.guration. cf g0 . cf g \n' . W F (cf g ' )  W F (cf g) . cf g . cf g ' . W F (cf g ' )  Proof. By case analysis on the rewrite \nsteps that can be ap\u00adplied to a con.guration. Applying any step results in another well-formed con.guration. \nLemma 2. A message in a queue implies the message was posted. ' Qt (.) = q.msg.q . .t ' = t.P ostt% (., \nmsg) H H Proof. By induction on t. The last step either appended msg to the queue, establishing the property, \nor msg was already present in the queue, in which case we apply the inductive hypothesis. Lemma 3. Consuming \na message implies the message was posted. C onsumet (., msg) . .t ' < t.P ostt% (., msg) H H Proof. Consuming \na message at time t requires that Qt (.) = H ' msg.q, and thus by lemma 2, .t = t.P ostt% (., msg). H \nLemma 4. Messages are consumed in FIFO order. P ostt (., msg) . P ostt+k(., msg ' ). H H C onsumet% (., \nmsg ' ) . H '' '' .t .t < t < t ' .C onsumet%% (., msg) H Proof. By induction on t. Given that msg was \nposted be\u00ad ' fore msg ', and, using lemma 3, msg was consumed after ' msg was posted, we begin with the \ncon.guration at time t, when msg was posted. The last step consumed msg '. The previous step either consumed \nmsg or msg was not on the queue. If msg was not on the queue, we apply the inductive hypothesis. Lemma \n5. Actors that are blocked and have not posted unblock have not changed their view of their topology. \nT opot (.) .3 ..t ' = t.\u00acP ostt% (., UNB(.)) . H H T opot (.) = T opot% (.) H H Proof. By case analysis. \nWe begin with a blocked actor at time t. No step can be made in which UNB is sent, and the actor s view \nof its topology does not change in any step in which UNB is not sent. Lemma 6. Actors that have posted \nblock and have not pos\u00adted unblock have not changed their view of their topology. P ostt (., BLK (., \n., .)). H .t ' % = t.\u00acP ostt(., UNB(.)) . H .t '' .t = t '' %% = t ' .T opot (.) = T opot(.) H H Proof. \nBy case analysis. Given lemma 5, only one step (un\u00adblocked actors with empty queues) sets an actor s \nblocked state to true, and that step sends BLK . Lemma 7. Actors in P T have blocked and have not un\u00adblocked. \n. . P T t . H .t ' = t.C onsumet% (., BLK (., ., .)). H .t '' = t '' .t ' = t.\u00acC onsumet%% (., UNB(.)). \nH P T t%% (.) = (., .) H Proof. By induction on t. The last step could have consumed BLK for the actor, \nestablishing the property. It could not have consumed UNB, since that would remove the actor from P T \n. Any other step leaves P T unchanged, and we apply the inductive hypothesis. Lemma 8. Actors that are \nsent CNF must be members of a perceived cycle that has just been detected and vice versa. P ostt (., \nCNF (t)) . . . P C t (t) . N ewP C t (t ) H HH Proof. By case analysis. Only one step sends CNF , and \nthat step detects a new perceived cycle and sends CNF only to the members of that cycle. Lemma 9. Actors \nthat send ACK must have consumed CNF and vice versa. P ostt (., ACK (., t )) . C onsumet (., CNF (t)) \nH H Proof. By case analysis. Only one step posts ACK , and that step consumes CNF for the same token. \nLemma 10. Con.rming actors consumed CNF earlier. C onsumet (., ACK (., t )) . H .t ' % = t.C onsumet(., \nCNF (t)) H Proof. If C onsumet (., ACK (., t )) then by lemma 3 H .t ' .P ostt% (., ACK (., t )), and \nthus by lemma 9 H .t '' = t.C onsumet%% (., CNF (t)). H Lemma 11. The CD consumed ACK for every con.rmed \nactor in a P C . P C t (t )(.) . .t ' = t.C onsumet% (., ACK (., t )) H H  Proof. By case analysis. \nOnly one step maps . to true in (F2) .t ' .t2 = t ' = t.\u00acC onsumet% (., UNB(.)) H ' ' P C (t), and that \nstep consumes ACK (., t ). (F3) .t .t2 = t = t.P T t% (.) = (., .) H From (F1), (F2) and lemma 3, we \nget: Lemma 12. A P C is uniquely identi.ed by its token. % 1 (G1) .t1 = t2.P ostt H (., BLK (., ., .))N \newP C t (t ) . N ewP C t H H (t ) . t = t ' % ' ' (G2) .t .t1 = t = t4.\u00acP ostt H (., UNB(.)) Proof. \nBy case analysis. Only one step creates a new PC, and From (G1), (G2) and lemma 6, we get: % ' ' = t4.T \nopot H (H) .t (.) = T opot H 1 that step uses a unique token. Any PC identi.ed by a given .t1 = t (.) \n From (F3), (G1) and (H), we get: token is the same PC, created in the same step. ' ' (I) .t .t2 = t \n= t4.(P T t% (.), true) = T opot% (.) H H B. Theorems If T opot H 3 (.) = T rueT opot H 3 (.), one of \nthe following must be true: Theorem 1 (A PC is truly closed if the CD s view of the (J1) T opot H Given \na con.guration cf g = (.) .1 = T rueT opot H 3 (.) .1 3 topology is the true topology). Given the reference \ncount invariant, this is only possible (_, (P C, P T , _), _): .. . P C (t).(P T (.), true) = T rueT \nopo(., cf g) . if Qt H 3 (.) 3 INC or Qt H 3 (.) 3 DEC . If either of these were true, by lemma 8 and \nlemma 4, INC or DEC would be T rulyC losed(dom(P C (t), cf g)) consumed by . before CNF (t ), which \nwould mean .t ' .t1 = % Proof. Assume that: t ' (., UNB(.)), which we know from to be = t4.P ostt H \n (A) C losed(dom(P C (t)), P T ) untrue from (G2). Therefore (J1) cannot be true. Expanding the de.nition \nof closed, we get: (J2) T opot H 3 (.) .2 = T rueT opot H 3 (.) .2 .. . P C (t ) : .. ' .. . P T (. ' \n) .2. . ' . P C (t). By case analysis, . must unblock to change T opot H 3 (.) .2, (B) P T (.) .1 = \n|{. ' | . ' .P C (t), . .P T (. ' ) .2}|Given .. . P T (t).(P T (.), true) = T rueT opo(., cf g), which \nwould mean .t ' .t1 = t ' = t4,..P ostt% (., UNB(.)), H which we know to be untrue from (G2). Therefore \n(J2) cannot be true. we substitute T rueT opo(., cf g) for P T (.) in (B), and get: (C) .. . P C (t ) \n: .. ' .. . T rueT opo(. ' , cf g) .2. . ' . (J3) T opot H 3 (.) .3 = T rueT opot H 3 (.) .3 P C (t) \n. T rueT opo(., cf g) .1 = |{. ' | . ' . P C (t ) . . . From theorem 2, we know T rueT opo(. ' , cf \ng) .2}| Given (A) and (C), we arrive at the de.nition of T opot H 3 (.) .3. If \u00acT rueT opot H then Qt \nH 3 (.) = 3 (.) .3, CNF (_)*. If this were true, by lemma 8 and lemma 4, mes- T rulyC losed(dom(P C \n(t)), cf g). Theorem 2 (A con.rmed actor implies the CD s view of its topology, the actor s view of its \ntopology, and its true topology agreed when the PC was detected). P C t (t)(.) . H sages other than \nCNF (_) would be consumed by . before CNF (t), which would mean .t ' .t1 = t ' = t4,..P ostt% (., UNB(.)), \nH which we know from to be untrue from (G2). Therefore (J3) cannot be true. From (J1), (J2) and (J3) \nwe get: (K) T opot H 3 (.) = T rueT opot H 3 (.) .t3 = t.N ewP C t H 3 (t) . (P T t H 3 (.), true) = \nT opot H 3 (.) = T rueT opot H 3 (.) From (C), (D), (I) and (K), we establish = t.N ewP C t H 3 (t ) \n. (P T t H 3 (.), true) = T opot H 3 (.) = Proof. Given P C t (t)(.) and lemma 11, we get: H .t3 (A) \n.t5 = t.C onsumet H 5 (., ACK (., t )) T rueT opot H 3 (.). From (A) and lemma 10, we get: (B) .t4 = \nt5.C onsumet H 4 (., CNF (t )) From (A) and (B) and lemma 3, we get: Theorem 3 (A fully con.rmed cycle \nis a true cycle). .. . P C t (t ).P C t (t)(.) . T rulyC losedt (dom(P C t (t ))) HH HH (C) .t3 = t4.P \nostt H 3 (., CNF (t)) Proof. From theorem 2 and lemma 12, we get: From (C) and lemma 8, we get: (A1) \n.t3.N ewP C t H 3 (t) (D) . . P C t H 3 (t) . N ewP C t H 3 (t ) (A2) .. . P C t H 3 (t ).(P T t H T \nopot H 3 (.), true) = 3 (.) = From (D) we get: (E) . . P T t H From (E) and lemma 7 we get: (F1) .t2 \n= t3.C onsumet H 2 (., BLK (., ., .)) T rueT opot H 3 (.) From (A1), (A2) and theorem 1, we establish \nT rulyC losedt (dom(P C t (t))). H H  \n\t\t\t", "proc_id": "2509136", "abstract": "<p>Disposal of dead actors in actor-model languages is as important as disposal of unreachable objects in object-oriented languages. In current practice, programmers are required to either manually terminate actors, or they have to rely on garbage collection systems that monitor actor mutation through write barriers, thread coordination through locks etc. These techniques, however, prevent the collector from being fully concurrent.</p> <p>We developed a protocol that allows garbage collection to run fully concurrently with all actors. The main challenges in concurrent garbage collection is the detection of cycles of sleeping actors in the actors graph, in the presence of concurrent mutation of this graph. Our protocol is solely built on message passing: it uses deferred direct reference counting, a dedicated actor for the detection of (cyclic) garbage, and a confirmation protocol (to deal with the mutation of the actor graph).</p> <p>We present our ideas informally through an example, and then present a formal model, prove soundness and argue completeness. We have implemented the protocol as part of a runtime library. As a preliminary performance evaluation, we discuss the performance of our approach as currently used at a financial institution, and use four benchmarks from the literature to compare our approach with other actor-model systems. These preliminary results indicate that the overhead of our approach is small.</p>", "authors": [{"name": "Sylvan Clebsch", "author_profile_id": "83358632257", "affiliation": "Imperial College, London, London, United Kingdom", "person_id": "P4290411", "email_address": "sc5511@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Sophia Drossopoulou", "author_profile_id": "81100331741", "affiliation": "Imperial College, London, London, United Kingdom", "person_id": "P4290412", "email_address": "scd@doc.ic.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/2509136.2509557", "year": "2013", "article_id": "2509557", "conference": "OOPSLA", "title": "Fully concurrent garbage collection of actors on many-core machines", "url": "http://dl.acm.org/citation.cfm?id=2509557"}