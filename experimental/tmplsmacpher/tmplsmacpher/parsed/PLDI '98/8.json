{"article_publication_date": "05-01-1998", "fulltext": "\n Using Static Single Assignment Form to Improve Flow-Insensitive Pointer Analysis * Rebecca Hasti and \nSusan Horwitz Computer Sciences Department, University of Wisconsin-Madison 1210 West Dayton Street, \nMadison, WI 53706 USA Electronic mail: {hasti, horwitz}@cs.wisc.edu Abstract A pointer-analysis algorithm \ncan be either flow-sensitive or flow-insensitive. While flow-sensitive analysis usually pro-vides more \nprecise information, it is also usually consider-ably more costly in terms of time and space. The main \ncontribution of this paper is the presentation of another op-tion in the form of an algorithm that can \nbe tuned to provide a range of results that fall between the results of flow-insensitive and flow-sensitive \nanalysis. The algorithm combines a flow-insensitive pointer analysis with static sin-gle assignment (SSA) \nform and uses an iterative process to obtain progressively better results. 1 Introduction Having information \nabout what pointer variables may point to is very useful (and often necessary) when performing many kinds \nof program analyses. Obviously, the better (or more precise) the information, the more useful the informa- \ntion is. A points-to analysis that takes into account the order in which statements may be executed (i.e., \na flow-sensitive analysis) generally provides more precise information than a flow-insensitive analysis; \nhowever, flow-sensitive analyses are considerably more costly in terms of time and/or space than flow-insensitive \nanalyses. Thus, the options for pointer anal-ysis one is generally presented with are: (1) flow-insensitive \n-faster but less precise; and (2) flow-sensitive - more precise but time/space consuming. The main contribution \nof this paper is the presentation of another option in the form of an algorithm that can be tuned to \nprovide a range of results. The algorithm combines a flow-insensitive pointer analysis with static single \nassignment (SSA) form and uses an itera- tive process to obtain progressively better results along the \nspectrum from flow-insensitive to flow-sensitive. The par-ticular flow-insensitive analysis used will \naffect the precision of the final results. Whether it is possible to obtain results as precise as those \nobtained by a flow-sensitive analysis is *This work was supported in part by the National Science Foun- \ndation under grant CCR-9625656, and by the Army Research Office under grant DAAH04-85-1-0482. Permiwion \nto make digital or hard copies of all or part of thfo wcrk for personal M classroom uw is granted without \n1-s provided that copies are not msda or distributed for profit n commercial advan-tage and that copies \nbear this notice and the full citstion on the tint page. 70 copy otherwise. to republish, to pest on \nsawers or to redistribute to lists, requires prior specific permission and/or a fee. SIGPIAN 96 Montrsal, \nCanada @ 1996 ACM 0-69791~967.4/96/0006...85.00 an open question. 1.1 Flow-sensitive vs. flow-insensitive \nanalysis Program analyses may be categorized as either flow-sensitive or flow-insensitive. A flow-sensitive \nanalysis takes into ac-count the order in which the statements in the program may be executed; a flow-insensitive \nanalysis does not. In other words, in a flow-sensitive analysis the program is handled as a sequence \nof statements while in a flow-insensitive analysis it is handled as a set of statements. Thus, a flow-sensitive \nanalysis produces results at the statement level (e.g., it may discover different properties of a variable \np at each state-ment) whereas a flow-insensitive analysis produces results at the program level (e.g., \nit can only discover properties of a variable p that hold for the entire program). (Analyses can be further \ncategorized as context-sensitive or context-insensitive. A context-sensitive analysis takes into account \nthe fact that a function must return to the site of the most recent call; a context-insensitive analysis \npropagates information from a call site, through the called function, and back to all call sites. In \nthis paper, all analyses are assumed to be context-insensitive.) One way to think about flow-insensitive \nanalysis is in terms of a variation on the standard dataflow framework [Kil73]. The standard framework \nincludes: 1. a lattice of dataflow facts, 2. a set of monotonic dataflow functions, 3. a control flow \ngraph (CFG), 4. a mapping that associates one dataflow function with each graph node (we use f,, to \ndenote the function mapped to node n).  The ideal goal of a flow-sensitive analysis is to find the \nmeet-over-all-paths solution to the dataflow problem [Kil73]. When this is not feasible (e.g., when the \nfunctions are not distributive), an acceptable goal is to find the greatest so-lution (under the lattice \nordering) to the following set of equations (one equation for each CFG node n): n.fact = meprede~ssors(n) \nfm(m fact) (l) (This equation is for a forward dataflow problem. The equation for a backward datailow \nproblem is similar, with successors used in place of predecessors.) Flow-insensitive analysis uses the \nsame framework, ex-cept that it uses a version of the CFG in which there is a=1 a0 = 1 b=2 b. = 2 c=a+b \nco = ao + bo if (. . .) if (. . .) then a = 3 then al = 3 u-2 = $(Ul,UO) d=b do = bo c=u+b Cl =a2 +bo \nprint(c) print(q) (a) Original (b) SSA Form Figure 1: Example for constant propagation an edge from each \nnode to every other node (including it-self) [Hor97]. Again, the ideal goal of the analysis is to find \nthe meet-over-all-paths solution (in the modified CFG), and when this is not feasible, to find the greatest \nsolution to the set of equations: n.fact = manod:(cFG) fTrdm*fact) (Note that this framework is useful \nfor understanding flow-insensitive analysis; actual algorithms do not involve creat-ing this modified \nCFG or directly solving these equations.) For the rest of this paper, when we refer to a flow-sensitive \nanalysis, we mean an analysis that computes the greatest solution to the set of equations (1). Similarly, \nwhen we refer to a flow-insensitive analysis, we mean an analy-sis that computes the greatest solution \nto the set of equa- tions (2). Flow-sensitive analyses generally take more time and/or space than their \nflow-insensitive counterparts; however, the results are usually more precise. For example, consider constant \npropagation on the code fragment in Figure l(a). A flow-sensitive constant-propagation analysis determines \nthat: l At (l), a = 1, b = 2, c = 3 l At (2), b = 2, c = 3, cl = 2 . At (3), b = 2, d = 2 and a flow-insensitive \nconstant-propagation analysis deter-mines that: . b=2,d=2 Note that the results of the flow-insensitive \nanalysis actually mean that at every point in the program, b is either unini-tialized or has the value \n2, and similarly for d. This kind of information is sufficient for most uses of the results of con- stant \npropagation (e.g., replacing uses of constant variables with their values). Also note that, although \nthe results of flow-insensitive analysis are not as precise as the results of flow-sensitive analysis, \nthey do provide some useful informa- tion.  1.2 Using SSA form to improve flow-insensitive analysis \nStatic Single Assignment (SSA) form [CFR+Sl] is a pro- gram representation in which variables are renamed \n(via subscripting) and new definitions inserted to ensure that: When we say that some fact is true at \na particular point, we mean that the fact is true immediately before that point. 1. Each variable xi \nhas exactly one definition site. 2. Each use of a variable zi is reached by exactly one definition. \n The new definitions (called 4 nodes) are inserted in the CFG at those places reached by two (or more) \ndefinitions of a variable z (the join points) and are of the form: Figure l(b) shows the SSA form for \nthe example from Figure l(a). Notice that once the program has been put into SSA form, flow-sensitive \nand flow-insensitive constant propagation identify the same instances of constant vari-ables in the code. \nFor example, both a flow-sensitive and a flow-insensitive analysis on Figure l(b) produce the follow- \ning results (the results are shown in flow-sensitive format; the results from flow-insensitive analysis \nhold not just at the point given, but at every point in the program): l At (l), a0 = 1, b. = 2, co = \n3 l At (2), ae = 1, bo = 2, co = 3, al = 3, do = 2 . At (3), a,, = 1, bo = 2, co = 3, 01 = 3, do = 2 \nIn other words, it does not matter whether the constant propagation analysis done on the SSA form is \nflow-sensitive or flow-insensitive. Thus, if the time and space required to translate a program into \nSSA form and then perform a flow- insensitive analysis are less than the time and space required to do \na flow-sensitive analysis, this approach is a win.  1.3 Points-to analysis The presence of pointers \nin a program makes it necessary to have information about what pointer variables may be pointing to in \norder to do many program analyses (such as constant propagation) correctly. Thus, a points-to analysis \nmust first be done on a program before any further anal-yses are done. (There are two kinds of points-to \nanalyses, may and must. Whenever we use points-to we mean may-point-to .) This points-to analysis may \nbe flow-sensitive or flow-insensitive. For example, consider the code fragment in Figure 2(a). A flow-sensitive \npoints-to analysis determines the fol-lowing points-to information at (i.e., immediately before) each \nprogram point (p + a means that p might point to a, p + {a, b} means that p might point to a or to b): \nPoints-to information u-kw a-+w,p+a u+x, p-is u-,x, p-ku, c-2 u-ix, p-fa, c--)x a-+{x, Yh P-)% c--)2 \n a --t tx, Y,), P + b, c -+ 2 a + lx, ~1, P + b, c + x, d + (2, Y) a -+ (2, ~1, P + b, c + 2, d + (2, \nII), b+.z A flow-insensitive points-to analysis determines the fol-lowing information: a=&#38;w a0 \n= &#38;WO p=&#38;a PO= &#38;a0 a=&#38;x al = &#38;x0 c = *p co = *po if (. . .) if (. . .) then *p=&#38;y \nthen * po = &#38;yo p=&#38;b PI = &#38;bo d=a do = al *p=&#38;z *p1 = &#38;zo print(*a) print(*ai) (a) \nOriginal (b) Naive SSA Figure 2: An example with pointers and its naive translation to SSA form As before, \nthe flow-insensitive analysis is not as precise as the flow-sensitive analysis, but the information it \ndoes pro- vide is safe (i.e., the points-to sets computed by the flow-insensitive analysis are always \nsupersets of the sets com-puted by the flow-sensitive analysis). Given the advantages of SSA form discussed \nabove in Section 1.2, it is natural to ask whether the approach of translating the program to SSA form \nand then using a flow- insensitive points-to analysis on the SSA form will achieve the same results as \na flow-sensitive analysis on the original program. This approach seems reasonable since each vari- able \nzk in the SSA form of the program corresponds only to certain instances of the variable x in the original \nprogram. Therefore, the whole-program results of the flow-insensitive analysis of the SSA form could \nbe mapped to CFG node specific results in the original program. Unfortunately, this approach will not \nwork. The basic problem is that it is not possible to translate a program that contains pointers into \nSSA form without first doing some pointer analysis. For example, Figure 2(b) shows a naive translation \nto SSA form of the program shown in Figure 2(a). There are several problems with the naive translation. \nOne problem is how the address-of operator (&#38;) is handled. For example, in Figure 2(a) at line (2), \npo is given the address of ae. Clearly this is incorrect since it leads to the incorrect inference that \nthe dereference of pe at line (4) is a use of ao, when in fact it is a use of al, defined at line (3). \nAnother problem is that when a variable is defined indi-rectly via a pointer dereference, that definition \nis not taken into account in (naively) converting the program to SSA form. For example, at (6) the assignment \nto *p is a def-inition of a (since at that point p contains the address of a). However, since variable \na does not appear textually on the left-hand side of the assignment, the naive conversion to SSA form \ndoes not take this into account. The result is that the program in Figure 2(b) violates the first prop-erty \nof SSA form: that each variable zi have exactly one definition site. Furthermore, because there is an \n(indirect) assignment at line (6), the use of al at line (8) is reached by two definitions, thus violating \nthe second property of SSA form. Nevertheless, we believe that SSA form can be used to improve the results \nof flow-insensitive pointer analysis. An algorithm based on this idea is described below. The al-gorithm \nis iterative: it starts with purely flow-insensitive points-to information, and on each iteration it \nproduces bet-ter information (i.e., smaller points-to sets). We conjecture that when the algorithm reaches \na fixed point (the last iter- ation produces the same points-to sets as the previous itera-tion) the \nfinal results mapped back to the original program will be the same as the results produced by a single \nrun of a flow-sensitive pointer analysis algorithm. Empirical studies are needed to determine how the \ntime and space requirements of the iterative algorithm compare with those of a flow-sensitive algorithm. \nHowever, since the results of every iteration are safe (the points-to sets com-puted after each iteration \nare supersets of the actual points-to sets) the algorithm can also be safely terminated before a fixed \npoint is reached (for example, after a fixed number of iterations, or when two consecutive iterations \nproduce results that are sufficiently similar). This means that the algorithm can be tuned to produce \nresults that fall along the spectrum from flow-insensitive to flow-sensitive analysis. 2 Algorithm description \nThe main insight behind the algorithm is that we can use the results of (flow-insensitive) pointer analysis \nto normalize a program, producing an intermediate form that has two properties: 1. There are no pointer \ndereferences. 2. The points-to sets of all variables in the intermediate form are safe approximations \nto (i.e., are supersets of) the points-to sets of all the variables in the original program.  Property \n1 means that the intermediate form can be trans- lated into SSA form. Property 2 means that flow-insensitive \npointer analysis on the SSA form produces results that are valid for the original program. When flow-insensitive \npointer analysis is done on the SSA form, the results are in terms of the SSA variables. However, each \nSSA variable xi corresponds to certain in-stances of the variable z in the original program. This means \nthat the points-to set for each xi can be mapped back to those instances of x in the original program \nthat correspond to z;. Note that in doing this we are producing points-to results that are no longer \nflow-insensitive, i.e., a variable z may now have different points-to sets at different places in the \nprogram. This results in points-to sets that are often more precise than the sets produced by the initial \nanalysis (done on the original non-SSA form of the program). These improved points-to sets can then be \nused to (re)normalize the program, producing a new intermediate form. If the new intermediate form is \ndifferent from the previous one, the pro- cess of converting the intermediate form to SSA form, doing \npointer analysis, and renormalizing can be repeated until a fixed point is reached (no change is made \nto the intermediate form). Figure 3 gives an overview of the algorithm. Initially, we will assume that \nthe input program consists of a single func-tion with no function calls. In Section 2.1 we describe how \nto handle programs with multiple functions and functions calls. The algorithm first applies flow-insensitive \npointer analy-sis to the CFG, then uses the results to annotate each pointer dereference in the CFG with \nits points-to set. Only pointer dereferences are annotated because the places where we are ultimately \ninterested in knowing about points-to informa-tion are the places where pointers are dereferenced. Note \nthat the CFG itself is never changed, except for the anno-tations. Given: a CFG G Do flow-insensitive \npointer analysis on G Annotate the dereferences in G Repeat: Create the intermediate form (IM) from G \nConvert IM to SSA form creating IMSSA Do flow-insensitive pointer analysis on IMSSA Update the annotations \nin G using IMSSA and the pointer analysis results until there are no changes in the annotations Figure \n3: An overview of the algorithm Example: Figure 4(a) gives an example in which each pointer dereference \nhas been annotated using the results of flow-insensitive points-to analysis. The annotations are shown \nto the right of each node containing a pointer deref-erence. For comparison, note that a flow-sensitive \npoints-to analysis would determine that at the dereference oft, t + s and at the dereference of s, s \n+ q. 0 The main loop of the algorithm begins by using the an-notated CFG to create the (normalized) intermediate \nform (IM). In the intermediate form, each pointer dereference is replaced with its points-to set. If \nthe points-to set con-tains more than one element, the single original statement is replaced with a multiway \nbranch in which the kth arm of the branch contains a copy of the original statement with the pointer \ndereference replaced by the kth element of the points-to set. If the points-to set contains only one \nelement, then rather than creating a branch, the pointer dereference is just replaced with the element \nin the points-to set. The intermediate form is then converted to SSA form in two phases. In the first \nphase, conversion to SSA form is done as usual (4 nodes are added and variables are renamed via subscripting) \nwith the exception that the operands of the address-of operator are not given subscripts, i.e., an assign- \nment of the form p = &#38;z is converted to pi = &#38;e; all other (non-address-of) uses and definitions \nof x are subscripted. In the second phase, each assignment of the form pi = &#38;z is converted to a \nmultiway branch. The number of arms of the branch is the number of subscripts that z has in the SSA form. \nThe kth arm of the branch is of the form pi = &#38;zk. (As in the translation to intermediate form, if \nx only has one subscript, we just replace &#38;x with &#38;x0.) - The uurnose of the second chase is \nto handle the first problem wiih translating a program with pointers to SSA form discussed in Section \n1.3. Since a pointer that is given the address of x could be pointing to any of the SSA versions of z, \nusing all possible versions in place of the address-of ex- pression is a safe translation. Note that \nbecause we have replaced each pointer dereference with its points-to set we no longer have the problems \nmentioned in Section 1.3 that arise from the indirect definition of variables through pointer dereferences. \nNote also that after the second phase, the in- termediate form may not be strictly in SSA form because \nthe transformation of pi = &#38;x may result in multiple as- signments to pi. However, this will not \naffect the pointer analysis (which is the only way in which we are using this form). An equivalent way \nto handle p; = &#38;x would be to convert it as described, followed by inserting a 4 node, and renaming \nthe pi s in the arms of the branch. In either case, the net result is that the definition of p that is \nlive imme- diately after the transformation of pi = &#38;x has all SSA versions of 2 in its points-to \nset. Example: Figure 4(b) shows the intermediate form for Figure 4(a). The intermediate form after the \nfirst phase in the conversion to SSA form is shown in Figure 4(c) and Figure 4(d) shows the final SSA \nform. 0 The next step is to do flow-insensitive points-to analy-sis on the SSA version of the intermediate \nform (which we denote by IMs&#38;. The results of this pointer analysis are then used to update the annotations \nin the CFG as follows: For each CFG node N with a pointer dereference *p: Find the corresponding node \nN in IMSSA. (If the node has been converted to a multiway branch con- struct, the branch node is the \ncorresponding node.) Recall that all pointer dereferences were replaced with their corresponding points-to \nsets during the creation of the intermediate form and thus the dereferenced variable p itself is not \npresent in N . Determine the SSA number k that p would have had at node N if it appeared there. Use the \npoints-to set for pk to update the annotation of *p in node N of the CFG. The updating of the annotations \ncompletes one iteration of the algorithm. Example: Points-to analysis on IMSSA(Figure 4(d)) de-termines \nthat: so -+ p Sl -+ q to + s Note that because of the way the address-of operator is han- dled, if xi \nis in pk s points-to set, then zcj iS in pk s points-to set for all j E {0,1,2,. . . ,maxSSA-#(z)}. Thus, \nthe points-to sets can be represented in canonical form by using variables without subscripts. The node \nin IMSsAthat corresponds to the node *s = 2 in the original CFG (Figure 4(a)) is the branch node that \nhas pl = 2 and q1 = 2 as its arms. The SSA number that s would have been given if it had appeared in \nthat branch node is 1. Because the analysis has determined that sr + q, the node w = 2 in the original \nCFG is annotated with s + {q}. Figure 5(a) shows the original program with updated annotations. 0 Once \nthe annotations have been updated, the process of creating an intermediate form, converting it to SSA \nform, doing pointer analysis, and obtaining better annotations can be repeated. Notice that if the annotations \nare the same for two different iterations, then the intermediate forms created using the annotations \nwill be identical. Thus, when no an- notations are changed during the updating stage of the algo- rithm \n(i.e., the annotations are the same for two successive iterations), the algorithm has reached a fixed \npoint (i.e., no new pointer information can be discovered) and the algo- rithm halts. Since the results \nof every iteration are safe, the algorithm may also be halted after a user-specified number of iterations \n(just after updating the annotations), resulting in pointer information that lies somewhere in between \nthe results from a purely flow-insensitive analysis and the results had the algorithm been run to completion. \nExample: Figure 5(a) shows the CFG with its annota- tions updated using the results of the first iteration. \nFig- ures 5(b), (c), and (d) illustrate the start of the second iter- ation (the intermediate form and \nthe two-phase conversion to SSA form). Points-to analysis on Figure 5(d) determines that: so +p Sl + \nq to --f s Original CFG Intermediate (Normalized) Form (with annotations) (*t replaced by s, and *s \nreplaced by p and q) P.0 4=1 S.&#38;P 1lh.r 8 s = 2 S (P19) 0 (4 (b) To SSA Form Phase 1 Final SSA \nForm (4 nodes and subscripts added) (instances of &#38; handled) PO 0 qo= 1 so-&#38;P 52 q2=$( q o 9 \n,I e2 (4 (4 Figure 4: Translation to SSA form (first iteration) 101 Intermediate Form Annotated CFG \n(after 1 iteration) (*t replaced by s, and *s replaced by q) 0 p=op=o q=l 8 s=&#38;p t=&#38;s s=&#38;q \n8 (4 (b) Final SSA Form (subscripts added) (instances of &#38; handled) PO 0 To SSA Form Phase 1 4$1 \nso= &#38;PO PI  (4 (4 Figure 5: Translation to SSA form (second iteration) 102 int g, h; Given: a list \nL of CFGS Do flow-insensitive pointer analysis on L For each CFG G in L ;roid f0 h =g; g = 0; 1 void \nmain() { int i; g = 3; f0; i = g; if (. . .) g=4; else f0;1 Figure 6: A program with multiple functions \n This is the ssme as the information determined by the first iteration; thus, the CFG annotations do \nnot change and the algorithm terminates after the second iteration. Note that the final results are the \nssme ss the flow-sensitive analysis on the original program. 0 2.1 Handling multiple functions and function \ncalls A program that contains multiple functions can be repre- sented by a set of CFGs, one for each \nfunction. However, there are problems with translating functions represented this way to SSA form when \nthe program includes global variables. Figure 6 shows an example C program that il-lustrates two problems \nthat arise when global variables are present. One problem arises because a global variable may be used \nin a function before any definition of it appears in that function. For example, in the function f, global \nvariable g is used in the assignment to h before any assignment to g. The difficulty is in determining \nthe SSA number to give such a use. Another problem is that, because a function can modify a global variable, \na use of a global variable that appears after a call may not be reached by the definition before the \ncall. For example, in the function main, the value of g in the assignment to i is 0 (from the assignment \ng = 0 in f) and not 3 (from the assignment g = 3 before the call to f) and hence the g in i = g should \nnot have the same SSA number as the g in g = 3. One way that these problems could be handled is to pass \nthe global variables used or modified by a function as explicit parameters, and to treat the function \ncall as an assignment to all of the global variables modified by the function. A simpler approach is \nto create a supergraph from the set of CFGs. The supergraph contains all nodes and edges of the original \nCFGs, including a call node and a return-point node for each function call. Additional edges are added \nfrom each call node to the entry node of the called function, and from the exit node of the called function \nto the call s return-point node. Figure 7(a) shows the CFGs for the program in The term super-graph was \nfirst used by Eugene Myers in [MyeEl]. William Landi and Barbara Ryder [LR91] use the term interprocedu-ml \ncontml j%w graph (ICFG). Annotate the dereferences in G Create the supergraph S for L Repeat: Create \nthe intermediate form (IM) from S Convert IM to SSA form creating 1Mss~ Do flow-insensitive pointer analysis \non 1Mss~ For each CFG G in L Update the annotations in G using IMssAand the pointer analysis results; \n update calls through function pointers in S until there are no changes in the annotations Figure 8: \nThe algorithm updated to handle multiple CFGs Figure 6, and Figure 7(b) shows the corresponding super-graph. \nCalls through function pointers are represented using a multiway branch in which the kth arm of the branch \ncontains a call to the kth element of the function pointer s points-to set. This requires that pointer \nanalysis be done before the supergraph is created. Moreover, the points-to sets for function pointers \nmay change (i.e., get smaller) during it-eration, so the supergraph may need to be updated (by re-moving \nsome of the arms of the multi-way branches that represent calls through function pointers) when annotations \nare changed. Figure 8 gives the algorithm from Figure 3 updated to handle multiple CFGs. 2.2 Complexity \nEach iteration of our algorithm requires a transformation to SSA form and a flow-insensitive pointer \nanalysis. Although there exists a linear-time algorithm for placing 4 nodes [SG95], the renaming phase \nof translation to SSA form can take cubic time in the worst case. Thus, in the worst case, the time needed \nto completely translate a pro- gram into SSA form (including renaming) is cubic. More-over, the resulting \nprogram can be quadratic in the size of the original program. However, experimental evidence sug-gests \nthat both the time to translate and the size of the translated program are linear in practice [CFR+Sl] \n[CC95]. Andersen [And941 gives a flow-insensitive pointer-snal-ysis algorithm that computes the greatest \nfixed point of the set of equations (2) given in Section 1.1. Andersen s algorithm is cubic in the worst \ncase. Experimental evi-dence intended to evaluate the algorithm s performance in practice[SH97] is inconclusive: \non small programs (up to about 10,000 lines) its performance is very similar to that of Steensgaard s \n(essentially) linear-time algorithm[Ste96]; however, lines of code alone does not seem to be a good predictor \nof runtime (for example, one 6,000 line program required over 700 CPU seconds, while several 7,000 line \npro- grams required only 3 seconds). Note that our algorithm could make use of a fast algorithm like \nSteensgaard s. How-ever, Steensgaard s algorithm does not always compute the greatest fixed point of \nthe set of equations (2). Therefore, while the final result produced by our algorithm would still be \nan improvement over a purely flow-insensitive analysis, it is unlikely that it would be as good as a \nflow-sensitive analysis that computes the greatest fixed point of the set of equations (1). Original \nCFGs Corresponding Supergraph  Entermain Q g=3 Call f w Return point i=g 9 (4 (b) Figure 7: The CFGs \nand supergraph corresponding to the code in Figure 6 3 Related Work A program representation similar \nto the intermediate form described here was used by Cytron and Gershbein in [CG93], where they give an \nalgorithm for incrementally incorporat-ing points-to information into SSA form. Our intermediate representation \nis essentially an in-lined version of Cytron and Gershbein s IsAlias function. However, their algorithm \nrequires pre-computed may-alias information and incorpo-rates points-to information as needed into a \npartial SSA form while solving another dataflow problem (constant prop-agation, in their paper). Lapkowski \nand Hendren [LH96] also discuss the problems with SSA form in the presence of pointers. However, they \nabandon SSA form and develop instead a related analysis called SSA Numbering. Others have worked on improving \nthe precision of flow- insensitive alias analysis. In [BCCH94] Burke et al. develop an approach that \ninvolves using pre-computed kill informa-tion, although an empirical study by Hind and Pioli [HP971 does \nnot show it to be more precise in practice than a flow- insensitive analysis. Shapiro and Horwitz [SH97] \ngive an algorithm that can be tuned, so that its precision as well as worst-case time and space requirements \nrange from those of Steensgaard s (almost linear, less precise flow-insensitive) algorithm to those of \nAndersen s (cubic worst-case but more precise flow-insensitive) algorithm. 4 Conclusions We have presented \na new iterative points-to analysis al-gorithm that uses flow-insensitive pointer analysis, a nor- malized \nintermediate form, and translation to SSA form. The results after just one iteration are generally better \nthan those of a purely flow-insensitive analysis (on the original program) and if the algorithm is run \nuntil the fixed point is reached, the results may be as good as those of a flow- sensitive analysis. \nWe are currently working on implementations of our al-gorithm using the flow-insensitive pointer analyses \ndefined in [And94], [Ste96], and [SH97]. We plan to use the im-plementations to explore how our algorithm \ncompares to flow-sensitive points-to analysis in practice. 5 Acknowledgement Thanks to Charles Consel, \nwhose question about using SSA form in pointer analysis inspired this work. References [And941 L. 0. \nAndersen. Program Analysis and Special- ization for the C Programming Language. PhD thesis, DIKU, University \nof Copenhagen, May 1994. (DIKU report 94/19). [BCCH94] M. Burke, P. Carini, J.D. Choi, and M. Hind. Flow-insensitive \ninterprocedural alias analysis in the presence of pointers. In K. Pingali, U. Baner- jee, D. Galernter, \nA. Nicolau, and D. Padua, editors, Languages and Compilers for Parallel Computing: Proceedings of the \n7th International Workshop, volume 892 of Lecture Notes in Com- puter Science, pages 234-250, Ithaca, \nNY, Au- gust 1994. Springer-Verlag. [CC951 [CFR+Sl] [CG93] [Hor97] [HP971 [Ki173] [LH96] [LR91] [We811 \n[SG%] [SH97] [Ste96] C. Click and K.D. Cooper. Combining analy-ses, combining optimizations. ACM Transac-tions \non Programming Languages and Systems, 17(2):181-196, 1995. R. Cytron, J. Ferrante, B.K. Rosen, M.N. Weg-man, \nand F.K. Zadeck. Efficiently computing static single assignment form and the control dependence graph. \nACM Transactions on Pro-gramming Languages and Systems, 13(4):451-490, October 1991. R. Cytron and R. \nGershbein. Efficient ac-commodation of may-alias information in SSA form. SIGPLAN Conference on Programming \nLanguage Design and Implementation, 28(6):36- 45, June 1993. S. Horwitz. Precise flow-insensitive may-alias \n analysis is NP-hard. ACM Transactions on Pro- gramming Languages and Systems, 19(1):1-6, January 1997. \nM. Hind and A. Pioli. An empirical comparison of interprocedural pointer alias analyses. IBM Research \nReport RC 21058, IBM Research Divi-sion, December 1997. G.A. Kildall. A unified approach to global program \noptimization. In ACM Symposium on Principles of Programming Languages, pages 194-206, January 1973. \nC. Lapkowski and L.J. Hendren. Extended SSA numbering: Introducing SSA properties to lan-guages with \nmulti-level pointers. ACAPS Tech-nical Memo 102, School of Computer Science, McGill University, Mont&#38;J, \nCanada, April 1996. W. Landi and B.G. Ryder. Pointer induced aliss-ing: A problem classification. In \nACM Sympo-sium on Principles of Programming Languages, pages 93-103, 1991.  E.W. Myers. A precise inter-procedural \ndata flow algorithm. In ACM Symposium on Principles of Programming Languages, pages 219-230, 1981. V.C. \nSreedhar and G.R. Gao. A linear time algo-rithm for placing +nodes. In ACM Symposium on Principles of \nProgramming Languages, pages 62-73, 1995. M. Shapiro and S. Horwitz. Fast and accu-rate flow-insensitive \npoints-to analysis. In ACM Symposium on Principles of Programming Lan-guages, pages 1-14, January 1997. \n B. Steensgaard. Points-to analysis in almost lin-ear time. In ACM Symposium on Principles of Programming \nLanguages, pages 32-41, January 1996.  \n\t\t\t", "proc_id": "277650", "abstract": "A pointer-analysis algorithm can be either flow-sensitive or flow-insensitive. While flow-sensitive analysis usually provides more precise information, it is also usually considerably more costly in terms of time and space. The main contribution of this paper is the presentation of another option in the form of an algorithm that can be 'tuned' to provide a range of results that fall between the results of flow-insensitive and flow-sensitive analysis. The algorithm combines a flow-insensitive pointer analysis with static single assignment (SSA) form and uses an iterative process to obtain progressively better results.", "authors": [{"name": "Rebecca Hasti", "author_profile_id": "81100198575", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton Street, Madison, WI", "person_id": "P240176", "email_address": "", "orcid_id": ""}, {"name": "Susan Horwitz", "author_profile_id": "81100357689", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton Street, Madison, WI", "person_id": "PP39039239", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/277650.277668", "year": "1998", "article_id": "277668", "conference": "PLDI", "title": "Using static single assignment form to improve flow-insensitive pointer analysis", "url": "http://dl.acm.org/citation.cfm?id=277668"}