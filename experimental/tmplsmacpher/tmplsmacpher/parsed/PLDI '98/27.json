{"article_publication_date": "05-01-1998", "fulltext": "\n Memory Management with Explicit Regions David Gay* and Alex Aiken EECS Department University of California, \nBerkeley {dgay,aiken}@cs.berkeley.edu void f (1 Abstract Much research has been devoted to studies \nof and algo- rithms for memory management based on garbage col-lection or explicit allocation and deallocation. \nAn al-ternative approach, region-based memory management, has been known for decades, but has not been \nwell-studied, In a region-based system each allocation spec-ifies a region, and memory is reclaimed by \ndestroying a region, freeing all the storage allocated therein. We show that on a suite of allocation-intensive \nC programs, regions are competitive with malloc/free and sometimes substantially faster. We also show \nthat regions sup-port safe memory management with low overhead. Ex-perience with our benchmarks suggests \nthat modifying many existing programs to use regions is not difficult. Introduction The two most popular \nmemory management tech-niques are explicit allocation and deallocation, as in C s malloc/free, and various \nforms of garbage-collection [Wi192]. Both have well-known advantages and disadvantages, discussed further \nbelow. A third al-ternative is region-based memory allocation, which has been widely used as an implementation \ntechnique for many years under a variety of names, e.g., zones [ROSEN], groups [lY90], or arenas [HanSO]. \nRegions have also re- cently attracted research attention as a target for static inference of memory \nmanagement [TT97] and for im-proving locality of dynamically allocated data [Sto97]. In a region-based \nmemory allocation scheme each al-located object is placed in a program-specified region. Memory is reclaimed \nby destroying a region, freeing all the objects allocated therein. A simple example is shown in Figure \n1. Each iteration of the loop allocates a small array. The call to deleteregion frees all arrays. *This \nmaterial is based in part upon work supportedby NSF Young Investigator Award No. CCR9457812, DARPA contract \nF30602-95-C-0136 and a Microsoft graduate fellowship. ~3 ,666 ACM 0-89791-987-4/98/0006...$6.00 c Region \nr = newregion ; for (i = 0; i < 10; i++) C int *x = ralloc(r, (i + 1) * sizeof (int)); work(i, x); 1 \ndeleteregion( I Figure 1: An example of region-based allocation. In the commonly used version of region-based \nprogram-ming, regions are explicit in the program and entirely under programmer control. To our knowledge, \nthe per- formance of this popular implementation technique has never been studied. Our f&#38;t contribution \nis a detailed comparison of the performance of regions with mal-lot/free libraries and conservative garbage \ncollection on a set of benchmark programs. Our conclusion is that explicit regions are, for our benchmarks, \nfaster than ei-ther malloc/free or conservative garbage collection, and sometimes significantly so (up \nto 16%). Memory con-sumption is good in our experiments: regions use from 9% less to 19% more memory \nthan the best alternative and always rank either first or second (see Section 5). While our study supports \nthe use of regions on perfor- mance grounds, the common implementation of regions is unsafe, as a region \nr can be deleted even if other regions have accessible pointers to objects in r. Our second contribution \nis the study of a safe region imple- mentation in which a region r can be deleted only if there are no \nezternalreferences to objects in r (a refer- ence external to r is any pointer not stored within r). \nWe enforce this rule by keeping a reference counf for each region; deleteregion is a no-op when this \nrefer-ence count is nonzero. Note that by reference count-ing regions instead of individual objects two \ncommon problems with reference counting are ameliorated: min-imal space is devoted to storing reference \ncounts, and cyclic structures can be collected so long as they are al- located within a single region. \nThe overhead of safety varies from negligible to 17% on our benchmarks, but the comparative performance \nremains almost the same: regions are still faster (up to 9%) than the alternatives in all but a few cases, \nand in those cases regions are only slightly slower (up to 5%). A third contribution is an assessment \nof how difficult it is to program with explicit regions. Our metric is the number and type of changes \nrequired to modify an appli- cation to use regions. All of our benchmarks required only modest recoding \nto use regions, and the needed region organization was straightforward to derive (see Section 5.1). We \nalso found that explicit regions have some partic-ular strengths. First, regions bring structure to mem-ory \nmanagement, making programs clearer and, in our subjective assessment, easier to write compared to us-ing \nmalloc/free. For example, it is not necessary to walk through a complex data structure to deallocate \nit. Second, we found some evidence that regions can be used to provide significantly improved data local-ity, \nas posited by Stoutamire [Sto97]. The execution time of one benchmark was improved 24% simply by reorganizing \nallocation so that the most frequently ac-cessed objects are allocated in a single region. Nei-ther malloc/free \nnor garbage-collected systems provide any mechanism for expressing locality. Third, regions are useful \nfor building software with predictable perfor-mance, as the cost of every operation is easily bounded, \nat least for unsafe regions and in [TT97] for compiler- inferred safe regions (see Section 2). Our safe \nimple- mentation uses a moderately sophisticated scheme for efficiency; we show that the overhead of \nthis scheme is amortized constant time per instruction executed, as-suming that the size of stack frames \nis bounded by a constant (see Section 4.3). Another advantage of region-baaed memory manage-ment is that \nit can be used nearly unchanged in an explicitly-parallel programming language. The only op-erations \nthat require synchronization amongst all pro-cesses are region creation and deletion. Each process keeps \na local reference count for each region which counts the references created or deleted by that process. \nA region can be deleted if the sum of alI its local refer-ence counts is zero. Writes of references to \nregions must be done with an atomic exchange (rather than a simple write) to prevent incorrect behaviour \nin the presence of data races, however the local reference counts can be adjusted without synchronization \nor communication. There are situations where regions are not a good model, particularly when the programmer \ndoes not know enough about the lifetime of objects at allocation- time to place them in appropriate regions. \nOne example we encountered is a game where objects are allocated and deallocated as the result of the \nplayer s actions; there is no way to place objects with similar lifetimes in a common region. Our purpose \nhere is to study the costs and benefits of regions as they are normally used. We leave generalizations \nof explicit regions as future work. We conclude this section with a high-level comparison of our region \nscheme with malloc/free and garbage col-lection. Our region model is reminiscent of malloc/free but allocation \nis about twice as fast and deallocation is much faster. In the safe version of our scheme, there is additional \noverhead for maintaining region reference counts. Garbage collection is easier to use than re-gions and \ncan be very efficient if the application only uses a fraction of available memory. When an appli-cation \nneeds most of the available memory, however, performance degrades. Also garbage collection prevents local \nreasoning about performance by introducing un-predictable pauses. Real-time collectors [Bak78, WJ93] \neliminate this last problem at the cost of higher over-head. From these considerations, we believe regions \nare best suited for high-performance applications that use a large fraction of machine memory and where \nthe life- times of values can be statically predicted. Regions are also useful for writing software with \nmore predictable performance than garbage-collection-based systems. The rest of this paper begins with \na more detailed survey of related work (Section 2). We then introduce our safe, region-based memory management \nsystem (Section 3) and its implementation (Section 4). Section 5 details the costs of safe regions and \ncompares their performance on six C applications with three malloc/free implemen-tations and the Boehm-Weiser \nconservative garbage col-lector [BW88]. 2 Related Work The literature on memory management is vast. Sur-veys \ncan be found in [Wi192] for garbage collection and [WJNB95] for explicit allocation and deallocation. \nRegions have been used for decades. Ross [Ros67] presents a storage package that allows objects to be \nal- located in specific zones. Each zone can have a different allocation policy, but deallocation is \ndone on an object- by-object basis. Vo s [Vo96] VmaIloc package is similar: allocations are done in regions \nwith specific allocation policies. Some regions alIow object-by-object dealloca-tion, some regions can \nonly be freed ail at once. Hanson presents arenas in [HanSO], but does not measure their performance. \nBarrett and Zorn [BZ93] use profiling to determine allocations that are short-lived, then place these \nallocations in fixed-size regions. A new region is created when the previous one filIs up, and regions \nare deleted when alI objects they contain are freed. This provides some of the performance advantages \nof regions without programmer intervention, but does not work for all programs. None of these proposals \nattempt to provide safe memory management. Stoutamire (St0971 adds zones, which are garbage-collected \nregions, to Sather [SO961 to allow explicit pro-gramming for locality. His benchmarks compare zones with \nSather s standard garbage collector. Reclamation is still on an object-by-object basis. The only published \nempirical studies on regions are for the region inference system of Tofte and Talpin [TT97], which automatically \ninfers for ML programs how many regions should be allocated, where these regions should be freed, and \nto which region each allocation site should write. Although very sophisticated, the Tofte/Talpin system \nrelies critically on the fact that regions, region allocation, and region deallocation are introduced \nby the compiler and not by the programmer. Besides be-ing fulIy automatic, the Tofte/Talpin system has \nthe ad- vantage that the runtime overhead for memory manage-ment is reduced to an absolute minimum while \nalso be-ing safe. Unfortunately, region inference is not perfect. To avoid leaking a great deal of memory \nit is necessary for the programmer to understand the regions inferred by the compiler and to adjust the \nprogram so that the compiler infers better region assignments. Second, op-timizations beyond the basic \ninference procedure make an enormous difference in memory management perfor-mance [AFL95, BTV96]. Both \nof these properties sug-gest that explicit first-class regions may be appropriate, but combining explicit \nprogrammer-controlled regions with region inference appears to be a very difficult prob-lem. Bobrow [Bob801 \nis the first to propose the use of regions to make reference counting tolerant of cycles. This idea is \ntaken up by Ichisugi and Yonezawa in [lY90] for use in distributed systems. Neither of these papers considers \nthe use of regions for enhancing locality, nor do they include any performance measurements. Grunwald \nand Zorn [GZ93] and Detlefs, Dosser and Zorn [DDZ94] study the performance of various allo-cators. Vo \ns paper on regions [Vo96] also compares the performance of the malloc/free-like allocator of the Vmalloc \npackage with other malIoc/free implementa-tions. Grunwald, Zorn and Henderson compare the performance \nand cache locality of different allocators in [GZH93]. None of these studies consider region-based allocation. \n3 Programming Model We have implemented a prototype safe region-based memory management system as an \nextension of C, CO. Using C allows us to compare existing allocation-intensive programs with versions \nof these applications modified to use regions. Our prototype requires lan-guage and compiler support \nfor two reasons. First, it is much easier for the compiler to generate the refer-ence counting code than \nto insert reference counts by hand. Second, our implementation must locate alI live local variables containing \npointers; this information is only available in the compiler. An added advantage of modifying the language \nis that we can enforce some of the requirements on pointers to objects in regions at compile-time. The \nrest of this section presents CQ, the region allocation library, and gives a simple example. 3.1 The \nLanguage CQ CQ distinguishes two kinds of pointers: normal pointers and region pointers, i.e., pointers \nto objects in regions. Region pointers are defmed with @ instead of *, e.g., int Qx. The types TQ and \nT* are different types, and no implicit conversion exists between them although ex-plicit casts are allowed. \nThese casts are unsafe, but are necessary for our experiments because the standard C libraries are not \naware of region pointers. In particular deleteregion does not account for region pointers cast to normal \npointers. When a region pointer r is updated it is potentially necessary to adjust two reference counts, \none for the old typedef struct region QRegion; typedef size-t (*cleanup-t)(/* struct ??? Qx */); typedef \nsize-t (*cleanuparray-t)(/*size-t n, struct ??? Qx */) ; Region neuregion(void) ; int deleteregion(Region \n*r) ; void Qralloc(Region r, size-t size, cleanup-t cleanup) ; void Qrarrayalloc(Region r, size-t n, \nsize-t size, cleanuparray-t cleanup) ; void Qrstralloc(Region r, size-t size); Region regionof (void \nQx) ; Figure 2: Region allocation interface. region r points to (a decrement) and one for the new re-gion \nr points to (an increment). This implies that region pointers must always be initialized, which is enforced \nby requiring initialization of all local variables that are, or contain, region pointers, and by clearing \n(writing O S in) all objects allocated in regions. Because C@ must recog-nise all writes of region pointers, \ncopying structs con-taining region pointers is forbidden-C s unions make it impossible to know which \nparts of a structure actually contain region pointers. Region pointers behave oth-erwise like normal \nANSI C pointers and in particular address arithmetic is allowed. While these restrictions on regions \npointers in CQ are not onerous, it is worth noting that explicit regions could be integrated into more \nmodern languages with fewer modifications. For example, in Java [GJS96] pointers (i.e., references) are \nalways initialized and union does not exist. 3.2 The Region Library Figure 2 shows the region interface. \nA new region is created with newregion Objects are allocated with ralloc, arrays with rarrayalloc. Objects \nor arrays that do not contain any region pointers can be allocated with rstralloc; the cleanup arguments \nto ralloc and rarrayalloc are discussed in Section 4. The mem-ory returned by ralloc and rarrayalloc, \nbut not rstralloc, is cleared. An object s region is returned by regionof. An attempt to delete a region \nis made by calling deleteregion( The deletion succeeds if there are no references (excepting *x) to the \nregion in live vari-ables or in other regions. On success, *x is set to NULL, and 1 is returned. On failure \n*x is unchanged, and 0 is returned. Figure 3 shows a simple example that copies a list into a region, \nthen later deletes that region. The cleanuplist function is presented in Section 4. struct list C int \ni; struct list Qnext; 1; struct list Qcons(Region r, int x, struct list Ql) c struct list Qp = ralloc \n(r , sizeof (struct list) , cleanup-list) ; p->i = x; p->next = 1; return p; 1 struct list Qcopy-list \n(Region r, struct list Ql) C if (1 == NULL) return NULL; else return cons(r, 1->i, copy-list(r, 1->next)); \nvoid work(struct list 01) i Region tmp = newregion0; 1 -copy-list(tmp, 1) ; . . . do something with 1 \n. . . deleteregion(&#38;tmp) ; Figure 3: List copy using regions. 4 Implementation Our implementation \nof safe regions is based on the ICC [FH95] C compiler and a runtime library implement-ing our region \ninterface. The modified ICC handles the language extensions of Section 3 and cooperates with the runtime \nlibrary to maintain region reference counts. The target machine is a Sun UltraSparc-I. This sec-tion \ndiscusses how our implementation manages regions (Section 4.1) and reference counts (Section 4.2). We \nalso have a modified version of our implementation that supports unsafe regions: it is identical to the \nsafe ver- sion, except that ah support for maintaining reference counts is disabled. The section concludes \nwith a ar-gument that the overhead of memory management is amortized constant time per instruction executed. \n 4.1 Managing Regions The goal of the region library is to provide cheap object allocation and region \ndeletion. It must also maintain a mapping from memory addresses to regions for the reference counting \ncode. The region data structure is shown in Figure 4. A re-gion contains a reference count and two allocators, \none for normal allocations (ralloc and rarrayalloc) and one for region-pointer-free data (rstralloc). \nEach al-struct allocator C char *firstpage; /* offset at which to allocate */ int allocfrom; 3; struct \nregion C int rc; struct allocator normal: struct allocator String; 1; Figure 4: Region structure. locator \nmaintains a list of 4K byte pages, with allocation occurring only on the first page of the Est. Allocation \nis very simple: If the allocation fits on the first page just return f irstpage+allocf rom and incre- \nment allocfrom, if not allocate a new page and try again. The ralloc and rarrayalloc functions must also \nsave the cleanup function at the start of the aho- cated object (see below) and clear the rest of the \naho- cated memory. Finally, rarrayalloc must save the size of the array. The allocators maintain an array \nmapping page addresses (i.e., memory addresses / 4K) to regions. The space overheads of this scheme are \nlow: eight bytes per page for the map of pages to regions and the list of allocated pages. If an object \ndoes not fit in the space remaining at the end of a page that space is wasted.2 Each allocation needs \nzero (for strings) to twelve (for arrays) bytes of bookkeeping information. The region itself is stored \nin the first page allocated for that region. To reduce cache conflicts between region structures, successive \nregions are offset by 64 bytes (the 2nd level cache line size) in their first page, up to a maximum offset \nof 512. 4.2 Managing Reference Counts While an object is allocated and deallocated only once, references \nto an object may change an arbitrary num-ber of times. Thus, while object allocation and region deallocation \nare inexpensive in our system, maintain-ing reference counts is potentially very expensive. It is useful \nto distinguish between references in local vari-ables, which change frequently, from references in the \nheap, which are updated more rarely. The main aim of our reference counting scheme is to avoid the large \noverhead that would be incurred by reference counting local variables exactly. There are four components \nto our scheme: maintaining approximate reference counts for local variables, maintaining exact reference \ncounts for pointers in the heap, performing a scan of the stack, and scanning deleted regions. Our prototype \nonly handles allocations of less than one page-our benchmarks did not use any larger objects. This re-striction \ncould be lifted without affecting the cost of small allo-cations. Also the last byte of a page cannot \nbe used if pointers to the end of objects are supported. 4.2.1 Local Variables The exact reference count \nfor a region is the number of pointers to objects of that region from other regions, global storage (including \nglobal and static variables and any memory returned by malloc if used) and the live variables in all \nactive call frames. We need the exact reference count only when deleteregionis called, at all other times \nwe need only maintain enough information to compute this reference count (this is the principle behind \ndeferred reference counting [DB76]). The actual reference count stored with a region reflects the number \nof pointers to objects of that region from all other regions, global storage, and the live variables \nin all active call frames above the high water mark on the stack (note the stack grows downward on the \nSPARC). The high water mark is just a location on the stack, with some frames above and some below. Our \nsystem maintains the following invariant: (*) The number offrames below the high-water mark is always \nat least one. Thus writes to local variables never update reference counts. Invariant (*) is maintained \nby a procedure call, but some work may be required on procedure return. If control returns to a call \nframe at the high-water mark, then the region reference counts attributable to local variables are decremented \nand the high water mark is adjusted above the call frame. We describe this unscan function in further \ndetail below. When deleteregion requires the exact reference count of r it scans the portion of the stack \nbelow the high water mark and updates the region reference counts. At that point the actual and exact \nreference counts are equal. The stack scan sets the high water mark above the frame of deleteregion, \nwhich is not itself scanned.  4.2.2 Global and Region References The compiler generates code to update \nreference counts on writes of region pointers in global storage and to ob- jects within regions. Reference \ncounting is different for writes to global storage and for writes within regions. When a pointer to region \nr is written in region r, the reference count for r is not incremented. We call such pointers sameregion \npointers. As global storage does not belong to any region, it cannot contain sameregion pointers. Figure \n5 shows pseudo-code for both kinds of reference count updates. The instruction counts re-flect the number \nof SPARC instructions required by our implementation for each kind of write. Our compiler attempts to \ndistinguish writes to local variables, global storage and regions at compile-time, but this is not always \npossible in C because writes via normal pointers can be writes to global storage or to variables on the \nstack. Writes to the stack should only be reference counted if that variable is above the high water \nmark. For writes that cannot be statically dis-Global writes -16 instructions t = *a: if (regionof (t) \n!= regionof (b) ) { regionof (t)->rc--; regionof (b) ->rc++; 1 Region writes -23 mstructrons t = *a I \nif (regionof (t) != regionof (b)) { if (regionof (t) != regionof (a) 1 regionof (t.) ->rc--; if (regionof \n(b) != regionof (a)) regionof (b) --)rc++; 1 Figure 5: Reference count methods for *a=b. tinguished, \na more expensive runtime routine is used to determine which case applies. 4.2.3 Stack Scan To allow \nthe stack to be scanned at runtime, the com-piler records at each function call site the set of registers \nand offsets in the current call frame that contain live re-gion pointers. Because our implementation \nis based on lee, which does not have liveness information available, our prototype considers all variables \nin scope to be live. The liveness information is static data whose location is recorded in the unused \nbits of a NOP instruction at the call site. (A more complex implementation would avoid this extra instruction.) \nAfter the scan of a call frame increments the region reference counts for all live variables, the high \nwater mark is placed just below that call frame. A call frame that was scanned is unscanned automat-ically \nwhen control returns to that frame. This is achieved by modifying return addresses during the scan to \npoint to a special unscan function that decrements the region reference counts, adjusts the high water \nmark above the call frame, and then jumps to the original re-turn address. 4.2.4 Region Scan A deleted \nregion r may contain pointers to objects in other regions. To adjust the reference counts of other regions \nwe examine all the region pointers in objects allocated in r. The user supplies the function that per-forms \nthis task as the cleanup argument to ralloc and rarrayalloc. This function must call destroy on ev-ery \nregion pointer in the allocated object and return the size of the object. We require the user to provide \nthis function for the same reason that we forbid copying structures that contain region pointers: the \npresence of C s unions makes it impossible for the compiler to lo-cate every region pointer. For cases \nwithout union, and in higher-level languages, the cleanup function could be generated automatically by \nthe compiler. The cleanup function also allows object finalization. Figure 6 shows the cleanuplist function \nfor the list type of Figure 3. The pseudo-code for scanning deleted regions is in Fig- ure 7. size-t \ncleanup-list(struct list 0x1 C destroy(x->next); return sizeof *x; 1 Figure 6: Example of cleanup function. \nfor all pages p of region: deleting = p; end = p + PAGESIZE; while (deleting < end) cleanup-t cln = *(cleanup-t \n*)deleting; /* the end of unfilled pages is marked with a NULL */ if (!cln) break; deleting += sizeof(cleanup-t); \ns = cln(deleting); deleting += ALIGN (s, ALIGNMENT) ; Figure 7: Region cleanup.  4.3 Amortized Cost \nof Safe Regions The primary justification for our reference counting scheme is that it both solves the \nengineering problem of avoiding maintaining all reference counts all the time while still bounding the \ncost of memory management. We make two assumptions. First, we assume that the size of the largest stack \nframe is bounded by a constant c.~ Second, we assume that every allocated word is ac- tually referenced \nby some program instruction. We can then argue that the amortized cost of memory manage-ment is a constant \nper instruction executed. The costs in our region system are incurred on region allocation, object allocation, \nupdates (reference count-ing), region deletion (scanning regions and the stack), and on procedure return \n(unscanning). To show our bound we distribute these costs over all memory refer-ences and procedure calls \nin such a way that the maxi- mum cost associated with any operation is bounded by a constant. Allocating \na new region is a constant time operation. The cost of allocating an object o is at worst propor-tional \nto the size of o plus the cost of acquiring a new page. The latter cost is constant, the former is dis- \ntributed to the program references to o. Scanning a deleted region simply scans each object o in the \nregion, the cost of which can also be assigned to program ref-erences to o. A reference count operation \nis charged to the assignment. The analysis of the stack scan and unscan requires a bit of care. Every \nscan of a frame is eventually paired with 3Actually, it is sufficient if the number of live region pointers \nin a frame is bounded by a constant. a corresponding unscan of the same frame. Except for the frame for \ndeleteregion (which is at the bottom of the downward-growing stack), the cost of scanning and unscanning \na frame f is charged to the call that creates the frame immediately below f on the stack. Because the \nhigh-water mark moves up only on procedure re-turn, it follows that every function call is charged for \nthe scan and unscan of at most one frame. Assuming stack frames have at most size c, every call is therefore \ncharged a constant cost. 5 Results We describe our benchmarks and the changes required to adapt them \nto use regions in Section 5.1. We use these benchmarks to compare the performance of regions with three \nmalloc/free implementations (de-scribed in Section 5.2) and the Boehm-Weiser conser-vative garbage collector. \nWe find that the safe region- based programs use from 9% less to 19% more memory (Section 5.4) than the \nallocator that uses least memory, and are from 5% slower to 9% faster than the fastest allocator. Unsafe \nregions are never slower than other allocators and are up to 16% faster (Section 5.5). On one benchmark, \nwe use regions to group frequently ac-cessed data structures and obtain a 24% performance improvement. \nWe measure the overhead of safe regions and iind that it does not exceed 17% and is generally much lower \n(Section 5.6). 5.1 Benchmarks We compared the performance of our safe, region-based memory management \non six allocation-intensive C pro- grams. These programs and the inputs we used for our measurements \nare cfrac: A program to factor large integers using the continued fraction method. The original application \nuses explicit reference counting to reclaim storage. We factor 4175764634412486014593803028771. griibner: \nFind the Grijbner s basis of a set of poly- nomials. The input is nine nine-variable polynomi-als. mudlle: \nA byte-code compiler for a scheme-like language. The original version of this program uses unsafe regions. \nThe same 500-line file is compiled 100 times. ICC: Our modified version of the ICC C compiler. The original \nprogram also uses unsafe regions anson s arenas [HanSO]). The input is a 6000- Fe C file. tile: Automatically \npartitions a set of text files into subsections based on frequency and grouping of words in the text. \nThis program uses malloc/free. Twenty copies of a 14K text are given as input. moss: A software plagiarism \ndetection system, written originally using malloc/free. The input is 180 student compiler projects (about \n10MB). Name ] Lines 1 Changed lines We modified these programs to use our safe regions. Our cfrac ] \n4203 1 149 18 first step was to choose appropriate regions for those applications that were not already \nregion-based. All the applications have a simple region structure, even pFJlii~ E$j 1 when the data structures \nstored in the regions are very complex. For instance, our region-based cfrac creates a region for temporary \ncomputations for every few it- erations of the main algorithm. Partial solutions are copied from this \nregion to a solution region so that old temporary regions can be deleted. In mudhe, one re- gion holds \nthe abstract syntax tree of the file being compiled and one region is created to hold the data structures \nneeded to compile each function. The other programs have similarly simple region structures. In general, \nwe found it fairly easy to modify these bench- marks to use regions. The difficulty lay not so much in \nselecting where to create and delete regions, but in the tedious process of changing types, writing cleanup \nfunctions, etc. As pointed out above, most of this work would not be necessary in a higher-level language. \nThe other difficulty is finding stale pointers that prevent a region from being deleted; an environment \nfor debug-ging regions would be helpful here. Once the region structure is selected, the following ba-sic \nmodifications are made: calls to malloc and free are replaced with appropriate region operations, nor-mal \npointers are changed to region pointers, the cleanup functions are written and initializations are added \nfor all local region pointers. Each application has some further changes: l For cfrac we disable the \nexplicit reference counting and allocate some static objects in regions. We also add the copies of partial \nsolutions to the solution region. l For mudlle it is necessary to clear some global vari-ables with stale \npointers in the original code; oth- erwise these pointers prevent region deletion. l In griibner we must \nreplace some bulk copies (via assignment) with explicit copies, statically allocate some structures that \nwere originally on the stack, and add copies of the polynomials that form the basis to a result region. \nMany frees are replaced by clearing the corresponding pointer, a number of other pointers must also be \nexplicitly cleared. l For ICC we replace bulk copies (via assignment or memcpy) with calls to hand-written \ncopy functions and replace some uses of memset with explicit NULL writes. Information is added to some \ntypes so that cleanup functions can be written. Some static and stack objects are allocated in regions \nand some global variables and region-allocated objects are cleared. Memory for strings is allocated individu-ally \nrather than in blocks. To improve ICC S perfor- mance, we create a region for every hundred state-ments \ncompiled rather than for every statement. l For tile, one local variable must be cleared to al-low a \nregion to be deleted. In addition, numerous memory management bugs present in the original code are repaired. \n0 moss allocates some large static arrays in a region. Table 1: Complexity of benchmark changes. The \nsize of these changes is summarized in Table 1. The Lines columns counts the number of lines in the original \nsource code. The first number under Changed lines represents the number of changed or extra lines of \ncode in the region-based version, based on the results of dif f -f; the second number counts only those \nlines that are not part of the basic modifications. 5.2 Allocators We compare the performance of regions \nwith the follow- ing allocators: Sun: This is the default allocator supplied with Solaris 2.5.1. It provides \nan interesting point for comparison as it will likely be used by default. BSD: The version of the BSD \nmemory allocator supplied by Sun. It rounds allocations up to the nearest power of two. It features fast \nallocation and deallocation but has a very large memory overhead. Lea: Doug Lea s implementation of malloc, \n~2.6.4.~ This is an improved version of the allo-cator used in some previous surveys of memory al-location \ncosts [DDZ94, Vo96]. In those surveys this allocator exhibited good performance overall. GC: The Boehm-Weiser \nconservative garbage col-lector [SW881 ~4.12. We disable all free s when compiling with this collector, \nthus guaranteeing safe memory management. We use three different region libraries in these measure-ments: \nsafe: the safe region-based memory management described in Section 4. This library is used for the region-based \nmeasurements (the Reg bars in Figures 8, 9 and 10). unsafe: the same as safe, but with all operations \nthat maintain or test reference counts disabled. This library is used for the unsafe region measure-ments \nin Figure 9 (bar unsafe ). emulation: a region library that uses malIoc and free to allocate and free \neach individual ob-ject. This library approximates the performance a region-based application would have \nif it were written with malloc/free. In our experiments this Available at ftp://g.oswego.edu/pub/misc/malloc.c \nName Total Y Total kbytes Max. kbytes Total Max. Max. kbytes Avg. kbytes Avg allots allots allocated \nallocated regions regions in region per region per region cfrac 3812425 60107 106 23383 5 83.6 2.57 163 \ngrijbner 805321 28454 43.6 11452 4 13.0 2.48 70 mudlle 737850 10661 240 4648 13 141 2.29 159 ICC 177816 \n8711 4567 1249 3 4125 6.97 142 tile 40699 1347 88.4 81 5 41.9 12.5 502 moss 552240 7778 2212 1899 7 1246 \n3.49 291 Table 2: Allocation behaviour with regions. Name 1 Total 1 Total kbytes 1 Max. kbytes allocated \nallocated 66879 1 84.8 grijbner 804956 28449 46.2 mudlle 742495 13578 324 S/o overhead) 10678 239 1 166495 \nI 9102 4683 (w/o overhead) 8452 4375 1330 84.0 ::ss 1 5Ez 7778 2203 Table 3: Allocation behaviour with \nmalloc. library is used to measure the performance of the mudlle and lee with malloc/free allocators. \nUsing this library imposes a small space overhead: the objects allocated in a region must be kept in \na linked list so they can be freed when deleteregion is called. Table 3 and Figure 8 include additional \nentries estimating memory usage without this over-head. The C library sometimes calls malloc, and thus \nC appli- cations using regions inevitably include a mix of mem- ory allocated with regions and with malloc. \nThe region- based programs are linked with the default Sun allo-cator; our results for regions include \nthe time and space cost of these calls to malloc. 5.3 Allocation Characteristics Tables 2 and 3 give \nthe memory allocation character-istics of the region-based and malloc/free versions of the applications. \nTotal allots is the total number of memory allocations performed by the program and To- tal kbytes allocated \nis the total number of kilobytes allocated, with allocation sizes rounded to the nearest multiple of \nfour. The Max. kbytes allocated column contains the maximum amount of memory allocated at any time. The \nremaining columns concern only regions: Total regions is the number of regions created, Max. regions \nis the maximum number of regions present at any time, Max. kbytes in region is the size of the ap- plication \ns largest region, Avg. kbytes per region is the average size of the regions and Avg. alIocs per region \nis the average number of objects allocated per region. The discrepancies in Tables 3 and 2 in the number \nof allocations and the amount of memory allocated are generally small and attributable to the small changes \nneeded to convert the applications to use regions. The first exception is cfrac , where the region-based \nversion does not need to allocate space for reference counts, but does need to allocate some extra copies \nof the results. The second exception is lee where the region-based ver-sion does more than 10,000 extra \nallocations because strings are allocated individually and some stack allo-cated structures are converted \nto region allocated struc-tures. Because a region can only be deleted all at once, the region-based versions \nof the applications tend to free memory later than the malloc/free-based versions. Thus the maximum amount \nof memory allocated at any time tends to be slightly larger in Table 2 than in Ta- ble 3.  5.4 Memory \nUsage Figure 8 compares the amount of memory requested from the operating system (bar OS ) by the different \nallocators with the memory actually requested by the programmer (bar requested, see Tables 3 and 2). \nThe graphs for cfrac and tile are clipped: the Boehm-Weiser garbage collector used 832 and 664 kbytes \nre-spectively. For lee and mudlle, the first bar is the raw memory usage, the second bar has the region-emulation \noverhead removed. The cfrac /Boehm-Weiser garbage collector pair requests less memory than the malloc/free-based \nversions because it does not need reference counts. Regions use from from 9% less to 19% more memory \nthan Doug Lea s allocator. Regions use less memory than all other allocators in all other cases, except \non the tile benchmark where regions use 1% more than Sun s allocator. The BSD allocator and the Boehm-Weiser \ngarbage collector use a lot of memory, which makes them unsuitable for some applications.  5.5 Performance \nFor each application/allocator combination we measure wall-clock execution time ( base+memory in Figure \n9), including the portion of time spent in memory man-agement ( memory only). Figure 10 reports processor \ncycles lost to read (waiting for the result of a load in-struction) and write (store buffer full) stalls. \nAn alloca- tor that uses the memory hierarchy more efficiently loses fewer cycles to read and write stalls. \nAll measurements cfrac arobner mudlle tile moss 200 200 4soo- 18018 loo100 140-140 1P 1P t 100 100 \n00 00 f 00 00 4040 20 20 0 0 Frgure 8: Memory overhead. cf rat grobner mudlle ICC tile 30 .s 0 25 4 \n0 OS 20 3 4 3 25 . 15 3 s 2 IO IS 2 I 6 1 OS 0 0 LneooLuocFwg 0 .9m6oobaocRD Figure 9: Execution time \nand memory management overhead. are performed on 167Mhz UltraSparc-I workstation and use the UltraSparc \ns internal counters for precision. All applications are compiled with ICC, a non-optimizing compiler. \nThe time spent in the actual application is represented by the base part of the execution time in Figure \n9. The allocation libraries are compiled with optimization by the GNU C compiler or are supplied by Sun. \nThe portion of time spent in these libraries (and in reference counting for region-based allocation) \nis the memory part of the execution time, again in Figure 9. Compiling the applications with an optimiz-ing \ncompiler will not change the time spent in memory management and will reduce the base part of execu-tion \ntime uniformly for all allocators. Thus using an optimizing compiler would not change the results of \nour comparison. On these benchmarks, unsafe regions (bar unsafe in Figure 9) are faster (up to 16%) than \nall the other al-locators. Safe regions are as fast or faster (up to 9%) than the other allocators on \ncfrac , tile , and moss and only slightly slower than the BSD allocator (5% slower) ---\\ and Boehm-Weiser \ngarbage collector (3% slower) on mudlle . On ICC safe redons are slower than the BSD allocator (5% slower) \nand competitive with Doug Lea s allocator-this application has the highest overhead for safe regions. \nThe graph for moss in Figure 9 includes the time for an optimised version ( base+memory bar) and our \norigi-nal region version ( slow bar). The memory allocation pattern of moss is to alternately allocate \na small, fre-quently accessed object and a large, infrequently ac-cessed object. This pattern reduces \nmemory locality among the small objects. The 24% improvement in ex-ecution time in moss is obtained by \nusing two regions: one for the small objects and one for the large objects. This improvement is also \nreflected in Figure 10: the graph for moss shows that the optimized region ver-sion ( Reg column) has \napproximately half the stalls of the original version ( Slow column). It is interesting to note that \nthe BSD memory allocator (which automat-ically segregates objects by size) tends to have fewer stalls \nthan the other explicit allocators; the resulting performance advantage is most visible with moss. 5.6 \nCost of Safety The costs for safe regions can be divided into three parts that mirror the implementation: \nthe cost of calling the cleanup functions when regions are deleted, the cost of scanning the stack when \ndeleteregion is called, and the cost of maintaining the reference counts on region pointer writes. Figure \n11 gives the breakdown of these costs for our six applications. cfrac grobner mudlle ICC tile moss 120 \n1P 70 400 low 0 0 0 0 0 0 SunBSDLw QC R.2 SunBSDLu GC Ma SuSSDLu DC Rq SUlSSDLuCiD~ SunBSDLw GC FW Sm6SDlMQORS@OW \nFigure 10: Processor cycles lost to stalls. The cost of safety varies from negligible ( tile ) to 17% \n( ICC ). For less allocation and pointer intensive pro-grams, we expect results similar to tile. We have \ncon-sidered various methods of reducing the cost of safety, such as recognizing sameregion pointers at \ncompile-time, and various schemes for optimizing the cleanup of regions. We plan to implement some of \nthese ideas in another version of region-based memory management. Cost of safety Figure 11: Region costs. \nConclusion We have presented a new region-based memory man-agement technique that combines efficiency \nwith safety. We have shown that this technique often uses less mem- ory and is as fast or faster than \ntraditional malloc/free-based memory management. Safe regions are also faster than conservative garbage \ncollection in most cases and use much less memory. The programmer can use regions to explicitly take \nadvantage of the locality of dynami- cally allocated data structures. This can lead to much better performance, \nas the moss example shows. Our style of region-based memory management re-quires extensions to be useful \nfor all applications. We plan to address this issue as part of providing re on- F based memory management \nin Titanium PSP 981, an explicitly-parallel, Java-based [GJS96] programming language. References [AFL951 \n[Bak78] [Bob801 [BTV96] [BWSS] [BZ93] [DB76] [DDZ94] Alexander Aiken, Manuel Fahndrich, and Raph Levien. \nBetter static memory man-agement : improving region-based analysis of higher-order languages. In Proceedings \nof the ACM SIGPLAN 95 Conference on Programming Language Design and Imple-mentation (PLDI), pages 174-185, \nLa Jolla, CA, June 1995. Henry G. Baker. List processing in real-time on a serial computer. Communications \nof the ACM, 21(4):280-94, 1978. Daniel G. Bobrow. Managing re-entrant structures using reference counts. \nACM Transactions on Programming Languages and Systems, 2(3):269-273, July 1980. Lars Birkedal, Mads Tofte, \nand Magnus Ve-jlstrup. From region inference to von Neu-mann machines via region representation in-ference. \nIn Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Princi-ples of Programming Languages, St. \nPeters- burg Beach, FL, January 1996. Hans-Juergen Boehm and Mark Weiser. Garbage collection in an uncooperative \nen-vlronment. Software Practice and Experi-ence, 18(9):807-820, 1988. David A. Barrett and Benjamin G. \nZorn. Using lifetime predictors to improve mem-ory allocation performance. In Proceed-ings of the ACM \nSIGPLAN 93 Conference on Programming Languages Design and Im-plementation, pages 187-196, Albuquerque, \nNew Mexico, June 1993. L. Peter Deutsch and Daniel G. Bobrow. An efficient incremental automatic garbage \ncollector. Communications of the ACM, 19(9):522-526, September 1976. David Detlefs, Al Dosser, and Benjamin \nZorn. Memory allocation costs in large C [FH95] [GJS96] [GZ93] [GZH93] [HanSO] [lY90] [Ros67] [SO961 \n[St0971 [TT97] [Vo96] [Wi192] and C++ programs. Software Practice and Experience, 24(6), 1994. Chris \nW. Fraser and David R. Hanson. A Retargetable C Compiler: Design and Im-plementation. Benjamin/Cummings \nPub. Co., Redwood City, CA, USA, 1995. J. Gosling, B. Joy, and G. Steele. The Java Language Specification. \nThe Java Series. Addison-Wesley, Reading, MA, USA, June 1996. Dirk GrunwaId and Benjamin Zorn. Cus-tomaIIoc: \nEfficient, synthesised memory al-locators. Software Practice and Experience, 23:851-869, 1993. Dirk GrunwaId, \nBenjamin Zorn, and Robert Henderson. Improving the cache locality of memory allocation. In Proceedings \nof the ACM SIGPLAN 93 Conference on Pro-gramming Languages Design and Implemen-tation, pages 177-186, \nAlbuquerque, New Mexico, June 1993. David R. Hanson. Fast allocation and deal- location of memory based \non object Iife-times. Software Practice and Experience, 20(1):5-12, January 1990. Yuuji Ichisugi and \nAkinori Yonezawa. Dis-tributed garbage collection using group ref-erence counting. In OOPSLA/ECOOP 90 \nWorkshop on Garbage Collection in Object- Oriented Systems, October 1990. D. T. Ross. The AED free storage \npackage. Communications of the ACM, 10(8):481-492, August 1967. David Stoutamire and Stephen Omohun-dro. \nThe Sather 1.1 Specification. Techni-cal Report TR-96-012, International Com-puter Science Institute, \nBerkeley, CA, Au-gust 1996. D. Stoutamire. Portable, Modular Expres-sion of Locality. PhD thesis, University \nof California at Berkeley, 1997. Mads Tofte and Jean-Pierre Talpin. Region-based memory management. Information \nand Computation, 132(2):109-176, Febru-ary 1997. Kiem-Phong Vo. Vmalloc: A general and efficient memory \nallocator. Software Pmc-tice and Experience, 26(3):357-374, March 1996. Paul R. Wilson. Uniprocessor \ngarbage col-lection techniques. In Proceedings of In-ternational Workshop on Memory Manage- ment, volume \n637 of Lecture Notes in Com-puter Science, St MaIo, France, September 1992. Springer-Verlag. [WJ93] \nPauI R. Wilson and Mark S. Johnstone. Truly real-time non-copying garbage coIIec-tion. In OOPSLA/ECOOP \n93 Workshop on Garbage Collection in Object-Oriented Systems, October 1993. [WJNB95] Paul R. Wilson, \nMark S. Johnstone, Michael Neely, and David Boles. Dynamic storage allocation: A survey and critical \nreview. In Proceedings of International Workshop on Memory Management, volume 986 of Lec-ture Notes in \nComputer Science, Kinross, Scotland, September 1995. Springer-Verlag. [YSPt98] Kathy Yelick, Luigi Semenzato, \nGeoff Pike, Carleton Miyamoto, Ben LibIit, Arvind Kr-ishnamurthy, Paul HiIfinger, Susan Gra-ham, David \nGay, Phil Colella, and Alex Aiken. Titanium: A High-Performance Java Dialect. In Proceedings of A CM \n1998 Work-shop on Java for High-Performance Net-work Computing, pages 1-14, Palo Alto, CA, February 1998. \n  \n\t\t\t", "proc_id": "277650", "abstract": "Much research has been devoted to studies of and algorithms for memory management based on garbage collection or explicit allocation and deallocation. An alternative approach, region-based memory management, has been known for decades, but has not been well-studied. In a region-based system each allocation specifies a region, and memory is reclaimed by destroying a region, freeing all the storage allocated therein. We show that on a suite of allocation-intensive C programs, regions are competitive with malloc/free and sometimes substantially faster. We also show that regions support safe memory management with low overhead. Experience with our benchmarks suggests that modifying many existing programs to use regions is not difficult.", "authors": [{"name": "David Gay", "author_profile_id": "81100039538", "affiliation": "EECS Department, University of California, Berkeley", "person_id": "PP39024398", "email_address": "", "orcid_id": ""}, {"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "EECS Department, University of California, Berkeley", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/277650.277748", "year": "1998", "article_id": "277748", "conference": "PLDI", "title": "Memory management with explicit regions", "url": "http://dl.acm.org/citation.cfm?id=277748"}