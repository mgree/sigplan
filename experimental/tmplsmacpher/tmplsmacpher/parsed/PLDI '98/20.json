{"article_publication_date": "05-01-1998", "fulltext": "\n Units: Cool Modules for HOT Languages Matthew Flatt Matthias Felleisen Department of Computer Science* \nRice University Houston, Texas 77005-1892 Abstract A module system ought to enable assembly-line program-ming \nusing separate compilation and an expressive link-ing language. Separate compilation allows programmers \nto develop parts of a program independently. A linking lan-guage gives programmers precise control over \nthe assembly of parts into a whole. This paper presents models of pro- gram units, MzScheme s module \nlanguage for assembly-line programming. Units support separate compilation, indepen-dent module reuse, \ncyclic dependencies, hierarchical struc-turing, and dynamic linking. The models explain how to integrate \nunits with untyped and typed languages such as Scheme and ML. Introduction Henry Ford had a better idea. \nHis assembly line revolu-tionized manufacturing with two innovations: standardized parts and a controlled \nassembly process. Standardized parts can be independently manufactured, tested, and replaced. A controlled \nassembly process ensures that parts are assem- bled reliably. Module systems ought to enable assembly-line \nprogramming. A module system should provide sepa-rate compilation to support the independent development \nof parts, and it should provide a linking language to give the programmer control over assembling parts. \nExisting module systems for HOT (higher-order, typed) languages do not enable assembly-line programming. \nSome HOT module languages do not provide separate compila-tion, making it impossible to test and distribute \nindivid-ual modules [3]. In other module languages, e.g., the pack- age languages of Ada, Modula-3, and \nJava, connections are hard-wired within modules instead of specified in a separate assembly process. \nSome HOT module systems fail to scale essential features of the core language to modules, which re-stricts \nthe ways that modules can be defined, e.g., ML does *This research was partially supported by a NSF Graduate \nRe-search Fellowship, NSF grants CCR9619756, CDA-9713032, and CCR-9708957, and a Texas ATP grant. ML \nstands for SML or CAML. B ,996 ACM 0.69791.9674/96/0006...55.00 not support mutually recursive procedure \nand type defini-tions at the module level. Finally, few HOT module lan-guages handle dynamic program \nconstruction and dynamic linking, which are needed for programs with some assembly required, e.g., web-based \napplets. For MzScheme [8], we designed and implemented a lan- guage of modules, called program units, \nto support assembly-line programming. In particular, the following properties of our unit language enable \nthe independent development of parts: l Encapsulation: A unit encapsulates a program part, clearly delineating \nthe interface between the unit and all other parts of the program. l Separate compilation: A unit s interface \nprovides enough information for the separate compilation of the unit. To support the assembly process, \nthe unit language provides the following mechanisms: l Individual reuse and replacement: Individual units \nare reusable and replaceable. This implies that the connections between units are specified outside the \nunits themselves rather than hard-wired within each unit. In addition, the language supports multiple \nin-stances of a unit in different contexts within a program. l Hierarchical structuring: The unit language \nal-lows units to be linked together to create a single, larger unit, possibly hiding selected details \nof the com-ponent units in the process. l Dynamic linking: Units support dynamic linking, connecting \nnew and executing code through a well-defined and localized interface. This paper presents untyped and \ntyped models of units that are suitable for Scheme-like and ML-like languages. For these core languages, \nscaling essential core features to the module level implies two final properties: 6 Types: If the core \nprogramming language supports static type definitions, units import and export types as well as values. \nl Mutual dependencies: In whatever manner the core language supports mutually recursive definitions (usually \nprocedure and type definitions), the unit lan-guage allows definitions with mutual references across \nmodule boundaries. Although our unit language specifies how units are de-fined and linked, there is \nno specific mechanism for describ- ing ruhich units are linked together to form a program. In general, \nthe process of selecting units for a program can be quite complex, as evidenced by elaborate makefiles \nused to build programs in traditional languages. In our unit lan-guage, the programmer writes program-linking \nprograms in the core language itself, units are integrated as first-class val-ues in the core language, \nand the unit definition and linking forms are core expression forms. The only primitive oper-ations on \nunits are linking and invocation, which preserves separate compilation for individual units, but programmers \ncan exploit the full flexibility of the core language to apply these operations. Section 2 explains how \nour unit model relates to exist-ing module languages. Section 3 provides an overview of programming with \nunits, and Section 4 defines the precise syntax, type checking, and semantics of units. Section 5 briefly \nconsiders extensions to the typed unit model. The last two sections relate our work to other current \nresearch in module languages, and put our work into perspective. 2 Existing Module Languages and Units \nThe unit model synthesizes ideas from three popular exist-ing module systems: .o files, packages, and \nML modules. The first represents the traditional view of modules as com- pilation units. The second extends \nthis view by moving the module language into the programming language. The last gives programmers greater \ncontrol over how modules are combined into a program. Traditional languages like C have relied on the \nfilesys-tern as the language of modules. Programs (makefiles) ma-nipulate .o files to select the modules \nthat are linked into a program, and module liles are partially linked to create new . o or library files. \nModern linking systems such as ELF 1271 support dynamic linking. However, even the most advanced linking \nsystems rely on a global namespace of func- tion names and module (i.e., file) names. As a result, mod-ules \ncan be linked and invoked only once in a program. Many modern languages (e.g., Ada 95 [I], Modula-2 [30], \nModula-d [ll], Haskell [15], and Java [lo]) use packages. A package system delineates the boundaries \nof each module and forces the specification of static dependencies between modules. Since module linking \nand invocation are clearly separated, packages allow mutually recursive function and type definitions \nacross package boundaries. The main weakness of a package system is its reliance on a global namespace \nof packages with hardwired connections among packages. Package systems do not permit the reuse of a single \npackage for multiple invocations in a program or the external selection of connections between packages. \n(Ada and Modula-3 s generics allow the former but not the latter.) Packages cannot be merged into a new \npackage that hides parts of the constituent packages. In addition, among the languages with packages, \nonly Java provides a mecha- nism for dynamic linking. This mechanism is expressed indi-rectly via the \nlanguage of class loaders, and is not fully gen-eral due to the constraints of a global package namespace. \nML s functor system [22, 241 is the most notable example of a language that lets a programmer describe \nabstractions over modules and gives a programmer direct control over 2Java s class system can also be \nviewed as a kind of module system or as a complement to the package system, Classes suffer the same drawbacks \nas packages: links, such as a superclass name, are hard-wired to a specific class [9]. assembling modules. \nUnlike package languages, the basic ML module, a structure, is not a fragment of unevaluated code. Instead, \na structure is a record with fields contain-ing the module s exported values and types. A module with \ndependencies is defined as a functor, a first-order function that consumes a structure and produces a \nnew structure. Functors separate the specification of module dependencies from module linking. Unfortunately, \nlinking by functor ap-plication prevents the definition of mutually recursive types or procedures across \nmodule boundaries. Worse still, ML provides no mechanism for dynamic linking. 3 Programming with Units \nLike a package in Java or Modula-3, a program unit is an unevaluated fragment of code, but there is no \nglobal names-pace of units. Instead, like an ML functor, a unit describes its import requirements without \nspecifying a particular unit that supplies those imports. The actual linking of the unit is specified \nexternally at a later stage. Unlike in ML, unit linking is specified for groups of units with a graph \nof connec- tions, which allows mutual recursion across unit boundaries. Furthermore, the result of linking \na collection of units is a new (compound) unit that is available for further linking. This section illustrates \nthe basic design elements of our unit language using an informal, semi-graphical program-ming language. \n(The graphical language is currently be-ing implemented for our Scheme programming environment. Programmers \nwill define modules and linking by actually drawing boxes and arrows.) The examples assume a core language \nwith lexical blocks and a sub-language of types. The syntax used for the core language mimics that of \nML. 3.1 Defining Units Figure 1 defines a tit called Database. In the graphical notation, a unit is drawn \nas a box with three sections: The top section lists the unit s imported types and val- ues. The Database \nunit imports the type info (of kind3 n) for data stored in the database, and the function error (of type \nstr-+void) for error-handling. The middle section contains the unit s definitions and an initialization \nexpression. The latter performs start- up actions for the unit at run-time. The Database unit defines \nthe type db and the functions new, insert, and delete (plus some other definitions that are not shown). \nDatabase entries are keyed by strings, so Database ini- tializes a hash table for strings with the expression \ns&#38;Table := makeStringHashTable(). The bottom section enumerates the unit s exported types and values. \nThe Database unit exports the type db and the functions new, insert, and delete. In a statically-typed \nlanguage, all imported and exported variables have a type, and all imported and exported types have a \nkind.3 Imported and defined types can be used in the type expressions for imported and exported values. \nAll exported variables must be defined within the unit, and the type expression for an exported value \nmust use only im-ported and exported types. In Database, both the imported 3A kind is a type for a type. \nMost languages have only one kind, 0, and do not ask programmers to specify the kind of a type. Some \nlanguages (such as ML, Haskell, and Miranda) also provide type con-structors or functions on types, which \nhave the kind n +fi. PhoneBook error:str+void I NumberInjo \\ I I database info::n error:str+void } imports \n type db = . . . fun new():db = . . . t- fun insert(d:db, key:str, v:injo) = - .. definitions fun delete(d:db, \nkey:str) = . . . and expressions ) . . . .&#38;Table := makeStringHashTable() I ib::S2 new:void+db insert:dbxstrxinfo+void \nexports delete:dbxstr-+void i Figure 1: An atomic database unit _- Figure 3: Linking units type info \nand the exported type db are used in the type expression for insert: dbxstrxinfo+void. A unit is specifically \nnot a record of values. It encap-sulates unevaluated code, much like the .o file created by compiling \na C++ module. Before a unit s definitions and initialization expression can be evaluated, it must first \nbe linked with other units to resolve all of its imports. 3.2 Linking Units In the graphical notation, \na programmer links units together by drawing arrows to connect the exports of one box with the imports \nof another. Linking units together creates a compound unit, as illustrated in Figure 2 with the Phone-Book \nunit. This unit links Database with Number-Info, a unit that implements the info type for phone numbers. \nFigure 2 also shows how to link units in stages. The error function is not defined by either Database \nor Number-Info, so PhoneBook imports error and passes the imported value on to Database. At the same \ntime, PhoneBook hides the delete function, but re-exports all of the other values and types info:$a error:str+void \nI .., . . . db::fi tiyvoid-tdb, ins,ert:dbxstrxinfo+void I j ., delete: #,bxs$r+void f ,. : i i 4 \\ db::Cl \nnew)void+db 4 sert:dbxstrxinfo+void info::Cl numInfo:int+info Figure 2: Linking units to form a compound \nunit to define a complete program from Database and Numberlnfo. A complete program is a unit without \nimports. Fig-ure 3 defines a complete interactive phone book program, IPB (Interactive Phone Book), which \nlinks PhoneBoorE with a graphical interface implementation Gui. The Main4 unit contains an initialization \nexpression that creates a database and an associated graphical user interface. A program unit is analogous \nto an executable fle; in-voking the unit evaluates the definitions in all of the pro-gram s units and \nthen executes their initialization expres-sions. Thus, invoking IPB executes Main s initialization expression, \nwhich creates a new phone book database and opens a phone book window. The variables exported by a program \nare ignored. The result of invoking a program is the value of its last initialization expression-a boo1 \nvalue in IPB (assuming Main s expression is evaluated last).5 A compound unit s links must satisfy the \ntype require- The name Main is not special. sour informal graphical notation does not specify the order \nof units in a compound unit, but the textual notation in Section 4 covers this aspect of the language. \n PhoneBook 1 1 I fun openBook(pb:db) = *.* openBook:db+bool Figure 4: Illegal linking due to a type mismatch \n ments of the constituent units. For example, in IPB (see Figure 3), Main imports the type db from PhoneBook \nunit and also the function openBook:db-+bool from Gui. The two occurrences of db must refer to the same \ntype. A type checker can verify this constraint by proving that the two occurrences have the same source \nin the link graph, which is the db exported by PhoneBook. In contrast, Figure 4 defines a programn Bad \nin which inconsistent imports are provided to Main. Specifically, db and openBook:db+bool refer to types \nnamed db that originate from different units. The type checker correctly rejects Bad due to this mismatch. \nLinking can connect units in a mutually recursive man-ner. This is illustrated in ZPB (see Figure 3); \nlinks flow both from PhoneBook to Gui and from Gui to PhoneBook. Thus, the insert function in PhoneBook \nmay call error in Gui, which could in turn call PhoneBook s insert again to handle the error.  3.3 Programs \nthat Link and Invoke Other Programs The IPB program relies on a fixed set of constituent units, including \na specific unit Gui to implement the graphical in-terface. In general, there may be multiple GUIs that \nwork with the phone book, e.g., separate GUIs for novice and advanced users. Every GUI unit will have \nthe same set of imports and exports, so the linking information required to produce the complete interactive \nphone book is independent of the specific GUI unit. In short, the ZPB compound unit could be abstracted \nwith respect to its GUI unit. If a form for linking units is integrated into the core eval- uation language, \nthen the abstraction of IPB can be achieved with a core function. Figure 5 defines MakeIPB, a function \nthat accepts a GUI unit and returns an interactive phone book unit. The programmer draws a dashed box \nfor aGui and MakeZPB to indicate that the actual GUI and interac- tive phone book units are not yet determined. \nMakeIPB can be applied to different GUI implementations to produce different interactive phone book programs. \nThe type associated with MakeIPB s argument is a unit type, a signature, that contains all of the information \nneeded :I ,openBook:db+bool error:str+void, .________-_------___-------------- Figure 5: Abstracting \nover constituent units Starter I fun MakeZPB(aGui) = [ -1 I .P.,I a l--l val Expert Gui = [db::Ci insert:dbxstrxinfo-+void] \ninjo::Cl numInjo:int+info . . .* *void ovenBook:db+bool I 1 val NouiceGui = . . . . invoke MakelPB(if \nezpertMode() EzpertGui else NouiceGui) Figure 6: Linking and invoking other programs to verify its linkage \nin MakeIPB. In the graphical notation, a signature corresponds to a box with imports, exports, and an \ninitialization expression type, but no definitions or ex-pressions. The signature for aGui is defined \nby its dotted box, with :void indicating the type of the initialization ex-pression. Using only this \nsignature, the type system can completely verify the linking in MakelPB and determine the signature of \nthe resulting compound unit. Figure 6 shows MakeIPB as part of a larger program, Starter, that selects \na GUI unit and links together a com- plete interactive phone book program. Once MakeIPB re-turns a program \nunit, Starter launches the constructed pro- gram with the special invoke form, which takes a program \nunit and executes it. 3.4 Dynamic Linking The invoke form also works on units that are not compldte \nprograms. In this case, the unit s imports are explicitly sat-isfied by types and values from the invoking \nprogram. This generalized form of invocation implements dynamic linking. For example, the phone book \nprogram can exploit dynamic linking to support third-party plug-in extensions that load phone numbers \nfrom a foreign source. Each such loader extension is implemented as a unit that is dynamically re-trieved \nfrom an archive and then linked with the phone book Gui db::il insert:dbxstrxinfo+void info::Sl numZnfo:int+injo \n:dbxjile+void openBook:db+bool error:str-+void Figure 7: Dynamic linking with invoke PhoneBook error:str-woid \nNumberInfo \\ [ $; i I $ V1 i info::CL error:str-woid j ; jl 1 +\\ 4 db::n ne# :void+db info::s2 numlnjo:int+info \n Figure 8: Graphical reduction program. 6 Now, the user of the phone book can install a loader extension \nat run-time via interactive dialogues. Figure 7 defines a Gui unit that supports loader exten-sions. \nThe function addLoader consumes a loader extension as a unit and dynamically links it into the program \nusing invoke. The extension unit imports types and functions that enable it to modify the phone book \ndatabase. These imports are satisfied in the invoke expression with types and variables that were originally \nimported into Gui, plus the error function defined within Gui. The result of invok- ing the extension \nunit is the value of the unit s initialization expression, which is required (via signatures) to be a \nfunc- tion of type dbxfile+void. This function is then installed into the GUI s table of loader functions. \nThe core language must provide &#38; syntactic form that retrieves a unit value from an archive, such \nas the Internet, and checks that the unit satisfies a particular signature. This type-checking must be \nperformed in the correct context to ensure that dynamic linking is type-safe. Java s dynamic class loading \nis broken because it checks types in a type environment that may differ from the environment where the \nclass is used [26]. 240 PhoneBook -l errotzstr-woid type info = *.* type db = . +. fun numlnjo(n:int):hfo \n= . . . fun netu():db = 1.. . . . strTable := makeStringHashTable() db::il newvoid-tdb injo::fi numlfljo:int+injo \nrule for a compound unit 4 The Structure and Interpretation of Units In this section we develop a semantic \nand type-theoretic ac-count of the unit language design in three stages. We start in Section 4.1 with \nunits as an extension of a dynamically typed language (like Scheme) to introduce the basic syntax and \nsemantics of units. In Section 4.2, we enrich this lan-guage with definitions for constructed types (like \nclasses in Java or datatypes in ML). Finally, in Section 4.3 we consider arbitrary type definitions (like \ntype equations in ML). For all three sections, we only consider those parts of the core language that \nare immediately relevant to units. The rigorous description of the unit language, including its type \nstructures and semantics, relies on well-known type checking and rewriting techniques for Scheme and \nML [6, 13, 311. In the rewriting model of evaluation, the set of program expressions is partitioned into \na set of values and a set of non-values. Evaluation is the process of rewrit- ing a non-value expression \nwithin a program to an equiva-lent expression, repeating this process until the whole pro-gram is rewritten \nto a value. For example, an atomic unit expression-represented in the graphical language by a box that \nevaluating the expression terminates, does not incur any computational effects (divergence, printing, \netc.), and compound imports exports e 7 does not refer to variables whose values may still be un- link \ne link and e link determined (due to an ordering of the mutually recursive invoke e with invoke-link \n definitions). e ; e 1 letrec-expr A unit expression is a first-class value, just like a num- . . . other \ncore forms . . . letrec-expr = letrec value-dejn in e imports = import value-war-decl* exports = export \nvalue-var-decl* definitions = value-defn * value-dejn = val value-var-decl = e link = with value-uar-decl* \nprovides value-var-decl* invoke-link = value-invoke-link * value-invoke-link = value-var-decl = e value-var-decl \n= so x = variable Figure 9: Syntax for UNITd (dynamically typed) containing text code-is a value, while \na compound unit expression-a box containing linked boxes-is not a value. A compound unit expression with \nknown constituents can be re-written to an equivalent unit expression by merg- ing the text of its constituent \nunits, as demonstrated in Fig- ure 8. Invocation for a unit is similar: an invoke expres-sion is rewritten \nby extracting the invoked unit s definitions and initialization expression, and then replacing references \nto imported variables with values. Otherwise, the standard rules for functions, assignments, and exceptions \napply. 4.1 Dynamically Typed Units Figure 9 defines the syntax of UNITd, an extension of a dy- namically \ntyped core language. The core language must pro- vide two forms that are used in the process of linking \nand invoking: an expression sequence form ( ; ) and a letrec form for lexical blocks containing mutually \nrecursive defini-tions. The core language is extended with three unit-specific forms: l a unit form for \ncreating units; s a compound form for linking units; and . an invoke form for invoking units.  4.1.1 \nThe unit Form The unit form consists of a set of import and export decla-rations followed by internal \ndefinitions and an initialization expression: unit import Zi . f. export ze . . . valz=e, ... e The \nimported variables xi are bound in the definition and initialization expressions. The exported variables \nze must be defined within the unit. The scope of a defined variable includes all of the definition expressions \ne, in the unit as weU as the initialization expression e. In each definition val z = evr the expression \ne, must be valuable in the sense of Harper and Stone [14], with the restriction that imported and defined \nvariable names are not considered valuable. The intent of this restriction is ber or an object in Java. \nThere are only two operations on units: linking and invoking. No operation can look inside a unit value \nto extract any information about its definitions or initialization expression. In particular, since a \nunit does not contain any values (only unevaluated expressions), there is no dot notation for externally \naccessing values from a unit (as in ML) and there are no instantiated units (ap-proximating an ML structure) \nthat contain the values of unit expressions. To simplify the presentation, UNITd does not allow CY-renaming \nfor a unit s imported and exported variables. In MzScheme s units, imported and exported variables have \nseparate internal (binding) and external (linking) names, and the internal names within a unit can be \no-renamed. 4.1.2 The compound Form The compound form links two constituent units together into a new \nunit: compound import zi ** * export xe .a* link el with xi1 provides 2.1 and e2 with xi2 provides ~~2 \n The constituent units are determined by two subexpressions: er and e2. Along with each expression, the \nvariables that the unit is expected to import are listed following the with key-word, and the variables \nthat the unit is expected to export are listed following the provides keyword. Variables are linked within \ncompound by name. Thus, the set of variables zir linked into the first unit must be a subset of xi Uze2. \nSimilarly, Gig must be a subset of xi UX~~. Finally, the set variables xe exported by the compound unit \nmust be a subset of 1~1 U x.2. A compound unit expression is not a value. It evaluates to a unit value \nthat is indistinguishable from an atomic unit. This unit s initialization expression is the sequence \nof the first constituent unit s initialization expression followed by the the second constituent unit%. \nOnce again, MzScheme s syntax is less restrictive than UNITd S. In MzScheme, the compound form links \nany number of units together at once (a simple generalization of UNITd s two-unit form), and hnks imports \nand exports via source and destination name pairs, rather than requir-ing the same name at both ends \nof a linkage. 4.1.3 The invoke Form The invoke form evaluates its first subexpression to a unit and \ninvokes it: invoke e with zi = ei . . * If the unit requires any imported values, they must be pro- \nvided through zi = ei declarations, which associate values ei with names xi for the unit s imports. An \ninvoke expression evaluates to the invoked unit s initialization expression. This last restriction simplifies \nthe presentation of the formal se-mantics, but it can be lifted for an implementation, as in MzScheme, \nwhere accessing an undefined variable returns a default value or sig-nals a run-time error. f distinct \nr i-e,, I t-Z T l-invoke e, with 2=6 Kq~Gpz distinct G distinct 3&#38;-iszpJlpi z,2cQJzpl GCzpludpz rl-el \nrke2 Eu?? distinct KC? r,%,zbz r,%,%keb r l-compound import X export G r l-unit import z export ZGY link \nel with cwl provides zpl Val I = e in eb and ez with z,i provides pi The notation 3 indicates either \na set or a sequence of variables 2, depending on the context. The notation val z = e indicates the sequence \nvai z = e where each I is taken from the sequence 3 with a corresponding e from the sequence Z. Figure \n10: Checking the form of UNITY expressions invoke (unit import z export G it [v,/zwl(letrec val Z = e \nin eb) if zg G val z = e in eb) with tw compound import Z export 37 V unit import 4 link (unit import \n2il export 1,1 export G Val Z1 = el in ebl) with G provides tpi val 01 = e1 and (Unit import m export \nG val 12 = e2 val c2 = e2 in e(Q) with q provides pi in ebl ; eb2 Figure 11: Reducing UNITd expressions \n4.1.4 UNITd Context-sensitive Checking unit import even The rules in Figure 10 specify the context-sensitive \nproper-export odd ties that were informally described in the previous section. val odd = fn 0 * false \nThe checks ensure that a variable is not multiply defined, 1 n j even (n-l) imported, or exported, that \nall exported variables are de-odd 13 fined, and that the link clause of a compound expression is locally \nconsistent. fn (evencell, oddcell) j 4.1.6 UNITd Evaluation (oddcell := (fn 0 * false 1 n * (!eueflceZl) \n(n-1)); The unit-specific reduction rules for UNITY, defined in Fig- fn () j (!oddceU) 19) ure 11, generalize \nthe graphical example in Figure 8. The rules extend those for Scheme [6] and resemble equations in the \nhigher-order module calculus of Harper, Mitchell, and Figure 12: An example of UNITd compilation Moggi \n[13]. The first rule specifies that an invoke expres-sion reduces to a letrec expression containing the \ninvoked unit s definitions and initialization expression. In this lo-tree expression, imported variables \nare replaced by values. 4.1.6 UNITd implementation The set of variables supplied by invoke s with clause \nmust ln MzScheme s implementation of UNITd, units are compiled cover the set of the imports required \nby the unit; otherwise, by transforming them into functions. The unit s imported a run-time error is \nsignalled. and exported variables are implemented as first-class ref-The second rule defines how a compound \nexpression erence cells that are externally created and passed to thecombines two units: their definitions \nare merged and their function when the unit is invoked. The function is respon- initialization expressions \nare sequenced. The compound sible for filling the export ceils with exported values and for rule requires \nthat the constituent units provide at least the remembering the import cells for accessing imports later. \nexpected exports (according to the provides clauses) and The return value of the function is a closure \nthat evaluatesneed no more than the expected imports (according to the the unit s initialization expression. \nFigure 12 illustrates thiswith clauses). Also, all bindings introduced by definitions transformation \non an atomic unit. in the two units must be appropriately o-renamed to avoid A compound unit is also \ncompiled to a function. Thecollisions. function encapsulates a list of constituent units and a clo- sure \nthat propagates import and export cells to the con-stituent units, creating new cells to implement variables \nin letrec-ezpr letrec type-dejn * value-d&#38; * in e imports import type-var-decl* value-var-decl* \nexports export type-var-decl* value-var-decl* definitions datatype-dejn * value-defn * datatype-dejn \ntype t = z T 1 x T b z link with type-var-decl* value-var-decl* provides type-var-decl* value-var-decl* \ninvoke-link type-invoke-link * value-invoke-link * type-invoke-link type-var-decl = 7 type-var-decl \nt :: K value-var-decl t:7 T-,0 = t 1 7 --+ T 1 signature signature = sig imports exports T t = type \nvariable K = type kind Figure 13: Syntax for UNITY (constructed types) the constituents that are hidden \nby the compound unit. The transformed units have the same code-sharing prop-erties as traditional shared \nlibraries. The definition and ini- tialization expressions of a unit are compiled in the body of the \nfunction produced by its transformation, and this one function is used for all instances of the unit. \nThus, there exists a single copy of the definition and initialization code regardless of how many times \nthe unit is linked or invoked.8 4.2 Units with Constructed Types Figure 13 extends the language in Figure \n9 for a statically typed language with programmer-defined constructed types, such as ML datatypes. In \nthe new language, UNITY, the im- ports and exports of a unit expression include type variables as well \nas value variables. All type variables have a kind9 and all value variables have a type. The compound \nand in-voke expressions are extended in the natural way to handle imported and exported types. The definition \nsection of a unit expression contains both type and value definitions. Type definitions are similar to \nML datatype definitions, but for simplicity, every type de-fined in UNITY has exactly two variants. Type \ndefinitions have the form type t = z,1,zd1 TI ) zcT,zdr 7r b zcf. Instances of the first variant are \nconstructed with the zCl function, which takes a value of type TI and constructs a value of type t. They \nare deconstructed with Zdl. Instances of the sec-ond variant are constructed with xCr given a value of \ntype r, and deconstructed with Zdr. Applying a deconstructor to the wrong variant signals a run-time \nerror. To distinguish variants, the q function returns true for an instance of the first variant and \nfalse for an instance of the second. The TI and rr type expressions can refer to t or other type variables \nto form recursive or mutually recursive type definitions. We assume that the core language for UNITY \nprovides a letrec form for mutually recursive procedure and datatype definitions. The type of a unit \nexpression is a signature of the form sig imports exports T where imports specifies the kinds and sour \nnative code compiler transforms a unit expression to a shared library that is managed by the operating \nsystem. Although the only kind in this language is a, we declare kinds ex-plicitly in anticipation of \nfuture work that handles type constructors and polymorphism. til::K;il C ti2::Kiz tel::n,l > t&#38;!::n&#38;! \nVJlil:7;1 E 1;1:7i1,31;1 :Ti2 E li2:Tiz : 7i2 2 Ti1 761 2 Tb2 Vx,2:7e2 E 1,2:7.?2, 3x,2:Tel E x,l:T,l \n: Tel < 7.52 sig[il , ef , bl] 5 sig[i&#38;, e2, b2] rl-e:7 7 17 rkse : 7 Figure 14: Subtyping and subsumption \nin UNITY signatures types of a unit s imports and exports describes the kinds and types of its exports. \nIn a sig form, as in a unit form, types in either imports or exports can be used in the type expressions \nwithin the signature. The type expression T is the type of the unit s initialization expression, which \ncannot depend on type variables listed in exports. 4.2.1 UNITY Type Checking For economy, we introduce \nthe following unusual abbrevia-tion, which summarizes the content of a signature with the indices used \non names: sig[i, e, 61 S sig import tiZZK2.i Zi:ri export t e::ICe 2e:7e Tb Signatures have a subtype \nrelation to allow the use of specialized units in place of more general units. As defined in Figure 14, \na specific signature t, is a subtype of a more general signature t, (t, 5 ts) if: 1. the type of the \ninitialization expression in t, is a sub- type of the one in t,; 2. t, has fewer imports and more exports \nthan t,; 3. for each imported variable in t,, its type in t, is a subtype of its type in t,; and 4. \nfor each exported variable in t,, its type in tr is a sub- type of its type in t,.  The typing rules \nfor UNITY are shown in Figure 15. These rules are typed extensions of the rules from Section 4.1.4. The \nspecial judgement I-$ is used when subsumption is al- lowed on an expression s type. Subsumption is used \ncare-fully so that type checking is deterministic. For example, subsumption is not allowed for the e, \nexpression in the in-voke rule because the initialization expression type rb in e, s signature supplies \nthe type of the entire invoke expres-sion. The first typing rule checks the well-formedness of a sig- \nnature. Each of the type expressions in a signature must be well-formed in an environment containing \nthe signature s imported and exported type variables, and the type expres-sion for the initialization \nexpression must not refer to any of the exported type variables. The second rule checks invoke expressions, \nfust ensuring that the with clause is well-formed. The first expression in an invoke form must have a \nsignature type whose imports match the with clause. The exports in the signature arc ig- nored. The initialization \nexpression s type in this signature is the type of the complete invoke expression. 27~~ distinct r I-7~ \n:: fi r l-3 :: K r tsz : ? r l-k, : sig[i,e, b] r' = r,qiig,m FTV(Tb) l-l c = 0 sig[i, e, b] 5 Sig import \nG z:i export 0 7b r' tTi :: K, r' he :: Ke r' t-76 :: 0 r t-sig[i, e, b] :: Cl I- t-invoke e, with t::n \n= 0 2:7 ** Tb ~uTu~u~uZ$JE&#38;T&#38;SJ~ distinct t,::&#38;uX,:Te c t::nuz:7UX,,:T, + tuX,,I:t + T1ulcr:T, \n+ tuXd,:t --t T&#38;k&#38; + bool r hig[i, e, b] :: il r' = r, ti ::hi, t::R r'kq :: i-2 r'bc :: i-2 \nr'w :: 51 r =r ,m,mtrxdl:t -+ T,,~~~:T~ -+ t,Xd,:t -b Tr,ft:t + bOOI r t-z : ? r teb : Tb I r l-unit \nimport ti::Ki Ii:7; export te::rie Ze:Te type t = cl, dl 71 1 xcrr dr Tr b St Val x:7 = i in eb : sig[i, \ne, b] tiUtplUtp2U@JzplUlpZ distinct CUz distinct twl::KwlUZ,1:7,1 5 ti::~iUtpa::~p2Uzi:7iUXp~:TpZ tw2::tcw2ux,2:7,2 \nc ti::r;,ut,luli:TilJlpl te::KeUXa:Te c tplutpZuXpl:TplU p2 r t-e1 : sig[il, el, bl] r l-e2 : sig[i%, \ne2, b2] r I-sig[wf ,pf, bl] :: Cl l? tsig[w2,pd, b2] :: fl sig[df , el , bl] 5 sig[wl, pl , bl] sig[i&#38;, \ne2,62] 5 sig[w2, p2, b2] r ksig[i, e, b2] :: fl I? k-compound import ti::tii xi:Ti export t,::~, de:~e \nlink er with twl::tc,l z,~:T~I provides tpl::npl rpl -- - and c2 with t,,,z::tc,z x,2:7,2 provides tp2::np2 \nxcpz:rP2 : sig[i, e, b2] Figure 15: Type checking for UNITY - The third rule determines the signature \nof a unit expres-4.2.3 Type Soundness sion. The first line of antecedents contains simple context-If \nwe were to combine UNITY with the monomorphic subset of sensitive syntax checks as in UNITd. In the second \nline, all ML, we could prove a Milner-style type soundness theoremof the type expressions in the unit \nare checked in an en-using a subject reduction argument along the lines of Wright vironment that is extended \nwith the unit s imported and and Felleisen [31]. defined types. Once the type expressions are validated, \nthe environment is extended again, this time with the types for imported and defined variables. Finally, \nthe types of all 4.2.4 UNITY Implementation definition expressions are verified. Subsumption is allowed \nClosed units in UNITY can be compiled separately in thefor all expressions except the initialization \nexpression, which same way as closed functors in ML. When compiling a unit, helps determine the overall \nsignature for the unit. imported types are obviously not yet determined and thusThe fourth and final \nrule verifies the linking in a cotn- have unknown representations. Hence, expressions involvingpound \nexpression and determines its signature. The first imported types must be compiled like polymorphic func-four \nlines of antecedents are simple context-sensitive syntax tions in ML [19, 281. Otherwise, the restrictions \nimpliedchecks. Then, the constituent unit expressions are checked, by a unit s interface allow inter-procedural \noptimizationsobtaining signatures for the constituent units. Each of these within the unit (such as inlining, \nspecialization, and dead-signatures must approximate a signature derived from the code elimination). \nFurthermore, since a compound unit iswith and provides clauses in the corresponding linking equivalent \nto a simple unit that merges its constituent units,line. Finally, the signature of the compound unit \nis de-intra-unit optimization techniques naturally extend to in- fined by the import and export clauses \nand the type of ter-unit optimizations when a compound expression hasthe initialization expression in \nthe second constituent unit. known constituent units.  4.2.2 UNITY Evaluation 4.3 Units with Type Dependencies \nand Equations The reduction rules for UNITY are nearly the same as the UNIT, supports a core language \nwhere each type is associ- rules for UNITd in Figure 11. The omy difference for UNITY ated with a distinct \nand independent constructor, but thisis that the invoke and compound reductions propagate view of types \nis too strict for many languages. For example, type definitions as well as val definitions. in Java, \nthe constructor that instantiates a class depends on the constructor for the superclass. Other languages, \nsuch as 761 5 762 til::Kil C ti2::&#38;2 tel::n,l _3 t,2::&#38;Q type-defn = typet :: n=o signature \n= sig imports exports depends dependency * T dependency = t-t Figure 16: Syntax for UNITY (type equations) \n ML, support type equations that introduce new types with-out explicit constructors; a type equation \nof the form type t = T defines the type variable t as an abbreviation for the type expression r. Naively \nmixing units with type dependencies and equa-tions leads to problems. Since two units can contain mutu-ally \nrecursive definitions, linking units with type dependen-cies may result in cyclic definitions, which \ncore languages like ML and Java do not support. To prevent these cycles, signa- tures must include information \nabout dependencies between imported and exported types. The dependency information can be used to verify \nthat cyclic definitions are not created in linking expressions. UNITY extends UNITY with type dependencies \nand equa-tions. Figure 16 defines syntax extensions for UNIT*, includ-ing a new signature form that contains \na depends clause. The dependency declaration t, u t; means that an exported type t, depends on an imported \ntype t;. When two units are linked with a compound expression, tracing the set of dependencies can ensure \nthat linking does not create a cyclic type definition. Also, the signature for a compound expres-sion \npropagates dependency information for types imported into and exported from the compound unit. 4.3.1 \nUNITY Type Checking The following abbreviation expresses a UNITY signature: sig[i, e, di, de, b] E sig \nimport ti::Ki 2i:~i export t ,=::Ke x,:re depends tde cc3 tdi Tb The subtyping rule in Figure 17 accounts \nfor the new depen- dency declarations. Specifically, a signature is more specific than another if it \ndeclares more dependencies. The type checking rules for UNITY are defined in Fig-ure 19. To calculate \ntype dependencies, the type checking rules employ the depends on relation, cxn. It associates a type \nexpression with each of the type variables it references from the set of type equations D: i- rx~ t iff \nt E FTV(7) or (g(t = T ) ED : t E FTV(T) and T c(n t) FTV(T) denotes the set of type variables in T \nthat are not bound by the import or export clause of a sig type. Type abbreviations are eliminated from \na type or expression with the 1 s (n operator, as sketched in Figure 18. The subscript is omitted from \n1 s In when D is clear from context.  4.3.2 UNIT* Evaluation Given a type equation of the form type \nt = I, the va&#38; able t can be replaced everywhere with T once the complete tdel -tdil c tde2 cc, tdi2 \nt/Xi1 :Til E Xi1 :Til s 3Xil :Ti2 E Xi2:Ti2 : Ti2 _< Til vX.2:7,2 E Xe2:7,2,3Xe2:Tel E X,l:T,l : Tel \n5 Te2 sig[il, ef , dil, def , bf] 5 sig[id, e2, di2, de2, b2] Figure 17: Subtyping in UNITY signatures \n program is known. Since the type system disallows cyclic type definitions, this expansion of types as \nabbreviations is guaranteed to terminate. Meanwhile, until the complete program is known, type equations \nare preserved as neces- sary. In the rewriting semantics for units, type equations are preserved by linking, \nand then expanded away by in-vocation. This semantics formalizes the intuition that type equations constrain \nhow programs are linked, but they have no run-time effect when programs are executed. The reduction rules \nfor UNITY are nearly the same as the rules for UNITd (see Figure 11) or UNITY. Like in UNITY, UNIT, S \ninvoke and compound reductions propagate type definitions as well as val definitions. In addition, the \ncom-pound reduction propagates type abbreviations, but the invoke reduction immediately expands all type \nabbrevia-tions in the invoked unit. 5 Other Extensions Experience with other modules systems, particularly \nthose of ML, suggests further extensions to UNIT., such as facil- ities for exposing the implementation \nof a type, hiding the type (or parts of the type) of a value, or type sharing. The first two of these \nextensions are straightforward additions to UNIT., but the unit analogue of the last one is less clear. \nIn the following subsections, we briefly discuss each of these concepts. 5.1 Exposing Type Information \nThe ML module system allows signatures that reveal some information about an exported type [12, 201. \nThe partially exposed types (or translucent types) are used for propagating type dependencies in a way \nthat allows type sharing, but they are also useful for assigning a name to a complex type that is exposed \nto clients. Consider exporting values of type enw from an Environ-ment unit such that enw is revealed \nas a procedure type. As shown in Figure 20, the translucent type enw in this case may be viewed as a \ntype abbreviation that is preserved within the signature. The unit Environment does not ex-port the type \nenu. Instead, the unit and its signature are extended with an extra section that defines the abbreviation \nenw. The resulting unit and signature are equivalent to the unit and signature that expands ens in all \ntype expressions. 5.2 Hiding Type Information Large projects often have multiple levels of clients. \nSome of the clients are more trusted than others and are thus privy to more information about the implementation \nof certain abstractions. To support this situation, UNIT. could pro-vide mechanisms for hiding a value \ns type information from untrusted clients after linking with trusted clients. if and t@D T=t if ~=t \nand (t = T ) ED if 7=7 +7 export t,::n; m if T=Sig[i, e, di, de, b] --and D = {(t = T)l(t = T) E D and \nt $ tiUte} depends tde +L+ tdi if e=c Unit hlpOrt ti::Ki Xi:Ti export t .$::n, Ze:7c if e=Unit import \nti::Ki Xi:Ti export t,::n, ze:7e type t,::n, = r. type t = Zcl, dl 71 , Xcr,Zd, 71. b xt vd x:7 = e in \neb and D = {(t = T)l(t = T) E D and t @ tiUteUt*Uq . . . Figure 18: Expanding a type or expression \nwith respect to a set of type abbreviations =gz GgFy r =r,~,Ezz F i v(Tb) fl z = 0 l? I-T :: K , r t-T, \n:: ne r kTb :: a r I-sig[i, e, di, de, b] :: Cl ~lJkJ~U?F;jUZ &#38;J~3$W&#38;J?f distinct -------e tc::KcuXe:Te \nc wu=UI:7UXc,:T, -+ tuXd,:t -+ T,uXc,:Tr --f tuXd,:t + T,uXt:t + boo1 D = (ta = 7,~) To CXD t; j T; $0 \nto for (ta = Ta),(t; = T;) E D t&#38;U tdi = {ta ?, ti 1 (ta = To) E D and ti E G and ta E G and Ta CX~ti) \nr I-sig[i,e, di, de, b] :: fi l? = r, ti::K;, t::fl r; = I?,z%i r; t Ta :: a, r i-jq :: n r-1 k1?;1 :: \na r c-p1 :: i-2 r l = r ,Xi:ITil,Xcl:1T~l -+ ,t,,Xd,:,t, --t ~T~I,x~~:IT~I + ,t,,&#38;,r:,t, + [Trl,It:Itl \n+ boo1 r hlal : 171 r klebl : Tb r t-unit import ti::Ki zi:7i export te::ne xe:Te type ta:xEa = Ta type \nt = Z,I,ldl 71 1 xcr,zdr Tr D dt val x:7 = e in eb : sig[i, e, di, de, b] tiUtplUtpZUKUT$JzpZ distinct \n~UZ distinct t,l ::K,luX,1:T,,,l s ti::RiUtp2:: p2um:7iUlp2 tw2::Kw2uXw2:Tw2 c ti::Kiutpl::KplU~~ te::neUde:7e \nc tpl::Kplutp2::np2uXp1:7plUdp2:7pi r l-e1 : sig[if , ef , dil, del, bl] r l-e2 : sig[i2, e2, di2, de2, \nb2] r t-sig[wl ,pf , dil ,&#38;I, bl] :: Cl I? +sig[w2,p2, di2, de2, b2] :: f2 sig[il, ef , dif , de1 \n, bf] 5 sig[wf , pl , dif , de1 , bl] sig[it, e2, die,de2, b2] 5 sig[w2,p2, di2, de2, b2] l? I-sig[i, \ne, di, de, b2] :: fi (tdilr tdel) f-l (tdc.2, tdi2) = 0 tde ^rt tdi = (te w ti I ti E q and te E c and \nte cu ti E t&#38;l w t&#38;rut&#38;Z u t&#38;2 r f-compound import ti::Ki Xi:Ti export tc::&#38; xc:Te \nlink el with t,,,l::tcwl z,,,l:~,,,r provides tpl::npl zpl and es with t,,,p::n,2 ~~2:7~2 provides t,2::nP2 \nXp2:Tp2 : sig[i, e, di, de, b2] Figure 19: Type checking for UNITY Consider the example in Figure 21. \nThe Environment RecEnv, which combines Environment and Letrec. unit is linked with the Letrec unit, allowing \nthe latter to As shown in Figure 21, information about RecEnv s ex-exploit the implementation of environments \nas procedures. ports can be restricted via explicit signatures and an ex-In contrast, other clients should \nnot be allowed to exploit tended subtype relation. The extended relation allows a the implementation \nof environments. Hence, the type of subtype signature to contain an extra exported type vari-environments \nshould be opaque outside the compound unit able (e.g., env) in place of an abbreviation in the supertype \nEnvironment Environment7s . . . 1 fun extend env n v = *a* ettend:(name+value)~namexvalue-+(name-+value) \nFigure 20: Exposing information for a type ZecEnv . * . Environment . . . fun extend env n v = . -. \n env = name+value :r--__-_*. y-----7 I I . . . env::fl extend:envx namex value-tenv recE&#38;end: envx \nnamesx values-+env b__--_-------- Figure 21: Hiding type information for an exported value signature. \nAs a result, the information formerly exposed by the abbreviation becomes hidden, replaced by an opaque \ntype. 5.3 Sharing Type sharing specifications are used to solve the diamond import problem for ML [22]. \nSuppose a particular symbol structure is provided to both a lezer functor and a parser functor. If both \nlever and parser export the type sym as originating from symbol (via translucent types), the struc-tures \nreturned by parser and leser can be joined by a functor that accepts structure arguments agreeing on \nthe sym type. This agreement prerequisite is declared via a type sharing specification. In UNIT., the \ndiamond import problem is solved by linking leser, parser, and symbol together at once. However, the \nunit model provides nothing like after-the-fact sharing specifications; thus, if lever and parser are \ncompound units that contain internal instances of symbol, then symbol is in- stantiated twice and there \nis no way to unify the two sym types. Type sharing is more flexible than unit linking in one im- portant \ncase. Suppose that lever links to many structures and has many clients. In addition, suppose that most \nof the clients share types with only a few of the structures. In ML, each client can conveniently declare \na few after-the- fact sharing declarations. In UNITY, if lever requires many imports, each of lezer s \nclients must provide aII of those im- ports, regardless of how few imports need to be shared. This example \nillustrates a problem of specifying urhich units need to be linked, rather than horn to link them. As \nexplained in the introduction, integrating units with the core language provides power for selecting \nwhich units to link. Future work must explore how core language features can be used to ex- press complex \nlinking patterns for units, and whether our model needs adjustment to accommodate common re-use patterns. \n6 Related Work As already mentioned in Section 2, our unit model incorpo-rates ideas from distinct language \ncommunities, particularly those using packages and ML-style modules. The Scheme and ML communities have \nproduced a large body of work exploring variations on the standard module system, espe-cially variations \nfor higher-order modules [2, 4, 12, 16, 18, 20, 21, 23, 291. Duggan and Sourelis [S] have investigated \nmixin modules for specifying recursive and extensible defi-nitions across modules; their work and ours \nhave no overlap. Cardelli [3] anticipated the unit language s emphasis on module linking as welI as module \ndefinition. Our unit model is more concrete than his proposal and addresses many of his suggestions for \nfuture work. Kelsey s proposed module system for Scheme [I71 captures most of the organizational properties \nof units, but does not address static typing or dynamic linking. 7 Conclusion Program units deliver both \nthe traditional benefits of mod- ules for separate compilation and the more recent advances of higher-order \nmodules and programmer-controlled linking. Our unit model also addresses the often overlooked, but in-creasingly \nimportant, problem of dynamic linking. The unit language was originally implemented for the development \nof DrScheme [7, 251, Rice s Scheme program- ming environment, which is implemented using MzScheme. DrScheme \nis a large and dynamic program with many in-tegrated components, including a multimedia editor, an in- \nteractive evaluator, a syntax checker, and a static debugger. Additional components can be dynamically \nlinked into the environment. DrScheme also acts as an operating system for client programs that are being \ndeveloped, launching client programs by dynamically linking them into the system while maintaining the \nboundaries between clients. Future work must focus on making units syntactically practical for typed \nlanguages. Our text-based model is far too verbose, and we do not address the design of a linking language. \nInstead, we provide a simple construct for linking units and rely on integration with the core language \nto build up linking expressions. This integration simplifies our pre-sentation, and we believe it is \nan essential feature of units. Nevertheless, future work must explore more carefully the implications \nof integrating the core and module languages. Acknowledgements The authors would like to thank Robby \nFindler for early contributions to this work, and Cormac Flanagan, Bob Harper, Richard Kelsey, Shriram \nKrishna-murthi, Peter Lee, Didier R&#38;my, Scott Smith, Paul Steckler, and J&#38;&#38;me VouiIIon for \nstimulating discussion and com-ments on the paper. Thanks also to the anonymous re-viewers for their \ncomments. Special thanks to Shriram for suggesting the title. References BARNES, J. G. P. Programming \nin Ada 95. Addison- PI Wesley, 1996. BISWAS, S. K. Higher-order functors with transparent PI signatures. \nIn Proc. ACM Symposium on Principles of Programming Languages (1995), pp. 154-163. CARDELLI, L. Program \nfragments, linking, and modu- larization. In Proc. ACM Symposium on Principles of Programming Languages \n(1997), pp. 266-277. [31 CURTIS, P., AND RAUEN, J. A module system for [41 Scheme. In Proc. ACM Conference \non Lisp and Func-tional Programming (1990), pp. 13-28. DUGGAN, D., AND SOURELIS, C. Mixin modules. In \nProc. ACM International Conference on Functional Programming (1996), pp. 262-273. [51 FELLEISEN, M., \nAND HIEB, R. The revised report on the syntactic theories of sequential control and state. Tech. Rep. \n100, Rice University, June 1989. Theoretical Computer Science, volume 102, 1992, pp. 235-271. PI FINDLER, \nR. B., FLANAGAN, C., FLATT, M., KRISH-NAMURTHI, S., AND FELLEISEN, M. DrScheme: A pedagogic programming \nenvironment for Scheme. In Proc. International Symposium on Programming Lan-guages: Implementations, \nLog&#38;, and Programs (1997), pp. 369-388. PI FLATT, M. PLT MzScheme: Language manual. Tech. Rep. TR97-280, \nRice University, 1997. PI FLATT, M., KRISHNAMURTHI, S., AND FELLEISEN, M. Classes and mixins. In Proc. \nACM Symposium on Prin-ciples of Programming Languages (1998), pp. 171-183. 191 GOSLING, J., JOY, B., \nAND STEELE, G. The Java Language Specification. The Java Series. Addison-Wes- ley, Reading, MA, USA, \nJune 1996. PO1 P11 HARBISON, S. P. Mod&#38;-3. Prentice Hall, 1991. PI HARPER, R., AND LILLIBRWGE, M. \nA type-theoretic approach to higher-order modules with sharing. In Proc. ACM Symposium on Principles \nof Programming Languages (1994), pp. 123-137. P31 HARPER, R., MITCHELL, J., AND MOGGI, E. Higher-order \nmodules and the phase distinction. In Proc. ACM Symposium on Principles of Programming Languages (1990), \npp. 341-354. P41 HARPER, R., AND STONE, C. A type-theoretic seman-tics for Standard ML 1996. Submitted \nfor publication, 1997. 1151 HUDAK, P., AND WADLER, P. (EDs.). Report on the programming language HaskeII. \nTech. Rep. YALE/DCS/RR777, Yale University, Department of Computer Science, Aug. 1991. [I61 JAGANNATHAN, \nS. Metalevel building blocks for modu- lar systems. ACM Transactions on Programming Lan-guages and Systems \n16, 3 (May 1994), 456-492. KELSEY, R. A. Fully-parameterized modules or the b71 missing link. Tech. Rep. \n97-3, NEC Research Institute, 1997. LEE, SHINN-DER AND DANIEL P. FRIEDMAN. Quasi- 1181 static scoping: \nSharing variable bindings across multi-ple lexical scopes. In Proc. ACM Symposium on Prin-ciples of Programming \nLanguages (1993), pp. 479-492. LEROY, X. Unboxed objects and polymorphic typing. [W In Proc. ACM Symposium \non Principles of Program-ming Languages (1992), pp. 177-188. LEROY, X. Manifest types, modules, and separate \ncom- WI pilation. In Proc. ACM Symposium on Principles of Programming Languages (1994), pp. 109-122. \nLEROY, X. Applicative functions and fully transparent higher-order modules. In Proc. ACM Symposium on \nPrinciples of Programming Languages (1995), pp. 142-[211 153. MACQUEEN, D. Modules for Standard ML. In \nProc. ACM Conference on Lisp and Functional Programming (1984), pp. 198-207. WI MACQUEEN, D. B., AND \nTOFTE, M. A semantics for higher-order functors. In European Symposium on Programming (Apr. 1994), Springer-Verlag, \nLNCS 788, pp. 409-423. 1231 MILNER, R., TOFTE, M., AND HARPER, R. The Def-inition of Standard ML. The \nMIT Press, Cambridge, Massachusetts and London, England, 1990. [24l RICE UNIVERSITY PLT. DrScheme. URL: \nwww.cs.rice.edu/CS/PLT/packages/drscheme/. k51 @I SARASWAT, V. Java is not type-safe, Aug. 1997. URL: \nwww.research.att.com/Nvj/bug.html. SUNSOFT. SunOS 5.5 Linker and Libraries Manual, 1996. [271 [281 TARDITI, \nD., MORRISETT, G., CHENG, P., STONE, C., HARPER, R., AND LEE, P. TIL: A type-directed op-timizing compiler \nfor ML. In Proc. ACM Conference on Programming Language Design and Implementation (1996), pp. 181-192. \nWI TOFTE, M. Principal signatures for higher-order pro-gram modules. In Proc. A CM Symposium on Principles \nof Programming Languages (1992), pp. 189-199. 1301 WIFLTH, N. Programming in Modula-2. Springer-Verlag, \n1983. [311 WRIGHT, A., AND FELLEISEN, M. A syntactic ap-proach to type soundness. Tech. Rep. 160, Rice \nUni-versity, 1991. Information and Computation, volume 115(l), 1994, pp. 38-94.  \n\t\t\t", "proc_id": "277650", "abstract": "A module system ought to enable <i>assembly-line programming</i> using separate compilation and an expressive linking language. Separate compilation allows programmers to develop parts of a program independently. A linking language gives programmers precise control over the assembly of parts into a whole. This paper presents models of <i>program units</i>, MzScheme's module language for assembly-line programming. Units support separate compilation, independent module reuse, cyclic dependencies, hierarchical structuring, and dynamic linking. The models explain how to integrate units with untyped and typed languages such as Scheme and ML.", "authors": [{"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Department of Computer Science, Rice University, Houston, Texas", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/277650.277730", "year": "1998", "article_id": "277730", "conference": "PLDI", "title": "Units: cool modules for HOT languages", "url": "http://dl.acm.org/citation.cfm?id=277730"}