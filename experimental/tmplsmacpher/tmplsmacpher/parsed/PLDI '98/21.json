{"article_publication_date": "05-01-1998", "fulltext": "\n Eliminating Array Bound Checking Through Dependent Types* Hongwei Xi Department of Mathematical Carnegie \nMellon University Sciences Frank Pfenning Department of Computer Carnegie Mellon University Science hwxiQcs.cmu.edu \nfp@cs.cmu.edu Abstract We present a type-based approach to eliminating array bound checking and list \ntag checking by conservatively extending Standard ML with a restricted form of dependent types. This \nenables the programmer to capture more invariants through types while type-checking remains decidable \nin the- ory and can still be performed efficiently in practice. We il- lustrate our approach through \nconcrete examples and present the result of our preliminary experiments which support sup-port the feasibility \nand effectiveness of our approach. 1 Introduction The absence of run-time array bound checks is an infamous \nsource of fatal errors for programs in languages such as C. Nonetheless, compilers offer the option to \nomit array bound checks, since they can turn out to be expensive in prac-tice (Chow 1983; Gupta 1994). \nIn statically typed languages such as ML, one would like to provide strong guarantees about the safety \nof all operations, so array bound checks cannot be omitted in general. The same is true for Java bytecode \ninterpreters or compilers (Sun Microsystems 1995) and proof-carrying code (Necula 1997), which are aimed \nat providing safety when transmitting code across a network to be executed at a remote site. Tag checking \nin functional languages is similar to array bound checking. For example, we can more efficiently ac-cess \nthe tail of a list if we know that the list is non-empty. This kind of situation arises frequently in \ndynamically typed languages such as Scheme, but it also arises from the com-pilation of pattern matches \nin ML. Traditional compiler optimizations do not fare well in the task of eliminating redundant array \nbound checks, so some special-purpose methods have been developed for automated analysis (see, for example, \n(Markstein and Markstein 1982; Gupta 1994)). With some notable exceptions (see below) these methods try \nto infer redundant checks without pro- *This research was sponsored in part by the Advanced Research \nProjects Agency CSTO under the title The Fox Project: Advanced Languages for Systems Software , ARPA \nOrder No. C533. P~tision to nuke dioitsl or herd copies of all or part of this Work for penm., w cla..,oom \nu.e I. granted without I*8 provided that copies are not made or distributed for profit or commwciel advan-tage \nand that copies beer this notice and the full citation On the first PWe. To copy otherwise. to republish, \nto post on ~erwws of to redistribute to lies. requires prior specific permission and/or a tn. SIGPLAN \n98 Montraal. Canada c) 1998 ACM 0-89791.987-4/98/0006...(6.00 grammer annotations and are thus limited \nby their ability to synthesize loop invariants-a problem that is in theory undecidable and in practice \nvery difficult (Susuki and Ishi-hata 1977). In contrast, we pursue a type-based approach within a language \nalready statically typed, namely ML. We rely on the programmer to supply some additional type in-formation, \nwhich is then used by the compiler to reduce static array bound checking to constraint satisfiability. \nThe constraints consists of linear inequalities and can be solved efficiently in practice. This approach \nleads to several language design and im- plementation questions, to which this paper provides a pos- \nsible answer. We have validated our ideas through a proto- type implementation for a fragment of ML large \nenough to encompass several standard programs, taken from existing library code. Our experiments demonstrate \nthat the required extended type annotations are small com-pared to the size of the program, the constraints \nwhich arise during extended type check-ing can be solved efficiently in practice, and the compiled code \ncan be significantly faster. Moreover, with one exception (where we had to replace on occurrence of \n< by 2) we did not have to modify the existing code, only extend it with some annotations. Our approach \nis based on the notion of dependent type (Martin-LGf 1980) which allows types to be indexedby terms. \nFor example, in ML we have a type of integer lists int list. Using dependent types we can express the \nmore precise type of integer lists of length 2 as int list (2). In this example, 2 is the index object. \nAn function for appending two inte-ger lists would have type int list(n) -> int list(m) -> int list (n \n$ m) for any n and m. Unfortunately, with-out any restrictions on the form of index objects, automatic \ntype-checking in a language with dependent types is unde- cidable and impractical. We avoid such problems \nthrough the combination of several important ideas: l We separate the language of type indices from the \nlan- guage of terms. Among other things, this separation avoids the question of the meaning of effects \nin type indices and permits a clear phase distinction between type-checking and evaluation. We are not \naware of any empirical study regarding its practical significance. assert and length sub (1 <I {n:nat) \na {n:nat) {i:nat array(n) -> int(n) 1 i < n) a array(n) * int(i) -> a fun dotprod(v1, ~2) = let fun \nloop(i, n, sum) = if i = n then sum else loop(i+l, n, sum + sub(vl, i) where loop <I {n:nat} Ci:nat 1 \ni <= n) in loop(0, length VI, 0) end where dotprod (1 Cp:nat} {q:nat 1 p <= q } int * sub(v2, i)) int(i) \n* intfn) array(p) * int * int array(q) -> int -> int Figure 1: The dot product function l We employ \nsingleton types (Hayashi 1991) to allow the necessary interaction between the index and term lan-guages. \nl We only consider programs which are already well-typed in ML. This allows our extension to be con-servative, \nthat is, without the use of dependent types, programs will elaborate and evaluate exactly as in ML. l \nWe use bidirectional type analysis to generate linear inequality constraints with a minimum of annotations. \nl The resulting constraints can be solved efficiently in practice with a variant of Fourier s method \n(Pugh and Wonnacott 1992). Besides the fact that programs run faster (which tends to be a strong motivator \nfor programmers), our system en-hances many of the benefits one derives from static typing. The dependent \ntypes help the programmer to think about the properties he expects to hold, and many (often trivial) \nerrors can be detected early, during dependent type checking rather than at run-time. The dependent type \nannotations serve as formal and machine-checked documentation of pro- gram invariants which greatly aids \nmaintainability through-out the software life-cycle. Dependent types allow program invariants and properties \nto be communicated and checked across module boundaries if they are included in signatures. Most closely \nrelated to our work is the work on shape checking by Jay and Sekanina (Jay and Sekanina 1996). They also \npursue a language-based approach with a restricted form of dependent types. However, their language and \npro- grams are rather restricted and different from the kind of programs typically written in ML (including, \nfor example, explicit shape conditionals). This allows them to perform shape analysis through a process \nof partial evaluation rather than constraint simplification, but it does not seem to in-teract well with \ngeneral recursion. We believe that their approach is well-suited for languages such as NESL (Blel-loch \n1993), but that it is too restrictive to be practical for ML. Dependent types also form the basis of \ngeneral theorem proving and verified program development environments such as Coq (Dowek, Felty, Herbelin, \nHuet, Murthy, Parent, Paulin-Mohring, and Werner 1993), Nuprl (Constable et al. 1986), or PVS (Owre, \nRajan, Rushby, Shankar, and Srivas 1996). We have not not yet explored this possibility in our prototype \nimplementation, which is restricted to the core language. Our work can be seen as an attempt to narrow \nthe gap be- tween full verification, which often only works for unrealis- tically small languages or \nis too time-consuming for practic- ing programmers, and static type systems for programming languages, \nwhich allow only a very restricted set of pro- gram properties to be expressed and checked. In this way, \nour work is also related to work on refinement types (Free-man 1994; Davies 1997) in which ML types are \nrefined into finitely many inductively defined sorts. This work is part of a larger effort to introduce \ndepen-dent types over tractable constraint domains into ML (Xi 1998). In particular, the basic language \narchitecture and the elaboration algorithm which generates index constraints do not depend on particular \nproperties of linear arithmetic and can be used to capture other program invariants. 2 Preliminaries \nIn this section we sketch our type system and give some illustrative examples. Please see (Xi 1998) for \na formal de-scription. 2.1 An introductory example The code in Figure 1 is an implementation of the dot \nprod- uct on integer arrays. Even automatic methods are able to eliminate array bounds checks for this \nexample-we use it here to introduce the language, not to illustrate its full expressive power. This example \nshould be read as follows. int (n) is a built-in singleton type which contains only the integer n. The \ntype int used later is the type of all integers. a array(n) is a built-in polymorphic type of arrays \nof size n whose elements are of type a. length <I {n:nat} a array(n) -> int (n) expresses that length \nis a function which, when given an array of size n yields an integer of type int (n) (which must therefore \nbe equal to n). In a full language implemen-tation, this would be a pervasive declaration; here, we assert \nit explicitly. sub <I {n:nat} {i:nat 1 i < n} a array(n) * intfi) -> a means that sub can only be applied \nto an array of size n and an integer i such that i < n holds. It always yields a a value of type a. \nWe use {n:nat} as an explicit universal quantifier or dependent function type constructor. Conditions \nmay be attached, so they can be used to describe certain forms of subset types, such as {n:nat I i < \nn} in the example. The two where clauses are present in the code for type-checking purposes, giving the \ndependent type of the local tail-recursive function loop and the function dotprod itself. After type-checking \nthe code, we are sure that the array ac-cesses through sub cannot result in array bound violations, and \ntherefore there is no need for inserting array bound checks when we compile the code. Similarly, if we \nuse an array update function update with the following type, update <l {n:nat) (i:nat I i < n) a array(n) \n* int(iI * a -> unit then no array bound checks are needed at run-time. Notice that we can also index \nlists (and not just arrays) by their lengths and declare nth (1 {l:nat) Cn:nat I n < 11 a list(l) * int(n) \n-> a thereby eliminating the need for list tag checks. Because of the similarity of our approach to \neliminating array bound checks and list tag checks, we shall focus on the former in this paper. 2.2 \nThe language of types Type indices may be integer or boolean expressions of the form defined below. We \nuse a to range over index variables. Integer index i, j ::= ali+jl;-jl;*jJdiv(i,j) 1min(i, j) I maz(i, \nj) 1abs(i) 1sgn(i) 1mod(i,j) Boolean index b ::= a (false 1 true ( i < j 1i < j Ii=jli>jli>j I -b I \nbl A bz I 61 v bz Index d ::= ilb We also use certain transparent abbreviations, such as 0 5 i < n which \nstands for 0 2 i A i < n. A system of dependent types allows types to be indexed by terms. For the purpose \nof this paper, indices are re-stricted to the integer and boolean expressions given above, with the additional \nconstraint of linearity. We have consid-ered a more general language schema in (Xi 1998). We use 6 for \nbase types or basic type families, either built-in (such as int or array) or user-declared. cy stands \nfor type variables as usual. index sort y ::= int 1 boo1 I {a : y I b} types T ..- cr 1 (71,. . . , T,z)d(dl, \n. . . ,dk) ) T] * . . . * T?I 1 71 -+ n 1IIIa : 7.7 1 Ca : 7.7 When a type constructor has no arguments \nor no indices, we omit the empty parentheses on the left or right or the constructor, respectively; when \na product has no compo-nents we write unit. The sort {a : y 1b} stands for those elements of y satisfy-ing \nthe boolean constraint b. We use nat as an abbreviation for {a : int 1a 2 0). Also notice that a is universally \nquan-tified in Ha : 7.7 and existentially quantified in Ca : 7.7. In the concrete syntax, we use {a:g} \nt for Ha : -y.r and Ca:gl t for Ca : 7.r. We can combine several quantifiers by separating the quantified \nvariables by commas and directly attach a condition to the quantifier. So ITa : {a : y I b}.r can be \nwritten as {a:g 1 b} t. We took advantage of these shorthands in the dot product example above. Our language \nextension is intended to encompass all of Standard ML. Our current prototype implementation in-cludes \nrecursion, higher-order functions, polymorphism (with a value restriction), datatypes, pattern matching, \nand ar-rays, but at present no exceptions or module-level constructs, which are left to future work. \nWe believe that only the ex-tension to modules involves non-trivial language design is-sues. 2.3 Built-in \ntype families We have built-in type families for integers, booleans and arrays. l For every integer \nn, int (n) is a singleton type which only contains n. l For false and true, boo1 (f alse) and boo1 (true) \nare singleton types which only contain false and true, respectively. l For a natural number n, a array(n) \nis the type of arrays of size n whose elements are of type a. Indices may be omitted in types, in which \ncase they are interpreted existentially. For example, the type int array stands for Cn : nat.int array(n), \nthat is, an integer array of some unknown size n. 2.4 Refinement of datatypes Besides the built-in type \nfamilies int, bool, and array, any user-defined data type may refined by explicit declarations. An an \nexample, consider the declaration of a list: datatype a list = nil 1 :: of a * a list After this declaration, \nthe constructor nil has type a list and :: is of type a * a list -> a list. The following declaration \nindexes the type of a list by a natural number representing its length. typeref a list of nat with nil \n<I a list(O) I : : (1 Cn:nat) a * a list(n) -> a list(n+lI The structure of the dependent types for \nthe constructors nil and : : must match the corresponding ML types. Figure 2 displays an implementation \nof the reverse func-tion on lists. Notice that the type of reverse ensures that this function always \nreturns a list of length n when given one of length n. This illustrates the need for giving explicit \ntypes to lo-cal functions (rev, in this case), since they are often more general than the externally \nvisible type (for reverse in this case) and cannot be synthesized automatically in general. However, \nno types need to be given for bound variables. The next example illustrates the need for existentially \nquantified dependent types. The filter function removes all the elements in a list 1 which do not satisfy \na given prop-erty p. Clearly, the length of the resulting list cannot be ex-pressed as a type index since \nit depends on arbitrary compu-tation, which is not permitted in type indices. Nonetheless, we know that \nthe resulting list will be of the length less than or equal to that of the original list. This information \ncan be incorporated into the type of the filter function through existentially quantified dependent types. \nfun reverse(l) = let fun rev(ni1, ys) = ys I rev(x::xs, ys) = rev(xs, x::ys) where rev <I {m:nat) {n:nat) \n a list(m) * a list(n) -> a list(m+n) in rev(1, nil) end where reverse <I Cn:nat) a list(n) -> a list(n) \nFigure 2: The reverse function for lists fun filter p nil = nil I filter p (x: :x8) = if p(x) then x: \n: (filter p xs) else filter p x9 where filter <I Cm: nat) ( a -> bool) -> a list(m) -> [n:nat I n <= \nml a list(n) The result of this function has type Cn:nat I n <= ml a list(n) which is concrete syntax \nfor Cn : {n : nat 1 n < m}.crlist(n). Existential types can also be used to express subset types (note \nthat this is different from subset sorts ascribed to in- dex variables). For instance, we can use Ci: \nint I 0 <= i+l 1 int (i) to represent the type for integers which are greater than or equal to -1. This \nfeature is exploited to eliminate array bound checks in the implementation of Knuth-Morris- Pratt string \nmatching algorithm shown in Appendix A. A detailed description of the algorithm can be found in (Cor-man, \nLeiserson, and Rivest 1989). Notice that several array bounds checks in the body of computepref ixFunction \ncan-not be eliminated. Elimination of these checks would require a representation of deep invariants \nof the algorithm which are not expressible in our type system. Existential types are also used to interpret \nindexed types such as int, when used without an index. For example, int is interpreted as Ci : int.int(i) \n(or Ci: intl int (i), in concrete syntax). Thus existential types provide a smooth boundary between annotated \nand unannotated programs in the context of a larger implementation. For larger and more interesting examples, \nwe refer the reader to (Xi 1997). 3 Elaboration The elaboration process transforms a program written \nin the source language into an expression in an explicitly typed internal language, performing type-checking \nalong the way. Since it is beyond the scope of the paper to present a detailed treatment of this process, \nwe shah highlight a few major features through examples. One can think of elaboration as a two-phase \nprocess. In the first phase, we ignore dependent type annotations and simply perform the type inference \nof ML. If the term is well-typed, we traverse it again in the second phase and col- lect constraints \nfrom the index expressions occurring in type families. Constraints are boolean index expressions b en- \nriched with explicit quantifiers and implication. The latter is necessary for type-checking pattern matching \nexpressions. The syntax for the constraints is given as follows. Constraints 4 ::= b 1 qi1 A&#38; 1 b \n2 C#J 1 3a : y.cj~ 1 Va : y.f#~ 3.1 Generating constraints The following is the auxiliary tail-recursive \nfunction in the implementation of the reverse function in Figure 2. fun rev(ni1, ys) = ys I rev(x::xs, \nys) = rev(xs, x::ys) where rev <I Im:nat) Cn:nat) a list(m) * a list(n) -> a list (m+n) Let us elaborate \nthe clause rev (nil, ys) = ys. Accord-ing to the form of the type assigned to rev, we introduce two index \nvariables M and N, and check nil against type a list(M) and ys against type a list(N). This generates \ntwo constraints M = 0 and N = n, where ys is assumed to be of type a list(n). Then we check the type \nof the right hand side of the clause, ys against a list (M+N), the result type specified for rev. This \nyields the constraint M + N = n. Thus analyzing the first clause in the definition of rev generates the \nconstraint Vn : nat.3M : natAN : nat.(M = OA N = n 1 M+ N = n). We then eliminate existential variables, \nsimplifying the con-straint to Vn : not.0 + n = n which is entered into a constraint store and later \neasily ver-ified. Note that we have been able to eliminate aII the existen- tial variables in the above \nconstraint. This is true in aII our examples, but, unfortunately, we have not yet found a clear theoretical \nexplanation why this is so. In practice, it is cru- cial that we eliminate aII existential variables \nin constraints before passing them to a constraint solver. Otherwise, we would have to deal with arbitrary \nformulas in Presburger arithmetic, which is decidable, but for which there are no practically efficient \ndecision procedures available. For the second clause in the definition of reverse rev(x: : x8, ys) = \nrev(xs, x::ys), we obtain the constraint Vm : nat.Vn : nat.(m + 1) + n = m + (n + 1) following the same \nprocedure, where xs and ys are assumed to be of type a list (ml and a list(n), respectively. Note that \nm and n are universally quantified, and the constraint can be solved easily. fun( a)Csize:nat) bsearch \ncmp (key, arr) = let fun look(lo, hi) = if hi >= lo then  let val m = lo + (hi -lo) div 2 val x = subcarr, \nm) in case cmpckey, x) of LESS => look(lo, m-l) I EqUAL => (SOME(m, x)) I GREATER => look(m+l, hi) end \nelse NONE where look <I Cl:nat I 0 <= 1 <= size} {h:int I 0 <= h+l <= size) int(1) * int (h) -> a answer \nin look (0, length arr -1) end where bsearch <I ( a * a -> order) -> a * a array(size) -> a answer Figure \n3: The binary search function Vh : int.Vl : nat.Vsize : nat.(O _< h + 1 _< size A 0 _< 1 5 size Ah 2 \n1) 1 (1 + (h -1)/L?) 5 size vh : int.Vl : nat.tlsiae : nat.(O 5 h + 1 2 size A 0 5 1 5 size A h 2 1) \n3 0 5 1 + (h -1)/2 -1 + 1 t/h : int.tfi : nat.vsite : nat.(O 5 h + 1 5 size A 0 2 1 5 size Ah 1 2) 1 \nI + (h -1)/2 -1 + 1 5 size vh : int.vl : not.tlsize : nat.(O < h + 1 5 size A 0 5 1 < size Ah 1 I) > \n0 5 I+ (/I -1)/x + 1 t/h : int.Vl : nat.tlsize : nat.(O 5 h + 1 < size A 0 5 1 2 size Ah 2 1) 2 1 + (/I \n-1)/z + 1 5 he Figure 4: Sample constraints In the standard basis we have retied the types of many 3.2 \nSolving constraints common functions on integers such as addition, subtraction, When all existential \nvariables have been eliminated and the multiplication, division, and the modulo operation. For in- resulting \nconstraints collected, we check them for linearity. stance, We currently reject non-linear constraints \nrather than post-+ <I {m:int) (n:int) int(m) * int(n) -> int(m+n) poning them as hard constraints (Michaylov \n1992), which isis declared in the system. The code in Figure 3 is an imple- planned for future work. \nIf the constraints are linear, wementation of binary search through an array. As before, we negate them \nand test for unsatisfiability. Our technique forassume solving linear constraints is mainly based on \nFourier vari-able elimination, but there are many other methods avail-sub <I Cn:nat) {i:nat I i < n) \nable for this purpose such as the SUP-INF method (Shostak a array(n) * int(i) -> a 1977) and the well-known \nsimplex method. We have chosen The explicit type parameter a is a recent feature of Fourier s method \nmainly for its simplicity. Standard ML to allow explicit scoping of type variables. We now briefly explain \nthis method. We use x for in-We extend this notation to encompass type index variables, teger variables, \na for integers, and 1 for linear expressions. {size:nat} in this case. Given a set of inequalities S, \nwe would like to show that S We list some sample constraints generated from type-is unsatisfiable. We \nfix a variable z and transform all the checking the above code in Figure 4. All of these can be linear \ninequalities into one of the forms 1 2 ax or ax 5 1 solved easily. for a 2 0. For every pair 21 < arz \nand asx 5 /z, where Note that if we program binary search in C, the array ar,az > 0, we introduce a new-inequality \nas11 5 all2 into bound check cannot be hoisted out of loops using the algo- S, and then remove all the \ninequalities involving x from S. rithm presented in (Gupta 1994) since it is neither increasing Clearly, \nthis is a sound but incomplete procedure. If x were nor decreasing in terms of the definition given there. \nOn the a real variable, then the elimination would also be complete. other hand, the method in (Susuki \nand Ishihata 1977) could In order to handle modular arithmetic, we also perform eliminate this array \nbound check by synthesizing an induc- another operation to rule out non-integer solutions: we trans- \ntion hypothesis similar to our annotated type for look. Un-form an inequality of form fortunately, synthesizing \ninduction hypotheses is often pro-hibitively expensive in practice. In future work we plan in alxl + \nfee + anxn I a investigate extensions of the type-checker which could in- into fer certain classes of \ngeneralizations, thereby relieving the alx1 +. . . + anxn 2 a , programmer from the need for certain \nkinds of obvious annotations. where a is the largest integer such that a < a and the W/l 17 12 13 IA \n0.7211.37 0.10/0.04 0.11/0.06 r).16/0.06 ).14/0.04 13 2 3 5 9 50 2 3 10 9 281 lines 33 lines 37 lines \n50 lines 81 lines -I-------hanoi towers list access I -29 , o.iojo.091 4 1 0.07/0.01 I 1 0.13jo.13 1 \n0.08/0.01 1 1 4 1 2 1 10 1 3 1 45 lines 18 lines Table 1: Constraint generation/solution, time in sets \ngreatest common divisor of al,. . . , a, divides a . This is used in type-checking an optimized byte \ncopy function. The above elimination method can be extended to be both sound and complete while remaining \npractical (see, for example, (Pugh and Wonnacott 1992; Pugh and Wonnacott 1994)). We hope to use such \nmore sophisticated methods which appear to be practical, although we have not yet found the need to do \nso in the context of our current experiments. 4 Experiments We have performed some experiments on a small \nset of pro- grams. Note that three of them (bcopy, binary search, and quicksort) were written by others \nand just annotated, pro-viding evidence that a natural ML programming style is amenable to our type refinements. \nThe first set of experiments were done on a Dee Alpha 3000/600 using SML of New Jersey version 109.32. \nThe second set of experiments were done on a Sun Spare 20 using MLWorks version 1 .O. Sources of the \nprograms can be found in (Xi 1997). Table 1 summarizes some characteristics of the programs. We show \nthe number of constraints generated during type-checking and the time taken for generating and solving \nthem using SML of New Jersey and MLWorks. Also we indicate the number of total type annotations in the \ncode, the num-ber lines they occupy, and the code size. Note that some of the type annotations are already \npresent in non-dependent form in ML, depending on programming style and module interface to the code. \nA brief description of the programs is given below. bcopy This is an optimized implementation of the \nbyte copy function used in the Fox project. We used this function to copy 1M bytes of data 10 times in \na byte- by-byte style. binary search This is the usual binary search function on an integer array. We \nused this function to look for 220 randomly generated numbers in a randomly generated array of size 220. \nbubble sort This is the usual bubble sort function on an integer array. We used this function to sort \na randomly generated array of size 213. matrix mult This is a direct implementation of the ma-trix multiplication \nfunction on two-dimensional inte-ger arrays. We applied this function to two randomly generated arrays \nof size 256 x 256. queen This is a variant of the well-known eight queens problem which requires positioning \neight queens on a 8 x 8 chessboard without one being captured by an-other. We used a chessboard of size \n12 x 12 in our experiment. quick sort This implementation of the quick sort algorithm on arrays is copied \nfrom the SML of New Jersey library. We sorted a randomly generated integer array of size 22s. hanoi towers \nThis is a variant of the original problem which requires moving 64 disks from one pole to another without \nstacking a larger disk onto a smaller one given the availability of a third pole. We used 24 disks in \nour experiments. list access We accessed the first sixteen elements in a ran- domly generated list at \ntotal of 220 times. We used the standard, safe versions of sub and update for array access when compiling \nthe programs into the code with array bound checks. These versions always perform run-time array bound \nchecks according to the semantics of Standard ML. We used unsafe versions of sub and update for array \naccess when generating the code containing no array bound checks. These functions can be found in the \nstructure Unsafe .Array (in SML of New Jersey), and in MLWorks, Internal .Value (in MLWorks). Our unsafe \nver-sion of the nth function used cast for list access without tag checking. Notice that unsafe versions \nof sub, update and nth can be used in our implementation only if they are assigned the corresponding \ntypes mentioned in Section 2.1. In Table 2 and Table 3, we present the effects of eliminat- ing array \nbound checks and list tag checks. Note that the difference between the number of eliminated array bound \nchecks in Table 2 and Table 3 reflects the difference between randomly generated arrays used in two experiments. \nIt is clear that the gain is significant in all cases, re-warding the work of writing type annotations. \nIn addition, type annotations can be very helpful for fmding and fixing bugs, and for maintaining a software \nsystem since they pro-vide the user with informative documentation. We feel that these factors yield \na strong justification for our approach. 5 Related work From the point of view of language design, our \nwork falls in between full program verification, either in type theory (Con-stable et al. 1986; Dowek, \nFelty, Herbelin, Huet, Murthy, I------- I anoi towers I 11.34 I 8.28 I 27% -._ i 2.24 1 1.2,4 I 45% \nI 1:648:576 1 Table 2: Dee Alpha 3000/600 using SML of NJ working version 109.32, time unit = sec. Table \n3: Sun Spare 20 using MLWorks version 1.0, time unit = sec. Parent, Paulin-Mohring, and Werner 1993) \nor systems such as PVS (Owre, Rajan, Rushby, Shankar, and Srivas 1996), and traditional type systems \nfor programming languages. When compared to verification, our system is less expres- sive but more automatic, \nwhen compared to traditional pro-gramming languages our system is more expressive, but also more verbose. \nSince we extend ML conservatively, depen-dent types can be used sparingly, and existing ML programs will \nwork as before if there is no keyword conflict. Hayashi proposed a type system ATTT (Hayashi 1991), which \nallows a notion of refinement types as in (Freeman and Pfenning 1991), plus union and singleton types. \nHe demonstrated the value of singleton, union and intersection types in extracting realistic programs, \nwhich is similar to our use of the corresponding logical operators on constraints. However, his language \ndoes not have effects and he does not address the practical problem of type checking or partial inference. \nWe have already compared some of the work on array bound checking for other languages (Markstein and \nMark-stein 1982; Gupta 1994; Susuki and Ishihata 1977), most of which is based on automated analysis \nor inference, and thus more limited while requiring no annotations. In many cases a considerable number \nof array bound checks remain, which limits the efficiency gains. Purthermore, these methods pro-vide \nno feedback to the programmer regarding the correct-ness of his code, which is an important component \nof our solution. We also deal with advanced features of ML such as higher-order functions and polymorphism. \nThe work by Jay and Sekanina (Jay and Sekanina 1996) which includes these features and has similar goals \nand approach to ours is more restrictive in the design and seems more promising for languages based on \niteration schemas rather than general recursion. Also related is the work on a certifying compiler by \nNec- ula and Lee, which introduces precondition annotations for a type-safe subset of C in order to eliminate \narray bound checks (Necula and Lee 1998) and generate proof-carrying code (Necula 1997). Their language \nis significantly simpler (for example, it does not include higher-order functions or polymorphism), which \nallows them to formulate their exten-sions without constructing a full type system. They also do not \ninclude existential types, which we found necessary in a number of our examples. 6 Conclusion and future \nwork We have demonstrated the practicality of the use of depen- dent types in a statically typed functional \nlanguage to elim- inate dynamic array bound and tag checks. The required additional type annotations \nare concise, intuitive and aid the programmer in writing correct and in many cases sig- nificantly more \nefficient programs. The necessary constraint simplification, though theoretically intractable, has proved \npractically feasible, even with a simple-minded implementa-tion and currently incomplete algorithm. Our \nimmediate goal is to extend our system to accom-modate full Standard ML which involves treating exceptions \nand module-level constructs. We would also like to incorpo- rate the ideas and observations from (Pugh \nand Wonnacott 1994) into our constraint solver and improve its efficiency. We also plan to pursue using \nour language as a front-end for a certifying compiler for ML along the lines of work by Necula and Lee \n(Necula and Lee 1998) for a safe subset of C. We can propagate program properties (including array bound \ninformation) through a compiler where they can be used for optimizations or safety certificates in proof-carrying \ncode (Necula 1997). This work arose from a larger effort to incorporate a more general form of dependent \ntypes into ML (Xi 1998). Our ex-tended type checking algorithm is robust (in the sense that it can collect \nconstraints independently of their domain), because we separated the language of indices and programs. \nThis allows other program invariants or properties to be expressed, propagated, and checked, and we plan \nto investi- gate the use of other constraint domains and simplification procedures. At present, unsolved \nconstraints generated during type-checking may provide some hints on where type errors origi-nate, but \nthey are often inaccurate and obscure. Therefore, we plan to investigate how to generate more informative \nerror messages should dependent type-checking fail. In con-trast, many other approaches to eliminating \narray bound checking could give the user little or no feedback when an error is found. Acknowledgements \nWe thank Peter Lee for providing us with many interesting examples and comments. We also gratefully acknowledge \ndiscussions with Rowan Davies and George NecuIa regarding the subject of the paper, and the help received \nfrom Kenneth CIine on measurements. Finally, we would Iike to thank the anonymous referees for their \nvaluable comments. References Blelloch, G. E. (1993, April). NESL: A nested data-parallel language (version \n2.6). Technical Re-port CMU-CS-93-129, School of Computer Science, Carnegie Mellon University. Chow, \nF. (1983). A portable machine-independent global optimizer -design and measurements. Ph. D. disserta- \ntion, Stanford University. Technical Report 83-254. Constable, R. L. et al. (1986). Implementing Mathematics \nwith the Nuprl Proof Development System. Englewood Cliffs, New Jersey: Prentice-Hall. Corman, T. H., \nC. E. Leiserson, and R. L. Rivest (1989). Introduction to Algorithms. Cambridge, Mas-sachusetts: The \nMIT Press. Davies, R. (1997, November). Practical refinement-type checking. Thesis Proposal. Dowek, G., \nA. Felty, H. HerbeIin, G. Huet, C. Murthy, C. Parent, C. PauIin-Mohring, and B. Werner (1993). The Coq \nproof assistant user s guide. Rapport Tech-niques 154, INRIA, Rocquencourt, France. Version 5.8. Freeman, \nT. (1994, March). Refinement Types for ML. Ph. D. dissertation, Carnegie Mellon University. Avail-able \nas Technical Report CMU-CS-94-110. Freeman, T. and F. Pfenning (1991). Refinement types for ML. In ACM \nSIGPLAN 91 Conference on Program-ming Language Design and Implementation, Toronto, Ontario, pp. 268-277. \nGupta, R. (1994). Optimizing array bound checks us-ing flow analysis. ACM Letters on Programming Lan-guages \nand Systems Z(l-4), 135-150. Hayashi, S. (1991). Singleton, union and intersection types for program \nextraction. In A. R. Meyer (Ed.), Proceedings of the International Conference on Theo-retical Aspects \nof Computer Software, pp. 701-730. Jay, C. and M. Sekanina (1996). Shape checking of ar-ray programs. \nTechnical Report 96.09, University of Technology, Sydney, Australia. Markstein, V., C. J. and P. Markstein \n(1982). Optimizac tion of range checking. In SIGPLAN 82 Symposium on Compiler Construction, pp. 114-119. \nMartin-Liif, P. (1980). Constructive mathematics and computer programming. In Logic, Methodology and \nPhilosophy of Science VI, pp. 153-175. North-Holland. Michaylov, S. (1992, August). Design and Implementation \nof Pmctical Constraint Logic Programming Systems. Ph. D. thesis, Carnegie Mellon University. Available \nas Technical Report CMU-CS-92-168. NecuIa, G. (1997). Proof-carrying code. In Conference Record of 244th \nAnnual ACM Symposium on Princi-plea of Programming Languages, pp. 106-119. ACM press. NecuIa, G. and \nP. Lee (1998, June). The design and imple- mentation of a certifying compiler. In A CM SIGPLA N 98 Conference \non Programming Language Design and Implementation. ACM press. Owre, S., S. Rajan, J. Rushby, N. Shankar, \nand M. Srivas (1996, July/August). PVS: Combining specification, proof checking, and model checking. \nIn R. Alur and T. A. Henzinger (Eds.), Computer-Aided Verification, CAV 96, Volume 1102 of LNCS, New \nBrunswick, NJ, pp. 411-414. Springer-Verlag. Pugh, W. and D. Wonnacott (1992). Eliminating false data \ndependences using the Omega test. In ACM SIG-PLAN 92 Conference on Programming Language De-sign and Implementation, \npp. 140-151. ACM Press. Pugh, W. and D. Wonnacott (1994, November). Experi-ence with constraint-based \narray dependence analysis. Technical Report CS-TR-3371, University of Mary-land. Shostak, R. E. (1977, \nOctober). On the SUP-INF method for proving Presburger formulas. Journal of the ACM 24 (4), 529-543. \nSun Microsystems (1995). The Java language specifica-tion. Available as ftp://ftp.javasoft.com/docs/javaspec.ps.zip. \nSusuki, N. and K. Ishihata (1977). Implementation of ar- ray bound checker. In 4th ACM Symposium on Prici- \nplea of Programming Languages, pp. 132-143. Xi, H. (1997, November). Some examples of DML pro-gramming. \nAvailable at http://www.cs.cmu.edu/-hwxi/DML/examples/. Xi, H. (1998). Dependent Types in Practical Programming. \nPh. D. thesis, Carnegie Mellon University. Forthcom-ing. A Knuth-Morris-Pratt string matching The following \nis an implementation of the Knuth-Morris-Pratt string matching algorithm using dependent types to eliminate \nmost array bound checks. assert length <I {n:nat> a array(n) -> int(n) and sub <I {size:int, i: int \nI 0 C= i < size) a array(size) * int(i) -> a (* sub requires NO bound checking *) and subCK <I a array \n* int -> a (* subCK requires bound checking *) type intPref ix = [i: int I 0 <= i+l] int(i) (* notice \nthe use of existential types *) assert arrayprefix <I {size:nat] int(size) * intPrefix -> intPrefix array(size) \nand subPrefix <I Csize:int, i:int I 0 <= i < size] intPrefix array(size) * int(i) -> intPrefix (* subPrefix \nrequires NO bound checking *) and subPrefixCK <I intPrefix array * int -> intPrefix (* subPrefixCK requires \nbound checking *) and updatepref ix <I Csize:int, i:int I 0 <= i < size) intPrefix array(size) * int(i) \n* intPrefix -> unit (* updateprefix requires NO bound checking *) (* computePrefixFunction generates \nthe prefix function table for the pattern pat *) fun computePrefixFunction(pat1 = let val plen = lengthtpat) \nval pref ixArray = arrayPref ix (plen, Ii) fun loop(i, j) =I (* calculate the prefix array *) if (j >= \nplen) then 0 else if sub (pat, j ) 0 subCK(pat , i+l) then if (i >= 0) then loop(subPref ixCK(pref ixArray, \ni) , j) else loop(-I, j+l) else (updatepref ix (pref ixArray , j , i+l); loop(subPrefix(prefixArray, \nj), j+l)) where loop <I {j:nat] intPrefix * int(j) -> unit in (loop(-1, 1) ; pref ixArray) end where \ncomputePrefixFunction <I Cp:nat] int array(p) -> intPrefix array(p) fun kmpMatch(str, pat) = let val \nstrLen = length(str) and patLen = length(pat) val prefixArray = computepref ixFunct ion (pat 1 fun loop(s, \np) = if s < strLen then  if p < patLen then if sub(str, 8) = subcpat, p) then loop(s+l, p+l) else if \n(p = 0) then loop(s+l, p) else loop(s, subPrefix(prefixArray, p-1)+1) else (s -patlen) else -1 where \nloop <I {s:nat, p:nat) int(s) * int(p) -> int in loop(0, 0) end where kmpMatch <I Cs:nat, p:nat] int \narray(s) * int array(p) -> int Figure 5: An Implementation of Knuth-Morris-Pratt String Matching Alogirithm \n \n\t\t\t", "proc_id": "277650", "abstract": "We present a type-based approach to eliminating array bound checking and list tag checking by conservatively extending Standard ML with a restricted form of dependent types. This enables the programmer to capture more invariants through types while type-checking remains decidable in theory and can still be performed efficiently in practice. We illustrate our approach through concrete examples and present the result of our preliminary experiments which support support the feasibility and effectiveness of our approach.", "authors": [{"name": "Hongwei Xi", "author_profile_id": "81100625632", "affiliation": "Department of Mathematical Sciences, Carnegie Mellon University", "person_id": "PP39051360", "email_address": "", "orcid_id": ""}, {"name": "Frank Pfenning", "author_profile_id": "81100157780", "affiliation": "Department of Computer Science, Carnegie Mellon University", "person_id": "PP39030152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/277650.277732", "year": "1998", "article_id": "277732", "conference": "PLDI", "title": "Eliminating array bound checking through dependent types", "url": "http://dl.acm.org/citation.cfm?id=277732"}