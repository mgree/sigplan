{"article_publication_date": "05-01-1998", "fulltext": "\n A Study of Dead Data Members in C++ Applications Peter F. Sweeney and Frank Tip IBM Thomas J. Watson \nResearch Center P.O. Box 704, Yorktown Heights, NY 10598 {pfs,tip}@watson.ibm.com Abstract Object-oriented \napplications may contain data members that can be removed from the application without affecting program \nbehavior. Such dead data members may occur due to unused functionality in class libraries, or due to \nthe programmer losing track of member usage as the application changes over time. We present a simple \nand efficient algo-rithm for detecting dead data members in C++ applications. This algorithm has been \nimplemented using a prototype ver-sion of the IBM VisualAge C++ compiler, and applied to a number of \nrealistic benchmark programs ranging from 600 to 58,000 lines of code. For the non-trivial benchmarks, \nwe found that up to 27.3% of the data members in the bench- marks are dead (average 12.5%), and that \nup to 11.6% of the object space of these applications may be occupied by dead data members at run-time \n(average 4.4%). 1 Introduction Object-oriented applications may contain data members (in-stance variables) \nthat can be removed from the applica-tion without affecting program behavior. Such dead data members \nmay occur for several reasons: b When an application uses a class library, it typically uses only part \nof the library s functionality. Certain members may be accessed only from the unused parts. 0 The expected \nuse of a class at design time may differ from the actual use of that class at coding time. l Programmers \nmay lose track of which members are used, due to the growing complexity of an application and its class \nhierarchy as the application changes over time. This paper presents a simple and efficient algorithm \nthat performs a whole-program analysis of a C++ application and identifies dead data members. The algorithm \nhas been implemented in the context of the IBM VisualAge C++ compiler (version 4.0) [18], and has been \napplied to a set of medium-sized C++ applications ranging from 600 to 58,000 e 1999 ACM 0-99791.997.4/99/0006...$5.00 \nlines of code. For the non-trivial benchmarks, we found that up to 27.3% of the data members can be identified \nas dead, and that up to 11.6% of the object space is occupied by dead data members at run-time. On the \naverage, we found that 12.5% of the data members are dead, and that 4.4% of object space is occupied \nby dead data members. Elimination of unused data members is interesting from an optimization perspective \nbecause it reduces the amount of memory consumed by an application. An application s execution time may \nalso be reduced, through reduced object creation/destruction time, and caching/paging effects. The detection \nof dead data members may also be useful in an integrated development environment, by providing feedback \nto the programmer, or by filtering out unimportant artifacts from an application. The remainder of this \npaper is organized as follows. In Section 2, we define what it means for a data member to be live or \ndead. Section 3 presents our algorithm for detecting dead data members. Section 4 evaluates the algorithm \non a set of medium size benchmarks. Section 5 presents related work and Section 6 presents our conclusions \nand future work. 2 Defining Liveness and Deadness In the remainder of this paper, we will use the following \nintuitive definitions of liveness and deadness of data members. We call a data member m live if there \nis an object o in the program that contains m such that the value of m in o may affect the program s \nobservable behavior (i.e., output or return value). If there is no such object o, we call m dead.  Note \nthat, according to this definition, data members that are only accessed from unreachable code are classified \nas dead. More interestingly, data members that are assigned a value that is subsequently never used in \nthe program are classified as dead as well. We are particularly interested in detecting situations of \nthis kind, since in real-life C++ pro-grams, data members are typically initialized with a value in a \nconstructor. Otherwise, the initialization of data mem-bers would lead to liveness, and very few dead \ndata members would be dead. Figure 1 shows an example C++ program. The following observations can be \nmade about the data members in the class hierarchy of this program: l A:. *mai and N: :mnl are live because \nthe accesses to these data members affect the program s return value. o A:: ma2 and N: :mn2 are dead, \nbecause there are no ac- cesses to these data members in the program. public: int mnl; /* live: accessed \nand observable */ int mn2; /* dead: not accessed e/ 1; class A { public: virtual int fO{ return mal; \n}; int mal; /* live: accessed and observable */ int ma2; /e dead: not accessed */ int ma3; /* dead: \naccessed but not observable */ 1;class B : public A { public: virtual int fO{ return mbl; }; int mbl; \n/e dead: accessed from unreachable code e/ I mb2; /* live: accessed and observable e/ int mb3; /e dead: \naccessed, but not observable */ int mb4; /* live: accessed and observable */ 1;class C : public A { public: \nvirtual int fO{ return mcl; }; int mcl; /e dead: accessed from unreachable code e/ 1; int foo(int *XL){ \nreturn (*I) + 1; } int mainO{ A a; B b; C c; A *ap; a.ma3 = b.mb3 + 1; int i = 10; if (i < 20){ ap = \n&#38;a; } else { ap = tb; } return ap->fO + b.mbl.mnl+ foo(tb.mb4); 1 Figure 1: Example program. A : \n: ma3 and B : :mb3 are dead since the accesses to these data members do not affect the program s return \nvalue. B : :mbl and C: :mcl are dead, because these members are accessed in unreachable code.  B: :mb2 \nis live, because there is an access to B: :mb2 from which another member, N : : nmi is accessed, which \naffects the program s return value. B::mb4is livebecause its address is taken, and subse-quently used \nin a way that affects the program s return vahre. Since the definition of liveness/deadness relies on \nthe fact whether or not a given member access operation can be ex- ecuted or not, the problem of precisely \ndetermining all dead data members is undecidable. Therefore, our analysis must be a conservative one. \nBelow, we present an algorithm that conservatively approximates the set of dead data members: each data \nmember classified by the algorithm as dead is guaranteed to be dead. 3 An Algorithm for Detecting Dead \nData Members In essence, our algorithm classifies a data member m as live if the value of m is read, \nor the address of m is taken. Since the act of storing a value into a data member cannot affect the program \ns observable behavior (i.e., output or return value) by itself, we ignore all write-accesses . This analy-sis \nis performed on all functions and methods that can be transitively called from main(), thus ignoring \nmember ac-cesses that occur within unreachable functions. Conserva-tive assumptions must be made in the \npresence of unsafe 'As an exception, data members that are volatile are marked live if they are written \nto. type casts, unions, and situations where the source code is only partially available (e.g., due to \nlibrary usage). Figure 2 shows pseudo code for the algorithm, expressed as a main procedure Detect UnusedDataMembers, \nand two auxiliary procedures ProcessStatement and MarkAlfCon-tamedMembers. The algorithm begins by marking \nall data members in all classes as dead (line 3). On line 4, each class C in the program is marked as \nnot visited (the pur-pose of this action will be explained shortly). Then, a call graph of the program \nis computed on line 5. We make no assumptions about the particular method used to determine the call \ngraph, however, the accuracy of the call graph may have an impact on the precision of the analysis [ll]. \nOn lines 6-8, procedure ProcessStatement is invoked for each statement that occurs in a function reachable \nfrom main0 in the call graph. For a given statement s, procedure ProcessStatement (lines 15-35) determines \nall data members that are read in s, and all data members whose address is taken in a, and marks them \nlive . For each expression e in statement s that is not a call to the delete or free system functionsa \n(line 18), the following actions are performed: l If e is a read-access of the form e .m, function Lookup \nis invoked to determine which data member C::m is ac-cessed, and C::m is marked live (lines 19-22). Read \noThis includes all data members in structs and unions, which are defined aa special cases of classes \nin C++ [l]. 'A data member whose address is passed to the delete or free ays-tern functions doss not \nhave to be marked as live, because these func-tiona do not affect the program s observable behavior. \nWe are par-ticularly interested in detecting such situations, since data members that are pointers to \nobjects are typically passed to doleto in the en-closing class s destructor. Other system functions (e.g., \nstrcpy) that are known not to affect lome of their parameters, could be treated as a special case as \nwell. procedure DetectUnusedDataMembers(Program P) begin mark all data members in P initially as dead \n; mark all classes in P initially as not visited ; construct the call graph G of program P; for each \nstatement s in each function f in call graph G do call ProcessStatement( end for for each union construct \nU in P do if (at least one of the members of U is marked live ) then call MarkAJJContainedMembers(U); \nend if end for end; procedure ProcessStatement(Statement s) begin for each expression e in statement \ns do if (e is not a call to the system functions delete or free) then if (e is an expression of the form \ne .m and is a read-access) or (e is a expression of the form te .m) then /* access to data member from \nexpression. similar for -> expressions. */ let X be the type of e ; let C = Lookup(X, m); /* m may occur \nin a base class of X */ mark data member C::m live ; else if (e is an expression of the form e .Y::m \nand is a read-access) or (e is a expression of the form Le .Y::m) then /* access to data member jtom \nexpression using ::I operator. similar for -> ezppressions. */ let C = Lookup(Y, m); /* m may occur in \na base class of Y / mark data member C::m live ; else if (e is an expression of the form tZ::m) then \n/* pointer-to-member ezpression. */ let C = Lookup(2, m); / * m may occur in a base class of 2 * / mark \ndata member C::m live ; else if (e is an unsafe type cast expression of the form (T)(e ), for some type \n2 ) then let S be the type of e ; call MarkAJJContainedMembers(S); end if end if end for end; procedure \nMarkAJJCont&#38;edMembers(Class C); begin if class C was marked not visited then mark class C as visited \n. for each data member m bf C do mark data member C::m live ; if the type of data member m is a class \nN then call MarkAJJContainedMembers(N); end if end for for each direct base class B of C do call MarkAJJContainedMembers(B); \nend for end if end; Figure 2: Algorithm for detecting unused data members. accesses of data members using \nthe -> operator are treated similarly. For address-taken expressions of the form te .m, we conservatively \nassume that the data member may be read through some pointer in the pro- gram if its address is taken-we \ndo not attempt to trace the use of such addresses. We make no assump- tions about the method used to \nimplement Lookup; an efficient member lookup algorithm for C++ was recently presented in [16]. Qualified \nread-accesses of data members are handled in a similar manner. l If e is an expression of the form gZ::m \n(i.e., the off-set of member m within class 2 is computed), func-tion Lookup is invoked to determine \ndata member C::m that is accessed, and this C::m is marked live (lines 26-28). Expressions of the form \n&#38;Z::m are typi- cally used in conjunction with pointers to members, a somewhat obscure C++ feature \nfor indirectly access-ing members from a specified object. We do not at- tempt to trace where a pointer-to-member \nexpression is used, and simply assume that any member whose offset is computed may be accessed somewhere \nin the program. s If e is an unsafe type cast expression of the form (T)(e ), for some type T that is \nnot necessarily a class (lines 29-32), the type S of subexpression e is deter- mined, and all members \ncontained within type S are marked live . We make this conservative assump-tion because a read access \nto type T implies a read- access to some member of S. The data members of S are marked live by calling \nprocedure MarkAXon-GnedMembers for type S. MarkAflContainedMem-bers (lines 36-50) marks all directly \nor indirectly con-tained data members of a class C; see Figure 2 for de- tails. In order to prevent duplication \nof work, a class C is marked visited if MarkAllContainedMembers is called for C, and all actions in MarkAlJContained-Members \nare only performed for classes that were not yet visited (see line 38). All classes are initially marked \nnot visited on line 4. After processing the statements, the union constructs in P are examined. If a \nunion U contains at least one data member that is marked live , all other members that are directly or \nindirectly contained in U are marked live (lines 9-11) by calling MarkAUContainedMembers. This conservative \nassumption is required because the value of a live union data member might otherwise depend on a write- \naccess to a dead union member. 3.1 Example We will now study how our algorithm analyzes the example \nprogram of Figure 1. Initially, all data members of the pro- gram are marked dead . If we assume that \nthe algorithm of [5] is used to construct a call graph, the call graph consists of the methods A: :f, \nB: :f, and C: :f in addition to main. For the purposes of this paper! a type cast from type S to type \nT is considered unsafe if T is a derived class of S and the object being cast cannot be guaranteed to \nbe a of type T at run-time. We have verified that all down-casts in our benchmarks are safe. In general, \nunsafe type casts are unlikely to occur, but this is something the user of the tool has to verify. A \nunion construct may contain data members whose type is a class (although there are restrictions on such \nclasses [l]), and these classes may contain data members, or have base clam34s that contain data members. \nAnalysis of the statements in the functions in the call graph proceeds as follows: s A: :mai, 9: :mbl, \nand C: :mcl are marked live, because their value is is read in the return statements of A: : f, B : : \nf , and C : : f , respectively. l Since data member B: :mb3 is read in main0 , it is clas- sified as \nlive , l The expression b.mb2 .nml in main s return statement reads the values of both B: :mb2 and N: \n:znl. There-fore, both 9: :mb2 and N: :sml are marked live. s Since the address of data member B: :mb4 \nin object b is taken in the return expression of main, B : :mb4 is classified as live. Note that, although \nA: :ma3 is accessed in maino, it is writ- ten to, not read. Therefore, A: :ma3 is not classified as live. \nDue to the conservativeness of the algorithm, three dead data members are marked live . B : : mb3 is \nclassified as live because it is read, even though it does not affect the pro-gram s return value. B \n: :mbi and C: :mci are marked live because methods B : :f and C: :f are identified as reachable functions. \nHowever, if a more accurate call graph is used, we can achieve better results. For example, a simple \nalias/points-to analysis algorithm [7, 15, 20, 171 can determine that pointer ap never points to a C \nobject. This fact can be used to ex-clude method C: : f from the call graph, so that the reference to \nC : : mc 1 can be disregarded, and data member C : : mc I can be marked dead . An even more ambitious \napproach would be to eliminate dead code prior to running our algorithm. For example, constant propagation \n[24] can be used to determine that the else-branch of the if statement is unreachable, enabling us to \nremove method 9: :f from the call graph, which would result in B : : mbl being classified as dead . Program \nslicing [25, 211 may also be used to remove useless code from an application prior to running the algorithm. \n 3.2 The sizeof operator The sizeof operator, which returns the size of an object or type as a number \nof bytes, can be used in different ways, and may or may not afIect the program s observable behavior. \nIf program behavior is Bffected, all data members in the affected classes must be marked live, otherwise \nthe use of sizeof can be ignored. Since the effects of sizeof cannot easily be determined automatically, \nour approach is that the user must specify which uses of sizeof can be ignored; by default, sizeof is \ntreated conservatively. In the current set of benchmarks, sizeof is only used for storage allocation \npurposes, and does not affect the pro- gram s observable behavior. Therefore, we do not mark any data \nmembers as live due to use of sizeof. 3.3 Dealing with Library Usage Situations where the source code \nand class hierarchy for parts of the program are unavailable due to library usage require special care. \nIn general, it is not possible to classify a data member in a library class as dead or live un-less the \ncomplete source code for the library is available. In particular, it is not possible to classify the \ndata members of a library class C for which header information and method hotaire Scriptable graphical \npresentation builder 5,355 37 (21) 166 deltablue Incremental dataflow constraint solver 1,250 10 (8) \n23 richards Simple operating system simulator 606 12 (12) 28 Table 1: Benchmark programs used to evaluate \nthe dead data member detection algorithm. The columns of this table show the name of the application, \na brief description of the application, the siee of the application (in lines of source code), the number \nof classes in the application s class hierarchy; the number between brackets is the number of used classes \n(i.e., classes for which a constructor is called in user code), and the number of data members that occurs \nin used classes, respectively. bodies are available if we do not have access to all library 4 Results \nsource code in which C s data members may be accessed. A data member in a user class derived from a \nlibrary The algorithm of Section 3 has been implemented in the class can be classified, assuming that \nthe execution of the context of the IBM VisualAge C++ compiler (version 4.0) library code cannot result \nin an access to that data member. that is currently being developed jointly by IBM Research This implies \nthat conservative assumptions must be made and IBM Toronto. We use a slightly modified version of the \nduring the construction of the call graph in the presence of Program Virtual Call Graph (PVG) algorithm \n[4] to build libraries, since a library may make calls to virtual methods a call graph of a C++ application. \nFor resolving member in the user s code; similar precautions must be taken if the lookups, we rely directly \non the information provided by library calls methods indirectly through function pointers the compiler. \nUnfortunately, there is no linguistic means to (callbacks). Such situations can be dealt with conservatively \ndetect whether or not a class occurs in a library. Therefore, as follows. If a virtual method f is defined \nin a library class, we rely on the user to indicate which classes are library and f is overridden in \na class C in the application code, we classes. assume C :: f to be reachable. In addition, if the address \nof We applied the dead data member detection algorithm a function f is taken in reachable code, we assume \nf to be to a small set of medium-sized C++ benchmarks in order reachable. to answer the following questions: \n1. What percentage of data members in an application3.4 Complexity Analysis can be determined to be \ndead? Our algorithm requires the construction of a call graph, and 2. What percentage of object space \nis occupied at nm-relies on an algorithm for performing member lookup. Us-time by dead data members? \ning the Rapid Type Analysis algorithm of [5], a call graph can be constructed in linear time in practice \n[ll]; for more The first question is answered directly by our algorithm, as sophisticed call graph construction \nalgorithms, we refer the will be discussed below in Section 4.2. The answer to the reader to [ll]. second \nquestion is obtained by analyzing the objects cre-Using the member lookup algorithm of [16], all member \nated during program execution, and measuring the amount lookups can be computed in time O(M x (C + I)), \nwhere C of space in these objects occupied by dead data members; is the number of classes in the hierarchy, \nI the number of this is done by a combination of code instrumentation and inheritance relations among \nthese classes, and M the num- analysis of a dynamic trace of the execution [14]. The dy-ber of distinct \nmember names (assuming that the program namic measurements will be discussed in Section 4.3. contains \nno ambiguous member lookups). Assuming that the call graph and all member lookups 4.1 Benchmark Characteristics \n have been pre-computed, our algorithm requires a single traversal of the expressions that occur in reachable \nfunc-Table 1 shows the set of benchmark programs that were used tions. All actions performed for each \nexpression can be to evaluate the dead data member detection algorithm. The performed in unit time, with \nthe exception of calls to pro-columns of the table show for each benchmark: the name of cedure MarkAllContainedMembers. \nThe total amount of the application, a short description, the size (number of lines time spent in all \ncalls to this procedure is O(C x M), as-of source code), the total number of classes, and the number \nsuming that all members in all classes are eventually vis-of used classes (i.e., classes for which a \nconstructor call ited and marked. This implies that, excluding the cost of occurs in the application), \nand the number of data members pre-computing member lookups and construction of the call that occur in \nused classes. graph, the total cost of our algorithm is O(N + (C x M)), Several of these benchmarks have \nbeen studied previ-where N is the number of expressions in the program. ously in the literature for other \npurposes (e.g., experimen- tation with virtual function-call elimination algorithms) [5, 9, 8, 6, 12, \n31. The programs of Table 1 range from 606 to 58,296 lines of code, and contain between 10 to 268 classes, \nand between 22 and 1052 data members. Some benchmarks (e.g., taldict, simulate, and hotwire) use class \nlibraries that have been developed independently from the applica- tion. Several other benchmarks (e.g., \nidl, lcom, ixx, and sched) use classes that were custom-built for the applica- tion. The code for all \nof these classes is available for analy- sis, and the results presented below only apply to application \ncode for which the full source code is available. In addition, all benchmarks rely on low-level libraries \n(e.g., iostream.h), for which the source code is unavailable or only partially available. In the computation \nof the numbers below, classes and data members in such libraries are ignored. Besides being of different \nsizes, the benchmark programs also cover a wide range of programming styles. The sched benchmark, for \nexample, is not written in a very object- oriented style, and contains very little inheritance: most \nof the classes are structs. On the other hand, id1 is a highly object-oriented application with a complex \nclass hierarchy and heavy use of virtual functions and virtual inheritance. 4.2 Static Measurements \nFigure 3 shows the percentage of dead data members in the used classes for the benchmark programs. The \npercentages shown in this figure are unweighted in the sense that they do not take into account the size \nof each data member. We believe that taking the size of data members into account for the static measurements \nis not meaningful, because there is no way to take into account statically how many times each class \nis instantiated. Data members in unused classes are ignored in the computation of the percentages, since \neliminating such members does not affect the size of any objects that are created at run-time. In the \nsmallest two of the benchmarks, deltablue and richards, no dead data members were found. For the other \nbenchmarks, the percentage of dead data members varies from 3.0% to 27.3%. Not surprisingly, the largest \npercentage of unused data members is found in the programs that use class libraries: taldict, simulate, \nand hotzire. However, our measurements indicate that even in applications with a custom-built class hierarchy, \nthe amount of redundancy can be considerable. 4.3 Dynamic Measurements Table 2 shows the relevant execution \ncharacteristics for each of the benchmark programs. The columns in the table show the amount of space \noccupied by objects throughout pro-gram execution , the amount of space occupied by dead data members \nin these objects, the maximum amount of space oc- cupied by objects at a single point in time during \nexecution (the high water mark ), and the high water mark if dead data members are eliminated from objects. \nNote that, in general, these two high water marks may occur at different execution points. Figure 4 shows \nthe percentage of object space occupied by dead data members at run-time for each of the bench-marks. \nThe figure shows two percentages for each bench- mark: l The leftmost (light grey) bar indicates the \nnumber of bytes in objects occupied by dead data members, as a percentage of the total number of bytes \noccupied by objects. We assume that the heap allocator always allocates the exact number of bytes that \nis requested. l The rightmost (dark grey) bar indicates a percentage of the reduction in size of the \noriginal high water mark, if all dead data members were to be eliminated. Both figures take into account \nthe size of each data member, as well as the number of times an object is created. Interestingly enough, \nthere is no strong correlation be-tween a high percentage of dead data members in Figure 3, and a high \npercentage of object space occupied by those data members in Figure 4. Another point to note is that, \nfor a number of benchmarks, the high water mark numbers are (nearly) identical to the numbers for total \nobject space. This situation occurs when an application heap-allocates most objects, and does not deallocate \nthem until the end of program execution. 4.4 Evaluation Although the number of benchmarks we used is \nrelatively small, some interesting observations can be made. The smallest two of the benchmarks, richards \nand deltablue, do not contain any dead data members. This is in line with our expectation that it is \nunlikely that many dead data members will occur in small pro-grams. The benchmarks that use a class library \nnot specif-ically built for the application, taldict, simulate, and hotaire, have the highest percentage \nof dead data members. This confirms our intuition that dead data members may arise due to unused library \nfunctionality. For some benchmarks with a high percentage of dead data members, the space occupied by \nthese data mem-bers at run-time is relatively small. In such cases, classes with dead data members are \ninstantiated in-frequently. Even in applications with custom-built class hierar- chies, the amount of \ndead data members is non-negligible. s Unfortunately, we have limited data on the develop-ment history \nof our benchmarks. Nevertheless, we be- lieve that applications that have a long maintenance history \nand/or have multiple successive or concurrent developers could accumulate many dead data mem-bers. For \nthe nine nontrivial benchmarks, the average percent-age of dead data members is 12.5%, resulting in an \naverage space savings of 4.4% at run-time if these members are re- moved (4.9% for the high water mark \nnumber). Given the simplicity of the algorithm, we believe that this optimization should be incorporated \nin any optimizing compiler. 5 Related Work Agesen and Ungar [2] describe an algorithm for the Selflan- \nguage that eliminates unused slots from objects (a slot cor-responds to either a data member or a method). \nThis algo-rithm computes, for each message send (method call) that may be executed, a set of slots that \nis needed to preserve that send s behavior, and produces a source file in which redundant slots have \nbeen eliminated. In spirit, this work is very closely related to ours, although the details of the lan- \nguages under consideration are very different. Self is a dy- namically typed language without an explicit \nclass hierarchy _._ jikes npic taldict simulate hotwire rlchardr Idl lcom ixx sohod deltablue Figure \n3: Percentage of dead data members detected in the benchmark prog~amr of Ibble 1. Benchmark Object Space \nDead Data Member Space High Water Mark High Water Mark w/o dead data members j ikes 2,921,490 2,179,730 \nid1 708,249 15,388 701,273 686,886 npic 115,248 5,616 24,972 23,840 ICOm 2,274,956 241,435 1,652,828 \n1,491,048 t aldict 7,080 36 7,998 6,972 in 551,160 29,745 299,516 269,775 8irulata 64,869 41 11,586 11,644 \nsched 9,032,676 1,049,148 9,032,676 7,983,528 hotrire 10,780 284 10,780 10,496 deltablue 276,364 0 196,212 \n196,212 richards 4,889 0 4,880 4,880 Table 2: Execution characterirtia of the benchmark programs of \nTable 1. The table show6 for each benchmark: the space occupied by objects created during execution, \nthe space occupied by dead data members in objects created during execution, the high water mark (i.e., \nmaxilhum amount of space occupied by objects at a single point in time during execution), and the high \nwater mark if dead data members are eliminated from objects. All meaeuremente are in byte&#38; jikeo \nnpic taldict almulato hotwiro riohards ldl lcom lxx s&#38;led deltablue Figure 4: Percentage of object \nspace occupied by dead data membem for each of the programs of Table 1. Light grey bars indicate the \npercentage of space occupied by dead data members throughout program execution. Dark grey bars indicate \nthe reduction of the maximum amount of space (high water mark) required at a single point in time by \neach program. in which objects are obtained by cloning other objects. In statically typed languages such \nas C++, objects are created by instantiating classes. In addition, C++ is a much larger language than \nSelf with a number of features that require special attention when determining dead instance variables. \nIn the context of C++, previous research has focused on the issue of determining and eliminating unused \nmethods, and the usefulness of these optimizations has been demon- strated [5, 191. The work described \nin the present paper was motivated in part by previous work for removing unused data mem-bers and inheritance \nrelations from C++ class hierarchies [22, 231. Class hierarchy slicing [22] is capable of eliminat- ing \nunused inheritance relations in addition to classes, data members and methods. For the example program \nof Fig- ure 1, class hierarchy slicing would be able to eliminate the unnecessary inheritance relation \nbetween class C and class A. This would result in the elimination of the A-subobject that contains data \nmember mai from object c. Class hierarchy slicing relies on alias/points-to information [7, 15, 20, 171 \nto resolve the potential receivers of virtual method calls. Class hierarchy specialization [23] is capable \nof making finer dis-tinctions than class hierarchy slicing by constructing a new class hierarchy in which \nvariables that previously had the same type X may obtain different types. As a result, data members may \nbe excluded from certain X-objects while be-ing retained in other X-objects. Like class hierarchy slicing, \nclass hierarchy specialization requires alias/points-to infor-mation. Class hierarchy specialization \nis also capable of sim- plifying complex inheritance structures, in particular elim-inating virtual inheritance. \nVirtual inheritance is typically implemented by using indirections in objects, which increase member \naccess time, and which may increase object size, depending on the object model that is used. Unfortunately, \nneither class hierarchy slicing nor class hierarchy specializa-tion have been implemented yet. It would \nbe interesting to compare the results of these algorithms to the results pre-sented in this paper. Live \nvariable analysis is a data flow analysis technique for determining if the value of a variable along \nany path is read before it is re-written [lo]. This analysis is typically used to eliminate redundant \nwrites: if a write to a variable is never read, then the write can be removed. The analysis described \nin this paper operates in a completely different domain, the removal of dead components from objects, \nand requires no flow-analysis. In their study of abstract models of memory manage-ment, Morrisett et \nal. [13] provide a semantic definition of reachable garbage that is similar in spirit to our notion of \nliveness. Specifically, they observe that certain reach-able heap-values cannot affect program behavior. \nBased on this observation, Morrisett et al. propose a type-inference algorithm that infers a type for \neach heap location; if an unconstrained type variable is inferred, that location can be replaced by an \narbitrary value (i.e., collected ). Cur anal-ysis for finding data members that are accessed (reachable) \nbut dead is trivial: A data member is dead if it is only writ-ten to. We consider the combination of \nour algorithm with more advanced techniques for eliminating useless code (e.g., program slicing) a promising \ndirection for future work. performed by an optimizing compiler, or as a component of a program maintenance/understanding \ntool. The algorithm has been evaluated using a set of realistic benchmark programs ranging from 600 to \n58,000 lines of code. We found that in the nontrivial benchmarks, up to 27.3% of data members is dead, \nand that up to 11.6% of the object space of these applications may be occupied by dead data members at \nrun-time. On the average, 12.5% of the data members are dead, and 4.4% of object space is occupied by \ndead data members. Evaluation of these measurements is in agreement with our belief that the use of selected \nparts of a general class library may give rise to redundant data members in objects. Acknowledgements \nWe would like to thank David Bacon, Michael Burke, John Field, David Grove, Michael Karasick, G. Ramalingam, \nand Mark Wegman for many helpful comments and suggestions. References PI ACCREDITED STANDARDS COMMITTEE \nX3, I. P. S. Working paper for draft proposed international stan-dard for information systems-programming \nlanguage C++. Dot No X3J16/96-0219Rl. Draft of 2 december 1996. AQESEN, O., AND UN~AFL, D. Sifting out \nthe gold. PI Delivering compact applications from an exploratory object-oriented programming environment. \nIn Proceed-ings of the 1994 ACM Conference on Object Oriented Programming Systems, Languages, and Applications \n(OOPSLA 9.4) (Portland, OR, Oct. 1994), pp. 355-370. AIQNER, G., AND H~LZLE, U. Eliminating virtual func-tion \ncalls in C++ programs. In Proceedings of the Tenth European Conference on Object-Oriented Programming \n 131 -ECOOP 96 (Line, Austria, July 1996), vol. 1098 of Lecture Notes in Computer Science, Springer-Verlag, \npp. 142-166. BACON, D. F. Fast and Effective Optimziation of Stat- PI ically Typed Object-Oriented Languages. \nPhD thesis, University of California at Berkeley, Dee 1997. Forth-coming. BACON, D. F., AND SWEENEY, \nP. F. Fast static analysis of C++ virtual function calls. In Proceed-ings of the 1996 ACM Conference \non Object Oriented Programming Systems, Languages, and Applications (OOPSLA 96) (San Jose, CA, Oct. 1996), \npp. 324-341. [51 k31 CALDER, B., AND GRUNWALD, D. Reducing indirect function call overhead in C++ programs. \nIn Conference Record of the Twenty-First ACM Symposium on Princi- ples of Programming Languages (POPL \n94) (Portland, Oregon, Jan. 1994), pp. 397-408. 171 CARINI, P. R., HIND, M., AND SRINIVASAN, H. Flow-sensitive \ntype analysis for C++. Tech. Rep. RC 20267, IBM T.J. Watson Research Center, 1995. PI DEAN, J., DEFOUW, \nG., GROVE, D., LITVINOV, V., 6 Conclusions AND CHAMBERS, C. Vortex: An optimizing compiler for object-oriented \nlanguages. In Proceedings of the 1996We have presented a simple and efficient algorithm for de- ACM Conference \non Object Oriented Programming Sys- tecting dead data members in C++ applications. This al- tems, Languages, \nand Applications (OOPSLA 96) (San gorithm can be used as the basis for a space optimization Jose, CA, \nOct. 1996), pp. 83-103. [Q] DRIESEN, K., AND HGLZLE, U. The direct cost of vir- tual function calls in \nC++. In Proceedings of the 1996 ACM Conference on Object Oriented Programming Sys-tems, Languages, and \nApplications (OOPSLA 96) (San Jose, CA, Oct. 1996), pp. 306-323. [lo] FISCHER, C. N., AND RICHARD J. \nLEBLANC, J. Craft-ing A Compiler. The Benjamin/Cummings Series in Computer Science. Benjamin/Cummings, \nMenlo Park, CA, 1988. [ll] GROVE, D., DEFOUW, G., DEAN, J., AND CHAM-BERS, C. CaII graph construction \nin object-oriented languages. In Proceedings of the 1997 ACM Conference on Object Oriented Programming \nSystems, Languages, and Applications OOPSLA (Oct. 1997), pp. 108-124. [12] LEE, Y.-F., AND SEFLRANO, \nM. J. Dynamic measure-ments of C++ program characteristics. Tech. Rep. ADTI-1995-001, IBM Santa Teresa \nLaboratory, Jan. 1995. [13] MORRISETT, G., FELLEISEN, M., AND HARPER, R. Abstract models of memory management. \nIn Func-tional Programming and Computer Architecture (La Jolla, CA, June 1995), ACM, pp. 66-77. [14] \nNAIR, R. Profiling IBM RS/SOOO applications. Inter-national Journal of Computer Simulation 6, 1 (1996), \n101-111. [15] PANDE, H. D., AND RYDER, B. G. Static type determi-nation and ahasing for C++. Report LCSR-TR-250-A, \nRutgers University, October 1995. [16] RAMALINGAM, G., AND SRINIVASAN, H. A member lookup algorithm for \nC++. In Proceedings of the ACM SIGPLAN 97 Conference on Programming Language Design and Implementation \n(Las Vegas, NV, 1997), pp. 18-30. [17] SHAPIRO, M., AND HORWITZ, S. Fast and accu-rate flow-insensitive \npoints-to andysis. In Conference Record of the Twenty-Fourth ACM Symposium on Prin-ciples of Programming \nLanguages (Paris, France, 1997), pp. 1-14. [18] SOROKER, D., KARASICK, M., BARTON, J., AND STREETER, \nD. Extension mechanisms in Montana. In Proceedings of the 8th IEEE Israeli Conference on Soft-ware and \nSystems (Herzliya, Israel) (June 1997), IEEE Computer Society, pp. 119-128. [lQ] SRIVASTAVA, A. Unreachable \nprocedures in object-oriented programming. ACM Letters on Programming Languages and Systems 1,4 (December \n1992), 355-364. [20] STEENSGAAFLD, B. Points-to analysis in almost linear time. In Proceedings of the \nTwenty-Third ACM Sym-posium on Principles of Programming Languages (St. Petersburg, FL, January 1996), \npp. 32-41. [21] TIP, F. A survey of program slicing techniques. Journal of Programming Languages 9, 3 \n(1995), 121-189. [22] TIP, F., CHOI, J.-D., FIELD, J., AND RAMALINGAM, G. Slicing class hierarchies in \nC++. In Proceedings of the 1996 ACM Conference on Object Oriented Program-ming Systems, Languages, and \nApplications (OOP-SLA 96) (San Jose, CA, Oct. 1996), pp. 179-197. [23] TIP, F., AND SWEENEY, P. F. Class \nhierarchy special-ization. In Proceedings of the Eleventh Annual Confer-ence on Object-Oriented Programming \nSystems, Lan-guages, and Applications (OOPSLA 97) (Atlanta, GA, 1997), pp. 271-285. ACM SIGPLAN Notices \n32(10). [24] WEOMAN, M., AND ZADECK, F. Constant propagation with conditional branches. ACM lkansactions \non Pro-gramming Languages and Systems IS, 2 (lQQl), 181- 210. [25] WEISER, M. Program slices: formal, \npsychological, and practical investigations of an automatic program ab-straction method. PhD thesis, \nUniversity of Michigan, Ann Arbor, 1979.  \n\t\t\t", "proc_id": "277650", "abstract": "Object-oriented applications may contain data members that can be removed from the application without affecting program behavior. Such \"dead\" data members may occur due to unused functionality in class libraries, or due to the programmer losing track of member usage as the application changes over time. We present a simple and efficient algorithm for detecting dead data members in C++ applications. This algorithm has been implemented using a prototype version of the IBM VisualAge C++ compiler, and applied to a number of realistic benchmark programs ranging from 600 to 58,000 lines of code. For the non-trivial benchmarks, we found that up to 27.3% of the data members in the benchmarks are dead (average 12.5%), and that up to 11.6% of the object space of these applications may be occupied by dead data members at run-time (average 4.4%).", "authors": [{"name": "Peter F. Sweeney", "author_profile_id": "81332530743", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP31096597", "email_address": "", "orcid_id": ""}, {"name": "Frank Tip", "author_profile_id": "81100333471", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP15029416", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/277650.277750", "year": "1998", "article_id": "277750", "conference": "PLDI", "title": "A study of dead data members in C++ applications", "url": "http://dl.acm.org/citation.cfm?id=277750"}