{"article_publication_date": "05-01-1997", "fulltext": "\n Spill Code Minimization via Interference Region Spilling * Peter Bergner t Peter Dahlt David Engebretsen \nMatthew O Keefe University of Minnesota Department of Electrical Engineering Minneapolis, MN 55455 bergner@vnet.ibm.com \nAbstract Many optimizing compilers perform global register al-location using a Chaitin-style graph coloring \nalgorithm. Live ranges that cannot be allocated to registers are spilled to memory. The amount of code \nrequired to spill the live range depends on the spilling heuristic used. Chaitin s spilling heuristic \noffers some guidance in reducing the amount of spill code produced. How-ever, this heuristic does not \nallow the partial spilling of live ranges and the reduction in spill code is limited to a local level. \nIn this paper, we present a global tech- nique called interference region spilling that improves the \nspilling granularity of any local spilling heuristic. Our technique works above the local spilling heuristic, \nlimiting the normal insertion of spill code to a portion of each spilled live range. By partially spilling \nlive ranges, we can achieve large reductions in dynamically executed spill code; up to 75% in some cases \nand an average of 33.6% across the benchmarks tested. 1 Introduction Global register allocation can be \nmodeled as a graph coloring problem. Nodes in the interference graph rep-resent the live ranges which \nneed to be allocated to machine registers. Edges between nodes specify con-straints on the allocation. \nSpecifically, if two nodes are connected by an edge, then their associated live *This work was supported \nin part by the Ofice of Naval Research under grant no. NOO014-94-l-0846 and grant no. NOO019-95-1-0611, \nby the NSF through grant no. ASC-9523480, and in part by IBM Graduate Fellowships and an IBM Faculty \nDevelopment Award. Currently with IBM Rochester. tCurrently with SGI, Mountain View CA. Permission to \nmake digital/hard copy of part or all this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advan-tage, the copyright notice, \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission and/or a fee. PLDI 97 Las Vegas, NV, USA 0 1997 ACM 0-89791-907-6/97/0006...$3.50 \nranges cannot be allocated to the same machine register. The register allocation problem then becomes: \nDoes a proper k-coloring of the interference graph exist? If the interference graph is k-colorable, then \nthe colors can be seen as representing registers and the coloring as a valid register assignment. Although \nminimal graph coloring is NP-complete, fast and powerful heuristics exist that produce very efficient \ncolorings in practice [6, 3, 71. 1.1 Chaitin-Style Allocators Chaitin et al. at IBM Yorktown were the \nfirst to im-plement a global register allocator based on a graph coloring algorithm (5, 61. Chaitin s \ncoloring heuristic is fast, simple and it relies on the following seemingly obvious but very powerful \ngraph theoretic property: Given a graph G and a node v such that degree(v) < k, then G is k-colorabJeif \nand only if G -v is k-colorable. This property states that no matter how the reduced graph G - v is colored, \nthere will always be at least one color left for v. Chaitin s coloring heuristic utilizes this property \nto recursively simpZify the interference graph by removing unconstrained nodes2 until the graph is ei- \nther empty or all the nodes in the reduced graph are constrained3. If the graph is empty, then Chaitin \ns col-oring heuristic has reduced the problem of finding a k-coloring of the interference graph to finding \na k-coloring of the empty graph. Chaitin then reinserts the nodes into the graph in the reverse order \nthat they were re-moved, giving each node a color not used by any of its neighbors. Since each node was \nunconstrained when re- moved, each node is guaranteed to be colorable when it is m-inserted. Where k \nequals the number of machine registers. Nodes with degree < k. 3Nodes with degree 2 k.  spill code \n-+ renumber -build + coalesce -spill costs 4 simplify 4 color Figure 1: Flow Graph of Briggs Allocator \n 1.2 The Need for Spilling Register allocation becomes difficult when there are not enough registers \nfor all the live ranges (i.e., the inter-ference graph is not k-colorable). Since the number of machine \nregisters is fixed, a valid allocation for the in- termediate language (IL) does not exist. The problem \nthen is to modify the IL in such a way that its interfer- ence graph is k-colorable and the increase \nin program execution time is minimized. In Chaitin-style allocators, the IL is modified by spilling the \nlive ranges of uncolorable nodes to mem-ory during portions of the program when they are not needed. \nUsing Chaitin s spilling heuristic, this roughly translates to inserting a store after each def of the \nlive range and a load before every use (Section 2.1 describes Chaitin s spilling heuristic in more detail). \nA shortcom- ing of this heuristic is that it inserts spill code through- out the entire spilled live \nrange. The live range is ei- ther entirely allocated or it is entirely spilled, no middle ground exists. \nThis spilling heuristic results in the live range being broken into many very short live ranges, all \nof which are live for only one basic block (i.e., the new live ranges do not extend across basic block \nbound- aries.). In fact, many of the new live ranges are live for only a few IL statements. In this paper, \nwe present a global technique called interference region spilling that improves the spilling granularity \nof Chaitin s spilling heuristic4. Our tech-nique works above the local spilling heuristic, limiting the \nnormal insertion of spill code to a portion of each live range. This allows live ranges to be partially \nspilled so that the new live ranges produced by our technique may extend across basic block boundaries, \nmaybe even entire loops. By partially spilling live ranges, we can achieve large reductions in dynamically \nexecuted spill code; up to 75% in some cases and an average of 33.6% across the benchmarks tested. 40~r \ntechnique can actually improve the spilling granularity of any local spilling heuristic.  2 Briggs Allocator \nBriggs et al. developed an improvement to Chaitin s allocator when faced with a reduced graph that only \ncontains constrained nodes [3]. Normally, Chaitin s al-locator would remove one of the constrained nodes \nfrom the graph and mark it for later spilling. However, Briggs takes this node and removes it from the \ngraph as if it were unconstrained, optimistically hoping there will be a color for it during the coloring \nphase. This spill candi- date is chosen using Chaitin s spill cost heuristic which selects the constrained \nnode with the smallest spill cost divided by current degree. This heuristic attempts to satisfy the goal \nof minimizing spill costs while at the same time trying to simplify the graph by reducing the degrees \nof many nodes (hopefully making some of the neighboring nodes unconstrained). After the node has been \nremoved from the graph, the simplification stage continues the process of removing unconstrained nodes \nor choosing another spill candidate if there are none, until the graph becomes empty. Once the interference \ngraph has been reduced to the empty graph, Briggs re-inserts the nodes in reverse or-der of deletion, \nattempting to give each node a color that is different than any of its neighbors. For uncon-strained \nnodes, Briggs is guaranteed to find a color. For constrained nodes, if two or more non-interfering neigh-bors \nhave received the same color, then some color may still be available for assignment to the constrained \nnode. If Briggs finds an available color, he gives the node that color and continues. However, if the \nneighboring nodes have been assigned all k colors, then Briggs marks this node for later spilling. The \nprocess of coloring the nodes continues until all nodes have been reinserted with a color or marked for \nspilling. If all of the nodes receive a color, then the colors can be seen as representing machine registers \nand the col-oring aa a valid register assignment. If however, some of the nodes did not receive a color, \nthen Briggs in-serts spill code using Chaitin s spilling heuristic for all the live ranges whose nodes \nwere marked for spilling. Since spill code requires some register resources, the 3 Interference Region \nSpilling entire process of building, simplifying and coloring the interference graph is repeated until \nno further spilling is needed. The flow graph for Briggs allocator is shown in Figure 1. 2.1 Chaitin \ns Spilling Heuristic Once we have determined which live ranges are to be spilled, we must now decide \nwhere to place the spill code. The simplest and roughest technique is to insert a store after every def \nof the live range and a load be- fore every use. Although this spill-everywhere technique works, it usually \ngenerates much more spill code than is necessary. In Chaitin s spilling heuristic, he men-tions several \nlocal optimizations that can reduce the amount of spill code produced when compared to the spill-everywhere \ntechnique [6, Pages lOO-1011. . If a use of a live range is easy to recompute, then it should not be \nreloaded, but recomputed. . If a use of a live range is close to its definition, then it is unnecessary \nto reload the live range at the use. . If two uses of a live range are close, then it is un- necessary \nto reload the live range at the second use. . Live ranges whose uses are all close to their defi-nition \nshould never be spilled. Two references to a live range are defined by Chaitin to be close if no other \nlive range dies between them. In other words, if no new register resources are made available by the \ndeath of a live range, then the load at the second use will gain nothing and should be avoided. Spilling \na live range whose uses are all close to its def- inition will not help make the interference graph more \neasily colored. Therefore, Chaitin gives these live ranges an infinite spill cost. This ensures they \nare never spilled. Later work, such as Bernstein et aJ. s spill-almost- everywhere [l] and Briggs et \naJ. s rematerialization [4] techniques further reduced the amount of spill code gen- erated. However, \nthe drawback of all of these techniques is that if a live range has been marked for spilling, it is spilled \nentirely. To enable the partial spilling of live ranges, we intro- duce a new concept called the interference \nregion. For two interfering live ranges, we define their interference region to be the portion of the \nprogram where they are live simultaneously. By eliminating (i.e., spilling) this region from one of the \nlive ranges through the addition of spill code, they will no longer be live simultaneously anywhere in \nthe program; thus they will no longer in-terfere. This effectively removes the edge between the two nodes \nin the interference graph, making the graph more easily colored. An example of a simple interfer-ence \nregion can be seen in Figure 2. To spill an interference region from a live range, we simply limit the \ninsertion of normal spill code to the uses of the live range that occur inside the inter-ference region \nand to the definition points of the live range that can reach, in the data-flow sense, the inter- ference \nregion. Unlike Chaitin s and Bernstein s local spilling heuristics, our technique can reduce the num-ber \nof stores as well as the number of loads inserted for non-rematerializable live ranges. In the event \nthe spilled live range will be used again after the interference region, as is the case in our exam-ple, \nwe must introduce a new form of spill code to reload the live range back into a register for further \nreuse. If the next use of the spilled live range after the inter-ference region is within the current \nbasic block, then our reloads will be inserted at the same location where Chaitin s spilling heuristic \nplaces a load. However, if the next use is in a successor basic block, then we will insert a reload where \nChaitin has none. This has important ramifications when computing interference region spill costs. Specifically, \nit may be more expensive, in terms of weighted loads and stores to spill an interference region from \na live range than to spill the live range entirely. In the next section, we discuss how to easily ensure \ninterference region spilling never generates more expensive spill code than the local spilling heuristic. \nReturning to our simple example, Figure 3 shows what live range B might look like after spilling it using \nChaitin s spilling heuristic, while Figure 4 shows what it might look like after interference region \nspilling. Notice that with interference region spilling and after renum-bering, the majority of B s original \nlive range is still intact and it no longer interferes with A. B I -store Interference --load Region \n --load -T -load I -closeuse --load Figure 2: Live Ranges Figure 3: Chaitin Spilling Figure 4: IR Spilling \n3.1 Choosing Interference Regions to Spill Now that we are able to remove arbitrary edges from the interference \ngraph by spill interference regions, the question becomes: which interference regions should we spill? \nOur solution utilizes the k-colored subgraph of the interference graph and the list of uncolorable nodes \nfrom the output of Briggs coloring phase. In Briggs allocator, the k-colored subgraph repre-sents the \nlive ranges that can be fully allocated, while the list of uncolorable nodes represents the live ranges \nthat could not be fully allocated (i.e., there may have been some register resources available, but none \nwere sufficient to entirely satisfy their needs). With inter-ference region spilling, we refine the meaning \nof the k-colored subgraph to represent the live ranges that can be fully or partially allocated. We start \nwith the k-colored subgraph produced by Briggs and we attempt to increase its size by attaching onto \nthe subgraph each of the uncolorable nodes, such that the enlarged sub-graph is still k-colorable. Since \nthese nodes are uncol-orable, we cannot include all of their edges. For each uncolorable node, we group \nits edges into k sets -one set for each color -where each set contains the edges that lead to neighboring \nnodes with the same color. A color is then chosen that minimizes spill costs, and the set of edges associated \nwith that color are not inserted back into the graph with the node. By not inserting the edges from one \nof the sets, we have made available a color with which that node can be colored. The edges not inserted \nrepresent the interference regions we must spill. By increasing the size of the k-colored subgraph, we \nare allowing portions of live ranges that were spilled by Chaitin s spilling heuristic to be allocated, \nthus re-ducing the amount of spill code for each spilled live range. An important consequence of interference \nregion spilling is that we insert a subset of the loads and stores generated by Chaitin s spilling heuristic \nworking alone, meaning any load or store we insert will be inserted by Chaitin s heuristic, while some \nloads and stores Chaitin inserts may not be inserted by our technique. How-ever, our technique may also \ninsert some reloads which Chaitin s spilling heuristic does not insert. Therefore, the amount of spill \ncode reduction, if any, depends on the number of uses of the live range that lie outside the spilled \ninterference regions, plus the number of defini- tion points that do not reach those interference regions, \nminus any reloads we are forced to insert5. In the event the interference region covers the en-tire live \nrange, then our technique reduces to Chaitin s spilling heuristic. However, if we insert any reloads, \nit may actually be cheaper (in terms of weighted loads and stores) to spill the entire live range. However, \nsince our heuristic works on top of Chaitin s spilling heuristic, we can simply revert to using Chaitin \ns spilling heuristic for any live range which is less expensive to spill en-tirely than it is to spill \nany of its interference regions. Therefore, for a given spilling decision, we are guaran-teed never to \nproduce more spill code than Chaitin s spilling heuristic working alone. Actually, only reloads which \nare inserted in locations where Chaitin s spilling heuristic has not inserted a load count against us. \n A= input(); B=A+l; if (A) C C = A + 2; B= A + C; if ( c ) ( B= B + C; C= B + C;     lnlool A= \nB + C; D= A + B; Figure 5: Code Example Figure 6: Interference Graph Figure 7: Spill Costs 3.2 Interference \nRegion Spilling Example To demonstrate the effectiveness of interference region spilling, we present \na simple example to compare the spill code generated by interference region spilling ver-sus Chaitin \ns spilling heuristic. The code example and its corresponding interference graph are shown in Fig- ures \n5 and 6. In this example, we will attempt a 2-coloring using the spill costs? given in Figure 7. Figure \n8: a-Colored Sub-Graph After Briggs coloring phase has finished, we are left with the Zcolored subgraph \nshown in Figure 8 and the uncolored live range A. Normally we would spill the live range A using Chaitin \ns spilling heuristic resulting in the code in Figure 10. However with interference region spilling, we \nfirst insert the uncolorable node A back into the graph. Now we must make A colorable by choosing a color \nfor it and removing all of its edges leading to neighboring nodes with that color. For our example, we \nIn Briggs spill cost phase, loads and stores are charged a cost of 2 WTSUB 1 for rematerializable instructions \n[2]. Figure 9: Spilling AX-K have two choices. We may either omit the edge A4+B or we can omit the edge \nAi+C. The estimated spill cost of spilling interference re-gion A+K is less than the cost of spilling \ninterference region AtiB (1 store + 1 load vs. 2 stores + 1 load + 1 reload), so we omit this edge from \nthe graph giving us the enlarged P-colored subgraph shown in Figure 9. The code resulting from spilling \ninterference region AHC from live range A is shown in Figure 11. Once spilling is completed, we need \nto recompute live ranges and rebuild the interference graph so that we can attempt another coloring. \nHowever, for this ex-ample, we will find that the new interference graphs for the codes in Figures 10 \nand 11 are both P-colorable and further spilling is not necessary. Therefore, the fi- nal result is that \ninterference region spilling inserted 1 store and 1 load of live range A while Chaitin s spilling heuristic \ngenerated 2 stores and 2 loads. This is a 50% reduction in total spill code for this example. A = input0; \nstore A; B=A+l; if ( A > { load Al; C = Al + 2; B= Al + C; if ( C > { B=B+C; C =B+C; 1 A2 =B+C; store \nAs ; 1 load As; D = A3 + B; Figure 10: After Spilling A Entirely A = input0; store A; B=A+l; if ( A \n> { load Al; C = A1 + 2; B = A1 + C; if ( C 1 { B =B+C; C =B+C; 1 A =B+C; D =A+B; Figure 11: After Spilling \nAHC  3.3 Implementat ion Details To implement interference region spilling, we modified Briggs allocator \nin two ways. First, we added an addi- tional interference region spill costs stage that, for each spilled \nlive range, determines whether we should spill the entire live range or which set of interference regions \nwe need to spill. This stage attempts to choose the in- terference regions that will minimize the amount \nof spill code needed. Secondly, the spill code stage was modified to limit the insertion of spill code \nto the uses inside the spilled interference regions and to the loads needed to reload the live range \nfor any further uses outside the interfer- ence regions. We also altered this stage so that only definition \npoints that reach the new loads and reloads will have stores inserted for them. Figure 12 shows the flow \ngraph for Briggs allocator modified with interfer- ence region spilling. In Briggs implementation of \nChaitin s spilling heuris- tic, a single pass is made over the control flow graph and each instruction \nin the block is visited in reverse order. As each instruction is visited, the instruction operands are \nexamined to determine whether any spill loads or spill stores are needed. Three sets are uti-lized: live \nindicates which live ranges are currently live, markedLR contains the live ranges that have been marked \nfor spilling and needLoad specifies all the live ranges which have been marked for spilling and have \nbeen used since the last death. foreachBaeicBlock(CFG, blk) { copySet(live. blk->liveOut); clearset(needLoad); \nforeachHember(markdLB, rag) { < hit range Crag] . numLiveWeighbore info > if ( member?(live, rag) &#38;&#38; \n! range [rag] . rpillEntirely t&#38; rengeCreg1 .numLiveNeighbore == 0 ) addMember(needReload. rag); \n1 // Scan inatructiona from bottom to top... foreachInenB2T(blk, inen) { < handle definitions of inm \n> < check for deaths in inen > < handle uses of inen > 1 // Add loads at top of block foreachHember(needLoad, \nrag) < insert load of reg > // Add rome reload8 at top of block foreachMember(needReload, reg) if ( \nat XR boundary for reg 1 < insert reload of reg > 1 < insert stores for defs that reach the new Joads/reJoada \n> Figure 13: Interference Region Spill Code interference interference r region spill code region spill \ncosts \\ * T + renumber -+ build + coalesce + spill costs -+ simplify + color + Figure 12: Briggs Allocator \nModified with Interference Region Spilling Our implementation of interference region spilling builds \nupon this framework in several ways. We have added three new fields to Briggs range structure. The range \n[reg] . SpillEntirely field indicates whether a live range is cheaper to spill entirely or spill partially. \nIf a live range is partially spilled, range Cregl . spillColor specifies the interference regions that \nneed to be spilled (i.e., the interference regions associated with edges lead- ing to neighboring nodes \nthat were assigned the color range[reg] . spillcolor). To easily detect when an interference region boundary \nis encountered, we incre- mentally update the range Cregl . numLiveNeighbors field to count the number \nof neighbors that are assigned the color range[reg] . spillColor and that are cur-rently live. Since \nreloads are inserted at interference re-gion boundaries, a needReload set was added to track the live \nranges that have been marked for spilling but have only been used outside of any spilled interference \nregion. While scanning the definitions, Briggs implementa- tion updates the live and needLoad sets and \ninserts stores for definitions of spilled live ranges. With in-terference region spilling, we include \nan update of the needReload set and delay the insertion of stores until until all loads and reloads have \nbeen inserted. // Handle definitions of insn forsachDefinedReg(insn, rag) { < update rangeC...].numLiveNeighbors \ninfo > deleteMsmber(needLoad, reg); deleteMember(needFleload, reg); deleteMember(live, rag); Figure 14: \nHandle Definitions In Briggs implementation of Chaitin s spilling heuris- tic, if a death is detected, \nloads are inserted for every spilled live range that has been used since the last death (i.e., members \nof needload). With interference region spilling, we also need to insert reloads if this death is an interference \nregion boundary for any member of needReload. // Insert loads/reloads only at deaths... foreachUsedReg(insn. \nreg) { if ( !member?(live, reg) 1 { color = renge[reg].color; foreachMember(needReload. mom) if ( color \n== range[meml.spillColor tt renge[mem].numLiveNeighbors == 0 &#38;&#38; interfere(reg, mom)) { < insert \nreload of mom > deleteHember(needReload, mom); 1 foreachMember(needLoad, mem) < insert load of mom > \nclearSet(needLoad); 1 1 Figure 15: Check for Deaths Finally, after any loads and reloads have been in-serted, \nthe live, needLoad and needReload sets need to be updated. If a used live range is a member of markedLR, \nthen it is added to the needLoad set if is cheaper to spill entirely or this use occurred within a spilled \ninterference region. Otherwise, if the live range is not already a member of needload, it is added to \nthe needReload set. An important question with regard to interference region spilling is how much effect \ndoes it have on alloca- tion time when compared to Chaitin s spilling heuristic. Currently, we only have \nlimited allocation time mea-surements comparing interference region spilling and Chaitin s spilling heuristic. \nPreliminary data compiling tomcatv indicates that the increase in register alloca-tion time due to interference \nregion spilling is approx- imately 20 -40%. However, analyzing our implemen-tation, we believe tuning \ncan reduce this performance penalty. The modifications to Briggs allocator have been localized to the \nspilling phase, which means that the allocation time for routines that do not need any spilling is unchanged. \nFor routines that require spill code, we now must compute interference region spill costs. However, we \nneed only compute these for live ranges that have been marked for spilling. // Handle uses of insn foreachUsedReg(insn, \nreg) { if ( member?(markedLIt, rag) ) { if ( range Cregl . spillEntirely I I range [regl .numLiveNeighbors \n!= 0 1 addMember(nesdLoad, reg); else if ( !member?(needLoad, rsg) ) addMember (needfteload, rag) ; } \nelse if ( !member?(live, reg) 1 < update rangel.. .I .numLiveNeighbors info > addMember (live, reg) ; \nI Figure 16: Handle Uses Results In order to experiment with our spill code minimiza-tion heuristics, \nwe have modified a version of the GNU C compiler (gee version 2.7.2 targeted to a MIPS II processor) \nto contain our implementation of Briggs op- timistic coloring allocator. We then modified Briggs al- \nlocator so that we can choose between the normal spill code stage which uses Chaitin s spilling heuristic \nand our new spill code stage which uses interference region spilling. We then compiled several integer \nand float-ing point intensive programs from the SPEC 92 suite of benchmarks. To simulate varying levels \nof register pressure, we compiled each benchmark multiple times varying the number of registers available \nto the register allocator. To accurately measure the amount of exe- cuted spill code, a MIPS II instruction \nlevel simulator was used to count the spill code that was inserted by our spilling phases. Our results \nare given in Table 17. The first two columns of the table specify the benchmark compiled and the number \nof registers available for allocation7. The third and fourth columns give results using Briggs implementation \nof Chaitin s spilling heuristic[2]. Col-umn 3 shows the dynamic spill cost which is computed by counting \neach spill instruction executed* and column 4 shows the percentage of all instructions executed that \n 7Here, 8 registers indicates 8 integer and 8 floating point regis-ters were used for allocation. Note \nthe MIPS II ISA only contains 16 usable floating point registers. Spill loads and stores are weighted \ntwice as much as simple re-materialized spill instructions. were spill code. The fifth and sixth columns \ngive the same information as columns 3 and 4 for interference region spilling. The next three columns \nshow the per- cent improvement in terms of dynamic spill costs for loads, stores and rematerialized instructions. \nFinally, the last two columns show the percent reduction in dy- namic spill code executed and execution \ntimer . For example, the first row of data shows we compiled the benchmark compress, allowing the allocator \nonly 8 registers for coloring. The spill cost using Chaitin s spilling heuristic was 128 million weighted \nspill instruc- tions executed and 19.5% of all instructions executed were spill instructions. For interference \nregion spilling, our dynamic spill cost dropped to 63 million weighted spill instructions, which now \ncomprise only 11.7% of all instructions executed. This gives us a 51.2% reduction in spill code and an \n18.6% execution time improvement. Note that all percentages less than one tenth of one per- cent have \nbeen left blank and register file sizes for which spill code comprised less than one percent of all instruc- \ntions executed have been omitted. Examining these results, we notice that although in-terference region \nspilling is not guaranteed to generate less spill code than Chaitin s spilling heuristic, for ev-ery \nbenchmark compiled, interference region spilling aZ-ways produced better spill code than Chaitin s spilling \nheuristic. Secondly, interference region spilling aver-aged a 33.6% reduction in dynamic spill costs \nand an 8.3% improvement in execution time over all of the benchmarks compiled. 5 Conclusion We have \nintroduced a new fine granularity spilling tech- nique called interference region spilling that can sig-nificantly \nreduce the amount of spill code generated in Chaitin-style graph coloring register allocators. In-terference \nregion spilling relies on our definition of an interference region, which specifies the portion of the \nprogram where two interfering live ranges are live si- multaneously. Spilling this region from one of \nthe live ranges breaks their interference, allowing them to be al- located to the same register. The \nresults demonstrate the effectiveness of interference region spilling. Com-paring against Chaitin s spilling \nheuristic, interference region spilling reduced dynamic spill costs an average of 33.6% across all register \nfiles sizes and benchmarks tested and up to 75% in some cases. Our results also indicate that under heavy \nregister pressure, interfer-ence region spilling significantly outperforms Chaitin s spilling heuristic. \nTimings were taken on an MIPS R5000. Data shown is an average of 10 trials. Program # Regs Chaitin Dynamic \n% total Spill Costs i IR Suill % total iI load 1 store Percentage Reduction I remat 11 Total Spill Compress \n8 128222726 19.5 62578192 11.7 51.2 51.2 12 128222726 19.5 62578192 11.8 51.2 51.2 16 128222726 19.5 \n62578192 11.7 51.2 51.2 20 26421276 6.6 26421272 6.6 Espresso 8 966806867 14.9 763558471 12.0 16.9 -0.4 \n4.5 21.0 12 733166332 12.0 502212430 8.7 27.6 0.5 3.4 31.5 16 563277100 9.7 334234983 6.1 35.2 0.1 5.4 \n40.7 20 99429247 2.0 74511956 1.5 24.1 1.0 25.1 Li 8 2330448245 39.6 1470516987 29.5 35.6 1.3 36.9 12 \n2340525803 41.4 1465031307 30.4 36.1 1.3 37.4 16 2345019255 42.5 1465032073 30.7 36.3 1.3 37.5 20 142346501 \n3.8 119978216 2.9 0.1 15.7 15.7 Alvinn 8 1824793308 46.2 463650268 17.9 74.6 74.6 12 1817620508 46.1 \n458937468 17.8 74.8 74.8 lfi 1816336508 46.1 457653468 17.7 74.8 74.8 Tomcatv Figure 17: SPEC 92 Benchmarks \n 11 Run Time , 18.6% 16.1% 16.4% 0.5% 6.8% 8.7% 6.7% 0.9% 9.0% 9.3% 8.8% -0.1% 15.0% 13.5% 15.7%  References \n[l] BERNSTEIN, D., GOLDIN, D. Q., GOLUMBIC, M. C., KRAWCZYK, H., MANSOUR, Y., NAHSHON, I., AND PINTER, \nR. Y. Spill code minimization techniques for optimizing compilers. SIGPLAN No-tices 24, 7 (July 1989), \n258-263. Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation. \n [2] BRIGGS, P. Register allocation via graph coloring. Ph.D. Thesis Rice COMP TR92-183, Department of \nComputer Science, Rice University, 1992. PI BRIGGS, P., COOPER, K. D., KENNEDY, K., AND TORCZON, L. Coloring \nheuristics for register alloca-tion. SIGPLAN Notices 24, 7 (July 1989), 275-284. Proceedings ofthe ACM \nSIGPLAN 89 Conference on Programming Language Design and Implementa- tion. [4] BRIGGS, P., COOPER, K. \nD., AND TORCZON, L. Rematerialization. SIGPLAN Notices 27, 7 (July 1992), 311-321. Proceedings of the \nACM SIGPLAN 92 Conference on Progmmming Language Design and Implementation. [5] CHAITIN, G., AUSLANDER, \nM., CHANDRA, A., COCKE, J., HOPKINS, M., AND MARKSTEIN, P. Register allocation via coloring. Computer \nLan-guages 6 (1981), 47-57. [6] CHAITIN, G. J. Register allocation and spilling via graph coloring. \nSIGPLAN Notices 17, 6 (June 1982), 98-105. Proceedings of the ACM SIGPLAN 82 Symposium on Compiler Construction. \n[7] CHOW, F. C., AND HENNESSY, J. L. The priority- based coloring approach to register allocation. ACM \nZkans. Program. Lang. Syst. 12, 4 (Oct. 1990), 501- 536. 295  \n\t\t\t", "proc_id": "258915", "abstract": "Many optimizing compilers perform global register allocation using a Chaitin-style graph coloring algorithm. Live ranges that cannot be allocated to registers are spilled to memory. The amount of code required to spill the live range depends on the spilling heuristic used. Chaitin's spilling heuristic offers some guidance in reducing the amount of spill code produced. However, this heuristic does not allow the partial spilling of live ranges and the reduction in spill code is limited to a local level. In this paper, we present a global technique called <i>interference region</i> spilling that improves the spilling granularity of any local spilling heuristic. Our technique works above the local spilling heuristic, limiting the normal insertion of spill code to a portion of each spilled live range. By partially spilling live ranges, we can achieve large reductions in dynamically executed spill code; up to 75% in some cases and an average of 33.6% across the benchmarks tested.", "authors": [{"name": "Peter Bergner", "author_profile_id": "81100040439", "affiliation": "IBM Rochester", "person_id": "P223627", "email_address": "", "orcid_id": ""}, {"name": "Peter Dahl", "author_profile_id": "81100410510", "affiliation": "SGI, Mountain View CA", "person_id": "P223877", "email_address": "", "orcid_id": ""}, {"name": "David Engebretsen", "author_profile_id": "81100634007", "affiliation": "University of Minnesota, Department of Electrical Engineering, Minneapolis, MN", "person_id": "P61405", "email_address": "", "orcid_id": ""}, {"name": "Matthew O'Keefe", "author_profile_id": "81100336916", "affiliation": "University of Minnesota, Department of Electrical Engineering, Minneapolis, MN", "person_id": "PP39063138", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258941", "year": "1997", "article_id": "258941", "conference": "PLDI", "title": "Spill code minimization via interference region spilling", "url": "http://dl.acm.org/citation.cfm?id=258941"}