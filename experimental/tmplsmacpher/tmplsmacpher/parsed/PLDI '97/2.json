{"article_publication_date": "05-01-1997", "fulltext": "\n A Member Lookup Algorithm for C++ G. Ramalingam and Harini Srinivasan IBM T.J. Watson Research Center \nP.O. Box 704, Yorktown Heights, NY, 10598, USA 1rama, harini}Qaatson.ibm.cw Abstract The member lookup \nproblem in C++ is the problem of resolving a specified member name in the context of a specified class. \nMember lookup in C++ is complicated by the presence of virtual inheritance and multiple in-heritance. \nIn this paper, we present an efficient algo-rithm for member lookup in C++. We also present a formalism \nfor the multiple inheritance mechanism of C++, which we use as the basis for deriving our algo-rithm. \nThe formalism may also be of use as a formal basis for deriving other C++ compiler algorithms. 1 Introduction \nThis paper concerns member lookup in C++. When a class member access expression such as x . m is statically \nanalyzed, e.g. by a compiler, the member name III has to be resolved in the context of a class specified \nby the sta-tic type of x. In the presence of just single inheritance, member lookup is essentially like \nname lookup in the presence of nested scopes (eg., as in languages like Pas-cal that allow nested procedures), \nwhich is fairly simple. Member lookup in C++, however, is complicated by the presence of multiple inheritance, \nvirtual and non-virtual inheritance, and the C++ rule of dominance. An object (i.e. , a class instance) \nmay contain, thanks to inheritance, multiple members with the same name. The C++ dominance rule defines \nwhich members of an object dominate (i.e., hide ) which other members with the same name. The lookup \nfor a member name m in the context of a class D unambiguously resolves to a particular member named m \niff that member domi-nates all other members named m in an object of class D. Otherwise, the lookup is \nsaid to be ambiguous. Permission to make digital/hard copy of part or all this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvan-tage, the copyright notice, the title of the publication and its date appear, and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to \nredistribute to lists, requires prior specific permission and/or a fee PLDI 97 Las Vegas, NV, USA 0 1997 \nACM 0-89791-907-6/97/0006...$3.50 This seems simple enough. However, some subtleties creep in when one \nattempts to formalize the above ex-planation. As evidence of this complexity, consider the fact that \nthe following description of the concept in the The Annotated C++ Reference Manual is, in fact, im-precise: \nA name B: :f dominates a name A: : f if its class B has A as a base. If a name dominates another no ambiguity \nexists between the two; the dominant name is used when there is a choice [5, page 204-2051. The recent \ndraft definition of ANSI C++ makes this explanation more precise: A member name f in one subobject B \ndomi- nates a member name f in subobject A if A is a base class subobject of B [l, Section 10.21. The \ncomplexity arises from the difference in the se-mantics of virtual and non-virtual inheritance, which \nmakes it somewhat difficult to even identify the precise set of members contained in an object! Figures \n1 and 2 illustrate the problem through two examples. Figures l(a) and 2(a) depict two programs. The only \ndifference between these two programs is that the first one uses non-virtual inheritance while the sec-ond \nuses virtual inheritance. The class hierarchy of a program may be depicted by a graph, the class hierar-chy \ngraph, whose nodes denote classes and whose edges denote inheritance relations. The class hierarchy graph \nof the programs in Figures l(a) and 2(a) are presented in Figures l(b) and 2(b) respectively. (The solid \nedges denote non-virtual inheritance, while dashed edges de-note virtual inheritance.) It turns out the \nlookup p->m is ambiguous in Fig-ure l(a) but not in Figure 2(a) (even though the quota-tion from The \nAnnotated C-t+ Reference Manual above seems to suggest that the lookup is unambiguous in both cases). \nThe precise details are irrelevant here, but the ultimate source of the problem is that an E object has \ntwo subobjects of class A in the first case, but only one subobject of class A in the second case. The \ntrou-ble is that the class hierarchy graph does not make this obvious. A different graph-based representation \nof the class hierarchy, called the subobject graph, does depict the composition of objects of various \nclasses better. The subobject graph facilitates formalizing the concepts of dominance and the lookup \noperation. Rossie and Fried-man [9] present a formalism that models the multiple inheritance mechanism \nof C++, where they provide for-mal definitions of the subobject graph, and utilize it to provide a definition \nof the member lookup operation. A precise description of the subobject graph can be found in [9]. Informally, \nthe subobject graph can be generated from the class hierarchy graph by duplicating nodes as indicated \nby the C++ semantics of non-virtual inher-itance. The subobject graphs of the examples in Fig-ures l(a) \nand 2(a) are presented in Figures l(c) and 2(c) respectively. Rossie and Friedman s goal is to provide \na model of member lookup in C++, not an algorithm. (Their spec-ification of the lookup operation, being \nexecutable, is it- self an algorithm. However, it is a potentially inefficient one since the subobject \ngraph s size can be exponential in the size of the class hierarchy graph.) In this paper, we present \na formalism based on the class hierarchy graph that models the multiple inheri-tance mechanism of C++. \nThere is a close relationship between our formalism and that of Rossie and Fried-man, as will be explained \nin the paper. However, since our formalism is based on the class hierarchy graph, it enables us to derive \nan efficient, polynomial time algorithm for member lookup. (The worst-case com-plexity of doing a single \nlookup using our algorithm is O(lNI x (INI + (El)), where INI denotes the number of classes in the program, \nand IEl denotes the num-ber of inheritance edges in the class hierarchy graph. The complexity of a single \nlookup, however, reduces to O((NI + IEI) in the common case of a program with no ambiguous lookups. All \npossible member lookups can be done in time O(lMI x INI x (INI + IEI)) (or O((lMI + INI) x (INI + IEI)) \nfor a program with no ambiguous lookups), where IMI denotes the number of member names in the program. \nThe primary contribution of this paper is an algo-rithm for member lookup in C++. (We are not aware of \nany previously published algorithm for this problem.) A secondary contribution of this paper is a reformulation \nof the Rossie-Friedman multiple inheritance formalism, which we feel may be of use as a formal basis \nfor de-riving efficient implementations of various aspects of a C++ compiler, as illustrated by this \npaper in the case of member lookup. Apart from its applications in a C++ compiler (in performing static \nanalysis and in constructing virtual-function tables), our lookup algorithm is also useful in efficiently \nimplementing class hierarchy slicing [12]. Organization: Section 2 introduces the terminol-ogy we use. \nSection 3 presents our formalism. Section 4 describes the ideas behind our algorithm. Section 5 presents \nthe algorithm and an analysis of its complex-ity. Section 6 discusses a few other issues relating to \nlookup in C++. Section 7 discusses related work and Section 8 concludes our paper.  2 Terminology The \nclass hierarchy of a C++ program can be com-pactly modelled by a directed acyclic graph, the Class Hierarchy \nGraph (CHG) whose nodes denote classes and whose edges denote inheritance relations. The CHG of a program \nis defined as follows. Let N denote the set of classes in the C++ program. Let E, denote the set of all \npairs of classes (X, Y) such that X is a direct virtual base of Y. Let Env denote the set of all (X, \nY) such that X is a direct non-virtual base of Y. We will refer to the elements of E,, and Env as virtual \nand non-virtual edges respectively. Let E denote E, U E,.,,. We will use the notation X + Y to refer \nto an element (X, Y) of E. The class hierarchy graph is the tuple (N, E). A class X is said to be a base \nclass of another class Y iff there is a nonempty path from X to Y in the CHG. Further, X is said to be \na virtual base class of Y iff there is a path from X to Y whose first edge is a virtual edge. We will \ndenote a path in the CHG by the sequence of nodes in the path, though, for the sake of clarity, we will \noften denote a path consisting of a single edge as C ----) E rather than CE. Let Q and p be two paths \nsuch that the last node of a and the first node of p are the same. We will denote the path obtained by \nconcatenating cr And p by a op. For example, (ABC) . (CED) is ABCED. We say a is a prefix of cy . /3 \nand that p is a suffix of a . /3. (A path is both a prefix and suffix of itself.) We will denote the \nset of all paths in a graph G by Paths(G). Every class X has an associated set of members, which we denote \nby M[X], which is the set of mem-bers declared directly in that class. (In figures depict-ing class hierarchy \ngraphs, elements of M[X] are shown enumerated adjacent to node X.) A class, however, in-herits all members \nof its base classes as well. A precise definition of the set of members that constitute a ckss instance \n(also called object) is complicated, and we will defer that to the next section. We will not distinguish \nbetween virtual and non- A mO A ml) A m0 class A ( void m() ; ); 1 1 class B : A 0; i B B class C: B \n1); iB\\ 1 1 class D: B ( void mO; } D mO class E : C, D 0; k/ v m E E E +p; . . . p->m(); (c) Subobject \nGmph (a) Non-vi&#38;al Inheritance Example (6) Class Hierarchy Graph Figure 1: An example illustrating \nnon-virtual inheritance. class A ( void m() ; }; i 1 class B : A 0; B B I \\ I \\ class C: virtual B {}; \nf/ lr fl \\ class D: virtual B ( void m(); } D NJ D mO classE:C,D{}; k/ CL/ E E E P; . . . p->m(); (6) \nClass Hierarchy Graph (c) Subobject Graph (a) Vi&#38;d Inheritance Example Figure 2: An example illustrating \nvirtual inheritance. virtual members, as the distinction makes no difference same pair of classes identify \nthe same subobject. In the for the problem we address. C++ also makes a dis-absence of virtual inheritance, \ndifferentpaths always tinction between static and non-static members, which identify different subobjects. \nis relevant to lookup. We will postpone the discussion Any formalism for explaining the multiple inheri-of \nstatic members until Section 6 and assume that all tance mechanism of C++ must begin by answering the \nmembers are non-static for now. question: what is the set of subobjects that comprises an instance of \na given class? [9]. Rossie and Friedman do so by constructing a subobject graph. In this sec-  3 A Model \nof C++ Multiple Inheritance tion we present a formalism similar to that of Rossie and Friedman, except \nthat it is based on the class hierarchyThe essential meaning of an inheritance edge B + D graph rather \nthan the subobject graph. in the class hierarchy graph is that every D object con-tains a B object. In \nparticular, a D object inherits all members of B as well. The Composition of Class Instances If A, is \na base class of AI, then there exists some We will begin by answering the question: when do two path \nA,, A,, - 1. . .AzAl. Such a path implies that every different paths in the CHG identify the same subobject? \nAl object contains a Aa subobject that contains a Ad subobject that, continuing in the same vein, eventually \nDefinition 1 For any path a, let ldc(a) denote the contains a A,, subobject. source of the path, and \nlet mdc(cu) denote the target The presence of multiple inheritance implies that of the path. multiple \npaths can exist between a given pair of classes B and D. Each of these paths identifies a B subobject \n(Here, ldc stands for the least derived class, while within a D subobject. Because of the presence of \nboth mdc stands for the most derived class.) virtual and non-virtual inheritance, different paths be-tween \nthe same pair of classes may or may not identify Definition 2 For any path CY, let fixed(a) denote the \nthe same subobject within a given object. In the ab-longest prejiz of the path that does not contain \nany vir-sence of non-virtual inheritance, all paths between the tual edge. H A foe a path ,!? in the \nCHG iff cx hides some path p x p* Figure 3: Example Class Hierarchy Graph We define a binary relation \nM on paths as below. Definition 3 Given two paths Q and p in the CHG, a~+? iflfized(cu) = fized(@) and \nmdc(o) = mdc(P). Obviously, RS is an equivalence relation on paths. The equivalence relation answers \nthe question of when two different paths identify the same subobject: cr@ iff both CY and /3 identify \nthe same subobject. Example. Consider the class hierarchy graph in Fig-ure 3. In this example, there \nare four paths between classes A and H, and the fized part of these paths are as follows: fized(ABDFH) \n= ABD, fized(ABDGH) = ABD, fied(ACDFH) = ACD, fized(ACDGH) = ACD. Hence, ABDFH xABDGH and ACDFH =ACDGH. \nConsequently, both ABDFH and ABDGH denote the same subobject in a H object. Likewise, both ACDFH and \nACDGH denote the same subobject in a H object. However, ABDFH $ACDFH. Thus, there are two dif-ferent \nsubobjects of class A in an instance of H. 0 For any path a, let [a] denote the equivalence class to \nwhich a belongs. In view of the above explanation, we may use the x-equivalence classes to identify or \nname subobjects. Observe that the equivalence relation, x, can hold only between paths with the same \nend points, since the condition fized(cy) = fixed(P) implies Idc(a) = Zdc(P). Hence it is meaningful \nto define: Definition 4 mdc([a]) = mdc(a); Zdc(p]) = Idc(P) Let us denote the set of all equivalence \nclasses of paths in a CHG G by q(G). We are now ready to define the composition of class instances. The \ncollection of subobjects that constitute an instance of a class X is: ( u E q(G) 1 mdc(a) = X }. A subobject \nu itself is composed of a collection of mem bers defined by M[ldc(u)].  The Dominance Rule Definition \n5 We say a path a hides a path p in the CHG if (Y is a suffix of p. We say a path cy dominates Example. \nIn the graph of Figure 3, path GH hides ABDGH but not ABDFH. Path GH dominates path ABDFH because GH \nhides ABDGH and ABDGH z ABDFH. Similarly, FH dominates ABDGH since FH hides ABDFH and ABDFH R ABDGH. \nI Lemma 1 Let a x CY and p x pt. Then a dominates /3 iflcz dominates p . Proof. Let a M (Y and p x p \n. First note that a ti (Y implies that fized(7 . a) = fized(-y . a ), for any 7. Now assume that CY dominates \np. Then, there exists some path 7 such that 7 . a M p. It is straightforward to show that 7 . (Y x /3, \nHence art dominates p. Since a dominates p and /3 F;: p , it follows from the definition of domination \nthat CX dominates fl. 0 Observe that this lemma states that the dominance relation on paths can be meaningfully \nextended to equiv- alence classes as below. Definition 6 We say that [cx] dominates PO] if and onZy if \nQ dominates p. Lemma 2 Q@(G), dominates) is a partial order. Proof. Reflezivity: Domination is obviously \nreflexive. Antisymmetry: Assume that [a] dominates [p] and lo] dominates [a]. Then, a is a suflix of \nsome p #. Further, p is a suffix of some CX WY. Consequently, a = p = a . Hence, domination is antisymmetric. \nT4-ansitivity: Assume that [Q] dominates lo] and lo] dominates [7]. Then, OL is a suffix of some p @. \nFur-ther, p is a suffix of some 7 ~7. Hence, a is a s&#38;x of some 7 ~7. In other words, [cr] dominates \n[7]. Hence, domination is transitive. I Formalizing Member Lookup Let us now turn our attention to member \nlookup. Let C be a class in a CHG. The set of all subobjects, within an object of class C, that contains \na member m is defined as follows. Definition 7 Defis(C, m) = {a E Q(G) 1 mdc(a) = C and m E Members(Idc(a))) \nExample. Consider our example CHG in Figure 3. Which subobjects of a H object have a member foo? AB :: \nkm AC :: fw Defns( H, f oo) = ((ABDFH, ABDGH), (ACDFH, ACDGH}, {GH}} Each of these elements of Defns(A, \nfoo) is an equiva-lence class of paths. Each of these equivalence classes identifies a unique and distinct \nsubobject of a H object that contains a member called foo. Similarly, we have: Defis(H, bar) = { (EFH}, \n{DFH, DGH}, {GH} }. 0 We are now ready to define the lookup operation. Definition 8 IfA is a set of equivalence \nclasses of paths, we define most-dominant(A) to be the unique ele-ment u E A such that u dominates u \nfor every u E A, if such a u exists, and we define most-dominant(A) to be 1 if no such u exists. Definition \n9 lookup(C, m) = most-dominant(Defns(C, m)) Example. In our example CHG, lookup(H, foo) = (GH} since \n{GH} dominates every element of Defis(H, foo). However, lookup(H, bar) = I since Defis(H, bar) does not \nhave a most-dominant element. 0 So far, we have used the w-equivalence classes as a convenient, deterministic \nrepresentation of subobjects. The algorithm we present later on, however, will manip ulate paths and \nnot equivalence classes. Hence, it will be convenient to extend the above definitions to paths as below: \nDefinition 10 DefnsPath(C, m) = {u E Paths(G) 1 mdc(a) = C and m E Members(Idc(cu))} Definition 11 IfA \nis a set of paths, we say a! E A is a most-dominant element of A if a dominates p for every PEA. Our \nalgorithm, in particular, will return some most-dominant element of qefnsPath(C, m), for a lookup on \nclass C for member mIn effect, rather than return an equivalence class of paths, it will return an arbitrary \nelement of the equivalence class. c4 ABD::fao , ACD::fm ABDF ::foo , ?==i% .@=% . ACDF::fw G::fw 0 ~i,~oo, \nGH :: loo Figure 4: Propagation of definitions of foo 4 The Idea Behind the Algorithm Let us first present \nthe outline of a simple, but ineffi-cient, algorithm that follows directly from the definition of lookup. \nThe algorithm consists of two phases. The goal of the first phase, the propagation phase, is to compute \nthe sets DefnsPath(C,m), for every class C and member m. Let us refer to a path a as a definition of \nmember m if it is an element of DefisPath(C, m) for some C. In the remaining part of this section we \nwill assume that we are only interested in a single member name m. (Thus, when we talk about any definition, \nit may be assumed to be a definition of m, unless otherwise mentioned.) Our goal is to identify all definitions \nof m. Let us refer to a definition ar::m as an inherited definition if a consists of at least one edge, \nand as a generated definition otherwise. The set of all generated defin-itions of m is easy to compute: \nit is simply the set { A:: m 1 A E N and m E Members(A) }. Starting out from the set of all generated \ndefinitions, we can identify all inherited definitions through the iterative process of propagating definitions \n(both generated and inherited) through the CHG: more precisely, a definition a::m is propagated along \nall outgoing edges of mdc(cr); the propagation of a definition a::m through an edge X -B Y identifies \na new (inherited) definition, namely cre(X + Y)::m. This iterative process stops when there are no more \nnew definitions to propagate. This propagation phase lets us identify the set of definitions that reach \neach node. The second phase of the algorithm is to simply determine for every class C if the set of definitions \nof m that reach C has a most-dominant definition a. If it does, then the result of lookup(C,m) is a. \nIf not, then Zookup(C,m) is undefined. The term definition and several other subsequent terms are used \nto draw an analogy between the algorithm presented here and the standard reaching definitions problem \n[3, Page 6101. Howerer, aa will become clear, there are quite a few differences between the two problems, \nand the reader should not be misled by the analogy. Example. Consider Figure 4, which illustrates this \nprocess for member foo. (Figure 5 illustrates the same for member bar.) There are two generated definitions \nof f oo namely, A::f oo and G::f oo. Propagation of A::f oo creates the two definitions AB::foo and AC::f \noo. Prop-agation of these two definitions, in turn, createsthe two definitions ABD::f oo and ACD::f oo, \nboth of which reach the same node D. The set of definitions that reach a node are shown adjacent to the \nnode. If the set of reaching definitions at a node has a most-dominant def-inition, that definition is \nshown in bold font. The other definitions are shown in italic. Obviously, the lookup is unambiguous exactly \nfor the nodes with a reaching definition in bold font. Other aspects of the figures (re- lating to nodes \nG and H) will be explained later. I Optimizing the Propagation Phase Note that our ultimate goal is to \njust identify the most- dominant reaching definition at every node. Not sur- prisingly, it turns out \nthat we do not really have to propagate all the definitions in order to do this. Consider the example \nin Figure 4. The definitions ABDG::foo and ACDG::foo reach the node G, which generates its own definition \nG::foo. It turns out that it is unnecessary to propagate ABDG::f oo and ACDG::f oo out of node G because \nthey are killed by G::foo. The following lemma indicates when it is validto kill a definition, i.e. , \nnot propagate it: Lemma 3 Path 7*(X -+ Y) dominates path 60(X + Y) ifl path 7 dominates path 6. a Proof. \n(+) Assume that 7 . (X -+ Y) dominates path 6 s (X + Y). Then, 7 . (X + Y) is a suffix of some path a \nw 6 . (X --t Y). Clearly, 01 must be of the form ,0.7o(X-+Y). Further, we must have /3 . 7 z 6. Hence, \n7 dominates 6. (+) Assume that 7 dominates 6. Then, 7 is a suffix of some path a NN 6. Clearly, 7 . \n(X -+ Y) is a suffix of ao(X+Y),andao(X-,Y)w6o(X+Y). Hence, %.emma 3 can also be stated as: most-dominant({ \n7 s (X -Y), 6 s (X + Y) 1) = most-dominant({ y,6 }) . (X + Y) (where I s(X -+ Y) is defined to be I). \nThe member-lookup problem is a pseudo-meet-orer-rll-paths da&#38;Bow analysis problem, where the pseudo-meet \noperation is most-dominant and the transfer function associated with edges is given by the path extension \noperator s. The above equation says that the path extension operator is distributive over most-dominant \n. This implies that the problem is a distributive dataflow analysis problem. Hence, it is not necessary \nto propagate ml1 the definitions reaching a node X along the outgoing edges of X; it is sufficient to \npropagate just the meet of all the reaching definitions. EFH :: bar , @WsZ@ GH :: bar Figure 5: Propagation \nof definitions of bar 7 . (X ---) Y) dominates 6 . (X --* Y). I Corollary 1 If 7 dominates 6 and 7 # \n6, then for any path 7 . w and any set S containing path 7 . w, S has a most-dominant element iff S -( \n6 . w } has a most- dominant element, in which case the most-dominant ei-ements of both sets are e-equivalent. \nIt follows from the above corollary that if 7 and 6 are two definitions of some member m that reach a \nnode X and that if 7 dominates 6 then we may kill 6 at this node. The reason is as follows. Let w be \nany path from node X to some node Y. Killing 6 at node X may prevent definition 6 . w from reaching node \nY. Hence, the set of reaching definitions of m at node Y will be affected. However, the above corollary \nimplies that the most-dominant reachingdefinition of m at node Y will still be the same (upto R-equivalence). \nIn other words, the result of the lookup will not be affected. Example. If a class X has its own definition \nof m, then clearly the generated definition X::m trivially dominates any other definition a::m that reaches \nX. Hence, we may kill a::m at node X. Thus, G::f oo kills ABDG::f oo and ACDG::foo in Figure 4. This \nis similar to what hap pens in the standard reaching definitions problem. However, consider node H. No \ndefinition of foo is generated at H, but we have three reaching definitions, namely GH::foo, which reaches \nH along one edge G + H, and ABDFH::foo and ACDFH::foo, which reach H along another edge F -+ H. Since \nGH dominates ABDFH and ACDFH, definitions ABDFH::foo and ACDFH::foo can be killed at node H. This kind \nof killing does not happen in the reaching-definitions prob lem, but is valid in the member-lookup algorithm. \nKilled definitions are shown crossed out in Figures 4 and 5. 0 Let us now explain how exactly our algorithm \nincor-porates killing. In the naive algorithm, as described ear-lier, the second phase (identifying the \nmost-dominant element among all reaching definitions for every node) was performed after the first phase \n(propagation of all definitions). For purposes of killing, it is convenient to interleave the two phases. \nIn particular, once the set of reaching definitions of a node X has been determined, we scan this set \nto check if it has a most-dominant el-ement. Any definition found to be dominated by some other definition \nduring this scan will be killed immedi- ately. All other definitions will be propagated out of the node \nX. In particular, for a node X for which the lookup is well-defined (i.e., unambiguous), the set of reaching \nde-finitions has a most-dominant element and we need to propagate only this definition along the outgoing \nedges of X. Let us call the definitions so propagated red defin-itions. For a class X for which the lookup \nis ambiguous, one or more definitions may be propagated along the outgoing edges of X. Let us call the \ndefinitions so prop agated blue definitions. More formally: Definition 12 A definition a! of m is said \nto be a red definition of m iff for every prefix 7 of cx such that 7 # (Y, 7 is a most-dominant element \nof DefnsPath(mdc(7),m). A question may possibly arise in the mind of the reader at this point. Why do \nwe need to propagate the blue definitions at all? Could we not use Lemma 3 to justify killing all the \nblue definitions as below? Let cy be any definition that reaches a node X for which the lookup is ambiguous. \nThen, there exists some other de-finition /3 that reaches X such that a does not dominate ,f3. Assume \nwe propagate o along some path w from X to some other class Y, giving us the definition (Y s w. Note \nthat a . w cannot be the most-dominant reach-ing definition of m at Y because it does not dominate pow \n(from Lemma 3). In other words, the result of the lookup at Y cannot be a . w. So, why can t we simply \nkill definition (Y at node X? Unfortunately, the above argument is not complete. The above argument does \npoint out correctly that a blue reaching definition cannot be the most-dominant reach-ing definition. \nHowever, a blue reaching definition may determine if some red definition is the most-dominant reaching \ndefinition or not. The example in Figure 5 illustrates this. lookup(F,bar) is ambiguous, with two reaching \ndefinitions EF and DF. Here, lookup(H,bar) is also ambiguous because GH::bar does not dominate EFH::bar. \nIf blue EF is not propagated from F to H, however, it might appear as though lookup(H,bar) was unambiguous. \n(In the case of member foo, as shown in Figure 4, the lookup at node F is ambiguous, but the lookup at \nthe subsequent node H is not ambiguous.) This is the reason for propagating blue definitions. One advantage \nof killing definitions is immediately obvious: the propagation phase itself has to do less work, and \nthe set of reaching definitions at many nodes may end up being smaller, speeding up the second phase \ntoo. Killing definitions has another significant advan-tage which will become clear later: it allows \nfor an effi-cient domination check among reaching definitions.   Identifying the Most Dominant Definition \nIt is fairly straightforward to identify the most-dominant definition, if one exists, of the set of reaching \ndefinitions. It is similar to selecting the maximum element from a list of integers, with minor modifications \nto handle the fact that dominance is only a partial order and not a total order. The only non-trivial \noperation is that of checking for domination between two paths. We ex-plain how this can be done below. \nAs we saw earlier, the reaching definitions are of two kinds, the red definitions and the blue definitions. \nWe observed earlier that a blue definition is guaranteed not to be the most-dominant element. This implies \nthat we may select the most-dominant definition among the red reaching definitions, if one exists, and \nsimply verify that it dominates all the blue reaching definitions. In particular, this implies that we \nwill not have to test for domination between two blue reaching defi-nitions. Thus, we will need to check \nfor dominance among two reaching definitions QL and p only if a and p reach the node under consideration \nalong different edges (since if multiple definitions are propagated along a sin- gle edge, they will \nall be blue definitions). This is in- teresting because it allows us to implement the test for domination \nefficiently, as explained below. Definition 13 A patha is said to be a vi&#38;al path (v-path) if it \ncontains at least one virtual edge. Let R be some new symbol not in the set of classes N. Let Nn denote \nthe union N U { R }. We define a function least VirtuaI that maps paths in the CHG to Nn as follows. \nDefinition 14 least Virtual(p) = mdc(fized(P)) if p is a v-path =Sa if p is not a v-path Lemma 4 Let \nX and Y be two different direct base classes of 2. Further, let CY . (X -+ Z), ,B . (Y + Z) E DefnsPuth(Z,m). \nIf a . (X + Z) is a red definition, then a . (X + Z) dominate3 /3 . (Y + Z) if either (i) least Virtuaqfl) \nis a virtual base of Zdc(a) OT (ii) leastVirtual(j3) = leastVi iTtuaZ(cY) # Cl.  Proof. Let a denote \na . (X + Z) and let fl denote p . (3) We are given that a dominates p . Hence, (Y is a suffix of some \n7 0 cu x p . Let 7 denote fized(P ) = fized(7 . cr ). There are two cases to consider. Consider the case \nthat 7 is a proper prefix of 7. Then, clearly, leastVirtual ( = mdc(7 )) must be a virtual base of Zdc(a \n). Consider the case that 7 is a prefix of 7'.Clearly, in this case least Virtual(/? ) = mdc(7 ) = least \nVirtuuZ(cr ) # f-l. (+) Assume that leastVirtuul(/3) is a virtual base of I&#38;(a). In other words, \nthere exists a path 7 from leastVirtaaQ3) to Z&#38;(o) whose first edge is a virtual edge. Then, let \n6 denote the path fized(P) 7 a . Clearly, a hides 6 and 6 a p . Hence, a dominates p . Now assume that \nleast VirtuuZ@) = least VirtuuI(cu) # R. Clearly, fized(P) and fized(a) are both elements of DefnsPat \nh( least Virtuar(p), m). The definition of a red definition implies that jzed(a) dominates (in fact, \nhides) fized(/3). It follows that (Y dominates p . 0 Abstracting Paths We are now ready to present our \nalgorithm in detail. It follows from Lemma 4 that we do not really need full information about paths \nto determine if one path dom-inates another path. Hence, our algorithm propagates not paths but abstractions \nof paths. Let us first consider blue definitions. As explained earlier, the only operation we perform \non a blue de-finition is to check if it is dominated by some other red definition. It follows from Lemma \n4 that for any blue definition p it would be sufficient to propagate least Virtual@). Let us be more \nprecise about what it means to prop agate least Virtual(p). When a definition p is propa-gated through \nan edge B + D it creates the definition Po(B + 0). Hence, when we propagate the abstraction least Virtuul(/3) \nthrough the edge B + D we need to cre-ate the abstraction leastVirtua@ . (B + D)). We now define an operation \no that abstracts the path concate-nation operator , which allows us to do . this. Definition 15 Xo(B+D) \n= if (X # a) then X else if B --) D E E,, then B else Q Note that, least VirtuaZ(p . (B + D)) = leastVirtuul(~)o(B \n---) D). The above abstraction of blue definitions is a crit-ical step in improving the efficiency of \nthe algorithm. With this abstraction, we need to propagate only sub-sets of No (whose size can be at \nmost IN] + 1) instead of propagating subsets of Paths(G) (whose sizes can be exponential in (N I). Now \nlet us consider red definitions. With a red defl-nition we may need to check both if it dominates some \nother definition as well as if it is dominated by some other definition. In view of Lemma 4, we may abstract \na red definition a to the pair (hfc(a), ZeastVirtuaqa)). Further, when such a pair (L, V) is propagated \nthrough an edge B + D, we simply transform it into (L, V o (B + D)). A red definition ~1 = (Lr, VI) dominates \nanother red definition rs = (La, V2) iff ~1 and rg satisfy the condition in Lemma 4, i.e., iff either \nV2 is a virtual base of L1 or VI = V2 # R. Though our algorithm does not require full path in-formation, \nit may be convenient to return full path in-formation for a successful member lookup, since compil-ers \nmay need the full path information to generate code for the lookup. If this is desired, we may abstract \na red definition cy to the triple (k(a), least Vdrtuaqa), a). (The first two components are still desirable \nto enable a quick dominance test.) This can be done without af-fecting the complexity of the algorithm \n(since at most one red definition is propagated across an edge). Example. For our example, Figures 6 \nand 7 illustrate the propagation of path abstractions for definitions of foo and bar respectively in \nthe CHG. At each node, the left hand side of + represents the path abstrac-tions that reach the node \nand the right hand side of + corresponds to the abstraction produced at the node by our algorithm, as \nexplained above. For example, con-sider node D in Figure 6. The node has two reaching red definitions, \nboth of which have the identical ab-straction (A$). Since (A$) does not dominate (A$), the lookup is \nambiguous at D. Hence, the red defin-itions become blue definitions for purposes of further propagation. \nConsequently, they are abstracted into the singleton $2, which is further transformed into D by propagation \nalong D + F (using the o operation). 0 5 The Algorithm and Its Complexity A complete description of \nour algorithm appears in Figure 8. It is based on a traversal of the CHG in topological sort order: if \nB is a base class of D then B will be visited and processed before D.For every class C and every relevant \nmember m, our algorithm computes the value of lookup[C,m], which is either Red D, where D E N x NQ or \nBlue S, where S C Na. The value Blue S implies that the corresponding lookup was ambiguous (with S being \nan abstraction of the set of definitions that created the ambiguity), (A, R ) => red (A, R ) (A, Q ) \n=> red (A, R ) >a=, (C, R ) => red (G, Q) >a= , ( G, n ) => red ( G, R ) Figure 6: Propagation of definitions \nof f oo bar 4  (E,il) => red (E,R) E Cl .x , (G,il, =sbluc[Q/ Figure 7: Propagation of definitions \nof bar while the value Red D implies that the corresponding If the above preprocessing has been done, \nwhat is lookup was unambiguous (with D being the abstraction the worst-case complexity of a single lookup \noperation? (l&#38;(a), least Virtuuqa)) of the definition a to which the Let us first consider the simpler, \nand hopefully com-lookup resolved). mon, case where the result of every possible lookup op Note that \nthe algorithm, as described, eagerly tabu-eration is unambiguous. In this case, lines [30]-[32] are lates \nthe lookup operation: it constructs a table lookup never executed. At most one definition reaches a node \nindexed by a class and a member name; once the table through each incoming edge, and the lookup at a \npar-has been constructed, every lookup operation takes con-ticular class can be done in time proportional \nto the stant time. It is easy enough to modify the algorithm number of incoming edges it has. The whole \nlookup is, into a memoising lazy algorithm that does not com-hence, linear in the size of the class hierarchy \ngraph, pute table entries that are unnecessary: a request for i.e. O(]ZV] + IEI), where INI is the number \nof nodes in Iookzlp[C,m] will recursively invoke looieup[B,m] for every the CHG and IEl is the number \nof edges in the CHG. direct base class B of C if necessary; as long as the al-(This assumes that the \nmembership test of line [12] can gorithm caches or memoizes the results of every lookup be done in constant \ntime. If not, the cost of O(]N]) performed, this will not worsen the complexity of the membership tests \nwill have to be added to the com-algorithm. plexity.) Let us now understand the complexity of the al-In \nthe general case, however, the worst-case com-gorithm. Assume that the test for whether a class is plexity \nof a single lookup can be O((]N] + IEI) x INI). a virtual-base of another class can be implemented in \nThis is because O( INI) blue definitions can reach a class constant time. (Note that to implement the \ntest for though each incoming edge. Hence, the cost of perform- whether a class is a virtual-base of \nanother class in con-ing the unions in lines [30]-[32] can be @(IN]) for every stant time, we can construct \na boolean matrix using a edge in the graph. transitive closure -like algorithm. A straight-forward The \nworst-case complexity of doing all possible lookups implementation of this will take time O(]iVj x (INI \n+ for a single member name is the same as that of doing IEI)), Note th a t a compiler requires this information, \na single lookup. If ]M] denotes the number of member in some form, and will have to compute it any way.) \nnames in the program, then the worst-case complexity function dominates ( (Ll,Vl), (L2,V2) ) { return \n(V2 E virtual-buses[Ll]) or (Vl = V2 # Q); . procedure doLookup() {;lt; for each class C in topological \nsort order { // Identify list of members for C ;Fj Members[C] := M[C]; for every direct base class X \nof C ti; Members[C] := Members[C] Members[X];PO1 // Identify dominating definition U for each member \nof C for every m E Members[C] ( Pll  if (m E M[C]) then WI lookup[C!,m] := Red (C,fi) P31  else \n{ ;;;! toBeDominated := 0; nocandidate := true; for every direct base class X of C { WI if (m E Members[X]) \nthen { 1171 case looAup[X,m] of WI Red (L,B) + V:= Bo(X -C); if nocandidate then { nocandidate := \nfalse; (candidateL, canditatev) := (L,V); } else if dominates((L,V), (candidateL, canditatev)) then { \n(candidateL, canditatev) := (L,V); } else if ( not dominates ((candidateL, canditatev), (L,V)) then toBeDominated \n:= toBeDominated U {canditatev, V} ; nocandidate := true; 1  ;i; Blue (S) =k- for every B E S [311 toBeDominated \n:= toBeDominated U { B o (X -+ C) }; [ii; I 1341 1 if (nocandidate) then  [351 lookup[C,m]:= Blue (toBeDominated) \ntit; else ( for every B E toBeDominated { / if ( (B E viriuuGbuses[candidateL]) or (B = candidatev # \nQ)) then remove B from toBeDominated [401 I411 1 if (toBeDominated = 8) 1421 then Zookup[C,m] :A Red \n(candidateL, candidatev) [431 else Zookup[C,m] := Blue (toBeDominated {candidatev}) 1441 U 1451 t:;; \n / Figure 8: The Member Lookup Algorithm of constructing the whole lookup table, as described in Figure \n8 is O(]M] x (INI + ]E[) x ]Nl) in the general case, and O((]M] + INI) x (IN] + ID])) in the (possibly \ncommon) case of a program in which every table entry is unambiguous. Other Issues The C++ rules for \nmember lookup, in reality, are slightly more complicated than what we have presented so far. In particular, \nmembers of a class may be classified into static3 and non-static members. While our earlier pre-sentation \nis valid in the absence of static members, it must be modified as below to handle static members. Definition \n16 If A is a set of equiudence classes of paths, we define mazimaZ(A) as follows: ma&#38;&#38;(A) = {u \nE A ] ,&#38; E A. (o # u and u dominates u)} Definition 17 We define lookup(C, m) to be mazimul(Defns(C, \nm)), if 1. ImazimayDefns(C,m))l = 1, OT 2. VU~,U~E muzimuZ(Defns(C, m))  (u) lac(ul) = id+), ad (b) \nm is a static member of Idc(ul). lookup(C, m) is dt$ned to be I otherwise. Observe that if condition \n(ii) holds true in the above definition, then the lookup can return a set with more than one element. \nIn terms of an implementation, how-ever, it is sufficient if some representative element of this set \nis returned. It is fairly straightforward to extend our algorithm to deal with static members. We modify \nthe function dominates defined in lines [l]-[3] of Figure 8 to take the member name m as an extra argument. \nThe function returns true iff (1) IT.2 E virtual-bases[ll] or (2) Vl = V2 # n or (3) (Ll = L2) and m \nis a static member of Ll. There are a couple of other features of C++ related to member lookup that we \nbriefly discuss below. One of these features is that of access rights. The access rights rules of C++ \nspecify which members of a base class may be accessed in the scope of the de-rived class. The access \nrights do not afiect the member lookup process in any way; they are applied only after It is also possible \nto introduce new type names and enumeration constants into the scope of a class. For purposes of member \nlookup, these are treated exactly like static members. a successful member lookup to determine if that \npar-ticular member access is legal. We show in [8] how our lookup algorithm can be extended in a straightforward \nway to compute access rights. Another related issue is the resolution of unqualified names. The problem \ndiscussed in this paper concerns the resolution of qualified names, such as the name m in the expressions \nx .m or X : :m. However, names may also occur unqualified in a C++ program. For example, the names a \nand b in the expression a+b, are unqualified names. The resolution of an unqualified name in C++ is essentially \nthe same as the traditional name lookup process in the presence of nested scopes. The only com-plication \nis that any of these nested scopes may itself be a class, and the local lookup within a class scope itself \nreduces to the member lookup problem addressed in this paper. More details about this appear in [8]. \n 7 Related Work 7.1 Member Lookup in C++ The work most closely related to our work is that of Rossie \nand Friedman [9], who present a formalism that models the multiple inheritance mechanism of C++. They \nshow how, given a class hierarchy 7, one may define a subobject poset (C(7), sdO). Let us denote the \nclass hierarchy graph of a class hierarchy 7 by CHG(7). We can show that: Theorem 1 The poset (\\E(CHG(y)), \ndominates) is iso- morphic to the poset (C(y), $,,). Thus, our *equivalence classes directly correspond \nto the subobjects defined by Rossie and Friedman. Rossie and Friedman utilize their subobject poset to \ndefine two member lookup operations, dyn and stat, that essentially model the lookups performed for virtual \nand non-virtual members respectively. However, these lookup operations, for a given member m, are defined \nas partial functions that map subobjects to subobjects. Recall that the lookup operation defined in this \npaper, for a given member m, maps a class to a subobject. The Rossie-Friedman lookup can be defined in \nterms of our lookup operation as below*: dyn(m,u) = lookup(mdc(u), m) stat(m,u) = (lookup(ldc(u),m)) \n0 u The Ron&#38;-Hedman operations correspond to a C++ implemen-tation where member lookup is done completely \nat run-time. There equations show how the lookup can be staged such that most of the work is done at \ncompile time, with the run-time operation being a constant-time operation (as is done in typical C++ \nimplementations). Our lookup operation model8 the part of member lookup that is typ ically performed \nstatically by a compiler. where the subobject composition operator . is defined by: [aI . lo1= b . PI \nTip et al. [12] address a different problem, that of class hierarchy slicing, but their work is based \non the Rossie and Friedman formalism. They present a slightly altered version of the Rossie and Friedman \nmember lookup definition, but one that is still based on the sub-object graph. The definitions presented \nby both Rossie and Fried-man and Tip et al. are executable definitions, providing us with member lookup \nalgorithms. However, direct im-plementations of these definitions can be inefficient, as we will discuss \nshortly. As an example of how current C++ compilers imple-ment member lookup, we studied5 the implementation \nin GNU s g++ compiler (version 2.7.2.1), whose source code is publicly available. The lookup algorithm \nin g++ is based on a breadth- first traversal of the subobject graph. In particular, the lookup for a \nmember m in a class X begins at the node in the subobject graph corresponding to an object of class X. \nIf class X itself does not have a member called m, the algorithm performs a scan of all the subobjects \nof an X object, in breadth-first order, and attempts to identify the most-dominant definition of m. Thus, \nthe g++ implementation is more or less a direct implemen-tation of the Rossie and Friedman definition \n(though it predates the Rossie and Friedman formalism), with the exception that the g++ implementation \nof select- ing the most-dominant definition is incorrect. The g++ algorithm keeps track of the most-dominant \nmember found by the traversal. When the traversal visits a sub- object, it checks to see if that subobject \nhas a member called m. If it does, it checks to see if either the most-dominant member found so far or \nthe newly found mem-ber dominates the other. If one of the two dominates the other, it keeps that definition \naround as the most-dominant one. If neither definition dominatesthe other one, the algorithm Teports \nambiguity and quits. It is the step described last, where ambiguity is re-ported if neither definition \ndominates the other one, that is incorrect. It is possible, when using a breadth-first search, to encounter \ndefinitions dl and dz, neither of which dominates the other, and to then later en-counter a definition \nda which dominates both dr and d2. This happens in the example presented in Figure 7.1. Though the lookup \nin line [s2] is unambiguous, the g++ compiler flags it as being ambiguou8. Let us briefly discuss the \ncomplexity of the algo-rithms described above. In the worst case, the sub- Thanks to Mike Stump, cc-author \nof g++, for confirming our understanding of the g++ implementation. 61n fact, 3 of the 7 compilers we \ntried this example on reported this lookup as being ambiguous. struct S ( int m; }; struct A: virtual \nS { int m; }; struct B: virtual S { int m; };  struct C: virtual A, virtual B { int m; }; struct D: \nC {}; struct E: virtual A, virtual B, D {}; main0 { sl: E e; s2: 9.m = 10; Figure 9: A counterexample \nfor the g++ algorithm. object graph s size can be exponential in the size of the class hierarchy graph \nand, hence, all the algorithms mentioned above have a worst-case complexity that is exponential in the \nsize of the class hierarchy graph, while the complexity of our algorithm ranges from lin-ear to quadratic \nin the size of the class hierarchy graph. (For the kind of class hierarchies that arise in practice, \nhowever, this kind of exponential blowup in the size of the subobject graph does not seem to occur. Hence, \nin practice, we do not expect our algorithm to ezponen-tiully outperform the algorithms described above. \nBut we do expect that our algorithm will perform as well or better than these algorithms. Since the time \nspent on member lookups in a compiler can be as much as 15% of the total compilation time [ll], faster \nlookups could be of relevance to a compiler.) An informal discussion of subobject graphs and mul-tiple \ninheritance in C++ appears in [5] and [lo], but nei-ther provides a formal model for multiple inheritance \nor an algorithm for member lookup. 7.2 Member Lookup in Other Languages Though there exist other languages \nthat support mul-tiple inheritance, we are not aware of other languages that have concepts such as dominance \nor two different kinds of inheritance (namely, virtual and non-virtual). Hence, member lookup in C++ \nappears to be quite dis-tinct from member lookup in other languages. SeZf [2] is an example of another \nlanguage that sup-ports multiple inheritance. Member lookup and ambi-guity checking in Self, however, \nare conceptually much simpler than in C++. Self does not have the concept of classes. Instead, objects \ndirectly inherit from other objects. A member name m is unambiguous in a given object iff exactly one \ndefinition of m is visibIe in that ob-ject. (A member m in a base object is said to be visible in a \nderived object iff there exists an inheritance path References between the two objects that does not \ncontain any other object with a member called m.) Member lookup in Self is done completely at run-time, \nand, hence, the speed of the lookup greatly affects the performance of Self pro-grams. Hence, several \ntechniques have been developed to optimize the lookup at run-time [7, 61. These tech-niques, however, \nare not directly relevant to compile-time member lookup. Attali et al. [4] p resent a semantics and algorithm \nfor lookup in Eiffel, another language with multiple in-heritance. Member lookup in Eiffel is complicated \nby the presence of a feature called renaming, that allows a derived class to rename an inherited member. \nThe Attali et al. algorithm, however, assumes that the input program is statically well typed . In particu- \nlar, they assume that none of the lookups in the source program is ambiguous. It is worth pointing out \nhere that much of the complexity of member lookup in CSS is in identifying ambiguous lookups. If one \nassumes that a particular lookup is unambiguous, then the lookup can be done very simply as follows. \nAssociate each class X with a topological number, top-sort(X), such that the topological number of a \nbase class is less than the topological number of a derived class. (Since a com- piler sees a base class \ndefinition before it sees a derived class definition, this numbering can be done trivially.) Then, from \nthe set of definitions that reach a class X, one simply selects the Q for which top-soti(Zdc(u)) is maximum \nas the most dominant definition.  8 Conclusions We believe that C++ has a fairly complicated seman-tics, \nthanks to the presence of a large number of fea- tures, not necessarily all orthogonal. This complexity \nwarrants taking a reasonably formal approach towards building C++ implementations. The main contribution \nof this paper is an algorithm for member lookup in C++. A secondary contribution of this paper is a reformulation \nof the Rossie-Friedman multiple inheritance formalism, which may be of use as a formal basis for deriving \nefficient implementations of a C++ compiler. The formalism, however, addresses only certain aspects of \nC++. A similar formal treatment of other aspects of C++ implementation would be worth pursuing. Acknowledgements \nBurke, Ron Cytron, Frank erees for their comments the paper. We thank John Field, Michael Tip, and the \nanonymous ref-which greatly helped improve I. P. S. Accredited Standards Committee X3. PI Working paper \nfor draft proposed international standard for information systems-programming language C++. Draft of \n26 September 1995. 0. Agesen, L. Bak, C. Chambers, B. W. Chang, PI U. Hiilzle, J. Maloney, R. B. Smith, \nD. Ungar, and M. Wolczko. The Self 4.0 Programmer s Reference Manual. Sun Microsystems, Inc. A.V. Aho, \nR. Sethi, and J.D. Ullman. Compilers. Principles, Techniques and Tools. Addison-Wesley, 1986. [31 I. \nAttali, D. Caromel, and S. 0. Ehmety. A Nat- PI ural Semantics for Eiffel Dynamic Binding. ACM IPrans. \non Programming Languages and Systems, 18(6):711-720, 1996. M. A. Ellis and B. Stroustrup. The Annotated \nC++ Fl Reference Manual. Addison-Wesley, 1990. U. Hclzle, C. Chambers, and D. Ungar. Optimizing PI dynamically-typed \nobject-oriented languages with polymorphic inline caches. In PTOC. of the European Conf. on Object-Oriented \nProgramming, July 1991. U. HGlzle, C. Chambers, and D. Ungar. Opti-mizing dynamically-dispatched calls \nwith run-time type feedback. In Proc. of the SIGPLAN 94 Conf. on Programming Language Design and Implemen-tation, \npages 326-336, June 1994. [71 G. Ramalingam and H. Srinivasan. A Member PI Lookup Algorithm for C++. \nTechnical report, IBM, 1997. In Preparation. J. G. Rossie and D. P. Friedman. An Algebraic Se- PI mantics \nof Subobjects. In Proc. of Conf. on Object-Oriented Programming Systems, Languages, and Applications, \npages 187-199, October 1995. M. Sakkinen. A critique of the inheritance prin- PO1 ciples of C++. Computing \nSystems, 5(1):69-110, 1992. B. Stroustrup, 1996. Personal Communication. WI F. Tip, J. D. Choi, J. Field, \nand G. Ramalingam. PI Slicing Class Hierarchies in C++. In Proc. of Conf. on Object-Oriented Programming \nSystems, Languages, and Applications, pages 179-197, Oc-tober 1996. \n\t\t\t", "proc_id": "258915", "abstract": "The member lookup problem in C++ is the problem of resolving a specified member name in the context of a specified class. Member lookup in C++ is complicated by the presence of virtual inheritance and multiple inheritance. In this paper, we present an efficient algorithm for member lookup in C++. We also present a formalism for the multiple inheritance mechanism of C++, which we use as the basis for deriving our algorithm. The formalism may also be of use as a formal basis for deriving other C++ compiler algorithms.", "authors": [{"name": "G. Ramalingam", "author_profile_id": "81100519054", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP31045870", "email_address": "", "orcid_id": ""}, {"name": "Harini Srinivasan", "author_profile_id": "81100406633", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP43132945", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258919", "year": "1997", "article_id": "258919", "conference": "PLDI", "title": "A member lookup algorithm for C++", "url": "http://dl.acm.org/citation.cfm?id=258919"}