{"article_publication_date": "05-01-1997", "fulltext": "\n Flick: A Flexible, Optimizing IDL Compiler Eric Eide Kevin Frei Bryan Ford Jay Lepreau Gary Lindstrom \nUniversity of Utah, Department of Computer Science 3190M.E.B., Salt Luke City, Utah 84112 flickQcs.utah.edu \nhttp://nnr.cs.utah.edu/projects/flux/flick/ Abstract An interface definition language (IDL) is a nontraditional \nlanguage for describing interfaces between software compo- nents. IDL compilers generate stubs that provide \nseparate communicating processes with the abstraction of local ob- ject invocation or procedure call. \nHigh-quality stub gener- ation is essential for applications to benefit from component- based designs, \nwhether the components reside on a single computer or on multiple networked hosts. Typical IDL com-pilers, \nhowever, do little code optimization, incorrectly as-suming that interprocess communication is always \nthe pri- mary bottleneck. More generally, typical IDL compilers are rigid and limited to supporting only \na single IDL, a fixed mapping onto a target language, and a narrow range of data encodings and transport \nmechanisms. Flick, our new IDL compiler, is based on the insight that IDLS are true languages amenable \nto modern compilation techniques. Flick exploits concepts from traditional pro- gramming language compilers \nto bring both flexibility and optimization to the domain of IDL compilation. Through the use of carefully \nchosen intermediate representations, Flick supports multiple IDLs, diverse data encodings, multiple transport \nmechanisms, and applies numerous optimizations to all of the code it generates. Our experiments show \nthat Flick-generated stubs marshal data between 2 and 17 times faster than stubs produced by traditional \nIDL compilers, and on today s generic operating systems, increase end-to-end throughput by factors between \n1.2 and 3.7. This research was supported in part by the Defense Advanced Research Projects Agency, monitored \nby the Department of the Army under contract number DABT63-94-C-0058, and Rome Laboratory, Air Force \nMaterial Command, USAF, under agreement number F30602-9G2-0269. The U.S. Government is authorized to \nreproduce and distribute reprints for Govem- mental purposes notwithstanding any copyright annotation \nhereon. Permission to make digital/hard copy of part or all this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advan- \ntage, the copyright notice, the title of the publication and its date appear, and notice is given that \ncopying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists. requires prior specific permission and/or a fee. PLDI 97 Las Vegas, NV, USA 6 1997 ACM 0-89791-907-8/971OCKJ6...$3.50 \n  1 Introduction h interface definition funguage (IDL) is a speciakpurpose language for describing \nthe interfaces of a software compo- nent. An IDL specification declares one or more interfaces; each \ninterface declares a set of operations that may be in- voked on objects implementing the interface. The \ninput and output behavior of each operation is given by the IDL specifi-cation. For example, the following \nCORBA [ 181IDL program declares a simple interface to an electronic mail service: interface Mail ( void \nsend(in string msg); 1; A largely equivalent mail system interface would be defined in the ONC RPC [23] \nIDL by this program: program Mail C version MailVers ( void send(string) = 1; 1 = 1; 1 = 0x20000001; \nAs shown by these examples, an IDL program declares a set of functions or methods but does not describe \nthe computa- tions that those functions and methods perform. IDLs are typ-ically independent of the programming \nlanguage in which the components are themselves implemented, further decoupling interface from implementation. \nAn IDL compiler accepts an IDL interface specification and outputs an implementation of that specification. \n+Qpi-tally, the implementation is a set of data type declarations and stubs written in a conventional \nprogramming language such as C, C++, or Java. The stubs encapsulate the commu- nication that must occur \nbetween the entity that invokes an operation (i.e., the client) and the entity that implements the operation \n(i.e., the server). The stubs that are output by the ONC RPC wa!s previously known as Sun RPC, and Sun \ns rpcgen is the standard Compiler for the ONC RPC IDL. The WIIbeI S in the eXampie ONC RPC IDL program \nan? chosen by the programmer to identify compo-nents of the interface. IDL compiler hide the details \nof communication and allow the client and server to interact through a procedural inter- face. Traditionally, \nstubs have implemented remote proce-dure culls (RPC) [3] or remote method invocations (RMI): the client \nand server are located in separate processes, and the stubs in each process communicate by exchanging \nmessages through a transport medium such as TCP/IP. More recently, IDLS have become popular for defining \nhigh-level interfaces between program modules within a single process. IDLs and IDL compilers arose for \nreasons familiar to any programming language veteran: descriptive clarity, pro- grammer productivity, \nassurance of consistency, and ease of maintenance. Performance of IDL-generated code, however, has traditionally \nnot been a priority. Until recently, poor or mediocreperformanceof II%generatedcode wasacceptable in \nmost applications: because interprocess communication was generally both expensive and rare, it was not \nuseful for an IDLcompiler to produce fast code. For performance criti- cal applications, implementors \nresorted to hand-coded stubs -tolerating the accompanying greater software engineering costs. Some IDL \ncompilers such as MIG [20] struck a mid- dle ground by providing a language with a restricted set of \nstructured data types, blended with programmer control over implementation details. This compromise could \nbe likened to that provided by a traditional compiler that permits em- bedded assembly language. Although \nembedded hints can lead to performance gains, reliance on hints moves the bur- den of optimization from \nthe compiler to the programmer, and has the additional effect of making the language non- portable or \nuseful only within restricted domains. Today, in almost every respect, IDL compilers lag be- hind traditional \nlanguage compilers in terms of flexibility and optimization. IDL compilers such as Sun s rpcgen [25] \nare generally written from scratch and are implemented without incorporating modem compiler technologies \nsuch as multiple, flexible intermediate representations. The result is that tOday S IDL COmpilerS are \nrigid : they accept Only a Sin-gle IDL, they implement only a single, fixed mapping from an IDLspecification \nto a target language, and they generate code for only one or two encoding and transport mechanisms. To- \nday s IDL compilers still assume that the transport medium is inherently slow, and therefore, that optimization \nof the stubs will not yield significant speed increases. Modem network architectures, however, have moved \nthe performance bottle- necks for distributed applications out of the operating system layers and into \nthe applications themselves [5,12,13]. In this paper we show that in order to solve the prob- lems inherent \nto existing IDL compilers, IDL compilation must evolve from an ad hoc process to a principled process \nincorporating techniques that are already well-established in the traditional programming language community. \nAl-though IDL compilation is a specialized domain, IDLcompil-ers can be greatly improved through the \napplication of con- cepts and technologies developed for the compilation of gen- era1 programming languages. \nFlick, our Flexible IDL Com-piler Kit, exploits this idea. Flick is designed as a toolkit of reusable \ncomponents that may be specialized for partic- ular IDLs, target language mappings, data encodings, and \ntransport mechanisms. Flick currently has front ends that parse the CORBA [18], ONC RPC [23], and MIG \n[20] IDLS. Flick compiles an interface specification in any of these lan- guages through a series of \nintermediate representations to produce CORBA-, rpcgen-, or MIG-style C stubs communi- cating via TCP, \nUDP, Mach [l] messages, or Fluke [lo] kernel IPC. Flick s compilation stages are implemented as individ- \nual components and it is easy for a system designer to mix and match components at IDL compilation time \nin order to create the high-performance communication stubs that he or she needs. Further, the organization \nof Flick makes it easy to implement new component front ends, presentation gener- ators, and back ends. \nFlick s design as a traditional language compiler pro-motes not only flexibility but also optimization. \nFlick imple- ments techniques such as code inlining, discriminator hash- ing, and careful memory management \nto maximize the speed at which data can be encoded and decoded (marshaled and untnarshaled) for communication. \nFlick s optimization tech- niques are similar to those provided by modem optimizing compilers, but its \ndomain-specific knowledge allows Flick to implement important optimizations that a general-purpose language \ncompiler cannot. Most of Flick s techniques are implemented by an abstract C++ base class for code gener- \nators, and therefore, all back ends inherit the optimizations provided by the large code base. The results \npresented in Section 4 show that Flick-generated communication stubs are up to 3.7 times faster than \nthose generated by other IDL compilers. 2 Flick The Flick IDL compiler is divided into three phases \nas illus- trated in Figure 1. These phases are analogous to those in a traditional language compiler \nand correspond to separable aspects of IDL compilation. Each phase is primarily imple- mented by a large, \nshared library of C and C++ code that pro- vides abstractions for such things as IDL source constructs, \ntarget language data types, and on the wire message data types. Each of Flick s libraries implements \na generic set of methods to manipulate these abstractions. The libraries are the bases for specializations \nthat override the generic meth- ods as necessary in order to implement behaviors peculiar or specific \nto a single IDL, language mapping, message fOrtKit, or transport facility. The first phase of the compiler \nis thefronr end. The front end reads an IDL source file and produces an abstract rep- resentation of \nthe interface defined by the IDL input. This representation, called an Abstract Object Interface (AOI), \nde- scribes the high-level network contract* between a client  =?%fY7-+$&#38; - -.- -  Figure1: Overviewof \ntheFlickIDL Compiler.Flickis dividedintothree compilationphases,andeach phaseis implementedby a largelibraryof \ncode. SpecializedcomponentsarederivedfromtheFlicklibrariesin order to parsedifferentIDLs, implementdifferenttargetlanguagemappings,and \nproducecodefora varietyof messageformatsandtransportsystems. and a server: the operations that can be \ninvoked and the data that must be communicated for each invocation. Flick s second compilation phase, \nthe presentation gen-erator, reads the network contract produced by the front end and outputs a separate \nand lower-level programmer s con-tract. The programmer s contract defines the interface be-tween the \nprogrammer s client or server code and the stubs, e.g., how parameters are passed between them. For example, \nconsider the CORBA IDL input shown in Section 1 that defines a network contract between the client and \nserver of a Mail interface. Given that input, a CORBA IDLcompiler for C will always produce the following \nproto-type describing the programmer s contract:2 void Mail-send(Mai1 obj, char *msg); This programmer \ns contract declares the C functions and data types that will connect the client or server code to the \nstub: we say that this contract is a presentation of the interface in the C language. The presentation \nshown above conforms to the CORBA specification for mapping IDLconstructs onto the C program- 2Forclarity,wehaveomittedthede&#38;&#38;ion \noftheHail objecttypeand theCDRBA-EnvironmentpammetertotheMailsend function. ming language. However, it \nis not the only possible presen-tation of the Mail interface. For instance, if we depart from the CORBAmapping \nrules, the Mail_send function could be defined to take a separate message length argument: void Mail-send(Mai1 \nobj, char *msg, int len);  This presentation of the Mail interface could enable opti- mizations because \nMailsend would no longer need to count the number of characters in the message [8,9]. This change to \nthe presentation would not affect the network contract be-tween client and server; the messages exchanged \nbetween client and server would be unchanged. The addition of a sep-arate len parameter changes only \nthe calling conventions for the Mailsend function. Flick s ability to handle different presentation \nstyles can be important for optimization as just described, but it is also essential for supporting multiple \nIDLS in a reasonable way. To summarize, a presentation describes everything that client or server code \nmust understand in order to use the func-tion and data type declarations output by an IDL compiler: this \nincludes the names of the functions, the types of their ar-guments, the conventions for allocating memory, \nand so on. Because there can be many different presentations of a sin-gle interface, Flick provides multiple, \ndifferentpresentation generators, each implementing a particular style of presenta-tion for a particular \ntarget programming language. When C is the target language, the presentation is described in an inter-mediate \nformat called PRES-C. Because the presentation of an interface may differ between client and server, \na presen-tation generator creates separate PRESX files for the client-and server-side presentations of \nan interface. The third and final phase of the compiler is the buck end. The back end reads a presentation \ndescription (PRES-C) and produces the source code for the C functions that will imple-ment client/server \ncommunication. The generated functions are specific to a particular message format, message data en-coding \nscheme, and transport facility. Table 1 compares the number of substantive C and C++ source code lines \nin each of Flick s libraries with the number of lines particular to each of Flick s specialized components. \nThe number of lines specific to each presentation generator and back end is extremely small when compared \nto the size of the library from which it is derived. Front ends have sig-nificantly greater amounts of \nspecialized code due to the need to scan and parse different IDL source languages. 2.1 Front Ends As \njust described, the purpose of a Flick front end is to trans-late an interface description (source IDLprogram) \nto an inter-mediate representation. Each of Flick s front ends is specific to a particular IDL. However, \neach is completely indepen-dent of the later stages of IDL compilation: the presentation Phase Component \nLines Front End Base Library 1797 CORBA IDL 1661 48.0% ONC RPC IDL 1494 45.4% PIE-S. Gen. Base Librarv \n6509 CORBA Lib&#38; 770 10.6% CORBA h?S. 3 0.0% Fluke Pres. 301 4.0% ONC RPC rpcgen hs. 281 4.1% Back \nEnd BaseLibrary 8179 CORBA IIOP 3.53 4.1% ONC RPC XDR 410 4.876 Mach 3 IPC 664 7.5% Fluke IPC 514 5.9% \nJ T&#38;e 1: Code Reuse within the Flick I DL Compiler. Percentages show the fraction of the code that \nis unique to a component when it is linked with the mdc for its base library. The. CORBA presentation \nlibrary is derived from the generic presentation library; the CORBA andFluke presentationgenerators a~ \nderived from the CORBA presentation library. of the interface that will be constructed, the target program- \nming languagethat will implement the presentation, the mes- sage format and data encodings that will \nbe chosen, and the transport mechanism that will be used. In sum, the output of a Flick front end is \na high-level network contract suitable for input to any presentation generator and any back end. Flick \ns MIGfront end, however, is a special case. A MIG interface definition contains constructs that are applicable \nonly to the C language and to the Mach message and IPC systems [20]. Therefore, as illustrated in Figure \n1, Flick s MIG front end is conjoined with a special MIG presenta-tion generator that understands these \nidioms. Flick s MIG components translate MIG interface descriptions directly into PRES-c representations; \nthis is different than Flick s CORBA andONC RPC front ends, which produce AOI. This difference reveals \na strength: Flick s multiple intermediate representa- tions provide the flexibility that is necessary \nfor supporting a diverse set of IDLs. 2.1.1 AOI: The Abstract Object Interface A01 is Flick s intermediate \nrepresentation language for de- scribing interfaces: the data types, operations, attributes, and exceptions \ndefined by an IDL specification. A01 is applicable to many IDLs and represents interfaces at a very high \nlevel. It describes constructs independently of their implementa- tion: for instance, A01 has separate \nnotions of object meth- ods, attributes, and exceptions, although all of these things are generally implemented \nas kinds of messages. A01 sup-ports the features of typical existing IDLs such as the CORBA and ONC RPC \nIDLs, and Flick s front ends produce similar A01 representations for equivalent constructs across different \nIDLs. This distillation process is what makes it possible for Flick to provide a large and general library \nfor the next stage of compilation, presentation generation.  2.2 Presentation Generators Presenrurion \ngenerufion is the task of deciding how an inter- face description will be mapped onto constructs of a \ntarget programming language. Each of Flick s presentation genera- tors implements a particular mapping \nof A01 constructs (e.g., operations) onto target language constructs (e.g., functions). Therefore, each \npresentation generator is specific to a par- ticular set of mapping rules and a particular target language \n(e.g., the CORBA C language mapping). A presentation generator determines the appearance and behavior \n(the programmer s contract ) of the stubs and data types that present an interface - but onfy the appearance \nand behavior that is exposed to client or server code. The unex- posed impfemen?ufion of these stubs \nis determined later by a Flick back end. Therefore, the function definitions produced by a presentation \ngenerator may be implemented on top of any available transport facility, and each presentation gen- erator \nis independent of any message encoding or transport. Moreover, each of Flick s presentation generators \n(except for the MIGgenerator as described previously) is independent of any particular IDL. A single \npresentation generator can pro- cess ~01 files that were derived from several different IDLs.~ Flick \ncurrently has two presentation generators that read A01 files: one that implements the C mapping specified \nby CORBA [ 181 and a second that implements the C mapping defined by Sun Microsystems rpcgen program \n[25]. Each of these presentation generators outputs its presentations in an intermediate representation \ncalled PRESX (presentation in C). PRES-c is a fairly complex description format con-taining three separate \nsublanguages as illustrated in Figure 2 (and described separately below): a MINT representation of the \nmessages that will be exchanged between client and server, a CAST representation of the output C language \ndec- larations, and a set of PRES descriptions that connect pieces of the CAST definitions with corresponding \npieces of the MINT structures. Of the three intermediate representations within a PRESX file, only CAST \nis specific to the C language; MINT and PRES are applicable to any programming language. We plan to create \nintermediate representation languages for C++ and Java presentations, for example, by replacing CAST \nwith intermediate representation languages for C++ and Java source code. 2.2.1 MINT: The Message Interface \nThe first step of presentation generation is to create an ab- stract description of all messages, both \nrequests and replies, 3Natudly. Ihe ability to process A01 files generated from different IDLs is somewhat \nnz&#38;ictexIdue to the limitations of Particular presentations.For example, the presentation generatorthat \nimplements the rpcgen present-a- tiOn Style Cannot accept AOI fikS that use CORBA-Style eXC+iOnS because \nthere is no concept of exceptions in standard rpcgen presentations. Simi-larly, the CORBA presentation \ngenerator cannot handle self-referential type definitionsthat may occur in an A01 file produced from \nan ONC RPC IDL input because CORBA does not support self-referential types. the type but does not specify \nany encoding or target language Example 1 Example 2 details. QI s2 ml 'int x' char str* I Ey .f I .* \ni int 4 E z! :* AC3 El !z E 1_________--. e.mm;..----------, 4 ______-- ;-;----- : .b M ;j =Y g* Figure.2: \n'Avo Examplesof PRESL. PRESI: istheintemIediaterepn%enta-tionthatconnects Ctargetlanguagedatawith onthewire\"dataencodings. \nThe first example links aC language int with a 4-byte, big endian encoding. The second example associates \na C string (char *) with a counted array of packedcharacters. that may be exchanged between client and \nserver as part of an interface. These messages are represented in a type de- scription language called \nMINT. A MINT representation of a data type is a directed graph (potentially cyclic) with each node representing \nan atomic type (e.g., an integer), an aggre- gate type (e.g., a fixed- or variable-length array, structure, \nor discriminated union), or a typed literal constant. MINT types do not represent types in the target \nprogram- ming language, nor do they represent types that may be en- coded within messages. Rather, MINT \ntypes represent high- level message formats, describing all aspects of an on the wire message except \nfor low-level encoding details. MINT types serve as glue between transport encoding types and tar- get \nlanguage types as illustrated in Figure 2. The first exam- ple in Figure 2 utilizes a MINT integer type \nthat is defined to represent signed values within a 32-bit range. The MINT in-teger type does not specify \nany particular encoding of these values, however. Target language issues are specified by the representation \nlevels above MINT in the figure; on the wire data encodings are specified by the representation level \nbe- low MINT. The second example in Figure 2 illustrates a MINT array type containing both a length and \na vector of charac- ters. Again, MINT specifies the ranges of the values within  2.2.2 CAST: The C Abstract \nSyntax Tree The second portion of a PRES-c file is a description of the C language data types and stubs \nthat present the interface. These constructs are described in a language called CAST, which is a straightforward, \nsyntax-derived representation for C language declarations and statements. By keeping an ex- plicit representation \nof target language constructs, Flick can make associations between CAST nodes and MINT nodes de- scribed \npreviously. Explicit representation of target language constructs is critical to flexibility; this is \nthe mechanism that allows different presentation generators and back ends to make fine-grain specializations \nto the base compiler libraries. Similarly, explicit representation is critical to optimization because \nFlick s back ends must have complete associations between target language data and on the wire data in \norder to produce efficient marshaling and unmarshaling code. Although Flick s explicit representation \nfor C language constructs is ordinary in comparison to the intermediate rep- resentations used by traditional \nlanguage compilers, it is unique in comparison to traditional IDL compilers because most IDL compilers \nincluding rpcgen and ILU [ 151 maintain no explicit representations of the code that they produce.  \n2.2.3 PRES: The Message Presentation PRES, the third and final component of PRESS defines the mapping \nbetween the message formats defined in MINT and the target language-specific, application-level formats \nde- fined in CAST. Like MINT and CAST, PRES is a graph-based description language. A node in a PRES tree \ndescribes a re- lationship between a MINT node and a CAST node: the data described by the MINT and CAST \nnodes are connected and marshaling and unmarshaling of data will take place as de- termined by the connecting \nPRES node. In language terms, a PRES node defines a type conversion between a MINT type and a target \nlanguage type. Different PRES node types describe different styles of data presentation as illustrated \nin Figure 2. In the first ex- ample, a MINT integer is associated with a C language inte- ger through \na direct mapping: no special data transformation is specified. In the second example, a MINT variable-length \narray is associated with a C pointer. The PRES node is an OPTSTR node and specifies that a particular \nkind of trans- formation must occur for both data marshaling and unmar- shaling. Consider the unmarshaling \ncase. The OPT-PTR node defines that when the MINT array size is non-zero, the array elements will be \nunmarshaled and the C pointer will be set to point at the decoded array elements -in this example, char- \nacters. If the MINT array size is zero, the C pointer will be set to null. Reverse transformations occur \nwhen the C pointer data must be marshaled into a message. Other PRES node types define similar kinds \nof presenta- tion styles, and the set of PRES node types is designed to cover all of the transformations \nrequired by existing presen- tation schemes. PRES is not specific to any one program- ming language, \nalthough certain node types depend on cer- tain language features. For instance, OPTSTR nodes only make \nsense for target languages that have pointers. 2.2.4 PRESX: The C Presentation PRESX combines the intermediate \nrepresentations described above to create a complete description language for C lan- guage interface \npresentations. A PRES-c file contains the ar- ray of stub declarations that will present the interface \n(to the client or server, not both). Each stub is associated with its declaration in CAST, the MINT description \nof the messages it receives, the MINT description of the messages it sends, and two PRES trees that associate \npieces of the two MINT trees with the function s CAST declaration. In total, a PRESX file is a complete \ndescription of the presentation of an interface -it describes everything that a client or server must \nknow in order to invoke or implement the operations provided by the interface. The only aspect of object \ninvocation not described by PRES-c is the transport protocol (message format, data encoding, and communica- \ntion mechanism) that will be used to transfer data between the client and the server. This final aspect \nof IDL compila-tion is the domain of Flick s back ends.  2.3 Back Ends A Flick back end inputs a description \nof a presentation and outputs code to implement that presentation in a particular programming language. \nFor presentations in C, the input to the back end is a PRES-c file and the output is a . c file and a \ncorresponding . h file. The output C code implements the interface presentation for either the client \nor the server. Be- cause the output of a presentation generator completely de- scribes the appearance \nand exposed behavior of the stubs that implement an interface, Flick s back ends are entirely inde- pendent \nof the IDL and presentation rules that were employed to create a presentation. Each back end is, however, \nspecific to a single program- ming language, a particular message encoding format, and a particular transport \nprotocol. All of the currently imple- mented back ends are specific to C, but Flick s kit architec- ture \nwill support back ends specific to other languages such as C++ or Java in the future. Each of Flick s \nC back ends supports a different communication subsystem: the first im- pkIIN3tS the CORBA IIOP(intemetInter-ORB \nhXOCOl)[ 181 on top of TCP; the second sends ONC RPC messages [23, 241 over TCP or UDP; the third supports \nMIG-Style typed messages sent between Mach 3 ports; and the fourth imple- ments a special message format \nfor the fast Fluke kernel IPC facility [ 101. Although these four communication subsys-tems are all very \ndifferent, Flick s back ends share a large li- brary of code to optimize the marshaling and unmarshaling \nof data. This library operates on the MINT representations of the messages. Whereas a presentation generator \ncreates associa- tions between MINT types and target language types (through PRES), a back end creates \nassociations between MINT types and on the wire encoding types. The mapping from mes- sage data to target \nlanguage is therefore a chain: from en- coded type to MINT node, from MINT node to PRES node, and from \nPRES node to CAST. Flick s library for C back ends operates on these chains and performs optimizations \nthat are common to all transport and encoding systems. 3 Optimization Flick s back ends apply numerous \ndomain-specific optimiza- tion techniques to address the performance problems that typically hinder IDL-based \ncommunication. Flick s opti- mizations are complementary to those that are generally im- plemented by \ntraditional language compilers. While many of Flick s techniques have counterparts in traditional compil- \ners, Flick is unique in that it has knowledge of its specialized task domain and has access to many different \nlevels of in- formation through its multiple intermediate representations. This allows Flick to implement \noptimizations that a general language compiler cannot. Conversely, Flick produces code with the expectation \nthat general optimizations (e.g., regis- ter allocation, constant folding, and strength reduction) will \nbe performed by the target language compiler. In summary, Flick implements optimizations that are driven \nby its task do- main and delegates general-purpose code optimization to the target language compiler. \n3.1 Efficient Memory Management Marshal Buffer Management Before a stub can mar- shal a datum into its \nmessage buffer, the stub must ensure that the buffer has at least enough free space to contain the encoded \nrepresentation of the datum. The stubs produced by typical IDL compilers check the amount of free buffer \nspace before every atomic datum is marshaled, and if necessary, ex- pand the message buffer. These repeated \ntests are wasteful, especially if the marshal buffer space must be continually ex- panded. The stubs \nproduced by Flick avoid this waste. Flick analyzes the overall storage requirements of every message \nthat will be exchanged between client and server. This is accomplished by traversing the MINT representation \nof each message. The storage requirements and alignment constraints for atomic types are given by the \non the wire data types that are associated with the various MINT nodes. The storage requirements for \naggregate types are determined by working backward from nodes with known requirements. Ultimately, Flick \nclassifies every type into one of three stor- age size classes: fixed, variable and bounded, or variable \nand unbounded. From this information, Flick produces optimized code to manage the marshal buffer within \neach stub. Before mar-shaling a fixed-size portion of a message, a Flick-generated stub will ensure that \nthere is enough free buffer space to hold the all of the component data within the fixed-size message \nsegment. The code that actually marshals the data is then free to assume that sufficient buffer space \nis available. In cases in which an entire message has a fixed size, Flick gen- erates a stub that checks \nthe size of the marshal buffer ex- actly once.4 A different message segment may be variable in size but \nbounded by a limit known at stub generation time or by a limit known at stub execution time. In this \ncase, if the range of the segment size is less than a predetermined threshold value (e.g., 8KB), Flick \nproduces code similar to that for fixed-size message fragments: the generated stub will ensure that there \nis enough space to contain the maxi- mum size of the message segment. If the range is above the threshold, \nhowever, or if the message fragment has no upper bound at all, then Flick descends into the message segment \nand considers the segment s subcomponents. Flick then ana- lyzes the subcomponents and produces stub \ncode to manage the largest possible fixed-size and threshold-bounded mes-sage segments as described above. \nOverall, our experiments with Flick-generated stubs have shown that this memory op- timization technique \nreduces marshaling times by up to 12% for large messages containing complex structures. Parameter Management \nAnother optimization that re- quires domain knowledge is the efficient management of memory space for \nthe parameters of client and server stubs. Just as it is wasteful to allocate marshal buffer space in \nsmall pieces, it is similarly wasteful to allocate memory for unmarshaled data on an object-by-object \nor field-by-field basis. Therefore, Flick optimizes the allocation and deal- location of memory used \nto contain the unmarshaled data that will be presented to clients and servers. For example, Flick-generated \nstubs may use the runtime stack to allocate space for parameter data when this is allowed by the seman- \ntics of the interface presentation. In some situations, Flick- generated stubs use space within the marshal \nbuffer itself to hold unmarshaled data - this optimization is especially im- portant when the encoded \nand target language data formats of an object are identical. Generally, these optimizations are valid \nonly for in (input) parameters to the functions in a server that receive client requests. Further, the \nsemantics of the presentation must forbid a server function from keep- 4Flick-generated stubs use dynamically \nallocated buffers and reuse those buffers between stub invocations. This is generally preferable to allocat- \ning a new buffer for each invocation. However, it means that stubs that e-n- code fixed-size messages \nlarger than the minimum buffer size must verify the buffer size once. ing a reference to a parameter \ns storage after the function has returned. Our experiments have shown that stack alloca- tion is most \nimportant for relatively modest amounts of data - stack allocation for small data objects can decrease \nun-marshaling time by 14% - and that reuse of marshal buffer space is most important when the amount \nof data is large. However, the behavior of stack and marshal buffer storage means that it is suitable \nonly in certain cases. Flick can iden- tify these cases because it has access to the behavioral prop- \nerties of the presentations that it creates.  3.2 Efficient Copying and Presentation Data Copying By \ncomparing the encoded representation of an array with the representation that must be presented to or \nby a stub, Flick determines when it is possible to copy ar- rays of atomic types with the C function \nmemcpy. Copying an object with memcpy is often faster than copying the same ob- ject component-by-component, \nespecially when the compo- nents are not the same size as machine words. For instance, our measurements \nshow that this technique can reduce char- acter string processing times by 60-705. In order for this \nop- timization to be valid, the encoded and target language data formats must be identical, and this \ncan be determined by ex- amining the type chains constructed by the presentation gen- erator and back \nend as described in Section 2.3. A more flex- ible copy optimizer that allows for byte swapping and word \ncopying of other aggregate types -similar to the optimizer in USC [19] - will be implemented in a future \nversion of Flick. Even when an object cannot be copied with memcpy, Flick performs an optimization to \nspeed component-by- component copying. As part of the analysis performed for optimizing marshal buffer \nallocation described above, Flick identifies portions of the message that have fixed layouts. A message \nregion with a fixed size and a fixed internal layout is called a chunk. If Flick discovers that a stub \nmust copy data into or out of a chunk, Flick produces code to set a chunk pointer to the address of the \nchunk. Subsequent stub accesses to components of the chunk are performed by adding a con- stant offset \nto the chunk pointer. The chunk pointer itself is not modified; rather, individual statements perform \npointer arithmetic to read or write data. Flick assumes that the tar- get language compiler will turn \nthese statements into efficient pointer-plus-offset instructions. Chunking is a kind of com- mon subexpression \nelimination that would not ordinarily be performed by the target language compiler itself due to the \ngeneral difficulty of optimizing pointer-based code. Chunk- based code is niore efficient than code produced \nby tradi- tional IDL compilers, which generally increments a read or write pointer after each atomic \ndatum is processed. Our ex- periments with Flick-generated stubs show that chunkingcan reduce some data \nmarshaling times by 14%. Table 2: Object Code Sixes in Bytes. Each IDL compiler produced stubs for the \ndirectory interface described in Se&#38;on 4 and the generated stubs were compiled for our SPARC test \nmachines. The sixes of the compiled stubs, along with the sizes of the library code muired to marshal \nand unmarshal data, were dctumid through exam&#38;ion of the objeet files. Numbers for MIG are not shown \nbecause the MIG IDL cannot express the interface. Li-brary code for OR&#38;line is not shown because \nwe had limited access to the ORBeline runtime. Specialized Transports Because Flick is a toolkit, it \nis straightforward to implement back ends that take advantage of special features of a particular transport \nsystem. For ex- ample, Flick s Mach 3 back end allows stubs to communi- cate out-of-band data [20] and \nFlick s Fluke [lo] back end produces stubs that communicate data between clients and servers in machine \nregisters. A Fluke client stub stores the first several words of the message in a particular set of reg- \nisters; small messages fit completely within the register set. When the client invokes the Fluke kernel \nto send the mes- sage, the kernel is careful to leave the registers intact as it transfers control to \nthe receiving server. This optimiza- tion is critical for high-speed communication within many microkernel-based \nsystems. 3.3 Efficient Control Flow Mine Code The stubs produced by many IDL compilers are inefficient \nbecause they invoke separate functions to mar- shal or unmarshal each datum in a message. Those functions \nin turn may invoke other functions, until ultimately, func- tions to process atomic data are reached. \nThis type of code is straightforward for an IDL compiler to generate. However, these chains of function \ncalls are expensive and impose a sig- nificant runtime overhead. Not only are the function calls wasteful, \nbut reliance on separate, type-specific marshal and unmarshal functions makes it difficult for an IDL \ncompiler to implement memory management optimizations such as those described previously in Section 3.1. \nA general-purpose mar- shal function must always check that buffer space is avail- able; a separate unmarshal \nfunction cannot use the runtime stack to allocate space for the unmarshaled representation of a data \nobject. Therefore, Flick aggressively inlines both marshal and unmarshal code into both client- and server-side \nstubs. In general, Flick-generated stubs invoke separate mar- shal or unmarshal functions only when they \nmust handle re- cursive types such as linked lists or unions in which one of Compiler 1 Origin IDL 1 \nEncoding 1 &#38;ansputi~ rpcgen Sun ONC 1 XDR 1 ONCtTCP POWerRPC Netbula -CORBA XDR ONCtTCP Flick Utah \nONC XDR ONCITCP ORBeline Visigenic CORBA HOP TCP ILU XemX PARC CORBA IIOP TCP Flick Utah CORBA IIOP TCP \n MIG CMU MIG Mach 3 Mach3 Flick Utah ONC Mach 3 Mach 3 L Table 3: Tested IDL Compilers and Their Attributes. \nrpcgen, Power~pc. and ORBeline are commercial products, while ILU and MIG are well known compilers from \nresearch organizations. The hwerRPC IDL is simibir to the CORBA IDL. The huge4 language WBS C, except \nfor ORBeline which sup ports only ci+. the union branches leads back to the union type itself.5 For a \nlarge class of interfaces, inlining actually decreases the sizes of the stubs once they are compiled \nto machine code. This effect is illustrated in Table 2. Inlining obviously removes expensive function \ncalls from the generated code, but more importantly, it allows Flick to specialize the inlined code in \ncontext. The memory, parameter, and copy optimizationsde- scribed previously become more powerful as \nmore code can be inlined and specialized. In total, our experiments with Flick show that stubs with inlined \ncode can process complex data up to 60% faster than stubs without this optimization. Message Demultiplexing \nA server dispatch function must demultiplex messages received by the server process and forward those \nmessages to the appropriate work func- tions. To perform this task, the dispatch function examines a \ndiscriminator value at the beginning of every message. This discriminator may be one or more integer \nvalues, a packed character string, or any other complex type, depending on the message format. Regardless \nof the type, Flick gener- ates demultiplexing code that examines machine word-size chunks of the discriminator \ninsofar as possible. The accept- able values for a discriminator word are used to produce a C switch \nstatement; multi-word discriminators are decoded using nested suit ches. When a complete discriminator \nhas been matched, the code to unmarshal the rest of the message is then inlined into the server dispatch \nfunction.  4 Experimental Results To evaluate the impact of Flick s optimizations, we com- pared Flick-generated \nstubs to those from five other IDL com-pilers, including three sold commercially. The different IDL compilers \nare summarized in Table 3. The first compiler, Sun s rpcgen, is in widespread use. PowerRPC [17] is a \n5A future version of Flick will produce iterative marshal and unmarshal code for WI-trzursive data encodings \nin the marshal buffer. new commercial compiler derived from rpcgen. POWerRPC provides an IDL that is \nsimilar to the CORBA IDL; however, PowerRPC s back end produces stubs that are compatible with those \nproduced by rpcgen. ORBeline is a CORBA IDL compiler distributed by Visigenic, implementing the stan- \ndard mapping for CORBA onto C++. ILU and MIG represent opposite ends of a spectrum: ILU is a very flexible \ncompiler that produces slow stubs, whereas MIG is a very rigid com- piler that produces fast stubs. For \nthe ONC RPC and CORBA IDL-based compilers, we measured the performance of generated stub functions com- \nmunicating across three different networks: a 1OMbps Eth- ernet link, a 1OOMbps Ethernet link, and a \n640Mbps Myrinet link [4]. For MIG interfaces, we measured Mach IPC speeds between separate tasks running \non a single host. For each transport and compiler, we measured the costs of three dif- ferent method \ninvocations. The first method takes an input array of integers. The second takes an input array of rect- \nangle structures: each structure contains two substructures, and each substructure holds two integers \n(i.e., a coordinate value). The third method takes an input array of variable-size directory entry structures: \neach directory entry contains a variable-length string followed by a fixed-size, UNlX stat- like structure \ncontaining 136 bytes of file information (30 4-byte integers and one 16-byte character array). Although \nthe size of a directory entry is variable, in our tests we al- ways sent directory entries containing \nexactly 256 bytes of encoded data. These methods were repeatedly invoked in order to mea- sure both marshaling \nspeed and end-to-end throughput for a variety of message sizes. The first two methods were invoked to \nsend arrays ranging in size from 64 bytes to 4MB. The third method was invoked to send arrays ranging \nin size from 256 bytes to 512KB. Marshal Throughput Marshal throughput is a measure of the time required \nfor a stub to encode a message for trans- port, independent of other runtime overhead or the time re \nquired to actually transmit the message. To measure marshal throughput, we instrumented the stubs produced \nby Flick, rpcgen, PowerRPC, ILU, and ORBeline, and the resultant throughput measurements are shown in \nFigure 3. The figure shows that Flick-generated marshal code is between 2 and 5 times faster for small \nmessages and between 5 and 17 times 60~r hosts for the network and marshaling tests were two Sun SPARC- \nstation 20/50 machines Each ran at XIMHz, had 20W16K (I/D. 514 set- associative) Ll caches, no L2 caches, \nwere rated 77 on the SPECint92 benchmark, and had measuted memory copy/mad/write bandwidths of 35/N/62 \nMBps, although the libc bcopy gives only 29MBps. They ran Solaris 2.5.1. One machine had 64MB DRAM, while \nthe other bad %MB DRAM. Our host for the MIC tests was a lOOMHa Pentium with an 8Ki8K (l/D 212 assoc) \nLl cache, a 5 I2K direct-mapped L2 cache, both write-back, and 16MB of DRAM, running CMU Mach 3. It had \ncopy/read/write band-widths of 36/62/82MBps. AI1 memory bandwidth tests were performed us- ing lmbench \n1.1 [la], and all throughput measumments were performed with the operating system socket queue size set \nto 64K. Figure 3: Marshal Throughput on a Big EmJian (SPARC) Archirectm. This test compares equivalent \nmarshaling functions and avoids any transport- dated bottlenecks. The performance ratioaaIesimilarwhenthetesls \nare performed on a little endian (Penthun) amhiteetme. Flicks superior throughput shows that Flick-generated \nstubs am suitable for use on high- pelf-ce tlamports. faster for large messages. As expected, Flick-generated \nstubs process integer arrays more quickly than structure arrays be- cause Flick performs its memcpy optimization \nonly for arrays of atomic types. ORBeline stubs use scatter/gather l/O in or- der to transmit arrays \nof integers and thereby avoid conven- tional marshaling [ 121; this is why data for ORBeline s per- formance \nover integer arrays are missing from Figure 3. End-to-End Throughput The gains derived from greater marshal \nthroughput can only be realized to the extent that the operating system and network between client and \nserver do not limit the possible end-to-end throughput of the system. To show that improved network performance \nwill increase the impact of an optimizing IDL compiler, we measured the round-trip performance of stubs \nproduced by the three compilers SUppOrting ONC transports: rpcgen, POWerRPC, and Flick, on three different \nnetworks. The stubs produced by the three compilers all have minimal runtime overhead that is not related \nto marshaling, thus allowing a fair comparison of end-to-end throughput.7 Figure 4 shows that the maximum \nend-to-end throughput of all the compilers stubs is approximately 6%7.5Mbps when com- municating across \na 1OMbps Ethernet. Flick s optimizations have relatively little impact on overall throughput. Over fast \ncommunication links, however, Flick s opti- mizations again become very significant. Figures 5 and 6 \nUnliie stubs producedby Flick, rpcgm, and PowIxRPC, stubs gener- ated by OR&#38;line and ILU include \nfunction calls to significant runtime hxy- ers. These runtime layers perform tasks that am necessary \nin certain envi- mmnents (e.g., muhi-thread synchronization) but which am not tequimd for basic client/server \ncommunication. Figure 4: End-to-End Throughput Across 1OMbps Ethernet. The data for POWerRPC and rpcgen \nis incomplete because the generated stubs signal an error when invoked to marshal large anays of integers. \nFigure 5: End-to-End Throughput Across 1 OOMbps Ethemet. Figure 6: End-to-End Throughput Across 64OMbj~ \nMyrim. show that for stubs communicating across 1OOMbps Ethernet and 640Mbps Myrinet, Flick s optimizations \nincrease end- to-end throughput by factors of 2-3 for medium size mes- sages, factors of 3.2 for large \nEthernet messages, and factors of 3.7 for large Myrinet messages. with Flick stubs, both 1OOMbps and \n64OMbps transports yield significant through- put increases. In contrast, PowerRPC and rpcgen stubs did \nnot benefit from the faster Myrinet link: their throughput was essentially unchanged across the two fast \nnetworks. This in- dicates that the bottleneck for PowerRPC and rpcgen stubs is poor marshaling and unmarshaling \nbehavior. Measurements show that the principal bottlenecks for Flick stubs are the memory bandwidth of \nthe SPARC test ma- chines and the operating system s communication protocol stack. Flick s maximum throughput \nis less than half of the theoretical Ethernet bandwidth and less than 10% of the the- oretical Myrinet \nbandwidth. These results, however, must be viewed in terms of the effective bandwidth that is available \nafter memory and operating system overheads are imposed. As measured by the widely available ttcp benchmark \npro- gram, the maximum effective bandwidth of our 1OOMbps Ethernet link is 70Mbps and the maximum bandwidth \nof our Myrinet link is just 84.5Mbps. These low measurements are due to the performance limitations imposed \nby the operat- ing system s low-level protocol layers [ 121. Through calcu- lations based on these numbers \nand measured memory band- width, we have confirmed that the difference between ttcp throughput and the \nperformance of Flick stubs is entirely due to the functional requirement to marshal and unmarshal mes- \nsage data -which requires memory-to-memory copying and is thus limited by memory bandwidth. As operating \nsys- tem limitations are reduced by lighter-weight transports [6, 71, Flick s ability to produce optimized \nmarshal code will have an increasingly large impact. Figure 7: End-to-End Throughput for MIG and Flick \nStubs. MIG is both highly specialii for optimizing Mach message communication, and is able only to support \nsimple data types. At larger-sized messages, Flick-generated stubs achieve throughput comparable to that \nof hirci-generated stubs even though Flick is a much mote flexible IDL compiler. End-to-End Throughput \nCompared to MIG In Fig- ure 7 we compare the end-to-end throughput of Flick-generated stubs to the throughput \nof stubs generated by MIG, Mach 3 s native IDL compiler. In this experiment the stubs transmit arrays \nof integers; we did not generate stubs to trans- mit arrays of structures because MIG cannot express \narrays of non-atomic types. MIG is a highly restrictive IDL com-piler, but it is also highly specialized \nfor the Mach 3 message communication facility. The effect of this specialization is that for small messages, \nMlc-generated stubs have through- put that is twice that of the corresponding Flick stubs. How- ever, \nas the message size increases, Flick-generated stubs do increasingly well against MIG stubs. Beginning \nwith 8K messages, Flick s stubs increasingly outperform MIG S stubs, showing 17% improvement at 64K. \nThe results of this exper- iment demonstrate the potential for further improvements in Flick and are \nencouraging because they show that although Flick is much more flexible and general-purpose than MIG, \nFlick-generated stubscan compete against stubs produced by the operating system s own IDL compiler. At \na current cost for small and moderate sized messages, Flick allows Mach programmers to use modem IDLs \nsuch as CORBA and sup- ports many C language presentations (e.g., structures) that MIG CannOt Offer. \n 5 Related Work Previous work has shown that flexible, optimizing compilers are required in order to \neliminate the crippling communica- tion overheads that are incurred by many distributed systems. In a \nseminal paper in the networking domain, Clark and Ten- nenhouse [5] identified data representation conversion \nas a bottleneck to many communication protocols. They empha- sized the importance of optimizing the presentation \nlayer of a protocol stack and showed that it often dominates processing time. Recent work by Schmidt \net al. [ 12,211 has quantified this problem for rpcgen and two commercial CORBA imple-mentations. On \naverage, due to inefficiencies at the presenta- tion and transport layers, compiler-generated stubs achieved \nonly 16-80% of the throughput of hand-coded stubs. To address these and similar performance issues, sev-eral \nattempts have been made to improve the code gener- ated by IDL compilers. Mach s MIG [20] compiler generates \nfast code but only by restricting the types that it can handle: essentially just scalars and arrays of \nscalars. Hoschka and Huitema [ 141 studied the tradeoffs between (large, fast) com- piled stubs and (small, \nslow) interpreted stubs and suggested that an optimizing IDL compiler should use both techniques in order \nto balance the competing demands of throughput and stub code size. However, their experimental results \nap- pear to apply only to the extraordinarily expensive type rep- resentations used in ASN.~, in which \ntype encoding is dy- namic even for fundamental scalar types such as integers. Of more relevance to commonly \nused representations is the Uni- versal Stub Compiler (USC) work by O Malley et al. [19]. USC does an \nexcellent job of optimizing copying based on a user-provided specification of the byte-level representations \nof data types. This work is complementary to ours: as the au- thors state, USC may be used alone to specify \nsimple conver- sion functions (e.g., for network packet headers) or it may be leveraged by a higher-level \nIDL compiler. By incorporating USC-style representations for all types, Flick could improve its existing \ncopy optimizations as outlined in Section 3.2. Recently, Gokbale and Schmidt [13] addressed perfor- mance \nissues by optimizing SunSoft s reference implemen- tation of IIOP [26]. The SunSoft HOP implementation \ndoes not include an IDL compiler but instead relies on an inter- preter to marshal and unmarshal data. \nThe authors opti- mized the interpreter and thereby increased throughput over an ATM network by factors \nof 1.8 to 5 for a range of data types. Their implementation achieved throughput compara- ble to that \nof commercial CORBA systems that utilize com- piled stubs, including ORBeline [ 111. However, since Flick- \ngenerated stubs typically greatly outperform stubs produced by ORBeline, Flick must also outperform the \nbest current in- terpretive marshalers. In the area of flexible IDL compilers, the Inter-Language Unification \n[15] (ILu) system from Xerox PARC empha-sizes support for many target languages, supporting C, C++, Modula-3, \nPython, and Common Lisp. However, like most IDL compilers, ILU uses as its sole intermediate representa- \ntion a simple AST directly derived from the IDL input file. ILU does not attempt to do any optimization \nbut merely tra- verses the AST, emitting marshal statements for each datum, which are typically (expensive) \ncalls to type-specific mar-shaling functions. Each separate backend is essentially a full copy of another \nwith only the printf s changed. For Flick to do similarly, it would simply emit marshaling code as it \ntraversed an A01 structure. ILU does support two IDLs -its native, unique IDL and the CORBA IDL -but \nonly by trans- lating the CORBA language into its own IDL. Like Flick, the Concert/C distributed programming \nsys- tem [2] quite fully develops the concept of flexible presen- tation. In Concert, the primary purpose \nof this separation is to handle the vagaries of RPCmapping to different tar-get languages, striving for \na minimal contract in order to achieve maximal interoperability between target languages. However, this \nseparation is not leveraged for optimizations. In earlier work [8,9] we concentrated on leveraging Flick \ns explicit separation of presentation from interface in order to produce application-specialized stubs. \nWe showed that programmer-supplied interface annotations that coerce the programmer s contract to applications \nneeds could pro- vide up to an order of magnitude speedup in RPC perfor- mance. Finally, several techniques \nused by Flick are similar or analogous to those in traditional compilers for general pur- pose programming \nlanguages. In addition, it appears that our work has many similarities to type-based representation anal- \nysis [22] directed to achieving more efficient unboxed data representations whenever possible, and to \nconvert between such representations. 6 Conclusion This work exploits the fundamental and overdue recogni- \ntion that interface definition languages are indeed program- ming languages, albeit specialized and non-traditional \nin their computational content. This insight is the basis for Flick, a novel, modular, and flexible IDL \ncompiler that ap- proaches stub generation as a programming language trans- lation problem. This, in \nturn, allows established optimizing compiler technology to be applied and extended in domain- specific \nways. Flick exploits many fundamental concepts of modem compiler organization including carefully designed \ninterme- diate representations, modularized front and back ends local- izing source and target language \nspecifics, and a framework organization that encourages reuse of software implementing common abstractions \nand functionality. Our quantitative ex- perimental results confirm that this approach is indeed effec- \ntive for producing high-performance stubs for a wide variety of communication infrastructures.  Availability \nComplete Flick source code and documentation are available athttp://uww.cs.utah.edu/projects/flux/flick/. \n Acknowledgments We are especially indebted to Steve Clawson, who provided technical support for our \nMach and Myrinet performance measurements. Chris Alfeld, Godmar Back, John Carter, Ajay Chitturi, Steve \nClawson, Mike Hibler, Roland Mc- Grath, Steve Smalley, Jeff Turner, and Kevin Van Maren all reviewed \ndrafts of this paper and suggested numerous im-provements; we wish we could have incorporated them all. \nNathan Dykman and Gary Crum did much early implemen- tation. We thank Gary Barbour for loaning us the \nSuns, Al Davis and Chuck Seitz for loaning the Myrinet cards, and Grant Weiler for help with Sun system \nsoftware. References Ul ACCETTA, M., BARON, R., BOLOSKY, W., GOLUB, D., RASHID, R., TEVANIAN, A., AND \nYOUNG, M. Mach: A new kernel foundation for UNIX develop- ment. In Proc. of the Summer 1986 USENIX Con. \n(June 1986), pp. 93-112. PI AUERBACH, J. S., AND RUSSELL, J. R. The Concert signature representation: \nIDL as an intermediate lan- guage. In Proc. of the Workshop on Inter&#38;we Definition Languages (Jan. \n1994), pp. 1-12. 131 BIRRELL,A. D., AND NELSON, B. J. Implementing remote procedure calls. ACM Transactions \non Com-puter Systems 2, 1 (Feb. 1984). 141 BODEN, N., COHEN, D., FELDERMAN, R., Ku-LAWIK, A., SEITZ, \nC., SEIZOVIC, J., AND Su, W.- K. Myrinet -A gigabit-per-second local-area network. IEEE MICRO 15,l (February \n1995), 29-36.  VI CLARK, D. D., AND TENNENHOUSE, D. L. Architec- tural considerations for a new generation \nof protocols. In Proc. of the SIGCOMM 90 Symp. (1990), pp. 200- 208. WI DRUSCHEL, P., DAVIE, B. S., \nAND PETERSON, L. L. Experiences with a high-speed network adapter: A software perspective. In Pnx. of \nthe SIGCOMM 94 Symp. (1994), pp. 2-13. [71 EICKEN, T. v., CULLER, D. E., GOLDSTEIN, S. C., AND SCHAUSER, \nK. E. Active messages: A meeh- anism for integrated communication and computation. In Proc. of the 19th \nInternational Symp. on Computer Architecture (May 1992), pp. 256266.  181 FORD, B., HIBLER, M., AND \nLEPREAU, J. Using an- notated interface definitions to optimize RPC. In Proc. of the 15th ACM Symp. on \nOperating Systems Princi- ples (1995), p. 232. Poster. [9] FORD, B., HIBLEK, M., AND LEPREAU, J. Using \nan- notated interface definitions to optimize RPC. Tech. Rep. UUCS-95-014, University of Utah, Mar. 1995. \n [lo] FORD, B., HIBLER, M., LEPREAU, J., TULLMANN, P., BACK, G., AND CLAWSON, S. Microkernels meet recursive \nvirtual machines. In Proc. of the Sec- ond Symp. on Operating Systems Design and Imple- mentation (Seattle, \nWA, Oct. 1996), USENIX Assoc., pp. 137-151. [l I] GOKHALE, A. Personal communication, Mar. 1997. [12] \nGOKHALE, A., AND SCHMIDT, D. C. Measuring the performance of communication middleware on high- speed \nnetworks. Computer Communication Review 26, 4 (Oct. 1996). [ 131 GOKHALE, A., AND SCHMIDT, D. C. Optimizing \nthe performance of the CORBA Internet Inter-ORB Proto- col over ATM. Tech. Rep. WUCS-97-09, Washington \nUniversity Department of Computer Science, St. Louis, MO, 1997. [14] HOSCHKA, P., AND HLJITEMA, C. Automatic \ngen- eration of optimized code for marshalling routines. In International Working Conference on Upper \nLayer Protocols, Architectures and Applications (Barcelona, Spain, 1994), M. Medina and N. Borenstein, \nEds., IFIP TC6/WG6.5, North-Holland, pp. 13 1-146. [15] JANSSEN, B., AND SPREITZER, M. ILU 2.0alpha8 \nReference Manual. Xerox Corporation, May 1996. ftp://ftp.parc.xerox.com/pub/ilu/ilu.html. [16] McVou, \nL., AND STAELIN, C. Imbench: Portable tools for performance analysis. In Proc. of 1996 USENIX Conf (Jan. \n1996). [17] NETBULA, LLC. PowerRPC, Version 1.0, 1996. http://wwu.netbula.com/products/powerrpc/. [18] \nOBJECT MANAGEMENT GROUP. The Common Ob-ject Request Broker: Architecture and Specification, 2.0 ed., \nJuly 1995. [I91 O MALLEY, S., PROEBSTING, T. A., AND MONTZ, A. B. USC: A universal stub compiler. In \nProceed-ings of the Conference on Communications Architec-tures, Protocols and Applications (SIGCOMM) \n(Lon-don, UK, Aug. 1994), pp. 295-306. [20] OPEN SOFTWARE FOUNDATION AND CARNEGIE MELLON UNIVERSITY. \nMach 3 Server Writers Guide. Cambridge, MA, Jan. 1992. [21] SCHMIDT, D. C., HARRISON, T., AND AL-SHAER, \nE. Object-oriented components for high-speed network  programming. In Proceedings of rhe First Conference \non Object-Oriented Technologies and Systems (Mon- terey, CA, June 1995), USENIX. [22] SHAO, Z., AND APPEL, \nA. A type-based compiler for standard ML. In Proc. ACM SIGPLAN Symp. on Pro- gramming Language Design \nand Implementation (June 1995). pp. 116-129. [23] SRINIVASAN, R. RPC: Remote procedure call proto- col \nspecification version 2. Tech. Rep. RFC 1831, Sun Microsystems, Inc., Aug. 1995. [24] SRINIVASAN, R. \nXDR: External data representation standard. Tech. Rep. RFC 1832, Sun Microsystems, Inc., Aug. 1995. \n[25] SUN MICROSYSTEMS, INC. ONC+ Developer s Guide, Nov. 1995. [26] SUNSOFT, INC. SunSoft Inter-ORB Engine, \nRe-lease 1.1, June 1995. ftp://ftp.omg.org/pub/ interop/iiop. tar. Z.  \n\t\t\t", "proc_id": "258915", "abstract": "An interface definition language (<sc>IDL</sc>) is a nontraditional language for describing interfaces between software components. <sc>IDL</sc> compilers generate \"stubs\" that provide separate communicating processes with the abstraction of local object invocation or procedure call. High-quality stub generation is essential for applications to benefit from component-based designs, whether the components reside on a single computer or on multiple networked hosts. Typical <sc>IDL</sc> compilers, however, do little code optimization, incorrectly assuming that interprocess communication is always the primary bottleneck. More generally, typical <sc>IDL</sc> compilers are \"rigid\" and limited to supporting only a single <sc>IDL</sc>, a fixed mapping onto a target language, and a narrow range of data encodings and transport mechanisms.<i>Flick</i>, our new <sc>IDL</sc> compiler, is based on the insight that <sc>IDL</sc>s are true languages amenable to modern compilation techniques. Flick exploits concepts from traditional programming language compilers to bring both flexibility and optimization to the domain of <sc>IDL</sc> compilation. Through the use of carefully chosen intermediate representations, Flick supports multiple <sc>IDL</sc>s, diverse data encodings, multiple transport mechanisms, and applies numerous optimizations to all of the code it generates. Our experiments show that Flick-generated stubs marshal data between 2 and 17 times faster than stubs produced by traditional <sc>IDL</sc> compilers, and on today's generic operating systems, increase end-to-end throughput by factors between 1.2 and 3.7.", "authors": [{"name": "Eric Eide", "author_profile_id": "81341490043", "affiliation": "University of Utah, Department of Computer Science, 3190 M.E.B., Salt Lake City, Utah", "person_id": "PP42049609", "email_address": "", "orcid_id": ""}, {"name": "Kevin Frei", "author_profile_id": "81342494681", "affiliation": "University of Utah, Department of Computer Science, 3190 M.E.B., Salt Lake City, Utah", "person_id": "P160924", "email_address": "", "orcid_id": ""}, {"name": "Bryan Ford", "author_profile_id": "81100262251", "affiliation": "University of Utah, Department of Computer Science, 3190 M.E.B., Salt Lake City, Utah", "person_id": "PP40025421", "email_address": "", "orcid_id": ""}, {"name": "Jay Lepreau", "author_profile_id": "81100366511", "affiliation": "University of Utah, Department of Computer Science, 3190 M.E.B., Salt Lake City, Utah", "person_id": "PP14130643", "email_address": "", "orcid_id": ""}, {"name": "Gary Lindstrom", "author_profile_id": "81100137251", "affiliation": "University of Utah, Department of Computer Science, 3190 M.E.B., Salt Lake City, Utah", "person_id": "PP43125767", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258921", "year": "1997", "article_id": "258921", "conference": "PLDI", "title": "Flick: a flexible, optimizing IDL compiler", "url": "http://dl.acm.org/citation.cfm?id=258921"}