{"article_publication_date": "05-01-1997", "fulltext": "\n Partial Dead Code Elimination using Slicing Transformations RastislavBodik Rajiv Gupta Dept. of Computer \nScience University of Pittsburgh Pittsburgh, PA 15260 {bodik,gupta}Qcs.pitt.edu Abstract We present an \napproach for optimizing programs that un- covers additional opportunities for optimization of a state- \nment by predicating the statement. In this paper predica- tion algorithms for achieving partial dead \ncode elimination (PDE) are presented. The process of predication embeds a statement in a control flow \nstructure such that the state- ment is executed only if the execution follows a path along which the \nvalue computed by the statement is live. The control flow restructuring performed to achieve predication \nis expressed through slicing tmnsformations. This approach achieves PDE that is not realizable by existing \nalgorithms. We prove that our algorithm never increases the operation count along any path, and that \nfor acyclic code all partially dead statements are eliminated. The slicing transformation that achieves \npredication introduces into the program addi- tional conditional branches. These branches are eliminated \nin a branch deletion step based upon code duplication. We also show how PDE can be used by acyclic schedulers \nfor VLIW processors to reduce critical path lengths along fre- quently executed paths. Keywords: partial \ndead code elimination, program slicing, program restructuring, path-sensitive optimization. 1 Introduction \nWe present a novel program transformation that predicates the execution of statements for improving the \nquality of generated code. The predication of a statement is a pro- cess that embeds the statement in \na control flow graph to reduce the number of paths along which the statement ex- ecutes, thus optimizing \nthe program. In this paper we use predication for carrying out partial dead code elimination [PDE). An \nassignment is partially dead if there is a path from the assignment statement to the end of the program \nalong which the value computed by the assignment is not used. PDE through predication is achieved by \nembedding a partially dead statement in a predicate flow graph which ensures that the execution of the \nassignment is triggered at run time only if the program follows a path along which the value computed \nby the statement is live. The control flow restructuring required by the above optimization is achieved \nthrough slicing transformations. Permission to make digital/hard copy of part or all this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advan-tage, the copyright notice, the title of the publication and its date appear, and notice \nis given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permission and/or a fee. PLDI 97 Las Vegas, NV, \nUSA 0 1997 ACM 0-89791-907-6/97/0006...$3.50 The algorithm we present ensures that predication does not \nincrease the operation count along any path as a result of PDE. Existing PDE techniques based upon code-motion \nreduce deadness by sinking partially dead statements to pro- gram points such that the number of paths \nalong which the value computed by the statement is dead is reduced [Z, 8, 13, 171. Predication improves \nupon these existing algo- rithms because it is able to achieve PDE of code statements that are not sinkable. \nFor acyclic graphs our approach gen- erates code containing no partially dead code, which is a result \nthat existing PDE algorithms cannot achieve. If a partially dead statement is nested inside a loop, existing \ntechniques can only achieve PDE if sinking of the statement to the point following the loop is possible. \nOur approach can reduce deadness even if this sinking is not possible. PDE is an important optimization \nfor VLIW architectures in which critical path lengths along frequently executed paths can be reduced \nthrough PDE [9, lo]. We show how our PDE opti-mization can improve effectiveness of hyperblock schedulers \n[6, 161 by moving operations that are dead on the dominant path off the scheduling region. Insertion \nof the predicate flow graph into the program control flow graph introduces into some paths additional \nas- signments and conditional branches. The assignment state-ments in the predicate graph are hoisted \nfrom other parts of the program under their original execution conditions and thus do not increase the \noperation count along any path. To ensure that the number of conditional bmnches that are executed along \nany path through the program remains the same, the predication of statements is followed by a con- ditional \nbranch deletion phase. The branches introduced during the predication of a statement are copies of later \nbranches and hence correlated to those branches. They can be eliminated through code duplication and \ncontrol flow graph restructuring techniques [l, 151. We are aware of four existing algorithms for PDE. \nKnoop, Riithing, and Steffen [13] present an optimal PDE algorithm based on sinking partially dead assignments \ncloser to their uses. Their algorithm can eliminate all partial deadness that can be removed without \nchanging the branching structure of the program. Briggs and Cooper [2] develop an algo- rithm for removing \npartial redundancies. Their algorithm may remove some partially dead code as well but some ex- ecution \npaths may be impaired by sinking partially dead assignments into loops. Feigen et al. [8] describe an \nalgo- rithm that modifies program branching structure by moving a partially dead assignment to the point \nof the use together with the statements that guarantee preservation of the orig- inal program semantics. \nThe algorithm has several serious restrictions. For example, it cannot move statements out of loops or \nacross loops. There is some similarity between their and our approach to a more aggressive PDE optimization. \n Pl :=a<0 i i i (a) lJnc@mized coda. lb) -w -lcrPoE (c) ccmplel. POE (dlertw-mch alldndm). Figure 1: \nPDE through statement predication. While they wrap the partially dead assignment into its exe- cution \ncondition and move it to the point of the use, we leave the assignment in place but embed it into the \nexecution con- dition that characterizes the paths along which the assign- ment is live. Finally, Steffen \n[17] describes a PDE algorithm based on code restructuring that is capable of eliminating all partially \ndead statements, at the cost of introducing non- determinism into the program. Nondeterministic branches \nare introduced even when acyclic programs are optimized. Since the program must be executed with backtracking, \nit may impair many execution paths. Next, we briefly illustrate the effectiveness of our ap- proach through \nan example. In Figure l(a), the statement x:=y*z is partially dead since the value of x computed by the \nstatement is never used if P2 is false. This deadness cannot be eliminated through code sinking techniques \n(the code-restructuring algorithm in [8] can handle this particular case). As shown in Figure l(b), by \npredicating the execu- tion of x:=y*z with P2, PDE can be achieved. In order to ensure that the value \nof predicate P2 is available before the statement, we also hoist the statement P2:=b<O. As shown in Figure \nl(c), the conditional branch introduced by predi- cation can be eliminated by restructuring the flow \ngraph. In this graph, the operation count along each execution path has been minimized. From the above \nexample it should be clear that the ob- jective of predication is to construct a flow graph structure \ninto which a statement can be embedded to eliminate partial deadness in the statement. In the remainder \nof this paper we develop algorithms for PDE in acyclic code, PDE in cyclic code, and present the application \nof our PDE algorithm to VLIW acyclic schedulers. PDE in Acyclic Code In this section we present the algorithm \nfor applying PDE to acyclic code segments. Our algorithms operate upon a control pow gmph G = (N, E, \nstart, end) of the program in the static single assignment (SSA) form [4]. In this form, a) each program \nvariable has a single definition and b) each use of a variable is reached by exactly one definition. \nThe SSA property is achieved by renaming each original program variable z to a unique variable xi at \neach static definition of c, and by introducing a &#38;assignment zk := d(zi,zj) at control flow merge \nnodes that are reached by definitions of distinct variables zi and z,. We use the SSA form because it \neliminates all output- and anti-dependences, which allows us to freely reorder state- ments during the \nslicing transformations that achieve PDE. All +ssignments are eventually eliminated in our algorithm \nwithout increasing the original operation count along any path in G. Since +-assignments exist in the \nprogram only temporarily, they are not the target of PDE. Consequently, the live and dead conditions \nof each definition are computed transitively across a sequence of +-assignments, as given by the following \nrecursive definition. A variable z is used along path p if it appears along p in the right-hand side \nof either a non-+-assignment or a &#38;ssignment whose left-hand side variable is used along path p. \nFor the purposes of our al- gorithm, referencing a variable in a +ssignment thus does not constitute \na use. A definition node d is live (dead) along path p from d to end if the value computed by.d is used \n(is not used) along p. A definition d is definitely live (dead) if it is live (dead) along each path \nthrough d. In this section we first present the slicing transformation upon which the PDE algorithm is \nbased. Next, we derive important properties of our algorithm. Finally, we describe an implementation \nof the PDE algorithm and analyze its complexity. 2.1 Slicing Transformations The PDE algorithm eliminates \npartial deadness of a single assignment node d at a time. First, we identify a multi- entry, multi-exit \nregion that characterizes the usage pattern of the value computed by d. This region is called the use \nregion and has the following properties: 1) d is one of the region entries, 2) the value computed by \nd is not used in the region, and 3) the value computed by d is either definitely live or definitely dead \nat each exit. PDE is achieved through B I-J 0 0 pattially dead statement weregionmtry fiiefmntierexit \ndead frontier exit elii ol fmntter exite (PFl3) 1 PDE Removal of PFG Figure 2: PDE optimization through \nslicing transformation. a slicing transformation of the use region. Definition 1. Let d be a node with \nan assignment to vari- able t. The use region of d, denoted U(d), is a multi-entry multi-exit region \nof the program control flow graph with the following entry and exit edges: (d,v) is a main entry edge \nto U(d). We assume that there is a single main entry edge and that d # u. (u, v) is a live frontier ezit \nedge from U(d) if 1) there is a path from d to u without a use of 2, 2) z is definitely live at II, and \n3) there is a path from u along which o is dead. (u, u) is a deodfrontier ezit edge from U(d) if 1) there \nis a path from d to u without a use of 2, 2) 1: is definitely dead at u, and 3) there is a path from \nu along which x is live. (u, v) is a side entry edge to U(d) if 1) each path from d to u contains a frontier \nexit edge of d and 2) there is a path from d to u along which there is no frontier exit edge of d. A \npath p from the sink node of an entry edge to the source node of an exit edge is called a region path \nif it does not contain any exit edge. The use region U(d) contains exactly those nodes that lie on some \nregion path of U(d). 0 It should be noted that each frontier exit edge emanates from a node with multiple \nexits, that is, a conditional branch node or a case statement. Our PDE algorithm is based upon embedding \nthe par- tially dead assignment in a flow graph, called a predicate j700 graph (PFG), that captures execution \nconditions un- der which the assignment is definitely live. The embedding ensures that the assignment \nis triggered only when the con-trol is going to follow a live path. The PFG is computed through slicing \n[19] of the use region. The backward slice of a program with respect to an edge is the set of statements \nthat determine whether the edge is executed. DeflnitionZ. Let d be an assignment node and U(d) its use \nregion. The backward slice of U(d) with respect to its live and dead frontier exit edges is called predicate \nflow graph of d, denoted as PFG(d). . Typically, the slice is computed with respect to the en- tire procedure \nor program. However, PFG(d) is a subgraph of U(d); it has the same set of entries and exits and contains \na subset of its statements. The PFG is computed by first including into the slice the source nodes of \nthe exit edges and then taking the closure over control and flow data de- pendences of the statements \nalready in the slice, in the back- ward direction. The goal of embedding d in PFG(d) is to suppress dead- \nness in d. We form a single-entry, single-exit region EMB(d) that will substitute d in the control flow \ngraph. The em-bedding graph EM?(d) is created by adding to PFG(d) the assignment node d and a new node \ne which will serves as the single exit node. The main entry of PFG(d) serves as the entry of EMB(d). \nThe exit node e connects all dead fron- tier exits and and embeds d in the live frontier exit edges as \nshown in Figure 2 and Figure 3(b). In the program resulting PFGQ EMB(d) Portion of PFG read-&#38;k flWlenlly1 \n_____________ ____-___--_ I I I I I I I I I I I I I I I I I I I I I I I I I I I 1 I I I I I --__-------I \n (b) Predicate ftow graph of assigmwnt d (c) -co&#38;fIlmfluftoenby1. (a) Use region of am@mefd d anditsusefnembeddfng \ndtoacWvePDE. Figure 3: An example of the use region and the predicate flow graph. after d is replaced \nby EMB(d), definition d is executed only if the control leaves the use region through a live frontier; \notherwise it is not executed. Thus, partial deadness of d is entirely eliminated. In the presented algorithm, \nthe embedding and substitu- tion of d modifies the use region. All assignment nodes that are included \nin PFG(d) are removed (hoisted) from their original positions in U(d). The conditional branches forming \nthe skeleton of the hoisted control flow structure, denoted by PFG in Figure 2, remain and are removed \nby a subsequent branch elimination step. To preserve program semantics, all side entry edges of the region \nmust be replaced by com- pensation code, denoted by PFG in Figure 2, which is also computed with a slicing \ntransformation as follows. First, the subgraph of the use region that is reachable from the side entry \nis identified. The intersection of this subgraph with PFG(d) yields the desired compensation code. The \ncompen- sation flow graph COMP,(d) for side entry s is constructed in a manner similar to EM?(d) by using \nthe side entry of PFG(d) that correspond to s and connecting all exits into a single exit node. In Figure \n2, a pictorial representation of the compensation code transformation is given. The dashed line delimits \nthe reachable part of the use region. Finally, the branch deletion step eliminates the correlated branches \nin PFCT . Next, we illustrate the algorithm by performing PDE on the acyclic program in Figure 3(a). \nFirst, we eliminate partial deadness present in the assignment d: x:=.... The uw region of d has two \nentries and three exits. Figure 3(b) shows PFG(d) and how the embedding graph EMB(d) is constructed. \nTo achieve PDE, the live frontier exits execute d and the dead frontier bypass d. To construct the embed- \nding graph for d, the main entry is used as the entry to the embedding graph. The entire flow graph delimited \nby the dashed line is what replaces node d in the original pro- gram. Figure 3(c) shows the flow graph \nof the compensation code that is inserted to use region entry 1. Note that the graph in Figure 3(c) contains \na spurious conditional branch P2 which our algorithm removes during the construction of the compensation \ngraph. The resulting program where d is fully live is shown in Figure 4(a); the assignments that belong \nto the PFG are hoisted from the u8e region but the conditional branch elimination has not been performed \nyet. We can repeat the same process to eliminate partial dead- ness in the assignment a:=b+l. Its use \nregion is shown in Figure 4(b) and the program after the embedding graph for this assignment is inserted \nis in Figure 4(c). Finally, the program after conditional branches are removed is shown in Figure 4(d). \nThe cost of branch deletion is code duplication. In Section 4 we present a method for reducing the impact \nof code duplication. 2.2 Correctness, Safety, Termination In this section we demonstrate the correctness \nand effective- ness of our PDE technique. We first show that the transfor- mations performed by the PDE \nalgorithm preserves program semantics (Theorem 3) and is always feasible (Theorem 4). Next we show that \nour approach is safe in that it does not increase the number of operations along any program path (Theorem \n7). Finally, we show that repeated application of our algorithm to individual statements removes alI \npar- tial deadness from the acyclic code segments and that the algorithm always terminates (Theorem 8). \nIt can be shown that each path from an assignment to the end of the program contains a live or dead frontier \nedge. The following theorem proves that the frontiers can navigate the predication of a partially dead \nassignment. Theorem 3 (Correctness/Revival). Let p be a path from start to end and d an assignment node \nfrom p. Executing an assignment d when it is followed on path p by a live frontier and suppressing d \nwhen it is followed on p by a dead frontier results in: a) a semantically equivalent program with b) \nthe assignment d being definitely live. i (a)AftwPDEof xz..:. (b) Urn region of a&#38;1+1 . w i (c) \nAfter POE of a:-b+l . (d) Aftw branch eNmhatbn. Figure 4: PDE of the program in Figure 3(a). Proof. \n(by contradiction) [a] Assume there is a path p along which not executing d alters the program behavior \nbecause the missing value of d is needed (that is, used). By Defini- tion 1, d cannot be followed on \np by a dead frontier. Hence, d must be followed on p by a live frontier which means that d must have \nbeen executed. [b] Assume there is a path p along which executing d pro-duces a value that is not subsequently \nused. By Definition 1, d cannot be followed on p by a live frontier. Hence d must be followed by a dead \nfrontier which means that d must not have been executed. 0 Theorem 4 (Hoi&#38;ability). Given an assignment \nd, the predicate flow graph PFG(d) can be fully evaluated a) in all entries of U(d) and b) prior to d. \nProof. [a] The hoisting of PFG(d) to any entry is permissi- ble because all flow data dependences on \nthe moved assign- ments are satisfied by hoisting the entire slice. No output- or anti-dependences exits \nin the SSA form to prevent the code motion. Since PFG(d) is acyclic, static single assign- ment guarantees \nthat the values computed by the hoisted assignments are available at their respective uses. [b] (by contradiction) \nAssume that the evaluation of PFG(d) Except that the exceptionsthat may be raised by d are removed from \nsome paths. prior to d is prevented by a flow data dependence between d and any statement in PFG(d). \nThen, d must belong to the slice of the frontier edges, which means it is used in U(d), a contradiction \nwith Definition 1. 0 The insertion of the PFG into use region entries intro- duces additional statements \nalong some paths. Next, we show that when the hoisted statements are removed from their original positions \nand the conditional branches are re- moved after PDE is performed, then our algorithm does not increase \nthe operation count along any path. Lemma 5 shows that the assignments and conditional branches that \nare hoisted within the PFG can be removed from the use re- gion. Lemma 6 relates to a use region with \nmultiple entries that are not mutually exclusive, such as those in Figure 3(a). The claim of the lemma \nis that a statement that has been hoisted to more than one entry will execute in at most one entry, for \nany program input. Lemma 5. Each statement s from PFG(d) can be removed from U(d) after hoisting. Proof. \nLet s denote the assignment in U(d) and s the copy of a hoisted within PFG(d). Consider a program execution \npath p from start to s. Since s is within the use region, p must include at least one use region entry. \nLet e be the last entry of U(d) on p. Because the algorithm inserts PFG(d) into e using the PFG entry \nthat corresponds to e, when path p is taken by the program, 3 must be executed. If s is an assignment, \nthen due to SSA form, the value of the hoisted assignment is available at the point of the original assign- \nment which is, therefore, redundant and can be removed. If s is a conditional branch, then due to SSA \nform, the copy and the original branches are correlated along all paths and the original branch can be \nremoved using branch elimination algorithm [l, 151. 0 Lemma&#38; After PDE of an assignment d has been \nper- formed, each statement .Y executes no more frequently than in the original program, for any program \ninput. Proof. If s does not belong to the PFG of d then its con- trol condition is unchanged by the slicing \ntransformation. If s is the assignment d, then its control condition is more strict than in the original \nprogram. If s has been hoisted within a slice, it executes under the same control condition as in the \noriginal program. Since Lemma 5 shows that each hoisted statement can be removed from its original position, \nit remains to be shown that if any two use region entries ei and ez are on the same path and the PFGs \ninserted in the two entries contain a copy of the same original assignment s, then the two copies of \ns cannot both execute. If there is a path p that contains both region entries el and ez, then some frontier \nexit edge f must lie on p between ei and ez. Let the frontier f be an out-edge of a conditional branch \nnode with predicate P. Assume that f is the true-exit. Then, the copy of s in PFG at ei executes only \nwhen P is false and the copy of 3 in PFG at ez executes only when P is true. Thus, for any two copies \nof a statement hoisted to a program path, there is always a predicate that makes their execution mutually \nexclusive. (e.g., the two copies of assign- ment P2:=a<O in Figure 4(a) are made mutually exclusive by \npredicate Pl.) 0 Finally, we want to show that our optimization guaran- tees safety, which means that \nthe operation count along any program path is not increased as a result of the optimiza- tion. To prove \nsafety, we need to show that it is possible to remove all +.ssignments without introducing assignments \nto any temporary variables. First, the algorithm attempts to rename the source variable of each &#38;assignment \nto the destination variable of the assignment, if such renaming is possible. Remaining &#38;ssignments \nare removed by an algo- rithm derived from the optimization framework in [17].2 The algorithm is based \non path duplication and works as follows. Consider a &#38;assignment a and a set of nodes that use the \nvariable assigned in a. The algorithm creates a separate path for each source variable of the &#38;assignment. \nSince only one variable reaches the use along each such path, renaming can be performed and the +rssignment \neliminated. Elimination of r$-assignments is illustrated in Figure 5. Note that the multiple definitions \nof x3 exist because some &#38;assignments have already been eliminated in the program. Theorem 7 (Safety). \nOur PDE algorithm does not increase operation count for any program input. Proof. Follows from Lemma \n5, Lemma 6, and the fact that all SSA-assignments are removed. 0 All concepts presented above relate \nto the optimization of a single assignment. Embedding a partially dead assign- ment may cause partial \ndeadness in statements that com- 2 While the PDE algorithm in [17) produces nondeterministic pro- grams, \nthe #-assignment elimination algorithm does not. pute values used by the assignment. Therefore, our algo- \nrithm repeats PDE for all partially dead statements in a re- verse topological sort order traversal of \nthe data dependence graph. To eliminate deadness of each assignment in the pro- gram, each assignment \nd (and each of its copies) needs to be optimized at most once. It is because after the optimization of \nd, the execution condition of d that guarantees definite liveness is unchanged by our algorithm, and \nso is the ex- ecution condition of all consumers of the value generated by d. The following theorem shows \nthat such repeated ap plications of PDE terminates. The proof seeks to establish that, given au acyclic \nprogram, it is not possible to perform infinitely many applications of PDE such that each creates a new \ncopy of some partially dead assignment. If this was possible, PDE would not terminate because some partially \ndead assignments would always exist. Theorem 8 (Termination). Let D be a directed acyclic graph whose \nedges are the flow data dependences between the statements in the program. If our PDE algorithm is applied \non a statement d only when no descendant of d in D is partially dead, then the PDE process terminates. \nProof. Theorem 7 implies that the operation count on any path does not increase after PDE of an assignment. \nThere- fore, the number of conditional branch nodes on any path through the optimized acyclic program \nis bounded during the entire execution of the PDE algorithm by the height of the original program. It \nfollows that the number of unique paths in such a program, after any program restructuring, is bounded \nby a constant. Let us assume that the PDE al-gorithm creates infinitely many new assignments. Given the \nfinite number of paths, the operation count along some path would have to increase beyond its original \nvalue, contradict- ing the Safety Theorem 7. 0 a := x3 8 (a) Before elimirWion. (b) Afler pathdt@lralfu~. \nB 8 B a := x3 8 := Xl a := x2 %s I (c)Afmr ehnfnatan. Figure 5: Elimination of +-assignments.  2.3 \nImplementation and Complexity So far we have provided a conceptual presentation of our ap- proach. A \ndetailed implementation of the acyclic algorithm is presented in Figures 6 and 7. For simplicity, we \nassume that a node in the control flow graph cannot be both a con- ditional node and a merge node. Procedure \nPDE considers one partially dead assignment at a time and can eliminate partial deadness either completely \nor only for the desired partially dead assignments (e.g., those on the frequently ex- ecuted paths). \nIn either case, since application of PDE to a statement may uncover deadness of another assignment, assignments \nare selected for optimization in a reverse topo- logical sort order of the data dependence graph so that \nPDE of each statement is performed at most once. First, procedure PDE determines the use region by solv- \ning four data flow problems and identifying the entries and frontiers (Figure 6). Note that the four \nproblems are not bit-vector (or separable) data flow problems because a &#38; assignment x; := 4(z;, \nzk), which is not treated in our PDE as a definition or a use, transfers data flow facts from the variable \n2i to variables cj and ok, and vice versa. Second, compute-PFG(d) constructs for each entry of the use \nregion the embedding graph in a way that it contains only those nodes from PFG(d) that are reachable \nfrom the entry (see Figure 3(c) for an example of unreachable nodes). Thus, no additional elimination \nof unreachable nodes in the embed- ding graphs is necessary. Next, the assignment d is embed- ded in \nits PFG, and the PFGs representing compensation code are introduced into all other entries. Since no \nnode is embedded into the latter PFGs, the conditional branches at the exits of the PFGs may be spurious \n(i.e, both exits Entry[dl: the set of entries in use region of d LF[dJ: the set of life frontiers of \nd DF[d]: the set of dead frontiers of d Solve data flow problems: ANUd: d is Available without intercepting \nuse GEN = {d), KILL = uses, meet op = V, direction = forward, init value = I FLd: d is Definitely live \nGEN = uses, KILL = definitions, meet op = A, direction = backward, init value = I FDd: d is Definitelydead \nGEN = definitions, KILL = uses, meet op = A, direction = backward, init value = T ANFd: d is Available \nwithout intercept. frontier GEN = {d}, KILL = frontiers of d, meet op = V, direction = forward, init \nvalue = I Identify the sets: LF[d] = {(u, u)~ANU&#38;[U] = T A FL&#38;&#38;] = TA 3(u, w) : FL&#38;&#38;] \n= I) DF[dJ = {(u, v)~ANU&#38;,[U] = T A FDf,[u] = TA 3(u, w) : FD;&#38;] = I} Entry[d = {(u, u)IANF&#38;&#38;u] \n= I A ANFjJu] = T} Figure 6: Computing the use region of an assignment d. may point to the same target) \nand are removed. Finally, the redundant conditional branches are eliminated and the SSA form that might \nhave been invalidated during the re- structuring is updated. After all desired deadness has been eliminated, \nthe &#38;assignments are removed. The procedure compute-PFG(d) computes PFG for the use region using \na backward traversal originating from the frontier edges and terminating at d and other entries. The \nPFG is gradually built as the traversal progresses, data slice being handled by frow(n) and the control \nslice by split(n). Procedure flow(n) adds an assignment node n to the root of the propagated PFG if n \ncomputes a value used in the PFG. Since n is being hoisted, it can be removed (see Lemma 5). Procedure \nsplit(n) checks PFGs propagated along both exits 1 procedure PDE(Program P) while partially dead assignments \nexist do pick d such that no def-use descendant of d is partially dead identify the use region of d (Figure \n6) compute-PFG(d) embed d within PFcd[(d, succ(d))] for each e E Entry[d] do remove spurious conditionals \nin PFGd[e] insert PFGd[e] into e end for eliminate redundant conditional branches update SSA form end \nwhile eliminate &#38;assignments procedure compute-PFG(assignment node d) initialize PFG with life and \ndead markers: for each e E LF[dj do PF&#38;[e] := {LF} for each e E DF[d] do PFGd[e] := {DF} for each \nn from the use region in reverse topological sort order do if n is a conditional node then split(n) else \nflow(n)  end for procedure flow(node n) let n be an assignment a := b + c let G denote PFG [(n, succ(n))] \nif any use of a is upward exposed in G add node n to the root of PFG: PFGd[(pred(n), n)] := n + G remove \nn end if procedure split(conditional branch node n) let et and et be the out-edges of n if PFGd[et] \n# PFcd[ef] then PFGd[(pred(n), n)] := PFGl[er] T n -5 PFcd[ef] else PFGd[(pred(n), n)] := PFGd[et] \n end if Figure 7: Implementation of acyclic PDE algorithm. of the conditional branch n and, if they \nare not identical, it adds the branch to the PFG because it is part of the control slice. When the traversal \nreaches an entry of the use region, the computed graph represents the part of PFG(d) that is reachable \nfrom the entry. Let us consider the complexity of our algorithm. On an acyclic program with N nodes and \nV SSA variables, the use region is determined by data flow analysis in O(NV) steps and procedure compute-PFG \nalso takes O(NV) steps. Elimination of branches and SSA assignments takes O(NV) steps for acyclic programs. \nThe time to eliminate deadness of a single assignment is thus O(NV). Due to hoisting of assignments in \nthe PFG and the subsequent restructuring, the size of the program may grow after PDE of a single variable. \nTherefore, on arbitrary input programs, complete PDE may take exponential time.   3 PDE in Cyclic Code \nIn the presence of loops, removal of partially dead code presents more challenges. Given a partially \ndead assign- ment d in a cyclic control flow graph G, our approach is able to eliminate d from all dead \npaths that exist in G prior to application of PDE. However, PDE results in a modified flow graph G in \nwhich new paths may be created. Along these paths, d may be dead after PDE is performed. The assignment \nd thus becomes definitely live with respect to G, but may be partially dead with respect to G . The diffi- \nculties with PDE in cyclic code can be traced down to two orthogonal problems: a) the cyclic nature of \nthe predicate flow graph and b) a cycle in the graph of data dependences of the partially dead statement. \nThese two problems are treated in the following subsections. In the last subsection we describe our contribution \nto partial faint code elimina- tion. 3.1 Cycle in Predicate Flow Graph Using the algorithm from Section \n2, partial deadness of an assignment can be successfully eliminated along all paths in a cyclic flow \ngraph because the embedding predicate flow graph can be hoisted prior to d as it is done for acyclic \npro grams. Hoisting of the PFG is possible because, even in the cyclic domain, no data dependences in \nthe use region exist that would prevent hoisting the slice of the use region to the use region entries. \nTherefore, Theorem 4 holds in the case when the program or the use region contain loops. However, not \nall assignments hoisted in the PFG can be re- moved from the use region, resulting in increased operation \ncounts on some paths. When a PFG containing a loop is in- serted at a use region entry, the assignments \non such a loop produce multiple dynamic values that may all be required by statements that remain in \nthe use region. For example, each hoisted loop leaves in the use region the skeleton of conditional branches \n(denoted PFG in Figure 2(b)), which is itself a loop whose statements that compute the loop exit condition \nhave been hoisted in the PFG. To eliminate the skeleton loop, the exit conditions from each iteration \nof the hoisted loop must be made available, which is only possi- ble through full (that is, infinite) \nunrolling of the hoisted loop. Consequently, the safety of Theorem 7 does not hold in cyclic code. Next, \nwe present a modified PDE algorithm that guarantees safety in cyclic code and we show that the algorithm \nsubsumes the sinking-based PDE algorithm [13]. Our cyclic-code PDE algorithm is based on the observa- \ntion that PFG(d) represents only the minimal set of use re- gion statements that must be hoisted to predicate \nd. When the embedding flow graph is defined to contain all state- ments in the use region, PDE algorithm \nhoists to the region entries all statements, including the skeleton of all condi- tional branches. This \nmakes elimination of statements from the use region unnecessary, resulting in a safe program trans- formation. \nNaturally, an embedding graph that is a superset of PFG(d) may contain assignments that prevent its hoisting \nprior to d, because an embedding graph larger than the slice of the frontier exit edges may include statements \nthat are on the def-use chain of d. According to Definition 1, these statements are restricted to &#38;ssignments. \nThe following arguments prove that these &#38;assignments do not prevent PDE. The &#38;assignments that \nreference the variable assigned by d and prevent hoisting of the entire U(d) exist in the use region \nbecause definitions of the corresponding original vari- able (which was renamed to a unique SSA variable) \nreach U(d) through the side exits. Obviously, a single-entry use region does not contain any such &#38;assignments. \nIf we could transform a multi-entry use region into a set of single-entry regions, we could hoist into \nthe entries any superset of the predicate flow graph. Interestingly, the PDE algorithm de- scribed in \nSection 2 performs such transformation. To see that, we have to realize that in each use region entry, \nonly one of the multiple entries of the embedding graph hoisted to that entry is connected. The other \nentries are unreach- able, effectively transforming the embedding graph into a single-entry region in \nwhich no +ssignemnts for d are nec-essary. The predicate flow graph is thus the minimal subset of statements \nfrom the use region that are required for predi- cation of d. The complete use region itself can form \nthe em- bedding graph and be hoisted into all its entry edges. Since the use region is empty after such \nhoisting, the exits of the embedding graph can be connected directly to the exits of the empty use region. \nThis version of the PDE algorithm is illustrated in Figure 8. A copy of the use region U(d) is created \nand used to embed d. The original use region U(d) serves as a compensation code for the side entries. \nIt should be noted that a single copy of the use region can now serve as compensation code for all side \nentries. The PDE algorithm depicted in Figure 8 can be phrased as a sinking transformation. Given a single-entry \nuse region, the assignment d can be sunk to the live frontier edges. Such sinking is not possible with \nmulti-entry use regions because of the &#38;assignments in the region. However, when a copy of the use \nregion is created and only the main entry is con- nected, a single-entry region is formed through which \nd can be sunk to live frontiers. Actually, the PDE algorithm in [13] eliminates deadness of an assignment \nby sinking to live frontier edges (or further to the uses). Since this algorithm does not restructure \nthe flow graph, PDE is permissible only on single-entry use regions. Our algorithm thus exploits all \nopportunities for PDE that the sinking algorithm in [13] does. The cyclic code version of our PDE algorithm \nis simpler than the algorithm from Section 2 because it eliminates the need to compute the slice (PFG) \nand perform the subse- 0 aeragimamy 0 livefmntkexif 0 deadfmntlerexll Figure 8: PDE in cyclic code. \nquent conditional branch elimination. On the other hand, this algorithm is likely to result in larger \ncode growth. Its simplicity, however, enables us to formulate PDE without the SSA form. Viewing this \nalgorithm as a sinking transfor- mation, the partially dead assignment d is the only state- ment moved \nduring PDE. It hence suffices to ensure its free- dom of motion. Given an assignment d: z := a + b, two \nnew temporary variables t, and tb are introduced and d is reWI%ten t0 t,, := a; tb := b; d : x := ta \n+ tb. Since there is a single assignment to each temporary created by PDE, d can be sunk without being \nrestricted by any anti-dependences on its operands. In other words, the temporaries provide d with the \nvalues of its operands that were current at d s original location. The temporaries can be viewed as SSA \nvariables created on demand when d needs to be moved. They are treated by PDE the same way as the &#38;ssignments; \ntheir assignments are not the target of PDE and, after PDE is complete, they are removed. 3.2 Cycle \nin Data Dependence Graph When the partially dead assignment d lies on a cycle of data dependences, PDE \nremoves d from all dead paths that exist in the control flow graph prior to PDE. However, new paths may \nbe created during code restructuring invoked by PDE. The assignment d (or some of its duplicates) may \nbe dead along the new paths. Repeated application of PDE pro-duces an identical scenario, resulting in \na non-terminating PDE process. Consider the example in Figure 9. The only dead path for d is the one \nthat leads directly out of the loop. This corresponds to d being dead only in the last iteration of the \nloop. PDE is performed using the cyclic code algo- Figure 9: Non-terminating PDE in cyclic code. rithm \nshown in Figure 8: the use region is duplicated with one entry in each copy of the region being connected \nto the outside program. The live frontier exit of the use region con- nected at the main entry (on the \nright in the figure) embeds the partially dead assignment. By tracing the restructured flow graph, it \nis clear that d was eliminated from the dead path. An alternative explanation is that the assignment \nd was delayed by one iteration, so that it is executed only if the following iteration is executed. However, \nrepeated appli- cation of PDE merely peels off another iteration and leaves d dead along a newly formed \npath. The PDE process does not terminate because there is always some last iteration in which d is dead. \nIn conclusion, only one dynamic instance of d is eliminated with one application of PDE. While sinking \napproaches terminate naturally when no new opportunities for optimization exist, our algorithm may never \nterminate because the restructuring may always create new opportu- nities for PDE. We solve the non-termination \nproblem by marking optimized assignments and optimizing each assign- ment at most once. 3.3 Partial \nFaint Code Elimination The non-termination problem can be alleviated by breaking the cycle along which \nPDE is repeatedly performed. While the data dependence graph cannot be made acyclic, the live condition \nof the partially dead assignment can be derived transitively from program statements that are always \nlive (called relevant in [13]), rather than directly from assign- ments that may remain partially dead \nafter each application of PDE. The transitive approach identifies for each assign- ment a set of faint \npaths [ll, 131, which a superset of the dead paths. Dead paths are identified by the direct ap- proach, \nand have been used in this paper so far. Under the faint notion, a definition d is live along a path \np from d to end if a chain of flow data dependences leads along p to a rel- evant statement (e.g., an \noutput statement or conditional). If d is not not live along p, then it is joint alongp. Using faint \npaths, the slicing approach to PDE allows meaningful definitions of live and dead frontier edges and \nalso permits the computation of their slice for embedding an assignment d. However, the use region as \nspecified in Deli- tion 1 does not exist, because d may appear on a (cyclic) faint path multiple times. \nThe definition thus breaks because d cannot be both at the region entry and inside the region. The consequence \nfor partial faint code elimination (PFE) 0 dNdftUlltlW~ PZ:rb<OPl ,, P2 ; ; x:=x*i j . . .. i :- i \n+ 1   6!b 0 i i (b) lsmbeddedhlheslicedfrontCedper. (c) Afbx tzcndbml brand &#38;nhalkm. Figure 10: \nPartial faint code elimination. using our approach is that d can be legally embedded in the slice of \nthe frontier edges, removing it from all faint paths, but the safety cannot be guaranteed because not \nall hoisted statements can be eliminated. Consider the example in Fig- ure 10(a). The assignment d: x:=x*i \ninside the loop is faint when P2 is false. Note that assignment d cannot be moved out of the loop and \ntherefore sinking cannot be employed to achieve PFE. As shown in Figure 10(b), we can eliminate faintness \nby embedding d in the slice of the frontier edges. The hoisted conditional branch P2 is eliminated by \nrestruc- turing the flow graph as shown in Figure IO(c). Complete and safe optimization was achieved. \nHowever, the assign- ment to P2 that was hoisted with the predicate flow graph into the loop had to be \nmoved before the loop using loop invariant code motion. We are not aware of an optimization algorithm \nthat can remove the faintness in Figure 10. Steffen conjectures in [17] that by code restructuring and \nbranch reordering, all dead code can be eliminated. We have proved in this paper his hypothesis for the \ncase of acyclic code. However, we do not believe that a complete and safe removal of dead or faint code \nis possible for arbitrary cyclic graphs, using a realistic model of computation. Consider the following \nprogram. do { a = reado; p=p+a; x=x*a; } uhile (a != cl); if (p != ~2) out(x); In this program, x is \nfaint when the value of p after the loop terminates equals c2. The predication of the assignment to x \nwithin the loop must thus be based on the final value of p, which can only be obtained by executing in \nsequence two slices of the loop. The first loop computes p and the following loop computes the final \nvalue of x. Either the second loop must reissue the input statements (destroying program semantics) or \nan infinite storage area for the values of the variable a read in the first loop must be created. In \neither case, a safe optimization does not seem possible. 4 Using PDE in Acyclic VLIW Scheduling Compilers \nfor VLIW architectures use instruction schedulers that exploit instruction level paraIlelism for generating \nfast schedules of frequently executed portions of a program [3, 9, 161. While not seen as the goal of \nthese schedulers, a limited form of PDE is achieved as a by-product of the code motion applied during \nscheduling. On the other hand, the PDE optimization [13, 8, 21 is expected to be performed by an optimization \nphase that precedes instruction scheduling. However, separating optimization and scheduling may result \nin undesirable consequences. For example, the placement of statements along critical edges3 during PDE \nmay introduce additional branches in the program and hence degrade the quality of schedules generated. \nThus instruction scheduling may in fact be a more suitable phase for performing PDE. In this section \nwe present a PDEbased scheduling algorithm that not only takes advantage of the complete elimination \nof partially dead code to minimize the schedule length but also reduces the impact of code duplication \nincurred during PDE. With more parallelism available in VLIW processors, re- cent research in code scheduling \nconsiders scheduling regions that are larger than the trace [9] or the superblock [7]. To allow inclusion \nof multiple frequently taken program paths in the scheduling region, the hyprblock scheduling region \n[S] contains both conditional branches and control flow merge points. The conditional branches are handled \nby sequential- izing the region using hardware predicated execution [5, 121 or by rev= if-conversion \n[18]. Consider the hyperblock Rl in Figure 11(a). Let us assume that exit E3 is the most frequently taken \nexit while exits El and E2 are taken in- frequently. In this situation, paths from Entry to E3 are 3A \ncritical edge leads from a node with multiple successora to a node with multiple predecessors. cycle \n0 CifP3 cl=not(Pl).not(P2) c2a=not(Pl).P2.not(P3).not(P4) c2b=Pl.not(P3).not(P4) cycle I D if True brX1 \nifcl br X2a if c2a br X2b if c2b Figure 12: The VLIW schedule of hyperblock Rl after PDE optimization. \n considered critical paths and a VLIW scheduler attempts to generate short schedules for these paths. \nThe scheduler in [16] improves upon hyperblock schedul-ing [S] by adding techniques for criticalpath \nreduction (CPR) that enable reordering of region exit branches. For the hy- perblock in Figure 11(a), \nthe CPR scheduler attempts to place the critical exit E3 (which is treated as an exit branch) in the \nschedule as early as possible so that the critical paths can exit the schedule early and continue to \nthe successor region. The CPR scheduler performs an alternative ver-sion of PDE which is achieved by \nreordering the region exit branches and lifting them across partially dead operations. A branch can move \nupwards across an operation only when the operation is dead on the exit from that branch. Find-ing a \nshort schedule for the critical path is thus achieved through PDE optimization. The CPR scheduler [16] \nfails to move an exit branch a above another exit branch b if b does not dominate a. In Figure 11(a), \nP4 cannot be scheduled before P2 and, more importantly, the branch corresponding to E3 cannot be scheduled \nbefore P4 or P2. This may result in a longer schedule because operations dead on the critical path are \nscheduled before the high priority exit branch. We propose a scheduling scheme based on our PDE algorithm \nthat re-moves this restriction. We apply PDE before scheduling in order to restructure the scheduling \nregion such that the resulting schedules of the critical paths will only contain live operations. When \nonly live operations precede the high priority exit, the scheduler can achieve minimal schedule length. \nConsider again Figure 11(a) and assume that operations A and B are dead on exit E3. Applying PDE to the \nschedul- ing region Rl results in the program shown in Figure 11(b). After PDE, partially dead statements \nhave been pushed off - - Afake PI 8 F?. -El  B P3 C P4 -EL? D ta)Tk hypaUak Rl. WllxhypablaekRl IBaPDE \nAUldBPedcldUlE3. PmI-fknv~ofRl. Figure 11: Reducing length of the critical path with PDE. the hyperblock \nto the compensation code and the region has been restructured. Any critical path now contains only op \nerations that are live on exit E3. Note that existing PDE algorithms [13] are based on code sinking and \nthus cannot eliminate B from the hyperblock. The CPR scheduler can-not remove A or B from the hyperblock \nbecause they are live on P4, and E3 cannot be lifted across P4. The hyperblock following the removal \nof partially dead operations shown in Figure 11(b) can be scheduled with a slight modification of the \nCPR scheduler. Note that all the conditional branches will disappear because the resulting schedule uses \npredicated execution, as shown in Figure 12. The side exits are handled as described in [16]; they are \nscheduled as early as possible based on their priorities. Note that operations C and D are executed speculatively \nas sug- gested in [14] because they are issued before the side exit branches. Because of speculation, \nthe execution conditions for C and D are very simple predicates that need not be computed by a long sequence \nof compare operations. Natu-rally, the partially dead operations pushed off-trace during PDE can be scheduled \nin Rl to fill any empty slots, giving priority to operations from higher priority exits. The above scheduling \nalgorithm reduces the impact of PDEincurred code duplication in the following way. Fit, there is less \nconcern for code duplication in compensation code (such as in our example) because overall performance \nwill not be significantly impaired by a longer schedule of infrequently executed compensation code. With \nrespect to instruction cache locality, the compiler can use a code layout in which the compensation code \nis not included in the win- dow of locality and hence the window size for the critical paths is unchanged \nafter PDE. Second, if the code dupli-cation occurs in the hyperblock, we reduce the amount of code with \npredicated execution by keeping only a single copy of each duplicated basic block and computing its execution \nconditions as a union of the conditions for all its copies. 5 Conclusion We have presented a powerful \nPDE algorithm baaed on pr* gram slicing transformations. We have proven that no par- tially dead statements \nexist and the operation count along any program path is not increased when our PDE algorithm is applied \nto acyclic code. This is a result that existing PDE algorithms cannot achieve. In cyclic code, we elimi- \nnate deadness to the extent that the operation count along any path is not increased. Since PDE applied \nin early stages of compilation may, in fact, decrease code quality, we have proposed a method for combining \nPDE with scheduling. Based on the observa- tion that most schedulers minimize schedule length through \nsome form of partial dead code removal, our PDEbased scheduling improves upon existing hyperblock scheduling \napproaches. Our algorithm moves all partially dead state-ments off critical paths in cases where other \nPDE algorithms fail. Thus we successfully handle arbitrarily shaped regions the scheduling of which is \nbecoming more important as par- allelism available in processors increases. We have illustrated the slicing \ntransformation in the context. of PDE optimization. We believe that the slicing approach can also be \nused for other optimizations that re-quire program restructuring and movement of conditional branches. \nOur current research investigates criteria for de- termining the nature and shape of the use regions \nfor other slicing-based optimizations. Acknowledgment This research has been supported in part by a \nNational Science Foundation Presidential Young Investigator Award CC%9157371 to the University of Pittsburgh \nand a grant from Hewlett-Packard. We want to thank M.L. Soffa for her help with the preparation of the \nfinaI paper. We are grateful to S. Abraham, S. An&#38;, R. Johnson, V. Kathail, S. MahIke, B. Ramakrishna \nRau, and M. SchIansker for their helpful comments on our preliminary results. We aIso thank the anonymous \nreferees for pointing us to relevant references. References Rastislav Bodii, Rajiv Gupta, and Mary Lou \nSoffa. PI Interprocedural conditional branch elimination. SIG- PLAN Notices, 1997. Proceedings of the \nACM SIG-PLAN 97 Conference on Progmmming Language De-sign and Implementation. Preston Briggs and Keith \nD. Cooper. EfFective partial redundancy elimination. SIGPLAN Notices, 29(6):159- 170, June 1994. Proceedings \nof the ACM SIGPLAN 94 Conference on Progmmming Lunguage Design and Implementation. PI Pohua P. Chang, \nScott A. MahIke, and Wen-Mei W. Hwu. Using profile information to assist dassic code optimizations. Software-Pmctice \nand Experience, 21(12):1301-1321, December 1991. t31 Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark \nK. [41 Wegman, and F. Kenneth Zadeck. An efficient method of computing static single assignment form. \nIn 16th An- nual ACM Symposium on Principles of Pmgmmming Languages, pages 25-35, 1989. James C. Dehnert, \nPeter Y.-T. Hsu, and Joseph P. [51 Bratt . Overlapped loop support in the Cydra 5. In Proceedings of \nthe Third International Conference on Architectural Support for Programming Languages and Operating Syst,ems, \npages 26-38, Boston, Mas-sachusetts, 1989. Scott A. MahIke et al. Effective compiler support for predicated \nexecution using the hyperblock. In 25th An-nual IEEE/ACM International Symposium on Microar- chitecture, \nNovember 1992. PI Wen-mei W. Hwu et al. The superblock: An effec-tive technique for VLIW and superscalar \ncompilation. M The Journal of Supercomputing, 7( 1):229-248, January 1993. Lawrence Feigen, David KlapphoIz, \nRobert Cassazza, and Xing Xue. The revival transformation. In Con- PI ference Record of POPL 94: 21st \nACM SIGPLAN-SIGACT Symposium on Principles of Pmgmmming Languages, pages 421-434, Portland, Oregon, January \n1994. PI Joseph A. Fisher. &#38;ace scheduling: A technique for global microcode compaction. IEEE Tmnsactions \non Computers, 30(7), July 1981. PO1 Rajiv Gupta and Mary Lou Soffa. Region schedul-ing: An approach for \ndetecting and redistributing par-allelism. IEEE Tmnsactions on Software Engineering, 16(4):421431, April \n1990. WI Susan Horwitz, Alan J. Demers, and Tim Teitelbaum. An efficient general iterative algorithm \nfor dataflow analysis. Acta Informatica, 24(6):679-694, 1987. Vinod Kathail, Michael S. SchIansker, and \nB. Ramakr- ishna Rau. HPL PlayDoh architecture specification: Version 1.0. Technical Report HPG93-80, \nHewlett-Packard Laboratories, February 1994.  [121 Jens Knoop, Oliver Riithing, and Bernhard Steffen. \nPartial dead code elimination. SIGPLA N Notices, 29(6):147-158, June 1994. Pmceedings of the ACM SIGPLAN \n94 Conference on Pmgmmming Language Design and Implementation, 1131 Scott A. MahIke, William Y. Chen, \nWen-mei W. Hwu, P41 B. Ramakrishna Rau, and Michael S. Schlansker. Sen-tinel scheduling for VLIW and \nsuperscalar processors. In Proceedings of the Fifth International Conference on Architectural Support \nfor Programming Languages and Operating Systems, pages 238-247, Boston, Mas-sachusetts, 1992. bank Mueller \nand David B. WhaIIey. Avoiding con- P51 ditional branches by code replication. SIGPLAN No-tices, 30(6):56-66, \nJune 1995. Proceedings of the ACM SIGPLAN 95 Conference on Pmgmmming Language Design and Implementation. \nMichael S. SchIansker and Vinod KathaiI. Critical WI path reduction for scalar programs. In 28th Annual \nIEEE/ACM International Symposium on Micnmrchi-tecture, Ann Arbor, Michigan, November 1995. Bernhard Steffen. \nProperty oriented expansion. P71 In SAS/ALP/PLILP 96, pages 2241, Aachen (D), September 1996. Springer \nVerlag. Proc. Int. Static Analysis Symposium (SAS 96). Nancy J. Warter, Scott A. MahIke, Wen mei W. Hwu, \n P4 and B. Ramakrishna Rau. Reverse if-conversion. SIG-PLAN Notices, 28(6):290-299, June 1993. Proceedings \nof the A CM SIGPLA N 93 Conference on Programming Language Design and Implementation. Mark Weiser. Program \nslicing. IEEE Tmnsactions on WI Software Engineering, 10(4):352-357, August 1984.  \n\t\t\t", "proc_id": "258915", "abstract": "We present an approach for optimizing programs that uncovers additional opportunities for optimization of a statement by <i>predicating</i> the statement. In this paper predication algorithms for achieving partial dead code elimination (PDE) are presented. The process of predication embeds a statement in a control flow structure such that the statement is executed only if the execution follows a path along which the value computed by the statement is live. The control flow restructuring performed to achieve predication is expressed through <i>slicing transformations</i>. This approach achieves PDE that is not realizable by existing algorithms. We prove that our algorithm never increases the operation count along any path, and that for acyclic code all partially dead statements are eliminated. The slicing transformation that achieves predication introduces into the program additional conditional branches. These branches are eliminated in a branch deletion step based upon code duplication. We also show how PDE can be used by acyclic schedulers for VLIW processors to reduce critical path lengths along frequently executed paths.", "authors": [{"name": "Rastislav Bod&#237;k", "author_profile_id": "81100033082", "affiliation": "Dept. of Computer Science, University of Pittsburgh, Pittsburgh, PA", "person_id": "P239460", "email_address": "", "orcid_id": ""}, {"name": "Rajiv Gupta", "author_profile_id": "81100027751", "affiliation": "Dept. of Computer Science, University of Pittsburgh, Pittsburgh, PA", "person_id": "PP39072720", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258930", "year": "1997", "article_id": "258930", "conference": "PLDI", "title": "Partial dead code elimination using slicing transformations", "url": "http://dl.acm.org/citation.cfm?id=258930"}