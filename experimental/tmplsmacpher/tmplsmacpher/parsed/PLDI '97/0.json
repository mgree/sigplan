{"article_publication_date": "05-01-1997", "fulltext": "\n Simple Translation of Goal-Directed Evaluation Todd A. Proebsting* The University of Arizona Abstract \nThis paper presents a simple, powerful and flexible tech- nique for reasoning about and translating the \ngoal-directed evaluation of programming language constructs that either succeed (and generate sequences \nof values) or fail. The technique generalizes the Byrd Box, a well-known device for describing Prolog \nbacktracking. 1 Motivation In the current world of programming language develop- ment, an enormous amount \nof effort is going into develop- ing new ways of expressing and manipulating data values (e.g., type \ntheory, object-oriented theory, etc.) and very lit- tle effort is going towards incorporating richer \ncontrol-flow constructs into modern languages. As evidence, note that CLU-style iterators have been well-understood \nfor around 20 years [LSAS77] and yet they appear in no mainstream language. Generators (iterators) and \ngoal-directed expression eval- uation are extremely powerful control-flow mechanisms for succinctly expressing \noperations that operate over a se- quence of values. The Prolog programming language de- rives much of \nits power from goaldirected evaluation (i.e., backtracking) in combination with unification [ByrSO]. \nThe Icon programming language is an expression-oriented *AddTess: Todd A. Procbsting, Department of Computer \nScience. University of Arizona, Tucson. AZ 85721; Telephone: 5201621426; Email: todd@cs.arizona.cdu. \nhtQxHwww.cs.arizona.cdo/pcoplc/todd/ * It s a shame iterators were not adopted by the Java designers-Java \nhype seems to have rwived garbage collection and might have done the same for itcrators. Permission to \nmake digital/hard copy of part or all this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advan-tage, the copyright notice, \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission and/or a fee. PLDI 97 Las Vegas, NV, USA 0 1997 ACM 0-89791.907-6/97/0006...$3.50 \nlanguage that combines generators and goal-directed eval- uation into a powerful control-flow mechanism \n[GG83]. One possible explanation for the slow adoption of gen- erators and goal-directed evaluation into \nmainstream lan- guages may be the perceived difficulty of implementing them correctly and efficiently. \nThis papers presents a new technique for implementing goal-directed evaluation of expressions that generate \na sequence of values. The tech- nique is simple, understandable, and yields efficient code. 2 Icon Introduction \nI will use the Icon programming language as a basis for ex- plaining the new translation scheme, although \nthe transla- tion scheme is applicable to other goal-directed languages. All Icon expressions succeed \nin generating zero or more values. An expression that cannot produce any more val- uesfuils. For example, \nthe expression 1 to 5 generates the values 1,2,3,4,5, and then fails. Combining expressions with operators \nor function calls creates a compound expression that combines all subex- pression values and generates \nall possible result values prior to failing. The expression (1 to 3) * (1 to 2) generates the values \n1,2,2,4, 3.6, and then fails. Subex- pressions evaluate left-to-right-the previous sequence represents \n1 x 1,l x 2.2 x 1.2 x 2.3 x 1,3 x 2. Note that the right-hand expression is re-evaluated for each value \ngenerated by the left-hand expression. Generators may have generators as s&#38;expressions. The expression \n(1 to 2) to (2 to 3) generates 1, 2, 1, 2, 3, 2. 2, 3, and then fails. Those values are produced because \nthe outer (middle) to gener-ator is actually initiated four times: 1 to 2, 1 to 3, 2 to 2,and 2 to 3. \nIcon s expression evaluation mechanism is goal-directed. Goal-directed evaluation forces expressions \nto re-evaluate subexpressions as necessary to produce as many values as possible. To demonstrate this, \nwe in-troduce Icon s relational operator < . The < operator takes two numeric operands and returns the \nvalue of the right operand if it is greater than the value of the left, otherwise, it fails (and, therefore, \ngenerates no value). Goal-directed evaluation forces < to re-evaluate its operand expressions as necessary \nto produce values on which it will succeed. The expression 2 < (1 to 4) generates the values 3,4, and \nthen fails. Similarly, 3 < ((1 to 3) * (1 to 2)) generates 4,6, and then fails. Generators and goal-directed \nevaluation combine to cre- ate succinct programs with implicit control flow. 3 Byrd Box Like Icon, Prolog \nevaluates programs in a goal-oriented fashion. Unlike Icon, Prolog uses unification and back- tracking \nto produce a sequence of substitutions. Nonethe less, their goal-directed evaluation mechanisms are similar \nin that expressions (%alls in Prolog) are started, succeed or fail, and may be resumed. Byrd [Byr80] \nconcisely summarized the execution of Prolog clauses by describing control-flow changes be- tween pairs \nof calls via four ports:2 start The start port is the initial entry point into the eval- uation of a \nparticular call. resume The resume port is the subsequent m-entry point for all re-evaluations of a particular \ncall. fail Thefail port is the departure point from a call that has just failed. succeed The succeed \nport is the departure point for all successful satisfactions of a particular call. For each call, Byrd \nconstructed a box that consisted of these four program points. Combining the boxes in sequence models \nthe backtracking control flow between pairs of calls: CdlN calIN+ - start succeed b start succeed-+ \n--fail resume fail resume + 2Byrd called these call, redo,fail, and exit. Satisfying one call leads directly \nto the initial invocation of a subordinate call. Similarly, the failure of a call causes the re-evaluation \nof the invoking call. Finkel and Solomon [FSSQ Fin961 independently devel- oped a similar four-port model \nof control flow. They used it to describe the control flow ofpowerloops. Power loops backtrack and thus \nthe start/succeed/resume/fail model de- scribes their behavior well. Unlike Prolog, however, power loops \ncannot be described by a simple sequential connec- tion of four-port boxes. 4 New Technique The four-port \ntechnique of describing backtracking con-trol flow is the basis for my technique of describing the control \nflow of generators and goal-directed evaluation. Ibis new technique generalizes Byrd s model and allows \nthe boxes to be combined in ways that are more powerful than Byrd s simple linear model-similar in some \nrespects to the Finkel and Solomon mode1.a Unlike any previous uses of the four-port model, the new technique \ndescribes control-flow constructs that require making some of the connections between ports at run-time. \nThis translation technique is syntax-directed. For each operator in a program s abstract syntax tree \n(AST), trans- lation produces four labeled chunks of code--one for each of Byrd s ports. In addition, \neach AST operator has a cor- responding run-time temporary variable to hold the values it computes. Thus, \nthe translation will produce four code chunks for each operator, I??: &#38;start The initial code executed \nfor the entire expression rooted at 13. &#38;resume The code executed for resuming the expression rooted \nat 0. &#38;fail The code executed when the expression rooted at 0 fails. &#38;succeed The code executed \nwhen the expression rooted at e succeeds at producing a value. The specification of these code chunks \nis similar to the specification of attribute grammars, except that nothing is actually computed. Instead, \neach code chunk is specified by a simple template. The start and resume chunks are synthesized attributes. \nThe fail and succeed chunks are inherited attributes. Having both inherited and synthesized chunks allows \ncontrol to be threaded arbitrarily among an 3I learned of power loops in a class from Ruf. Hnkel in 1984 \nat the University of Wisconsin. Undoubtedly, I got the basic idea of a four-port translation scheme in \nthat class, although I thoughtI was inventing it from scratch. To the best of my knowledge, the generalizations \nof the four-port method are my own. operator and its children, which is necessary for some goal- directed \noperations. In the Byrd Box, ports are locations, whereas here they are pieces of code. The evaluation \nof some Icon operators requires addi- tional temporary variables and code chunks. 4.1 Wanslating N Possibly \nthe simplest expression to translate is a single numeric literal (e.g., 3 ). A numeric literal represents \na sequence of length one. The code for a numeric literal will immediately produce its value and exit. \nUpon resumption, it will fail. Note that the code chunks for handling success and failure are inherited \nfrom an enclosing expression, and therefore cannot be specified here. litcrrrlN k?dN start : brdN.Vahe \nt N : sot0 literalnr.succeed bdN.resm : got0 literalN.fail  4.2 lhmslating Unary Operators Mathematical \nunary operators such as negation are also easy to translate, and they give a simple idea of how suc- \nceed and fail chunks are created. Starting and resuming the negation expression requires starting and \nresuming its subexpression. Negating an expression is straightforward: for each value the subexpression \ngenerates, simply negate that value and succeed: fail when the subexpression fails. uminusf E) uminUS.Start \n: goto E.stm uminus.resume : aoto E.resume E.fail : got0 uminus.fail E.succeed : uminus.value c -E.value \n: aoto uminuasucceed 4.3 hanslating Binary Addition Binary operators introducethe first interesting \nthreading of control among the various code chunks. Translating El + E2 requires that all values of E2 \nbe produced for each value of Er and that the sums of those values be generated in order. Thus, resuming \nthe addition initiates a resumption of Es. and El is resumed when EZ fails to produce another result. \nStarting the addition expression requires that Er be started, and for each value El generates, E2 must \nbe (re- )started (not resumed). The addition fails when El can no longer produce results. The following \nspecification captures the semantics cleanly. PlU@l, JJ32) plua.start : goto El.start plusresume : goto \nEz.resume E, .fail : sot0 Plus.fail E1 .sucuxd : goto E2.start E2 .fail : goto Er.resume E2 .succeed \n: plusvalue c El .value+ E2 .value : got0 plus.succeed Unlike addition, a relational operator (e.g., \n>, =, etc.) may fail to produce a value after its subexpressions suc-ceed. When a comparison fails, it \nresumes execution of its right operand in order to have other subexpressions to compare (i.e., it is \ngoal-directed, and seeks success): L-~n(El, &#38;) LessThanstart : goto Er.start LessThauresume: got \no E2 resume EI .fail : sot 0 LeSsThan.fail E1 .succeed : goto E2.start E2.fail : goto El.resume E2.succeed \n: if (Er.v&#38;e 1 E2.vuZue) goto E2 resume : LessThanvufue c E2.vulue : got o LessThan.succeed  4.4 \nlhnslating Builtin Generators Builtin operations, like El to E2 . are equally easy to translate in this \nframework. The to generator produces every integer from El to E2 in ascending order. Further- more, it \nmust generate those values for every pair of values that El and E2 produce. The code below uses an extra \ncode chunk as well as an additional temporary variable. to(El, ~92) to.start : goto E~start toxsume : \nt0.I t t0.I + 1 : got0 to.code El .fail : got0 to.fail E; .succeed : goto E2.start E2.fail : goto Erresume \nE2.succtted : to.I t El.value : got0 toxode tomde : if (to.I > Ez.value) goto E2 resume : to.value t \nt0.I : got0 to.succeed 3  4.5 banslating Conditional Control-Flow The previous translations used direct \ngotos to connect var- ious chunks in a fixed fashion at compile time. For some operations this is not \npossible. The if expression, if El then E2 else E3 Evaluates El exactly once, simply to determine if \nit suc- ceeds or fails. If Er succeeds then the if expression generates the E2 sequence (and fails when \nE2 fails), oth- erwise the if generates the E3 sequence until failure. Translating an if statement into \nthe four-port model requires defering the if's resumption action until run- time. If El succeeds, then \nthe i f's resume action must be to resume ES. Otherwise, the if's resume action is to resume E3. This \ntranslates into an indirect got o based on a temporary value, gate. El s succeed and fail chunks set \ngate to the appropriate chunk s-ei ther Ei s or E2 s- resume label. ifstmt(E,. E2. E.71 ifstmt.start \n: goto EI.start iMmt.resume : got0 [if&#38;nt.gute] El .fail : ifstmt.gate t addrOf Ea.resume : goto \nEa.start El .succe&#38; : ifstmt.gate t addrOf Ea.resume : aoto E?.start E2 .fail : got0 ifstmt.fail \nE2 .succeed : ifstmt.value e Ez.value : cI0t 0 ifstmt.succeed Ea.fail : got0 ifstmt.fail E3.succeYA : \nifstmt.value t Ea.value : aoto ifstmt.succeed  4.6 Translating Other Operations This new four-port model \nis capable of succinctly describ- ing every type of Icon operator, including loops, condi- tionals, and \nfunction calls. Tbe previous examples include all tire necessary parts (i.e., goto's, indirect goto's, \nand simple computations) for building the code chunks. Trans- lating a function call that generates a \nsequence of values requires a mechanism for suspending and resuming afunc- tion invocation.  5 Example \nTranslation Translating Icon expressions in a syntax-directed fashion with these four-port templates \nis easy. For instance, the translation of 5 > ((1 to1 2) * (3 to2 4)) requires expanding the templates \nfor 1,2,3,4,5, *, tol, toz, and >. Figure 1 gives all of the code chunks for the nine expanded templates. \nThe example demonstrates that while the technique is simple, it suffers from generating many simple copies \nand many branches to branches. Propagating copies and elim- inating branches to branches (by branch chaining \nand re- ordering the code) optimizes the code well. Figure 2 gives the result of performing these optimizations \non the code in Figure 1. The result closely resembles code that would be produced from two generic for \nloops, which is exactly what one would hope for.  6 Related Work Independently, Byrd, and Finkel and \nSolomon developed a four-port model for describing backtracking control flow-see Section 3 for more details. \nIt is not clear if Byrd invented the four-port box for translation putposes, or for debugging purposes \n[Byr80]. It appears that Byrd used the boxes to model control flow between calls witbin a single clause, \nbut not to model the flow of control between clauses within a procedure, nor to model the control-flow \nin and out of a procedure. Finkel and Solomon used their four-port scheme to describe power loops. In \nneither case was the idea of four-ports generalized into a mechanism for describing how four pieces of \ncode might be generated and stitched together for various operators in a goal-directed language. Many \npeople have studied the translation of Icon s goal- directed evaluation. The popular Icon translation \nsystem, which translates Icon into a bytecode for interpretation, controls goal-directed evaluation by \nmaintaining a stack of generator frames that indicate, among other things, what action should be taken \nupon failure [GG86]. Special byte- codes act to manipulate this stack-by pushing,popping or modifying \ngenerator frames-to achieve the desired goal- directed behavior. The new scheme requires nothing more \npowerful than conditional, direct, and indirect jumps. O Bagy and Griswold developed a technique for \ntrans- lating Icon that utilized recursive interpreters [OG87]. The basic idea behind recursive interpreters \nfor goal-directed evaluation is that each generator that produces a value does so by recursively invoking \ntbe interpreter. Doing so preserves (suspends) the generator s state for possible resumption when the \njust-invoked interpreter re- turns. A recursively invoked interpreter s return value in-dicates whether \nthe suspended generator should resume or fail. O Bagy s interpreter executes the same bytecode as the \noriginal Icon interpreter. Recursive interpreters suffer from the overhead of recursive function calls. \nGudeman developed a goal-directed evaluation mecha- nism that uses continuation-passing to direct control \nflow Label Code Label Code 1 .start l.vulue t 1 1 .resume got0 l.fail got0 l.succeed 2.start 2.value \nt 2 2.resume got0 2.fail goto2.succeed 3.stal-t 3.value t 3 3.resume got0 3.fail sot0 3.succeed 4start \n4.value t 4 4.resume got0 4.fail goto4.succeed S.StiUt 5.value c 5 5 .resume got0 5.fail goto5.succeed \nmukstart gototol.start mult.resume got0 to2.resume to1 .fail got0 mult.fail to1 .succeed got0 toz.start \nto2 .fail got0 tol.resume to2.succeed mult.value t tol.value * to2.vulue aoto mult.succeed to1 .start \ngot0 1.stal-t to1 .resume to1.1 t to1.1+ 1 got0 tol.code l.fail got0 to1.fail 1 .succeed got0 2.stal-t \n2.fail got0 l.resume 2.succeed to1.1 t l.vulue got0 tolxode to1 .code if (t0l.b 2.vulue) got0 2.resume \ntol.vulue t tol.1 sot0 to1 .succeed to2.start got0 3.stal-t to2.resume toz.1 t to2.1+ 1 got0 to2.code \n3.faiI got 0 to2.fail 3 .succeed goto4.stal-t 4.fail got0 3.resume 4.succeed to2.1 c 3.value got0 tosxode \ntopxde i f (to2.1> 4.vulue) got 0 4.resume topdue t to2.1 aoto toa.succeed greaterdart got0 5.start greater.resume \ngot0 multxesume 5.fail got 0 greater.fail s.succeed got0 mult.start mult.fail got0 5.resume mult.succeed \nif (5.vuluel mult.vulue) got0 multxesume grfxiter.vafue c mult.vuZue got0 greater.succeed Figure 1: \nTemplates for 5 > ((1 to1 2) * (3 to2 4)) greater.start to1.1 t 1 got 0 to1 .code to1 .resume to1.1 \nt to1.1+ 1 to1 .code if (to1.I> 2) got 0 greater.fail to2.1 t 3 got0 to2.code greaterxesume to2.1 t \nto2.1+ 1 tozxode if (to2.1> 4) got0 tol.resume mult.vulue e toI. * to2.1 if (5 5 mult.value) got0 greater.resume \ngreater.value t mult.vaZue aoto meater.succeed Figure 2: Optimized Code for 5 > ((1 to1 2) * (3 to2 4)) \n5 [Gud92]. Different continuations for failure and success are maintained for each generator. While \ncontinuations can be compiled into efficient code they are notoriously difficult to understand, and few \ntarget languages directly support them. Walker developed an Icon-to-C translator, which used a mechanism \nvery similar to the interpreter s for controlling goal-directed evaluation. This translator concentrated \nits efforts on data-flow optimizations rather than control-flow optimizations. 7 Conclusion and Future \nWork These new techniques will be the basis for a new Icon compiler that will translate Icon to Java \nbytecodes. The translation of an Icon program s abstract syntax tree will be a simple expansion of its \noperators, based entirely upon templates like those given previously. After generating code naively, \ncopy propagation and branch elimination will optimize the code. This code generation method is simple \nto implement and generates efficient code. 8 Acknowledgments Saumya Debray helped debug my explanation \nof Prolog control flow-any remaining errors are certainly my fault. This research is partially supported \nby grants from IBM Corp., ATT Foundation, NSF (CCR-9502397, CCR- 9415932), and ARPA (N66001-96-C-8518, \nDABJ-63-85- C-0075). References UWW Lawrence Byrd. Understanding the control of prolog programs. Technical \nReport 151, Uni- versity of Edinburgh, 1980. [Fin961 Raphael A. Finkel. Advanced Programming Language \nDesign. Addison-Wesley Publish- ing Company, 1996. ISBN 0-8053-l 192-O. [FS80] Raphael Finkel and Marvin \nSolomon. Nested iterators and recursive backtracking. Technical Report 388, University of Wisconsin-Madison, \nJune 1980. K=831 Ralph E. Griswold and Madge T. Griswold. The Icon Prvgmmming Language. Prentice-Hall, \nInc., 1983. ISBN O-13-449777-5. W3361 Ralph E. Griswold and Madge T. Griswold. The Implementation of \nthe Icon Programming Language. Princeton University Press, 1986. ISBN O-69 l-0843 l-9. [Gud92] David \nA. Gudeman. Denotational semantics of a goal-directed language. ACM Tmnsac-tions on Programming Languages \nand Sys-tems, 14( 1):107-125, January 1992. [LSAS77] B. Liskov, A. Snyder, R. Atkinson, and C. Schaffert. \nAbstractionmechanisms in CLU. Communications of the ACM, (8):564-576, August 1977. [OG87] Janalee O \nBagy and Ralph E. Griswold. A re- cursive interpreter for the icon programming language. In Proceedings \nof the SIGPL.ANW Symposium on Interpreters and Interpretive Techniques, pages 138-149, St. Paul, Min- \nnesota, June 1987. 6   \n\t\t\t", "proc_id": "258915", "abstract": "This paper presents a simple, powerful and flexible technique for reasoning about and translating the goal-directed evaluation of programming language constructs that either succeed (and generate sequences of values) or fail. The technique generalizes the <i>Byrd Box</i>, a well-known device for describing Prolog backtracking.", "authors": [{"name": "Todd A. Proebsting", "author_profile_id": "81100592757", "affiliation": "Department of Computer Science, University of Arizona, Tucson, AZ", "person_id": "P283229", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258917", "year": "1997", "article_id": "258917", "conference": "PLDI", "title": "Simple translation of goal-directed evaluation", "url": "http://dl.acm.org/citation.cfm?id=258917"}