{"article_publication_date": "05-01-1997", "fulltext": "\n Automatic Verification of Pointer Programs using Monadic Second-Order Logic Jakob L. Jensen* Michael \nE. Jorgensen* Nils Klarlundt Michael I. Schwartzbach* * BRICS, Universit of Aarhus t AT&#38;T Research, \nK ew Jersey Abstract We present a technique for automatic verification of pointer pro-grams based on \na decision procedure for the monadic second-order logic on finite strings. We are concerned with a Ailc-fragment \nof Pascal, which in- cluded recursively-defined pointer dtmctund but excluded pointer arithmetic. We \ndefine a logic of dtowd with interesting boric predicated such ad pointer equality, tedtd for nil pointers, \nand garbage cells, ad well ad reachability along pointers. We present a complete decision procedure for \nHoare triples based on this logic over loop-free code. Combined with explicit loop invariants, the decision \nprocedure allows us to answer dur-prisingly detailed questions about small but non-trivial programs. \nIf a program jails to datidjy a certain property, then we can auto-matically supply an initial store \nthat provided a countererample. Our technique had been fully and efficiently implemented for linear linked \nlists, and it e&#38;ends in principle to tree structured. The resulting dydtem can be wed to verify e&#38;endive \nproperties of smaller pointer programs and could be particularly useful in a teaching environment. 1 \nIntroduction Background Programming with pointers is difficult and risky. This has motivated a huge body \nof work concerned with analyzing pointer programs and verifying their properties. Traditional pointer \nanalyses accept preexisting programs and provide approximate and conservative answers to a fixed collection \nof questions concerning pointer aliases, ni 1 deref- erences, dangling references, and unclaimed memory. \nWe present an approach based on a tit-order store logic in which such questions can be stated as simple \nformulas. But the store logic allows pointer analysis to be taken to a higher symbolic level, where more \ngeneral properties ex-pressed by assertions can be verified by a complete decision procedure. In this \nway, our verifier works as an oracular, symbolic debugger for pointer code. Our approach is made practical \nthrough a strong con-nection to finite state regularity: a string over a sufficiently complex store alphabet \ncan describe the shape of a collec-tion of data variables, each denoting a linear list. We also allow \npointer variables that can point into the values of data variables. Permission to make digital/hard copy \nof part or all this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for profit or commercial advan-tage, the copyright notice, the title of the publication \nand its data appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, \nto republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee. PLDI 97 Las Vegas, NV, USA 0 1997 ACM 0-89791-907-6/97/0006...$3.50 Contributions In this paper \nwe present the following results. A first-order logic of memory cella and their contents. The logic specifies \nregular (finite-state) languages of stores, and we show that it subsumes the scope of tra- ditional pointer \nanalyses. A complete decision procedure for Hoare triples u&#38; ing this logic over loopfree code without \narithmetic. For full programs our technique is of course approxi-mative, but we can in this manner clearly \ncharacterize its power. An automatic technique for generating concrete coun-terexamples whenever a program \nfails to verify. These can be used to interactively explain programming er-rors. A full implementation \nfor a u,hile-fragment of Pascal that considers linear linked lists only. However, theo-retical results \nguarantee that our approach generalizes to tree structures. A collection of small but non-trivial programs \nfor which we verify interesting properties. A sketch of a method for developing pointer programs, where \ndebugging is replaced with attempts to verify strategically placed formulas. A more abstract contribution \nis to identify and exploit an important niche of finite state regularity in programming language semantics. \nRelated Work Our work does not follow the established tradition of con- ventional heapbased pointer analysis \n[8, 9, 20, 4, 5, 19, 16, 22, 21, which develops specialized algorithms for answering specific questions \nabout preexisting programs without arm* tations. We are more general in providing a full, decidable logic \nin which one may phrase a broad range of questions, and in providing concrete counterexamples whenever \na ques- tion is answered in the negative. Also, the use of Hoare triples allows a modular analysis of \nprograms. However, we are less general in requiring programs to be explicitly annotated with formulas \nand invariants; also, the present implementation handles only list structures. Most similar in spirit \nis the ESC system [3], which also uses a restricted specification logic, requires explicit annota- tion \nwith formulas and invariants, and generates counterex-amples. A principal difference is in the questions \nthat can be phrased. We are concerned with non-arithmetic properties of pointers in the heap, whereas \nthe ESC logic includes ar-ray subscript errors and deadlocks in concurrent programs. The two approaches \nare incomparable in their ambitions. For loop-free code we provide a complete, model-theoretic BDD-based \ndecision procedure, whereas ESC relies on an incomplete theorem prover. Another recent, similar approach \ndescribes data struc-tures by shape types, which are graph grammar expres-sions [7]. Shape types can \nbe embedded in an imperative programming language, and values of shape types can be updated by rather \nelementary operations such that it can be verified that shape invariance holds automatically under certain \nrestrictions. Shape types do not rely on any dis-tinctions between data variables and pointer variables, \nbut they do seem to require rather extensive modifications of the imperative host language. In contrast, \nwe annotate Pascal programs with assertions in a formal logic, very similar to what is taught in elementary \nprogramming classes at college level. In [18] algorithms are provided that sometimes will infer when \npointers are parts of list and trees. The system LCLint [S] uses simple annotations and a fast, incomplete \ndecision procedure to detect certain dy-namic memory errors in C programs. In comparison, our technique \nis more detailed but restricted to a simpler store model. The present work is also related to reasoning \nabout pro-gram equivalence. For example, [17] provides a sound and complete proof system for a simple \nlisp-like language that manipulates memory cells. Our previous work on decidable graph transductions \n[14] describes the theoretical foundations for our current ap-proach and for several generalizations. \n2 The Pascal Subset We consider a subset of the Pascal language, which has been restricted for reasons \nof both presentation and neces-sity. First, we have chosen Pascal rather than e.g. C to reflect that \nwe cannot handle pointer arithmetic. For sim-plicity, we consider only a while-fragment; however, recur-sive \nprocedures are easily accommodated. Furthermore, our present implementation only supports lists rather \nthan trees; however, our theoretical foundations extend cleanly to tree structures. Finally, our verification \ntechnique does not con-sider integer arithmetic, and to make this approximation explicit, our language \nincludes only enumeration types as basic values. Syntax We allow exclusively declarations of enumeration \ntypes, record types with variants, and types of pointers to records. All declared variables are required \nto have pointer types. A pointer variable expression is defined as: v ::= x variable V^.n ~ pointer traversal \n A pointer value expression is defined as: P ::= v variable expression nil the nil constant A boolean \nezpression is quite restricted since we do not allow arithmetic: B ::= P1=P2 pointer equality PlOP2 pointer \ninequality v-. t=v variant test B1 and Bs conjunction B1 or Bs disjunction not B negation The collection \nof statements is fairly complete: s ::= V:=P assignment begin S end block Sl ; s2 sequence if B then \nS conditional if B then S1 else S2 conditional while B do S loop netuW,v) allocation dispose(V,v) deallocation \n We do not consider input and output explicitly; rather, we assume that values are communicated through \nthe global variables. An Example Program An example of a program in our language is the follow which \nperforms an in-situ reversal of a linked list with co - T ored elements. program reverse; type Color \n= (red,blue) ; List = -Item; Item = record case tag: Color of red,blue: (next: List) end ; vor x,y,p: \nList; begin while rOni do begin p:=x^.next; x-.next:=y; y:=x; x:-p end end. Let us illustrate the \nscope of our ambitions on this small ex- ample. With our system, we can automatically verify that the \nresulting structure is still a linked list conforming to the type List. We can also verify that no pointer \nerrors have occurred, such as dangling references or unclaimed memory cells. However, we cannot verify \nthat the resulting list con- tains the same colors in reversed order. Still, our partial verification \nwill clearly serve as a finely masked filter for many common programming errors. 3 Stores and Formulas \nStores We are interested in stores consisting of cells and pointers: The white circles are record cells, \nwhich are labeled with record types and variants. The black circles are garbage cells corresponding to \ndeallocated records. Each cell is tagged as to whether it is a record or garbage cell. The ground symbol \nis a distinguished ni 1 cell. A record cell may have an outgo- ing pointer (several, if we consider trees). \nThe named han-dles on a store are either data variables (x, y, z) or pointer variables (p). It should \nbe clear that the state of a pro-gram in our Pascal subset can be modeled as such a store, provided we \nclassify the program variables as either data or pointer variables. We are particularly interested in \nwell-formed stores, which satisfy the following properties: the record cells and their pointers form \ndisjoint lists; each data variable points either to nil or to the root of a unique list; a pointer variable \nmay point to nil or to any record cell; garbage cells have no incoming pointers; and the Pascal type \nsystem is respected. A well-formed store is easily turned into one that is not by a few program statements, \nfor example: . a data variable is set to point into the middle of a list and the prior elements are not \ndeallocated; or . a record cell is allocated, but the variable assigned its address is changed to something \nelse so that no pointer variable designates the record cell. Logic We now define a logic of storm in \nwhich one may state inter-esting properties; for example, well-formedness is a property that can be expressed \nas a formula. The logic is a first-order formalism in which terms denote cells in the store. A cell term \nis of the form: c ::= x data variable P pointer variable C .n pointer traversal nil the nil cell Q, \nP, . . . cell term variables A formula is built from basic predicates and the usual con- nectives: ip \n::= Cl = c* cell equality Cl cR> C2 routing relation -a negation 91 t @2 conjunction exa: ip existential \nquantification over cells A routing relation (introduced in [13]) is a binary relation on cells: R ..-..- \nn traverse an n-pointer (T:v)? test for type and variant nil? test for the nil cell garb? test for a \ngarbage cell RI . R2 concatenation RI + R2 union R* Kleene star The relation c<R>d holds if the regular \nlanguage denoted by R contains a sequence that leads from the cell c to the cell d and in which all pointer \ntraversals are possible and all tests are successful as they are encountered. The individual tests are \ndecided as follows: . the test (T:v) ? is true if the cell has record type T and variant v; . the test \nnil? is true if the cell is the nil cell; and . the test garb? is true if the cell is a garbage cell. \n Thus, in the following store containing a list with red and blue nodes: next $1 P the relation x<next \n.next . (List :blue)?>p is true, whereas the relation pcnext *>x is false. We allow the usual syntactic \nsugar, such as true, I, =>, <>, and all. Mhermore, the unary relation <R>c abbreviates c<R>c. Some examples \nof general formulas on stores are: if p is not red, then it can be reached from x through a number of \nnext pointers: -<(List: red)?>p => x<next*>p; no garbage cells have incoming next pointers: all c.d: \nc<next>d => <garb?>@ and no non-nil cell has two distinct incoming next pointers: all c,p,q: (cOni and \np<next>c and q<next>c) => (p=q). All of the above formulas are true for the example store. This first-order \nlogic may be extended to a monadic second- order logic which additionally allows sets of cells; however, \nthis extension is not needed for the current presentation. Note that neither version of the logic permits \nus to mention arithmetic properties, such as the lengths of lists. 4 Deciding Hoare Triples Given a loop-free \nstatement S and any two formulas @I and &#38;, we can automatically decide validity of the Hoare triple: \n(@I} S {Qz}. We define validity as follows: if we start our computation in a well-formed store (with \nsufficient available memory cells) that satisfies the precondition @I, then the ex- ecution of the statement \nS will always result in a well-formed store that satisfies the postcondition &#38;. The inclusion of \nthe well-formedness predicates is an essential technical re-quirement for our decision procedure. A simple \nexample of a valid triple is: ( x<next*>p &#38; p .next=nil } new(q,blue) ; q-.next:=nil; p .next:=q \n{ x<next*>q b q .next=nil &#38; pOq } This triple expresses that if p points to the last element of the \nlist x in a well-formed store, then the three lines of code result in a well-formed store, where q points \nto the last element in x and where p is different from q. Our logic defines the semantics of the formula \np- .next=nil such that it holds only if p- .next is well-defined and is equal to nil. The key insight \nbehind our decision procedure is to en-code a store as a string. Clearly, the effect of a loopfree program \nis then to transform one string into another. The set of stores that satisfy a given formula @ in our \nlogic can be shown to always form a regular set of strings .C(@). Further-more, formulas in the store \nlogic can be shown to be closed under the weakest precondition transformations induced by loop-free code. \nThus, our decision procedure applied to the triple {@I} S (9i2) can be roughly sketched as follows: . \ncompute the weakest precondition wp(S, 92) describing those well-formed stores that under the transformation \ninduced by S will produce well-formed stores that sat-isfy Q2; . compute a predicate allot(S) that describes \nthe num-ber of cells that S may need to allocate (this technical condition is necessary since a string \nover the store al-phabet must have enough garbage cells, which are the ones that are converted into new \nrecord cells); and s decide if JZ(@,) f~ t(aUoc(S)) c L(wp(S, a~)). There are of course subtle details \nto this approach that are not explained here; however, the formal foundations for the general case of \ntrees are presented in [14]. Encoding Stores To encode a single store as a string, we need a suitable \nal-phabet, called the store alphabet. A single alphabet symbol will consist of both a label and a bitmap. \nThe label is ei- ther nil, garb, lim, or a pair (T:v) where v is a variant of the record type T in the \ncurrent program. The bitmap indi-cates a position for each declared data variable and pointer variable. \nThe encoding of a store is now defined as follows: . the first position (and no other) is labeled nil; \ns following the first position is a sequence of encodings of the lists; . each list is encoded (in the \ndeclared order) as a sequence of cells followed by a lim symbol, where each cell is followed by its successor \nin the list; . each cell is labeled with its type and variant; . following the encodings of lists are \nthe garbage cells; . each variable occurs in exactly one bitmap; . a data variable occurs in the bitmap \nof the root of its list, or in nil if it is empty; and . a pointer variable occurs in the bitmap of \nits destina- tion. For example, the store: next X +I P is encoded as the string of six symbols: [nil,B] \n[(Liat:red),{x}] [(Liat:red),#] [(List:blue),{p}] [(List:red),@] [lint,@) and the more complicated store: \nis similarly encoded as the string of nine symbols: [nil,{y}] [(Lirt:red),{x,p}] [(List:red),{q}] [(List:red),@] \n[lim,@] Dim,@] [(List:blue),{z)] [(List:blue),@] [lim$] Encoding Formulas We claim without proof that \nthe set of well-formed stores satisfying a given formula corresponds to a regular language of string \nencodings. As an example, consider the formula x<next*>p. It corresponds to the set of strings accepted \nby the following deterministic, partial automaton: I [nil,01 [(List:?),01 We have used the symbol [(List:?),. \n. .] to indicate that a transition is possible for both colors. As indicated, even fairly simple formulas \nmay yield very complicated automata, since they make explicit alI the special cases; for example, the \nstring: [nil,{x,p)l [lim,Bl corresponds to the case where x is an empty list, and the string: [nil,(p)] \n[(List:red),{x}] [lim,g] to the case where x is a red singleton list and p points to the final nil cell. \n Deciding Triples We claim, again without proof, that the wptransformer and the alloopredicate are computable, \nLet us illustrate with an example baaed on the supposedly valid triple: ( x<next*>p 0 p^.next.-nil } \n new (q,blue) ; q .next:=nil; p^.next:=q { x<next*>q b q .next-nil t p<>q } The precondition formula \ndescribes the stores accepted by the automaton APE: [(list:?) ,Ol CfList:?) .{x,p)l The olloc-predicate \nrequires at least one available garbage cell and corresponds to the automaton Aolloc: [(lirt:?) 01 L \n The weakest precondition is calculated by the technique of tmnaduction, where the postcondition is syntactically \ntrans-formed according to the effect of the program statements. In this technique aII basic relationships, \nsuch as the succes-sor relation between cells, are accounted for in a predicate after each program statement. \nThe effect of a statement is to transform this collection of predicates. The resulting collection is \nthen used to rewrite the postcondition (and the well-formedness formula), where each reference to a basic \nre- lationship is replaced by the corresponding IinaI transformed predicate. For this particular example, \na rather large for-mula results; but it will be equivalent to: x<next*>p It (ex g: <garb?>g) &#38; pa \n.next=nil which corresponds to the automaton Aup: C(limt:?).Ol I I C(Limt:I).{x.p)l A simple computation \nwill now confirm that AprenA A, (for this trivial case they are in fact equal). It i-w o ows that the \ntriple is indeed valid. For general programs this task is quite intricate, since it is also necessary \nto consider the effects of conditionals and possible type errors and run-time errors. A full version \nof this paper will contain further details of the predicate transformation.  5 Verifying Programs Our \ndecision procedure can clearly be used to answer all possible questions about a loop-free program that \ncan be phrased in our logic. This provides a very general tool for analyzing such programs, since it \nis not limited to answering single, fixed questions such as the absence of dangling refer- ences or unclaimed \nmemory cells. It demonstrates that such programs can be completely understood as transformations on regular \nsets. Using Invariants Most interesting programs contain loops. For these we can verify the same class \nof properties as for loop-free programs, provided we can phrase loop invariants in our logic. Our decision \nprocedure is then not entirely automatic, nor is it complete since it is well-known that a true property \nof a loop cannot necessarily be proven by an invariant. In practice, however, it is quite easy to phrase \nuseful invariants in our logic. Let us recapitulate the required proof technique for loops. To verify \nthe triple {@I} tiile B do S {&#38;} we phrase a loop invariant Z and prove validity of the formula @I \n=+ I, the triple {I t B} S {I}, and the formula Z L B + &#38;. The generation and verification of these \nthree sub-goals is handled automatically by our decision procedure, when the invariant has been given \nAs a default, our system uses the well-formedness pred-icate for the invariant. In many cases, this turns \nout to be sufficient. Examples We now show a number of example programs that are suc-cessfulIy verified \nby our decision procedure. They are ordi-nary Pascal programs, except that we annotate them with occasional \nformulas and classify the declared variables as data or pointer variables. In each case we verify that \nthe resulting store is well-formed. This guarantees that we en- counter no run-time errors, and that \nwe leave no dangling references or unclaimed memory cells. In some case8, we Use the power of our logic \nto verify further properties. The first example is the program that reverses a list. program rmreree; \ntype Color = (red,blue); List = Item; Itom = record case tag: Color oj red,blue: (next: List) end ; \n{data}vo+ x,y: List; (pointor}var p: List; begin {ymil} while xOni1 do begin p:=x^.next; x .next:Py; \ny:=x; x:-p end {x=nil} end. This program is particularly welLsuited for our analysis, since we do not \nneed to specify an invariant beyond the implicit well-formedness formuka. After the loop, we are assured \nthat x is empty; also, since the well-formedness con- dition is implicit in all assertions, we are assured \nthat y contains a list. The next program performs a cyclic rotation of a list x where p points to the \nlast element. We omit the type declarations which are the same in all our examples. progroa rotate; (data}vor \nx: List; {pointer}vor p: List; begin (x<next+>p &#38; (rOni =* p*.nextmil)} if xOnil then begin p .next:-x; \nr:*x .next; p:-p .next; p^.next:=niZ end {x<next*>p &#38; (xOni1 -> p .next=nil)}  end. Note how the \nprecondition is used to specify the assumptions under which the program works. The postcondition assures \nthat this data type invariant is preserved by the operation. The following p .zrun inserts a red node. \ninto a possibly empty list x (cychc y) after the positron m&#38;cated by p, taking care of all the special \ncases. program insert; {data}ver x: List; {pointer}vor p,q: List; begin (x<next+>p a (x-nil <=> p-nil)) \nif ponil then begin i/ p .next=nil then begin q:=x-next; new (p,red) ; x .next:=p end else begin q:-p \n.next; new (p .next ,red) ; p:=p-.next end else q:=nil ; neu(p,red); x:-p end ; p .next:-q end. We \nnow dually consider a program that deletes the node after p. program delete; {data}vot x: List; {pointor}vor \np,q: List; begin {x<next+>p i (x-nil <-> p-nil)} ij pOnil then begin if p-. next=nil then begin q:=x \n.next. ij x .tag= red then dispose (x,red) else dispose (x,blue); x:-q end else begin q:-p-.next .next; \nij r .t.ag-red then dispose (x,red) else dispose (x,blue); p .next:-q end end {p<>nil -> (ex q: *garb?>q \n&#38; (all r: <garb?>r -> r-q)) &#38; p-nil -> (ox q: <garb?>q) 1 end. The postcondition verifies that \nif the list was not empty, then exactly one record has been deallocated; if the list was empty, then \nno deallocation took place. We now turn our attention to a program that searches for the first occurrence \nof a blue node in a list. program search ; {data}vor x: List; {pointer}vsr p: List; begin p:=x; while \npC>niL and p .tag<>blae do {x<next+>p a (all q: (xCnext+>q t q<nexte>p) => <(List:red)?>q)} p:-p .next \nend {x<next*>p 1: (p-nil I C(List:bloo)?>p) 8 (all q: (x<next=>q &#38; q<next.next+>p) *> <(List:red)?>q) \n 1 end. To merely verify we&#38;formedness, we do not have to specify an explicit invariant. However, \nby providing a rich invariant we can automatically verify the behavior of this program which is expressed \nby the postcondition: to find the first blue node if one exists. This illustrates that we can verify \nproperties well beyond standard pointer analyses. The final program zips two lists into one, by performing \na strict shuffle of their elements and appending the tail of the longer list. program zip ; {data}var \nx,y,x: List; {pointer}vor p.t: List; begin i/ x-nil then begin t:=x; x:-y; y:=t end ; x:-nil ; p:-nil \n; ahile xOni1 do {(x-nil => y-nil) t r<nexte>p &#38; W>nil -> p .nextail)} begin ij z=nil then begin \n 2:=x; p:=x; end else begin p-.next:=x; p: =p-. next end ; x:=x .next; p .next:=nil; if y<>nil then \nbegin t:=x; x:=y; y:=t end end end. For this example we need a seemingly involved invariant to establish \nwell-formedness. However, it merely states that x is only empty if y is empty, and that p points to the \nlast element of z. Examples of Non-veriflable Programs We next turn our attention to faulty programs \nthat cannot be verified. Consider first the reverse nronram in which we perform a likely mistake by accident&#38;y-switching \nthe second and third program line in the loop body. program fumble; {data)vclr x,y: List; (pointer}vor \np: List; begin {y-nil} uhilc xChi2 do begin p:=x .next; y:=x; (* line 3 ............ line ) (* 2 . \nx:=p end {xmil} end. The program is clearly no longer correct, which our deci-sion procedure detects \nsince it is not the case that &#38;(@I) n r(alioc(S)) E C(wp(S,&#38;)). Significantly, we may ndw Ob-tain \nmore information besides this bare fact, since the set (C(@,) n c(oiioc(S))) \\ L(wp(S, Qp)) is also g \n(non-empty) regular language from which we can automatically extract a shortest string. For the fable \nprogram such a string is: [nil,(p)] [(List:red)$] [lim,@]Pim,0] which corresponds to a particular store: \nP next x n II + Y- This initial store is a concrete counterexample on which the program will expose \nits faulty behavior. We may simulate the program on this store, and after the first iteration we see \nthe error: P x B  next i=b Y We envision a tool in which a programming error will gen-erate and play \na small cartoon of store modifications that explains the faulty behavior. As another example, consider \na program that swaps the !irst two elements of a list. program swap; {data}vor x: List; {pointer}vot \np: List; begin if xonil then begin p:=x; x:=x-.next; p .next:=x-.next; x .next:=p end end. The program \nis essentially correct, except that it fails by dereferencing a nil-pointer in the special case of a \nlist of length one. Correspondingly, our decision procedure re-sponds with the string: [nil,(p)] [(List:red)$] \n[lim$] which corresponds to a store containing a list of length one. To confirm the hypothesis that this \nis the only fatal case, we may introduce the precondition Cx-.next<>nilI and then successfully verify \nthe program.  6 Implementation An implementation of our decision procedure needs to: . compute and \nrepresent the regular set of stores that satisfy a given formula; . compute the predicate transformer \ncup and the predi-cate alloc; and . decide properties of regular sets. We have a unifying framework \nfor expressing all these tasks. Using Monadic Second-Order Logic Our implementation is based on the \nmonadic second-order logic on finite strings (M2L), which is an inordinately suc-cinct notation for specifying \nregular sets [21]. It uses for-mulas similar to but more general than those of our store logic. It turns \nout to be a straightforward task to inductively translate formulas of our store logic into equivalent \nformu-las of M2L. The regular set is then represented by an M2L formula. Also wp and allot are elegantly \ncaptured through formu-las in M2L, where the effect of each program line is simu-lated with all the appropriate \ntype and run-time tests. The formulas look vaguely like the code for an interpreter. Finally, all the \nrequired properties of regular sets corre-spond to simple connectives in M2L; for example, set inclu-sion \nis implication of the representing formulas. The net effect is to produce a (possibly huge) M2L for- \n mula whose validity coincides with validity of the given triple. Using Fido and Mona The M2L approach \nis fruitful because of the Fido and Mona tools that implement this logic for finite strings and trees \n[lo, 151. Mona is an engine that reduces an M2L formula to an equivalent finite state automaton. Fido \nis a high-level specification notation that generates primitive Mona formulas. The implementation of \nMona is feasible because of a spe- cial representation of automata, where transition functions are encoded \nas binary decision diagrams [l] (BDDs). Cor-responding to this representation, specialized algorithms \nfor the basic automata operations have been developed. As a re- sult, Mona may efficiently reduce automata \nwith very large alphabets, such as those we encounter in our application. The implementation of our decision \nprocedure is a pipeline: from the annotated Pascal program we gener-ate a Fido specification, which is \ntranslated into a volu-minous Mona formula, which is then reduced to a finite state automaton. A complete \ndocumentation of the ex-ample programs, including the Fido and Mona formulas that are generated by the \ndecision procedure, is available athttp://uvv.brics.dk/-mis/pointers/. Complexity The theoretical worst-case \ncomplexity of our decision proce- dure is non-elementary, i.e. not bounded by any finite stack of exponentials. \nThis lower bound is inherited from M2L. Fortunately, the worst-case scenario hinges on the use of complex \nformulas, which are not likely to occur in practice. Using the current implementation of the Fido and \nMona tools, we obtain the following statistics for our example pro- grams. The time is measured on a \nSparcServer 1000; the size of the formula is that of the raw Mona input; and for the largest automaton \nencountered during the Mona reduction we give the number of states and the number of BDD-nodes in the \nrepresentation of its transition function. I Program I Time I Formula I States I Nodes I I I These measurements \nare merely intended to give a rough idea of the complexities of the verification problems. Note how seemingly \ninnocuous pointer manipulations are revealed to possess large state spaces when all possible executions \nand special cases are considered. The times reported here are for an implementation of Mona in ML running \non a Spare 1QOO. With another BDD-package developed at the University of Aarhus and a more modern machine, \nthe run-ning times would likely be ten times faster [12]. Also, the calculations of the weakest preconditions \ncan be sped up, sometimes several hundred times, on the examples consid-ered here [ll]. 7 Conclusions \nWe have demonstrated that small programs in our Pascal subset can be verified with great accuracy. Our \ndecision procedure exploits a new approach to pointer analysis by modeling stores as strings and reducing \nthe problem to va-lidity of formulas in monadic second-order logic. Our use of a decidable specification \nlogic for properties of stores with pointers may also be of independent interest. How may we use and \nextend this technique? We present the answers to a number of pertinent questions. Can we include trees? \nThe well-formedness requirement insists on disjoint lists. However, our decision procedure is based on \nencoding stores as finite strings for which the monadic second-order logic is decidable. While we cannot \nencode trees in this string logic, we could in principle use the fact that also the monadic second-order \nlogic of trees is decidable. Thus restricted Pascal programs manipulat-ing trees as the values of recursive \ndata types are in theory amenable to the analyses presented in this paper. Our pre- liminary experiments \nwith a decision procedure for monadic second-order on trees show that it is much more computa-tionally \nintensive than the string version. Thus it is an open question whether our analysis can be made to work \nfor trees in practice. Can we go beyond trees? Some extensions are possible, specifically along the lines \nof graph types [13], which include doubly-linked and cyclic structures. However, this extension requires \nan invasive modification of the Pascal syntax. Also, there are clear limitations; for example, on grid \nstructures the store logic is no longer decidable. What about modularity? It is very easy to perform \na modular analysis of programs if the interface between two code fragments can be specified as an intermediate \nformula. In this case, a triple breaks into two smaller triples. What about real progmms? We have restricted \nthe al-lowed syntax in several ways. However, the only non-trivial one is the exclusion of integers and \narithmetic. Our deci-sion procedure will never be complete for arithmetic, but a canonical approximative \nanalysis may be performed by ab- stracting the type of integers into a singleton enumeration type, or \neven into a finite range with modulo arithmetic. Where will this be used? It is unlikely that our tech-nique \nwill verify a huge, preexisting program. However, when implementing an abstract data type for a library, \nit should be possible to state the required invariants to obtain an automatic verification of the operations. \nAlso, our tool seems ideal for a teaching environment, since it encourages formal reasoning and provides \ncounterexamples for faulty programs. References Randal E. Bryant. Graph-based algorithms for Boolean \nfunction manipulation. IEEE Tmnsactions on Comput- ers, August 1986. 111 PI Michael Burke, Paul Carini, \nJong-Deok Choi, and Michael Hind. Flow-insensitive inter-procedural alias analysis in the presence of \npointers. In of the 7th In- ternational on Languages and Compilers for Pamllel Computing, number 892 \nin Lecture Notes in Computer Science, August 1994. David L. Detlefs. An overview of the Extended Static \nChecking system. In Proceedings of The First Work-shop on Formal Method8 in Software Practice. ACM SIGSOFT, \nJanuary 1996. 131 [4] AIain Deutsch. Inter-procedural may-alias analysis for pointers: Beyond k-limiting. \nIn of the ACM SIGPLA N 94 on Progmmming Language Design and Implemen-tation, June 1994. [5] AIain Deutsch. \nSemantic models and abstract in-terpretation techniques for inductive data structures and pointers. In \nof the ACM SIGPLAN on Partial Evaluation and Semantics-Based Progmm Manipula-tion (PEPM), June 1995. \n[S] David Evans, John Guttag, Jim Horning, and Yang Meng Tan. LCLint: A tool for using specifica- tions \nto check code. In Proceedings of Symposium on the Foundations of Software Engineering. ACM SIG-SOFT, \nDecember 1994. [7] Pascal I+adet and Daniel Le Metayer. Shape types. In Proc. 24th Symp. on Print. of \nProg. Lang., pages 27-37. ACM, 1997. [S] Rakesh Ghiya and Laurie J. Hendren. Is it a Tree, a DAG, or \na Cyclic Graph? A shape analysis for heap directed pointers in C. In the 23rd ACM SIGPLAN-SIGACT on Principles \nof Programming Languages, January 1996. [9] Laurie J . Her&#38;en and Alexan~ Nicolau. ParaUeIizing programs \nwith recursive data structures. IEEE TPDS, 1(1):35-47, January 1990. [lo] Jesper GuImann Henriksen, Michael \nJorgensen, Jakob Jensen, Nils KIarhmd, Bob Paige, Theis Rauhe, and Anders Sandholm. Mona: Monadic second-order \nlogic in practice. In Proceedings TACAS 95, LNCS lUl9, May 1995. [ll] Jakob Jensen and Michael Jorgensen. \nM.sc. thesis. 1996. [12] N Klarhmd and T. Rauhe. Bdd algorithms and cache misses. Technical report, BRICS \nReport Series RS-Q65, Department of Computer Science, University of Aarhus, 1996. [13] NiIs Klarlund \nand Michael I. Schwartzbach. Graph types. In the Twentieth Annual ACM SIGPLAN-SIGA CT on Principles of \nProgmm-ming Languages, January 1993. Available through http://vw.brics.dk/~klarlund/llonaFido/papers. \n[14] Nils KIarl und and Michael I. Schwartzbach. Graphs and decidable transductions based on edge constraints. \nIn Proc. CAAP 94 (TAPSOFT), 1994. [15] Nils KIarhmd and Michael I. Schwartzbach. Regularity = Logic + \nRecursive Data Types. BRICS, University of Aarhus, October 1996. [16] William Landi and Barbara G. Ryder. \nA safe approxi- mate algorithm for interprocedural pointer abasing. In of the ACM SIGPLAN 92 on Progmmming \nLanguage Design and Implementation, June 1992. [17] Ian Mason and Carolyn Talcott. Inferring the equiva- \nlence of functional programs that mutate data. Theo-retical Computer Science, 105:167-215, 1992. [18] \nAki Matsumoto, D.S. Han, and Takao Tsuda. Alias analysis of pointers in Pascal and Fortran 90: depen-dence \nanalysis between pointer references. Acta Infor-matica, 33:99-130, 1996. [19] John Plevyak, Andrew A. \nChien, and Vijay Karam-cheti. Analysis of dynamic structures for efficient par- ahel execution. In of \nthe 6th International on Languages and Compilers for Pamllel Computing, number 768 in Lecture Notes in \nComputer Science, August 1993. [20] Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. Solving shape-analysis \nproblems in languages with de- structive updating. In the 23r-d ACM SIGPLAN- SIGACT on Principles of \nProgramming Languages, January 1996. [21] Wolfgang Thomas. Automata on infinite objects. In J. van Leeuwen, \neditor, Handbook of Theoretical Computer Science, volume B, pages 133-191. MIT Press/EIsevier, 1990. \n[22] Robert P. Wilson and Monica S. Lam. Efficient context- sensitive pointer analysis for C programs. \nIn of the ACM SIGPLA N 95 on Progmmming Language Design and Implementation, June 1995. \n\t\t\t", "proc_id": "258915", "abstract": "We present a technique for automatic verification of pointer programs based on a decision procedure for the monadic second-order logic on finite strings.We are concerned with a while-fragment of Pascal, which includes recursively-defined pointer structures but excludes pointer arithmetic.We define a logic of stores with interesting basic predicates such as pointer equality, tests for nil pointers, and garbage cells, as well as reachability along pointers.We present a complete decision procedure for Hoare triples based on this logic over loop-free code. Combined with explicit loop invariants, the decision procedure allows us to answer surprisingly detailed questions about small but non-trivial programs. If a program fails to satisfy a certain property, then we can automatically supply an initial store that provides a counterexample.Our technique had been fully and efficiently implemented for linear linked lists, and it extends in principle to tree structures. The resulting system can be used to verify extensive properties of smaller pointer programs and could be particularly useful in a teaching environment.", "authors": [{"name": "Jakob L. Jensen", "author_profile_id": "81332506666", "affiliation": "BRICS, Universit of Aarhus", "person_id": "PP31083044", "email_address": "", "orcid_id": ""}, {"name": "Michael E. J&#248;rgensen", "author_profile_id": "81332507430", "affiliation": "BRICS, Universit of Aarhus", "person_id": "PP31081631", "email_address": "", "orcid_id": ""}, {"name": "Michael I. Schwartzbach", "author_profile_id": "81392609511", "affiliation": "BRICS, Universit of Aarhus", "person_id": "P198767", "email_address": "", "orcid_id": ""}, {"name": "Nils Klarlund", "author_profile_id": "81100072411", "affiliation": "AT&T Research, New Jersey", "person_id": "PP39025867", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258936", "year": "1997", "article_id": "258936", "conference": "PLDI", "title": "Automatic verification of pointer programs using monadic second-order logic", "url": "http://dl.acm.org/citation.cfm?id=258936"}