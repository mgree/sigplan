{"article_publication_date": "05-01-1997", "fulltext": "\n Call-Cost Directed Register Allocation Guei-Yuan Lueh and Thomas Gross School of Computer Science Carnegie \nMellon University Pittsburgh, PA 15213 Abstract Choosing the right kind of register for a live range \nplays a major role in eliminating the register-allocation overhead when the compiled function is frequently \nexecuted or func- tion tails are on the most frequently executed paths. Pick-ing the wrong kind of register \nfor a live range incurs a high penalty that may dominate the total overhead of reg- ister allocation. \nIn this paper, we present three improve-ments, storage-class analysis, benefit-driven simplification, \nand preference decision that are effective in selecting the right kind of register for a live range. \nThen we compare an enhanced Chaitin-style register allocator (with these three improvements) with priority-based \nand optimistic coloring. 1 Introduction Graph coloring is a common approach to model register allo- \ncation. A register allocator assigns registers (colors) to live ranges in such a manner that conflicling \nlive ranges -i.e., live ranges that are simultaneously live in the program -are kept in different registers. \nThe compiler constructs an inter- ference graph whose nodes represents live ranges and whose edges connect \nlive ranges that conflict. This graph captures the information about conflicts between live ranges. The \nregister allocator attempts to find a legal N-coloring of the graph, where N is the number of physical \nregisters. Chaitin s algorithm consists of two major phases, sim-plification and color assignment. Simplification \nis based on the observation that if a vertex V has degree < N, then the color-assignment phase guarantees \nto find a color for V, be-cause at least one legal color remains regardless what colors are assigned \nto V s neighbors [7]. This process of removing Effort sponsored by the Advanced Research Projects Agency \nand Rome Laboratory, Air Force Materiel Command, USAF, under agree- ment number F30802-96-1-0287. The \nU.S. Government is autho-rized to reproduce and distribute reprints for Governmental purposes notwithstanding \nany copyright annotation thereon. The views and conclusions contained herein are those of the authors \nand should not be interpreted as necessarily representing the official policies or endorsements, either \nexpressed or implied, of the Advanced Research Projects Agency, Rome Laboratory, or the U.S. Govern-ment. \n Permission to make digital/hard copy of part or all this work for personal or classroom use is granted \nwithout fee provided that copies are not made or distributed for profit or commercial advan- tage, the \ncopyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee PLDI 97 Las Vegas, NV, USA  @ 1997 ACM 0-89791-907.6/97/0006...S3.50 \nunconstrained live ranges from the graph, i.e., vertices that have degree less than N, is called simplification. \nSimplifi-cation blocks when all live ranges of the graph have degree 2 N. In this case, a live range \nis picked to spill, i.e. the corresponding node and all its edges are removed from the graph, until simplification \ncan proceed further. The choice of live range depends on some heuristic estimate of the cost of moving \nthis live range to memory. Simplification termi-nates when an empty graph is obtained. Color assignment \nfollows the simplification phase and picks physical registers for live ranges. It assigns colors to the \nlive ranges in the reverse order in which the live ranges were removed during simplification. Chaitin \ns al-gorithm provides a conceptually simple way to pack live ranges into registers; it forms the basis \nof many practical register allocators. However, this algorithm (or optimistic coloring [4]) does not \naddress how to deal with an important aspect of compilation, the calling convention. In this paper, we \ndiscuss how to deal with this aspect and also provide an empirical evaluation (including an evaluation \nof optimistic and priority-based coloring). All performance data have been gathered with the cmcc optimizing \nC compiler [l]. In Section 2, we briefly review the register allocation framework of this compiler, to \nlay the foundation for a comparison of various coloring approaches. Then we introduce three improvements \n(Sections 4 -6). Sec-tion 8 contrasts the effect of these improvements with opti- mistic coloring. In \nSection 9 we discuss the relationship to priority-based coloring. Finally, Section 10 compares these \nimprovements to coloring to another extension of Chaitin- style coloring which has been adopted by other \ncompilers.  2 Register allocation framework Our goal is to compare different approaches to register \nallo-cation. It is difficult and impractical to implement and ex- periment with different register-allocation \napproaches with-out a register-allocation framework. A framework fosters code reuse, emphasizes the common \nstructure, and facili-tates a fair comparison. That is, if an improvement is added to some parts of register \nallocation (e.g., the construction of the interference graph) then ail register allocators can ben-efit \nfrom the improvement. We briefly summarize our framework for register alloca-tion [l]; there are these \nphases: graph construction, live-range coalescing, color ordering, color assignment, graph re- Reconsiruclicm \n Figure 1: Structure of the register allocator. construction , spill-code insertion, and shufle-code \ninsertion (as illustrated by Figure 1). This register-allocation struc- ture allows us to model a wide \nrange of register allocation approaches. The graph-construction phase builds the inter- ference graph \nfor the input instruction sequence. The co- alescing phase eliminates copy instructions that move data \nvalues between two non-conflicting live ranges. The color- ordering phase heuristically determines the \norder in which live ranges are to be assigned colors. The color-assignment phase assigns colors to live \nranges based on the ordering computed by the previous phase; this phase uses the inter- ference graph \nto make sure that conflicting live ranges are assigned different colors. If either of the color-ordering \nor color-assignment phases spills a live range, the register allo- cator rebuilds the interference graph \nand restarts from the coalescing phase. Our register allocator reserves no registers for spill code; \nthat is, the register space is not divided into local and global registers. Spill code and shuffle code \nare inserted into the final schedule by the last two phases. Shuffle code moves a data value between \nthe different storage locations assigned to a split live range. There are data structures that are used \nas the interface between the color-ordering and color-assignment phases: the color stack (C), and the \nspill pool (S). The color-ordering phase determines the order in which live ranges are assigned colors \nand pushes live ranges onto C based on the order-ing -the higher the position within C, the more freedom \nin choosing registers in the color-assignment phase. The color-assignment phase pops live ranges from \nC and finds legal (i.e., non-conflicting) colors for them. S keeps spilled live ranges. If the color-ordering \nphase decides to spill live ranges, or the color-assignment phase fails to find legal col- ors for live \nranges, those spilled live ranges are added to S. Table 1 shows how the register allocation framework \ncan model various register-allocation approaches. Chaitin-style [7], priority-baaed [S] 2 and optimistic \ncoloring [4] construct the interference graph for a function. Fusion-style coloring [13] identifies regions, \nconstructs the interference graph for each region, and then fuses graphs together to get the interference \ngraph of the function. Several strategies have been proposed to improve spilling heuristics [17, 2, 51 \nor to split live ranges to reduce spill cost [8, 6, 17, 16, 11, 15, 121. Other approaches have also attempted \nto reduce call cost intra-procedurally [8,9, 181 or inter-procedurally [21, 9, 20, 191; however these \napproaches are complimentary to the work presented here. Graph reconstructionmodifies the existing interference \ngraph in-stead of rebuilding it from scratch. This step improves compilation time. The priority-based \ncoloring that we implement is Chow s priority- based coloring without live range splitting. The influence \nof live range splitting on register overhead operations is beyond the scope of this paper; see [13] for \ndetails. Register allocation Phases ChatIn- Pnorlty- Optlmwtlc Fusron- style based style Graph function \nfunction function region construction (spill+split) Graoh X X X X I rec&#38;struction I I I I I Table \n1: Different register-allocation approaches using the framework of Figure 1. 3 Cost model for register \nallocation Our basic machine model is a RISC processor that requires that the operands of all operations \nreside in registers. (All our measurements are done for the MIPS architecture.) The register allocation \ncost includes all overhead operations that move operands in and out of a register; thii cost includes, \ne.g., also overhead operations that move values from one reg- ister to another. That is, we compare the \nresults of a register allocator against a perfect allocation with unbounded regis-ters. The higher the \ncost (for a fixed number of registers), the worse the register allocator has performed. The register \nallocation cost is the sum of three compo-nents: (i) spill cost (to move a value to and from memory; \nno register has been assigned to this value), (ii) call cost (to free up/restore registers upon procedure \nentry/exit), and (iii) shuflle cost (moving a value from one live range to an-other). Register allocation \ncost must include the call cost. If the register allocator focuses on the spill cost alone, the evalua- \ntion of the register allocator may be overly optimistic, as we discuss in the next section. The call \ncost, however, is influ- enced by the compiler s calling convention. Many compilers divide the registers \ninto two sets, callee-save and caller-save registers, respectively. 3.1 Chaitin-style base model Chaitin-style \ncoloring simplifies the interference graph to de- termine the coloring order and spills live ranges baaed \non spill cost (either static estimated or dynamic spill cost) when simplification blocks. A live range \nthat contains (no) calls prefers using callee-save (caller-save) registers, so the color- assignment \nphase attempts to find a callee-save (caller-save) register. If there is no callee-save (caller-save) \nregister left (taken by all the live range s neighbors), a legal caller-save (callee-save) register is \nassigned to the live range. This simple model is used as the base for comparison. It allows us to assess \nthe significance of each improvement in terms of reducing overall overhead operations. Although the base \nmodel is simple, it is not unreasonable. In Section 10, we compare this base model to a more sophisticated \nap-proach to handle call cost which is implemented in various compilers. However, for a significant number \nexperiments, the simple base model outperforms the other approach.  3.2 Limitations of the base model \nFigure 2 depicts the register allocation cost for two pro-grams from the SPEC92 suite, eqntott and ear, \nfor various combinations of caller-save and callee-save registers. The MIPS architecture has separate \nregister banks for integer and floating-point values. The notation (R;,Rf,E;,Ef) of the x-axis of Figure \n2 shows the combination of caller-save and callee-save registers for the two register banks. R; and Rf \nare the number of caller-save registers for integer and floating-point values, respectively. E; and EJ \nare the num-ber of callee-save registers for integer and floating-point val-ues. The standard calling \nconvention of the MIPS machine uses 4 registers of the integer bank to pass arguments, and 2 registers \nto pass function-return values. In addition, 2 floating-point registers pass arguments and 2 floating-point \nregisters can hold a function-return value. All these regis- ters are caller-save registers. Hence, the \nregister allocator uses at least (6,4,0,0). From Figure 2, we see that giving the register allocator \nmore registers can reduce the spill cost dramatically. The spill cost is cut down to 0.8 % with (10,8,4,4) \nregisters for eqntott and to 0.5 % with (9,7,3,3) registers for ear. How-ever, simply focusing on the \nspill cost is misleading; the figure shows that the spill cost is no longer an issue once a certain number \nof registers is available. As the figure illus- trates, we must take the call cost (caller-save and callee-save \ncost) into consideration. There are two noteworthy aspects: first, the contribution of the call cost \nto total register alloca- tion cost is significant. Second, giving the register allocator more registers \nmay actually worsen the register allocation cost because some live ranges may now reside in the regis- \nters whose call overheads introduce more memory accesses than the spill cost of the live ranges. Cohn \nand Lowney [lo] measured the dynamic call cost for various Windows/NT applications and SPEC programs. \nFor more than half of the programs, the call cost is 10% -25% of their execution time. If the register \nallocation does not take the call cost into consideration, the call overhead introduced by the register \nallocation may end up on the hot part of the program [lo]. 4 Storage-class analysis A live range can \nreside in one of these storage classes (assum- ing that registers are divided into caller-save and callee-save \nregisters): 0 memory, 0 a caller-save register, or 0 a callee-save register. Each storage class has an \nassociated cost. Storage-class analysis decides where live ranges reside baaed on two func- tions, benefit-caller \nand benefitxnllee. The two functions model the benefits provided by these two storage classes over the \ndefault location (memory). These functions are de- fined for each live range IT-. For each IF, benefit-caller(lr) \n(resp. benefit-callee(lr)) is delined as the weighted refer-ence counts of the spill code minus the weighted \ncaller-save (resp. callee-save) cost. The weighted reference counts and call cost are derived using either \nestimated execution fre-quency or profiling information. (In this paper, static refers to the use of \nstatic execution estimates, and dy-namic means use of profiles.) These two functions benefit--coller(ir) \nand benef Lcallee(lr) indicate the estimated num-ber of load/store operations that are eliminated if \na caller- save (or callee-save) register is assigned to IF. They are similar to the priority function \nof [8], except the benefits are not normalized by the size of the live ranges. During the color-assignment \nphase, the selection of the kind of register to use is based on these two functions. If benef it-cnllee(lr) \n> bene f it-caller(lr), finding an available &#38;lee-save register for lr is attempted prior to finding \nan available caller-save register. If bene f it-callee(lr) 5 benefit--caller(lr), it is preferable to \nput IF into a cnller-save register over using a callee-save register. The accuracy of the two benefit \nfunctions depends on the accuracy of the estimated execution frequency. The simplification phase guarantees \nthat the color-assign- ment phase finds registers for live ranges on C. However, sometimes not using \na register (i.e., spilling a live range) is better than using the wrong kind of register because the \ncost of using the register (Cal&#38;-save or caller-save cost) could be greater than the spill cost of \nthe live range. Our algorithm models register assignment as a possible improvement. That is, we start \nout with the assumption that a live range resides in memory (is spilled) and then try to determine if \nallocating a register reduces the over-head operations. This model allows us to spill live ranges to \nreduce the overall number of load/store operations even though there are available registers. The two \nbenefit func- tions give us a good indication if a live range IF is a worth- while candidate for register \nresidence. If IF gets a caller-save register and benefit-caller(lr) < 0, then spilling IF reduces load/store \ncounts by 1 benefit-caller(lr) 1. While assigning registers to live ranges, the color-assign- ment phase \nmakes spilling decisions right away for the live ranges that are supposed to get caller-save registers \n(i.e., spill when benefit-caller(lr) < 0). There are two ways to make spilling decisions for live ranges \nthat receive callee-save registers. The first approach models callee-save cost as oc- curring only once \nfor each callee-save register. For the first live range IF that uses a given callee-save register, making \nthe spilling decision then is similar to making the decision to use a caller-save register. That is, \nif benefit-callee(lr) < 0, then IF is spilled to memory. For a live range that is not the first user \nof a callee-save register, the live range can use the callee-save register for free (since there in no \nneed to spill the register). The second approach views callee-save cost as shared by all live ranges \nthat share a callee-save reg- ister. That is, the first live range to use the register does not pay all \nthe cost; the cost is spread over all users. The spilling decisions for live ranges that (potentially) \nget callee- save registers are not finalized until the color-assignment phase finishes. At that time, \nit is known which live ranges may use a specific callee-save register. For a callee-save register r, \nand b(r) the set of live ranges that share r, if c IrEdCrj spill-cost(lr) < calleeicost(r), then all \nlive ranges  120.ooo.m H callerJd_st % 5 OumOaca spill-Id B I I 8O.wO.W E B 0 60.ooo.olm s B 4o.amoo \n 2O,oW,ooOIll 6 0 6 o^.6 m m 03 d d d i v; .A eqntott Figure 2: Register of 6(r) are spilled. Our experimental \ndata indicate that the second approach performs better than the first one for some SPEC92 pro-grams, \nfor others it makes no difference. To illustrate why thii is the case, consider two live ranges with \nspill cost 4000 that share the same callee-save register, and the callee-save cost is 5000. The first \napproach does not assign any of the two live ranges to the callee-save register because of the high first-use \ncost. At the end, spilling the two live ranges in-troduces 8000 load/store operations (assume that they \nalso have high caller-save cost, or all caller-save registers are taken by their neighbors). However, \nthe second approach assigns the two live ranges to the register -a decision that saves 3000 load/store \noperations over spilling. Benefit-driven simplification Simplification removes live ranges one by one \nfrom the inter- ference graph and pushes them onto C. The reverse ordering in which live ranges are pushed \nto the stack is the ordering in which they are assigned colors. Simplification is a nice and easy way \nof packing live ranges into registers but there is no cost model, and therefore, decisions during simplifica- \ntion may turn out to handicap the color-assignment phase. If the target machine has only one kind of \nregister, the order of removing already-unconstrained live ranges does not have any influence on the \nfinal register overhead, because using each register incurs the same cost. But for a machine with a mixture \nof registers of different costs, the position of a live range on C plays an important role in reducing \nthe register overhead. Each live range has two benefit functions, benefit-caller and benefit-caIfee, \nwhich determine the preferred kind of register. Live ranges on top of C have a higher chance to obtain \nthe preferred kind of register, because fewer regis- ters are already taken by other live ranges. For \nexample, Figure 3 (a) depicts an interference graph consisting of 3 live ranges. All prefer using a callee-save \nregister. There are only two callee-save registers available. One live range must use a caller-save register. \nWith N = 3, all three live ranges are unconstrained. A legitimate sequence of remov- ing live ranges \nfrom the interference graph is IT,,, lrz, and then lr,. b-, and IT, (on top of C) are assigned callee-save \nregisters during the color-assignment phase, and Ir, ends up in the caller-save register. This assignment \nthen saves I I I hme-hCL--. G?FC;i I 9 u! s s u! s s f-1 *: -r: Ye 1 9 *. 5 -. op aq 05 m 00. h. 9 -------- \n00000000 oo--m* N m- m* d d vi d ;c;c --------  ---u-w-- ear allocation cost. 3200 load/store operations \nover spilling. However, the best ordering during simplification is Zrmr Irr, and then lrz, so that Ir, \nand Ir, can obtain the two callee-save registers; this assignment actually saves 4100 load/store operations. \nbenejr~caller Y bentjtgl1er = 1 ,ooa = I ,ooo Ir, benejt~callee= 2,KQ benefir_cniee = 2,ouJ 5 v bemjr-caller \n= 100 bcneji~callee = 200 Figure 3: Effect of simplification order, with N = 3 registers (2 callee-save \nand 1 caller-save). During simplification, if there is more than one uncon- strained live range, then \nthe live range that has the smallest priority is removed. Now we can view C as a priority-based color \nstack; the higher position a live range on C, the more likely the live range has more freedom with regard \nto picking registers. Hence register allocation based on this color stack is now similar to priority-based \ncoloring [S]. In other words, benefit-driven simplification unifies the priority-based ap- proach with \nsimplification-based register allocation, and we revisit this aspect in Section 9. bone f it-caller and \nbene f it-callee form the foundation of our experiments to investigate different strategies to order \nunconstrained live ranges during simplification. Specifically, we investigate two keys to order live \nranges: 1. max(benefit-caller, benef it-callee) ] benefit-caller -benef iticallee ( 2. if benefit-caller \n2 0 A benefiticallee > 0 max(benef it-caller, bene f iticallee) other&#38;e  i Priority-based coloring \nuses the first strategy to prior-itize so as to make sure that the live range with maxi-mum savings has \nthe highest priority to occupy a regis-ter. However, this strategy, when implemented as part of benefit-driven \nsimplification, increases the register overhead for some SPEC92 programs, compared to register alloca-tion \nwithout using benefit-driven simplification. This first strategy is not suitable for Chaitin-style register \nallocation because simplification guarantees that all live ranges on C can find registers; in other words, \nmaking sure that live ranges with bigger savings own registers is not a concern for Chaitin-style coloring. \nWhat Chaitin-style coloring cares about is the incurred penalty of using the wrong kind of reg- ister \n- it cares more about the delta between the two benefit functions rather than the maximum of the two. \nTherefore the second strategy is used. The example in Figure 4 illustrates how the key functions make \na difference in register allocation overhead. The inter- ference graph in Figure 4 (a) comprises three \nlive ranges, lrzr lry, and lr,. Using the first definition, lr, and lr, have higher priorities (2000) \nthan lr, (1500). The order in which live ranges are removed from the graph is lrzr lrY, and lr,. Because \nall three live ranges prefer a callee-save register, lr, and lr, are assigned the two callee-save registers. \nThe total savings amounts to 4500 load/store operations. With the second definition, lr, has a higher \npriority than lr, and lrv, because for lr, the penalty of using the wrong kind of regis- ter is higher \nthan for the other two. Thus lr, ends up on top of C. The second definition yields a better allocation \nthan the first one (and results in a total savings of 5300 load/store operations).  Preference decision \n One shortcoming of Chaitin-style register allocation is that low-priority (small-savings) live ranges \nwith high degree may take away the kind of register that high-priority (big-savings) live ranges crave \nfor. Benefit-driven simplification tries to prevent this situation from happening. Nevertheless, there \nis still no guarantee that live ranges with high priority get the registers they prefer, because simplification \nis sensitive to the degree of live ranges (a live range can be removed from the interference graph only \nif the live range s degree is less than N). The color-assignment phase, however, ex-amines only the two \nbenefit functions, benefitazllee and benefitxnller, to determine what kind of register a live range should \nget without caring about the needs of other live ranges. This restricted view of the color-assignment \nphase is the cause of unnecessary overhead operations. Therefore, prior to the color-assignment phase, \nwe pro- vide a separate phase that pre-determines the preferable kind of register for some live ranges. \nThe purpose of this phase is to minimize the caller-save overhead. This phase goes through each function \ncall in order of weighted exe-cution frequency and makes the preference decision for live ranges across \nthe function call. For a function call, if the number (L) of the live ranges that contain the call and \npre- fer callee-save registers is less than or equal to the number of available callee-save registers \n(M), then there is no pref- benejr~caffrr = 1,800 k, benefit_collee = **@Q--p k$ZZ; Z :$i d1% benqit_caller \n = 500 benejir~culfee = 1.5CXl Figure 4: Priority with N = 3 registers (2 callee-save and 1 caller-save). \nFigure 5: Preference decision example with N = 3 registers (1 callee-save and 2 caller-save). erence \ndecision that needs to be made. If L is greater than M, then regardless of how registers are assigned, \nat least L - M live ranges must use caller-save registers rather than callee-save registers. We sort \nthose live ranges using a key function. The least L -M live ranges are annotated so that their prefer- \nable kind of register is caller-save regardless of the fact that benefit-callee > benefit-caller. After \nregisters are assigned to those live ranges, just like for regular live ranges, register allocation uses \nbenefit-callee and benef itxaller to analyze if they should reside in registers or memory. The key is \ndefined as: caller-cost if benefitxaller > 0 spill~ost otherwise. { caller-cost(lr) is the overhead \nincurred for Zr using caller- save registers which is equal to spillawt -benefit-caller. For those live \nranges with benefit-caller > 0, caller-cost is used as the key (caller-cost is the overhead). For the \nlive ranges whose benefit-caller < 0, the key is spillxost be-cause storage-class analysis s$lls them \nif they do not get callee-save registers. In other words, spill-cost is the in- curred penalty for not \nusing a callee-save register. Figure 5 (a) depicts an interference graph with five live ranges. The two \nbenefit functions of each live range are listed in the table of Figure 5 (b). Callee-save registers are \nthe precious resources in this example (all live ranges are competing for callee-save registers). The \nkey values of live ranges which are used in benefit-driven simplification are lrt (loo), lr, (loo), lr, \n(loo), lr, (300), and lr, (3900). Only lr, can be removed at first given N = 3, because the de- grees \nof the other live ranges are greater than or equal to 3. Let the subsequent order in which live ranges \nare removed from the graph be lr,, lrt, lri,, and lr,. The ordering in which live ranges are assigned \ncolors is lr,, lr,, Irt, lrr, and lr,. Ir, then takes away the callee-save register and leaves no callee-save \nregister, only the caller-save registers for Irt, lr, and lr, to use (lrz gets the same register as Irz). \nThis assignment saves 900 load/store operations (300 and 600 for using caller-save and callee-save registers, \nrespectively). If live ranges Ir, and lr, contain the same (high-frequency) function call, then lr, is \nforced to reside in a caller-save reg- ister instead of the callee-save register. This color assign- \nment then saves 4500 load/store operations (lrz, lr, and lrl get the caller-save registers, and lr, and \nlr, reside in the callee-save register). Evaluation In this section we report on an empirical evaluation. \nWe measure the influence of different combinations of the im- proving techniques for various SPEC92 programs: \n(alvinn, compress, ear, eqntott, espresso, gee, li, SC, doduc, fpppp, matrix300, nasa7, spice, and tomcatv). \nWe pay special at- tention to the issue of deciding between a caller-save and a callet+save register \nfor a live range. The y-axis of the figures in this section shows the register overhead produced by a \nbase Chaitin-style coloring (with the simple cost model) di-vided by the overhead of an improved-version \nChaitin-style register allocator using various combinations of the enhance- ments (storage-class analysis, \nbenefit-driven simplification, and preference decision). The bigger this number, the less overhead is \nthere in the improved version. SC, BS and PR stand for Storage-Class analysis, Benefit-driven Simplifica-tion \nand PReference, respectively. We can classify the SPECS2 programs (compiled using profile information) \ninto 4 classes. (See [14] for the data for the programs that are not shown here. Also, the issue of dynamic \nversus static information is discussed there as well.) Each optimization contributes a significant fraction \nof improvement. Examples are nasa7 and eax (shown in Figure 6). For nasa7 and ear, there is not much \nroom for optimizations to reduce overhead operations if only a smaller number of registers is available. \nWith more registers, the optimizations have more freedom to choose the right kinds of storage class (caller-save \nreg- isters, callee-save registers, or memory) for live ranges. Only storage-class analysis has a dramatic \nimprove-ment; spilling live ranges that have the wrong kind of registers helps reducing the overall overhead \nopera- tions. Examples are li, SC (shown in Figure 6), and matrix300. Pre-determining the preferred kind \nof registers for live ranges does not affect the overall number of overhead operations. Examples of this \nclass are eqntott and espresso (shown in Figure 6), as well as compress, spice, fpppp, and doduc. For \nprograms that have low callee-save and caller-save costs, such as tomcatv, which consists of only one \nbig function and no calls, none of the three techniques makes any difference. All the ratios for the \nthree im- provements are 1.0. Figure 7 shows the effect of these improvements on the programs from Figure \n2. This figure depicts the register overhead for ear and eqntott with the three improvements. For the \neax and eqntott programs, improved Chaitin-style coloring reduces the register overhead by a factor of \n45 and 66 (i.e, with the base register allocator, there are 45 (66) times as many overhead operations \nas required by the im- proved Chaitin-style coloring). 8 Optimistic versus non-optimistic Optimistic \ncoloring [4] delays spilling decisions for live ranges until the live ranges actually fail to find legal \ncolors. Op-timistic coloring aggressively tries to find colors for those otherwise spilled live ranges. \nIf we exclude call cost from the overhead operations, optimistic coloring guarantees to deliver a result \nat least as good as Chaitin-style coloring. If none of the live ranges spilled by Chaitin-style coloring \ngets a color, then the register overhead is the same as that of using Chaitin-style coloring. If some \notherwise spilled live ranges are assigned colors, then optimistic coloring pro-duces a superior result. \nHowever, if we use the actual cost model from Section 3, which includes the call cost, trying to squeeze \nmore live ranges into registers may not be a good idea because the call cost of keeping live ranges in \nregis- ters may be higher than the live ranges spill cost. Figure 8 presents a situation where optimistic \ncoloring generates more register overhead operations. Given two registers, one callee-save and one caller-save, \nsimplification blocks because the degree of all live ranges is equal to 2. Optimistic coloring pushes \nall live ranges onto C and is able to assign legitimate colors for them. What may happen is that ir, \nand Ir, use the callee-save register, and Ir, and lr, use the caller-save register. In this case, the \nhigh caller-save cost of lr, causes an inferior result. benefir_calier benejt-callee Figure 8: Optimistic \ncoloring with N=2 (1 callee-save and 1 caller-save). Tables 2 and 3 compare the overhead of optimistic \nand base Chaitiu-style coloring using static and dynamic infor-mation to estimate execution frequencies. \nThe value in each entry is the quotient Base-Chaitin/Optimistic. The darkly shaded regions (< 1.00) highlight \nthe cases where optimistic coloring results in more overhead operations than base Chaitin-style coloring. \nThe lightly shaded regions (> 1.00) indicate that optimistic coloring outperforms base Chai- tin-style \ncoloring. The (blank) rest (= 1.00) indicates that optimistic coloring has no influence. Surprisingly, \noptimistic coloring does not improve overhead operations for most of the cases and, in addition, deteriorates \nthe result of register allocation more often than ameliorates it. There are a cou- ple of reasons for \nthat: (1) if the register allocator assigns registers to the live ranges that have high spill cost, assigning \nregisters to the otherwise spilled live ranges that have low spill cost makes only a small difference. \nTherefore we notice only a small improvement. (2) If the live ranges spilled by the base register allocator \nend up in the wrong kind of reg- isters, the overall effect is negative. Optimistic coloring is sometimes \neffective for a small number of registers because the smaller the number of registers is, the more live \nranges are spilled. Yet even in the best cases, the influence of op- timistic coloring is small (within \nf 6 %) except for fpppp when using static information (up to 36 % improvement in 8 - E40- r 35 7.5 I-Y \nLO ~~~ * 4- 0 ,,,,,,,,,,,,,1,,, q~=aa~q~~q~s6as~~~0 ---d d 0 m * t n n d d c c w 00. 09 6 yi b$ %$ ;. \n;. 6 a$ m: m: 2. 0 0 0 d 0 = 0 cce??eeg~~~;ti16~<idd , ,tTi 3c = ear -; 5 54- P3- i 32- Y d o,, ,,, \n,,,1,1,,1 ,,,, s3=-~~~~~-~-~~~-66 0: -: -: qq-&#38;;;~>~$;~gdo 2 2 2 3 2 f -J 2 0; h: 5 g 0 0 0 0 u w \nw -1---= = d *r ,.i .+ 4 4 -----------L u---w-w. nasa7 the number of overhead operations registers). \ng 1.7- 2 1.6-Y t :::-,g,.,-=i p l.Z-3 l.l- Ii ,.b- 0 9 n y ,.,- i!/ -I- 0.91 $~3--R~3$~GT638saG6 -3.2 \n0 n d i n 4 I; 5 d i i rd d 0; of < &#38; &#38; d p &#38; d 6 - - 1-v-------w-w -------. li -.-SC+BS+pR \neqntott .._ 1.7- ld- I.% 1.4- 1.3- 1.2- I.!- ,- 0.9- 0.8 , , , , , , , , , , , , , , , , ) n d d 1- r: \nd d D d d d d d d --mm me ---. ri*lon++n * d c _ = = = 21 s-4 n n i i w-i d ~~~~ ~~. u::==; = espresso \n Figure 6: Improvement as function of register pressure. with a small number of Figure 9: Optimistic \nversus non-optimistic for fpppp (using static information). We incorporate optimistic coloring into improved \nChaitin- style coloring (i.e., including all three improving techniques). Except for fpppp when using \nstatic information, the re-sults are almost identical to those obtained by the improved Chaitin-style \ncoloring alone. This result is no surprise be- cause the improvement of optimistic coloring is small \nto be- gin with, and the storage-class analysis spills the live ranges that are not worthwhile residing \nin registers; this optimiza- tion may actually undo the color assignment done by opti- mistic coloring. \nFigure 9 shows in more detail the improve- ments due to optimistic coloring, improved Chaltin-style col-oring, \nand improved Chaitin-style with optimistic coloring for fpppp using static information. Optimistic coloring \nper-forms well with a small number of registers, but the enhance ment drops as the number of register \nincreases. Improved Chaitin-style coloring, on the other hand, performs well as the number of registers \nincreases, because the more registers are available, the more freedom the register allocator has to choose \nbetween caller-save and cake-save registers. We see the improvements of optimistic coloring plus improved \nChaitin-style coloring as the two are integrated. When the number of registers is small, improved Chaitin-style \ncolor-ing is not very effective, so we see only the contribution of optimistic coloring. As the number \nof registers increases, optimistic coloring has less influence and improved Chaitin-style coloring picks \nup, so we see the enhancement due to improved Chaitin-style coloring. 9 Priority-based versus Chaitin-style \nThe use of a benefit function to sort live ranges invites a comparison with priority-based coloring [8]. \nAt first sight, Chaitin-style coloring and priority-based coloring appear to have little in common. Priority-based \ncoloring assigns reg- isters to live ranges based on a priority function and splits a live range lr when \nno legal register exists for lr. Chaitin-style and priority-based coloring share a major core if priority-based \ncoloring simply spills rather than splits y) 120.ooo.ooo 8 Paa~m~m ; 80,OOWXI B 0 60.m.m % fj 40,m.m \nd 2o,M)o,oOO ear eqntott Figure 7: Register overhead for improved register allocation. Table 2: Optimistic \ncoloring versus Chaitin (using static information). live ranges when it runs out of colors. That is, \nboth ap-proaches try to determine the color ordering in which live ranges are assigned colors (registers). \nChaitin-style coloring simplifies the interference graph to decide the ordering in which live ranges \nare assigned colors. The color-assignment phase then guarantees to assign registers for all non-spilled \nlive ranges based on the ordering. Priority-based coloring uses cost analysis as the priority to determine \nthe order- ing and guarantees that the color-assignment phase assigns registers to the most important \n(high savings of memory accesses) live ranges. The two approaches aim at two dif- ferent directions: \n(1) Chaitin-style coloring finds an order- ing that packs live ranges into registers-potentially it uses \nfewer colors than priority-based coloring, and (2) priority- based coloring wants to make sure that the \nmost important live ranges are in registers even though it may require more colors (or spill more unimportant \nones). Both approaches have their own strengths and weaknesses. Chaitin-style col-oring with all three \nenhancements is a hybrid of the two approaches that uses Chaitin-style coloring as the frame- work for \npacking live ranges and uses storage-class analysis Table 3: Optimistic coloring versus Chaitin (using \ndynamic information). and benefit-driven simplification to achieve the same effect as the priority-based \napproach. 9.1 Priority functions Reducing register overhead operations is the primary goal of the priority \nfunction. Hence, the more memory accesses saved by assigning a register to a live range, the higher the \npriority of the live ranges is. The bigger a live range, the more conflicting live ranges cannot use \nthe same register as the live range. That is, higher register pressure is intro- duced if bigger live \nranges reside in registers. Higher reg- ister pressure is more likely to cause overhead operations. Therefore, \nthe bigger a live range, the lower the priority of the live range is. Baaed on the two conditions, we \nuse mal(bcne/itroller(lr),bencfitrallec(lr u as the priority function sirc(lr) for priority-based coloring. \nsize(Zr) is the number of basic blocks that lr contains. This priority function is the same as the one \nused in [8]. The spilling heuristic of Chaitin-style coloring and optimistic coloring is a~~~~~ $$ ~. \nThe heuris- tic tends to spill live ranges that have low spill cost and high degree. The priority function \nand the spilling heuristic are alike. The numerator of the priority function reflects the spill cost \nbecause the bigger the spill cost, the bigger the two benefit functions are. The denominator reflects \nthe de- gree of live ranges because the bigger the live ranges, the more likely the live ranges have \nhigher degree. There are a few ways to determine the color ordering for priority-based coloring: . removing \nunconstrained: Unconstrained live ranges are removed from the interference graph and pushed onto C. The \nremaining live ranges are pushed onto C from the least priority to the highest priority. Chow uses the \nsame approach [8]. . sorting unconstrained: Unconstrained live ranges are not pushed onto C in a priority \nfashion if we simply remove unconstrained live ranges. That is, the kind of register that a higher-priority \nlive range wants is pos- sibly taken away by lower-priority live ranges. Sort-ing unconstrained live \nranges alleviates the problem by pushing unconstrained live ranges onto C also in a priority manner. \n. sorting: All live ranges are purely sorted in terms of their priorities. The sorting approach guarantees \nthat the higher the priority, the more likely that live ranges are assigned their preferred kind of register. \n All three heuristics produce nearly identical register over- head (&#38; 10%) for most cases. The experimental \nresults show that the sorting approach yields much better results (less overhead) than the other approaches \nfor ear (using both static and dynamic information) and espresso (dynamic). Hence, we choose the sorting \napproach as the priority func- tion for priority-based register allocation. When we compare improved \nChaitin-style coloring with priority-based coloring, we can classify the SPEC92 programs based on the \nresults into 3 classes. See [14] for the data of the programs that are not shown here and a detailed \ncomparison of the three heuristics. . Both priority-based and improved Chaitin-style col-oring are doing \nequally well. Examples are alvinn, eqntott, gee, and li. For alvinn (Figure lo), packing live ranges \nis important for small numbers of registers. When the number of registers increases, packing live ranges \nbecomes less important (because high spill-cost live ranges are most likely to find registers) so we \nsee that the two approaches yield similar results. . Improved Chaitin-style coloring is superior to priority- \nbased coloring. compress, ear, SC, doduc, nasa7, spice, and tomcatv fall into this category. For nasa7 \n(Figure lo), improved Chaitin-style coloring produces slightly fewer overhead operations than priority-based \ncolor-ing when the number of registers is small. When the two approaches have more registers, the results \nstart to diverge. Chaitin-style coloring produces a similar improvement trend in both the dynamic and \nstatic case. Priority-based coloring, nevertheless, does not improve overhead operations a lot over the \nbase in the static case. In this case, priority-based coloring introduces 4 times more overhead operations \nthan im- proved Chaitin-style. The same scenario happens to ear as well. For tomcatv, the priority-based \napproach spills more live ranges than improved Chaitin-style ap-proach, both in the static and dynamic \ncases, due to the inability of packing live ranges densely. . There is no clear winner between the two \napproaches. Examples of this class are espresso, matrix300, and fpppp. For espresso, priority-based coloring \nis su-perior to improved Chaitin-style coloring in the dy- namic case but not in the static case. If \nwe compare the results for fpppp (static) (Figure 10) with the re- sults shown in Figure 9, we notice \na similarity between priority-based coloring and the integration of improved Chaitin-style and optimistic \ncoloring. When the num- ber of registers is small, we see the trend of optimistic coloring. As the number \nof registers increases, we see the trend of improved Chaitin-style coloring. From the experimental results, \nimproved Chaitin-style coloring is superior to priority-based coloring in two ways: (1) Chaitin-style \ncoloring is able to pack more live ranges into a set of registers, which potentially introduces fewer \nspill code operations, (2) the priority function used in priority- based coloring may cause low spill-cost \nlive ranges to take away the registers preferred by high spill-cost live ranges. 10 Chaitin-style versus \nCBH In this section, we compare improved Chaitin-style coloring with another base model that is implemented \nin various com- pilers. This model extends Chaitin-style coloring to explic- itly model the calling convention. \nAccording to Briggs [3], this model also extends hierarchical coloring (as described for the Tera compiler \n[6]). Based on the main components, we name this cost model CBH (for Chaitin/Briggs-Hier- archical coloring). \nAlthough the CBH cost model has been adopted by prior researchers, there is no published report of the \nmodel s effectiveness. The comparison of this section serves three purposes. First, it allows us to know \nif our base Chaitin-style color-ing is a reasonable base or not, relative to a model adopted by other \ncompilers. Second, the comparison presents the effectiveness of the CBH cost model. Third, the compari- \nson also shows if the call-cost directed Chaitin-style model outperforms CBH. In the CBH approach, live \nranges that cross calls inter- fere with all caller-save registers. In other words, none of the caller-save \nregisters can be assigned to live ranges that contain calls. A live range is introduced for each callesave \nregister extending from the entrance of a routine to the exit of the routine. The live range is called \na callee-save-register live range. Each callee-save-register live range has two ref- erences, one at \nthe entry and the other at the exit (these represent save/restore of the callee-save register at the \nen- try/exit). With the execution frequency of the routine, we can get the spill cost for the live range. \nThe call cost is then modeled by CBH just like regular spill cost. Regis-ter allocation performs simplification \nto determine if it is worthwhile using a &#38;lee-save register. When simplification blocks, one live \nrange with the least spill cost is chosen from the remaining live ranges, including the caller+save-register \nlive ranges. Choosing a callee-save-register live range as op posed to a regular live range to spill \nmeans spilling each remaining ordinary live range is more expensive than sav-ing/restoring the callee-save \nregister at the entry/exit. Once alvinn nasa7 f PPPP 2- 1.7- 1.6- IS- 1.4- 1.3- l.2- l.l- I- 0.9-  \n0.61 0.6, , , , , , , , , , , I , I , , , , o.s~, , , , , I ( ( I,, , , I,, , I ~~3~~~~~~~~~~~~~~' ~~'~a~G?qqqaqqaqaas \nq ci 3 4 y? n r! ? r: r! u! 9 y ~~~n-q<q?c~aqqqqqq --nnnn+*nroorrdcaca $=:;r43 CL -. *. f YL CI a. u! \n'I -. Do -. * -J2-I-l*9~~9q--q-- yi yi e: d. r+ r: 6. ti. a: m: d 0' 0' 0. 0. 0. o- c y y a: m: v: P. \n00 '9 m. m. 0 0 0 0 0 0 0 c y w$ d * I. I-q 6 m. a 0 0 0 d d 0 0. 0. l-r-w2nDPooo---1--.-1--PI P OD OD \nm 0% 0 0 - - -. -. 1 -. 1 -. -. - c P od 00 OF a- 0 0 -f -. -. -. 1 1 1 -. 1 ------___ - N' N 0' CI d \nP n' v ------_ -===~Nnn*+nu I-w-------NNOwltPnY) ----C------L ----M-MdM--- CIIIII1lb ,',=;==z: --w-w--- \nespresso gee  Figure 10: Priority-based vs. Chaitin-style coloring. a cahee-save register is spilled, \nthe callee-save register can then be assigned to live ranges. This is similar to the way Chow handles \ncake-save registers [8]. That is, the first live range that uses a callee-save register pays the cake-save \ncost. We compare CBH with improved Chaitin-style coloring. To allow an easy comparison of the new figures \nwith Figure 6, we use the same base line. The data for improved Chaitin- style coloring in Figure 11 \nare the data (SC+BS+PR) from Figure 6. Again, the y-axis of all figures shows the ratio of register overhead \noperations relative to the register overhead produced by the base Chaitin-style allocator. The bigger \nthe number on the y-axis, the more overhead operations are removed. The data of the programs that are \nnot shown in Figure 11 are in [14). We can analyze the data from several different perspec- tives. CBH \nrepresents a model of call cost that is conceptu- aily simple (always a good property). CBH does not \nallow live ranges that cross calls to use caller-save registers, be- cause they interfere with all caller-save \nregisters. Those ex-tra interference edges, however, may overly constrain regis- ter allocation, especially \nwhen there is not asufficient num- ber of cake-save registers because all live ranges crossing calls \nare competing for cake-save registers. Examples of programs that exhibit this behavior are alvinn, compress, \near, espresso, gee, li, SC, doduc, matrix300, and spice. For those SPEC92 programs, high spill-cost live \nranges that cross calls are spilled because there are only a small num-ber of cake-save registers. As \nthe number of cake-save registers increases, the constraints become leas critical, and CBH is able to \nassign registers effectively for alvinn, ear, and matrix300. Then there are cases where improved Chaitin-style \ncolor-ing and the CBH approach produce almost identical results, i.e. the same number of overhead operations. \nfpppp and tomcatv fall into this category. Sometimes the CBH approach does not improve the qual- ity \nof register allocation when using profiling information. Examples are compress, li, SC, gee, doduc, nasa7 \nand spice. For those programs, we see that CBH cannot catch up with improved Chaitin-style coloring. \nThe main reason for this situation is that many live ranges on the most frequently exe- cuted paths also \ncross call sites that are on less frequently ex- ecuted paths. All those live ranges are competing for \ncallee save registers regardless the fact that the call sites contained in the live range are not frequently \nexecuted. Consequently, those live ranges are either assigned callee-save registers or spilled. As a \nresult, CBH spills more than necessary and incurs high register overhead (spill code) for such programs. \nOn the other hand, improved Chaitin-style coloring pays caller-save cost at occasionally executed paths \nand assigns caller-save registers to live ranges that do not cross calls on frequently executed paths. \nAnother noteworthy aspect is that CBH requires a fair Program 1 compress eqntott 1 li 1 sc 1 spice \n1 Imnrovement I 2.9 I 2.2 I 2.8 I 4.4 I 1.0 1 , 1 I Table 4: Speedup of execution time (percentage). \n number of registers to make up the deficiency of its call cost model for matrix300 and nasa7. The data \nfor im-proved Chaitin-style coloring and CBH of matrix300 (dy-namic) show that improved Chaitin-style \ncoloring continues to improve beyond using (9,7,3,3) registers, whereas CBH still suffers from the lack \nof callee-save registers until it has 4 additional integer and 3 additional floating-point callee- save \nregisters. nasa7 follows a similar pattern. For ear and eqntott, we see a similar trend although it is \nless pro- nounced. For ear and nasa7, improved Chaitin-style coloring achiev- es a big improvement for \nboth the static and dynamic cases. CBH, however, produces roughly identical overhead opera- tions as \nthe base Chaitin-style coloring in the static case. From those figures, we can derive the conclusion \nthat im-proved Chaitin-style coloring is superior to the CBH ap-proach, and the n base model is actually \nreasonable after all. For a lot of register ranges, the base Chaitin-style all* cator is actually superior \nto the CBH-style allocator. 11 Execution time One dimension of interest to compiler designers is total \nexe-cution time (The discussion focussed so far on the number of overhead operations.) Table 4 shows \nthe speedup due to the three enhancements (compared to optimistic coloring) with all registers (26 int, \n16 float). These data are for the MIPS architecture; the execution time has been measured on a DECstation \n5000. The table shows that the enhancements can speed up execution time by up to 4.4 %. 12 Conclusion \nThe experimental results of this paper show that the call cost dominates the register overhead as the \nnumber of regis- ter increases, because the register allocator is able to assign registers to most live \nranges. Ignoring the call cost may lead the register allocator to choose the wrong kind of regis- ter \nfor live ranges and introduce, as a result, more overhead operations. Chaitin-style coloring with all \nthe enhancements (of Sec- tions 4 -6) combines the benefits of Chaitin-style allocation (pack more live \nranges into registers) with the advantages of priority-based coloring (high priority live ranges have \nmore freedom in choosing registers). The experimental data show that the improvement over ordinary Chaitin-style \ncoloring can be up to a factor of about 50 in the number of overhead operations (55 for ear and 66 for \neqntott). For some live ranges, spilling is superior to keeping the live range in the wrong kind of register. \nFor example, if a callee-save register is not available, not assigning a (caller-save) register may be \nthe right choice for the register al- locator. In an evaluation of the effectiveness of optimistic coloring, \nthe same observation holds. Optimistic coloring needs to take call cost into account. Otherwise, the \noverall effect may be negative. From the experimental results, improved Chaitin-style coloring is superior \nto priority-based coloring. Chaitin-style coloring is able to pack more live ranges into a set of regis- \nters. The enhancements described here allow Chaitin-style allocation to order live ranges, thereby achieving \nsimilar benefits as can be obtained from the priority function of priority-based coloring. As a result, \nlow spill-cost live ranges do not take away the registers preferred by high spill-cost live ranges. Coloring \nbased on the CBH cost model imposes the con- straint of not assigning caller-save registers to live ranges \ncontaining calls. Due to this constraint, callee-save registers then become the most critical resources \nin a lot of cases. As a result, the caller-save registers may be underutilized; live ranges containing \ncalls are spilled although the calls may be executed only infrequently. One interesting aspect of register \nallocation is that each model hits some aspect of dealing with call cost. There are some programs (or \nsome register ranges for some programs) where the priority-based and/or CBH-style approaches per-form \nreasonably well, as there are situations where opti-mistic allocation performs well. One of the challenges \nis to devise an approach that combines the benefits of all mod- els. Storage-class analysis, benefit-driven \nsimplification, and preference decision address this concern and can be inte-grated into a Chaitin-style \nregister allocator. These opti-mizations provide an effective way to deal with modern call- ing conventions \nfor a wide range of programs. Acknowledgements We appreciate the feedback provided by the referees. \nPre-ston Briggs explained to us the details of the CBH model. We also thank Ali Adl-Tabatabai and Fred \nChow for vari- ous discussions, and Tony Dewitt for a careful reading of the paper. References A. Adl-Tabatabal, \nT. Gross, and G. Y. Lueh. Code reuse in an optimizing compiler. In Pruc. SIGPLAN Conference on Object-Oriented \nPmgmmming Systems, Languages, and Applications, pages 51-68. ACM, October 1996. PI PI D. Bernstein, D. \nQ. Goldin, M. C. Golumbic, H. Krawczyk, Y. Mansour, I. Nahshon, and R. Y. Pinter. Sdll code mini- mization \ntechniques for optimizing compilers. in Pmt. ACM SIGPLAN 89 Conf. on Pnw. Lonauaae Desian and Imole- \nmentation, pages 258-263. ACM, Jily-1989. P. Briggs. Personal communication, 1996. [31 141P. Brim, K. \nD. Cooper, K. Kennedy, and L. Torczon. Col-oring heuristics for register allocation. In PIUC. ACM SIG-PLAN \n89 Conf. on P&#38;g. Language Design and Implemen- tation, pages 275-284. ACM, July 1989. P. Briggs, \nK. D. Cooper, and L. Torczon. Rematerialiration. In Proc. ACM SIGPLA N 92 Conf. on Prvg. Language De- \nsign and Implementation, pages 311-321. ACM, June 1992. 151 D. Callahan and B. Koblenz. Register allocation \nvia hierar- chical graph coloring. In Proc. ACM SIGPLAN SI Conf. on Prog. Language Design and Implementation, \npages 192-203, Toronto, June 1991. ACM. PI G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, 171 \n M. E. Hopkins, and P. W. Markstein. Register allocation via coloring. Computer Languages, 6:47-57, January \n1981. - Improved Chaitin CBH ww -(sulk) - Improved Chaitin (dymid -~zmic,  20 1.25 alvinn ear WC \n2.2 6 1.75 2- 5 1.5 l.B- 4 E 1.25 1.6- :s 3 s 0.7: 1.4-1.2- 2 0.25 0.8 , , , , , , ( , , , , , , , , \n, , 0 612-~-^-^-e.---^^^^-+++-i-io-lYt.l?q=?cc9F9Y 0. 1 f t CI ? 4 s 9 q q q q -I-\"\"~~~~--\"\"W\"-I CI q \n- c. c. 0. -? 9 9 s. q 9 q q 9 =a 2. w\":sC\"2lfs\"\" \"e-1\"-\"\" ~~~~~~~~~~~Q~~~~q~-l--Ltfqqq~~~gggy * a: '4 \nI-: \". m. 00. m. *. 0 0 I. c OD ca 01 h 0 0 - - 1 -. 1 -. -. 1 -. -. ------====\"\"~\"ff~~ \"W\"\"W\"\"\" @q~qq$GjqqqqQqsqqaa \n4 '. '. N. N. 0. -3 4 9 '? \". 9 \". c c. 00. 4 =z q y s. g P. 'I 00. 0. a. a. 0 0 Q 0 0 0 0 0 c E 00 \"-1-e-d0 \n01 01 0 0 - - 1 -. 1 1 1 -. 1 1 -clnoo**nY)---1------.e-\"\"\"1\"\"\"\" li matrix300 nasa'l Figure 11: Improved \n PI F. C. Chow and J. L. Hennessy. A priority-based coloring approach to register allocation. ACM Runs. \non Pmg. Lang. Syst., 12:501-535, Oct. 1990. PI F.C. Chow. Minimizing register usage penalty at procedure \ncalls. In Pmt. SIGPLAN Sgmp. on Pmgmmming Language Deaign and Implementation, pages 85-94. ACM, June \n1988. DOIR. Cohn and P.G. Lowney. Hot cold optimization of large IllI 1131 1141 1151 Pf~l Windows/NT \napplications. In Pmt. Micro 29. ACM, 1996. S. fieudenberger and J. Ruttenberg. Phase ordering of reg- \nister allocation and instruction scheduling. In R. Giegerich and S. L. Graham, editors, Code Genemtion \n-Concepts, Tools, Techniques, pages 146-170. Springer Verlag, 1992. S. M. Kurlander and C. N. Fischer. \nZero-cost range splitting. In Pmt. ACM SKGPLAN 94 Conf. on Prog. Language De- sign and Implementation, \npagea 257-265. ACM, June 1994. G. Lueh, T. Gross, and A. Adl-Tabatabai. Global register allocation based \non gaph fusion. In Pmt. 96 Workshop on Languages and Compilers for Pamllel Computing, page to appear, \nSan Jose, CA, Aug 1996. Springer Verlag. G. Y. Lueh. &#38;ion-Based Register Allocation. PhD thesis, \nCarnegie Mellon University, 1997. W.G. Morris. Ccg: A prototype coagulating code genera-tor. In Pmt. \nSIGPLAN Sgmp. on Progmmming Language Design and Implementation, pages 45-58. ACM, June 1991. C. Norris \nand L. L. Pollock. Register allocation over the program dependence graph. In Pmt. ACM SIGPLAN 94  Chaitin-style \nversus CBH. Conf. on Pmg. Language Design and Implementation, pages 266-277. ACM, June 1994. T. A. Proebsting \nand C. N. Fischer. Probablistic register allocation. In Pmt. ACM SIGPLAN 92 Conf. on Pmg. Language Design \nand Implementation, pages 300-310. ACM, June 1992. 1171 0. Waddell R.G. Burger and R.K. Dybvig. Register \nalloca-tion using lazy savea, eager restores, and greedy shuffling. In WI Proc. SIGPLAN Sump. on Pmgmmming \nLanguage Design and Implementation, pages 130-138. ACM, June 1995. WI V. Santhanarn and D. Odnert. Register \nallocation across procedure and module boundaries. In Proc. SIGPLAN Sgmp. on Prcgmmming Language Design \nand Implemento- tion, pages 28-39. ACM, June 1990. P.A. Steenkiste and J.L. Hennessy. A simple interproce \ndural register allocation algorithm and its effectiveness for lisp. ACM tineactions on Pmgmmming Languages \nand Systems, ll(l):l-32, January 1989. PI D. W. Wall. Global register allocation at link time. In Pll \nPmt. ACM SIGPLAN 86 Sgmp. on Compiler Construc- tion, pages 264-275, Palo Alto, June 1986. ACM.   \n\t\t\t", "proc_id": "258915", "abstract": "Choosing the right kind of register for a live range plays a major role in eliminating the register-allocation overhead when the compiled function is frequently executed or function tails are on the most frequently executed paths. Picking the wrong kind of register for a live range incurs a high penalty that may dominate the total overhead of register allocation. In this paper, we present three improvements, storage-class analysis, benefit-driven simplification, and preference decision that are effective in selecting the right kind of register for a live range. Then we compare an enhanced Chaitin-style register allocator (with these three improvements) with priority-based and optimistic coloring.", "authors": [{"name": "Guei-Yuan Lueh", "author_profile_id": "81331498383", "affiliation": "School of Computer Science, Carnegie Mellon University Pittsburgh, PA", "person_id": "PP33032555", "email_address": "", "orcid_id": ""}, {"name": "Thomas Gross", "author_profile_id": "81332502168", "affiliation": "School of Computer Science, Carnegie Mellon University Pittsburgh, PA", "person_id": "PP39077301", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/258915.258942", "year": "1997", "article_id": "258942", "conference": "PLDI", "title": "Call-cost directed register allocation", "url": "http://dl.acm.org/citation.cfm?id=258942"}