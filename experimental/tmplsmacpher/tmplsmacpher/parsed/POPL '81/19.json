{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 rule p is expressed as P: X(pso) + wlX(p.l)w2X(p,2)w3 . ..wn(P)X(p.n(p))wn(p)+l \n.  (2) Aisa set of a ttributes. Each X e VN has a subset AIXI of A. An element of A[X] is c~lled an \nattribute of X. A[X] is a disjoint union of the set ICXI of inherited attributes and the set s[X] of \nsynthesized attributes. We require that 1[S] = @ for the initial symbol S. When p is aproduction rulewe \nsay thatp has an attribute occurrence a.X(p,k) if a 6 A[X(p,k)] and O < k s n(p). For a set B of attributes \nwe extend this notation and write B.X(p,k) = {b.X(p,k)l b e B } . (3) F is a set of semantic functions. \nA semantic function f P,v is associated with every attribute occurrence v = a.X(p,k) such that a e SIX(p,O)] \nor a e IIX(p,k)] for 1 S k S n(p) . It specifies how to compute the value of v from values of other attribute \noccurrences of the rule p. We denote the set of these attribute occurrences by DIt is called a dependency \nset of fp,v. If p,v p,v = Vi  Vm] hen p,v s a napping domain(al) x . . . X domain(am) + domain(a) \n where vi = ai.X(p, ki) and domain(a) is a value domain of the attribute a in general. We express this \nfact by an equation V=f P, V(V1* . . . SVm). In what follows we assume without loss of generality that \nvi = a.X(p,O) for a e IIX(p,O)] or . = a.X(p,k) for a e S[X(p,k)] and 1 S k S n(p) to VI simplify discussions. \n 2.2 Dependencies Here we define several dependency relationa among attributes and related concepts. \n(1) Let P be a production rule. A dependency graph DGP for the production rule p, which gives dependency \nrelationship among attribute occurrences of p, is defined by DGP = (DVP, DEP) where the node set DV \nis the set of all attribute occurrences of p and ;he edge set DEP is the aet of dependency pairs for \np. Formally DV = {a. X(p,k)l O ~ k S n(p) and a eA[X(p,k)]} P JIEP = {(v~sV~)ivl e p,v2] (2) When a derivation \ntree T is given, a dependency graph DGT for the derivation tree T is defined to represent dependencies \namong attributes of nodes in T. DGT ia obtained by pasting DGpts together according to the syntactic \nstructure of T. Let p be the production rule applied at the root of T and T[k] the k-th subtree of T. \nDGT is recursively constructed from DGP, DGT[lls . . . s in the following way. GT[n(p)] DGT = (DVT, DET) \nwhere n( ) DVT = DV: U Uk=: DVT[k] DET = DE; U U;~~)DET[kl and DG~ = (DVt, DE;) is a graph obtained from \nDG by replacing every attribute occurrence a.f(p,k) in the production rule p by the corresponding occurrence \na.r[k] of the attribute a in the tree T, where r[k] is the root node of T[k]. (We assume r[O] denotes \nthe root of T). DV~ = {a.r[k]l a.X(p,k) c DVP } DE: = {(a. r[k],b. r[j]) I (a. X(p,k),b.X(p, j)) e DEP \n} Note that we used the notation a.t for the occurrence of the attribute a at the node t of the derivation \ntree T. Next we consider dependencies among attributes of a single nonterminal symbol. (3) Let T be a \nderivation tree with the root labeled X c VN. DGT determines IO graph IOIX.T] of X with respect to T. \nIt gives how synthesized attributes of X are dependent on other attributes of X through the derivation \ntree T. That is, IOIX,T] = (AIX],EIOIT]) where an edge (a,s) is in EIOIT] cAIXI X SIXI iff there is in \nDGT a path from Va to vs ,whereva and v.S are nodes for attributes a and s of the root X of T respectively, \nand this means that the attribute a is required to evaluate the synthesized attribute s. For general \nattribute grammars there may be finitely many IO graphs for X c VN and we denotes the set of these IO \ngraghs by IO(X), that is, IO(X) = {IOIX,TI 1 T is a derivation tree with root X}. Let IO(X) = {101, 102,..., \nION] and IOk = (AIXI, Ek). Superposing IOkts results in a superposed IO graph IOIX] = (AIxI, EIO)S EIO= \nU~.lEk . (4) LetTbe a derivation tree which has the initial symbol S as its root and contains X ~ VN \nas one of its leaf nodes. An 01 graph OIIX,T] of X with respect to T is given by OIIX,T] = (AIXI,EO1[TI), \nEO1[TI c AIXI x I[xl where an edge (a,i) is in EO1[T] iff there is in DGT a path from Va to vi, where \nVa and vi are nodes for attributes a and i of the leaf node X. A superposed 01 graph OIIX] is defined \nin the similar way as IOIXI. That is, if O1l,...,OIN are possible 01 graphs of Xand OIk = (AExI, Ek) \nthen OIIX] = (A[X], EO1), EO1= U#=lEk . (5) A dependency graph DG[X] of a nonterminal symbol X is defined \nas the union of IO graph and 01 graph, that is, DG[X] = (A[X], EIOU EO1) . (6) For a production rule \np its augmented dependency graph is defined by DG; = (DV;, DE;) where ~v* =~v PP DE* = DEP u {(a. X(p,k).b.X(p.k)) \nI (a,b) is an P edge of IOIX(p.k)] for 1 <k< n(p) or OIIX(p,O)]} DG~ represents dependency relations \namong attribute occurrences of p, which is realized partly by semantic functions and partly by derivation \ntrees. Note that the augmented dependency graph introduced above is a little stronger than what is defined \nin [7] where only downward augmentation is taken into account. (7) An attribute grammar is said absolutely \nnoncircular iff DG~ does not contain cycles for any production rule p. This definition for absolute noncircularity \nis ahown equivalent to the one given in [71. Now we give some definitions about the order of attribute \nevaluation. This order is implied by the dependencies defined above and it also controls progression \nof verification. (8) A set BC SEX] or IIX] of attributesof X is said evaluable in parallel iff no a. \nb E B are connected in DG[X]. Note that attributes S1SS2, ... ssn of the initial symbol S are evaluable \nin parallel by the restriction on the arguments of semantic functions. It is easy to see that there is \nno essential order in which attributes in B are evaluated. (9) For a nonterminal symbol X and a setBc \nA[X] of attributes of X, predecessor of B in DG[X] is predx(B) . {ala is a proper predecessor Of some \nb EB in DG[X]} . Similarly, fora production rule p and a set V of attribute occurrences of p, predecessor \nof V in predp(V) = {UIU is a proper predecessor of some v EVin DG~] . 3. Verification Procedure The purpose \nof verification of attribute grammar is to know whether a given proposition ci(sl,s~,...ssn ) about attributes \nsl,s2 . . . ..sn of the initial symbol S of the attribute grammar may hold whatsoever derivation trees \nare derived from s. TO this end we assign assertions aX,B S tO relevant pairs of a symbol X 6 VN and \na set B of ita attributes which is evaluable in parallel. @.x,B is a proposition about attributes in \nB and their predecessors which is expected to hold at any node labeled with X in any derivation tree. \nIt must coincide with U(S1.S2,...,Sn )forX=SandB = {s~,s2,...,sn}. c?.x,Bts are verified in the following \nmanner. Consider the dependency graph DGT for any derivation tree T. DGT determines the order in which \noccurrences of B s are evaluated in T and we can prove that cix,B~s hold at corresponding nodes of T \nby traversing DGT in this order. As DGT is constructed by pasting DGpra together we can decompose the \nabove proof into subproofs with respect to the production rules pts and paste them together to obtain \nthe desired total proof. Specifically our verification procedure consists of the following steps. [Step \n11 Selection of Asserted Attributes For each X c VN determine a familY BIXI of parallelly evaluable sets \nof Xfs attributes to which assertions are attached. [Step 2] Assignment of Assertions For each X 6 VN \nand set B e B[X] assign an assertion ux,B. The assertion aX,B must be specified in terms of attributes \nin- B and its predecessor B* in DG[X], that is, aX, B = X, B[B9 B* I B* c predx(B) . [Step 3] Generation \nof Verification Conditions Let p be a production rule. For each X . X(p,k), O < k < n(p), and B e B[X] \ngenerate a verification condition VX,B of the form X,B : A A sr[p] = &#38;x,B aX1 , B1 A aX2,B2  A \n Xh,Bh where (1) in general, ZX,B is obtained from aX,B by replacing every attribute b e B by its occurrence \nb.X cB.X , (2) if X=X(P,O) then Bc SEX] or if X= X(p,k) for 1 < k= n(p) then B c IIX], (3) axn,B (n \n= 1.2,..., h) is an assertion for Xn = X(p,kn), % -S kn S n(p), and Bn e B[Xn] such  that Bn.~ c predp(B.X) \ns (4) sr[pl is a conjunctionof expressions of the form v = fp,v(v1sv2,... svm) where v is an occurrence \nof synthesized attribute of X(p,O) or of inherited attribute of X(p,k) (1 < k S n(p)) and Dp,v = {v1,v2, \n. . ..vm]. We call sr[p] a semantic rule of p. production rules semantic rules l:N+SL POS.L=O vail.N=if \nneg.S then -vail.L else vail. L fi 2: s++ neg.S=FALSE 3: s+- neg. S=TRUE 4:L+B Pos.B=pos.L vail .L=vall \n.B 5: LO+LIB Pos.L1=pos.Lo+l Pos. B=pos. Lo vail.Lo=vall .L1+vall.B 6:B+0 vail.B=O 7:B+1 vail .B=2+pos \n.B 180 [Step 4] Proof of Verification Conditions If all verification conditions generated are proved \nto hold, we conclude that the correctness of all assertions, therefore the correctness of the assertion \na assigned to the initial symbol. is established. As is easily seen from the form of verification conditions, \nverification of assertions s proceeds upward in derivation trees if B c aX,B s[X] and downward if B c \nIIX]. 4. Examples Here we give examples of verification of attribute grammars by the procedure presented \nabove. [Example 11 Consider an attribute grammar AG1 defined below. symbols VN={N,S,L,B} VT={+, -,O,l] \n attributes IIN]=@ SENl={va11,va12} 1[S]=0 S[S]={neg} IIL]={Pos} S[L]={va11,va12] II B]={Pos] SIB] ={vall \n,va12] va12.N=if neg.S then -va12.L else va12.L fi va12.L=va12 .B va12.Lo=2%a12 .L1+va12.B va12.B=0 \nva12 .B=l Note that the nonterminal eymbol L is indexed to distinguish different occurrences in the \nproduction rule 5. This grammar computes the value of binary number b=b1b2...bn in two ways given by \nvail (b1b2...bn) = b12 -l+vall~ (b2 . . . b)n va12i(b1b2... bn) = 2tia12 (bl...bl)+bnbn where vail \nandva12 t are functions corresponding to the attributes vail and va12 respectively. We want to show that \nvail (b) = va12 (b) and this is expreesed as vail = va12 in the terminology of AG1. According to the \nverification procedure hitherto stated we first determine asserted attributes and their assertions. They \nare given below. = va12 N,{va11,va12} : ail : true S,{negl : vail = va12*2+pos L,{va11,va12] : vail =. \nva12*2+pos aB,{vall,v al z ) Then we proceed to generate verification conditions after constructing augmented \ndependency graphs which are necessary to compute predp s. The following is. for example, the augmented \ndependency graph for the production rule 5. LO po s vail va12 L1 pos vail va12 The generated verification \nconditions are Asr[l]a ~N,{va11,va12] S,{neg} &#38;L,{va11,va12] sr[21 ~ tis, {neg] sr[31 ~ &#38;S,{neg] \nA sr[41 = ~L,{va11,va12J B, {vail ,va12) A sr[5] L1, {va11,va12} A aB, {va11,va12} = Lo.[vail.va12] The \nfifth verification condition above is, for example, rewritten as vail.L1=va12.L1*24Pos .L1 A vail .B=va12.B*2+p0s.B \nA pOSOL1=pOS, L~+l A POS. B=POs. LO A vail.Lo=vall+valloB A va12.Lo=2~a12.L1+va12.B = vail.Lo=va12.Lo*2~pos.L0 \nand is shown to be valid. Other verification conditions are proved in the same way and this completes \nour verification. Note that verification progressed upward in this example. That is, only the synthesized \ninduction was used. Next we give an example where verification progresses in both directions. [Example \n2] The attribute grammar AG2 below computes 4*n by going down and up derivation trees twice when it is \nfed with the string an. symbols VN={S,A] VT={a} attributes IIS]=@ S[s]={k] IIA]={f,h] S[A]={g,k} production \nrules semantic rules l:s+A k.S=k.A h.A=g.A f .A=O 2: A. +sAl f.A1=f.Ao+l g. AO=g.A1+l h. A1=h.Ao+l \nk.Ao=k.A1+l  3:A+a g.A=f.A k.A=h.A The figure below shows how attributes are evaluated. fghk s   \n/ .= Ao a +1+1+1+1 A / a +1+1+1+1 d A .. sr[6] = iB, {Val~sva12} sr[71 = ~B, {vall, va121 a 181 Dependency \ngraphs of nonterminal symbols are DG[S]: o DG[A]: c+Q-+0~ k fghk  We want to prove that the value of \nk at the root of any derivation tree is 4*n and to this end we set the following assertions. : Vn[k=4*n] \nS,[k] O,A,{g]: Vn[g.2*n+f] : h=2*f+g A,{h] c?.A,{k}: k=f+2*g  where V denotes the existential quantifier. \nDependency graphs for production rules are s k fghk Afghk o @ Afghk a Al fghk a z a and we obtain the \nfollowing verification conditions where unnecessary premises to the left of ?=! are omitted for the sake \nof simplicity. A &#38;A,{g] A Sr[l] = ds,{k} ~A,{k] r[l] = A,{h} A sr[21 a &#38;Ao,{g] Al , {g} ~Ao,{h] \nA r[z] = Al,{h} iAl,{k] A r[2] = aAO,{k} sr[31 = iiA,{g} ;A,{h] A 5r[3] a tiA,{k] These are valid formulas \nand this completes the verification. Note that the upward (synthesized) induction was used to verifY \nas,{k}~ UA,{g] and ctA,{kl, on the other hand, the downward (inherited) induction established aA, {h~. \nSometimes introduction of extra attributes simplifies verification. Suppose we add, for example, a synthesized \nattribute d to the nonterminal symbol A in AG2 to specify the depth of derivation trees. Necessary modification \nto the semantic rules is the addition of d.A=f.A to A + a and d.Ao=d.A1 to *O + aA1. In this case we \ncan verify the desired result by setting assertions . k=4*d aS,{k] g+f=2*d aA,{g]: : k=h+2*(d-f) aA,{k} \nand proving them by resorting only to the synthesized induction. Verification conditions to be proved \nare A,{g} A A,{k} A r[l] = %,{k} aA1,{g]A r[2]= Ao,{g]  Al,{k]A r[2]= Ao,{k} Sd.s]= iiA,{g] srC31 \n~ tiA,{k} . 5. Consistency and Completeness 5.1 Definitions In this section we establish consistency \nand completeness of our verification procedure. This fact states that we can rest on it when proving \nthe correctness. Firat we give their definitions. [Consistency/GompletenessI A verification procedure \nfor attribute grammars is consistent iff an assertion for the initial symbol S is true at the root of \nany derivation tree which is derivable from S when the assertion a is verified to be correct by the procedure. \nIt is complete iff the converse holds. In proving the claim that our verification procedure enjoys both \nproperties, we must resort to some formal basis on which computations specified by attribute grammars \nare defined. To this end we introduce an intuitive computation model based on the dependency graph [81. \n[An Intuitive Semantics for Attribute Grammars] Let AG = (G,A,F) be a noncircular attribute grammar and \nT a derivation tree of the underlying grammar G. Values of attributes at the nodes of T are determined \non the basis of the dependency graph DGT which specifies functional dependency among attribute occurrences \nof T. Let val(v) be the value of an attribute occurrence v=a.t of T. As the value of v depends on T we \nshould write val(v,T) instead of val(v) in principle. We denote it, however, by val(v) for the sake of \nsimplicity. val(v) i~ recu~sively defined as shown below. That ia, if VI. V2, . . . , Vn are direct predecessors \nof v in DGT and Fv is the semantic function for v then val(v) = Fv(val(vl), . . . ,val(vn)) . If we denote \nthe production rule applied at the node t by p[t] and the k-th son node of t by t[kl, then the function \nFv is expressed as 1? a.t = p[tl,a.X(p[tl,O) : when a is a synthesized attribute = fP[t?],a.X(p[tl],k) \n: when a is an inherited attribute and t [k]=t. Noncircularity of AG implies acyclicity of DGT and this \nassures well-definedness of val. 5.2 Consistency Here we establish consistency of our verification procedure. \n[Theorem 11 Our verification procedure for absolutely noncircular attribute grammars is consistent. (Proof) \nSuppose an assertion a about attributes of the initial symbol S is verified to hold by our procedure, \nthat is, for every X e VN and B e BIXI the generated verification condition holds. We show that for any \nX and B the X,B assertion UX,B is true at any node t labeled with X in any derivation tree T. When writing \n&#38;x,B = aX,B(bls . . . ,bu), bi E B u predx(B), this means to prove an assertion instance ax,B[t] \nis true, where X,BCt] = aX, B(val(bl t)s  val(b U t)) First we construct an assertion dependency graph \nDG~ for the derivation tree T, which represents a dependency relation among ax ~[tlts. * DG~ is defined \nin the same way as DGT. Let p be the production rule applied at the root of T. If we denote the root \nnodes of T and its k-th subtree T[k] by r and r[k] respectively (We assume r[O]=r), DG~ is defined recursively \nfrom DG~[l] DG?[n(p)l by DG; = (D ?, DE;) where [r] 1 B E BIX(p,O)]} u U~~)DV~[k3 % = X(p,O),B [r[k]],ax(p, \nj),C [r[jII) E; = (aX(p,k),B B.X(p,k) Cpredp(C.X(p,j))} n(p)DEa u k=l T[k] Note that we dropped off \nnode identification information from the denotation for nodes of DG~ to clarify the description. That \nis, we should write (ax(p,k),B[r],r,B) instead of X(p,k),B[r] for the sake of precision. DG-. is acyclic \nby the absolute noncircu larity of the attribute grammar under consideration and the parallel evaluability \nof asserted sets. Suppose DG~ contains a cycle and a node ax,B[r] is on this cycle. From the definition \nof DG~ we have B.X c predp(B.X) as predp ia transitive. There\u00ad fore, for each beB there exists b?cB such \nthat (b ,b) c DG[X]. If b!=b this contradicts to the bt#b also contradicts to absolute noncircularity. \nthe parallel evaluability of B. Now, what we want to show is to prove @x,B[t] = true for any ax,B[tl \nE D@T. As DG~ is acyclic, induction on DG~ is utilized to establish the desired result. et X1,B1 [tll~ \naX2,B2[t2]* .. aXh,Bh[th] be direct predecessors of v.x,B[t] in DG~. From the definition of DG~ we can \nfind a production rule p such that X, Xl, X2, . . . ,Xh are among X(P,O), . . . ,X(p,n(p)) and Bn.Xn \nC predp(B.X) for 1 s n < h. By assumption the verification condition VX,B: A ... A sr[p] n ~x,B Xl ,Bl \nA ~X2,B2 A Xh,Bh holds, that is, it is a valid formula when considering attribute occurrences contained \nin it to be free variables. Therefore, by replacing them by the values of the attributes at the corresponding \nnodes of T, that is, by replacing the occurrence a.X(p,k) by the value val(a.rk)s where rk e ~,t2s . \n. . ,th] is the node for X(p,k)~ we {t,t have a true formula aX1,B1[tll ax B [t~] A... Acix h,Bh[th] \nA sr [p] 2 2 ~ ax,B[tl . sr~[p] is obtained from ar[p] and is a conjunction of equations of the form \nval(a.rk) ~ fp,a,x(p,k)(val(al .rkl), . . . ~val(am.r~)) where D = {al.x(p~kl)~ . . . ,am.X(p,km)] . \np,a.X(p.k) er~[pl is trivially true by the definition of val. Therefore, if we assume axl,B1[tl]s ax \n,B [t2]t . . . [th ] are truewe Can conclude t~aZaX,B[t] aXh,Bh is also true. This completes our proof \nby induction. n 5.3 Completeness To discuss the completeness problem we need to introduce a baaic and \nimportant reeult about evaluation of attributes [5]. Let b be a synthesized attribute of a nonterminal \neymbol X of an absolutely noncircular attribute grammar. Define in[b,X] to denote a set of attributes \nof X which may be required to evaluate b, that is, in[b,X] = {al (a,b) is an edge of IOIX]} . When in[b, \nX]={al, a2,..., am] the value of the attribute b at a node r labeled with X in a derivation tree is uniquely \ndetermined from the values of al, . . . ,am at r and the subtree T with the root r. Therefore we can \ncorrespond a function to each pair (b,X), b,X Fb,x: domain(al)X. ..xdomain(am)xT + domain(b) such that \nit computes b from al, . . . .am and T, where T denotes the set of all derivation trees of the underlying \ncontext free grammar. The function Fb, X is expressed as shown below where xl, . . . ,xm are formal parameters \nfor alt . . . ,am respectively, production(T) denotes the production rule applied at the root of T and \nPI, P2* . . . are production rules with left side symbol x. Fb,x = lambda xl,...s~sT case production(T) \nof Pl: Epl,b,X P2: Ep2,b,X . . . end Body of Fb,x is a case expression which selects a relevant expression \nEp,b,x to compute the value of b on the basis of the production rule p applied at the root of T. The \nexpression Ep,b,X is given by Ep,b,x = exp(b.X(p,O)) where exp is an expression constructed from f fs, \np,v 1?a,xfs, T[k]ts and Xits, and is defined recursively on the node aet of DG~, the augmented dependency \ngraph for the production rule p. Well-definedness of exp is assured by the absolute noncircularity of \nthe grammars under consideration. Let v be an attribute occurrence of p, that is, a node of DG*, and \nVI, . . . ,Vn be the direct P predecessors of v. The form of exp(v) differs depending on the type of \nv. We use boldface parentheses, brackets and commas for the sake of quoting. [Case 11 v=b.X(p,O) or v=a.X(p,k) \nfor aeIIX(p,k)] and 1sk<n(p): exp(v) = f P,v(=(vl)s . . . ,exp(vn)) [Case 2] v=a.X(p,k) for aeSIX(p,k)l \nand 1 s k < n(p): ~(v) = a,X(p,k)(e~(vl)* . sew(vn)* T[kl) Note that VI, . . . ,Vn are occurrences of \nattributes of X(p.k) in this case. [Case 31 V=ai.X(p,O) for 1 < i < m: =p(v) = xi [Example] When p is \na production rule X + YZ whose semantic rule and DG~ are given by  x L-1-il c.Y = a.X e.Z = a.X b.X \n= h(d.Y, f.z) YcdA Zef and if there is no other production rules with left side symbol X then we have \n= lambda x,T b,X h(Fd,y(xsT[l])s Ff,z(x,T[2])) NOW we show that the function Fb,x correctly performs \nthe task of attribute evaluation. [Theorem21 LetTbea derivation tree with root node r labeled X. If \nb .s S[X] and in[b,X] = {al, . . . ,am} then we have val(b.r) = Fb,x(val(al.r), . . . ,val(am.r), T) \n(Proof) By induction on the height h(T) of T. (h(T) is defined in the ususal way as the length of the \nlongest path in T). In the following we denote by p the production rule applied at the root r of T. First \nconsider the case h(T) = 1. Aspis a terminating rule in this case and attributes are attached only to \nnonterminal symbols, any direct predecessor of v=b.X(p,O) in DG~ is of the form ai.X(psO). From the construction \nof Fb,x we have Fb,x(xl. . . . ,5, T) = fp,v(xl. . . . .%) . On the other hand, the intuitive semantics \nfor attribute grammars gives val(b.r) = f P,v(val(al.r), . . . ,val(am.r)) as ai.rts are the direct \npredecessors of b-r in DGT, and we have val(b.r) = Fb,X(val(al.r), . . . ,val(am.r)~ T) . This gives \nthe basis of the induction. Now, suppose the theorem holds for any derivation tree of height less than \nh and consider a derivation tree T of height h. For each attribute occurrence v=a.X(p,k) of the production \nrule p applied at the root r of T we denote the corresponding occurrence of the attribute a in DGT by \nv =a.r[k]. If VI, . . . ,Vn are the direct predecessors of a node v in DG~ then we have, from the intuitive \nsemantics for attribute grammars, val(vt) =f P,v(val(vl ), . . . ,val(vn )) in case where v=b.X(p,O) \nor v=a.X(p,k) for a .s IIX(p,k)] and 1 S k S n(p). When v=a.X(p,k) for a e SIX(p,k)I and 1 s k s n(p) \nwe have val(v!) = Fa,x(p,k)(val(vli), . . . ,val(vnt), T[k]) by the induction hypothesis as h(T[k]) < \nh(T)-1. Therefore, from the definition of Fb,x. we can conclude that val(b.r) = Fb,x(val(al.r), . . . \n.val(am.r)) and this completes the proof. c1 Here we are in position where we are able to prove the \ncompleteness theorem. [Theorem 3] Our verification procedure is complete. (Proof) Suppose a proposition \nct(s~, . . . * Sn ) about parallelly evaluable attributes Sls . . . .Sn of the start symbol S is true \nat the root node of any derivation tree derivable from S. For each X E VN we define B[X] = {top(A) ! \nA c S[X] } where top(A) = {ala eA and there is no b eA such that (a,b) is an edge of DG[X]] . Note that \nB[X] is the family of all the sets of fis synthesized attributes which are evt?luable in parallel. We \nset the assertion of the following form for each X6VNand B6B[X]. ~e~ [b=Fb,x(ab~, ab~, . . . ,abmb, T)] \n aX,B = TET where v and A are the existential and universal quantifiers respectively and in[b,X] = {abl, \n. . . . abm what follows we show that t? ln (1) VX,B S and =J U(sl, ... ,Sn)(2) %{sl, . . . ,Sn] are \nvalid formulas to prove the theorem. Let be a verification condition X,B associated with a production \nrule p. As assertions are assigned only to the sets of synthesized attributes, we have X=X(p,O) and B \nc SIX(p,O)] and is written as X,B l<i<h =X(p,ki),Bi] A r[p] = X(p,O),B where kl? . . . ,kh are among \n1, . . . ,n(p). We show that VX,B is true for any combination of specific attribute values substituted \nfor the corresponding attribute occurrences in it. We denote, however, the specific values by the notations \nfor the attribute occurrences for the sake of typographical clarity. Suppose X(p,ki),Bi for the specific \nattribute values is true for i=l,...,h. Then we have, for some derivation tree Tk. with root X(p,ki) \nand for any c e Bi, 1 c.X(p,ki) (acl.x(p,ki)s...sacm .X(p,ki),Tk ) = c.X(p>ki) ci where in[c,X(pski)]={acl \n. . . ..acm ]. We construct a tree Twith;oot X(p,O) in the following manner. Let 11,12,...,n(p)p) be \ndisjoint sets of integers such that 11U12U...UIn(p) = {1,2,...,h] and for each k=l,...,n(p) and i 6 \nIk ki=k. For k.1,...,n(p) such that Ik Z @ construct a set B(k) = top(UielkBi) . As B(k) is evaluable \nin parallel, construction of ax,B implies that B(k) = Bi(k) fOr some i(k) C Ik. Note that Bi(k) and its \npredecessors contain all the attributes of X(p,k) which are required to evaluate attributes B of X. For \neach k=l,...,n(p) we define T[k], the k-th subtree of T, as T[k] = Ti(k) ... when Ik ~ @ = X(p,k) : the \ntree which consists of a single node X(p,k) ... when Ik =!3 . T is apparently a derivation tree of the \nunderlying context free grammar. It is not difficult to see that for this derivation tree T the construction \nof essential requirement that verification of large the function Fb,X implies software may succeed. One \nof the authors has proposed a hierarchical b.X(p,O) = Fb,X(p,o)(abl.X(P,C)), . . ..a bmb .X( P, O) ST) \nand functional programming method called HFP [6] based on attribute grammar. The verification for any \nb e B if sr[p] is true. Thus we have shown procedure presented here can also be applied to HFP the verification \ncondition VX,B holds. with a small modification and the fact that it can It is easy to show that enjoy \nthe above-mentioned merit with respect to it verification makes us believe HFP a useful = ct(sl,...,sn \n) programming method. S,{al,...,sn} holds. As there are no predecessors References of S1 ,..., sn, 1. \nBochmann, G.V. Semantic evaluation from left to right. Comm. ACM 19,2(Feb. 1976), 55-61 aS.{51S . . ..Sn} \n= TCTAISiSn [Si = F~i,s(T)l . 2. Chirica, L. M., Martin, D.F. An order-algebraic Consider any specific \nvalues sit,...,sn~ Of S~s...S definition of Knuthian semantics. MST 13, 1-27 (1979) ~~m~~~et;~;~~l~~ \n ssn] s rue hen or 3. Jazayeri, M. On attribute grammare and the semantic specification of programming \nsi? =F i*s(T) languages. Ph.D. Th., Compt. and Inform. Sci. Dept., Case Western Reserve U., Cleveland, \nand sit is really the value of the attribute Si Ohio, Ott.1974 evaluated at the root of T by Theorem \n2. 4. Kaetens, U. Ordered Attribute Grammars. Acts Therefore, by the assumption on the proposition Informatica \n13(1980), 229-256 a(sl,.. .,sn ) , 5. Katayama, T. Translation of attribute grammar into procedures. \nTech. Rep. CS-K8001, Dept. of a(sl~, . . ..sn ~) = true Compt. Sci., Tokyo Inst. of Tech., Tokyo, July \n1980. Also submitted to TOPLAS. and we have thus obtained the desired result. D 6. Katayama, T. HFP: \nA hierarchical and functional programming methodology based on Now a single comment is in order. In \nthe attribute grammar. Tech. Rep. CS-K8002, Tokyo proof of the completeness theorem we have assigned \nInst. of Tech., Tokyo, 1980, Also, to be assertions only to the sets of synthesized presented at 5th \nInternational Conference on attributes. This does not mean, however, that we Software Engineering. can \nalways follow this policy in practice, because 7. Kennedy, K.. and Warren, S.K. Automatic in general \nit is not always possible to find the generation of efficient evaluators for closed form of the function \nand we have to attribute grammars. Conf. Rec. 3rd ACM Symp. on F B,x find appropriate asserted sets which \nare not only Principles of Programming Languages, Atlanta, subsets of SIXI but also of IIXI. Ga., Jan. \n1976, pp.32-49. 8. Knuth. D.E. Semantics of context-free . 6. Concluding remarka languages. MST 2(1968), \n127-145. 9. Pair, C., Amirchahy, M., Neel, D. Correctness A verification procedure for attribute grammar \nproofs of syntax-directed processing is presented and its consistency and completeness descriptions by \nattributes. JCSS 19, 1-17 are established. (1979) Although the usage of attribute grammar is now 10. \nSaarinen, M. On Constructing Efficient limited only for sxpe?imentsl compiler wwieing. Evaluato~c for \nAtt~<bute Cvam%ave. Le.sktir. progress about their evaluation techniques will Note in Computer Science \nNo.62, Automata, make it stand to be used in constructing production Language and Programming, Springer-Verlag \nquality compilers in near future and this will make (1978), 382-396 their verification an important phase \nin compiler construction. The advantage of the verification procedure for attribute grammar is that it \ncanbe performed modularly (production-rule-wise) only by considering local data (attributes) relevant \nto the production rule and this is in general the \n\t\t\t", "proc_id": "567532", "abstract": "Verification of attribute grammar is discussed. As is widely recognized, attribute grammar of Knuth [8] is a very convenient device to describe semantics of programming languages, especially in automating compiler construction. Many efforts have been made to obtain efficient evaluators for attribute grammar [1,3,4,5,7,10] so that efficient compilers may be produced from the semantic specifications written in the attribute grammar.There is another important problem about the semantic specifications. This is how to verify the correctness of the specification and is essential in ascertaining the correctness of produced compilers. In contrast with the evaluation problem, this has not been studied well and only a few partial results have been reported up to now [2,9].In this paper we propose a verification procedure for proving the correctness of attribute grammar, which is applicable to the wide class of attribute grammars called absolutely noncircular ones [7]. Our method can be extended to accept any noncircular attribute grammar since it is shown that any noncircular attribute grammar is transformed into an equivalent absolutely noncircular one [5].Our verification procedure utilizes dependency relations among attributes and verification is performed by induction based on this order relation, according to which attributes are evaluated. This procedure consists of (1) assigning assertions to relevant pairs of a nonterminal symbol and a parallelly evaluable subset of its attributes, (2) generating a set of verification conditions for each production rule with the aid of dependency graph of the rule and (3) proving the verification conditions. Of course, verification is performed production-rule-wise.Our method can accept attribute grammars which contain both synthesized and inherited attributes and handle them in a well-formed way. This contrasts to the previous works where only the synthesized case is considered [2] or there seems no general and formal descriptions about how to verify general attribute grammars [9].In this paper we first give necessary definitions and notations for attribute grammar and then propose a verification procedure to prove its correctness. After giving some examples of verification, we establish consistency and completeness of our procedure.", "authors": [{"name": "Takuya Katayama", "author_profile_id": "81100019572", "affiliation": "Tokyo Institute of Technology, Ookayama, Meguro, Tokyo 152", "person_id": "PP39023479", "email_address": "", "orcid_id": ""}, {"name": "Yutaka Hoshino", "author_profile_id": "81100228908", "affiliation": "Tokyo Institute of Technology, Ookayama, Meguro, Tokyo 152", "person_id": "P383054", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567552", "year": "1981", "article_id": "567552", "conference": "POPL", "title": "Verification of attribute grammar", "url": "http://dl.acm.org/citation.cfm?id=567552"}