{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 same input-output semantics however, since the former diverges whenever \ny is a nonstandard integer (cf. Section 2.4). (3) If we consider arbitrary interpretations, then there \nare two program schemes similar to those above which are indistinguishable by partial correctness assertions \ninvolving open first-order formulas, but aredistinguishable by such assertions when quantified first-order \nformulas are used (cf.[MH,3.2]). (4) If reconsider states augmented with uninterpreted function symbols, \nthen for any countable set of partial correctness assertions there is a (generally noneffective) program \ninequivalent to the identity program NOP but which satisfies the same partial correctness assertions \nas NOP (Proposition 5.4).  In the next section we review precisely what it means for a class of partial \ncorrectness assertions to define the input-output semantics of a class of programs. In section 3 we give \nsome general sufficient conditions for partial correctness assertions involving a given class Q of predicates \nto define a given class 5? of input-output relations. The main condition is that the predicates in ~ \nbe box closed for the relations in ~; box-closure amounts to an abstract version of Cook s [Cl familiar \nnotion that the assertion language for 9 is expressive for the programming language for ~. A trivial \napplication of these conditions yields observation (1) above. ,Observation O) shows that it is sometimes \npossible for partial correctness assertions to determine input-output semantics absolutely. That is, \nthe input-output semantics of a program from a given programming language is absolutely determined when \nits input-output relation is dk.tingukhable from al) other input-output relations (not necessarily only \nthose of programs in the language) by means of f%partial correctness assertions, where ~ k some class \nof predicates. In what other circumstances this can occur? The answer to this question is trivially negative \nunless we agree to identify states which are indistinguishable as far as the predicates of ~ are concerned; \nsuch states are said to be S%equivalent. We consider the concept of definability up (o %equivalerrcein \nSection 4 and observe that box-closure again yields a sufficient condition for program semantics to be \ndefinable up to ~-equivalence for boundedly nondeterministic programs, but nor for unfoundedly nondeterministic \nones, (Box-closure, or more precisely its syntactic counterpart, expressiveness, has been widely studied \nas a sufficient condition for completeness of axiom systems for partial correctness assertions (cf.[Al). \nThe insufficiency of expressiveness for ensuring semantical definability points out the existence of \ncases where one can have a complete axiom system for partial correctness assertions about some class \nof programs but still not be able to prove that certain programs are correct.) Finally in Section 5 we \nestablish observation (4) above, concluding that with the exception of a few restricted examples like \n(l), it is no[ possible for S2ZJ-partial correctness assertions to absolutely determine (merely up to \nS%equivalence) thesemantics of even simple flowcharts, for any countable class 93 of predicates. So the \nbest one can expect of partial correctness specifications are the kind of results obtained earlier --that \nthey distinguish among programs whose input-output relations are known to lie in some large domain of \nreasonable relations. 2. Basic Definitions Most of the terminology used in this paper is taken from [MHJ \nor [GM j, suitably modified to meet our purposes. We repeat the important definitions here for the sake \nof completeness, 2.1 We assume that programs run on machines with states. For now we will treat states \nas abstract elements in some class ~ ignoring their internal structure. (However, this will change slightly \nin the next section). A predica(e p is a mapping from ~to truth values. We write s != p if p(s) = T and \n%i=pifs i=pforalls~x We will think of (possibly nondeterministic) programs as defining a binary relation \non states. If u is a program, then Ra is the initial state-final state relation defined by a, namely \nRa = {(s,t) I t is a state which is a possible result of program a when started in state s}. If %is a \nclass of states, R is a binary relation on Z and p is a predicate on z then we can define a new predicate \n CRIP on X as follows: s t= [R]p iff t 1= p for all t such that (s,t) ~ R. Also, <R>p is a predicate \non % equivalent by definition to -[ R]=P. That is, s k= <R>p iff t 1= p for some t such that (s,t) c \nR. 2.3 Partial Correctness and Termination Let $ i be a class of states, 9 a class of predicates on ~ \nand R a binary relation on K Then the B-partial correcmess [heory of R, denoted PC~(R), is That is, (p,q) \n~ PC~R) iff for all(s,t)6R, ifs* pthen t1=q. Similarly, the S%termination theory of R, denoted Tc#Rl, \nis 2.4 Definitions by Assertions Let % be a class of states, @ a class of binary relations on K(think \nof 9? as the input-output relations defined by some set of programs), and 9 a class of predicates on \nK Then we say that .@partial correctness (resp. termination) assertions define t% when for all RI, R2 \n~~, RI = R2 iff PCC#R1) = PC@R2) (resp. T#Rl) = T~(R2)). we address ourselves is for which ~ ~ and ~ \nis it the case that f%-partial correctness (resp. termination) assertions define % ? Although it was \nobserved in [BTTI that choosing 9 to be the first order definable predicates suffices in most circumstances \n(providing uninterpreted function or predicate symbols are available), observation (2) in the introduction \nreveals that the natural class of first order partial correctness assertions are not always adequate \nfor defining semantics, as we now verify. Let a be the program scheme x=Qwhile x4ydo x=S(x)od, and let \nb be the program scheme x = y. Take 9 to be the class of predicates defined by first order predicate \ncalculus. If we take Ra and Rb to be the input-output relations defined by a and b on al! states, then \nPCgj(RJ 4 PCC#RJ; for example the pair (V~S(z) 4y) Ay40, @/se)isin PC~(RJ but not in PCC#RJ. However, \nif we let Kbe the class of nonstandard models of the integers with successor (i.e. S is always interpreted \nas successor, and all other functions and predicates are trivial), and take Ra , Rb to be the input-output \nrelations defined by a and b on X then it can be shown that PC~(Ra ) = pC~(Rb ), although clearly we \nstill have Ra # Rb . 3. A Sufficient Condition for Axiomatic Definitions 3.1 Definition A type (or signature) \nis a set of objects called symbols, Each symbol is either a function symbol or predica(e symbol, and \nhas an associated non-negative ari(y. (Variables and constants are simply treated as zeroary function \nsymbols). A type is said to be finite if it has only finitely many function symbols and predicate symbols. \nA state s of type r consists of a non-empty set Dom(s) called the domain, and a mapping from each function \n(resp. predicate) symbol f e ~ to a value s(O which is a function (resp. predicate) on Dom(s) of arity \nmatching that of f. Thus, the general question to which 3.2 Let To be a (fixed) type which has countably \nmany function symbols and predicate sytnbols of each arity, We henceforth assume that all types considered \nare subsets of TO Let i be the class of all states (of type rd. In what follows we iet %denote a subclass \nof ~ and % a class of binary relations on X In [MHl we considered several classes of relations on % including: \n(a) @arb -the input-output relations defined by arbitrary nondeterministic, possibly infinite flowchart \nschemes of finite type with first order tests, simple assignments, array assignments, and random assignments \n(see [,MH 1 for more details), (b) 9re -those relations defined by recursively enumerable flowchart schemes \nof finite type, (C) filvhi[e -those relations defined by while-program schemes of finite type, It was \nshown that first-order termination assertions defined f?i arb and first order partial correctness assertions \ndefined 9?re, but quantifier-free partial correctness assertions did not even define %Whi[e (cf. [MH, \nSections 3.2, 4.1, 5.1]). We now abstract the main ideas from these proofs to obtain a sufficient condition \nfor f%partial correctness (resp. termination) assertions to define ~. 3,3 Definition Two types r, r are \nsaid to be ma(ched if there is a bijection ~ + ~ which maps the function (resp. predicate) symbols of \n~ to function (resp. predicate) symbok in r of the same arity. For states s, s , we will write SIT = \ns 1~1if s(f) = s (f ) for each f ~ r and corresponding f c 7 . 3.4 Dej7nition: ~is closed if, for all \ns, t c %such that Dam(s) = Dam(t), and for all disjoint matched 7, T , there exists u ~ %such that Ulr \n= Slr and ulr~ = t{r. (The idea is that 3 i __isclosed if, given s, t E Sf and r, we can find a u ~ ~in \nwhich we can code up the behavior of both Slr and tlr.) ~is almost closed if there exists a finite type \n~~ such that for all s, t c L% with Dam(s) = Dam(t) and for all matched ~, ~ such that ? n 7 = @ and \nr n T1 =P, there exists u c ~ such that Ulr = Slr and Ulrt = tlr. In this case we say Sfis closed ou/.ride \nrl. 3.5 Exampkm 1. @ is closed. 2. %,={ sG%\\for  all functions f f r of arity 2 1 and ail predicates \nP # r, s 1=(f is projection on the first coordinate and P is trivial)] is closed. &#38;v can be viewed \nas the states of type 7. .. function symbol. Then ~ = {s l(Dom(s), 0, is a group} #closed. 1Suppose \n is a binary 4. Suppose +, x are binary function symbols, and O, 1 are constants. Then Xfield = {S I \n(Dom(s), +, x, 0, 1) is a field} is almost closed (take 71=0! x,0,1}). 5, Similarly XpA = [S / (Dom(s), \n+, X, O, 1) is a model of Peano Arithmetic} is almost closed. 6. Finally, %arith = {S I Dam(s) = IN, \ns(0) = O, s(1) = 1, with the usual interpretation of + and x on the integers) is almost closed. The states \nin %arith are called arithmetic slates, The motivation here is that the variables represent the names \nof memory registers in a machine, while the state specifies the contents of all the registers. 3.6 A \nclass of predicates ~ on X is closed under box (resp. diamond) with respect to @ iff [R]p (resp. <R>p) \nE ~ for all p ~ 9 and R ~ % . Similarly, we say 9 is c/osea under negation (resp. disjunction) iff for \nall p, q 69, 1P (resp. pVq) c~. 3.7 Dejini!iom A binary relation R on ~is said to be of type ~ = 7(R) \nif (i) (s,t) ER ~ S! = To-? tlrO_r (i.e. R only affects r), (ii) if(s,t)~R,s eZ and S 17 = s&#38;,, \nthen for some t ~ ~ such that t l~ = tlr, we have (s , t ) a R, (iii) r is the smallest class with properties \n(i) and (ii), iNote the relations in ~arb, ~re, and awhile are all of finite type, 3.8 Definition Let \n~be a class of predicates on ~and $? a set of binary relations of finite type on % Then we say S23can \ndistinguish the types of $% if for any RI, R2 ~~, if r = 7(R1)U7(R2) and r matches 7, then there is a \npredicate Pr,71 c ~ such that for allsez s t= pr,rl iff SIT = Slrf We say @ can specify the types of \nqifforany R1, R2~~and se% if?= T(RI) U T(R2), there is a predicate qs,r e ~ such that for all tew t f= \nqs,7 iff tlr = sir.  3.9 Exampkc 1. First order predicates can distinguish the types of ~arb Suppose, \nfor example, that RI, R2 c garb and r = 7(R1) U 7(R2) = {xl, x2, fl, f2), where f 1, f2 are unary function \nsymbols. Suppose ~ = {x~ , x~ , fl , f2 ) matches r, Then we can take pr T, to be: P (X1 =xl AX2=x2 \nA ~x3(f1(x3) = fl (x3) A f2(x3) = f2 (x3)). 2. Quantifier-free formulas cannof distinguish the types \nof .f%arb (or for that matter), However, while they can distinguish the types of ~arb restricted to \nl@ (this is essentially equivalent to disallowing array assignments in our programs). 3. Quantifier-free \nformulas can specify the types for f??arb restricted tO %arith n 9/ ~,xl (again we are essentially disallowing \narray assignments in our programs). Having defined all this terminology, we can now state some quite \ngeneral sufficient conditions for partial correctness assertions to define semantics. 3.10 Theorem: Suppose \nXis almost closed, ~ is a class of binary relations of finite type on ~ and 9 is a class of predicates \non ~ closed under box (resp, diamond) with respect to f?? and under negation, and able to distinguish \nthe types of ~. Then ~-partial correctness (resp, termination) assertions define .%. Proo$ We consider \nthe case of partial correctness assertions. The proof for termination assertions is similar. Suppose \nX_is closed outside r 1. Suppose Rl, R2 c 3? and RI 4 R2. We want to show PC~(R1) # PC@R2). Without loss \nof generality we can suppose (sjt) ~ RI -R2. Let T = 7(R1) U 7(R2), and choose a r s TO -(T ~ u r) which \nmatches r. Let S 6 xbe such that S lr : S[7 and s lr~ = t17. (Such an s exists since Xis closed outside \n7 l). Since s lr(R1l , we can = lr(R1) also find a state t c Y/such that and (s ,t ) 6 R1. lr(R1) = IT(R1) \nNote that in fact (1) t lrtlr = sincetlT-r(R1) = lr-7(Rl) (since (s,t) ~ RI) = lr_~(R1) (since sir \n= s lr) = 17-7(R1) (since k. ,t l c R1 and lr(R1) = 17(R1)) lMoreover, t lr, = s lr, (again because \nr g ~0-dR1) and (s ,t ) ~ Rl) and by construction we have S lrt = tlr . So we have (2) t lr~ = tlr. \nSince ~ distinguishes the types of % , there is a predicate pr~, cSD such that u I= pr ~~ iff U17 = UIT,. \nFrom (1) and (2) it follows that t 1= pT,7t. It is easy to see that for any predicate p we have ([ R2]p, \np) G PC~(R2). In particular, we have ([ R2]=pr,r/, qpr ~J 1 ~ PCg(R2). However, ([ R211pr,rI, p) @ \nPC.@R1). To show this, it suffices to show S 1= [R217P7,71, since we have already shown that t I=pr ~tand(s \n,t ) ~RI. So suppose: in order to obtain a contradiction, suppose that (s ,u~ E R2 and u 1= pr,r,. Then \nsince lr(R2) = l~(R2)? we can find u E Xsuch that u lr(R2) = l~(R2) and (s,u) e R2. But just as above \nwe can show that (3) U lr = Ulr. Since u t= pr TJ we must also > have (4) U IT = U IT . Moreover, since \nr c Tn -7(RJ and A (s ,u ) c R2, it follows ~hat (5) S ITf = U lr,. And finally, from (3), (4), (5) \nand the fact that S lr ~ = tlr we have (6) U[r = tlr. But (s,t) c RI, (s,u) E R2 imply that From (6) \nand (7) it follows that u = t, contradicting the fact that (slt) # R2. Thus we have ([ R217pr,rJ,1pr,TJ) \nG PC@R2) -PCg(R1). B 3.11 Coro//ar~ ~ partial correctness assertions define the semantics of r,e. programs \non any closed subset of states where ~ is the class of predicates definable in (a) first order dynamic \nlogic, (b) first order arithmetic, (e) -predicate second order calculus, (f) weak second order predicate \ncalculus.  Proof Each of these classes of predicates can be shown to be closed under box with respect \nto are. The result then follows irhmediately from Theorem 3.10. 0 3.12 Remarks 1. We can slightly weaken \nthe hypothesis that SZJis closed under box (resp. diamond) with respect to ~. It is sufficient that [R]p \n(resp. <R>p) is equivalent to a (possibly infinite) disjunction of predicates in ~. If ~ is the class \nof formulas of first order predicate calculus, then @ is no( closed under diamond with respect to ~arb, \nbut it is weakly closed in the above sense (cf. [JMH, Lemma 2.9]). Thus first order termination assertions \ndefine ~arb (cf. [MH, Theorem 5,1). . 2. First order predicates are nof closed under box with respect \nto 9 arb. However, as shown in [Mm, first order predicates are almost closed under box with respect to \nS?re in the following sense: If Reqre, andFisafirst order formula, then there is a first order formula \nG such that (i) 1= G * [R]F, and 144 (ii) if [R]F and Dom(s) is s I= infinite, then s 1=G for some \ns e % with sir(R) = S 17(R). This turns out to be enough to guarantee that first order partial correctness \nassertions do define are (as well as are restricted to any almost closed class of states). 3.13 ?%eorenz: \nSuppose ~ is a class of binary relations on ~ and ~ is a class of predicates on ~closed under negation \nand able to specify the types of %. Then S%partiai correctness (resp. termination) assertions define \n~. Proof Again we just consider partial correctness assertions. Suppose RI, R2 6 ~, and RI 4 R2, We want \nto show PC~(R 1), # PC~(R2). Again we can suppose without loss ~f generality that (s,t) ~ R1 -R2. Let \nr = r(Rl) U r(R2), and take qs,~, qt,r as in Definition 3.8. Note (s,t) c R1, so (qs,r,-qt,r) 4 PC~(R1). \n Ut @5,r,7qt,T)For ~PCj(R2). suppose not. Then for some (s ,t ) we must have s 1=q$,~, t 1=qt,,. Since \nS lt = sir, there must exist uE %such that Ulr = t 1, and (s,u) ~ R2. But t i= qt, ~ implies t lr =tlr, \nsoUlr =tlr. And since (s,t) 6 R1 and (s,u) ~ R2, we must have tlr -: Sir .7 = Ul,o.r. or o Hence t = \nu, contradicting the fact that (s,t) d R2. n %.14 Corollary: Quantifier-free assertions define ~arb \nrestricted to 4. Definability Modulo @-Equivalence 4.1 Defini[iom Two states s,t are g-equivalent, in \nsymbols s ~g t, if and only if they satisfy exactly the same predicates in ~; i.e. s i= p iff t t= p \nfor all p 6 ~, If R is a binary relation on Z the @-closure of R is Two relations are S%equiva/ent, in \nsymbols RI ~~ R2, if and only if they have the same @closure. In choosing to restrict the class of predicates \nused to make assertions about programs to some class 93, a decision to ignore distinctions among ~-equivalent \nstates is in effect also being made, In general we may expect that 4? is chosen to be the class of predicates \ndefinable in a rich enough language that .f%equivalent states look alike , so no problem arises in identifying \nthem. This is precisely what happens for all the examples considered in the last section, as the following \nlemma shows: 4.2 Lemm~ If $fis almost closed and Si2Jis closed under negation and under box with respect \nto 5? and able to distinguish the types of ~, then for all Rl, R2 ~ %, RI =R2 iff RI ~~ R2. Proof This \nfollows immediately from Theorem 3.10 and Lemma 4.3 below, which should be obvious. 4.3 Lemm@ If RI ~~ \nR2 then PCgI(R1) = PCc#R2). Essentially, Lemma 4.3 states that implementations which differ only in the \nsubstitutions of S%equivalemt states for one another are bound to satisfy the same specifications when \nthese specifications involve only predicates in ~. Again, the question arises as to when the converse \nto Lemma 4.3 holds.  4.4 Definition S%partial correctness assertions dej7ne ~ up to g-equivalence iff \nfor all RI, R2 ~ % RI 59 R2 iff PC@R1) = PCa(R2). A sufficient condition for ~ to define ~ up to SD-equivalence \nis provided by Proposition 4.6 below, 4.5 Definition: A binary relation R on Xis said to be fini(e relaling \nif {tl (s,t) c R) is finite for every s E ~ 4,6 Proposition If @ is closed under negation, finite disju \nnction, and under box with respect to ~, false~ ~, and every R c .% is finite relating, then ~-partial \ncorrectness assertions define~ up to SD-equivalence. Prooji Suppose RI, R2 c% and RI #~R2. We want to \nshow PC~R1) # PC~(R2). Again, suppose (s,t) e cl~, Rl) -c@,R2), Since R2 is finite relating, we can suppose \n{u I (s,u) ~ R2) = {Ul,...,Un}, And since for each i we have t $9 ui, there must be a predicate qi 6 \n~ such that t B ~qi and ui Rq~ Let q =V i<n qi. (If n = O, let q = false). Then it is easy to check that \n([ R21q, q) E PC~(R2) -PCC#R1). a  4.7 Remark: The hypothesis that every R ~ @ be finite relating is \nnecessary, as the following example shows: Let ~ be the following program scheme (cf. [MH, Example 3.21) \nif (y $x Vz#f(x))then ATOP else while y ~ z do z = f(tlz)); y z f(y) od; Y =X; z= fix) fi The program \n~ essentially checks to see if {x, fix), f2(x),... ] are all distinct. If so, it halts and acts like \nA OP (the program which does nothing; i.e. RNOP = {(S}S) I s ~ %]). If not, then ~ diverges. For n \n>0, let an be the scheme fi(x) 4 fj(x)) f A()<i<j<n then fn(x) = x else NOP fi. If {x, fix),. ... PYx)) \nare all distinct, then an sets f%x) to x. Otherwise it does nothing. Let a = ~ u (unzlan), b = NOP U \n(Un>lan). Note that (by definition) Ra = Un>oRn and Rb = RNOP U (lJn2 lRn) (where we have shortened R \nto Rn). an Let ~ be the class of predicates defined by quantifier-free first-order formulas (of type \nr~, Then we claim: 1. If q c ~, then [RJq, [RJq E~, The first claim follows easily from the following: \nLemma If q 6 Q, there exists a finite set of terms Tq such that if s(Tq) = t(Tq), then si=qifft!=q, The \nproof, which is omitted, follows by induction on the structure of formulas. Given q c ~, choose Tq as \nabove and let no = max {n I fn(x) ~ Tq}, Then if k > no, we have (*) t=[R@ = q Moreover, note that R. \n= RNOP -{(s,s) I s != x, f(x), f2(x), are all distinct and y = x and z = f(x)}. So we have s 1=[Rdq z \ntrue if (s,s) 6 RNOP -Ro, s 1=[Rdq z q otherwise, Thus (**) 1= ([Rdq ~ /rue) V ([Rdq ~ q). From (*) and \n(**) it follows that 1= [R>q = Ak~~Rk]q = [Rk]q) A q. AISkfno Similarly ~ [Rjh = (Al<k<noA q. .-[Rk]q) \nSince[Rk]q ~@fork~1,we have proved claim 1. Claim 3 follows from the fact that [R~q = [R$q for all q \nG ~. Finally, if we take a state s e % whose domain is the integers, with s(x) = s(y) = O, s(z)=1, and \ns(fl the successor function, then it is easy to see (s,s) is in the S%closure of Rb but not of R@ proving \nclaim 2. II 5. Absolute Dej7nabili!y We now turn to the question posed in the introduction of determining \nsemantics absolutely. 5.1 Dej7ni(iom S%partial correctness assertions define $? ahstdutely if, for all \nR ~ c @ and R2 an arbitrary binary relation on ~ Thus, the relations in % can be distinguished from u// \nother f%inequivalent binary relations on Xby their ~-partial correctness theories. 5.2 In an important \nspecial case, namely when we take ~ to be arbitrary flowchart schemes restricted to %arith n @p,xl (that \nis, the arithmetic states of type @,x]), it is easy to check that quantifier-free formulas define % absolutely. \nBut this example is just that a special case. As the following proposition shows, if we just enlarge \nthe type of the states slightly, e.g., by considering %arith n ~~,x,p,~, where f is a unary function \nand P is a unary predicate, then not even first order predicate calculus formulas can absolutely define \narbitrary flowchart schemes. In fact, no countable class of predicates can do the job. The following \nproposition generalizes a result of [JMH, Appendix C.2)]. A similar result has been obtained independently \nby J, Tiuryn, 5.3 Definition Type r is uninterpreted over %iff for every s e %, there exists an s IEXsuch \nthat sir = S !r. 5.4 Proposition Suppose T contains at least one unary function and one unary predicate \nsymbol, r is uninterpreted over Z and ~ is any countable class of predicates on Kclosed under negation \nand conjunction. Then there exists a binary relation R on X_of type r such that R #~ RA,OP but PC~R) \n= PC~RA,O$. Proof Let P be a unary predicate and f a unary function symbol in ~, and let ql, q2) qy... \nbe some enumeration of the predicates in ~ satisfiable by some s E x Define a predicate pi (not necessarily \nin a as follows pi = P($(X)) if qi A P($(x)) is satisfiable, =P( P(x)) otherwise. Note that pi A qi \nis satisfiable for all i, Let buzz be a program scheme which always diverges: while x = X do hrOPod. \n Let R be the input.output relation on %defined by the scheme Ui (if pi then A OP eke buzz fi). It follows \nthat RNOP -R = {(S,S)1SE Ailpi}. Thtls R ~~ RNOP since for some s E ~ s k Ailpi. (Here we need the fact \nthat r is uninterpreted over X) However PC~(R) = PC~(RNo# To see this, note that R G RNOP so l cg@NO~ \nG W@). To prove the converse containment, suppose (qi,q} ~ PC~(R) -PC@ RA,o~. Thus qi A -qj must be satisfiable \nand so must equal qk for some k. But pk A qk is satisfiable, say by s . Thus (s ,s9 e R, and S i= qk, \nSOS ~ (qi A _ qj), contradicting the assumption that (qi,qj) E PC~R). U 6. Conclusions We have shown \nthat in quite general circumstances partial correctness assertions can determine the input-output semantics \nof programming languages. However, this determination is not absolute. We cannot in general hope to distinguish \nthe semantics of a given program from all other input-output semantics, only from those of other programs \nin the language. Acknowledgment: We would like to thank Amir Pnueli for stimulating our interest in absolute \ndefinability, and Jerzy Tiuryn for several useful discussions. References [A] Apt, K. R. Ten Years of \nHoare s Logic, A survey, Part I, 5th Scandinavian Logic Symposium, Jan. 1979, Aaiborg, Denmark; revised \nmanuscript September, 1979, 49pp. [BTTl Bergstra, J.A., J. Tiuryn, and J.V. Tucker. Correctness Theories \nand Program Equivalence, Preprin[, Stichting Mathematisch Centrum, Amsterdam, 1979. [cl Cook, S. A. \nSoundness and Completeness of an axiom system for program verification, SIAM J. Conrputing, 7,1(1978), \n70-90. [GMl Greif, I. and A. R. Meyer, Specifying the Semantics of While- Programs, preliminary report \n(under the title Specifying Programming Language Semantics, ) 6th Annual ACM Symposium on Principles \nof Programming Larrguage.r, January, 1979, 180-189; MIT Laboratory for Computer Science Technical Memorandum \nNo. 130, March, 197935 pp.; to appear ACM Trans. Programming Lang. and Systems, 1980. [HMP] Harel, D., \nA.R. Meyer, and V. Pratt, Computability and Completeness in Logics of Programs: Preliminary Report, 9th \nACIV Symp. on Theory of Computing, Boulder, Colorado, (May, 1977), 261-268. Revised version, M. I.T. \nLab. for Computer Science T,M97, (Feb. 1978), 16 pp. [MHI Meyer, A.R. and J. y. Habern) Axiomatic Definitions \nof Programming Languages: A Theoretical Assessment, (Preliminary Report) Proc. of Seven(h Annual POPL \nConj, January 1980, 203-212; MIT LCS TM 163, April, 1980, 34 pp.; submitted for publication. [,MWl Meyer, \nA.R. and K. Winklmann, On the Expressive Power of Dynamic Logic, Preliminary Report, Proc, of the lI(h \nAnnual AC,W Confi on Theory of Compuling, Atlanta, Ga., May 1979, 167-175; MIT LCS TM 157, February,1980, \n36pp.; submitted for publication. 148 \n\t\t\t", "proc_id": "567532", "abstract": "Sufficient conditions are given for partial correctness assertions to determine the input-output semantics of quite general classes of programming languages. This determination cannot be unique unless states which are indistinguishable by predicates in the assertions are identified. Even when indistinguishable states are identified, partial correctness assertions may not suffice to determine program semantics.", "authors": [{"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "Harvard University, Cambridge, Massachusetts", "person_id": "P149011", "email_address": "", "orcid_id": ""}, {"name": "Albert R. Meyer", "author_profile_id": "81100572937", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP15036546", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567548", "year": "1981", "article_id": "567548", "conference": "POPL", "title": "Axiomatic definitions of programming languages, II", "url": "http://dl.acm.org/citation.cfm?id=567548"}