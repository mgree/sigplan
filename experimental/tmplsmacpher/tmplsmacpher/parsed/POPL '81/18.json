{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 properties ~equi~e that m execution sequence of the program will eventually \nachieve some goal such as termination with a correct result or correct response to some request, The \nin?erpretati.on of tem\u00adporal formulas over execution sequences of a given program was found to be very \nuSe\u00ad ful for reasoning about both sequential deterministic programs and concurren-t pro\u00ad grams. In the \ncase of concurrent prog\u00ad rams, where the nondeterminism is caused by different scheduling scripts, we \ngen\u00ad erally wish to prove that the program ter\u00adminates OP responds correctly regardless of how the individual \nprocesses are sched\u00aduled. This approach is pursued in [F NI, [MP], [L]. The branching time approach, \non the other hand, considers for a given program the set of all execution trees generated by the program. \nWith a nondeterministic program P and a given input x we can associate the tree of all possible compu\u00adtations \nof P on x. Since the program <s nondeterminj-stic, some of the execu\u00ad tion states will have more than \none suc\u00ad cessor corresponding to a nondeterminis\u00ad tic choice. Over execution trees we can study existential \nproperties such as coF\u00adrect termination for at least one possible computation (for every input). More \ngen\u00ad erally, we may study the property that there is always one possible computation which realizes some \ngoal. This certainly does not imply that all computations will realize the same goal. Consequently, this \napproach is useful for nondeterminis\u00ad tic programs which are executed by system\u00adatically exploring all \npossible choices by methods such as breadth first search, etc. This interpretation of nondeterm<n\u00adism \nis recommended for example in [F] as a design tool and is the one classically used in automata and complexity \ntheory. The branching time approach is implied in the underlying structure of Dynamic Logic ([H], [AI), \nbut was not previously studied in a temporal framework. In the end, the choice between linear and branching \nmodels cannot be made on philosophical grounds but instead should be dictated by the type of programs, \nexec uti.on policies and properties which one wishes to study. For a fuller discussion of this issue \nsee [L]. A natural step at this point would be to formalize and investigate a branching temporal logic \ni_n o~der to compare the two approaches discussed above under the con\u00adtrolled environment of the same \nlogic. It turns out that a unified system which com\u00adbines both approaches is no more complex than the \ntwo separate systems. We define UB: the unified system of branching time. The underlying model will be \nthe branching tree of all possible com\u00adputations of a program. We define, how\u00adever, additional temporal \noperators that allow reference either to all possible ex\u00adecution sequences or only to a single se\u00adquence. \nThe meta-theoretical results in UB include: 1) An exponential decision procedure for satisfiability. \n2) A finite model property. 3) A simple axiomatization which is shown to be complete. The decision procedure \nuses semantic tableaux. Tableaux systems provide a rap\u00adid way of deciding natural formulas. The completeness \ntheorem shows how to read-off a Proof from a tableau. The expressive power of the system is illustrated \nby formalizing both universal and existential properties of nondetermin\u00ad istic programs. Finally we give \na tempor\u00adal semantics for nondeterministic pro\u00adg~ams , complementing the semantics given in [PN] for \ndeterministic but concurrent programs. The semantics will be given for programs which are presented both \nin graph form and in structured form. The UB Language-Syntax and Semantics The base of ~8 is the p~opositional \ncalculus on ~ and v with the other connective defined as usual. We use six modal operators symmetrically \nrepresented .Dy the digraphs: VG,VF,VX,3G,3F and 3X. The first symbol denotes quantification over paths. \nThe second symbol denotes the temporal quantification along the selected paths, with G,l? and X having \ntheir mean\u00adings as in [PN]. Let T be atree and s anode in T. Let a be a proposition which can hold at \nsome nodes in the tree. Then the in\u00adtuitive meaning of the modal operators when applied to a proposition \nis as fol\u00adlows : Wu holds at s(in T) iff a is true at all nodes of the subtree rooted at s (including \ns). VFa holds at s iff on every path departing from s there is some node at which a is tvue. VXa holds \nat s iff u is true at every immediate successor (des\u00adcendant) of s. 3Ga holds at s iff there exists a \npath departing from s such that a is true at all nodes on this path. 3Fa holds at s iff a is true at \nsome node in the subtree rooted at s, i.e. there exists a path departing from s such that a is true at \nsome node on this path. 3Xa holds at s iff a is true at one of the immediate successom of s. We give \na now a more formal defini\u00adtion of the semantics of U13. A model T for UB is a triple T = (S,P,R) where \nS is a set of states and P is an assignment of proposition letters to states. For a proposition a and \na state Scs , aEP(s) iff a is true at the state s. R is a binary relation on states which defines the \nstructure of T. When s Rt holds, we say that t is an immediate successor (descendant) of s. To capture \nthe concept of non ending time, we require that R be total, i.e. Vs3tQ(sRt) -every state has a successor. \nR+: is the reflexive transitive closure of R. Thus sR~:t iff there is an R-path leading from s to t. \nAn s-branch b is an infinite path b = (s = SO,S1,. ..) such that Sits and siRs . We define the 1+1 notion \nof a general formula p being sat\u00adisfied at a node s in T -written as T,s k p or St=p when T is implicitly \nunderstood. 1. For a proposition a, s 1= a iff aEP(s). 2. Sk bp iff S~P 3. s 1=pvq iff Sl=por St=q 4. \ns 1= VGp iff VbVt (tEbat*p) 5, s k VFp iff Vb3t (tEbAt*p)  6. s 1= Vxp i ff Vt(sRtatep) 7. s E 3Gp \niff 3bVt (tEbat@p) 8. s != 2Fp iff 3b3t (t6bAtl=p) 9. s E Slxp iff dt (sRtAt 1= p) In the above formulas \nthe quantification of b is over all the s-branches in T.  A formula p is satisfiable if for some model \nT and some state sES T,s~ p. A formula p is true in T if for every state SES -T,si= p. We write T t= \np. A formula p is valid if it is true for every model T. We write ~ p. In subsequent sections we will \npre\u00adsent a procedure for deciding satisfiabil\u00adity and an axiomatic system for proving all valid formulas \nin UB. Expressing Program Properties in UB As an example of the power of the language to express both \nuniversal and existential properties, consider a non\u00addeterministic program: p:@.>{=>->@ We distinguish \ntwo special locations in this program -the beginning node b and the exit node e. We define special location \npropositions of the form aft for each location L in the program. The pro\u00adposition a.t.t is true at execution \nstate s if the execution currently resides at loc\u00adation t in the program. Consequently the proposition \natb holds at all initial. execution states and the proposition ate is true at all terminated execution \nstates. Let Q and ~ be respectively input and output predicates forming a cor\u00adrectness specification \nfor the program P. Following [Ml], [M2] we can distinguish four types of correctness of P relative to \n(Q?,*): a) P is partially ~-correct with res\u00ad pect to (Q,iJ). Either there is an infinite computation \nor there is a finite correct computa\u00ad tion. This is expressible by the UB formula: If we evaluate this \nformula over execu\u00ad tion trees of the program P i? forces every tree whose initial state satisfies q \nto contain a path all of whose states satisfy ate a +. This implies that the computation corresponding \nto the path either diverges and never reaches t or terminates at Q with $ correct. Once we reach e the \nrest of the branch. must infinitely repeat the same state since the program dictates no farther change. \nThis explains the representation of finite com\u00adputations in our infinite model. b) P is totally ~-correct \nwith respect to (Kl,$). There is a finite correct computation, but other computations may be incorrectly \nterminating or div\u00adergent. This is expressible by: c) P is partially V-correct with respect to (W,*). \nEvery terminating computa\u00ad ti-on must satisfy 4, but there is no guarantee of the existence of any ter\u00ad \nminating computation. This is expres\u00ad sible by: d) P is totally V-correct with respect to (@,$). Every \ncomputation ter\u00adminates and satisfies ~ on ter\u00admination. This is expressible by: A similar four way classification \nis given in [H] for the different notions of total correctness. The model of program to be studied here \nadmits also a 6U.i.&#38;M&#38; node which implies incorrect termination or abortion: :o- 4 The following \nfour notions of total correctness of P with respect to (w,+) are possible: A) For all inputs satisfying \nQ, all computations of P terminate and yield correct results, i.e. re\u00adsults satisfying b. This is ex\u00adpressible \nas: (a-tbw) = VF(a-teA~) B) For all g-inputs, every compu\u00adtation either terminates success\u00adfully or loops. \nNo computation may fail. c) For all ~-inputs each computa\u00adtion will either fail or reach successfully. \nNo infinite compu\u00ad tations are allowed. (aZbA9) = VF(aZ6v(aXeA$)) D) For all ~-inputs there Is at least \none successful computation. Other computations may fail or diverge. Note that B) and C) did not guaran\u00adtee \nthe existence of a successful computa\u00adtion. To enforce this it is sufficient to add the clause 3 FaL6 \n-to the right hand side of the implications. A Deductive System for U% Presented below is a deductive \nsystem of axioms and inference rules for proving validity of UB formulas. We take VG, G and VX as primitive \noperators and define the other modalities by: D1 . vFp z ~3G*p D2. 3Fp = mVG*p D3. ~xp = %Vxmp Alternately \nwe could have taken all six operatom to be primitive but then we should add D1-D3 as axioms. The axiom \nschemata are: Al. 1-VG(paq) n (VGpaVGq) A2. ~ VX(pnq) > (VXpnVXq) A3. I-VGP n VXP A VXVGP A4. 1-VG(pnVXp) \n= (PSv Gp) These four axioms are of universal charac ter. The other four are existential. El. *VG(paq) \na (3Gp~3Gq) E2. I_ 3Gp = p A SlX3GP S3. I-VGp -3GP E4. l-VG(p=HXp) n (P=3GP) The rules of inference are: \nR1 , If p is an instance of a prop\u00adositional tautology then pp. R2 . If bp and kp>q then yq (Modus Ponens). \nR3 . IfI-p then l-VGp (Generaliza\u00adtion). Note in particular the two induction axioms A4 and E4. A4 states \nthat if p is true at the root of a tree, and for ev\u00adery state s in the tree p is inherited by all immediate \ndescendants of s, then p is true for all nodes in the tree. E4 on the other hand states that if P is \ntrue at the root SO, and everywhere in the tree p is inherited by at least one immediate descendant, \nthen there ex\u00adists a rooted path (i.e. an sO-branch) all of whose nodes s atisfy p. In appendix A we \npresent some use\u00ad ful theorems of this deductive system. In particular there is an additional induction \ntheorem: Semantic Tableaux for UB In this section we describe the con struction of semantic tableaux \nformulas in UB, obtain a decision procedure for satisfiability and prove the finite model property. In \nthe next Section we use the tableaux construction to derive the com\u00adpleteness of the deductive system. \nA structure is a triple (S,P,R) where S is a set of states, P is an as signment of formulas to states \nand R is a binary relation on states. It is con venient to use the same name S for a structure and its \nset of states. A structure differs from a model <n that the assignment P is not restricted to propo\u00adsitions, \nnor is it required to always con\u00adtain p or ~p for every p. A formula is a nexttime formula if its principal \nconnective is a modality VX or 3X. A formula is elementary if it is a proposition, the negation of a \nproposi\u00adtion or a nexttime formula. A formula which is not elementary is classified as an a-formula or \na .6-formula accovding to the table below. This table also defines certain subordinate formulas a. and \nB.. 11 A structure T is called a Hintikka set iff: H1 . ~pEs * p@s (abbreviating PCS for pEP(s)). H2. \naes * uEs and aEs, l 2 where a, uI and are in\u00ad a2 stances of the entries in the table. H3 . BE= * Blcs \n~ f3*Es? where 6,B1,62 are instances of the entries in the table. H4.a. If VXpEs then s has at least \none successor and for each t, a successor of s, JKt. b. If ~XpCS then there is t, a successor of s, such \nthat s IN and pEt. c. If qFp6s then there exists an s-branch b and a tEb such that pet. d. If VFpCS then \nfor every s\u00ad branch b there is a tEb sucii that pet. T is a Hintikka set for p if pEs for some SET. a \nal a2 pAq P q =(pvq) -p q P P P VGp P vTVGp 3 Gp P 3T3Gp +}p {;}wp {i}Np - I}P {;}-P 43-P ,5 f32 vFp \nVXVFp P A consequence of the definitions is: Proposition 1 (Hintikka~s Lemma for UB): A UB formula p \nis satisfiable (has a model) iff it has a Hintikka set. It is easy to check that any model is a Hintikka \nset when we extend P to cover all formulas which are true in a state. Similarly, any Hintikka set can \nbe extended to form a model. A semantic tableau is a systematic search for a Hintikka set. The tableau \nis constructed as a tree of nodes, Each node contains a set of formulas derived from the original formula \np whose sat\u00adisfiability we wish to check, Later we identify some of the nodes as states of a structure \nwhich will be shown to be a Hintikka set. Notation: If n is a node of T then Un is the set of formulas \nlabelling n. A formula p may be marked as l check\u00aded p . Let p be a UK formula and label the root of \nthe tree T by {p}. The tableau is constructed inductively from the root by applying the following rules \nto nodes n which are leaves of T. Ra : If @Jn then create m a son urn = (Un-{a}) u {a ,c41,Q2}. By this \nwe mean-mark a as checked and add. a 1 and a .2 6 : If LWJn then create two sons, 1 and m2 f n and let: \nu II?i = (Un -{B]) U {B ,Bi}, i = 1,2. Rx: If all non-elementary formulas in n are checked, let Vn = \n{3xp1,. . .axpk,vxql,. ..k%l} be the set of nextti me formulas in Un, Then, for each i = 1,. ..,lt create \na son m-with 1 urn = Pi>q~2. .->q~}. i If k. 0, L>0, create an only son m with urn = {ql,. ..,ql}o If \nk=1 = O then node n is a terminal leaf; no further rules are applied to n. A node n which is not a leaf \nis called an a-node, 6-node or an X node if the Ra-rule, RB-rule or Rx-rule, res\u00adpectively was applied \nat n. Every X-node is defined to be a state. Two states and are re\u00ad 1 2 lated by R if S2 is the first \nstate en\u00adcountered as a descendant of s, in T. The const??uction of T is kept finite by ob\u00adserving the \ntwo following termination rules : T1 : If a created node n contains both p and Wp then mark this node \nas closed and do not expand it any fur\u00adther. T2: If a state m is to be created as as a son of n, and \nthere is a state t (which has already been created). elsewhere in the tableau such that Um = Ut, then \ndo not create m but connect n to t instead, Since the numbe~ of distinct formulas that can appear in \na Un is finite, these two rules ensure termination, The result\u00ading structure is no longer a tree because \nof T2 but is finite. Consider the resulting structure T as a candidate for being a Hintikka set. It satisfies \nHl, H2, H3 and H4a,b but not necessarily H4c,d. Consequently we proceed to eliminate from T violations \nof H4-c,d. The elimination is performed by successive deletion of nodes. A simi. lar procedure is used \nin [PR] for con\u00adstructing a model for PDL . The deletion of nodes follows the rules below: Ml. Every \nnode which contains both and -p for some p is de\u00adleted, M2. If n is an a-node and m, its son, has been \ndeleted, then de\u00adlete n. M3. If n is a B-node and both its sons, ml and m2, have been deleted, then delete \nn. M4. If n is an X-node and any of its descendants has been dele,\u00adted, then delete n. M5. Let 3FpEn \nwhich is also a state. If there is no path from n leading to a node t contain\u00ading p, then delete n. M6 \n. Let VFpGn which is also a state. If there is a maximal n-path b (a path which cannot be extended), \nsuch that 1) For all tCb, pat; 2) Every VFp node tCb P (i.e. a node to which the ~ rule for VFp has been \napplied) has Is unsatisfiable. only one descendant; tEen delete n. Lemma 1 Tlie root o f T is deleted \nby the elimination process iff pEU is o * The proof of the completeness theorem in the next section \nshows that if the root of T is deleted then the negation of the formula p in the root is provable. Since \n the proof system is sound, p is unsat isfiable. * We need to show that if the root is not  Geleted \nthen p is satisfiable. By Propo\u00adsition 1 it is sufficient to show that there iS a Hintikka set for p. \nThe only step that is not straightforward from the construction is to show that H4 holds for Vf-formulas \n. In fact, the surviving part of T may not form a Hintikka set but we show that we can always construct \na Hintikka set out o f the surviving part of T. An alternative node for VFp is a e-node for VFp both \nof whose sons have survived. Informally we unwind T so that ev\u00ad e~y non-fulfilling branch is forced to \neventually include the fulfilling son of some alternative node. We construct a structure T whose nodes \nare instances of surviving nodes of T. Denote instan\u00adces of nET by n ,n ET etc. In the re\u00admainder of \nthe proof, nodes!! refers only to surviving nodes. n; is the root of T!. If n! is a leaf of T then extend \nTt as follows, where n(n~,nj) denotes the path from n! 1 ton! inT . 3 wl . If n is not an alternative \nnode in T for any VFp, then for every son mi of n let m; be a son of n in T!. W2 . If n is an alternative \nnode in T for some VFpEn, let k be the number of instances of n in r(n~,n ). (i) Ifk = 1 then let mi \n(ar\u00adbitrarily) be the son of n! in T. (ii) If k >1 then if my (m:) LL was the son of n taken at the \nk-1 st instance n of n then let mj (m-j_) be the son of nt in T . Thus we alternate our choices. W3. \nIf n has a previous ins?ance n in ~(n ,n!) and every al\u00adternative node t which has an instance in IT \n(n ,n ) has at least two instances in ~(n ,n ) then identify n wi?h n . The construction must ultimately \nterminate since there is only a finite number of alternative nodes. For suppose that r=mt ml,...is an \ninfinite path > 2 generated by the construction of T . Then since T is finite there is a k such that \nfor all i b k, mi has infin\u00aditely many instances in = m&#38; m~+l~... k In particular, every alternative \nnode in must appear infinitely often and thus k for some !2, m~ and ml are instances of the same node \nand every alternative node which appears in ~k appears at least twice in Thus W3 should k have been \napplied to identify m; and m;. Let VFpEn ET and suppose that there is an n -branch b in T which does \nnot fulfill VFp. By construction (W2), no alternative node for VFp can Since T is finite, eventually \nthere must be nodes aPPear more than once in b. such that no alternative node for vFp appears in r(m!,m \n). By the tableau construction, if VFp6n Eb and b is not fulfilling then VXVFp propagates VFp to all \nnodes of b including m . But then from the inverse image of r(m ,m ) we would be able to construct in \nT an infinite non-fulfilling path for VFpCm containing no alternative nodes for VFp, contradicting the \nassumption that m was not deleted by (M6). Let 3FpCn CT . We show how to trace a fulfilling path in T! \n. By assumption m ~ m there is a fulfilling path ITl in T. As long as we dontt reach an alternative node \nin T, then we can trace the path T; Of instances in T! . Similarly, if mi~rl is an alternative node in \nT, EIT1 and i+ 1 contains the wrong sonm:+l~~ lf m: then if mi has a next instance m; in T which is \naccessible from m! then 1 II add m!=> . . . ,m. to ,i and continue with 1 the correct son by W2. If \nnot, then note that if 3FpEmi, then 3Fp is in both sons of mi. Find a fulfilling path X2 in T from m. \nand continue to trace a 1 fulfilling path in Tt, By assumption mi has no instance in T accessible from \nm! so eventually 3 Fp is fulfilled or we 1 start tracing IT3 for a different alter\u00adnative node mk. Since \nthe number of (al\u00adternative) nodes is finite, eventually 3Fp is fulfilled. o Proposition 2, There is \na decision pro\u00adcedure for satisfiability in U%. UB has the finite model property. P~oposition 2 follows \neasily from the previous lemma and constructions. Note that if we are only interested in satis\u00adfiability \nthen we do not need to construct the unwound tableau. It is sufficient to check whet-her the root node \nwas deleted by the elimination process.The decisiop. ?roccdtirc including both the tableau con\u00adstruction \nand the deletion procedure can be shown to be exponential in the size of the formula. Completeness Let \np IYe a valid UB formula, Create a tableau for {-p}. If the elim\u00adination procedure is applied then nO \nis eliminated, otherwise -p would have been satisfiable. If Un = {pi} is a set of formulas in a node \nn then a~n, the associated formula of n, is V(-pi). In a i typical proof of completeness by the tab\u00adleau \nmethod (for example [RuI), one shows that 1-~fn for every leaf and that prov\u00adability is p~eserved as \none ascends the tree to the root. In UB these meta-the\u00ad orems hold bu~ are not sufficient because of \nthe non-fulfilling branches. For these we need induction axioms A4 and E4. We show in a series of lemmas \nthat we can prove the af of every eliminated node. Since no is eliminated, its af which is p is provable. \nLemma 2. If n is a closed leaf then kafn. Proof. t-+pv-p by Rl, hence ~afn by dilution. u Lemma 3. If \nnET is an (i) a-node, (ii) B-node, (iii) X-node and (i) &#38;afm, (ii) ~ af and 1-af (iii) l-af m for \nsome 1 2 T ~> then t-af n Proof : For ~ and the lemma fol- CY, B 10WS by simple propositional reasoning \nand T13-T14 (Appendix A). For the RX rule, we need to use T9 to deduce kv~yLA. ..Ah%lJ&#38; ~ VX-Pi from \nkVX (qlA...AqL ~ Pi) 0 Tliis part of the completeness proof, the definition of af and the proof that \n t-af is preserved, is greatly simplieifed by the use of The nexttime operator whe compared with a classical \ncompleteness proof [RU]. Now we pay for this simplic\u00adity by the need to give the meta-theory far the \ninduction axioms. In practice, this meta-theory is easy to apply and proofs can b< .cmstr~~t~d b> the \ntableau method. Some of the techni\u00adques used belowwere first used in [PR]. Let t be a node (state) in \nT which was deleted by M5 because 3 F-p was not fulfilled. Let [t]$ be the set of states accessible from \nt by taking the 3XSFNp defined sons. For uE[t]$ let [u] be the immediate successors of u in [tl~ and \nlet Vu be the set of all formulas q such that Vxq is a universal nexttime formula in u. Let t Wv=llq \nand W z Wu. Wt is UdvtJ q~yu called the invariant of t. t Lemma 4: 1-Wt > Vxw Lemma 5. For t as in lemma. \n4 and for all ue[tl~~, l-w u ~ P, hence t-wt > p. Proof:(H)For all u E [t] : we can deduce Fwu 3 V (A \nVXq) and then by T9 VEIUI qEvv FWu 3 v vX( A q). The lemma follows VEIUI qEvr from the definitions using \nTIO to ex\u00adtract VX. = Proof:(S)Let n be the node which was ob\u00adtained from u by applying the X rule ?0 \n3X3F-p. Un = Vu U{3F-P}. Without loss of generality we can assume that 3F-pEn * -pEn or 3X3F-p C n is \nthe first tableau rule applied at n. Then u = Vuu{- p}. Without loss of generality 1 we can assume that \n3F-pEn + -pEn or 51X3F-p.En is the first tableau rule ap\u00adplied at n, Then Urn, = vu u {-p}. The node \nmust be deleted, otherwise M5 1 would not have been applied. By the in\u00ad ductive hypothesis baf which \nis 1 D kwu ~p. From ~emma 4 7 generalization and A4, kWt s VGWt. From Lemma 5, generalization and Al, \nEvGWt a VGp. Trivially, kwt ~ Wt since t E [t] . Thu S kWt > vGp which is afn for some node n obtained \nfrom t by applying the Rx\u00ad rule. By Lemma 3 (iii), t-aft. If t was deleted by M5, let b be a branch as \ndescribed there: VF-p6t , -p$nEb and all fulfilling alternatives already deleted, For each uEb let u \nbe the im\u00admediate successor of u in b. Denote by u >$ the set of states in b accessi\u00adble from u and by \nVu, the set of form\u00adulas in the node u . v will be {qilVXqiEu} U {1-1 for the u r such that 3XrEu caused \nu to be generated. Let Zu be the conjunction of all the formulas in VU, and Zt = v z . u~t 9, t Lemma \n6: ~Zt 33X2 . Proof:Like Lemma 4 except that Tll is used to deduce that 1-Zu = A vxqiA3xr qialu , implies \nt433X(A9i/w). Lemma 7: bzt~p. Proof: By M6 nodes containing -p were deleted; hence by induction their \na_f s are provable. As in Lemma 5, l-Zu~ p hence I-Zt =p. n Using E4, El instead of A4, Al we obtain \nbZt = 3GZt, k3GZt = 3Gp, l-Zt a 3Gp and k aft k c1 Proposition 3: A1-A4, El-E!, R1-R3 form a complete \ndeductive system for LIB. The UB Semantics of Nondeterministic Programs The utility of UB for proving \nthe program properties so elegantly express\u00adible in the language depends on the abil\u00ad ity to restrict \nthe class of possible mod\u00ad els to the class of execution trees of a given program P. This is done by \nspecify\u00ading a set of axioms which impose the structure of computation according to a given program on \nour general models. It may also be considered as specifying the temporal semantics of the programming \nlanguage by connecting its syntactical constructs to transformations and dev\u00adelopments in time. In order \nto do this we extend our language by allowing predicates on var\u00adiables. We have three types of variables: \na) Computation variables, Yl,Y2,. . . which are modified by the execu\u00adtion and vary from state to state. \n~) Free variables X1,X2,. ,. which remain constant in time and are used to express relations between \nvalues of computation variables in different instances. Thus (y=X) ~ 3F(y=f(x)) is the expression cf \nthe state\u00adment that there exists some com\u00adputation and some state in it such that the value o? y in this \nstate is equal to f of the in\u00aditial y. c) A program variable v whose val\u00ad ue at any state points to the \nsegment of program yet to be executed. To emphasize the general principle underlying the semantics consider \nfirst an unstructured language in which programs are represented by transition graphs, G = (N,E). The \nset N of nodes is called the set of locations. E is the set of edges each of which is labeled by a guard\u00aded \ninstruction of the form g(y) > [y := f(y)] with the meaning that this edge is enabled if y(y) is true \nand passing through the edge involves the assignment of fy to y. We form our temporal semantics of such \nprograms by letting II range over N (the location set) and forming for each node a semantic formula. \nLet a node IEN admit the following transitions: gl(;) > [y:=fiyl 9. 4 gin(y) > [y:=fmyl , Then we form \nthe formula scheme Here Q = Q(m,y) is an arbitrary predicate depending in general on the program variable \nT and the computation variables y. It may also refer to free variables . Note the presence of the E connec\u00adtive \nwhich implies that this formula con\u00adtains two implications. The first is stating that for every i = 1,...,m \nsuch that gi is true there is a successor state s in which TS=Li and Y~ fi (current y). The other implication \nis a complementary statement saying that the only possible successor states are derived in this fashion. \n Next we will show that the temporal formalism is nor necessarily rest~icted to unstructured languages. \nConsider as an illustration Dijkstrats language of  guarded commands [D]. Here we let m range over program \nsegments. S will of\u00adten stand for an arbitrary program seg\u00adment. The semantics of an assignment state\u00adment \nmay be given by: LTI = {y; = e; S}) = [Q({S}, e) : 3XQ(IT,Y)] which states that provided we are about \nto execute {y := e; S}, Q will be true in the next instant iff Q(m,y) is true for n = {s} and y = e. \nIn the following let c = [ : gi(y) + Cil whe~e c.is any . 1 ~.~ command and gi s are guards. The seman\u00adtics \nof conditional is given by the axiom: (IT = {C;S}) = [{ : [gi(y)/@({ci;s},y)]} i.1 It states that Q(n,y) \nwill be true of the next instant iff for some i,gi(y) is true and so is Q with IT = {ci;S} and y. Similarity \nfor the repetitive command *C we CT= =.~ Q({C; kC;S},y) Lu t Q({S},y)} =3xQ(m,y)I Here the computation \nstep chooses betwee~ the case that some guard is true and the conditional C has to be executed first, \nand the case that all guards are false and we proceed beyond the repetition > <C. Discussion and Conclusions \nIn this paper we presented a unified branching time system which enjoys the joint advantages of both \nlinear time and branching time systems, in being able to express and ~eason about the two basic types \nof termination, universal and exis\u00adtential. We have established the logical properties of the UE properties \nby pre-\u00adsenting a decision algorithm and a com\u00adplete deductive axiomatic system for the propositional \nfragment of the language. The decision procedure presented is ob\u00adviously exponential. This language must \nof course be com\u00ad pared with process logic languages such as PL[HKP] and its predecessors. These lan \nguages certainly can express any of the prope~ties expressible in ~~ and many more . However, there is \na price to pay for this expressibility which is the com plexity of the language. A sign of this is the \nfact that FL is nonelementary (has nonelementary decision procedure) while UB is exponential. Admittedly \nwe do have six modal op\u00aderators which is a disadvantage compared to simple~ systems such as DX for lin\u00adear \ntime lGPSSI or the corresponding Kranching time systems. On the other hand the formation rules of these \noperators are simple and uniform, and they do enable us to express most of the interesting pro\u00adgram properties \ndiscussed in the litera ture. Another advantage lost in the Transi tion from linear to branching time \nis expressive completeness in the sense of . [GPSS] . Here the problem is inherent and cannot be remedied \nby the addition of one or two extra operators. In the full ver\u00adsion of the paper we will bring a proof \nof the following: Proposition 4: No branching time temporal language w~th a ~inite number of modal operators \ncan be expressively complete. This theorem, due to Gabbay (Unpub\u00adlished manuscript) is based on the foll&#38;w\u00ading \nobservations: a) A temporal language with a finite number of operators can always be translated into \ns first order formula with a number of distinct variable names which is fixed for the language. b) In \nfirst order language it is easy to come up with formulas which need an arbitrarily large number of distinct \nvariable names, Consider for example the state\u00ad ment: Lecture Notes in Mathematics 188, Springer Verlag, \nBerlin, 1971, 252- There exist k time instants 269. no two of which are re-[M21 Z. Manna, Second order \nmathematical l  tk theory of computation, Second ACMlated, Symposium on Theory of Computmg, This statement \nneeds k variables 1970, 158-168. [MP] Z. Manna and A. Pnueli, The modeal for its expression for an arbitrary \nlogic of programs, Automata, Lan\u00ad k. These formulas for sufficiently guages and Programming, Lecture \nNotes in Computer Science 79, large k cannot therefore be ex\u00ad Springer-Verlag, Berlin, 1979, 385\u00adpressed \nin any temporal logic. 409. I F N3 A. Pnueli, The temporal semantics of concurrent programs, Symposium \non Some recent works do indeed present Semantics of Concurrent Computations, branching time systems \nwhich are richer Lecture Notes in Computer Science 70, Springer Verlag,-1979, 1-20. than ours and include \nadditional opera\u00ad [PR] V.R. Pratt, A practical decision tors. Such are the systems discussed in method \nfor propositional dynamic logic, Tenth ACM Symposium on Theory [EC] and [A2]. of ComDutin~. 1977. 326-337. \nReferences [RU] N. Res;her ~nd A. Urquhart, Temporal [Al] K.R. Abramson, Modal logic of con-Logic, Springer-Verlag, \nVienna, 1971. current nondeterministic programs, [s1 R.M. Smullyan, First-Order Logic, Symposium on Semantics \nof Concurrent Springer-Verlag, Berlin, 1968. Computations, Lecture Notes in Com\u00adputer Science 70, Springer \nVerlag, Appendix A: Discussion of UB Berlin. 1979-, 21-33. If *VGp-p (Tl, below) is added to [A21 K.R. \nAbrahamson, Decidability and Expressiveness of Logic of Process-A1-A4 then we get a complete deductuve \nes, Ph.D. Thesis, University of system for the universal fragment of ~shington, August 1980. [D] E,W. \nDijkstra, Guarded commands, branching time. If VX and 3X are nondeterminancy and formal deriva\u00ad merged \n(along with VG and 3G) so that tion of programs, C. ACM 18(8), 1975, 453-457, Vxp = +x-p is an axiom \nthen we get a [EC] E.A, Emerson and E.M. Clarke, Char\u00ad complete deductive system for linear time. acterizing \ncorrectness properties of parallel programs using fixpoints, By T1 and T5, the axioms could be ex\u00adTR-04-80, \nAiken Computation Labora\u00ad pressed more symmetrically as: tory, Harvard. IF] R.W. Floyd, Nondeterministic \nalgor\u00ad./i3:kVGp 2 pAV@AvxVGP ithms, J. ACM 14(4), 1967, 636-644. ~FL] M.J. Fischer and R.E. Ladner, Propo-E2:l-3Gp \n= p A 3XpA2X3Gp. sitional dynamic logic of regular\u00adprograms, Journal of Computer and Also, E3 can be \nderived by taking T1 and System Sciences 18(2), 1979, 194-211. ~GPSS] D. Gabbay, A. Pnueli, S. Shelah \nand T6 as axioms . Some axiom of the form J. Stavi,-The temporal analysis of V23 is needed to limit the \nmodels to fairness, Seventh ACM Symposium on Principles of Programming Languages, non-ending time. 1980, \n163-173. IHJ Hare!, First Order Dynamic Logic, Lec-Theorems of UB ture Notes in Computer Scxence 68, \nT1. I- vGp Dp Springer-Verlag, Berlin, 1979. [HKPI D. Hare[l D. Kozen and R. Parikh, Pro-T2. + VGp a \nVFp cess logic: expressiveness, decid- T3. F Vx(p=q) -(3xp33xq) ability, completeness, 21tn Sympos\u00adium \non Foundations of Computer Sci-T4. b VG(p=q) n (VFpaVFq) ence, 1980. T5. &#38; 3Gp n 3XP lHC] G.E. \nHughes and M.&#38;. Cresswell, An Introduction to Modal Logic, Meth-T6. 1-Vxp 3 3xp uen, London, 1968. \nT7. I- VG(pAq) = VGpAVGq ~L] L. Lamport,  Sometime is sometimes not never , Seventh ACM Symposium T80 \n1-3G(pAq) = 3GpA3Gq on Principles of Programming Lan- T9. I- vx(pAq) = vxpAvxq guages, 1980, 174-185. \n[Ml] Z. Manna, Mathematical theory of TIO .1-3x(pAq) = ~xPA3xq partial correctness, Symposium on T1l. \n1-vxPA~xq 3 ~x(PAq) Semantics of Algorithnnc Languages, T12. . VGpA3Gp -3G(pAq) T13. I-vGp z pAVxVGp \n T14. I-3Gp = pA3x3Gp T15. ~vGp = VGVGp T16. P 3Gp = 3G3Gp T17. + 3G(p5dXp) n (p=~Gp) T18. I-VFVGp = \nVGVFp T19 . 1-3G((pv3Gq)A(3Gpvq)) E (3Gpv3Gq) T20. b VXVGp = VGVXp T21. l-3X3Gp = 3G3Xp. Comments: The \nproofs of T1-T12 are straightforward. T13-T21 are proved using induction axioms A4 and E4. It is also \npossible to prove derived rules: ~ p+kMp and l-p~q +1-Mp ~ Mq for any modality M. We saw how T9 and Tll \nare used in the completeness proof to deduce the induc tiveness of the invariant. T13 and T14 are the \nkey to the tableau constructions: 1--3G-pv-3x3Gp. To falsify 3Gp, either P is false now or put off to \ntomoroow the task of falsifying 3Gp. T15.=16 correspond to the transitivity axioms of the model system \nS4 [HCI. T17 is another induction axiom. We conjecture that replacing E4 by T17 results in a weaker system \nbecause the induction step needed p > VXp is too strong. The sys\u00adtem is probably not different from linear \ntime. T18 is our version of the S~.2 [HCI axiom MLpaLMp. Note that 1-3Gp=vFp and l-VF 3Gp a SIGVFp can \nbe proved but this is an artifact of the reflexiveness of UB and would not ca~ry over if E2 were changed \nto l-3Gp = 2Xp A 3X3Gp as required classi\u00adcally in temporal logic ~RU]. T19 is the S4.3 [HC] linearity \naxiom for 3G. T20 show that VX and VG com\u00admute. For 3X and 3G only the direction shown in T21 holds. \n\t\t\t", "proc_id": "567532", "abstract": "A temporal language and system are presented which are based on branching time structure. By the introduction of symmetrically dual sets of temporal operators, it is possible to discuss properties which hold either along one path or along all paths. Consequently it is possible to express in this system all the properties that were previously expressible in linear time or branching time systems. We present an exponential decision procedure for satisfiability in the language based on tableaux methods, and a complete deduction system. As associated temporal semantics is illustrated for both structured and graph representation of programs.", "authors": [{"name": "Mordechai Ben-Ari", "author_profile_id": "81100485679", "affiliation": "Tel Aviv University", "person_id": "PP31044318", "email_address": "", "orcid_id": ""}, {"name": "Zohar Manna", "author_profile_id": "81100089034", "affiliation": "Stanford University, Weizmann Institute of Sciences", "person_id": "PP15021756", "email_address": "", "orcid_id": ""}, {"name": "Amir Pnueli", "author_profile_id": "81100648459", "affiliation": "Tel Aviv University, Weizmann Institute of Sciences", "person_id": "PP15038449", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567551", "year": "1981", "article_id": "567551", "conference": "POPL", "title": "The temporal logic of branching time", "url": "http://dl.acm.org/citation.cfm?id=567551"}