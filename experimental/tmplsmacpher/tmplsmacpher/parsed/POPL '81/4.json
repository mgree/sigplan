{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 in the host language by some stylized version of data abstractions. The \napproach we take is to consider useful primitives that can be added to the query languages themselves \nwhile preserving the relational view (an alternate way of thinking about this is that we are examining \nthe appropriate operations on the data-abstraction of relations). As such, it is indeed possible to add \nTuring machine capability to query languages. We will do this with a very primi\u00adtive construct (viz. \ncounters) because our purpose is to examine the inherent capabilities of constructs, not to build a useable \nlanguage. The latter can be pursued subsequently using standard techniques of programming language design. \nThe paper [CH 1] shows that there is a well defined notion of the set of all computable querie$. The \nprogramming language used to show this has generic (or untyped) variables that take on relations as \nvalues, but the rank (or width ) of the relation is not fixed. Such variables can be used in an unconventional \nway: the width can be used to encode a number. It is a natural question to ask whether generic variables \nprovide some other inherent capa\u00adbility. We will answer this question affirmatively. Another primitive \nwe will consider is equaliry. This refers to the equality of domain variables, i.e., those which take \non values from the domain of the database (as used, for example, in first\u00adorder logic). It turns out \nthat a surprisingly rich set of queries can be posed without equality. For instance, the conjunctive \nand tableau queries [CM, ASU] are reasonably expressive, but they do not have equality. Also, Zloof [Z3] \nin showing the power of Query-by-Example gives over two dozen examples of queries and none of them requires \nequality (four of the examples use the symbol = , but this can be thought of as syntactic sugaring, as \nin the use of the same symbol for assignment in some program\u00adming languages). It should be noted that \neven without equality, one can use the same variable in several places (and hence do eq-jOins [C 11), \ncan check if a variable is equal (or not equal) to a constant (because constants are modeled by separate \nrelations containing a single element each), and can even check whether two sets are equal (by subtracting \nand checking for emptiness), Its essential use is only when one needs to check that distincr domain variables \nare equal. We will make this concept precise, and give an algebraic characterization of the set of queries \nthat can be stated without equality. The cleanness of the characteriza\u00adtion lends credence to the robustness \nof the formalization. The final primitive we consider is one that is not natural for query languages. \nIt seems, however, to be of some fundamental importance as far as the theory is concerned. This primitive \nallows a query to inquire about the overall structure of the data\u00adbase. More specifically, one can determine \nthe isomorphism class of the database. The paper is organized as follows. Section 2 gives the basic definitions, \nthe framework for the query languages, and the con\u00adstructs of (i) Looping (L), (ii) Turing-machine capability \n(C),  (iii) Generic variables (G), and (iv) Equality (E). Section 3 provides characterizations of these \nconstructs, and a comparison of their expressive powers. Section 4 defines the remaining two primitives: \n (v) Counting (the number of tuples in a relation) (B), and (vi) Isomorphism class (I), and characterizations \nof these, along with relationships between all combinations of the six primitives (the reason for the \nchoice of the letters C, B for primitives (ii), (v) will be clarified later).  2. The query language \nIn this section we define data bases, queries, and the lan\u00adguage model for expressing queries. Definition \n2.1: A data base B = (D, R,, Rz, .... Rk) consists of a finite nonempty domain D taken from a fixed count\u00adable \nrmiversal set U, and relations Ri CDai (ai is called the rank of Ri). The fype of B is ii=(al,.,.,ak). \nFollowing [B, P, AU, CH1], the notion of the relational data base abstraction is that the ordering of \ntuples in a relation is immaterial: Definition 2.2: A computable query (query for short) of type z+ \nb is a partial recursive function Q:{ BIBisof type Z}-0+2ub where Q(B) c Db, and obeys the consistency \ncriterian: If B+b+B then Q(B )=h(Q(B)) (here B--h+ B means that h is an isomorphism mapping B to B , \ni.e., if B=(D,R1,..,,Rk), B =(D ,RI ,..., R),), then h is a one-one onto function from D to D , and for \nall i, Ri =h(Ri)). The set of all computable queries is denoted CQ. A query is said to be total if it \nis defined for all data bases (of the appropriate type). The standard queries used in the literature \nsuch as first-order queries [C3], conjunctive queries [CM], tableau queries [ASU], queries with transitive \nclosure or fixpoint operators [AU, CH2, K, V] are all subsets of CQ. For real query languages, it is \nsome\u00adtimes useful to augment the notion of a computable query so as to 51 be able to name an unbounded \nnumber of elements in the data base domain, or to treat part of the data base as being interpreted (e.g. \nto sum up numbers). These can be handled as suggested in [CH1 ], but most of our results comparing the \nprogramming primi\u00adtives remain unchanged. Our basic query language is based on relational algebra, along \nwith an If-then-else statement (as we shall see, this adds no power, but is used for convenience). The \nprogramming language contains the following: Variables: x:, x:, X:, .... x;, x;, .... x;. Terms: D, Ri, \nX;, and if t,tl ,t2 are terms, then so are the following: tl x t2 Cartesean product t, u t~ Union -t \nComplement Proji(t) Projection (i> 1) PermO(t) Permutation 0 Restricti, j(t) Restriction (i,j> 1). Statements: \nX;+t where t is a term and if S,S, ,S2 are statements, then so are the following: (s,;s2), If X; = {} \nthen S1 else S2. Variable X: has rank a. This superscript will be omitted when no confusion results. \nAll variables are initialized to {}. All terms are also ranked. The values of terms D, Ri are from the \ndata base. The term t, xt2 has value {(d,=) I ~etl, Set2]; tl Ut2 is Set union if t,, t2 have the same \nrank, and is empty otherwise; ~ t has value Da-t where t has rank a; Proji(t) deletes the i-th column \nfrom t, having value {(dl,...,dl, di+l,l,da),da) I (dl,...,da)ct} (if i>a the value is defined to be \nthe empty set); given a permutation 6 on { 1,...,a] where t has rank b>a, the value Permd(t) = {(do(l),..., \ndo(a)) I (dl,.,,,da)< t} where 0 is extended to be the identity on {a+ 1,.,.,b}, and Restricti,j(t) = \n{(dl,...,dl, dl+l,l,da),da) I (dl,...,da)ct, di=dj}. While it may appear that Restriction requires equality, \nas we shall see, (Theorem 3.1), this corresponds only to the use of repeated variables in logic. Relational \nalgebra generally has other operations as well, e.g., intersection, difference, join, division, but these \ncan be built up from the given ones, For example, eq-joins can be implemented using cartesean product \nand restriction (and without using equali\u00adty, which will be introduced later). We will, in the sequel, \nallow t, nt2 as a short form for -(-t, u t2). Note: these OPeratOrs can be used to check if two terms \ntl, t2 are equal by chec~lng (t1n=t2)u(-tl ntJ={}. A program is a statement which has associated with \nit a type Z+ b, and an output variable of rank b, which contains the value of the program (if and) when \nit terminates. Statements and pro\u00adgrams have the obvious semantics. Given values for variables occurring \nin a term t, its value in a data base B will be denoted by ValB(t). In addition, we will consider the \nfollowing primitives: (i) Loop (L), (ii) Counters (C),  (iii) Generic variables (G), and (iv) Equality \n(E). (i) Loop (L): If S is a statement, the following is also a state\u00ad ment: While X={] do S. (ii) Counters \n(C): The following counter variables are also al\u00adlowed: co, c,, C2, ,.. Their values are nonnegative \nintegers, and they can be used in assignment statements: Ci-ci+l, Ci+ci-l, and in tests Ci=o in the If-then-else \nand While-do statements. At the beginning of a program, counters are initialized to O. By convention, \nif Ci has value O, then Ci -Ci-1 leaves its value unchanged. While counters are not the most efficient \nway of introducing Turing machine capability, they are simple, and any other way gives equivalent results. \nAlso, it should be noted that the use of counters does not give the capability of counting the number \nof tuples in a relation. (iii) Generic variables (G): The following generic variables are allowed: Yo, \nY,, Y2, They are not ranked, but the value of Yi at any point in the com\u00adputation is a relation of some \nrank. As such, it is convenient (but not necessary for any of the results) that empty sets also be ranked \n(so that complements and intersection can be defined appropriately). These variables may be used wherever \na ranked variable may appear. (iv) Equality (E): The following is also a term: E. Its value is the equality \nrelation { (d,d) I d c D]. A computation srep of a program is the execution of an as\u00adsignment statement \nor a test in an if-then-else or while-do state\u00adment. Definition 2.3: If P c {L, C, G,E], let CP denote \nthe set of queries represented by programs which may use the primitives from P. Of course, all programs \nrepresent computable queries. It has been shown [CH 1] (using a slightly different model) that Theorem \n2.1: CIL,G,EI=CQ (recall that CQ is the set of all conjunctive queries). In order to compare different \nsets of primitives, we will be primarily intersected in programs that halt on all data bases. This is \nto avoid spurious appearances of greater expressive power by being in an infinite loop. Definition 2.4: \nIf PI ,P2C {L, C, G,E}, we say that PI SP2 iff every total query in CPI is also in CP2. Also, PI<P2 if \nPI SP2 but not P2sPI, and P1=P2 if both PISP2 and P2SP1. Also, we write P1=sP2 if it is not the case \nthat PI<P2. Usually it turns out that PI SP2 whenever CPI c CP2. Dis\u00adcrepancies will, however, be pointed \nout. 3. Characterization and comparison of primitives In this section we present characterizations of \nthe query classes, and give a complete comparison diagram (Fig. 1) relating them. Definition 3.1: A formula \n@(Z) of first-order logic with relatiofl symbols Ri and = represents a query Q where Q(B)= {6 I ~(~) \nholds in B]. Let F (resp. F-) denote the set of all queries repre\u00adsented by formulae of first-order logic \n(resp. first-order logic without =). Codd [C3] showed that terms in relational algebra with equality \nrepresent the queries in F. It is apparent that If-then-else adds no inherent expressive power; also \ncounters and generic variables add no inherent power. without some kind of loop. Theorem 3.1: C{E} = \nC{ C,G,E] = F, C{} = C{C,G} = F-, Proof: The only new aspect is C{} =F-. (A) Show that d{] CF-. First \nnote that any program in C{} computes a term on D,Ri using x, u, -, Proji, Perm6, Restricti,j, and an \nif-rhen-else operator on terms having the form if t,={}rhen t2 else t~ where t ~, t2, t3 are terms (with \nt2, t3 having the same rank). This operator can then be eliminated. Suppose t2, t~ have rank a and tl \nhas rank b. Let t denote (projl (proj2(...(Projb( to)))).))) XDa. The value of t is Da if t ~* { ], and \nis {] otherwise. Then a term Of the form if t,={} then t2 else t~ is equivalent to (tIl tq) U (-tfitz). \nNext, we show that any term t without if-then-else is representable by a formula @t(I) in F-such that \non database B, ~~ t iff @t(~) holds in B. Note: the order of the variables in ~ in @t(Z) is rele\u00advant \nhere. QD(x) is T (true), @Ri(Y) is Ri(~), and given t], tz, (i) if t is tl xt2, then 0,(%7) is @t,(~) \nA 0,,(7), (ii) if t is tl u tz, then @,(~) is Ot,(i) v @t,(~),  (iii) if t is =tl, then @t(X) is -@t,(~), \n(iv) if t is proli(tl), then @t(xl,...,xl, xi+l,l,..., X8) is ~xi. ot, (x,,...,xa), (v) if t is PermO(tl), \nthen @t(x~(l),...,xe(a)) is 13tl(xl,...,xa), and (vi) if t is Restricti,j(tl), then Ot(xl,...,xl,xj+l,l, \nx,),x,) is  ~, (xl!... >xl>xi!xj+l>l >...> Xa). It is straightforward that in each case, @t represents \nthe term t, thereby showing that any program in C{} is representable by a term in F-. (B) Show that F-C \nC{}. We show by induction on formulas that for every formula 0(%) there is a term to (which has no equality \nE) such that to is represented by @ as defined above. We assume that bound variables in @ have been renamed \nsuch that each variable (bound or free) has a distinct name. (i) Suppose ID(xl,...,x,) is R(xil,...,xib) \nwith ijsa for each j<b. Such a @ will be built up with a series of steps as follows. (a) Start with \nexactly b variables: if *(yl ,...,yb) is R(yl,...,yb) then ty is R; (b) eliminate common variables: \nif the formula  same *](Yl,.,Yj.],Yi,Y j+l,..., . ( Y1,...,Yl, Yj+l!l, Yc),Yc) is the as y ) then ty \nis Restricti,j(tvl) (c) introduce new variables: If Y (YI ,...,yi,y,y i+, ,..., y)is ~simply *1 (yl,...,yc), \nthen tv is PermO(tvl xD) where O(j)=j for j<i, f3(i+l)=c+l, and O(j)= j-1 for j>i. (ii) If @(xl,...,x,) \nis @l(xl,...,xJu@2 (xl,xa),xa) then to is to, utoz. (iii) If @(xI, ....x~)=-@I(x I .....x~). then to \nis -to,. (iv) Finally, if @(xl,..., xl,xi+l+, .....Xa) is 3xi. @j(xl,..., xa) then to is 53 proj i(t., \n). It is again straightforward tO check that in each case, to is represented by @, which completes the \ninduction. 1 It may be noted that generic variables can simulate counters as follows: a counter with \nvalue c can be encoded by a generic variable Y with value Dc, incrementing (resp. decrementing, test\u00ad \ning for O) corresponds to YxD (resp. Projl (y), testing Prowl={}). Thus Lenrma 3.2: For PC{ L, E]. PkI{C}SPU{G]=PU \n{C,G} We next consider the power of equality. As observed above, C{ L, G, E}=CQ. and a natural question \nis to determine what happens when E is not allowed, i.e., to characterize C{L,G} (= C{ L, C,G]). Definition \n3.2: A strong homomorphism from B=(D,Rl,...,Rk) to B = (D , Rl ,...,R) ) is a mapping h:D*D such that \nfor all ~, Ri(~) iff R/(h(d)) (of course, h(dl,...,da )=(h(dl), h(da)))a))). A homo\u00admorphism is surjec~iue \nif h maps D onto D ; it is injective if h is one-one. A strong homomorphism that is both subjective and \ninjective is just an isomorphism. Such a mapping is a key part of the defi\u00adnition of computable queries \n(equivalently, queries in C {C,G,E}). Strong subjective homomorphisms play a similar role for C{ C, G}. \nWe can consider two elements d, d of a data base as being equivalent if for every relation R in it, R(d,d,il) \nholds iff R(d,d ,@ holds. Now a strong subjective homomorphism can map two elements in D onto the same \nelement in D only if the two elements are equivalent in D. In a sense, a strong subjective homomorphism \ncannot tell equivalent elements apart. Theorem 3.3: QcC7{L,G} iff Q is a partial recursive function (with \nQ(B)cDa if defined, for B=(D,~)) and if h is a strong subjective homomorphism from B to B then Q(B) is \ndefined iff Q(B ) is defined, and 66Q(B) iff h(~)c Q(B ). Proof: Given QcC{L,G}, let S be a program (with \nprimitives L,G) which computes Q. Without loss of generality assume that each term in S contains at most \none operator (x, u, -, Proj,, Perm6, or Restricti,j), Of course, Qis partial recursive. We show that \ngiven data bases B=(D,RI,... ), B =(D ,R l,... ), and a strong subjective homomorphism h: BAB , Q(B) \nis defined iff Q(B ) is defined, and 6eQ(B) iff he. The proof is by induction on the number i of computation \nsteps of S. Let StepB(i) be the i-th step in the computation of S on database B, and let ValB(i,Z) be \nthe value of variable Z (a ranked or generic variable) after i steps in the computation of S on B (and \nlikewise for B ). The induction hypothesis consists of two parts: (i) StepB,(i)= StepB(i), and(ii) forallvariables \nZof the form Xj or Yj, ~cValB(i,Z) iff h(~) 6ValB, (i, Z). The hypothesis is clearly true for i=O. Now, \nif it holds for i, then StepB, (i+ 1) s StepB(i+ 1) (trivial if StepB(i) is an assignment, and if it \nis a test, by (ii), the test will branch the same way on both Band B ), Wenext show that (ii) GeValB(i \n+l,Z)iff h(~).s ValB,(i+ l, Z). This is trivial if StepB(i+l) is a test. Suppose StepB(i+l) is an assignment \nZ-t. If t is D, Rj, Xj, or Y, then (ii) holds immedi\u00adately. The remaining case where t has an operator \nfollows using the following observation: let relations T, T be such that for and, dcTiff h(d)@T (and \nsimilarly for Tl, Tt ). Then (a) dcTxTl iff h(~)c T xT l, (b) d6TuTl iff h(d)e T uT l, (c) d< -T iff \nh(d)s -T , (d) de Proji(T) iff h(d) c Proji(T ), (e) ~c Perme(T) iff h(~) e PermO(T ), and  (f) de \nRestricti,j(T) iff h(~) c Restricti,j(T ). We show the only-if part of (f). The others are similar. If \nii=(dl,...,dl, dj+l,l,..., da) 6 Restricti,j(T) then  (dl,...,dl,di,d j+l,l,da)cT,)cT, and by the hypothesis \n(h(dl),...,h(dl), h(di),h(dj+l), ),h(da))=T))=T. Hence, h(d)c Restrictii(T ). This completes one direction \nof the theorem, The proof in the other direction (i.e., if Q is partial recursive and preserves strong \nsubjective homomorphisms then it is in C{ L, G}) is similar in spirit to the proof in [CH1] that CQCc{L,G,E}, \nand is omitted here, 0 This gives a fairly clean characterization of the power of equality. An example \nillustrates this point. Suppose B=(D,R) with R={(a,c), (b,c)}, then without equality we cannot distinguish \na from b (a and b are equivalent ). Therefore, for a query Q of rank (2)-3, if say (a,b,c) is in the \noutput Q(B), then the output must also contain (b,a,c), (a,a,c), and (b, b,c). Theorem 3.3 gives us this \nbecause there is a B =(D ,R ) with R ={(d,c)} and a strong subjective homomorphism h:D+D mapping both \na,b to d, and mapping c to itself. Then (a, b,c)c Q(B) implies that (d,d,c)c Q(B ) which inturrr implies \nthat (b,a,c) etc. arein Q(B). Similarly, any yes-no query (type is Z+O, with output {()} mean\u00ad ing yes, \n{] meaning no) has output yes on B iff it has output yes on B . Finally, if B =(D,R) with R={(a,c), (b,c), \n(c,a), (c,b)}, then (a, b,c)c Q(B ) implies the following are also in Q(f3 ): (a,a,c), (b,a,c), (b. b,c), \n(c,c,a), (c,c,b). It may be noted that Theorem 3.3 generalizes the characteri\u00adzation of the computable \nqueries (Theorem 2.1). Note that if one of the relations in a database (say the first) is always the \nequality relation, then every strong subjective homomorphism is an isomor\u00ad 54 phism (and vice versa, \nof course). Queries in C{L,GI then effec\u00adtively give us queries in C{ L, G, E}, and the characterization \nof these queries (by Theorem 3.3) is precisely the definition of computable queries. A consequence of \nthe theorem is that programs with L,G cannot count the number of elements in a relation. To be more specific, \nthe query EVEN of type ()-0 (i.e., B=(D)) is not in C{L,G} (= C{ L, C,G]). EVEN(B) = {()} if ID I is \neven { {} otherwise. Theorem 3.6: (i) C{}, C{E} are complete in LOGSPACE> (N c{ L}, C{L,E} are complete \nin PSPACE,  Corokry 3.4: EVEN L C{ L,G1. In fact, the query EVEN is quite hard to compute with our primitives. \nIt cannot even be co&#38;puted in C{ L,C,E} -see Lem\u00adma 3.8. Another consequence of this theorem is that \nequality cannot be simulated using all the other primitives because the equality relation itself does \nnot preserve strong subjective homomorphisms: CorolIury 3.5: {E}-s{L,G}. So far we have attempted to \ncharacterize the power of equal\u00adity, and the consequences of not having it. We now turn our attention \nto the looping construct. In order to understand it properly, we need some concepts from computational \ncomplexity, and their relationship with queries. Definition 3.3: Let PTIME (resp. LOG SPACE, PSPACE) \nbe the class of sets (or languages ) that can be recognized in polynomi\u00adal time (resp. logarithmic space, \npolynomial space). ILet PRIM-REC (resp. TOTREC) be the class of primitive recursive (resp. total recursive) \nsets. Definition 3.4: The graph of a query Q is Gr(Q) = {(B,d) I ~e Q(B)}. The function Gr allows us \nto treat a query as a language. It may be noted that for total queries, QI =Q2 iff Gr(Q1 ) =Gr(Q.J. [CH2] \ndefines the set of queries that can be computed in polyno\u00admial time, polynomial space, etc., and suggests \nthat these be used as a means of characterizing classes of queries. We will do this next. Definition \n3.5: For a class of languages L (e.g. PTIME) define the queries in L to be QL = {Q I Q is total, and \nGr(Q) cL}. Thus we write QPTIME, QPSPACE, QPRIMREC, etc. Definition 3.6: A set of queries S is said to \nbe complete in a class of languages L if every total query in S is also in QL, and for every Xc L there \nis a total Q c S such that X is Iogspace reducible (see, e.g., [S1) to Gr(Q). Note that mw complexity \nclasses L (e.g. PTIME, PSPACE) contain logspace complete languages, and hence if S is complete in such \nan L there is a total Q c S such that Gr(Q) is Iogspace complete in L. If a set S of queries is complete \nin a complexity class L, it essentially means that the complexity of queries in S is character\u00adized by \nL: (total) queries in S can be as hard as anything in L, but no harder. We can show that: (iii) C{L,C} \nis complete in TOTREC. Proof: (i) We only need to show that c{E] c QLOGSPACE. But C{ E1=F, and for any \nfirst order formula 10, given a B, ~ as input it is sl.raightforard to determine in log space whether \nor not ~(d) holds in B. (ii) Let S be a program for a total query Q .sC{ L,Ej. Since all variables have \nfixed rank, the entire state of a computation can be represented in polynomial space (note: this is a \npolynomial in the size of the database). Hence Q e QPSPACE. It remains to show that there is a total \nquery Q c C{L,E} such that Gr(Q) is complete in PSPACE. One can construct such a Q of type (1,2,1)+0. \nThe data base B=(D,One,Suc,Initial) with D={l,2,...,n}, One={ I}, SUC={(1,2), (2,3), .... (n-l,n)}, will \nbe used to simulate tbe computation of a one-tape linear space bounded Turing machine M accepting some \nlanguage complete in PSPACE. The relation Initial represents the initial configuration of M, with i c \nInitial if f the i-th bit of the initial configuration is a one. Q simulates the computation of M by \nusing a unary variable to represent the tape contents, and another unary variable (initialized to One) \nto represent the position of the input head (details omitted), and outputs {()} if M accepts the input \nand {} otherwise. Q may output either { } or {()} if the database is not as prescribed, but it is fixed \nup so that it never runs forever. Then Gr(Q) is complete in PSPACE. (iii) For any total query Q, Gr(Q) \nc TOTREC. But the com\u00adputation of any Turing machine that halts on all inputs can be simulated by a program \nin c{L,C } computing a total query. The input is provided by a database as in (ii) above, and the program \ncan be fixed up so as never to diverge. 1 One consequence of Theorem 3.6 is that query classes which \ncontain C{L,C] as a subset (e.g., C{ L,G1, C{ L, C,EI, C{ L, G,E1) are complete in TOTREC. But also Coro//ary \n3, 7; (i) {L}=s {E}, (ii) {L,C} ~ S {L, E]. proof: (i) C{L} contains a total query Q such that Gr(Q) \nis complete in PSPACE, But Q cannot be in C{E} since every total query Q E C{E} has Gr(Q) eLOGSPACE. \nThis proof has a different flavor from other proofs such as showing that transitive closure is not expressible \nin first order [AU] which also implies (i). (ii) Similar. 0 We next analyze the power of generic variables. \nWe have seen that these can simulate counters. But do they provide any additional power? The answer is \nyes. The ability to compute arbitrarily wide relations can be used to count the number of tuples in a \nrelation. Without generic variables, one cannot even compute the query EVEN (defined just before Corollary \n3.5). Lemma 3.8: EVEN 4 C{ L, C, E}. The proof is obtained by easy adaptation of one in [CH2: Thin. 6,2]. \nTheorem 3.9: {L,G} -s {L, C, E}. Proof: The proof is by constructing a program S of type (2)+0 computing \na total query in C{L,G} which is not in C{ L, C, E}. The database B= (D, E ) contains a binary relation \nE which S treats as if it were the equality relation. Suppose E is, in fact, the equality relation. Then \nS will output {()] if D has an even number of elements, and { } otherwise. If S computes the query Q, \nthen Q ~ C{ L,C,E} because if some program S with primitives L,C,E computed Q, then S could be converted \nto a program for computing the query EVEN by systematically replacing all occur\u00adrences of E by E, and \nthis would be a contradiction by Lemma 3.8. It remains to show an S having the above property such that \nS halts on all databases. In the program below, shortcuts are used which can be expanded to obtain a \nlegal program with primitives L,G. Below, ti,j (i<j) stands for PermO(=E x D] z) where f)(i)= 1, f3(j)=2, \nand fl(k) is arbitrary for kzi,j. This essentially moves the columns of -E to positions i,j and fills \nin the other columns. Intersecting a relation with ti,j forces values in columns i,j of any tuple to \nbe distinct (if E =E). Also, while i, j may be arbitrarily large, ti,j can be computed using the primitives \nL,G. The program S is (the permutation 0 interchanges 1,2; the state\u00ad ment Output(t) causes the program \nto output the term t and halt): If Projl (E ) zD then Ou~PUK{}); If Perme,(E ) #E then OU@Ut({}); If \nProj2(Restrict2,3 (E xE ))zE then Ouqrrtt({]); If =E ={} rhen Output({}); Y*. E ; C+2; While True do \n( y + tl,c+l n tz,c+l n . n tc,c+l n (Yx D); If Y ={} then Output (if C is even then {()} else {}); Y-Y \n; C+c+l ). The first three statements in the program check to see that E is an equivalence relation on \nD, and are used to guarantee termina\u00adtion. 0  c=-) U_J.- Comparison diagram relating L, C,G,E. Fig. \n1 We thus have a complete comparison diagram (Fig. 1) relat\u00ading all combinations of the primitives L, \nC, G and E. There are eight distinct classes, with the others being equal to the ones shown as follows: \n{1 = {C} = {G} = {C,G}, {E] -{C,E] -{G,E] -{C,G,E], {L,G} -{L, C, G], and {L,G,E} ~ {L, C, G, E}. 4. \nBounded loops and isomorphism class, In this section we introduce the remaining two primitives discussed \nin the introduction, The first is the ability to count the number of tuples in a relation. Such a primitive \nis common in data base languages such as Query-by-Example. Also, from a Furmally, the primitives are: \ntheoretical point of view, there is good reason for it because it seems to be hard to simulate using \nthe other primitives. To ithrs\u00adtrate this point, consider the query EVEN. This cannot be com\u00adputed using \nprimitives L,C,E; neither can it be computed using L,G. It is, however, easily computed if one can determine \nthe size of a relation. One way of modelling this primitive in our query language is to have counters, \nand an integer valued operator that returns the size of a given relation. There is a way, however, of \nadding this primitive without necessarily having counters, and it has the same effect as the above suggestion \nif counters are also allowed. The mechanism is that of bounded loops and is defined below. To appreciate \nthe significance of the second primitive, it is useful to consider the basic capabilities needed for \nquery lan\u00adguages. They are: (i) The ability to do determine what the data base looks like , (ii) The \nability to do computation (i.e., Turing machine capa\u00adbility), and  (iii) The ability to compute a relation \nfor output. Capability (ii) can be provided to its maximal extent by counters C (if looping is also allowed). \nCapability (iii) is provided by the relational operators includhg equality E if terms of arbitrary rank \ncan be computed [B, P]. Capability (i), however, has no such pure analog in the other primitives. True, \nthe ability to count the number of tuples in a relation gives some information about the data base (as \ndoes an if-then-else statement), but a reasonable question is whether determining the size of a relation \nis the most powerful primitive in this regard. A most-powerful primitive (the isomorphism-class primitive) \ncan he defined, though it is not con\u00advenient for use in real query languages. For a given type Z, let \nBo, Bl, B2, be an effective enumeration of all data bases of type 5 without repetition of isomorphic \ndata bases, i.e., for every B there is a unique i such that B, Bi are isomorphic. Such an i will be called \nthe Godel number of B. The isomorphism-class primitive provides i as an additional input to the program. \nUsing this input, a pro\u00adgram (with L and C) can determine for each term t (without variables) whether \nor not ValB(t) = { } in the given database B, since ValB(t)={] iff ValB, (t) = {}, and the latter can \nbe deter\u00admined. It is not hard to show that knowing i is equivalent to having an oracle which would. \ntell whether or nOt ValB(t) = { } fOr any specified t. Also, knowing i allows one to simulate (with L,C) \nthe bounded loop construct since I ValB(t) I = I ValBi(t) I can also be determined for any t. (v) Bounded \nloop (B): If S is a statement and Z is a variable (Xi, Yi, or Ci) then the following is also a statement: \n For IZI doS. If Z is Xi (resp. Yi, Ci) this statement causes S to be executed n times, where n is the \nvalue of 1Xi] (resp. I Yi I , I Ci I =Ci) upon entry to the For statement. (vi) Isomorphism class (I): \nThe following counter variable is also allowed:  c, along with other counters C and looping L. CI can \nbe used wher\u00adever tbe other counter variables Ci can be used. On data base B, C, is iuitiafized to the \nGodel number of B. If primitive I is allowed, C,L are automatically allowed. This formalism is used because \nvariable C, cannot be used effectively without both primitives C and L. It could, in principle, be used \nwith C or B, but the resulting sets of queries would depend on the Godel numbering used, making them \nuninteresting. IrI this section we examine the power of the six primitives defined above in all possible \ncombinations, and provide complexi\u00adty theoretic or algebraic characterizations of several classes of \nqueries. The results are summarized in Figure 2, and it may be helpful to consult it while reading the \nrest of this section. It may be noted that any program (with possibly all 6 primi\u00ad tives) computes a \ncomputable query -one only has to check that the outputs satisfy the consistency criterion as in Def. \n2.2. Now, definitions 2.3, 2.4 can be extended so that cP, p] ~p2, pl <pz, PI SPl are defined for P, \nPI,P2C {L, C,G,E,B,I} instead Of just {L, C, G, E}. Also, Lemma 3.2 and Corollary 3.5 extend directly \nto: Lemma 4. I: For Pc{L,E,B,I], Pu{C}SPU{G]SPU {C,G]. Theorem 4.2: {E} -.s {L, C, G. B,I}. Proof: Let \nB=(D), i.e., with no relations. If S is a program without equality, then S cannot compute the binary \nrelation E={<d,d> I d~ D} (which is trivially computable in C{E}). he proof is by induction on the number \nof computation steps of S, by the induction hypothesis that for each i, and each variable in S, there \nis an a such that the variable has value Da or {} after i steps (note: the relational operators x, u, \n=, Proji, PermO, Restricti,j on arguments of the form Da or {}, always return values of the form Db or \n{}). Primitives B,I are related by: Lemma 4.3: For Pc{E,G}, Pu{L,C,B,I}SPU {1}. Proof: Since programs \nwith I also have L,C, it suffices to show that such programs can simulate statements of the form: Forlzldos \nfor a relation-valued variable Z (Xi, or Yi). On errtry to this statement in the execution of a program \nS, with primitives Pu {L, C,B,I} on database B, ValB(Z) =ValB(t) for some term t without variables. However, \nif B denotes BCI (C1 is the Godel number of B), then I ValB(Z) I = I ValB(t) I = I ValB, (t) [ since \nB,B are isomorphic. Since programs with P u {1} can compute I ValB(t) I , they can simulate the given \nFor statement. 0 Next. we consider the power of the bounded-loop primitive B. To begin, it can be used \nto compute the query EVEN by the program (with output in X): X+{()}; For I D I do X+{()}-X. Hence, by \nCorollary 3.5, Lemma 3.8 we have: Theorem 4.7 can perhaps be placed in perspective by the complexity \ncharacterizations of the respective classes:  The complexity of programs with only the bounded-loop \nprimitive is given by: Lemma 4.5: C{ B}, C{B,E] are complete in PTIME, Proof: Show that C{B,EI c QPTIME \nby induction on the struc\u00adture of statements. Given initial values for the variables in state\u00adment S, \nthe final values of all variables can be computed in polyn\u00adomial time: this is true for assignment statements \n(each of the relational operators can be computed in time polynomial in the size of the database), and \ninduction shows that it holds for com\u00adposite statements (S, ;S2), If X: = {} then S1 else S2, and For \nIX: I do S (note: in the For statement, IX: I <n where the domain of the given database has n elements). \nIt can be shown that there is a query Q in C{B} such that Gr(Q) is complete in PTIME by simulating a \npolynomial time\u00adbounded Turing machine -details are left to the reader. cl Lemma 4.5 provides an upper \nbound on the complexity of queries with bounded-loop. For instance, using Theorem 3.6, we have: Lemma \n4.6: If PTIME*PSPACE then {L}=s [B,E]. Note: it is generally suspected that PTIMEz PSPACE (it is, for \ninstance, implied by the famous open problem P*NP). Now, programs with L can be simulated with B if counters \nare also allowed. In fact, it can be shown that: Theorem 4.7: {L, B}s{C,B}, {L, E,B} S{C,E.B}. Proof: \nOmitted. This are the only cases where s does not correspond to the subset relation on the corresponding \nclasses, since, for instance, C {L,B] ~ C{ C, B}. We regard this latter as being uninteresting, because \nC{B,L} appears powerful only because it can cycle forev\u00ader, and a strict subset relation again entails \nif programs with B ,C are also allowed a new statement which causes the execution to go into an infinite \nloop. Theorem 4.8: (i) C{ L,BI, C{ L,E,B} are complete in PSPACE. (ii) C {C,B}, C{ C,E,B} are complete \nin PRIMREC. The proof is straightforward and is omitted. A consequence of this theorem is that both s \nrelations in Theorem 4.7 can be strengthened to <, and that {C, B]-< {L, E, B}, It may be noted that \nwhile programs with B,C can simulate programs with B,L, having both L,C present gives still more power. \nThis follows since C{L,C] is complete in TOTREC, and hence {L, C}-S{ G, E, B]. Next we examine the power \nof generic variables together with bounded loops. We first characterize C {B,G}. It is not hard to show \nthat it is complete in PRIMREC, but it has a more interesting characterization: Theorem 4.9: C{ B,G,E} \n= QPRIMREC, The proof is omitted, The theorem says that the programs with bounded loops, generic variables, \nand equality compute precisely the primitive recursive queries. Further, it can be shown that C{B,G1 \nis the set of queries in QPRIMREC which satisfy the strong subjective homomorphism condition in Theorem \n3.3 (i.e., if h is a strong subjective homomorphism from B to B , then d< Q (B) if f h(z) E Q(EI )), \nand this implies the above theorem. It can be shown that C{B,G} strictly contains C {B,CI. It is, however, \nnot immediate. We do not know, for instance, if there is a yes-no query in the former which is not in \nthe latter. But, it can be shown that with generic variables, given enough computing steps, certain bounded \nrank relations can be computed which cannot be computed using only ranked variables. Theorem 4.10: {G,B}=s{E,I}, \n{L, G}= S{ E, II,  Preserves momorphlsms Preserves equivalent elements PRIMREc ,/ IJ  Preserves /( \nstrOng slrr]ect]ve homomorphisms PSPACE I Comparison diagram relating L, C, G,E,B,I (assuming PTIME=PSPACE) \nFig. 2 59 Proof: There is a total query in C{G,B} n C{L,G} which is not in C{ E, I}. Consider a data \nbase B= (D,R,E ) of type (2,2), where E is the equality relation, and R is a binary relation giving course \nregistration information: (c,s) e R if student s is registered for course c. The desired query is: MAXREG: \nWhat is the course(s) with the maximal registration? In case E is not the equality relaition, MAXREG \nmay have any defined value. We write a program for MAXREG using L,G (with shortcuts) and it can be written \nusing G,B (with shortcuts) by replacing While True do by For I D I do . Below, for a term t of rank \n2, t(i,j) denotes Perm@(t x D j-2) where O(i)= 1, fl(j) =2, and O(k) is arbitrary for k*i,j; also, the \npermutation 8 interchanges 1,2. If Proj ~(E ) #D then CM@({}); If Perm8,(E ) =E then Output({}); If Proj2(Restrict2,3 \n(E x E )) <E then Ch@d{}); Y*R; C+2; While True do ( C+c+l; Y -R(l,C)n(YXD); Y -(-. )(2, C)n(n E-)(3, \nC)n)n(.. n)~c l,CJnYC; nY ; If Y ={} then Outpur (Proj2(Proj3... (Proj~_l (Y))...)); Y-Y ). The query \nMAXREG is not in C{ E, I}. Let S be any program in c{E,I} (with terms restricted to having at most one \noperator) which uses no variable of rank > a. It can be shown (details omitted) that S does not compute \nMAXREG by showing that their outputs must differ on the following database B=(D,R,E ) with D={cl, c2,sl,l,..., \nsl, a,s2,1,..., sz,a+l }, E =E, and R= {(ci,si,j) I all i,j }. It may be noted that S can determine that \nthere are two courses, one with a students, the other with a+ 1 students, but it lacks the ability to \npick out the course with a+ 1 students. 0 What has been shown is that even if one knows the Godel number \nof the given database, one cannot compute arbitrary terms without using generic variables. But does the \nknowledge of the Godel number of the database give any power in addition to just being able to count \nthe number of tuples in a relation? The answer seens to depend on whether or not generic variables are \nalso allowed (i. e., on whether or not arbitrary terms can be com\u00adputed). Theorem 4.11: {1} -.s {L, C,E,B} \nThe proof is by a counting argument on forests of height 1, where it is shown that there are not enough \nterms of bounded rank to identify the given forest by the cordinalities of the terms. Consequences of \nthis theorem are that {L,C,B} < {1}, and {L, C,E,B}<{E,II. Theorem 4.12: C{ L,G,B1 = C{ G,I}. The proof \nis omitted. This theorem enables us to provide a fairly clean characteri\u00adzation of the class CIL,G,B}. \nDefinition 4.1: A query Q is said to preserve equivalent elements if for every strong homomorphkm h:B \n* B, d~ Q(B) if f h(d) e Q(B). The only difference between preserving equivalent elements and preserving \nstrong subjective homomorphisms is that in the latter, h is subjective, and may map B to some other database \nB (in the above definition). The preservation of strong subjective homomorphisms characterizes the class \nC{L,G1 (Theorem 3.3); the preservation of equivalent elements similarly characterizes C{L,G,B}: Theorem \n4.13: A query Q is in C{ L,G,B1 iff Q preserves equiva\u00ad lent elements. Suppose B=(D,R), R={(a,c), (b,c)}, \nthen if QcC7{L,G,B] and if (a,b,c) < Q(B) then it follows from the theorem that (b,a,c),(a,a,c), (b,b,c) \ne Q(B). And if B =(D,R ), R ={ (a,c), (b,c), (C,a), (C,tr)}, and (ahc)cQ(f3 ) then (a,a,c), (b,a,c), \n(b,b,c), (c,c,a), and (c,c,b) must all be in Q(B ): compare with comments following Theorem 3.3. This \nresult can be used to prove Theorem 4.2. It also follows that every yes/no query (these are queries of \ntype Z+ O) is in C{ L, G, B}. In fact, it is not hard to see that every yes/no query is also in C{ I}. \nThis completes the comparison of all 64 combinations of the 6 primitives. See Fig. 2 for the complete \nHasse diagram. There are 21 distinct sets of queries with the ones not shown being equivalent to the \nones shown as follows: {} = {C} = {G} = {C,G], {E} = {C,E} = {G,E} = {C, G,E}, {L,G} -{L, C,G}, {G,B] \n= {C, G, B}, {G,E,B} E {C, G, E, B}, {L,G,B} = {L,C,G,B} = {G,I}, {L,G,EI -{L,C,G,E] =={L,G,E,B] = {L, \nC,G,E,B} -{G,E,I], and for Pc{L,C,B}, Qc{G,E}, PuQu{I] -Qu{I}.  4. Conclusions While it is satisfying \nto obtain a complete comparison dia\u00adgram relating all combinations of the six primitives, the resulting \n21 classes of queries cannot possibly all be fundamental. Some doubtless are. These include C{E} (i.e., \nF, the set of first-order queries), C{ L,G,E} (i.e., CQ, the set of all computable queries), and the \nnew class C{ B,G,E} (i.e., QPRIMREC, the set of primi\u00adtive recursive queries). Perhaps more important, \nthe exercise has resulted in a better understanding of the capabilities and limita\u00adtions of the various \nprimitives. For example, Theorem 3.3 and the following comments essentially say that without equality \nwe cannot distinguish between equivalent elements of the data base (in the sense explained there). Other \nthan this, classes with and without equality behave alike. There is, perhaps, one exception. Given loops \nL, generic variables G, and equality E, together they can be used for counting the number of tuples in \na relation. But no two of them suffice (it does not suffice even to replace generic variables G with \nthe slightly weaker primitive C representing Turing machine capability). Further, with generic variables \nit is possible to compute certain terms (of fixed rank) which cannot be computed using only ranked variables \n(Theorem 4.10). A query that requires generic variables is MAXREG: given courses and registered students, \nlist the course(s) with the maximal registra\u00ad tion. One technique which seems to be very useful is that \nof com\u00adplexity characterizations. One finds classes of queries complete in LOGSPACE, PTIME, PSPACE, PRIMREC, \nand TOTREC. Interestingly, all the classes of queries considered turned out to be complete in one complexity \nclass or another. At this time not enough is known to say whether this was good fortune, or that there \nis an underlying reason for it. But it does seem that certain query language comparisons are connected \nwith deep problems of complexity theory. Current query languages are based on the desire to express \nall first order queries. As a consequence, they do well on such queries, but fail on simple queries that \nare not expressible in first order. One way out is to imbed the query language in some general purpose \nprogramming language (which would not have a relational view of the data). The alternative, which we \nsuggest is worth irwestigating, is to construct the query languageso that it can compute all the computable \nqueries. The language design then consists of choosing the right set of primitives. Implement\u00ading relational \nalgebra (as in extant query languages) and Turing machine capability (as in standard programming languages) \nis understood reasonably well. The question is what else we should have. Generic variables, for example, \nmay not constitute the most natural or efficient construct. These considerations can be examined from \nanother point of view -that of the dichotomy of query languages between those that are based on relations, \nand those that are based on tuples or individual elements of the data base (see [Pi,U]). The former have \noperators, terms and variables for relations (as in the rela\u00adtional algebra, and our programming language \nmodel); the latter have variables only for individual elements or tuples (as character\u00adized by first-order \nlogic). The former have been more successful theoretically in that it is possible to express all computable \nqueries within the relational abstraction. The latter have been more successful pragmatically (e.g., \nALPHA, ILL, QUEL, Query-by-Example, SQL, etc. are all of this kind). Such languages, howev\u00ader, seem to \nbe hard to extend gracefully without having the inter\u00adnal representation show through. For example, it \ngenerally be\u00adcomes possible to write queries such as tell me the first element in the representation \nof the data base , with the obvious problems of modifiability, transportability, and correctness (see \n[AU] for some of these issues). It is, obviously of interest to try and ex\u00adtend the set of queries that \ncan be expressed without violating the consistency criterion of Def. 2.2. A standard primitive to do \nthks has the form: Forall tuples tin relation R do statement S, where S is somehow restricted so as not \nto use the order in wh]ch the Forall statement cycles over the tuples. Our bounded-loop primitive B can \nbe thought of as the very special case of this where S cannot even refer to t. Thus our characterization \nof B provides a lower bound for primitives of this sort. A natural question is what is an upper bound? \n, or more to the point, what is a natural set of primitives such that programs in this style can compute \nall the computable queries . It can be shown that with such a Forall statement and an extension of the \nisomor\u00adphism primitive I such that one can determine the Godel number of any specified relation, one \ncan (with relational algebra, count\u00aders and loops, but no equality or generic variables) compute all \ncomputable queries. Unfortunately, the primitive I is not a very natural one to use in real languages, \nand the choice of a good set of primitives remains an open area for research. Acknowledgement Thanks \nare due to David Harel for many stimulating discus\u00adsions which included, among other things, the suggestion \nthat the bounded loop construct be examined. References [ASU] Aho, A. V., Y. Sagiv and J. D. UIlman, \nEquivalences among relational expressions. SIAM J. Computing (1978). [AU] Aho, A. V. and J. D. Unman, \nUniversality of data retriev\u00adal languages. Proceedings 6th ACM Symp. on Principles of programming Languages. \nSan-Antonio, Texas (Jan. 1979), pp, 110-117. [B] Bancilhon, F., On the completeness of query languages \nfor relational data bases, Proceedings 7th Symp. on Mathe\u00admatical Foundations of Computer Science, Zakopane, \nPoland, Springer-Verlag Lecture Notes in Computer Sci\u00adence (Sept. 1978). [cl] Codd, E. F., A relational \nmodel for large shared data bases. Communications of the ACM, 13,6. (June 1970). [C2] Codd, E. F., A \ndata base sublanguage founded on the relational calculus, Proc. ACM SIGFIDET Workshop on Data Description, \nAccess and Control (Codd and Dean, Eds.), ACM, San Diego (Nov. 1971) pp. 35-68. [C3] Codd, E. F., Relational \ncompleteness of data base sublan\u00adguages. In DataBase Systems (Rustin, Ed.), Prentice Hall (1972). [Ch] \nChamberlin, D. D., et. al. SEQUEL2: a unified approach to data definition, manipulation, and control. \nIBM J. Res. Dev.,20,6(1976) pp. 560-575. [Cha] Chang, C. L., DEDUCE 2: Further investigations of deduction \nin relational databases, in [GM], pp. 201-236. See also, Chang, C. L., DEDUCE: A deductive query language \nfor relational data bases, in Pattern Recogrrition and Artificial Irr(elligerrce, (C. H. Chan, Ed.), \nAcademic Press (1976) pp. 108-134. [CH1] Chandra, A. K. and D. Harel, Computable queries for relational \ndata bases, Proc. llth ACM Symp. on Theory of Computing, Atlanta, Georgia (Apr-May 1979) pp. 309-318. \nAIso, JCSS (to appear). [CH2] Chandra, A. K. and D. Harel, Structure and complexity of relational queries, \nProc. 21st Symp. on Foundations of Comp. Sci., Syracuse, N.Y. (Oct. 1980), PP. 333-347. [CM] Chandra, \nA. K. and P. M. Merlin, Optimal implementation of conjunctive queries in relational data bases, Proceed\u00adings \n9th ACM Symp. on Theory of Computing. Boulder, Colorado (May 1977). [F] Fagin, R., Monadic generalized \nspectra, Zeitschr. f. Math. Logikund Grundlagen d. Math.21 (1975 )PP.89-96. [GM] Gallaire, H., and J. \nMinker (eds.), Logic and Data Bases, Plenum Press, NY (1978). [HSW] Held, G. D., M. R. Stonebraker, and \nE. Wong, INGRES: A relational data base system, AFIPS Conf. Proc., 44 (1975) pp. 409-416. [IBM] Query-by-Example, \nTerminal User s Guide, IBM manual SH20-2078-O (Sep. 1978); see also Query-by-Example, Program Description/Operations \nManual, IBM manual SH20-2077-0 (Sep. 1977). [K] Kowalski, R. A., Predicate logic as a programming lan\u00adguage, \nProc. IFIP 74, North-Holland (1974) pp. 556\u00ad 574. [LP] Lacroix, M., A. Pirotte, ILL: An English structured \nquery language correlational data bases, Proc. IFIPTC-2 Work\u00ading Conf. on Modelling in Data Base Management \nSyst. (G. M. Nijssen, Ed.), Nice, North-Holland (1977) pp. [P] Paredaens, J., On the Expressive Power \nof the Relational Algebra, Informrztion Processing Letters, 7,2(Feb, 1978). [Pi] Pirotte, A., High level \ndata base query languages, in Logic and Data Bases, H. Gallaire and J. Minker (eds. ), Plenum Press, \nNY (1978), 409-436. [s] Stockmeyer, L. J., The polynomial-time hierarchy. TCS, 3 (1977) pp. 1-22. [u] \nUnman, J. D., Principles of database systems, Computer Science Press (1979). [v] van Emden, M. H., Computation \nand deductive informa\u00adtion retrieval. In Formal Description of Programming Concepts, E. Neuhold, cd., \nNorth-Holland (1978) pp. 421-439. [Va] Vandijck, E., Towards a more familiar relational retrieval language, \nInf. Syst.,2, 4(1977 ), pp. 159-169. [Zl] Zloof, M. Query by Example, RC4917, IBM Research, Yorktown \nHeights (July 1974). [Z2] Zloof, M, Query-by-Example: Operations on the Trans\u00aditive Closure. RC5526, \nIBM Research, Yorktown Heights (Oct. 1976). [Z3] Zloof, M, Query-by-Example: a database language, IBM \nSyst. J., 4 (1977) 324-343, \n\t\t\t", "proc_id": "567532", "abstract": "This paper examines a number of programming primitives in query languages for relational databases. The basic framework is a language based on relational algebra, whose variables take relations as values. The primitives considered are (i) looping, (ii) counters, (iii) generic (or unranked) variables, (iv) equality, (v) bounded looping (which corresponds to counting the number of tuples in a relation), and (vi) isomorphism class (which corresponds to knowing the isomorphism class of the data base). A comparison diagram is given relating all combinations of these six primitives, and several of the resulting classes of queries are characterized by their complexity or algebraic properties. It is shown, for example, that equality cannot be simulated using all the other primitives, that generic variables (with loops) cannot be simulated with only ranked variables and all the other primitives, and that with bounded loops one can determine the isomorphism class of the database when generic variables are allowed, but not otherwise.", "authors": [{"name": "Ashok K. Chandra", "author_profile_id": "81100394413", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, NY", "person_id": "PP39040848", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567537", "year": "1981", "article_id": "567537", "conference": "POPL", "title": "Programming primitives for database languages", "url": "http://dl.acm.org/citation.cfm?id=567537"}