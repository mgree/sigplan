{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 ing or side-effects. If the static semantics, i.e. type and declaration \nconstraints, are part of the denota\u00ad tional definition, these constraints will be automatically validated \nduring verification condition generation; no additional English restrictions are necessary. Since the \nprocess of verification condition genera\u00ad tion is completely described within Scott s functional formalism \nit is possible to combine proofs using fixed point induction and proofs using invariant. The relation \nbetween Hoare s logic and denota\u00ad tional semantics has been investigated in several pre\u00ad vious works \n[C177, MS76, Mi77]. It has been shown how to express predicate transformers in Scott s framework and \nhow to prove consistency between a set of proof rules and a denotational definition, In thh paper we \nintroduce the notion of related language definitions. Two definitions are related if they describe the \nsame language from a different point of view. We show that a continuation semantics and an equivalent \npredicate transformer semantics are related in thh sense. In the next section we will introduce some \nnota\u00adtions and summarize the theoretical foundations. In section 3 we introduce the notion of related \nlanguage definitions. It is shown that under certain conditions a predicate transformer semantics can \nbe constructed from a continuation semantics by simple textual sub\u00adstitution, In section 4 we introduce \nthe assert state\u00adment. It is shown bow a predicate transformer seman\u00adtics can be used to gerwate verification \nconditions for programs augmented with sufficiently many assertions. Finally, in section 5 we discuss \nsome issues relevant to the application of our theory. These include a worked example, some hints on \na possible implementation, and the treatment of jumps, procedures and functions, and nondeterminism. \nThe appendix contains the continua\u00adtion semantics of a simple example language that will be used in examples \nthroughout the paper. 2. Notations, Definitions We assume that the reader is familiar with Scott-Strachey \nsemantics MS76, SS71, St77, Te76] and the underlying theory SC72]. In our notation we follow [ that of \nStoy and Tennent [St77, Te76]. A domain D is a complete partial order (cpo) [P178], ordered with respect \nto C withthe least element -L. If D1 and D2 are two dom~ns, then D1 + D2 and D1 X D2 denote the separated \nsum, and product spaces respectively; these domains are ordered in the usual way. If z E D1 + D2 then \nz I Di denotes the projection of z on Di; it is defined to be ~ if z is not in the component Di. Conversely, \nif z E Di then z I D1 + D2 is the im\u00adbedding ofzinD1+ Dz. ForZ1EDl, 22EDathe 150 pair (ZI, 22) is an \nelement of DI x Da. If z CDi X Da then xi denotes to the i-th component of z. D* denotes the domain of \nfinite lists over D. The notation (zl, ..., ZJ refers to a list with the elements 21, ..., Zn, We write \n() for the empty list and use &#38; for concatenation. IfSisaset,SL with ~ ~ sESisaflatdomain, For a \nflat domain D we write proper(D) for the set of proper elements (# ~) of D. T = {tt, jf}L is the domain \nof truthvalues, If Z1 c T and Z2, 23 E D then the conditional if Z1 then 22 else 23 is a term in D, If \nZ1 = ~ then the value of the conditional is ~. If D1 and D2 are two domains then D1 * D2 is the domain \nof continuous functions from DI to D2. If T is a in D2 and z E D1 then Xz,T is aterm term in D1+D2.1fj \nCD1+D2 and zCD1 then j z c Da is the result of applying j to z. Function application associates to the \nleft. Alternatively we use the symbol ; to denote function application; it has lower precedence than \njuxtaposition and associates to the right. For example z y; u U;w z means z V(UU(Wz)). A function ~ is \ncalled strict if ~~ = J_. For arbitrary j the function strict j = A z.if == z 1 then ~ else j z is strict \nand continuous (see e.g, [st77]). Forj CD1-Da,ZIEDa,andX2EDI the term j [zl/z2] denotes the function \nA y.if y = 22 then Z1 else j y. Z1 and 22 may be lists in which case j [zl /22] denotes a simultaneous \nredefinition of j; if 22 is a list whose elements are not distinct or if Z1 and 22 are of different length \nwe define j[zl/z2] = ~. Ifj ED ~ Dthen jiz j EDdenotestheleast fixed point of j. Continuity of j guarantees \nthe exisb ence of a least fixed point. The property If~zQzthenjiz j~z. (1) will be relevant later, In \naddition to the truthvalues T = {tt, /f}A the two element cpo T2 of truthvalues with T2 = {trwe, jaise} \nwith true ~ jalse will be of particular importance. T2 has the nice property that for tl and t2 in T2 \nthe implication t, 3 t2 is true if and only if t2 ~ tl. A predicate over D is an element p E D + T2. \nThat is, all predicates we consider will be continuous. This restriction is not a severe one because \nif D is a flat domain any strict function on D is continuous and any function defined on the proper elements \nof D can be extended to a strict function on D. By the ordering of T2 we have Vz.p(z) 2 q(z) iff q ~ \np. A set S is directed if every finite subset has an upper bound in S, For a directed set S its least \nupper bound is written as u S. A function j is inciusive [MS76] it for any directed set $ = {Zi} f(u{zi}) \nG U{/zi}. Inclusive predicates are admissible for fixed point induc\u00adtion. 3. Related denotational definitions \nTo be able to talk about language definitions as ob\u00adjects let us introduce the following notation. A \ndenota\u00adtional semantics Q is a collection of domains and func\u00adtions. Domains are defined from a set of \nprimitive domains {Bi} by product, sum, function domain con\u00adstruction, and recursion, Functions on these \ndomains are defined in typed A-calculus from a fixed set of primi\u00adtive functions {ii}. To emphasize this \ndependence we write Q = Q(131,..., B~, ~i, tJ., tJ. Primitive domains and functions are those not fur\u00adther \ndefined in a language definition. For example, the flat integer cpo NL and addition on ZVl or the domain \nA of answers are considered primitive in most definitions. But one may also consider more complex domains \nand functions as primitive, For example, the semantics of a language could be described relative to a \nset of elementary statements with a fixed but not further defined meaning. Given a definition Q = Q(BI,.. \n.j~n, fl,... ,fm) we will now investigate properties of a definition ~ = Q(Jjl,,,,, An, jl,..,, ]m) \nthat has primitive domains and functionz altered but is otherwise identical to 42. We show that under \ncertain conditions Q and d are related in a meaningful manner. The reason for studying related definitions \nis that they express the semantics of a language from a different point of view, for example a definition \nwhich distinguishes different error situations and its related definition that maps all errors into the \nundefined ele\u00adment ~. We will show later that for most continuation semantics one can define a related \ndefinition which is a predicate transformer semantics. 3.1. Relating domains Let Q = Q(B1,..; jBnjjl}...ljm) \nand then ~ = Q(&#38;,,. o,&#38;jl,.. o, ~m) then ~ consists of the same definitional clauses as Q with \nsome primitive functions and domains replaced. Thus, transformations back and forth between Q and 4 are \nsimple textual substitutions. For each domain D of Q there is a corresponding domain fi of ~. For each \nterm t c D of Q there is a correspond\u00ading term i ED of l?. Let domains lh,..., Bn and &#38;,..., &#38; \nbe related by inclusive binary relations REI C Bi X pi. we extend R to all domains of Q by defining relations \n~D C D X ~ according to kD(Z, f) ijj Z= i for a primitive D that is not a parameter RD$+~,(Z,4) ijj RD,(z \nI DI, ~ I ~1) A RD,(z IDz, AIb2) RD, XD,(Z, f) iff RD,(Z;, ~1) A %J,(Z21 *2) RD,+~,(j, j) ijj A{R~,(tg, \nji) i Rih(9, j)}. Note, if Di is defined recursively, then so is RDi. h this case RD, iz defined to be \nthe least fixed point satis\u00adfying the above definition, Unfortunately, the set con\u00adstructor used in thh \ndefinition is not continuous, not even monotonic, Therefore, the existence of a least fixed point iz \nnot guaranteed. To prove its existence we have to resort to the theory of inclusive predicates [MS76, \nRe74]. A detailed analysis is beyond the scope of this paper but corollary 5.1 in [Re74j applies to our \nsitua\u00adtion and can be used to show that RD is in fact well defined for any D. We will omit domain subscripts \nif they can be inferred from the context. Observe, that for domains D independent o! the parameters Bi \nwe have D = b as well as %D(~, ~) ~ d=d. Definition: Given RB, as above we say two definitions ,Q ~ Q(~I,..., \nB~, fl,..., j~) and ~ = Q@l jm) are related if for all ji the , ...,Bn,llv* .# relation RD(ji, ji) holds \nfor the appropriate D (i.e. ]i C D). Note tha} in general suitable ~i need not exist for given Q, Bil \nBit and ht~ 3.2. Properties of related deflrdtions Th~orem: Let Q = Q~Bl,..., BtL,jI, j~), j~) and 4 \n= Q(B1,..,, fin, jl,..., fm) be two related definitions. For an arbitrary term t c D of Q ad the corresponding \nterm ~ c D of k the relation R~(t, i) holds, Proof: The proof proceeds by induction on the structure \nof t. a) Primitive functions: R(ji, ~i) holds W the definition of related semantics. b) Application: \nassume inductively ~(g, j) and ~(% *), then R(g z, g ~) follows by definition of R. c) Fixed points: \nJ?(L, 1); if R(g, j) and R(z, i) part (b) yields R(g z, j i). Since R is inclusive it is admis\u00ad sible \nfor fixed point induction which yields HU(gnl), u(j ~)) = R(j~z g, j~z j). d) X-abstraction: Let t(z) \nbe a term with free variable z. Given any function g such that R(g, j), then by induction hypothesis \nwe have R(t(g), i(~)), Since this is true for arbitrary g, we have and thus J2(Xz.t, h z..i). e) Conditionals: \nimmediate since RT has to be the iden\u00adtity relation. Obviously, T cannot be replaced by another domain \nsince then conditionals are not well defined. u 3.3. Predicate transformer semantics Throughout the rest \nof this paper we only consider continuation semantics [sw74] Qc = Q(A, ji,..., jm) with answer domain \nA, A continuation is a mapping from stores (S) to answers (A), i.e, C = S + A. The meaning of a statement \nis described by its effect on the continuation that applies after the statement (tail function [Ma71]). \nLet q c A + T2 be a predicate on answers. We define ~A ~ A X T2 as)?A(u,b) s b= qa. We will show below \nthat given suitable functions ~i the related definition Qq = Q(T2, ~1,..., ~,,J is a predicate transformer \nsemantics. First let us consider selection of suitable functions ~i. In practice the following rules \nsuffice: if u E A is a constant take &#38; = q(a); ifj ED+ Atakej= X z.q(j z); if d E Z) for a D independent \nof A take d = d. If the language includes nondeterminism described by power domains [P176, Sm78] the \nsituation is slightly more complicated. For example, in [Te77] Tennent uses the domain of continuations \nC = S + P(A). Alternatives are described by 61 I 02 = ku.(?lo l.J 82U. Foragiven qEA + T2wedefineq* EP(A) \n-bT2 according to   CI (P) = A{qa Ia EP}. It follows that / and U are related functions, i.e. R( l \n, au ). Our theory is applicable to any language definition Qc for which Q~ can be constructed. Let \nus now argue why Qg is a predicate transformer semantic? for the language defined by Qc. Given a pro\u00adgram \nEl, its meaning is determined by the term dP,e = S [EI]PoOO (assuming the semantics given in the appen\u00addix). \nHere 80 and POare the initial continuation and en\u00advironment respectively. Starting program 0 with store \nu we get the answer #prCu. Suppose we are given a predicate q on answers which we want to be true after \nprogram execution, i.e. we want q(OP,~u) to hold. Now by the the definition of RA we have ~(dpreu) = \n~p,etf. Since S is independent of A the relation RS is the identity, thus u = &#38; and dopr.u) = ~pr.~. \nConsequently, ~~,c is a precondition of e; i.e. if 8P,, holds for the initial store a and if pro\u00ad gram \n0 terminates then q holds for the final answer of e, But 6P,, is just the result of computing ~[e~jo~o \nin Qq. Note, if 0 does not terminate its answer will be ~, But unless q = X z.fahe monotonicity of q \nre\u00ad quires q J-= ~, i.e. q holds for the final answer of a nonterminating program. Thus, we cannot reason \nabout termination within Q~. In general, continuations of Qq are predicates on stores that guarantee \nq for the final answer, Thus, ~ [e]~ is a p~edicate transformer that maps ~ into 4P,, = ~ [e]@ such that \nif ~ after e guarantees q then so does jPrC before e. This notion of predicate transformer is diflerent \nfrom Dijkstra s weakest liberal preconditions [Di76], For example, wfp([goto m], P) cannot be defined \nmean\u00ad ingfully, In our method the use of a fixed exit condition q allows to define predicate transformers \nfor jumps and error exits. Given the predicate q, correct label bindings can be computed for every environment; \nthus, the term ~ [goto m]~t? = j[rn] correctly describes the precondi\u00ad tion for the goto statement. 4. \nProgram Proofs In this section we introduce an assert statement in the programming language and show \nhow it can be used together with the predicate transformer semantics con\u00adstructed above to generate verification \nconditions. We do this for the language given in the appendix; domains used in this section refer to \nthose of this definition. Constructions similar to those presented for our example language are immediate \nfor many other languages. 4.1. The Assert Statement Let II, . . . . In be identifiers and let P by a \ncon\u00adtinuous predicate on values P c V + T2 an assertion C Asrt is a term of the form F (II,,.,, Z,J. \nWe add a new statement of the form assert P(Z1,, ,., 1.) to our programming language. Inserting arbitrary \nassertions in a program will not change its semantics, thus we define S[assert P(Z1 ,..., zn)]pe=e, Intuitively, \nan assertion serves the same purpose as in Hoare s logic. Formally, the assert statement is a means to \nassociate a continuation with a particular point of the program. In analogy to &#38; defining the meaning \nof expressions we define a function 4 defining the meaning of assertions: ~i5A8rt+U+$+T2 AuF (ll,..., \nIJ1=l= h7.P(u(p[l~] \\ L),.,. ,u(puln] IL)). Note, that the assertion denotes an element of S -+ T2, \ni.e. a continuation in Q~, while P is a predicate on values, The predicate q E A + T2 is not an assertion \nin the above sense; it plays a special role since it is used to construct Q* It is usually not meaningful \nto talk about values of program variables in q because variables do no longer exist once a program terminated. \nHowever, depending on the domain A, q may assert properties of an output file or it may assert that certain \nerrors do not occur during program execution. For example, the predicate q = kz.z # inualidindex cannot \nin general be stated as a predicate on stores, 4,2. Generating Verification Conditions Subsequently, \nwe only consider a particular predi\u00adcate transformer semantics Q9; since all terms refer to Q~ rather \nthan Qc we omit all primes. The problem of generating verification conditions for a program e is to derive \na set of conditions Vi and a predicate r on stores (precondition) such that vi, ,.., Vn l--s~ejpoooG \nr. (2) If we are able to prove all Vi then this guarantees the usual partial correctness statement if \nr holds for the initial state and if e terminates, then q is true for the final answer, i.e. Vf7.ru \n3 s[ejpodo~. Formulas of the form (2) can be systematically derived by symbolic execution of meaning \nfunctions fol\u00adlowing the structure of the input program. We present several typical cases. The semantics \nof the assert statement S [assert P(ll,..., IJ]PO = 8 gives rise to e gAIP(Il, . ~n)no 1\u00adS[assert P(I1, \n..., IJ]P4 L AIPU1,..o,l?w. (3) One important point about this otherwise trivial rule is that the precondition \n4[P(11,.,., ln)]p is a constant not dependhg on 0. Given a simple statement like an assignment, one can \nevaluate the meaning function, i.e. derive a formula + s[e]po = r. For a sequence of statements t31; \nez we get vi, ,,., VmES[f12]pi?~r1 Vn+l,.,., Vm ~ S[el]prl ~ r and by monotonicity VI,....vm+s[el. \ne2]p0Gr. Loops in the program are defined through terms of the form ~iz N1.T(@). If T(8) is evaluated \n(for a symbolic i?) using the above rules a formula of the form VI(6),..,, Vn(4) 1-T(d) ~ r is derived. \nIf the code inside the loop is augmented with sufficiently many assertions the predicate r will be a \nconstant not dependhg on 4. Since we did not make any assumption about 0 the above formula holds for \nany 0, in particular it holds for r: Vi(r),..., Vn(r) ~ T(r) ~ r. By (1) from section 2 this implies \nVi(r),,,., Vm(r) ~ fix NY(O) ~ r which again is a formula of the form (2) giving verification conditions \nfor a loop, 4.3. Proving verification conditions Verification conditions generated by our method are \nof the form T1 ~ T2 where terms Ti are constructed from conditionals, redefinition (z [ti/v]), predicates \nand functions occuring in assertions, and primitive functions on values used in the language definition. \nWe assume that the chosen assertion language is strong enough to express all verification conditions \nconstructed in the above way, Ignoring the special case of the initial con\u00adtinuation 00 each verification \ncondition can be written in the form kr.P(ucYl, . . . . ~~n) ~ k.~(U&#38;&#38;l . . . /Ua~) where P \nand Q are strict predicates over V and all at are distinct locations (6 L.), 1 < k < n + 1, n < m. By \nproperties of T2 verification conditions of the above form can be proven by showing V~.Q(~(.Yk, . . . \n. cram) 2 P(ucYl, . . . . %) or, after substituting zi for ~~i  vZi.Q(Zkj...,zm) ~ P(ZIJ...jZn). Note, \nthat we have to quantify over the domain V (including ~). This poses a slight problem since it rules \nout the use of a conventional theorem prover for first order logic. For example, axioms such as z # z \n+ 1 do not hold in V = N_l . A possible solution is to require a theorem prover w-hlch operates on domains \ninstead of sets. But we can also argue that those cases where quantification over V is different from \nquantification over proper elements of V result from erroneous pro\u00ad grams (e.g. accessing uninitialized \nvariables). This rather informal argument can be made more precise as follows. Suppose we change the \ndefinition Q to a new definition ~ by adding the clause $[assert P(ll,..., lJj@ = Arr.8trict(Acl. . . \nCn.hr) C(p[zl])  a(p[ln]). The meaning of a program ~ is the same in Q and ~ only if identifiers in \nassertions in e are declared and initialized. To generate verification conditions for e in ~ we have \nto use the rule k7.8trict(hl,., 6n.0u) U(p[ll]).. .a(puInJ) G JUW1, ,,, ,Zn)np 1-$[assert Z (11, .,., \nZJ]PO G AIP(I1,..., I?J]P. Thus, whenever our original method generates a verification condition of the \nform Ao.P(crrYl, . . . , cran) Q Xo.Q(acr~, . . . ,aam) (4) then the corresponding condition generated \nin 4 is hJ.8tri@ ~k. . . tm.p(ual, . . . . ~~n))(@, Q, (~~m) ~ kr.Q(aak, . . . ,CMKm) (5). We noted above \nthat condition (4) is equivalent to V~i E V.Q(Zk ,.. ,,zm)2P(zl,..., zJ It is easy to see that condition \n(5) is equivalent to VZi ~ proper(V) .Q(zk, . . . . Zm) ~ P(z1, . . . . Zm). Thus, we can conclude that \nit suffices to prove verification conditions for proper values only provided the program does not accessundeclared \nor uninitialised variables in assertions -first order theorem proving is applicable, 5. Application \n 5.1. Example The following simple example uses the language defined in the appendix. We assume a predicate \ntrans\u00adformer semantics with q = X a.true. Thus, if the pro\u00adgram aborts with some runtime error it will \nbe partially correct. A meaningful exit condition is provided by the assertion placed at the end of the \nprogram. a and b are two arbitrary integer constants. begin newz; newy;z+ a; while O<(z z-l)do begin \nnew z = y; z+z+b; assert P(z, ~); en~ assert R(y) end Let us call this program pgm with statement part \n8trnt8.With 60 = Xa.true and initial store 60 the 5nal answer of pgm is given by s~grnjJ_&#38;Xro = P[new \nz; new y]l(Ap.C[8tmt8] pOO)UOo (Since there are no labels 3 and j both evaluate to the empty list.) Abbreviating \nx = Ap.C[8trnt8jp80 we have D[new z; new yj~xuo = D[new zj-l; (@D[new yjJ-X)ao = Dlnew yJl(l[aJz])xai \n= X(L [%/~] [%JY])U2 where al = uo [O/CYOO]and uz = al [O/aoJ. We write CYOfor the Q such that ua = unused. \nThus, tYUO# % follows immediately. Po = l[a~,/z] [%t/v] is the environment in which we have to evaluate \nthe statement part 8trnts of the outer block. The final answer is given as C[8tmt8]pO@O@ = (S[2 ~ a]po; \n$Uwhiie,.. ]po; $Uassert It(y)] poOO)uz = [S~while . . .]po; $[assert R@)]po(?o)cr2[a/gJo[z]] Let ~a \n= aa [a/po[zj] = uz [a/~J and r = A[assert R(y)]po = kr.R(craO,), With the trivial verification condition \n00 = kr.true ~ q we get (S[while . . .]$o; S[assert R(g)] poOo)aa G ($[while . . . ]po r)a3 = jiz(xo$t[o \n< (z+ z l)]po; COn(f(SubO@]pOO,r))aa. To find an approximation for this fixed point we symbolically \nevaluate it with continuation d. We first consider the loop body $[body]po(f = D[new z = y]po; )@.Cuz+z+b; \nassert P(z, ~)]j8 =C[ztz+b; assert P(z, tdlJP14 = Au.(C~assert P(z, y)]p14)u[b + a(~l !z])/Pi [z]] = \nk.(C[assert P(z, V)]glo)u[b + aaU1/aUl] G AU.P(UUIUO,b + Oad where we used pi = PoIPo!d/z] = Po[atd8] \nThe last step generates the verification condition So far we found that given 4 ~ p &#38; [os (Z t z \nI)]po; cotad($ubodyllpoe,r)aa G &#38;IIO< (Z+ z l)]Po;codp, On = Aa.ifO < ua.o 1 then P(urxoO 1,b+ \nu%,) else R(cm2uO). Since 6 is not free in the right hand side we substitute the right hand side for \n6 in the verification condition and the fixed point term and get Xa.if O< au., 1 ,then P(aa#O 1, b \n+ ucta,) else R(a%O) G h7.P(Ua~0, b + aa~,) * jiz(M.t[o < (z -z -l)JJPO; cond(S Ubody]poU,rj)oa ~ AcM \nO< vaaO 1 then P(mx~O-Lb+ u%) else R(aauO). Substituting a new variable z for u% and ti for uaci verification \ncondition and precondition can be written as Vz, y.P(z, y) 3 if O<z-lthen P(z-l, b+y)else R($d and if \nO<a-lthen P(a-l, b+ O)eise R(0) respectively. Assuming P(zI y) is the predicate u$b = z*b + y A O<zand \nQ(y)=y= a*b then our technique requires proving the first order verification condition Vz, g.a$b = z*b+f/AO<z3 \nifo <z-1 then a*b = (z 1)*b+b+f/AO<z-1 elsea*b = y and the precondhion if O< a-1 thena b=(a l)*b+b+OAO<a \nl elsea*b = O ~a~OVb=O. 5.2. Implementation In principle an implementation of our theory proceeds by \nsymbolic evaluation of the X term denok ing the meaning of a given program. The evaluator will simplify \nthk term to a greater (wrt. ~) term; it will generate a verification coadltion whenever an assert statement \nis encountered. Fixed points are evaluated by (possibly repeated) substitution. If this process does \nnot eliminate the fixed point the program does not contain su5ciently many assertions. Note that such \nan evaluator will not neces\u00adsarily require assertions for loops which are only ex\u00adecuted a finite number \nof times; rather, repeated sub\u00adstitution will unfold those loops, Of course, an intel\u00adligent evaluator \nmay apply fixed point induction if sub\u00adstitution is not successful. The evaluator characterized above \nwill automati= tally check ali context conditions, type and declara\u00adtion constraints that are part of \nthe language definition; no dhtinction between static and dynamic semantics is necessary. A simple-minded \nimplementation will generate several isomorphic instances of the same verification condition. This is \nthe case because the language definition may ask for the evaluation of the same term twice. Special provisions \ncan detect this situation and eliminate duplicate conditions. A verification condition generator including \nthe above mentioned extensions as well as jumps and pro\u00adcedures (as described below) is being implemented \nat Stanford. The rules and strategies presented so far do not include an equivalent to the frame rule \nin Hoare s logic. In our implementation we are experimenting with various techniques to achieve the effect \nof frame rules. 5.3. Labels and Jumps Loops constructed with goto s result in fixed points over environments; \nthey can be eliminated in the very same way as fixed points over continuations. For ex\u00adample, consider \nthe program fragment begin el; m:E12 end in the environment p and with continuation 8. The en\u00advironment \nthat has label m bound to the correct con\u00adtinuation is given by   ji~(k).p[cue2Djo/~]). Generating \nverification conditions for C[e21@ and ob\u00adserving j[z] = p[zj if z # m we derive v(jUmIl, P, O) t-cue2njd \nG whn, P, 0 If sufficiently many assertions are contained in ez, term T will be independent of j[mj, \ni.e. T(j[rn], p, 0) = T(p, 0), Therefore, we find V(j[mj, p, fq~p[cue2jjd/t7t] ~ p[? (p, 6)/m] and, \nafter substituting p[T(p, O)/m] for j, V(T(p, 8), p, ~)~ p[CUe2Np[T(p} 6)/m] )~/m] L P[T(P, Win]. So, \nby (1) we conclude V(T(p, 4), p, fl)~ jiz(hj,p[CuealjO/m]) G p[T(p, #)/m]. The same technique applies \nfor several labels. 5.4. Procedures and Functions The technique described so far is capable to deal \nwith procedures and functions without further exten\u00adsions. First, consider a situation where a procedure \nis declared without any assertions, In this case the evaluator will bind the procedure name in the environ\u00adment \nto a term denoting the proper procedure value, Upon call to the procedure this symbolic procedure value \nwill be applied to a continuation; at this time verification conditions can be generated for the body \nand the call. Clearly, this technique is very inefficient if many calls to the procedure occur. Also, \nit does not allow for recursion, We can improve on this situation by merely placing assert statements \nat the beginning and end of the procedure body. In this case the evaluator can generate verification \nconditions for the body (path from entry to exit assertion) at the point of declaration. 6. Conclusions \nWe have presented a theory which allows reason\u00ading about predicates, predicate transformers, assertions, \nand inductive assertion proofs in the framework of Scott s logic of computable functions. Using this \ntheory Floyd-Hoare style verification is possible without proof tules, thus eliminating restrictions \non aliasing and side effects and the need for consistency proofs. The reader may argue that we have in \neffect given a set of proof rules to generate verification conditions. Yes, our theory may be looked \nat in this way. However, our rules pertain to the A-calculus; they are not con\u00adtrived for a particular \nprogramming language, We were mainly concerned with the underlying theory and merely sketched a possible \nimplementation of our theory. More experience with our prototype im\u00adplementation is required to learn \nhow best to handle some of the technical problems involved, 7. Acknowledgements I d like to thank Avra \nCohn, Mike Gordon, Friedrich vonHenke, Dana Scott, and Bob Tennent for their comments on earlier versions \nof this paper, Olaf Owe has contributed to the implementation of this theory through valuable discussions. \n8. References [C177] Clarke, E.M.: Program Irwariant8 as Fized Points; Dept. of Computer Science, Duke \nUniversity, CS 1977 5 [Di76] Dijkstra, E.W.: A Discipline ojPrograrnrning; Prentice Hall, 1976 [D076] \nDonahue, J. E.: Complementary Dejinitiona oj Programming Language Semanticg; Lecture Notes in Computer \nScience 42, Springer, 1976 [F167] Floyd, R. W.: Awigningkfeunings to Programu; Proceedings of Symp. in \nApplied Mathematics 19 (1967) [GM77] Gordon, M., Milner, R., Wadsworth, C.: Edinburgh LCF; Internal report \nCSR-1 1-77, University of Edinburgh [H069] Hoar., C. A. R.: An Aziomatic Basis of Computer Programming; \nCACM 12, Ott, pp 576-580 (1969) [HL74] Home, C. A. R., Lauer, P.E: Consident and f70mp1ementarg Formal \nTheorie8 oj Ihe $emantica oj Programming Languages; Acts Informatica 3, pp135\u00ad154, (1974) [IL75] Igarashl, \nS., London, R. L., Luckham, D. C.: Automatic Program Verification 1: Logical Basi8 and It$ lmplernedation; \nActs Informatica, Vol 4, pp 145\u00ad182 (1975) [Li75] Ligler, G.: Surjace Propertie8 oj Programming Language \nComtructs; in Proving and improving pro\u00adgrams, G.Huet, G. Kahn (cd.), Arc-et.-Senans, 1975 [Ma71] Mazurkiewiex, \nA.: Proving Algorithm by Tad JOmctionu; Information and Control, 18 (1971), pp220-226 [MS76] Mflne, R,, \nStrachey, C.: Atheoryo/p,o\u00adgramming language aemantica; Chapman and Hall, London 1976 [Mi77] Milne, R.: \nTranajorming Predicate Tran8/orrneru; IFIP working conference on formal description of programming concepts, \nSaint Andrews, 1977 [OC78] Oppen, D. C,, Cartwright, R: Reauoning about recurdivelg de/ined data utructuree; \nProc, fifth ACM Symp. on Principles of Programming languages, 1978 [P176] Plotkin G.: A powerdornain \nconstruction.; SIAM Journal of Computing 5, 1976,452-487. [P178] Plotldn, G,: T a8 a f.hiuer801Domain; \nJournal of computer and system sciences17,pp 209-236(1978) [Re74] Reynolds, J.C.: On the Relation between \nDirect and Continuation Semantic6; Proc. 2nd Coil, on Automata, Languages and Programming, Saarbrucken, \npp. 157-168, 1974 [SC78] Sehwarts, R,L,: An Aziornatic Semantic Definition of ALGOL 68; CS Dept, UCLA, \nUCLA\u00ad34-P214-75, Aug. 78 [5%72] Scott, D., Lattice Theory, Data Type8 and Semantic8; NYU Symp. on Formal \nSemantics, Prentice-Hall, New York (1972) [ss71] Scott, D., Strachey, C.: Toward a Mathematical Semantic8 \n/or Computer Longuage8; Tech. Monograph PRG-6, Programming Research Group, University of Oxford (1971) \n[Sm78] Smyth M.B,: Power domains,; Journal of Computer and System Sciences 16, 1978,23-36. [St77] Stoy, \nJ.: DenotationalSemantic# -The Scott-Strachey Approach to Language Theory; MIT Press, Cambridge (1977) \n[SW74] Strachey, C., Wadsworth, C. P.: 6 ontinuation8, a Mathematical Semantic8 for Handling Full Jurnp8; \nTechnical MonographPRG-11, Oxford University, 1974 [Te76] Tennent, R.D+: The Denotational Sernantic8 \noj Programming Languagea; CACM, 19 (1976) pp437\u00ad453 [Te77] Tennent, R.D.: A DenotationalDe@ tiora ojthe \nProgramming Language Paacal; Tech. Report 77-47, Queen s University, Kingston, Ontario (1977), revised \n1978 9. Appendix: An example language The following simple example language is used throughout the paper \nto demonstrate our approach, The language has beerrkept simple; for example static, semantics are not \ndescribed. There are no data types and only simple control structures. However, some unconventional features \nare in\u00adcluded in order to demonstrate the treatment of aliasing and side effects: the declaration new \n1 = J declares 1 to be an alias for J;  assignment is allowed as an expression to allow for side effects. \nThe language contains an assert statement ; its  sole purpose is to include predicates in the program \ntext; its execution has no effect. The definition is written in the style of [Te77]. Details of the memory \nallocation are described axioma\u00adtically (for an a such that ., , ); suitable continuous func\u00adtions for \nmemory allocation can be found in [MS76].  9.1. Abstract syntax AEDec Declarations E c Ezp Expressions \nr E Corn Commands e c Strn Statements 1 ~ Jd Identifiers F 6 Con Constant symbols A ::= new 1 [ new \nIi =12 IA1;Az E ::= I := EIF(E1,..., En)l IIN r ::=z:elrl; rzle e .. Elwhile Edo Ol ., 1:= if E then \n01 else e~ ] dummy I goto I I assert P(ll,..., In) I begin A; 1 end 9.2. Semantic Domains f C V Values \naeL Locations UEs= L + V + {unused} Stores A Answers d E C = S -A Continuations lc.cK=v+c Expression \ncontinuations xEx=fJ+c Declaration continuations peu = Id -t (L+ C) Environments The domains A, L and \nV are left unspecified; both are flat lattices. 9.3. Auxiliary functions update cd = A@7[6/cY]) content \ncuc= k7.lc(@7 toad 6102= MM c then t?l else 42) 9.4. valuations J4(scon+v +v D~12ec*U+X+C &#38;C Ezp+U-+K+C \nCC Com+U+C+C SGStm+U+C4C JcCona+U-+C+C j ECom + Id N is not further defined here.   \n\t\t\t", "proc_id": "567532", "abstract": "A theory of partial correctness proofs is formulated in Scott's logic computable junctions. This theory allows mechanical construction of verification condition solely on the basis of a denotational language definition. Extensionally these conditions, the resulting proofs, and the required program augmentation are similar to those of Hoare style proofs; conventional input, output, and invariant assertions in a first order assertion language are required. The theory applies to almost any sequential language defined by a continuation semantics; for example, there are no restrictions on aliasing or side-effects. Aspects of \"static semantics\",such as type and declaration constraints, which are expressed in the denotational definition are validated as part of the verification condition generation process.", "authors": [{"name": "Wolfgang Polak", "author_profile_id": "81341495124", "affiliation": "Stanford University", "person_id": "PP43132582", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567549", "year": "1981", "article_id": "567549", "conference": "POPL", "title": "Program verification based on denotation semantics", "url": "http://dl.acm.org/citation.cfm?id=567549"}