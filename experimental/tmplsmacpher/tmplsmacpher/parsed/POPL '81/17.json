{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 decidable, and in at most (roughly) exponential time to beat. The result \nof this paper is the even more remarkable fact that their combination remains decidable, and moreover \nremains of complexity one exponential. No substantially better complexity bound is presently obtainable \neven for the miniscule fragment of this theory consisting of just Boolean functions and variables, i.e. \npropositional calculus. We shall even include call-by-value procedure parameters in the combination, \na concept that has no meaning in either static logic or PDL alone, A Side Issue The nrimary interest \nin this particular fragment of logic is that it is a large decidable fragment that, along with other \nfragments involving the constructs omitted from our fragment, should form a uscfol part of a verifier. \nAs a side-issue one may speculate on the extent to which our fragment is large enough to be usable entirely \non its own. The first instinct of a programmer is that without assignments all is lost, while without \nprocedure definitions there are no procedures and fittle organization. And the first instinct of the \nprogramming logician is that without quantifiers there is no logic. Yet in fact in middle management \nprogramming in a large software operation none of these need be the case. A programmer moy be given the \nnames of a nurnbcr C.cprocedures written by other programmed, along with partial correctness and termination \nproperties of those procedures, withoot being given the actual code implementing the procedures. His \ntask may bc to assemble those procedures into another procedure whose partial correctness and termination \nproperties have been spccitled, using begin-end, if-then\u00adelse, and while-do as glue, without ever dirtying \nhis hands with an actual assignment statement. The task may not be so large that he is driven to creating \nhis own auxiliary procedures. And the reasoning ilivolved may be straightforward enough, as it often \nturns out in practice when the static logic is rich enough, that quantifiers are not needed. Thus it \nis conceivable that the binding-free fragment could be used for completely automatic checking of claims \ninvolving such middle-management programming. The remaining objection then becomes the exponential running \ntime of our, procedure, which pretty much rules out full y automatic operation: the programmer would \nstill need to defend his program in a series of manageably small steps. Problem Definition We now define \nthe problem formally. In the following wc let X,Y,Z range over terms, f,g over func[icms, h over sways, \np,q,r over formulas, and a,b,c over programs. Thq language constructs are: Terms X,Y,Z,... Variables \n0,1,2,N1L,... Constants f(xl,-,xk) Functions on terms, e.g. i-cons car cdr h[Xl,...,Xk] Array element \nstore(h,i, v) Array h but with h[i] = v Formulas X=y, X<y Atomic formulas P, pvq, pAq, ... All Boolean \nfunctions on formulas p{a}q Partial correctness assertion halts(a) Termination assertion Programs A(Xl,...,Xk), \n~,... Procedures (parameters optional) !rcgin al; ... ; ak end Compound statement if p then a ck b Conditional \nstatement while p do a While-loop case i Of al,...,ak Case statement alb nondetcrrninistic choice Here \nis an example of a valid formula in this language. halts(while x~y A Z=X+ 1 do begin A(x); B; A(z-l); \nB end) -+ hafts(while y= x +2 A --(Y<z V z~x) do begin A(z-l); B end) Its vafidity is decidable by the \nmethod we shall describe. Note that it is valid even if Lhe procedures A and B are nondetenninistic, \nas theY might be if their bodies included nondctcrministic choices. A conventional formal proof of the \nvalidity of this formula will involve inductive reasoning. Thus our decision proccdurc must be capable \nof discovering inductive hypotheses in some form. Our method is also applicable to inference steps to \nshow that the validity of the conclusion of the inference follows from the validity of the premises. \nThis is. formally equivalent to having the conjunction of the universal closure of the premises (what \nis obtained by prctixing each premise with a universal quantifier for each free variable in the premise) \nimply the universal closure of the conclusion. Since we have no quantifiers, being able to check soundness \nof such inference steps is an ability not catered for merely by having a decision method for validity. \nProblcm Reduction While we could proceed to describe the method for the language exactly as wc have presented \nit, it will be more convenient to boil it down to a basis of primitives from which the other constructs \ncan readily be derived. To this end we redUCe the language to the primitive constructs of PDL and static \nlogic as follows. Anything not so reduced is then assumed to be one of the primitives. Only formulas \nand programs are so affected; terms are afready primitive. Fomtulas P, Q,R,.., Propositional variables \n<a>p (or O(a,p)) a can bring about p. The sense of can in the O operator is that implicit in tossing \na coin can bring about heads. rhe truth of <a>p is defined for a given state: <a>p holds of state u \njust when some terminating computation of a starts from u and ends in a state in which p holds. <a>uue \nwould assert of state L1 that a baS a terminating computation when started in state u. A formula is valid \nwhen it is true of all states; thus the validity of <a>/rue amounts to the existence of a terminating \ncomputation of a, independent of the starting state. Programs a;b Binary case of compound statements \np? Test or guard a* Nondetcrrninistic iteration The test p? is a program that terminates without side-effects \nwhen started in a state in which p holds, imd fails to terminate when sbrted in other states. The program \na* executes program a indefinitely often. Wc now make the following syntheses. The binary operations \n; and I are assumed to associate to the left even though they are written without parentheses. Formulas \np{a}q p+ .<Q-q halts(a) <titrue Programs begin al; ; ak end al; ....a if p then a else b p?;a I -p?;b \nwhile p do a (p?;a)*;-p? CW i Of al,...,ak i= l?;al I ... I i=k?;ak The remaining primitives on the original \nlist are all the term constructs, predicates = and. ~, all Boolean functions, procedure calls, and the \nnondetcnninishc choice statement. These and the immediately preceding formula and program constructs \nexhaust our primitives. The primitives are conveniently summarized by the following list. XYZ... Ol+... \n+-cons carcdr nilstore Uf3 C{} PQ R...-vA+*... =<O A(...) I)(...) C(...) ... I ; * ? It should be realized \nthat the above syntheses are intended for use only in the context of deciding properties of programs \nhaving to do with their initial and final states. Thus p?;al -p?;b is a satisfactory way of synthesizing \nif p then a else b prov{ded we only care about relationships between initial and final states of programs. \nThese two programs are equivalent as far as their initial and final states are concerned, in the sense \nthat the set of all possible transitions from an initiaf state to a final state is the same for each \nprogram. Semantics So far we have only formalized syntax, although we have supplied some informal semantics. \nIn order to be precise about the problem we shall give a formal definition of the semantics of the problem. \nA nrodei is a set W of states, together with an assignment, in each state u, of data to terms, truth \nvalues to formulas, and sets of states to programs (denoting the states to which this program may go \nfrom u). A model of formula r is a model having a state sutisfyirzg r (a state in which r is true). A \nformula is satisfiable when it has a model. The usual constraints on composite expressions apply: x+ \ny must be assigned the sum of the assignments to x and y, pVq must be assigned the disjunction of the \nassignments to p and q, x< y is assigned true just when the assignment to x is less than or equal to \nthe assignment to y, and similarly for other familiar operations and predicates. fhc ,program alb is \nassigned the union of the assignments to a and b in u, a;b is assigned dIc union of the sets assigned \nto b in each state in the set assigned to a, and a* in LI is assigned the union of {u} with the assignments \nin u to each of a, a;a, a;a;a,... The test p? is assigned {u} in state u if p is assigned true in u, \nand otherwise is assigned the empty set. Programs A(xl,...,xk) and A(yl,...,Yk) in the same state may \nbe assigned entirely arbitrary sets of states (we have no idea how they are implemented) unless xi = \nyi for l~i~k, in which case they must be assigned the same set of states. The formula <a>p is assigned \n[rue just when p is assigned true in at least one of the states in the assignment to a. The basic problem \nis to test satisfrability of a formula r. The problcm of testing validhy of r reduces to testing unsatisfiabifity \nof --r, whence we need say nothing further about validity. In addhion to the basic problem there is also \nthe problem of testing soundness of inferences. An inference is a set of formulas called the premises \ntogether with another furrnula called the conclusion. An inference is sound when either some premise \nis not valid or the conclusion is valid. We give algorithms for both problems. The Algorithm We nuw present \na relatively simple form of our algorithm for testing satisfiability of formulas. The algorithm corresponds \nto the method of truth tables for propositional calculus. Like that method it is simpler to explain than \nalternative methods though not necessarily as efficient as those alternatives. A particularly attractive \nmethod for practical use is the method of tableaux, which we will dkcuss briefly at the end. The algorithm \ncombines the methods of [10] and [11]. It is conveniently decomposed into six phases executed in sequence: \nForm Subformulas, Form States, Static Filter, Form Edges, Dynamic Filter, and Test. 1. Form Subfonntdas. \nThe subformulas of the input formula r are formed. The notion of subfotmula used here is not the obvious \none but rather the one introduced in [5], where the set of subfonmulas of r is called the closure of \nr. The nonstandard notions of subformula arc that <a>p and <b>p arc considered subformtdm of <alb>p, \n<a><b>p is a subformtda of <a;b>p, <a><a >p ii a subforrnnla of <a*>p, and p is a subformtda of <p?>q. \nIn addhion we include all Lh equations x= y such that x and y arc terms both occurring as the I actual \nparameter of A(...) for some procedure call A and parameter position i in the input formula r. Otherwise \nthe notion is standarrL p is a subfotmula of pVq, as WC1l a.. of -p and <a>p. The notion is reflexive \nand transitive; thus P is a subformtda of P and of --(PVQ). Note that with the exception of atomic formulas \nand formulas of the form <A(,,.)>p, the truth of a formula is determined by the truth values of its immediate \nsub formulas, 2. Form Stales. This phase generalizes what happens in the method of truth tables for propositional \ncatculus. All possible truth values are assigned to the subformulas. Each such assignment determines \na state. In each state procedure calls are depararnetrized. Each occurrence of A(xl,...,xk) is replaced \nby a paratrrcterless procedure call B. A(xl,,..,xk) and A(yl,,..,yk) are replaced by different B S ttSkS \nhL thk state xi = yi for l~i~k (whence the inclusion of such equations among the sub formulas). The choice \nof procedure names is determined locally for each state; the same name may bc used in two states for \nentirely different procedure calls if desired. 3. Stalic Filler. This phase eliminates those states that \nare unsatisfiable or semantic nonsense even without considering O forrmlas. We require of each state \nthat -p and p have opposite truth values, and that pVq holds just if onc of p or q holds. We verify the \ncquiv~ences <alb>p = <a>p V <b>p, <a;b>p = <a><b~, <a*>p = <a><a >p, and <p?>q = pAq. The set of all \ntrue formulas in the state of tbe ,form x= y or x ~ y or their negations arc tested for simultaneous \nsatisfiability by Oppen s procedure. 4. Form Edges. This phase develops a network of edges linking the \nsurvivora of Static Filtering in a way that reflects possible computations of the programs. For each \natomic program A and for each pair U,V of states, an edge labelled A is connected from u to v just when \nfor all subformulas <A>p falw in u, p is false in v, With respect to our formal semantics, the assignment \nto A in u is the set of all v for which there is an A edge from u to v. 5. Dynamic Filler. The basic \nprocedure of this phase deletes any state o such that <a>p is true in u and there is no state v in the \nassignment to a satisfying p. The assignment to a is recomputed inductively from the assignments to the \natomic programs after each deletion.  The basic procedure is applied repeatedly until all surviving \nstates pass the test. 6. Test. The input is satisfiable just when it is true in some surviving state. \nCorrectness Claim. r is satisfiable if and only if the procedure says it is. For the it dhcction of the \nclaim, observe that the object constructed is a model of the input. Oppen s procedure yields assignments \nto terms in each state that respect the term semantics and the semantics of = and ~. Form States respects \nthe semantics of -, V, etc. when assigning troth vahms, and the semantics of <a>p are verified by Form \nEdges and Dynamic Filter. Thus if the procedure says it has a model, it really does, For the only if \ndirection, by the finite model theorem of [5], if dierc is a model of r (ttrc big model) there is one \nwhose states arc all distinguished by the truth assignments to the subforrnulas of r (the small model). \nI-fence our starting set of states includes all the states of the small model. The presence of terms \ndoes not harm thk theorem since an assignment of data to terms that satisfies, one state in the big model \nmay bc used for every state in the big model having the same assignmcnta to sobformtdas, permitting such \nstates to be collapsed into one state. The Form Fdges phase inserts every edge that appears in the small \nmodel, and possibly many more. The Dynamic Filter phase will not dclctc any state that is a Nate of the \nsmall model since the required edges are present in the small model and hence in the construction. Hence \nthe small model must survive Dynamic FNering, and the state satisfying the input will then be found, \nRefinements A valuable refinement is for Create States to anticipate Static Filter in some of the more \nobvious ways. The troth values of formulas of the form -p, pVq, <alb>p, <a;b>p, and <p?>q may be determined \nfrom those of their immediate subforrnulas, reducing the initial set of states and avoiding some of the \ntests of Static lWter. TMs can also be done for say <A*>P, whose truth value is that of P A <AXA*>P. \nSince P and <A><A*>P are each treated as logically independent their values are determined in each state, \nthus determining <A*>P. But now consider <P?*>Q, whose subforcnulas are P, Q, and shown along the lines \nof the corresponding proof in ~]. <p?Xp?*>Q. Calculating the truth value of <P?*>Q from the vatues of \nits subformulas gets us into a loop. This problem arises for <a*>p just when p(a) holds, where T is defined \ninductively as ip(A) = false rp(alb) = q(a) or qr(b) T(a;b) = q(a) and p(b) p(a ) = T(P?) = [me So when \nrp(a) holds <a*>p must be treated like atomic and <A>p formulas. We shall call these the logically independent \nsubforrmdas. Deparametrization may introduce on the order of n2 equations if the input is of length n. \nHowever equations are not logically independent, and there are Bn possible assignments of truth values \nto equations on n distinct terms when the assignments respect the fact that identity is an equivalence \nrelation. Bn, the nti Bell number, counts the number of partitions of n things. It grows only a little \n2 more S1OW1than n!, which however is a good deal less than 2n y. Thus only those states should be formed \nthat satisfy the equivalence properties of equafity. In Dynamic Filter, one refinement is to batch deletions \nand to recompute assignments to nonatomic programs inductively only between batches. Another refinement \nfor this phase is to test only those <a>p for which a is of the form A or b*. It turns out not to be \npossible to omit testing <a*>p. Yet another refmcment of Dynamic Filter avoids inductively computing \nassignments to nonatomic programs. When wc test <a>p we do not really need to know which state satisfies \np, we only need to know that one exists. So instead of computing the a-paths (i.e. the assignments to \nthe a s) we can propagate all occurrences of p to all those states that have an a-path to one of those \noccurrences, without expficitfy computing the a-paths in the process. Wc accomplish this by constructing \na new graph whose vertices are state-formula pairs, one pair (u,P) for each p satisfied by u. Call the \nfOLmL1kI <a>p a diamond formula and its argument p a Fargel formula. It suffices to suffices to use only \ndiamond and target formulas in this graph. The edges of this graph are unlabellcdj to avoid confusion \nwith the edges of the main construction we will call them links, written (U,p)-(v,q) [13]. The links \nare all pairs of the form (U,<p?>q)=(u,tl), (u,<alb>p)-(u,< a>p), (u,<alb>p)a(u,<b>p), (u,<a;b>p)-(u,<a><b>p), \n(u,<a*>p)*(u,p), (u,<a*>p)~(u,<a><a*>p), and (u,< A>p)* (v,p) provided in the construction an A edge \nwent from u to v. These links can be seen to keep track of paths with sut fiuent accuracy to guide formulas \nbackwards along paths. In order to describe propagation we shall extend the pair (u,p) to the triple \n(u,P,S) where S is a subset of the set of subforrmdas. Initially each triple has the form (u,p,{p}). \nThe basic step of the propagation process is described by the transformation (u,p,.S)-(uv,q,T) ~ (u,p,SUT)+(v,q,T), \nwhich is to say that formulas are propagated backwards along links. This process is iterated until no \nfurther propagation is possible. h can be seen with some effort that if <a>p is true in u then there \nis a state v satisfying p and an a-path from u to v if and only if p C S in the triple (u,<a>p,S). This \nprocess defines the new basic procedure for Dynamic Filter. As before, this process is iterated until \nno fort!ler states can be deleted. Between deletions the propagation must be redone, although the graph \nand the links need only be computed once at the start of Dynamic Filter, provided that when u is deleted \nso is (u,p) for all p. Analysis Wc analyze the complexity of the procedure assuming some of tie more \nstraightforward refinements, treating the remaining refinements by case. We let n denote the length of \nthe input measured in symbols, counting 1 for each variable, each V, each 0, ew., and ignoring parentheses. \nNot counting the equations introduced by deparametrization, the number of subformulas is at most n, as \ncan be Some critical numbers in tic complexity are the number M of states produced by Form Stales, the \nnumber t of target formulas, and the number d of diamond (<a>p) and associated target formulas together. \nCertainly t~d~ n. M will be at most 2iBm where i is the number of logically independent subformulas and \nm is the number of terms occurring as parameters. Asymptotically Bm will dominate this expression; however \nin a typical input of length say 20 one would hardly expect m to be more than say 5, for which Bm = 52. \nIn general, for typical inputs Bm should not be unmanageably large, despite its worse-than-exponential \n(n!) rd ~ of growth. The time required by each phase can be summarized as follows. 1. Form Subformulas. \nO(n). (There is no need to construct the 0(n2) deparametrization equations explicitly.) 2. Form States. \nO(nM). 3. Static Filter. O(MBn). The Bn comes from the worst case cost  of Oppcn s method, which itself \ndepends on partitions arising in connection with equations. This bound is rather weak; for example it \ndoes not reflect the fact that the parts of the formula dealt with by Oppen are disjoint from the parts \ncontributing to M. 4. Form Edges. O(wf+. 5. Dynamic Filter, If a s assignment is computed explicitly, \nthis  costs 0(M3) for each of O(n) programs (transitive closure is cubic), repeated O(M) times to delete \nO(M) states, for a total of 0(nM4). If formula propagation is used this drops to 0(td2M3). (Propagating \nt folmulas along (dM)2 edges costs 0(td2M2).) 6. Test, O(nM). To summarize with a very crude estimate, \nthe cost is no more than 0(n3Bn3). More attention to details such as t, d, M, etc. permit a more promising \nbound. Nevertheless this simple method remains relatively expensive compared to what is possible with \nthe next mctbod we shall consider. The Tableau Method An approach that yields better worst case bounds \nas well as much better typical case performance is the method of tableaux. In this method states arc \nnot created unless necessary. We give a brief sketch of the method here, and refer the reader to a more \ndetailed treatment of the Oppeu-independent part of the method in [13]. In this method the set of subformulas \nis defined a little differently. Instead of considering p to be a subformula of -p, the immediate subformulas \nof -(pVq) are taken to be -p and -q; of -<alb>p, -<a>p and -<b>p; of -<a;b>p, -<D<b>p; of -<a >p, -p \nand -<a>< a*>p; of -<p?>q, -p and -q; and ~f -<A>p, -p. The folmula --p is simplified to p as soon as \nit arises, and hence need not be considered firthcr in the reckoning of Subformtdas. It can be shown \nalong similar lines to the corresponding proof in [5] that with this definition of subformula, a formula \nof length n can still only have at most n sub forrmdas. For any given p in the set of subforrmdas of \nr, -p may or may not also be in the set. (But if for no P is -p also in the set, r must be satisfiable.) \nWe now have complete symmetry between p and -p. We take advantage of this by writing -PA -q for -(p Vq), \nand [a]-p for -<a>p. The trick of simplifying --p to p is very economical of time., Another cheap trick \nis to decompose conjunctions into their constituents. The following inductively defined function f maps \nformula p to a set of fotmulas whose conjunction is equivalent to p. It can be seen with a little effort \nthat the induction is well-founded. tlDAo) = fft3) U ffa) flalb~) = fla]p) U f([b]p) fi[wb]p) = f([a][b]p) \nfi[a lp) = f(-p) U flblb lp) q<p?>q) = f(p) u flq) fl<~b>p) = f(<aXb>p) f~) = {p} otherwise FormulaspVq, \n<alb>p,<a*>p,and[p?]qarecalleddisjunctive, and are said to be satisfied by one of the two appropriate \nsubformulas, respectively p or q, <a>p or <b>p, p or <aXa*>p, and -p or q. Each subformula has one of \ntwo values in a state, true or unknown. Falsehood of p in a state is represented by the truth of -p; \ndurs falsehood of p is representable only when --p is in the set of subfomrulas. For convenience we will \nview each state as the set of sub formulas true in that state. A consistent state does not contain p \nand -p for any p. To test r for satisfiability, a model is constnrctcd as follows. Initially one state \nconsisting of just f@) is created provided f(r) is consistent. This forms the root of a tree of states \nconnected by edges corresponding to either atomic programs or the identity programs. The tree is grown \ndownwards by select: :!g some leaf state u that does not also occur as a nonleaf state. If that leaf \ncontains any unsatisfied dk.junctive formula then u is called a disjurrc(ive state, and two new states, \ndescendants of u, are created, consisting respectively of uUf(p) and UU f(q) where p and q are the satisfying \nsubformulas, provided each is consistent; an identity edge links u to each of its descendants. Otherwise \nu is called a conjunctive state, and for each <A>p in u a descendant U{ flq)l[A]qEu}U ~p) is created \nprovided it is consistent, with an A edge linking u to that descendant. When no further growth is possible, \nidentical states are identified as vertices, yieldlng a dkected graph that may contain cycles. Thk graph \nis now proned essentially as in the Dynamic f3tering of the truth table method. Each <a>p in each state \nmust have an a edge to a state containing p. The result is satistiabk Just when the root survives this \npruning. Transitive closure can be avoided with this method just as with truth tables. Unlabcllcd edges \ncan bc confined to following the edges of the tableau (SCC[13] for details), so that the sparseness of \nthe tableau edges is inherited by the links. The complexity of this procedure is reduced over the troth \ntable method in the worst case primarily because there are fewer edges. Each vertex can have at most \nd edges leaving it rather than M, so there are O(dM) edges. lf program assignments arc computed explicitly \neach state elimination may cost the product of the number of vertices and edges, or 0(dM2), so that the \nwhole process costs dM3 Using links reduces it to 0(td2M2). At thk level of complexity our procedure \nbecomes practically attractive even in the worst case; in the typical case, due to its tendency to only \nconstruct states when needed, the tableau method should make it possible to deal with quite large inputs. \nTesting Soundness of Inferences The algorithm generalizes to handle the inference of conclusion c from \npremises pl,...,pk Simply by requiring the premises to be t.t oe in every state of a counterexample to \nc (a mortcl of -c). For the mcthort of truth tables this may be handled in the Static Filter phase by \ndeleting states that contradict any premise. For the tableau method, each new state is initialized with \nthe set of premises when it is created. Conclusion We have described two algorithms for deciding aatisfiability \nand validity of formulas and soundness of inferences. The worst case time of the better algorithm is \non the order of Bn2, guaranteeing prompt answers for short inputs. A more careful analysis should permit \nsome increase in this bound, possibly by making it more sensitive to the details of particular problems. \nFor typical inputs it is conjectured that the trrblcau method will be acceptably fkst on rather longer \ninputs, though typical performance remains to be established by experiment. This algorithm should prove \nusefol as a component of an automatic program verifier based on decision methods rather than on classical \ninference roles. Bifrliography [11 f3en-.4ri,M., and Pnuefi, A., Finite Models for Deterministic Propositional \nDynamic Logic, Dec. 1979. [2] Constable, R.L. and M. ODonnell, A Programming Logic, Winthrop Press, 1978. \n[3] Davis, M., and J.T. Schwartz, correct-program Techrmlogy/Extensibility of Verifiers. Two Papers on \nProgrmn Verification, Courant Institute of Mathematical Sciences, CS Dept., NY University, Report No. \nNSO-12, September 1977 (146 pages). [4] Downcy, P., H. Samet, and R. Setbi, Off-line and On-line Algorithms \nfor Deducing Equalities, Conference Record of the Fifth Annual ACM Symposium on Principles of Programming \nLanguages, 158-170, Tucson, Arizona, Jan. 1978. [5] Fischer, M.J. and R.E. Ladncr., Propositional Modal \nLogic of Programs, Proc. 9th Ann. ACM Symp. on fhcory of Computing, 286-294, Boulder, CoI., May 1977. \n[6] Halpern, J., DPDL: Models, Complexity, Completeness, Manuscript, March 1980, [7] King, J.C., A program \nverifier, Proc. IFIP Cong. 71, North-Holland, Amsterdam, 1971, 235-249. (Also Ph.D. Thesis, Carnegie- \nMellon University, Pittsburgh, Pa, 1969. ) [8] Minsky, M.L., Computation -Finite and Infinite Machines, \nPrentice-Hall, N. J., 1967. [9] Oppcn, D.C., Complexity of Combinations of Quantifier-Free Theories, \nProceedings of the Fourth Workshop on Automated Deduction, 67-72, Austin, Texas, Feb. 1979. [10] Oppen, \nD.C., Simplification by Cooperating Decision Procedures, ACM Trans. on Programming Languages and Systems, \n2, 1, 1979. [11] Pratt, V.R., Models of Program Logics, Proc. 20th IEEE Conference on Foundations of \nComputer Science, San Juan, PR, Oct. 1979. [12] Pratt, V.R., On Specifying Verifiers, Proc. 7th Ann. \nACM Symp. on Principles of Programming Languages, Las Vegas, Jan. 1980. [13] Pratt, V.R., A Near Optimal \nMethod for Reasoning About Action, JCSS, 20, 2, 231-254, April, 1980. [14] Schwartz,J.T., Decision Algorithms \nfor Multi-level Syllogistic, Proceedbtgs of the llfth Conference on Automated Deduction, Les Arcs, France, \n1980. \n\t\t\t", "proc_id": "567532", "abstract": "When the \"binding mechanisms\" of assignment, quantification, and procedure definition are removed from a conventional first order total correctness logic of programs, the remaining logical system is decidable in time approximately one exponential in the length of the input. This system is maximal in the sense that the presence of any one of the three binding mechanisms would make it undecidable. Such a decision procedure can play a central role in the construction of program verifiers based on decision methods.", "authors": [{"name": "V. R. Pratt", "author_profile_id": "81100298352", "affiliation": "M.I.T. sabbat. Stanford", "person_id": "PP39036584", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567550", "year": "1981", "article_id": "567550", "conference": "POPL", "title": "Program logic without binding is decidable", "url": "http://dl.acm.org/citation.cfm?id=567550"}