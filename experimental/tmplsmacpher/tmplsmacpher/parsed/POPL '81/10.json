{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 All of the tools we will discuss share a common representa\u00adtion of a program, \nthe program s parse tree. This might be the first point at which we differ from collections like The \nProgrammer s Workbench[5]. The parse tree embodies in some sense a fuller understanding of the program \nthan the text string for that program. Thus, there are many tasks which are much easier for our components. \nAnother thing that is shared by all components is the display routine. All information about a pro\u00adgram \nprints through the same interface. A common read loop is also shared. Before going into more detail, \nwe describe one sequence of interactions which illustrate these points. The display program is designed \nto display the parts of a program near a desired sub\u00adexpression and to brighten that sub-expression. \nWhen editing, a programmer can, for example, move that entire sub-expression to a different place in \nthe program, without counting how many lines need to be moved. When executing, that sub-expression is \nthe current location counter . If he is executing a program and wishes to see only the execution of some \nsub-part which will be executed after many statements, he can use ordinary edit com\u00admands to move the \nfocus of attention from the current location counter to the location he wishes to see in more detail. \nHe may then execute a command which means execute until this new focus is the location counter . Thus, \ncommands normally associ\u00adated with editing of a program are valuable in a quite different context. Effects \nlike this pervade our system. The graceful incorporation of a tool such as an interpreter necessarily \nintroduces language dependence into the system. However, the language sensitive parts of our system can \nbe isolat\u00aded, and in a future paper we will discuss how to do so. The language we chose was LISP/370 \n[2], a dialect of LISP which includes most of the semantic features in modern languages such as PASCAL. \nBy way of contrast, consider Interlisp[15], very likely the most highly developed program development \nenvironment widely available for a high level Iangnage. Section 2.2 of [15] presents a toy example of \nthe development of a factorial program. In this scenario the programmer encounters three distinct user \ninterfaces in the course of developing his program -the basic read-eval-print loop (for program creation), \na debugger(that catches program errors), and an editor (for modifying and saving the program). Interlisp \nis a traditionally structured program development envi\u00adronment wherein the tools are independent entities \nable to provide different kinds of information in their individual contexts. Conse\u00adquently an Interlisp \nprogrammer is said to be in the break package (debugging system) or in the editor or irr masterscope \n(analysis subsystem). We believe that having different interfaces for differ\u00adent tools focuses the user \ns attention on the tool rather than the program being developed. To sharpen this last point we remark \nthat the LISPEDIT user brings the tool to the program rather than the other way around. The program (actually \ncollection of programs) is an object about which a wide variety of information is aIways available as \npart of its srazus: the program text, the program status in long term (file) memory, the values of variables \nthat are currently (in the dynamic sense) defined, the point of execution that has been reached within \nthe program, the call stack, a variety of static flow infor\u00admation about the program, etc. Moreover, \nthis information, being merely Lisp data, is always presented to the user through the same structured \ninterface. Indeed, whenever it makes sense to do so, the program status may be changed by ediring these \nvery same data. There are a number of other PDE s[see 10 for a list of them and also 1,2,4,6,11,12], \nbut none to our knowledge have both 1) as high a level of integration of their components and 2) have \nbeen used to build large systems. We suggest thereader note that the testing notions, the display, and \nthe comment facility are tools which have not appeared elsewhere. We will discuss several other programming \ntools, which are not new when considered in isola\u00adtion; it is when their interaction is considered that \nthey become interesting. The remainder of this paper has four sections. Section 2 discusses the individual \ncomponents from a user s point of view, demonstrating the display and some of the commands available. \nSection3 shows howasimple program might be built and the way in which parts of the system interact with \neach other. Section 4 gives some examples of how the user might benefit from the integration of the system \nfacilities. Section 5 discusses theimple\u00admentation of the system and some of the important components. \nSection 6 presents a collection of statistics gathered which provide insight in the relative utility \nof a number of commands. Finally, we provide a few brief conclusions in Section 7. We should note that \nthe system as it exists does not quite match the description given here. The system described matches \nthe system as it was about two years ago. However, we shall also describe a few ideas which are not available \nin Lispedit but will be implemented in the system described in [16]. In the text and section 6 we will \ndescribe which ideas have not been implement\u00aded. For a more precise description of what is currently \nin Lispedit see [17]. 2. System Components We observed in the preceding section that our system con\u00adceptually \nbreaks into six components. We shall not discuss the LISP/370 compiler any further, but we will describe \nthe five remaining components in detail. By overlaying this structure on the system, for pedagogical \nreasons, we do not mean to imply that the components are not interrelated. In fact, the ability to use \ncode from other components simplifies many tasks. 2.1. The Display Component One of the goals of our \nsystem is to keep the user from feeling that he is constantly changing environments while develop\u00ading \none program. To a great extent, from the user s point of view, if the display changes the environment \nis thought to have changed. While changing the text dk.played is obviously neces\u00adsary, it is important \nnot to change the overall appearance of the display. The display format we will describe allows us to \ndisplay all the information a user needs, without giving that user the feeling that the environment has \nchanged. 93 There are two critical objectives that a display must meet. It must show that information \nwhich the user is interested in and it must show such information in an easy to use form. We presume \na display with the capabilities of an IBM 3277, which can bright\u00ad en fields and refresh the screen very \nrapidly. We will discuss three ways in which the programmer s inter\u00ad ests may be determined. First, \nin most editors there is a notion of a focus of interest. In line editors this can be a particular line \nin the display, often brightened. In full screen editors it may be a cursor, such as an underscore or \na blinking box. The focus acts as a reference point for commands, including (but hardly confined to) \nthose which change or replace the data represented by the focus, those which insert new data in the vicinity \nof the focus, and those which shift the focus to other data. The user can enter commands directly or \ncan use local function keys. In short, the system assumes that the <user is interested in that piece \nof data which he as last acted upon (via the editor s command language) and it reflects that historical \nfact via some form of highlighting on the screen. The Lispedit display routine shows the focus and parts \nof the data related to the focus. We attempt to determine automatically what related parts of the program \nthe user is inter\u00ad ested in viewing. Many other systems only show the user some fixed number of lines \nabove and below the focus. Second, a user frequently has occasion to direct his attention to multiple \nfoci. For example the user might request to be shown all instances of the variable x. The display for \n[16] will eventually try to brighten all such instances and show their interrelationships. The third \nway the system described in [16] may determine the interests of the user is to keep track of what the \nuser has focused on recently. Thus, if the user is trying to read through a program, he is probably not \ninterested in what has just been seen. If he is trying to correlate various parts of a program, he is \nmore interested in what has been a recent focus. We will say that some section of a program which the \nuser would probably like to see has Klgh priority. It must be possible to display a large program or \na large data structure. Moreover, the display must be small enough to be comprehensible and fit on a \nCRT device. The syntactic structure of the program is available to the display program. Thus, if priorities \ncan be ass@ed to the parts of the program, those parts with higher priorities can be displayed and others \nreplaced with ellipses ... . If short repre\u00ad sentations of the syntactic units are available, they may \nbe used instead of ellipsis marks. While the Lispedit display only approxi\u00ad mates a priority driven display \nwe have a prototype implementa\u00ad tion for [16] which always displays a high priority item in prefer\u00ad ence \nto a lower priority item. Lispedit fails to always do this since it is uses a simpler one-pass algorithm. \nIf we are interested in one specific syntactic structure in a particular program, say a loop, we give \nhigh priority to the sub\u00adsections of that loop, the surrounding statements, and the enclos\u00ading control \nstructure which show how the loop is reached in the program. If the loop is too large to show on one \nscreen or the part of the screen allocated to the description of the loop itself, then some of the leaves \nof the parse tree for the loop, such as the then and else clauses of an if ... then else statement may \nbe elided. By modifying the assignment of priorities we can focus on several subsections of a program \nsimultaneously, For example, if B must always be done after A in a program, one use of the display system \nwould be to display all instances of A and B to ensure that the proper order is preserved. The display \nis re-computed dynamically. With every terminal interaction, the data or program being displayed is traversed \nand the structure re-prettyprinted. Thus, the programmer need not worry about the indentation of a line \nbeing entered, and if a group of expressions three syntactic levels of nesting down is moved to a location \nfour levels down, the programmer need make no adjustment of margins. Because the dynamic redisplay is \ndone automatically and correctly, errors caused by reading indentation rather than parentheses (or semi-colons \nin other languages) do not occur. The ability to distinguish various regions of the displayed text is \nuseful, The example of the matching A and B actions above provides an opportunity for making such a distinction. \nSeveral kinds of display hardware assistance (generically called highlighting ) can be imagined: multiple \nfonts, underscoring, reverse video, and brightening. Presently we use brightening to distinguish the \ncurrent focus of attention. When a standard text editor cannot fit an entire entity (usually a file ) \non a single screen the user is normally presented with a fixed sized rectangular window, centered on \nthe current cursor. Movement through the item being edited is accomplished by sliding this fixed window \nover a static field representing the item. In many cases, the data shown by such a display consists of \na number of unrelated parts of the item, while parts which are closely related to the data designated \nby the cursor are outside the displayed area. Our dynamic display through the use of a number of heuristics \nis much more likely to display the right items. To the best of our knowledge, our algorithm is a new \nand rather general approach to the problem of displaying information. We present two displays of the \nsame program. Figure one is an actual Lispedit screen where the current focus is the first conditional \nexpression in the program. Note that all the program text that precedes the focus in the program is visible \nin full detail; within the focus we can see the main predicate expression and the predicates in the secondary \nconditional expression; in the program text following the focus we can see enough of the program to identify \nthe other cases that are being examined. Figure two displays the whole program as it might be shown on \nan imaginary high resolution screen. 94 ( (LAMBDA ((FLUID CALLER-SEQUENCE)) (PROG ((FLUID POINTS) (FLUID \nSAFETY) (FLUID DESCRIPTIVENESS) S1 LEVEL &#38; ) (CALLING STAYMAN-I ) (SETQ POINTS TF C) (SETQ DESCRIPTIVENESS \n4) (SETQ SAFETY 4) (COND  ( (EQ PARTNERS-BID-LEVEL 1) (COND ((LESSP TPC 8) (COND ((OR 0S1 (AND (LESSP \n&#38; 7) ( &#38; ...))) a) (...))) ((AND (GREATERp TPC 11) (.OR (GREATERP (ELT SQ 0) 7) (&#38; &#38; \n...))) ...) ((OR (AND (GREATERp DPC IX (OR (GREATERp (...) 3) (...))) a) (...)) ( T (SEQ (SETQ pOINTS \nHCPC) (SETQ LEVEL (COND &#38; &#38; ...)) a))))) (COND ((EQ pARTNERS-BID-LEVEL 2) (COND ((LESSp TpC 4) \n(COND &#38; ...)) ...))) (COND ((EQ pARTNERS-BID-LEVEL 3) (COND ((LE=p TpC 6) (COND &#38; ...)) ...))) \n(COND ((NULL SUGGESTED-BIDS) (ADD-BID (PASS)))) (RETURN SUGGESTED-BIDS)))) Lispedit level 1-------------------dirob: \nBI DDI NG2*V STAYMAN-I VALU E Editing SNAP-SHOT Picture of screen placed M file: snap shot Figure 1. \n,STA MAN. ) (.., , ,0..8., , (,, !, CALL, R. Sequence))  ,,,,. ( ,,, >0 m,.,,, (m ,. SAFETY, ,,, ,, \n0,, ,,,,, ,,,s,, ,, LE m ,,, ,. S CC,STEO.,,DS, (,.,,!, s,.,..,. ,, (S,TQ ,0,,7, ,,,) ,SETQ ,,s,8,.,, \n,,,,s ,) (s,,,? SAFETY 4) (m.o ( KQ w~mmm 1) < cw:oy: e, , ,0, 0s, ,.,, {,,s,, (E,, 0,s, ,, 7) ,,,ss, \n{.. ,09, (W/m,, ,,s,,,) ,,,, <.0,.,,, ,,.s,, )  (S,Q . ,,{SETQ , ,),) Figure 2. 95 Both Mentor [6] \nand Interlisp [15] can display a program (or program fragment) to a fixed, user specified, level of detail. \nTo achieve the first display with the Cornell Synthesizer [12] would require one command for each object \nthat was elided. In Llspedit the depth of detail is automatically adjusted to produce a syntacti\u00adcally \ncoherent picture of the program that attempts to make opti\u00admal use of the available display area. Ordinarily, \na program wonld probably not be written this way. Rather, the three cases would have been made into individ\u00adual \nsubroutines and a program which tested the cases would have called the appropriate one. We claim (and \nthe programmer who coded this obviously agrees) that, in the presence of our display algorithm, it is \neasier to understand as written. Indeed, the condi\u00adtions identify the cases as easily as a procedure \nname. Moreover, it is possible to compare what happens in one case to what hap\u00adpens in the other two. \nWe should describe briefly at this point the format of our screen. On the top we display the object being \nedited. That is followed by a fence line separating the object from the message area. On the fence line \nis the name of the object, and a mode indicator. In most cases the mode is just lispedit. However, if \nyou want all lines typed are to be inserted as opposed to being interpreted as commands, then the mode \nindicator says input mode. Heval, which will be discussed later, is another mode. Below the fence line \nis displayed the last command entered, and any message or messages produced by the command. The fence \nline floats, depending on how many messages were prod\u00aduced, and the object being displayed shrinks or \ngrows accordingly. 2.1.5. Comments Comments cannot be inserted textually, because the display of a program \nis reformatted dynamically. Rather, comments must be explicitly associated with the section of the program \nthey discuss. So, we must have some means of associating a comment with an object to be commented other \nthan the normal one of placing the comment a small number of blanks away from the object. We have three \ntechniques which may be unified. The sim\u00adplest of these is named ellipsis. If an expression is too large \nto be displayed, the user is able to indicate a name for that section of code which will be shown instead \nof ... . A second more flexible form of comment is allowed by making comments into footnotes on the statements. \nIn this form a footnote mark is placed on the statement and somewhere else the comment ap\u00adpears. This \nallows reading the program without having the pro\u00adgram text interrupted and yet allows parts of the program \nto be commented. Since the screen is reformatted automatically, it is important to avoid placing a comment \nwhere it would be annoying or where it is not clear what it is referencing. This can happen for example \nwhen in the automatic reformatting two lines are combined onto one line. If there is a comment in between \nthe two lines it is not clear a priori whether the comment should go between the two pieces of program \ntext, or off to the side. Using footnote notation also allows us to move comments around to make a prettier \ndisplay. The third type of comment enables a description of identifiers to be written and requested later. \nThis is similar to a footnote, except that the footnote mark does not ordinarily appear, and the footnote \nis related to all sections of a program where a variable appears. Thk is useful for descriptions of subroutines \nas well as documentation for identifiers. 2.2. The Editor Component We have borrowed several features \nfrom typical text editors. In addition to the display component that we have already dis\u00adcussed, the \neditor has a command-read loop that supports posi\u00adtioning and updating commands. The read loop recognizes \ncom\u00admands, invokes the appropriate routines, and calls the display routine to show the results. It is \nimportant that the command execution routines not call the display routine directly. Doing so would preclude \none command from calling another to perform some simple function. Certain commands, such as input mode, \nmay establish their own read loops and these must call the display routine between console reads. The \nconsole reads are performed by subsections of the read loop. The read loop also performs service functions \nsuch as remembering the last 10 commands. Paraphrasing traditional LISP parlance, we might characterize \nthe command-read loop as a READ-EVAL-DISPLAY loop. There is a notion of a current position, which is \nindicated by the so called f ecus. The position is a node of the expression tree. (The reader should \nbear in mind that LISP structures are being edited, not strings which happen to map into valid LISP structures, \n) The current position is meant to distinguish our focus of attention, and is indicated by brightening. \nMany commands are interpreted relative to the expression distinguished by the focus. Another node may \nbecome the focus of our interest and we will want this node to become the current position. There are \nthree ways to achieve this in our system. The most primitive way is to give a series of directions like \ngo up to the father of the current node and go to the fifth son of the now current node. The primitive \ncommands are up, right (in a list), ie~t, down, son, and lop. Less primitive commands have been implemented \nusing the primitive commands, including both commands such as locate a particular s-expression equal \nto the argument and a more power\u00adful pattern matching locate, and commands which return the focus to \na previously visited location. Yet another type of positioning occurs relative to the displayed representation \nof the structure. We might command that the focus be made the s-expression which starts with the fifth \ntoken on line 6. Commands can create other commands. Locate All Expressions finds all expressions which \nmatch a pattern inside the current focus. It has an optional argument, which defines a com\u00admand. Each \ntime this command is issued the focus is shifted to the next match found by the original locate command. \nThis com\u00admand is independent of the current focus and other locate com\u00admands. We have kept the number \nof primitive updating functions small. This is necessitated by the fact that changes to the pro\u00adgram \ntext result in the incremental modification of certain look-aside data structures that describe various \naspects of the program being edited. Included among such structures are data bases that describe how \nthe program is to be pretty-printed and data bases that describe the findings of static program analysis. \nIn order to keep the look-aside data structures synchronized with the program as it is developed, the \nparts of the system concerned with maintaining those structures must be informed of changes. By keeping \nthe number of primitive functions small we can isolate in a few places interfaces with the look-aside \nupdating functions. Hence, even functions such as changing one expression to another are done in terms \nof locate and replace, which are primitive. 2.3. The Dynamic Analysis Package One of the most important \nthings to know about a program is how it runs on examples of input data. We can run a program on one \nor many different instances of data and use the display rou\u00adtine to display results of the execution. \nOne of the more interest\u00ading tools we have in this line is a hierarchical, single-stepping interpreter \n(the command -h:val -stands for Hierarchical EVAL\u00aduator). This interpreter allows single stepping much \nlike console debugging. However, since the language has a fair amount of structure, a step might be the \nevaluation of an expression or might be to start the evaluation of a sub-expression of that expression. \nWe allow the size of a step to be changed interactively. Before an expression is to be evaluated, the \nuser has the option of simply evaluating that expression or evaluating each of the sub\u00adexpressions. In \neither case, the value of the expression evaluated will be shown. We should also mention that various \ntiming facili\u00adties are also included as part of the hierarchical evaluation system. This interpreter \ncan be extended so that it has the ability to validate a program. A program is said to be validated if \n1) all sub-expressions have been executed 2) all assignment statements have been followed by uses of \nthe assigned variable and 3) all expressions whose values may change have evaluated to more than one \nvalue. All correctly written programs can be tested (possibly this needs several runs) in such a way \nthat this is achieved. We will display the unexecuted expressions and unused assignment statements. We \nshould point out that these conditions are incomparable in strength with the work on testing by program \nmutation[3 ] and have the advantage of not complaining about conditions which cannot be tested. While \nwe have not imple\u00admented the validation notion, we are not aware of any equally sophisticated and practical \ntesting techniques and intend to imple\u00adment these ideas in the system described in [16]. 2.4. The Static \nAnalysis Package While dynamic analysis can reveal program behavior for particular input data, it cannot \nreveal what may (or may not) be the case in general. A simple theorem prover or symbolic evalua\u00adtor \nbased on techniques generally associated with optimizing compilers can serve to demonstrate various \nstatic trutha about a program s behavior.. The algorithms that we employ are based on a lattice-theoretic \nframework for propagating information about programs, operating directly on the high-level language, \nand treating inter-and intra-procedural analysis symmetrically. Static analysis can be of value to the \nprogrammer both in terms of providing information about his programs and in the transformat\u00adion of his \nprograms so as to ameliorate them with respect to some objective measure. Informational uses of static \nanalysis include the detection of uninitialized variables, unused statements, dead assignments, type \nincompatibilities, and certain classes of non-termination in loops. Furthermore, if the programmer wishes \nto know what statements potentially modify (or use) a particular variable, or what statements can affect \nthe value of a variable at a particular use, static analysis can provide the answer. Transforma\u00adtional \nuse of static analysis can support such functions as program simplification through procedure integration \nand constant propa\u00adgation. We intend to communicate the findings of static analysis through the use of \nthe highlighting mechanisms that generally support the display component of the editor. 3. An Example \nof Program Creation and Debugging In this section we attempt to develop the reader s intuition by showing \nsome instances where our system is useful. We do this by tracing the building and debugging of a program. \nSo that the reader may eaaily follow this process, the program built will be a simple one. Unfortunately, \nthis blunts many of the points we will be trying to make. We wish to show that our system makes it easier \nto understand programs. But, in the interest of brevity, the program we are forced to consider may be \neasily understood without any of the tools we are building. As the example progresses, the programmer \nchanges his principle activity. First the basic program is entered. A few changes are made, and then \nthe program is debugged. This is realistic only for small programs. In a larger program there are many \niterations of this process. A programmer does not often spend large amounts of time doing primarily one \nkind of activity. The interface presented by LISPEDIT does not change substan\u00ad tially and in the context \nof many iterations of the programming process this becomes important. In the following we will first \nshow what the user would type as a command line, followed by a summary of the screen that would be displayed \nthereafter. 1ne --1 oramamy nas LKwe use twenty-two lines of text. Here, we will ordinarily assume \nsome\u00adthing more like six. Command: GH Quick-m Display: () Explanation: We want to create a quicksort \nprogram to sort ele\u00adments in descending order. So, we get the vahre of quicksort from the file system. \nIt is initially NIL, and that is what is dis\u00adplayed. When applied to a list a with initial element y, \nthe quicksort program Q will create two lists ~ and v whose elements are those in the tail of a which \nare >Y and <Y, respective. The value Q(a) is then obtained by appending together the three lists Q(P), \n(y), and Q(P). Command: i Display: () Explanation: The display indicatefi that we are in input mode and \nare about to replace the current focus, by changing one of the headings on the screen. Command: (lambda \n(sortme) Display: ( lambda (sortme) ) Explanation: (sortme) is now the focus and anything which is input \nwill be inserted after it. Command: (prog () Display: ( lambda (sortme) (prog ()) Explanation: sorfme \nis the list which is passed in, and we will deal with it in a program prog which at the moment has \nno local variables. Command: (cond ((Oorl sortme)(return sor-tme))) Display: ( lambda (sortme) (prog \n () (cond ((Oorl sortme) (return sortme))) ) ) Explanation: Oorl is a user defined predicate which returns \ntrue if sortme is a list of O or 1 elements. In that case the list is already sorted. Command: (setq \ny (car sortme)) Display: ( lambda (sortme) (prog  () (cond ( (Oorl sortme) (return sOrtme) ) ) (setq \ny (car sortme)) ) ) Explanation: We will be comparing elements to y, which is the first element in the \nlist. If we had a color terminal we might display a section of a program which is wrong in red (which \nis mnemonic for stop) as was done in [18]. Here y would be red because it is undeclared. Command: describe \ny (y will be greater than all elements in bucketl, and less than or equal to elements in bucket2) Display: \n( lambda ( sortme) (prog ( ) (cond ( (Oorl sortme) (return sortrne) ) ) (setq y (car sortme)) ) ) y \n<--> (y will be greater than all elements in bucketl , and less than or equal to elements In bucket2) \n Explanation: By means of this command we can use short identifi\u00aders, and still be able to figure out \nwhat they mean. On a larger screen we may be able keep all these descriptions off to the side. Only one \ndescription is necessary for many instances of the icfen\u00adtifier in the program. The variable y is still \nred, since it has not yet been declared. Command: $declare y Display: ( lambda (sortme) (prog (Y) (cond \n( (Oorl sortme) (return sortme) ) ) (setq y (car sortme)) ) ) Explanation: declare is a command. If \nyou are in input mode, a $ preceding a command will force that command to be executed. Command: (for \nx in (cdr sorfme) do (cond Display: ( lambda ( sortme ) (prog (y) (cond ( (Oorl sortme) (return sortme) \n) ) (setq y (car sortme) ) (for x in (cdr sortme) do (cond) ) ) ) Explanation: for is a macro which \nexecutes the statement after the &#38; repeatedly with x assuming all the values in (cdr sortme). Command \n:((greaterp x y) 1 (setq bucketl (cons x bucketl) *I (Iessp would give ascending sort) Display: ( lambda \n( sortme) (prog (y) ... (for x In (cdr sortme) do (cond ( (greaterp x y) *I *1 (lessp would. . . ) (setq \nbucketl (cons x bucketl)) ) ) ) ) ) Explanation: Note the ellipsis. Remember that we are assuming a six \nline screen and must elide something. The setq to y, test for empty or null list, and end of the comment \nare probably the best choices. Since bucket 1 is undeclared it is shown in red. This does not require \nus to do anything before we proceed; however unless we wish to use it as a free variable (which may be \ndeclared to eliminate the redness), it is a mistake and must be fixed even\u00adtually. The notation * 1 is \nused for comments. If there were more comments *2, *3 *n would be used. With this notation the comment \nneed not be on the same line as the code that it is de\u00adscribing although it always will be in this example \nsince on a six line screen lines are too important to devote to a comment. We will now pretend that the \ncurrent focus is a large expression and that we wish to avoid re-typing it. Command: $copy Display: the \nsame as above. Explanation: copy, which is executed as a command, stores a copy of the focus so that \nit may be inserted elsewhere. Command: )( t Display: (prog (y) ... (for x in ( cdr sortnre ) do (cond \n( (greaterp x y) *1 *1 (lessp would. . . ) (setq bucketl (cons x bucketl ) ) ) ( t))))) 98 Command: \nrun Command: $% Display: Box 3 is the focus. Display: Explanation: Run causes the evaluation of the \nfocus, without (prog (Y) ... showing the evaluation of the subparts. (for x in (cdr sortme) do (cond \n( (greaterp x y) *1 *1 (lessp would. . . ) Command: run (setq bucketl (cons x bucketl ) ) ) Display: \nBox 4 is the focus, LAST VALUE = 1 ( t (setq bucketl (cons x bucketl )) ) ) ) ) ) Explanation: the value \nof y is now 1, and this is the value of the Explanation: to inserts the value that was stored by copy. \nTo may last focus displayed and evaluated. be re-used later to insert the same thing. Command: display \ndata bucketl bucket2 Command: cng bucketl bucket2 * Display: Box 4 is the focus on the top half of the \nscreen; bucket 1 Display: = (). and bucket2 = () on the bottom of the screen. (pr09 (Y) Explanation: \nthis allows us to observe the value of certain varia\u00ad... (for x (cdr do bles as execution continues. \nThe implementation sets up another in sortme) (cond ( (greaterp x Y) *I *1 (lessp would. . ) edit session \non the bottom of the screen. Thus, if the data is too (setq bucketl (cons x bucketl ) ) ) large we can \nuse edit commands to look at specific portions of the ( t (setq bucket2 (cons x bucket2)) ) ) ) ) ) data. \nExplanation: The change command works in the scope of the current focus. The * that is the third argument \nto cng causes Command: step bucket 1 to be changed in all those instances, Display: Box 5 is the focus, \nbucket 1 = (), bucket2 = () We eventually finish the program, and the final version ap- Command: run \npears in figure 3. We have drawn in boxes which indicate various Display: Box 6 is the focus, LAST VALUE \n= 2, bucketl = (), values of the focus in what follows. bucket2 = () We wish to run this program. We \ncan do so simply by typing Explanation: the value of x is now 2, and this is the value of the the LISP \nexpression which invokes the sort routine. Alternatively, last focus displayed and evaluated. we can \nrun it, examining the program as it is being executed. In Command: run order to observe the running program, \nwe type in the command Display: Box 5 is the focus, LAST VALUE = (2), bucketl = hevaf, invoking the hierarchical \ninterpreter. Heval allows the user (2), bucket2 = () to step through parts of his program and display \nintermediate We may become tired of running around in the loop. Using results on the screen. edit commands \nwe position the f ecus at box 7. Command: Heval (1 23 4) Command: corm Display: the (elided) program \nwith Box 1 as the focus. Display: Box 7 is the focus, LAST VALUE = 3, bucket 1 = (4 3 Explanation: This \ncommand starts the evaluation of the quicksort 2), bucket2 = () program with sortme bound to the list \n(1 23 4), Explanation: The program has been executed until it is about to execute Box 7. The value of \nthe last f ecus displayed was 3, x on Command: step that iteration of the loop was 3. Bucket2 has become \na larger list Display: Box 2 is the focus. in subsequent executions of the loop. Explanation: Step causes \nthe evaluation of each of the subexpres\u00ad sions of the focus to be shown. ( lambda ( sortme) 1 (prog (y \nbucketl bucket2 ) ) return sortme) ) ) 7 . (cond ( (Oorl SJrtme) (I 3 (setq y (car sortme) ) I 5+ ( \ncdr sortme ) do 1 I 1 *1 (lQSSp would. . ) 6. (cond ( (greatem x Y) 1 IN (.~tqI    ,---b~cketlI \n(cons x bucketl ) ) ) I :mJ-~~ I + (sets bucket2 (cons x bucket2) II I .,.. )) 1)) =(4 7. (rettirn (append \n(quicksort bucketl ) (llst Y) ~ Figure 3. Command: run Display: top level display of quicksort, value \n= (4 32 1) Explanation: we have finished the execution of the quicksort, and it has returned the right \nvalue. We have now exited heval. We may be interested in which statements have not been executed. The \ncommand te,sred will highlight box 8, since the code contained there has never been executed. If there \nwere more sections which had not been executed, they would also be bright\u00adened. We could then run another \ntest case, and nnly those state\u00adments which had not been executed in either case would be brightened, \nHad we mis-typed bucket2 as bucket 1 in box 7, the setq in box 8 would still be brightened, since there \nwould have been no uses of bucket2 following that setq. In LISP/370 all variables bound in a prog are \ninitialized to nil, Were they not, the first use of bucket 1 and bucket2 would have been highlighted \nwith red, because they were uninitialized. If we were confused about the function which bucket 1 was \nper\u00ad forming,have all instances of bucket 1 highlighted, with wewould  other statements being elided. \nWe could do this highlighting to a procedure call which used or stored into bucket 1 even if the procedure \ncall did not have bucket 1 mentioned in its argument, or only used it by calling another routine which \nused it. This concludes our example. It is unfortunate that for obvi\u00adous pedagogic reasons we cannot \nillustrate the utility of our sys\u00adtem in developing large programs. However, we will point out that the \nsystem has been used in its own development, as well as other unrelated large programs. 4. Examples of \nIntegration of Facilities In this section we would like to describe some of the ways users have utilized \nthe fact that all of the tools we provide inter\u00adact well with each other. One example is the way the \ncommand Come is used. Ex\u00adecution is begun in Heval. At some point the user wishes to skip seeing at a \ndetailed level anything but the execution of a certain piece of code. Using ordinary positioning commands \nthe f omrs is moved to that section, the command come is executed, and execution continues until it reaches \nthat point, after which the user sees the execution in detail again. This example points out the need \nto integrate the positioning and execute commands. Another two examples are illustrated by the command \ne = . When an expression is typed by the user it is evaluated and the value displayed on one line in \nthe message area. That line starts with value =. If the vahre does not fit on one line parts of the value \nare elided (using the same elision strategy as in the display). The value is also put in the global variable \n=. That value may be examined by editing that global variable (just as any other varia\u00adble may be edited). \nWhile editing a global variable, all of the positioning commands which work while editing programs still \nwork. This saves a lot of relearning. Commands also put values in t,he global variable =. If the command \nrun is given, in Heval, the brightened expression is evaluated, and its value is placed in ,, _!, The \nfocus moves to the next location. The message area holds the message Last value = and one line of the \nvalue. Thus, it must be possible to integrate the ability to edit objects and data in the same editor. \nIt is also important to allow the evaluation of expressions inside of the editor. The command HM also \nbenefits. This flags a certain proce\u00addure to be Hierarchically evaluated. It is important that it work \nboth when the user is editing and when evaluating a potentially calling procedure. Since only the sonrce \nmay be hierarchically evaluated there is a problem when hm is applied to a compiled routine. If the compiled \nroutine stored the location in the file system where the source would be found, the problem could be \nalleviated. We do not currently do this. Thus, it is important to integrate the file system, which keeps \ntrack of where the source for a program is, with the debugging system. When we first implemented hm, \nwe made a mistake and copied the object before it was evaluated. Users, knowing that the system was highly \nintegrated, would find an error, while step\u00adping through the program, and they would fix the error. They \nwould then stop the monitoring of the program, and since the original program was restored, so was their \nbug. If compiled code is to be accessible to the hm command, either updating must be stopped, the formerly \ncompiled program run interpretively, or the program recompiled. The latter is better. Thk would be particu\u00adlarly \ntrue in a system for a different language, where when the change made was to a declaration, that change \nmight cause other programs to be recompiled. It is possible that the best situation would utilize an \nincremental compiler, which would help the user avoid the decision whether to compile or interpret his \ncode. Often one wants to be able tn edit one of a collection of functions without affecting the others. \nWhen one does this the date stamp should not change for the others, even if because of the changes made \n(perhaps in declarations of variables) the other routines need to be recompiled. Occasionally, however, \none wants to edit the whole collection (for example to find all in\u00adstances of a free variable). Thus, \nit is desirable to integrate the file system with the editing system. 5. Implementation and Other System \nFacilities In this section we describe some of the facilities which we have found useful in implementing \nthe system. These facilities are also available to the user as part of the system. We will also go into \nsomewhat more detail on the algorithms used and the precise features offered the user. 5.1. Annotation \nThere are two system facilities which we have not discussed. Both of them deal with annotating certain \nstructures. We have incorporated in our program development environ\u00adment a file system structured as \na forest of trees, each tree corre\u00adsponding roughly to a directory. More concretely each tree is of height \nthree, the root being labeled with the directory name, subtrees being labeled with the names of objects \nof interest, and finally, the leaves being labeled with indicators that distinguish various properties. \nTypically, the individual objects of a labeled tree denote functions or data objects to be used together. \nUnder the property indicators on the leaves are found such things as function defining expressions. Thus, \nthe subtree designated quicksort might hold the above procedure under a tree labeled sortpackage . The \nleaves of the quicksort subtree contain various pieces of information about that procedure. Under the \nvalue leaf of the quicksort subtree is the source text of quicksort. Un\u00adder the disposition leaf is an \nindication as to whether the code should be interpreted or compiled. Yet another leaf might say that \nthere is a compiled version available. Various commands facilitate the addition of other annotations \nunder selected leaf labels. Editor commands are defined through the general file mecha\u00adnism. Certain \ntrees are singled out to be examined whenever a command is issued by a user. The command itself is taken \nas a subtree label. If certain distinguished labeled leaves can be found under that subtree, then the \ncommand can be vafidly interpreted. Of course, users can establish dynamically what trees are to be searched \nfor command interpretation. Typically a user will have at his disposal several system supplied trees, \nas well as his own, and perhaps those borrowed from other users. A command must have a leaf, called the \ntell leaf, describing the command in Eng\u00adlish, and another leaf which describes the number of arguments \nexpected, so that the read loop of the editor may determine if a command is ill-formed. We are likely \nto add a leaf which indi\u00adcates whether the command can modify the structure being exam\u00adined, so that \nwe would know that certain nodes of the object being displayed should no longer be annotated as described \nbelow. The second of our annotation facilities allows us to associate information with any LISP/370 datum. \nThis annotation is a triple <p i v> where the value v is associated with the pointer p under the indicator \ni. Using this facility we can do such things as adding backpointers to the usually single-threaded LISP/370 \nlist data structures. Similarly we may associate information with any LISP/370 data structure indicating \nhow it is to be pretty-printed. It is important to note that the annotation in no way affects the object \nbeing annotated. Consequently the annotation of an ob\u00ad ject is transparent to LISP/370 system functinns \nsuch as EVAL. 5.2. The Pretty-Print/Display Algorithm There are two major reasons why conventional pretty \nprint\u00ad ing algorithms fail in our display situation. 1) It is necessary tO examine the ancestor(s) of \na node in order to know how to pretty-print that node. For example a number might be printed differently \nif it were a label or a quantity to be added; in the former case it would be placed at the beginning \nof a line, in the later it might be in the middle. Standard pretty-print algorithms usually start at \nthe root node. But, we have the notion of a focus or foci of interest, which, if sufficiently localized, \ncan cause the loss of surrounding portions of the display, including the root itself. So, we cannot start \nprinting at the root; we can start some analysis at the root. 2) Standard algorithms assume an infinitely \nlong sheet of paper, rather than our limited CRT display. and so need not squeeze as much on a line, \nnor deal with the notion of eliding sections. as we are forced to. In our system the prettyprint algorithm \nand me display algor\u00adithm are two separate but interacting components. The pretty\u00adprint algorithm converts \nthe structure of the parse tree into a structure of nested boxes that reflects the esthetic intentions \ninherent in pretty printing. The display algorithm translates these boxes into a two dimensional image \nthat fits on the output device. Let us consider the box which would be produced by the pretty\u00adprint algorithm \nfor a PROG. There is a particular type of box, called a vertical box, which should, if possible, be displayed \nwith all of its component boxes lined up vertically. All the statements in the PROG are grouped in a \nvertical box. Other boxes are used to allow enough indentation of this vertical box to enable labels \nto be shown to the left of the labelled statements. The bound varia\u00adbles of the PROG are shown in a box \nadjacent to PROG. The purpose of the box structure is to map the parse tree into a struc\u00adture that indicates \nthe preferred two-dimensional layout of pro\u00adgram text, to specify the relative priorities (or importance) \nof phrase components, and to define a minimal elided form for each statement. The display algorithm carries \nout the instructionsin the boxstruc\u00adture under the constraint of one or more foci of attention and within \nthe limitations of tbe available display area. In the single focus case, display generation begins at \nthe box that defines the current focus. The first step in display generation is to initialize a priority \nqueue with the current focus. The next step is to attempt to show the minimal elided form of the first \nbox in the queue. If the attempt fails, that particular box remains elided and we go to the next box \nin the priority queue. If the attempt succeeds, we add to the priority queue any immediate neighbors \nof the current box that have not yet been visited. The above steps are then repeated for the next entry \nin the queue. The process terminates when the display is full or the queue is empty. The current display \nalgorithm assigns decreasing priorities to new entries in the queue by dividing the current priority \nby a constant that depends on the relative position of the new entry. The con\u00adstant for a box that contains \nthe current box is slightly larger than the constant for a component box. The constant for adjacent boxes \nis close to one. This scheme produces a display that favors expansion of the focus over expansion of \nthe context surrounding the focus and preserves detail in statements close to the focus. If several foci \nare present, the simplest strategy is to choose a primary focus and to proceed as in the single focus \ncase. If any secondary foci are expanded during this process, they are shown in the proper highlight. \nA more interesting strategy is to place all the foci on the priority queue during initialization and \nto bias the priority allocation scheme to favor branches in the structure that connect foci. The result \nof this strategy is to generate a display that shows the relative positions of the foci in the text of \nthe program, with connecting text shown mostly in elided form. 5.3. HEVAL The hierarchical evaluator \nis a recursive descent interpreter. It uses the fact that in LISP/370 one can create states and evahr\u00adate \ninside of them. It has a number of important user features, some of which were illustrated in the example. \nWe will discuss the commands run, step, come, runfast, hm, , and value. The command hm takes as arguments \nprocedure names. It changes those procedures so that when they are invoked they are hierarch\u00adically evaluated \n(HEVALed). When a procedure is being hevaled, all normal editing commands are legal, although changes \nto the program may be impossible to execute directly because of macro expansion. The focus ordinarily \nidentifies the object to be evalu\u00adated next. If run is typed, the focus will be evaluated, and the next \nobject to be evaluated is displayed. The value of the object that was just evaluated is displayed in \nthe message area. (Values put in the message area can always be edited recursively, if they are too big \nto fit. A partially elided form is displayed then. ) If step is typed evaluation of the object is started, \nbut is halted when the first displayable part of that object (e. g. the conditional part of a cond) is \nabout to be executed. Evaluation then proceeds to the second displayable part reached in execution. In \nthe case of a function call, when all the arguments have been evaluated the message line shows that that \nfunction is about to be applied to those arguments. The step and run commands allow the user to traverse \nthe execution tree. This is easy to grasp in a system like ours where the entire focus (to be executed \nby the run command) is highlight\u00aded. In a system like the Synthesizer 12] which denotes the cur\u00adrent \nexecution pointer by a single point, the user must infer the scope of the run command. The Synthesizer \ndoes not allow exec\u00adution of sub-expression of arithmetic expressions. Sub-expression evaluation is particularly \nuseful to the user who has made a mis\u00adtake in understanding the precedence rules of the language. But, \na user who does not understand the precedence rules will not be able to understand the scope of the run \ncommand from a display which identifies a sub-expression from a single point. The value command causes \nany lisp expression following it to be evaluated in the context of the procedure being evahrated. This \nallows you, for example, to change the value of a variable by evaluating an assignment to that variable. \nOne can also edit, recursively, the value of that variable and change its value before returning to the \nedit session in which the evaluation is taking place. If a procedure is called which has been HMed, while \nHE-VALing another procedure, the editor switches its attention to the HMed procedure until it has finished \nits execution. This can of course happen to the new program, causing many levels of stack. Typing runfast \ncauses both running and temporarily causes proce\u00addures which had been HMed merely to be executed, not \nHevaled. This allows careful examination of certain calls to some proce\u00addures, without forcing it in \nall cases. The command corrre is used by first positioning yourself at the point that the code you are \ninterested starts, and then saying come. Execution continues with no intermediate displays, until the \nfocal expression (i. e. the ex\u00adpression you have just focused on) is about to be executed. 5.4. FLUX \nThe static analysis package, called Flux, is based on a global flow analyzer. This analyzer does both \ninter-and intra-proce\u00addural analysis incrementally. The results of this analysis should include define-use \nchains and error detection. We want to detect dead code (i.e. unreachable nodes and dead variable assignment), \nuninitialized variables, type confficts, loops whose terminating condition does not change etc.. The \nability to display multiple focal points will enable us to exhibit this information to the user. On user \ncommand, all errors may be displayed. If you position on a use of a variable, all definitions which can \nreach that expression will be highlighted. 6. Statistics Much of what we have learned in the process \nof implement\u00ading this system is intuitive, and can not easily be communicated to someone who has not \nused the system. In this section we try to convey some of this information by describing some of the \nusage statistics that we have gathered. We would also like to enter a plea with all other builders of \nsimilar systems to gather similar statistics so that comparisons might be made. We have found the statistics \nuseful in our devel\u00adopment work. They 1) show us what components are slow and often used, 2) tell us \nwhich portions are most important to im\u00adprove since they are heavily used, 3) help us find simple sets \nof commands to show new users, and 4) tell us when an experienced user is unaware of a command since \nhe does not use it. The statistics were gathered periodically (when the system was not in a period of \nchange, for example when we switched from non-shared to shared pages for code) over a period of 9 months. \nThree to four users were the primary participants in this experiment, and 91,402 interactions with the \nhost computer were recorded. A heavy user seems to have about 600 interactions with the host computer \na day. These interactions consist of about 10 characters. When in input mode the number of characters \nper typed line approximately doubles. The system maintains 7 prede\u00adfine control keys; these accounted \nfor about one quarter of the interactions (these single key commands were not counted in the 10 character \nfigure above). One interesting number, which our data is not presently precise enough to determine, is \nwhat percent\u00adage of a user s time is he being held back by his typing speed. This would suggest how much \nattention should be paid to having commands which allowed abbreviated typing. For example, it has been \nsuggested that one can type a program more rapidly in Teitelbaum s system[ 12] because with a command \nlike .DW one can insert do while end; . The notion of validation, the comment facility, and the user \ninterface to FLUX are tools which have not yet been implemented in our standard system. Consequently \nthe statistics do not show how often testing or commenting is done. Let us describe our grouping of commands. \nIn each group we have gathered similar commands, and will here, briefly, de\u00adscribe the most important \nmembers of the group. Group 1 contains the commands son, next, up, left, right, and number. These are \ntree motion commands. Son x y z changes the current focus to be the zth son of the yth son of the xth \nson of the current focus. Next positions the focus on the largest s\u00adexpression to the right of the current \nfocus in the entire expres\u00adsion being edited, R igltt finds the sibling to the right. A number command \npositions to the right and if it cannot go further to the right goes down. Some of these commands take \nas arguments either a number or *, and * goes as far as possible. Group 2 contains Run, Step, Come, and \nValue. These com\u00admands control the execution of the hierarchical evaluator. Group 3 contains Replace, \nChange, Dele~e, and Insert. These are some of the update commands. Group 4 consists of the single command \nto evaluate an ex\u00adpression in the current global execution environment. Group 5 contains the file system \ncommands. Those include reading in functions so they may be interpreted or edited,, as well as loading \ncompiled modules and compiting source. Group 6 contains the. commands which enable the user to edit different \nobjects, and to change edit sessions. Group 7 consists of the lines entered in input mode. This mode \nis described in the example. Group 8 consists of the various location commands. These are grouped separately \nfrom the tree motion commands, since their effect is dependent on the atoms of the tree rather than its \nshape. Group 9 are language dependent update commands. For example, Declare, which is described in the \nexample, and Fo~, which takes a list of arguments, and replaces the focus by a list which is the list \nof arguments with the current focus appended. Fof is very useful in an expression language. Group 10 \nconsists of the various commands to aid reviewing previous commands. The most common of these allows \nthe user to modify the previous command and re-execute it. Group 11 include Copy, Move, To. They are \ndescribed in the example. Group 12 are user defined commands. Common examples of these are continuations \nof locate commands. Group 13 are the remaining miscellaneous commands. The most common of these is the \ncommand to pass a command to the underlying operating system. 1) Son, Next, Up, Left, Right, and Number. \n26% 2) Run, Step, Come, and Value. 20 Vo 3 j Replace, Change, Delete, and Insert. ll% 4) expression evaluation \n8% 5) file system commands 7 v. 6) editing objects 496 7) input mode 4% 8) locate commands 5% 9) Declare, \nFof 3% 10) Review commands 3 v. 11) Copy, Move, To 2% 12) user defined commands. 2 Yo 13) Miscellaneous \n4% Let us define an update command as one which changes the tree being edited. A motion command is one \nwhich moves the focus, but is not an update command. Then 31 % of the com\u00admands (groups 1 and 8) executed \nare motion commands and 20\u00b04 are update commands (groups 3, 7, 9, and 11). Since our editor does not \naccept full screen input, the only way to do updating is by moving the focus and making an update command. \nWe were pleased to find that our average of 1.3 motion commands for each update command was that low. \nWe believe that the ratio would be considerably higher in a text editor. As many motion com\u00admands may \nbe regarded as only a means to an end, a low number indicates that relatively few superfluous commands \nneed be execu\u00adted. The reasons for such a low number are probably two fold. 1) Our formatting algorithm \naccurately displays what the user wants to see. Thus, few motion commands are necessary in order to read \nthe program. 2) it is relatively easy to get to where you want to make a change. Note that 23% of the \ncommands (groups 2 and 9) a user enters would be impossible in a less integrated system; this fact provides \nconvincing evidence of the value of combining such tools into one system. 7. Conchrsions It is our belief \nthat as better hardware becomes available systems like ours will become easier to build. For example \nthe MENTOR system [6] had to be teletype compatible and as a result does not interact as well as it might \nwith a CRT. Another example comes from address space. In the absence of a large address space it becomes \nnatural to have a tool which is invoked, and brings in only code thought to be relevant to the kinds \nof interactions when using that tool. With a large address space, these problems can be handled by hardware \npaging rather than software overlaying. The Cornell Program Synthesizer 12] has done a wonderful job \nof providing a unified environment, much like ours, in 56k bytes. Nevertheless, there is a noticeable \ndelay when invoking a command involved with either execution or editing, when the last command was in \nthe other set of com\u00admands. As a result of the larger address spaces and faster ma\u00adchines, we believe \nthat systems like ours will become increasingly common and popular. We have tried to demonstrate the \nadvantage to a programmer of having a unified set of programming tools. We believe that the system is \nvastly superior to a typical combination including a text editor, compiler, operating system, etc. The \ncapabilities of the commands and the display component have enabled users to create and modify programs \neasily. Furthermore, the testing aids such as HEVAL have speeded up and simplified the debugging process. \nIt is clear that the notion of establishing a single envi\u00adronment for program development via such a \nsystem is a signifi\u00adcant step toward increasing programmer productivity. Finally, we believe that these \ntechniques are language independent and will apP1y tO most modern structured languages[ 13,8, 16]. We \nhope to be able to create a set of tools which can be given a table and then work for the language described \nby that table. As was the case with compiler-compilers this will probably not work perfectly at first \nand will require a small amount of special casing for each particular language. Acknowledgments We would \nlike to thank Vincent Kruskal and Paul Kosinski, who participated in the initial discussions which became \nthe basis for LISPEDIT. We would also like to thank our user community, which consists primarily of Len \nBerman, Larry Carter, and Alan Cobham, for a number of useful suggestions, several of which have been \nincorporated into system commands. References 1. Austermuhl, B., Henhapl, W., Kron. H., Lutze, R., On \na Programming Environment and its Generation, University at Darmstadt, Germany, PulR2/79. 2. Brown, \nM., Wood, S., A Display-oriented Program Editor, Yale.  3. Budd, T. A., DeMillo, R. A., Lipton, R. J., \nand Sayward, F. G., Theoretical and empirical studies on using program muta\u00adtion to test the functional \ncorrectness of programs, Seventh Annual ACM Symposium on Principles of Programming Lan\u00adguages, Las Vegas. \nNevada, January, 1980, pp. 234-244. 4. Cheatham, T., Townley, J,, Holloway, G., A System for Pro\u00adgram \nRefinement, Aiken Computing Laboratory, TR-05-79, Aug. 1979. 5. Dolotta, T. A., Haight, R. C. and Mashey, \nJ. R., The Programmer s Workbench, The Bell System Technical Journal Vol. 57, No. 6 Part 2, July-Aug. \n1978. 6. Donzeau-Gouge, V., Huet, G., Kahn, G., Lang, B., Levy, J.J., A Structure Oriented Program Editor: \nA first step toward computer assisted Programming , in International Computing Syrnposiunr, 1975 North \nHolland Publishing Company, 1975, PP.113-120. 7. Elzer, P. F., Some Observations concerning existing \nsoftware environments, DARPA, May 1979.  8. Ghezzi, C., Mandrioli, D., Incremental Parsing, ACM Trans\u00adactions \non Programming Languages and Systems, Vol. 1, No. 1, July 1979, pages 58-70. 9. IBM Data Processing \nDivision, LISP/370 Program Description/Operations Manual, Program Number 5796 -PKL, SH20-2076-0, White \nPlains, New York, March, 1978. 10. Lederman, A., An Abstracted Bibliography on Programming Environments, \npersonal communication, June 1980. 11. Reiser, J. F., Bail, a debugger for Sail, Stanford Artificial \nIntelligence Laboratory Memo AIM-270, Oct. 1975.  12. Teitelbaum, R. T., The Cornell Program Synthesizer: \nA Mi\u00adcrocomputer Implementation of PL/CS, Cornell TR 79-370. 13. Wegman, M. N., Parsing for a Structural \nEditor, FOCS Oct. 1980. 14. Masinter, L. M., Global Program Analysis in an Interactive environment, \nSSL-80-1 XEROX, January 1980.  15. Teitelman, W. et al., Interlisp Reference Manual, Xerox PARC, Dec. \n1978. 16. Mikelsons M. and Wegman M., PDEIL: the PLIL Program  Development Environment --Principles \nof Operation, IBM RC 8513, Yorktown Heights, New York, Nov. 1980. 17. Mikelsons M., Lispedit Command \nDescriptions, IBM RC 8275, Yorktown Heights, New York, May 1980. 18. Kruskal, V., An Editor for Parametric \nPrograms, IBM RC 6070, Yorktown Heights, New York, June 1976,   \n\t\t\t", "proc_id": "567532", "abstract": "In this paper we describe how we have combined a number of tools (most of which understand a particular programming language) into a single system to aid in the reading, writing, and running of programs. We discuss the efficacy and the structure of our system. For the last two years the system has been used to build itself; it currently consists of 500 kilobytes of machine code (25,000 lines of LISP/370 code) and approximately one hundred commands with large numbers of options. We will describe some of the experience we have gained in evolving this system. We first indicate the system components which users have found most important; some of the tools described here are new in the literature. Second, we emphasize how these tools form a synergistic union, and we illustrate this point with a number of examples. Third, we illustrate the use of various system commands in the development of a simple program. Fourth, we discuss the implementation of the system components and indicate how some of them have been generalized.", "authors": [{"name": "C. N. Alberga", "author_profile_id": "81100477921", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York", "person_id": "P35091", "email_address": "", "orcid_id": ""}, {"name": "A. L. Brown", "author_profile_id": "81452610766", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York and Xerox PARC, Palo Alto, California", "person_id": "PP14018336", "email_address": "", "orcid_id": ""}, {"name": "G. B. Leeman", "author_profile_id": "81100260826", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York", "person_id": "PP31034443", "email_address": "", "orcid_id": ""}, {"name": "M. Mikelsons", "author_profile_id": "81100290768", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York", "person_id": "P181738", "email_address": "", "orcid_id": ""}, {"name": "M. N. Wegman", "author_profile_id": "81100339949", "affiliation": "IBM Thomas J. Watson Research Center, Yorktown Heights, New York", "person_id": "PP39038649", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567543", "year": "1981", "article_id": "567543", "conference": "POPL", "title": "A program development tool", "url": "http://dl.acm.org/citation.cfm?id=567543"}