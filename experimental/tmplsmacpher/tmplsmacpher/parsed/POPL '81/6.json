{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 than we had anticipated (and much simpler than the intermediate versions!) \nThis simplification was due to two factors: the language itself changed in ways that made safety easier \nto define, and the specifications became more and more independent of implementation issues. Initially, \nwe believed that the choice of implementation strategy for the collector was a critical part of the design \nprocess. The algorithm to be used was a modified iorm of the incremental garbage collector described \nin [3], which is based on reference counting. Other algorithms, such as those based on ,tracing all pointers \nand marking reachable cells, are extremely difficult to implement in a concurrent system (see [6,7,8]). \nThe incremental algorithm avoided these problems, since it used reference-counts that could be updated \nas an indivisible part of each assignment to a pointer variable. Since the collection algorithm seemed \nso essential, we expected it to appear as an integral part of the specifications. In retrospect, this \nwas clearly wrong. The concept of safety has nothing to do with the implementation method, and the final \nversion of the specifications reflects this fact. However the initial versions of the specifications \nwere essential steps in clarifying oulr understanding of the problem. The remainder of this paper presents \nand evaluates the specifications. Section 2 discusses the goals of the specification task. Section 3 \nis a comparison with related work. Section 4 describes the specification style and presents an informal \nsummary of l,he specifications; the complete formal specifications appear in Appendix 1.Section 5 assesses \nthe degree to which the goals were met, and Section 6 gives our conclusions. 2. The specification task \n2.1. Safety The first goal in developing the specifications was to clarify the notion of safety. Safety \nis a property of the interface between the user s Mesa prc)gram, and the memory management system, which \nconsists of the garbage collector and memory allocator. (We will refer to the user s program as the rrwfafor, \nand the memory management system as the collector.) The specifications can be viewed as a promise to \nthe user: if all of the user s actions are legitimate then the garbage collector will remain invisible. \nThe precise meaning of legitimate and invisible is the meat of the specifications. Typically, the interface \nbetween two parts of a system consiata of the services that one provides to the other, and the specifications \ndescribe the services and how they are invoked. Although the collector does provide some services (new \nand free), its most important characteristic is the .. . invtslbhty of garbage collection. Mloreover, \nthe interface between the mutator and the collector potentially includes all of memory. A major purpose \nof the specifications is to define the boundary between the mutator and the collector by identifying \nwhich memory changes each may legitimately make. This is accomplished as follows. The specifications \ndefine a partitioning of memory (based on stored values) into locations that belong to the mutator and \nlocations that belong to the collector. Collector operations are prohibited from modifying any values \nstored in the mutator s part of memory, and vice versa. Moreover, mutator operations must not increase \nthe set of locations that belong to the mutator; such an increase can only occur as the result of an \naction of the memory-management system (perhaps invok~d by the mutator). 2.2. Language Designers A second \ngoal of the specification effort was to give the designers an objective and precise way of assessing \nthe safety of the design. Although finding unsafe features is easy --a number are discussed below -. \nmaking sure that ail have been found is a more difficult problem. In addition, the designers had to evaluate \nproposed changes. In some cases a safe version of an unsafe feature might be found; if not, its use might \nbe restricted to unchecked modules. In extreme cases it might be necessary to remove a feature completely, \nif even its inclusion in the unsafe language would undermine the type system. it was hcrped that the \nspecifications woufd provide criteria for making these decisions. Unsafe features in Mesa include procedure \nvalues and the address of operator (both of which can lead to dangling references), variant records, \ninput/output (which brings in potentially untyped data), loophole, machine-coded procedures, pointer \narithmetic, and the explicit free operation. How Cedar Mesa deals with these features is discussed in \nSection 5. However the treatment of the free operation has an important impact on the specifications, \nand is discussed brief Iy here. One might think that with garbage collection there is no need to retain \nfree, but there were compelling reasons for including uncollected storage in the language. Garbage collection \nadds a significant overhead to all assignments that modify the values of stored pointers. If the storage \nis frequently used and then discarded, garbage collection provides a valuable service in reclaiming storage \nautomatically. However, there are cases where the overhead of collection is not offset by any gain. This \nis the case when referenced objects are never available to be collected (as when a data structure is \nbuilt once and then used throughout program execution) or when the programmer can easily determine when \nstorage can be reclaimed. To improve performance in these cases, Cedar Mesa distinguishes between counted \nand uncounted references. Counted references can be reclaimed by the garbage collector, and uncounted \nreferences can not. In the safe language, storage for uncounted references is never reclaimed, and would \nbe used for static data structures. The unsafe language retains the free operation for releasing memory \nallocated to an uncounted reference. 78 2.3. Programmers The specifications were also intended to provide \na guide for programmers, particularly those who write unchecked modules; they do this by defining restrictions \non mutator actions. Within the safe language, these restrictions are enforced by the compiler or runtime \nchecks. In unchecked modules, it is the programmer s responsibility to see that they are obeyed. Unchecked \nmodules may make changes in memory which would not occur during execution of safe modules; as long as \nthese changes do not vfolate the interface specifications, the garbage collector will work correctly, \nand the type system will remain intact. 2.4. Implementors The final goal was to help the implementors \nof the compiler and the garbage collector to determine that the implementation does not lead to breaches \nof the type system. Of course, the basic requirement is that the language implementation correctly capture \nthe semantics of the language. Tkw specifications of the interface between the garbage collector and \nother parts of the system are a partial solution to the problem of how to meet that requirement. This \nis especially important because of concurrency. Not only are user processes executing in parallel, but \ngarbage collection may take place in parallel with user program activity. The specifications should give \nsome guidance in dealing with concurrency for example, they might help in the identification of actions \nthat must be performed indivisibly. 3. Related work There has been fittle experience with characterizing \nthe safety of a language as complex as Mesa. A number of languages with similar power simply accept the \nvulnerability of the type system. PL/1, Algol 68, and ADA are all in this category. PL/ 1 and Algol 68 \ninclude constructs that can lead to dangling references (although this is considered a programmer error). \nADA avoids this problem, but it includes the option of machine-language modules without describing the \nconstraints required to prevent them from violating the rest of the program s type-safety. None of these \nlanguages include garbage collection in the language definition, although some have implementations that \nprovide it. Simula and Clu have garbage collection and are type-safe. However, they are considerably \nsimpler than Mesa in some respects; for example, they do not support concurrency. Relevant work on specifying \nthe storage propetiies of higher-level languages has been carrried out by Bekic and Walk [4, 5]. Their \nspecifications are similar to ours in general style, although they did not consider garbage collection \nor the effects of erroneous programs. In essence, their work assumed the existence of a well-definined \ntype system for memory, while we were concerned with building one. Finally, there have been several discussions \nof garbage collectors that operate in parallel with user programs [6, 7, 8]. These papers presented \ncollectors that find free memory by tracing the user s data structures. The primary problem is making \nit possible for the collector to traverse a structure that is simultaneously being modified by the program. \nThis problem did not arise in Cedar Mesa, because we were abfe to assume that the collector used reference-counts \nthat were updated as an atomic part .of assignments to memory. On the other hand, the works listed above \ndealt with data with a uniform structure, so type consistency --our principfe concern --was a problem \nthey did not have to address. 4. The specifications The boundary between the mutator and the collector \nis specified in two ways. First, there is an invariant assertion that must be preserved by each atomic \naction in either the mutator or collector. (Atomic actions are the finest grain of process interleaving). \nThe invariant states that all memory used by the mutator is consistently typed with regard to references. \nThe invariant must be defined at the level of atomic actions in order to guarantee that whenever process \ntransfers occur, even during expression evaluation or block entry, memory is in a consistent state. Second, \nthe atomic actions of the collector and the mutator are partially characterized by pre-conditions and \npost-conditions. The atomic action specifications express requirements that certain parts of memory must \nnot be changed by the the collector, and others must not be changed by the mutator. The specifications \nare partial in the sense that they do not completely define the actions. For example, the specification \nof new does not state what value is returned, but does imply that the value is a reference to a portion \nof memory that was free before the call. In this section the specifications will be presented at a rather \ninformal level. The formal version is given in Appendix 1.We first list the types and functions used \nin the specifications, without giving their complete definitions. We then state the invariant and the \natomic action descriptions. . Types A memory is an array of words, indexed by address. A reference is \nessentially a typed pointer. Cedar Mesa allows both counted and uncounted references: the latter are \nnot managed by the collector. A subreference contains a reference and a selecfor; itrefers to a component \nof a data object, such as an element in an array or a field in a record. Functions Ioc(r: reference; \nm:memory) returns (set of address) The set of words used to store the object to which r refers. If r \n= nil, /oc(r,m) = 0. accessible(c counted reference, m: memory) returns (Boolean) A reference is accessible \nif it can be reached by following a chain of storedl references from a distinguished starting reference. \nWe will say that a subrefererrce is accessible if it refers to part of an accessible reference. Program \nvariables can be accessed by means of subreferenlces. allocated(rrn uncounted reference; nit: memory) \nAn uncounted reference is allocated if it has received storage locations from new that have not yet been \nreleased by free. Vve will say that a subreference is allocated if itreferstopart of an allocated reference. \nvalid(v: any; rn:memory) retumrs (Boolean) A value is valid in a memory state if all the counted references \nit contains are accessible in that state. Expression evaluation in the safe part of Cedar Mesa results \nin valid values (this is discussed in Section 5.2). This property of expressions is an important part \nof the way that memory is kept type-consistent. (Note that a valid value may contain uncounted references \nthat are not allocated. This stems from thle fact that the collector ignores uncounted references, so \nit is not essential for type safety that they be kept in a consistent state.) inuse(m: memory) returns \n(set of adldress) An address is in use if it belongs to the storage of an accessible reference. Note \nthat the only locations that canlegally be accessed bythemutator arethosethatsre in use, i.e. those that \nbelong to accessible Or allocated references. This will be reflected inthepre-condiiionsof the atomic \nactions below. compafib/e(t7, t2: type) returns (Bocllean) Type compatibility is determined by the language \ndefinition. If two types are compatible, they require the same amount of storage and agree on the placement \nof counted references within that storage. Equal types are trivially compatible, as are types that have \nthe same size and do not contain any counted rt?ferences. Invariant The following clauses must hold for \nall references rl, r2 and any memory state m that can be reached during program execution. 1. Suppose \nid is an identifier in the, active progrdm scope (the active scope of the program can be determined \nfrom the memory state m), and let @id be a subreference to id. Then accessibfe(@id, m). 2. If accessib/e(rl,m) \nA accessibfe(r2,m) then /oc(fj, m) = /oc(r2,rn) and their types are compatible, or Ioc(rl,m) n loc(r2,m) \n= 0. 3. If rl is accessible and r2 is allocated, then /oc(rl ,m) n /oc(r2,m) = 0.   The first clause \nimplies that an identifier can be reached via an accessible su bref erence whenever execution is in a \nscope where the identifier is defined. The second clause guarantees that accessible references give consistent \ninterpretations of the locations in memory where counted references are stored. That is, accessible references \neither refer to disjoint parts of memory, or refer to exactly the same locations and interpret any stored \ncounted references in the same way. The third clause implies that the storage locations assigned to accessible \nand allocated references are disjoint. This is important, because otherwise the space used by an allocated \nreference might be unexpectedly claimed by the collector. Atomic actions We must specify three kinds \nof atomic actions: those within the mutator, those implemented by the collector and invoked by the mutator, \nand those within the collector. The actions are described as functions which compute a new memory state. \nThe notation used is m2 = f( . . ,m 7), where m 7 is the old memory state and m2 is the new one. Each \naction is specified by a pre-condition, which describes acceptable values of the arguments to f, and \na post\u00adcondition describing the relationship between the new memory state and the arguments of f. It \nis the responsibility of the invoker of an operation to ensure that its pre\u00adconditions are satisfied, \nwhile the post-conditions are the responsibility of the implementor of the operation. Below we give the \nspecifications for mutator assignments, arbitrary collector actions, and the interface operations new \nand free. (Any operation that changes memory can be viewed as an assignment, so this includes all operations \nin the mutator and collector). 1. Mutator assignment: m2 = assign(sr: subreference; tv: any; ml: memory) \n P re-condit ion: sr is an accessible subreference in ml, the types of sr and w agree, and tv is valid \nin m 7. Post-condition: Assign changes the value associated with sr in m2 to W; it makes no other changes \nto memory locations that are in use in m 1. Moreover, assign does not change the set of locations allocated \nto sr, or change the allocation status of any uncounted reference. 2. Collector operations: rn2 = op(rnl) \nPre-condition: true Post-condition: All memory locations that are in use in m 1 are in use in m2, and \nthey have the same values in both memory states. The allocation status of uncounted references is unchanged. \n3. Interface operation new: m2 = new(sr,m 7) Pre-condition: sr is accessible or allocated, and it refers \nto an object of type reference (either counted or uncounted). Post-condition; New returns a reference \nwhose storage is disjoint from the storage of any previously accessible reference, and initializes that \nstorage to a valid value (to a default with nil references or to a value provided by the call). Note \nthat the parameter sr is a subreference to the object where the returned value (a reference to the newly \nallocated object) is to be stored. New does not make any other changes to that part of memory accessible \nto the program. If sr points to an uncounted reference, then the reference returned is allocated. (If \nsr points to a counted reference, then the reference returned is accessible. However this is an immediate \nconsequence of the definition of accessibility, and does not need to be included in the post-condition \nof new.) The allocation status and the storage of all other references is unchanged by new. 4. Interface \noperation free: m2 = free(sr: subreference, ml:memory) Let ur be the value to which sr points. Pre-condition: \nIn rnf, sr is accessible or allocated, and ur is an allocated reference. Post-condition: In m2, sr points \nto a reference with value nil, and all other locations have the same value as in ml. ur is not allocated \nin m2, but the allocation status of all othefi references remains the same as in m f. 5. Assessment \nof the specifications   5.1. Safety The first requirement of the specifications was that they capture \nthe invisibility of the collector. We believe the specifications are successful in this respect, although \nthe judgement is inherently a subjective one. They allow safe-Ianguage programmers to assume that they \nare working. with a large memory in which allocated space is never reclaimed. First, programmers can \nassume that every call to new returns a reference to a previously unused portion of memory. The specifications \nof new imply that the reference returned is one to an area of memory that was not in use at the time \nof the call; in the safe language, this is equivalent to one which was never in use. Second, programmers \ncan assume that the garbage collector does not change the values of variables in any way that they can \ndetect. This is implied by the axioms for collector operations, which state that the collector does not \nchange any memory that can be used by the program. 5.2. Language designers The most important contribution \nof the formal specification effort came during the process of developing the specifications. Discussions \nwith the language design committee led to the discovery of a number of poorly\u00ad understood features in \nthe language, and a subsequent clarification of their meaning. By the time the specifications were completed, \nthe designers felt that they had a good understanding of the problem, and the language was structured \nin a way that made safety an intuitively manageable property. The concepts of valid values and accessible \nor allocated references were intuitive enough to be used informally. Ideally, the formal version of the \nspecifications would have been used as the basis for a rigorous check of the safety of Cedar Mesa. This \nwould have required a formal definition of the semantics for the language, and rmme exists. However, \nit was possible to check the language in an informal but sytematic way, as described below. This increases \nour confidence in the completeness of the specifications as well as in the safety of the language. In \nan informal evaluation of language safety, we need to argue that the safe language satisfies the specifications. \nTo be consistent with the invariant, the initial program state must satisfy the invariant, and each program \noperation must preserve the invariant. To be consistent with the specifications of atomic actions, the \nlanguage must guarantee that the pre-conditions of each assignment and new operation are satisfied. Below \nwe outline an argument that the safe language meets the specifications. Conjecture 1: The safe language \npreserves clause 1 of the invariant, i.e. identifiers that are defined in the active program scope can \nbe reached via accessible subref erences. Discussion: This is the intended semantics of scope entry and \nexit. identifiers become defined when a new block or procedure is entered. At this time a frame is allocated \nto hold the variables of the block or procedure. All variablr% in the frame are initialized to valid \nvalues (i.e. any counted references are either ni I or are already accessible). Finally, the frame is \nconnected to some accessible frame; at this point it becomes accessible, and the identifiers of the block \nor procedure become accessible subreferences. At block or procedure exit, the reference that made the \nframe accessible is reset to ni 1. In most cases, the frame is then inaccessible, and can be reclaimed \nby the collector. However, it may still be accessible because of other stored references, as would be \nthe case if a reference to the procedure had been stored in a program variable. Thus dangling reference \nproblems with procedure values do not occur, since the frame can not be reclaimed as long as there are \naccessible references to it. Conjecture 2: Operations of the safe language preserve the second clause \nof the invariant, that is, accessible references are either disjoint or type compatible. Discussion: \nThe safe language operations that must be considered are mutator assignment and new (free is not part \nof the safe language). In conjecture 4, we will argue that the pre-conditions of these operations are \nsatisfied in the Safe language. The following theorem then implies that the second clause of the invariant \nis preserved. 81 Theorem 1: A mutatcrr assignment or new operation e Dereferencing whose pre-conditions \nare satisfied preserves the second clause of the invariant. o An exception is raised if there is an attempt \nto dereference a null reference. Discussion: Appendix II contains a rigorous proof of this theorem, \nbased on the formal specifications in Appendix 1.Informally, the post-conditions for mutator assignment \nguarantee that the only accessible parts of memory changed by the assignment belong to, the sub-reference \ncorresponding to the left-hand sidle of the assignment. Moreover, the value stored there is valid in \nml, so no new references become accessible in m2, Since all the accessible references in m 1 satisfied \nthe invariant, and since assign does not change the type cm storage locations of references, the accessible \nreferences in m2 satisfy the invariant. The argument for new is similar, except that one new reference \nbecomes accessible. But the new reference does not overlap storage with any accessible reference in m \n7, and thus it does not overlap with any accessible reference in m2. Conjecture 3: The safe language \npreserves the third clause of the invariant, that is, the storage locations of counted and uncounted \nreferences dc) not overlap. Discussion: Assignment does not change the storage locations of references, \nnor make arvy additional references accessible or allocated. So we need only consider the effects of \nnew. The post-condition of new implies that only one new reference becomes accessible or allocated, and \nits storage locations were not previously in use. Conjecture 4: In the safe language, the pre-conditions \nof all assignment and new operations are met. Discussion: This follows from the safety of the Cedar Mesa \nexpression structure. Expressions can appear in two contexts in Mesa programs --in a left-hand-side corrtext, \nwhere they are evaluated to yield su preferences, and in a right-hand-side context, where they may yield \nany type of value. Expression evaluation either completes successfully or raises an exception. In Cedar \nMesa, if evaluation completes successf u Iy, the resulting value is an accessible or allocated reference \n(for a left-hand-side context) or a valid vakre (for a right-hand-side context). The argument for the \nsafety of Mesa expressions is based on recursion on the structure of expressions. The base step comes \nfrom the first clausa of the invariant any identifiers in the expression must be stored in locations \nof accessible or allocated references. For the induction step, one must show that each expression constructor \nin the language yields an accessible reference [a valid value] when applied to accessible references \n[valid values], unless evaluation of the expression causes an exception to be raised. Much of the work \nin developing the safe language was concerned with ensuring this property. Below we consider how it has \naffected certain features of the language. o Dereferencing a non-null accessible reference automatically \nyield a valid value, from the definition of accessibility. o Dereferencing a non-null allocated reference \nalways yields a valid value, because the language definition states that uncounted references cannot \nrefer to objects that contain counted references, and any value with no counted references is valid. \n o Dereferencing a subreference may not be safe in certain memory states --for example, the subscript \nchecks for an array reference might be out of  bounds. Runtime checks will raise an exception in this \ncase. Loopholes were banished from the safe language, since they could easily result in an invalid value. \nA safe form of loophole, called PUN was introduced; it can be used to transfer between compatible types. \n. Variant records potentially introduce the same sort of problems as loopholes. In the safe language, \nvariant records either contain no counted references, or have their variant set immutably when they are \ninitialized. o Variant records and loopholes remaine -in the unsafe language, but only in a restricted \nform. For example, it is never legal to use loophole to assign into a variable that contains counted \nreferences, unless the value being assigned also contains counted references at the same locations. e \nAllocation using new, whether invoked by the runtime system at block entry or explicitly by the programmer, \nalways returns a reference to an object that has been initialized with a valid value. Untyped input/output, \npointer arithmetic, tree, and machine code were banished to the unsafe portion of the language. 5.3. \nProgrammers The programmer who writes unchecked modules must be prepared to verify that the modules meet \nthe specifications. Statements from the safe subset of the language necessarily satisfy the requirements,. \nso the programmer only needs to check unsafe operations -\u00adtypically machine code, or assignments that \nuse pointer arithmetic or loopholes. For these operations, the programmer must show that the pre-condition \nof each invoked operation is satisfied, and that the operation preserves the invariant. To preserve the \nfirst clause of the invariant, it is enough to refrain from changing the values of references that connect \nframes. The second clause is automatically preserved if the pre-conditions of mutator assignment, new, \nand free are met (Theorem 1 implies this 82 for new and mutator assignment, and it can easily be extended \nto include free as well.) So the programmer s responsibility amounts to showing that the specifications \nof the atomic actions are met. 1. For each assignment rr72 = assign(r,fv,rn.?), r is accessible or allocated \nin m 1, tvis valid in m, and r and tv have compatible types. The compatibility of r and tv is established \nby referring to the language definition. To show that r is acce. ~ible, the programmer must show that \nit could be derived as the value of a safe left-hand\u00adside expression. To show that r is allocated, it \nis necessary to show that it became allocated as a result of a call to new, and has not been released \nby a call to free. One easy way to guarantee this is to ensure that free is always called with the only \nremaining copy of an allocated reference. Then when free assigns nil to the location that held the reference, \nit will be destroying the last stored copy of the reference as it makes the reference not allocated. \nIf this discipline is always followed, any stored uncounted reference will be allocated. 2. For each \nnew operation, m2 = new(sr,m 1) show that sr and cferef(sr,rn 7) are accessible or allocated in m 1. \nThis is can be established in the same way as for assignment statements. 3. For each free operation, \nm2 = free(sr,m 1) show that sr is accessible or allocated, and deref(sr,rnl) is allocated. (Note: it \nis a good idea to make sure that deref(sr,rn 1) is the only reference in ml to the object to be released. \nIf  this rule is followed, all stored uncounted references will be al located.) 5.4. Language implementors \nThe task here is to insure that no safety breaches are introduced by the implementation, which includes \nthe compiler, the memory manager, and other parts of the ru ntime system. The specification effort identified \na number of areas in which caution was required, although the final specifications were at too abstract \na level to allow for a thorough check of safety. The greatest danger comes from the presence of concurrent \nprocesses. For example, the semanbcs of the language require a runtime check that a dereferenced pointer \nhas a non-null value. The implementor must make sure that between the time when the reference is checked \nand the time when it is dereferenced, no other process can change its value. To guarantee this, the value \nmust be copied before it is checked, and the local copy should be used for the dereferencing operation. \n6. Conclusions The design of Cedar Mesa is complete, and implementation is under way. Developing formal \nspecifications of the garbage collector interface was a significant aid in the language design process. \nAs is often the case, much of the benefit was realized during the process of creating the specifications. \nThe language design and the specifications evolved together. Often the discussion of a problem with the \nspecifications uncovered difficulties and points of confusion in the language itself. In several cases, \na restriction that simplified the specifications also simplified the language, and was incorporated into \nthe design. The result was that both the final specifications and the language were considerably simpler \nthan we had expected them to be. Once the specifications were available, their definition of safety was \nintuitive enough to be used informally in analyzing potential language features. ACKNOWLEDGMENTS. These \nspecifications emerged as a result of a number of discussions with the Cedar Language Design Committee \n(Danny Efobrow, Peter Deutsch, Jim Horning, Jim Morris, Bill McKeeman, Paul Rovner, and Ed Satterthwaite), \nand would have been impossible without their contributions. Jim Horning was a particularly valuable source \nof advice and language interpretations. Danny Bobrow worked on early versions of the specifications, \nand provided important insights into the workings of the collector. 7. References [1] J. G. Mitchell \net al., Mesa Language Manual, Report CSL\u00ad79-3, Xerox Palo Alto Research Center, April, 1979. [2] C. M. \nGeschke et al., Early experience with Mesa, CACM 20:8 (Aug. 1977) pp. 540-553. [3] I_. P. Deutsch and \nD. G. Bobrow, An efficient, incremental automatic garbage collector, CACM 19:9 (Sept. 1976), PP 522-526. \n[4] H. Bekic and K. Walk, On formalization of storage properties, in E. Engeler, editor, Semantics of \nAlgorithmic Languages, Springer Verlag Lecture Notes in Mathematics, VOI 188, 1971. [5] K. Walk, Modelling \nof storage properties of higher-level languages, International Journal of Computer and Information Sciences, \n2:1 (March 1973) pp 1-24. [6] G. Steele, Jr. Multiprocessing compactifying garbage collection, CACM 18:9 \n(Sept. 1975), pp 495-509. [7] E. W. Dijkstra et al., On the fly garbage collection: an exercise in cooperation, \nCACM 21:11 (Nov. 1978), PP 966-971. [8] D. Gries, An exercise in proving parallel programs correct, \nCACM 20:12 (Dec. 1977), pp. 921-930. 1. Formal Specifications True if sr is a legitimate subreference \nin memory m. This appendix presents the formal version of the specifications discussed in Section 4. \nIn some cases, English comments are provided for motivation, but they are not part of the formal specifications. \nTypes The types memory, address, reference, typeDescriptor, value and selector are primitive types. \nWe do not care about the kinds of values they can take on, except that they satisfy the axioms of the \nfunctions given in the next section. The types sub deference and typedValue are composed from the primitive \ntypes. A memory is an array of words, indexed by address. A fypeDescriptor is a representation of the \nmemory layout for objects of a given type. It need ony indicate where references and memory allocation \ninformation are stored. A value is a seq i ?nce of words. A fypedVakfe is a pair (t:typeDescriptor, w \nvalue) . Most of the functions below work with typed values. A reference is a essentially a typed pointer. \nIts type can be determined using the function type and the value it refers to can be obtained using the \nfunction deref defined below. A selector is a syntactic object for selecting a component of a compound \ntype. Examples include array subscripts, and record field selectors. A subrefererme is a pair <c reference, \ns: selector> . The generate reference operator @id returns a subreference to id. Primitive Functions \ntype(r: reference) returns (typr?Descriptor) type(sr: subreference) returns (typeDescriptor) This is \nthe type of the object to which the reference or subreference refers. Ioc(r: reference; m:memory) returns \n(set of address) The set of words allocated to the object to which r refers. deref(r: reference, m: memory) \nreturns (typedValue) deref(sr: subreference, m: memory) returns (typedValue) The value stored in m for \nr or sr. refersto (tv: typed Vafue, r: counted reference) returns (Boolean) True if tv has a component \nwhose value is r. This is the only interpretation of. values we need. compatible t 7: typeDescriptor, \nt2: typeDescriptor ) returns (Boolean) Two types are compatible if they require the same amount of storage \nand interpret counted reference components in the same way. See axioms PF3-PF5 below for the implications \nof type compatibility. legalSR( sr: subreference, m: memory ) retu rns (Boolean) allocated(ur: uncounted \nreference, m:memory) returns (Boolean) A//ocated(ur) is true from the time when new(ur) returns until \nfree(ur) is called. The value of this function is likely to depend on parts of memory that are neither \nallocated nor accessible, that is to runtime information maintained by the language support system. Axioms \nIn the remainder of this section, variables have the types indicated below a, al, a2 address m, m 1, \nm2 memory r, rl, r2 reference cr counted reference ur urrcounted reference t, tl, t2 typedescriptor tv, \ntv7, tv2 typed value s selector sr subreference PFI: if Va E foc(r,mf) (ml[a] = m2[a]) then Ioc(r,m \n7) = loc(r,m2) The storage used for a reference r in memory state m depends only on the value of words \nwith addresses in loc(r,m). PF2: if Va E Ioc(r,m 1) (ml[a] = m2[a]) then deref(r,m 1) = deref(r,m2) The \nvalue obtained by dereferencing a reference depends only on the storage belonging to that reference. \nPF3: if compatible (fype(rf), type(r2)) A Ioc(rf,m) = /oc(r2,m) thenrefersto(deref (rl ,m), r3) a refersto(deref(r2, \nm), r3) If two types are compatible, they cause counted references in the values to be interpreted in \nthe same way. PF4: if Ioc(rf ,m 1) = loc(rl,m2) = loc(r2,m2) A compatibfe(rl.t, r2.t) then loc(r2,m7) \n= foc(r2,m2) If two types are compatible, they interpret memory in the same way as far as storage location \nassignment is concerned. PF5: if valid(tvl,m) A va/id(tv2,m) A cornpafible((tvf .s).t, tv2) then vafid(tvl \n[s/tv2]), where tv 1[s/tv2] denotes the value obtained when the s component of tvl is replaced by tv2. \n Substitution of a valid component value in a valid value results in a valid value as long as the types \nare compatible.  Derived Functions chained(rl ,r2: reference; m: memory) returns (Boolean) chained(rl \n,r2,m) = refersto( deref(rf, m) , r2 ) Reference rl is chained to r2 if r2 is a component of the value \nobtained by dereferencing r 1. accessible(cr: counted reference, m: memory) returns (Boolean) accessifie(cr, \nm) = chained (base, cr, m), where ctrained * is the transitive closure of chained. Base k a constant; \nit is the starting point of the chain of frames containing local variables of procedures and blocks. \nA reference is accessible if it can be reached by following a chain of stored counted references from \na distinguished starting reference. valid(tv: typedvalue; m:memory) ret u rns (boolean) valid(tv,m) \n= Vr( refersto(tv,r) + accessible(r,m) ) A value is valid in a memory state if all the references it \ncontains are accessible in that state. inuse(m: memory) returns (set of address) inuse(m) s {a: Elr ( \n( (accessible(r,m) V allocated(r, m) ) A a C /oc(r,m) ) }  Invariant The following clauses must hold \nfor all references rl, r2 and any reachable memory state m. 1. Suppose id is an identifier in the active \nscope, and let @id = sr. Then legalSR(sr, m) and accessible(sr.r,m). 2. If accessible(rl ,m) A accessible(r2,m) \n then Ioc(rf,m) fl Ioc(rl, m) = @ V (compatible(rl. t,r2.t) A Ioc(rl,m) = loc(r2,m)).  3. (allocated(rl,m) \nA accessible(r2,m) ) =+ (Ioc(rl,m) n loc(r2,m) = 0).  Atomic actions 1. Mutator assignment m2 = assign(sc \nsr.rbreference; tv: typed Value; m 1: memory) Pre-condition: ( accessible(sr.r,m 1) V aliocated(sr.r,ml) \n) A /egaEf?(sr, rm) A valid(tv,mf) A compatible(type(sr), tv.t) Post-condition: MA1: cieref(sr.r,m2) \n= deref(sr.r,mf)[s/fv] MA2: a C (inuse(mf) --Ioc(sr.r,ml) ) = m7[a] . m2[a] MA3: Ioc(sr.r,m 1) = loc(sr.r,m2) \n MA4: allocated(ur, m2) e (allocafed(ur,m 7) V (ur = deref(sr, ml)) 2. Collector operations: m2 = op(ml), \nPre-condition: true Post-condition:  Cl: (a E inuse(ml) ) =9 (mf[a] = m2[a])  3. Interface operation \nnew: m2 = new(sr, m l)]. Let rl = deref(sr.r,m 1) and r2 = deref(sr.r,m2).  Pre-condition: ( accessible(sr.r,ml) \nV allocafed(sr.r,m l)) A legalSR(sr, m 1) A type(r) = reference Post-condition: NI: valid(deref(r2, \nm2),mf) N2: a E (inuse(m) -foc(r,m7)) e ml [a] = m2[a] N3: Ioc(sr.r,m 1) = loc(sr.r,m2) N4: loc(r2,m2) \nrl inuse(ml) = 0 N5: allocated(ur, m2) e (allocated(ur,mf) V (ur = deref(sr,r).sr.s) ) 4. Interface \noperation free: m2 = free(ur: uncounted reference, m 1: memory)] Pre-condition: (accessible(sr.r,ml) \nV allocated(sr.r,m l)) A legalSR(sr, ml) A type(r) = reference A allocated(deref(sr)) Post-condition: \nF1: deref(r2,m2) = nil F2: a 6 (inuse(m) -Ioc, (rml) ) = m I[a] = m2[a] F3: Ioc(sr.r,ml) = loc(sr.r,m2) \nF4: allocated(ur,&#38;2)s (allocated(ur,mf) V ur = deref(sr,mf)) Il. Proof of Theorem 1 Theorem: Mutator \nassignment and new operations, when performed in a memory state where their pre\u00adconditions and the invariant \nare satisfied, preserve the second clause of the invariant. Proof: We first consider the case of assignment \nstatenwnts, and prove lemmas showing that assignment statements satisfying the specifications cannot \nmake new references accessible, and cannot change the storage assigned to any accessible references. \nThe references in parentheses are to clauses of the formal specifications in Appendix L Lemma 1: Suppose \nthat m2 = sssign(sr, tv, m 7) satisfies the specifications of mutator assignment, m 7 satisfies the invariant, \nand rr is accessible in both m 1 and m2. Then Ioc(rr, m 1) = loc(rr,m2). Proof: There are two cases to \nconsider: either references rr and sr.r have overlapping storage locations in m f or they do not. If \nthey do not overlap in m 7, then the storage assigned to rr is the sane in m 1 and m2; by MA2 and PF1, \nIf they do overlap in m 1, then they must have the same storage locations and compatible types, since \nm 7 satisfies the invariant. Now Ioc(sr.r,ml) = loc(sr.r,m2) by MA3. Then by PF4, Ioc(rr,m 1) = loc(rr,,,12). \nI Lemma 2 Suppose that m2 = assign(sr, tv, m 7) satisfies the specifications of mutator assignment, m \n1 satisfies the invariant, and rr is accessible in m2. Then rr is accessible in ml. Proof: Suppose rr \nis accessible in m2. Then there is a sequence of references head =ro, rl, . ..rn=rr such that chahred(ri, \nri +,, m2). We will show by induction that each reference in this sequence is accessible in m 7 as well. \nClearly head is accessible in m 7. Next we assume ri is accessible in m 7, and show that ri+, is too. \nFirst, if ri refers to the same value in m 1 and m2, clearly ri+ ~ is accessible in m 1. If rj does not \nrefer to the same value in both memory states, its storage must have different values in m 7 and m2 (PF2), \nand thus its storage must overlap that of sr.r (MA2). But in that case, sr.r and rj must have the same \nstorage in m 1 and have compatible types, since m 7 satisfies the invariant. By lemma 1, they must also \nhave the same storage in m2. Thus, since PF3 implies chah?ecf(ri, ri+,, m2), we have cfrained(sr.r, ri \n+,, m2). But we know that deref(sr.r, m2) = deref(sr.r,m l)[s/fv]. By the pre-condition of assign and \nPF5, this value is valid in m 1. But then ri+, must be accessible in ml, from the definition of valid. \nB Using these two lemmas we can show that mutator assignments preserve the second clause of the invariant. \n Let rl and r2 be accessible references in m2. By lemma 2, they are accessible in m f as well. Since \nm 7 satisfies the invariant, either rl and r2 have disjoint memory in m 1 or they share identical memory \nand are compatible in type. But lemma 2 implies that each reference is assigned the same memory in m \n7 and m2. Thus they must be either disjoint or compatible in m2, and the second clause of the invariant \nis satisfied. This completes our consideration of mutator assignment. Collector operations trivially \npreserve the invariant, since they do not change the values of any words that are in use in ml (Cl), \nand thus cannot change the accessibility or storage of any references. Finally, the proof for the new \noperation is almost identical to the proof for mutator assignment, using the first three post-conditions \nof new in much the same way as the three post-conditions for mutator assignment. I   \n\t\t\t", "proc_id": "567532", "abstract": "This paper describes the formal specifications of garbage collection in the programming language Cedar Mesa. They were developed as part of the process of identifying a <i>safe</i> subset of Mesa for which garbage collection was possible. The purpose of the specifications was to provide a precise definition of safety, along with criteria for checking the safety of proposed language features. Thus the specifications had to characterize the \"invisibility\" of the collector, as well as describe the services it provides. A beneficial effect of the specification effort was that the process of constructing the specifications led to a number of discoveries that improved the quality of the language.", "authors": [{"name": "Susan Owicki", "author_profile_id": "81100374618", "affiliation": "Stanford University", "person_id": "PP39039997", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567539", "year": "1981", "article_id": "567539", "conference": "POPL", "title": "Making the world safe for garbage collection", "url": "http://dl.acm.org/citation.cfm?id=567539"}