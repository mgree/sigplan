{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 . A concise notation for describing the methodologies porated by the semantic \nfunctions. Hence, the must be developed. This description must drive the model is powerful enough and \narises naturally pds so that the development and analysis of the just as grammars are very natural for \nmodeling program are tuned to the methodology. the translation process. . A library of methodologies, \neach designed to provide aid within a precisely defined problem domain must be created. These methodologies \nmust be organized to begin guiding program development in very general problem domains and, if necessary, \nprogress to very specific problem domains. Not much is known about programing in various problem domains \nthough our intuition and collective knowledge points to the existence of patterns of programming in several \nwell defined problem domains. Problem domains of interest fall into a variety of &#38;2?.%@ categories \nsuch as data oriented program\u00adming, distributed programming, real time program\u00adming, simulations, etc. \n. Suitable design notations and techniques for analyzing program design must be incorporated by the pals. \no The design of the pds/pe components is impor tant since the programmer must be permitted flexible \nuse of these components by means of a command language, 2. ~RIAD DESCRIPTION We are currently involved \nin the design and implementation of a pds called TRIAD. TRIAD consists of a set of tools which are the \nprogram developer, the analyzer, a data base of system maintained program components and a data base \nfor the development histories of programs. Using a command language, the programmer can interact with \nthe interface in order to use the tools (see Figure 1). The design of the tools and the inter\u00adface will \nfacilitate flexible use of the tools and thus provide the programmer with a friendly programming environment. \nIn TRIAD we use attributed grammar forms [BAB179, GINS77, KENE79, W791, to model pro\u00adgram development \naccording to a-particular methodology. In other words, attributed grannnar forms will encode methodologies \ntailored to re\u00ad create patterns of programming in well-defined problem domains. The TRIAD analyzer is \nfacili\u00ad tated by the use of a precise description of program development based on a methodology. TRIAD \nalso maintains a history of a program from its abstract, functional form to its concrete, implementation \nform. This history (or refine\u00adment tree) reflects a methodology description (denoted as attributed grammar \nform) of the programmer s choice. Each refinement tree, therefore, belongs to a family of trees reflec\u00ad \nting a methodology and the analysis routines of TRIAD exploit this knowledge to provide useful messages \nduring all stages of program develop\u00adment and program modification. The effectiveness of the TRIAD analyzer \nin providing useful feedback to the programmer during the development process, is entirely based on the \nfact that the program development itself can be systematically represented in a machine analyzable form \nusing attributed grammar forms. The attri\u00adbutes and rules for evaluating these attributes in the attributed \ngrammar forms permit the analyzer togenerate messages based on a global data flow analysis of the program \ns refinement tree. In the long run, program verification can be incor- The library of methodology descriptions \ncould, of course, be previously created by a project supervisor to effectively aid in the development \nof programs specific to an applica\u00adtion area. We are examining existing methodologies in order to create \na set of methodology descriptions for precisely defined problem domains. Our initial work is in characterizing \nproblem domains in the data processing area which is known to have fairly standard problem specifications. \nTo summarize, we use attributed metaforms as a unifying model for a pals, to facilitate the interactive \nanalysis of program development and the integration of various existing tools. We view such an integrated \npds facility, based on existing analysis techniques and tools, to be more effective than its individual \ncomponent parts for developing reliable software. Also, this pds does not preclude the integration of \nmore sophisticated tools as they are developed. The integrated pds facility is being constructed now \nfor production use during all phases of the soft\u00ad ware life cycle and expected to be available for use \nin the near future. Library of Data Base of Data Base of Methodology Program System Descriptions Refinement \nMaintained (M.D.) Trees Modules .  CylM \\ ~__ _T  , q~R p.e. interface m I Programmer s -1 Response \nw TRIAD -prompts, messages, refinement trees Figure 1: Overview of the TRIAD pds 3. FOCUS OF THE PAPER \nIn this paper, we first present grammar forms for modeling program development according to a methodology. \nWe then briefly illustrate how the pds uses this model. The paper focuses on the design of the &#38;rammar \n~orm methodology descriptions (gfmd) for guiding program ~evelopment In problem domains within the general \ncategory of data pro\u00adcessing. We present grammar forms that adequately model the majority of program \ndevelopment activities of a major data processing organization. In addition, we summarize our experimental \nresults based on an analysis of a variety of data processing programs. 29 4. GRAI@Wl FORMS Most existing \nmethodologies are based on the process of abstraction and/or refinement. These dual processes are viewed \nas (context-free) con ceptual tools for the programmer and are designed to limit the complexity of program \ndevelopment. Here we shall talk about the refinement process only, though our discussion carries over \nto the dual process of abstraction. The development of a program by the process of refinement (that \nis, of replacing a code sequence by other code sequences) gives rise to a tree, though the order of program \ndevelopment and hence the creation order of the tree may be arbitrary. In other words, separately developed \nsubtrees may be combined as a tree, thereby enabling both top down and bottom-up development as required \nby the methodology. Since the tree representation facilitates the maintenance of a variety of historical \ninfor\u00admation regarding program development, we use trees as the primary objects in our system. We call \nthe trees refinement trees. A program has many refinement trees. TRIAD can encourage the programmer to \ndevelop refinement trees with desirable properties by providing templates (by means of a context free \ngrammar) which the programmer can use to generate the trees. The symbOls of this grammar are prompts \nto which the programmer responds. The programmer s responses to prompts are termed interpretations of \nthe symbols . See Figure 2. Both the prompts and their interpretations may have certain semantic attributes. \nHowever, we shall ignore the semantic aspects of program development here. Grammar FmmDe finition ,[GINS77] \nA cmntext-free grammar+ G = (V,Z,P,S) is a four-tup-le where V is a finite vocabulary, Z is a finite \nterminal vocabularyandZ ~Y; and P is a finite set of production wules of the form X+ awhere Xis in V \nZ and a is i~ V.*,, Sis the start symbol and S is in V Z. Since G has a finite vocabulary it is, by itself, \nimadequa%e for modeling a program refkne ment tree whose node-s may be labeled b,y strings belonging \nto an infinite set --the design language. Hence, we augment the context free grammar as shown below. \nA grammar form is a master grammar that is a template or form for other grammars, that have a similar \nform . The interpretation grammars are obtained by allowing substitutions of terminal serings for terminals \nand nonterminals for nonterminals. See example in Figure 2. Although the substitution of strings of terminals \nfor terminals is arbitrary, only distinct non terminals may replace distinct nonterminals. This somewhat \nnonintuitive restriction becomes under\u00adstood only when we examine the shape of the derivation trees. \nThe restriction on nonterminal substitution ensures that the interpretation grammars have similar derivation \ntrees to that of the master grammar. t It is assumed that the reader is familiar with standard terminology \ndealing with the use of context free grammars for parsing programs [AH077]. More formally a (context-free) \ngrammar form G is a four-tuple (G,/~,V,S) where i) G = (V,Z,P,S) is a context-free grammar, ii) M is \nan infinite set of substitutions, and iii) V and S are infinite vocabularies with S : ~. For each u in \nM, a) u(a) is a finite set in S*, a in Z; b) M(X) is a finite set in V-S, X in V-Z; and c) if Xand Yare \nin V-Z where X#Y, then U(X) n P(Y) = 0. We will follow the convention that a grammar form will simply \nbe referred to by its underlying grammar G, while M, V and S are understood. An interp?ietation grammar \nG1 = [V1,Z1,P1,S1) of G is a grammar such that i) P(V) =VI ii) U(Z) = Z1 iii) p(V-E) = VI -Xl iv) PI \n~ {p(X) + p(a)+ ~X+ u in P} and v) S1 { p(s). It is important to notice that PI is only a finite subset \nof all possible substitutions into production rules. Also we do not need to use inter\u00adpretations of all \nthe production rules in P to obtain P 1. Example of a Grammar Form Description of a Method\u00ad !?@S.Y We \nchoose to illustrate (Figure 2) the use of grammar forms by partially describing JACKSON methodology. \nJACKSON techniques for resolving structure clashes can be described using attri\u00ad butes and semantic functions \nwhich we do not do here.  5. .EXPERIENCE IN U:SLNG GFMD Zn order to umde~stand the Gssues involved \nin creating well tailored ~grammar form .descniptions to the pals., we first restricted ourselves tu \nageneral problem cat%gory where the = of processing problams an% the ~atterns of their solutions arising \nin practice were well understood. One such processing experience is summarized next. An effort was initiated \nin 1976 by the Manage\u00adment Systems and Services Division of Westinghouse Electric Corporation located \nat Westinghouse s Tele Computer Center, in Pittsburgh, Pennsylvania [WEST79] to standardize the development \nof data processing programs. Based .on previous data processing experience, nine skeleton programs were \ncreated as listed in Figure 3. Each skeleton consisted of skeletal control with documentation indicating \nhow the skeleton was to-be completed by supplying more code. In two years, approximately 180 pro\u00adgrams \n(or 100% o f the division s new programs) were developed using these skeletons. It waa found that the \nuse of program skeletons with docu\u00admentation on how to supply details regarding a specific problem, in \nfact reduced program develop\u00adment costs in the long run. Of course, there was an initial cost overhead \ninvolved in teaching the programmers the use of the skeletons. 30 1. <input I structure> <pro ram> 1 \n<program body name> <output I sturcture> 4. <program <process b dy name> r description> 2a. <input <partition \nstructure> i ascription>* b. <output <partition s ructure> [ ascription>* 5. <initi 1 part> <process \n<process description> I description> <final art> 3a. <partition <partition ascription> ! ascription>* \nb. <partition partition ascription> [ ascription 6,a. <initial initial part> Ipart code b. <final final \npart> I part code 6.c. <process process de cription> i description code Figure 2a. A partial JACKSON \nGFMD. Note that for the sake of conciseness in presenting the grammar form productions, regular expression \nnotation (*) is used. Terminal symbols are underlined. These productions (or templates) generate valid \nJACKSON methodology structures and specify some of the techniques for generating the structures as shown \nin Figure 2b. proq wri : master f le update d input .9Awcture: prograrn ~ody me: output st$ueture: transaction \nand master new master file ?odu;:ce;s ,eec paxtikion desc.: partition dese. : initial part: .: final \n~art: par 1ition deser.: transaction master initialize process all finalize product* program products \nprogra I I I I partition desc.: partition desc. : initial part: process dese. : inal art: L product* \nproduct* HLL code HLL code HLL code 1-I [ I partition desc.: par+)tion dese.: pa~~ition dese.: partiti~n \ndese. : match no match i 1 ::&#38;--, , :Pj:; de6c partition desc.: par+z.tion desc.: . . transactions* \ntransactions* active inactive Figure 2b. The JACKSON GFMO productions are interpreted in JACKSON notation \nto create the above refinement tree which reflects the methodology pre\u00ad scribed in Figure 2a. The pds \nprompts are in italics and denote the grammar form terminals and non-terminals of Figure 2a. The inter\u00adpretations \nfor the non-terminals are in the JACKSON design language where 0 denotes alternatives, * denotes iteration. \nThe interpre\u00adtation of each terminal symbol is actual code in some ~igh level implementation language \n(HLL). NAME FUNCTION Extract Table -Selected input records are pro- File cessed and the results placed \ninto an incore table. Convert Data -Input records are converted File into records to be sorted. Sort \nTable File -Records from an incore table are used to form records to be sorted. Edit Transaction -Input \nrecords are subjected to File a number of validation tests which check for format errors. Update Master \nTransaction records are used File to update a master file. Edit Sort File Sorted input records are matched \nwith a master file for purposes of validating the input records. Create Detail Using the complete sort \nkey Report create a report dealing with the lowest level entity in a hierarchical relationship. Create \nSummary Create a report by stnmnarizing Report one or more lower levels of a hierarchical relationship \npresent in a sorted file. Create Detail Jointly produce a detail and and Summary summary report. Report \nFigure 3. Program Design Methodology Skeleton Programs Development of Program Input/Output Steps SELECT1 \ndata based on membership in an ordered relation SELECTL data based on membership in two different compatible! \nordered rela\u00adtions SELECT3 data based on membership in two different incompatible! ordered rela tions \n Figure 4a. Descriptions of the gfmd primitives New gfmd name gfmd SELECT and FABRICATE CONTROL BREAK \nVALIDATE UPDATE Figure 4.b. Combinations of gfmd primitives 32 Our work on isolating fundamental program \ndevelopment patterns was initially based on the Westinghouse experience summarized above. Our progress, \nbased on an analysis of a variety of programs, is described below. GFMO Primitives The majority of programs \nin the data processing problem category are based on a simple intuitive model of programming -select \nthe required data and process it. In fact, JACKSON methodology focuses on describing data first and this \nhelps explain the popularity of the methodology in data processing establishments. The select process \nmodel was exploited in isolating the primitive gfmds listed in Figure 4a, This list is by no means complete. \nThe formatting of the output of a program is closely related to the SELECT primitive used in developing \nthe program as will be illustrated later. Using systematic combinations of the primitives in Figure 4a, \nfour new methodologies were created as described in Figure 4b. These four gfmds develop the same programs \nas the nine skeleton (Westinghouse) programs which, in turn, were used to generate 180 different programs. \nThis suggests that the primitives are fundamental in some sense and can be combined in simple ways to \nyield gfmds for precisely defined problem domains in the data processing problem category. Figure 5 illustrates \nhow the gfmd primitives, SELECT1, SUMMARIZE and WRITE can be combined to create the CONTROL BREAK gfmd \n(Figure 4b). The control break problem is a stancfard problem in file processing where the hierarchically \norganized input data determines the predicates in the nested iterations which comprise the program body. \nDevelopment of Program Processing Steps SUM3fARIZE1 property of data in a single equivalence class VERIFY \nthat,data is correct MODIFY data WRITE data isolated based on a SELECT-PROCESS model SELECT primitive \ngfmd PROCESS primitives SELECT3 SUl@iARIZE1 , WRITE SELECT1 SUWRIZE1, WRITE SELECT2 VERIFY , WRITE SELECT2 \nMODIFY, WRITE to form methodologies for processing 180 programs. 1. control br k program> I input file \nname> <process entity> <output structure, I 2. input file name> I storage structure> <entity structure \nname> 3. <entity str cture name> + <nested entity> entity field d scrip tion> 4. <entity field, description> \n, <field name> field des ripticm> <k y?> 5. process entity> I <ini for WH LE <predicate> QQ <process \nnested <use data p ocessed .acc ss ~ use proc ssed entity> entity> for nested entity> iterator> data \nfor entity> 6. <process nes ed entity> <process r entity> SELECT1gfmd OUTPUf  7. <output s ructure> \n<printed re ort file> <output file>  8. <printed re ort file>  1 I<report eading> .pagi atiom entity \nname> <print f elds>* higher entity report?> 9. <higher ent ty report> I .entit name> <higher entity \nreport> Figure 5a. CONTROL BREAK methodology description using SELECT1 primitive. control break program: \nGENERATE SfiES REPORT 1 (9%: f!~ name: proces! entity: =.,.,.: (see Figure 5.d (see Figure 5 .C I for \ndetails) for details)1 1 storag structure: entity structure nmne: flat file customer m;~%fls~r entit,y \nstkcture nme: name : orderll lescr. : esj%,m; yes enti tu strt!cture me: $armunt no z e M descr. : \niekl descr. : E ield name: quantity ie ld deem. : key ?: no Figure 5.b. The interpretation details for \ninput file name. Annotations for Figure 5.b. 1. The user is prompted by the pds with the grammar variable \ninput file name: . The riser supplies an in terpretaion sales file . If the structure of the sales file \nhas bee defined in a data dictionary much of the remainder of the refinement tree for this node could \nautomatically be generated by the pds with the ap approving or disapproving as the tree is generated. \n 2. TWO points of clarification are. needed at this point in the tree. The most significant is the ability \nof the grammar farm model to simplf y derivational sequences. For example, A + B + C can be shortened \nto A~C. In this case A is entity structure name, B is entity field description, and C is field nom?, \nfield desc?., keq?. The second point concerns the way we drew the refinement to save space, i .e. , \n field name: field descr. : is equivalent to fie d me: field !ieecr . : k ?:. L key ?: 3. The interpretation \nat this point is skipped as a means of simplifying tbe diagram.  An inter\u00ad 4. The ap interpretation \nof yes is used by the system to generate another production. pretation of no would prevent the generation \nof a further refinement as occurs in the lowest level of this figure. output tructure (cent d from Figure \n5 .b) : output ~file?: no ~rinted r port file?: yes I higher entity~ report?: PepO1>theadin,q : pcmgin! \nat ion: entitzy nmc: order &#38;K::@ %!!.: yes :@; printlfield: printl field: higher ent]ty report?: \nentit. name: customer order count E$amOunt yes I printi fie2d: printi field: higher entity r~port?: \nenti t,y name: sales file order count E$amount no Figure 5.c. The interpreted refinement tree for the \noutput structures. Annotations 1. Report heading and pagination details were omitted in the hope of \nsimplifying the figure. 2. The interpretation item count causes process code to be generated which \ncounts the number of items.  process entity: (cmt d from Figure 5 .b) sales file initialize for enti \nt,q: NH LE predi ate: O process n . ted entity: use data processed _ SET EOF FOR SALES FILE not end of \nCUSTOMER for nested entity: READ FIRST REC sales file ORDER COUNT E$ANOUNT INITIALIZE ALL TEMPORARIES \n use processed data for entity: 6)PRINT ORDER COUNT Z$AMOUNT initialize Ifor entity: WHI!LE predi~atr: \n&#38; process m s ted entity: use datalpmcessed &#38; SWITCH OLD CUSTOMER{), not end of OBOER for nested \nentity: NEW CUSTOMER#; customer Z 1 Z$ANOUNT @ INITIALIZE ALL TEMPoRARIES EXCEPT SALES FILE , TEMPORARIES \n use processed data for entity: @ PRINT ORDER COUNT, Z$ANOUNT initialize for entity: WR LE predi ate: \n&#38; process nested entity: use data iproeessed SWITCH OLD OROER#, not end of NO for nested entity: \nNEw ORDER#; order entity Z 1 2$ANOUNT @ INITIALIZE ORDER TEMPORARIES I access itervztm:use J for OD \nprocesood ta entity: READ NEXT REC PRINT ITEM COUNT, Z$AMOUNT Figme 5.d. The interpretation details \nfor the body of the control break program. Annotations 1. Information formed bile processing the entire \nsales file (i. e., all the customers) is used at this point. This ammmts to printing a summary for the \nentire sales file.  2. 81 represents te rminal code for the counting of the number of orders.  lZ$AMOUNT-represents \nthe terminal code ceded to win up the dollar anr.x t jnst formed for the order. The accmnulative effect \nof thi* statement in the customer loop is to produce the total dollar amount for each customer. 3. As \nin comment 1 the waler count and dollar ammmt can be printed but in this case it is for each customer \not the entire sales file.  4. 11 at this le el counts the number of items in each order.  Figure 5a \ngives the templates for developing programs using the CONTROL BREAK methodology. The SELECT1 gfmd, illustrated \nin Figure 5a, consists of templates which channel the development process in order to describe, as shown \nin Figure 5b, the hierarchical structure present in data. The remaining SELECT1 gfmd templates develop \nthe control structure, as shown in Figure 5d, necessary for selecting the data to be processed. The non \nterminals <use data processed for nested entity> and <use processed data for entity> should be interpreted \nusing a SUMMARIZE process as illustra ted in Figure 5d. (This interpretation could be, enforced by the \nsemantic aspects of the methodology and is ignored here.) Generally speaking, the SELECT gfmd primitives \ndictate the control struc\u00adture of a program. The PROCESS primitives are embedded into this control structure. \nIn the case of the CONTROL BREAK gfmd, the PROCESS primitives (too simple to describe using templates \nhere) are SUMMARIZE and WRITE. Figure 5d gives the develop\u00adment and interpretation of the body of the \nprogram. Figure 5C illustrates the use of the output struc\u00adture templates to specify the points in the \nnested iterations of the program control structure where the WRITE statements are to be inserted. The \nformatting of the output is dictated by the control structure of the program body which in turn is dictated \nby the SELECT1 primitive. Combinations of gfmda for Program Development Fairly complex programs can be \ndeveloped using the four gfmd s, given in Figure 4b, in some sequence. To use these gfmd s in sequence, \nhowever, a linking mechanism must sometimes be inserted. One such mechanism is illustrated (Figure 6) \nusing another standard problem which is taught in a technique oriented file processing course at the \nComputer and Information Science Department (The Ohio State University). The problem is described next. \nTwo files are to be processed. The first file consists of orders for products placed by customers and \ncomprises the transaction file. The second file consists of the products stocked by the company and is \ncalled the product master file. This problem is a version of the familiar validation of a transaction \nfile using standard data stored in a master file. The results of this validation should produce two reports \n--an exception report which contains error messages as well as some summary data, and a valid transaction \nreport which lists valid transactions and summary data for the valid trans\u00adactions. An output file containing \nrecords formed by adding master data to each transaction record is also produced. The transaction file \nin the specific problem contains lines from sales orders arranged so that all the orders for a particular \nproduct appear together in the file. This was accomplished by sorting the original order file with product \nnumber as the primary key. The master file contains product information. See Figure 6a. TWO methodologies \n--the VALIDATE (given in Figure 6b) and the CONTROL-BREAK are linked to develop the refinement tree for \nthis problem. We call this new methodology the VALIDATION REPORT . The =struction of the VALIDATION REPORT \ngfmd is given in Figure 6c. The VALIDATE gfmd guides the programmer into developing a program which reads \neach transaction record, verifies and marks it with an error code, and then writes the transaction onto \na temporary file. The SORT program, or the linking mech\u00adanism, inputs the error coded transactions and \norders them according to valid or invalid, and error type. This hierarchically organized data is the \ninput to the CONTROL BREAK program which prints out the required summary reports. The details of the \nactual development are obvious and are not given here. Conclusions Drawn From a Preliminary Analysis \nof Student Programs Fourteen different student programs for the VALIDATION REPORT problem described above \nwere collected. The programs were written by computer science majors taking a second course in PL/~ and \nwere acquainted with structured progra~ing techniques. Prior to assigning the problem, JACKSON methodology \nwas discussed and its use was required in developing the program turned in. In order to analyze the programs, \nthe problem specifications were re-written (Figure 7) in terms of a) relationships present in data that \nmust be considered by the program control struc ture in order to select data and b) processes that must \noperate on the selected data. We assume that the success of a process depends on two factors a) correct \nimplementation statements for the process-on and b) the placement of the implementation statements of \nthe process at correct points in the control structure of the program. Our observations are summarized \nbelow. <transaction <master file> file> Product Order Data Data [Q VALIDATION REPORT Extended Transaction \nFile  CT Figure 6a. Validation report problem. validate program> II 1 1. program <output> <define files> \nbody> SELECT2 gfmd 2. <define files> I name oft transaction <name of master file> file>  4. name of \nma ter file> II 3. .mxne of trans ction file> .tkey> key ord ring> <mke y > key ord ring> 5. .progra \nbody> I .i itial part> NHILE <~ EOF Iin D!3 <form validation un!t and process it> Q_ <final Part> transaction \nfile> 6. <form validation un t and process it> F .tkey~ rekey> ~ flush aster> ~ deal with tr nsaction> \n deal transaction> I 7. &#38;lush master> 8. with  I I <read hew &#38; .tkey~mkey> &#38; <no m tch> \nEI!SE aa~ch> <process un-needed master> master>  9. <no m tch~ NH LE <same trans ction key> ~ .no mat \nh process> <read next t ansactiOn> L  10. match ppcess> 1  ~ same transaction key> ~ <validation process> \n<read next transaction> ~ Skeleton VERIFY efmd 11. validation process> I I+ single record tests?> 12. \n<single record test?> I1  IF field i of .relat[ional .field[j of ~ <mark !rror ~ valid process> transaction> \noperator> master> transact ion>l I Figure 6.b. VALIDATE gfmd UsinS SELECT1 and VERIFT Primitives VA. \n.n. m.n., .-- . -. . pro am I I validate program sort control break [program VALIDATE gfmd CONTROL \nBREAK gfmd I validate program  control break program code for sorting output file of VALIDATE [ El \na [ Figure 6.c. VALIDATION REPORT methodology sing VALIDATE and CONTROL BREAR gfmds, 36 1. Transaction \nfile is an ordered relation. the order is ascending by Product Number, Order Number, and Line Number, \n 1.1 There ca be several transactions for each product in the transaction file. 2. Master file is an \nordered relation. The order is ascending by product number, 3. Partition transactions into valid transactions \nand invalid transactions. 4. Partition invalid transactions by error type.  Figure 7a. Relationships \nto be Considered in Validation Report Problem. 1. Validate transaction product numbers. 2. Validate \ntransaction unit prices. 3. Form valid transaction report summaries. 3.1 z of valid transaction quantity \nfields. 3.2 Count the number of valid line items. 3.3 z of valid transaction dollar amounts. 4. Construct \nand output an extended record for each valid transaction record (record type 5) . 5. Construct and output \ntwo extended records for each invalid transaction record. (One record type 5, the other record type \nO.) 6. Generate 1 line for the valid transaction report for each valid transaction. 7. Generate 1 line \nfor the exception report for each invalid transaction. 8. Form exception report summaries.  8.1 Z of \ninvalid transaction quantity fields by error type. 8.2 Count the number of invalid line items by error \ntype. 8.3 z of invalid transaction dollar amounts by error type. Figure 7.b. Processes Requirements in \nthe Valida\u00adtion Report Problem. Control Structures of Programs As expected the control structures of \nall the sample programs were entirely dictated by the need to select data based on relationships 1 and \n2 (Figure 7a.) in the input file. How\u00adever, there was a wide variation in the details of the control \nstructures used. A large variety of correct ways of implementing the selection of data was actually reflected \nin these 14 programs. While all the students provided the needed outer loop shown in Figure 8a., a major \nvariation occurred in the control structures used within the body of this outer loop to identify the \nthree major program branches which are: 1) TKEYWIKEY, 2) TKEY+!KEY, and 3) TKEY=MKEY. These branches \nwere defined using NIFT, statements as in either a nesting of Figure 8.b. or a linear sequence of IF \nstate\u00adments as in Figure 8.c. A second major varia\u00adtion in the control code dealt with the use of a loop \n(no match loop, see Figure 8.d. ) within the TKEY+fKEY branch and/or the use of a loop (match loop, see \nFigure 8.e.) within the TKEY= MKKY branch both of which implement the multiple transactions per product \nrelationship (1.1 in Figure 7a.). Using the nesting or lack of nesting as variable 1 and the presence \nor absence of the match and no match loops as variable 2, Figure 8.f. defines 8 categories of control \ncode and a count of the number of student programs occuring in each category. Hence, based on the preliminary \nstudy, we find that even if a methodology such as JACK-SON is followed by the students, there is a large \namount of variation in the control structures of the resulting programs. Actually, JACKSON methodology \nattempts to provide more explicit guidance for develop ment than many other general purpose methodologies. \n/READ first T kc and i-f Rec A %WSILE loop body --T A b Figure 8a. Common Outer Loop in Student Programs \nTKEY<IWEY TKKY=MKEY branch branch I =./ 1 Figure S.b. Nested IF Approach to Branch Identifi\u00adcation TKEY \nT > EY TKXY>MXXY branch % *. ekI TKEY T NKEY TKEY=NREY branch Figure 8,c, Linear IF Approach to Branch \nIdenti\u00adfication 37 Setup loop predicate B WSILE No T same match product process J 43 IF 1 Read next \nmsc u Figure 8.d. No Match LOOP Found in TSSY<MKEY Branch of Some Programs Set up loop predicate Q Read \nNext /3 Figure 8.e. Match Loop Found in TRRY=MKEY Branch of Some Programs Figure 8.f. Count of Student \nProgzams by Control Code Category. Success of Processes Recall that in order to successfully realize \n a required process specification the implementa tion statements must be correct and the statements must \nbe correctly located or embedded in the control structure of the program. A large number of the programs \ndid not successfully realize all the processes called for by the specifications. In the study we concentrated \non implementation and location errors and ignored errors which appeared to be caused by imprecise problem \nspecifications. The major causes for the incorrect imple\u00admentation of a process were 1) missing a required \nstatement(s), or (2) using an incorrect operator(s) and/or operand(s) within a statement. The major causes \nfor the incorrect placement of process implementation statements in the control struc\u00adture were 1) process \ncode located in the wrong branch(s), or 2) incorrect placement of process code in relation to a loop \nstructure, or 3) missing branch, i.e. , predicate missing from the control code. From the tabularized \nresults in Figure 9, it is evident that most implementation errors were caused by the omission of statements. \nBecause in many cases the student was able to successfully implement a similar process we feel that the \nreason for missing processes was failure to understand the problem specifications. From the tabularizes \nresults in Figure 9, we conclude that students appear to make more errors in the placement of a process \nthan in its actual implementation. That is, even though the control structure in the program is correct, \nthe process statements were placed incorrectly. 6. CONCLUSIONS Our collective programming experience \npoints to the existence of patterns of programming though few attempts have been made to systemati\u00adcally \nidentify these patterns. Based on the Westinghouse experience we claim that in fact patterns of programming \nexist in the data pro\u00adcessing area and exploiting these patterns to provide the programmer with improved \nsupport results in reduced development costs and improved maintainability and reliability. We have shown \nthat the grammar form model presented here is, in fact, adequate to encode methodologies for channeling \nprogram development in order to re-create programming patterns in well defined problem domains. A few \nmethodology encodings are adequate to guide program development for a large variety of programs. This \nis because each methodology is flexible enough within the problem domain, and, in addition, methodologies \ncan be combined in systematic ways. Based on a preliminary analysis of student programs we find that \na) general methodologies are not very successful in limiting the design choices and hence there is a \ngreat amount of variation in the resulting correct control structures of the programs, b) more errors \nare made in the placement of process implementation statements within the control structure of the program \nthan in the actual imple\u00admentation of the process. As we have illustrated using the CONTROL BREAK and \nVALIDATION RRPORT methodologies, grammar forms are very successful in channeling program development \nso that a specific control structure for the program is developed. The correct points in this control \nstructure where specific process statements could be located are also marked and are used to guide the \nprogrammer in correct placement of processes. The implementa\u00adtion details of the processes themselves, \nin 38 many cases, are left to the programmer. However, this is errors. verifying where More our the \nprogrammer makes the least extensive controlled experiments claims above are currently in progress. Obviously, \nimplementations for a exist. given problem many correct Existing methodologies attempt to discipline \nprogram development so that there are fewer variations in the implementation of a given problem. This \npromotes ease of maintenance and reliability. Here we advocate the use of methodologies for precisely \ndefined problem domains. We show that such methodologies generate a specific control structure for a \nproblem. In addition, the methodologies guide the placement of the process statements. We expect such \ntailored methodologies to channel development so that there can be very few possible implementations \nfor a gitien problem. This should facilitate program maintenance and reliability even more than general \npurpose methodologies. Finally, a precise model for encoding program development methodologies facilitates \nautomation and system enforcement of standardized program development. Whilethesarne standardi zation \ncan be attempted through education, such an attempt probably will not be as effective. This is because \nthe programmer may not recognize a standard pattern of development as such until much effort has been \nexpended. We also expect a system driven by precise, domain oriented methodology descriptions to be more \neffective since the responses of the system will also be domain oriented and hence more intuitive for \nthe programmer. 7. ACKNOWLEDGEMENT The authors would like to acknowledge the valuable assistance provided \nby Lucy Wright in analyzing programs and tabulating data. Process Number Where Successful of Programs \nthe recess Was Unsuccessful  Reasons I@ 1 : c Fa zion 3 ur  >f . i yQ ca ~ Ss Y\u00ad. 1. VALIDATE \nNumbers Transaction Product o 2. VALIDATE Transaction Unit Prices 0 3.1 Z of Fields Valid Transaction \nQuantity 6 8 2 1 1 2 3.2 Count Items of the Number of Valid Line 6 8 2 2 4 3.3 X of Valid Amounts Transaction \nDollar 6 8 2 2 2 2 4. Construct Record for and Output Each Valid an Extended Transaction 13 1 1 5. Construct \nRecords action and Output 2 for Each Invalid Extended Trans\u00ad 13 1 1 6. Generate 1 Line of Transaction \nReport Valid Transaction the for Valid Each 8 6 2 4 7. Generate 1 Report for Transaction Line Each of \nthe Invalid Exception 10 4 2 2 8.1 E of Invalid Transaction Quantity Fields by Error Type 3 11 4 1 6 \n8.2 Count Line of the Number Items by Error of Invalid Type 6 8 3 1 4 8.3 Z of Invalid Amounts by Transaction \nError Type Dollar 0 14  14 Figure 9. Results of Student Program Study 8. 2EFERENCES [RAMA79] Ramanathan, \nJ. and Blattner, M., [AH077] [BALZ79] [BARS79] [CHEA79] [DOD80] [FLOY72] [GINS77] [JACK75] [JENS75] [KENN79] \n[LIsK77] [POPE77] Aho, A. V. and Unman, J. D., Principles of Compiler Design, Addison Wesley, 1977. Balzer, \nR. and Goldman, N., Principles of Good Software Specification and Their Implications for Specification \nLanguages, Proceedings of IEEE Conference on Specification of Reliable Software, Cambridge, MA, April \n1979. Barstow, D. R., Knowled8e-Based Program Construction, Programming Language Series, T. E. Cheatham \n(cd), The Computer Science Library, North Holland, 1979. Cheatham, T. E., Townley, J. A., and Holloway, \nG. H., A System for Program Refinement, Proceedings of the 4th International Conference on Software Engineering, \nMunich, Germany, 1979, pp. 53-62. Stoneman Environment Requirements, Department of Defense, February \n1980. Floyd, R. W., Toward Interactive Design of Correct Programs, IFIP Conference, 1971, Amsterdam, \nThe Netherlands, 1972, pp. 7-10. Ginsburg, S., A Survey of Grammar Forms -1977, Sixth Int 1 Symp. on \nMath Foundations of Computer Science, TatranskaLomnica, Czechoslovakia, 5-9, 1977. Jackson, M. A., Principles \nof Program -~ Academic press, New yOrk, 1975. Jensen, K. and Wirth, N., PASCAL User Manual and Report, \nSpringer-Verlag, New York, 1975. Kennedy, K. and Ramanathan, J., A Deterministic Attribute Grammar Eval \nuator Based on Dynamic Sequencing, ACM Transactions on Programming Languages, July 1979, Vol. 1, No. \n1. Liskov, B., Snyder, A., Atkinson, R. and Schaffert, C., !Abstraction Mechanisms in CLU, CACM 20, 8 \n(August 1977), pp. 564-576. Popek, G. J., Horning, J. T., Lampson, B. W., Mitchell, J. G., and London, \nR. L., Notes on the Design of EUCLID, Proceedings of an ACM Conference on Language Design for Reliable \nSoftware, Ed., D. B, Wortman, March 1977. [ROMA77 ] [ROSS77] [SHAW77 ] [STAy761 [TEIC77] [TEIT80] [TEIT77] \n[WARN74] [WEST79] Program Forms and Program Form Analysis, AFIPS Conference Proceedings for the National \nComputer Conference, New York City, 1979. Roman, Gruia-Catalin, An Argument in Favor of Mechanized Software \nProduction, IEEE TSE, Vol. SE-3, No. 6, November 1977. Ross, D. T. and Schoman, K. E., Jr., Structured \nAnalysis for Requirements Design, IEEE Transaction on Software Engineering, Vol. SE3, No. 1, January \n 1977. Shaw, M., Wulf, W. A., and London, R. L., Abstraction and Verification in Alphard: Defining \nand Specifying Interaction and Generators, Communications of the ACM, August 1977, Vol. 20, No. 8. Stay, \nJ. F., HIP~and Interactive Program Design, IBM Systems Journal, 1976. Teichroew, D. and Hershey, E. A. \nIII, PSL/PSA: A Computer-Aided Technique for Structured Documentation and Analysis of Information Processing \nSystems, IEEE Transactions on -Software Engineering, Vol. SE-3, No. 1 January 1977. Teitelbaum, T. and \nReps, T., The Cornell Program Synthesizer: A Syntax Directed Prograrmaing Environ\u00adment, Department of \nComputer Science, Cornell University, Ithaca, N.Y., 1980. Teitelman, W., A Display Oriented Programmer \ns Assistant, Xerox Pare, March 1977. Warnier, J. D., Logical Construction of programs, Van Nostrand, \nNew York, 1974. Westinghouse Corporation, Program Design Methodology Evaluation Survey, Pittsburgh, PA, \n1979.  \n\t\t\t", "proc_id": "567532", "abstract": "", "authors": [{"name": "J. Ramanathan", "author_profile_id": "81339523609", "affiliation": "The Ohio State University, Columbus, Ohio", "person_id": "PP31031724", "email_address": "", "orcid_id": ""}, {"name": "C. J. Shubra", "author_profile_id": "81100565112", "affiliation": "The Ohio State University, Columbus, Ohio", "person_id": "P383049", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567535", "year": "1981", "article_id": "567535", "conference": "POPL", "title": "Modeling of problem domains for driving program development systems", "url": "http://dl.acm.org/citation.cfm?id=567535"}