{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 2. The Dining Philosophers Problem communicate directly with each other \nand in which chopsticks are represented by passive cells (memor- In [3] E. Dijkstra proposed a problem \nin con-ies) which may be accessed only by the two adjacent current programming which has, since then, \nbeen philosophers. N. Francez and M. Rodeh have recently considered as a classical problem, the dining \nphilo considered this constraint and remarked that none of sophers problem. This problem is interesting \nnot so the solutions published so far (e. g., [1], [2], [3], much on account of its practical importance \nbut be-[5], [6], [7] and [8]) satisfied this criterion. cause it is a paradigm for a large class of concur-Indeed, \nthey all use some kind of central scheduler rency control problems. which regulates the eating of the \nphilosophers. Francez and Rodeh [4] propose a solution which is The problem will be presented first informally \ntruly distributed, in the language CSP [6]. and then in a more precise way. Suppose a number of philosophers \nare sitting around a circular table. A second constraint that we impose is that all The life of a philosopher \nconsists mainly of think-philosophers be identical (we could call this the ing. When a philosopher thinks, \nshe does not inter-layman s point of view). This is a very natural act with her colleagues. But , from \ntime to time, assumption if we think of a very large number of it may happen that a philosopher gets \nhungry from very simple philosophers, so simple, in fact, that too much thinking. He then wants to eat \nfrom a they could not even possibly remember an identifi\u00adbowl of foodr which a kind benefactor maintains \nfull cation number, personal to each philosopher (assume and which is located in the middle of the table. \nTo we have more than n philosophers, each of whom can eat he needs two chopsticks (wisdom is essentially \nhold fewer than logn bits) . We also restrict our oriental in this tale) . He will then try to pick attention \nto initial configurations which are symme\u00adup the two chopsticks which are closest to him. tric: we assume \nthat, in the beginning, all philo-One chopstick is located at his right, just in the sophers are in the \nsame state and all shared varia\u00admiddle between him and his right neighbor (there is bles hold the same \nvalue. If it were not for such only one chopstick between any two adjacent philo-an assumption, it would \nbe easy to code different sophers) and another one is located between him and protocols for the different \nphilosophers in the his left neighbor. In all, there are only as many initial values of the shared variables \n(or the chopsticks as there are philosophers. A philosopher initial states of the different philosophers) \n; pro\u00admay only pick up one chopstick at a time and obvi-tocols similar to those described in Section \n7 ously he cannot pick up a chopstick which is already would also do the job if the initial values of \nthe in the hand of a neighbor. If a hungry philosopher shared variables are favorable. In short, we are \ncannot eventually get both chopsticks adjacent to interested in large distributed systems of simple him, \nfor example, if each time he tries to pick up identical processors. a chopstick it happens to be in the \nhand of the appropriate neighbor, then the philosopher starves. Our goal is to find protocols for the \nphiloso-If a hungry philosopher gets to hold both his chop-phers which will satisfy the two constraints \nex\u00adsticks at the same time, he eats (without releasing plained above and will allow the philosophers \nto his chopsticks), eventually satisfies his eat. If the system is such that every hungry phil\u00admaterial \nneeds and puts down both his chopsticks. osopher eventually gets to eat, then we shall say that it is \nlockout-free. We shall exhibit such a In a more precise way a philosopher goes indef-system. But as a \nfirst step we will build a initely through a cycle: thinking, trying, eating system which enjoys only \na weaker non-starvation and so on ad infinitum. To eat a philosopher needs property: if, at any time, \nthere is a hungry exclusive access to two resources each of which is philosopher, say Plato, then at \nsome later time shared with a neighbor. A philosopher may die only some philosopher (not necessarily \nPlato) will eat. while he is thinking. A system which enjoys this property will be said to be deadlock-free. \nIn other words, a deadlock-free The problem is to describe a system of proto-system only guarantees that \nnot all hungry philo\u00adcols for the philosophers, chopsticks and possibly sophers starve. some other entities, \nwhich will behave in the way indicated above (especially that at any time each A word on our assumptions \nconcerning the syn\u00adchopstick is in at most one hand) and which will chronization of the different processors. \nWe are ensu~e that, with varying degrees of strength, phil-not assuming anything concerning the respective \nosophers will be able to eat. Thus we will be talk-rates of activity of the different philosophers, or \ning, not of one, but of several problems and solu-the overall scheduling. We may not, therefore, tions. \nexclude the possibility of an adversary scheduler who would, for example, do his best to keep Plato 3. \nConstraints and Properties of the Solutions from eating, by awaking him only when one of his neighbors \nis eating. We allow this adversary We shall now describe some constraints on the scheduler to make use \nof all information ab~ut the class of solutions we are willing to consider. Such system, including the \nresult of random draws per\u00adconstraints will be justified both by aesthetic and formed by processes, the \nvalues of the shared vari\u00adpractical considerations. ables and the value of the private variables of each \nprotocol. This is an extremely severe assumption Our first constraint is that we are interested which \nensures that the protocols presented here only in truly distributed systems, i.e. , systems in have very \nstrong correctness properties. Other which there is no central memory or central process works, in different \nsituations, make less severe to which every other process may have access. assumptions ([41 and [11]) \n. This adversary sched-Indeedr we are looking for systems in which the only uler, though, is not allowed \nto use information active agents are the philosophers who do not about the results of future random draws. \nWe have to allow for the possibility of an adversary schedu\u00adler because we assume that the interactions \nbetween philosophers that we describe are only the visible part of an iceberg of complex relations which \nwe do not know about and are not willing to study. This is also a very sound principle of system design: \nwe are to assume that the worst is certain. We use variables shared by two adjacent philo\u00ad sophers and \nassume that both philosophers, will never access a common variable of theirs exactly at the same time \n(they have exclusive access to the varia\u00adble) and that every philosopher that requests access to a variable \nwill eventually get access to it. In other words, we assume that the problem of synchro\u00adnizing the access \nof a number (here, only two) of processes to a shared variable is solved. The justi\u00adfication for this \nassumption is that the length of time taken byan atomic action (reading, writing or reading and writing) \nis very small compared with the rate of activity of a philosopher. Therefore the density of accesses \nis very small and we may assume either that conflicts do not occur, or that they are taken care of by \nthe hardware. To fix ideas, we are assuming that we are dealing with four different orders of magnitude \nof time slices. The smaller one is that of the atomic action on a variable (only the shared variables \nare of interest) , say, a nanosecond. The second one is the rate of activity of a philoso\u00adpher: the idle \ntime between each activation which is, say, of the order of a millisecond. The third is the time needed \nfor a meal which is, say, of the order of a second. A philosopher is therefore will\u00ading to suffer a number \nof failures before he may eventually get to eat. The last one is the lifetime of the system itself which \nwe may assume to be of the order of hours. Since, at the previously men\u00adtioned rates, each process participating \nin an actual system will perform many millions of atomic actions, the properties we are about to claim \nfor our systems in terms of unending computations, in practice apply also to actual systems. We are therefore \njustified in assuming that a philosopher may, in one move and without risk of being disturbed by or of \ndisturbing a neighbor, check that a chopstick is down on the table and pick it up. As will be seen later \nthe picking up and putting down of a chopstick will be expressed by a change in the value of a shared \nvariable. 4. Deterministic Solutions A very simple argument will now show that there is no solution to \nthe problem, satisfying the constraints mentioned above, in which the philoso\u00adphers are deterministic \nprocesses. Theorem 1. There is no deterministic, deadlock\u00adfree, truly distributed and symmetric solution \nto the dining philosophers problem. Proof. Suppose there is a deterministic, truly ~ibuted and symmetric \nsolution. We shall de\u00adfine a scheduler which will allow no philosopher to eat, showing in this manner \nthat no such solution may be deadlock-free. For the proof s sake, let us number the philosophers in cyclic \norder from 1 to n (this is an external naming and the philosophers themselves are not aware of their \nown name). The scheduler will activate each philosopher for a single atomic action in the order 1 to \nn, then repeat another similar round in which the philoso\u00adphers 1 to n are activated in turn, and so \non. The claim is that, if the configuration is symmetric with respect to all philosophers at the beginning \nof a round, then the configuration will again be symmetric at the end of the round. Full details of the \nproof will appear elsewhere. The deterministic solution proposed by Francez and Rodeh in [4] seems to \ncontradict the claim we just made. The solution to this apparent contradic\u00adtion is that there is no truly \ndistributed determin\u00adistic implementation of CSP. L. Lamport [9] seems to have been the first to notice \nthis fact, and Theorem 1 above, together with the CSP protocols proposed in [4], constitutes formal proof \nof this fact. Thus any truly distributed implementation of CSP must be probabilistic and, in such an \nimple\u00admentation, even terminating programs (for the seman\u00ad tics of CSP) terminate only with probability \none. Such a probabilistic implementation of CSP is pKo\u00ad posed in [4]. 5. The Free Philosopher s Algorithm \nThe gist of our idea is the following: since the problem,,with any deterministic solution is the symmetry \nwhich could keep recurring, we need a way to break this symmetry. We shall incorporate free choice into \nthe protocols of the individual philo\u00adsophers, letting the laws of probability ensure that, with probability \none, the symmetry will be broken. We propose the following process for each philo\u00adsopher. In the program \nbelow, the function R is the reflection function on {Right,Left}. 1 while true 2 do think; 3 do trying:=true \nor die od; 4 Zile trying 5 do draw a random element s of {Right,Left};  ***with equal probabilities \n*** 6 wait until s chopstick is down and then lift it; 7 if R(s) chopstick is down 8 then lift it; \n9 trying:=false 10 else 11 put down s chopstick 12 fi 13 g; 14 eat; 15 put down both chopsticks *** \none at a time, in an arbitrary order *** 16 od . Definition. A schedule S, for n philosophers, is a function \nwhich assigns to every past behavior of the philosophers, the philosopher Pi whose turn is next to be \nactive, i.e. , to perform an atomic action. Under past behavior up to any given time, we mean the complete \nsequence of atomic actions and random draws with their results, up to that time. Following [11], for \nus a schedule is not merely a fixed sequence of activations but, rather, is a mapping which makes the \nnext action depend on the whole past behavior. This captures the idea that, for any specific system, \nwhat will happen next de\u00adpends on the whole history of past successes and failures of the processes to \ngain access to shared resources, as well as on what has happened inter\u00ad nally within the processes. Unlike \n[11], we do include under past history the results of random draws already made. For a given schedule \nS and specific outcomes of the random draws D (D is an infinite sequence of elements of the set {Right,Left}), \nwe get a particular computation C = COM(S,D), which is an infinite sequence of atomic actions. Note that \na computation is unending and embodies the total life\u00adspan of the system. We shall use the term finite \ncomputation to denote a finite sequence of atomic actions. The ith element of a computation C is Notethe \natomic action which takes place at time i. that we assume that no two atomic actions take place exactly \nat the same time in C; this restriction could be easily lifted to allow atomic actions of different processes, \nas long as they do not concern the same shared variables, to take place exactly at the same time. Definition. \nA computation C is proper if, in C, every philosopher is activated an infinite number of times. A schedule \nS is called proper if, for every sequence D of outcomes of the random draws, the computation COM(S, D) \nis proper. It follows from the explanations found after the program, that, if a schedule S is proper \nthen, in every possible computation C = COM(S, D), no philosopher quits while trying to eat, eating, \nor exiting. On the space of all possible outcomes of random draws D we impose the uniform probability \ndistri\u00adbution. The function COM then associates with every schedule S a probability distribution on the \nspace of all computations,the probability of a set E of computations being defined as the probability \nof the set of sequences of random draws D such that COM(S,D) is in E. In the sequel we shall make no \nassumption on S, except that it is proper. Our theorems, thus, ensure that certain properties hold for \nevery individual proper schedule. We do not assume a probability distribution on the space of schedules. \nOur goal is to show that, in the system of the free philosophers, a deadlock may occur only with probability \nzero. We shall first define precisely the events in question. Definition. A deadlocked computation C \nis a com\u00adputation for which there exists a point t in time, at which at least one philosopher is trying \nto eat, but after which no philosopher eats. A philosopher Pi is locked-out (or starving) in a computation \nC, if there exists a time t at which Pi is trying to eat, and after which Pi never eats. For a fixed \nproper schedule S, the event of being a deadlocked computation has a well defined probability (the proof \nis left to the reader). Denote DL(S) = Pr(D : C=COM(S,D) is deadlocked) . We actually want to prove that, \nfor every proper schedule S, DL(S) = O. The following lemmas refer to two philosophers, Plato and Aristotle, \nwhere Plato is seated next and to the left of Aristotle. Lemma 1. If Plato picks up a chopstick an infinite \nnumber of times but Aristotle picks up a chopstick only a finite number of times, then, with probabil\u00adity \none, Plato eats an infinite number of times. The exact meaning of the lemma is that the event of Plato \neating an infinite number of times has probability one relative to the event described in the hypotheses. \nThe claim is meaningful only for those schedules which attach a positive probability to the hypotheses, \nand it should be understood that the lemma applies only to those schedules. Proofs for this and the following \nlemmas are omitted. Lemma 2. In a deadlocked computation, every philo\u00adsopher picks up a chopstick an \ninfinite number of times, with probability one. Lemma 3. Let F be a finite computation consisting of \nt steps, such that, at time t, both Plato and Aristotle are trying to eat, Plato s last random draw was \nLeft and Aristotle s last random draw was Right. Consider all (infinite) computations C which are continuations \nof F. Then, with probabil\u00adity not less than one half: at least one of Plato or Aristotle picks up a chopstick \njust a finite number of times in C, or at least one of them gets to eat in C, after his last random draw \nin F and no later than two random draws after his last random draw in F. To each time instant there corresponds \na con\u00adfiguration of latest random draws. We shall say that a configuration, A, and a later configuration \nB, are disjoint if each philosopher has, between A and B, performed a random draw. Lemma 4. If every \nphilosopher picks up a chopstick an infinite number of times, and if, at time t, the configuration of \nlast random draws is A, then there will arise, with probability one, a later configura\u00adtion B, disjoint \nfrom A, in which some philosopher s last random draw is Left while his right neighbor s last random draw \nis Right. We now get to the main theorem concerning the free philosophers. Theorem 2. For every proper \nschedule S, DL(S) = O. Proof. We shall prove the theorem by contradiction. Assume that DL(S) >0. We may \nthen talk about the probability of events relative to a deadlock. By Lemma 2, with probability one (relative \nto the event of deadlocked computation) , every philosopher per\u00adforms an infinite number of random draws. \nBy Lemma 4, there will arise, with probability one, an infi\u00ad nite sequence of disjoint configurations \nof last random draws satisfying the hypotheses of Lemma 3: say AO, Al ,.. .,An... . BY Lemma 3, some \nphiloso\u00adpher eats between An and An+2, for every n, with probability one. We have shown that, relative \nto tlie event of deadlocked computations, non-deadlocked computations have probability one. We conclude \nthat a deadlock may occur only with probability zero.QED 6. Lockouts are Possible As indicated in the \nintroduction one would like a lockout-free system. It may be shown that the system proposed above is \nnot lockout-free. Theorem 3. The system of the free philosophers is not lockout-free. C.A.R. Hoare [5] \nhas proposed a measure of the quality of a solution to the dining philosophers problem: the size of the \nlongest chain of starving philosophers that may occur. Though it is possible that the protocols proposed \nabove are quite satis\u00adfactory in practice, we shall show that a schedule may, with probability one, starve \nall but one philo\u00adsopher. Theorem 4. For the system of n free philosophers, there is a schedule which \nstarves, with probability one, n-1 philosophers. The previous theorem throws light on why the proof of \nTheorem 2 had to be delicate. No local reasoning would succeed in showing that one of a chain of philosophers \nsitting next to each other will get to eat. We shall now offer another solution which guarantees that, \nwith probability one, there will be no lockout, i.e, nobody will starve. 7. The Courteous Philosopher \ns Algorithm The possibility for lockouts demonstrated in Section 6 is due to the fact that a philosopher \nPi may be discourteous enough to pick up his neighbor s chopstick (on line 6), even if that neighbor \nis trying to eat and Pi has alread eaten after his neighbor s most recent meal. By using a~onal values \nfor the variables shared by neighboring philosophers, we can ensure courteous behavior and obtain a lockout-free \nsystem. The courteous philo\u00adsopher is defined by the following process. var Ieft-signal,right-signal \n: {On,Off}; *** Left-signal is shared with left neighbor. *** *** It is initially set to Off and iS \nset to On *** *** when one becomes hungry and restored to *** *** Off only after eating. *** *** The \nleft neighbor may read it but not *** *** change it. *** *** He refers to it as right-neighbor-signal \n. *** *** s~etrically for right-signal. *** read only var left-neighbor-signal ,right-neighbor signal \n: {Roff}; *** Left-neighbor-signal is left neighbor s *** *** *** right signal. varleft-last,right-last \n: {Left,Neutral,Right}; *** left-last is shared with left neighbor and *** *** *** both may change it. \n*** It indicates who ate last : left from chop-*** *** stick or right from chopstick. It is *** *** *** \ninitially on Neutral. *** Left-last is the same as left neighbor s *** *** *** right-last. 1 while true \n2 do think; 3 do trying:=true 4 left-signal:=On; right-signal:=On 5 or die 6 g; 7 while trying 8 do 9 \ndraw a random element s of {Right,Left}; *** with equalprobabilities *** 10 wait until s chopstick is \ndown 11 and 12 ( s-neighbor-signal = Off 13 or s-last = Neutral 14 ~ s-last = s) 15 and then li~ s chopstick \n16 if R(s) chopstick is down 17 then lift it; 18 trying: =false 19 else 20 put down s chopstick 21 fi \n22 * 23 eat; 24 left-signal:=Off; right-signal:=Off; 25 left-last:=Right; right-last:=Left; 26 put down \nboth chopsticks *** one at a time in any order *** 27 od . The following proof requires an ordering \nin time of the meals of the philosophers. It turns out that while there is no immediate natural way to \ndefine a global order on the meals, we are able to say when a philosopher s meal preceded or followed \nhis neighbor s meal. This local ordering suffices for our proof. The methodology used here for dealing \nwith time in systems of concurrent proces\u00adses may be useful, with appropriate modifications, in other \ncontexts. When a philosopher eats he goes through the following sequence of actions: picking up a first \nchopstick (line 15), picking up a second chopstick (line 17), setting his left-last variable to Right \n(line 25), setting his right-last variable to Left (line 25), and putting down both his chopsticks (line \n26). If, while performing the sequence described above, a philosopher picks up his second chopstick \n(line 17) at time tl and puts down the first of the chopsticks he releases at time t2, we shall say that \nhis corresponding meal-interval is [tl,t2] (this implies tl<t2). Definition. We shall say that meal interval \n[tl,t2] precedes meal-interval [t3,t41 ([tl, t21 <[t3rt41) if t2<t3. Remark 1. The relation precedes \nis antireflexive and transitive. Remark 2. If [tl,t2] is a meal-interval of Plato, then between time \ntl and time t2, Plato is the only philosopher who has access to Plato s left-last and right-last variables \n(since Plato holds both his chopsticks during this interval of time and no philosopher ever changes his \nlast variables unless he holds both his chopsticks) and therefore at time t2 Plato s left-last variable \nis equal to Right and his right-last variable to Left. Remark 3. If, in a computation C, [tl, t2] is \na meal-interval of Plato and [t3,t4] of Plato and [t3rt4] a meal-interval then either [tl, t2] < [t3, \nt4] or (since a philosopher has both his hazds during any meal-interval of neighbors may each have both \ntheir hands at the same time) . a meal-interval of Aristotle, [t3, t4] < [tl, chopsticks in his,and no \ntwo chopsticks in t2] [12] Rabin, Memorandum Berkeley, M.O. The No. UCB/ERL August 1980. choice M80/38, \ncoordination Univ. of problem Calif. Theorem 5. If S is of courteous philosophers, one, a computation \nc a = proper schedule then, with COM(S, D) is for a probability lockout-free. system 8. Conclusions The \nsolution to the dining philosophers problem presented here suggests an approach to the general question \nof programming methodology which seems to be opposed to the prevalent one, as illustrated in particular \nin [11. There, the reproducible beha\u00advior of programs is advocated as a necessary condi\u00adtion for debugging \nand it is claimed that, for systems to be reliable, they must be built out of components which themselves \nhave a reproducible behavior. Here the reliability of the system is guaranteed even though the component \nprocesses may have a totally irreproducible behavior. References [1] Brinch Prentice-Hall Hansen, 1973. \nP. Operating Systems Principles. [2] Brinch Hansen, current programming 1978) . P. Distributed concept. \nCACM processes, 21, 11 a con\u00ad(November [3] Dijkstra, tial processes, Academic Press E.W. Hierarchical \nOperating Systems 1972. ordering Techniques, of sequen\u00ad [4] Francezr N. and Rodeh, data type implemented \nby a tion scheme. I.B.M. Israel April 1980 (to be presented on F.O.C.S. , Syracuse Oct. M. A distributed \nabstract probabilistic communica-Scientific Center TR-080, at 21st Annual Symposium 1980). [5] Hoare, \nprogramming, above. C.A.R. Operating Towards a Systems theory of Techniques, parallel quoted [6] ses. \nHearer CACM C.A. 21, R. 8 Communicating (August 1978). sequential prOces\u00ad [7] Holt, R. C., Graham, G.S., \nLazowska, E.D., Scott, M.A. Structured concurrent programming operating systems applications, Addison-Wesley \nand with 1978. [8] Kaubisch, Quasiparallel Vol. 6 1976, W. H., Perrotr programming. Pp. 341-356. R. H., \nSoftware and Hearer C.A. and Experience, R. [9] Lamport, L. Private communication, 1978. [10] ficial \n(Jack Rabin, M.O. intelligence, L. Rosenfeld Theoretical Information ed.)r pp. impediments Processing \n615-619. to arti\u00ad74 [111 Rabin, 4.logN-valued Forschungsinstitut March 1980, M.O. N-process synchronization \nshared variable, Technical fuer mathematik, ETH 21St Annual F.O.C.S. Symposium by Report Zuerich, (1980) \n. 138 \n\t\t\t", "proc_id": "567532", "abstract": "It is shown that distributed systems of probabilistic processors are essentially more powerful than distributed systems of deterministic processors, i.e., there are certain useful behaviors that can be realized only by the former. This is demonstrated on the dining philosophers problem. It is shown that, under certain natural hypotheses, there is no way the philosophers can be programmed (in a deterministic fashion) so as to guarantee the absence of deadlock (general starvation). On the other hand, if the philosophers are given some freedom of choice one may program them to guarantee that every hungry philosopher will eat (with probability one) under any circumstances (even an adversary scheduling). The solution proposed here is fully distributed and does not involve any central memory or any process with which every philosopher can communicate.", "authors": [{"name": "Daniel Lehmann", "author_profile_id": "81100463097", "affiliation": "Hebrew University, Jerusalem, Israel", "person_id": "PP35029791", "email_address": "", "orcid_id": ""}, {"name": "Michael O. Rabin", "author_profile_id": "81100510853", "affiliation": "Hebrew University, Jerusalem, Israel", "person_id": "PP39046283", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567547", "year": "1981", "article_id": "567547", "conference": "POPL", "title": "On the advantages of free choice: a symmetric and fully distributed solution to the dining philosophers problem", "url": "http://dl.acm.org/citation.cfm?id=567547"}