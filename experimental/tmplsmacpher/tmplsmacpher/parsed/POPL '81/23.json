{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 problems are co-NP-complete. These problems are in-PROGRAM NESTING TREE \nrmp m tractable due to the presence ofaliasing. However, x the expected degree of exponentiality is felt \nto be small, especially when certain redundancies are eliminated. Iterative solutions to these problems \nare presented which are then related to the theory of monotone data flow analysis frameworks [Kildall]. \nAn efficient algorithm based on these iterative so\u00adlutions is then sketched which is superior to the \none obtained by employing Kildall s general algo\u00adri thin. The algorithm runs in time O(SET*EDGE) where \nEDGE is the size of the program s flow graph. SET is the possibly exponential parameter which re\u00adflects \nthe number of aliasing patterns of the pro\u00adgram. A pruning scheme is introduced which reduces the number \nof alias patterns to the extent that SET is expected to be asymptotically small (on the order of the \nnumber of variables in the program) for realistic programs. Thus the algorithm should be efficient in \npractical applications. PROGRAMMODELS: This paper investigates data flow problems in a typical block \nstructured programming language such as PASCAL. The salient inter-procedural character\u00adistics of such \na language are the nesting of pro\u00adcedures, pass-by-reference parameters, and re\u00adcursion. The analytic \nmodel employed in this paper is sketched below. It is assumed that procedure definitions may be nested. \nThis nesting is model led by a directed rooted tree whose root, MAIN, is the main procedure. A procedure \nP is the father of a procedure Q if the definition of Q is directly declared within P. Figure 1 should \nmake the construction of this nesting tree clear. Within the definition of a procedure, P, a R[cl S(a,a,c) \nS(c,a,d) T(a) FIGURE 1: INTER-PROCEDURAL STRUCTURES number of local variables, LOCALIP], may be declar\u00aded. \nThis set includes the formal parameters of P. Those formal parameters which are passed-by-reference are \ntermed reference parameters of P and are denoted by FORMALIP]. A variable is global to P if it is the \nlocal variable of any proper ancestor of P in the nesting tree. The code part of P can address (manipulate) \nonly its local and global variables. Formally -- GLOBALIP] = . (LOCALIQIIIQ is a proper ancestor ofp) \nADDRESS[P] = LOCALIP] U GLOBALIP]. The code part of a procedure can also contain statements, called call-sites, \nwhich call (invoke) other procedures. One writes P!~~~~~~~~~--> R (f I,... ,fk) if there is a call-site \nin P calling R with actual parameters aT through ak where each actual ai is passed-by-reference to the \nreference parameter fi. Only reference parameters are of in\u00adterest as these are the only variables for \nwhich aliases are dynamically established. The call struc\u00adture of a program is model led by a directed \nMulti\u00adgraph, called a call -, in which each edge cor\u00adresponds to a call-site. Each edge is labelled with \nthe tuple of actual parameters used at its call-site. The call graph may contain loops as recursion is \nper\u00admi tted. Figure 1 illustrates the construction. A call graph is assumed to satisfy the following \nrequirements. (1) Every procedure is reachable, i.e., there is a path from MAIN to every procedure. \n(2) If P+Q (P calls Q) then Q is addressable by P, i.e. , the father of Q is an ancestor of P in the \nnesting tree.  A simple consequence of (2) is that P +Q implies GLOBALIQ] s ADDRESS[P]. A path in the \ncall graph is called a call chain and represents a sequence of calls made in an execution of the program. \nA program s execution involves two dynamic ef\u00adfects. Whenever a call is executed, a new activa\u00adtion of \nthe called procedure R, is created. Each activation causes a new incarnation (instance) of each variable \nin LOCALIR]-FORMALIR] to be cre\u00adated. Recursion permits the simultaneous exist\u00adence of many incarnations \nof the same variable -\u00ada variable refers to its most recent incarnation. The following lemma determines \nwhen a variable addressed by two different procedures refers to the same incarnation. Incarnation Lemma: \nSuppose Q. + Q1 + . . . + Qn is a call chain. A variable x refers to the same incarnation in both Q. \nand Qn iff x E o (GLOBALIQill{ i z 1). This effect is called the SCOPE effect. The other dynamic effect, \ncalled the ALIAS ef\u00ad feet, is the aliasing of reference parameters to their actual parameters during \nthe execution of an ~Jhen p~~j~lgak) invocation. ---> R (f ,.. .,fk) each fi 1 is aliased to a i; that \nis, fi is made to refer to the same incarnation that ai referred to in P. In general, two variables x \nandy are aliased along some call chain p, written x <~>y, if both x and y refer to the same incarnation \nafter p is traversed. Aliasing is an equivalence relation along a spe\u00adcific call chain. However, different \ncall chains establish different aliasing relations. The form of these relations will be discussed in \nthe next section. The data flow problems analyzed in this paper require that every procedure s internal \ncontrol structure is represented, Each procedure is mod\u00adelled as a flow qraph [Karp] with unique exit \nand entry vertices. These flow graphs are linked inter\u00adprocedurally by calls into a super @as follows. \nSuppose E:P+R is an invocation of R from call-site vertex CSITEIE] in procedure P s flow graph. The vertex, \nCSITEIE], is split into two vertices, CPOINTIE] and RPOINTIE]. All in-coming edges to CSITEIE] are in-coming \nedges to CPOINTIE] and a call ~ is added from CPOINTIE] to the entry ver\u00adtex of R. All out-going edges \nfrom CSITEIE] are out-going edges from RPOINTIE] and a return ~ is added from the exit vertex of procedure \nR to RPOINTIE]. All other edges in the resulting super graph are called simple edges. For a call or return \nedge e, let INVOKE[e] be the invocation E in the call graph responsible for the creation of e. Fiaure \n2 depicts the construction, The super graph model was chosen as it satisfies 221 This theorem gives the \ninductive basis needed to W ///,-., compute mp for arbitrary O. Given mp and an invoca. EMTRYIRI /1 \n/[ tion E from procedure Qn to Qn+l, one can infer that CPOINTIEl . . call ,/ mp. E={ fl(X,E) \\lXcmoand \nfl(X,E) #~} CSITEIE] R E: P-R ,-----\u00ad r.1.m U{ {x} llXSLOCALIQn+l] -F0RFlAL[Qn+12}. RPOIUTIE1 \\\\ \\\\ \n \\\\ Figure 3 illustrates the construction of several EXITIRl % \\\\ (!) m \\ s--~ alias partitions for \na simple program. + lNVOKE[.al!l= WJCW[r. t.,.], E It is sufficient for algorithmic purposes to FIGURE \n2: MODELLING CALLS IN THE SUPERGRAPH the criterion that any execution sequence of the pro\u00ad gram can be \nmodelled as a path in the super-graph. Note, however, that not every path is an execution sequence, despite \nthe assumption of precision up to symbolic execution. The propagative algorithms in the following sections \nwill have to insure that only execution paths are followed. ALIASING SETS AND PARTITIONS In this section \nthe nature of the aliasing re\u00ad la~fon <.~> ,, induced by a call chain i~AIN + Q1 + ... + Qn is analyzed. \n P: As stated earlier <~> is an equivalence relation on the vari\u00ad ables in ADDRESS[Qn]. Let np be the \npartition of ADDRESS[Qn] induced by <~>. Each componentOrequiv. alence class of the alias partition np \nis termed an alias set of Qn. By definition the variables _ in each alias set all refer to the same incarna\u00adtion. \nLet X be a set of variables and E denote the invocation Qnf~J~~~~~~~>Qn+ l(fl,.., fk). Define the i ncarnation \npropagation function, f as follows -- I fl(X,E) = (X n GLOBALIQn+l] ) u { fi II ai c X }. Note that fl \nis monotonic and distributive in the argument X. The utility of fl is seen in the follow\u00ading theorem. \nAlias Theorem: Xc mp=>fl(X,E)~mo.E ~fl(X,E)=g. 222 just know all the possible alias sets, Z(Q), for \neach procedure Q. Formally, z(Q) = {X\\13 call chain p from MAIN to Q such that X s Tp}. All the alias \nsets can be found by initially stipulating that every singleton set {x} such that x c LOCALIQ] -FORMALIQ] \nfor some procedure Q is an alias set of Q and then repeatedly applying fl to this basis and its offspring \nwhenever possible until no new alias sets are generated. A work-list algorithm for this computation requires \ntime O(SET*INVOKE*(SET+MAXF)) where SET is the number of alias sets, INVOKE is the number of call-sites, \nand MAXF = mjx(lFORhlALIP]/). The O(SET+MAXF) term comes from the cost of operat\u00ading a hash table and \ncomputing fl. This term has O(1) expected behavior. Thus the total expected time is O(SET*INVOKE). Note \nthat SET is potentially as large as 0(2VAR) where VAR is the number of var\u00ad iables in the program. INTEF?-PROCEDURAL \nOATA FLO!d PROBLENS The framework for the inter-procedural live and avail data flow problems is obtained \nby annotating each vertex, v, in the super-graph with two sets, GEN[v] and KILLIv], of tokens. For simplicity \nit will henceforth be assumed that the tokens are the variables of the program, although one should realize \nthat the tokens could be the set of expressions in the program or some other program entity set. P, NESTING \nTREE &#38; CALL GRAPH I P LOCALIPl={a] Q LOCALIQl={b, c] R LOCALIRl={d ] I-1null n~ abc I I abd cI-I \n103 I1 II abc 10304 I IJ a bcd n 1030402 I II 1 4 b rI 103040204 Aa c1 1 SOME ALlAS PARTITIONS FIGURE \n3: ALIAS variable x is said to be generated at vertex vwhen x c GENIvI, and x is killed at v when x \ns KILLIv]. A rigorous formulation of these data flow prob\u00ad lems involve some subtleties not found in \ntheir intra-procedural counterparts [Ken, Cocke]. First, a variable x can be live or avail at a vertex \nv in procedure P s flow graph, only when x e ADDRESS[P]. As stated earlier not every path in the super \ngraph d P (a) 1 Q(b) (c) (b) (c) 32 R(d) 4 a PQR 4 4 1 abQR c QR @ 3 abd R cd R  et? .! Alias S&#38; \nPhcedures of 44 Alias Set b QR E ALL ALlAS SETS AND fA TRANSITIONS SETSAND PARTITIONS represents an \nexecution sequence. The second point then is that the path(s) in question must be an ex\u00adecution path(s). \nThe most complicating factor is the existence of aliases. When one asks if a variable x is live at a \nvertex v, one is realliy asking a question about the incarnation to which x refers at v. Thus the definition \nof live must involve the entire execution path in question, includi ngthepart from the entry vertex of \nMAIN to the vertex v. The incarna\u00adtion to which x refers is captured by the followina notation. For an \nexecution path p and variable x, let SA(X,P) be the alias set of the alias partition established by p, \nwhich refers to the same incarna\u00adtion that x most recently referred to in the execu\u00ad tion of p. Such \nan alias set may not exist and in this case let SA(x,p) = ~. The notation SA(x,p) = SA(x,q) asserts that \nthe two alias sets refer to the same incarnation. A formal definition of the live and avail data flow \nproblems is now possible. INTER-PROCEDURAL LIVE: x is live at v iff x s ADDRESS[procedure containing \nv] and 3 execution path p:ENTRYIMAIN] + . . . + Vo(=v)+ l+ +vn such that SA(x,p;) n GEN[vn] z 0  @SA(X,po) \n= SA(x,pn) and VOsj<n(SA(x,pj)n KILL [vj] = !3 ~s~(x>pj) ~ A(x>po) ) INTER-PROCEDURAL AVAIL: x is avail \nat v iff x G ADDRESS[procedure containing v] w W execution paths p:vo(=ENTRYIPIAIN]) + VI + . . . + \nVn(=v) ~i such that SA(X,Pi) n GEN(vil z O . a@sA(x,po) = sA(x,pn) Q@ Vi ~j <n nKILL[vj] =O (sA(x,pj) \n ~sA(x>po) ~ SA(X,Pj) ). The must and may summary data flow problems are concerned with summarizing the \neffects of a pro\u00adcedure s execution. Each vertex, V, of the sUper\u00ad*Note: pi istheprefixofp from ENTRY[ptAIN]to \nvi. graph is annotated with a single set, AFFECT[v], of variables. A variable x is said to be affected \nby v whenever x s AFFECT[V]. The variable x ~ be affected by a procedure P if there is an execution path \nthrough P for which the appropriate incarnation of x is affected somewhere on this path. The vari\u00adable \nx must be affected by P if x is affected on some vertex of every execution path through P. Formally -- \nMAY SU!IMARY PROBLEM: x may be affected by P iff 3 execution path p: ENTRYIMAIN]+. ..+VO(=ENTRYIP]+VI \n+v2+,..+vn(=EXIT[ P]) for which SA(X,PO) s SA(x,pn) and gi such that SA(X,Pi) n AFFECT[vi] * k? @SA(X, \nPo) = A(x, pi) MUST SUM!IARY PROBLE!I: x must be affected by P iff Vexecutionpathsp :ENTRYIMAIN] +. ..+vO(=ENTRYIP] \n)+vl +v2+. ..vn(=EXITIP])]) for which SA(x,po) = SA(x,pn) . such that SA(x,pi) n AFFECT[Vi] # 0 arlJsA(x,po) \n< sA(x,pi) The may-summary problem has an efficient solu\u00adtion [Ban] because it does not depend on the \nintra\u00adprocedural structure of a program. Banning has termed such problems flow insensitive. The remain\u00ading \nthree problems --live, avail, and must-sum\u00admary --are all flow sensitive and are the focus of the remainder \nof the paper. COMPLEXITY OF THE PROBLEMS: The theory of NP-complete problems is well es\u00ad tablished [GJ]. \nIt is the consensus of the math\u00adematical community that NP-complete problems do not have polynomial-time \nalgorithms. The inter\u00ad procedural live problem is shown to be NP-complete. presence of aliasing as there \nmay be an exponential The complement of a problem is obtained by ne-number of alias sets. (Note that \nthis is true for gating the problem statement. For example, the com-Figure 4). plement of avail, called \nco-avail, asks if a vari- THE ITERATIVE SOLUTION: able is not avail at a vertex. The co-avail and co-this \nan iterative the In section solution to must problems are NP-complete. Hence, the avail and live data \nflow problem is presented and related to must-summary problems are said to be co-NP-complete the theory \nof monotone data flow analysis frameworks. [GJ]. The avail and must-summary problems have similar To \nshow that a problem is NP-complete it suf-solutions. The iterative solution employs an alias fices to \nshow that the problem is in NP and that a set framework in which alias sets are propagated known NP-complete \nproblem {s polynomially transform-instead of variables and in which a propagated alias The NP-complete \nproblem used here is able to it. set retains enough information about its propagation the classic 3-satisfiability \nproblem [Cook]. One path to guarantee that only execution paths are is given a set of variables X and \na boolean expres\u00ad followed. sion E in 3-Conjunctive Normal Form on these vari- In the alias set framework, \nthe vertices of the ables. The problem is to determine whether E is super graph are annotated with sets \nof alias sets, SGEN[V] and SKILLIV] wheresatisfiable; that is,if there is a truth assignment SGEN[V] \n= {X11X c Z(procedure containing v) and X n GEN[v] * O} to the variables in X for which E is true. Theorem: \nThe inter-procedural live data flow problem is NP-complete. SKILLIV] = {x11X &#38; z(procedure containing \nv) and X n KILLIv] z O}. Proof: An arbitrary 3-satisfiability problem must be transformed into a live \ndata flow prob-The entities that are propagated in this framework lem. Suppose X = {xl,. ... Xn] and \nthe expression consist of ordered pairs, <X,E>, called alias .pairs.  X is an alias set and the component \nE, called the E = ~ (xi1+xi2+xi3) where Xij &#38;xux. The i=l memory, is either an edge in the call graph \nor the data flow problem modelling E is depicted in special symbol * . Instead of finding the relation \nFigure 4. It is asserted that E is satisfiable live, the special relation alias live is desired if and \nonly if the variable T is live at the and is defined as follows -\u00adentry vertex of the main procedure \nPo. D ALIAS LIVE: Similar proofs show that the avail and must\u00ad <X,E>SSLIVEIV] (readsas <X,E> isalias \nliveat summary problems are co-NP-complete. Note that in vertex v ) iff the proof above, recursion was \nnot employed. The 3 execution path P:ENTRYILIAIN] +.. .+VO(=V) presence of just the ALIAS effect makes \nthese prob\u00ad +V +...+V 1n lems NP-complete. Moreover, the problems are poly\u00ad and variable x such that \n . nomial if the SCOPE effect is considered in isola\u00ad x = sA(x,po) tion. The problems are intractable \nin the and xis live at vonpath p 225 Y/ )@x =) (F,T) KI LL[x~2] LOCAL IPO]= {T, F] KILLIx;l] b 1 KlLL[x~31 \nLOCAL IPil= {Xi,~) v = 2 =  FIGURE 4: IS T LIVE AT ENTRY[~]? andThe introduction of the memory component \nis neces \u00ad E = INVOKE [vk-l-wk] for k = min {CE[pojl<RE[pojll+ sitated by the requirement that propagation \nis along l<j<n if k exists execution paths only. From the definiton of E [\u00ad above, it follows that for \nany edge e from w into* otherwise [ is an execution path if and only if e is OpOj TNote: CE[poj = the \nnumber of call edges on the not a call edge or E c {*,INVOKE[e]]. It should be subpath of p frOl?! V. \nto vj clear that this observation provides the necessary RE[poj] = the number of return edges. leverage. \n226 The relation between the alias live and live prob\u00adlems is expressed in the following simple theorem. \nTheorem: LIVEIV] = u (Xll<X,E> CSLIVEIV]) The iterative solution employs a function IL which maps a super \ngraph vertex into a set of alias pairs and a function PL which maps a set of alias pairs and a super \ngraph edge into another set of alias pairs. The main theorem is -- Alias Live Theorem: <X,E c SLIVEIV] \niff . qpathp:vO(=v)-wl+ ,. __ that<X,E>e~L( IL(VJP)+ .-wnsuch The functions IL and PLare given in Figure \n5 below. IL(v) = { <X,*> II Xs SGEN[V] } P,(Y,e) = x L (1)For simple edge e: { <X,E>ll Xg!SKILL[v] and<X,E>c \nY ]  (2) For return edge e corresponding to call graph edge F:  { <x,F> II X # SKILLIV] and 3< X , \nE>e Y(X=fl(X , F~fl ) ]  (3) For call edge e corresponding  to call graph edge F: { <X,E> 11X # SKILLIV] \nand ((E = * ?@ 3<X ,*> cY(X =fl(X,F))) g (< X,EJS SLIVEIRPOINTIF]] ~ (fl(X,F)=O~ 3< X ,F~s Y ( X = fl(X,F) \n)))) ] The alias set framework for the live problem can be viewed as an instance of a distributive monotonic \ndata flow analysis framework [Kildall]. The lattice . consists of the set of all sets of alias pairs \nof the program with the meet, operator being set union. tFL(x,p) = PL(PL(. ..(PL(x,vl+vn)n,v 1+v2)+v2) \n,Vo+vl) The operation space consists of the functions ~ P where for P VO+V+... +V 1n ~p(X)= F (F (...F \nVn-l+vn(x)...)) O+v 1 1+V2 MQFVW(X) = PL(X,V+W) U IL(v). The alias live theorem asserts that the solution \n.to the alias live problem is the meet over all w (MOP) solution. That is, SLIVEIV] = u (~p(jl)llp is \na path from v to EXITIMAIN]). The distributive property of PL implies that the !IOP solution is also \nthe minimum fixed ~ (MFP) solution to the set cif equations --SLIVEIV]= u (FVW(SLIVEIW])). The MFP exists \nas the lattice is finite and PL is a monotonic function. AN EFFICIENT ALGORITHM: The fact that the alias \nframework is a monotone data flow analysis framework allows one to employ Kildall s general algorithm \nin solving the live data flow problem. However, a better algorithm is presented. The first improvement \ninvolves reducing the number of alias sets, SET. Let OCCURIP] be the set of variables that occur in the \ncode part of P. be a collection of sets of variables, et !/EL REL[P], one for each procedure P in the \nprogram. Definition: is a pruning system iff REL (l)v P (REL[P] ~OCCURIPl) and (2)V invocations P+R: \n(fl(RELIPl,P+R) a f1(ADDRESS[P],P#7) n REL[R]). The importance of pruning systems is that whenever X \nis an alias set in x(P) one may use the pruned alias set X n REL[P], in lieu of X as X n REL[P] z X \nn OCCURIP] and the relevant portion of X is retained under the mapping fl (condition (2)),  In fact, \nif one lets f ~EL(X,P+R) =fl(X,P+R) nREL[P], the monotonicity of fl implies that fREL(XnRELIPI,P+R) = \nfl(X,P+R) n REL[R]. Thus the mapping fREL has the special property that a pruned alias set s image under \nfREL is the pruned ima9e of the alias set. Thus, as in the previous section, one may compute all the \npruned alias set of a pro\u00ad gram directly using fREL. The optimal pruning system for a program con\u00ad sists \nof the sets OPTIP] = OCCURIP] u {xlll call chain P:QO+. . . +Qn such that x c OCCURIQn] . and x c n \n(GLOBALIOi]\\\\ ial) }.   The POPT pruning system is optimal in that it con\u00adsists of the smallest possible \nsets. The OPT sets are the minimum fixed points of the system of equa\u00adtions -- OPTIP] = u (GLOBALIR]nOPTIR] \n\\lP+R) u OCCURIP]. A round-robin [H] solution to this problem requires time O(INVOKE2) where INVOKE is \nthe number of edges in the call graph. The number of pruned alias sets for the POPT system is expected \nto be much smaller than the number of alias sets. In practice, the number SET is ex\u00adpected to be O(VAR) \nwhen the POPT system is employed. This expectation arises from the assumption that in practice OCCURIP] \nrarely contains elements which are aliased. The second improvement, stems from taking advan\u00adtage of certain \nspecial properties of the propaga\u00adtion function PL. Suppose an alias pair <X,E> is alias live at a vertex \nv. The alias pair is said to be free at v if E = * and restricted at v other\u00adwise, The first observation \nis that all restricted alias pairs at vertices within a given procedure P were propagated from the exit \nvertex of P. This common origin for restricted alias pairs implies that the propagation of all restricted \nalias pairs with the same alias set can be accomplished by propagating just the alias set and an associated \nvector of memory components. This factorization reduces the problem to one of propagating the alias sets \nof each free and restricted alias pair. These representative alias sets are called the factored alias \n-. Suppose there is a free and a restricted alias pair at a vertex v for which the alias sets are identical. \nFrom the properties of PL it follows that wherever the restricted alias pair is sub\u00adsequently found to \nbe alias live, the free alias pair will also be alias live. Thus the second ob\u00adservation is that free \nalias pairs supercede re\u00adstricted alias pairs whenever they meet at a vertex. These observations lead \nto a significant per\u00adformance increase as there are at most O(SET) factored alias pairs as opposed to \nthe O(SET*INVOKE) collection of alias pairs. A work\u00ad list algorithm employing this propa gative scheme \nruns in time O(VERTEX+ANOTATE+INVOKE+Z SETP(EDGEP+MAXS)) where VERTEX = the number of super-graph vertices. \nANOTATE = the sum of the cardinalities of every GEN and KILL set. SETP = the number of pruned alias sets \nof procedure P. EDGEP = the number of super graph edges whose head vertices are in P s flow graph. MAXS \n= the cardinality of the largest pruned alias set. Note that the parameters SETP, EDGEP, and MAXS tend \nto remain constant (or grow quite slowly) as pro\u00adgram size increases as procedure size tends to remain \nconstant. be able to arrange the solution so that it worked A round-robin algorithm utilizing this approach \non a procedure at a time, thus removing the neces\u00adhas a time bound of O((R+2)*(SEDGE+SET*INVOKE)) sity \nof having the entire super graph in core at where SEOGE is the number of simple edges in the one time: \nSuch an approach is possible, but it is super graph and R is the loop interconnectedness not yet clear \nwhether it is practical, due to the parameter of the super graph. However, this bound ap-space-time tradeoff \nrequired. Another option for plies only when the super graph is reducible --a re-reducing the space requirement \nis to compute fopT quirement which may not hold very often. If the on the fly, thus removing the O(SET*INVOKE) \nand ;~T super graph is irreducible the R+2 term becomes tables. Again the space-time tradeoffs appear \nto EDGE. The round-robin approach is highly parallel be severe. in its operation and works well as long \nas there Another interesting consideration is the inte\u00ad is not a small core of factored alias pairs which \ngration of this scheme into data flow problems in\u00ad are reticent to stabilize. Empirical studies are cluding \nadditional features such as parallelism needed to determine which of the two approaches --and pointer \ndata types. round-robin or work-list --is superior. ACKNOWLEDGMENT: CONCLUSION: This author wishes to \nrecognize the helpful The live, avail, and must summary data flow collaboration of his colleagues --Lee \nOsterweil, problems have been shown to be theoretically Lloyd Fosdick, and Oick Taylor --at the University \nintractable in the inter-procedural context. of Colorado. Oespite this, an iterative approach was developed \nREFERENCES: to solve each problem which fit into the domain [A] Allen,F.E. InterProcedural Data Flow \nAnalysis. Information Processin~ 74, of monotone data flow analysis frameworks. A prac-North-Holland \nPub. Co., Amsterdam (1974), 398-402. tical algorithm was then presented in which the [AC] Allen, F.E. \nand Cocke, J. A Program Data degree of exponentiality was reduced to manageable Flow Analysis Procedure. \nComm. ACM 19, 3(1976), 137-146. levels. A work-list implementation of this algo\u00ad[Barth] 8arth, J.M. A \nPractical InterDrocedural rithm was seen to have a worst case time bound of Data Flow Analysis Algorithm. \nComm. ACM 21, 9(1978), 724-736. O(VERTEX+ANOTATE+INVOKE+ZPSETP*( EDGEP+MAXS)). [Ban] Bannina, J.P. An \nEfficient Way to Find Empirical studies are needed to determine the the Side Effects of Procedure Calls \nand the Aliases of Variables. Conf. Rec. effectiveness of this approach. In particular, Seventh ACM Symp. \nPrinciples of Program\u00adming Languages (1980), 29-41. how large is SETP in practice? How effective are \n[Cocke] Cocke, J. Global Common Subexpression the OPT pruning sets? How does performance vary Elimination. \nSIGPLAN Notices 5(1970), 20-24. with program size? Manual studies indicate a reason\u00ad[Cook] Cook, S.A. \nThe Complexity of Theorem able outcome. Proving Procedures. Proc. 3rd Annual ACM Symposium on Theory \nof Computing The space requirement for the algorithm is 7i971) , 151-158. O(PROC*VAR+SET*INVOKE+VERTEX+EDGE) \n. Ttie super graph [FO] Fosdick, L.O. and Osterweil, L.J. Data Flow Analysis in Software Reliability. \nis a large structure. It would be convenient to ~, 3(1976). [GJ] Garey, N.R. and Johnson, D.S. Computers \nand Intractability --A Guide to the Theory of NP-Completeness. W.H. Freeman and Co. (1978). [GM] Graham, \nS.L. and Wegman, !1. A Fast and Usually Linear Algorithm for Global Flow Analysis. J. ACM 23, 1(1976), \n172-202. [H] Hecht, M.S. Flow Analysis of Computer Programs. North-Holland Pub. Co., New York (1977). \n[Karp] Karp, R.M. A Note on the Application of Graph Theory to Digital Computer Pro\u00adgramming. Information \nand Control, 3(1960), 179-190. [Kildall] Kildall, G.A. A Unified Approach to Global Program Optimization. \n~ Rec. First ACM Symp. Principles of Pro\u00adgramming Languages (1973), 194-206. [M] Myers, E.W. A Precise \nand Efficient Algorithm for Determining Existential Summary Data Flow Information. Tech. Rep. CU-CS-175-80, \nUniv. of Colorado, Boulder, Colo., March 1980. [RI] Rosen, B.K. High Level Data Flow Analysis, Pt. l(Classical \nStructured Programming). Res. Rep. RC5598, IBM T.J. Watson Res. Ct., Yorktown Heights, New York, August \n1975. [R2] Rosen, B.K. High Level Data Flow Analysis, Pt. 2(Escapes and Jumps). Res. Rep. RC5744, IBM \nT.J. Watson Rec. ct., Yorktown Heights, New York, April 1976. [s] Spillman, T.C. Exposing Side-Effects \nin a PL/1 Optimizing Compiler. Infor\u00admation Processing, North-Holland Pub. Co., Amsterdam (1971), 376-381. \n[UH] Unman, J.D. and Hecht, M.S. ASimple Algorithm for Global Data Flow Analysis Problems. SIAMJ. Computing, \n4(1975), 519-532. [UK] Unman, J.D. and Kam, J.B. Global Data Flow Analysis and Iterative Algorithms. \nJ. ACM 23, 1(1976), 158-171.  \n\t\t\t", "proc_id": "567532", "abstract": "Data flow analysis is well understood at the intra-procedural level and efficient algorithms are available. When inter-procedural mechanisms such as recursion, procedure nesting, and pass-by-reference aliasing are introduced, the data flow problems become much more difficult. The avail, live, and must-summary data flow problems are shown to be NP-complete in the presence of aliasing. However, an algorithm is presented with O(SET*EDGE) time performance where EDGE is the size of the program's flow graph and SET is a possible exponential number which reflects the number of aliasing patterns of the program. It is argued that in practice SET is small and on the order of the number of variables of the program.", "authors": [{"name": "Eugene M. Myers", "author_profile_id": "81406593967", "affiliation": "University of Colorado at Boulder, Boulder, Colorado", "person_id": "P383050", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567556", "year": "1981", "article_id": "567556", "conference": "POPL", "title": "A precise inter-procedural data flow algorithm", "url": "http://dl.acm.org/citation.cfm?id=567556"}