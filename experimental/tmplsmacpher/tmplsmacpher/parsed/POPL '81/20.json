{"article_publication_date": "01-26-1981", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1981 ACM 0-89791-029-X $5.00 to Smalltalk. The introduction of types is more promising in Stnalltalk \nthan in similarly declarationless language LISP, since Smalltdk has a rich user-defined abstract classes. \nTherefore, the most straightforward approach to introduce types is to associate types of variables to \nclasses that variables denote and to associate types of PrOCr3dllreS to mappings from classes to classes. \nSince a variable may denote objects of different classes, we define the type of a variable to be a union \nof classes that t-he variable will ever denote. The aim of this research is not to implement compilers \nfor Smalltalk with type declarations. We intend to design tools to supply type declarations to current \nSmalltalk programs. Complete type determination is neither possible nor desirable; people do write Smalltalk \nprograms that take advanr~ge of late bindings. We are, therefore, interested in finding a relatively \nefficient method that can find types of expressions in a large number of cases. The problem of statically \nassigning types to type\u00addeclarationlcss programs is called type-inference problem. We can find a nUmber \nof work on type inference [3, 4, 7, 9, 11, 15]; these techniques are, however, either too restrictive \nor too incfficicmt for our purpose. The only technique implemented, proven to work for non-trivial cases,and \nLised extensively was developed by Milner [7] to detei mine types for ML language of LCF. Even though \nML language is much simpler than Smalltalk, the fact that there exists an efficient, versatile algorithm \nencouraged LIS to investigate whether we can extend the method. The LCF type checker produces a set of \nequations from procedure declarations and solves them by unification [1.2], to obtain the types of the \nprocedures; it can run in iinear time dUe to a fast unification algOrkkII invented recently [10]. We \nextended Milner s method so that we can treat unions of types; in oLlr method, we create a set of equations \nand inequalities and solve them by unification and a transitive closure algorithm. This technique is \ngeneral and can be applied to other data-flow problems. T he advantage of Milner s method and our method \nis that it reduces the problems to purely mathematical domain so that we can apply various formula manipulation \nalgorithms, without considering the execution order or side-effects. Another advantage is that these \nmethods can handle functions with polymorphic types. In section 2 we review earlier work on type inference. \nThe brief introduction of the syntm and the semantics of Smalkalk is done in section 3. Then we introduce \nthe types into Smalltalk in section 4. We discuss the first part of our algorithm, how to extend LCF \ntype checking algorithm for liberal unions of types, in section 5. Then in section 6 the whole algorithm \nis presented. Section 7 is concerned with the implementation and experience. Smalltalk has four major \ndifferent versions of the language and implementations, The version we used for our experiments is SmallLalk-76. \n2. Earlier work on type inference There are cssentiall y two approaches to type inference. Functional \napproach is USed mainly for applicative languages; however, as we show in this paper, that is essentially \nnot the limitation to this approach. Data-flow @prOaCh k USed fOr imperative languages: state vectors \nconsisting of the types of the variables at various locations in the programs are introduced. These state \nvectors are pushed through the programs until fixed-poinK of the types are obtained. 2.1. Functional \napproach Morris and Reynolds [9, 11] independently considered the same problem at about the same time. \nIn typeless Ianguagcs like Lambda calculus (Morris) or Lisp (Reynolds), it is possible to encounter run-time \nerrors such as applying lists to arguments. So the question that they posed is: Can one infer types of \nfhnctions in these typeless languages, to catch more errors at compile time? Consider a recursive function \nmap(f,m) = def if nUll(m) then nil else cons(f(car(m)), map(f,cdr(m))). Suppose the type specifications \nof null, nil, cons, car, and cdr are given as follows: 188 null: al list+ Bool, nil: -+ a2 list, cons: \n~3Xa3 list -+ ~3 list, car: LX4list -+ a4,, cdr: ~5 list -+ a5 list, where al, ... , ~5 are variables \nthat take types as volLIes, and list is a postfix type constructor. Then we can easily think th~t map \nhas the following type: (a+ ~)Xa list -+/1 list, They have given a way to derive types of ftmctions such \nas the one sl~.~:,n above. Milner [7] has pursued their approach further, and ~hown that an efficient \nway to solve the problem is to use the unification algorithm. He implemented the algorithm in LCF, and \ndemonstrated the feasibility of using such a program as an interactive programming aid: one can write \nprograms without any type declarations and the tool fills all the details. The characteristics of this \napproach are: 1. The types of functions are given as an expression with the types of parameters as free \nvariables. Therefore, even for procedures with polymorphic types, once we compute the type of a function, \nno recomputation is necessary when the function is used with parameters of different types. This is particularly \nuseftd in interactive programming. 2. The domain of types can be infinite. 3. The result types of functions \nmust be uniquely determined given the types of all the parameters. For example, determining types of \na ftlnction like  f(x) = def if x then 1 eke 1.1 is beyond the capability of their system. 2,2, Data-flow \nanalysis approach IJsing data-flow analysis techniques to determine properties which can be described \nby a finite lattice [6], various people [3,4,15] showed that one can infer types of program states at \nvarious locations in the program. The characteristics of this approach are: 1. It can treat arbitrary \nunion of types. 2. The domain of types must be finite. 3. Input must be constant elements of the lattice \nfor each analysis. Therefore, it cannot handle polymorphic procedures. Unlike the functional approach, \nwhenever a fhnction call is encountered, the function body may have to be reanalyzed. It may be possible \nto apply procedural data-flow analysis techniclues [ 13, 16], but nobody has shown how to apply them \nto type-inference problems of polymorphic procedures.  3, %alltalk There is a paper that describes fragments \nof Smalltalk\u00ad76 [2], but the complete language description is yet to be published [14]. Here, I will \ndescribe lhc syntax and the semantics of Smalltdk-76 briefly. 3.1. Syntax rhe syntax is described with \nFINF form with the following convention: I (alternative), { }+ (repetition of one or tnore times). <expression> \n::= <assignment> I <block> I <con clitional> I <message>! <identifier> <assignment> ::= <variable> +-<expression> \n<block> ::= [ <concat> ] <concat> ::= <return expr> I <expression>, <concat> <conditional> ::= [<expression>~[ \n<concat>]<concal>] <return expr> :: =<expression> ] fl<expression> <message> ::= <expression> <unary \nse~ector> I <expression> <binary op> <expression> I <expression> {<selector> <expression>} + <selector> \n::= <identifier>: I <identifier> g <unary selector> ::= <identifier> <binary op> ::= <a sequence of operator \nchwaclers> <method> ::= {<selector> <formal pararnetcr>} + <temporary vars> <block> I <binaly op> 1<temporary \nvars> <block> [ <unary selector> I <temporary Jars> <block> 189 Message is equivalent to procedure call \nof Algol and method is equivalent to procedure declaration. A typical message r f: e, which is equivalent \nto the Simula [1] procedure call r.~(e), means to invoke the procedure f in the class of r with the parameter \ne. From here on we will use the terms messages and methods instead of procedure cal Is and declarations. \n  3.2. Class structure The only kind of entities in Smalltalk is an object. Every object belongs to \none and only one class; all the objects in a class respond similarly to messages. Programmers can c~eate \nclasses freely, but all the classes form a tree structure; the root is Class Object. All the objects \nof a class have the same intermaf structure. Internal structure of an object is determined by local variables \nand a vector of methods descriptors. There are four kinds of variables: temporary variables: Iocaf to \neach method instance ~.ariables: local to each object class variables: local to each class global variables: \nthey can be accessed from every method. A subclass is said to inherit all the properties of its superchiss-all \nthe class variables, instance variables, and a vector of methods descriptors of the superclass are implicitly \ndefined for the subclass. 3.3. Scruantics of messages Consider a message, r f,: a, f2: q. IHere r is \ncalled a receiver, and a., and ~ are parameters of the message. f,: and f ~: are the selectors of the \nmessage, and the concatenation of the selectors denote the name of the method that implements the message. \nThe execution of this message takes the following steps. First, r, al, q are evahlated. Let the value \nof r be an object of class A. Then, class A is searched whether the method f, :f2: is declared in it. \nIf it does,, the method f 1:fz: in class A is invoked with al, a2 as actual parameters off, :f2:. If \nf, :f2: does not exist in class A, then its superclass is searched. This process is repeated until Ctass \nObject is searched. If f, :f2: does not exist in Class Object, then it is a run-time error. This process \nis shown in Fig. 1. Ckass Object Ctass A fl:f2: Ctass 8 F 5 This is the class wlu?re r belongs. Fig, \n1, The message invocation of r f 1: al f2: a2, The CXLZSSr is B. Since f! :f2: does fioL f?XiSt ii% of \nChss A, f 1:f2: tn Ckzss B is invoked. 4. Types in Smalltalk We Will introduce Syntax of type expressions, \nand define how these expressions are interpretecf. Then we will show how we assign type expressions to \nprogmrn expressions. The purpose of this is to prove that we can assign types to programs so that programs \nwith type assignment will not create run-time errors, and to show that we can actually present such an \nalgorithm. 4.1..Definition of types .4.1.1. Base type set There is a finite set B, which consists of \nall the class names. B is called the base type set. 190 4.1.2. Type expressions We will be assigning \ntype expressions of the form aXp XY-+8 to functions. These type expressions are defined as follows: 1. \nAny subset of the base type set B is a type expression. 2. Greek letters, al, q, ... denoting type variables \nare type expressions. 3. T (top) and L (bottom) are type expressions. 4. If a and p ttre type expressions, \nthen so are ax~, and ~+p.  {Integer, Real}, {Object}, a->p, {Integer}-i~ are all type expressions. \n 4.1.3. Partial order We can also define a partial order relation (per) between type expressions. The \npor is defined as follows: Constant type expressions Fkst, we consider per s among constant type expressions. \n1. If a,bg B,then a~b iff a~b. 2. If a G B, then ~Qa and aZ_r_. 3. aGg A b~d iff axb~gxd a~g A b~d iff \ng+bga+d  Variable type expressions Variable type expressions contain type variables as parts of the \nexpressions. T&#38;r ~ iff there exists a substitution S such that S7g = 7P 4.1.4. Type descriptions \nof methods Type expressions are not sufficient to dcscribc types of procedures, Consider a method f I \n[self is: h tte~ers [fiself a-d-dlrtt: I ] tkelf cutdReaL 1.0]. The receiver of this method is denoted \nby s?lf in the method. [f the class of the receiver is Integer, then the result of sending adctlnt: I \nto seLf is returns; otherwise, the result of sending addReaL: t.0 to self is returned. If the type of \nthen-expression is T1 and the type of else\u00ad expression is 72, then the type of the result of the method \nis a union of q and T2. If we introduce a union operator U, we can associate the type of this method \nwith a type expression Tf= r+ ru 1 T2. Alternatively we can express this using per s, f = T+Y A TIGY \nA T2~7, We took the latter approach for describing types of methods, because we wanted to reduce the \nnumber of symbols used. We will describe the type of a method by a type equation and a set of per s, \nwhich may be empty. We call this the type description of the method. Example f: Y I [self A: y a [tkelf] \nfly]. equation: Tf = TxXTy+rr per s: Tse&#38;Tp Ty~7r Any Tr which satisfies per s is a solution; the \nIcast solution is Txu7y.  4.2. Type assignments We assign types to programs in a way similar to Milner \n[7]. We need first some notion of a type environment to give types to the free variables in an expression \nand assert per s obtained From fhnction applications. A prejix p is a finite sequence of variables. An \nassump~ion v is a finite sequence of por s. A prefixed expression (pe) has the form <p,v,e>, where every \nvariable free in e occurs in p. If a pretix or an assumption consist of a sil@e element, then they are \nrepresented by that element; otherwise the members arc separated by commas and enclosed in parentheses. \n We say that a variable x is active in p if no x occurs to the right of it in p. Now a type assignment \nof a pe <p,v,e> is an assignment of a type expression or a type description to each element of p, and \nto etch subexprxssion of e, A variable x is assigned a type expression when x is either in p or in e. \nA method name f is assigned a type description when f is in p, and a type expression when f is in e. \nThus one type assignment of the following pe, <,,append: r I [self nutl D [or copy] flsdf car cow: (self \nCd?_ append: r)]> is: append:{ List}X{List]+{List} {List} I seLf{List} W{List}-~{Object} > !r{List} \nOpy{List}-+{List}] *seLf{List} car{ List}+_r cOns:Tx{List}-+ {List} seLf {List} cdr{ List} +{ List} append \n{List} x{ List} +{ List} { List} ){List}J{List}> We denote a type assignment of <p, v, e> by <~, 7, e>, \nor <p, V, co> when we want to indicate the type u assigned to e itself, In any <F, V, ~>, and any binding \nfa of a method name fin either p or ~, a type variable in u which does not occur in any enclosing yT \nbinding of a variable y is called a generic type variable for the binding FO. A generic instance of u \nis an instance of o in which only generic type variables are instantiated. We now define the notion of \na well-typed (wt) pe as follows: (i) <P, v, XT> is wt iff either (a) x is a variable, and XT is active \nin p, or (b) x is a method name, and Xa is active in F and, if u consists of a type equation ,x = 7 \nand POr S $x, then 7 is a generic instance of U, and the instantiation of 9X by this substitution is \nasserted by 7. (ii) <L v, (Epfa),> is wt iff <P, v, e>, <P, v, D are wt, and u ~ ~.+B and p~~ and BET \nare asserted by V.  (iii) <p, v, [~p > [Fo] e y]~> is wt iff <p, v, e>, <p, v, e >, and <p, v, e > are \nall wt, and UZ, and yG. are both asserted by ~. (iv) <b, t, co ra I Vy [S]7 declared in class A> is W \niff <~ cone ) - > iswt, and u = CIX8 -+ T,where (flO, ra,vy ,v,s a is a union of class names of A and \nsubclasses of A that does not have the declaration of fl ancl its superclass is in a. If there is a way \nto well-type an expression, then the execution of the expression in the type environment will not create \nany run-time errors. This can be easily proved. The rest of the paper deals with the algorithm to assign \nwell-typing. 5. Extending the type-inference algorithm of LCF We first show that we can extend the type-inference \nalgorithm of LCF so that we can infer the types of procedures that have liberal unions of types for conditional \nexpressions. Then we extend further to allow temporary variables and assignments. The algorithm in this \nsection are not yet the complete algorithm for the type-inference problem of Smalltalk.  5.1. Type inference \nalgorithm for union of types Let LISconsider the following append: ftlnction, which takes two lists as \narguments and returns a list: append: r I [self nutls [frr copy] tlself car cons: (self Gdr append: r)], \nWe assume that all the fhnctions in the definition of append: have the type descriptions as follows: \nnllll {List} -+ {Object} cop y {List} + {List} car {List} --+ T cdr {List} + {List} cons: T x {Lk@ + \n{List}. We develop an algorithm that can handle this example. Algorithm L: (Milner s algorithm to infer \ntypes for ML language of LCF). Algorithm A: (We allow liberal unions of types. Namely, conditional expressions \nmay evaluate to objects of different classes according to whether then-branch is taken or else\u00adbranch \nis taken.) Step 1: Let the fhnction definition to which we are assigning a type be E r ] A(x). Assign \nnew type variables to this declaration as follows. First we introduce an equation: Tf = TXXTr+ PO. \nThis formula represents that the types of the function, the arguments, and the result are ~~ TX, .Tr, \nand P. respectively. Then we will assign fresh type variables to all the expressions and argument positions \nof method in A(x). For the case of append:, it is done as in Fig.2 by introducing type variables PI to \nP19. &#38; pl p2 p3 plo pll p16 Fig, 2. Assignment of type uariuws to cxpresstin of appeti The meaning \nof this assignment is that the type of each expression is represented by the type variable attached to \nit. Also all the messages have type variables attached to their argument positions. They are types expected \nfor the arguments. According to Fig.2 self car cons: (self cdr appemk r) gets the type p7, and their \narguments self car and self cdr append: r are assigned P9 ancI p13 respectively. Step 2: Obtain type \nequations and per s from the fresh type variable assignments. Type equations are created from messages. \nWe also obtain per s from the comparisons between actual parametem and argument positions. If there is \na message e, f: e2 and the fresh variable assignments are Pi+ elf:ez pj + the first argument position \nof f; Pk + the second argument position of f: PI-q Pm+ e2,  then the equation produced is TL = PjxPk \n+ Pi, and the per s produced are pl~pj, Pm~Pk. Per s are also created from conditional expressions and \nfrom references to formal parameters. If there is a condhional expression [e D [S11 S21 and the fresh \nvariables are assigned as follows: P5-+ [e 2 [S1l S21 P14 % P24 S2,  then the per s produced are PILPS \nP2GPS. From Fig.2 we obtain the following equations and per s: null =P2- Pl Tcopy =P5+ P4 car = Plf) \n+ P9 cdr = P16 + P15 append: = P14xP18 + P13 = p8~p12 + p7 cons: sel@3~ P3~P2J r~P6~ P6~P5~ 7sel~Pll~ \nPll~PIOJ P9~P8Y 7self~P17~ P17~P16J P15~P14J r~P19~ P19~P18! P13~P12, P4~P0, P7~Po. Step 3: Unify the \nequations of functions created in Step 2, against the definitions of functions using Algorithm L. From \nthe unification of the equations for append:, we obtain the following most general unifier: ({object}~pl)({ \nList}~p2)({List}~p4)({List}/p5)(~/p9) ({List}/p~~)({List}/p~5)({List}/p~6)(l_/p 8)({List}/p7) ({List}/p12) \nStep 4: Collect all the por s. Then solve them to obtain all the relations among parameters and results. \nThe way to solve these per s is discussed in 5.2. Finally substitute the per s using the most general \nunifier obtained in Step 3. In the above example, the per s are: Therefore, the type description of append: \nis, append: = selfx7r + POJ sel&#38;{List}> r~{Listl, {list}PPo. This says, the arguments of append: \nare of class List and the result must be of class List. End of Algorithm 5.2. Solving the set of partial \norder relations We will explain the algorithm to solve a set of per s required in Step 4 of the previous \nalgorithm. The partial order relations are all of the form e~b, where e and b are either constants or \nvariables. These variables can be divided into two classes: variables representing parameters, which \nwe call terminal variables, and results and variables used to represent subexpressions, which we catl \nnon-terminal variables. The input of the algorithm is the set of per s and the output is the set of per \ns c~d, where c and d are either constants or terminal variables, such that they represent all the relations \namong constants and terminals inferred from the input. This can be solved by transitive closure algorithm. \nStep]: Replace each constant by each fresh variable ~. Step2: Apply transitive closure algorithm to por \ns. Step3: For each terminal variable, obtain all the terminal variables and constants related by the \nclosure of ~ relation. 5.3. Type inference for temporary variables and assignments The second step is \nto introduce local variables, assignments, and statement series into the language. This requires a flow \nanalysis to detelmine definition points and application points of variables. Consider the following program: \nx+e. (1) Unti.Lg X f dog (2) [x+g], (3) The value of x at (2) is defined by the values of x assigned \nat both (1) ,and (3). Algorithms L and A require that any name, whether it may denote a function or an \nobjec~ retains the same type whenever it is referred, On the other hand it is actually possible that \na variable denote objects of different classes at different locations. Therefore, if we need finer details \nof type infolrnation, we give different names to the different occurrences of a local variable. We then \nuse the partial order relations among these different type variables of the same temporary variable to \ngive the data-flow information among these variables. This will certainly increase the complexity of \nthe algorithm. On the other hand if we assign one type variable to one local variable we may not obtain \nfine details we may need for some procedures. Therefore, we have to choose a method according to the \nrequirements on the time of computation, the ease of implementation, and the degree of accuracy. Algorithm \nB: (Assigning types to the language with temporary variables and assignments). Step 1: Put suffix to \ntemporary variables for each occurrence. In the above example, we suffix as follows: xl +e, (1) until.: \nX2 f do: (2) [X3 + g]. (3)  Step 2: Obtain type equations and type formulas for the program using Algorithm \nA; except, for an assignment y+e we create a por Te=T Y From our example the per s obtained are: 7e=Txl, \n7g=Tx3, 7X cTf 2 pre  Step 3: Obtain per s describing the data-flows. Now at the application instmce \n(2), x2 can be both xl and x3. Therefore, we create two per s: TXLrx , TXLTX . 1232 Step 4: Solve the \npor s. In the example we obtain TeLT fPre$ g= fpre. End of Algorithm 6. Algorithm to infer types in \nSmalltalk The features that Smalltalk has and LCF does not have are: 1. temporary variables and assignments, \n 2. arbitrary union of types, 3. late bindings, and 4. global variables and assignments.  We have \nshown algorithms for 1 and 2, We will develop the rest of the algorithms in this section. 6..t. Late \nbindings All the algorithms we presented require that we know the types of messages used in a method, \nexcept the type of itself if it has a recursive call. We have not described how we can treat multiple \nrecursion, but we can cleal with multiple recursion by a trivial extension of Algorithm L. The problcm \nthat the late bincling causes for the previous algorithms is that we do not know the association between \na mess~ge and methods so that we cannot tell the types of the messages, Furthermore, the association \nmay change dynamically. Therefore, all we can do at the beginning is to assume the worst czwe and assume \nthat each message may invoke all the possible methods. Therefore, we assume the type of the message to \nbe some kind of a union of all the types of all the methods invoked. Using these types of the messages \nwe can use Algorithm B to obtain the type description of the method. Then, wc may obtain more accurate \ninformation about the type of the method; hence, more information about bindings of each message. We \niterate this process until we can no Iongcr obtain more accurate information. This iteration should terminate \nsince the number of different type descriptions is finite and the iteration will always decrease the \nordering of the type description. The data structure used to perform this algorithm is a table with message \nntamesas keys, l-he values of this table are lists of pairs of class names and the data structures called \nthe type trees. A type tree consists of a list of the Parameter types, the temporary-variable types, \nthe result type, and a list of por s. This is shown in Fig. 3. Message name t I f Ctass name Type tree \nObject - f A \\ . Ft.g, 3, Type rxabte There is also a table of back references with a key of a message \nname; each value of the table consists of a list of pairs of a class and a method where this message \nis referred. Following is the type-inference algorithm for late binding. Algorithm C: (Late binding) \nStep 1: Initialize the type trees. The first parameter, which is the receiver of the method, is initialized \nto a set of class names; class names included in this set are the class name of the method and class \nnames of subclasses in which the method is not declared and their superclasses are in this set. Then \nthe rest or parameters are initialized to ~ and the result is to T. Step 2: For each method do the following: \nFor each message in the method, obtain the types by taking type unions of methods involved, How to take \ntype unions of methods are described in 6.2. The methods involved may be all the methods if the receiver \nis T. Then apply Algorithm B to determine types of parameters, temporaries, and results. If the computation \nyields smaller types than the types at the beginning for any of the entities, then we replace them by \nthe new types, and mark the method that it is updated. [f the types or parameters or results change, \nthen all the methods that calls the rne~hod being computed must also be marked for recomputation. However, \nif only the temporaries change, then we only need to recompute the CL!rrent method. Step 3: After scanning \nall the methods, repeat Step 2 for each method markecl for recomputation. ErId OJ Algori~hm  6.2. Type \nunions of methods In Step 2 of Algorithm C, we bad t-o take unions of types of methods to obtain the \ntype of a message. How should this union bc taken? Consider a message f and the corresponding methods \nin Class A and B. We distinguish these methods by putting suffixes using class names, then the types \nare 7fA and ~fB. The type union must behave as follows: if we assign 7fA@~fB to f and the program is \nwell-typed, then the program should still be well-typed even if ~f is A assigned to f and ~f is assigned \nto f. B Consider an example, Tf= 71 + 723 qG{A}, {C, DZ72> A Tf= ~1 T2, 71~{B}, {D, E}G72. B Then \nthe message f can be successfully sent to objects of both class A and B. The result may be C, D, or E. \nTherefore, TfA@Tf = T1 + Q, ~IC{A, B}, {C, D, E}G~2. B In the case of multiple parameters, the treatment \nof the parameters other than the first one is different. Consider, = 71X72 + T3>TID{A], T2L{C> ~}, {E, \nF}QT3, gA = TlXT2 + T3, TIG{B}, T2Q{D, G}, {F, H}LT3. gB Let the union be gA @ gB = T~x T 2 -+ 73. \nThe message can be sent to objects of class A and B, therefore, Tl~{A, B}. However, when the assignment \nof TgA@TgB produces well-typing, the assignments of rgA ancl 7gB should also produce Weli-typing. So \nwe have to take simple intersections of types for the rest of the parameters. Therefore, T2G{DI, {E> \nF> HKT3. 6.3. Example for Algorithm C Now let us look at how Algorithm C works with an example. There \nare two classes A and B, where the following methods are defined. Class A null add: car Gdr append: x \nI r [r +x. unttlg r nutl dog [self +-self radcl: r car. r + r cctr]. oself ]. Class B add: car cdr, \nWe will show that we can infer that the type of append: is Now we can assign as follows: {A}X{A} + {A}. \n We assume that we know the lypes of all the other Then compute the types using the message-types of \nClass methods as listed below. A. The result is Class A null {A} -+ {Object} add: .qxT -+ 71, 71 ={A} \n6A. Global ml own variables. car {A} +T Finally, we have to consider global and own variables. cdr 71 \n-+ q, q ={A}. Here we mean own variables to be variables whose values (lass B at the beginning of the \ncomputation of methods depend add: TIXT -+ ?1, T1 ={B} on the previous history of computation. car {B} \n+T There are three kinds of global and own variables: cdr T1+ T1, q ={ B}. instmce variables, class variables, \nand global variables. Actual] y there are pool variables, but they behave exactly step 1 like global \nvariables except that they have to be explicitly Let us first examine the body of append:. There are \nimported to classes. four messages: [nstance variables are local to each object. They are null, add:, \ncar, and cdr. created whenever an object is created, and their values can We compute the types of messages \nby taking type unions: be only accessed from the methods of the ckass. Class variables are local to e~ch \nclass. They are created null {A} -+ {Object} whenever a class is crcatcd, and they can be accessed from \nadd: qXT + 71, q ={A, R} every object of the class. G Iobsd variables are accessed car {A, B} -+T from \nevery object of SmallEdk. We will treat all of them cdr q -+ 71, q ={A, B} in a similar manner; we will \nonly present an algorithm append: 7selFx7x + 73. which works for all of them. Step 2 The difficulty \nof handling global variables is that unlike temporary variables the flow of control among all We put \nsuffixes to temporary variables and obtain the the occurrences of global variables is totally unpredictable. \nfollowing version of append.:, Therefore, in general we have to consider a value of a append: x I r global \nvariable at one location to be affected by all the [rl + x. assignments to that variable in the entire \nsystem. Until,g T-2 YILLtt. dog Therefore, what we will do is to assume the type of a [selfz + self3 \nadd: t 3 car, rq + r5 cctr]. llself~ ]. global variable to be the union of all the types of objects that \nthe variable may ever denote in the system. Now obtain the partial order relations by unification. Algorithm \nD: (Handling of global variables). Step 3: We solve this set of per s and obtain Step 1: We assign two \ntypes to each global variable. One Tx=Tr ET~ =Tr Tr = +{A}, 1 234 is accesstype and the other is assign \ntype. Initialize access {A} TselflQ~self2 = 7self3~{A B~ 7self2~Tself4g73 types @ T and initialize assign \ntypes to L Step 2: Compute the types of methods using Algorithm C. Whenever, global variables are accessed, \nwe use access types as their types. On the other hand we accumulate all the assignments and argument \nrestrictions to assign types. Namely, if a global variable is assigned an object with type ,, we replace \nthe type OF the assign type of that global variable by the union of r and the previous value of the assign \ntype. Step 3: After the comput~tion, compare access types and assign types. If assign types are smaller \nthan accesstypes, replace access types by assign types, Then repeat Step 2 on all the methods which refer \nthe global variables whose access types are changed. 7. Implementation The type-inference algorithm has \nbeen implemented in SmaWalk-76. It is intended to type-check the Smalltalk kernel system, which consists \nof about 60 classes and 1300 methods. Out of these methods 98 are implemented outside of the system by \nmicrocode and Bcpl programs. The types of these primitive methods are hand coded and fed into the type-checking \nsystem. We have actually implcmetr~ed a simpler version of the algorithms presented in this paper; we \ntreated temporary variables (local variables) to take the same value in the entire method in Algorithm \nB, and we assumed all global variables to have T as their values in Algorithnl ~. This decision was made \nfrom the following reasons: a) we wanted the system to run fast, b) we needed some data on how well a \nsimple algorithm will work before implementing an elaborate algorithm, and c) tnost of Smalltalk methods \nare simple and straightforward so that they do not have the behavior that their types differ depending \non the locations. One of the most useful fessturesof this algorithm is that it detects whether the method \nreturns self, NIL, or one of the parameters. Since many Smalltalk methods return self or NIL, this capability \nwas very important. We have not yet tested the type inference on the entire Smalltalk kernel, beCaUse \nSmalltalk-76 has a severe limitation on the number of objects to be created and the entire data structure \ndoes not fit into the memory. The system is planned to be expanded shortly and we can report the result \nof the entire system. So far we have been testing on the subset of the kernel that is concerned with \nnumbers. 8. Conclusion After embarking on this project, Al Perlis suggest to me another approach to \nobtain more information on types. The approach is, we run the system against some examples and record \nall the types of arguments and the results This will probably converge quite quickly and we can obtain \ninformation close to the actual types of the methods. This idea is also found in the thesis by Mitchell \n[8]. It is possible to implement an efficient compiler using this technique. We gather not only the lypes \nof arguments but also the frequency and the distribution of these types. Suppose a message invokes one \nmethod very often, say 90% of the time, we can crrxate the following code: The class of the receiver \nis checked to see whether that represents the most frequent case. [f so, it jumps to the corresponding \nmethod directly; otherwise, it searches methods by the standard way. However, these infomlation we obtain \nfrom statistics can never be better than the actual type. What we obtain is the lower bound of the actual \ntype. On the other hand we obtain the upper bound of the actual type by type inference program. If both \nagree, then we are sure of the accuracy of our algorithm. [t is always important to obtain both these \ninformation in a type inference system. Furthermore, the statistics can never give us the information \non polymorphic types. Many Smalltalk progmms can be simply analyzed that they return one of the parameters \nas the results, and this fact is very important for various purposes. Acknowledgements We appreciate \nvarious help and suggestions of our collegues at .lhe Xerox Palo Alto Research Centers. We are indebted \nto Adele Goldberg, Jim Horning, Jim Morris, Larry Masinter for reading this paper. References 1. DAIII, \nO.-J,, NYGAARO, K, Simula an Algol-13ased Simulation Language. Comm. of the ACM, VO1.9,No.9, pp.671-678. \n 2. [NGAI,I.S, D.H.H. The Smalltalk-76 Programming System Design and Implementation. Conf. Rec. Fifth \nACM Symp, on Principles of Programming Languages, Tucson, Arizona, 1978, PP.9-16. 3. JONES, N. D., ANO \nMUCHNICK, S. Bitlding time optimization in prOgranllning languages. Conf. Rec. Third ACM Symp. on Principles \nof Programming Languages, Atlanta, Ga., 1976, pp.77-94. 4. KAPL.AN,M., AW UL.LMAN,J.D. A Scheme for \nthe automatic inference of variable types, Journal of the ACM, No.], VOI.27, PP,128-145, 1980. 5. KAY, \nA.C. Microelectronics and the Personal Computer. Scientific American, 237, No.3, pp230-244, September \n1977. 6. K[],L)AI.L,G.A. A Unified Approach to Global Program Optimization. Cent . Rec. ACM Symp. on \nPrinciples of Programming Languages, Boston, Mass,, 1973, pp.194\u00ad  206. 7. MM-w.rL, R.. A theory of \ntype polymorphism in progmmming. Journal of Computer and System Sciences, 17, 348-375 (1978). 8. Mrrclnm, \nJ.G. The Design and Construction of Flexible and Efficient interactive Programming Systems. Ph.D. thesis, \nCarnegie-Mellon University, 1970. Reprinted in Outstanding Dissertations in the  Computer Sciences series. \nGarland Publishing Co., N.Y., 1980. 9, MORRIS, J.H. Lambda-Calcuhls Models of Programming Languages, \nPh.D. Thesis, MAC-TR-57, MIT, 1968. 10. PAHWSON, M.S. &#38; WI;GMAN, M.N. Linear Unification. Proc. Eighth \nACM Symp. on Theory of Comp., Hershey, Pa., 1976, pp.181-186. 11, RI;YNOLIX, J.C. Automatic Computation \nof Data Set Definitions. Information Processing 68, PP.456-461, North-Holland Publisi]ing Company, Amsterdam, \n1969. 12. ROBINSON, J.A. A machine-oriented logic based on the resolution principle, Journal of the ACM, \nNo.1, VO1.12, pp.23-41, 1965. 13. ROSEN 13.K. Data flow analysis for procedural languages, Journal of \nthe ACM, N0,2, Vol. 26, pp.322\u00ad344, 1979.  14. GOLDBERG,A., ROINON,D., INGAI.LS D., &#38; TESI.ER, L. \nDreams &#38; Schemes, Part One: The Language &#38; its Implementation. To be published. 15. TENNI:WAUM, \nA. Type determination for very high level languages. Rep. IWO-3, Coumnt Inst. Math. Sci., New York U., \nNew York, 1974.  16 WLiHI, W.E. Interprocedural Data F1OWAnalysis in the Presence of Pointers, Procedure \nVariables, and Label Variables. Conf. Rec. Seventh ACM Symp. on Principles of Programming Languages, \nLas Vegas, Nevada, 1980, pp.83-94. \n\t\t\t", "proc_id": "567532", "abstract": "<p>Smalltalk is an object-oriented language designed andimplemented by the Learning Research (Group of the Xerox Palo AltoResearch Center [2, 5, 14]. Some features of this language are:abstract data classes, information inheritance by asuperclass-subclass mechanism, message passing semantics, extremelylate binding no type declarations, and automatic storagemanagement. Experience has shown that large complex systems can bewritten in Smalltalk in quite a short period of time; it is alsoused to teach programming to children quite effectively.Object-oriented languages like Smalltalk have begun to be acceptedas friendly languages for novice programmers on personalcomputers.</p><p>However, Smalltalk has some drawbacks, too. Smalltalk programsare inefficient compared with Lisp or Pascal Late binding is amajor reason of this inefficiency; every time a procedure iscalled, its implementation in the current context has to befound.</p><p>Because of late binding, whether there is an implementation of aprocedure call or not can only be found at run-time. This may beconvenient in the early stages of system development; one can run apartially completed system, and when he discovers a run-time errorcaused by an unimplemented procedure, he can write the procedurebody and proceed the computation from the point where the error wasdiscovered. However, there is no way to guarantee that there willbe no run-time errors. We found many \"completed\" systems whichstill had such run-time errors.</p><p>Another problem is that it is hard for a novice to readSmalltalk programs written by other people. The fact that there areno type declarations and the fact that the bindings are late aremajor causes of unreadability. All the Smalltalk procedures are socalled generic procedures. Each procedure name is associated withseveral procedure bodies declared in different classes. Dependingon the classes of the arguments of a procedure call differentprocedure bodies are invoked. Since the classes of the argumentsmay differ according to the context, it is impossible to staticallypredict the behavior of the procedure calls.</p><p>We observed that both inefficiency and unreadability areattributed to late binding; however, early binding can beeffectively accomplished if we can tell the classes of theprocedure arguments at compile time. In the long run probablySmalltalk needs to have \"type\" declarations---probably not rigiddeclarations of Pascal but rather in the form of hints to compilersand programmers. Even without changing the language it would benice to have a tool that supplies \"type\" declarations to currentSmalltalk or partially specified Smalltalk. This will also lead toefficient compilation.</p><p>We thus concluded that we need to introduce \"types\" toSmalltalk. The introduction of types is more promising in Smalltalkthan in similarly declarationless language Lisp, since Smalltalkhas a rich user-defined abstract classes. Therefore, the moststraightforward approach to introduce types is to associate typesof variables to classes that variables denote and to associatetypes of procedures to mappings from classes to classes. Since avariable may denote objects of different classes, we define thetype of a variable to be a union of classes that the variable willever denote.</p><p>The aim of this research is not to implement compilers forSmalltalk with type declarations. We intend to design tools tosupply type declarations to current Smalltalk programs. Completetype determination is neither possible nor desirable; people dowrite Smalltalk programs that take advantage of late bindings. Weare, therefore, interested in finding a relatively efficient methodthat can find types of expressions in a large number of cases.</p><p>The problem of statically assigning types totype-declarationless programs is called type-inference problem. Wecan find a number of work on type inference [3, 4, 7, 9, 11, 15];these techniques are, however, either too restrictive or tooinefficient for our purpose. The only technique implemented, provento work for non-trivial cases, and used extensively was developedby Milner [7] to determine types for ML language of LCF. Eventhough ML language is much simpler than Smalltalk, the fact thatthere exists an efficient, versatile algorithm encouraged us toinvestigate whether we can extend the method.</p><p>The LCF type checker produces a set of equations from proceduredeclarations and solves them by unification [12], to obtain thetypes of the procedures; it can run in linear time due to a fastunification algorithm invented recently [10]. We extended Milner'smethod so that we can treat unions of types; in our method,wecreate a set of equations and inequalities and solve them byunification and a transitive closure algorithm. This technique isgeneral and can be applied to other data-flow problems.</p><p>The advantage of Milner's method and our method is that itreduces the problems to purely mathematical domain so that we canapply various formula manipulation algorithms, without consideringthe execution order or side-effects. Another advantage is thatthese methods can handle functions with polymorphic types.</p><p>In section 2 we review earlier work on type inference. The briefintroduction of the syntax and the semantics of Smalltalk is donein section 3. Then we introduce the \"types\" into Smalltalk insection 4. We discuss the first part of our algorithm, how toextend LCF type checking algorithm for liberal unions of types, insection 5. Then in section 6 the whole algorithm is presented.Section 7 is concerned with the implementation and experience.</p><p>Smalltalk has four major different versions of the language andimplementations. The version we used for our experiments isSmalltalk-76.</p>", "authors": [{"name": "Norihisa Suzuki", "author_profile_id": "81332530584", "affiliation": "Xerox Palo Alto Research Centers, Palo Alto, CA", "person_id": "PP43124867", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567532.567553", "year": "1981", "article_id": "567553", "conference": "POPL", "title": "Inferring types in Smalltalk", "url": "http://dl.acm.org/citation.cfm?id=567553"}