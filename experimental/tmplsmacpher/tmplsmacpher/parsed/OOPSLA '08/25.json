{"article_publication_date": "10-19-2008", "fulltext": "\n The VISITOR Pattern as a Reusable, Generic, Type-Safe Component BrunoC.d.S.Oliveira,MengWang, andJeremyGibbons \nOxfordUniversityComputingLaboratory WolfsonBuilding,ParksRoad,OxfordOX13QD,UK {bruno.oliveira,meng.wang,jeremy.gibbons}@comlab.ox.ac.uk \nAbstract The VISITOR design pattern shows how to separate the structure of an objecthierarchyfromthebehaviouroftraver\u00adsals \noverthathierarchy.Thepatternis very.exible;this very .exibilitymakesitdif.cultto capturethepattern as \nanything moreformalthanprose,pictures andprototypes. We show how to capture the essence of the VISITOR \npattern as a reusable software library, by using advanced type system features appearing in modern object-oriented \nlanguages such as Scala. We preserve type-safety statically and modularly:no re.ection or similar mechanisms \nare used and modules canbe independently compiled.Thelibraryis generic, in two senses: not only is it \nparametrised by both the returntype andthe shape ofthe objecthierarchy,but also it allowsa numberofimplementationchoices(internal \nver\u00adsus external control,imperative versusfunctionalbehaviour, orthogonal aspects such as tracing and \nmemoisation) to be speci.edbyparametersratherthan .xedinearlydesignde-cisions.Finally, wepropose ageneralised \ndatatype-like no\u00adtation, on top of our visitor library: this provides a conve\u00adnientfunctionaldecompositionstylein \nobject-orientedlan\u00adguages. Categories and Subject Descriptors D.2.13 [SoftwareEn\u00adgineering]: Reusable \nSoftware Reusable libraries; D.3.2 [ProgrammingLanguages]:LanguageClassi.cations Object\u00adorientedlanguages,Applicative(functional)languages,Mul\u00adtiparadigm \nlanguages; D.3.3 [Programming Languages]: Language Constructs and Features Recursion, Patterns, Data \ntypes andstructures General Terms Languages,Design Keywords DesignPatterns,VisitorPattern,SoftwareCom\u00adponents,ProgramExtensibility,AlgebraicDatatypes,Traver\u00adsal \nPermission to make digital or hard copies of all or part of this work for personal or classroomuseisgranted \nwithoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonserversortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. OOPSLA 08 October19 23,2008,Nashville,Tennessee,USA. \nCopyright c &#38;#169; 2008ACM978-1-60558-215-3/08/10. . .$5.00 1. Introduction A software component \nis, generally speaking, a piece of software that can be safely reused and .exibly adapted by some other \npiece of software. Safety can be ensured, for example, by a type system that guarantees correct usage; \n.exibility stems from making components parametrizable overdifferent aspects affectingtheirbehaviour. \nComponent\u00adoriented programming (McIlroy, 1969), a programming stylein which softwareis assembledfromindependentcom\u00adponents,hasfor \nalongtimebeen advocated as a solution to the so-called software crisis (Naur andRandell,1969). WhileMcIlroy \ns vision was warmlyreceived,the truthis that to date that vision has not been fully realised, largely \ndue to limitations of current programming languages. For example, the majority of languages have a bias \ntowards one kind of decomposition of software systems, which im\u00adposesa correspondingbias onthekindsofextensibility \navail\u00adable: somelanguagesfavour object-orienteddecomposition (where adding new variants is easy), while \nothers favour functional decomposition (where adding new functions is easy).Extensibilityisimportantforthedevelopmentofcom\u00adponents(Szyperski,1996),yet \nthebiasimposedby alan\u00adguage makesithardtodevelop components that require the dual kind of extensibility. \nA related problem is what Tarr etal.(1999) call thetyranny ofthedominantdecomposi\u00adtion : when software \ncanbe modularized alongjust onepri\u00admarydimensionat atime,concernsthatdonotbreakdown naturally along that \ndimension will be scattered across the dominant structure and entangled with other concerns. For another \nexample, certain software designs seem to be hard to capture more abstractly as software components.Thisis \nthecaseformostof the Gang ofFour (GoF)design pat\u00adterns (Gamma et al., 1995), the structure of which cannot \nbe expressedmoreprecisely thanin terms ofprose,pictures andprototypes. Our .rstcontributioninthispaperistoshowthat,withthe \nmodern expressivetype systems startingto appearin object\u00adorientedlanguages, we caninfact capture(atleast \nthe struc\u00adtural aspects of) the VISITOR designpattern(Gamma et al., 1995)as ageneric andtype-safevisitor \nsoftware component. Moreover,itispossible to capture a number ofvariations on thepatternwithinoneparametrizablecomponent \nspecif\u00adically, we can supportthefollowingdesigndecisions: who is responsible for traversing the object \nstructure? (Gammaetal.,1995) theoperationortheobjectstruc\u00adtureitself?  is the visitor imperative (withresults \nof traversals stored as mutable statein the visitor) or functional(withresults returnedby the accept \nmethod)?  does the visitor satisfy certain orthogonal concerns such as tracing or caching of computations? \n Insteadof committingto aparticulardecision at thetime we design a visitor, as wouldbe necessary with \ntheinformally\u00adexpressed VISITOR pattern, we can de.ne a single visitor thatpostponesallofthesedesigndecisionsbyallowingthem \ntobe speci.edbyparametrization. Our component is implemented in the Scala program-minglanguage(Odersky,2006) \nandits type safetyis stat\u00adically guaranteed by the modular type system. The Scala features that make \nthis possible are parametrization by type (or generics, as found in recent version of Java or C#) and \nabstract types (althoughtype-constructorpolymor\u00adphism (Cremet and Altherr, 2008) could be used instead). \nAsfar as we are aware, allexisting solutionsintheliterature trying to capture some notion ofgeneric visitors(Palsberg \nandJay,1998;Visser,2001; Orleans andLieberherr,2001; Grothoff,2003;Forax etal.,2005;Meyer andArnout,2006) \nmake use of re.ection, introspection or metaprogramming mechanismsthatdo notstaticallyguaranteetype-safety.Fur\u00adthermore, \nmost of those solutions only capture particular variants ofthepattern. Oursecond contributionis a semanticsfor \nageneralised algebraic datatype notation using visitors built with our li\u00adbrary.The notation allows ustode.neparametric, \nmutually\u00adrecursive and existential visitors, being comparable in ex\u00adpressive power to Haskell 98 and \nML-style datatypes. It alsointegrates well withobject-orientedlanguages,allowing both datatypes and data-constructors \nto override or de.ne new .elds and methods. Furthermore, it generalises tradi\u00adtionalalgebraicdatatypes,inthe \nsensethatboththetraversal andthedispatchingstrategies areparametrizable.Webelieve thatthis notationispracticaland \ncan signi.cantly reducethe burden ofexpressingfunctionaldecompositionin an object\u00adorientedlanguage. \n1.1 Overview Section 2 introduces the VISITOR design pattern, and the problemsitinduces.InSection3, wepresent \nour visitorli\u00adbrary from a programmer s perspective, and informally in\u00adtroducethedatatype notation.Section4 \nreviewsthe work of BuchlovskyandThielecke(2005) relatingthe VISITOR pat\u00adtern tolambda calculus encodings \nofdatatypes, and extends this work to obtain generic encodings of datatypes that are parametricin the \ntraversal strategy.InSection5, we exploit these developments in a highly generic library of visitors \nwritteninScala.InSection6,wepresentaformaltranslation between the datatype notation and visitors de.ned \nwith the visitorlibrary.Finally, adiscussion ofthe results and related workispresentedinSection7, and \nconclusionsinSection8. 2. The VISITOR as a Design Pattern Inthis section we reviewthetraditionalpresentationof \nthe VISITOR pattern(Gammaet al.,1995),anddiscuss some problemsitpresents.Wehastento emphasizethatinthispa\u00adper \nwe are onlyreallytalking aboutthe structural aspects of thedesignpattern, andnotanyofthe otherimportantaspects \nsuch asthemotivating story orexamplecode.Having said that, wedobelievethat wehave capturedthe mostimportant \nstructural variationsin theimplementation of thepattern. 2.1 The VISITOR Pattern The VISITOR design \npattern is an alternative to the normal object-oriented approach to hierarchical structures, separat\u00adingthe \noperationsfrom the object structure, and thus allow\u00ading the extension of the former without changing \nthe latter. Moreover,the VISITOR keeps relatedaspects of a single op\u00aderationtogether,byde.ningthemin \na single class.Figure1 showsthe class structure ofthepattern.Theparticipants col\u00adlaborate asfollows: \n the Visitor interface declares a visit method for each ConcreteElement type;  each ConcreteVisitor \nclass implements a single opera\u00adtion,de.ningthevisit methodfor each ConcreteElement;  theElementabstractsuperclassdeclaresthe \naccept method, taking a Visitor as argument;  each ConcreteElementsubclassde.nesthe accept method to \nselect the appropriate visit methodfrom a Visitor.  In contrast to the standard object-oriented decomposi\u00adtion, \nepitomisedby the COMPOSITE pattern(Gamma et al., 1995), and like a functional decomposition, the VISITOR \npattern makes it easy to add new operations at the cost of making it dif.cult to add new variants. One \ncan see the pattern as a way of simulating double dispatch in a single\u00addispatch language: the method \nimplementation chosen de\u00adpends on the dynamic types of both the ConcreteElement andthe ConcreteVisitor. \n 2.2 Imperative and Functional VISITORs In the traditional presentation of the VISITOR pattern, the \nvisit and accept methods return no result; any value com\u00adputedbythe visitoris storedin the visitorforlater \nretrieval. An alternative is for the visit and accept methods to re\u00adturn the value directly. Borrowing \nsome terminology from Buchlovsky andThielecke(2005), we usetheterm imper\u00adative visitor for one that has \nvisit and accept methods that return void, with all computations executed through side\u00adeffects, accumulating \nresults via mutable state; in contrast,  Figure 1. The VISITOR designpattern a functional visitor isimmutable,all \ncomputationsyielding their results throughthe return values of the visit and accept methods, which arepure. \n 2.3 Internal and External VISITORs In their presentation of the VISITOR pattern, Gamma et al. (1995) \nraise the question of where to place the traversal code:inthe object structureitself(inthe accept methods), \norinthe concrete visitors(inthe visit methods).Buchlovsky andThielecke(2005) use the term internal visitor \nfor the former approach, and external visitor for thelatter. Internal visitors are simpler to use and \nhave more interesting alge\u00adbraicproperties,butthe .xedpatternof computationmakes themless expressivethan \nexternal visitors. Figure 2 shows examples of the two variations, using functional-style VISITORsinScala.Inboth \nvisitors,thetrait Tree and the classes Empty and Fork de.ne a COMPOSITE (Emptyrepresents aleaf, and Forka \ncompositionoftwo sub\u00adtrees).Usingthe visitorterminology,Treeistheelementtype and Empty and Fork are the \nconcrete elements.The method accept,de.nedin Tree andimplementedinthetwo concrete elements, takes a TreeVisitor \nobject with two visit methods, onefor each concrete element.This whole system of classes de.nes aninstance \nof the VISITOR pattern.Unlike with the traditional presentation of the VISITOR, the parameters of the \nconstructors are fed directly into the visit methods in\u00adstead ofpassingthe whole constructedobject.Parametrizing \nthevisit methodsinthis waygivesafunctionalprogramming feelwhen using visitors. Operations on trees are \nencapsulated in ConcreteVisitor objects. For example, an external visitor to compute the depth of a binary \ntree explicitly propagating itself to subtrees isde.nedasfollows: object Depthextends TreeVisitor[int] \n{ def empty = 0 def fork(x:int, l:Tree, r:Tree)= 1+ max (l.accept (this), r.accept (this)) } De.ning \nvalues of type Tree bene.ts from Scala s case class syntax, which avoids some uses of the new keyword. \nTo use a ConcreteVisitor, we need topassit as aparameter to the accept method of a Tree value.As a simpleexample, \nwede.ne a method test to computethedepthof a smalltree. val atree = Fork (3, Fork(4, Empty, Empty), Empty) \ndef test = atree.accept (Depth) Internal Visitors trait Tree { def accept[R](v:TreeVisitor[R]) :R } case \nclass Emptyextends Tree { def accept[R](v:TreeVisitor[R]) :R= v.empty } case class Fork (x:int, l:Tree, \nr:Tree) extends Tree { def accept[R](v:TreeVisitor[R]) :R= v.fork(x, l.accept (v), r.accept (v)) } trait \nTreeVisitor[R] { def empty:R def fork(x:int, l:R, r:R) :R } External Visitors trait Tree { def accept[R](v:TreeVisitor[R]) \n:R } case class Emptyextends Tree { def accept[R](v:TreeVisitor[R]) :R= v.empty } case class Fork (x:int, \nl:Tree, r:Tree) extends Tree { def accept[R](v:TreeVisitor[R]) :R= v.fork(x, l, r) } trait TreeVisitor[R] \n{ def empty:R def fork(x:int, l:Tree, r:Tree) :R } Figure 2. InternalandExternal VISITORsforBinaryTrees \n 2.4 The Class Explosion As is the case with most design patterns, the VISITOR pat\u00adternpresents theprogrammer \nwith a number ofdesigndeci\u00adsions.An obviousdimensionof variationfollowstheshape of the object structure \nbeing traversed: the Visitor interface forbinary trees willdifferfromthatforlists.Wehavejust discussedtwo \notherdimensions ofchoice:imperative versus functional behaviour, and internal versus external control. \nAfourthdimension captures certain cross-cutting concerns, such as tracing of execution and memoization \nof results. Handled na\u00a8ively, this .exibility introduces some prob\u00adlems. For one thing, capturing each \ncombination sepa\u00adrately leads to an explosion in the number of classes: ImpExtTreeBasicVisitor for imperative \nexternal tree visi\u00adtors, FuncIntTraceListVisitor for functional internal tracing list visitors, and so \non. Secondly, the dependency on user\u00adsuppliedinformation(the shape of the object structure)pre\u00advents \nthese classesfrombeingprovidedin alibrary.Finally, because the variations have different interfaces, \nthe choice betweenthemhastobemadeearly,andisdif.cultto change. All three of these problems can be solved, \nby specify\u00ading the variationbyparametrization.The main contribution of this paper is the provision of \na generic visitor compo\u00adnent, parametrizable on each of these dimensions: shape (of object structure), \nresult type (hence imperative versus functional),strategy(internal versus external), and concern (cross-cutting). \n3. Programming with the Visitor Library In this section wepresent aprogrammer s view of theScala visitor \nlibrary, showing how it can avoid the early design decisionsimposedbythedesignpattern approach. 3.1 A \nDatatype Notation for Visitors Inspiredbydatatypedeclarationsfromfunctionalprogram\u00adminglanguages,weintroducea \nsuccinct data-like notation as syntactic sugarforthe actual visitorlibraryinScala, with\u00adout compromising \nclarity and expressiveness. We present this notation informally in this section; a formal account is \npresentedinSection6. Consider the following Haskell (Peyton Jones, 2003) datatypede.nition: data Tree= \nEmpty | ForkIntTreeTree An equivalentde.nitionin ourdata notationis: data Tree { constructor Empty constructor \nFork(x:int, l:Tree, r:Tree) } Thefollowingtablepresentsthe correspondencebetween the conceptsin our \nvisitorlibrary and thetraditionalVISI-TOR pattern notation. Librarynotation VISITOR terminology data \nT Element constructor Concrete Element (D)CaseT Visitor V extends (D)CaseT Concrete Visitor new (D)CaseT \nAnonymous Concrete Visitor The traits (D)CaseT aregeneratedfrom thedatatypede.ni\u00adtions. For the tree \nexample, this means that we would have DCaseTree and CaseTree traits. Generalized data notation We make \nour data notation more amenable to object-oriented programming by gener\u00ad data Nat { val intValue:Int \nconstructor Zero { val intValue= 0 } constructor Succ(n:Nat) { val intValue= 1+ n.intValue } override \ndef toString () :String= this.accept ( new CaseNat[Internal, String] { def Zero = \"Zero\" def Succ(n:String)= \n\"Succ(\" + n+ \")\" }) override def equals (x:Any) :boolean= x match { case m:Nat .intValue.equals (m.intValue) \ncase .false } override def hashCode() = intValue.hashCode() } Figure 3. Usingthegeneralizeddata notationtode.ne \nNat. alizingit sothatdatatypescande.neand overridemethods and values,in the same way as classes or traits.InFigure3, \nwede.ne a new Natdatatypethatusesthisgeneralizednota\u00adtion;it overridesthe toString, equals and hashCodemethods \nandde.nes a val intValuethatisimplementedbyeach ofthe constructors. 3.2 Traversal Strategies and the \nFunctional Notation While conventional datatypes normally use case analysis or pattern matching to decompose \nvalues, visitors have a choice of traversal strategies: internal and external. Case analysis andpatternmatching \nare aformof thelatter.Con\u00adsider,for example, ade.nition ofthe depthfunction ontrees inHaskell: depth::Tree.Int \ndeptht = case t of Empty .0 Forkxl r .1+ max (depthl)(depthr) This corresponds,in ourlibrary,to: def \ndepth1 = new CaseTree[External, int] { def Empty= 0 def Fork (x:int, l:R[TreeVisitor], r:R[TreeVisitor]) \n= 1+ max (l.accept (this), r.accept (this)) } Here, depth1 de.nes a new anonymous concrete visitor on \nTree using the CaseTree visitor trait. The External type ar\u00adgument of CaseTree selects the external traversal \nstrategy, which allowstheprogrammerto explicitly drivethetraver\u00adsalthroughthe accept methods.The int \ntype argumentspec\u00adi.es the return type of the visit methods Empty and Fork. R[TreeVisitor] is a typedependenton \nthe traversal strategy; in the case of external visitors, it is effectively a type syn\u00adonymfor the Tree \ncomposite1.For the remainder of thepa\u00adper, for clarity, we will use the composite type directly in\u00adsteadfor \nspecifyingthe recursivetypesfor external visitors. Functional Notation Calling the accept method repeat\u00adedly \nis awkward.InScala,functionsare objects, so we can use a functional notation by making visitors a subclass \nof functions with composites as arguments.With this notation, depth1 canberewrittenasfollows,which nicely \nre.ectsthe recursive nature of thede.nition: def depth2 = new CaseTree[External, int] { def Empty = 0 \ndef Fork(x:int, l:Tree, r:Tree)= 1+ max (depth2 (l), depth2 (r)) } Internal Visitors In the de.nitions \nof depth1 and depth2 the particular traversal strategy used is parametrized on the concretevisitorinstead \nofbeing.xedby thevisitorcompo\u00adnent.Thisis a major advantage of our visitorlibrary overthe traditional \ndesign pattern interpretation: we do not need to commitin advanceto aparticular strategy whendesigning \na new visitor. For example, instead of using external visitors tode.ne the depth functions, we couldhave \nusedinsteadan internalvisitor: def depth3 = new CaseTree[Internal, int] { def Empty = 0 def Fork(x:int, \nl:int, r:int)= 1+ max (l, r) } Sinceinternalvisitors use traversal strategiesdeterminedby the elements, \nthe above de.nition does not require explicit traversal of the structure, sois simpler tode.ne.In the \ncase ofinternal visitors, R[TreeVisitor] isjustatype synonymfor int, which we use togive the typesfor \nl and r. 3.3 Advice and Modular Concerns Having explicit control over traversal gives us the capabil\u00adity \nof decoupling non-functional concerns from base pro\u00adgrams into localized modules and invoking them at \neach stepofrecursion.Inspiredby Aspect-OrientedProgramming (AOP)(Kiczales et al.,1997), weterm suchlocalizednon\u00adfunctionalconcerns \nadvice2.Consider thefollowing(na\u00a8ive) version of theFibonaccifunctionde.ned over Nat. 1Unfortunately, \nfor external visitors, Scala does not allow us to write def (x:int, l:Tree, r :Tree) directly(webelieve \nthis maybe abug). 2In contrast to the pointcut mechanism in AOP, our advice is installed by parametrization.Weleave \nadetailed comparisontoSection7. def .b1 = new CaseNat[External, int] { def Zero = 0 def Succ(n:Nat)= \nn.accept ( new CaseNat[External, int] { def Zero = 1 def Succ(m:Nat)= .b1 (n)+ .b1 (m) }) } Though straightforward, \nthe above de.nition has exponen\u00adtial time complexity. One way around this is memoization (Michie, 1968), \nwhich involves caching and reusing the computed results.Memoizationis anorthogonal concernto thebase \ncomputation, and cross-cuts (Kiczales et al.,1997) different functions, so is likely to become entangled \nwith thosefunctions. Ourvisitorlibraryoffersawaytooverthrowthis tyranny of the dominant decomposition \n: it allows parametrization by dispatching, which can be used to introduce advice like memoization.In \nordertobene.tfromthis additionalpower, we explicitlyparametrize .b bythedispatchingbehaviour: def .b2 \n(d:Dispatcher[NatVisitor, External, int]) = new DCaseNat[External, int](d) { def Zero = 0 def Succ(n:Nat)= \nn.accept ( new CaseNat[External, int] { def Zero = 1 def Succ(m:Nat)= .b2 (d)(n)+ .b2 (d)(m) }) } Instead \nof CaseNat, we use the more general DCaseNat,a visitor parametrized by a Dispatcher (a type de.ned in \nthe library, explained in detail in Section 5). The .b2 function nowtakes an extra value argumentthatdeterminesdispatch\u00adingandpassesittothe \nconstructor of DCaseNat.Weinclude several commonly used pieces of advice in the library, and provide \ntemplates for user-de.ned new ones. We discuss a few ofthembelow. Basic the simpledispatcher, whichde.nes \nthedefault behaviour ofa visitor;  Memo memoization of results;  Advice atemplateforde.ning newdispatchers, \nwhich hasbeforeand after methodsthataretriggeredbeforeand after calls;  Trace tracing a computationbyprinting \nout theinput and output,implemented using Advice as template.  More than one piece of advice can be \ndeployed at the same time by composing them together. The special Basic dispatcheris atomicandis used \nastheunit of composition. Here are afewpossibleinstantiations of.b2: def n.b = .b2 (Basic) def m.b = \n.b2 (Memo(Basic)) def tm.b = .b2 (Trace(Memo(Basic))) def mt.b = .b2 (Memo(Trace(Basic))) Theprogramn.b \nis equivalentto.b1, while m.b is a ver\u00adsion with memoization.Theprograms tm.b and mt.b com\u00adbinetracing \nand memoizationindifferent ways: whileboth programs return the same output for any given input, the trace \nwrittentothe consoleisdifferent.In ourlibrary,the or\u00addering of adviceisdeterminedby the order of composition. \nIntm.b, TraceistriggeredbeforeMemo, whichprints outall callsincluding those resorting to memoization.On \nthe other hand, mt.b only prints out traces that do not involve mem\u00adoization, as Memo (whichcanbe seen \nas an around advice) takesprecedence and maybypass the tracing. 3.4 Imperative Visitors TheGoFpresentation \nofthe VISITOR patterndiscussesboth internal and external imperative visitors; the emphasis is on the \ninternal variant, with external visitors being recom\u00admendedfor advanceduses(wherethe recursion schemedoes \nnot .ttheinternal variant).Asitturnsout,imperativevisi\u00adtorsarea special case offunctional visitors,with \nthereturn type set to void (orUnit, in Scala). For example, consider adding all theintegersin sometree, \nusing animperative vis\u00aditor that accumulatesthe value of the sumin a mutable vari\u00adable.Using an internal \nvisitor, we could write thatprogram inScala as: class AddTree1 extends CaseTree[Internal, Unit] { var \nsumValue = 0 def Empty = {} def Fork(x:int, l:Unit, r:Unit)= {sumValue += x;} } We could also write an \nimperative external version of the visitor as: class AddTree2 extends CaseTree[External, Unit] { var \nsumValue = 0 def Empty = {} def Fork(x:int, l:Tree, r:Tree)= {this (l);this (r);sumValue += x;} } Inthis \ncase, we need to explicitly traversethe structure,by applyingthe visitortothe composites(rememberthat \nthis (l) is equivalent to l.accept (this)). The imperative visitors are used asfollows: def test:int= \n{ val addTree = new AddTreen (); val tree1 = Fork(3, Empty(), Empty()); val tree2 = Fork(4, tree1, tree1); \n addTree (tree2); return addTree.sumValue; } Here, AddTreen should be replaced by either AddTree1 or \nAddTree2. The program creates a new instance addTree of AddTreen,de.nesthe value tree2, applies addTree \ntoit, then returnsthevalueaccumulatedby the visitortraversalinthe variable sumValue. 3.5 A Simple Form \nof Multiple Dispatching As we mentionedinSection2.1,theVISITOR pattern sim\u00adulatesdoubledispatching in \na single-dispatchinglanguage. The use of nested external visitors allows us to go further, and simulate \nmultiple dispatching. For example, we could de.nea modularly type-safe(inthe sensethat no casts and no \nglobal analysis are required) equality function by using this nesting technique. Figure 4 shows an implementation; \nthe method takes two trees as arguments, performs a case analysis(using an external visitor) on one of \nthe trees, then in both the Empty and Fork cases, performs a case analysis on the othertree. Notethat \nthis version ofequality requirestripledispatch\u00ading,because the methodis de.nedin some object A, which \nis used to dynamically determine the implementation of equal, and the two tree arguments need to be dynamically \ninspected. We could, of course, have de.ned a version of equalitythatwouldonlyrequiredoubledispatching,byplac\u00ading \nthe method equal in Tree and taking another Tree as an argument. While this technique can be used to \nemulate a form of multipledispatching,theprograms start sufferingfrom read\u00adabilityissues,duetothe nestingofvisitors.Similarproblems \noccur in functional programming languages, when multi\u00adple nested case analyses are used. To alleviate \nthese, many of those languages introduce pattern matching as syntactic sugar ontopofcase analysis, allowingade.nitionlike \nequal tobe written asfollows: equal::Tree.Tree.Bool equalEmpty Empty = True equal (Fork xl1 r1)(Forkyl2 \nr2)= x =y.equall1 l2 .equal r1 r2 equal = False Supportforpattern-matchingcouldbebuilt on top of exter\u00adnal \nvisitorsin essentially the same way thatitisbuilt on top of case analysisin mostfunctionalprogramminglanguages; \nweleave thedetails of such an extensionforfuture work.  3.6 Parametrized and Mutually Recursive Visitors \nThe expressiveness of our library extends to parametrized and mutually recursive visitors. An example \nis forests and trees: data Tree[a] { constructor Fork(x:a, f :Forest[a])  def isEmpty= new CaseTree[External, \nboolean] { def Empty = true def Fork(x:int, l:Tree, r:Tree)= false } def equal (t:Tree) :Tree.boolean= \nnew CaseTree[External, boolean] { def Empty = isEmpty(t) def Fork(x:int, l1:Tree, r1:Tree)= t.accept[External, \nboolean]( new CaseTree[External, boolean] { def Empty= false def Fork(y:int, l2:Tree, r2:Tree)= x =y.equal \n(l1)(l2) .equal (r1)(r2) }) } Figure 4. A type-safe equalityfunction usingExternalVis\u00aditors. } data Forest[a] \n{ constructor Nil constructor Cons(t:Tree[a], f :Forest[a]) } Trees, oftype Tree[a],have one constructor \nFork thatbuilds a tree containing one element of type a and aforest;forests, of type Forest[a], have \ntwo constructors Nil and Cons that construct empty and non-empty collections of trees. We couldde.ne \nafunction to sum all theleaves of a tree ofintegers asfollows: def sumTree = new CaseTree[Internal, int, \nint] { def mrefForest = sumForest def fork(x:int, xs:int)= x+ xs } def sumForest = new CaseForest[Internal, \nint, int] { def mrefTree = sumTree def nil = 0 def cons (x:int, xs:int)= x+ xs } Due to the mutually \ndependent nature of the two visitors, afunctionthattraverses onemustknowof a corresponding functiononthe \nother.Forthis reason, mutuallyrecursivevis\u00aditorscontain .elds referring tothe visitorsthattheydepend \non.We name such.elds mrefForest and mrefTree (thedetails are explained in Section 6). Additionally, for \nparametrized typeslikeTree[a],typearguments(suchas a)are alsopassed as argumentsto CaseTree. Church Encodings \nNat =.A. (A.A) .A.A zero .Nat zero =.s z .z succ .Nat .Nat succ n =s z .s (n s z) Tree =.A. A.(Nat .A.A.A) \n.A empty .Tree empty =.e f .e fork .Nat .Tree.Tree.Tree forkxl r =.ef .fx(lef)(ref) Parigot Encodings \nNat =.A. (Nat .A) .A.A zero .Nat zero =.s z .z succ .Nat .Nat succ n =.s z .s n Tree =.A. A.(Nat .Tree.Tree.A) \n.A empty .Tree empty =.e f .e fork .Nat .Tree.Tree.Tree fork xl r =.ef .f xlr Figure 5. Encodings ofnaturals \nandbinarytrees. 4. Visitors as Encodings of Datatypes Inthis section, welook atthe relationshipbetween \nvisitors and encodings of datatypes, and introduce the theoretical foundations for the Scala visitor \nlibrary presented in Sec\u00adtion5. 4.1 Encoding Datatypes in the Lambda Calculus The pure lambda calculus \nhas no notion of datatypes; they havetobe encoded usingfunctions.Church(1936) showed how to encode the \nnatural numbers via repeated function composition:thenumber0isrepresentedby zero-foldcom\u00adposition ,thenumber1by \none-foldcomposition ,thenum\u00adber2by two-fold composition ,and soon. zero =.f ..x .x succ =.n ..f ..x .f \n(nf x) Muchlater,B\u00a8ohm andBerarducci(1985) demonstrated precise typings of such encodings in System F. \nThe name Churchencoding is normallyassociated withB\u00a8ohm andBe\u00adraducci s System F encoding. Church encodings \nallow us to write iterative de.nitions. A less well-known encoding is the Parigot encoding (Parigot,1992),whichallows \nusto write recursive de.nitions, but requires System F to be ex\u00adtended with recursion.Splawski andUrzyczyn(1999)give \nprecisede.nitions ofiteration versus recursioninthis sense; we shall notdiginto thedetailsin thispaper. \nFigure 5 shows the Church and Parigot encodings of naturals and treesin aSystem-F-like calculus extended \nwith recursion. For Church encodings, the types Nat and Tree are not recursive:the constructorstraversethe \nstructure, and the functions that form the basis of those two types only need to process the results \nof those traversals. In contrast, withParigot encodings,the constructorsdonottraversethe structure;therefore,thefunctionsthatrepresent \nNatand Tree needtode.nethetraversalthemselves.This requiresthatthe types of those functions recursively \nrefer to Tree and Nat, whichcan onlybe achievedif we allow recursivetypes.Note that the internal and \nexternal visitors presented in Figure 2 correspond very closely to, respectively, the Church and Parigot \nencodingsfor trees(although we use Nat instead of int here). 4.2 Generic Visitors: Shape Abstraction \nWe are not the .rst to realize that visitors are related to en\u00adcodings ofdatatypes;infact,ithasbecomefolkloreknowl\u00adedge \namong some communities.Buchlovsky andThielecke (2005), in work directed to the type-theory community, \nformalized the relation between visitors and encodings of datatypespreciselyand showed a single shape-generic \nform of the encodings. The traditionalpresentation of encodings ofdatatypesin SystemF(and commonvariants)(Girard \net al.,1989)is of theform: T =.X. (FR.X) .X where the operation on types F speci.es the shape of the \ndatatype.Typically,FR takes theform of a sum ofproducts SiFiR, a collection of variantsin whicheach FiRis \na simple productof types; so the encodingis equivalentto T =.X. ((Si Fi R) .X) .X Now, the type (Si Fi \nR) .X offunctionsfrom a sumisiso\u00admorphic to the type .i (Fi R.X) ofproducts offunctions y+zy (in the \nsame waythat x= x\u00d7xz);so another equivalent encodingis: T =.X. (.i (Fi R.X)) .X BuchlovskyandThielecke(2005)point \nout that this clearly relates the datatype T with the type of its accept method .X. (.i (Fi R . X)) . \nX: the latter can be read, for some result type X, as taking a visitor of type .i (Fi R . X) and yielding \na result of type X; the visitor itself is just a collection offunctions of theform Fi R.X, eachbeing \nthe visit methodfor one variantof thedatatype,with argument vector Fi R. Church andParigot encodings \ncorresponding,respec\u00adtively, to internal and external visitors follow from two NatFRA=(A, R.A) Nat =InternalNatF \nzero .Nat zero =.(z, s) .z succ .Nat .Nat succ n =.(z, s) .s (n (z, s)) Figure 6. Church encoding of \nPeano numerals usingprod\u00aducts offunctions speci.c instantiations of R. For reference, de.ne operation \nV byVRX =.i (Fi R.X). Genericinternalvisitorsare obtainedbyspecializing R= X;we cande.ne InternalV =.X.VXX \n.X Generic external visitors are obtained by specializing R=ExternalV;we cande.ne ExternalV =.X.V (ExternalV) \nX .X In each case, V is a typeparameter abstracting over con\u00adcrete visitor components.It couldbe saidthat \nV is theshape parameter of the encodings, sincedifferentinstantiations of V willlead todifferentdatatypes. \n 4.3 Generic Visitors: Traversal Strategy Abstraction Generic encodingsbasedonproducts offunctions allow \none to abstractfromdifferencesinthe shape ofdata and model different traversal strategies internal and \nexternal of datatype-generic visitors. Still, there is substantial duplica\u00adtion ofcode wheneverwe wanttohavebothstrategies.How\u00adever, \nthisduplication canbe avoided: we can model visitors that aregenericinboth the shape and the traversal \nstrategy. The template CompositeV =.X. VRX .X could be used to capture different implementations of the \nVISITOR patternbyusing aproperinstantiationfor R.How\u00adever,thisde.nitionis not validinSystemF,because \nRis un\u00adbound; some other approach is needed. Since R represents the type of recursive occurrences that \nappear in the visit methods, if we want to capture both internal and external visitors, Rshoulddepend \nonboth V and X.Thisdependency can be made explicit by having R = SVX and binding S universally. CompositeV \n=.SX. V (SVX) X .X We shall referto S as the traversal strategy. AlthoughCompositeV is nowavalidSystemFde.nition, \nitis stillnotright.To see whattheproblemis,let s .rst refor\u00admulate the Church Peano numerals using products \nof func\u00adtions, as in Figure 6. When we try to use Composite NatF instead of InternalNatF, there are no \nproblems in de.ning the constructor zero; however for succ, it is impossible to provide a value ofthe \nright type: Nat =CompositeNatF zero .Nat zero =.(z, s) .z succ .Nat .Nat succ n =.(z, s) .s ? s requires \nan argument with type SVX, and we cannot create any values of that type.The solutionfor thisproblem consists \nin adding some extra information about S in the de.nition ofComposite. CompositeV =.XS. DecomposeS.V \n(SVX) X .X The extra information is given by Decompose S, which is basicallyjust atype-overloaded(inthetype-parameter \nS) method.In otherwords,theimplementationof this method can be determined solely from the type S and, \ntherefore, made implicit. Referring to the method in DecomposeS as decS, wehavethat: decS .V (SVX) X \n.CompositeV .SVX The operationdecS solves theproblem ofproducing a value of type SVX, and allows us to \nde.ne the constructor succ as: succ .Nat .Nat succ n =.(z, s) .s (decS (z, s) n) Note that theDecomposeS \nparameterisimplicitlypassed. In order tode.ne new strategies, we needtode.ne some concrete type S and \nthe corresponding decS operation. For example,to makeinternalandexternalvisitorstwoinstances of CompositeV, \nwe specialize S to Internaland External: InternalV X =X ExternalV X =CompositeV Here we reusetheidenti.ersInternaland \nExternalto referto the associatedtraversalstrategies.The speci.cinstantiations of decS forinternaland \nexternal visitors are: decInternal .(V (InternalV X) X) .CompositeV . InternalV X decInternal v c =cv \ndecExternal .(V (ExternalV X) X) .CompositeV . ExternalV X decExternal v c =c In thede.nition of decInternal \nthe reader should(again) note that the Decompose S parameter is implicitly passed and, therefore, the \ncomposite c just needs to take the visitorv as an argument.With decExternal, we simply ignore the visitor \nparameter and return the composite itself. This allows the use of the composite directly in the de.nitions \nof the visit methods. 5. A Scala Library for Visitors In theprevious section, we used theChurch andParigot \nen\u00adcodings of datatypes to motivate a notion of visitors that is genericin twodimensions:in the shape \nofthedata structure being visited, and in the strategy for assigning the respon\u00adsibility of traversal. \nArmed with this insight, we will now present an implementation in Scala of a generic visitor li\u00adbrary. \nWe use the resultsfromSection4.3as afunctional speci\u00ad.cationfor ourScala visitorlibrary.Thetranslationfromthe \nfunctionalspeci.cationinto aScala componentis relatively straightforward, although some typings vary \nslightly due to thedifferencesbetweenSystemF-likelanguages andScala. We startbyrecalling thede.nition \nof Composite, and anno\u00adtateitwith extrainformationidentifying the accept method and the visitor component. \naccept method -'A v CompositeV =.XS. DecomposeS.V (SVX) X .X A v-' Visitor In order to implement the \ndifferent components present in the functional speci.cation we will make extensive use of generics(parametrizationbytypes)andabstracttypes(Oder\u00adsky,2006), \nwhichprovide a means to abstract over concrete types usedinside a class ortraitdeclaration.Abstracttypes \nare usedtohideinformation aboutinternals of a component, in a waysimilartotheir useinSML(Harper andLillibridge, \n1994) and OCaml (Leroy, 1994). They are considered by OderskyandZenger(2005b)tobe essentialforthe construc\u00adtion \nof reusable components; they allowinformationhiding overseveral objects, akeypart of component-orientedpro\u00adgramming(P.ster \nandSzyperski,1996). Alternatively to abstract types, we couldhave used type\u00adconstructor polymorphism \n(Cremet and Altherr, 2008) in\u00adstead. A Haskell solution that exploits this approach is showninOliveira(2007).SinceScala \nnow supportstype\u00adconstructorpolymorphism(Moors et al.,2007), a solution using such an approach should \nalso be possible. However, as discussed by Oliveira, abstract types seem to be more expressive than type-constructor \npolymorphism alone, and allowthede.nition of a slightly moregeneral visitorlibrary. Visitors and the \nFunctional Notation The Visitor compo\u00adnentin thelibrary, which capturesthe shape ofthe type V in thefunctionalspeci.cation,hastwo \nabstracttypes: S (repre\u00adsenting the traversal strategy) and X (representingthe return type of the visitor). \nThe Visitor also contains a type R that correspondsto thetype SVX (the .rstargument of V, spec\u00adifyingthe \ntype ofrecursive arguments). trait Visitor { type X type S<:Strategy type R[v<:Visitor]= (S {type X = \nVisitor.this.X;type V = v}) #Y } The notationT#Y usedinthede.nitionofthetype synonym R is the equivalence \nof obj.method on type level. In other words, T#Y selects the type Y from the trait or class T.We will \nexplainthe type Y when weintroduce Strategy. We alsointroduce a type synonymVisFunc parametrized by a \nvisitor v, a strategy s and a result type x, as a shortcut for visitors thatare alsofunctions. type VisFunc[v<:Visitor, \ns<:Strategy, x]= Function1[Composite[v], x] with v {type S= s;type X = x} In essence, wetreatvisitors \nasfunctions(thetrait Function1 is provided by the Scala library) that take a Composite[v] as an argument \nand return a value of type x, by observing that the invocation a.accept (f) where a is a composite and \nf is a visitor canbeinterpreted as aformoffunctionappli\u00adcation f (a).The with keywordis usedinScala todo \nmixin composition of traits. Composites TheComposite traitisparametrizedby a visi\u00adtor V and contains \nan accept methodthat takes twoparame\u00adters.The .rstparameteristhevisitortoapply; thesecondis the traversal \nstrategyto use while visiting the structure. trait Composite[v<:Visitor] { def accept[s<:Strategy, x](vis:VisFunc[v, \ns, x]) (implicit decompose:Decompose[s]) :x } We switch the order of the two arguments (when com\u00adpared \nto the Composite equation shown earlier) because decomposecanbeimplicitlyinferred(sinceitisdetermined \nby the concrete instantiation of s), and Scala requires im\u00adplicitargumentstobeplacedlast. Traversal Strategies \nThe shape of theparameter S is cap\u00adturedinScalaby thefollowingtrait: trait Strategy{ type V<:Visitor \ntype X type Y } A Strategy has two abstract types V and X and a type Y that is dependent on V and X \n(althoughthat dependencyis not captured directly by Scala s type system). The type Y represents the type \nused in place of recursive occurrences in the visit methods. Subtypes of this trait will correspond to \ndifferent possible traversal strategies for the visitors. In particular, the strategies Internal and \nExternal are de.ned as: trait Internalextends Strategy{ type Y = X } trait Externalextends Strategy{ \ntype Y = Composite[V] } As we have seen, the traversal strategy parameter in the accept methodcanbe \nmadeimplicit.This meansthat we can call the accept methodbypassingjustthe .rstparameter, giventhatadecoperationofthe \nappropriateDecomposetype for the secondargumentisin scope.The trait Decompose is parametrized by the \ntraversal strategy S and encapsulates a single method dec. This method takes a visitor and a com\u00adposite \nand returns the result of recurring on that composite using the traversal strategy. trait Decompose[s<:Strategy] \n{ def dec[v<:Visitor, x](vis:VisFunc[v, s, x], comp:Composite[v]) : (s {type V = v;type X = x}) #Y } \nTraversal strategiesforinternal and externals visitors are providedbythelibrary(notethatbothstrategies \ncanbe used implicitly): implicit def internal:Decompose[Internal]= new Decompose[Internal] { def dec[v<:Visitor, \nx](vis:VisFunc[v, Internal, x], comp:Composite[v]) = vis.apply (comp) } implicit def external:Decompose[External]= \nnew Decompose[External] { def dec[v<:Visitor, x](vis:VisFunc[v, External, x], comp:Composite[v]) = comp \n} The twoimplementations ofthe method dec correspond, re\u00adspectively,to thede.nitions decInternal and \ndecExternal in the functional speci.cation.Theimportantthing here effec\u00adtively the piece of code that \nwe want to abstract from is the de.nition of dec, which is vis.apply (comp) for in\u00adternal visitors andjust \ncomp for external visitors. Note that the apply methodisde.nedin the Function1trait and corre\u00adspondstofunctionapplication.In \nessence,thetraversalstrat\u00adegy of the internal visitors recurs on the composite comp (since it calls theaccept \nmethod via apply);and the traver\u00adsal strategy for external visitors returns the composite un\u00adtouched, \nwhich allows concrete visitors to control recursion themselves. Dispatchers InScala,functions are notprimitive: \nthey are de.ned as a trait Function1 with an apply method. This means that we can provide our own implementation \nof the apply methods, which allows us to add extra behaviour on function calls. Our visitor library has \nthe notion of a dispatcher, allowing us to parametrize the dispatching be\u00adhaviour ofour visitors, adding \nan extraform ofparametriza\u00adtion thatis not consideredbythefunctional speci.cation. Figure 7 shows the \ntrait that de.nes the interface of a Dispatcher and a few implementations of that trait. The method dispatch \ntakes a visitor and a traversal strategy and returns a function that will be used by the apply method \nin the visitor to de.ne the dispatching behaviour. The def\u00adinition Basic implements Dispatcher with the \nstandard dis\u00adpatchingbehaviourbyjust calling the accept method. The class Advice,inspiredbythe notion \nof adviceinAOP, wraps itself around another dispatcher and de.nes dispatch as a TEMPLATE METHOD (Gamma \net al., 1995) that calls the before and after methods around the dispatch function of the dispatcher \nargument. One implementation of advice is givenbyTrace, whichprovidesa simpletracingconcernthat prints \nthe argumentsbeforeperforminga call andprints the result after returning. Finally, the Memo dispatcher \nimple\u00adments a form of memoization: it intercepts function calls so that only calls on values that have \nnot been seen before areperformed resultsforothercallsareretrievedfroma cache. We should emphasize that \ndispatchers are composable (that is, we can construct more complex dispatchers using simpler ones)having \nBasic as the unit of composition.Fur\u00adthermore, new ones canbe easily added. The Case Visitor Havingbuiltthebasicbuildingblocksfor \nthe visitor library, we now introduce the Case class, which willbe used toprovide thefunctional notation \nand tode.ne concrete visitors: abstract class Case[v<:Visitor, s<:Strategy, x] (d:Dispatcher[v, s, x]) \n(implicit dec:Decompose[s]) extends Function1[Composite[v], x] { self :Case[v, s, x] with v {type S= \ns;type X = x}. type X = x type S= s def dispatcher= d def decompose= dec def apply (c:Composite[v]) :x \n= dispatcher.dispatch(this, decompose).apply (c) } The class Case is type-parametrized by a visitor v \n(the shape argument), a strategy s (the traversal strategy argu\u00adment) and the return type x. Furthermore, \nit is also value\u00adparametrized by a d (the dispatcher argument)and an im\u00adplicitvalue dec(relatedtothetraversalstrategy).Subclasses \nof Case will implement the visitor type v passed as an ar\u00adgument. This is expressed by Scala s self-type \nannotation self :Case[v, s, x] with v {type S= s;type X = x}.The class Case extends Function1and the \napply methodisde.nedby calling the dispatchmethodfrom theprovideddispatcher d. 6. Translation of Datatypes \nIn this section we de.ne a translation scheme between datatype-like declarations and visitors de.ned \nusing our Scala library. We introduce a mini-language for datatypes trait Dispatcher[v<:Visitor, s<:Strategy, \nx] { def dispatch(vis:VisFunc[v, s, x], dec:Decompose[s]) :Function1[Composite[v], x] } implicit def \nBasic[v<:Visitor, s<:Strategy, x]= new Dispatcher[v, s, x] { def dispatch(vis:VisFunc[v, s, x], dec:Decompose[s]) \n:Function1[Composite[v], x]= c .c.accept[s, x](vis)(dec) } abstract class Advice[d<:Visitor, s<:Strategy, \nx](dis:Dispatcher[d, s, x]) extends Dispatcher[d, s, x] { def before(comp:Composite[d]) :Unit = {} def \nafter (comp:Composite[d], res:x) :Unit= {} def dispatch(vis:VisFunc[d, s, x], dec:Decompose[s]) :Function1[Composite[d], \nx]= c .{before(c);val res = dis.dispatch(vis, dec)(c);after (c, res);res} } def Trace[v<:Visitor, s<:Strategy, \nx](dis:Dispatcher[v, s, x]) = new Advice[v, s, x](dis) { override def before(comp:Composite[v]) :Unit= \n{ System.out.println(\"Calling function with argument: \\t\" + comp); } override def after (comp:Composite[v], \nres:x) :Unit = { System.out.println(res+ \"\\t was returned from the call with argument: \\t\" + comp); } \n} def Memo[v<:Visitor, s<:Strategy, x](dis:Dispatcher[v, s, x]) = new Dispatcher[v, s, x] { val cache:HashMap[Composite[v], \nx]= new HashMap[Composite[v], x] () def dispatch(vis:VisFunc[v, s, x], dec:Decompose[s]) :Function1[Composite[v], \nx]= c .{ cache.get(c) match { case Some(x) .x case None.{val res = dis.dispatch(vis, dec)(c);cache.put(c, \nres);res} } } } Figure 7. VisitorLibraryDispatchers asfollows. Datas t ::= data T [a\u00af]= {c\u00afs\u00af} Constructors \nc ::= constructor K [\u00df\u00af] v :t {s\u00af} Types t ::= t1 |T0 [a\u00af] Non-recursiveTypes t1 ::= a |T1 [t1] |t1 .t1 \nScala s ::= Scaladeclarations A datatype T , possibly parametrized by type variables a\u00af, introducesa \nsetofdata constructorsandsome optionalScala code \u00afs.Each constructor, K , cantake an optionallist oftype \narguments \u00df\u00af(whichactas existentiallyquanti.edtypes) and alist oflabelled type arguments v :t.Scalade.nitions \n\u00afs can be inserted to de.ne or override .elds and methods. We single out non-recursive type arguments, \nt1, which do not make self-reference to the datatype that introduced them. Recursive occurrences of type \nconstructors are denoted T0, to separate themfromthe non-recursive ones(T1). The reason for this separation \nis to enforce a few syn\u00adtactic restrictions on the language. In particular, nested datatypes(Bird andMeertens,1998) \nand constructors with functional parameters having recursive occurrences (Mei\u00adjer and Hutton, 1995) are \nexcluded, since traversals are hardtode.nefor those types.Despite these restrictions, the data constructorpresentedhereis \ncomparablein expressive power to ML-style and Haskell 98-style datatypes, allow\u00ading us to express (type-)parametrized \ndatatypes, mutually recursivedatatypes and existentialdatatypes. Declarations in the datatype language \ncan be translated to visitors by the meta-function GEN in Figure 8. Before going into the details of \nthe translation, we .rst introduce n a few notational conventions. We write \u00afo for a sequence of entities \nnumbered from 1 to n and oi as the ith of them. We use a pattern matching syntax ti@T [.\u00af] to denote \nthat thebound variable t is of type T [.\u00af] for some T and .. New GEN(data T [a\u00af]= {c\u00afs\u00af})= LET GENREF(Tm)= \ndef mrefTm :VisFunc[TmVisitor[a\u00af], S, X] n GENTYPE(constructor K [\u00df\u00af] v : t {\u00afs})= def K [\u00df\u00af](vi :CASE \nSTATUSOF(ti@T ' [.\u00af])OF RECURSIVE .R[T Visitor[a\u00af]] MUTUALREC .R[T ' Visitor[a\u00af]] .ti)i.1..n NONREC \n:X n GENDATA(constructor K [\u00df\u00af] v : t {\u00afs})= case class K [\u00df\u00af, a\u00af](vi :ti) i.1..nextends T [a\u00af] { def \naccept[s<:Strategy, x](vis:VisFunc[T Visitor[a\u00af], s, x]) (implicit decompose:Decompose[s]) :x = vis.K \n[\u00df\u00af](CASE STATUSOF(ti@T ' [.\u00af])OF RECURSIVE .decompose.dec[T Visitor[a\u00af], x](vis, vi) MUTUALREC .decompose.dec[T \n' Visitor[a\u00af], x](vis.mrefT ' , vi) vi)i.1..n NONREC . s\u00af } IN trait T Visitor[a\u00af] extends Visitor { \nGENREF(Tm) GENTYPE(c\u00af) } trait T [a\u00af] extends Composite[T Visitor[a\u00af]]{\u00afs} abstract class CaseT [s<:Strategy, \na\u00af, x](implicit dec:Decompose[s]) extends DCaseT [s, a\u00af, x](Basic)(dec) abstract class DCaseT [s<:Strategy, \na\u00af, x](disp:Dispatcher[T Visitor[a\u00af], s, x]) (implicit dec:Decompose[s]) extends Case[T Visitor[a\u00af], \ns, x](disp)(dec) with T Visitor[a\u00af] GENDATA(c\u00af) Figure 8. TranslationScheme names for visitors and references \nare created by pre.xing or post.xing with the type constructor name, for example T Visitor. We assume \na dependency analysis and write Tm to denote the set of mutually recursive types that T makes referencesto(excluding \nT itself). For each datatype T , we generate a corresponding vis\u00aditor type (a trait that extends Visitor) \nand a composite (a trait that extends Composite[T Visitor[a\u00af]]). We also gener\u00adate two auxiliary visitors \nDCaseT and CaseT . The former extends Case[T Visitor[a\u00af], s, x],providing a convenient way to parametrize \nvisitors by traversal and dispatching strate\u00adgies as well as allowing visitors to be interpreted as func\u00adtions.Thelatterprovides \na shorthandforthe Basicdispatch\u00adingstrategy. Thefunction GENDATA creates a case classfor each constructor \nK extending T [a\u00af] and generates the cor\u00adresponding accept method by checking the recursive status of \nK s arguments, whichdeterminesthe traversal code. Each of the visitors T Visitor[a\u00af] may have mutually \nre\u00adcursive referencesto other visitors thatitdepends on, which aregeneratedbythefunction GENREF.Thetypes \nofthe visit methods K (namedafterthe correspondingconstructor)also dependonthe recursivestatus ofthe \nconstructor sarguments and aregeneratedby the GENTYPE function. In Figure 9 we apply the translation \nto the trees and forests exampleinSection3.6.For thedatatypeTree[a], we generate the visitor and composite \ntypes TreeVisitor[a] and Tree[a],the two auxiliary visitors CaseTree and DCaseTree, and the constructor \nFork. The mutual dependency with Forest [a] is captured by the de.nition of mrefForest in TreeVisitor \n[a]. A similar process happens for Forest [a], resulting in the generation of ForestVisitor [a], Forest[a], \nCaseForest, DCaseForest, Nil and Cons.A mutual reference mrefTree is alsoplacedin ForestVisitor[a]. 7. \nDiscussion and Related Work 7.1 Traversal Strategies and Recursion Patterns Traversal strategies are \nclosely related tothe recursionpat\u00adterns studied by the Algebra of Programming movement (BirdandMoor,1997).Thisline \nof work supportsHoare s observationthatdatastructuredeterminesprogramstructure; the shape of the data \ninduces for free a number of patterns of computation,together with reasoningprinciplesfor those patterns. \nThe mostfamiliarof thesefamilies of recursionpatterns isthe fold (or catamorphism ) operation,whichperforms \ntrait TreeVisitor[a] extends Visitor { def mrefForest:VisFunc[ForestVisitor[a], S, X] def Fork (x:a, \nxs:R[ForestVisitor[a]]) :X } trait Tree[a] extends Composite[TreeVisitor[a]] abstract class CaseTree[s<:Strategy, \na, x](implicit dec:Decompose[s]) extends DCaseTree[s, a, x](Basic)(dec) abstract class DCaseTree[s<:Strategy, \na, x](disp:Dispatcher[TreeVisitor[a], s, x]) (implicit dec:Decompose[s]) extends Case[TreeVisitor[a], \ns, x](disp)(dec) with TreeVisitor[a] case class Fork[a](x:a, xs:Forest[a]) extends Tree[a] { def accept[s<:Strategy, \nx](vis:VisFunc[TreeVisitor[a], s, x]) (implicit decompose:Decompose[s]) :x = vis.Fork (x, decompose.dec(vis.mrefForest, \nxs)) } trait ForestVisitor[a] extends Visitor { def mrefTree:VisFunc[TreeVisitor[a], S, X] def Nil:X \ndef Cons(x:R[TreeVisitor[a]], xs:R[ForestVisitor[a]]) :X } trait Forest[a] extends Composite[ForestVisitor[a]] \nabstract class CaseForest[s<:Strategy, a, x](implicit dec:Decompose[s]) extends DCaseForest[s, a, x](Basic)(dec) \nabstract class DCaseForest[s<:Strategy, a, x](disp:Dispatcher[ForestVisitor[a], s, x]) (implicit dec:Decompose[s]) \n extends Case[ForestVisitor[a], s, x](disp)(dec) with ForestVisitor[a] case class Nil[a] extends Forest[a] \n{ def accept[s<:Strategy, x](vis:VisFunc[ForestVisitor[a], s, x]) (implicit decompose:Decompose[s]) :x \n= vis.Nil } case class Cons[a](x:Tree[a], xs:Forest[a]) extends Forest[a] { def accept[s<:Strategy, \nx](vis:VisFunc[ForestVisitor[a], s, x]) (implicit decompose:Decompose[s]) :x = vis.Cons(decompose.dec(vis.mrefTree, \nx), decompose.dec(vis, xs)) } Figure 9. Translation ofthe Tree and Forest datatypesinto visitors. structurally \ninductive computations reducing a term to a value.Better still,thosesimilarde.nitionsarerelatedpara\u00admetrically,and \ncanallbesubsumedin onesingle datatype\u00adgeneric de.nition, parametrised by the shape. The internal visitors \nexpressible with ourlibrary arebasicallyfolds. TheAlgebra ofProgrammingpatterns canprovideinspi\u00adrationfor \nnewtypes ofvisitor,beyondwhatis well-knownin theliterature.For example,Meertens(1992)introducesthe notionofa \nparamorphism,whichin aprecisetechnicalsense is to primitive recursion what catamorphism is to iteration. \nInformally,thebodyof aparamorphismhasdirect access to the original subtermsof aterm,in additiontotheresults \nof traversing those subterms as a catamorphismdoes.The ob\u00advious de.nition of factorial, in which (n + \n1)! depends on n as well as n!, is a representative application. This recur\u00adsionpatterncanbeexpressed \nas astrategy using ourvisitor library: trait Paraextends Strategy{ type Y = Pair[X, Composite[V]] } \n implicit def para:Decompose[Para]= new Decompose[Para] { def dec[v<:Visitor, x](vis:VisFunc[v, Para, \nx], comp:Composite[v]) = Pair[x, Composite[v]] (vis.apply (comp), comp) }  7.2 Dispatching Strategies \nand Modular Concerns Kiczales etal.(1997) s aspect-orientedprogramming(AOP) aims at modularizing concerns \nthat cut across the compo\u00adnents of a software system. These ideas inspired some of the applications of \nour library in Section 3. In AOP, pro\u00adgrammersareableto modularizethese crosscuttingconcerns withinlocallyde.ned \naspects: pointcutsdesignate when and where to crosscut other modules, and advice speci.es what willhappen \nwhen apointcutis reached.AlthoughAOP suc\u00adcessfully separates concerns that are scattered and tangled \nthroughouttheprogram,it can alsointroduce aform oftight coupling between base programs and their aspects, \nwhich complicates modularprogram understanding and reasoning. Several authors (Aldrich, 2005; Kiczales \nand Mezini, 2005; Gudmundson and Kiczales, 2001) have proposed waystoharnessthepower of aspectsbygiving \nmore control to programmers over which parts of their code are open to advice. Notable among these are \nAldrich s open modules, which encapsulatefunctionde.nitionsinto modules and ex\u00adport public interfaces \nfor both calling and advising from other modules. Internal function calls that are private to a module \ncan onlybe advisedifthe module explicitly chooses to allowthis.Inthis sense, our use of advicethroughvisitors \nis akin to the internal advising of open modules. Functions or modules that are subject to advice are \nparametrized by dispatchers andinstantiatedto aparticulargeneric advice.A signi.cantdifferencebetween \nour approach and open mod\u00adulesliesinthe means of triggering advice:parametrization versus pointcuts. \nIt is no surprise that our library does not have fully .edged support for AOP; however, a signi.cant \nclass of applications of AOP can be coded up conveniently and modularly. 7.3 Case Classes and Algebraic \nDatatypes Thedatatype notation that wehaveintroducedin thispaper isinspiredbyalgebraicdatatypes fromfunctionalprogram\u00adming.Scala(Odersky,2006)hasits \nown notion of algebraic datatypes via (sealed) case classes. With case classes, we could rewrite the \nTree and depthexamples as: sealed case class Tree case class Emptyextends Tree case class Fork (x:int, \nl:Tree, r:Tree) extends Tree def depth(t:Tree) :int= t match { case Empty() .0 case Fork(x, l, r) .1+ \nmax (depth(l), depth(r)) } The sealed keywordguarantees that the classhierarchywill notbe extendedin \nothermodules.Sealing allowstheScala compilertoperforman exhaustivenesscheck,guaranteeing that an operation \nis de.ned for all cases. This gives us es\u00adsentially the same advantages(anddisadvantages) as alge\u00adbraicdatatypes.However, \nsimple case classes are moregen\u00aderal than algebraic datatypes, because they do not need to be sealed: \nwe could have de.ned Tree without the sealed keyword, gaining the ability to add new variants in the \nfu\u00adture.Nevertheless, this extragenerality can createproblems because,although new variantscanbe added,functionsde\u00ad.ned \nby matching cannot be extended, and exhaustiveness checksbecome unavailable, essentiallyintroducingthepos\u00adsibility \nof Message notunderstood run-time errors. There are three main differences between the notion of datatypes \nintroduced in this paper and case classes. Firstly, algebraicdatatypes and case classes correspond, essentially, \nto visitors with traversal and dispatching strategies set to External and Basic, therefore losing much \nof the reusabil\u00aditybene.ts offeredby thoseparametrizations.Secondly, al\u00adthough thedatatype notation requires \nalanguage extension, the approachwehavetakenis mostlylibrary-based.Thishas theimportant advantagethat \nwe can extend thefunctionally providedby the visitorlibrary, without extending the com\u00adpileritself.For \nexample, as wehave seeninSection7.1,itis very simpleto add a newkind of traversal strategy.Webe\u00adlievethatan \napproach couldbe taken similarto the one with ITERATORs(Gamma et al.,1995)inC# and new versions of Java, \nwith a library component and some built-in language support(the foreach keyword).We envisionalanguageex\u00adtension \nsupporting thedatatype notation,perhaps also with a parametrizable case construct and pattern matching \nnota\u00adtion,built ontop of the visitorlibrary.Finally,the semantics of case classes is essentially given \nby type inspection and downcasting.Our semanticsdoes notrely onthe availability of casts or run-time \ntypeinformation, soit couldbe usedin object-orientedlanguages withoutthese mechanisms. 7.4 Design Patterns \nas Software Components Norvig (1996) studied the consequences of using a dy\u00adnamic language such as Lisp \nor Dylan for the GoF pat\u00adterns (Gamma et al., 1995); he claimed that 16 of these 23 patterns have qualitatively \nsimpler implementations in such languages some simply disappear, and others may beformalizedas software \ncomponents.Arnout(2004)did a similar study of design patterns in the Eiffel programming language(Meyer,1997);she \narguedthatEiffelfeatures such as genericity, tuples and agents played an essential role in the componentization \nofpatterns.Hannemann andKiczales (2002)studieddesignpatternsinthe contextofAspectJ.The results showedthat74% \noftheGoFpatterns couldbeimple\u00admentedin a moremodularwayand52%weremorereusable. Gibbons(2003) arguesthatdatatype-genericprogramming \ncan be used to capture the abstractions behind many de\u00adsignpatternsformally; subsequentpapers(Gibbons,2006; \nGibbons and Oliveira, 2008) interpret four of the GoF pat\u00adterns as higher-order datatype-generic programs. \nOdersky andZenger(2005b) point outthat theScalaprogramming languageisdesignedwith componentdevelopmentin \nmind; they identify abstract type members, self type annotations and modular mixin composition as abstractions \nthat do not existin mainstreamOOlanguagesbutprovetobeimportant for component development, and use the \n.rst two features to provide an elegant software component that captures the OBSERVER designpattern. \n 7.5 Generic Visitors Therehavebeen severalproposalsfor generic visitors (visi\u00adtorlibrariesthat canbe \nreusedfordevelopingsoftware using something like the VISITOR pattern) in the past. Palsberg andJay(1998)presented \na solution relying ontheJava re\u00ad.ection mechanism, where a single Java class Walkabout could support \nall visitors as subclasses. Re.nements to this idea, mostly to improve performance, have been proposed \nsincebyGrothoff(2003) andForax et al.(2005).Meyer and Arnout(2006) alsopresent ageneric visitor along \nthe same lines, but having less dependence on introspection mecha\u00adnisms(althoughthoseare still needed).Oneadvantageof \nthese approaches is that they are not invasive that is, the visitable class hierarchies do not need \nto have accept methods and it is possible to write generic traversal code (i.e. code thatworksfordifferent \nvisitors).In thispaper, we can avoid most of the direct uses of the accept methods by using the datatype \nand functional notations, but the meth\u00adods will still be needed. Although we do not address the issuehere,very.exibleandtype-safegenerictraversalcode \ncanbe written using a datatype-genericprogrammingexten\u00adsionto our visitorlibrary(Oliveira,2007).Adisadvantage \nof introspection-based approaches is that they cannot stati\u00adcally ensure type-safety, and so strictly \nspeaking should not be classi.ed as components.Furthermore,those approaches lack.exibilityinthechoiceofthedispatchingpolicy(Cunei \nandVitek,2005). Visser(2001) observesthatthe VISITOR pattern suffers from two main limitations: lack \nof traversal control; and resistance to combination, which are closely related to our notions of traversal \nand dispatching parametrization. His solutionfor thoseproblems consists of a number ofgeneric visitor \ncombinatorsfor traversal control.These combinators can express interesting traversal strategies like \nbottom-up, top-down or sequential composition of visitors and can be usedtode.ne visitor-independent(orgeneric)functionality. \nLikeall otherimplementationsofformsofgenericvisitors, Visser s solutionrequiresrun-timeintrospection.Itwouldbe \ninteresting to explore some of Visser s ideas in the context of our visitorlibrary. ThePeripatonlanguage(VanDrunen \nandPalsberg,2004) supportstheso-called visitor-orientedprogramming style . InPeripaton, everythingis \na visitor:the visitor objectcanbe considered the top of the objecthierarchy,playing the same role as \nObject in Java. By interpreting the visit method as function application, we get a notion that lies in \nbetween functions and objects, similarly to the functional notation in our visitorlibrary.DJ(Orleans \nandLieberherr,2001) is a re.ection-based Java library for traversals that has been used in the context \nof adaptive programming. Chadwick et al. (2006) proposes a (functional) visitor-oriented pro\u00adgramminglanguagethatis \nmodular andcompositional, aim\u00ading at more reusable designs. They have implemented the idea as a modi.edversion \nofDJ.In subsequent work,Chad\u00adwick andLieberherr(2008)proposea re.ection-basedJava library DemeterF that \ncomes with a type system making it possibleto type-checkvisitor code, verifyingtraversals stat\u00adically. \n 7.6 Multiple Dispatch Mainstream object-oriented languages, like C++, C# and Java, alluse a singledispatching \nmechanism, where a single argument(the self object)is dynamically dispatchedand all otherdispatchingis \nstatic.Aproblem arises,however, when a method requires dynamic dispatching on two or more ar\u00adguments. \nMultiple dispatching makes it dif.cult to provide modular(compile-time) type-checking to catch ambiguous \nand invalid combinations of dynamically dispatched argu\u00adments, andthere arefearsthatitgoes against object-oriented \nprincipleslike encapsulation.Thereis a richliterature moti\u00advating and proposing solutions for this problem: \nChambers andLeavens(1995);Clifton et al.(2000);Ernst et al.(1998) arejustafew examples.Still, noneofthose \nsolutionsachieve modular static type-checking without restrictions. Visitors canbe used to emulate a(limited) \nformof mul\u00adtiple dispatching in object-oriented languages, as we men\u00adtionedin Section3.5.Ambiguous andinvalid \ncombinations ofdynamicallydispatched argumentsdo notpose aproblem for our visitors, but the price to \npay for this is that we lose the abilityto easily add new variants, whichispossible with many of the \nmultiple-dispatching solutions.Theproblem of extensibility of visitors(thatis,the ability to add new \nvari\u00adants) is exploredby Oliveira(2007,Chapter5), and a solu\u00adtioninspiredbyOdersky andZenger(2005a)isproposed \nas a way to add extensibility to the visitor library. Encapsula\u00adtionis moreproblematic, and visitor-based \nsolutions are of\u00adten criticizedas notbeingveryobjectoriented.We agreethat theidea of encapsulationis \nimportant and, wheneverpossi\u00adble,it shouldbepreserved.Nevertheless,in some situations a functional decomposition \nstyle is more appropriate, and trying topreserve(full) encapsulationishard.What seems clearly worse to \nus than theloss of encapsulationis thefact that most object-orientedlanguagesdo nothave an easy-to\u00aduse \nmechanismfor aform of multipledispatching(evenif limited) except via the (statically) type-unsafe instanceOf \nintrospection mechanism.Webelievethatourdatatype nota\u00adtion andthe related Externaltraversal strategy \ncouldprovide an easy-to-use andlightweight(if simple-minded) solution forthe multipledispatchingproblem. \n8. Conclusions Wehave arguedthat(the structural aspects of) theVISI-TOR design pattern can be captured \nas a reusable, generic, modular and statically type-safe componentby using some advanced type system \nfeatures that are starting to appear in modern object-orientedlanguages.Inspiredbyfunctional programming,wehaveshownthatwe \ncansigni.cantlyim\u00adprovethe use ofvisitors viadatatype-like andfunctional no\u00adtations, while atthe sametimeprovidinga \nsimplefunctional decompositionmechanismthat, wethink,is well-suitedfor object-orientedlanguages. Thisworkisbasedon(Oliveira,2007,Chapter3),the \n.rst author sdoctoraldissertation; in essence,thisbuilds onthe insightsprovidedbytype-theoreticencodingsofdatatypesto \nderive a visitor software component.Other chapters of that dissertation address two otherissues, related \nto visitors, not discussed here: datatype-generic programming (the ability to writefunctionsthat workfor \nany visitors); and extensibil\u00adity (the abilityto add new variants to visitors).Solutionsfor thesetwoproblems \nare also achievedwithoutcompromising modular static type-safety. The hope is that this line of work will, \nmore generally, show how more expressive forms of parametrization can help in resolving limitations of \ncurrent programming lan\u00adguages whenitcomes to componentization and modulariza\u00adtion of software.For thefuture, \nwe wouldlike to: Investigate possible programming language extensions for the datatype notation, as \nwell as a case analysis and apattern matching notation,withfull supportforall the parametrization aspects \nofthe visitorlibrary.  Develop a formal setting that can be used to formalize and reason about components. \nIn particular, we would liketo create a simple,but expressive,purelyfunctional object-oriented language \nand investigate the implemen\u00adtation of somedesignpatterns as components.  The codeforthispaper canbe \nobtainedfromwww.comlab. ox.ac.uk/people/Bruno.Oliveira/VisLib.tgz. References JonathanAldrich. Open modules:Modular \nreasoningabout advice. In LNCS 3586:EuropeanConference on Object\u00adOrientedProgramming,pages144 168,2005. \nKarine Arnout. Pattern Componentization. PhD thesis, SwissInstitute ofTechnology,March2004. RichardBird \nandLambertMeertens. Nesteddatatypes. In J. Jeuring, editor, LNCS 1422: Mathematics of Program Construction,pages52 \n67,1998. Richard S. Bird and Oege De Moor. Algebra of Program\u00adming. PrenticeHall,1997. CorradoB\u00a8ohm andAlesssandroBerarducci.Automatic \nsyn\u00adthesis of typedlambda-programs onterm algebras. Theo\u00adreticalComputerScience,39(2-3):135 153,August1985. \nPeter Buchlovsky and Hayo Thielecke. A type-theoretic reconstruction of the Visitorpattern. Electronic \nNotes in Theoretical Computer Science,155,2005. Mathematical Foundations ofProgrammingSemantics. Bryan \nChadwick and Karl Lieberherr. Functional Adap\u00adtive Programming with DemeterF. Technical Report NU-CCIS-08-March19,NortheasternUniversity,Boston, \nMarch2008. Bryan Chadwick, Therapon Skotiniotis, and Karl Lieber\u00adherr.FunctionalVisitorsRevisited.TechnicalReportNU\u00adCCIS-06-03,NortheasternUniversity,Boston,May2006. \nCraig Chambers and Gary T. Leavens. Typechecking and modules for multimethods. ACM Transactions on Programming \nLanguages and Systems, 17(6):805 843, November1995. AlonzoChurch.An unsolvableproblem ofelementarynum\u00adber \ntheory. American Journal of Mathematics, 58:345 363,1936. CurtisClifton,GaryT.Leavens,CraigChambers, \nandTodd Millstein. MultiJava:Modular open classes and symmet\u00adric multiple dispatch for Java. In Object-Oriented \nPro\u00adgramming, Systems, Languages, and Applications,pages 130 145,2000. VincentCremetandPhilippeAltherr. \nAddingtype construc\u00adtor parameterization to Java. Journal of Object Technol\u00adogy, 7(5):25 65, June 2008. \nSpecial issue on ECOOP 2007Workshop onFormalTechniquesforJava-likePro\u00adgrams. AntonioCunei andJanVitek. \nPolyD: a .exibledispatching framework. In Object Oriented Programming, Systems, Languages, andApplications,pages487 \n503,NewYork, NY, USA, 2005. ACM. doi: http://doi.acm.org/10.1145/ 1103845.1094849. Michael Ernst, Craig \nKaplan, and Craig Chambers. Pred\u00adicate dispatching: A uni.ed theory of dispatch. In Eu\u00adropean Conference \non Object-Oriented Programming, pages186 211,London,UK,1998.Springer-Verlag. R\u00b4emiForax,EtienneDuris, \nandGillesRoussel. Re.ection\u00adbased implementation of Java extensions: The double\u00addispatch use-case. In \nACM Symposium on Applied Com\u00adputing,pages1409 1413,2005. ErichGamma,RichardHelm,RalphJohnson,andJohnVlis\u00adsides. \nDesign Patterns: Elements of Reusable Object-OrientedSoftware. Addison-Wesley,1995. JeremyGibbons.Patternsindatatype-genericprogramming. \nIn J. Striegnitz, editor, Declarative Programming in the Context ofObject-OrientedLanguages,Uppsala,2003. \nJeremyGibbons. Designpatternsashigher-orderdatatype\u00adgeneric programs. In ACM Workshop on Generic Pro\u00adgramming,pages1 \n12,2006. Jeremy Gibbons and Bruno Oliveira. The essence of the Iterator pattern. Journal of Functional \nProgramming, 2008. Jean-YvesGirard,PaulTaylor, andYvesLafont. Proofs and types. CambridgeUniversityPress,1989. \nChristianGrothoff. Walkabout revisited:TheRunabout. In LNCS 2743: European Conference on Object-Oriented \nProgramming,pages103 125,2003. Stephan Gudmundson and Gregor Kiczales. Addressing practical software \ndevelopment issues in AspectJ with a pointcut interface. In ECOOP 2001 Workshop on Ad\u00advancedSeparation \nofConcerns,2001. JanHannemann andGregorKiczales. Designpatternimple\u00admentation in Java and AspectJ. SIGPLAN \nNot., 37(11): 161 173,2002. Robert Harper and Mark Lillibridge. A type-theoretic ap\u00adproach to higher-order \nmodules with sharing. In Princi\u00adples ofProgrammingLanguages,pages123 137,1994. Gregor Kiczales and Mira \nMezini. Aspect-oriented pro\u00adgrammingandmodular reasoning.In ACM:International Conference onSoftware engineering,pages49 \n58,2005. GregorKiczales,JohnLamping,AnuragMenhdhekar,Chris Maeda,CristinaLopes,Jean-MarcLoingtier, andJohnIr\u00adwin.Aspect-orientedprogramming.InMehmetAks\u00b8it \nand SatoshiMatsuoka,editors,LNCS1241:EuropeanConfer\u00adence on Object-Oriented Programming, pages 220 242, \n1997. Xavier Leroy. Manifest types, modules, and separate com\u00adpilation. InPrinciples ofProgrammingLanguages,pages \n109 122,1994. Doug McIlroy. Mass produced software components. In Naur andRandell(1969),pages138 155. \nLambert Meertens. Paramorphisms. Formal Aspects of Computing,4(5):413 425,1992. Erik Meijer and Graham \nHutton. Bananas in space: Ex\u00adtending fold and unfold to exponential types. In Func\u00adtional Programming \nLanguages and Computer Architec\u00adture,pages324 333,1995. Bertrand Meyer. Object-Oriented Software Construction. \nUpper Saddle River, N.J., Prentice Hall, 2nd edition, 1997. BertrandMeyer andKarineArnout.Componentization:The \nVisitor example. Computer,39(7):23 30,2006. Donald Michie. Memo functions and machine learning. Nature,218:19 \n22,1968. Adriaan Moors, Frank Piessens, and Martin Odersky. To\u00adwards equal rights for higher-kinded types. \nIn 6th Inter\u00adnationalWorkshop on MultiparadigmProgramming with Object-OrientedLanguages,2007. Peter Naur \nand Brian Randell, editors. Software Engineer\u00ading:Report of a ConferenceSponsoredby the NATOSci\u00adence \nCommittee, Garmisch, Germany, 7 11 Oct. 1968. 1969. PeterNorvig. Designpatternsindynamicprogramming. \nIn ObjectWorld96,May1996. Martin Odersky. An Overview of the Scala programming language(secondedition).TechnicalReportIC/2006/001, \nEPFLLausanne,Switzerland,2006. Martin Odersky and Matthias Zenger. Indepen\u00addently extensible solutions \nto the expression problem. In Proceedings of Foundations of Object-Oriented Languages 12, January 2005a. \nhttp://homepages.inf.ed.ac.uk/wadler/fool. Martin Odersky and Matthias Zenger. Scalable component abstractions. \nIn Object Oriented Programming, Systems, Languages, andApplications,pages41 57,2005b. Bruno C.d.S. Oliveira. \nGenericity, Extensibility and Type-Safety in the VISITOR Pattern. PhD thesis, University of Oxford,2007. \nDoug Orleans and Karl Lieberherr. DJ: Dynamic adaptive programming in Java. In Re.ection 2001: Meta-level \nArchitectures and Separation of Crosscutting Concerns , Kyoto,Japan,September2001.SpringerVerlag. Jens \nPalsberg and C. Barry Jay. The essence of the Visitor pattern. In Computer Software and Applications, \npages 9 15,1998. MichelParigot. Recursiveprogrammingwithproofs. Theo\u00adreticalComputerScience,94(2):335 \n356,1992. Simon Peyton Jones, editor. Haskell 98 Language and Li\u00adbraries The Revised Report. Cambridge \nUniversity Press,Cambridge,England,2003. Cuno P.ster and Clemens Szyperski. Why objects are not enough. \nIn International Component Users Conference, 1996. Zdzislaw Splawski and Pawel Urzyczyn. Type .xpoints: \nIteration vs. recursion. In International Conference on FunctionalProgramming,pages102 113,1999. Clemens \nSzyperski. Independently extensible systems software engineering potential and challenges. In 19th AustralianComputerScienceConference,1996. \nPeri Tarr, Harold Ossher, William Harrison, and Stanley Sutton, Jr. N degrees of separation: Multi-dimensional \nseparation of concerns. In International Conference on SoftwareEngineering,pages107 119,1999. Thomas \nVanDrunen and Jens Palsberg. Visitor-oriented programming. In Proceedings of FOOL-11, the 11th ACM SIGPLAN \nInternational Workshop on Foundations ofObject-OrientedLanguages,NewYork,NY,USA,Jan-uary2004.ACMPress. \nJoost Visser. Visitor combination and traversal control. In Object Oriented Programming, Systems, Languages, \nand Applications,pages270 282.ACM,2001.    \n\t\t\t", "proc_id": "1449764", "abstract": "<p>The V<sc>ISITOR</sc> design pattern shows how to separate the structure of an object hierarchy from the behaviour of traversals over that hierarchy. The pattern is very flexible; this very flexibility makes it difficult to capture the pattern as anything more formal than prose, pictures and prototypes.</p> <p>We show how to capture the essence of the V<sc>ISITOR</sc> pattern as a reusable software library, by using advanced type system features appearing in modern object-oriented languages such as Scala. We preserve <i>type-safety statically and modularly</i>: no reflection or similar mechanisms are used and modules can be independently compiled. The library is <i>generic</i>, in two senses: not only is it parametrised by both the return type and the shape of the object hierarchy, but also it allows a number of implementation choices (internal versus external control, imperative versus functional behaviour, orthogonal aspects such as tracing and memoisation) to be specified by parameters rather than fixed in early design decisions. Finally, we propose a generalised <i>datatype</i>-like notation,on top of our visitor library: this provides a convenient functional decomposition style in object-oriented languages.</p>", "authors": [{"name": "Bruno C.d.S. Oliveira", "author_profile_id": "81310493622", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223220", "email_address": "", "orcid_id": ""}, {"name": "Meng Wang", "author_profile_id": "81351595589", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223221", "email_address": "", "orcid_id": ""}, {"name": "Jeremy Gibbons", "author_profile_id": "81339501222", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223222", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449799", "year": "2008", "article_id": "1449799", "conference": "OOPSLA", "title": "The visitor pattern as a reusable, generic, type-safe component", "url": "http://dl.acm.org/citation.cfm?id=1449799"}