{"article_publication_date": "10-19-2008", "fulltext": "\n Interprocedural Query Extraction for Transparent Persistence * Ben Wiedermann, Ali Ibrahim, and William \nR. Cook Department of Computer Sciences, The University of Texas at Austin {ben,aibrahim,wcook}@cs.utexas.edu \nAbstract Transparent persistence promises to integrate programming languages and databases by allowing \nprograms to access persistent data with the same ease as non-persistent data. In this work we demonstrate \nthe feasibility of optimizing transparently persistent programs by extracting queries to ef.ciently prefetch \nrequired data. A static analysis derives query structure and conditions across methods that access persistent \ndata. Using the static analysis, our system trans\u00adforms the program to execute explicit queries. The \ntrans\u00adformed program composes queries across methods to handle method calls that return persistent data. \nWe extend an exist\u00ading Java compiler to implement the static analysis and pro\u00adgram transformation, handling \nrecursion and parameterized queries. We evaluate the effectiveness of query extraction on the OO7 and \nTORPEDO benchmarks. This work is focused on programs written in the current version of Java, without \nlanguages changes. However, the techniques developed here may also be of value in conjunction with object-oriented \nlan\u00adguages extended with high-level query syntax. Categories and Subject Descriptors D.3.4 [Programming \nLanguages]: Processors Compilers,Optimization; H.2.3 [Database Management]: Languages General Terms Languages, \nPerformance Keywords Programming Languages, Databases, Static Anal\u00adysis, Object-Relational Mapping, Attribute \nGrammars 1. Introduction Integrating programming languages and databases is an im\u00adportant problem with \nsigni.cant practical and theoretical in\u00adterest. Integration is dif.cult because procedural languages \n* This work was supported by the National Science Foundation under Grant No. 0448128. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 08, October 19 23, \n2008, Nashville, Tennessee, USA. Copyright c . 2008 ACM 978-1-60558-215-3/08/10. . . $5.00 and database \nquery languages are based on different seman\u00adtic foundations and optimization strategies [21]. From a \npro\u00adgramming language viewpoint, databases manage persistent data, which has a lifetime longer than the \nexecution of an in\u00addividual program [32, 1, 25]. Ideally a uni.ed programming model, transparent persistence, \nshould be applicable to both persistent and non-persistent data. One of the key integration issues is \nthe treatment of queries. Queries are not fundamentally necessary, given an object-oriented view of persistent \ndata in which a program can traverse from one object to another. But there are at least two advantages \nto queries: they can provide higher\u00adlevel constructs for programmers to access data, and they enable \nspecialized query optimizations typically found in databases. In this work, we develop a technique for \nextracting queries from programs that use traversals to access persis\u00adtent data. The goal is to support \nquery optimization. We also discuss how query extraction can be combined with approaches that use higher-level \nqueries. We previously pre\u00adsented a sound query extraction technique [29], but this work was limited \nto a kernel language without procedures and did not target a practical database platform. In this paper \nwe implement query extraction for Java and evaluate its effec\u00adtiveness on two benchmarks. The contributions \nof this work are: An interprocedural static analysis to extract queries from Java programs that use \ntransparent persistence. The anal\u00adysis handles virtual method calls by introducing addi\u00adtional queries \nwhere necessary and composing analysis results at runtime.  A Java-based implementation that converts \nanalysis re\u00adsults to queries that target the popular Hibernate persis\u00adtence system [6].  A practical \napproach to recursive data traversals that un\u00adfolds the recursion in stages of .nite depth.  An evaluation \nof the system using the TORPEDO [22] and OO7 [5] benchmarks.  The current implementation demonstrates \nthe feasibility of this approach, without making changes to the Java lan\u00adguage. Some important features \nare left for future work. Cur\u00ad 1 class Client { ... 2 void reportZip(DataAccess db, int zip) { 3 for \n(Employee e : db.getEmployees()) 4 if (e.zip == zip) 5 printIfOver (e, 65000); 6 } 7 void printIfOver \n(Employee e, .nal int salaryLimit ) { 8 if (e. salary > salaryLimit ) 9 printEmployee(e); 10 } 11 void \nprintEmployee(Employee e) { 12 print(e.name); print(\": \"); 13 print (e.manager.name); 14 }} 15 class \nDataAccess { ... 16 Collection <Employee> getEmployees() { 17 return root.getEmployees(); 18 }} Figure \n1: Procedures and transparent persistence. rently only operations that read persistent data are supported, \nnot updates to persistent values. Aggregation operations and sorting are also not considered. These features \nare easier to implement using high-level queries, as in Linq [4, 24], but would require changes to the \nJava language. It is important to stress that the techniques developed here can also be used in conjunction \nwith queries, as illustrated in the following section. This work suggests that the best solution may \nbe a combination of queries to specify aggregation and sorting, and query extraction to specify prefetching \nand merging. 2. Problem Transparent persistence can be added to most any language by extending the concepts \nof automatic memory manage\u00adment and garbage collection to the management of persistent data: by identifying \na root object as persistent, any object or value reachable from the root is also persistent [2]. For \nex\u00adample, the Java program in Figure 1 uses several procedures to operate on a collection of employee \nobjects. The code is typical of web-based applications in using a data access layer, represented by the \nDataAccess class, to load persistent data. The DataAccess class has direct access to the root vari\u00adable, \nwhich represents a persistent store of objects. The reportZip method calls the getEmployees method of \nthe data access layer to load employees. It then iterates through the employees to .nd the employees \nin a given zip code; these employees are printed using the printIfOver method. The printIfOver method \nchecks employee salaries before print\u00ading. Loading of the employee s manager is lazy: each man\u00adager object \nis loaded when needed. A key problem with this approach is that the entire database of employees must \nbe loaded, even though only a few employees may be printed. The operation should 1 void reportZip(DataAccess \ndb, int zip) { 2 Query q = db.createQuery( // create query 3 from Employee e 4 left join fetch e.manager \n5 where e.zip == :zip 6 and e. salary > : salaryLimit ); 7 // set the parameters 8 q.setParameter(\"zip\", \nzip, Hibernate.INTEGER); 9 q.setParameter(\"salaryLimit\", 65000, Hibernate.INTEGER); 10 for (Employee \ne : q. list ()) // execute the query 11 printEmployee(e); // no test required 12 } Figure 2: Query execution \nusing Hibernate. 1 void reportZip(DataContext db, int zip) { 2 // preload speci.cation 3 DataLoadOptions \ndlo = new DataLoadOptions(); 4 dlo .LoadWith<Employee>(e => e.manager); // ERROR! 5 db.LoadOptions = \ndlo; 6 // query 7 int salaryLimit = 65000; 8 var employees = from e in db.Employee 9 where e.zip == zip \n&#38;&#38; e.salary > salaryLimit 10 select e; 11 foreach (Employee e in employees) 12 printEmployee(e); \n13 } Figure 3: Query and load options in Linq. use an index to .nd the desired employees, using stan\u00addard \ndatabase optimizations. But transparent persistence does not easily leverage the power of database query \nop\u00adtimization. To solve this problem, many persistence mod\u00adels allow programmers to execute queries. \nFor example, Figure 2 is a hand-optimized rewrite of Figure 1 that uses Hibernate, an object-relational \nmapping tool, and its query language HQL [15] to execute a query. The query returns only employees whose \nsalary is over a salary parameter, and whose zip code is a given zip code. The prefetch clause left \njoin fetch e.manager indicates that each employee s manager should also be loaded. The if statements \nin Fig\u00adure 1 are not needed in Figure 2 because the query s where clause ensures the query only returns \nemployees for which the tests are true. Although the programs in Figure 1 and Figure 2 print the same \nresults, they have different performance and software engineering characteristics. For large data sets, \nthe Hiber\u00adnate version will typically be orders of magnitude faster, be\u00adcause it leverages the power \nof relational query optimiza\u00adtion [7]. Despite its performance bene.ts, there are sev\u00aderal well-known \ndrawbacks to the Hibernate version: Query strings and parameters are not checked at compile time for \nsyntax or type safety, and passing parameters is awkward. 1 void reportZip (DataContext db, int zip) \n{ 2 int salaryLimit = 65000; 3 var employees = from e in db.Employee 4 where e.zip == zip &#38;&#38; \ne.salary > salaryLimit 5 join m in db.Employee on e.managerID equals m.ID 6 select new Employee( e.name, \nm ); 7 foreach (Employee e in employees) 8 printEmployee(e); 9 }} Figure 4: Creating results with Linq. \nThese problems have been .xed by more recent query mechanisms, including Linq [4, 24] and Safe Query \nObjects [8]. Figure 3 gives one attempt to implement this program in C# with Linq. In this example, prefetch \nis speci.ed by setting LoadOptions on the DataContext object that executes the query. The sample illustrates \na LoadWith<Employee>(f) option, which speci.es that the object f(o) should be loaded whenever an object \no of a type T is loaded. Unfortunately, the code will generate a runtime error, because load options \nare not allowed to create cycles in the type graph; the exam\u00adple loads an employee (manager) with every \nemployee. Alternatively, Figure 4 uses Linq to create an employee object that contains a manager record, \nwhere the manager is loaded via a join. In this case the select cause of the query calls an Employee \nconstructor that takes two arguments: the name and the manager object. A fundamental problem with queries \nis that the modular\u00adity of the original program in Figure 1 is compromised, be\u00adcause the query in the \nmain function reportZip contains im\u00adplementation details about the behavior of the printEmployee subroutine. \nThe reportZip function would have to be rewrit\u00adten if printEmployee were changed to also print the em\u00adployee \ns department: void printEmployee(Employee e) { print(e.name); print(\": \"); print(e.department.name); \nprint(\", \"); // Added print (e.manager.name); }} The query also merges the conditions that were origi\u00adnally \ngiven separately in reportZip and printIfOver . It may be possible to preserve the original modularity \nof the pro\u00adgram by assembling the query from fragments. However, this effort would signi.cantly complicate \nthe design and in\u00adtroduce more potential for errors. This paper presents query extraction, a technique \nthat can be used to infer queries from procedural programs. The goal is to analyze the program in Figure \n1 and derive the query that is used in Figure 2, while preserving the procedure calls and modularity \nof the original. 3. Overview of Query Extraction Query extraction infers a description of the subset \nof database values that a transparently persistent program needs in order to execute. The technique is \na source-to-source transforma\u00adtion that takes as input an object-oriented program written in a transparent \nstyle and produces an equivalent program that contains explicit queries. Query extraction proceeds in \ntwo stages. First a path-based analysis computes an over\u00adapproximation of the database records required \nby each method in the program. Then the original program is trans\u00adformed so that each method executes \nan explicit query. The explicit query pre-loads the database records speci.ed by the analysis. In this \nsection, we describe the kinds of programs query extraction can handle. We then brie.y outline the analysis \nand transformation phases, which are discussed in more de\u00adtail in Sections 4 6. Data Model Query extraction \nmodels the program s per\u00adsistent data store as a rooted, directed graph of database records. A persistent \nrecord is a labeled product whose .elds contain either basic values or references to other records. A \nreference/relationship can be either single-valued or multi\u00advalued. Given an object, a traversal is a \nseries of .eld ac\u00adcesses that loads one or more related objects. The special variable root represents \nthe unique root of the database. Our implementation relies on Hibernate to provide a description of the \npersistent data schema and to load database values into memory. Program Model Query extraction assumes \nthe program ac\u00adcesses persistent data transparently. The technique requires no change to the language, \nnor does it require the program\u00admer to write annotations. The analysis identi.es persistent data via \na transitive closure of traversals from root. Our prototype implementation operates on a subset of Java. \nIt does not handle features like dynamic class load\u00ading and re.ection. Furthermore, query extraction \nis de.ned for read-only operations on persistent data. Although our im\u00adplementation is for Java, our \ntechnique is applicable to any object-oriented programming language. Path-based Analysis The analysis \nphase of query extrac\u00adtion models program values as paths. A path describes a set of database records \nand consists of three components: 1. The sequence of .eld names that the program traverses to reach the \nrecords, 2. The condition(s) under which the program accesses the records, 3. A data dependence .ag \nthat indicates whether the pro\u00adgram s result depends on the value of the database records.  f . FieldName \nv . VarName l . Literal op . Op -------. p . Path : FieldName \u00d7 AbsOp \u00d7 Dependence ------. o . AbsOp \n: Op \u00d7 AbsValue d . Dependence : {true | false } av . AbsValue : . + Literal + AbsOp + Path s . Store \n: VarName . AbsValue Figure 5: Abstract values. Section 4 describes an intraprocedural path-based analy\u00adsis. \nSection 5 describes how the results of the intraprocedu\u00adral analysis may be composed to compute a whole-program \nanalysis. Program Transformation The program transformation phase of query extraction .rst generates \nexplicit queries based on the analysis results. The phase then outputs a new program that uses explicit \nqueries to pre-load the necessary database values. The new program operates over these pre\u00adloaded data \nvalues. Soundness and Precision Query extraction is sound if the queries for each method in a program \nload all the data necessary to perform the method s operations. A query can be viewed as describing a \nsubset of the database. For each method, the analysis is sound if the subset of the database speci.ed \nby the explicit query can be substituted for the entire database without changing the behavior of the \nmethod. Query extraction is precise if it loads no more data than is needed by each method in the program. \nExact precision is undecidable in general. Our analysis tries to be as precise as possible, and our implementation \ncontains some optimiza\u00adtions that improve precision. 4. Intraprocedural Query Extraction Our previous \napproach to intraprocedural query extraction was expressed as an abstract interpretation for a language \nwith no procedures [29]. This section recasts our previous approach as an attribute grammar, which more \nclosely fol\u00adlows our implementation technique. We .rst de.ne query extraction for a subset of Java that \ncontains no methods. Sec\u00adtion 5 extends query extraction to the interprocedural case. 4.1 Abstract Values \nThe path-based analysis approximates real-world values with abstract values. Figure 5 formally de.nes \nthese abstrac\u00adtions. The domains FieldName and VarName describe the .elds and variables that appear in \na program, respectively. The domains Literal and Op contain literal values (e.g., 1 or \"a\") and operations \n(e.g., == or +) respectively. These domains are syntactic, meaning their elements are described by the \nsyntax of the analyzed programming language. The most important abstract value is a path, which de\u00adscribes \ndatabase values. A path p is represented as a three\u00ad - . tuple (f ,c,d), consisting of an ordered sequence \nof .eld - . names f that identi.es the .elds traversed to reach a set of database values, a condition \nc under which the traversal is performed, and information d about the traversal s data dependences. We \nsometimes elide a path s condition and de\u00adpendence information when that information is not signi.\u00adcant \nor may be easily determined from context. Paths abstract over collections, so that all the objects in \na collection share the same path. A special .eld name . stands for an arbitrary element of a collection. \nFor example, if root contains a collection employees, then the path for that collection is employees; \nthe path for any employee in that collection is employees..; and the path for any employee s salary in \nthat collection is employees... salary . A path s condition describes the circumstances under which a \nprogram accesses data values. The condition is taken from the domain AbsOp, whose elements are syntactic \nex\u00adpressions that contain operators for numerical and logical operations over one or more abstract values. \nEach path s condition is derived from one or more con\u00additional expressions that appear in the program. \nFor exam\u00adple, the program in Figure 1 uses the expressions e.name and e.manager.name only under the enclosing \nif statement s condition e. salary > salaryLimit. A conditional expression that appears in a program \nis a query condition if it can be included in a database query, as described in Section 4.3. If a conditional \nexpression does not satisfy the requirements for being a query condition, then the expression will not \nbe associated with any path. A path s data dependence is a boolean .ag that speci\u00ad.es whether the path \ns values affect the data produced by the program. Data dependence determines whether a path forces loading \nof objects in a collection. For example, Fig\u00adure 1 uses the zip code and salary .elds only in conditional \nexpressions. Even though these paths are used uncondition\u00adally, they do not force loading of the entire \ncollection of em\u00adployees because they are only used to determine control .ow of the program. An abstract \nvalue av can be the bottom element . (which represents unknown information), a set of literals, a set \nof abstract operations, or a set of paths. A Store maps a variable name to an abstract value. 4.2 Attribute \nGrammars An attribute grammar is a way to specify the semantics of a context-free language [18]. An attribute \nis a semantic func\u00adtion that is associated with a given node of a program s Ab\u00adstract Syntax Tree (AST). \nFor a simple calculator language, a value attribute would return the appropriate integer value \u00b7 Abstract \nValue AV(\u00b7) : AbsValue Paths P(\u00b7) : Path Output Store OS(\u00b7) : Store null . \u00d8 IS(\u00b7) l {l} \u00d8 root {(., \ntrue, false )} AV(\u00b7) e. f AV(e).f AV(\u00b7) e1 op e2 AV(e1) op AV(e2) TS(e1) . TS(e2) v IS(\u00b7)[v] \u00d8 v=e . \nTS(e) [v . AV(v) . AV(e)]IS(\u00b7) if e s1 else s2 TS(e) . TS(s1) . TS(s2) OS(s1) . OS(s2) for (v : e) s \nTS(e) . AV(e).. . TS(s) OS(s)/v s1;s2 TS(s1) . TS(s2) OS(s2) other[ e] TS(e) IS(\u00b7) (a) Synthesized attributes. \nInherited Attribute \u00b7 Inherited Attribute Values for Descendants Input Store for (v : e) s IS(s) . [v \n. AV(e)..]IS(\u00b7) . OS(s) IS:Store s1;s2 IS(s2) . OS(s1) Query Condition C : AbsOp if e s1 else s2 C(s1) \n. C(\u00b7) . AV(e) C(s2) . C(\u00b7) . not(AV(e)) if e is a valid query condition Data Dependence D : Dependence \neffectful[ e] D(e) . true Iterator Context IT : --.Path for (v : e) s IT(s) . IT(\u00b7) + AV(e).. if AV(e).. \nextends IT(\u00b7) \u00b7 Traversal Summary TS(\u00b7) : Path v {(AV(\u00b7), C(\u00b7), true) if D(\u00b7) (P(\u00b7), C(\u00b7), false ) if \n\u00acD(\u00b7) v=e TS(e) . iter(\u00b7) other[ \u00b7] P(\u00b7) . {iter(\u00b7) if D(\u00b7) \u00d8 if \u00acD(\u00b7) where iter(\u00b7) = ({last(IT(\u00b7))}, \nC(\u00b7), true) (c) Computing traversal summaries. (b) Inherited attributes. Figure 6: Attribute grammar \nthat computes traversals for a subset of Java syntax. for an AST node of type Int and would return the \nsum of the operands for an AST node of type Add. Attributes are typically partitioned into two classes: \nsyn\u00adthesized and inherited. The value of a synthesized attribute may depend on the values of its node \ns descendants. The value of an inherited attribute may depend on the values of its node s ancestors. \nAttribute values may induce a circular dependence. A .xed-point algorithm computes the value for each \nattribute [20].  4.3 Intraprocedural Path Analysis The intraprocedural path analysis computes a traversal \nsum\u00admary for each statement and expression in a method. A traversal summary is a set of paths representing \nall the data needed to execute a statement or expression. A method s traversal summary may be composed \nwith those of other methods to compute a whole-program analysis. Figure 6 de.nes the path-based analysis \nas an attribute grammar over Java abstract syntax. The traversal summary of a syntactic element is de.ned \nby a synthesized attribute TS. Attribute TS is itself de.ned with the help of three other synthesized \nattributes: AV, P, and OS, whose de.nitions ap\u00adpear in Figure 6a. In this .gure, the \u00b7 symbol represents \na Java expression or statement. Attribute P is a synthesized attribute that collects all the traversal \nsummaries of an ele\u00adment s sub-expressions. The attribute AV represents the abstract value of a given \nexpression or statement. The abstract value of null is ., and the abstract value of a literal is the \nset containing that literal. The abstract value of the special variable root is a path with no .eld traversals \nand the default condition and de\u00adpendence: (., true, false ). A .eld traversal e.f concatenates .eld \nnames to previously computed paths, according to this de.nition: -. - . AV(e).f = {(f .f, c, d) | (f \n,c,d) . AV(e)} Binary operations are interpreted as abstract operators over abstract values; these operations \nare also used to represent query conditions. The synthesized output store attribute OS describes an element \ns effect on the store. The output store is typically a function of the inherited input store attribute \nIS. The way in which stores .ow between elements and their constituents is standard, although a few cases \ndeserve mention. Assignments affect the output store. The resulting store maps the variable to the right-hand-side \ns abstract value. If the input store already contains a value for a given variable, then the output store \ncontains the union of the old and new values. A for statement creates a special path AV(e).. that rep\u00adresents \nan arbitrary element of the collection value e. The attributes of the for statement s body are computed \nusing a store that maps loop variable v to the special path. The body s input store value depends on \nits output store value, which forms a circular dependency (Figure 6b). A variable s abstract value is \nthe value contained in the input store. If the input store contains no binding for a variable, then the \nvariable s abstract value is unde.ned (.). All other Java statements (e.g., exception-handling blocks, \nwhile loops, etc.) are given a default interpretation, by the other case: the paths are unioned and the \nstore is unchanged. Query Conditions Under certain circumstances, a condi\u00adtional expression that appears \nin a program may be shipped to the database as a query condition. Query conditions .lter the data loaded \nby a program. A condition in an if state\u00adment can be a query condition only if it satis.es three re\u00adquirements: \n1) it contains only portable operators, 2) it is pointwise, and 3) if the condition appears in a nested \nloop, the loop s collections must participate in a master-detail re\u00adlationship. An operation is portable \nif it can be performed both in the database and in the program. For example, checking the existence of \na .le is not a portable operation. It is also essential that the operations have the same semantics in \nthe database as in the program. This requires some translation, for example, to provide consistent handling \nof null values in Java and SQL. Restricting query conditions to contain portable operations has little \neffect on programmers, because they would expect only portable operations to be included in a query. \nA condition is pointwise if it can be evaluated on each item of a collection independently of all other \nitems in the collection. The restrictions on query conditions involve checking for loop-carried dependences, \nwhich are identi.ed by a well-known static analysis. Programs very frequently contain loop-carried dependences, \nsince they are created by any aggregation operation, including computing the sum or maximum of a collection. \nHowever, it is much less common that a variable involved in a loop-carried dependence will be used in \na .lter condition. As an example, consider a program that prints only the values that form an increasing \nsequence from a collection: int base = 0; for (Data x in db.getItems()) { if (x. value >= base) { print \n(x.name); base = x.value; }} The analysis will not attach the condition in the example s if statement \nto any paths, because the condition induces a loop-carried dependence. A conditional expression that \nappears in nested loops is a query condition only if the collections over which the loops iterate participate \nin a master-detail relation. An inner-loop collection is a detail of an outer-loop collection if the \nin\u00adner collection is a traversal from the iteration variable of the outer loop. These master-detail loops \nare a common idiom. For example, a program might iterate over all purchase or\u00adders, then iterate over \neach item in the purchase order. Other kinds of nested loops do sometimes arise; they correspond to ad-hoc \njoins that .nd correlations between collections that have no explicit relationship between them. The \nquery condition attribute C de.ned in Figure 6b collects conditions under which an expression or statement \nis executed. The attribute is inherited by all sub-expressions. Data Dependence and Iterators Figure \n6b also de.nes auxiliary inherited attributes data dependence D and iterator context IT. The data dependence \nattribute D .ags expressions whose execution directly affects the program output. It is true for any \nstatement or expression that can affect non-local state, including assignment to object .elds and arguments \nto li\u00adbrary methods (like print methods). Rather than list all con\u00adtexts that can affect the store, they \nare summarized as effect\u00adful[ e] contexts containing an expression e. Data dependence defaults to false \n. The iterator context attribute IT maintains a list of inner\u00aditeration variable paths that extend outer-iteration \npaths. This attribute helps determine whether a conditional expression satis.es the nested restriction \nfor query conditions. IT also helps the analysis keep track of which collections should be marked data-dependent. \nTraversal Summaries Figure 6c de.nes the traversal sum\u00admary attribute TS. It combines the path, condition, \nand data dependence attributes into a traversal summary. Given a set of paths P , a condition c, and \ndata dependence d, the nota\u00adtion (P, c, d) represents a new set of paths whose conditions and data dependence \nare replaced: -. - . (P, c, d)= {(f ,c,d) | (f, , ) . P } The traversal summary computation depends \non the kind of statement or expression being analyzed. For variables, the computation ensures that using \nan expression has the same effect as using a variable that has been assigned the value of the expression. \nAny data-dependent expression generates an extra path that corresponds to the inner-most iteration. The \nintuition behind this de.nition is that data dependence inside a loop causes the program to have a data \ndependence on the iteration variable of the loop. For example, if the loop includes a statement x=x+1 \nthen the program has a data dependence on the existence of the items in the collection (which satisfy \nthe condition C). The formal de.nition adds a data-dependent traversal path for the current iterator \ncontext whenever the analysis encounters an assignment or a data\u00addependent expression. Example Figure \n7 illustrates an application of the path\u00adbased analysis. The analyzed program is a one-method ver\u00adsion \nof the example from Figure 1. Each program statement is numbered, and each number corresponds to a node \nin the program s AST (nodes for expressions are elided). An AST node is represented as a table whose \nmiddle column is the statement number and whose left and right columns contain values for synthesized \nand inherited attributes, respectively. If a node contains no value for an inherited attribute, then \nthat attribute s value is the same as the parent node s value. The analysis begins with an empty input \nstore, a true query condition, and an empty iterator context. Statements one and three are assignments, \nand their corresponding out\u00adput stores contain the results of the assignment. The for loop also modi.es \nthe store by assigning a path to the loop variable e. Note that this assignment appears in the input \nstore for statement .ve. The for loop also sets the iterator context value for statement .ve, to indicate \nthat the loop s body operates on elements of the employees collection. Statements .ve and six are if \nstatements that set the query condition for their corresponding children. Statement seven is effectful \nbecause it prints data, so its traversal summary includes the iterator context. The traversal summary \nfor the entire method consists of the following paths: -. f c d employees employees.. employees...zip \ntrue false employees... salary employees...zip==\"78751\" false employees...name employees...manager.name \nemployees.. employees...zip==\"78751\" . employees... salary > 65000 true 5. Interprocedural Query Extraction \nInterprocedural analysis allows query extraction to propa\u00adgate query information across procedure boundaries. \nWhile the basic framework for our interprocedural analysis is stan\u00addard, several aspects of the problems \nare unique which call for specialized solutions. Query information can .ow in two directions, corre\u00adsponding \nto procedure parameters and return values. For procedure parameters, the caller prefetches the data needed \nby the procedure. For persistent return values, the procedure prefetches the data needed to support the \ntraversals in the caller from the procedure result. Thus the query information moves in the opposite \ndirection from the values. Transmitting query information across procedure bound\u00adaries is dif.cult, especially \nin object-oriented programs that make extensive use of virtual method calls. There are at least .ve possible \napproaches to this situation: devirtualiza\u00adtion, specialization, over-approximation, query separation, \nand dynamic composition. Devirtualization, and closely related class hierarchy anal\u00adysis, are techniques \nto identify a speci.c method that will be called at a given virtual method call site. It works by exam\u00adining \na complete program to discover whether there is only one implementation for a given method signature. \nPolyvariant specialization is a technique for compiling a separate version of the caller for each method \nthat can be called. This technique is used in JIT compilers, where it is very effective. The main drawback \nis the potential for signi.cant increase in code size. Over-approximation could be used to compute a \nquery that approximates the queries from all matching method bodies. This technique works best if the \nqueries from dif\u00adferent virtual methods are similar. If not, extra data could be loaded that is not needed. \nQuery separation is a simple approach: in cases where devirtualization fails, simply require the procedure \nto exe\u00adcute a new query to load its own data. Dynamic composition of static analysis allows queries to \nbe combined across virtual methods calls. It can be used for method arguments and method return values. \nOur current implementation uses devirtualization and query separation to handle callsites with persistent \nparame\u00adters. Our implementation uses dynamic composition to han\u00addle virtual callsites that return persistent \nvalues. The .rst three techniques all rely on the closed-world as\u00adsumption: the results are valid only \nif the dynamic class hier\u00adarchy does not differ from the static class hierarchy. Java pro\u00adgrams can violate \nthis assumption by dynamic class loading and runtime code generation. Techniques have been devel\u00adoped \nto update static analysis results when the set of classes changes dynamically [17]. We believe that these \ntechniques could work with query extraction, but we have not yet tried to integrate them. 5.1 Abstract \nValues To extend the analysis of the previous section to the inter\u00adprocedural case, we must .rst extend \nthe abstract values. Rooted Paths Whereas intraprocedural analysis considers only paths that traverse \nfrom variable root, interprocedural Figure 7: An illustrated example of the intraprocedural, path-based \nanalysis. Each example statement is numbered, and each number corresponds to a node in the AST. Each \nnode is a table whose middle column is the statement number and whose left and right columns contain \nvalues for synthesized and inherited attributes, respectively. If a node contains no value for an inherited \nattribute, then that attribute s value is the same as the parent node s value. analysis must consider \npaths traversed from method param\u00adeters and from method return values. We extend the de.nition of paths \nfrom Section 4.1 to - . include a path root. A rooted path is a four-tuple (r, f ,c,d) where the root \nr can be root, a persistent method parameter, or a callsite return. Path Composition Interprocedural \nquery extraction com\u00adposes traversal summaries to create summaries of data traversals that cross method \nboundaries. The composition operation for paths is: . .. -.--- '' ' (r, f ,c,d) . (r,f ,c ' ,d ')=(r, \nf. f ,c . c ' ,d . d ') Composition is lifted to operate on sets of paths by compos\u00ading all combinations \nof paths from each set. Query Parameters A query parameter is a value that comes from the Java program \nand may be different for each execution of the query. For example, printIfOver in Figure 1 includes a \ncondition that depends on the salaryLimit method parameter. We extend the AbsOp domain to allow operations \nand conditions to refer to local variables (including param\u00adeters). A condition may contain only bindable \nvariables. A variable is bindable if its last assignment occurs before the query which uses the variable \nexecutes. Our current implementation executes queries only at the beginning of a method s execution. \nThus a variable must be a .nal parameter, or a variable that makes a traversal from a .nal parameter. \nThis restriction still allows the condition in Figure 1 to be attached but does not attach a condition \nthat depends on the results of, for example, a virtual method call invoked after executing the query. \n Conditions and Dependence Conditions present a prob\u00adlem for composing paths across procedure boundaries. \nIf a callee path s condition references one of its parameters, then the caller must replace the parameter \nwith its corresponding argument s abstract value. If the callee path s condition ref\u00aderences a local \nvariable, then the caller must conservatively replace that condition with true. If a callsite cannot \nbe devir\u00adtualized, then its arguments are marked data-dependent. 5.2 Interprocedural Path Analysis Interprocedural \nquery extraction extends the language and attribute grammar of Section 4 to include method declara\u00adtions \nM, callsites gl(a1,...,an) and returns return e. The analysis assigns a unique label l to each callsite \nof a method g. The remainder of this section describes how the analysis computes values for declarations, \ncall sites, and returns. Return Statements and Method Declarations A return statement s attributes are \ncomputed from the attributes of the returned expression. A method M s traversal summary is the union \nof its statements summaries. The method s abstract value is the union of all the abstract values for \nthe method s return statements: TS(return e) = TS(e) AV(return e) = AV(e). TS(M) = TS(s) s.M . AV(M) \n= AV(s) s=return e.M Callsites A callsite s traversal summary and abstract value depend on whether the \nanalysis can predict the called 1 public void salaryInfo () { 2 for (Department d : root.departments) \n{ 3 printSalariesAbove (d,65000); 4 printSalariesBelow (d,30000); 5 }} 6 public void printSalariesAbove \n(Department d, 7 .nal double amount) { 8 for (Employee e : d.employees) { 9 if (e. salary > amount) \n10 print (e.name); 11 }} 12 public void printSalariesBelow (Department d, 13 .nal double amount) { 14 \nfor (Employee e : d.employees) { 15 if (e. salary < amount) 16 print (e.name); 17 }} Figure 8: Method \nsalaryInfo can pre-load data for printSalariesAbove and printSalariesBelow . method s data traversals. \nIf so, then the analysis can com\u00adpose the caller s traversals with those of the callee s, in order to \npre-load the callee s data. If a callsite cannot be devirtualized, the called method must execute its \nown query by using its traversal summary and taking the actual method arguments as roots. We denote by \ng l(a1,...,an) a callsite that cannot be devirtualized. The callsite s traversal summary includes its \narguments sum\u00admaries: n . TS( gl(a1,...,an)) = TS(ai) i=1 The callsite s abstract values is a new path \nthat is rooted at the callsite s label: AV( gl(\u00b7\u00b7\u00b7 )) = {(l, ., c, d)} In a static, .nal, or devirtualized \nmethod call, the method implementation that will be invoked by the call is known statically. If the called \nmethod takes persistent parameters, the caller pre-loads the data needed to support that method s traversals \nfrom those parameters. For example, the pro\u00adgram in Figure 8 requires only those employees who make less \nthan $30,000 or more than $65,000. To load just these records ef.ciently, the analysis must synthesize \nthe condi\u00adtions from the two print methods. We de.ne a method s traversal summary to be a map from persistent \nroots to paths. The set of paths a method M traverses from a given parameter Pi is: PM = TS(M)[Pi] i \nThe argument summaries in a devirtualized callsite are composed with the traversal summary of the called \nmethod. If method f calls method g at devirtualized callsite l, the callsite s traversal summary consists \nof the traversals made 1 public void employeeInfo() { 2 for (Department d : root.departments) { 3 for \n(Employee emp : d.employees) { 4 Employee e = getEmpToNotify(emp,65000); 5 print (e.department.name); \n6 }}} 7 public Employee getEmpToNotify(Employee e, 8 .nal double amount) { 9 if (e. salary > amount) \n 10 return e; 11 else 12 return e.manager; 13 } Figure 9: Traversal passes through getEmpToNotify back \nto employeeInfo. by the arguments plus the traversals performed within g. n{} . TS(ai) . TS(gl(a1,...,an)) \n= (AV(ai) . Pg) i i=1 If method g is recursive, then this analysis diverges. We discuss how to ensure \ntermination in Section 5.5. A callee may return a persistent value that depends on its parameters, and \nthe caller may traverse from the returned value. In this case, the caller s traversals pass through the \ncallee. If the callee can be devirtualized, then the caller can pre-load its pass-through traversals. \nFigure 9 contains an example of pass-through traversals. Method getEmpToNotify s return value is the \nresult of a traversal from its .rst parameter e. Method employeeInfo, which calls getEmpToNotify, traverses \nthe return value s department .eld. The analysis of method employeeInfo de\u00adtects this pass-through path \nand generates a summary that includes the department .eld. If a method returns a path that traverses \nfrom a given parameter Pi, then that path is denoted: RM = AV(M)[Pi] i The abstract value domain is \nalso extended by de.ning AV(\u00b7)[R] to be the empty set if it contains only abstract operations. A method \ns pass-through paths are those paths in its return value that are traversals from a parameter value: \nn . TM RM = i i=1 where n is the number of parameters for M. The abstract value of a devirtualized callsite \nconsists of the caller s pass-through paths, plus those values in the callee s abstract value not affected \nby pass-through traver\u00adsals: n . AV(gl(a1,...,an))=( (AV(ai) . Rg)) . (AV(g) - Tg) i i=1 1 public void \nhrDeptInfo() { 2 Department d = getHRDepartment(); 3 for (Employee e : d.employees) { 4 print (e.manager.name); \n5 }} 6 public Department getHRDepartment() { 7 for (Department d : root.departments) { 8 if (d.id == \n1) 9 return d; 10 }} Figure 10: Callee can pre-load caller s data.  5.3 Dynamic Query Composition \nAlthough a caller may not pre-load data for a virtual call\u00ad site, it is possible for the callee to dynamically \npre-load some of its caller s data. For example, assume the analysis deter\u00ad mines that method getHRDepartment \nin Figure 10 is virtual. Then the callsite at line two cannot pre-load its pass-through traversals. Our \nprogram transformation modi.es method calls and de.nitions so that the callee may preload pass-through \ntraversals for the caller. Every method that returns a per\u00ad sistent value is statically changed to take \nan additional argu\u00ad ment Sf that contains the caller s traversals from the callee s return value. The \ncaller also passes a .ag devirtualized that indicates whether the callsite was devirtualized, in which \ncase the callee need not load pass-through paths. The callee uses this information at runtime to generate \na dynamic query TS ' based on its own static traversal summary: { (AV(g) - Tg) . Sf devirtualized TS \n'(g)= TS(g) . AV(g) . Sf otherwise Recall that static query composition from caller to callee requires \nthe caller to bind values for any parameters that ap\u00adpear in the callee s abstract value. Dynamic query \ncomposi\u00adtion from callee to caller similarly requires the callee to bind values for any parameters that \nappear in the callee s return summary. The caller helps satisfy this requirement by pro\u00adviding the callee \nwith the necessary values.  5.4 Query Extraction and Object-Oriented Programming Object-oriented programs \nexhibit several features that re\u00ad quire a customized solution. An instance of a persistent record may \nuse this to reference its .elds. The analysis ac\u00ad commodates this behavior by modeling this as a path \nroot, whenever this is a persistent record. If a program assigns a persistent value to an object s .eld, \nthe analysis marks the assigned expression as dependent. Java strings are instances, rather than primitive \nvalues. As such, string comparison in Java uses a string s equals method. Our analysis detects this comparison \nin if state\u00adments and converts the expression to a query condition, if the expression satis.es the restrictions \nfrom Section 4.3. A common idiom in data-centric, object-oriented pro\u00adgrams is to iterate through a \ncollection and build a new collection by adding an element only if the element satis\u00ad.es some condition. \nIn general, our analysis does not track paths assigned to user-created data. However, for this idiom, \nthe analysis computes the collection s abstract value as the union of the abstract values added to the \ncollection. This ap\u00adproach maintains soundness, under two assumptions: 1) the add method makes no traversals \nof its own and 2) the pro\u00adgram does not modify the user-created collection after read\u00ading it. 5.5 Recursion \nThe analysis may generate in.nite-size values, by examin\u00ading recursive methods or by examining recursive \npaths over which the program iterates. For example: int totalManagerSalaries (Employee e) { if (e != \nnull) { return e. salary + totalManagerSalaries(manager); } else { return 0; } }  In our previous work, \nthe analysis detected recursive .eld traversal and widened the path immediately to .. Thus the analysis \nwas uninformative in the presence of recursive traversals. Our current implementation uses a path represen\u00adtation \nthat is more expressive and generates the path + e.manager . salary Our current implementation also \nwidens abstract values. The join of two values is . if one of the values contains the other. If the analysis \nwidens a query condition to ., then that condition becomes true. 5.6 Soundness We previously proved \nthe soundness of our analysis for a small kernel language. The analysis in this paper is not sound, because \npersistent values may escape through object .elds; however, the program will fallback to the lazy loading \nprovided by the persistence architecture. There is an impor\u00adtant caveat; the persistent architecture \ndoes not know about .ltered collections. If the analysis allows a .ltered collection to escape, then \nsuch a collection may be used by other parts of the program that expect a differently .ltered collection. \nA conservative solution is to remove conditions on a path that represents collection values, if the path \ncan escape. A more sophisticated analysis could keep track when a collec\u00adtion reference escapes the scope \nof a method and reload it as an un.ltered collection. The current analysis also does not handle re.ection. \nIn particular, class loading and dynamic class generation break the devirtualization s closed-world assumption. \nFinally, our implementation like most persistent architectures preserves object reference identity within \na single query, but does not guarantee reference identity across the entire program lifetime. 6. Implementation \nWe implemented query extraction using JastAdd an attribute\u00adgrammar-based compiler system for Java that \nenables pro\u00adgram analyses to be written in a modular, declarative fash\u00adion [14]. Query extraction is \nimplemented as a source to source transformation which rewrites the program to include queries. The transformed \nprogram executes queries in HQL (Hibernate Query Language). The input to the system is a Java program \nand a Hibernate con.guration .le that identi\u00ad.es persistent classes, the mapping of persistent classes \nto database tables, and the location of the database. The output is a Java source program which can be \ncompiled and run on a standard Java virtual machine. 6.1 JastAdd JastAdd compiles circular reference \nattribute grammars into compilers. JastAdd includes a Java 1.5 compiler speci.ca\u00adtion, which we extended \nto perform query extraction. Jas\u00adtAdd provides as part of the Java speci.cation a control .ow analysis \nwhich handles all Java control .ow constructs in\u00adcluding exceptions. Our analysis takes advantage of \nthis con\u00adtrol .ow analysis to connect the input and output store at\u00adtributes. The Java speci.cation also \nincludes an experimen\u00adtal devirtualization analysis.  6.2 Code transformation A persistent method is \na method that accesses the special variable root, takes persistent parameters, or returns a per\u00adsistent \nvalue. For each persistent method m, the analysis pro\u00advides two values: 1. A traversal summary for root, \npersistent parameters, and devirtualized callsites. 2. A traversal summary for the method return value. \n The two traversal summaries are encoded into helper methods named m AV and m RAV, for abstract values \nand result abstract value , respectively. Persistent methods are augmented with three extra ar\u00adguments: \ncallerPaths , callerParams, and loadParams. The callerPaths parameter is a traversal summary for paths \nrooted at the return value of the method. This summary is composed with the traversal summary of the \nmethod at run\u00adtime. The callerParams parameter provides values for any parameters mentioned in callerPaths \n. The loadParams pa\u00adrameter speci.es that the caller could not devirtualize the call to this method. \nIn this case, the method will have to ex\u00adecute queries for any persistent parameters. For example the \n 1 public Bid highBid(double threshold) { 2 AuctionService as = new AuctionService1(); 3 for (Bidb : \nroot. bids) { 4 if (b.amount > threshold) { 5 as. printBid(b); 6 System.out. println (\"Bid of \" + b.amount); \n7 return b; 8 }} 9 return null ; 10 } Figure 11: An example of a method which accesses persis\u00adtent data. \n 1 public Bid highBid( double threshold , 2 AbstractValueSet<Path> avs, 3 Map<String, Object> callerParams, \n4 boolean loadParams) 5 { 6 // Prologue 7 AbstractValueSet<Path> returnAV = highBid RAV(); 8 AbstractValueSet<Path> \nts = highBid AV(); 9 Map<String, Object> queryParamValues = 10 new HashMap<String, Object>(); 11 queryParamValues.put(\"threshold\",threshold); \n12 ts = QueryExecutor.composeWithReturnAV(ts, returnAV, avs, 13 queryParamValues, callerParams, false \n); 14 Map<PathRoot, AbstractValueSet<Path>> 15 tsPartitioned = Path.mapRootToPaths(ts); 16 Root root \n= new edu.utexas.plq.Root(); 17 Map<String, Object> methodParamMap = 18 new QueryExecutor().executeQueries(session \n, 19 root, ts , Root. persistentClasses (), 20 queryParamValues, returnAV, avs, 21 callerParams , loadParams); \n22 23 // Original Code 24 AuctionService as = new AuctionService1(); 25 for (Bidb : root. bids) { 26 \nif (b.amount > threshold) { 27 as.printBid(b, ts.get(new PathRoot(\"callsite_0\"), 28 queryParamValues,true); \n29 return b; 30 }} 31 return null ; 32 } Figure 12: Code transformation for method in Figure 11. code \nin Figure 11 is transformed to the code in Figure 12 which is simpli.ed to omit type packages. Callsites \ninside the method (e.g., lines 27 28 in in Fig\u00adure 12) are transformed to use the version of the method \nthat accepts additional traversal information. 6.3 Query Translation Our prototype compiler targets \nthe Hibernate Query Lan\u00adguage (HQL), which is automatically translated to SQL by the Hibernate library. \nA traversal summary is translated into as few queries as possible given the constraints of HQL. If a \nquery condition contains a traversal from an object which may be null, then the transformed program may \neliminate a NullPointerException that would have occurred in the origi\u00adnal program. This can be .xed \nby adding null checks to the HQL condition or more productively warning the user of this potential bug. \nSupporting recursive queries is challenging, because HQL/SQL do not support transitive closure. The implementation \nsupports recursion by unfolding re\u00adcursive paths a .nite number of times. A query is generated for the \nunfolded traversal summary. If the program traverses beyond the objects already loaded, additional queries \nare executed using the same unfolded traversal summary. The number of unfoldings is a parameter nUnfold \nto query extrac\u00adtion allowing the user to tune how recursive queries are gen\u00aderated. Concretely, if a \nprogram recursively traverses data organized as a binary tree of depth n and nUnfold = m, then the .rst \nquery will retrieve the top m levels of the tree. When the program reaches one of 2m nodes at depth m, \nanother query is executed which retrieves m levels of the subtree rooted at that node. This continues \nuntil the program .n\u00adishes its traversal. In the current implementation, recursive paths are only allowed \nif they are generated by method re\u00adcursion, because the implementation only performs queries at method \nboundaries. Further engineering is required to al\u00adlow the full generality of recursive paths supported \nby the analysis. 7. Evaluation We evaluated query extraction s potential by examining benchmarks that \ncontain transparent code and hand-optimized queries. The results demonstrate that query extraction is \na viable concept. The analysis extracts the same number of queries that appear in the hand-optimized \nversion of per\u00adsistent programs programs that perform only transparent persistence and that contain no \nexplicit queries. The pro\u00adgram generated by query extraction sometimes loads more objects from the database \nthan an equivalent hand-optimized program, because query extraction must statically over\u00adapproximate \na program s data requirements. However the results demonstrate that the analysis is not overly conser\u00advative: \nThe extracted program loads fewer objects than the transparent program in many cases, and the same number \nof objects as the equivalent hand-optimized program in some cases. These two metrics number of queries \nexecuted and number of objects loaded are the most important indica\u00adtors of query extraction s scalability, \nbecause they charac\u00adterize a program s behavior with respect to persistence. Our prototype performs well \nfor these metrics. Other metrics such as total execution time and analysis time indicate the quality \nof our prototype implementation. We present our im\u00adplementation s performance for these metrics and conclude \nthat our prototype performs well except in a few cases. Experimental Con.guration Our experimental con.gura\u00adtion \nconsists of a server that hosts the database and a client machine on which the benchmarks run. The machines \nare located on the same local network, and ping reports an av\u00aderage roundtrip time of about 250 microseconds. \nThe server has a 2.4 GHz Intel Pentium 4 processor with an 8KB L1 cache, 512KB L2 cache, and 1GB RAM. \nThe server s oper\u00adating system is based on the 32bit Linux 2.6.22 kernel, and the database is PostgreSQL \nversion 8.2.6. The client has dual 3.0 GHz Pentium-D processors with a 16KB L1 cache, 1MB L2 cache, and \n2GB RAM. The client s operating system is based on the 32bit Linux 2.6.22 kernel. All the benchmarks \nran on Sun s HotSpot JVM version 1.5.0, with a maximum heap size of 256MB and the ParallelOld garbage \ncollector. Measuring Execution Time Execution time is non\u00addeterministic, due to the random behaviors \nof the operating system and the JVM. To account for non-determinism, we gather a group of sample values \nand report the sample size, mean, and con.dence interval for a 95% con.dence level. We follow a multiple-iteration, \nmultiple-JVM-invocation methodology [11, 12] to gather samples. We run several it\u00aderations of each benchmark \nwithin a single JVM invocation until the execution time reaches a steady state. Then we dis\u00adable the \nJVM compiler, execute another iteration to clear the compilation queue, and compute the mean execution \ntime of ten iterations. This value constitutes a sample execution time for a single benchmark invocation. \nWe gather a group of samples by running multiple invocations. Benchmarks No standard suite of benchmarks \nexists for comparing transparent programs with equivalent, hand\u00adoptimized programs that contain explicit \nqueries. We ex\u00adamined existing database benchmarks and located two that serve our purposes. The TORPEDO \n[22] benchmark mea\u00adsures the number of queries executed by object-relational mappers for Java. The OO7 \nbenchmark [5] measures the performance of object-oriented database management sys\u00adtems. We had to modify \nboth benchmarks, so that we could use them to evaluate our analysis. 7.1 TORPEDO The TORPEDO [22] benchmark \nconsists of a simple data model for an online auction service and 17 use cases which perform various \noperations on sample data. Six of these use cases perform read-only operations; the other 11 use cases \nmodify the data. The application is separated into three layers: a data and persistence layer responsible \nfor loading data from the database, a business logic layer responsible for implementing use cases, and \na view layer responsible for Benchmark Total Persistent? TORPEDO 136 67 OO7 187 123 extracts a query. \nand the benchmark database contains 40 objects. ing three versions of the benchmark. The The transparent \nversion extracted with the special variable root can preload the method s data, and how many are recursive. \nTORPEDO has many persistent methods, but the application layers communicate through interfaces making \ndevirtualiza\u00adtion impossible in some cases. Every use case involves at least three methods in the different \narchitectural layers and most involve many more. The query extraction analysis for TORPEDO took about \n33 seconds. TORPEDO speci.es only that researchers must report the number of queries executed. We report \nnumber of queries executed, number of objects loaded, and execution time, because these metrics provide \na more accurate picture of the behaviors of transparent, hand-optimized, and query\u00adextracted programs. \nQueries Executed Figure 13 shows that query extrac\u00adtion locates and executes the same number of queries \nas the hand-optimized TORPEDO. Both of these versions execute fewer queries than the transparent TORPEDO. \nThe num\u00adbers for each use case include commits. Each use case re\u00adquires a minimum of two queries because \neach use case exe\u00adcutes a commit. For example, the hand-optimized and query\u00adextracted TORPEDO versions \nexecute two queries for the Find All Auctions use case: one query to load all the auc-Figure 13: Number \nof queries executed, number of objects loaded, and execution time for the TORPEDO benchmark. Query extraction \nlocates and executes the same number of queries as the hand-optimized version in all use cases, loads \nfewer objects than the transparent version in all but one use case, and outperforms the transparent version \nin many cases. tions and related objects plus one commit. By contrast, the transparent TORPEDO requires \neight queries to perform the same task: one to load all the auctions, three to load the items for each \nauction, three to load the collections of bids for each auction, and the commit. Objects Loaded In four \nof the six benchmarks, the query\u00adextracted version loads the same number of objects as the hand-optimized \nversion, and both versions load at most as many objects as the transparent version. Find High Bids is \nnaturally an aggregation task, because it searches for the maximum amount bid for a speci.ed auction. \nThe hand\u00adoptimized TORPEDO contains an aggregation query and loads the minimum number of objects. The \nquery-extracted TORPEDO loads all the auctions bids and computes the maximum in the client; however it \nstill loads fewer objects than the transparent version, because the transparent version must .rst search \nfor the speci.ed auction. The query-extracted TORPEDO loads many objects for List Partial Auction , because \nthe code for this use case invokes the same method as List Auction , but passes a boolean .ag that indicates \nthe method should list only a portion of an auction. The analysis is context insensitive and cannot distinguish \nbetween the two cases, so it conser\u00advatively loads all the objects that may be required by the method. \nExecution Time The TORPEDO database does not con\u00adtain much data, so the use cases execute quickly, and \nthere is little difference in execution time among the three ver\u00adsions. The results show that our research-quality \nimplemen\u00adtation is comparable to a hand-optimized program and out\u00adperforms the transparent version in \nall but two cases. The query-extracted version of List Partial Auction executes more complex queries \n(i.e., with more joins) than its trans\u00adparent counterpart, so it takes about twice as much time to execute. \nThe transparent version of List Auction Twice With Transaction takes less time than the other two versions \nbecause it takes advantage of caching. We found the over\u00adhead of run-time query composition to be negligible \n(around .004% of total execution time). We believe that more engi\u00adneering effort would yield even better \nresults.  7.2 OO7 The OO7 [5] benchmark is based on a CAD/CAM applica\u00adtion that de.nes a composite structure \nby a highly recursive and interrelated graph of components and parts. The OO7 benchmark is not representative \nof the most common op\u00aderations in typical transactional/enterprise applications, be\u00adcause OO7 focuses \non extensive traversals of hierarchical structures. However, the benchmark is widely used in the re\u00adsearch \ncommunity and presents some interesting challenges for query extraction. The OO7 speci.cation de.nes \nthree kinds of use cases: queries, traversals, and structural modi.cations. The queries perform read-only \noperations on the data. There are seven query use cases labeled Query 1 through Query 8 (Query 7 does \nnot exist). The traversals scan the object graph and col\u00adlect information. There are six traversal use \ncases, labeled Traversal 1 through Traversal 9 (Traversal 4, Traversal 5, and Traversal 7 do not exist). \nTraversal 2 and Traversal 3 perform database updates; the remaining traversals perform read-only tasks. \nTraversal 1, Traversal 2, Traversal 3, and Traversal 6 rely on recursion to scan the assembly hierarchy \nand part graphs. There are two structural modi.cation use cases. One use cases inserts values into the \ndatabase, and the other deletes values from the database. The speci.cation describes three database sizes: \nsmall, medium, and large. Our evaluation is for the small database size, which contains about 41,000 \nobjects. Our version of the OO7 code contains close to 1,300 lines of code. Our evaluation is based \non a version of OO7 that uses Hibernate 3, which we had implemented for a previous re\u00adsearch effort. \nOur OO7 version implements the 11 read-only use cases in the speci.cation and omits the four use cases \nthat perform updates. The query use cases contain hand\u00adoptimized, explicit queries. We created equivalent, \ntranspar\u00adent versions of these use cases. We then applied query ex\u00adtraction to the transparent use cases \nto generate versions that contain explicit queries. We compare the performance of all three versions. \nThe traversal use cases are based on trans\u00adparent persistence. We applied query extraction to these use \ncases. Neither the OO7 speci.cation nor reference imple\u00admentations provide a version of the traversals \nthat contain hand-optimized queries, so our evaluation for these use cases compares query-extracted performance \nto transparent persis\u00adtence performance. Table 1 lists the persistent characteristics of the methods \nin OO7. The query extraction analysis for OO7 took about 100 seconds. OO7 does not specify which metrics \nto report, so we re\u00adport number of queries executed, number of objects loaded, and execution time. Because \nOO7 contains recursive traver\u00adsals of an object graph, the performance of the query\u00adextracted version \nfor some use cases depends on how deep the analysis unfolds recursive traversals. Query extraction is \nparameterized by this depth, as described in Section 6.3. We .rst performed query extraction with an \nunfolding depth of one. Figures 14a contains the results for the query use cases, and Figure 14b contain \nthe results for the traversal use cases. All execution time values are for a con.dence level of 95% and \na sample size of ten benchmark iterations. Performance for Query Use Cases The evaluation for these uses \ncases compares the performance of hand-optimized, transparent, and query-extracted versions. The query-extracted \nversion executes the same number of queries as the hand\u00adoptimized version for every use case except Query \n8, which performs an ad-hoc join of two collections. Query extrac\u00adtion does not optimize these kinds \nof traversals. The hand\u00ad does not optimize. (b) Performance for traversal use cases. Query extraction \nperforms bet\u00adter than transparent persistence for Traversal 6 and worse than transpar\u00adent persistence \nfor Traversal 1. This difference occurs because Traver\u00adsal 1 traverses a highly connected graph, and \nan HQL query cannot ef.ciently retrieve such a structure. Figure 14: Queries executed, objects loaded, \nand execution time per OO7 query (a) and traversal (b) use case. optimized version loads all the required \nobjects with a single query. The query-extracted version performs one query for each collection, and \nloads too many objects because the use case s condition violates the master-detail restriction dis\u00adcussed \nin Section 4.3. The transparent version executes at least as many queries as the query-extracted version \nfor all use cases. The query-extracted versions of Query 4 and Query 5 execute the same number of queries \nas the corresponding hand-optimized version, but load more objects. These extra objects are due to the \nfact that the transparent program from which the query-extracted version is generated traverses a relationship \nto evaluate a condition, so query extraction must load the traversed object to maintain the program s \nseman\u00adtics. The hand-optimized query references the same relation\u00adship in the query s where clause, but \ndoes not need to load the objects referenced in the condition. The transparent version loads more objects \nthan the other two versions for Query 4 and Query 5. For all use cases except Query 8, the query-extracted \nversion takes time comparable to the other two versions. The query-extracted version of Query 8 takes \nthree orders of magnitude longer to execute than the hand-optimized version, because query extraction \ndoes not optimize this query. Performance for Traversal Use Cases The evaluation for these uses cases \ncompares query-extracted performance (b) Query extraction usually takes less time and executes fewer \nqueries than transparent persistence for Traversal 6. This use case traverses a tree of height six. Figure \n15: Query extraction performance depends upon the structure of traversed data and upon unfolding depth. \nagainst transparent persistence performance. Traversal 8 and Traversal 9 yield uninteresting comparisons \nfor queries exe\u00adcuted and objects loaded, because these use cases traverse a single object. Query extraction \nexecutes fewer queries than transparent persistence for Traversal 1 and Traversal 6. The transparent \nversions of these use cases load objects lazily, as they are traversed. The query-extracted version prefetches \nthese objects and so uses fewer queries. The query-extracted versions of these two use cases always load \nthe same number of objects as the transparent version, because the use cases traverse all the objects \nin the database along a certain path. The execution time for both versions is comparable for Traversal \n8 and Traversal 9. The transparent version per\u00adforms better for Traversal 1; but the query-extracted \nversion performs better for Traversal 6. Figure 15 illustrates this dif\u00adference in more detail by varying \nthe unfolding depth for these two use cases. Figure 15a shows how the number of queries and the execution \ntime vary with unfolding depth for Traversal 1. This use case traverses the entire object graph stored \nin the database a behavior that cannot be easily ex\u00adpressed with a relational query language like HQL. \nAlthough the query-extracted version executes fewer queries than the transparent version, the query-extracted \nversion takes much more time to execute. This overhead is due to the large amount of redundant data in \neach row that is required to rep\u00adresent an object graph in a relational table. As the number of queries \ndecreases, the amount of redundant data increases, so there is an inverse relation between the number \nof queries and the execution time. The results for Traversal 6 highlights query extraction s advantages. \nThis use case traverses a sub-tree of the object graph. Figure 15b shows how the number of queries and \nthe execution time vary with unfolding depth for this use case. Note that the number of queries is a \ngood indication of execution time for this use case. The query-extracted version always executes fewer \nqueries than the transparent version, and takes less time than the transparent version except when the \nunfolding depth is .ve. This spike occurs because the data happens to have a complete tree structure \nof height six. Thus our implementation of recursion described in Section 6.3 is suboptimal for unfolding \ndepths which are not a factor of six. In general, the optimal unfolding depth depends on the data characteristics. \n8. Related Work Interest in the problem of integrating programming lan\u00adguages and databases has enjoyed \na recent resurgence. Most researchers have focused on providing queries as .rst-class members of a programming \nlanguage. Kleisli [31], Haskel-l/DB [19] and Links [9] are functional programming en\u00advironments that \nprovide comprehension syntax as a means to specify database queries. LINQ extends C# s syntax and type \nsystem to include similar features [4]. Safe queries pro\u00advide typed, .rst-class queries for Java [8]. \nThe Java Query Language (JQL) extends Java to support optimizable queries of in-memory objects [30]. \nThese solutions all provide a language-based, safe alter\u00adnative to embedded query strings. They differ \nfrom our solu\u00adtion in that they require programmers to learn a new syntax or API, and that the programmer \nmust write explicit queries. Although these queries bene.t from type-safety and auto\u00admatic conversion \nto a database query language, program\u00admers still bear the burden of declaring their needs for per\u00adsistent \ndata. This declaration introduces a subtle dependency in the program between the structure of the data \ndeclared in the query and the structure of data traversed by the pro\u00adgram. Furthermore, explicit queries \nreduce the modularity of programs by concentrating queries in one program location, reducing opportunities \nto exploit redundant data traversals. Our approach infers a programmer s persistent data use by analyzing \nprograms in an existing language. However, static analysis cannot in general detect common query id\u00adioms \nlike aggregation and existence. New languages, type systems, and constructs also are better solutions \nfor other artifacts of impedance mismatch like null values. It is an open problem to .nd the sweet spot \nbetween these two approaches, but we believe their combination provides the most promise for integrating \nprogramming-languages and databases. Neubauer and Thiemann partition a sequential program executed at \none location into semantically equivalent, in\u00addependent, distributed processes [26]. Their approach pro\u00advides \nsoftware engineering bene.ts similar to ours, except for multi-tier applications. The DBPL language [28] \nand it successor Tycoon [23] explored optimization of search and bulk operations within the framework \nof orthogonal persistence. Tycoon proposed integrating compiler optimization and database query opti\u00admization \n[10]. Queries that cross modular boundaries were optimized at runtime by dynamic compilation [27]. The \nlan\u00adguages included explicit syntax for writing queries or bulk operations on either persistent or non-persistent \ndata. Several researchers have extended object persistence ar\u00adchitectures to leverage traversal context \naccess patterns, including paths to dynamically predict database loads and prefetch the predicted values \n[3, 13, 16]. Because our work generates queries which could be used in object persis\u00adtence architectures, \nthe two techniques could be combined to achieve further performance bene.ts. 9. Conclusion This paper \npresented an automatic technique for extracting queries from object-oriented programs that use transparent \npersistence. The work builds on our previous formal study for query extraction in a kernel language without \nprocedures. The key problem for interprocedural analysis is propagating query information across procedure \nboundaries: persistent data needed for procedure parameters is preloaded by the caller; and conversely, \nthe procedure preloads all the data needed by the call site from its return value. Procedure pa\u00adrameters \nare handled by devirtualization and query separa\u00adtion, while procedure results are handled by a novel \ncom\u00adbination of static analysis and dynamic query composition. While parameters are only preloaded if \ndevirtualization suc\u00adceeds, the dynamic composition always allows a callee to preload data for its caller. \nWe presented a prototype Java compiler with query extraction including support for recur\u00adsion query parameters, \npersistent parameters and return val\u00adues. We evaluated the technique using the TORPEDO and OO7 benchmarks. \nThis work demonstrates the feasibility of query extraction in a practical setting. Acknowledgments We \ngratefully acknowledge the anonymous OOPSLA 2007 and 2008 reviewers, PLDI 2008 reviewers, Ben Delaware, \nand Milind Kulkarni for their comments on the paper. We thank Kathryn McKinley, Mike Bond, and Jungwoo \nHa for their advice on methodology. References [1] M. Atkinson and R. Morrison. Special issue on persistent \nobject systems. VLDB Journal, 4(3), 1995. [2] M. P. Atkinson and R. Morrison. Orthogonally persistent \nobject systems. VLDB Journal, 4(3):319 401, 1995. [3] P. A. Bernstein, S. Pal, and D. Shutt. Context-based \nprefetch for implementing objects on relations. In The VLDB Journal, pages 327 338, 1999. [4] G. M. Bierman, \nE. Meijer, and W. Schulte. The essence of data access in c.. In Proc. of the European Conference on Object-Oriented \nProgramming (ECOOP), pages 287 311, 2005. [5] M. J. Carey, D. J. DeWitt, C. Kant, and J. F. Naughton. \nA status report on the OO7 OODBMS benchmarking effort. In Proc. of ACM Conf. on Object-Oriented Programming, \nSystems, Languages and Applications (OOPSLA), pages 414 426. ACM Press, 1994. [6] D. Cengija. Hibernate \nyour data. onJava.com, 2004. [7] S. Chaudhuri. An overview of query optimization in relational systems. \nIn Proc. of Symp. on Principles of Database System (PODS), pages 34 43, 1998. [8] W. R. Cook and S. Rai. \nSafe query objects: statically typed objects as remotely executable queries. In ICSE 05: Proceedings \nof the 27th international conference on Software engineering, pages 97 106, New York, NY, USA, 2005. \nACM Press. [9] E. Cooper, S. Lindley, P. Wadler, and J. Yallop. Links: Web programming without tiers. \nIn Proceedings of the 5th In\u00adternational Symposium on Formal Methods for Components and Objects, pages \n266 296, Amsterdam, The Netherlands, November 2006. [10] A. Gawecki and F. Matthes. Integrating query \nand program optimization using persistent CPS representations. In M. P. Atkinson and R. Welland, editors, \nFully Integrated Data Environments, ESPRIT Basic Research Series, pages 496 501. Springer Verlag, 2000. \n[11] A. Georges, D. Buytaert, and L. Eeckhout. Statistically rigorous java performance evaluation. In \nOOPSLA 07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems \nand applications, pages 57 76, New York, NY, USA, 2007. ACM. [12] J. Ha, M. Gustafsson, S. M. Blackburn, \nand K. S. McKinley. Microarchitectural characterization of production jvms and java workloads. Mar 2008. \n[13] W.-S. Han, Y.-S. Moon, and K.-Y. Whang. PrefetchGuide: capturing navigational access patterns for \nprefetching in client/server object-oriented/object-relational dbmss. In\u00adformation Sciences, 152(1):47 \n61, 2003. [14] G. Hedin and T. Ekman. The JastAdd system modular extensible compiler construction. Science \nof Computer Programming, 69:14 26, 2007. [15] Hibernate reference documentation. http://www.hibernate. \norg/hib_docs/v3/reference/en/html, May 2005. [16] A. Ibrahim and W. Cook. Automatic prefetching by traversal \npro.ling in object persistence architectures. In Proc. of the European Conference on Object-Oriented \nProgramming (ECOOP), 2006. [17] K. Ishizaki, M. Kawahito, T. Yasue, H. Komatsu, and T. Nakatani. A study \nof devirtualization techniques for a java just-in-time compiler. In OOPSLA 00: Proceedings of the 15th \nACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications, pages 294 \n310, New York, NY, USA, 2000. ACM Press. [18] D. E. Knuth. Semantics of context-free languages. Theory \nof Computing Systems, 2(2):127 145, June 1968. [19] D. Leijen and E. Meijer. Domain speci.c embedded \ncompilers. In Proceedings of the 2nd conference on Domain\u00adspeci.c languages, pages 109 122. ACM Press, \n1999. [20] E. Magnusson and G. Hedin. Circular reference attributed grammars their evaluation and applications. \nSci. Comput. Program., 68(1):21 37, 2007. [21] D. Maier. Representing database programs as objects. In \nF. Bancilhon and P. Buneman, editors, Advances in Database Programming Languages, Papers from DBPL-1, \npages 377 386. ACM Press / Addison-Wesley, 1987. [22] B. E. Martin. Uncovering database access optimizations \nin the middle tier with TORPEDO. In Proceedings of the 21st International Conference on Data Engineering, \npages 916 926. IEEE Computer Society, 2005. [23] F. Matthes, G. Schroder, and J. Schmidt. Tycoon: A scalable \nand interoperable persistent system environment. In M. Atkinson, editor, Fully Integrated Data Environments. \nSpringer-Verlag, 1995. [24] Microsoft Corporation. The LINQ project. msdn. microsoft.com/netframework/future/linq. \n[25] R. Morrison, R. C. H. Connor, G. N. C. Kirby, D. S. Munro, M. P. Atkinson, Q. I. Cutts, A. L. Brown, \nand A. Dearle. The Napier88 persistent programming language and environment. In M. P. Atkinson and R. \nWelland, editors, Fully Integrated Data Environments, pages 98 154. Springer, 1999. [26] M. Neubauer \nand P. Thiemann. From sequential programs to multi-tier applications by program transformation. In Proc. \nof the ACM Symp. on Principles of Programming Languages (POPL), pages 221 232, 2005. [27] J. Schmidt, \nF. Matthes, and P. Valduriez. Building persistent application systems in fully integrated data environments: \nModularization, abstraction and interoperability. In Proceed\u00adings of Euro-Arch 93 Congress. Springer \nVerlag, Oct. 1993. [28] J. W. Schmidt and F. Matthes. The DBPL project: advances in modular database \nprogramming. Inf. Syst., 19(2):121 140, 1994. [29] B. A. Wiedermann and W. R. Cook. Extracting queries \nby static analysis of transparent persistence. In Proc. of the ACM Conf. on Principles of Programming \nLanguages (POPL), pages 199 210, 2007. [30] D. Willis, D. J. Pearce, and J. Noble. Ef.cient object querying \nin Java. In Proc. of the European Conference on Object-Oriented Programming (ECOOP), Nantes, France, \n2006. [31] L. Wong. Kleisli, a functional query system. J. Funct. Program., 10(1):19 56, 2000. [32] M. \nZand, V. Collins, and D. Caviness. A survey of current object-oriented databases. SIGMIS Database, 26(1):14 \n29, 1995.   \n\t\t\t", "proc_id": "1449764", "abstract": "<p>Transparent persistence promises to integrate programming languages and databases by allowing programs to access persistent data with the same ease as non-persistent data. In this work we demonstrate the feasibility of optimizing transparently persistent programs by extracting queries to efficiently prefetch required data. A static analysis derives query structure and conditions across methods that access persistent data. Using the static analysis, our system transforms the program to execute explicit queries. The transformed program composes queries across methods to handle method calls that return persistent data. We extend an existing Java compiler to implement the static analysis and program transformation, handling recursion and parameterized queries. We evaluate the effectiveness of query extraction on the OO7 and TORPEDO benchmarks. This work is focused on programs written in the current version of Java, without languages changes. However, the techniques developed here may also be of value in conjunction with object-oriented languages extended with high-level query syntax.</p>", "authors": [{"name": "Ben Wiedermann", "author_profile_id": "81322510080", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1223145", "email_address": "", "orcid_id": ""}, {"name": "Ali Ibrahim", "author_profile_id": "81100633758", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1223146", "email_address": "", "orcid_id": ""}, {"name": "William R. Cook", "author_profile_id": "81406596033", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1223147", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449767", "year": "2008", "article_id": "1449767", "conference": "OOPSLA", "title": "Interprocedural query extraction for transparent persistence", "url": "http://dl.acm.org/citation.cfm?id=1449767"}