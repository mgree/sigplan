{"article_publication_date": "10-19-2008", "fulltext": "\n Generics of a Higher Kind Adriaan Moors Frank Piessens DistriNet, K.U.Leuven {adriaan, frank}@cs.kuleuven.be \nAbstract With Java 5 and C# 2.0, .rst-order parametric polymor\u00adphism was introduced in mainstream object-oriented \npro\u00adgramming languages under the name of generics. Although the .rst-order variantof genericsisvery useful,it \nalso im\u00adposes some restrictions: it is possible to abstract over a type, but the resulting type constructor \ncannot be abstracted over. This can lead to code duplication.We removed this restric\u00adtion in Scala, by \nallowing type constructors as type param\u00adeters and abstract type members. This paper presents the design \nand implementation of the resulting type construc\u00adtor polymorphism. Furthermore, we study how this feature \ninteracts with existing object-oriented constructs, and show how it makes the language more expressive. \nCategories and Subject Descriptors D.3.3 [Program\u00adming Languages]: Language Constructs and Features Polymorphism \nGeneral Terms Design, Experimentation, Languages Keywords type constructor polymorphism, higher-kinded \ntypes, higher-order genericity, Scala 1. Introduction First-order parametric polymorphism is now a standard \nfea\u00adture of statically typed programming languages. Starting with SystemF[23, 50]and functional programming \nlan\u00adguages, the constructs have found their way into object\u00adoriented languages such as Java, C#, and \nmany more. In these languages, .rst-order parametric polymorphism is usu\u00adally called generics. Generics \nrest on sound theoretical foun\u00addations, which were establishedby Abadi and Cardelli[2, Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 08, October 19 23, \n2008, Nashville,Tennessee, USA. Copyright c . 2008ACM 978-1-60558-215-3/08/10... $5.00 Martin Odersky \nEPFL martin.odersky@ep..ch 1], Igarashi et al.[31], and many others; they are well\u00adunderstoodby now. \nOne standard application area of generics are collections. For instance, the type List[A] represents \nlists of a given element type A, which canbe chosen freely.Infact, generics can be seen as a generalisation \nof the type of arrays, which has always been parametric in the type of its elements. First-order parametric \npolymorphism has some limita\u00adtions, however. Although it allows to abstract over types, which yields \ntype constructors such as List,these type con\u00adstructors cannotbe abstractedover.For instance, one cannot \npass a type constructor as a type argument to another type constructor. Abstractions that require this \nare quite common, even in object-oriented programming, and this restriction thus leads to unnecessary \nduplication of code.We provide several examples of such abstractions in this paper. The generalisation \nof .rst-order polymorphism to a higher-order system was a natural step in lambda calculus [23,50,7]. \nThis theoretical advance has since been incorpo\u00ad rated into functional programming languages.For instance, \nthe Haskell programming language[28]supports type con\u00ad structor polymorphism, which is also integrated \nwith its type class concept[33]. This generalisation to types that abstract over types that abstract \nover types ( higher-kinded types ) has manypractical applications.Forexample, com\u00adprehensions[54], parser \ncombinators[30, 35], as well as more recentwork on embedded Domain Speci.c Languages (DSL s)[14, 26]critically \nrely on higher-kinded types. The same needs as well as more speci.c ones arise in object-oriented programming. \nLINQ brought direct sup\u00adportfor comprehensionstothe.NET platform[5,37],Scala [43]has hada similar feature \nfrom the start, andJava5in\u00ad troduceda lightweight variation[24, Sec. 14.14.2].Parser combinators are \nalsogaining momentum: Bracha uses them as the underlying technology for his Executable Grammars [6], \nand Scala s distribution includesa library[39]that im\u00adplements an embedded DSL for parsing, which allows \nusers to express parsers directly in Scala, in a notation that closely resembles EBNF.Type constructor \npolymorphismis crucial in de.ning a common parser interface that is implemented by different back-ends. \nIn this paper, we focus on our experience with extend\u00ading Scala with type constructor polymorphism, and \non the resultinggaininexpressivityofthe languageasa whole.A similarextension couldbe addedto,forexample,Javainthe \nsameway[3]. Ourextensionwas incorporatedin Scala 2.5, which was released in May 2007. The main contributions \nof this paper are as follows: We illustrate the utility and practicality of type construc\u00adtor polymorphism \nusing a realistic example.  We develop a kind system that captures both lower and upper bounds, and \nvariances of types.  We surveyhow the integration with existing features of Scala (such as subtyping, \nde.nition-site variance annota\u00adtions, and implicit arguments) makes the language more powerful.  We \nrelate our experience with implementing the kind system in the open-source Scala compiler.  Forthe readerwhoisnotyetfamiliarwithScala,thenext \nsectionprovidesabrief introduction.Therestofthispaperis dividedin three parts, which each consideradifferentfacet \nof the evaluation of type constructor polymorphism. First, Section 3 demonstrates that our extension \nreduces boiler\u00adplatethatarisesfromtheuseof genericity.Weestablishintu\u00aditions with a simple example, and \nextend it to a realistic im\u00adplementation of the comprehensions fragment of Iterable. Second, we present \nthe type and kind system. Section 4 discusses the surface syntax in full Scala, and the underly\u00ading model \nof kinds. Based on the ideas established in the theoretical part, Section 5 re.nes Iterable, so that \nit ac\u00adcommodates collections that impose bounds on the type of their elements. Third, wehavevalidated \nthe practicalityof our designby implementing our extension in the Scala compiler, and we reporton ourexperienceinSection \n6. Throughoutthe paper, we discussvarious interactionsof type constructor polymor\u00adphism withexisting \nfeaturesin Scala. Section 7focusses on the integration with Scala s implicits, which are usedto en\u00adcode \nHaskell stype classes. Ourextension lifts this encoding to type constructor classes. Furthermore, due \nto subtyping, Scala supports abstracting over type class contexts, so that the concept of a bounded monad \ncan be expressed cleanly, which is not possible in (mainstream extensions of) Haskell. Finally, we summarise \nrelated work in Section 8 and concludein Section 9. 2. Prelude: Scala Basics This section introduces \nthe basic subset of Scala[43,45]that is usedin theexamplesof this paper.We assumefamiliarity with a Java-like \nlanguage, and focus on what makes Scala different. 2.1 Outline of the syntax A Scala program is roughly \nstructured as a tree of nested de.nitions.Ade.nition starts withakeyword, followedby its name,a classi.er,andtheentityto \nwhichthegiven name is bound, if it is a concrete de.nition. If the root of the tree is the compilation \nunit, the next level consists of objects (introduced by the keyword object)and classes(class, trait), \nwhich in turn contain members. A member may again be a class or an object, a constant value member (val),a \nmutablevalue member(var),a method(def), or a type member(type). Note that a type annotation always follows \nthe name (or, more generally, the expression) that it classi.es. On the one hand, Scala s syntax is very \nregular, with the keyword/name/classi.er/bound entity-sequence being its lead motif. Another important \naspect of this regularity is nesting, which is virtually unconstrained. On the other hand, syntactic \nsugar enables .exibility andsuccinctness.Forex\u00adample, buffer += 10 is shorthand for the method call buffer.+=(10), \nwhere += is a user-de.nable identi.er. 2.2 Functions Since Scalaisa functional language, functions are \n.rst-class values. Thus, like an integer, a function can be written down directly: x: Int . x+1 is the \nsuccessor function on in\u00adtegers. Furthermore,afunctioncanbepassedasanargument to a (higher-order) function \nor method. Functions and meth\u00adods are treated similarly in Scala, the main difference is that a method \nis called on a target object. The following de.nition introduces a function len that takes a String and \nyields an Int by calling String s length method on its argument s: val len: String . Int = s . s.length \nIn the classi.er of the de.nition, the type String . Int,the arrow. isa type constructor,whereasit introduces \nan anonymous function on the right-hand side (whereavalue is expected). This anonymous function takes \nan argument s of type String and returns s.length. Thus, the applica\u00adtion len(\"four\") yields 4. Note \nthat the Scala compiler infers[46]the type of the argument s, based on the expected type of the value \nlen. The direction of type inference can also be reversed: val len = (s: String) . s.length The right-hand \nside s anonymous function can be ab\u00adbreviated using syntactic sugar that implicitly introduces functional \nabstraction. This can be thought of as turning String s length method into a function: val len: String \n. Int = _.length Finally, since Scala is purely object-oriented at its core, a function is represented \ninternally as an object with an apply method that is derived straightforwardly from the function. Thus, \none more equivalent de.nition of len: object len { def apply(s: String): Int = s.length }  2.3 Classes, \ntraits, and objects In Scala, a class can inherit from another class and one or more traits. A trait \nis a class that can be composed with other traits using mixin composition. Mixin compositionisa restricted \nform of multiple inheritance, which avoids ambi\u00adguities by linearising the graph that results from composing \nclasses that are themselves composites. The details are not relevant for this paper, and we simply refer \nto both classes and traits as classes . The feature that is relevant to this paper, is that classes may \ncontain type members. An abstract type member is sim\u00adilartoatype parameter.Themaindifference between \nparam\u00adeters and members is their scope and visibility.A type pa\u00adrameter is syntactically part of the \ntype that it parameterises, whereas a type member like value members is encapsu\u00adlated, and must be \nselected explicitly. Similarly, type mem\u00adbers are inherited, while type parameters are local to their \nclass. The complementary strengths of type parameters and abstract type members areakeyingredientof Scala \ns recipe for scalable component abstractions[47]. Type parameters are made concrete using type applica\u00adtion. \nThus, given the de.nition class List[T], List is a type constructor (or type function), and List[Int] \nis the application of this function to the argument Int. Abstract type members are made concrete using \nabstract type mem\u00adber re.nement, a special form of mixin composition. Note that List is now an abstract \nclass1, since it has an abstract member T: trait List { type T } This abstract member is made concrete \nas follows: List{type T=Int} Note that, with our extension, type members may also be parameterised, as \nin type Container[X]. Methods typically de.ne one or more lists of value pa\u00adrameters, in addition to \na list of type parameters. Thus, a method can be seen as a value that abstracts over values and types. \nFor example, def iterate[T](a: T)(next: T . T, done: T . Boolean): List[T] introduces a method with one \ntype parameter T, and two argument lists. Methods with multiple argument lists may be partially ap\u00adplied. \nFor example, for some object x on which iterate is de.ned, x.iterate(0) corresponds to a higher-order \n1For brevity, we use the trait keyword instead of abstract class. function with type (Int . Int, Int \n. Boolean) . List[Int]. Note that the type parameter T was inferred to be Int from the type of a. Finally, \nan object introduces a class with a singleton instance, which can be referred to using the object s name. \n3. Reducing Code Duplication with Type Constructor Polymorphism This section illustrates the bene.ts \nof generalising generic\u00adity to type constructor polymorphism using the well-known Iterable abstraction. \nThe .rst example, which is due to Lex Spoon, illustrates the essence of the problem in the small. Section \n3.1 extends it to more realistic proportions. Listing 1 shows a Scala implementation of the trait Iterable[T]. \nIt contains an abstract method filter anda convenience method remove. Subclasses should implement filter \nso that it creates a new collection by retaining only the elements of the current collection that satisfy \nthe pred\u00adicate p. This predicate is modelled as a function that takes an element of the collection, which \nhas type T, and returns a Boolean. As remove simply inverts the meaning of the predicate, it is implemented \nin terms of filter. Naturally, when .ltering a list, one expects to again re\u00adceive a list. Thus, List \noverrides filter to re.ne its result type covariantly.For brevity, List s subclasses, which im\u00adplement \nthis method, are omitted.For consistency, remove shouldhavethe same resulttype,buttheonlywaytoachieve \nthis is by overriding it as well. The resulting code duplica\u00adtion is a clear indicator of a limitation \nof the type system: both methods in List are redundant,but the type system is not powerful enough to \nexpress them at the required level of abstraction in Iterable. Our solution, depicted in Listing 2, is \nto abstract over the type constructor that represents the container of the re\u00adsult of filter and remove. \nThe improved Iterable now takes two type parameters: the .rst one, T, stands for the type of its elements, \nand the second one, Container, repre\u00adsents the type constructor that determines part of the result type \nof the filter and remove methods. Morespeci.cally, Container isa type parameter that itselftakes one \ntype pa\u00adrameter. Although the name of this higher-order type param-eter(X)is not needed here, more sophisticatedexamples \nwill show the bene.t of explicitly naming2 higher-order type pa\u00adrameters. Now, to denote that applying \nfilter or remove to a List[T] returns a List[T], List simply instantiates Iterable s type parameter to \nthe List type constructor. In this simpleexample, one could also useaconstruct like Bruce s MyType [9]. \nHowever, this scheme breaks down in more complex cases, as demonstrated in the next section. 2In full \nScala _ may be used as a wild-card name for higher-order type parameters.  Listing 1. Limitations of \nGenericity Listing 2. Removing Code Duplication 3.1 Improving Iterable In this section we design and \nimplement the abstraction that underlies comprehensions[54].Type constructor polymor\u00ad phism plays an \nessential role in expressing the design con\u00adstraints, as well as infactoring out boilerplate code without \nlosing type safety. More speci.cally, we discuss the signa\u00adture and implementation of Iterable s map, \nfilter, and flatMap methods. The LINQ project brought these to the .NET platform as Select, Where, and \nSelectMany [36]. Comprehensions provide a simple mechanism for deal\u00ading with collections by transforming \ntheir elements(map, Select), retrievinga sub-collection(filter, Where), and collecting the elements from \na collection of collections in a single collection(flatMap, SelectMany). To achieve this, each of these \nmethods interprets a user\u00adsupplied function in a different way in order to derive a new collection from \nthe elements of an existing one: map trans\u00adforms the elements as speci.ed by that function, filter interprets \nthe function as a predicate and retains only the el\u00adements that satisfy it, and flatMap uses the given \nfunction to produce a collection of elements for every element in the original collection, and then collects \nthe elements in these collections in the resulting collection. The only collection-speci.c operations \nthat are required by a method such as map, are iterating over a collection, and producing a new one. \nThus, if these operations can be abstracted over, these methods can be implemented in trait Builder[Container[X], \nT] { def +=(el: T): Unit def finalise(): Container[T] } trait Iterator[T] { def next(): T def hasNext: \nBoolean def foreach(op: T . Unit): Unit = while(hasNext) op(next()) } Listing 3. Builder and Iterator \nIterable in terms of these abstractions. Listing 3 shows the well-known, lightweight, Iterator abstraction \nthat en\u00adcapsulates iteratingoveracollection, as well as the Builder abstraction, which captureshowto \nproducea collection,and thus may be thought of as the dual of Iterator. Builder crucially relies on type \nconstructor polymor\u00adphism, as it must abstract over the type constructor that rep\u00adresents the collection \nthat itbuilds. The += method is used to supply the elements in the order in which they should appear \nin the collection. The collection itself is returned by finalise. For example, the finalise method of \na Builder[List, Int] returns a List[Int]. Listing4showsa minimal Buildable with an abstract build method, \nandaconvenience method, buildWith,that captures the typical use-case for build. By analogy to the proven \ndesign that keeps Iterator and Iterable separated, Builder and Buildable are modelled as separate abstractions \nas well. In a full imple\u00admentation, Buildable would contain several more meth\u00adods, such as unfold (the \ndual of fold [22]), which should not clutter the lightweight Builder interface. Note that Iterable uses \na type constructor member, Container, to abstract over the precise type of the con\u00adtainer, whereas Buildable \nuses a parameter. Since clients of Iterable generally are not concerned with the exact type of the container \n(except for the regularity that is im\u00adposed by our design), it is neatly encapsulated as a type member. \nBuildable s primary purpose is exactly to create and populate a speci.c kind of container. Thus, the \ntype of an instance of the Buildable class should specify the type of container thatitbuilds. This informationis \nstillavailable witha type member,butitis less manifest. The map/filter/flatMap methods are implemented \nin terms of the even more .exible trio mapTo/filterTo /flatMapTo. The generalisation consists of decoupling \nthe original collection from the produced one theyneed not be the same,aslongasthereisawayofbuildingthetargetcol\u00adlection. \nThus, these methods take an extra argument of type Buildable[C]. Section 7showshowan orthogonal feature \nof Scala can be used to relieve callers from supplying this argument explicitly. For simplicity, the \nmapTo method is implemented as straightforwardly as possible. The filterTo method shows how the buildWith \nconvenience method can be used. The result types of map, flatMap, and their generali\u00adsations illustrate \nwhy a MyType-based solution would not work: whereas the type of this would be C[T], the result typeof \nthese methodsis C[U]:it is the same typeconstruc\u00adtor,but it is applied to different type arguments! Listings \n5 and 6 show the objects that implement the Buildable interface for List and Option. An Option corresponds \nto a list that contains either 0 or 1 elements, and is commonly used in Scala to avoid null s. With all \nthis in place, List can easily be implemented as a subclass of Iterable, as shownin Listing 7. The type \nconstructor of the container is .xed to be List itself, and the standard Iterator trait is implemented. \nThis implementa\u00adtion does not offer any new insights, so we have omitted it. 3.2 Example: using Iterable \nThisexample demonstrateshowto use map and flatMap to compute the average age of the users of, say, a \nsocial net\u00adworking site. Since users do not have to enter their birthday, the input is a List[Option[Date]]. \nAn Option[Date] trait Buildable[Container[X]] { def build[T]: Builder[Container, T] def buildWith[T](f: \nBuilder[Container,T]. Unit): Container[T] ={ val buff = build[T] f(buff) buff.finalise() } } trait Iterable[T] \n{ type Container[X] <: Iterable[X] def elements: Iterator[T] def mapTo[U, C[X]](f: T . U) (b: Buildable[C]): \nC[U] = { val buff = b.build[U] val elems = elements while(elems.hasNext){ buff += f(elems.next) } buff.finalise() \n } def filterTo[C[X]](p: T . Boolean) (b: Buildable[C]): C[T] = { val elems = elements b.buildWith[T]{ \nbuff . while(elems.hasNext){ val el = elems.next if(p(el)) buff += el } } } def flatMapTo[U,C[X]](f: \nT.Iterable[U]) (b: Buildable[C]): C[U] = { val buff = b.build[U] val elems = elements while(elems.hasNext){ \nf(elems.next).elements.foreach{ el . buff += el } } buff.finalise() } def map[U](f: T . U) (b: Buildable[Container]): \nContainer[U] = mapTo[U, Container](f)(b) def filter(p: T . Boolean) (b: Buildable[Container]): Container[T] \n= filterTo[Container](p)(b) def flatMap[U](f: T . Container[U]) (b: Buildable[Container]): Container[U] \n= flatMapTo[U, Container](f)(b) } Listing 4. Buildable and Iterable object ListBuildable extends Buildable[List]{ \ndef build[T]: Builder[List, T] = new ListBuffer[T] with Builder[List, T] { // += is inherited from ListBuffer \n(Scala standard library) def finalise(): List[T] = toList } } Listing 5. Building a List object OptionBuildable \nextends Buildable[Option] { def build[T]: Builder[Option, T] = new Builder[Option, T] { var res: Option[T] \n= None() def +=(el: T) = if(res.isEmpty) res = Some(el) else throw new UnsupportedOperation -Exception(\">1 \nelements\") def finalise(): Option[T] = res } } Listing 6. Building an Option class List[T] extends Iterable[T]{ \ntype Container[X] = List[X] def elements: Iterator[T] = new Iterator[T] { // standard implementation \n} } Listing 7. List subclasses Iterable either holdsadateor nothing. Listing 8showshowtopro\u00adceed. First, \na small helper is introduced that computes the cur\u00adrentagein yearsfromadateof birth.To collecttheknown \nages, an optional date is transformed into an optional age using map. Then, the results are collected \ninto a list using flatMapTo. Note the use of the more general flatMapTo. WithflatMap, the inner map would \nhave had to convert its result from an Option to a List, as flatMap(f) returns its results in the same \nkind of container as produced by the function f (the inner map).Finally,the results are aggregated using \nreduceLeft (not shown here). The full code of the example is available on the paper s homepage3. Note \nthat the Scala compiler infers most proper types (we added some annotationstoaid understanding),butitdoesnot \n3http://www.cs.kuleuven.be/~adriaan/?q=genericshk val bdays: List[Option[Date]] = List( Some(new Date(\"1981/08/07\")), \nNone, Some(new Date(\"1990/04/10\"))) def toYrs(bd: Date): Int = // omitted val ages: List[Int] = bdays.flatMapTo[Int, \nList]{ optBd . optBd.map{d . toYrs(d)}(OptionBuildable) }(ListBuildable) val avgAge = ages.reduceLeft[Int](_ \n+ _) / ages.length Listing 8. Example: using Iterable infer type constructor arguments. Thus, type argument \nlists that contain type constructors, must be supplied manually. Finally, the only type constructor that \narises in the ex\u00adample is the List type argument, as type constructor infer\u00adence has not been implemented \nyet. This demonstrates that the complexity of type constructor polymorphism, much like with genericity,is \nconcentrated in the internals of the library. The upside is that library designers and implementers have \nmore control over the interfaces of the library, while clients remain blissfully ignorant of the underlying \ncomplexity. (As noted earlier, Section 7willshowhowtheargumentsoftype Buildable[C] can be omitted.) \n 3.3 Members versus parameters The relative merits of abstract members and parameters have been discussed \nin detail by many others[8, 53, 21]. The Scala philosophyis to embrace both: sometimes parameter\u00adisation \nis the right tool, and at other times, abstract members providea better solution.Technically,ithasbeenshownhow \nto safely encode parameters as members[40], which sur\u00adprisingly wasn tpossiblein earlier calculi[44]. \nOur examples have used both styles of abstraction. Buildable s main purposeistobuilda certain container. \nThus, Container is a type parameter: a characteristic that is manifest to external clients of Buildable, \nas it is (syn\u00adtactically) part of the type of its values. In Iterable a type member is used, as its external \nclients are generally only in\u00adterested in the type of its elements. Syntactically, type mem\u00adbers are \nless visible, as Iterable[T] isavalid proper type. Tomakethe type memberexplicit, one may writeIterable \n[T]{type Container[X]=List[X]}. Alternatively, the Container type membercanbe selectedonasingletontype \nthat is a subtype of Iterable[T]. 4. Of Types and Kinds Even though proper types and type constructors \nare placed on equal footing asfar as parametric polymorphism is con\u00adcerned, one must be careful not to \nmix them up. Clearly, a type parameter that stands for a proper type, must not be TypeParamClause ::= \n [ TypeParam { , TypeParam} ] TypeParam ::= id [TypeParamClause] [ >: Type] [ <: Type] AbstractTpMem \n::= type TypeParam Figure 1. Syntax for type declarations (type parameters and abstract type members) \n Figure 2. Diagram of levels applied to type arguments, whereas a type constructor pa\u00adrameter cannot \nclassify a value until it has been turned into a proper type by supplying the right type arguments. In \nthis section we give an informal overview of how programmers may introduce higher-kinded type parameters \nand abstract type members, and sketch the rules that govern their use.We describe the surface syntax \nthatwas introduced with the release of Scala 2.5, and the underlying conceptual model of kinds. 4.1 Surface \nsyntax for types Figure1showsa simpli.ed fragmentof the syntaxof type parameters and abstract type members, \nwhich we collec\u00adtively call type declarations . The full syntax, which ad\u00additionally includesvariance \nannotations,is describedin the Scala language speci.cation[42]. Syntactically, ourexten\u00ad sion introduces \nan optional TypeParamClause as part of a type declaration. The scope of the higher-order type pa\u00adrameters \nthat may thus be introduced, extends over the outer type declaration to which theybelong. For example, \nContainer[X] is a valid TypeParam, which introduces a type constructor parameter that expects one type \nargument. To illustrate the scoping of higher\u00adorder type parameters, Container[X] <: Iterable[X] declares \na type parameter that, when applied to a type argu\u00adment Y written as Container[Y] must be a subtype \nof Iterable[Y]. Asa more complicatedexample, C[X <: Ordered[X]] <: Iterable[X] introduces a type constructor \nparameter C, with an F-bounded higher-order type parameter X, which occurs in its own bound as well as \nin the bound of the type parameter that it parameterises. Thus, C abstractsovera type constructor so \nthat, for any Y that is a subtype of Ordered[ Y], C[Y] is a subtype of Iterable[Y] 4.2 Kinds Conceptually, \nkinds are used to distinguish a type parameter that stands for a proper type, such as List[Int], from \na type parameter that abstractsovera type constructor, such as List. An initial, simplistic kind system \nis illustrated in the diagram in Fig. 2, and it is re.ned in the remainder of this section. The .gure \nshows the three levels of classi.cation, where entities in lower levels are classi.ed by entities in \nthe layer immediately above them. Kinds populate the top layer. The kind * classi.es types that classify \nvalues, and the . kind constructor is used to construct kinds that classify type constructors. Note that \nkinds are inferred by the compiler. They cannot appear in Scala s surface syntax. Nonetheless, Fig. 3 \nintroduces syntax for the kinds that classify the types that can be declared as described in the previous \nsection. The .rst kind, *(T, U), classi.es proper types (such as type declarations without higher-order \ntype parameters), and tracks their lower (T)and upper bounds Kind ::= *( Type , Type ) | [id @ ] Kind \n-> Kind Figure 3. Kinds (not in surface syntax) (U). It should be clear that this kind is easily inferred, \nas type declarations either explicitly specify bounds or receive the minimal lower bound, Nothing, and \nthe maximal upper bound, Any. Note that intersection types can be used to specify a disjunction of lower \nbounds, and a conjunction of upper bounds. Since we mostly use upper bounds, we abbreviate *(Nothing, \nT) to *(T), and *(Nothing, Any) is written as *. We re.ne the kind of type constructors by turning it \ninto a dependent function kind, as higher-order type parameters may appear in their own bounds, or in \nthe bounds of their outer type parameter. In the examples that was introduced above, Container [X] introduces \na type constructor parameter of kind * . *, and Container[X] <: Iterable[X] implies the kind X@* . *(Iterable[X]) \nfor Container. Finally, the declaration C[X <: Ordered[X]] <: Iterable[X] re\u00adsults in C receiving the \nkind X @ *(Ordered[X]) . *( Iterable[X]).Again, the syntax forhigher-order type pa\u00adrameters provides \nall the necessary information to infer a (dependent) function kind for type constructor declarations. \nInformally, type constructor polymorphism introduces an indirection through the kinding rules in the \ntyping rule for type application, so that it uniformly applies to generic classes, type constructor parameters, \nand abstract type con\u00adstructor members. These type constructors, whether concrete or abstract, are assigned \nfunction kinds by the kind system. Thus, if T has kind X@K . K , and U has kind K, in which X has been \nreplaced by U, a type application T[U] has kind K , with the same substitution applied. Multiple type \narguments are supported through the obvious general\u00adisation (taking the necessary care to perform simultaneous \nsubstitutions). 4.3 Subkinding Similar to the subtyping relation that is de.ned on types, subkinding \nrelates kinds. Thus, weoverload <: to operate on kinds as well as on types. As the bounds-tracking kind \nstems from Scala s bounds on type declarations, subkinding for this kind simply follows the rules that \nwere already de.ned for type member conformance: *(T, U) <: *(T , U ) if T <: T and U <: U . Intuitively, \nthis amounts to interval inclusion. For the dependent function kind, we transpose subtypingof dependent \nfunctiontypes[4]tothekindlevel. class Iterable[Container[X], T] trait NumericList[T <: Number] extends \nIterable[NumericList, T] Listing 9. NumericList:an illegal subclass ofIterable class Iterable[Container[X \n<: Bound], T <: Bound, Bound] trait NumericList[T <: Number] extends Iterable[NumericList, T, Number] \n Listing 10. Safely subclassing Iterable 4.4 Example: why kinds track bounds Suppose Iterable4is subclassed \nasin Listing 9. This pro\u00ad gramis rejectedbythe compiler becausethetype application Iterable[NumericList, \nT] is ill-kinded. The kinding rules classify NumericList as a *(Number) . *, which must be a subkind \nof the expected kind of Iterable s .rst type parameter, * . *. Now, *(Number) <: *, whereas subkinding \nfor function kinds requires the argument kinds to vary contravariantly. Intuitively, this type application \nmust be ruled out, be\u00adcause passing NumericList as the .rst type argument to Iterable would forget that \nNumericList may only contain Number s: Iterable is kind-checked under the as\u00adsumption that its .rst type \nargument does not impose any bounds on its higher-order type parameter, and it could thus apply NumericList \nto, say, String. The next section elab\u00adorates on this. Fortunately, Iterable can be de.ned so that it \ncan ac\u00adcommodate bounded collections, as shown in Listing 10. To achieve this, Iterable abstracts over \nthe bound on Container s type parameter. NumericList instantiates this bound to Number.We re.ne thisexamplein \nSection 5. 4.5 Kind soundness Analogous to type soundness, which provides guarantees about value-level \nabstractions, kind soundness ensures that type-level abstractions do not go wrong . At the value level, \npassing, e.g., a String to a function that expects an Integer goes wrong when that function in\u00advokes \nan Integer-speci.c operation on that String.Type soundness ensures that application is type-preserving, \nin the sense that a well-typed application evaluates to a well-typed result. As a type-level example, \nconsider what happens when a type function that expects a type of kind * . *, is applied to a type of \nkind *(Number) . *. This application goes 4For simplicity, we de.ne Iterable using type parameters in \nthis example. trait Builder[Container[X <: B[X]], T <: B[T], B[Y]] trait Buildable[Container[X <: B[X]], \nB[Y]] { def build[T <: B[T]]: Builder[Container,T,B] } trait Iterable[T <: Bound[T], Bound[X]] { type \nContainer[X <: Bound[X]] <: Iterable[X, Bound] def map[U <: Bound[U]](f: T . U) (b: Buildable[Container, \nBound]): Container[U] = ... } Listing 11. Essential changes to extend Iterable with support for (F-)bounds \nwrong, even though the type function itself is well-kinded, ifit does something with that type constructor \nthatwouldbe admissible with a type of kind * . *,but not with a type of kind *(Number) . *, such as applying \nit to String. If the .rst, erroneous, type application were considered well\u00adkinded, type application \nwould not be kind-preserving, as it would turna well-kinded type intoa nonsensical, ill-kinded, one (such \nas NumericList[String]). As our kind system is closely related to dependently typed lambda calculus with \nsubtyping, it is reasonable to as\u00adsume that it is sound. Proving this conjecture, as well as the morefamiliar \nmeta-theoretic results,is ongoingwork. The underlying theory an object-oriented calculus has been describedin \nearlierwork[40]. Finally, it is important to note that kind unsoundness results in type applications \ngoing wrong at compile time. Thus, the problem is less severe than with type unsoundness, but these errors \ncan be detected earlier in the development process, without effort from the programmer. 5. Bounded Iterable \nAs motivated in Section 4.4,in order forIterable to model collections that impose an (F-)bound on the \ntype of their elements, it must accommodate this bound from the start. Toallowsubclasses ofIterable to \ndeclare an (F-)bound on the type of their elements, Iterable must abstract over this bound. Listing 11 \ngeneralises the interface of the orig\u00adinal Iterable from Listing 4. The implementation is not affected \nby this change. Listing 12 illustrates various kinds of subclasses, includ\u00ading List, which does not impose \na bound on the type of its elements, and thus uses Any as its bound(Any and Nothing are kind-overloaded). \nNote that NumericList can also be derived, by encoding the anonymous type function X . Number as Wrap1[Number]#Apply. \nAgain, the client of the collections API is not exposed to the relative complexity of Listing 11. However, \nwithout class List[T] extends Iterable[T, Any] { type Container[X] = List[X] } trait OrderedCollection[T \n<: Ordered[T]] extends Iterable[T, Ordered] { type Container[X <: Ordered[X]] <: OrderedCollection[X] \n} trait Wrap1[T]{type Apply[X]=T} trait Number class NumericList[T <: Number] extends Iterable[T, Wrap1[Number]#Apply] \n{ type Container[X <: Number] = NumericList[X] } Listing 12. (Bounded) subclasses of Iterable it, a signi.cant \nfraction of the collection classes could not be uni.ed under the same Iterable abstraction. Thus, the \nclients of the library bene.t, as a uni.ed interface for col\u00adlections, whether theyconstrain the type \nof their elements or not, means that theyneed to learn fewer concepts. Alternatively, it would be interesting \nto introduce kind\u00adlevel abstraction to solve this problem.Tentatively, Iter\u00adable and List could then \nbe expressed as: trait Iterable[T : ElemK, ElemK : Kind] class List[T] extends Iterable[T, *] This approach \nis more expressive than simply abstracting over the upper bound on the element type, as the interval \nkind can express lower and upper bounds simultaneously. This would become even more appealing in a language \nthat allows the user to de.ne new kinds[51]. 6. Full Scala In this section we discuss our experience \nwith extending the full Scala compiler with type constructor polymorphism. As discussed below, the impact5 \nof our extension is mostly re\u00adstricted to the type checker. Finally, we list the limitations of our implementation, \nand discuss the interaction withvari\u00adance. The implementation supports variance annotations on higher-order \ntype parameters, but this has not been inte\u00adgrated in the formalisation yet. 6.1 Implementation Extending \nthe Scala compiler with support for type construc\u00adtor polymorphism came down to introducing another level \nof indirection in the well-formedness checks for types. Once abstract types could be parameterised (a \nsimple extension to the parser and the abstract syntax trees), the 5The initial patch to the compiler \ncan be viewed at http://lampsvn. epfl.ch/trac/scala/changeset/10642 check that type parameters must \nalways be proper types had to be relaxed. Instead, a more sophisticated mechanism tracks the kinds that \nare inferred for these abstract types. Type application then checks two things: the type that is used \nas a type constructor must indeed have a function kind, and the kinds of the supplied arguments must \nconform to the expected kinds. Additionally, one must ensure that type constructors do not occur as the \ntype of a value. Since Scala uses type erasure in the back-end, the extent of the changes is limited \nto the type checker. Clearly, our extension thus does not have any impact on the run-time characteristics \nof a program. Ironically, as type erasure is at the root of other limitations in Scala, it was an important \nbene.t in implementing type constructor polymorphism. Similarextensionsin languagesthattargetthe.NETplat\u00adform \nface a tougher challenge, as the virtual machine has a richer notion of types and thus enforces stricter \ninvari\u00adants. Unfortunately, the model of types does not include higher-kinded types. Thus, to ensure \nfull interoperability with genericity in other languages on this platform, compil\u00aders for languages with \ntype constructor polymorphism must resort to partial erasure, as well as code specialisation in or\u00adder \nto construct the necessary representations of types that result from abstract type constructors being \napplied to argu\u00adments. 6.1.1 Limitations Syntactically, there are a few limitations that we would like \nto lift in upcoming versions. As it stands, we do not directly support partial type application and currying, \nor anonymous type functions. However, these features can be encoded, as illustratedin Section 5. We have \nnot yet extended the type inferencer to infer higher-kinded types. In all likelihood, type constructor \nin\u00adference will have to be limited to a small subset in order to ensure decidability.  6.2 Variance \nAnotherfacetof the interaction between subtyping and type constructors is seen in Scala s support for \nde.nition-site variance annotations[19].Variance annotations provide the information required to decide \nsubtyping of types that result from applying the same type constructor to different types. As the classical \nexample, consider the de.nition of the class of immutable lists, class List[+T]. The + before List s \ntype parameter denotes that List[T] isa subtypeof List[U] if T is a subtype of U. We say that + introduces \na covariant type parameter, -denotes contravariance (the subtyping relation between the type arguments \nis the inverse of the resulting relation between the constructed types), and the lack of an annotation \nmeans that these type arguments must be identical. Variance annotations pose the same kind of challenge \nto the model of kinds as did bounded type parameters: kinds must encompass them as they represent information \nthat should not be glossed over when passing around type con\u00adstructors. The same strategy as for including \nbounds into * canbeappliedhere,exceptthatvarianceisapropertyoftype constructors, so it should be tracked \nin .,by distinguishing +- . and . [52]. Without going in too much detail, we illustrate the need forvariance \nannotations on higher-order type parameters and how theyin.uence kind conformance. Listing13 de.nesa \nperfectlyvalid Seq abstraction, albeit with a contrived lift method. Because Seq declares C s type parameter \nX to be covariant, it may use its covariant type parameter A as an argument for C, so that C[A] <: C[ \nB] when A <: B. Seq declares the type of its this variable to be C[A] (self: C[A] . declares self as \nan alias for this, and gives it an explicit type). Thus, the lift method may return this, as its type \ncan be subsumed to C[B]. Suppose that a type constructor that is invariant in its .rst type parameter \ncould be passed as the argument for a type constructor parameter that assumes its .rst type parameter \nto be covariant. This would foil the type system s .rst-order variance checks: Seq s de.nition would \nbe invalid if C were invariant in its .rst type parameter. The remainder of Listing 13 sets up a concrete \nexample that would result in a run-time error if the type application Seq[A, Cell] were not ruled out \nstatically. More generally, a type constructor parameter that does not declare any variance for its parameters \ndoes not impose anyrestrictions on the variance of the parameters of its type argument. However, when \neither covariance or contravari\u00adance is assumed, the corresponding parameters of the type argument must \nhave the same variance. 7. Leveraging Scala s implicits In this section we discuss how the introduction \nof type con\u00adstructor polymorphism has made Scala ssupport for implicit arguments more powerful. Implicits \nhave been implemented in Scala since version 1.4. They are the minimal extension to an object-oriented \nlanguage so that Haskell s type classes [56]can be encoded[41]. We .rst show how to improve the example \nfrom Sec\u00adtion3using implicits,sothat clientsof Iterable no longer need to supply the correct instance \nof Buildable[C]. Since there generally is only one instance of Buildable[C] for a particular type constructor \nC,it becomes quite tedious to sup\u00adply it as an argument whenever calling one of Iterable s methods that \nrequires it. Fortunately,Scala simplicits canbe usedto shift thisbur\u00adden to the compiler. It suf.ces \nto add the implicit keyword to the parameter list that contains the b: Buildable[C] parameter, and to \nthe XXXIsBuildable objects.With this change, which is sketched in Listing 14, callers (such as in trait \nSeq[+A, C[+X]] { self: C[A] . def lift[B >: A]: C[B] = this } class Cell[A] extends Seq[A, Cell] { // \nthe only (static) error private var cell: A =_ def set(x: A) = cell = x def get: A = cell } class Top \nclass Ext extends Top { def bar() = println(\"bar\") } val exts: Cell[Ext] = new Cell[Ext] val tops: Cell[Top] \n= exts.lift[Top] tops.set(new Top) exts.get.bar() // method not found error, if // the above static \nerror is ignored Listing 13. Example of unsoundness if higher-order variance annotations are not enforced. \ntheexampleof Listing 8)typicallydo not needto supply this argument. In the rest of this section we explain \nthis feature in or\u00adder to illustrate the interaction with type constructor poly\u00admorphism. With the introduction \nof type constructor poly\u00admorphism, our encoding of type classes is extended to con\u00adstructor classes, \nsuch as Monad, as discussed in Section 7.3. Moreover, our encoding exceeds the original because we in\u00adtegrate \ntype constructor polymorphism with subtyping, so that we can abstract over bounds. This would correspond \nto abstracting over type class contexts, which is not supported in Haskell[29,32,34,15].Section7.3 discusses \nthis in more detail. 7.1 Introduction to implicits The principal idea behind implicit parameters is that \nargu\u00adments for them can be left out from a method call. If the ar\u00adguments corresponding to an implicit \nparameter section are missing, theyare inferred by the Scala compiler. Listing15 introduces implicitsbywayofa \nsimpleexam\u00adple. It de.nes an abstract class of monoids and two concrete implementations, StringMonoid \nand IntMonoid. The two implementations are marked with an implicit modi.er. Listing 16 implements a sum \nmethod, which works over arbitrary monoids. sum s second parameter is marked implicit. Note that sum \ns recursive call does not need to pass along the m implicit argument. The actual arguments that are eligible \nto be passed to an implicit parameter include all identi.ers that are marked trait Iterable[T] { def \nmap[U](f: T . U) (implicit b: Buildable[Container ]): Container[U] = mapTo[U, Container](f) // no need \nto pass b explicitly // similar for other methods } implicit object ListBuildable extends Buildable[List]{...} \nimplicit object OptionBuildable extends Buildable[Option]{..} // client code (previous example, using \nsuccinct function syntax): val ages: List[Int] = bdays.flatMapTo[Int, List]{_.map{toYrs(_)}} Listing \n14. Snippet: leveraging implicits in Iterable abstract class Monoid[T] { def add(x: T, y: T): T def unit: \nT } object Monoids { implicit object stringMonoid extends Monoid[String] { def add(x: String, y: String): \nString = x.concat(y) def unit: String = \"\" } implicit object intMonoid extends Monoid[Int] { def add(x: \nInt, y: Int): Int =x+y def unit: Int = 0 } } Listing 15. Using implicits to model monoids def sum[T](xs: \nList[T])(implicit m: Monoid[T ]): T = if(xs.isEmpty) m.unit else m.add(xs.head, sum(xs.tail)) Listing \n16. Summing lists over arbitrary monoids class Ord a where (<=) :: a . a . Bool instance Ord Date where \n(<=) = ... max :: Ord a . a . a . a max x y = if x <= y then y else x Listing 17. Using type classes \nto overload <= in Haskell implicit, and that can be accessed at the point of the method call withouta \npre.x.For instance, the scopeof the Monoids object can be opened up using an import state\u00adment, such \nas import Monoids._ This makes the two implicit de.nitions of stringMonoid and intMonoid el\u00adigible to \nbe passed as implicit arguments, so that one can write: sum(List(\"a\", \"bc\", \"def\")) sum(List(1, 2, 3)) \n These applications of sum are equivalent to the following two applications, where the formerly implicit \nargument is now given explicitly. sum(List(\"a\", \"bc\", \"def\"))(stringMonoid) sum(List(1, 2, 3))(intMonoid) \n If there are several eligible arguments that match an im\u00adplicit parameter s type, a most speci.c one \nwill be chosen using the standard rules of Scala s static overloading reso\u00adlution. If there is no unique \nmost speci.c eligible implicit de.nition, the call is ambiguous and will result in a static error. 7.2 \nEncoding Haskell s type classes with implicits Haskell stype classeshavegrown froma simple mechanism \nthat deals with overloading[56], to an important tool in dealing with the challenges of modern software \nengineering. Its success has prompted others to explore similar features in Java[57]. 7.2.1 An example \nin Haskell Listing 17 de.nes a simpli.ed version of the well-known Ord type class. This de.nition says \nthat if a type a is in the Ord type class, the function <= with type a . a . Bool isavailable. The instance \ndeclaration instance Ord Date gives a concrete implementation of the <= operation on Date s and thus \nadds Date as an instance to the Ord type class. To constrain an abstract type to instances of a type \nclass, contexts are employed.Forexample, max s signature constrains a to be an instance of Ord using \nthe context Ord a, which is separated from the function s type by a .. Conceptually, a context that constrains \na type a, is trans\u00adlated into an extra parameter that supplies the implementa\u00adtions of the type class \ns methods, packaged in a so-called trait Ord[T] { def <= (other: T): Boolean } import java.util.Date \nimplicit def dateAsOrd(self: Date) = new Ord[Date] { def <= (other: Date) = self.equals(other) || self.before(other) \n} def max[T <% Ord[T]](x: T, y: T): T = if(x <= y) y else x Listing 18. Encoding type classes using Scala \ns implicits method dictionary . An instance declaration speci.es the contents of the method dictionary \nfor this particular type. 7.2.2 Encoding the example in Scala It is natural to turn a type class into \na class, as shown in Listing 18. Thus, an instance of that class corresponds to a method dictionary, \nas it supplies the actual implementa\u00adtions of the methods declared in the class. The instance dec\u00adlaration \ninstance Ord Date is translated into an implicit method that converts a Date into an Ord[Date]. An object \nof type Ord[Date] encodes the method dictionary of the Ord type class for the instance Date. Because \nof Scala s object-oriented nature, the creation of method dictionariesisdrivenby member selection. Whereas \nthe Haskell compiler selects the right method dictionary fully automatically, this processis triggeredby \ncalling miss\u00ading methods on objects of a type that is an instance (in the Haskell sense) of a type class \nthat does provide this method. When a type class method, such as <=, is selected on a type T that does \nnot de.ne that method, the compiler searches an implicitvalue that convertsavalueof type T intoavalue \nthat does support this method. In this case, the implicit method dateAsOrd is selected when T equals \nDate. Note that Scala s scoping rules for implicits differ from Haskell s. Brie.y, the search for an \nimplicit is performed locally in the scope of the method call that triggered it, whereas this is a global \nprocess in Haskell. Contexts are another trigger for selecting method dictio\u00adnaries. The Ord a context \nof the max method is encoded as a view bound T <% Ord[T], which is syntactic sugar for an implicit parameter \nthat converts the bounded type to its view bound. Thus, when the max method is called, the compiler must \n.nd the appropriate implicit conversion. Listing 19 re\u00admoves this syntactic sugar, and Listing 20 goes \neven further and makes the implicits explicit. Clients would then have def max[T](x: T, y: T) (implicit \nconv: T . Ord[T]): T = if(x <= y) y else x Listing 19. Desugaring view bounds def max[T](x: T, y: T)(c: \nT . Ord[T]): T = if(c(x).<=(y)) y else x Listing 20. Making implicits explicit to supply the implicit \nconversion explicitly: max(dateA, dateB)(dateAsOrd). 7.2.3 Conditional implicits By de.ning implicit \nmethods that themselves take implicit parameters, Haskell s conditional instance declarations can be \nencoded: instance Ord a . Ord (List a) where (<=) = ... This is encoded in Scala as: implicit def listAsOrd[T](self: \nList[T])( implicit v: T . Ord[T]) = new Ord[List[T]] { def <= (other: List[T]) = // compare elements \nin self and other } Thus, two lists with elements of type T can be compared as long as their elements \nare comparable. Type classes and implicits both provide ad-hoc polymor\u00adphism. Like parametric polymorphism, \nthis allows methods or classes to be applicable to arbitrary types. However, para\u00admetric polymorphism \nimplies that a method or a class is truly indifferent to the actual argument of its type param\u00adeter, \nwhereas ad-hoc polymorphism maintains this illusion by selecting different methods or classes for different \nactual type arguments. This ad-hoc nature of type classes and implicits can be seen as a retroactive \nextension mechanism. In OOP, vir\u00adtual classes[48, 20]have been proposed as an alternative that is better \nsuited for retroactive extension. However, ad\u00adhoc polymorphism also allows types to drive the selection \nof functionality as demonstrated by the selection of (im\u00adplicit) instances of Buildable[C] in our Iterable \nexam\u00adple6. Buildable clearly could not be truly polymorphic in its parameter, as that would imply that \nthere could be one Buildable thatknewhowto supplya strategyforbuilding anytype of container. class Monad \nm where (>>=) :: m a . (a . m b) . mb data (Ord a) . Set a =... instance Monad Set where --(>>=) :: Set \na . (a . Set b) . Set b Listing 21. Set cannot be made into a Monad in Haskell trait Monad[A, M[X]] { \ndef >>= [B](f: A . M[B]): M[B] } Listing 22. Monad in Scala trait BoundedMonad[A <: Bound[A], M[X <: \nBound[ X]], Bound[X]] { def >>= [B <: Bound[B]](f: A . M[B]): M[B] } trait Set[T <: Ord[T]] implicit \ndef SetIsBoundedMonad[T <: Ord[T]]( s: Set[T]): BoundedMonad[T, Set, Ord] = ... Listing 23. Set as a \nBoundedMonad in Scala  7.3 Exceeding type classes As shown in Listing 21,Haskell s Monad abstraction[55] \ndoes not apply to type constructors with a constrained type parameter, such as Set, as explained below. \nResolving this issuein Haskellis an active research topic[15,16,29]. In this example, the Monad abstraction7 \ndoes not accom\u00admodate constraints on the type parameter of the m type con\u00adstructor thatit abstractsover. \nSince Set isa type constructor that constrains its type parameter, it is not a valid argument for Monad \ns m type parameter: ma is allowed for anytype a, whereas Set a is only allowed if a is an instance of \nthe Ord type class. Thus, passing Set as m could lead to violating this constraint. For reference, Listing \n22 shows a direct encoding of the Monad type class. To solve the problem in Scala, we generalise Monad \nto BoundedMonad in Listing 23 to deal with bounded type constructors. Finally, the encoding from Section \n7.2 is used to turn a Set into a BoundedMonad. 6Java s static overloading mechanism is another example \nof ad-hoc poly\u00ad morphism. 7In fact, the main difference between our Iterable and Haskell s Monad is spelling. \n 8. Related Work 8.1 Roots of our kinds Since the seminal work of Girard and Reynolds in the early 1970 \ns, fragments of the higher-order polymorphic lambda calculus or SystemF. [23,50,7]haveservedasthe basisfor \nmanyprogramming languages.The mostnotableexampleis Haskell[28], which has supported higher-kinded types \nfor over15 years[27]. Although Haskell has higher-kinded types, it eschews subtyping. Most of the use-cases \nfor subtyping are subsumed by type classes, which handle overloading systematically [56]. However, it \nis not (yet) possible to abstract over class contexts[29, 32, 34, 15]. In our setting, this corresponds \nto abstracting over a type that is used as a bound, as discussed in Section 7.3. The interaction between \nhigher-kinded types and subtyp\u00adingisa well-studied subject[13,12,10,49,17].Asfar as we know, none of \nthese approaches combine bounded type constructors, subkinding, subtyping and variance, although all \nof these features are included in at least one of them.A similarity of interest is Cardelli s notion \nof power types[11], which corresponds to our bounds-tracking kind *(L, U). In summary, the presented \ntype system can be thought of as the integration of an object-oriented system with Polar\u00adizedF. [52], \nCardelli s power type, and subkinding. Sub\u00ad sub kinding is based on interval inclusion and the transposition \nof subtyping of dependent function types[4]to the level of kinds. 8.2 Type constructor polymorphism \nin OOPL s Languages with virtual types or virtual classes, such as gbeta [20],can encode type constructor \npolymorphism through ab\u00ad stract type members. The idea is to model a type construc\u00adtor such as List as \na simple abstract type that has a type member describing the element type. Since Scala has virtual types, \nList could also be de.ned as a class with an abstract type member instead of as a type-parameterised \nclass: abstract class List { type Elem } Then,a concrete instantiationof List could be modelled as a \ntype re.nement, as in List{type Elem = String}. The crucial point is that in this encoding List is a \ntype, not a type constructor. So .rst-order polymorphism suf.ces to pass the List constructor as a type \nargument or an abstract type member re.nement. Compared to type constructor polymorphism, this encod\u00ading \nhas a serious disadvantage, as it permits the de.nition of certain accidentally empty type abstractions \nthat cannot be instantiated to concrete values later on. By contrast, type constructor polymorphism has \na kind soundness property that guarantees that well-kinded type applications never re\u00adsult in nonsensical \ntypes. Type constructor polymorphism has recently started to trickle down to object-oriented languages. \nCremet and Al\u00adtherr s work on extending Featherweight Generic Java with higher-kinded types[18]partly \ninspired the design of our syntax. However, since they extend Java, theydo not model type members and \npath-dependent types, de.nition-sitevari\u00adance, or intersection types. They do provide direct support \nfor anonymous type constructors. Furthermore, although theirwork demonstrates that type constructor polymorphism \ncan be integrated into Java, theyonly provide a prototype of a compiler and an interpreter. However, \ntheyhave developed a mechanised soundness proof and a pencil-and-paper proof of decidability. Finally, \nwe brie.y mention OCaml and C++. C++ s tem\u00adplate mechanism is related, but, while templates are very \n.exible, this comes at a steep price: they can only be type\u00adchecked after they have been expanded. Recent \nwork on concepts alleviates this[25]. In OCaml (as in ML), type constructors are .rst-order. Thus, although \na type of, e.g., kind * . * . * is sup\u00adported, types of kind (* . *) . * . * cannot be ex\u00adpressed directly. \nHowever, ML dialects that support applica\u00adtive functors, such as OCaml and Moscow ML, can encode type \nconstructor polymorphism in much the same way as languages with virtual types. 9. Conclusion Genericity \nis a proven technique to reduce code duplication in object-oriented libraries, as well as making them \neasier to use by clients. The prime example is a collections library, where clients no longer need to \ncast the elements they re\u00adtrieve from a generic collection. Unfortunately, though genericity is extremely \nuseful, the .rst-order variant is self-defeating in the sense that abstract\u00adingoverproper typesgives \nrise to type constructors, which cannot be abstracted over. Thus, by using genericity to re\u00adduce code \nduplication, other kindsof boilerplate arise.Type constructor polymorphism allows to further eliminate \nthese redundancies, as it generalises genericity to type construc\u00adtors. As with genericity, most use \ncases for type constructor polymorphism arise in library design and implementation, where it provides \nmore control over the interfaces that are exposed to clients, while reducing code duplication. More\u00adover, \nclients are not exposed to the complexity that is in\u00adherent to these advanced abstraction mechanisms. \nIn fact, clients bene.t from the more precise interfaces that can be expressed with type constructor \npolymorphism, just like genericity reduced the number of casts that clients of a col\u00adlections library \nhad to write. We implemented type constructor polymorphism in Scala 2.5. The essence of our solution \ncarries over easily to Java, see Altherretal.fora proposal[3]. Finally, we have only reported on one \nof several appli\u00adcations that we have experimented with. Embedded domain speci.c languages (DSL s)[14]are \nanother promising appli\u00ad cation area of type constructor polymorphism.We are cur\u00adrently applying these \nideas to our parser combinator library, a DSL for writing EBNF grammars in Scala[39]. Hofer, Ostermann \net al. are investigating similar applications[26], which critically rely on type constructor polymorphism. \nAcknowledgments The authors would like to thank Dave Clarke, Marko van Dooren, Burak Emir,Erik Ernst, \nBart Jacobs, Andreas Ross\u00adberg, Jan Smans, and Lex Spoon for their insightful com\u00adments and interesting \ndiscussions. We also gratefully ac\u00adknowledge the Scala community for providing a fertile testbed for \nthis research. Finally, we thank the reviewers for their detailed comments that helped us improve the \npaper. An older version of this paper was presented at the MPOOL workshop[38]. The .rst author is supported \nby a grant from the Flemish IWT.Partof the reportedworkwas performed duringa3\u00admonth stay at EPFL. References \n[1] M. Abadi and L. Cardelli. A theory of primitive objects: Second-order systems. Sci. Comput. Program., \n25(2-3):81 116, 1995. [2] M. Abadi and L. Cardelli. A theory of primitive objects: Untyped and .rst-order \nsystems. Inf. Comput., 125(2):78 102, 1996. [3]P. AltherrandV. Cremet. Addingtype constructor parameter\u00adizationtoJava. \nAcceptedtotheworkshoponFormalTech\u00adniques for Java-like Programs (FTfJP 07) at the European Conference \non Object-Oriented Programming (ECOOP), 2007. [4] D. Aspinall and A. B. Compagnoni. Subtyping dependent \ntypes. Theor. Comput. Sci., 266(1-2):273 309, 2001. [5] G. M. Bierman, E. Meijer, and W. Schulte. The \nessence of data access in Comega. In A.P. Black, editor, ECOOP, volume 3586 of Lecture Notes in Computer \nScience, pages 287 311. Springer, 2005. [6] G. Bracha. Executable grammars in Newspeak. Electron. Notes \nTheor. Comput. Sci., 193:3 18, 2007. [7] K. B. Bruce, A. R. Meyer, and J. C. Mitchell. The semantics \nof second-order lambda calculus. Inf. Comput., 85(1):76 134, 1990. [8] K. B. Bruce, M. Odersky, andP.Wadler. \nAstatically safe alternative to virtual types. In E. Jul, editor, ECOOP, volume 1445 of Lecture Notes \nin Computer Science, pages 523 549. Springer, 1998. [9]K.B.Bruce,A. Schuett,andR.vanGent.PolyTOIL:Atype\u00adsafe \npolymorphic object-oriented language.InW.G. Olthoff, editor, ECOOP, volume 952 of Lecture Notes in Computer \nScience, pages 27 51. Springer, 1995. [10]P.S. Canning,W.R. Cook,W.L. Hill,W.G. Olthoff, and J. C. Mitchell. \nF-bounded polymorphism for object-oriented programming. In FPCA, pages 273 280, 1989. [11] L. Cardelli. \nStructural subtyping and the notion of power type. In POPL, pages 70 79, 1988. [12] L. Cardelli. Types \nfor data-oriented languages. In J. W. Schmidt, S. Ceri, and M. Missikoff, editors, EDBT, volume 303 of \nLecture Notes in Computer Science, pages 1 15. Springer, 1988. [13] L. Cardelli and P. Wegner. On understanding \ntypes, data abstraction, and polymorphism. ACM Computing Surveys, 17(4):471 522, 1985. [14] J. Carette, \nO. Kiselyov, and C. chieh Shan. Finally tagless, partially evaluated. In Z. Shao, editor, APLAS, volume \n4807 of Lecture Notes in Computer Science, pages 222 238. Springer, 2007. [15] M. Chakravarty, S. L.P. \nJones, M. Sulzmann, andT. Schri\u00adjvers. Class families, 2007. On the GHC Developer wiki, http://hackage.haskell.org/trac/ghc/ \nwiki/TypeFunctions/ClassFamilies. [16] M. M. T. Chakravarty, G. Keller, S. L. P. Jones, and S. Marlow. \nAssociated types with class. In J. Palsberg and M. Abadi, editors, POPL, pages 1 13.ACM, 2005. [17]A.B. \nCompagnoniandH.Goguen.Typed operational seman\u00adtics for higher-order subtyping. Inf. Comput., 184(2):242 \n297, 2003. [18]V. Cremet andP. Altherr. Adding type constructor parame\u00adterization to Java. Journalof \nObjectTechnology, 7(5):25 65, June 2008. Special Issue:Workshop on FTfJP, ECOOP 07. http://www.jot.fm/issues/issue \n2008 06/article2/. [19] B. Emir, A. Kennedy, C. V. Russo, and D. Yu. Variance and generalized constraints \nforC# generics. In D. Thomas, editor, ECOOP, volume 4067 of Lecture Notes in Computer Science, pages \n279 303. Springer, 2006. [20] E. Ernst. gbeta a Language with Virtual Attributes, Block Structure, and \nPropagating, Dynamic Inheritance. PhD thesis, Department of Computer Science, University of Aarhus, \u00b0Arhus, \nDenmark, 1999. [21] E. Ernst. Family polymorphism. In J. L. Knudsen, editor, ECOOP,volume 2072 ofLectureNotes \nin Computer Science, pages 303 326. Springer, 2001. [22] J. Gibbons and G. Jones. The under-appreciated \nunfold. In ICFP, pages 273 279, 1998. [23] J. Girard. Interpretation fonctionelle et elimination des \ncoupures de l arithmetique d ordre superieur. Th `Etat, ese d \u00b4Paris VII, 1972. [24] J. Gosling, B. Joy, \nG. Steele, and G. Bracha. Java(TM) Language Speci.cation, The (3rdEdition) (Java (Addison-Wesley)). Addison-WesleyProfessional, \n2005. [25] D. Gregor, J. J\u00a8arvi, J. G. Siek, B. Stroustrup, G. D. Reis, and A. Lumsdaine. Concepts: linguistic \nsupport for generic programmingin C++.InP.L.TarrandW.R. Cook, editors, OOPSLA, pages 291 310.ACM, 2006. \n[26] C. Hofer,K. Ostermann,T. Rendel, andA. Moors. Polymor\u00adphic embedding of DSLs. InY. Smaragdakis and \nJ. Siek, editors, GPCE.ACM, 2008. To appear. [27] P. Hudak, J. Hughes, S. L. P. Jones, and P. Wadler. \nA history of Haskell: being lazy with class. In B. G. Ryder and B. Hailpern, editors, HOPL, pages 1 55.ACM, \n2007. [28]P. Hudak,S.L.P. Jones,P.Wadler,B. Boutel,J.Fairbairn, J. H. Fasel, M. M. Guzm\u00b4an, K. Hammond, \nJ. Hughes, T. Johnsson, R. B. Kieburtz, R. S. Nikhil,W.Partain, and J. Peterson. Report on the programming \nlanguage Haskell, a non-strict, purely functional language. SIGPLAN Notices, 27(5):R1 R164, 1992. [29] \nJ. Hughes. Restricted datatypes in Haskell. Technical Report UU-CS-1999-28, Department of Information \nand Computing Sciences, Utrecht University, 1999. [30] G. Hutton and E. Meijer. Monadic Parser Combinators. \nTechnical Report NOTTCS-TR-96-4, Department of Com\u00adputer Science, University of Nottingham, 1996. [31]A.Igarashi,B.C. \nPierce,andP.Wadler. FeatherweightJava:a minimal core calculus for Javaand GJ. ACMTrans. Program. Lang. \nSyst., 23(3):396 450, 2001. [32] M. P. Jones. constructor classes &#38; set monad?, 1994. http://groups.google.com/group/comp. \nlang.functional/msg/e10290b2511c65f0. [33] M.P. Jones. Asystem of constructor classes: Overloading and \nimplicit higher-order polymorphism. J. Funct. Program., 5(1):1 35, 1995. [34] E. Kidd. How to make data.set \na monad, 2007. http: //www.randomhacks.net/articles/2007/03/ 15/data-set-monad-haskell-macros. [35] D. \nLeijen and E. Meijer. Parsec: Direct style monadic parser combinators for the real world. Technical Report \nUU-CS\u00ad2001-27, Department of Computer Science, Universiteit Utrecht, 2001. [36] E. Meijer. There is no \nimpedance mismatch: (language integrated query in Visual Basic 9). InP. L.Tarr andW. R. Cook, editors, \nOOPSLA Companion, pages 710 711.ACM, 2006. [37] E. Meijer. Confessions of a used programming language \nsalesman. In R.P. Gabriel, D.F. Bacon, C.V. Lopes, and G. L. S. Jr., editors, OOPSLA, pages 677 694.ACM, \n2007. [38] A. Moors,F. Piessens, andM. Odersky.Towards equal rights for higher-kinded types. Accepted \nfor the 6th International Workshop on Multiparadigm Programming with Object-Oriented Languages at the \nEuropean Conference on Object-Oriented Programming (ECOOP), 2007. [39] A.Moors,F. Piessens, and M. Odersky. \nParser combina\u00adtors in Scala. Technical Report CW491, Department of Computer Science, K.U. Leuven, 2008. \nhttp://www. cs.kuleuven.be/publicaties/rapporten/cw/ CW491.abs.html. [40] A. Moors, F. Piessens, and \nM. Odersky. Safe type-level abstraction in Scala. In Proc. FOOL 08, Jan. 2008. http://fool08.kuis.kyoto-u.ac.jp/. \n[41]M. Odersky.Poorman stypeclasses,July2006.TalkatIFIP WG 2.8, Boston. [42] M. Odersky. The ScalaLanguage \nSpeci.cation,Version 2.6. EPFL, Nov. 2007. http://www.scala-lang.org/ docu/files/ScalaReference.pdf. \n[43] M. Odersky, P. Altherr, V. Cremet, I. Dragos, G. Dubo\u00adchet, B. Emir, S. McDirmid, S. Micheloud, \nN. Mihaylov, M. Schinz, L. Spoon, E. Stenman, and M. Zenger. An Overview of the Scala Programming Language \n(2. edition). Technical report, 2006. [44] M. Odersky,V. Cremet,C.R\u00a8ockl, andM. Zenger.Anominal theory \nof objects with dependent types. In L. Cardelli, editor, ECOOP,volume 2743 ofLectureNotes in Computer \nScience, pages 201 224. Springer, 2003. [45] M. Odersky, L. Spoon, and B.Venners. Programming in Scala. \nArtima, 2008. [46] M. Odersky, C. Zenger, and M. Zenger. Colored local type inference. In POPL, pages \n41 53, 2001. [47] M. Oderskyand M. Zenger. Scalable component abstractions. InR. Johnson andR.P. Gabriel, \neditors, OOPSLA, pages 41 57.ACM, 2005. [48] H. Ossher andW. H. Harrison. Combination of inheritance \nhierarchies. In OOPSLA, pages 25 40, 1992. [49] B. C. Pierce and M. Steffen. Higher-order subtyping. \nTheor. Comput. Sci., 176(1-2):235 282, 1997. [50] J. C. Reynolds. Towards a theory of type structure. \nIn B. Robinet, editor, Symposium on Programming, volume 19 of Lecture Notes in Computer Science, pages \n408 423. Springer, 1974. [51] T. Sheard. Type-level computation using narrowing in Omega. Electr. Notes \nTheor. Comput. Sci., 174(7):105 128, 2007. [52] M. Steffen. Polarized Higher-Order Subtyping. PhD thesis, \nUniversit\u00a8at Erlangen-N\u00a8urnberg, 1998. [53] K. K. Thorup and M. Torgersen. Unifying genericity \u00adcombining \nthe bene.ts of virtual types and parameterized classes. In R. Guerraoui, editor, ECOOP, volume 1628 of \nLectureNotes in Computer Science,pages 186 204. Springer, 1999. [54]P.Wadler. Comprehending monads. Mathematical \nStructures in Computer Science, 2(4):461 493, 1992. [55]P.Wadler. Monadsfor functional programming.InJ. \nJeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer \nScience, pages 24 52. Springer, 1995. [56]P.WadlerandS. Blott.Howtomake ad-hoc polymorphism less ad-hoc. \nIn POPL, pages 60 76, 1989. [57] S.Wehr,R.L\u00a8ammel, andP. Thiemann. JavaGI:Generalized interfaces for \nJava. In E. Ernst, editor, ECOOP, volume 4609 of Lecture Notes in Computer Science, pages 347 372. Springer, \n2007.     \n\t\t\t", "proc_id": "1449764", "abstract": "<p>With Java 5 and C# 2.0, first-order parametric polymorphism was introduced in mainstream object-oriented programming languages under the name of generics. Although the first-order variant of generics is very useful, it also imposes some restrictions: it is possible to abstract over a type, but the resulting type constructor cannot be abstracted over. This can lead to code duplication. We removed this restriction in Scala, by allowing type constructors as type parameters and abstract type members. This paper presents the design and implementation of the resulting type constructor polymorphism. Furthermore, we study how this feature interacts with existing object-oriented constructs, and show how it makes the language more expressive.</p>", "authors": [{"name": "Adriaan Moors", "author_profile_id": "81381603100", "affiliation": "Katholieke Universiteit Leuven, Leuven, Belgium", "person_id": "P1223217", "email_address": "", "orcid_id": ""}, {"name": "Frank Piessens", "author_profile_id": "81100110352", "affiliation": "Katholieke Universiteit Leuven, Leuven, Belgium", "person_id": "P1223218", "email_address": "", "orcid_id": ""}, {"name": "Martin Odersky", "author_profile_id": "81100056476", "affiliation": "&#201;cole Polytechnique F&#233;d&#233;rale de Lausanne, Lausanne, Switzerland", "person_id": "P1223219", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449798", "year": "2008", "article_id": "1449798", "conference": "OOPSLA", "title": "Generics of a higher kind", "url": "http://dl.acm.org/citation.cfm?id=1449798"}