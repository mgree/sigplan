{"article_publication_date": "10-19-2008", "fulltext": "\n Multiple Dispatch in Practice Radu Muschevici Ewan Tempero James Noble Alex Potanin Victoria University \nof Wellington, University of Auckland, Victoria University of Wellington, New Zealand New Zealand New \nZealand {radu|alex}@mcs.vuw.ac.nz ewan@cs.auckland.ac.nz kjx@mcs.vuw.ac.nz Abstract Multiple dispatch \nusesthe run time typesof more than one argumenttoamethodcalltodetermine which methodbody to run. Whileseverallanguagesoverthelast20 \nyearshave provided multiple dispatch, most object-oriented languages still support only single dispatch \n forcing programmers to implementmultiple dispatchmanually whenrequired.This paper presents an empirical \nstudy of the use of multiple dispatchin practice, consideringsixlanguagesthat support multiple dispatch, \nand also investigating the potential for multipledispatchinJava programs.We hope thatthis study will \nhelp programmers understand the uses and abuses of multiple dispatch; virtual machineimplementors optimise \nmultiple dispatch; and language designers to evaluate the choice of providing multiple dispatch in new \nprogramming languages. Categories and Subject Descriptors D.3.3[Programming Languages]: Language Constructs \nand Features Procedures, functions, and subroutines; D.1.0 [Programming Tech\u00ad niques]: General GeneralTerms \nDesign,Experimentation, Languages, Mea\u00ad surement Keywords double dispatch, empirical software engineering, \ninstanceof, multimethods, multiple dispatch 1. Introduction All object-orientedlanguages provide single \ndispatch:when amethodis calledonanobject,the actualmethodexecutedis chosen basedonthedynamictypeofthe \n.rstargumenttothe method (the method receiver, generally self, or this). Some object-orientedlanguages \nprovide multiple dispatch, where Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA 08, October 19 23, 2008, Nashville,Tennessee, USA. Copyright c . 2008ACM \n978-1-60558-215-3/08/10... $5.00 methods can be chosen based on the dynamic types of more than one argument. \nThe goal of this paper is to understand how programmers write programsthat use multiple dispatch whenitisavailable \nandtoinvestigatewhat programmersdo whenitis not. Weasktwo complementary questions.Formultipledispatch \nprograms we ask how muchis multiple dispatch used? what proportion of method declarations dispatch on \nmore than one argument.For single dispatch programs, we ask how muchcould multiple dispatchbe used? \nthat is, what proportionofmethods hand-code idiomsto provide multiple dispatch, or what proportion of \nmethods could be refactored to use multiple dispatch if it was provided by the language. To that end, \nwe describe a corpus analysis of programs written in six languages that provide multiple dispatch (CLOS,Dylan, \nCecil, Diesel, Nice and MultiJava). While therearea rangeofothermultipledispatchlanguages(e.g. Slate \n(Salzman andAldrich 2005)), wefocus on these six languages here becausewewere ableto obtainacorpusfor \neachof these languages.We useJavaasa control subjectin ourstudy.We presenttheresultofa secondanalysisofalarge \ncorpus of Java programs that do not use explicit multiple dispatch. The contributions of this paper are \nas follows: (1) a language independent model of multiple dispatch;(2) a suite of language independent \nmetrics, measuring the use of multiple dispatch; (3) the corpus analysis study usingthose metrics ona \ncollectionof programsin six multipledispatch languages; and (4) a comparison with hand-coded multiple \ndispatch in a large corpus of Java programs. Outline. Section2presentsthe briefhistoryandoverview of \nmultiple dispatch including related work. Section 3 presents a language-independent modelof multiple \ndispatch, and de.nesthemetricswewill useintermsofthat model. Section4thenpresentsthe resultsof ourstudyin \nmultiple dispatch languages, and section 5 presents the results for Javaprograms. Section6puts ourresultsin \nperspective and Section7concludes. 2. Multiple Dispatch In singledispatchlanguages,suchas SIMULA,Smalltalk, \nC++, Java, and C., only the .rst argument of a method call can participatein dynamicmethod lookup.InJava,for \nexample, the .rst argumentofa method callis calledthe receiver object,iswritten beforethe dot ina method \ncall (receiver.method(arguments)), and is called this inside a method body.The classof this .rst argument \ndesignates the methodbodytobeexecuted.Wewillrefertoa methodbody as being specialised ontheclass whereitis \nde.ned, andto the class of that .rst formal parameter as the parameter s specialiser.InJava, asin most \nsingle dispatchlanguages, a method s specialiser is implicitly de.ned by the class enclosing the method \nde.nition, for example: class Car extends Vehicle { void drive () { print( Driving a car ); } void collide \n(Vehicle v) { print( Car crash ); }} In single dispatch languages, every dynamically dis\u00adpatched method \nis specialised on precisely one class so itiseasytothinkofmethods as operations onclasses.Of course, \nsomelanguages mayalsohave non-dispatched meth\u00adods (such as Java static methods) that are not dynamically \ndispatched at all. Following C++, Java and C. also sup\u00adport method overloading, where methods may be \ndeclared withdifferent formal parameter types,but onlythereceiver (the distinguished .rst argument) is \ndynamically dispatched. Given this de.nitionof theVehicle class: abstract class Vehicle { void drive \n() { print( Brmmm! ); } void collide (Vehicle v) { print( Unspeci.ed vehicle collision ); }} thefollowingcodewillinvolvetheCar \nclass s collide(Vehicle) method shown above, and print Car crash . Vehicle car = new Car(); Vehicle bike \n= new Bike(); car.collide(bike); Themethod de.nedin Car is called insteadofthemethod de.ned in Vehicle, \nbecause of the dynamic dispatch onthe .rst argument the receiver of the message. Now,inasingle dispatchlanguage \nthe Car crash method will still be invoked even if the Car class overloaded the collide method with a \ndifferent argument: class Car extends Vehicle { // ... as above void collide (Bike b) { print( Car hits \nbike ); }} but in a multiple dispatchlanguage, the Car hits bike mes\u00adsage would be printed. Getting to \nthe Car.collide(Bike) method from a call of Vehicle.collide(Vehicle) requires two dynamic choices: on \nthetypeofthe .rst this argument and on the typeof thesecond(Vehicle or Bike) argument this iswhythese \nsemantics arecalledmultipledispatch.Amethod that uses multiple dispatch is often called a multimethod. \n 2.1 Classes and Multiple Dispatch Methods in single dispatch languages are usually de.ned in classes, \nand the receiver.method(arguments) syntax for method calls supports the idea that methods are called \non objects (orthat messages are sent to objects asSmalltalk would put it). This does not apply to multiple \ndispatch languages, however, where a concrete method body can be specialised on a combination of classes, \nand so methods are not necessarily associated with a single class. Some multiple dispatchlanguages declaremethods \nseparately, outsidethe class hierarchy, while others consider them part of none, one or several classes, \ndepending on the number of specialised parameters. Since method bodies nolongerhavea one-to\u00ad one association \nwith classes, all parameter specialisers have to be stated explicitly in method body de.nitions, as this \nexampleinthe Nice programming language(Bonniot et al. 2008) shows: abstract Class Vehicle; class Car \nextends Vehicle {}class Bike extends Vehicle {} void drive (Car c) {/* a method specialised on the class \nCar */ print( Driving a car ); } void collide (Car c, Bike m) {/* a method specialised on two classes \n*/ print( Car hits bike ); } Similarly, whileJava method call syntaxfollowsSmalltalk by highlightingthereceiver \nobjectandplacingit before the method name: myCar.drive() , multiple dispatch languages generallyadoptamoresymmetricalsyntaxfor \ncallstogeneric functions: collide(myCar, yourBike); or drive(myCar); , of\u00ad ten while also supporting \nJava-style receiver syntax. 2.2 Single vs Multiple Dispatch Multiple dispatch is more powerful and .exible \nthan single dispatch.Any singledispatch idiom canbe usedina multi\u00adpledispatchlanguage multiple dispatch \nsemantics area supersetofsingle dispatch semantics.Ontheotherhand,im\u00adplementing multiple dispatchidioms \nwill require specialised hand-coding in a single dispatch language. Binary methods (Bruce et al. 1995), \nfor example, operate ontwo objectsofrelatedtypes.The Vehicle.collide(Vehicle) method above is one example \nof a binary method: object equality( Object.equals(Object) ), object comparisons, and arithmeticoperationsareother \ncommonexamples.Inasingle dispatch language,overridingabinary methodinasubclassis notconsidered safe becauseitviolates \nthecontravarianttype checkingrule for functions.For this reason,single dispatch languageslikeSmalltalk \ngenerally use the double dispatch pattern to implement binary methods, encoding multiple dispatch into \na series of single dispatches (Ingalls 1986). Double dispatch is also at the core of the Visitor pattern \n(Gamma et al. 1994) that decouples operations from data structures. Forexample,we couldrewritethe collisionexampleto \nuse the double dispatch pattern in Java as follows: class Car {void collide(Vehicle v) { v.collideWithCar(this); \n} void collideWithCar(Car c) { print( Car hits car ); } void collideWithBike(Bike b) { print( Bike hits \ncar ); } } for the Car class, and class Bike {void collide(Vehicle v) { v.collideWithBike(this); } void \ncollideWithCar(Car c) { print( Car hits bike ); } void collideWithBike(Bike b) { print( Bike hits bike \n); } } for the Bike class. Calling a collide methodprovidesthe .rst dispatch, while the second call \nto a collideWithXXX method provides the second dispatch. The arguments are swappedaround so that each \nargument gets a chance to go .rst and be dispatched upon. External clients of these classes should onlycallthe \ncollide method,while actualimplementations mustbe placed in the collideWithXXX methods. The double dispatchidiomis \ncommonin languageslike Smalltalk where single dispatch is the preferred control structure. Java s instanceof \ntype testprovides an alternative technique for implementing multiple dispatch. The idiom hereisa cascadeof \nif statements, eachtesting an argument s class, and the body of each if corresponding toa multimethod \nbody.To return to the Car class: class Car { void collide(Vehicle v) { if (v instanceof Car) { print( \nCar hits car ); return; } if (v instanceof Bike) { print( Car hits bike ); return; } throw Error( missing \ncase: should not happen ); }} and the Bike class: class Bike { void collide(Vehicle v) { if (v instanceof \nCar) {print( Bike hits car ); return}; if (v instanceof Bike) {print( Bike hits bike ); return}; throw \nError( missing case: should not happen ); }} Compared with directlydeclaring multimethods, either idiom \nfor double dispatchingcodeis tedious to write and error-prone.Codeto dispatch on threeor moreargumentsis \nparticularly unwieldy.Modularityiscompromised,since all participating classes have to be modi.ed upon \nintroducing a new class, either by writing new dispatching methods or new cascaded if branches. The cascaded \nif idiom hasthe advantage thatit doesn tpolluteinterfaceswithdispatchingmethods,but the methodswiththecascades \nbecome increasingly complex, and it is particularly easy to overlook missing cases. 2.3 Multiple Dispatch \nLanguages Multipledispatchwaspioneeredby CommonLoops (Bobrow 1983; Bobrow et al. 1986) and the Common \nLisp Object system(CLOS) (Bobrowetal. 1988),bothaimedatextending Lisp with an object-oriented programming \ninterface. The extensions were meant to integrate smoothly and tightly withtheprocedure-oriented designofLisp \n(Bobrowetal. 1986)andfacilitatetheincrementaltransitionof code from the procedural to the object-oriented \nprogramming style. The basic idea is that a CLOS generic function is made up of one or more methods. \nA CLOS method can have specialisers on its formal parameters, describing types (or individual objects)it \ncan accept.Atruntime,CLOS will dispatcha genericfunctioncall on any or allofits arguments to choose the \nmethod(s)to invoke the particular methods chosen generally depend on a complex resolution algorithm \nto handle anyambiguities. Severalmore recent programming languagesaimtopro\u00advide multimethods in more \nobject-oriented settings. Dy\u00adlan(Feinberg 1997)is based on CLOS.Dylan s dispatch design differs fromCLOSin \nthat itfeatures optional static type declarations which canbe usedto type generic functions, thatis,toconstraintheirparametersto \nsomething morespe\u00adci.c than <object>,therootofallclassesinDylan.Dylan also omitsmuchofthe CLOS scon.gurability,treating \nall arguments identically when determining if a generic function call is ambiguous. Cecil(Chambers 1992)isaprototype-based \nprogramming languagethat features symmetric multimethodsand an op\u00ad tional static type system.Cecil treatseachmethodasencap\u00ad \nsulatedwithineveryclass upon whichitdispatches.Thisway a methodisgivenprivileged accessto all objectsofwhichit \nisa part.Thisis differentfrom, e.g.Java, wheremethods are partof precisely one class and also unlikeCLOS \nor Dylanin which methods are not part of anyclass. Diesel(Chambers 2006)isa descendantofCecil and shares \nmany of its multiple dispatch concepts. The main differencesto CecilareDiesel s module system(unlike \nCecil, Diesel method bodies are separate from the class hierarchy and encapsulated in modules)and explicitgeneric \nfunction de.nitions(which bringitcloserto CLOS).AsinDylanand Cecil, message passing is the only wayto \naccess an object s state. The Nice programminglanguage (Bonniot et al. 2008) strives to offer an alternative \nto Java, enhancing it with multimethods and open classes. In Nice, operations and state can be encapsulated \ninside modules, as opposed to classes. Messagedispatchingis based onthe .rst argument and optionally \non anyother arguments. MultiJava (Clifton et al. 2000) extends Java with multi\u00ad methods and open classes. \nMultiJava retains the concept of a privileged receiver object to associate methods with a single class \nfor encapsulation purposes, however, the runtime selec\u00ad tionofamethodbodyisnolonger based onthe receiver \ns type alone. Rather, anyparameter in addition to the receiver can be specialised.  2.4 Related Work \nThere are of course manyother multiple dispatch languages, whichwehavenotbeenabletoincludein ourstudy:space \ndoes not permit us to describethem all here.Parasitic Multi- methods(Boyland and Castagna 1997)isan earlierextension \ntoJavathatprovides multiple dispatch.Kea (Mugridgeetal. 1991)wasthe .rst staticallytypedlanguage withmultiple \ndispatch. Smalltalk has been extended with multiple dispatch (Footeetal.2005) while Dutchynetal.(2001)modi.edthe \nJava virtualmachine to treat static overloading as dynamic dispatch.Slate(Salzmanand Aldrich 2005)providesmultiple \ndispatch in a Self-like setting. Alternatives to multiple dispatch range from classical dou\u00adbledispatch(Ingalls \n1986) and theVisitor pattern (Gamma et al. 1994) to visitor-oriented programming(Palsbergand Drunen 2004) \nand dispatching on tuplesof objects(Leavens and Millstein 1998). Predicate dispatching generalises mul\u00adtiple \ndispatch to include .eld values and pattern matching (ChambersandChen 1999), whileaspect-orientedprogram\u00adming \n(Kiczales et al. 1997, 2001) is basedaround pointcuts that can dispatch on almost anycombination of events \nand properties in a program s execution. Multipledispatchstudiesareless widespreadthan multiple dispatch \nimplementations Kempf,Harris, D Souza, and Snyder s early1987 study of CLOSis one notable exception. \nTheef.ciencyofimplementation has beenevaluated (Kidd 2001;Footeet al. 2005)aspartoflarger projects:Cunei \nand Vitek (2005) include a recent comparison of the ef.ciencyof a range of multiple dispatch implementations. \nCorpus analysis is a widelyused empirical software en\u00ad gineering research method.There are many recentexamples \naddressing programtopology(Potanin et al. 2005; Baxter etal. 2006),mining patterns(FabryandMens 2004; \nGil and Maman 2005), objectinitialisation(Unkel and Lam 2008), aliasing(Ma andFoster 2007), dependency \ncycles(Melton andTempero 2007),exception handling (Cabral and Marques 2007), and non-nullity (Chalin \nand James 2007). 3. Methodology Inthis sectionwedescribe the methodology underlying our studies. We begin \nby introducing a language-independent modelfor multiple dispatch, describe each of the multiple dispatchlanguagesintermsofthatmodel, \nandgiveaJava Figure 1. AModel for Multimethod Analysis.GFrefers to genericfunction,CMrefersto concretemethod,and \nspec refers to specialiser. example asa control.Wethen use the model to de.ne metrics for multiple dispatch. \n 3.1 Modelling Dynamic Dispatch We begin by describing a language-independent model of dynamic dispatch. \nThe model,showninFigure1,is designed to allow us to compare multiple dispatch consistently across different \nprogramming languages. The model s terminology has beenchosentomatch general usage, ratherthanfollowing \nanyparticular programming language. Section 3.3 will use the model to de.ne the metrics that can be used \nacross a rangeof programming languages.We now present the main entities of the model in turn. Generic \nfunction Agenericfunctionisa functionthatmay be dynamically dispatched, such as a CLOSgeneric function, \na Smalltalk message, or Java method call. Each generic function will have one or more concrete methods \nassociated withit:callinga genericfunctionwillinvokeone(ormore) oftheconcretemethodsthat belongtothat \nfunction. Generic functions are identi.ed by a name and a signature. Some languagesallowa generic functiontobe \nde.nedexplicitly (e.g. CLOS s defgeneric), whereasin otherlanguages(such asJava)theyareimplicit andmustbeinferredfrom \nmethod de.nitions. Somelanguagesalso automatically generate genericfunc\u00ad tionsasaccessorstoall .elddeclarations.Becausewewish \nto focus on programmer speci.ed multiple dispatch methods, we omitautomatically generated accessors from \nour analysis. Name Generic functions and concrete methods are referred to by their names. In our model, \na name is always fully\u00ad quali.ed , that is, if a namespace is involvedthen thatinfor\u00ad mationis partof \nthe name.Toavoidambiguity, ouranalyses always compute fully-quali.ed names where necessary. Signature \nThe permissibleargumentstoa generic function are de.nedbythatfunction s signature, and allthe concrete \nmethods belonging to a generic function must be compatible with thatsignature.Inlanguageswith only dynamictyping, \na generic functions signature may be simply the number of arguments required by the function: some language \ns signatures additionally support re.nements suchas variable language typing GF term GF dfn CM term \nCM grouped in GF multi accessor CLOS dyn generic function explicit method name a no auto Dylan opt generic \nfunction explicit method name a no auto Cecil opt method implicit method body name+#args no auto Diesel \nopt function explicit method name+#args no auto Nice static method declaration implicit method implementation \nname+#args+types yes MultiJava static method family implicit method name+#args+types no Java static method \ncall implicit method body name+#args+types yes Smalltalk dyn message implicit method name(+#args) b no \n a All argument lists (lambda lists) must be congruent. b Smalltalk message selectors encode the number \nof arguments to the message. Figure 2. Multimethodsacrosslanguages.Columns describe language name; static, \ndynamic, or optionally static typing;the terminology used for genericfunction (GF);whether generic function \nde.nitions areexplicit orimplicit;theterm usedfor concretemethod (CM);how concrete methods are groupedinto \ngeneric functions(i.e.howa generic function signatureis de.ned);whetherone concretefunctioncanbepartofmultiplegenericfunctions;andwhetherthelanguageautomatically \ngenerates accessor messages (which we elide from our analysis). lengthargumentlists orkeyword arguments.In \nlanguages with(optional or mandatory)statictypesystems,a generic function s signature will also de.ne \nstatic types for each formal argument of the function. Some languages have implicit parameters (such \nas the receiver or this parameterintraditional object-oriented languages such as SIMULA, Smalltalk, \nJava, C++, C#). In our model, these parameters are made explicit in the signature (hence our useof the \nterm function ).Inthe case oftraditionalobject-orientedlanguages,the receiveristhe .rst formal parameter \nposition. Concrete method Aconcrete method gives one code body fora generic function roughlycorrespondingtoa \nfunction in Pascal or C, a method in Java or Smalltalk, or CLOS method.Aswell asthis code,a concretemethodwillhave \na name and an argument list the argumentlist mustbe compatible with thesignature ofits generic function(as \nalways dependingontherulesofaparticularlanguage).A concrete method may also have a specialiser for eachformal \nargument position. The rules of each language determine the generic function(s) to which a given concrete \nmethod belongs. Specialiser Formal parameters of a concrete method can have specialisers. Specialisers \nare used to select which con\u00ad cretemethodtorun whena genericfunctioniscalled.When agenericfunctionis \ncalled, the actual arguments to the call areinspected, and only those concretemethods whose for\u00admalspecialisers \nmatchthose arguments canbeinvokedin responseto the call. Specialisers can describe types,singleton objects, \nor sets of objects andtypes (details depend onthe language in question). Some concretemethodparametersmayhavenospecialiser \n(they are unspecialised) the method is applicable for any argumentvaluessuppliedtothose parameters.In \ncontrast,ina class-basedobject-orientedlanguage, every instance method will belong to a class, and its \ndistinguished .rst receiver argumentwillbespecialisedtothatclass.Forexample,this istrue forevery non-static, \nnon-constructor methodinJava; Java statics and constructors are not specialised. Dynamicspecialisersarecloselyrelatedto \ngenericfunc\u00ad tion signatures in statically typed languages: whenever a generic function is called, its \nactual arguments must conform to the types described by its signature. Depending on the language, specialisers \nmay or may not be tied into a static type system. Dispatch When a generic function is called at run time, \nit must select the concrete method(s) to run. In our model, thisis a dynamic dispatch from the generic \nfunction to its concrete methods.Ifthis dispatchis based onthetypeof one argument,we callit single dispatch;ifon \nthetypeof more than one argument, multiple dispatch. If a generic function has only a single concrete \nmethod, then no dynamic dispatch is required:we saythe functionis monomorphic or statically dispatched. \n 3.2 Modelling Programming Languages Toground ourstudy,wenowdescribehowthefeaturesof each of the languages \nwe analyse are captured by the model. The crucialdifferences betweenthe languages canbe seen as whether \ntheyoffer static typing, dynamictyping, or optional (static)typing; the numberof genericfunctions permethod \nname;andwhetheraconcretemethodcanbeinmorethanone generic function. These details are summarisedin Figure \n2, whichalsogivesanoverviewofterminology usedby each language, with Java and Smalltalk for comparisons. \nCLOS CLOS (Bobrow et al. 1988) .ts quite directly into our model. CLOS generic functions are declared \nexplic\u00aditly, and then (concrete) methods are declared separately; both generic functions and methods \nlie outside classes. Each generic functionis identi.edbyits name(withina names\u00adpace), so all methodsof \nthesame name belongto the same generic function.CLOSrequires lambdalist congruence : Abbrev Name basis \ndescription DR CR Dispatch Ratio Choice Ratio generic function concrete method number of methods in the \ngeneric function number of methods in the same generic function DOS RS Degree of Specialisation Rightmost \nSpecialiser concrete method concrete method number of specialisers rightmost specialised argument position \nDOD RD Degree of Dispatch Rightmost Dispatch generic function generic function number of specialisers \nrequired to dispatch to a concrete method rightmost specialiser required to dispatch to a concrete method \n Figure 3. Metrics allmethods must agree on the number of required and op\u00adtional parameters, and the \npresence and names ofkeyword parameters (Lamkins and Gabriel 2005). Dylan Dylan s dispatch design (Feinberg1997) \nis similar toCLOSinmost respects,including concretemethodsbe\u00ading combinedvia explicit generic function \nde.nitions, and similar parameterlist congruencyconditions. Dylan supports optional static type checking, \nandspecialisers andstatictype declarations areexpressed using the same syntax. When de.n\u00adingaconcretemethod,thetypedeclarations \nserveasdynamic specialisersifthey are morespeci.c than the typesdeclared by the generic function. Cecil \nCecil (Chambers 1992) generic functions(multimeth\u00ad ods)are declaredimplicitly, based on concrete method \ndef\u00adinitions, and each concrete methodis containedwithin one generic function. Unlike CLOS, a generic \nfunction comprises concrete methods of the same name and number of argu\u00adments: genericfunctions withthe \nsame namebut different parameter countsareindependent.LikeDylan,Cecilsupports optional static typedeclarations,but \nunlike Dylan, different syntactic constructs are used to de.ne static type declarations anddynamicspecialisers.Aparametercan \nincurastatictype de.nition, specialisation, or both. Diesel Diesel (Chambers 2006) is a descendant of \nCecil, however generic functions aredeclaredexplicitly(called func\u00ad tions). EachDieselfunction can have \na default implementa\u00ad tion, whichin our model correspondstoa concrete method with no specialised parameters. \nAdditional concrete methods (simplycalled methods)canaugmenta functionby specialis\u00ad ing anysubset of \nits parameters. Nice Nice(Bonniotetal. 2008)isamorerecent multiple dispatch language design based on \nJava. A Nice generic function(method declaration)supplies a name, a return type andastaticsignature.Different \nconcretemethods(method implementations)can existfor a declaration. When de.ning a concrete method,theparameter \ntype declarations serve as dynamic specialisers if they are different to (that is more speci.c than) \nthe types stated in the method declaration. MultiJava MultiJava(Cliftonetal. 2006)isanextension of Java \nthat adds the capability to dynamically dispatch on other arguments in addition to the receiver object. \nA generic function (also called method family)consists of a top method, which overrides no other methods, \nand any numberof methods thatoverridethetop method.Anymethod parametercanbespecialisedbyspecifyingatrue \nsubtypeof the corresponding static type or a constant value. Java Java is of course a single dispatch, \nstatically typed class-basedlanguage that we include as a control. Java uses theterm method for both \ngeneric functions(method call) and concrete methods(method bodies). Generic functions are de.nedimplicitly, \nand depend onthe names and the static types of their arguments. Smalltalk Smalltalkisnotpartof ourstudybutweinclude \nit in the table as a comparison. Smalltalk introduced the terms message roughly corresponding toimplicitly \nde.ned generic function, and method for concrete method. Smalltalk is dynamically typed, and every message \nis single dispatched (even the equivalent of constructors and static messages, which are sent dynamically \nto classes). Every method name (or selector)de.nes a new generic function, and the names encode the number \nof arguments to the message.  3.3 Metrics Our study approaches multimethods and multiple dispatch from \na programmer s point of view by analysing source code available publicly, mostly under open-source licenses. \nWe focus on method de.nitions which we willexamine statically. We do not examine method calls or dynamic \naspects of a program (e.g. frequencyof method calls through a callsite, frequencyofinvocationsper method)althoughwewouldlike \nto see these aspects covered in future studies. To study multiple dispatch across languages we de.ne \nmetricsbased on our language independent model. Figure3 summarises the metrics we de.ne in this section. \n3.3.1 Dispatch Ratio (DR) Wearemostinterestedinmeasuringtherelationships between generic functions and \nconcrete methods. Any number of concrete methods can belong to a given generic function, giving the basic \nmetric dispatch ratio DR(g)= |CM(g)| the numberof concretemethods that belongtothe generic function g.DRmeasures,in \nsome sense,the amount of choice offeredbya genericfunction: monomorphic functions will have DR(g)=1, \nwhile polymorphic functions will have DR(g) > 1. We are usually not interestedinthemeasurements from \ntheabovemetricsforindividualgenericfunctionsor concrete methods,butratherwewanttoknow abouttheirdistribution \nover a given application, or even collection of applications. Wecanreport the measurementsasafrequencydistribution, \nthatis,for a value dr, what proportion of generic functions g have DR(g)= dr.Frequencydistributions provideinfor\u00admationsuch \nas: what proportionof genericfunctionshave exactly1concrete method. Across whole applications or corpora, \nwe use the basic DR metric to de.ne an average dispatch ratio across each corpus. The average dispatch \nratio DRave the average numberof concretemethodsthata genericfunctionwould need to choose between is: \ng.G DR(g)DRave = |G| where G is the set of all generic functions. The intuition behind DRave is thatifyou \nselecta generic function from a program at random, to how many concrete methods could it dispatch? 3.3.2 \nChoice Ratio (CR) Because a generic function with a DR > 1 necessarily contains more methodsthanamonomorphic \ngeneric function, we were concerned that DRave can give a misleading low .gure for programs where some \ngeneric functions have many more concrete methods than others. For example, consider a program with one \ngeneric func\u00adtion with 100 concrete methods, DR(g1) = 100, and another 100 monomorphic methods DR(g2..101)=1.For \nthis pro\u00adgram, DRave =1.98, even though half the concrete methods can onlybe reachedbya 100-way dispatch. \nTo catch these cases, we de.ne the choice ratio of a concrete method m to be the total number of concrete \nmethodsbelongingtoallthegenericfunctionsto which m belongs:  CR(m)= | CM(g)| g.GF (m) Notethatthis counts \neach concrete method only once, even ifit belongstomultiplegenericfunctions.A corpus-wide average,CRave \ncan be de.ned similarly: CR(m) m.M CRave = |M| where M isthesetof concretemethods.The intuition behind \nCRave is thatifyouselecta concrete method from a program at random,thenhowmanyother concrete methods \ncouldhave been dispatched instead of this one? 3.3.3 Degree of Specialisation (DOS) The degree of specialisation \nof a concrete method simply counts the number of specialised parameters: DOS(m)= |spec(m)| where spec(m) \nis the set of argument positions of allspe\u00adcialisers ofthe method m (wewilllater write speci(m) for the \ni th specialiser).DOScanalsobeextendedto anaverage, DOSave in the obvious manner, over all concrete methods. \nDynamicallyspecialising multiple method parameters is a keyfeatureofmultiple dispatch:DOSmeasures this \ndirectly. Pure functions without dynamic dispatch, like Java static methods,C functions, orC++ non-virtual \nfunctions, will have DOS=0. Singlydispatchedmethods likeJavainstance methods,C++ virtualfunctions, andSmalltalk \nmethods will have DOS =1. Methods that are actually specialised on more than one argument willhaveDOS> \n1. 3.3.4 Rightmost Specialiser (RS) Programmersreadmethodparameter listsfromlefttoright. This means \nthat a method with a single specialiser on the last(rightmost) argument may be qualitatively different \nto a methodwith one specialiser on the .rstargument.Tomeasure this we de.ne the rightmost specialiser: \nRS(m)= max(spec(m)) If a method has some number of specialised parameters (perhaps none) followed by \na number of unspecialised pa\u00adrameters, then RS= DOS;where a method has some unspe\u00adcialised parameters \nearlyinthe list, andthen somespecialised parameters, RS > DOS.The capability to specialise a pa\u00adrameter \nother thanthe .rst distinguishes multiple dispatch languages from single dispatchlanguages.RScan, forexam\u00adple,identify \nmethodsthat use single dispatching(DOS=1) but where that dispatch isnot the .rstmethod argument.Once \nagain, we can de.ne a summary metric RSave by averaging RSover all concrete methods. 3.3.5 Degree of \nDispatch (DOD) The degree of dispatch is the number of parameter positions requiredfora genericfunctiontoselecta \nconcretemethod. Thekeypointhereisthatspecialising concretemethodpa\u00ad rameters does notbyitself determine \nwhetherthat parameter positionwillberequiredtodispatchthegenericfunction.This is because allthe concrete \nmethodsinthe generic function couldspecialisethe same parameter position in the same way. Similarly, \nif only one concrete method specialises a parame\u00ad ter position,that position could still participatein \nthe method dispatchevenif no otherconcrete methodspecialises that parameter the other concrete methods \nacting as defaults. The DODmetriccountsthe number of parameter positions where two (or more) concrete \nmethods in a generic function have different dynamic specialisers. In general, these are the positions \nthat mustbe consideredby the dispatch algorithm. where i . P iff .m1,m2 . CM(g) DOD(g)= |P |, such that \nspeci(m1) .= speci(m2) We can once again de.ne a summary metric DODave as the average over all generic \nfunctions. If DRave and CRave measure the amount of choice involved in dispatch, then DODave measures \nthe complexity of that choice. 3.3.6 Rightmost Dispatch (RD) Finally,byanalogytoRS, wecan de.neRD:therightmost \nparameter a generic function actually dispatches upon. where i . P iff .m1,m2 . CM(g) RD(g)= max(P ), \nsuch that speci(m1) .= speci(m2) RDistoRS asDODistoDOS:the DO versions count specialisers of methods, \nor dispatching positions of generic functions, while the R versions consider only the right\u00ad most position.RDforagenericfunction \nwill usuallybethe maximumRSofthatfunction smethods,unlesseverycon\u00ad cretemethodinthe genericfunction specialisestherightmost \nparameterinthesameway.Forthewhole corpora,we can reportRDave as theaverageRD across all generic functions. \n 3.4 Example To illustrate themetrics, consider thefollowingsimple multi\u00ad ple dispatch example written \nin Gwydion Dylan: de.ne class <vehicle> ... ; de.ne class <car> (<vehicle>) ... ; de.ne class <sports-car> \n(<car>) ... ; //DR =2, DoD =1,RD =2 de.negeneric collide(v1 :: <vehicle>, v2 :: <vehicle>); //CR =2, \nDoS = 1,RS =1 de.ne method collide(sc :: <sports-car>, v :: <vehicle>) ... ; //CR =2, DoS = 1,RS =2 de.ne \nmethod collide(v :: <vehicle>, c :: <car>) ... ; //DR =4, DoD =3,RD =3 de.negeneric pileup(v1 :: <vehicle>, \nv2 :: <vehicle>, v3 :: <vehicle>); //CR =4, DoS = 2,RS =3  de.ne method pileup(sc :: <sports-car>, \nv :: <vehicle>, c :: <car>) ... ; //CR =4, DoS = 2,RS =2 de.ne method pileup(sc :: <sports-car>, c :: \n<car>, v :: <vehicle>) ... ; //CR =4, DoS = 3,RS =3 de.ne method pileup(c :: <car>, c :: <car>, c :: \n<car>) ... ; //CR =4, DoS = 0,RS =0 de.ne method pileup(v :: <vehicle>, v :: <vehicle>, v :: <vehicle>) \n... ; Thesearetwo generic functions(collide and pileup)withtwo andfourconcrete methods respectively. \nThevaluesforthe metrics relevant to each declaration are in the comments above them. DR is2for collide \nand4 for pileup because that is the number of concrete methods eachof these generic functions contains. \nObviously, each of the concrete methods has a respectiveCRof2and4.Howeverthedifference canbe observedif \nwe tryand countthe DRave and CRave for this Dylan example. DRave = (2+4)/2=3 is the dispatch ratio forthis \nprogramthatexamines each generic function. CRave = (2+2+4+4+4+4)/6=3.33 is the choice ratio for this \nprogram that examines each concrete method. This means that the choice of alternative concrete methods \nforeachmethodislargerthantheaverage numberofmethods per generic function. DOSiscalculatedforeach concretemethodbyexamining \nthe number of specialisers, while RS records the position of therightmost specialiser(accountinginparticular \nfor the second concrete method collide that does a single dispatch on a second argument).Averages forDOSandRSgive \nus (1+1+2+2+3+0)/6=1.5 and (1+2+3+2+3+0)/6=  1.83 respectively. Finally,DODandRDaremeasuredatthelevelof \ngeneric functions.DOD records the numberof genericfunction s arguments that can be potentially specialised \nby one or moreof the concrete methods andRDrecords therightmost position usedbya specialiser. Theiraverages \nare (1+3)/2= 2 for theDODave and (2 + 3)/2=2.5 for theRDave. 4. Multiple Dispatch Languages Forthisstudywehavegathereda \ncorpusof9applications writtenin6languages thatoffermultiple dispatch (Figure4). Mostare compilersfor \nthe respectivelanguage they are all too often the only applications of signi.cant size that we could \nobtain. CLOS is notablydistinct in this respect and thecorpus couldbeexpandedby several CLOS projects.We \nopted to cover a broad spectrum of languages rather than weightingthis study towards onelanguage.The \nMultiJava\u00adbasedLocationStack(Hightower 2002)isaframeworkfor processingmeasurementsfroma networkof geographical \nlocation sensors. We applied the metrics de.ned in Section 3.3 to our corpus: the results are summarised \nin Figure 11. As is often the case when measuring realcode, we had to make assumptions aboutexactlywhattomeasure.Oneassumption \nwas with respectto the auto-generated .eld accessors some languagesprovided(see Figure2).As our interestisinhow \nprogrammers interact with language features, we did not measurethese accessors.Allofthe languagesstudiedhere \ncome with standard libraries. Our measurements of each applicationincludedthe contributionduetothelibraries(in \ncontrast with the Java measurements, see Section 5). The Nice language compiler compiles bothNice and \nJava source code into Java bytecode. The compiler itselfis written partly in Java, partly in Nice. For \nthis study, we only consider Language Application Domain Version Concrete methods Generic functions \nDylan Dylan CLOS CLOS CLOS Cecil Diesel Nice MultiJava Gwydion OpenDylan SBCL CMUCL McCLIM Vortex Whirlwind \nNiceC LocStack compiler compiler compiler compiler toolkit/library compiler compiler compiler framework \n2.5 svn:12/03/2008 1.0beta5 svn:27/04/2008 0.9.16 19d 0.9.5 3.3 3.3 0.9.13 0.8 6621 5389 861 1031 5400 \n15212 11871 1615 735 3799 2143 363 512 2222 6541 5737 1184 491 Figure 4. Size of applications in corpus \n Figure 5. Dispatch ratio(DR) frequency distribution,ex\u00ad pressed asa percentageof all generic functions \nwithagiven DRmeasurement. native Nice methods, since only these have multiple dispatch potential. 4.1 \nDispatch Ratio The Dispatch Ratio distribution for allapplications is shown in Figure5.Sevenapplicationsinsix \ndifferent languages fol\u00ad lowasimilardistributionwith 65% 93%ofgeneric functions havingasingle concrete \nmethod. The sharesfor genericfunc\u00adtionswithtwo(2% 20%),three(3% 6%)and moremethods decrease rapidly. \nThe exceptions here are CMUCL and Mc- CLIM(bothCommonLisp projects),whichhavea60%-share of genericfunctions \nwith2alternativeimplementations that isroughly doublethe proportionof genericfunctionswith one single \nconcrete method, but otherwise have a similar shapetotheother7applications.We arenotmeasuringthe use \nof non-generic functionsin CLOSapplications, so we Figure 6. Dispatch ratio(DR)distribution, log-log \nscale hypothesizethat some monomorphicfunctionsin these appli\u00ad cations maybeimplementedby non-generic \nfunctions.Itis also notablethatthesetwo projects are quite differentinsize, McCLIMbeing roughly5times \nthe sizeof CMUCLin terms of concrete methods, yet their distributions are very similar. The curvesshownin \nFigure5 arereminiscentofpower law distributions.Asthe curves arefairly closetoeach other, weshowallvaluesonthesame \nlog-log scale(Figure6).The strong indicationofastraightlineis furtherevidenceofthe possibility that power \nlaws are being followed. The DRave and CRave valuesfor theapplicationsin our corpus are shown in Figure \n11. Six of the applications have a DRave measurementofatleast2,indicatingthat forevery generic function, \non average a dispatch decision must be made between two concretefunctions. The results for CRave showconsiderablevariance.Onaverage, \nanyconcretemethod inVortexis part of dispatch decision with 60 or so other methods, whereas for NiceC \nit would be only with 3.5 other methods.  4.2 Specialisation Figure 7 shows, for each application, what \nproportion of generic functionshaveagivenDOSmeasurement.Atthetop are the highestDOSvalues measuredfortherespective \nappli\u00ad  Figure 7. Degree of specialisation (DOS) distribution of concretemethods across applications. \nThelowest blockin eachstackis the proportion withDOSmeasurementof0, the next,the proportionwith1,andso \non.Thevalueatthetop of each stackindicates the highestDOS measured for this application. cation. Whileitis \nquite common formethodsto specialiseup to3parameters,wefound generic functions that specialise 7 (OpenDylan, \nmake-source-location ), 8 (Whirlwind, resolve8 )and20(Gwydion, parser:production 113 ) pa\u00ad rameters.Thereisalsoaconsiderablerangefortheproportion \nof generic functions with no specialisation acrossthe applica\u00ad tions. Theresults for theRS metric areshownin \nFigure8. Since they are not signi.cantly different from DOSnumbers, we concludethat programmers generally \nspecialise parameters left-to-right, then follow with unspecialised parameters.  4.3 Dispatch Figure9 \nshows thedegreeof dispatch(DOD).Againexclud\u00ad ingCMUCL andMcCLIM,most applicationshavesimilar levels (2.7 \n6.5%)of multiple dispatch(DOD > 1), and sin\u00ad gle dispatch (13 32%). The shareof genericfunctions that \narenotrequiredtodispatchdynamically rangesfrom64%to 93%; this correspondsnicelywiththe 65% 93%of generic \nfunctions having a single concrete method and thus a dis\u00ad patch ratio of 1. The Nice compiler has the \nlowest proportion of multiple dispatch (1%)among the analysed applications, eventhoughwehaveexcluded \nthat partof the source written inJava.Onaverage,acrossallmeasured applications, we found that around \n3% of generic functions utilise multiple dispatch(DOD> 1) and around 30% utilise single dispatch (DOD= \n1). Figure 8. Rightmost specialiser(RS) distribution of con\u00adcrete methods across applications. The value \nat the top of each stack indicates the highestRS measured for this appli\u00ad cation. Figure 10 shows the \nrightmost dispatched parameter (RD). This generallyfollows DOD, although the proportions are often a \nlittle higherfor RD= 2. This shows thata signi.cant number of single-dispatched generic functions have \ntheir dispatch decision made on the second or beyond argument supplied in the call. Figure 11 provides \nthe averages of each of the metrics for all the multimethod applications to show relationships between \nthe metrics. As can be seen, RD is generally a littlelargerthan thedegreeofdispatch(DOD) RD = DOD by \nde.nition (because dispatch must occur on the RD thargument,butthere couldbeargumentstothe left of it \nthat do not dispatch). RS is higher than DOS for the same reason. The specialiser metrics DOS and RS \nwill also generally be below the dispatch metrics DOD and RD, because generic functions dispatch on positions \nwhere methods are specialised, but not all specialised positions will dispatch if all concrete methods \nspecialise the same argument positionin the sameway. Indeed,this appearsto be thecaseinGwydion Dylan \nleadingto thelargevaluesin .gures7and8, suchasamaximum20specialisers:many ofthesespecialisersare commontoallthemethodsinthe \ngeneric function, and are in effect acting as static(non\u00addispatching)type declarations for those method \narguments. (Strictly, specialiser and dispatch metrics are not comparable, as dispatch metrics average \nover generic functions while specialisation metrics average over concrete methods). Gwydion OpenDylan \nSBCL CMUCL McCLIM Vortex Whirlwind NiceC LocStack DRave 1.74 2.51 2.37 2.01 2.43 2.33 2.07 1.36 1.50 \nCRave 18.27 43.84 26.57 4.31 7.61 63.30 31.65 3.46 8.92 DOSave 2.14 1.23 1.11 0.85 0.98 1.06 0.71 0.33 \n1.02 RSave 2.24 1.34 1.23 0.89 1.11 1.10 0.78 0.34 1.08 DODave 0.20 0.39 0.42 0.69 0.78 0.36 0.32 0.15 \n0.08 RDave 0.24 0.48 0.45 0.71 0.86 0.41 0.37 0.15 0.11 Figure 11. Metrics: averages across applications \n  Figure 9. Degreeofdispatch(DOD)distributionofgeneric functions acrossapplications.Thevalueatthetopofeach \nstack indicatesthehighestDODmeasured forthis applica\u00ad tion. 5. Multiple Dispatch in Java In orderto understand \nhow representative our results from the previous section are, it is useful to determine to what de\u00ad gree \nmultiple dispatchis needed.Weexamineamainstream language, namelyJava, and determine how often program\u00ad \nmers use somemechanismtosimulatemultipledispatch.Our methodologyisto establishthe commonidioms, andthen \nmeasurethe useoftheseidiomsinastandard corpus.The release of the corpus that we used for this study has \n100 applications in it (Qualitas Research Group 2008). The mea\u00ad surementswe presenthereareforjustthelatestreleaseof \neachapplicationinthe corpus.Wealso measure these appli\u00ad cations using the applicable metrics from Section \n3. As withthe multimethodlanguages,wedo not measure any code that is automatically generated, but unlike \nthe multimethod languages we could onlymeasure that codethat is distributed as an application independent \nof the standard library (JRE) and any third-party libraries. This is due to thefactthattheJREissigni.cantlylarger \nthat manyofthe functions acrossapplications.Thevalueatthetopofeach stackindicates the highestRD measuredfor \nthisapplication. applications, and we feltitsmeasurementswould maskthose of the application. 5.1 Double \nDispatch AsillustratedinSection2,a common approachtoproviding multipledispatchin single dispatchlanguagesisthe \ndouble dispatch pattern describedbyIngalls (1986).Wecanget an ideaoftowhatdegree doubledispatchisusedby \nmeasuring the occurrenceofthe doubledispatch pattern.We referto methodsthatmatchthispatternas doubledispatchcandidates. \nThe characteristicsof the doubledispatch patternthat we use to identify its use are: 1. The this object \nis passed as an actual parameter to a method invoked on one of theformalparameters tothe double dispatch \ncandidate. 2. Thetypeof the formalparameterof theinvoked method is different from the actual parameter \npassed. 3. There is more than one child (either through extends or implements)ofthe formal parameter \nof the invoked method containing the same method. The .rst characteristicbyitself will produce manyfalse \npositives. This pattern occurs very frequently when set\u00adtingupa mutualrelationship betweentwoobjects.Forex\u00adample,in \nantlr the class antlr.preprocessor.Hierarchy has a method public void addGrammar(Grammar gr) whose .rst \nstatement is gr.setHierarchy(this). Inspection of Grammar classindicates thatall thatis happeningisa \nsetter is being used to setup a mutualrelationship between a Grammar and a Hierarchyobject. The key to \navoiding the setter situation is to realise that atrue doubledispatchpatternappliesto hierarchiesof types(Shape \nand Port in the case of the example). The sec\u00adond and third characteristics provide heuristics for establish\u00ading \nthatthehierarchiesexist.We also rule out the useof java.lang.Object as theformal parameter type as meeting \nthe double dispatch pattern. Wedo our measurements on bytecode rather that source, in part duetothe dif.cultyin \ngettinghigh-.delity parsers(Irwin 2007)andinpartduetohavingexistingbytecode analysis toolsavailable.We \nonlyexamined methods writtenforthe applicationfor which doubledispatch couldtake place, that is, we did \nnot examine synthetic methods, native methods, constructors,staticmethods, and abstract methods.Wedo \nexamine private (and generally non-public) methodsto allow for the possibilitythatthe doubledispatch \nhas beenfactored into a private method. 5.1.1 Results for double dispatch Ofthe 100 applications we measured, \n30 have at least one candidate method, that is, at least one method that has the pattern described above. \nFigure 12 shows those applications, the numberofcandidatemethods,andthenumberofmethods examined. We have \nchecked each case and in the fourth column give our assessment as to whether or not one of the candidates \nis indeedintendedto provide double dispatch. Notethat Yes onlymeans thatatleast onecandidate could be \nconsidered useof double dispatch(sometimesbyavery generous interpretation),but not necessarily all do. \nIn some cases (azureus) the appearance of the pattern does not seem to be due to deliberate use of double \ndispatch, whereasinothers(eclipse)itdoes(inthis caseanexampleof theVisitorpattern). The numberof candidate \nmethodsis not a usefulindicatorofthe useof double dispatch arelatively high number does not indicateits \nuse(azureus again), and nor doesalower numberindicate non-use(emmaisaVisitor pattern). Ourresults clearlyhavea \nnumberoffalse positives manycandidates are notinfact an actual useof double dis-patch.False negatives \narealso possible. Becausecharacter\u00adistic1requiresthattheinvokedmethodbeonaformalpa\u00adrameter to a candidate, \nif the parameter is assigned to a local Application DDC M DD aoi 2 5122 No aspectj 1 9647 No azureus \n14 17553 No colt 1 2783 No derby 10 17224 Yes drjava 1 9491 No eclipse 77 102231 Yes emma 2 943 Yes freecol \n1 3625 No gt2 26 15980 Yes informa 6 832 No itext 1 4931 No jedit 1 4361 No jhotdraw 1 1672 No jre 28 \n77563 Yes jrefactory 80 1939 Yes jruby 19 6681 Yes jtopen 1 21360 Yes jung 4 2456 No megamek 4 4515 No \nnakedobjects 9 7581 Yes pmd 3 2126 Yes poi 14 6239 Yes pooka 4 3426 Yes proguard 26 3306 Yes quartz 2 \n1575 No sandmark 1 5400 No squirrel 1 6465 No velocity 5 1296 Yes xalan 10 7935 Yes Figure 12. Number \nof double dispatch candidate methods (DDC), Number of methods examined (M), Manual assess\u00adment of whether \nat least one candidate is an actual use of  double dispatch (DD). variable and the invocation done on \nthe local, suchmethods willnotbe considered candidates.Wehavenotseenanex\u00ad ample of this, and it seems \nunlikely that such situations will occurwhen actually doing doubledispatch.We believethe results presentedrepresent \nupper bounds onthe actual useof double dispatch.  5.2 Cascaded instanceof Analternativetotheuseofthe \ndoubledispatchpatternisto manually dothedispatchthroughthe useofthe instanceof operator.Againanexamplewasgivenin \nSection2.Inthis case we consider a method to be a cascaded instanceof candidate if it contains two applications \nof instanceof to the same formal parameter of a method. We require two applications because we have found \nmany uses of single uses of instanceof within a method that do not appear to be Application % CIC M DDC,DD \njunit 0.51 2 391 myfaces 0.57 27 4779 jpf 0.58 5 867 jedit 0.62 27 4361 1,No freecol 0.63 23 3625 1,No \njsXe 0.65 3 465 displaytag 0.65 5 769 gt2 0.65 104 15980 26,yes jung 0.65 16 2456 4,No aspectj 0.65 63 \n9647 1,No eclipse 0.69 707 102231 77,Yes jchempaint 0.75 27 3624 quartz 0.76 12 1575 2,No megamek 0.82 \n37 4515 4,No colt 0.93 26 2783 1,No antlr 0.96 19 1987 jruby 1.00 67 6681 19,Yes axion 1.32 32 2419 argouml \n2.28 216 9484 Figure 13. Applicationswithmorethan 0.5%methodsbeing  cascaded instanceof candidates(CIC).Thelast \ncolumn repeats the relevant double dispatch data from .gure 12. simulatingmultipledispatch.Weexamined \nthe same setof methods as we did for the double dispatch pattern. 5.2.1 Results All but 16 applications \nshow at least some use of the instanceof pattern described above.Figure13 showsthose 19applicationsthathave \nmorethan 0.5%of their methods being cascaded instanceof candidates(theremaining results are omittedfor \nspace reasons).Asinthe caseof the double dispatch pattern, there are some that do not appear to be simulatingmultipledispatch(jsXeforexample)but \nothers (antlr for example) that clearly could be rewritten to use doubledispatch(and moregenerallymultimethods).Ofpar\u00ad \nticular interestis argouml.Not onlydoesithavethe highest proportion of its methods withthe instanceof \npattern,italso has a considerable number of uses of instanceof thatdon t match the pattern we measure \nand also apparentlyalso has no useof doubledispatch.We suspectmuchof thiscouldbe reduced through useof \ndouble dispatchbutitwould require considerable refactoring. Itwouldseem that multiple dispatchis more \noftenbeing simulated in Java using cascading instanceof rather than double dispatch, although we note \ntwo(xalan,jruby) that appear to use both.In boththose casesthe double dispatch pattern are associated \nwith the use of the visitor pattern. As with double dispatch candidates, the cascading instanceof candidates \nmust have the application of instanceof to a parameter of the candidate. Sampling of the codein thecorpus \nsuggeststhatitis possible that instanceof Figure 14. Degreeof specialisation(DOS)forJava applica\u00ad tions; \nmeasurements as a proportion of total concrete meth\u00ad ods. be appliedto local variables. Such situations \nwouldnot be considered candidatesin our measurements.Wealso require atleasttwo applicationsof instanceof. \nIt is likely that even a single use of instanceof may correspond to a crude double dispatch. Thismeans \nwe arelikelytohave morefalse nega\u00ad tives for the cascading instanceof resultsthan for the double dispatchresults.Neverthelesswebelievethe \nresults wehave are upper bounds on the use of cascading instanceof as a means to provide multiple dispatch. \n  5.3 Metrics Results We now present themeasurementsfrom the metrics presented inSection3.3forourJava \ncorpus.Forthosemetricsbased on the presence of specialisers, in Java the only parameter that can be specialised \nis the this parameter. It is possible that no parameters are specialised, namely in the case of static \nmethods and constructors. This means that in the standardinterpretation of Java, rightmost specialiser(RS) \nwillbeeither0 or1,andthe rightmostdispatch(RD)will be 0 or 1 exactly when RS is 0 or 1. So the proportion \nof functions havingRS andRD measurements of0is the proportionofgeneric functionsthatare either staticmethods \nor constructors, measurements wegive below. Unlikethe doubledispatch and cascading instanceof mea\u00ad surements,for \nthe metricsdiscussed here wemust measure staticmethods and constructors.We also must measureab\u00ad stractmethods, \nwhichdohaveaspecialiser.Wedo not mea\u00ad sure synthetic and native methods, and we do not measure private \nmethods. We can consider the use of either double dispatch or cascaded instanceof as providing specialisation \non a second parameter,givingaRSof2.However, as ourresultsabove show, even if we consider presence of \nthe double dispatch or cascaded instanceof pattern as actually simulating multiple dispatch(which we \nknow is not the case), then it is rare that even 1% ofthefunctions willhave anRS measurement of measurements \nas proportion of total generic functions. 2.Accordingly,forclarity wewillonlygivethe resultsfor measurementsof0 \nor1. Degreeof specialisation(DOS)isalso either0 or1in thestandardinterpretationofJava,exactly whenRSis0 \nor 1. Figure 14 shows the results for DOS as applied to our Java corpus. The bars are ordered in increasing \nsize ofthe applications, asmeasuredby numberofgenericfunctions. Whatis somewhat surprisingishowlarge \nthe proportionof functionshaveD OSof0.All applicationshaveatleast15% of genericfunctions being constructors \nand static methods (thelowestbeingderbyat 15.7%).Theapplicationwiththe largestproportionofDOSbeing0isjasml(67.3%).Itseems \nthatthepresenceofstaticmethods accountsformanyofthese results.Halfthe applicationshavemore than 40%of \ntheDOS measurements due to static methods; the lowest is 11.7% (trove) and the highest is 80.5% (mvnforum). \nAs withDOS thedegreeof dispatch(DOD)metricwill only provide measurements of 0 or 1. However, in this \ncase non-static methods and non-constructors can have a measurementof0ifthereisnot morethan1concretemethod \nbelonging to the generic function. Figure 15 shows the DODmeasurements as a proportion of the generic \nfunctions. It shows that rarely (6 of the 100 applications) does the proportion of genericfunctions with \nmore than1concrete methodgettoeven10%,thatis, usuallylessthan10%of methods areoverridden.However,recall \nthat user-de.ned methods that override standard library or third-party library are not counted in our \nmeasurements. For the remaining metrics we need to determine what are generic functions in Java. Unlike \nthe other languages thereis no speci.cconcept on whichto base the decision, so we appealtothe de.nitiongiveninSection3,andidentify \ngeneric functions with anypossible method call. Figure 16 illustrates the consequencesof this de.nition.Focusing \nonly onthe generic functions associatedwith A and B,there are seven generic functions the two default \nconstructors, and the5possible callsthatcantakeplaceasshowninthebody of Main#uses(A,B). class A {public \nvoid methodA() {}public void inherited() {} } class B extends A {public void methodB() {}public void \ninherited() {} // overrides fromA } class Main { public void uses(A anA, B aB) { anA.methodA(); // GF: \nmethodA(A) anA.inherited(); // GF: inherited(A) aB.methodB(); // GF: methodB(B) aB.inherited(); // GF: \ninherited(B) aB.methodA(); // GF: methodA(B) }} Figure 16. Java example of generic functions. The generic \nfunctions being called at each callsite are shown in the comments. Forillustration,we willname genericfunctions \nwith the functional formofthe possiblemethod calls,thatis,making theimplicit this argument type explicit, \nas shown in the commentsin the .gure.Forexample,thereisthe generic function methodB(B) and it contains \nthe concrete method B.methodB().Allgeneric functions except inherited(A) con\u00adtain only one concrete function. \ninherited(A) contains two concrete methods, A.inherited() and B.inherited(), as either of these could \nbe executed at the second callsite. The last callsite in the example requires more discussion. It is \na legal call, and so by our de.nition it is a generic function.However,in thegivenexample,the onlyconcrete \nmethod it contains is A.methodA(), as that is the method inherited by B.At .rstglance thisseems odd,howeverit \nmust be this way. If we consider the generic function atthis callsite to be methodA(A) then,if a new \nclass inheritsfromB and overrides inherited(),the generic function atthe callsite wouldhavetochange,despite \nneither B nor Main changing. So our conclusionis thatthe genericfunctioncalledatthe last callsite of \nthe example must be methodA(B) (and this is in fact how it will be compiled, as an invokevirtual on B.methodA()).Wehaveexploredotherpossible \nde.nitions andthesealsohaveissuesandaswehadtomakea choice, chose that presented here. However it does \nsuggest that more work is needed to unify the concept of generic function (and specialiser) across all \nprogramming languages. Figure 17 shows the measurementsfor DRave with the de.nitionofgeneric function \nas describedabove. Allofthe measurements areatleast1 orgreater.The smallestisinfact 1(jasml), indicating \nthat nomethodsin thisapplication are  tions. Java applications, log-log scale. overridden. Thelargestis \n1.44(proguard). The medianis 1.11 (marauroa). Figure 18 shows the distribution of dispatch ratio(DR) \nover all generic functions over all Java applications analysed shown on a log-log scale. In all, there \nare 1,927,036 generic functions represented, of which 4.97% have more than 1 concretemethod. The genericfunctionwiththe \nmost concrete methods(926)isfromeclipse. Thedistribution showsthe classicpowerlawshape (along the samelinesas \nFigure6in Section 4). Finally, the results foraverage choiceratio(CRave)are showninFigure 19. The smallestvalueis \n1.0(forjasml, as wewouldexpectfromtheprevious results),thelargestis77.1 (jruby), and the median is 3.2 \n(jspwiki). One point to note is that we have presented the Java resultsin orderofapplicationsizeasmeasuredby \nnumber ofgeneric functions.Thereisnoobvioustrendinanyofthe measurements with respect to size. Figure \n19. Average choiceratio(CRave)for Java applica\u00ad tions. 6. Discussion There are a number of inferences \nwhich can be drawn from the results presented in the last two sections. Perhaps the mostobviousis thatmanyof \nthe metricvaluesarelow:other thanCMUCLandMcCLIM,everylanguagewe measured had more than 60% monomorphic \ngeneric functions; less than 10% of functions dispatch on two or more arguments (Figure 9). Thisis re.ected \nin dispatch ratio DRave values: no language had more than 2.5 concrete methods for each generic function \n(Figure 11). Furthermore, the DRave values for the multimethod languages (1.50 2.51, except Nice, 1.36) \nexceed those for Java (median 1.11, max 1.44). We may also see some effects of the maturityof applications \nbeing measured.CMUCL and McCLIM arethemost matureofthe 9multiple dispatch applications, and theyexhibit \nthe most dynamicdispatch(around70%inFigure8, whereasthenext closest is less than 40%). The choice ratio \nCRave provides an alternative view of the amount of dispatchin the systems we studied: counting how manyalternative \nconcrete methods could have been reached byadispatch.HereagainweseeJava svaluesare consistently lower \nthan thoseof themultimethodlanguages, althoughthe .gures arelargeroverall.Thelarger CRave values even \nin Nice, every method on average could have dispatched to three alternative methods not only demonstrates \nthe skeweddispatchratio distributionshowninFigure5,butalso demonstratesthevalueof theCR metric: whiledispatching \ndoes not appear that important when measured by generic functions,itismore importantmeasuredbymethods \n(because, of course, one dispatching generic function will have at least two methods to dispatch to). \nMonomorphic vsPolymorphic methods It seemsthat espe\u00ad ciallyinJava,butalsoinotherlanguages, therewillbe \nmany generic functionsthatdo notdispatch: staticmethods,con\u00adstructors,but also auxiliary methods, methodsthat \nprovide default argument values in languages without variable argu\u00ad mentlists orkeyword arguments.On \nthe other hand, there will be a signi.cant number of generic functions that do dis\u00ad patchto three or \nmore different concrete methods and the methods belongingtothosefunctionsmakeupa substantial fraction \nof the program s methods. TheTemplate Method pattern (Gamma et al. 1994), for example, will contribute \nto this effect, as only hook methods shouldbe overridden in subclasses, while methods providing abstract, \nconcrete, and primitive operations will not be overridden. Our metrics cannot say anything about how \nimportant multiple dispatch (or even single dispatch) is to program design: simply that many methods \nare monomorphic, and mostof the remainder are single dispatch. Those dispatching methods may be crucial \nto the functioning of a particular program as well asTemplate method,manyotherpatterns (Visitor, Observer, \nStrategy, State, Composite) are about scaffolding a well-chosen dynamic dispatch with lots of relatively \nstraightforward non-dispatching code. Anotherpoint hereis thatalanguage speci.cation does not dictateaprogramming \nstyle: just supportingmultiple(or even single) dispatchina programming language doesn t meanitwillbeusedinprograms,theNice \ncompilerbeing aprimeexample.On the other hand,the multiple dispatch corpora generally exhibit more single \ndispatch than most of the Java corpus. Style ComparingRD andDOD metricsin Figure11we see that some corpora(primarilyMcCLIM, \nGwydion and OpenDylan,but also LocStack,Vortex andWhirlwind)have signi.cantlyhighervaluesforrightmostdispatched \nparameter RD than theydo for degree of dispatch DOD. This means that some generic functions argument \nlists musthave some non-dispatching parameters to theleftof thedispatching parameters a contrast to \nsingle-dispatch languages where the dispatch is always on the single leftmost parameter. For example, \nprograms couldcontain two-argument generic functions which dispatch on the secondargumentbut not on the \n.rst. In the case of McCLIM, this must partly be explained by the fact that the CLIM Standard (McKay \nand York 2001) explicitly requires some types of generic functions todispatch on theirsecond arguments(setfs \nand mapping functions). More generally, multiple dispatch gives more options to API designers, who can \nchoose argument order to re.ect application semantics rather than be restricted by having to place a \ndispatching argument .rst. In sin\u00adgle dispatch languages, code canfall intoa ObjectVerb Subject order: \nrectangle.drawOn(window). Here, Rectangle must come .rst, purely because the code needs to dis\u00adpatch \non Rectangle to draw different kinds of .gures. In multiple dispatchlanguages, this could equallybewritten \nwindow.draw(rectangle) matching the SubjectVerb Object word order commonlyused in English, or perhaps \nVerb Sub\u00adject Object draw(window,rectangle). Multiple dispatchlan\u00adguages offer this .exibility, even \nwhere only single dispatch is required, and our metrics demonstrate that programmers take advantage of \nthis .exibility. Java Idioms Our detailed analysis ofJavaidioms shows that thereis signi.cantly more \nuse of instanceof than we expected recall that we only count methods with multiple applications of instanceof \nto a parameter, meaning that applicationstoa non-parameter, including .elds,and single uses within a \nmethod are not counted. Multiple dispatchis beingsimulatedby useof instanceof ratherthan viaexplicit \ndouble dispatching,and when double dispatchis used,itisinimplementationsoftheVisitor pattern. Itis not \nclearif thisis because doubledispatchislargely unknown by most programmers, or whether concern over the \nperformance of double dispatch haslead programmers to prefer use of instanceof although double dispatch \nwill oftenbefaster than instanceof (Footeetal. 2005;Cuneiand Vitek 2005). We surmise(we cannottellfrom \njustthe corpus data) the reasons whyprogrammers seem to prefer instanceof to doubledispatch.Dispatchisin \nsome senseanimplementation issue,but especiallyinJava, where objectshaveexplicit and documented interfaces, \ndispatching methods pollute their classes interfaces, reducing classes cohesion and increasing coupling. \nAlthough instanceof cascades may be slower than double dispatching, and are certainly less extensible, \nby beinglocalisedtoasingleclassthey aresigni.cantly more straightforwardto codethan doubledispatching.Thismay \naccount for the relative popularity of each idiom. Multiple dispatchbene.ts Adding multiple dispatch \nto a programming language can help improve the expressiveness by providinga .rstclassalternativetoeither \ndouble dispatch or cascaded instanceof. Multiple dispatchis considered one of the possible solutionsto \nthe expression problem (Wadler 1998; Zenger and Odersky2005). Clifton et al. show how multimethods can \nbe used to help with binary methods, event handling,treetraversals,andimplementing.nitestate machines \n(Clifton et al. 2006, Section 5.1). An HistoricalPerspective Figure 20 is taken directlyfrom Kempf, Harris, \nD Souza, andSnyder(1987) published at OOPSLA 87. This paper evaluates CommonLoops (the .g\u00ad ures reportonPCLCommonLoopsandPCL \nsBeatriXgraph\u00adicslibrary).Our studiesreplicatethe corpusanalysisfromthat research,but20 yearslaterand \nacrossa numberoflanguages andmetrics. ComparingFigures5,7,and20,thesimilarityof thedistributionsis striking. \nAlthough both systems sharethe same heritage Lisp-based multiple dispatch languages and GUIlibraries \nfor thoselanguages there arealsosigni.cant differences: we have analysed recent releases of CLOSand \nMcCLIM,versionsatleasttwentyyearslaterthanPCLand BeatriXasstudiedin 1987.Themore recentprogramsare also \nmuchlarger than their 1987 counterparts: wherePCL has 91 genericfunctions, CLOShas 512;BeatriXhas 143 \nwhile McCLIMhas 2222.Taken together,these results show  Reprinted fromKempf, Harris, D Souza, andSnyder, \nOOPSLA 87. that,atleastasfarasgeneric functionsare concerned,CLOS programming practice is consistent \nover the last 20 years. Evidence based language design I have always remark d, that the author pro\u00adceeds \nfor some time in the ordinary ways of reason\u00ad ing...whenallofa suddenI amsurpriz dto.nd,that instead \nof the usual copulations of propositions, is, and is not, I meet with no proposition that is not connected \nwith an ought, or an ought not. David Hume, ATreatise of Human Nature,1739. Hume s Law states that normative \n(prescriptive) state\u00ad ments in this case, statements about how programs ought tobe written cannotbejusti.edexclusivelyby \ndescriptive statements.Our corpus analyses are descriptive: theytell us abouthow programs are written,butcannot(on \ntheirown) tell usabout whether thatisa good waytowrite programs, or whether language designers should \nconsider multiple dis\u00ad patch(orevensingledispatch)asalanguage featureworth retaining.Inthis paper,wedonottrytomakeanyofthese \nclaims wedo noteven claimwhetherhigh orlowvalues for metrics are desirable: our metrics characterise \nprogram structures: theydo not attempt to measure program quality. Nonetheless, thereseemtobe clearadvantagestoinform\u00adingthe \ndesignoffuture languages withevidencedrawnby something other than anecdote, personal experience, small\u00adscale \nobservational studies, or personal morality (Dijkstra 1968). Similarly, maintenance and debugging tasks \n and eventeaching about programming paradigms wouldsurely bene.tfrombeing basedinevidence abouttheworldasitis, \nas well as the world as we would like it to be! 7. Conclusion In this paper we present an empirical study \nof multiple dispatchinexistinglanguages.To our knowledgeitisthe .rst cross-language corpus analysisof \nmultiple dispatch.We de.ne six metrics (DispatchRatio,ChoiceRatio,Degreeof Specialisation,Rightmost Specialiser, \nDegree of Dispatch, and Rightmost Dispatch) based on a language-independent modelofmultiple dispatch.Wepresent \nthevaluesof these metrics for a corpus of programs written in six multiple dispatchlanguages: CLOS,Dylan, \nCecil,Diesel,Nice and MultiJava.Wecompare our results with an additionalstudy on the use of the double \ndispatch pattern and cascaded instanceof expressions in Java. In answer to our question how muchis multiple \ndispatch used?, we found that around 3% of generic functions utilise multiple dispatch and around 30% \nutilise single dispatch. Determininghow much theseresults generalise i.e., howwellthese measurements \nrepresentthe useof multiple dispatch in other applications and languages necessarily requiresfurtherstudy,butweexpectthese \nresultstoprovide a benchmark for comparison. Considering oursingledispatchstudyofJavaprograms, to answer \nhow muchcould multiple dispatchbe used?, we foundthat cascaded instanceof expressions are used more oftenthan \ndouble dispatch,but that bothtogetherare used much less than multiple dispatch in any of the multiple \ndispatchapplicationswe studied.We considerthatthisresult means that Java programs would have scope to \nuse more multiple dispatch were it supported in the language. Finally,ourstudyisbutabeginninginthislineof \nresearch. Ourlanguageindependent modelof multipledispatch, and the de.nitionsofthemetrics,proved moredif.culttodevelop \nthat we initially expected; ensuring measurements were comparable acrosslanguages required particularcare. \nThis suggeststhereis considerable subtletyin the concepts we aretryingtomodel.We hopethiswork will inspire \nmore research, including quantitative and qualitative studies of multiple dispatch languages and applications, \nand design studies of languages supporting multiple dispatch, to further our understanding of multiple \ndispatch in practice. A. Corpus   A.1 Applications in Multiple Dispatch Languages Figure21 presentstherawmeasurements \nusedto generate Figures 5 10. It shows percentages of the total generic functions(DR,DOD,RD)orconcrete \nmethods(DOS,RS) forfrequenciesbetween0and9andthe sumof frequencies equaltoorhigher than10.Italsomentionsthesourceswhere \nwe obtained each application.  A.2 Java Applications The completelistofJavaapplications measuredinthis \nstudy is listed below. The format is application name-version id. Thisisrelease 20080603ofthe Qualitas \nCorpus(Qualitas Research Group 2008). ant-1.7.0, antlr-2.7.6, aoi-2.5.1, argouml-0.24, aspectj-1.0.6, \naxion-1.0-M2, azureus-3.0.3.4, c jdbc-2.0.2, checkstyle-4.3, cobertura-1.9, colt-1.2.0, columba-1.0, \ncompiere-250d, derby-10.1.1.0, displaytag-1.1, drawswf-1.2.9, drjava-20050814, eclipse SDK-3.1.2-win32, \nemma-2.0.5312, exoportal-v1.0.2, .ndbugs-1.0.0, .tjava-1.1, .tlibraryfor.tnesse-20050923, freecol-0.7.3, \nfreecs-1.2.20060130,galleon-1.8.0, ganttproject-1.11.1, gt2-2.2-rc3, heritrix-1.8.0, hibernate-3.3.0.cr1, \nhsqldb-1.8.0.4, htmlunit-1.8, informa-0.6.5, ireport-0.5.2, itext-1.4, ivatagroupware-0.11.3, jFin DateMath-R1.0.0, \njag-5.0.1, james-2.2.0, jasml-0.10, jasperreports-1.1.0, javacc-3.2, jchempaint-2.0.12, jedit-4.3pre14, \njena-2.5.5, jext-5.0, jfreechart-1.0.1, jgraph-5.10.2.0, jgraphpad-5.10.0.2, jgrapht-0.7.3, jgroups-2.6.2, \njhotdraw-5.3.0, jmeter-2.1.1, jmoney-0.4.4, joggplayer-1.1.4s, jparse-0.96, jpf-1.0.2, jrat-0.6, jre-1.5.0 \n14-linux-i586, jrefactory-2.9.19, jruby-1.0.1, jsXe-04 beta, jspwiki-2.2.33, jtopen-4.9, jung-1.7.1, \njunit-4.4, log4j-1.2.13, lucene-1.4.3, marauroa-2.5, megamek-2005.10.11, mvnforum-1.0-ga, myfaces core-1.2.0, \nnakedobjects-3.0.1, nekohtml-0.9.5, openjms-0.7.7-alpha-3, oscache-2.3-full, picocontainer-1.3, pmd-3.3, \npoi-2.5.1, pooka-1.1-060227, proguard-3.6, quartz-1.5.2, quickserver-1.4.7, quilt-0.6-a-5, roller-2.1.1-incubating, \nrssowl-1.2, sablecc-3.1, sandmark-3.4, springframework-1.2.7, squirrel sql-2.4, struts-1.2.9, sun.ow-0.07.2, \ntomcat-5.5.17, trove-1.1b5, velocity-1.5, webmail-0.7.10, weka-3.5.7, xalan-j 270,xerces-2.8.0, xmojo-5.0.0. \nAcknowledgments ThankstoToddMillstein,who suggested lookingatthe useof instanceof andtherightmostparameter; \nBruceHoultandthe othermaintainersofGwydionDylanandOpenDylanfor their help; DanielBonniotfor support onNice; \nCraig Chambers forvaluable discussions andhelp withCecil and Diesel; and Jeffrey Hightower for providing \nsupport for the Location Stack. Thanks arealsoduetothe anonymousreviewersfor their comments and suggestions. \nThisworkwas fundedinpartbyaVictoria Universityof WellingtonFacultyof Science, EngineeringandArchitecture \n&#38;Design StrategicResearchGrant, and the New Zealand Foundation for Research Science andTechnology \nsupported Software Process and ProductImprovement project. Some workwas carried out whileTemperowasavisitingresearcher \nat theBESQ centreatthe BlekingeInstituteofTechnology, whose support he gratefully acknowledges. References \nGarethBaxter, Marcus Frean, James Noble, MarkRickerby,Hayden Smith,MattVisser, HaydenMelton, andEwanTempero. \nUnder\u00ad standingthe shapeofJavasoftware.In OOPSLA, pages 397 412, Portland, OR, USA, 2006.ACM Press. Daniel \nG. Bobrow. The LOOPS Manual. XeroxParc, 1983. DanielG. Bobrow,KennethKahn,GregorKiczales, LarryMasinter, \nMarkSte.k, andFrankZdybel.CommonLoops:Merging Lisp and object-oriented programming. SIGPLAN Not, 21:17 \n29, 1986. DanielG. Bobrow,LindaG. DeMichiel,RichardP.Gabriel,SonyaE. Keene,GregorKiczales, andDavid A.Moon. \nCommon Lisp Object System speci.cation. SIGPLAN Not, 23:1 142, 1988. DanielBonniot, BrynKeller, and FrancisBarber. \nThe Nice user s manual, 2008. URL http://nice.sourceforge.net/ manual.html. John Boyland and Giuseppe \nCastagna. Parasitic Methods: An implementation of multi-methods for Java. In OOPSLA, pages 66 76.ACM \nPress, 1997. KimB.Bruce,LucaCardelli, GiuseppeCastagna, Jonathan Eifrig, ScottF. Smith,ValeryTrifonov,GaryT.Leavens,andBenjaminC. \nPierce. On binary methods. Theory and Practice of Object Systems, 1:221 242, 1995. Bruno Cabral andPaulo \nMarques. ExceptionHandling:A .eld study in Java and .NET. In ECOOP, volume 4609, pages 151 175. Springer-Verlag, \n2007. Patrice Chalin andPerryR.James. Non-null referencesbydefault inJava: Alleviatingthe nullityannotationburden.In \nECOOP, volume 4609, pages 227 247. Springer-Verlag, 2007. Craig Chambers. The Diesel Language, speci.cation \nand rationale, 2006. URL http://www.cs.washington. edu/research/projects/cecil/www/Release/ doc-di%esel-lang/diesel-spec.pdf. \nCraig Chambers. Object-oriented multi-methods in Cecil. In ECOOP, volume 615, pages 33 56. Springer-Verlag, \n1992. CraigChambersandWeiminChen.Ef.cientmultipleandpredicated dispatching. In OOPSLA, pages 238 255, \nDenver,CO, USA, 1999.ACM Press. CurtisClifton,GaryT. Leavens, CraigChambers, andToddMill\u00ad stein. MultiJava:Modular \nopen classesand symmetric multiple dispatch for Java. In OOPSLA, pages 130 145,Minneapolis, MN, USA, \n2000.ACM Press. Curtis Clifton,ToddMillstein, GaryT. Leavens,and CraigCham\u00ad bers. MultiJava: Design rationale, \ncompiler implementation, and applications. TOPLAS, 28:517 575, 2006. Antonio Cunei and Jan Vitek. PolyD: \na .exible dispatching framework. In OOPSLA, pages 487 503, San Diego, CA, USA, 2005.ACM Press. EdsgerW. \nDijkstra. GoTo statement considered harmful. Commu\u00adnicationsof theACM, 11(3):147 148, March 1968. ChristopherDutchyn,Paul \nLu, Duane Szafron, Steven Bromling, andWadeHolst. Multi-dispatchin the Java Virtual Machine: Designand \nimplementation.In USENIX,pages 6 6, San Antonio, Texas, United States, 2001. USENIX Association. JohanFabryandTom \nMens. Language-independent detection of object-oriented design patterns. Computer Languages, Systems \nand Structures, 30(1 2):21 33, 2004. Neal Feinberg. Dylan Programming: An Object-Oriented and Dynamic \nLanguage. Addison-Wesley, 1997. BrianFoote, RalphE. Johnson, andJames Noble.Ef.cientmulti\u00ad methodsinasingle \ndispatch language.In ECOOP, volume 3586, pages 337 361. Springer-Verlag, 2005. ErichGamma,RichardHelm, \nRalphE. Johnson, and John Vlissides. DesignPatterns. AW, 1994. Joseph(Yossi)GilandItayMaman.MicropatternsinJava \ncode. In OOPSLA,pages 97 116, San Diego,CA,USA, 2005.ACM Press. JeffreyHightower. The location stack:Alayered \nmodelforloca\u00adtionin ubiquitous computing. In Proceedings of the 4th IEEE Workshop on Mobile Computing \nSystems &#38; Applications (WM- CSA2002), pages 22 28, 2002. David Hume. ATreatise of Human Nature. Printed \nfor John Noon, London, 1739. DanielH. H. Ingalls. A simple technique for handling multiple polymorphism. \nIn OOPSLA, pages 347 349, Portland,OR,USA, 1986.ACM Press. WarwickIrwin.Understanding and Improving Object-Oriented \nSoft\u00ad ware Through Static Software Analysis. PhD thesis, University of Canterbury, Christchurch, New \nZealand, 2007. James Kempf, Warren Harris, Roy D Souza, and Alan Snyder. Experience with CommonLoops. \nIn OOPSLA, pages 214 226, Orlando, FL, USA, 1987.ACM Press. Gregor Kiczales, John Lamping, Anurag Mendhekar, \nChris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin. Aspect\u00ad oriented programming. In ECOOP,volume1241, \npages220 242. Springer-Verlag, 1997. Gregor Kiczales,Erik Hilsdale, Jim Hugunin,MikKersten, Jeffrey Palm, \nandWilliamG. Griswold.AnoverviewofAspectJ. In ECOOP, volume 2072, pages 327 355. Springer-Verlag, 2001. \nEricKidd.Ef.cient compressionof generic functiondispatchtables. Technical Report TR2001-404, Hanover, \nNH, USA, 2001. DavidB. Lamkins and RichardP. Gabriel. SuccessfulLisp: How to Understand and Use Common \nLisp. book.x.com, 2005. GaryT. LeavensandTodd Millstein. Multipledispatch as dispatch on tuples. In OOPSLA, \npages 274 287.ACM Press, 1998. Kin-KeungMaandJeffreyS.Foster.Inferringaliasingand encapsu\u00adlation propertiesfor \nJava.In OOPSLA, pages 423 440, Montreal, Quebec, Canada, 2007.ACM Press. ScottMcKay andWilliamYork. Common \nLisp Interface Manager: CLIM II Speci.cation, 2001. Hayden Melton andEwanTempero.An empirical studyofcycles \namong classesinJava. Empirical Software Engineering, 12(4): 389 415, August 2007. Warwick Mugridge, JohnHamer, \nandJohn Hosking. Multi-methods ina staticallytypedprogramminglanguage.In ECOOP, volume 512, pages 147 \n155. Springer-Verlag, 1991. JensPalsbergandJ.Van Drunen.Visitor-oriented programming. In FOOL,Venice, \nItaly, 2004. AlexPotanin,James Noble,MarcusFrean,andRobert Biddle. Scale\u00ad free geometry in object-oriented \nprograms. Communications of theACM, May 2005. Qualitas Research Group. Qualitas corpus release 20080603. \nhttp://www.cs.auckland.ac.nz/ ewan/corpus/ The University of Auckland, June 2008. Lee Salzman and Jonathan \nAldrich. Prototypes with multiple dispatch: An expressive and dynamic object model. In ECOOP, volume \n3586, pages 312 336, Glasgow,Scotland, 2005. Springer- Verlag. Christopher Unkel and Monica S.Lam. Automatic \ninference of stationary .elds:ageneralizationofJava s .nal .elds. In POPL, volume 43, pages 183 195, \nNewYork, NY, USA, 2008.ACM Press. PhilipWadler. Theexpression problem. DiscussionontheJava\u00ad Genericitymailinglist(see12November \n1998 post),November 1998. Matthias Zenger andMartinOdersky. Independentlyextensible solutionsto theexpression \nproblem. In FOOL, SanDiego,USA, October 2005. AlsoavailableasTechnical ReportIC/2004/109, EPFL, Switzerland, \nDecember 2004. Application Metric 0 1 2 3 4 5 6 7 8 9 10+ Gwydion http:// DR 0 83.36 6.87 3.55 1.74 \n1.00 0.76 0.74 0.37 0.16 1.45 www.opendylan.org/ DOS 5.74 36.31 31.28 13.77 5.51 1.43 2.72 0.82 1.27 \n0.30 0.85 /downloading.phtml RS 5.74 35.21 31.29 13.25 6.80 0.97 2.45 0.06 2.79 0 1.45 DOD 83.36 13.90 \n2.61 0.11 0.03 0 0 0 0 0 0 RD 83.36 10.66 4.63 0.95 0.32 0.05 0.03 0 0 0 0 OpenDylan http:// DR 0 68.08 \n14.56 5.83 3.64 2.61 1.21 0.23 0.84 0.47 2.52 www.opendylan.org/ DOS 6.48 68.36 21.75 2.84 0.20 0.35 \n0 0.02 0 0 0 downloading.phtml RS 6.48 59.96 27.89 4.73 0.43 0.50 0 0.02 0 0 0 DOD 68.08 25.43 5.88 0.51 \n0.09 0 0 0 0 0 0 RD 68.08 18.71 11.15 1.73 0.28 0.05 0 0 0 0 0 SBCL http:// DR 0 63.64 21.21 6.34 2.75 \n1.65 0 0.55 0.83 0.28 2.75 www.sbcl.org/ DOS 7.32 75.15 16.26 1.28 0 0 0 0 0 0 0 RS 7.32 66.20 22.53 \n3.60 0.35 0 0 0 0 0 0 DOD 63.64 31.68 3.58 1.10 0 0 0 0 0 0 0 RD 63.64 29.20 5.51 1.38 0.28 0 0 0 0 0 \n0 CMUCL http://www. DR 0 34.57 57.62 2.54 1.95 1.17 0.20 0 0.20 0.39 1.37 cons.org/cmucl/ DOS 28.13 59.36 \n11.45 1.07 0 0 0 0 0 0 0 RS 28.13 57.32 11.93 2.33 0.29 0 0 0 0 0 0 DOD 34.77 61.91 2.54 0.78 0 0 0 0 \n0 0 0 RD 34.77 60.94 3.12 0.98 0.20 0 0 0 0 0 0 McCLIM http:// DR 0 24.30 59.54 6.75 3.60 1.58 1.49 0.32 \n0.41 0.14 1.89 common-lisp.net/ DOS 22.63 60.44 13.67 3.07 0.17 0.02 0 0 0 0 0 project/mcclim/ RS 22.63 \n52.06 19.56 3.83 1.07 0.67 0.19 0 0 0 0 DOD 27.54 67.24 4.82 0.36 0 0.05 0 0 0 0 0 RD 27.54 61.79 8.69 \n1.49 0.23 0.09 0.18 0 0 0 0 Vortexhttp://www. DR 0 67.89 15.87 6.15 3.38 1.73 1.04 0.89 0.43 0.29 2.34 \ncs.washington.edu/ DOS 12.09 71.65 14.82 1.31 0.10 0.01 0.01 0 0 0 0 research/projects/ RS 12.09 70.13 \n14.93 1.87 0.52 0.42 0.03 0.01 0.01 0 0 cecil/www/Release/ DOD 67.89 28.18 3.55 0.37 0.02 0 0 0 0 0 0 \nRD 67.89 24.90 5.61 1.24 0.28 0.03 0.03 0.02 0 0 0 Whirlwind http:// DR 0 72.86 14.35 4.92 2.75 0.96 \n0.78 0.68 0.44 0.21 2.06 www.cs.washington. DOS 42.67 45.10 10.85 1.26 0.11 0 0.01 0 0.01 0 0 edu/research/ \nRS 42.67 41.03 12.63 2.92 0.44 0.25 0.03 0.01 0.02 0 0 projects/cecil/ DOD 72.86 23.20 3.42 0.38 0.12 \n0 0 0 0.02 0 0 www/Release/ RD 72.86 19.89 5.32 1.29 0.38 0.19 0.03 0.02 0.02 0 0 NiceC http://nice. \nDR 0 86.57 7.69 2.79 0.84 0.42 0.25 0.25 0.17 0.08 0.93 sourceforge.net/ DOS 70.03 27.24 2.60 0.12 0 \n0 0 0 0 0 0 RS 70.03 26.01 3.59 0.25 0.12 0 0 0 0 0 0 DOD 86.57 12.42 0.84 0.17 0 0 0 0 0 0 0 RD 86.57 \n12.08 1.10 0.17 0.08 0 0 0 0 0 0 LocStack http:// DR 0 93.28 1.83 1.22 0.20 0.61 0.20 0.41 0 0 2.24 portolano.cs. \nDOS 12.52 75.24 9.93 2.31 0 0 0 0 0 0 0 washington.edu/ RS 12.52 75.24 4.08 8.16 0 0 0 0 0 0 0 projects/location/ \nDOD 93.28 5.30 1.43 0 0 0 0 0 0 0 0 RD 93.28 3.87 1.63 1.22 0 0 0 0 0 0 0 Figure 21. Metricsdistributions \nfor eachapplicationin corpus: dispatchratio(DR),degreeof specialisation(DOS),rightmost  specialiser(RS),degreeof \ndispatch(D OD), rightmost dipatch(RD),expressedin percent. \n\t\t\t", "proc_id": "1449764", "abstract": "<p>Multiple dispatch uses the run time types of more than one argument to a method call to determine which method body to run. While several languages over the last 20 years have provided multiple dispatch, most object-oriented languages still support only single dispatch forcing programmers to implement multiple dispatch manually when required. This paper presents an empirical study of the use of multiple dispatch in practice, considering six languages that support multiple dispatch, and also investigating the potential for multiple dispatch in Java programs. We hope that this study will help programmers understand the uses and abuses of multiple dispatch; virtual machine implementors optimise multiple dispatch; and language designers to evaluate the choice of providing multiple dispatch in new programming languages.</p>", "authors": [{"name": "Radu Muschevici", "author_profile_id": "81490646985", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P1223245", "email_address": "", "orcid_id": ""}, {"name": "Alex Potanin", "author_profile_id": "81100005943", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P1223246", "email_address": "", "orcid_id": ""}, {"name": "Ewan Tempero", "author_profile_id": "81100213613", "affiliation": "University of Auckland, Auckland, New Zealand", "person_id": "P1223247", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "P1223248", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449808", "year": "2008", "article_id": "1449808", "conference": "OOPSLA", "title": "Multiple dispatch in practice", "url": "http://dl.acm.org/citation.cfm?id=1449808"}