{"article_publication_date": "10-19-2008", "fulltext": "\n Sound and Extensible Renaming for Java Max Sch\u00e4fer Torbj\u00f6rn Ekman Oege de Moor Programming Tools Group, \nUniversity of Oxford, UK {max.schaefer, torbjorn.ekman, oege.de.moor}@comlab.ox.ac.uk Abstract Descriptive \nnames are crucial to understand code. How\u00adever, good names are notoriously hard to choose and manu\u00adally \nchanging a globally visible name can be a maintenance nightmare. Hence, tool support for automated renaming \nis an essential aid for developers and widely supported by popular development environments. This work \nimproves on two limitations in current refac\u00adtoring tools: too weak preconditions that lead to unsound\u00adness \nwhere names do not bind to the correct declarations after renaming, and too strong preconditions that \nprevent re\u00adnaming of certain programs. We identify two main reasons for unsoundness: complex name lookup \nrules make it hard to de.ne suf.cient preconditions, and new language features require additional preconditions. \nWe alleviate both problems by presenting a novel extensible technique for creating sym\u00adbolic names that \nare guaranteed to bind to a desired entity in a particular context by inverting lookup functions. The \nin\u00adverted lookup functions can then be tailored to create quali\u00ad.ed names where otherwise a con.ict would \noccur, allowing the refactoring to proceed and improve on the problem with too strong preconditions. \nWe have implemented renaming for Java as an extension to the JastAdd Extensible Java Compiler and integrated \nit in Eclipse. We show examples for which other refactoring engines have too weak preconditions, as well \nas examples where our approach succeeds in renaming entities by insert\u00ading quali.cations. To validate \nthe extensibility of the ap\u00adproach we have implemented renaming support for Java 5 and AspectJ like inter-type \ndeclarations as modular exten\u00adsions to the initial Java 1.4 refactoring engine. The renaming engine is \nonly a few thousand lines of code including ex\u00adtensions and performance is on par with industrial strength \nrefactoring tools. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 08 October 19 23, 2008, Nashville, Tennessee, USA. Copyright c &#38;#169; 2008 ACM \n978-1-60558-215-3/08/10. . . $5.00 Categories and Subject Descriptors D.3.4 [Programming Languages]: \nProcessors General Terms Languages Keywords Refactoring, name analysis, renaming, extensi\u00adble compilers \n1. Introduction Renaming is one of the most commonly used refactorings [OJ90]. Well chosen names for \nclasses, methods, and .elds, play a key role in software systems to complement docu\u00admentation, but as \nsystems evolve it is important to be able to change these names to re.ect updated designs. Most languages \nallow globally visible declarations, and renaming therefore requires a global analysis to .nd which source \n.les to change. To avoid manual inspection of the en\u00adtire source code, automated tool support for such \nname based refactorings provide an invaluable aid in everyday develop\u00adment. An important property of \nrefactorings is that they are behaviour preserving [Opd92, Fow00]. This is particularly important for \nglobal refactorings, such as renaming, where it is not reasonable to manually inspect the performed trans\u00adformations. \nBehaviour preservation is most often ensured by having a set of preconditions that must be met for a \nrefactor\u00ading to be valid. In this work we look at two limitations of a purely precon\u00addition based approach. \nToo weak preconditions lead to un\u00adsoundness where programs will not compile after the refac\u00adtoring, or \neven worse, to programs where names refer to dif\u00adferent declarations after the renaming than before the \ntrans\u00adformation. During this work we found examples that lead to the severe latter case, exposing bugs \nin refactoring en\u00adgines in common IDEs such as Eclipse, NetBeans, IntelliJ, and JBuilder [Ecl07, Net07, \nJet07, JBU07]. Moreover, lan\u00adguages like Java provide several ways to refer to the same entity using \ndifferent symbolic names. For example, a .eld shadowed by a local variable can still be accessed by quali\u00adfying \nit with this, and a type in a distant package can often be accessed using a quali.ed name. We thus do \nnot want too strong preconditions either, since they prevent renaming programs where some minor quali.cations \nwould enable the refactoring. This work improves on too strong preconditions that pre\u00advent refactorings, \nby using more .exible renaming, and present a systematic approach to avoid too weak precon\u00additions which \nlead to unsoundness. Rather than stating pre\u00adconditions that guarantee behaviour preservation, we use \nthe following correctness criterion: Rename refactorings should preserve the invariant that only names \nare affected by the refactoring, and that each name refers to the same declared entity before and after \nthe transformation. This is slightly weaker than behaviour preservation, which is impossible to achieve \nin the presence of dynamic class loading and re.ec\u00adtion, but on the other hand it provides us with an \nimplemen\u00adtation strategy. We present a novel technique for creating symbolic names that are guaranteed \nto bind to a desired entity in a particular context by inverting lookup functions. By apply\u00ading this \noperation for each bound name that could possibly be affected by a renaming operation we guarantee that \nour correctness invariant described above is preserved. This also allows us to re-qualify names that \nwould otherwise refer to different declarations before and after the refactoring. If no symbolic name \ncan be computed for a desired context we abort the rename operation and revert all changes. We have previously \nshowed how name lookup can be implemented in a modular syntax directed fashion using attribute gram\u00admars \n[EH06]. In this work we show how to systematically invert each lookup rule by providing a corresponding \nin\u00adverted rule to each lookup rule to which creates a symbolic name. The rules can be tailored for various \nlevels of qual\u00adi.cation which enable .exible renaming where the desired intrusiveness can be selected \nby the tool developer or even the tool user. The notion of inverted lookup aligns well with Opdyke s \npreconditions for renaming, where he states that the actual conditions are closely tied to name lookup \nfor a particular language [Opd92]. A major challenge for analysis tools is how to handle changes and \nextensions to a language. Indeed, we found sev\u00aderal examples of unsoundness in refactoring engines due \nto unsupported language extensions, e.g., static imports as in\u00adtroduced in Java 5. To address this problem \nwe show how to extend renaming speci.cations in a modular fashion to support new language features. The \nclose correspondence between lookup and renaming enables the compiler imple\u00admentor to preserve the renaming \ninvariant by adding a re\u00adverse rule each time she implements a language construct that affects name binding. \nWe have implemented a complete renaming engine for Java as a modular extension to the JastAdd Extensible \nJava Compiler (JastAddJ) [EH07] and integrated it as a plugin to Eclipse1. The engine has been validated \nagainst both auto\u00admatically generated tests, and our own renaming test suite for benchmarking refactoring \nengines. The suite exposes 1 All tools including source are available for download at http://jastadd.org/refactoring-tools. \nseveral bugs due to too weak preconditions in other ma\u00adjor refactoring engines which causes the binding \ninvariant to be violated. Moreover, it includes numerous examples where our approach succeeds in renaming \nentities by insert\u00ading quali.cations where other refactoring engines fail. Extensibility is validated \nby adding renaming support for Java 5 and AspectJ like inter-type declarations as modular extensions \nto the Java 1.4 refactoring engine. Both exten\u00adsions can be used individually with their corresponding \ncom\u00adpilers or together to support renaming for the combined set of language features. All in all the \nimplementation is less than 3000 lines of code. The renaming infrastructure can also be used as a build\u00ading \nblock when implementing more high-level refactorings. Refactorings that rearrange or produce new code \nneed to ensure that the binding structure is preserved. A common framework handling these low-level details \nallows the im\u00adplementor to focus on issues germane to the refactoring at hand. This could reduce the \nnumber of naming related bugs which we have found to be pervasive in all major refactoring engines. In \nsummary, we present a systematic approach to renam\u00ading Java based on inverted lookup rules. The approach \nis: Sound when each lookup rule in the name analysis has a corresponding inversion rule. Flexible in \nthat the level of quali.cation in names intro\u00ad duced during renaming can be tailored as desired. Modular \nwhere each language construct is speci.ed in iso\u00ad lation using syntax directed rules. Extensible since \nboth lookup rules and inversion rules are implemented in a declarative modular fashion and auto\u00ad matically \ncomposed into a global solution. The rest of this paper is structured as follows. In Section 2 we give \nan introduction to renaming and describe de.cien\u00adcies in existing refactoring engines. We also give an \nintro\u00adduction to the correctness criterion used throughout the pa\u00adper. An introduction to name lookup \nusing JastAdd is given in Section 3. Section 4 gives a detailed presentation of the reverse lookup strategy \nand shows how to tailor the desired level of name quali.cation. We show how to support renam\u00ading of an \nextended language in Section 5.The approach is evaluated in Section 6 with respect to its correctness, \nperfor\u00admance, and extensibility. Related work is discussed in Sec\u00adtion 7 and we .nally conclude and present \nfuture work in Section 8. 2. Example: Rename Variable Throughout this paper, we will take the Rename \nVariable refactoring as our running example. In standard Java termi\u00adnology [GJSB05], both local variables \n(including parame\u00adters) and .elds (either static or instance) are referred to sim\u00adply as variables. The \naim of the Rename Variable refactoring class A{ int x; A(int y) { x = y; } } Figure 1. A simple example \nprogram to refactor class A{ int x; A(int newX) { x = newX; } } Figure 2. A simple example program, refactored \nis to change the name of a variable and make all necessary changes to the program such that all bindings \nare preserved. In this section, we will give several example programs to refactor. We will use these \nexamples to contrast our imple\u00admentation with the refactoring engine of Eclipse, which is mature and \nwidely used. A .rst example program is shown in Figure 1. There are two variable declarations in this \nprogram, one for the .eld x, which is an instance member .eld of class A, and one for the parameter y \nof method m, which is itself an instance member method of class A. The .eld x is referenced once in the \nbody of m by the sim\u00adple name x. We collectively refer to all expressions that refer to a .eld as (.eld) \naccesses, and likewise for other named en\u00adtities such as types and methods. Beside the example here, \nthere are many more possible accesses that could also refer to the .eld x from inside method m, for example \nthis.x, ((A)this).x, or even A.this.x. The local variable y is also referenced once, by the simple name \ny (which is, of course, a local variable access). In contrast to .elds, there is no way to qualify local \nvariable accesses. A local variable is thus either directly visible or inaccessible. Now our little example \nprogram is perhaps not in very good style, since the name of the constructor parameter y bears no relation \nto the name of the .eld it is used to ini\u00adtialise, which may be a bit confusing. We could, for example, \nrename the parameter to newX; this is easily accomplished, for example, in Eclipse, and will yield the \nrefactored code in Figure 2, in which the parameter declaration and all refer\u00adences to it use the new \nname. Observe that the refactored program has the same binding structure as the original, i.e., every \naccess still refers to the same entity as in the original program; our refactoring was successful. class \nA{ int x; A(int x) { this.x = x; } } Figure 3. A simple example program, refactored again Another commonly \nseen idiom is for the parameter to have the same name as the .eld it initialises. But trying to perform \nthis refactoring will fail, for example, in Eclipse since the newly renamed parameter collides with the \n.eld. The same refactoring will, however, be successfully per\u00adformed if we .rst change the access to \n.eld x to this.x manually. Ideally, one would like the IDE to carry out this sort of adjustment automatically. \nOur implementation does this, and yields the code in Figure 3. Again, the binding structure of the refactored \nprogram is the same, although the access x has changed to this.x. To achieve this, our implementation \nproceeds as follows: For every access occurring in the program, we know which declaration it should bind \nto (the same one as in the original program); if needed, we compute a new access that will in fact bind \nto that declaration in the refactored program, and replace the old access by the new one. This ensures \nthat the binding structure of the refactored program is the same as that of the input program, i.e. the \nrefactoring is correct. The key observation about the access computation func\u00adtion is that it is a (partial) \nright inverse to the lookup func\u00adtion: We can think of the lookup function at a certain pro\u00adgram position \np as a partial function lookup: access -decl p that determines for a given access the declaration it \nrefers to (if any). The access computation function at the same position should now be a partial function \naccessp: decl -access that determines for a given declaration an access that refers to it (if there is \none). Correctness of our access computation means that lookup(accessp(d)) = d p for every declaration \nd and program position p, if accessp(d) is de.ned. We will not formally prove that our refactoring engine \nful.lls this condition, but it provides a basic guideline for implementation. Our access computation \nis directly mod\u00adelled after the lookup machinery of the JastAddJ Java com\u00adpiler with the code for access \ncomputation closely mirroring the code for lookup. This ensures that we will not forget one of the many \nborder cases that exist in a complex language like Java. class A{ public static void main(String[] args){ \nfinal int y = 23; new Thread() { int x = 42; void run() { System.out.println(y); } }.start(); } } Figure \n4. A more complex example class A{ public static void main(String[] args){ final int x = 23; new Thread() \n{ int x = 42; void run() { System.out.println(x); } }.start(); } } Figure 5. A more complex example, \nwrongly refactored Traditionally, many implementations of automatic refac\u00adtorings have tried to avoid \ntricky cases by checking a set of preconditions before performing the refactoring. However, these preconditions \nare formulated from scratch and it is very hard to ensure that they really cover every nook and cranny. \nWhen we tried to rename newX to x above, the precondi\u00adtions were strong enough and warned about the name \ncolli\u00adsion. In fact, we argued that they were too strong, since the refactoring can easily be carried \nout with only slightly more invasive changes to the user s code. However, in Figure 4 we have a not much \nmore complex program where Eclipse s preconditions are not strong enough. This little program constructs \na thread and runs it; the thread will print 23. Similar to before, we have a .eld x and a local variable \ny, but this time their scopes are nested in the opposite way. If we tell Eclipse to rename the local \nvariable to x, it obliges, but creates the output program seen in Figure 5 whose binding structure is \nnot the same as the input program s. Incidentally, its behaviour is different as well: the refactored \nprogram prints 42. Our implementation does not check preconditions in ad\u00advance. Instead, when a rename \nis performed, it tries to adjust all accesses such that they resolve to the same declaration as before. \nIn our last example, the refactoring engine tries to compute an access to the newly renamed local variable \nx from inside the thread class. There it will discover that there import static java.lang.Math.*; class \nIndiana { static double myPI = 3.2; static double CircleArea(double r) { return PI*r*r; } } Figure 6. \nExample program using the static import feature is in fact no such access, reject the refactoring, and \nundo all previous changes. It may seem to be prohibitive to adjust all accesses oc\u00adcurring in the input \nprogram. Intuitively, it is clear that most of them will not be in.uenced by the refactoring. But which \nones do need adjustment? For one, certainly every reference to the entity being renamed has to be updated. \nBut as the ex\u00adample above shows there might be other entities which are endangered by the rename and \nwill need to have some or all of their accesses adjusted. Towards the end of Section 4 we will discuss \na very simple approximation to determine the endangered set that works well in practice. Another major \nissue for refactoring engines is language evolution: Since its inception, the Java language has gone \nthrough seven major revisions (Java 1.0 to 1.4, Java 5, and Java 6) with an eighth on the horizon. While \nsome of these revisions mostly concerned the standard library or minor is\u00adsues of language syntax, the \ntransition from Java 1.4 to Java 5, in particular, brought with it a wealth of new features and concepts, \nwhich refactoring engines are, of course, expected to support. To pick just one example, let us look \nat the static import feature. It allows the programmer to import static .elds and methods of classes \nso that they do not have to be explicitly quali.ed, which is very useful for frequently used constants \nlike Math.PI. But the introduction of static imports also had a signif\u00adicant impact on the way name lookup \nis performed: Previ\u00adously, only types could be imported, so import statements never affected the visibility \nof variables. Static imports do, however, and what affects lookup also affects renaming. Take, for example, \nthe program in Figure 6. The class Indiana is located in a compilation unit that statically im\u00adports \nthe .eld Math.PI so that it can be accessed using the simple name PI; at the same time, the class also \nde.nes a static .eld named myPI. If we want to rename myPI to PI, we must also qualify the access to \nMath.PI, as our implementation does, yielding the program of Figure 7. Before the introduction of static \nimports, when renaming the .eld in this example it would have been enough to check for collisions with \nother variables in class Indiana, but now we also need to consider the import declarations of the surrounding \ncompilation unit. import static java.lang.Math.*; class Indiana { static double PI = 3.2; static double \nCircleArea(double r) { return Math.PI*r*r; } } Figure 7. Example program with static import, refactored \nTwo of the most popular Java IDEs, Netbeans and IntelliJ, fail to take this into account and incorrectly \nrefactor this example. Eclipse and JBuilder both detect the name clash in this case, but fail on a very \nsimilar example where we instead import a static method and shadow it locally [EESV08]. Thus none of \nsurveyed IDEs offers complete support for static imports. Our implementation covers this example as well \nas all other Java 5 features. The refactoring engine for Java 1.4 is implemented as an extension of JastAddJ \ns Java 1.4 frontend with its access computation modelled after the lookup rules. To support Java 5, we \nonly need to implement a correspond\u00ading extension for the Java 1.5 module of the frontend. Since all \nthe lookup rules for the new language features are care\u00adfully implemented there, we only need to equally \ncarefully translate them into access computation rules. 3. Lookup The approach we present to .exible \nrenaming is closely re\u00adlated to name lookup and its implementation in the JastAddJ compiler. We therefore \ngive an introduction to that approach as background before presenting the reverse lookup strategy in \nSection 4. A more detailed description and a thorough evaluation are given in [EH07, EH06]. The purpose \nof name lookup is to bind each symbolic name to a corresponding declaration. This is traditionally done \nby traversing the program s abstract syntax tree and populating a symbol table with declarations that \nare in scope at various locations in the tree. This often leads to scheduling problems of traversals \ndue to dependencies between analy\u00adses such as name name lookup and type analysis [AET08]. We therefore \ntake a different approach in JastAddJ and use the AST itself as a symbol table, by specifying name lookup \nas a function of the tree location for each symbolic name. Lookup rules are speci.ed in a syntax directed \nfashion over the AST extended with additional graph structure such as name bindings, type hierarchies, \netc. That technique gives us the following properties: Modularity in that we can specify the name lookup \nfor each language construct that affects scoping in isolation. Composability in that rules for individual \nlanguage con\u00ad structs can be combined to support the complete language automatically. class X{ int a; \n} class Y{ int b; class Z extend X { int c; void m(boolean d) { int e; if(d) { int f; } } } } Figure \n8. Name lookup in Java with numerous nested scopes and inheritance. Declarations a to f are all accessible \nwith their simple names from the position marked Declarativity in that we need not specify the order \nin which these rules are executed or combined. Extensibility in that we can support lookup for language \nextensions by either adding new rules or re.ne existing rules. Object-oriented languages with nested \nclasses and inheri\u00adtance provide many challenges from a name lookup point of view. Consider the Java \nexample in Figure 8. Variable dec\u00adlarations a-f are all accessible with a simple name in the lo\u00adcation \nmarked . To bind f we search the local block; e is visible since it is declared in an enclosing block; \nd is a pa\u00adrameter in an enclosing method; the .eld c is a local member .eld in the current class; a is \nan inherited member .eld from its superclass; b is visible since it is declared in an enclosing class. \nThis strategy can be viewed as if lookup progresses outwards lexically with the exception that member \nlookup does a detour upwards the inheritance hierarchy. We now present how Java name lookup with lexically \nnested structures and inheritance can be implemented using attribute grammars in JastAdd. First we present \nthe static structure of the language and then show how to add name lookup on top of that structure using \nsyntax directed rules. 3.1 Abstract Grammars JastAdd uses an abstract grammar to model the structure \nof the AST. Consider the grammar in Figure 9 which models a subset of Java with nested blocks, nested \nclasses, inheri\u00adtance, and quali.ed access. It consists of a set of productions where each production \ndescribes an AST node type and a list of children, which can be either subtrees or terminals. For example, \na ClassDecl has a string typed terminal child named ID to hold the name of the class, an optional child \nnamed Super which is an Access, and a list of BodyDecl children. ClassDecl ::= <ID:String> [Super:Access] \nBodyDecl*; abstract BodyDecl; FieldDecl : BodyDecl ::= Type:Access <ID:String> [Init:Expr]; MethodDecl \n: BodyDecl ::= Type:Access <ID:String> ParameterDecl* [Block]; MemberClass : BodyDecl ::= ClassDecl; \nParameterDecl ::= Type:Access <ID:String>; abstract Stmt; Block : Stmt ::= Stmt*; VariableDecl : Stmt \n::= Type:Access <ID:String> [Init:Expr]; abstract Expr; abstract Access : Expr; VarAccess : Access ::= \n<ID:String>; TypeAccess : Access ::= <ID:String>; Dot : Access ::= Left:Expr Right:Access; Figure 9. \nAn abstract grammar for an object-oriented lan\u00adguage with nested blocks, nested classes, and inheritance, \nused to introduce name lookup A class will be generated for each production with get\u00adters and setters \nfor accessing the children. For example, ClassDecl will have a getter String getID() for its ter\u00adminal \nchild. The optional child Super exists when the .ag boolean hasSuper() is true, and can then be queried \nus\u00ading Access getSuper(). The list of body declarations has getters for length, int getNumBodyDecl(), \naccess to in\u00addividual elements, BodyDecl getBodyDecl(int i), and iteration by Iterable<BodyDecl> getBodyDecls(). \nA production can inherit from another production, which translates into inheritance between the classes \ngenerated from them. For instance, FieldDecl inherits the abstract node type BodyDecl. All nodes implicitly \ninherit ASTNode, just like all Java classes extend Object. The type ASTNode holds generic node traversal \ncode and other behaviour com\u00admon to all tree nodes. 3.2 Lookup and type analysis external API Lookup \nand type analysis are speci.ed using declarative at\u00adtribute grammars. Attributes can be seen as normal \nmeth\u00adods when invoked from imperative Java code, but an at\u00adtribute evaluation engine derives a suitable \nevaluation order between dependent attributes. JastAdd allows attributes to be reference valued, i.e., \nrefer to other nodes in the AST. Name lookup is then cast into the problem of binding a name to // Lookup \nis used to find a visible // declaration in a particular context Variable ASTNode.lookupVariable(String \nname); MethodDecl ASTNode.lookupMethod(String name); TypeDecl ASTNode.lookupType(String name); // The \nlookup framework is used to bind // accesses to corresponding declarations Declaration ASTNode.lookup(Access \nacc); // Each expression has a type and binds // to its corresponding declaration TypeDecl Expr.type(); \nFigure 10. The API for name lookup and type analysis rel\u00adevant to renaming. The node types are declared \nin Figure 9. its corresponding declaration. Type analysis is similarly un\u00adderstood as binding each expression \nto a type declaration representing its static type. Throughout this presentation we will use the API \nin Fig\u00adure 10. It is possible to lookup variables, methods, and types from all nodes in the AST. We de.ne \na common inter\u00adface Variable for VariableDecl, ParameterDecl, and FieldDecl since they are treated the \nsame during lookup. We have a similar interface Declaration to abstract over all kinds of declarations. \nLookup is then used to bind each access to a declaration through the attribute lookup(). The type of \nan expression is similarly accessible through the type() attribute. The following sections will show \nhow these attributes are implemented.  3.3 Nesting with shadowing The purpose of name lookup is to .nd \nthe declaration that corresponds to a symbolic name in a particular context. At\u00adtribute grammars provide \ninherited attributes which enable abstraction over the current context. An inherited attribute is declared \nin a node and any ancestral node may provide an equation de.ning the value for that attribute. That way \nthe symbolic name need not be aware if it is, for example, nested in a block, method, or .eld initialiser. \nConsider the code snippet in Figure 11. We declare an in\u00adherited attribute named lookupVariable(String \nname) in the Access type using an inter-type declaration. This will allow all access nodes to lookup \nvariables visible from their particular contexts. Inter-type declarations are implemented outside their \nclasses but otherwise act as if they were de\u00adclared locally. This enables us to group attribute de.nitions \nby their concerns rather than by the type of their receiver. Next we de.ne an equation for that attribute \nprovided by the Block node since it introduces a new scope. The rule gives an equation for the lookupVariable(String \nname) attribute in each subtree that can be reached from the Block node using the accessor getStmt(int \ni). Such a subtree corresponds to the ith statement within the block. To look up a variable from such \na statement, we .rst search for local declarations which is done by the attribute localVariable(String \nname). If there is no such dec\u00adlaration we call lookupVariable(name) from the Block to .nd a declaration \nin the enclosing context of the block. Since we only delegate to the enclosing context when no local \ndeclarations are found we effectively implement shad\u00adowing. Additional .lters can be used to also check \nthat vari\u00adables are not used before they are de.ned, and to enforce accessibility restrictions. Notice \nthat the equation is only valid for the subtrees reachable through getStmt(int i) and not the Block it\u00adself. \nWhen we call lookupVariable(name) on the Block we therefore read the inherited attribute declared in \nBlock which has an equation in an ancestor to the block, e.g., a nested block or method. This kind of \nchaining of inherited equations allow us to gradually progress outwards through the nested scopes when \nsearching for declarations. The local search is implemented using a synthesised at\u00adtribute to iterate \nover local declarations to .nd a Variable in the Block itself. For this presentation they can be seen \nas virtual methods added as inter-type declarations. However, the implementation may not contain any \nexternally visible side-effects, which enables caching of attribute values. These kinds of attributes \nand equations are used for all language constructs introducing new scopes. A MethodDecl needs, for instance, \nan eq lookupVariable(String name) that is identical to the one in Block, a synthesised attribute localVariable(String \ns) that iterates over its formal parameters, and an equation isVariable(String name) in ParameterDecl \nidentical to the one in VariableDecl. The same technique is used to implement lookup for types and methods. \nType lookup is for instance quite similar to variable lookup in that equations are needed to lookup local \nclasses in a block, member classes that are inherited, and nested classes. There is also an outermost \nequation for lookupType(String name) in CompilationUnit that handles imports.  3.4 Member inheritance \nA ClassDecl is similar to a Block in that it is a nested structure that introduces a scope for variables, \nin this case member .elds, and therefore needs to provides equations for lookupVariable(String name). \nIt differs a bit in that not only local declarations should be considered but also member inherited from \nsuperclasses. Nested scope lookup is, so to speak, an outwards movement that searches enclos\u00ading scopes, \nwhile member lookup searches upwards in the inheritance hierarchy. Consider the implementation in Figure \n12. Besides the usual localVariable(String name) in ClassDecl and isVariable(String name) in FieldDecl, \nwe also in\u00adtroduce an attribute memberFields(String name) which is synthesised. This attribute includes \nlocal declarations as well as declarations inherited from superclasses. Notice that inh Variable Access. \nlookupVariable(String name); eq Block.getStmt(int i). lookupVariable(String name) { // find local declarations \nVariable v = localVariable(name); if(v != null) return v; // otherwise delegate to enclosing context \nreturn lookupVariable(name); } // the block will need to delegate lookup inh Variable Block. lookupVariable(String \nname); syn Variable Block.localVariable(String name) { // iterate over contained statements for(Stmt \ns : getStmts()) if(s.isVariable(name)) return (Variable)s; return null; } // most nodes are not variable \ndeclarations syn boolean ASTNode.isVariable(String name) = false; // only declarations with matching \nnames eq VariableDecl.isVariable(String name) = name.equals(getID()); Figure 11. Nested scopes variable \nlookup implementation. we include superclasses transitively by recursively invok\u00ading memberFields on \nthe type of the speci.ed superclass name. This introduces a dependency between name lookup and type analysis, \nbut fortunately the attribute evaluation scheme will schedule the computations automatically.  3.5 Quali.ed \naccess A ClassDecl plays two roles from a name lookup perspec\u00adtive. It provides an equation for its members \nwhen using lookupVariable(String name). This includes its mem\u00adbers as well as declarations from lexically \nenclosing con\u00adstructs, e.g., nested classes, .nal local variables in enclosing methods for anonymous \nclasses, statically imported .elds, etc. However, during quali.ed lookup, e.g., accessing a .eld in an \nobject, only members should be considered as illus\u00adtrated in Figure 13. The equation for memberFields(String \nname) is thus kept separate not only for understandability and sep\u00adaration of concerns but also to be \nreused during quali.ed lookup. Quali.ed lookup can then be implemented by look\u00ading up remote members \nsimilar to the way members are looked up in superclasses. A quali.ed name is modelled as two separate \naccesses that share a common Dot parent node. syn Variable ClassDecl. localVariable(String name) { for(BodyDecl \nb : getBodyDecls()) if(b.isVariable(name)) return (Variable)b; return null; } eq FieldDecl.isVariable(String \nname) = name.equals(getID()); eq ClassDecl.getBodyDecl(int i). lookupVariable(String name) { // search \nfor member fields Variable v = memberField(name); if(v != null) return v; // otherwise delegate to enclosing \ncontext return lookupVariable(name); } syn Variable ClassDecl. memberField(String name){ // search local \ndeclarations Variable v = localVariable(name); if(v != null) return v; // search inherited members return \nhasSuper() ? getSuper().type().memberField(name) : null; } Figure 12. Inheritance variable lookup implementation. \nclass X{ int a; } class Y{ int b; class Z extend X { int c; Zz= new Z(); // OK: local member c in Z \nint i1 = z.c; // OK: member a inherited from X int i2 = z.a; / / ERROR : q u a l i f i e d a c c e s \ns d o e s n o t / / s e a r c h e n c l o s i n g c l a s s e s int i3 = z.b; } } Figure 13. Quali.ed \n.eld access Access ASTNode.accessVariable(Variable v); Access ASTNode.accessMethod(MethodDecl m); Access \nASTNode.accessType(TypeDecl t); Figure 14. The API for access construction We can then simply take the \ntype of the left hand side of a quali.ed name, and search its member .elds for a matching name. eq Dot.getRight().lookupVariable(String \nname) = getLeft().type().memberField(name); The same technique is used for memberTypes when ac\u00adcessing \na type by its fully quali.ed name, i.e., including its package name and possibly enclosing type names. \nFinally, we can now outline the implementation of the lookup function itself: In an invocation of the \nform p.lookup(acc), the node p indicates the context (i.e., the position in the syntax tree) from where \nthe lookup of access acc is performed. If the access is quali.ed, we recursively look up the access to \nthe right of the Dot. Otherwise it is either a VarAccess,a MethodAccess, a TypeAccess. All of these are \njust wrappers for simple names that tell us which lookup function to delegate to. In particular, if acc \nis a VarAccess with name n, we delegate to p.lookupVariable(n). 4. Specifying Renaming We will now give \nan executable speci.cation of access com\u00adputation as a right inverse of lookup: each lookup equation \nfrom the previous section is inverted, yielding a correspond\u00ading equation for access computation. As \na .rst step, we outline a very simple access compu\u00adtation that never produces quali.ed accesses. It can \nbe used as the basis of a non-intrusive renaming implementation that will never add extra quali.cations; \nin particular, this imple\u00admentation cannot perform the refactoring from Figure 3. We then show how it \ncan be extended to produce a possibly qual\u00adi.ed access as its result. Similar inverses are required for \ntype lookup and method lookup, and can be constructed using the same approach. Together, they form the \nexternal API given in Figure 14, which is closely related to the lookup API in Figure 10. Our informal \nstatement that access computation should be a partial right inverse of lookup can now be cast into a \nmore concrete form: For every variable v and AST node p, if p.accessVariable(v) is not null, then we \nshould have p.lookup(p.accessVariable(v)) == v and likewise for the other two access computation func\u00adtions. \nIt is worth noting that renaming should never affect visibility, and need therefore not deal with access \ncontrol modi.ers such as public and private. syn Access Block.accessLocal(Variable v) { // iterate over \ncontained statements for(Stmt s : getStmts()) if(s== v) // and search for a particular variable return \nnew VarAccess(v.getID()); return null; } syn Access ClassDecl.accessLocal(Variable v) { for(BodyDecl \nb : getBodyDecls()) if(b== v) return new VarAccess(v.getID()); return null; } Figure 15. Inverting local \nlookup in blocks and classes eq Block.getStmt(int i). accessVariable(Variable v) { Access acc = accessLocal(v); \nif(acc != null) return acc; return accessVariable(v); } Figure 16. First attempt at inverting a lookup \nrule 4.1 Non-Intrusive Renaming The simple access computation we introduce here will only tell us whether \na variable can be accessed through its sim\u00adple name. Given a variable v, it will thus either return a \nVarAccess containing v.getID() if the variable is visi\u00adble, or null if it is inaccessible. The equations \nimplementing the lookupVariable at\u00adtribute in Figures 11 and 12 all follow a very simple pattern: First, \nwe try perform a local lookup on the current node, and if that does not yield any result we recursively \ninvoke our\u00adselves on another node. In the equation specifying lookup at a statement inside a block, for \nexample, we .rst invoke localVariable; if that fails, lookupVariable is recursively invoked on the parent \nnode, i.e. the block itself. First we invert the attribute Block.localVariable, which is easily done. \nSince the code is very similar, we also invert the corresponding equation for Classes; both are given \nin Figure 15. Note that in a valid Java program there can be only one declaration with a given name in \nev\u00adery block or class, hence the given code snippets really are inverses to the local lookup attributes \ngiven in the previous section. Encouraged by our success we now would like to invert the equation for \nlookupVariable on a block statement. Our .rst attempt might look like the code in Figure 16. eq Block.getStmt(int \ni). accessVariable(Variable v) { Access acc = accessLocal(v); if(acc != null) return acc; acc = accessVariable(v); \n// check for shadowing in block if(localVariable(acc) != null) return null; return acc; } Figure 17. \nRight inverse of a lookup rule This, however, is not quite right. Consider, for example, the following \nprogram fragment: class A{ int x; void m() { int x; } } Assume we want to construct an access to the \n.eld x in A from the position marked . Since that position is the second statement within a block, the \nequation will be evaluated with parameter i set to 1 (indexing is zero-based). The auxiliary method accessLocal \nwill not .nd the declaration we are looking for: although there is a declara\u00adtion for a local variable \nx, this declaration is not equal to the declaration we are trying to access. Hence we will invoke accessVariable \nagain, one node higher up in the syntax tree. Eventually it will return the access x, which does in fact \nrefer to the .eld if seen outside the body of method m. Inside that body, however, it does not, but will \ninstead refer to the like named local variable of m. Generally speaking, we can not always directly return \nthe access computed recursively at a higher node in the syntax tree, but we might need to adjust it to \nmake sure it is still valid. However, we are not dealing with quali.ers just yet, so for the moment all \nwe do is to check for shadowing, and fail (i.e., return null) if that occurs. The resulting code is in \nFigure 17. Tracing all possible execution paths of this equation, one sees that this equation is indeed \ninverse to the one in Fig\u00adure 11, under the assumption that local access and local lookup are inverses \n(which is easily seen) and that the re\u00adcursive invocation of accessVariable on the parent node is inverse \nto the recursive invocation of lookupVariable (which acts as a sort of induction hypothesis). The process \nof inverting is not entirely straightforward to automate, mainly owing to the fact that the equations \ncan contain arbitrary Java code (without side effects). It is certainly systematic, though, and can be \nperformed manually for every lookup rule without much dif.culty. class A{ int x6; } class B extends A{ \nint x5; } class C extends B{ int x4; class D extends F{ int x1; } } class E{ int x3; } class F extends \nE{ int x2; } Figure 18. Quali.ed accesses in Java Field name Source Bend Safely quali.ed access x1 D \nD this.x1 x2 F D super.x2 x3 E D ((E)this).x3 x4 C C C.this.x4 x5 B C C.super.x5 x6 A C ((A)C.this).x6 \n Table 1. Safely quali.ed accesses (cf. Figure 18) 4.2 Adding Quali.ers Now we will show how to extend \nthe above approach to add quali.cations. Remember that .eld lookup in Java pro\u00adceeds in an outwards and \nupwards motion: We .rst look among the member .elds of the lexically enclosing class, then among all \nits supertypes, then among the next lexically nested class, then among that class supertypes, and so \non. When the .eld is .nally found, it will be located in an an\u00adcestor class A of some class B lexically \nsurrounding the point of lookup. We call the class A the source and the class B the bend. To illustrate \nall possible cases, Table 1 indicates for every .eld in the program in Figure 18 what its source and \nbend are when looked up from the position . The table also gives a safely quali.ed access for each .eld, \ni.e. an access that would refer to the .eld even if it were shadowed in some way. We can see, for example, \nthat a .eld can always be safely accessed by qualifying with this if its source and bend class are both \nequal to the class lexically surrounding the point of lookup. Similar rules exist for the other quali.cations, \nso in order to determine how a .eld can be accessed it is enough to compute its source and bend. eq ClassDecl.getBodyDecl(int \ni). accessVariable(Variable v) { VarAccessInfo acc = accessMember(v); if(acc != null) return acc; acc \n= accessVariable(v); if(acc != null) return acc.moveInto(this); return null; } syn VarAccessInfo ClassDecl. \naccessMember(Variable v) { VarAccessInfo acc = accessLocal(v); if(acc != null) return v; if(hasSuper()) \n{ acc = getSuper().type().accessMember(v); if(acc != null) return acc.moveDownTo(this); } return null; \n} Figure 19. Right inverse of lookup rule with re\u00adquali.cation Our improved version of accessVariable \ndoes no longer simply return a String, but a VarAccessInfo, which stores the source and bend of the .eld \nto be accessed (the target) as well as a .ag indicating whether the .eld is shadowed or hidden (by a \nlocal variable or another .eld). In a second step, this information will be used to create an actual \nAccess. We will at .rst omit this step for simplicity. Corresponding to the two directions of movement \ndur\u00ading lookup, there are two basic situations where the access information has to be updated: Whenever \nwe return from a lookup at a parent node we need to move the informa\u00adtion into the inner scope (e.g., \na class or a block), noting whether any shadowing could take place; upon returning from a lookup in a \nparent type we need to move the infor\u00admation down to the child type, again noting possible hiding. These \ntwo movements are achieved by methods moveInto and moveDownTo in VarAccessInfo. For example, let us look \nat the inverses of memberField and lookupVariable when invoked on a body declaration inside a class, \nwhich are given in Figure 19. In the .rst case, after having computed an access to variable v from outside \nthe class (for example, from its enclosing class), we need to move this access into the class: We check \nwhether there is a member .eld of the same name that would shadow v (which is the target of our access \ncomputation), and if so set a .ag to indicate that a quali.er will have to be added when we create an \nAccess to v (see Figure 20). Similarly, after having computed an access to a variable in the super class, \nwe need to move this access down to public VarAccessInfo moveInto(ClassDecl td) { if(td.memberField(target.getID())!=null) \nneedsQualifier = true; return this; } public VarAccessInfo moveDownTo(ClassDecl td) { if(td.localVariable(target.getID())!=null) \nneedsQualifier = true; return this; } Figure 20. Moving an access into and down to a type dec\u00adlaration \nAccess toAccess() { VarAccess va=new VarAccess(target.getID()); if(needsQualifier) { if(bend == enclosingType()) \n{ if(source==bend) return new Dot(new ThisAccess(), va); else if(source==bend.getSuper().type()) return \nnew Dot(new SuperAccess(), va); } return null; } else { return va; } } Figure 21. Generating accesses \nthe current class, checking whether there are any local .elds that could hide the variable being accessed. \nHaving the moving methods return a VarAccessInfo leaves open the possibility that such a movement may \nfail and return null. This allows us to handle local variable accesses in the same way as .eld accesses: \nThey are rep\u00adresented by objects of type LocalVarAccessInfo which extends VarAccessInfo. However, since \nlocal variable ac\u00adcesses can not be quali.ed, its moveDownTo and moveInto methods will always return \nnull if any shadowing is de\u00adtected. Once all the required information is collected, we need to produce \na Java expression to actually access the tar\u00adget .eld. This is handled by a method toAccess in class \nVarAccessInfo. Figure 21 shows a simpli.ed implemen\u00adtation of the access generation, which can generate \nthis-or super-quali.ed accesses: The actual implementation goes further and can, in fact, generate all \nof the access forms in Table 1 including casts. class A{ int x; } class B extends A{ int y; } class C{ \nint m(B b) { return b.x; } } Figure 22. The need for merging accesses In addition, it also checks a number \nof additional conditions to ensure that only correct accesses are generated2. It is certainly debatable \nif a refactoring engine should in\u00adtroduce complex quali.cations like ((A)B.this).x into a program, but \nwe found it hard to draw an a priori bound\u00adary between reasonable and unreasonable quali.cations. The \ndegree of intrusiveness can be adjusted by changing the implementation of the toAccess methods, and it \nis certainly conceivable to make this con.gurable by the user. If no qual\u00adi.cations are ever added, we \nagain obtain an Eclipse-style maximally unobtrusive refactoring. Correctness of this enhanced implementation \nis no longer as easy to see as for the simple implementation, but it still follows the implementation \nof lookup equation by equation. 4.3 Access Merging One .nal subtlety which we have ignored so far has \nto do with quali.cations. Consider the example program in Figure 22. In method C.m, we access the .eld \nx of an object of type B. Now assume we want to rename that .eld to y. Obvi\u00adously, we also need to adjust \nits (only) reference and com\u00adpute a new access to put in its place. Our access computa\u00adtion suggests \nsuper.y, which is indeed a correct way of accessing the .eld from inside B. We cannot, however, sim\u00adply \ninsert this access in place of the reference, as that would result b.super.y, which is not valid Java. \nInstead we want to merge the access super.y with its quali.er b, yielding the access ((A)b).y. Intuitively, \nthis merging step can be understood as sub\u00adstituting the quali.er for this: Since super.y in the above \nexample is actually just a shorthand for ((A)this).y, re\u00adplacing this by b yields the desired result. \nFor our pur\u00adposes, the merging of a quali.er q and a .eld access a can 2 For example, an access such \nas this.x is invalid inside a static method or a static initialiser, and hence should not be generated. \nbe described by three rewrite rules: q . n . q.n for any name n q . this.n . q.n q . super.n . ((A)q).n \nwhere A is the superclass of q s type In the last case, we will need to construct a type access referring \nto type A. This is done by an attribute accessType, whose implementation is modelled after lookupType. \nCom\u00adputing an access to a type has to handle very similar prob\u00adlems like computing a variable access: \nin particular, types can also be shadowed or hidden by other types, and some\u00adtimes even be obscured by \n.elds of the same name. Overall, its implementation is very similar to accessVariable.  4.4 Determining \nEndangered Declarations We have seen above how to adjust accesses to make sure that they refer to a given \ndeclaration. But how do we decide which accesses need adjustment? In general, it is clear that when renaming \nan entity x to y, the only declarations that can possible be endangered are those which themselves declare \nentities called either x and y. So a very straightforward approach would be to sweep the entire program \nfor all simple names x and y and treat all of them as potentially endangered accesses. This sounds somewhat \nexpensive, however, so a more re.ned approach could try to make use of the language s lookup rules to \nnarrow down the set of endangered accesses. Surprisingly, it turns out that this is not needed. As our \nevaluation in Section 6 shows, the na\u00efve approach works quite well in practice, and has the additional \nadvantage of being largely language independent. 5. Extending Renaming One of the major features of JastAddJ \nis its extensibility which allows modular speci.cation of language features. The name lookup presented \nin Section 3 can be modularly extended to handle new language features, such as the en\u00adhanced for statement \nand static imports in Java 5. Since our implementation of access computation has a direct cor\u00adrespondence \nto the name lookup implementation (and the computation of endangered accesses is language indepen\u00addent) \nwe enjoy the same kind of modularity. JastAddJ is actually implemented as a Java 1.4 compiler with Java \n5 and AspectJ-like inter-type declarations imple\u00admented as modular extensions. In the same way, we have \nex\u00adtended our Java 1.4 refactoring engine with support for Java 5 and inter-type declarations. 5.1 Java \n5 There are quite a few language features in Java 5 that af\u00adfect name binding. For instance, static imports \nof .elds and methods make imported entities visible in the current compi\u00adlation unit with their simple \nnames, and generic types intro\u00ad eq CompilationUnit.getTypeDecl(int i) .lookupVariable(String name) { \nfor(ImportDecl i : getImportDecl()) if(i.importsField(name) != null) return i.importsField(name); for(ImportDecl \ni : getImportDecl()) if(i.importsFieldOnDemand(name) != null) return i.importsFieldOnDemand(name); return \nlookupVariable(name); } // match name then return member eq StaticImportDecl.importsField(String name) \n= name().equals(name) ? type().memberField(name) : null; // on demand matches all members eq StaticImportDeclOnDemand \n.importsFieldOnDemand(String name) = type().memberField(name); Figure 23. Import static .elds lookup \nimplementation eq CompilationUnit.getTypeDecl() .accessVariable(Variable decl) { for(ImportDecl i : getImportDecls()) \nif(i.importsField(decl.name()) == decl) return new VarAccessInfo(decl); for(ImportDecl i : getImportDecls()) \nif(i.importsFieldsOnDemand(decl.name()) == decl) return new VarAccessInfo(decl); return accessVariable(decl); \n} Figure 24. Access computation for static import .elds duce named type variables. Specifying renaming \nfor most of these features is fortunately quite simple in our framework. Consider the task of supporting \nrenaming for static im\u00adports. Import clauses may import static member .elds and static member methods \nwhich are then made visible using their simple names in the current compilation unit. Like nor\u00admal imports, \nstatic import clauses are either named, i.e. they only import a single .eld or method, or on-demand, \nwhich means that they import all static .elds and methods of a given class. The Java 5 extension adds \nattributes and equations related to variable lookup as shown in Figure 23. We .rst search named static \nimports, and then proceed to on-demand static imports if no match is found. Finally we delegate to the \nenclosing context if neither kind of import match. The code is slightly abbreviated in that a check that \nthe imported .eld is accessible from the current compilation unit is left out. These rules follow the \nwell-known try local lookup, then delegate pattern, and hence are easily inverted (see Fig\u00adure 24). Providing \ninverted rules is equally straight forward for most extensions. New type lookup rules are for instance \naspect X{ static int x; int B.m() { return x+y; } } class B{ int y; } Figure 25. A simple program using \ninter-type declarations eq IntertypeMethodDecl.getBody(). lookupVariable(String name) { Variable v = \nparameterDeclaration(name); if(v != null) return v; v = introducedType().memberFields(name); if(v != \nnull) return v; return lookupVariable(name); } Figure 26. Variable lookup on inter-type methods needed \nto account for type variables, but again they are eas\u00adily inverted, with corresponding changes to the \nmoveInto method to make sure that shadowing by type variables does not go unnoticed.  5.2 Inter-Type \nDeclarations Inter-type declarations are a powerful concept to separate concerns that cross-cut the static \nclass hierarchy. They are part of the AspectJ language, enabling addition of new mem\u00adbers to an already \ndeclared class [Tea]. Take for example the program in Figure 25. It contains both an aspect X and a class \nB with the aspect declaring an inter-type method m on B; to differentiate, we refer to X as m s host \naspect, while B is its introduced type. The method m behaves like a regular member method of B but the \nlookup rules for inter-type methods are slightly augmented. This allows them to access members of both \nthe introduced type and the host aspect using simple names. The method m can thus access both members \nof B, like y in the example, and static members of X, like x. The implementation of inter-type declarations \nintroduces new node types to represent aspects, inter-type methods, and inter-type .elds. The introduced \nmembers are similar to their non inter-type counterparts but have an additional attribute introducedType() \nthat refers to the declaration they are introduced into. This allows variable lookup for inter-type methods \nto be easily implemented as shown in Figure 26: Parameters are looked up .rst, followed by members of \nthe introduced type; then we delegate to the parent node, which is the host aspect. eq IntertypeMethodDecl.getBody(). \naccessVariable(Variable decl) { VarAccessInfo acc = accessParameterDeclaration(decl); if(acc != null) \nreturn acc; acc = introducedType(). accessMemberField(decl); if(acc != null) return acc.moveInto((MethodDecl)this); \nacc = accessVariable(decl); if(acc != null) return acc.moveInto(this); return null; } Figure 27. Access \ncomputation on inter-type methods Again, this lookup rule follows our basic pattern, so we can invert \nit to obtain the code in Figure 27. Observe that for the .rst moveInto we reuse already existing code \nthat checks whether a type access would be shadowed by param\u00adeters; the second moveInto also needs to \ntake member .elds of the introduced type into account, which is done by a new method moveInto(IntertypeMethodDecl). \nSince the inter-type declarations extension is mostly con\u00adcerned with names and follows the name lookup \nstrategy from Section 3, no further extensions beyond implementing the new access rules are necessary. \n6. Evaluation 6.1 Correctness Along with our implementation we have developed a suite of several hundred \ntest cases, about .fty of which come from Eclipse s refactoring test suite. These tests systematically \nexplore both common and exotic cases for all the refactor\u00adings we have implemented and have been very \nhelpful not only for validating our own implementation, but also for .nding bugs in other IDEs. A commented \nlist of examples that we found to be refactored incorrectly by the most recent version of Eclipse s refactoring \nengine can be found online [EESV08]. Of the around three hundred test cases, 10% require ad\u00additional \nquali.cation to avoid shadowing and hence cannot be refactored by Eclipse. Some of these cases can be \nhan\u00addled by IntelliJ, which can automatically add this qual\u00adi.ers, but others, which would require more \nsophisticated quali.cation, cannot. The part of the test suite that deals with inter-type declarations \ncan not directly be compared against other tools: Although AspectJ plugins are available for some of \nthe major IDEs (notably AJDT for Eclipse [AJD]), none of them offers any refactoring support. In order \nto convince ourselves that our refactorings work as expected on simple inputs, we have used the ASTGen \nsyn\u00adtax tree generator library [DDGM07], which has been used Table 2. Results of the automatically generated \ntests; Ecl = Eclipse, JA = our implementation; TGI = Total Generated Inputs; CI = Compilable Inputs; \nSucc = successfully refactored inputs, Diff = different outputs Refactoring Generator TGI CI Succ: Ecl \nSucc: JA Diff Rename Class AllRelationships 108 88 88 88 0 Rename Method SingleClassMethodReference 9450 \n9450 9450 9450 0 Rename Field SingleClassFieldReference 5280 2824 2824 2824 0 DualClassFieldReference \n23760 7947 7947 7947 0 before to detect bugs in refactoring software. This library provides a number \nof generators that can be used to gener\u00adate a large number of input programs and it provides sup\u00adport \nfor automatically performing refactorings on them us\u00ading the Eclipse refactoring engine. We have written \na simple driver program that in addition performs the same refactor\u00adings using our own implementation, \nand compares the output to Eclipse s. Table 2 summarises the results of this experiment: The .rst column \ngives the name of the refactoring tested, the sec\u00adond column lists the test generator used (for details \nabout the individual generators please refer to [DDGM07]); the following columns give information about \nthe total number of generated test cases, the number of compilable test cases (refactoring uncompilable \nprograms is possible, but the re\u00adsults would be hard to assess), and the number of inputs suc\u00adcessfully \nrefactored by Eclipse resp. our implementation. The generated test programs are generally of a very sim\u00adple \nstructure (and the original paper did, indeed, not .nd any bugs in Eclipse s renaming support), so it \nis not surprising that both Eclipse and our own implementation are able to refactor all compilable inputs. \nOur implementation gives the exact same results on all programs (as seen in the last col\u00adumn), in particular \nit never produces uncompilable output programs.  6.2 Code Size Next, we want to assess the code complexity \nof our imple\u00admentation, both in absolute terms and in comparison to the JastAddJ compiler frontend. Table \n3 shows the code size of the JastAddJ frontend3. Its basic module, which implements the full Java 1.4 \nlanguage, comprises about ten thousand lines of code. Both the exten\u00adsion module for Java 5 and the extension \nto handle inter-type declarations are signi.cantly smaller. Either of them can sep\u00adarately be used together \nwith the Java 1.4 frontend, or all three can be combined to yield a compiler for Java 5 with inter-type \ndeclarations (for this, an extra 76 lines of code are needed). Our refactoring engine is partitioned \nin the same way as the frontend and also consists of three modules that can be 3 These and all the following \nsource code line counts were obtained using David A. Wheeler s SLOCCount utility [Whe06]. Module Total \nJava 1.4 Frontend 9990 Java 1.5 Frontend 6234 Inter-type Declarations 1824 ITD + Java 1.5 Integration \n76 Table 3. Code size of the JastAddJ frontend Module Total Access Framework Java 1.4 Refactoring 1902 \n1014 888 Java 1.5 Refactoring 538 284 254 Inter-type Declarations 211 211 0 Table 4. Code size of the \nrefactoring engine combined with the corresponding modules from the fron\u00adtend. Their code sizes are summarised \nin Table 4. For every module, we indicate its total code size, how much code is devoted to access computation, \nand how much of framework code we need. For the Java 1.4 component, we notice that the size of the access \ncomputation code tal\u00adlies well with the lookup code from the frontend, which is implemented in about \n1100 lines. Framework code for this module includes driver programs, the computation of endan\u00adgered accesses, \nand undo functionality. For the Java 1.5 refactoring module, we see that only very little code needs \nto be added to the access computation. It also includes a modest amount of framework code that handles \nJastAddJ s internal representation of generic types and their instantiations and harmonises it with the \nrest of the refactoring code. Perhaps surprisingly, the module implementing refactor\u00ading for inter-type \ndeclarations is even smaller than the Java 1.5 one. This is because inter-type declarations mainly af\u00adfect \nlookup and so are handled very neatly by our approach without requiring any additional framework code. \nOverall, these numbers show that by integrating the refac\u00adtoring code tightly with the compiler and exploiting \nJast\u00adAdd s modularity and extensibility we are able to obtain a very concise implementation. The implementation \nof renam\u00ading refactorings in Eclipse, for instance, is at least three times as big.  6.3 Performance \nAnother important question to evaluate, of course, is if our implementation is practical on large input \nprograms. To ad\u00address this, we performed a number of renamings on the source code of the Jigsaw webserver \n[w3c06], which con\u00adsists of about 100K lines of Java 1.4 code The results of our experiments (as measured \non an AMD Athlon 64 X2 machine running Linux 2.6.22) are put to\u00adgether in Table 5. We will brie.y explain \nthe data relating to type renaming. Interesting types to rename for evaluation purposes are on the one \nhand those which are referenced a lot, and on the other hand those which are rarely referenced. Hence \nwe chose three of the most heavily used types (the classes Attribute and Request as well as the interface \nHTTP) and some rarely used classes to rename; the number of types referencing each of them is given in \nthe third col\u00ad 4 umn. For every refactoring to be performed, there is quite a signi.cant startup time \nduring which the program is loaded into memory and checked for errors (around 18 seconds for Jigsaw). \nIn an IDE this step would normally already have been performed before the user initiates a refactoring, \nso we have not included it in our evaluation. Once the program is loaded, the refactoring needs to de\u00adtermine \nthe set of potentially endangered accesses, and then proceeds to rename the type and perform any other \nadjust\u00adments. The third column of the table gives the total number of endangered accesses, the fourth \nthe time needed to .nd these accesses, and the last the total time for performing the refactoring. The \ntime for adjusting accesses was well below 0.1s in every case. The bulk of the time was spent .ushing \ninternal attribute caches which the renaming invalidates, in turn triggering the garbage collector. Nevertheless, \nwe can observe that the overall time it takes to rename a type is around two seconds (regardless of their \nfrequency of use), which is comparable to Eclipse s per\u00adformance on the same tasks. Determining endangered \nac\u00adcesses is quite fast, and although our approach is very coarse grained we still end up with manageable \nnumbers of ac\u00adcesses to adjust. An earlier version of our implementation had a more so\u00adphisticated algorithm \nthat tried to avoid too many false pos\u00aditives, and indeed managed to give about 20% less endan\u00adgered \naccesses than the current one. However, the extra ef\u00adfort needed more than outweighed the gain in precision, \nand lead to much slower refactorings. The situation for .eld and local variable renaming is not much \ndifferent. For the latter, we have chosen a variable with perhaps the most common name of all. Here, \nthe discrep\u00adancy between actual references and endangered accesses as determined by our algorithm is \nvery marked, but still not big enough to cause a substantial decrease in performance. 4 These numbers \nwere obtained using SemmleCode [Sem08]. In conclusion, the numbers show that our implementation compares \nvery favourably to an industrial strength refactor\u00ading engine like Eclipse s. It can perform more sophisticated \nrenamings, and handles corner cases on which Eclipse fails. 7. Related Work 7.1 Correctness of Refactorings \nCorrectness of refactorings has long been a primary con\u00adcern in the literature. Opdyke [Opd92] and Roberts \n[Rob99] champion a precondition based approach. They specify global conditions which a program has to \nmeet for the refac\u00adtoring to be correct. The scope nesting rules of the languages treated in these theses \n(a subset of C++ and Smalltalk, respectively) are fairly simple. In particular, there are no nested classes, \nso the preconditions for renamings are very lightweight and not much attention is paid to them. Later \nwork [Cor04, Ett07] has focused on giving a se\u00admantics of the underlying language in order to rigorously \nprove that the given preconditions are suf.cient to preserve program semantics. To keep the formal development \nman\u00adageable, however, the language has to be quite simple. One possible way to overcome this limitation \nmay be to formalise both the underlying language and the refactorings to be performed in an interactive \ntheorem prover, which will keep track of all the details to be proved. This approach, taken, for example, \nby Sultana and Thompson [ST08], suf\u00adfers from a lack of automation; even seemingly trivial state\u00adments \nhave to be proven in excruciating detail, again restrict\u00ading the scope of the work. Much work has also \ngone into the precise de.nition of type-based refactorings, i.e. refactorings that change the type structure \nof a program [Tip03, BTF05, vDD04, DKTE04]. Such refactorings, however, have to deal with quite differ\u00adent \nissues, mostly type constraints which are orthogonal to renaming.  7.2 Speci.cation of Refactoring The \nhigh-level declarative speci.cation of refactorings has seen quite some interest in the research community. \nMens et al. [MDJ02] specify refactorings as transformations on a largely language-independent graph representation \nof pro\u00adgrams that concentrates on those aspects of the source code to be preserved by the refactoring. \nTheir de.nition of preser\u00advation properties is very close to the access preservation invariant we use \nhere. However, their graph representation does not seem suitable for specifying renamings, since name \nlookup is not explicitly represented in the program graph. Another approach is introduced in [GM06]. \nBased on a formalisation of Java in rewriting logic, they give executable speci.cations of several refactorings \nin Maude. While their implementations are quite concise, it seems that this ap\u00adproach mainly excels at \nlocal refactorings (such as the Re\u00adname Temporary example they give) and would perhaps Renamed Entity \nName References Number of EA Time to .nd EA Total Time Toplevel Type Attribute Request HTTP FileEditor \nMain 177 132 106 1 0 1464 887 1100 0 2 0.4s 0.3s 0.3s 0.3s 0.2s 2.2s 2.0s 2.2s 1.4s 1.9s Nested Type \nAlert Openner 1 1 0 2 0.1s 0.2s 1.8s 1.9s Field EDITABLE OK INTERNAL_SERVER_ERROR DEFAULT_SSL_ENABLED \nimg 86 74 46 1 0 538 185 142 0 17 0.3s 0.3s 0.2s 0.1s 0.1s 3.3s 3.3s 2.6s 3.1s 3.2s Local Variable i \n4 3055 0.2s 1.5s Table 5. Refactoring Jigsaw: Some Performance Measurements (averaged over 20 runs); \nEA = endangered accesses be more cumbersome to use for refactorings that affect the whole program. A \nquite different and more .exible approach is taken by the JunGL language [VEdM06], which is a domain \nspeci.c language especially suited for implementing refactorings. The refactorings can manipulate an \nextensible graph repre\u00adsentation of the program with user-de.nable edges to capture program properties \nof interest. An important feature is path queries, which can be used to express, for example, name lookup \nin an elegant short form. So far, however, JunGL has only been used to implement refactorings on subsets \nof lan\u00adguages while we support full Java 5.  7.3 Aspect-Oriented Refactoring Our implementation supports \nrefactoring in the presence of inter-type declarations, one of the major features of aspect oriented \nprogramming. The interplay between aspect ori\u00adented programming and refactoring has been explored by \nothers. For example, Cole and Borba [CB05] give some precon\u00additions for refactoring AspectJ code, while \nHanenberg et al. [HOU03] show how to make well-known refactorings such as Rename Method aspect-aware. \nBoth papers, how\u00adever, concentrate almost exclusively on how to handle point\u00adcuts and advice and do not \nconsider inter-type declarations. It would be interesting to see how our approach can be ex\u00adtended to \ntake these more dynamic features into account. 8. Conclusions In this paper we have investigated two \nproblems related to preconditions for renaming refactorings. Too weak precon\u00additions results in unsound \nrenamings where symbolic names refer to different declared entities before and after the refac\u00adtoring, \nand too strong preconditions prevent certain renam\u00adings from being carried out. We have presented an \napproach to specifying renaming refactorings that is closely coupled to the way name lookup is implemented \nin a compiler. Inverted lookup rules are used to create accesses that are guaranteed to bind a symbolic \nname to a speci.c declared entity. By applying this operation to each name possibly affected by the refactoring, \nwe guar\u00adantee that the binding structure is preserved and avoid too weak preconditions. The accesses \ncreated during inverted lookup can be tailored to introduce quali.cations which en\u00adables renamings that \nwould otherwise be prohibited by too strong preconditions. Another challenge is to update refactorings \nas the lan\u00adguage evolves. In our experiments we have not found a sin\u00adgle refactoring engine for Java \nthat handles static imports properly. The direct correspondence between lookup rules and access rules \nhelp us avoid many pitfalls that went unno\u00adticed in other refactoring engines. The presented approach \neffectively improves on state-of-the-art, both in correctness and .exibility in allowed renamings. We \nhave implemented renaming, including pluggable ex\u00adtensions for Java 5 and AspectJ like inter-type declarations, \nas modular extensions to the JastAdd Extensible Java Com\u00adpiler. The tool is available as a plugin for \nEclipse, with an implementation size of less than 3000 lines of code, and it achieves similar performance \nto mature refactoring engines. We have created a renaming test suite that our implemen\u00adtation passes \nbut which exposes numerous bugs and limita\u00adtions in industrial strength refactoring tools. We believe \nthat this renaming approach is general and can bene.t both other refactorings and other languages be\u00adside \nJava. High-level refactorings can use it as a building block to preserve bindings when rearranging code, \na com\u00admon source of bugs in current tools. We have previously shown that name lookup for the Modelica \nlanguage can be implemented in the same way as shown here [\u00c5EH08], and it would be interesting to apply \nthe renaming approach to that implementation as well. In order to give a formal justi.cation of the soundness \nof our approach, it is of central importance to prove the inver\u00adsion property of access computation and \nname lookup. We have developed a general framework for formalising refer\u00adence attribute grammars in the \ntheorem prover Coq, and are now working on a mechanised proof of the inversion prop\u00aderty. The goal of \nthat work is to provide a theoretical foun\u00addation for the practical implementation techniques presented \nin this paper. It has been argued that a refactoring engine cannot be both thorough and fast. For example, \nthe authors of the Refactoring Browser [BR99] write in [Fow00]: Computer scientists tend to focus on \nall of the boundary cases that a particular approach will not handle. The fact is that most programs \nare not boundary cases (. . . ) We believe that our approach shows that at least for a statically typed \nlanguage it is possible to achieve reasonable speed and also handle boundary cases. Acknowledgments We \nwould like to thank Mathieu Verbaere for sharing his experience on refactorings and their implementation \nwith us, and for his many helpful and encouraging comments on every stage of this work. Special thanks \nalso go to Damien Sereni for help with proof reading. References [\u00c5EH08] Johan \u00c5kesson, Torbj\u00f6rn Ekman, \nand G\u00f6rel Hedin. Development of a Modelica Compiler Using Jast-Add. Electronic Notes in Theoretical Computer \nScience, 203(2):117 131, 2008. [AET08] Pavel Avgustinov, Torbj\u00f6rn Ekman, and Julian Tibble. Modularity \nFirst: A Case for Mixing AOP and Attribute Grammars. In Aspect-Oriented Software Development (AOSD). \nACM Press, 2008. [AJD] AspectJ Development Tools 1.5.1. http://www. eclipse.org/ajdt. [BR99] John Brant \nand Don Roberts. The Smalltalk Refac\u00adtoring Browser. http://st-www.cs.uiuc. edu/users/brant/Refactory/, \n1999. [BTF05] Ittai Balaban, Frank Tip, and Robert Fuhrer. Refac\u00adtoring support for class library migration. \nIn Pro\u00adceedings of the 20th ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, \npages 265 279, 2005. [CB05] Leonardo Cole and Paulo Borba. Deriving Refac\u00adtorings for AspectJ. In Aspect-Oriented \nSoftware Development (AOSD). ACM Press, 2005. [Cor04] M\u00e1rcio Lopes Corn\u00e9lio. Refactorings as Formal Re.nements. \nPh.D. thesis, Universidade Federal de Pernambuco, 2004. [DDGM07] Brett Daniel, Danny Dig, Kely Garcia, \nand Darko Marinov. Automated Testing of Refactoring Engines. In Proceedings of ESEC/FSE 07. ACM Press, \n2007. [DKTE04] Alan Donovan, Adam Kiezun, Matthew S. Tschantz, and Michael D. Ernst. Converting Java \nPrograms to use Generic Libraries. In Object-Oriented Programming, Systems and Languages, pages 15 34, \n2004. [Ecl07] Eclipse 3.3.1. 2007. http://www.eclipse.org, [EESV08] Torbj\u00f6rn Ekman, Ran Ettinger, Max \nSch\u00e4fer, and Mathieu Verbaere. Refactoring bugs in Eclipse, IDEA and Visual Studio, 2008. http://progtools.comlab.ox.ac.uk/ \nrefactoring/bugreports. [EH06] Torbj\u00f6rn Ekman and G\u00f6rel Hedin. Modular name analysis for Java using JastAdd. \nIn Generative and Transformational Techniques in Software Engineer\u00ading, International Summer School, \nGTTSE 2005, volume 4143 of LNCS. Springer, 2006. [EH07] Torbj\u00f6rn Ekman and G\u00f6rel Hedin. The JastAdd Ex\u00adtensible \nJava Compiler. In Richard P. Gabriel, editor, ACM Conference on Object-Oriented Programming, Systems \nand Languages (OOPSLA). ACM Press, 2007. [Ett07] Ran Ettinger. Refactoring via Program Slicing and Sliding. \nD.Phil. thesis, Computing Laboratory, Oxford, UK, 2007. [Fow00] Martin Fowler. Refactoring: improving \nthe design of existing code. Addison Wesley, 2000. [GJSB05] James Gosling, Bill Joy, Guy Steele, and \nGilad Bracha. The Java Language Speci.cation. Prentice Hall, 3rd edition, 2005. [GM06] Alejandra Garrido \nand Jos\u00e9 Meseguer. Formal Spec\u00adi.cation and Veri.cation of Java Refactorings. In Proceedings of the Sixth \nIEEE International Work\u00adshop on Source Code Analysis and Manipulation (SCAM), 2006. [HOU03] Stefan Hanenberg, \nChristian Oberschulte, and Rainer Unland. Refactoring of Aspect-Oriented Software. In Net.ObjectDays, \n2003. [JBU07] JBuilder 2007. http://www.codegear.com/ products/jbuilder, 2007. [Jet07] IntelliJ IDEA \n7.0.1. http://www.jetbrains. com, 2007. [MDJ02] Tom Mens, Serge DeMeyer, and Dirk Janssens. For\u00admalising \nbehaviour preserving program transforma\u00adtions. In Graph Transformation, volume 2505 of Lecture Notes \nin Computer Science, pages 286 301, 2002. [Net07] Netbeans 6.0. 2007. http://www.netbeans.com, [OJ90] \nWilliam F. Opdyke and Ralph E. Johnson. Refactor\u00ading: An aid in designing application frameworks and \nevolving object-oriented systems. In Proceedings of Symposium on Object-Oriented Programming Emphasizing \nPractical Applications (SOOPPA), September 1990. [Opd92] William F. Opdyke. Refactoring Object-Oriented \nFrameworks. PhD thesis, University of Illinois at Urbana-Champaign, 1992. [Rob99] Donald F. Roberts. \nPractical Analysis for Refactor\u00ading. PhD thesis, University of Illinois at Urbana-Champaign, 1999. [Sem08] \nSemmle. SemmleCode. http://semmle.com, 2008. [ST08] Nik Sultana and Simon Thompson. Mechanical Veri.cation \nof Refactorings. In Workshop on Partial Evaluation and Program Manipulation. ACM SIGPLAN, January 2008. \n[Tea] The AspectJ Team. Guide. The AspectJ Programming [Tip03] Frank Tip. Refactoring for generalization \nusing type constraints. In Proceedings of the 18th ACM Conference on Object-Oriented Programming, Systems, \nLanguages, and Applications, pages 13 26, 2003. [vDD04] [VEdM06] [w3c06] [Whe06] Daniel von Dincklage \nand Amer Diwan. Converting Java classes to use generics. In Proceedings of the 19th ACM Conference on \nObject-Oriented Program\u00adming, Systems, Languages, and Applications, pages 1 14, 2004. Mathieu Verbaere, \nRan Ettinger, and Oege de Moor. JunGL: a Scripting Language for Refactoring. In International Conference \non Software Engineering (ICSE 06), 2006. w3c. Jigsaw. http://www.w3.org/Jigsaw/, 2006. David Wheeler. \nSLOCCount. http://www. dwheeler.com/sloccount/, 2006.   \n\t\t\t", "proc_id": "1449764", "abstract": "<p>Descriptive names are crucial to understand code. However, good names are notoriously hard to choose and manually changing a globally visible name can be a maintenance nightmare. Hence, tool support for automated renaming is an essential aid for developers and widely supported by popular development environments.</p> <p>This work improves on two limitations in current refactoring tools: too weak preconditions that lead to unsoundness where names do not bind to the correct declarations after renaming, and too strong preconditions that prevent renaming of certain programs. We identify two main reasons for unsoundness: complex name lookup rules make it hard to define sufficient preconditions, and new language features require additional preconditions. We alleviate both problems by presenting a novel extensible technique for creating symbolic names that are guaranteed to bind to a desired entity in a particular context by inverting lookup functions. The inverted lookup functions can then be tailored to create qualified names where otherwise a conflict would occur, allowing the refactoring to proceed and improve on the problem with too strong preconditions.</p> <p>We have implemented renaming for Java as an extension to the JastAdd Extensible Java Compiler and integrated it in Eclipse. We show examples for which other refactoring engines have too weak preconditions, as well as examples where our approach succeeds in renaming entities by inserting qualifications. To validate the extensibility of the approach we have implemented renaming support for Java 5 and AspectJ like inter-type declarations as modular extensions to the initial Java 1.4 refactoring engine. The renaming engine is only a few thousand lines of code including extensions and performance is on par with industrial strength refactoring tools.</p>", "authors": [{"name": "Max Sch&#228;fer", "author_profile_id": "81381592942", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223197", "email_address": "", "orcid_id": ""}, {"name": "Torbj&#246;rn Ekman", "author_profile_id": "81339498098", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223198", "email_address": "", "orcid_id": ""}, {"name": "Oege de Moor", "author_profile_id": "81100198102", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P1223199", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449787", "year": "2008", "article_id": "1449787", "conference": "OOPSLA", "title": "Sound and extensible renaming for java", "url": "http://dl.acm.org/citation.cfm?id=1449787"}