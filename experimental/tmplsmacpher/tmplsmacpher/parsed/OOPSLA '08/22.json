{"article_publication_date": "10-19-2008", "fulltext": "\n Analysis and Reduction of Memory Inef.ciencies in Java Strings Kiyokuni Kawachiya Kazunori Ogata Tamiya \nOnodera IBM Research, Tokyo Research Laboratory 1623-14, Shimotsuruma, Yamato, Kanagawa 242-8502, Japan \n<kawatiya@jp.ibm.com> Abstract This paper describes a novel approach to reduce the mem\u00adory consumption \nof Java programs, by focusing on their string memory inef.ciencies. In recent Java applications, string \ndata occupies a large amount of the heap area. For example, about 40% of the live heap area is used for \nstring data when a production J2EE application server is running. By investigating the string data in \nthe live heap, we iden\u00adti.ed two types of memory inef.ciencies duplication and unused literals. In the \nheap, there are many string objects that have the same values. There also exist many string lit\u00aderals \nwhose values are not actually used by the applica\u00adtion. Since these inef.ciencies exist as live objects, \nthey can\u00adnot be eliminated by existing garbage collection techniques, which only remove dead objects. \nQuantitative analysis of Java heaps in real applications revealed that more than 50% of the string data \nin the live heap is wasted by these inef.\u00adciencies. To reduce the string memory inef.ciencies, this paper \nproposes two techniques at the Java virtual machine level, StringGC for eliminating duplicated strings \nat the time of garbage collection, and Lazy Body Creation for delaying part of the literal instantiation \nuntil the literal s value is actually used. We also present an interesting technique at the Java program \nlevel, which we call BundleConverter,for preventing unused message literals from being instantiated. \nPrototype implementations on a production Java virtual machine have achieved about 18% reduction of the \nlive heap in the production application server. The proposed tech\u00adniques could also reduce the live heap \nof standard Java benchmarks by 11.6% on average, without noticeable per\u00adformance degradation. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 08, October \n19 23, 2008, Nashville, Tennessee, USA. Copyright c &#38;#169; 2008 ACM 978-1-60558-215-3/08/10. . . \n$5.00 Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features \nframeworks General Terms Languages, Design, Performance, Experi\u00admentation Keywords Java, string, memory \nmanagement, garbage col\u00adlection, footprint analysis and reduction 1. Introduction Virtually all programming \nlanguages provide support for strings together with a rich set of string operations. In Java [10], the \nstandard class library includes three classes, String for immutable strings, and StringBuffer and StringBuilder \nfor mutable strings. Although the devel\u00adoper of a Java virtual machine (JVM) attempts to imple\u00adment these \nclasses as ef.ciently as possible, there is little description in the literature on how ef.cient or inef.cient \nthey actually are in terms of time and space. In this paper, we study space inef.ciencies in a typical \nimplementation of Java strings. Actually, the most frequently created objects during Java program execution \nare String objects, which represent strings, and char array objects to hold the string values1. In this \npaper, we call these objects string-related objects. For example, Figure 1 shows a live heap area when \nIBM WebSphere Application Server (WAS) [14] Version 6.1 with Trade6 benchmark application [13] is executed \non IBM J9 Java VM [5, 12] 5.0 for Linux. String-related objects occupy about 40% of the live heap. From \nexhaustive analysis of string data in the live heap, we found two types of memory inef.ciencies. First, \nthere are many string objects that have the same values. For instance, we observed 1,067 live instances \nof the string \"name\" in a snapshot of the Java heap during the execution of an enter\u00adprise application. \nSecond, there are many string literals (con\u00adstants) whose values are not actually used by the application. \nIn particular, many strings for error messages are instantiated in the heap when message classes are \ninitialized, but most of them are never used in normal execution. 1 In this paper, char arrays directly \nused by applications are not treated as the string-related objects.  05 10 15 20 25 30MB ~40% are string-related \nobjects Figure 1. Live heap analysis of WAS 6.1 running Trade6. String-related objects occupy a large \npart of the live heap. These string memory inef.ciencies waste a considerable amount of the live heap \nin Java. Further quantitative analy\u00adsis by running large enterprise applications in a production JVM \nshowed that such wasted data occupies more than 50% of the live string data. Since these inef.ciencies \nexist as live objects, they cannot be removed by existing garbage collec\u00adtion (GC) techniques. To remove \nthe string memory inef.\u00adciencies, this paper proposes three new optimization tech\u00adniques for each of \nthe three major components, JVM, GC, and application classes. The .rst technique, StringGC, is a new \nmemory optimiza\u00adtion at GC time to eliminate space wasted by duplicated Java strings. It is implemented \nwith a standard generational col\u00adlector, and uni.es duplicated String objects when they are long-lived \nand moved to the tenured space. Experimental re\u00adsults showed that it is able to eliminate more than 90% \nof the space wasted by duplicated strings. The second technique, BundleConverter, is a program converter \nto suppress the instantiation of message literals. It converts the internal structure of Java classes \nthat extend java.util.ListResourceBundle. After the conversion, String objects are created only when \nmessages are actu\u00adally requested, rather than when the class is initialized. Con\u00adverted classes can be \nused without modifying other part of applications. Since most error messages are not used during normal \nexecution, this conversion can suppress 99% of mes\u00adsage instantiations. The third technique, Lazy Body \nCreation, is also targeting the reduction of unused literals, and is implemented in the JVM and its String \nclass. When the JVM instantiates a string literal, it creates only part of the data structure. The remaining \npart, which contains the value of the string, will be created when the literal is actually used. This \ntechnique can be used for all literals, even for classes that cannot be converted to suppress the instantiation \nof string literals. With this technique, the space wasted by unused literals was reduced by more than \n60%. Combination of these three techniques on a production JVM has removed about 90% of the string memory \nin\u00adef.ciencies and achieved about an 18% reduction of the live heap in real enterprise applications. \nThe proposed tech\u00adniques are also effective for client-type applications. Using SPECjvm98 [24] and DaCapo \n[6] benchmark programs, we con.rmed that live heap was reduced by 11.6% on average without noticeable \nperformance degradation. Our contributions in this paper are as follows: A quantitative analysis of \nstring memory inef.ciencies in Java. We identi.ed several types of memory inef.cien\u00adcies in Java strings \nand measured the wasted space by running large-scale enterprise applications in a produc\u00adtion JVM. We \nobserved that the space wasted by Java strings can be about 20% of the live heap area.  Three proposed \ntechniques to reduce the inef.ciencies.  To remove the string memory inef.ciencies, we intro\u00adduced three \nnew techniques, one for each of the three major components, JVM, GC, and application classes. StringGC \neliminates duplicated strings at the time of garbage collection. BundleConverter converts applica\u00adtion \nclasses to avoid instantiating unused message liter\u00adals. Lazy Body Creation delays part of the literal \ninstan\u00adtiation in the JVM. Empirical results of reducing the inef.ciencies using a prototype on a production \nJVM. We implemented these three techniques for a production Java virtual machine, and examined large \nenterprise applications. Results show that it eliminated about 90% of the string memory inef\u00ad.ciencies, \nand reduced the size of the live heap by about 18%. Using standard Java benchmarks, we also veri.ed that \nour techniques are applicable to most Java applica\u00adtions. The rest of the paper is organized as follows. \nSection 2 describes how strings are handled in Java, and investigates wasted space due to Java strings \nin real applications. Sec\u00adtion 3 proposes three techniques to remove the string mem\u00adory inef.ciencies. \nSection 4 shows experimental results of these three techniques using a prototype on a production JVM. \nSection 5 discusses related work, while Section 6 of\u00adfers conclusions.  2. String Memory Inef.ciencies \nin Java This section describes the speci.cation and typical imple\u00admentation of strings in Java, and examines \nthe resulting memory inef.ciencies. 2.1 String Handling in Java In Java, string data is mainly handled \nthrough a class String, which is one of the core classes provided with the JVM. One important characteristic \nof String objects is that they are immutable. User programs cannot modify their val\u00adues by any method. \nTo manipulate string data, Java provides another class, StringBuffer2. These classes can explicitly be \nused by user programs, but objects of these classes may also be created and converted to each other implicitly \nby Java compilers such as javac. Although the Java Language Speci.cation [10] does not specify the details, \nthe String class is typically imple\u00admented as in Figure 2. Actually, this is a simpli.ed version 2 There \nis one more string-related class, StringBuilder, which is a thread-unsafe (but faster) version of StringBuffer. \n 1 public final class String ... { // only has private fields 2 private char[] value; // char array to \nhold the value 3 private int offset; // start offset in the char array 4 private int count; // length \nof the string value 5 private int hashCode; // hash code of this object, or 0 :: 6} Head Body String \nobject char[ ] object Figure 2. Structure of a Java string in typical implementa\u00adtions. Two objects, \na String (head) and a char[ ] (body), are used to represent each Java string. of the implementation in \nthe Apache Harmony open source Java SE project [1], but we know that many JVMs implement the class in \na very similar way. As seen in the .gure, a string is represented with two objects, a String and a char \narray (char[ ]), which we call the head and body of the string, respectively. The head points to the \nbody through the value .eld. The actual value of the string is stored as a subarray of the body, where \nthe offset .eld of the head gives the index of the .rst character, and the count .eld the length of the \nstring. The hashCode .eld is used to store the hash code of the String object. All of these .elds are \ndeclared as pri\u00advate, and cannot be directly accessed by a user program. As an example, the String object3 \nin Figure 2 represents a string \"string\". The String class de.nes its own hashCode() method to get the \nobject s hash code, which is calculated from the value of the string using a formula de.ned in the class \nspeci.cation [25]. Since the hash code is uniquely determined for each String object, it is stored into \nthe hashCode .eld for future use, once it is calculated. 0 in this .eld means that a hash code has not \nbeen calculated yet. String literals are constant values declared in Java pro\u00adgrams using double-quotes, \nsuch as \"literal\". Their val\u00adues are stored as UTF-8 [26] data in the constant pool of each class .le \n[19]. The JVM instantiates each literal into the Java heap as a String object and a char array when it \nis .rst used by the program with the ldc (load constant) bytecode. Since each char data represents a \n16-bit Unicode (UTF-16) [26] character, the UTF-8 data in the constant pool is converted to the corresponding \nUnicode data and put into the created char array in the heap. A String can be interned by explicitly \ninvoking its in\u00adtern() method, which returns a uni.ed String object with the same value. The Java Language \nSpeci.cation [10] spec\u00adi.es that all string literals are automatically interned when it is instantiated. \nTherefore, there is no duplication of string literals in the Java heap. 3 The header in each object in \nFigure 2 is an area used by JVM to store object-management information such as class pointer and lock \nstatus. 1 class WasteSample { 2 public static void main(String[] args) { 3 String sysjar = \"system.jar\", \nusrjar = \"user.jar\"; 4 String tmpstr = sysjar + \":\" + usrjar + \":\" + \".\"; 5 int colon1 = tmpstr.indexOf(\":\"), \n6 int colon2 = tmpstr.indexOf(\":\", colon1+1); 7 String jar2 = tmpstr.substring(colon1+1, colon2); 8 tmpstr \n= null; 9 10 System.out.println(jar2); // \"user.jar\" is printed 11}} String jar2 (=\"user.jar\") [0] \n[1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] [16] [17] [18] [19] [20] [21] [22] \n[23] [24] [25] [26] [27] [28] [29] [30] [31] [32] [33]   unused area unused area Figure 3. Sample \nprogram for string manipulation, and a resulting String structure, whose char array contains large unused \nareas. There also exist multiple String objects which have the same value \"user.jar\".  2.2 String Memory \nInef.ciencies The string structure shown in Figure 2 is effective for reduc\u00ading the copying of string \nvalues because the char array can be shared by multiple String and StringBuffer objects4. The sharing \noccurs, for example, when a new String object is created by String.substring() or StringBuffer.to-String(). \nHowever, it may result in memory being wasted differently, since unused areas may remain in a char array. \nIn this case, we say that there is fragmentation in the array. The program in Figure 3 is an example \nof such waste. Al\u00adthough it depends on the JVM implementation, the resulting string jar2 will be as shown \nin the lower part of the .gure, where 26 of the total 34 elements of the char array are not used. This \nhappens because a StringBuffer was implicitly created in line 4 and a generous char array was allocated \nfor the string manipulation. This is an arbitrary example for the explanation, but similar string manipulations \nare performed frequently during Java program execution. Another kind of memory waste in Java strings \nis that there may exist multiple String objects (and char arrays) that have the same string value. In \nthe example in Figure 3, the strings jar2 and usrjar have the same value \"user.jar\". However, the String \nobjects and the char arrays for these two strings exist independently in the heap. Such duplication occurs \nvery frequently in real Java applications. The fragmentations and duplications explained above typically \noccur for strings dynamically generated during the program execution. In contrast, string literals basically \ndo not have such problems, since they are directly created from 4 Thevalueof StringBuffer can be modi.ed \nthrough its methods such as insert() and delete(). If the target char array is shared with other String \nobjects, a copy of the array is created before the modi.cation. 1 class MyMessages { 2 private static \nString[] messageList = { 3 \"message0\", // 0 4 \"message1\", // 1 5 \"message2\", // 2 6 \"message3\" // 3 7 \n}; 8 String getMessage(int key) { // returns a message 9 return messageList[key]; // specified by the \nkey 10}} 11 12 class MessageTest { 13 public static void main(String[] args) { 14 MyMessages myMsg = \nnew MyMessages(); 15 System.out.println(myMsg.getMessage(2)); 16}} Figure 4. An example where unused \nliterals are created. All of the messages are instantiated, even though only one of them is used. constant \nvalues in classes and automatically uni.ed by in\u00adterning. However, there is another type of inef.ciency \nfor string literals in Java. It is very common that string literals are instantiated too eagerly, even \nthough their values are not actually used by an application. Figure 4 is an example of such unused literals. \nWhen this program is executed, all of the literals \"message0\" to \"message3\" are instantiated at line \n14, where the class My-Messages is loaded and initialized, although only \"mes\u00adsage2\" is actually used \nby the program. Once a string literal is instantiated, it continues to exist as a live object unless \nthe class is unloaded. Therefore, the instantiation of unused literals may consume much of the Java heap. \nIn this section, we de.ned three kinds of memory in\u00adef.ciencies in Java strings fragmentation, duplication, \nand unused literals. In Java, objects that are not referred to from anywhere are removed by garbage collection \n[15] as dead objects. However, all of the memory inef.ciencies discussed here exist as live String objects \nor in live char arrays. Therefore, existing GC techniques cannot remove them. New mechanisms to remove \nthe waste are required for more ef.cient memory management in Java.  2.3 Quantitative Analysis of the \nInef.ciencies In recent Java applications, there are increasing needs to han\u00addle string data, such as \nfor processing XML and accessing databases, so the string memory waste discussed above may become signi.cant. \nTherefore, we did quantitative analysis of the waste in real Java applications. The investigation was \ndone with IBM s latest production JVM, the J9 Java VM [5, 12] 5.0 for Linux. For each of the investigations \nde.ned below, the Java heap area was dumped after a system GC and exhaustively analyzed using an off-line \ntool. The following large-scale enterprise Java applications were chosen for the analysis: Trade6: Running \nthe Trade6 benchmark application [13] on IBM WebSphere Application Server (WAS) [14] Ver-Table 1. String \nmemory inef.ciencies in real Java applica\u00adtions. Total waste reaches about 20% of the live heap. Metrics \nTrade6 count size Tuscany count size Total live objects 582,012 31,346 KB 281,210 15,193 KB String objects \n103,370 2,894 KB 57,773 1,618 KB -duplicated 36,468 1,021 KB 33,914 950 KB -literals 35,498 994 KB 9,342 \n262 KB -unused literals 24,636 690 KB 5,619 157 KB char[ ] objects 94,553 9,445 KB 48,985 4,428 KB -usedfor \nString 92,966 8,967 KB 47,991 3,649 KB -duplicated 28,166 2,005 KB 25,564 1,606 KB -unused in remaining \n6,171 154 KB 2,026 47 KB -literals 35,498 3,100 KB 9,342 533 KB -unused literals 24,636 2,152 KB 5,619 \n283 KB String-related objects 196,336 11,861 KB 105,764 5,267 KB -duplication 64,634 3,026 KB 59,478 \n2,556 KB -fragmentation 6,171 154 KB 2,026 47 KB -unused literals 49,272 2,842 KB 11,238 441 KB Total \nwaste -ratio to str-rel obj -ratio to the live heap 113,906 6,022 KB 58.0% 50.8% 19.6% 19.2% 70,716 3,043 \nKB 66.9% 57.8% 25.1% 20.0%  Figure 5. String memory breakdown in Trade6. Much memory is wasted by duplications \nand unused literals. sion 6.1. The benchmark models a .nancial services trad\u00ading platform, whose data \nis stored in an external database. This test investigates the heap after processing requests based on \na trading scenario for three minutes. Tuscany: Running the Tuscany [3] Incubating-M1, open source middleware \nfor the Service Component Archi\u00adtecture (SCA) [23], on the Apache Tomcat [2] servlet container. This \ntest investigates the heap after processing requests to a BigBank sample SCA application for three minutes. \nThe results are summarized in Table 1. In the table, the Total live objects row shows the numbers and \nsizes of the live objects at the time of the analysis. The J9 Java VM used for the investigation uses \ntype-accurate GC [5, 15], so no dead objects are mixed into the measurement results. The String objects \nrow shows the numbers and sizes of live String objects, without including the char array objects used \nfor the string bodies. The next duplicated row shows the String objects that can be removed because their \nvalue is the same as another String object5. For example, in Trade6, 36,468 of 103,370 (35.3%) String \nobjects could 5 If there are 100 String objects which have the same value, 99 is shown in the table as \nthe number of duplicated objects. Trade6 Tuscany 1,055 \"\" 1,067 \"name\" 930 \"java.lang.String\" 891 \"\\n \n\" 586 \"TRADE61 \" 773 \"descriptorType\" 586 \"TRAD61DB\" 620 \"\\n \" 370 \"Q1\" 527 \"displayName\" 361 \"1.0\" 504 \n\"attribute\" 345 \"server1\" 368 \"operation\" 327 \"name\" 363 \"java.lang.String\" 279 \"dollyNode04Cell\" 342 \n\"\\n \" 253 \"dollyNode04\" 304 \"\\n\\t\\t\\t\" 242 \"true\" 304 \"\\n \" 216 \"T1\" 267 \"none\" 215 \"en-US\" 252 \"role\" \n214 \"type\" 248 \"displayname\" 207 \"void\" 246 \"false\" Table 2. Top 15 duplicated string values and their \ncounts in real Java applications. There are more than 1,000 indepen\u00addent \"name\" strings in Tuscany. be \nremoved, or uni.ed, because of the duplications. Table 2 shows the top 15 duplicated strings6 for each \napplication. For example, there were 1,067 independent \"name\" strings in Tuscany. Returning to Table \n1, the literals row in the String sec\u00adtion shows the number and size of String objects created from string \nconstants. Among these literals, the unused lit\u00aderals row shows the ones whose values are not used by \nthe applications. We measured these numbers by modifying the JVM and its String class library to mark \neach String ob\u00adject when it is created by the ldc bytecode (literal creation) and when its value .eld \nis accessed (literal use). The result in the table shows that 16 34% of the live String objects are literals. \nSurprisingly, more than 60% of the string literals are not used even though they exist in the live heap. \nTable 3 shows some examples of such unused literals in Trade6. It is observed that many error messages \nare unnecessarily instan\u00adtiated. The char[ ] objects row in Table 1 shows the number and size of live \nchar array objects, and the next used for String row shows the number used for holding String values. \nThe result shows that almost all (98%) of the char arrays are used for holding the string values. Among \nthese char arrays used for string bodies, the duplicated row shows the ones that can be removed when \nduplicated val\u00adues are uni.ed. The unused in remaining row shows the numbers of remaining char arrays \nwhich have unused areas (fragmentations) as shown in Figure 3, and the total size of the unused elements. \nThe rows literals and unused liter\u00adals in the char[ ] section have the same meanings as those in the \nString section, except that the size columns show the size of char arrays used for holding the literal \nvalues. The remaining part of Table 1 summarizes the three kinds of string memory inef.ciencies measured \nabove. Here, 6 The \"dolly\" in Trade6 results is the name of the machine that was running the application. \nTrade6 \"SECJ0040E: Error occurred while generating new LTPA keys. The exception is {0}.\" \"SECJ0041E: \nCan t set Authentication Mechanism to LTPA when LTPAConfig is null\" \"SECJ0270E: Failed to get actual \ncredentials. \"WSWS3221E: The exception is {0}.\" Error: Bean attribute {0} is of type {1}, which is not \na simple type.\" \"WSWS3222E: Error: Attribute is of type {0}, which is not a simple type.\" \"WSWS3220E: \nError: Error: Empty or missing service name.\" Table 3. Example of unused literals in Trade6. Many error \nmessages are unnecessarily instantiated. string-related objects mean String objects and char arrays used \nfor holding their values. Finally, the Total waste row indicates the totals for objects and for heap \nmemory that were wasted7 by the string memory inef.ciencies. The last row of the table shows the ratios \nof the wasted amount to the heap. Figure 5 is a visualization of the result for Trade6. From these results, \nthe following can be observed: In the investigated Java applications, 35 40% of the live heap area is \nused for holding string values.  25 50% of the string memory is wasted by duplications.  Compared to \nthe duplication, the impact of fragmentation in char arrays is small. It is less than 2% of the string \nmemory.  16 34% of live String objects are literals, but more than 60% of them are not used by the program. \nThe unused literals occupies 8 24% of the string memory.  As a result of these inef.ciencies, more than \n50% of the string memory is wasted, which is about 20% of the live heap.  This investigation assessed \nthe importance of reducing the string memory inef.ciencies for real Java applications. In next section, \nwe will discuss several concrete methods for doing this.  3. Reduction of the String Memory Inef.ciencies \nThe investigation in the previous section revealed that the Java heap can be reduced by up to 20% by \nremoving the following string memory inef.ciencies: Duplication: There are many String objects that have \nthe same values. Fragmentation: There are unused areas in the char arrays used for holding the string \nvalues. Unused literals: Many literals are instantiated even though they are not used. 7 The char[ ] \nobjects which have unused areas are not counted in the number of wasted objects, but the unused areas \nare added to the wasted size.  (a) Before a nursery-space GC (b) After a nursery-space GC Figure 6. \nBehavior of the UNITE StringGC. String A1 is UNI.ed with the same-value string A0 when it is TEnured. \nIn this section, we propose three independent techniques to reduce the inef.ciencies. To reduce the duplication \nand fragmentation, we propose an enhancement of garbage col\u00adlectors, named StringGC. To reduce the unused \nliterals, we propose two approaches, program conversion by Bundle-Converter and Lazy Body Creation in \nthe JVM. 3.1 String Garbage Collection First of all, we propose a string garbage collection (String-GC) \ntechnique to address the duplication and fragmentation in Java strings. The key idea is to restructure \nstring-related objects at the time of garbage collection. To remove the duplicates, String objects with \nthe same value are uni.ed. To eliminate the fragmentation, char arrays are shrunk to contain only the \ncharacters used as string values. The StringGC generally aims at the elimination of du\u00adplicates and fragments, \nbut the investigation results of Ta\u00adble 1 showed that the impact of fragmentation is not as large as \nthat of duplication. Therefore, as a practical approach to StringGC, we focused on unifying the String \nobjects with the same values8. One naive way to reduce the duplication would be to unify each String \nobject at the time of its creation, by mod\u00adifying the String constructors to reuse an existing String \nobject that has the same value. However, searching for a String object with the same value takes time, \nand should not be done for temporary strings. To get better results for StringGC without degrading the \nperformance, the search and uni.cation should be applied only to long-lived String ob\u00adjects. Our solution \nfor this problem is to combine StringGC with a generational garbage collector [15], and perform the String \nsearch and uni.cation at the time of tenuring a String object, rather than when creating the object. \nWe call this pragmatic StringGC approach UNITE (UNI.cation at TEnuring) . 8 Refer to our research report \n[18] for the full algorithm of the generic StringGC, which also tries to eliminate the fragmentation. \nWe implemented the UNITE StringGC in IBM s latest production JVM, the J9 Java VM 5.0 for Linux. The JVM \ncan choose several GC policies [5], and generational GC was chosen for the prototype. In the prototype, \nall String objects in the tenured space are registered in a tenured\u00adstring table . When the generational \nGC decides to move a String object from the nursery space to the tenured space, the table is searched \nto check if there is a String object with the same value. If found, the nursery String object is uni.ed \nwith the found String object, which is already tenured. If not found, the nursery String object is moved \nto the tenured space and registered in the table. If a String object in the tenured-string table is no \nlonger referred to, the registration is removed when the tenured-space GC collects the dead object. Figure \n6 shows an example of the behavior of this UNITE StringGC, in which Nursery Space 1 became full and GC \nwas performed. A long-lived String object A1 was tenured and uni.ed with A0 that has the same value. \nIn contrast, B1 was moved to the tenured space and registered in the ta\u00adble, since there was no String \nobject with the same value. String object C1 was not old enough so just moved to Nurs\u00adery Space 2, although \nthere was a same-value String object C0 in the tenured space. String object C2 was not moved, and therefore \nwas collected, since it was not reachable from GC root sets. The references to the uni.ed or moved objects \nwere appropriately updated by the GC. 3.1.1 Discussion The StringGC explained above uni.es String objects \nif they have the same value. For example, in Figure 6, String objects A0 and A1 whose values are \"aaa\" \nare uni.ed. Due to this uni.cation of string heads, Java programs that do some identity-based operations \non String objects may be\u00adhave differently. The identity-based operations include ref\u00aderence comparisons \nwith == , monitor entrances and ex\u00adits, and calls to System.identityHashCode(). Figure 7 1 class BadManner \n{ 2 public static void main(String[] args) { 3 String s1 = new String(\"java\"); 4 String s2 = new String(\"java\"); \n5 if (s1 == s2) // should use s1.equals(s2) 6 System.out.println(\"Same Strings\"); 7 else 8 System.out.println(\"Different \nStrings\"); 9}} Figure 7. A bad-mannered program incompatible with the string-head uni.cation. In this \nprogram, s1 and s2 are Dif\u00adferent Strings although they have the same value. 1 public final class String \n... { :: 2 public boolean equals(Object o) { 3 if (o == this) return true; 4 if (!(o instanceof String)) \nreturn false; 5 String s = (String)o; 6 if (s.value == value &#38;&#38; // newly 7 s.offset == offset \n&#38;&#38; // added 8 s.count == count) return true; // check 9 // original comparison code follows :: \n 10}} Figure 8. Modi.ed String.equals() to exploit the string-body uni.cation. The comparison is accelerated \nif the string bodies have been merged. shows an example that behaves differently after the string\u00adhead \nuni.cation. If the String objects s1 and s2 are uni\u00ad.ed by StringGC, the program will print \"Same Strings\", \nwhile it originally printed \"Different Strings\". However, in Java programming, using == to compare strings \nshould be avoided and String.equals() is rec\u00adommended. We strongly believe that well-written Java pro\u00adgrams \nshould not use such identity-based operations for String objects. There are Java programs that intentionally \nuse == for the string comparison, by interning the involved strings in advance. Such programs still work \ncorrectly even if the string heads are uni.ed. The issue only occurs if a program relies on the non-identity \nof same-value String objects, which should be very rare. If the string-head uni.cation is still considered \nto be prob\u00adlematic, the issue can be avoided by unifying only the bod\u00adies (char arrays) of the same-value \nstrings. Since the string body is not directly accessible by Java programs, this ver\u00adsion is compatible \nwith the identity-based operations. The heap area reduced by StringGC is decreased by this modi.\u00adcation, \nbut the analysis of Table 1 shows that we still have a chance to remove more than 60% of the waste by \ndupli\u00adcation, since char arrays occupy the main part of the string memory. Unifying the String objects \nhas a good side effect in speeding up the execution of String.equals(), because typical implementations \nof the method .rst check the two objects with == . Slow character-by-character comparisons 1 class MyMessages \n{ 2 String getMessage(int key) { 3 switch (key) { 4 case 0: return \"message0\"; 5 case 1: return \"message1\"; \n6 case 2: return \"message2\"; 7 case 3: return \"message3\"; 8 default: // error handling 9}}} Figure 9. \nAn example of program conversion to reduce un\u00adused literals. Only the requested messages will be instanti\u00adated. \nare unnecessary if the same-value String objects are uni\u00ad.ed by StringGC. Even if the string heads are \nnot uni.ed, StringGC can speed up String.equals() by modifying the method to compare the value, offset, \nand count .elds as shown in Figure 8. This is because these .elds become the same if string bodies with \nthe same value are uni.ed by StringGC. When a String is uni.ed, the values of its value and offset .elds \nmay change. Therefore, special care must be taken not to run StringGC while a Java program is accessing \nthese .elds. Fortunately, the String class is a .nal class provided by the Java runtime and its .elds \nare accessed only by the String class or runtime. One possible solution is to minimize the sections which \nuse the String .elds and to make GC-safe points out of these sections to suppress StringGC. Another practical \nsolution is to unify String or char array objects only if the values of the offset .elds are the same. \nFor the evaluation in the next section, we adopted the former approach.  3.2 Program Conversion to Reduce \nUnused Literals The StringGC aims at the reduction of the duplication by unifying strings at the time \nof garbage collection. However, it cannot reduce the waste from unused literals, since it is dif.cult \nfor the GC to know which string literals have not been (and will not be) used by the application. It \nis better to remove the waste from unused literals before the literals are fully instantiated in the \nJava heap. To reduce the unused string literals, we .rst propose a program conversion. In Java programming, \na typical coding pattern can instantiate almost all string literals at the time of class initialization \nregardless of whether or not they are actually used. This pattern is often used for handling mes\u00adsage \nstrings, as shown in Figure 4. Therefore, we propose converting (or rewriting) such message classes to \na structure that instantiates the messages only when they are actually used by the application. Figure \n9 is an example of such a conversion for the MyMessages class in Figure 4. In the original class, all \nmessages are instantiated at the time of class initialization. In contrast, in the converted class, messages \nare instantiated when they are .rst requested through the getMessage() method, so memory waste by unused \nliterals is reduced. #chars #strs Trade6 Class name 86,702 1,628 security_en 86,702 1,628 security 72,594 \n1,340 engineMessages_en 72,594 1,340 engineMessages 31,564 492 CWSICMessages_en 31,564 492 CWSICMessages \n26,997 382 CWSIPMessages_en 26,997 382 CWSIPMessages 25,782 466 HAManagerMessages_en 25,782 466 HAManagerMessages \n: : : 2,181,795 64,887 TOTAL Table 4. Top 10 classes that have many instantiated string literals in \nTrade6. All are subclasses of ListResourceBun\u00addle. Actually, only a string \"message2\" is instantiated \nwhen the converted class is used with the MessageTest program in Figure 4. Such program conversion can \nbe done manually by pro\u00adgrammers. However, if the structure of message classes are well de.ned and known, \nthere is a chance to automate the conversion. To .nd such opportunities, we performed addi\u00adtional investigations \nfor unused literals. Table 4 shows the top10classes9 that have many instantiated string literals in the \nTrade6 test case. For each class shown in the third col\u00adumn, the second column shows the number of string \nliterals instantiated from the class, and the .rst column shows their total number of characters. The \nbottom line is the total for all classes (including the top 10), which shows that about 65,000 literals10 \nwere instantiated for the application. Here we noticed that all of the top 10 classes are sub\u00adclasses \nof java.util.ListResourceBundle, which is a framework to provide internationalized message sets in Java \n[7]. Actually, all unused messages shown in Table 3 came from these classes. Figure 10 shows a typical \nprogram us\u00ading ListResourceBundle. By extending the class, a mes\u00adsage class for English locale, MyResources \nen, is de.ned. BundleTest is a sample program to use the message class, where a message for a speci.c \nkey is retrieved by get-String(). In this example, all of the messages and keys are instantiated when \nthe message class is loaded and initialized at line 15. The getString() method, de.ned in ResourceBun\u00addle, \ninternally invokes handleGetObject() of the spec\u00adi.ed bundle to retrieve an object from a key string. \nBy re\u00adplacing this method using a similar conversion technique as the one used in Figure 9, we can suppress \nthe instantia\u00adtion of unused literals. Figure 11 shows the converted My\u00ad 9 Package names of classes are \nomitted in this table because of the space limitation. 10 In this test case, FooMessages en and FooMessages \ncontain exactly same message sets, so the number of literals in the live heap is smaller than this. \n1 import java.util.*; 2 public class MyResources_en extends ListResourceBun dle { 3 public Object[][] \ngetContents() { return contents; } 4 private static final Object[][] contents = { 5 {\"k0\", \"message0\"}, \n6 {\"k1\", \"message1\"}, 7 {\"k2\", \"message2\"}, 8 {\"k3\", \"message3\"} 9 }; 10 } 11 12 class BundleTest { 13 \npublic static void main(String[] args) throws Exception { 14 Locale l = Locale.ENGLISH; 15 ResourceBundle \nmyRes = ResourceBundle.getBundle(\"MyResources\", l); 16 System.out.println(myRes.getString(\"k2\")); 17}} \nFigure 10. An example that uses ListResourceBundle. All messages (and keys) are instantiated in line \n15. 1 import java.util.*; 2 public class MyResources_en extends ResourceBundle { 3 protected Object handleGetObject(String \nkey) { 4 int hc = key.hashCode(); 5 if (hc == 3365 &#38;&#38; key.equals(\"k0\")) return(\"message0\"); \n6 else if (hc == 3366 &#38;&#38; key.equals(\"k1\")) return(\"message1\"); 7 else if (hc == 3367 &#38;&#38; \nkey.equals(\"k2\")) return(\"message2\"); 8 else if (hc == 3368 &#38;&#38; key.equals(\"k3\")) return(\"message3\"); \n9 else return null; 10 } 11 public Enumeration<String> getKeys() { :: 12}} Figure 11. A message bundle \nconverted to reduce unused literals. Only the requested messages (and keys) will be instantiated. Resources \nen class. Here the converted class is a subclass of ResourceBundle, since handleGetObject() is de.ned \nas a final method of ListResourceBundle and cannot be overridden. This change should not affect applications \nthat conform to the ResourceBundle interface. Note that the conversion shown in Figure 11 includes an \nadditional technique to reduce unused literals. Since the key passed to handleGetObject() is a string, \nsuch as \"k2\" in Figure 10, direct comparison of the passed key with the message keys will result in instantiating \nall those keys that appear in the path executed. To avoid this, keys are .rst checked for their hash \ncodes. In Figure 11, the numbers 3365 3368 correspond to the hash codes of \"k0\" \"k3\", respectively. As \nexplained in Section 2.1, the hash code of a String is determined from its value using a formula de.ned \nin the speci.cation [25]. Therefore, it is possible to pre\u00adcalculate them at the time of conversion. \nString comparison is done only when the hash code matches the speci.ed key. DateFormatZoneData \"localPatternChars\" \n: \"Acre Time\" \"US/Mountain\" \"ACT\" \"US/Pacific\" \"Acre Summer Time\" \"US/Pacific-New\" \"ACST\" \"US/Samoa\" \n\"Central Standard Time \"VST\" (South Australia)\" \"W-SU\" \"CST\" \"Zulu\" : \"GyMdkHmsSEDFwWahKzZ\" Table 5. \nSome of the string literals instantiated when Date-FormatZoneData is initialized. Most remain unused. \nBy this conversion, we can almost completely suppress the instantiation of unused literals. For example, \nwhen the converted class in Figure 11 is used with the Bundle-Test program in Figure 10, only two strings, \n\"k2\" and \"message2\", are instantiated from the converted class. Since the structure and usage of the \nmessage classes ex\u00adtending the ListResourceBundle are well known, it is possible to automatically convert \nsuch classes to the struc\u00adture shown in Figure 11. For this purpose, we created a pro\u00adgram named BundleConverter. \nThis program loads a spec\u00adi.ed subclass of ListResourceBundle, extracts all keys and messages de.ned \nin the class, and generates a class converted as shown in Figure 11. By replacing the original ListResourceBundle \nsubclasses with the converted ones, applications can reduce the instantiation of unused literals. 3.3 \nLazy Body Creation The program conversion shown above is very effective in suppressing the instantiation \nof unused literals. However, such conversion is dif.cult for classes whose internal struc\u00adtures are not \nwell known by the converter or by the program\u00admer. One example of such classes is DateFormatZoneData, \nwhich instantiates more than 1,000 literals at its initializa\u00adtion, some of which are shown in Table \n5. By checking these values, it is considered that only few literals are used by the application, but \nthe program conversion cannot be applied to the class since its structure is not known. For such cases, \nthis section proposes another technique to reduce the memory waste of unused literals. The technique, \nnamed Lazy Body Creation, is implemented inside the JVM. As explained in Section 2.1, a Java string is \nrepresented with two objects, a String (head) and a char array (body). The key idea of Lazy Body Creation \nis to delay the creation of the string body until the literal s value is actually used. For unused literals, \ntheir bodies are not created in the Java heap, so the memory waste by unused literals can be partially \navoided. Since this technique is implemented in the JVM, it works for all literals unlike the program \nconversion. The Java virtual machine with Lazy Body Creation sepa\u00adrates the instantiation of string literals \ninto the following two phases:  (B) When the value is actually used. Figure 12. Behavior of Lazy Body \nCreation. The string body is not created if the value is not used. A. When a string literal is being \nloaded by the ldc bytecode, 1. Calculate the hash code and length of the literal, and search for an already \ninterned String object of the same value. If found, return it. Otherwise, perform the follow\u00ading steps. \n 2. Create a String object (head) with null in its val\u00adue .eld, which means that the creation of the \nbody is delayed. 3. Store the address of the UTF-8 data in the constant pool into the offset .eld. \n4. Store the values calculated in Step 1 into the count and hashCode .elds. 5. Perform the interning \nof the created String object, and return the result.  B. When a String s value is being used, 1. If \nthe value .eld is null, perform the following steps before using the value .eld. 2. Create a char array \n(body) with the length of count to hold the literal s value. 3. Fill in the char array with Unicode \ncharacters converted from the UTF-8 data pointed at by the offset .eld. 4. Store 0 into the offset .eld, \nthen store the reference to the created char array into the value .eld. 5. The other .elds, count and \nhashCode, need not be mod\u00adi.ed, since appropriate values have already been set.  Since the value of \neach literal exists as UTF-8 data in the constant pool of the class structure, it becomes possible to \ndelay the creation of the string body by remembering the address of the UTF-8 data. The address is stored \nin the off\u00adset .eld rather than in the value .eld, to avoid confusing the garbage collector. (header) \nvalue=null offset count =12 hc =nnnn String is a core class provided with each JVM. As shown in Figure \n2, it cannot be extended and all of its .elds are private. Therefore, the check in Phase B only needs \nto be added to the methods in the String class and the JVM itself, where the value .eld (or offset .eld) \nis directly accessed. Note that some methods in the String class can be executed without creating the \nstring body, since they do not access the value .eld. Examples of such methods are String.length(), hashCode(), \nand intern()11. Figure 12 illustrates the behavior of Lazy Body Creation. The upper .gure (A) shows when \na literal \"rare literal\" is loaded by the ldc bytecode, where only a String object (head) is created \nin the Java heap. The lower .gure (B) shows when the literal is actually used, where the char array (body) \nis created. Once the body is created, the literal can be used in the same way as regular String objects. \nThe Lazy Body Creation proposed here is applicable to all Java programs without modi.cation. Although \nit does not prevent string heads from being created, we believe this technique is effective to reduce \nthe memory waste by un\u00adused literals because 64 75% of such waste comes from the string bodies (char \narrays) according to our investigations summarized in Table 1. 3.3.1 Discussion In the implementation \nof Lazy Body Creation, Phase A (string head creation) is executed by only one thread for each literal, \nusing the original mutual exclusion mechanism of literal initialization. In contrast, Phase B (string \nbody cre\u00adation) may be executed by multiple threads in parallel. Our algorithms prevent race conditions \nwithout requiring addi\u00adtional locks. In Step B4, the value .eld is set after12 the offset .eld is set \nto 0, which prevents any other thread from accessing the char array with an invalid offset index. With \nthis ordering, it is possible that the offset has already become 0 in Step B3. That would mean that some \nother thread is executing Step B4, so the thread in Step B3 just can wait until the value .eld is set. \nSimilar waiting loop is inserted for all the places that directly access the UTF-8 data through the offset \n.eld. There may be a different kind of racing condition if two threads execute Step B4 in parallel. However, \nthis does not cause any problem even if the offset or value .elds are overwritten, because the same values \n(0 or the same-value char array) are stored by both threads. The previous char array will be collected \nas garbage when it is no longer re\u00adferred to. It is also possible to avoid the overwriting using atomic \ncompare-and-swap. 11 The length and hash code are already calculated and stored in the count and hashCode \n.elds, so can be returned by length() and hashCode(), respectively. Literals are interned at the time \nof the instantiation, so in\u00adtern() can simply return the object if the value .eld is null. 12 An appropriate \nmemory barrier must be inserted to enforce the write order. 1 class DuplicationBench { 2 static String[] \ndoCreate(int dupRatio) { 3 String[] strs = new String[1000000]; 4 int n = 0, dupCount = 1000000 * dupRatio/100; \n5 for (int i = 0; i < dupCount; i++) 6 strs[i] = \"STR_\"+n; // \"STR_0\" 7 for (int i = dupCount; i < 1000000; \ni++) 8 strs[i] = \"STR_\"+(++n); // \"STR_1\",\"STR_2\",... 9 return strs; 10 } 11 static int doCompare(String[] \nstrs) { 12 String str0 = \"STR_0\"; 13 int dupCount = 0; 14 for (int i = 0; i < 1000000; i++) 15 if (strs[i].equals(str0)) \ndupCount++; 16 return dupCount*100 / 1000000; // ==dupRatio 17 } :: 18 } Figure 13. DuplicationBench, \nto test the string duplication. 1,000,000 String objects are created and compared, where dupRatio percent \nof them have the same value. Additional care must be taken when StringGC is used with Lazy Body Creation. \nSince a new object usually cannot be created during GC, the StringGC code must be written so as to not \ntrigger the string body instantiation. In our implementation, it directly accesses the UTF-8 data in \nthe constant pool if a String object does not have a body.   4. Evaluation This section evaluates the \neffectiveness of the three tech\u00adniques in reducing the string memory waste described ear\u00adlier. As the \nimplementation target, we used IBM s latest pro\u00adduction JVM, the J9 Java VM 5.0 for Linux. StringGC was \nimplemented in its generational collector. Lazy Body Cre\u00adation was implemented in its core virtual machine \ncompo\u00adnent, while also modifying codes in the String class and the JVM that directly use the String.value. \nBundleCon\u00adverter was prepared as an independent Java program. All of the measurements were done on a \n3.06 GHz dual Xeon PC with 4 GB of memory, running the Red Hat En\u00adterprise Linux 3 AS operating system. \nThe Java heap size was set to 256 MB, where two 32 MB areas are used as the nurseries of the generational \nGC. 4.1 Micro-Benchmarks First, micro-benchmarks were used to analyze the basic characteristics of the \nproposed techniques. 4.1.1 Micro-Benchmark for String Duplication The program shown in Figure 13, called \nDuplicationBench, was used to analyze StringGC. The doCreate() method in the program creates 1,000,000 \nString objects through StringBuffers. The dupRatio percent of those created String objects had the same \nvalue (\"STR 0\"). In the mea\u00adsurements, this program was executed by specifying vari\u00ad Number of live \nobjects [M objects] Relative time for doCreate() (smaller is better)  Live heap size [MBytes] Figure \n14. Heap analysis of DuplicationBench. StringGC worked effectively to reduce the live heap. The two dotted \nlines show the actual dup ratios in Trade6 and Tuscany. ous dupRatio values on the JVMs with and without \nthe StringGC. We con.rmed that all of the related methods were JIT-compiled similarly in both JVMs. The \ngraphs in Figure 14 show the status of the Java heap just after the doCreate() method is executed. The \nupper graph shows the numbers of live objects and the lower graph shows their total size for each dupRatio \nvalue. The two vertical dotted lines labeled Trade6 and Tuscany show the actual duplication ratios measured \nin Section 2.3. Without the StringGC, the heaps were almost the same for all of the dupRatio values. \nThere were about 2 million live objects in the heap because one string is represented by two objects, \na String and a char array, as shown in Figure 2. When the StringGC was enabled, both the number of live \nobjects and their total size decreased as the dupRa\u00adtio increased. The ratio of decrease matched the \ndupRatio, which indicates that String uni.cation of the StringGC worked effectively. One interesting \nobservation is that the heap decrease stopped around the 70% dupRatio.Thisis because the newest Strings \nwere not uni.ed since they remained in the nursery space, which was 32 MB in these measurements. Relative \ntime for doCompare() (smaller is better) Figure 15. Relative times for doCreate() and doCom\u00adpare() in \nDuplicationBench. With StringGC, the creation became slower but the comparison became faster. Next, the \nupper graph of Figure 15 shows the times for executing the doCreate() method, normalized against the \ntime with no duplications on the original JVM. Without the StringGC, the times were constant for all \ndupRatio values. When the StringGC was enabled, the method became slower, especially for low dupRatio \ncases. This is evidently due to the cost for maintaining the tenured-string table, where one\u00admillion \nstrings were eventually registered. The time became betterasthe dupRatio increased, since the table size \nbe\u00adcame smaller. The performance overhead with the StringGC peaked at a slowdown of 3.2 times lower, \neven for this ar\u00adti.cial string-intensive program where millions of string\u00adrelated objects exist in the \ntenured space. Performance with more realistic programs will be measured in the next section. As discussed \nin Section 3.1.1, unifying the String ob\u00adjects has a side effect of speeding up some string compar\u00adisons. \nWe also measured this effect in the micro-benchmark. The doCompare() method of DuplicationBench was used \nfor the measurements. This method compares the 1,000,000 String objects created by doCreate() with a \nstring \"STR 0\" by using String.equals(). Therefore, dupRatio percent of the comparisons will succeed. \n1 import java.util.*; 2 class LiteralsBench { 3 public static void main(String[] args) throws Exception \n{ 4 Locale l = Locale.ENGLISH; 5 ResourceBundle myRes = ResourceBundle.getBundle(\"MyResources1000\", l); \n6 useMsg(myRes, 1000); // use \"message1000\" 7 /*----Measurement point A ----*/ 8 for (int i = 1001; i \n<= 1999; i++) 9 useMsg(myRes, i); // use \"message1001\",... 10 /*----Measurement point B ----*/ 11 } 12 \nvolatile static char c; 13 static void useMsg(ResourceBundle res, int idx) { 14 String msg = res.getString(\"k\" \n+ idx); 15 c = msg.charAt(0); // msg s value is used here 16}} 17 18 public class MyResources1000_en \n extends ListResourceBundle { 19 public Object[][] getContents() { return contents; } 20 private static \nfinal Object[][] contents = { 21 {\"k1000\", \"message1000\"}, // 2,000 literals here : : // (1,000 keys \nand 22 {\"k1999\", \"message1999\"} // 1,000 messages) 23 }; 24 } Figure 16. LiteralsBench, to test unused \nmessage literals. It .rst uses just one message in the message class, then uses the remaining messages. \nThe lower graph of Figure 15 shows the normalized time for executing the doCompare() method for various \ndupRa\u00adtio values. In the original JVM, the time becomes worse for higher dupRatios, because the comparisons \nof String objects with the same value eventually needed to execute character-by-character comparison, \nwhile hash-code com\u00adparison was suf.cient for different strings. However, when the StringGC was enabled, \nthe comparison became faster for higher dupRatios, because the same-value String objects had been uni.ed. \nConsequently, for this micro-benchmark, comparing same-value String objects was 6.4 times faster than \non the original JVM.  4.1.2 Micro-Benchmark for String Literals Next, we analyzed BundleConverter and \nLazy Body Cre\u00adation using another micro-benchmark called LiteralsBench, shown in Figure 16. This program \n.rst loads a message class MyResources1000 en, which is a subclass of List-ResourceBundle containing \n1,000 messages, then uses the messages one-by-one. Measurements were done at two points shown in the \nprogram: (A) after one message is used, and (B) after all of the messages are used. Using this micro-benchmark, \nthe following three cases were tested: 1. Run LiteralsBench on the original JVM. 2. Run LiteralsBench \non a JVM with Lazy Body Creation.  Measured 1 Original 2 Lazy Body 3 Bundle point JVM Creation Converter \nA String 2,000 2,000 2 char[ ] 2,000 2 2 B String 2,000 2,000 2,000 char[ ] 2,000 2,000 2,000 Table \n6. Number of objects created from the literals of My-Resources1000 en in LiteralsBench. Both of the proposed \ntechniques could reduce the instantiation of unused literals. Measured 1 Original 2 Lazy Body 3 Bundle \nsection JVM Creation Converter Entry to A 100 89 158 (noverify) (93) (82) (61) AtoB 50 66 120 Table \n7. Relative execution times of LiteralsBench. The BundleConverted class is slower than the original class. \n3. Run LiteralsBench with a new, BundleConverted MyRe\u00ad sources1000 en class, on the original JVM. BundleConverter \nand Lazy Body Creation were tested sepa\u00adrately here, to understand the behavior of each optimization. \nTable 6 shows the number of String and char[ ] ob\u00adjects in the Java heap created from the 2,000 literals \nof the MyResources1000 en class. These results are just as ex\u00adpected. At the measurement point A, all \nliterals were fully instantiated in the original JVM, while the creation of char arrays were suppressed \nin Lazy Body Creation. If the mes\u00adsage class is converted by BundleConverter, only two liter\u00adals (\"k1000\" \nand \"message1000\") were instantiated at this point. At Point B, there is no difference among the three \ntest cases, since all messages had been used by this point. Next, Table 7 shows the relative execution \ntime of Liter\u00adalsBench in each test case. The times from the entrance of main() to Points A and B were \nmeasured and normalized. The JIT compiler was turned off in this measurement. Lazy Body Creation arrived \nat Point A faster than the original JVM, because it did not create string bodies for most literals. Instead, \nthe time from A to B became longer, because the delayed body creations were done here. The total time \nto Point B was almost the same as the original JVM. For the program converted by BundleConverter, we \nex\u00adpected that it would reach Point A much faster because fewer objects need to be created. However, \nthe result was 1.6 times slower than original JVM. This is because bytecode veri.ca\u00adtion took longer \ntime for the converted class, since it contains a long handleGetObject() method as shown in Figure 11. \nThe (noverify) row in the table shows the times if the ver\u00adi.cation is turned off, in which the time \nto Point A became much faster than the original JVM. As for the total time to arrive at Point B, it was \nslower than for the original class. This is because many if-statements needed to be executed in the converted \nclass.  4.2 Macro-Benchmarks Next, macro-benchmarks were run using more realistic Java programs. 4.2.1 \nExecution Performance First, the execution performance was measured by using the SPECjvm98 [24] benchmark \nprograms. In the evaluation, each of the seven programs was run separately in the appli\u00adcation mode, \nspecifying the problem size as 100%. For each con.guration, we took the best time from repeated runs. \nFigure 17 shows the results, where the execution time relative to the original JVM is shown for the StringGC \nJVM and the Lazy Body Creation JVM. Since ListResource-Bundle class is not used in SPECjvm98, BundleConverter \nwas not tested here. Surprisingly, for StringGC, we observed a time reduction of about 30% in db. The \nreason is that many string-compare operations in this benchmark was accelerated by the uni.ca\u00adtion of \nString objects, as shown in the lower graph of Fig\u00adure 15. In the measured environment, about 80,000 \nString objects were tenured during one execution of the benchmark, and about 50,000 of them were uni.ed \nto other String objects. String.equals() was executed about 1,460,000 times. For Lazy Body Creation, \nwe could not observe any signi.cant differences. We also measured the DaCapo [6] benchmarks for the three \nJVMs, but did not .nd any signi.cant differences. Actually, the deviations among the runs were much larger \nthan the differences among the JVMs. To summarize, no performance degradations due to String-GC or Lazy \nBody Creation were observed in these macro\u00adbenchmarks. 4.2.2 Heap Reductions for Client-Type Applications \nNext, we measured the heap reductions for these macro\u00adbenchmarks. Our original motivation was to reduce \nthe memory consumption of large enterprise applications. How\u00adever, our string reduction techniques also \nwork effectively for most of these client-type applications. Figure 18 shows the analyses of the live \nheaps of the SPECjvm98 and DaCapo benchmarks. Since these programs have no stable state for consistent \nanalyses among multi\u00adple runs, we analyzed each program when it reached 70% of its total object allocations. \nFor example, a total of 222 MB of objects are allocated to execute antlr in DaCapo, so we analyzed its \nlive heap when 155 MB (222 \u00d7 0.7) of the ob\u00adjects had been allocated. Note that the analyzed live heap \nwas much smaller than the allocated size, because many ob\u00adjects had already died at the measurement point. \nFor each benchmark in the .gure, the upper bar shows the live heap in the original JVM, and the lower \nbar shows the live heap when StringGC and Lazy Body Creation are en\u00adabled. Since the actual sizes of \nthe live heaps vary among the benchmarks, they are normalized so the size in the original Relative time \nto Original JVM (smaller is better) 1.2 1.0 0.8 0.6 0.4 0.2 0.0 Figure 17. Relative times to the original \nJVM in the SPECjvm98 benchmarks. There are no large differences, ex\u00adcept db was accelerated by StringGC. \nJVM is 100%. The memory for String objects and the char arrays for holding their actual values are separately \nshown in the bars. This shows that these string-related objects occupy large portions of the live heap \nin most of the benchmarks. The number under each benchmark name on the left side is the reduction ratio \nof the live heap for that benchmark. The live heaps were reduced in all of these benchmarks. In particular, \nmore than 10% reductions were observed for seven benchmarks: db, mpegaudio, jack, bloat, chart, luindex, \nand lusearch. The geometric mean indicates that our string reduction techniques can reduce the live heaps \nby 11.6% for these client-type applications. In Figure 18, we only showed the live heap at the 70% al\u00adlocation \npoint of each benchmark. However, we con.rmed that each benchmark basically exposed similar demography \nin the live heap for all of the 10%, 20%, ...., 90% alloca\u00adtion points. For example, Figure 19 shows \nthe comprehen\u00adsive analysis for eclipse in DaCapo. The live heaps in the original JVM (left bar) and \nour modi.ed JVM (right bar) are compared for each of the 10% to 90% allocation points. Although the size \nof the live heap changes during the execu\u00adtion, its 40 50% region is always occupied by string-related \nobjects in this benchmark. As shown in the dotted lines, our string reduction techniques were able to \nreduce the live heap size by 8 13%.  4.2.3 Heap Reductions for Real Applications Finally, we measured \nthe effects for heap reduction in large\u00adscale enterprise Java applications, which was the original concern \nof this research. The same programs described in Section 2.3, Trade6 and Tuscany, were used for the evalua\u00adtion. \nTable 8 shows the results of live heap analysis as reported in Table 1, when incrementally enabling StringGC, \nBundle-Converter, and Lazy Body Creation. BundleConverter was 0% 20% 40% 60% 80% 100% Live heap size \n(smaller is better) String char[ ] for String Other objects MB Original JVM StringGC+Lazy Body Creation \n  10 20 30 40 50 60 Time (percentage to total allocation) mpegaudio -21.3% Figure 19. Live heap of eclipse \nin DaCapo at the 10 90% allocation points. Proposed techniques consistently reduced jack the live heap \nsize by 8 13%. -17.4% javac mtrt -2.2% jess -8.4% compress -1.3% db -30.8% 12 10 8 6 4 2 0 70 80 90 \nMetrics Trade6 count size Tuscany count size Original JVM Total live objects 582,012 31,346 KB 281,210 \n15,193 KB -String objects 103,370 2,894 KB 57,773 1,617 KB -char[ ] for String 92,996 8,967 KB 47,991 \n3,649 KB + StringGC Total live objects 520,387 28,506 KB 227,684 13,007 KB -String objects 69,162 1,937 \nKB 26,527 743 KB -char[ ] for String 67,236 7,157 KB 25,129 2,186 KB + BundleConverter Total live objects \n487,363 26,643 KB -String objects 59,574 1,668 KB -char[ ] for String 57,684 5,962 KB +LazyBodyCreation \nTotal live objects 472,380 25,695 KB 220,272 12,544 KB -String objects 59,693 1,671 KB 26,093 731 KB \n-char[ ] for String 43,125 5,055 KB 18,743 1,887 KB Total eliminated -ratio to the waste -ratio to the \norig. heap 109,632 5,651 KB 96.2% 93.8% 18.8% 18.0% 60,938 2,650 KB 86.2% 87.0% 21.7% 17.4% -8.3% antlr \n-9.4% bloat -12.7% chart -26.3% eclipse -8.7% fop -3.3% hsqldb -0.6% Table 8. Cumulative results for \nheap memory reductions in jython real applications. From 87% to 94% of the string memory inef.ciencies \nhave been removed. -8.5% luindex -17.1%  Original JVM -14.4% lusearch +StringGC pmd -8.0%  +Bdl.Converter \nxalan -2.9% +Lazy B.Creation Figure 18. The live heaps of the SPECjvm98 and DaCapo 0 5 1015202530MB \nbenchmarks at the 70% allocation point. For each pair of bars, the upper bar shows the original JVM and \nthe lower Figure 20. Live heap reduction for Trade6 by the proposed bar shows the modi.ed JVM with StringGC \nand Lazy Body methods. The inef.ciencies were eliminated in each step, Creation, which reduced the live \nheaps by 11.6% on average. and the live heap size was reduced by 18%. #chars Trade6 #strs Class name \n706 (-99.2%) 0 ( -100%) 205 (-99.7%) 0 ( -100%) 76 (-99.8%) 0 ( -100%) 294 (-98.9%) 0 ( -100%) 177 (-99.3%) \n0 ( -100%) : 16 (-99.0%) security_en 0 ( -100%) security 6 (-99.6%) engineMessages_en 0 ( -100%) engineMessages \n2 (-99.6%) CWSICMessages_en 0 ( -100%) CWSICMessages 4 (-99.0%) CWSIPMessages_en 0 ( -100%) CWSIPMessages \n4 (-99.1%) HAManagerMessages_en 0 ( -100%) HAManagerMessages : : 1,109,686 (-49.1%) 44,232 TOTAL (-31.8%) \n-reduction due to the conversion Table 9. Literals instantiated from the converted classes. Compared \nto the result in Table 4, BundleConverter success\u00adfully suppressed the unnecessary literal instantiations. \nnot used for Tuscany, because this application was not inter\u00adnationalized and was not using ListResourceBundle. \nWhen StringGC was enabled, 33.1% of the String ob\u00adjects and 27.7% of the char arrays for strings were \nremoved in Trade6. Due to this, 9.1% of the live heap area in the original JVM was eliminated. StringGC \nwas more effective for Tuscany, where 14.4% of the heap usage was eliminated. Comparing this result with \nTable 1, the StringGC prototype removed about 90% of the string memory waste from dupli\u00adcation. When \nBundleConverter was used, the number of string literals in Trade6 was reduced by 30.0%, from 35,498 to \n24,882. Interestingly, non-string-related objects were also reduced. This is because the conversion shown \nin Figure 11 eliminates the use of HashMap in ListResourceBundle. Due to these effects, BundleConverter \ncould further reduce the live heap size of Trade6 by 1.9 MB, which was 5.9% of the original live heap. \nTable 9 shows the number of characters and strings in\u00adstantiated from the converted message classes, \nwhich origi\u00adnally had the top 10 literals as shown in Table 4. The num\u00adbers in parentheses are reduction \nratios from original classes. For example, the instantiated literals of a class security en were reduced \nby 99.0%, from 1,628 to 16. Since there is a key string for each message, this means that only 8 messages \nof this class were actually used by the Trade6 test case. Returning to Table 8, when Lazy Body Creation \nwas added, char arrays were not created for 56.3% of the re\u00admaining 24,882 literals in Trade6. This shows \nthat there still exist classes that instantiate unused literals besides List-ResourceBundle. Lazy Body \nCreation further reduced the char arrays by 0.9 MB, which was 3.0% of the original live heap. For Tuscany, \nLazy Body Creation also saved 3.0% of the live heap. Figure 20 illustrates the reduction of the live \nheap for Trade6. This clearly shows that the inef.ciencies were re\u00adduced in each step. The remaining \ninef.ciencies we could not remove were: (1) duplications of String objects in the nursery space, (2) \nfragmentations in char arrays, and (3) string heads of unused literals which cannot be Bundle-Converted, \nthe total of which was less than 3% of the re\u00adduced new live heap. Summarizing these results, the combination \nof the three proposed techniques eliminated 87 94% of the string mem\u00adory inef.ciencies measured in Table \n1, achieving about 18% reduction of the live heap usage.   5. Related Work This section will introduce \nrelated work and compare that work with our three techniques. In Java, a string can be interned by the \nString.in\u00adtern() method, which returns a String object whose value is the same as the target String. \nA unique object is re\u00adturned for the same string value. Therefore, interning can be used to unify duplicated \nString objects. However, this must be done explicitly in each Java application, and as far as we know, \nno application utilizes interning to reduce the string memory overhead. Actually, it is usually used \nto make String objects comparable by using == . The simple idea of interning all Strings when they are \ncreated is not practical, since many temporary Strings will also be interned. Our UNITE StringGC in Section \n3.1 is one solution to this problem, by interning only the long-lived String objects. It is common to \neliminate the duplicates of string lit\u00aderals. The Java Language Speci.cation [10] speci.es that all string \nliterals and string-value constant expressions must be interned. In the Unix operating system, a tool \nnamed xstr(1) is provided to extract strings from C programs and unify them. Dieckmann and H\u00a8olzle [8] \nstudied the allocation behavior of the SPECjvm98 benchmarks, and measured low-level data including age \nand size distribution, type distribution, and the overhead of object alignment. Their study did not include \nduplication or fragmentation or speci.cally focus on strings. They mentioned in the conclusions that \nthey are working on additional experiments for an extended version of the paper, suggesting that they \nare gathering new data which will illuminate the in.uence of strings on the heap composition. However, \nto the best of our knowledge, the new data remains unpublished. Marinov and O Callahan [20] presented \nObject Equal\u00adity Pro.ling (OEP) to discover opportunities for replacing a set of equivalent object instances \nwith a single represen\u00adtative object. While we focus on duplication in strings, they studied duplication \nin general, or mergeability in their ter\u00adminology, for arbitrary Java objects. They precisely de.ne the \nmergeability problem, and describe how to ef.ciently compute mergeability. They developed a tool, a combination \nof an online pro.ler and postmortem analyzer, and revealed signi.cant amounts of object equivalence in \nreal Java pro\u00adgrams. Automatic optimizations exploiting object equivalence are beyond the scope of their \npaper. However, they per\u00adformed a case study for two SPECjvm98 benchmarks, db and mtrt, and manually \noptimized them to reduce the space used by live objects. Their tool showed that in db only two classes, \nString and char[ ], matter for mergeability, and that the relevant allocation site for the mergeable \nString was line 191 in the .le Database.java. They then mod\u00adi.ed the line to call String.intern() immediately \nafter the allocation. They observed a 47% reduction in the aver\u00adage space for live objects, and a slight \nimprovement in the execution from 19.1 sec to 18.8 sec. This is an interesting contrast with the results \nfrom our optimizations. Hash-consing [9, 11] in functional languages guarantees that two identical objects \nshare the same records in the heap. Hash-consing eliminates duplicated records, and allows the equality \nof two records to be determined without structural comparison. However, it must maintain a hash table \nto check if there is already an identical record, and check the hash table at every allocation. Appel \nand Goncalves [4] proposed to integrate hash\u00adconsing with generational garbage collection. They only \nhash-cons records that survive a garbage collection, thereby avoiding the cost of a table lookup for \nshort-lived objects. They implemented the scheme for the Standard ML of the New Jersey compiler. Unfortunately, \nthe space savings in the programs they measured were not impressive, less than 1% in most cases. They \nargue that hash-consing would show real promise when coupled with function memorization. Vaziri, Tip, \nFink, and Dolby [27] proposed a way to for\u00admally declare object identity using relation types. This model \ncan be used for hash-consing of general objects. However, the classes must be declared using their constructs, \nwhich are not compatible with current Java syntax. In the future, it may become possible to combine their \nmodel with our StringGC to further reduce the memory footprint. Mitchell and Sevitsky [22] investigated \nthe causes of memory bloat in various Java programs, and showed that memory health is limited by the \nstructural overhead of the design of each data type. Some of the string memory inef\u00ad.ciencies we showed \nin this paper can be regarded as such overhead that limits the memory health. Lazy evaluation is a well-known \ntechnique, especially in functional programming languages such as Haskell [16], where computations are \ndelayed until their results are actu\u00adally needed. Our two techniques to reduce unused literals can be \nconsidered as applying the concept of lazy evaluation to a speci.c mechanism of the language implementation. \nOne reason of many unused literals is that there is no way for a Java program to directly declare a static \nhash map. Therefore, all literals are instantiated at the initialization time to construct a HashMap \ndynamically. Adding a new language construct may be another solution to reduce the unused literals. Memory \nleaks are one of the largest causes of footprint expansion even in garbage-collected languages such as \nJava. However, they are basically a problem within each applica\u00adtion, so research has been focused on \ntools to detect memory leaks effectively, such as LeakBot [21] and Cork [17]. In contrast, the string \nmemory inef.ciencies we revealed come from the design and implementation of the Java language it\u00adself. \nTherefore, we could create several techniques to reduce these inef.ciencies which are widely applicable \nto almost all Java applications, as shown in Figures 18 20. 6. Conclusion This paper described proposals, \nimplementations, and eval\u00aduations of three techniques to reduce the string memory con\u00adsumption of Java \nprograms. Recent Java applications handle more and more string data, such as for processing XML and accessing \ndatabases. For example, in a production J2EE application server, about 40% of the live heap area is used \nfor string data. Through exhaustive investigation of this string data, we identi.ed two types of string \nmemory inef.ciencies in Java. First, there are many duplicated strings in the heap. Second, there are \nmany string literals whose values are not actually used by the program. These inef.ciencies exist as \nlive objects, so they cannot be addressed by existing GC techniques. Quantitative analysis of real Java \napplications revealed that more than 50% of the string data is wasted, occupying about 20% of the live \nheap area. To remove the inef.ciencies, we developed three new techniques. StringGC is a new optimization \nat GC time to eliminate duplicated strings. BundleConverter is a program converter that converts message \nclasses in an application to a form that does not instantiate unused message literals. Lazy Body Creation \nis a new JVM mechanism to delay part of the creation of literals until they are actually used. We implemented \nthree techniques for a production Java virtual machine, and examined large enterprise applications. Results \nshow that our techniques eliminated about 90% of the string memory inef.ciencies, and reduced the size \nof the live heap by 18%. We also showed that the proposed techniques can reduce the live heap size of \nstandard Java benchmarks by 11.6% on average, without any noticeable performance degradation.  Acknowledgments \nWe thank the members of the Infrastructure Software Group and the Systems Group in IBM Tokyo Research \nLaboratory, who have developed many Java-related optimization tech\u00adniques and who always gave us valuable \ncomments. We also thank Andrew Low and Thomas Gissel of IBM Software Group for their various suggestions \nto our memory investigation work.  References [1] The Apache Software Foundation. Apache Harmony. http://harmony.apache.org/ \n[2] The Apache Software Foundation. Apache Tomcat. http://tomcat.apache.org/ [3] The Apache Software \nFoundation. Apache Tuscany. http://tuscany.apache.org/ [4] A. W. Appel and M. J. R. Goncalves. Hash-consing \ngarbage collection. Technical Report CS-TR-412-93, Department of Computer Science, Princeton University, \n1993. [5] C. Bailey. Java Technology, IBM Style: Introduction to the IBM Developer Kit: An overview \nof the new functions and features in the IBM implementation of Java 5.0, 2006. http://www.ibm.com/developerworks/java/library/ \nj-ibmjava1.html [6] S. M. Blackburn, et al. The DaCapo Benchmarks: Java Benchmarking Development and \nAnalysis. In Proceedings of the 21st ACM Conference on Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA 06), pp. 169 190, 2006. [7] P. Chan, R. Lee, and D. Kramer. The Java Class \nLibraries, Second Edition, Addison Wesley, 1998. [8] S. Dieckmann and U. H\u00a8olzle. A Study of the Allocation \nBehavior of the SPECjvm98 Java Benchmark. In Proceedings of the 13th European Conference on Object-Oriented \nProgramming (ECOOP 99), pp. 92 115, 1999. [9] A. P. Ershov. On Programming of Arithmetic Operations. \nIn Communications of the ACM, Vol. 1, No. 8, pp. 3 9, 1958. [10] J. Gosling, B. Joy, G. Steele, and \nG. Bracha. The Java Language Speci.cation, Third Edition, Addison Wesley, 2005. [11] E. Goto. Monocopy \nand Associative Algorithms in an Extended Lisp. Technical Report 74-03, Information Science Laboratory, \nUniversity of Tokyo, 1974. [12] N. Grcevski, A. Kielstra, K. Stoodley, M. Stoodley, and V. Sundaresan. \nJava Just-In-Time Compiler and Virtual Ma\u00adchine Improvements for Server and Middleware Applications. \nIn Proceedings of the 3rd USENIX Virtual Machine Research and Technology Symposium (VM 04), pp. 151 162, \n2004. [13] IBM Corporation. IBM Trade Performance Benchmark. https://www14.software.ibm.com/webapp/iwm/web/ \npreLogin.do?source=trade6 [14] IBM Corporation. WebSphere Application Server. http://www.ibm.com/software/webservers/appserv/was/ \n[15] R. Jones and R. Lins. Garbage Collection: Algorithms for Automatic Dynamic Memory Management, Wiley, \n1996. [16] S. P. Jones. Haskell 98 Language and Libraries: The Revised Report, Cambridge University Press, \n2003. [17] M. Jump and K. S. McKinley. Cork: Dynamic Memory Leak Detection for Garbage-Collected Languages. \nIn Proceedings of the 34th ACM Symposium on Principles of Programming Languages (POPL 07), pp. 31 38, \n2007. [18] K. Kawachiya, K. Ogata, and T. Onodera. A Quantitative Analysis of Space Waste from Java Strings \nand its Elimina\u00adtion at Garbage Collection Time. Research Report RT0750, IBM Tokyo Research Laboratory, \n2007. [19] T. Lindholm and F. Yellin. The Java Virtual Machine Speci.cation, Second Edition, Addison \nWesley, 1999. [20] D. Marinov and R. O Callahan. Object equality pro.ling. In Proceedings of the 18th \nACM Conference on Object-Oriented Programming, Systems, Languages, and Applica\u00adtions (OOPSLA 03), pp. \n313 325, 2003. [21] N. Mitchell and G. Sevitsky. LeakBot: An Automated and Lightweight Tool for Diagnosing \nMemory Leaks in Large Java Applications. In Proceedings of the 17th European Conference on Object-Oriented \nProgramming (ECOOP 03), pp. 351 377, 2003. [22] N. Mitchell and G. Sevitsky. The Causes of Bloat, The \nLimits of Health. In Proceedings of the 22nd ACM Conference on Object-Oriented Programming, Systems, \nLanguages, and Applications (OOPSLA 07), pp. 245 260, 2007. [23] Open SOA. Service Component Architecture \nHome. http://osoa.org/display/Main/Service+Component+ Architecture+Home [24] Standard Performance Evaluation \nCorporation. SPEC JVM98 Benchmarks. http://www.spec.org/osg/jvm98/ [25] Sun Microsystems. Java2 Platform \nStandard Edition 5.0 API Speci.cation: java.lang.String. http://java.sun.com/j2se/1.5.0/docs/api/java/ \nlang/String.html [26] The Unicode Consortium. The Unicode Standard, Ver\u00adsion 5.0, Addison Wesley, 2006. \n[27] M. Vaziri, F. Tip, S. Fink, and J. Dolby. Declarative Object Identity Using Relation Types. In Proceedings \nof the 21st European Conference on Object-Oriented Programming (ECOOP 07), pp. 54 78, 2007.  \n\t\t\t", "proc_id": "1449764", "abstract": "<p>This paper describes a novel approach to reduce the memory consumption of Java programs, by focusing on their \"string memory inefficiencies\". In recent Java applications, string data occupies a large amount of the heap area. For example, about 40% of the live heap area is used for string data when a production J2EE application server is running. By investigating the string data in the live heap, we identified two types of memory inefficiencies -- \"duplication\" and \"unused literals\". In the heap, there are many string objects that have the same values. There also exist many string literals whose values are not actually used by the application. Since these inefficiencies exist as live objects, they cannot be eliminated by existing garbage collection techniques, which only remove dead objects. Quantitative analysis of Java heaps in real applications revealed that more than 50% of the string data in the live heap is wasted by these inefficiencies. To reduce the string memory inefficiencies, this paper proposes two techniques at the Java virtual machine level, \"StringGC\" for eliminating duplicated strings at the time of garbage collection, and \"Lazy Body Creation\" for delaying part of the literal instantiation until the literal's value is actually used. We also present an interesting technique at the Java program level, which we call \"BundleConverter\", for preventing unused message literals from being instantiated. Prototype implementations on a production Java virtual machine have achieved about 18% reduction of the live heap in the production application server. The proposed techniques could also reduce the live heap of standard Java benchmarks by 11.6% on average, without noticeable performance degradation.</p>", "authors": [{"name": "Kiyokuni Kawachiya", "author_profile_id": "81100038759", "affiliation": "IBM Tokyo Research Laboratory, Yamato, Kanagawa, Japan", "person_id": "P1223212", "email_address": "", "orcid_id": ""}, {"name": "Kazunori Ogata", "author_profile_id": "81100139883", "affiliation": "IBM Tokyo Research Laboratory, Yamato, Kanagawa, Japan", "person_id": "P1223213", "email_address": "", "orcid_id": ""}, {"name": "Tamiya Onodera", "author_profile_id": "81100474003", "affiliation": "IBM Tokyo Research Laboratory, Yamato, Kanagawa, Japan", "person_id": "P1223214", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449795", "year": "2008", "article_id": "1449795", "conference": "OOPSLA", "title": "Analysis and reduction of memory inefficiencies in Java strings", "url": "http://dl.acm.org/citation.cfm?id=1449795"}