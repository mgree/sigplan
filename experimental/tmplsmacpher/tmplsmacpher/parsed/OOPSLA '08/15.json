{"article_publication_date": "10-19-2008", "fulltext": "\n The Impact of Static-Dynamic Coupling on Remodularization RickChern KrisDeVolder UniversityofBritishColumbia \n2366MainMall Vancouver,BC Canada {rchern, kdvolder}@cs.ubc.ca Abstract We explore the concept of static-dynamic \ncoupling the degree to which changes in a program s static modular structure imply changes to its dynamic \nstructure. This pa\u00adper investigates the impact of static-dynamic coupling in a programming language on \nthe effort required to evolve the coarse modular structure of programs written in that language. We performed \na series of remodularization case studies in both Java and SubjectJ. SubjectJ is designed to be similar \ntoJava,buthave strictlyless static-dynamic cou\u00adpling.Our resultsincludequantitativemeasures timetaken \nand number of bugs introduced as well as a more subjec\u00adtivequalitative analysis of the remodularizationprocess.All \nresults point in the same direction and suggest that static\u00addynamic coupling causes substantial accidental \ncomplexity for the remodularization ofJavaprograms. Categories and Subject Descriptors D.2.2[Design Tools \nand Techniques]: Evolutionary prototyping, Modules and interfaces; D.3.3 [Language Constructs and Features]: \nModules, packages; D.2.6 [Programming Environments]: Integrated environments; D.2.3 [Coding Tools and \nTech\u00adniques]:Object-orientedprogramming General Terms languages, experimentation Keywords remodularization,subject-orientedprogramming, \nhyperslices, static-dynamic coupling, refactoring, language design 1. Introduction We consider two kinds \nof program structure: static and dy\u00adnamic. Static program structure is concerned with how in\u00adformationinprogramtextis \norganizedin terms ofdocument Permission to make digital or hard copies of all or part of this work for \npersonal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial \nadvantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonserversortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. OOPSLA 08, October19 23,2008,Nashville,Tennessee,USA. \nCopyright c &#38;#169;2008ACM978-1-60558-215-3/08/10. . .$5.00 structure.Dynamicprogramstructureis concerned \nwith the structure of computations during program execution for example, dynamic program structure in \nan object-oriented language corresponds to the structure of objects and their run-timeinteractions. In \nthe remainder of this paper, we refer to remodular\u00adization as the evolution of aprogram s coarse static \nmodu\u00adlar structure.Languagedesign canimpact the complexityof remodularizingprograms.Inparticular, somelanguagede\u00adsigns \ncan make it harder to move code around within the static modular structure without changingdynamicprogram \nstructure; we call this static-dynamic coupling. The key contribution of our paper is providing exper\u00adimental \nresults towards answering the following research question: How andto what extentdoes static-dynamic coupling \nin a language impact the complexity of remodulariz\u00ad ingprograms? Toinvestigate thisquestion, weperformeda \nseries of re\u00admodularizationcase studiesintwolanguages Java[13]and SubjectJ. SubjectJ was designed to \nbe similar to Java but haveless static-dynamic coupling.We collectedquantitative data time taken and \nnumber ofbugsintroduced and also performed a more subjective qualitative analysis of the re\u00admodularizationprocess. \nAll results point in the same direction and suggest that static-dynamiccouplinginJava causes substantialaccidental \ncomplexity1.Quantitative results showthat remodularizing in Java takes more time and results in more \nfrequent intro\u00adduction ofbugs;qualitative resultsprovideinsightinto how static-dynamiccouplinginJavaleadsto \naccidentalcomplex\u00adity. Note that we do not claim SubjectJ itself as a novel contribution. SubjectJ is \nonly a guinea pig. The ideal pair of guinea pigs would be two languages that signi.cantly differ from \neach other in terms of static-dynamic coupling, 1Theterm accidental complexity coinedbyBrooks[2] means \ncomplex\u00adity that arises in computer programs or their development process which is non-essential to theproblem \ntobe solved . public class Counter extends JPanel { private int count = 0; private JButton button; private \nJLabel label; public Counter() { label = new JLabel(\"\"+getCount()); add(label); button = new JButton(\"Increment\"); \nadd(button); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent \ne) { increment(); } }); } public int getCount() { return count; } public void increment() { count++; \nupdateDisplay(); } private void updateDisplay() { label.setText(\"\"+getCount()); } } Figure 1. GUI and \nmodel codetangled. but are identical in all other respects. We chose Java as the .rst guinea pig, because \nit has particularly strong static\u00addynamiccoupling,andbecauseitis amainstreamlanguage forwhichitiseasy \nto .nd existing codebases.Tobeclose to anideal secondguineapig,SubjectJ was not designed to be innovative, \nbut rather to be very similar to Java, while removing what weperceived to beJava sgreatest source of \nstatic-dynamic coupling. Theremainderof thispaperis structured asfollows.We startbypresenting a concreteexampleillustrating \nthatJava has strongstatic-dynamiccouplingandhowthis complicates remodularization. In Section 3 we describe \nSubjectJ. Sec\u00adtion4presentsthe case-study experimentcomparing remod\u00adularization in Java and SubjectJ. \nRelated work is reviewed inSection6,and weprovideconcluding statementsinSec\u00adtion7.  2. Static-Dynamic \nCoupling Example The following example illustrates the concept of static\u00addynamic coupling, and shows \nhow it complicates Java re\u00admodularization.More speci.cally, we will argue that static\u00addynamiccoupling \ncompelsJavadevelopersto adopt asolu\u00adtion that modi.es dynamic program structure, even if they only wanted \nto change static structure. The complexity of the dynamic structure transformations makes them hard to \nsupport by refactoring tools, and the developer must resort to an error-prone cut-and-paste and .x compiler \nerrors approach. Figure 1 shows a Java Counter program, which has a single Increment buttonanddisplaysthenumberof \ntimes thisbuttonhasbeenpressed. For presentation purposes, this example is deliberately simplistic, but \nits structure is representative of many real\u00ad public interface CounterListener { public void valueChanged(); \n} public class CounterModel extends JPanel { List<CounterListener> listeners = new ArrayList<CounterListener>(); \nprivate int count = 0; public CounterModel() {} public void increment() { count++; notifyListeners(); \n } private void notifyListeners() { for (CounterListener l : listeners) l.valueChanged(); } public void \naddListener(CounterListener l) { listeners.add(l); } public int getCount() { return count; } } Figure \n2. A separate model with alistenerinfrastructure public class Counter extends JPanel implements CounterListener \n{ private CounterModel count; private JButton button; private JLabel label; public Counter() { count \n= new CounterModel(); label = new JLabel(\"\"+count.getValue()); add(label); button = new JButton(\"Increment\"); \nadd(button); button.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent \ne) { count.increment(); } }); count.addListener(this); } public void valueChanged() { label.setText(\"\"+count.getCount()); \n} } Figure 3. GUIcode as a client of the model istic Java GUIs. The code that maintains the counter state \nis tangled with the GUI code. This is not good modularity, but nevertheless manyGUIs areinitially writtenin \nthis way [25].Thesimplicityoftheexamplemakesforclearerpresen\u00adtation,but may makethe problems weareabouttodiscuss \nseem trivial.We ask the readertobearin mind that,in more realistic programs, the scattering and tangling \nof UI code could span across multiple classes of considerable complex\u00adity. Now, suppose we wanted to \nremodularize this code to separate the model code from the GUI code, creating a clear interface between \nthe two code modules, while pre\u00adserving externalprogrambehavior.A typical way to achieve these remodularizationgoalsis \ntoimplement a model-view\u00adcontroller architecture, with a listener registration protocol on the model \nclass(es). The result is shown in Figures 2 and3. The type of transformation needed here implementing \nadesignpattern cannot easily bebrokendowninto refac\u00adtoring steps supportedby a typicalIDE.Therefore,typically \nan ad-hoc cut-and-paste and .x compiler errors process willbe used.Thisprocessistedious,unpredictable,and \ner\u00adrorprone. Recallhoweverthatour originalintent was to changethe coarse staticprogramstructure.As such,theimplementation \nof a listener infrastructure, which is a transformation of dynamic structure, was strictly speaking uncalledfor.At \nthe sametime,thelistenerimplementation seemstobethe main source of complexity. Tobe clear, wedo notimplythatimplementing \nalistener might notbeuseful,only thatit wasnot anexplicitly stated goal in this example. Even if we might \neventually want to move to a listener based solution, being forced to adopt a particularimplementation \nearlier than neededispoorincre\u00admentality.As such, we wouldliketo avoidits complexity,or atleastpostponeit \nuntilitis really needed. Unfortunately,inJavathecomplexityis unavoidablebe\u00adcause of strongstatic-dynamic \ncoupling:Javaimposes struc\u00adturallimitations whichimplythatthe remodularizationgoals cannot be met without \nchanging dynamic structure. The main reason is that in Java, each class declaration is con\u00adtained entirely \nwithin one .java .le. This constraint makes it as good as impossible to separate model code from GUI \ncode without creating separate runtime objects.  3. SubjectJ Inthis sectionweprovidean overviewofSubjectJ,focussing \non the aspects that are relevant for this paper. For a more detailed description of the SubjectJ language \nand tools we referto[6]. Notethatwedo notclaimSubjectJitselfas a novelcontri\u00adbution;it only serves as \naguineapig.Tobe close to anideal guinea pig, it was designed explicitly to be very similar to Java, while \nrelaxing what we perceived to be Java s great\u00adest source of static-dynamic coupling: the constraint that \na class s declaration must be wholly contained within a sin\u00adgle Java source .le. Thus, SubjectJ s primary \ndesign goal is to allow classes to be split across coarse-grained static modules. To be meaningful, we \nbelieve this goal should be achieved without diluting the module concept. This is capturedby the seconddesigngoal \nthatSubjectJ modules shouldhavewell-de.nedexplicitinterfacesthatallowhiding implementationdetailsfrom \nother modules. Finally,weadoptedtwopragmaticdesigngoals.The .rst pragmaticgoalwas thatJavaprograms shouldbe \nvalidSub\u00adjectJ programs. This allows experimentingon the same re\u00adalistic Java code bases for both Java \nand SubjectJ remodu\u00adlarization case-studies. The second goal was that SubjectJ syntax should not radically \nbreak existing Java tools in the Eclipse2 IDE.This allows the use ofEclipse tools withboth 2http://eclipse.org/ \nveri.ed December2007. @Shared public class Counter extends JPanel { private JButton button; private JLabel \nlabel; public Counter() { label = new JLabel(\"\"+getCount()); add(label); button = new JButton(\"Increment\"); \nadd(button); button.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent \ne) { increment(); } }); } @Import public int getCount(); @Import public void increment(); @Export private \nvoid updateDisplay() { label.setText(\"\"+getCount()); } } Figure 4. Version of Counter in the UI subject \ns source tree. Java andSubjectJ, so thatSubjectJ andJava are comparable in terms ofrealisticIDE support. \nThe design of SubjectJ builds heavily on the ideas of subject-orientedprogramming[17,28]andmulti-dimension\u00adal \nseparation of concerns [32]. SubjectJ is essentially a light variant ofHyper/J[31], supporting only two \ndimen\u00adsions of concern (class and subject) and a single built-in composition rule. However, SubjectJ \nmodules have explic\u00aditly de.ned interfaces and can encapsulate implementation details.In contrast,Hyper/Jhyperslices \nasdescribedin[31] donotdistinguishbetweenexported and non-exporteddec\u00adlarations,and thusdo nottruly encapsulateimplementation \ndetailsbyhidingdeclarationsfrom otherhyperslices3. Inthefollowing sections,wedescribein moredetail the \nmodular units of SubjectJ, and overview the tool support for transformingsource codein SubjectJ.We thenillustrate \nhow SubjectJ can be used for remodularizing existing Java programs. 3.1 Modular Units in SubjectJ: Subjects \nSubjectJ allows decomposing a Java program into modular units called subjects . A subject is a partial \nJava program, with a well-de.ned public interface. Figures 4 and 5 show an example of the SubjectJ code \nwe might end up with after separating the code from Figure 1 into two subjects, onefortheUI related code(Figure4) \nand oneforthe rest (Figure 5). Note that due to the simplicityof this example, each subject only containsdeclarationsfor \na single class.In general however, a subject can contain multiple partial or complete classes from different \nJava packages, and is thus representedby a sourcetree with multiple .java .les. 3Although the composition \ntools presented in [31] do not support true encapsulation ofhyperslices,thelimitationisnot aconceptual \nconstraint of theHyper/Jlanguage, andis addressedbythe composition enginedescribed in[18]. Annotation \nAttached to Meaning @Export Field, Method, Constructor The signature ofthis declaration can be importedby \nother subjects. @Import Field, Method, Constructor The signature ofthis declaration must be exportedby \nanother subject. This annotation should only be attached to method declarations without a body, and.eld \ndeclarations without an initializer. @Shared Class The class header (including extends clause, but not \nnecessarily all im\u00adplements clauses)can be shared with other subjects. Implements clauses are shared \nautomaticallyif the correspondinginterface is shared. @Shared Interface The interface header (but not \nnecessarily all extends clauses) can be shared with other subjects. Extends clauses are shared automatically \nif the correspondinginterface is shared. Table 1. Annotationsde.ninga subject sinterface @Shared public \nclass Counter extends JPanel { private int count = 0; @Export public void increment() { count++; updateDisplay(); \n} @Export public int getCount() { return value; } @Import private void updateDisplay(); } Figure 5. Version \nof Counter in the OTHER subject s sourcetree. SubjectJ syntax is essentially Java syntax with custom \nJava 1.5 annotations. The purpose of the annotations is to de.ne a subject s public interface; an overview \nof these annotations is shown in Table 1. The public interface of a subjectis independentfromJava spublic/private \nmodi.ers, and is scoped relative to subjects rather than classes. When subjects arecomposed,we verifywhethertheirinterfacesare \nconsistent with each other. The annotations make it explicit how a subject depends on other subjects, \nand also whatparts ofthe subject are visi\u00adbletoothersubjects.Forexample,inFigure4 andFigure5 the @Shared \nannotation attached to the Counter class signi\u00ad.es that the declaration of the Counter class may be shared \nby other subjects. This places the name Counter concep\u00adtuallyin apublicglobal namespace,allowing multiplesub\u00adjectstorefertoitand \ncontributetheirown .eld,constructor and methoddeclarationstothe class.Similarly,an @Export placedon a \nmember meansthe signature ofthe memberdec\u00adlaration is visible to other subjects, while an @Import on \na member means the subject depends on the signature of the memberdeclarationbeing made availableby an \n@Export from another subject. Note that although the Counter classis shared,thisdoes not mean that all \nofits members mustbe shared.For exam\u00adple,thebutton and label .elds are not exported and so they areprivate \nto theUI subject.This means that other subjects arenot allowedtohave(direct)dependenciesonthese .elds, \neventhoughthey may contribute codeto the same class. Only subjects that are declaratively complete [32] \nare considered valid. Declarative completeness means that a subject needs to include at least the signatures \nor headers of anything it depends on. This constraint ensures that a subject,although notacompleteJavaprogram,is \nrelatively self-containedand canbe understood and worked onin rela\u00adtiveisolation.Declarative completeness \nalso strengthensthe notionofsubjectinterfacesbecauseitforcesanydependency a subject has on other subjects \nto be explicitly represented by@Import or @Shared annotations. The reader may have noticed our asymmetric \ntreatment of extends clausesinclassesversusinterfaces,and theun\u00adnecessary extends JPanel clauseinFigure5thatis \na conse\u00adquenceofthis.Conceptually,SubjectJbreaksupJava classes into smaller syntactic units and allows \nthese units to be re\u00adarrangedinto subjects.Todecide on thegranularity of these units, we performed some \npreliminary experiments remod\u00adularizing Java code into SubjectJ subjects. We only broke up a unit if \nwe encountered scenarios where separating the unit across subjects would help achieve a remodularization \ngoalfromourpreliminaryexperiments.So, wedecidedto al\u00adlowindividualseparationof implements clauses(and \nex\u00adtends clausesforinterfaces),because we observed that en\u00adtire interfaces were often irrelevant to a \nsubject, but we de\u00adcided not to allow extends clauses to be separated from their class headers, because \nwe did not encounter scenar\u00adios in our preliminary experiments where a class declara\u00adtion needed tobe \nseparatedfromits superclass.We did en\u00adcounter such scenarios later on while performing the case study \nexperimentdescribedinSection4;but,having already performeda number of case studies at this time, wedecided \nnottoremovetheconstraintonseparating extends clauses. Although this constraint clearly impedes the movement \nof code undesireably,SubjectJ stilllegitimately serves as alan\u00adguage with looser static-dynamic coupling \nthan Java in our case study experiments.  3.2 SubjectJ Tools SubjectJprovides a number of toolsfor thepurpose \nof edit\u00ading, compiling,running and refactoringSubjectJprograms. Figure 6. Overview of SubjectJ tools \nDecompose, Com\u00adpose, andChecker. Figure 6 shows an overview of these tools. The following subsections \ndescribe each of the SubjectJ-speci.c tools in moredetail. 3.2.1 Compose TheCompose toolis conceptually \nvery simple:it computes the union of all its input subjects, linking any @Import to a corresponding @Export, \nandgeneratesaJavaprogram.This Java program can then be compiled and run with standard Java tools. TheCompose \ntool also checks that subjectinterfaces are beingrespected.For example, considertwoindependentde\u00advelopers \nworking on the UI and OTHER subjects. Suppose bothaddedahelper methodwithanidenticalsignaturetothe Counter \nclass.Lackingappropriate@Import and @Export an\u00adnotations,these methods shouldbe consideredhiddenwithin \ntheir respectivesubjects.Thefactthattheywouldbe mapped onto the same method declaration in the composed \nJava program violates this intent and is therefore a composition con.ict. The current implementation \nof the Compose tool checks for con.icts and issues error messages. A more so\u00adphisticatedimplementationcouldautomaticallyresolvesuch \ncon.ictsby renaminghiddendeclarations. 3.2.2 Decompose The Decompose tool is the inverse of the Compose \ntool. The Compose tool inserts subject tracking annotations into a composed program. These annotations \ntrack what subjectsthe codeinthe composedprogrambelongedto.The Decomposetooluses thisinformationtoinvertthe \ncompose operation. Anoverviewof thetracking annotationsis showninTa\u00adble2.Figure7shows the result of composingtheUI \nsubject fromFigure4 andOTHER subjectfromFigure5.Tracking annotations mark the code in the composed program \nwith @Subject({\"UI\",\"OTHER\"}) public class Counter extends JPanel { private int count = 0; @Subject(\"UI\") \nprivate JButton button; @Subject(\"UI\") private JLabel label; @Subject(\"UI\") public Counter() { label \n= new JLabel(\"\"+getCount()); add(label); button = new JButton(\"Increment\"); add(button); button.addActionListener( \nnew ActionListener() { public void actionPerformed(ActionEvent e) { increment(); } }); } @Export(\"UI\") \nprivate int getCount() { return count; } @Export(\"UI\") public void increment() { count++; updateDisplay(); \n} @Subject(\"UI\") @Export(\"OTHER\") private void updateDisplay() { label.setText(\"\"+getCount()); } } Figure \n7. ComposedJavaprogramwith Tracking annota\u00adtions. the names of the subjects they belong to. Note that \ndiffer\u00adenttypes of annotationsapply todifferentparts of the code they are attached to. For example, the \n@Export annotation on updateDisplay indicates that its signature is exported to the OTHER subject, while \nthe @Subject annotation on updateDisplay indicates thatitsbodybelongs onlytoUI. Also note that an annotationlike \n@Export(\"UI\") implies both thatthedeclarationitis attached toisimportedby the UI subject and exported \nby whatever subject it belongs to. Thisisbecausecompositionfusesimports and exportsinto a shareddeclaration.Afurtherdetail \nto noteis that anydec\u00adlaration that doesn t have an explicit @Subject is treated as having a @Subject(\"OTHER\") \nannotation.Thus,the annota\u00adtion on getCount implies that it belongs to OTHER(and is exported to UI). \nFinally, the @Implement annotation, which isnotusedinthissimpleexample,marksindividual imple\u00adments clauses. \n 3.2.3 Checker The Checker tool accepts a Java program, marked up with annotations asifproducedbytheComposetool, \nand veri.es whetherthe mark-uprepresents a validdecomposition ofthe Javaprograminto subjects.Thistoolisintended \nto support use cases where the Decompose tool is run on composed programs that were produced or modi.ed \nby the developer ratherthan theComposetool. Essentially, theChecker tool checksfordeclarative com\u00adpleteness.Thisis \na relativelystraightforward static analysis, verifying whether code marked as belonging to any given \n Attached to Meaning @Subject(S1 , . . . ) Class The class header (including extends clause but not necessarily \nimplements clauses) belongs to subjectsS1 ,. . . Interface The interface header (not necessarily including \nextends clauses ) belongs to subjects S1 ,. . . @Subject(S) Field The .eld(signature plus optionalinitialer)belongs \nto subjectS Method, Constructor The signature andoptionalbodybelong to subject S @Export(S1 , ...) Field, \nMethod, Constructor The declaration s signature is imported by subjects S1 ,. . . and is exported by \nthe subjects the declaration belongs to. @Implement(@Mapping(key=S1 , values = I 1 1 ,I 2 1 ,. . . ),. \n. . ) Class For each subject Si , only the implements clauses for interfaces I 1 i , I 2 i , . . . belong \nto Si . For subjects notexplicitly mapped, implicitlyinclude all implements clauses. Interface Like for \na class, butapplies to extends instead of implements clauses. Table 2. Tracking annotationsthat allowdecomposingJavaprogramsinto \nsubjects. subjecthas staticdependencies ondeclarations notincluded orimportedin the subject. Optionally, \ntheChecker tool can automaticallyinsert an\u00adnotationstoincludethe missing code.Thisis useful support forusecasesinvolvinguser-generatedoredited \ncomposed programs.Essentially,itallows adeveloperto only annotate the .elds, methods, and constructors \nthat belong to a given subject, and let the Checker tool infer proper subject inter\u00adfacesfrom staticdependencies. \n  3.3 Implementation The SubjectJ Decompose, Compose and Checker tools are implemented as a singleEclipseplugin.Itsimplementation \nconsists of approximately4000lines of code, of which ap\u00adproximately 300 lines implement a rudimentary \nSWT UI that lets the user launch the SubjectJ tools from within Eclipse. The running times of the tools \nare approximately linear to the size of the code base to which the tools are applied. UsingaPC with a2.13GHzIntelCore2processor \nand1GB of memory,weranthetoolsonthelargestcodebasein our case studies, with70833lines of code(seeSection4).The \nDecomposeandComposetools eachrequiredapproximately 1 minute to run, while the Checker tool required approxi\u00admately2 \nminutes to run. 3.4 Remodularizing Java Programs with SubjectJ Inthis section, wedescribethetypicalwayin \nwhichtheSub\u00adjectJtoolsjustdiscussed wouldbe usedin the use case cor\u00adrespondingto our remodularization \ncase studies: remodular\u00adizing an existing Java code base into two subjects. Variants of this use case \nto further remodularize a program already divided into subjects can also be supported, but discussion \nof themis not relevantto our experiment. Reconsider theJavaprogramfromFigure1.Suppose we wanted to remodularize \nthis, separating all UI related code into its own UI subject and keeping the remaining code in the OTHER \nsubject. To do this, we basically need to insert appropriateannotationstomarkUI related codeintheJava \nprogram, and then run the Decompose tool. The Checker tool canbe used to assistin thisprocess. For our \nexampleit mightgo asfollows.We startbyplac\u00adingfour@Subject(\"UI\") annotations:ontheconstructor;the label \nandthe button .elds; andthe updateDisplay method. Recall that everything not explicitly annotated is \ntreated as belonging to the OTHER subject. However, to make this a validdecomposition,we need moreannotationstodescribe \ntheinterfacebetweentheUIandOTHERsubject.We runthe Checker tool toinfer the needed annotations,producing \nthe mark-upshowninFigure7.RunningtheDecomposetool on thisproduces the remodularizedprogram showninFigure4 \nandFigure5.  4. Experiment We now present our case study experiment, aimed at ad\u00addressing our research \nquestion, How and to what extent does static-dynamic couplingin alanguageimpactthe com\u00adplexity of remodularizing \nprograms written in that lan\u00adguage? .In our experiment, we comparedremodularization complexitybetweenJava \nandSubjectJ, alanguagedesigned for reducedstatic-dynamic coupling comparedtoJava. To compare remodularization \ncomplexity between Java and SubjectJ, we carried out a series of 8 case studies on 8 different open source \nJava software packages. Each case study involvedperforming a remodularizationtask twice onceinJava and \nonceinSubjectJ.We then comparedthe re\u00adsultsto each other.Toquantify complexity, we measuredthe timetakentoperformthe \nremodularizations,andcountedthe numberofbugsintroduced whileperforming each remodu\u00adlarization.We alsoperformedaqualitativeanalysisfocused \non .nding anecdotal evidence of accidental complexity. Qualitative and quantitative results complement \neach other. The quantitative results provide reasonably objective evidence that remodularization is easier \nin SubjectJ, while thequalitative resultsprovideinsightinto how,byproviding concrete examplesof theproblems \nencounteredintheJava remodularizations. We startbypresentingour experimentalsetupin morede\u00adtail in Section \n4.1. We discuss the threats to validity of our experimentinSection4.2.Then wepresent thequantitative \nresults in Section 4.3, followed by the results of the anec\u00addotalanalysisinSection4.4.Conclusions andlimitations \nof the experiment arediscussedinSection4.5. 4.1 Experimental Setup For each of the 8 case studies in \nthe experiment, we se\u00adlected a different open source Java code base. Table 3 has an overview of the selected \ncode bases. We also de.ned for each case study a remodularization, which required the identi.cation and \nseparation of a certain subset of the ex\u00adisting codebase, characterizedby thehigh-leveldescription shown \nunder Code to Separate in Table 3. We de.ned an acceptable remodularization to be the creation of either \na Java package or a SubjectJ subject containing all and only theidenti.edsource code(with anyrequiredinterface \ncode). The8 casestudieswereperformedby the .rstauthorof thispaper(whowecall theprogrammer ),intheorderin \nwhich they are showninTable3.With the exceptionof the JHotDraw code base, he was unfamiliar with the \nselected codebasespriortoperformingthe experiment. For each case study the remodularization wasperformed \ntwice consecutively, once using Java and once using Sub\u00adjectJ. For the .rst 4 case studies the SubjectJ \nremodular\u00adization was performed .rst; for the last 4, the Java remod\u00adularization wasperformed.rst.Theprogrammer \nwas not al\u00adlowedaccesstoanydataorresultsproducedduring the .rst remodularizationprocess, whileperformingthe \nsecond.The programmerwas otherwise allowedto use allavailabletools, includingautomatedJava refactoring \ntoolsin aninstallation of Eclipse 3.2.2. Since SubjectJ was designed not to break existing Java tools, \nEclipse already provides some support for working with SubjectJ. However, Eclipse s Java brows\u00adingand \nrefactoringtoolsdo not understandthe semantics of SubjectJ annotations.Tobridgethisgap andprovidebrows\u00adingand \nrefactoring supportforSubjectJprograms compara\u00adble to the level of support Java programs receive from \nthe Eclipse JDT, we did two things. First, we installed version 3.1.13 of theJQuery[21] plugin and customizedittopro\u00advide \nsome rudimentary supportforbrowsing Java elements markedwith @Subject and @Export annotations.Second, \nwe allowedtheSubjectJprogrammerto usetheSubjectJtools as describedinSection3.2.Usedin this way, theChecker \nand Decomposer together function as simple refactoring tools for moving declarations from one subject \nto another with\u00adoutbreaking staticdependencies.Thisprovidesfunctional\u00adity similar to the Eclipse Move \nMethod refactoring, but withSubjectJ subjects. For each remodularization performed, we measured the total \ntime needed to completethetask, madedetailed notes of the stepsperformedduring the remodularizationprocess, \nand saved a copy of the code base upon completion of the task.Thetimedataispresented and analyzedinSection4.3. \nThe notes and saved code are thebasisfor the morequalita\u00adtive resultspresentedinSection4.4.  4.2 Threats \nto Validity Our central research question is, How and to what ex\u00adtent does static-dynamic coupling in \na language impact the complexity of remodularizingprogramswritteninthatlan\u00adguage? . In this section, \nwe discuss the construct, internal, and external validity of our experiment with respect to this researchquestion. \n 4.2.1 Construct Validity We areinterestedin the theoretical constructs of our central researchquestion \nstatic-dynamic coupling and remodular\u00adization complexity. Construct validity describes how well the variables \nand observations in our experiment map to thesetheoretical constructs.There aretwo sources ofthreats \nto the construct validity of our experiment. One is that the variable wedesignedto varyin our experiment(program\u00adminglanguage)is \nnotpreciselythetheoreticalcause wewish tounderstand(static-dynamiccoupling).Theotheristhatthe set of \noutcomes we observe(remodularizationtime, number of bugs, and anecdotal evidence) is not precisely the \ntheo\u00adretical effect we wish to understand(remodularization com\u00adplexity). First, our centralresearchquestion \nconcernstheimpactof static-dynamic coupling.To understandtheimpact of static\u00addynamic coupling in our \nexperiment, we compare two pro\u00adgramming languages Java; and SubjectJ, a language de\u00adsigned to have looser \nstatic-dynamic coupling than Java. A possible threat to constructvalidityis thatSubjectJdoes not in fact \nhave looser static-dynamic coupling than Java. An\u00adother possible threat to construct validity is that \nSubjectJ andJavadifferin more thanjust static-dynamic coupling, andthatthesedifferences canimpact remodularization \ncom\u00adplexity. We have attempted to address these threats by ex\u00adplicitly identifying and removing Java \ns greatest source of static-dynamic couplingfromSubjectJ, while otherwisede\u00adsigningthelanguagetobe very \nsimilartoJava.Asdescribed inSection 4.1, we also tried to designSubjectJ tool support tobe comparabletoJavatool \nsupportinEclipse.However, the SubjectJ and Java tools are inevitably different. Since static-dynamiccouplingin \nalanguageispartly re.ectedby its tool support, it is dif.cult to assess the extent to which tooldifferences \nare a threat to construct validity. Application and Description LOC Code to Separate Tetris game ofTetris \nhttp://cslibrary.stanford.edu/112/ 1036 GUIhandling. TyRuBa logic programminglanguage http://tyruba.sourceforge.net/ \n22116 Storingand persisting facts used by the language. JHotDraw simple drawing application http://www.jhotdraw.org/ \n14611 All functionalityfor creatingand modifyingtext .gures. Chinese Chess game ofChinese chess https://chinese-chess-xiang-qi.dev.java.net/ \n3073 Logic for AIopponent. MineRay game of minesweeper https://mineray.dev.java.net/ 3478 Logic for populatingmap \nwith mines. DrawSWF simple animation application http://drawswf.sourceforge.net/ 7540 All functionalityfor \ncreatingand modifyingtext .gures. FindBugs Java source code bug.nder http://findbugs.sourceforge.net/ \n70833 Savingofbug analysis results. JChessBoard game of chess http://jchessboard.sourceforge.net/ 6190 \nGUIhandling. All website references veri.edFebruary2008. Table 3. Overviewof selected codebases and \ncorresponding refactoring tasksfor case studies.LOCisthetotal numberof non-blank and non-commentlinesin \nthe codebase. Secondly, our research question concerns remodulariza\u00adtion complexity. To assess the extent \nof remodularization complexityin our experiment,we measured thetimetaken to complete each remodularization \ntask, and the number of bugs produced during remodularization tasks. A possible threatto constructvalidityisthatthese \nmeasurementsare not general indicators of complexity. However, to complement our reasonablyobjectivequantitativemeasurements,wepro\u00advidethequalitative \nobservations ofSection4.4 which con\u00adcern aspects of complexity that are more dif.cult to objec\u00adtively \nmeasure. Our qualitative and quantiative results are consistent with each other, togetherproviding a \nmore con.\u00addentindicator ofremodularization complexity.  4.2.2 Internal Validity There are threats to \ntheinternal validity of our experiment i.e., alternative causes (other than difference in program\u00adming \nlanguage) that could affect our observed outcomes. One source of threats comes from learning effects. \nBy per\u00adforming the same remodularization task twice, there is bias that comesfromknowledgegainedby theprogrammerdur\u00ading \nthe .rst iteration of the task. Our experimental setup addresses this by having the programmer perform \nhalf of the remodularizations using Java .rst, and half using Sub\u00adjectJ.rst.However,the strengthofthelearningbiaspossibly \nvariesdependingonwhichlanguageis .rstusedtoperforma remodularization,andthereislikely alearningbiasbased \non the order the8 remodularizations wereperformedin the ex\u00adperiment.Our analysisinSection4.3.1considershow \nthese threatslimit the scope of our conclusions. Another threatcomesfrom the comparability of the8 re\u00admodularization \ntasks given to the programmer. We address one threat in this respect, by limiting all remodularization \ntaskstobe ofthe sametype identi.cationandseparationof agivenfunctionalityfrom agiven codebase.We also \nassign similarfunctionalitiesbetweenthe set of remodularizations performedusingJava .rst,and thesetof \nremodularizations performedusingSubjectJ .rst.Inparticular,both setsof re\u00admodularizations require separation \nof GUI handling, data persistence, text .gure creation and modi.cation, and ad\u00adversarialAIlogic(population \nofgame maps, or chessplayer opponent)functionalities. Apotential threatisthedifferencein codebases associ\u00adated \nwith each remodularizationtask.Inparticular,the code bases for Java-.rst remodularizations have more \nlines of code in total than the code bases for SubjectJ-.rst remodu\u00adlarizations.Itispossible that thisdifference \ncouldintroduce bias,but an analysisinSection4.3.1 of ourquantitativere\u00adsults suggests that thisbiasislimitedfor \nour experiment. Finally, a socialthreattointernal validity comesfromthe useof the .rstauthorof thispaperastheprogrammerwho \nperformsthe remodularizationsinthe experiment.Whilethe programmer strived to not allow his role as an \nauthor bias his performance, we concede that such bias is nevertheless possible, and recognize this threat \nas a limitation of our experimental setup. 4.2.3 External Validity Externalvalidityinvolves thegeneralizability \nof our experi\u00admentresults.Our centralresearchquestionconcernsthegen\u00aderal impact of static-dynamic coupling \nin languages on re\u00admodularizationcomplexity.In our experimenthowever,we compare only two speci.c languages \n(SubjectJ and Java) thatdifferin static-dynamic coupling, and remodularization complexity is measured \nbased on tasks of a speci.c type (identi.cation and separation of a certain subset of an ex\u00adisting codebase) \ngiventooneprogrammer(the .rstauthor of thispaper).Ourresultsprovideonly oneset ofdata,and may notbegeneralizableto \notherlanguages,tasks, andpro\u00adgrammers. In particular, our results may not be generalizable to languages \nthat have static-dynamic decoupling at the sub\u00admethodgranularity,such asAspectJ[23].Eventhough our results \nsuggest that inter-type declarations probably sub\u00adstantially reduce remodularization complexity, thereislittle \ngrounds to draw similar conclusions about pointcut advice becausethesefeaturesoperateat a .nerlevel ofgranularity, \nandhave no counterpartinSubjectJ. In addition,the remodularizationtasksin our experiment were intentionally \nselected to be of a speci.c type, and as such,determining theimpact of static-dynamic coupling on other \ntypes of remodularization tasks (e.g. tasks based on concerns otherthanhigh-levelsoftwarefunctionality)would \nrequirefurtherinvestigation. Finally, a signi.cant threat to external validity is that all the remodularization \ntasks were performed by a single programmer thedeveloper of SubjectJ. Although thepro\u00adgrammer was experienced \nwith both the SubjectJ and Java languages and their refactoring tools, it is possible that he was better \nat using SubjectJ tools than Java tools. Also, different programmers could apply different programming \nstyles andproblemsolving techniquestothesameremodu\u00adlarization tasks.Experiments onlarger samples ofprogram\u00admers \nwouldproduce moregeneralizable results.  4.3 Quantitative Results For each remodularization task, we \nmeasured the total time taken to complete the task, and recorded the bugs intro\u00adduced while performing \nthe task. Taking into account po\u00adtential learning biases and other threats to internal validity described \nin Section 4.2.2, our results suggest that remod\u00adularization takes substantially less time in SubjectJ \nthan in Java. The programmer also introduced signi.cantly more bugs while remodularizinginJava thaninSubjectJ. \n 4.3.1 Time Results Table4provides an overview oftimedata,listedinthe order thecasestudieswereperformed.The \nSubjectJ and Java columns show the time taken to perform the refactoring task in the respective language. \nThe Difference column shows thedifferencebetweenSubjectJ andJava timesgiven as a percentage of the SubjectJ \ntime. A positive difference indicates that the Java remodularization took more time. A negativedifferenceindicatesSubjectJ \ntook moretime. The table is divided in two sections, based on which remodularization was performed .rst, \nimplying a different learning bias caused by performing the same task twice. Note however, that the SubjectJ \ntime is always placed in the .rstcolumn.Similarly,thedifferencecolumnisalways computedrelativetotheSubjectJtime.Thisis \nnot to suggest both sections should be interpreted in the same way, but to facilitate contrasting the \nnumbers in both sections to each other. In the top half of the table, the time differences are ex\u00adpected \nto be biased negatively, due to performing the Sub\u00adjectJremodularizationbeforetheJava remodularizationfor \neachcase study.Despitethis negativebias,thetophalfofthe table shows a positive trend in time differences: \ntwo cases yield mildlypositivedifferences,onecase a strongpositive difference, andone caseyields a mildly \nnegativedifference. The time differences in the bottom half of the table are expected to be biased positively, \nso a positive trend in this half is not surprising. However, the differences are consis\u00adtently and signi.cantlygreater \nthanin the tophalf the table. This suggeststhatthelearning advantageforthe secondit\u00aderation of ataskis \nsubstantial,and the negativebias onthe tophalf of the tableis strong. We can compute an aggregate score \nthat is not partic\u00adularly weighted towards either half of the table. The two halves of the table have \ndifferent biases, but time spent re\u00admodularizingwas almost equalinthetwohalves(63.4hours vs.66.9hours).Combiningthe8 \ncase studies, atotal of44.6 hours were spent usingSubjectJ, and85.7hours were spent using Java. Thus, \nover the entire course of our experiment, about92% moretime was spent remodularizinginJavathan inSubjectJ. \nAs we mentionedinSection4.2.2,internalvaliditythreats limitthe scope ofour conclusions.First,inlight \nof ourqual\u00aditative results (see Section 4.4), we believe that there is a strongerlearningbias whentheJava \nremodularizationisper\u00adformed .rst,asweobserved thatremodularizinginJavare\u00adquires a more in-depth understanding \nof the code base. We also believe that the programmer may have become more .uentinperformingcase studiesduringthe \ncourse ofthe ex\u00adperiment, ashebecame morefamiliar withremodularization techniques(e.g. separationstrategies \nforJava). It is also possible that bias could be introduced by the codebasesin thebottomhalf of the tablehaving \nmore total lines of code than the code bases in the top half. However, thisbiasislikelylimitedin our \nexperiment, as wedo not see a signi.cant correlationbetweenlines of code andpercent\u00adagedifferencesin \nremodularizationtime.Forinstance,the4 differencesin thebottomhalf of the table rangefrom183% to 325%, \nbut the case studies in this half with the largest codebase(FindBugs, with70833LOC) and smallest code \nbase(MineRay, with3478LOC)havedifferencesthatfallin between this range at210%and252%, respectively. In \nsummary, we believe our aggregate score of 92% should notbetakentosay anything moreprecisethan there \nis a substantial effect . In particular, this score does not al\u00ad Code Base SubjectJ (hours) Java (hours) \nDifference SubjectJremodularization performed .rst (total hours = 63.4) Tetris 3.0 3.5 +17% TyRuBa 18.0 \n20.3 +13% JHotDraw 4.2 4.0 -5% Chinese Chess 3.8 6.6 +74% Sum(1) 29.0 34.4 +19% Java remodularization \nperformed.rst (totalhours = 66.9) MineRay 0.7 2.3 +252% DrawSWF 2.0 5.8 +183% FindBugs 9.9 30.7 +210% \nJChessBoard 3.0 12.5 +325% Sum(2) 15.6 51.3 +229% Aggregatedresults (total hours = 130.3) Sum(1)+Sum(2) \n44.6 85.7 +92% Table 4. Overview oftimedata resultsfrom case studies. low us to draw a general conclusion \nthat SubjectJ cuts re\u00admodularizationtimeinhalf.In any case, evenif we consider only the .rstfourcasestudies \nwhereperforming remodu\u00adlarizationsinSubjectJbeforeJava negativelybiasedthetime differences we still see \napositive19% trend.  4.3.2 Number of Bugs Introduced Theprogrammerintroducedmany morebugs while remod\u00adularizing \nin Java than in SubjectJ4: 8 bugs were introduced inJava remodularizations, and only onebug wasintroduced \nin a SubjectJ remodularization. The manifestation of these bugsandhowtheycontributedto remodularizationcomplex\u00adityisdescribedinSection4.4.4. \n 4.4 Qualitative Results After performing each case study, we analyzed our notes and the resulting code \nbases. The main focus of this anal\u00adysis was to .nd anecdotal evidence explaining how static\u00addynamic couplingmadeperformingthe \nsame remodulariza\u00adtioninJava more complex thaninSubjectJ. Overall,theJava remodularizationprocess seemed \ncog\u00adnitivelyharder.Inboth casestheprogrammerneeded to ex\u00adplorethe codeto .ndsections relativetothe concernofinter\u00adest. \nHowever,inSubjectJ thegeneral remodularizationpro\u00adcess itself was centered almost exclusively around \nthis type of activity. This was facilitated by the use of SubjectJ Java annotations to mark code ofinterest, \nand tracking static de\u00adpendenciesusingtheCheckertool.In contrast, withstandard Java, theprogrammer neededto \nnotjustidentify code ofin\u00adterest, but also decide on a separation strategy for chang\u00ading dynamic structure \nto allow separating the code into its ownJavapackage.Thelistenerinfrastructurefrom our mo\u00ad 4Weconsideredbugstobedistinctifthey \nweredetected and .xedbetween different test runs of the application being remodularized. public class \nBugInstance { private BugProperty propertyListHead; private SAVE_BugInstance saveBugInstance; ... public \nBugInstance(...) { ... saveBugInstance = new SAVE_BugInstance(this); ... } public BugProperty getPropertyListHead() \n{ return propertyListHead; } } public class SAVE_BugInstance { private BugInstance bugInstance; public \nSAVE_BugInstance(BugInstance bugInstance) { this.bugInstance = bugInstance; } public void writeXML() \n{ ... BugProperty prop = bugInstance.getPropertyListHead(); ... } ... } Figure 8. Dual Object implementation \nof saving XML bugreports. tivating example is one separation strategy. Four additional strategies were \nusedin the case studies. Separation strategies added complexity to the Java re\u00admodularizationprocess.The \ncomplexity manifesteditselfin multiple ways: dif.culties deciding on the right strategy; complextransformationsnot \nwell supportedby available au\u00adtomated refactoringtools; and theintroduction ofbugs. We will begin by \ndiscussing different separation strate\u00adgies used in the case studies. Then we will go into each of theaboveproblemsrelated \nto using themin moredetail,il\u00adlustrating eachproblemwith anecdotesfromourcase stud\u00adies. 4.4.1 Separation \nStrategies Over the course of the 8 case studies, changes to dynamic program structure werefrequentlyneededto \nachievethede\u00adsired code separation. The need to change dynamic struc\u00adture was much more prevalent in \nthe Java remodulariza\u00adtions than in the SubjectJ remodularizations this was par\u00adtially re.ected in the \nnumber of different separation strate\u00adgies used. In the SubjectJ remodularizations, dynamic structure \nchanges were only needed when a method contained code that was related to a concern of interest, and \ncode that was not.The splitmethod strategy(supported asthe Extract Method refactoringinEclipse)was usedto \nextractthe code ofinterestinto a separate method. In the Java remodularizations, the split method strategy \nwas also needed, but four additional strategies were used. One of the strategies involved applying the \nlistener infras\u00adtructure, asin the motivating example.We nowdescribe the three other strategies. One \nstrategy, which we call dual object , is generally applicableand wasusedinevery casestudy exceptthe .rst. \nIt splits objects of agiven classinto two objects: one object containing the methods and .elds we want \nto separate, and one containingthe rest.For example,the codeinFigure8is the result of applying dual object \nto separate the writeXML methodfrom a class called BugInstance.Each BugInstance objectbecomestwo objects, \nwith the SAVE BugInstance ob\u00adjects containing the writeXML() method. The dual objects have mutualreferencesto \neachother;constructorcodeneeds tobe addedtoinitializethese references.Accessesfrom one object to the \nother are accesses to this in the original code, and needtobe updated. Another strategy, which we call \nstatic method , was used onlyintheTyRuBa case study.This strategy converts agroup ofinstance methodsfrom \nseveral classesinto a sin\u00adgle static method. The receiver object becomes one of the parameters ofthe \nstatic methodand methoddispatchis con\u00advertedto ifinstanceof tests.Thisstaticmethodcanthenbe moved around \nrelativelyfreelybecause static methodshave loose static-dynamiccoupling.This strategyavoidsthe com\u00adplexityofdual \nobject s mutual references,butislessgener\u00adally applicable itcan onlybe appliedto move methods,not instance \n.elds.Itintroducescomplexityofitsownby using ifinstanceof tests and typecasts. A .nal strategy, used \nonly in the DrawSWF case study, splits a class into a superclass and a subclass. The subclass contains \nthe .eld and method declarations that need to be separated,whilethe remaining.eld andmethoddeclarations \nstay inthesuperclass.Referencesareupdated to createand use objects of the subclass. This strategy results \nin weaker encapsulation than dual object all protected members of the superclass are exposed to the subclass; \nand multiple constructor calls must be changed to create the subclass insteadof the superclass. 4.4.2 \nDeciding on the Right Strategy When separating source code from classes in Java, it was often dif.cult \nto decide what separation strategy to use. In most cases, the programmer decided to apply the dual object \nstrategy,becausehefoundithard topredict whether allcodeofinterestcouldbecapturedbyother(possiblymore \nelegant,butlessgeneral) strategies. However, there were situations where experimentation with dual object, \nand careful consideration of strategy ben\u00ade.ts and limitations, led to the use of a different separation \nstrategy. For example, in the TyRuBa case study, the ab\u00adstract QueryEngine.getStoragePath() method (and \nevery implementation of it) was identi.ed as one of the methods to be separated from the rest of the \ncode. While starting to apply dual object, the programmer realized that addition of code in SimpleRuleBaseBucket \nto initialize its dual ob\u00adject reference would be necessary. This was complicated because this code could \nonly be placed after super() con\u00adstructor calls, causing potential problems if the dual object needed \nto be accessed during the execution of super(). To avoidpotentialproblems,theprogrammerobserved that \nno .elds needed to be moved, and decided to use the static method strategy instead. Although static method \ncaused othercomplications typecastsand ifinstanceof tests these complications seemed morepredictable. \nIn a scenario from the DrawSWF case study, separa\u00adtion of code into a subclass was chosen over the dual \nob\u00adjectstrategy.While exposingprotectedmembersfromsuper\u00adclasses to subclasses resultsin weaker encapsulation,it \nwas for this reason that the programmer chose to use subclass\u00adingin this scenario.Inparticular,theprogrammer \nneededto separate some codefrom a class which extended thelibrary class DefaultCellEditor. The code required \naccess to a protected inner class DefaultCellEditor.EditorDelegate. Theprogrammerthus neededto extend \nDefaultCellEditor in the separated code. However, applying dual object and directly extending DefaultCellEditor \nwouldinvolve many delegations between the duals, simply to override default implementations of methods \nin both classes. Noticing that the disadvantages of subclassing would be minimal in this scenario the \noriginal class extending DefaultCellEditor wasinstantiated at only oneplaceinthe code theprogram\u00admer \nchose instead to subclass this original class, preserv\u00ading implementations of overriden methods from \nthe origi\u00adnal code. In this particular scenario, applying the subclass\u00adingstrategy avoided complexitythat \nwouldbeintroducedby applyingdual object. In contrast to the above scenarios, remodularizations in SubjectJ \ndid not require making these kinds of decisions because only one strategy, split method, was ever used. \n 4.4.3 Automation of Transformations The more complex separation strategies used in the Java remodularizations \nusually involved manual transformations not well-supported by the available automated refactoring tools.In \ncontrast, the only strategy usedin SubjectJ remod\u00adularizations was the split method strategy, which is \nrel\u00adatively well-supported by Eclipse. Other program structure changesinSubjectJ remodularizationswerestaticin \nnature and well-supportedby theSubjectJ tools. Weprovideananecdotefromthe FindBugs casestudy toillustrate \nthedifferencein automated transformation sup\u00adportbetweenSubjectJandJava remodularizations.While re\u00admodularizing \nusing Java, the programmer applied the dual object strategy on 38 classes to separate their writeXML() \nmethoddeclarations.An example ofthe resulting codefrom one of the classes BugInstance is shown in Figure \n8. Lack of automated refactoring support for this strategy re\u00adquired the programmer to manually change \na large number ofdifferentplacesin the codein a coordinatedfashion. While remodularizing using SubjectJ, \nthe programmer also decided to separate the writeXML method declaration from the same 38 classes. However, \nmanual code modi\u00ad.cations were limited to adding @Subject annotations to each writeXML method. Further \ncode modi.cations were largely performed by using the Checker and Decomposer tools.While the changes \nwhere similarin extent to theJava remodularization, the programmer did not need to spend much effort \nmanuallyperforming changes. This anecdote illustrates that the difference between the SubjectJ andJava \nremodularizationsislessinthe extent of the changes thanitisinhow well the changes couldbe sup\u00adported \nby reliable automated tools. Although Eclipse has refactoringsto movemethodsand.elds,theprogrammerdid \nnot use them here because they were felt to be unreliable. Indeed, he did try to use Eclipse move refactoring \ntools in the .rst case study, but found they often introduced er-rorsintothecode.Welaterveri.ed thatthe \nmovemethod toolinEclipsepassesthe receiverobjectas an argumentto the method, essentially using the method \nas a static method. Thus,if themethodis usedin apolymorphicway,thenref\u00aderencestothemethodarenot updated.The \nmove.eld tool appears to never update references.We do notbelieve these shortcomingsarebecause ofalackofeffortonthepartofthe \nEclipsedevelopers,butratherbecause strong static-dynamic coupling makes moving instance members in Java \na com\u00adplexproblem.In comparison, movingdeclarationsbetween SubjectJsubjectsis relatively uncomplicatedbecauseit \nonly affects the(static)interfacesbetween the subjects. 4.4.4 Introduction of Bugs Table5providesabriefoverviewofthebugsintroduceddur\u00ading \nthecase studies.All9bugswereintroducedbecauseof mistakes made while making manual code changes to apply \nseparation strategies.More speci.cally,Bugs#1 to#6 were related toapplying thedual object strategy.Bugs#7 \nand#9 were caused by mistakes made when manually extracting method code. Finally, Bug #8 was related \nto applying the subclassing strategy. We now describe two bugs in more detail Bug#2,introducedduring \naJava remodularization; and Bug #9, the only bug introduced during a SubjectJ re\u00admodularization. TheprogrammerintroducedBug#2 \nwhile applyingdual object,toseparate brain codefromtheabstractclass Piece into BRAIN Piece.Thebug resultedfromforgetting \ntoprop\u00aderly initialize the references from BRAIN Piece objects to theirdual objects.Apossible causeforthisforgetfulnessis \ntheadded complexity of applyingdual objectto an abstract class: the Piece class does not(and cannot) \ncall a construc\u00adtor ofthe abstractBRAIN Piece class, sotheprogrammerwas not alertedtothelack of an explicit \nBRAIN Piece constructor bycompiler errors. Bug #9 wasintroducedby theprogrammerwhen manu\u00adally extracting \nmethod codein a situationthat was notsup\u00adportedbytheEclipse extractmethod tools.A carelessmis\u00adtake resultedin \nthe extracted method shownbelow: @Subject(\"Text\") @Export(\"OTHER\") private static DrawObject createObject2_TEXT(int \ndrawing_mode) { if (drawing_mode == TEXT) { new Text(); } return null; } Theprogrammerwrote new Text(); \nwhenheintended to write return new Text(); . The programmer was not alertedbya compilation errorbecausethe \nmethodstill ended witha returnstatement,resultingin a NullPointerException.  4.5 Experiment Conclusions \nThe case study results reported on here were focussed on the research question How and to what extent \ndoes static\u00addynamic coupling in a language impact the complexity of remodularizingprograms writtenin \nthatlanguage? .To this end, we compared remodularization complexityinJava ver\u00adsusSubjectJ.The maindifferencebetweenSubjectJandJava \nisthatSubjectJremoveswhatweperceivedtobethegreatest source ofstatic-dynamiccouplingfromJava,by allowingin\u00addividualclass \nmemberstobe moved easilyfrom one subject to another. To assess andcomparecomplexity,a series of8case \nstud\u00adies was performed. Each case study consisted of perform\u00ading a remodularization task once using Java, \nand once us\u00ading SubjectJ. Two quantitative indicators of complexity time taken and number of bugs introduced \nboth suggest that remodularizing code is signi.cantly more complex in Java than SubjectJ. The qualitative \nanecdotal analysis pro\u00advides someinsightinto the causes of the complexity. Central tothecomplexity ofJava \nremodularizationswas the use of complex separation strategies, which led to dif.\u00adculties not encountered \nin SubjectJ remodularizations. De\u00adcisions on which strategy to use were trivial in SubjectJ only one \nstrategy was used but were more complex in Java: multiple strategies were used, and, since they involve \nchangestodynamic structure,they required a moreindepth # Code Base Behavior Cause Bugs introducedduringJava \nremodularization tasks 1 JHotDraw NullPointerException Dualis referencedbefore it is created. 2 Chinese \nChess NullPointerException Reference to dualis not initialized. 3 FindBugs NullPointerException Getter \nmethod returns null instead of reference. 4 FindBugs Program freeze Getter method calls itself in.nitely. \n5 JChessBoard NullPointerException Dualof JChessBoard used before it is fullyinitialized. 6 JChessBoard \nNullPointerException Dualof History used before it is fullyinitialized. 7 DrawSWF NullPointerException \nManually extracted code from method erroneously sets local vari\u00adable to null. 8 DrawSWF IllegalArgumentException \nReference to originalclass instead of new subclass. Bugs introducedduringSubjectJremodularization tasks \n9 DrawSWF NullPointerException Manuallyextracted code from method erroneously returns null. Table 5. \nOverview ofbugsintroducedduringcase studies(arbitrarily numberedfor reference convenience). understanding \nofhow theprogram works.The extent of the changes between SubjectJ and Java remodularizations was similar. \nHowever, the more complex separation strategies used in Java remodularizations are dif.cult to support \nvia refactoring tools, and hence are typically carried out via an ad-hoc and error-prone copy and paste \nand .x errors ap\u00adproach.  5. Future Work Thispaperisfocussed speci.cally on examining theimpact of \nstatic-dynamic coupling in a language on remodulariza\u00adtioncomplexity.Theexperimental resultsarethusbased \non performing given remodularization tasks with well-de.ned outcomes.Thepaperdoes not,however,examinethe \nmoti\u00advations for performing remodularizations, nor the extent to which remodularizedcode satis.es motivatinggoals.Inpar\u00adticular,issues \nsuch astheresulting understandability,main\u00adtainability, and evolvability of remodularized code are out\u00adside \nthe scope of our central researchquestion.However, an understanding of suchbroaderissuesisimportantfordeter\u00admininghow \nour experimentalresults are relevanttopractical software engineeringprocesses. In general, it would be \nuseful to have a better under\u00adstanding of when and how purely static program structure changes are applicable. \nFor example, although our experi\u00admental results suggest that reduced static-dynamic coupling decreases \ncomplexity of remodularization tasks, dynamic structure changes have bene.ts as well. Future work could \nexaminethe resultingbene.ts anddisadvantagesfrom static versusdynamic separations of code(e.g.forproviding \nrun\u00adtime pluggability of different modules). Future work could also explorethe merits of using remodularizationto \nachieve betterincrementality.As mentionedin ourillustrative exam\u00adple of Section 2, implementing a listener \ninfrastructure is sometimes useful, depending on the broader goals behind the code restructuring. In \nsuch cases, purely static changes toprogram structure couldbe used to improveincremental\u00adity of a restructuring \neffort that eventuallyleads todynamic structure changesfor alistenerbased solution. 6. Related Work \nThis paper is about the impact of static-dynamic coupling on remodularization. Since remodularizations \nare program transformations intent on preserving program behavior, we can regardthem as a speci.c type \nof refactorings. Inthis section wediscuss relatedworkinthreebroad cat\u00adegories. In Section 6.1 we provide \na historical perspective onthe concept of static-dynamiccoupling.Section6.2dis\u00adcusses related work on \nprogramming systems that provide loose static-dynamic coupling.Finally,Section6.3discusses related work \non automated refactoring tools. 6.1 Historical Perspective An interesting point to note, is that as early \nas 1969, Dijk\u00adstra talked about language design in terms of coupling be\u00adtween static and dynamic program \nstructure and its poten\u00adtialimpact onthe understandability ofprograms[9].Dijk\u00adstra motivates structured \nprogramming, by arguing that it needs to be easy to map a program s textual structure onto the structure \nofits execution and vice versa.Essentially,Di\u00adjkstra is arguing for strong static-dynamic coupling at \nthe intra-procedurallevel. Even though our results seem to argue for loose static\u00addynamic coupling, wedo \nnotbelievetheyinherentlycontra\u00addictDijkstra s view.First, ourresults concernstatic-dynamic couplinginthe \ncontextof code restructuring,leavingques\u00adtions on understandabilityopenforfuture work(see5).Sec\u00adondly, \nwe are mainly interested in coupling at the coarse\u00adgrainedmodularlevel, notthelevel of sub-methodgranular\u00adity. \nArguably,despiteDijkstra seloquentargumentsforstrong static-dynamic coupling, we have seen a trend in \nprogram\u00adminglanguage evolution that moves awayfrom strong cou\u00adpling between dynamic and static structure \nat the coarser level. Examples include the introduction of object-oriented inheritance anddynamic methoddispatch[12]. \n 6.2 Static-Dynamic Coupling and Languages SubjectJ was designed to remove what we perceived to be Java \ns greatest source of static-dynamic coupling. Besides Hyper/J (the inspiration for SubjectJ, as we described \nin Section3),thereare many otherprogramming systemsthat can be considered to have loose static-dynamic \ncoupling. In this section we provide an overview and discuss how SubjectJrelates to these other systems. \nThe main difference between SubjectJ and Java is that it allows splitting declarations that belong to \na single class across multiple source .les. There are many other object\u00adoriented programming systems \nthat provide similar func\u00adtionality. For example, C# [19] supports partial classes. Ruby[11] allows class \nmembers tobedeclared outside of a class. Multi-methodlanguages(e.g.[5,8,7]) also decouple thedeclaration \nof methodsfromthedeclaration of classes. Someprogrammingsystemsbasedon mixins[1]provide mixin layers \nas units of modularity that crosscut classes [29,3,20].MixJuiceisbasedontheconcept ofdifference\u00adbased \nmodules[20].Theideaisthat a mixin-layer module implements a particular software feature. Each module \ncan extend existing classes or interfaces, or de.ne additional classes andinterfaces. Aspect-oriented \nprogramming languages (e.g. [23, 22, 30]) provide inter-type declarations and advice. Intertype declarations \nmakeit easy to move wholedeclarations out of classes andintoaspects,providing akind of static-dynamic \ncoupling at the granularity of member declarations, similar to SubjectJ. Aspect-oriented languages also \nprovide point\u00adcuts and advice, whichin some sense extend static-dynamic decouplingto sub-methodgranularity. \nThe above technologies differ in mechanism, but, like SubjectJ, they provide .exibility in organizing \nthe coarse static structure of the programs without changing dynamic structure.Sothisideais not new.RecallhoweverthatSub\u00adjectJ \nin itself was not intended to be a novel contribution. Indeed,tobe closeto anidealguineapig,SubjectJ \nwas not designed to add novel features, but rather to be very simi\u00adlar to Java, while removing what we \nperceived to be Java s greatestsource of static-dynamic coupling. We claim the value of our contribution \nis not the inven\u00adtion of new language features, but rather that we provided tangible evidence that existingfeatures \nwhich reduce static\u00addynamic couplingmay reduce accidental complexityfor re\u00admodularization.Thisideainitselfis \nalso not new.Infact, we believe language designers intuitively understand this. For example, theMixJuice \nauthors explicitly mention that mov\u00adingcode betweenMixJuice super-modules andsub-modules retains the \nsemantics of the code. They suggest that this could make some refactorings easier.However, asfar as we \nknowwearethe .rsttoattemptquantifying thiseffect with empiricaldata. As notedinSection4.2.3however,we \nshouldbe cautious intryingtogeneralizetoo muchfromour experiment;inpar\u00adticular, thereis littlegrounds \ntodraw conclusions about the impactofpointcutadvice on remodularizationcomplexityin AspectJ. 6.3 Refactoring \nTools Refactoringtools canprovide substantialsupportfor achiev\u00adingremodularizationgoals.Thereis alarge \namount of work directed towards providing semi-automated (e.g. [33, 34, 15]) and fully-automated [27, \n4] refactoring support for complexrefactorings.Some combinethis withprogramslic\u00ading[35] to aidinthe selection \nof what codeto extract and make refactoringtools moreprecise[14,24]. However, we believe that the level \nof support that can beprovidedby automated refactoring toolsisindirectly af\u00adfected by static-dynamic \ncoupling, because it is dependent onthe complexity ofprogramtransformationsperformedby thetools.In other \nwords, refactoringsthat require more sub\u00adtle or complex tranformations are less likely to be imple\u00admented, \nor, if they are implemented, more likely to be un\u00adreliable.Indeed, wefoundin our experiment that thediffer\u00adence \nbetween the SubjectJ and Java remodularizations was less in the extent of the changes than it was in \nhow well the changes could be reliably supported by available tools. In particular, the Eclipse IDE does \nnot provide a reliable refactoring for moving instance methods between classes. It shouldbe notedthat \nmoving static methodsdoes nothave the sameproblem.Similarly, movingmethodsbetweenSub\u00adjectJsubjectsis \nrelatively uncomplicatedbecauseit only af\u00adfects the staticinterfacesbetween subjects.ThusSubjectJis able \nto reliably support this type of transformation through tools that are of comparable complexity to toolsfor \nmoving Java static methods. Thisis notto suggestthatdevelopingreliable and sophis\u00adticated refactoring \ntools is not a useful endeavour. In fact, webelieve that work on refactoring tools, and work onpro\u00adgramminglanguagefeaturesthatreduce \nstatic-dynamic cou\u00adplingand make code easierto move, are complementaryand should go hand in hand. For \nexample, aspect-oriented pro\u00adgramminglanguages which reduce static-dynamic coupling create opportunitiesto \ncatalogue whole new classes of refac\u00adtoringsfor remodularizing codeinto aspects[26], and auto\u00admate the \nrefactoringprocess[10,15,16].  7. Conclusion In this paper we asked the following central research ques\u00adtion: \nHow andto what extentdoes static-dynamic coupling in a language impact the complexity of remodulariz\u00ad \ningprograms writtenin thatlanguage? The key contribution of our paper is that we provide experimental \nresults towards answering this research ques\u00adtion.Weperformeda series of remodularization case studies \nin both Java and SubjectJ. To be close to an ideal guinea pig, SubjectJ was designed explicitly to be \nvery similar to Java, while relaxing what we perceived to be Java s great\u00adest source of static-dynamic \ncoupling: the constraint that a class sdeclaration mustbe wholly contained within a single Java source \n.le. Our results include quantitative data suggesting that the impact of relaxing this restriction is \nsubstantial. In particu\u00adlar, analysis ofthequantitative results suggeststhatremodu\u00adlarizinginJavatakes \nconsiderably moretime and resultsin more frequent introduction of bugs than remodularizing in SubjectJ.Our \nresults alsoprovide someinsightinto how ac\u00adcidental complexity arises in remodularization of Java pro\u00adgrams \nbecause of the constraint. Speci.cally, remodulariz\u00ading in Java involves more complex separation strategies \nstrategies for changing dynamic structure solely to allow code separation. The complexity of these strategies \nis such that they are oftenpoorly supportedby available refactoring tools andhence are carriedout via \nan ad-hoc and error-prone copy andpasteand.xcompilererrors approach.  References [1] Gilad Bracha and \nWilliam Cook. Mixin-based inheritance. In OOPSLA/ECOOP 90: Proceedings of the Conference on Object-oriented \nprogramming, systems, languages, and applications / European conference on object-oriented programming, \npages 303 311, New York, NY, USA, 1990. ACM. [2] Frederick P. Brooks, Jr. No silver bullet: Essence and \nacci\u00addents ofsoftware engineering. IEEEComputer,20(4):10 19, April1987. [3] Richard Cardone and Calvin \nLin. Comparing frameworks andlayered re.nement. In ICSE 01:Proceedingsof the23rd International Conference \non Software Engineering, pages 285 294, Washington, DC, USA, 2001. IEEE Computer Society. [4] EduardoCasais. \nAutomatic reorganization ofobject-oriented hierarchies:Acase study. Object-OrientedSystems,1(2):95 115,December1994. \n[5] Craig Chambers. Object-oriented multi-methods in Cecil. In O. Lehrmann Madsen, editor, Proceedings \nECOOP 92, volume615 of LNCS,pages33 56,Utrecht, theNetherlands, June1992.Springer-Verlag. [6] RickChern. \nReducing remodularization complexity through modular-objectivedecoupling(inprogress). Master sthesis, \nTheUniversity ofBritishColumbia,2008. [7] Curtis Clifton, Gary T. Leavens, Craig Chambers, and Todd D. \nMillstein. MultiJava: modular open classes and symmetric multiple dispatch for Java. In Proceedings of \nthe Conference on Object-Oriented Programming, Systems, Languages andApplication(OOPSLA-00), volume 35.10 \nof ACM Sigplan Notices,pages 130 145, N.Y.,October 15 19 2000.ACMPress. [8] Linda G. Demichiel. Overview: \nThe Common Lisp Object System. Lisp and Symbolic Computation, 1(2):227 244, September1988. [9] Edsger \nW. Dijkstra. Notes on Structured Programming, chapter1,pages1 82. AcademicPress,1972. [10] Ran Ettinger \nand Mathieu Verbaere. Untangling: a slice extraction refactoring. In Karl Lieberherr, editor, Proc. 3rd \nInt Conf. onAspect-OrientedSoftwareDevelopment(AOSD\u00ad2004),pages93 101.ACMPress,March2004. [11] David \nFlanagan and Yukihiro Matsumoto. The Ruby Programming Language. O Reilly,2008. [12] A. Goldberg and D. \nRobson. Smalltalk-80: The Language and itsImplementation. Addison-Wesley,1983. [13] James Gosling, BillJoy, \nGuy Steele, and Gilad Bracha. The Java Language Speci.cation,ThirdEdition. TheJavaSeries. Addison-Wesley,Boston,Mass.,2005. \n[14] William G. Griswold and David Notkin. Automated assistance for program restructuring. ACM Transactions \non Software Engineering and Methodology, 2(3):228 269, July1993. [15] Jan Hannemann, Thomas Fritz, and \nGail C. Murphy. Refactoring to aspects: an interactive approach. In eclipse 03: Proceedings of the 2003 \nOOPSLA workshop on eclipse technology eXchange, pages 74 78, New York, NY, USA, 2003.ACM. [16] Jan Hannemann, \nGail Murphy, and Gregor Kiczales. Role\u00adbased refactoring of crosscutting concerns. In Peri Tarr, editor, \nProc. 4rd Int Conf. on Aspect-Oriented Software Development (AOSD-2005), pages 135 146. ACM Press, March2005. \n[17] William H. Harrison and Harold Ossher. Subject-oriented programming (A critique of pure objects). \nIn OOPSLA, pages411 428, 1993. [18] WilliamH.Harrison,HaroldOssher,andPeriL.Tarr.General composition \nof software artifacts. InWelfL\u00a8owe andMario S\u00a8udholt, editors, Software Composition, volume 4089 of LectureNotesinComputerScience,pages194 \n210.Springer, 2006. [19] Anders Hejlsberg, Scott Wiltamuth, and Peter Golde. C# Language Speci.cation. \nAddison-Wesley Longman PublishingCo.,Inc.,Boston,MA,USA,2003. [20] YuujiIchisugi andAkiraTanaka. Difference-based \nmodules: A class independent module mechanism. In Proceedings ECOOP 2002, volume 2374 of LNCS, Malaga, \nSpain, June 2002.SpringerVerlag. [21] Doug Janzen and Kris De Volder. Navigating and querying code withoutgettinglost. \nIn AOSD,pages178 187, 2003. [22] Kabir Khan, Bill Burke, Flavia Rainone, Staale Pedersen, Marc Fleury, \nAdrian Brock, Claude Hussenet, and Marshall Culpepper. JBossAOP. http://labs.jboss.com/jbossaop/. [23] \nGregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm, and William G. Griswold. An overview \nof AspectJ. In J. Lindskov Knudsen, editor, ECOOP 2001 Object-Oriented Programming 15th European Conference, \nvolume 2072 of Lecture Notes in Computer Science, pages 327 353. Springer-Verlag,Budapest,Hungary,June2001. \n[24] Raghavan Komondoor and Susan Horwitz. Effective, automatic procedure extraction. In IWPC, page 33. \nIEEE ComputerSociety,2003. [25] P. Li and E. Wohlstadter. View-based maintenance for graphical user interfaces. \nIn Proc. of the International Conference onAspect-OrientedSoftwareDevelopment,2008. [26] Miguel P. Monteiro \nand Jo ao M. Fernandes. Towards a catalog of aspect-oriented refactorings. In AOSD 05: Proceedings of \nthe 4th international conference on Aspect\u00adoriented software development, pages 111 122, New York, NY,USA,2005.ACM. \n[27] Ivan Moore. Automatic inheritance hierarchy restructuring and method refactoring. In OOPSLA,pages235 \n250,1996. [28] Harold Ossher, Matthew Kaplan, WilliamHarrison, Alexan\u00adderKatz, andVincentKruskal. Subject-orientedcomposition \nrules. In OOPSLA 95: Proceedings of the tenth annual conference on Object-oriented programming systems, \nlan\u00adguages, and applications, pages 235 250, New York, NY, USA,1995.ACM. [29] YannisSmaragdakisandDonBatory. \nImplementinglayered designs with mixinlayers. InEricJul, editor, ECOOP 98 Object-Oriented Programming, \nvolume 1445 of Lecture NotesinComputer Science,pages550 570. Springer,1998. [30] OlafSpinczyk,AndreasGal, \nandWolfgangSchr\u00a8oder-Preikschat. AspectC++: An aspect-oriented extension to the C++ programming language. \nIn Proceedings of the Fortieth International Conference on Tools Paci.c, pages 53 60.AustralianComputerSociety,Inc.,2002. \n[31] P.TarrandH.Ossher. Hyper/J userandinstallationmanual. Technical report,IBMT.J.WatsonResearchCenter,2000. \n[32] Peri Tarr, Harold Ossher, William Harrison, and Stanley M. Sutton, Jr. N degrees of separation: \nMulti-dimensional separation of concerns. In Proceedings of ICSE 99, pages 107 119, LosAngelesCA,USA,1999. \n[33] FrankTip. Refactoring using type constraints. InHanneRiis Nielson andGilbertoFil\u00b4e,editors, SAS, \nvolume 4634 of Lecture Notes in Computer Science, pages 1 17. Springer, 2007. [34] LanceTokuda andDonS.Batory. \nEvolving object-oriented designs with refactorings. In Proceedings of Automated Software Engineering,page174,1999. \n[35] Mark Weiser. Program slicing. IEEE Transactions on Software Engineering,SE-10(4):352 357,July1984. \n \n\t\t\t", "proc_id": "1449764", "abstract": "<p>We explore the concept of <i>static-dynamic coupling</i>--the degree to which changes in a program's static modular structure imply changes to its dynamic structure. This paper investigates the impact of static-dynamic coupling in a programming language on the effort required to evolve the coarse modular structure of programs written in that language. We performed a series of remodularization case studies in both Java and SubjectJ. SubjectJ is designed to be similar to Java, but have strictly less static-dynamic coupling. Our results include quantitative measures-time taken and number of bugs introduced--as well as a more subjective qualitative analysis of the remodularization process. All results point in the same direction and suggest that static-dynamic coupling causes substantial accidental complexity for the remodularization of Java programs.</p>", "authors": [{"name": "Rick Chern", "author_profile_id": "81381593781", "affiliation": "The University of British Columbia, Vancouver, BC, Canada", "person_id": "P1223195", "email_address": "", "orcid_id": ""}, {"name": "Kris De Volder", "author_profile_id": "81100389193", "affiliation": "The University of British Columbia, Vancouver, BC, Canada", "person_id": "P1223196", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449786", "year": "2008", "article_id": "1449786", "conference": "OOPSLA", "title": "The impact of static-dynamic coupling on remodularization", "url": "http://dl.acm.org/citation.cfm?id=1449786"}