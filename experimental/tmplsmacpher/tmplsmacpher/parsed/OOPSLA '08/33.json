{"article_publication_date": "10-19-2008", "fulltext": "\n ATag-BasedApproachfor theDesignandCompositionof InformationProcessingApplications Eric Bouillet,MarkFeblowitz,ZhenLiu,Anand \nRanganathan,Anton Riabov IBMResearch {ericbou,mfeb,zhenl,arangana,riabov}@us.ibm.com Abstract Inthe \nrealm ofcomponent-based software systems,pursuers of theholygrail of automated application compositionface \nmany signi.cant challenges. In this paper we argue that, while the general problem of automated composition \nin re\u00adsponsetohigh-levelgoal statementsisindeed very dif.cult to solve, we can realize composition in \na restricted context, supporting varying degrees of manual to automated assem\u00adbly for speci.c types of \napplications. We propose a novel paradigm for composition in .ow-based information pro\u00adcessing systems, \nwhere application design and component development are facilitated by the pervasive use of faceted, tag-based \ndescriptions of processing goals, of component capabilities, and of structural patterns of families \nof appli\u00adcation.Thefacets andtags representdifferentdimensions of both data and processing, where each \nfacet is modeled as a .nite set of tags that arede.nedin a controlledfolksonomy. All data .owing through \nthe system, as well as the func\u00adtional capabilities of components are described using tags. A customized \nAI planner is used to automatically build an application, in the form of a .ow of components, given a \nhigh-levelgoalspeci.cationintheform of a set oftags.End\u00adusers use an automaticallypopulatedfaceted search \nand nav\u00adigation mechanism to construct these high-level goals. We also propose a novel software engineering \nmethodology to design anddevelopa set of reusable, well-described compo\u00adnents that can be assembled into \na variety of applications. With examples from a case study in the Financial Services domain, we demonstrate \nthat composition using a faceted, tag-based application design is not only possible, but also extremely \nuseful in helping end-users create situational ap\u00adplicationsfrom a wide varietyof available components. \nPermission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithout \nfeeprovidedthat copies arenotmadeordistributed forpro.t orcommercialadvantageandthatcopiesbearthisnotice \nandthefullcitation onthe.rstpage.To copy otherwise,to republish,topostonserversorto redistribute tolists, \nrequirespriorspeci.cpermission and/ora fee. OOPSLA 08, October19 23,2008,Nashville,Tennessee,USA. Categories \nand Subject Descriptors H4.0 [INFORMA-TIONSYSTEMSAPPLICATIONS]:General General Terms Algorithms,Design,Experimentation \nKeywords Composition, Programmable Web, Tag Cloud, Automated Application Assembly, Tag-based Component \nDescription,ComponentReuse,FacetedNavigation 1. Introduction Composingsoftware applicationsfrom componentshaslong \nbeen a topic of interest and research. Notions of operator composition were established well before the \nintroduction of pipes into UNIX in 1972 [26]. This theme has resur\u00adfacedrecently,in theform of web service \ncomposition tech\u00adniques[14] andinhosteddata mashup systems such asYa-hooPipesTM[1]andIBM R @DAMIA[3].Eachapplies \nrecent advances in service descriptions, graphical editing, etc., to the problem of composing applications \nfrom components, withthegoals of enabling automated composition or simpli\u00adfying manual composition. Yet \nmany of the familiar challenges in architecting and engineering component-based applications remain: \nthe need to partition application code into scalable and/or reusable components, the need to provide \nsuf.cient descriptive con\u00adtentsuch thatsomeagent -humanorautomated -cancom\u00adpose applications from these \ncomponents, etc. Advances in object-oriented computing [2] support the de.nition of abstract component \ninterfaces. But composing applications from software components requires more descriptive con\u00adtent than \ncan typically be gleaned from components inter\u00adfacedeclarations.For component selection[29] andfor ap\u00adplication \ncomposition[12], additionalknowledgeis needed -of the components functional capabilities, of constraints \non each component s applicability for a particular task, of the rules of assembly with other components, \netc. The key challenge remains: .nding a practical means of expressing, formally orinformally,just the \nright amount ofinformation at the right level of detail and/or abstraction to convey to the application \nassembler the information that can assist in composition of the best component assemblies for a given \nCopyright c &#38;#169;2008ACM978-1-60558-215-3/08/10...$5.00 task. Even withthe neededdescriptive content, \nsimplydescrib\u00ading components does not ensure their broad applicability across more than a few component \nassemblies, or their ap\u00adpropriate useinagiven assembly.Theprocess of architect\u00ading and composing component-based \napplications requires attention notjust toindividual components,but requires a broader perspective on \nthe evolving collection of compo\u00adnents, which rangefromdomain-speci.c to widely reusable components, \nand to the various applications that will incor\u00adporate these components. In other words, there must be \na careful design and engineering process to come up with a set of reusable components that can be combined \ntogether intoalargenumberofdifferent .ows. In this paper we present a new methodology that we de\u00advelopedforfacilitating \nthedesign and composition of .ow\u00adbased information processing applications. Flow-based ap\u00adplications[16] \nare component assemblies arrangedin adi\u00adrected acyclic graph (.ow) of black-box components con\u00adnected \nby data .ow links (Figure 1). Systems like Yahoo Pipes andIBMDAMIAsupportthe creation ofdata mashups \nas .ow-based applications.Streamprocessing systems(like System S [9]) also support .ow-based applications \nthat continuously process streaming data. Acyclic work.ows in service-oriented systems can also be viewed \nas .ow-based applications, where services exchange messages amongst one another either directly or through \na coordinator service (like aBPELwork.ow). At the core of our approach is a novel tag model where domain-speci.c \ntags, organized into facets, are used to de\u00adscribe1) end-userinformationprocessinggoals,2) compo\u00adnentfunctionalprocessing \nanddata semantics, and3) appli\u00adcation requirements and structural constraints. The promi\u00adnent role that \ntags and tag-based descriptions play in all three areas establishes a strong visible thread from users \ninformationneedstodynamically assembled .ow-based ap\u00adplications. Our application design methodology makes \nuse of the tag-based model to capture application requirements and subsequently identify requirements \nfor individual com\u00adponents. Our composition approach makes use of the tags to decide whether certain \ncomponents can be composed to\u00adgetherintoa .ow. To support .ow composition, we have developed tools that \ncan process component descriptions and can aid in the process of composing the applications. The composition \nprocess canbe manual, completelyautomated or assisted.In manual composition, an end-user(ordeveloper) \nconstructs the .owby connecting compatiblecomponentsusing anin\u00adteractive editor. In completely automated \ncomposition, the end-user can specify aprocessinggoal, whichgets compiled into a .ow. Assisted composition \nallows users to come up with a .ow by interweaving automatic .ow generation and manual editing. While \nourprevious work, embodiedin atool calledMARIO(MashupAutomation withRuntimeOrches\u00adtration andInvocation)[25],focuses \non automating mashup composition and userinterfacegeneration, our methodology is suitablefor anykind \nof composition approach. Thekey contribution of thispaperis a tag-based applica\u00adtion design methodology \nthat facilitates the composition of customized .owsthat satisfy end-usergoals.Theaimof the application \ndesign methodology is to come up with a set of reusable, well-described components that can be combined \ntogether into a wide variety of .ows. We describe the need for specifyingcomposition constraints(Section2),introduce \nthe terminology(Section3),describe the software engineer\u00adingprocess(Section4),formally describethe models(Sec\u00adtions5and6), \nand.nally, compareour approachwithrelated work(Section7).  2. Motivation -TheRoleofComposition ConstraintsinSituationalApplications \nThe emergence of data mashups offers renewed promise in the oft-revisited .eld of component-based application \nas\u00adsembly. Yahoo Pipes, IBM DAMIA, etc., offer graphical tools to compose applications from web-based \ndata sources and from a .xed set of components. These systems aim to address the need for situational \napplications, end-user drivencomputing thatCherbakov[6]describesas applica\u00adtionsbuiltto address aparticular \nsituation,problem, or chal\u00adlenge. Situational applications are usually built by casual programmers usingshort,iterativedevelopmentlife \ncycles, are updated frequently as needs evolve, and are often aban\u00addonedinfavor of new solutions. Assemblingsituationalapplicationsfrom \ncomponentsbe\u00adcomes easier with tools that assist in the assembly of com\u00adpatible components into functioning \ncompositions. In prac\u00adtice, though, even with tool support, the large number of available components \nand the high complexity of composi\u00adtion constraints make manual assembly adaunting task. In existing \nsystems, component composition constraints are commonlyspeci.edbypublishingcomponentinterfaces, andby \nstricttyping ofinput and outputparameters.In .ow\u00adbasedapplicationsthis approach translatesto stricttyping \nof the data that is ingested into and produced by each compo\u00adnent.However,practicalimplementations ofthe \nstricttyping approach can sufferfrom either under-or over-speci.cation. Under-speci.cation occurs when \nthedata typedoes not suf\u00ad.ciently capture the semantics, and therefore the constraint is not restrictive \nenough.For example, a component thatin\u00adputs an integer can be connected to a variety of inputs that are \nintegers, such as temperature, humidity, etc., while the component may expect the integer to represent \nthe age of a person. Over-speci.cation occurs, e.g., when one de.nes atypethatistoonarrowly scoped,inadvertentlyprecluding \nlegitimate uses ofthe component.Theseproblems clarifythe needfor another mechanism of expressing composition \ncon\u00adstraintsin addition to strict typing.Designing such a mecha\u00adnisminaway thatis .exibleand easy touseisasigni.cant \nC u r r e n t F o r e c a s t  Figure1. Flowexampleforthe RelativeHumidity IA WeightedAverage GFS Eta \ngoal challenge. We address this by using tags, as we explain in followingsections. When composition constraints \nare well speci.ed, it can bepossibleto compose applications automatically for user\u00adspeci.ed composition \ngoals, using constraints to guarantee application correctness.MARIO, an example of such a sys\u00adtem,is \ncapable ofpractical, real-time automatic composition for .ow-based applications.InMARIO, users specify \ncom\u00adposition goals using tags. The set of tags available for user selectiondepends onthe set ofcomponents \nandcomposition constraints.Onlythetagsthat correspondto supportedgoals are presented to the end user, \nlimiting the choices to those applications satisfying all constraints. MARIO also ranks alternative compositions \nthat satisfy the speci.ed goals, presents thebest match to the user, andprovides a clustered view of \nalternatives. Fully automatic composition has many bene.ts, includ\u00ading automatic adaptation to changes \nin the set of available components and signi.cant simpli.cation for the end user. In some cases, however, \nthe composition constraints may notbe speci.edpreciselyenoughto achievefullautomation. In these cases, \nan approach that combines manual and auto\u00admaticdecisions can still take advantage of the constraints \nto assist the enduser.  3. Overview:ThePervasiveUseofTags To respondto users urgentneedsfor an expandingvarietyof \nsituationalapplications, our workfocuses on waysto support the composition ofcomponentsinto .ow-basedapplications, \nasdepictedinFigure1. Our approach to composing these applications relies on the use offaceted,tag-baseddescriptions.We \nusetags, asso\u00adciated with organizingfacets, todescribe theprocessinggoalsfor an application  the application \nsdata  the application s components  the structure offamilies ofrelated applications  Processing in \n.ow-based applications is performed by a graph of interconnected components, each transforming input \ndata to output data. At a syntactic (code) level, the compatibility of each component is typically de.ned \nand constrained using types declared in component interfaces and used in, e.g., method invocations. But \ncombining these componentsintofunctioning assembliesrequires morethan syntactic compatibility -it also \nrequires knowledge of the component s semantics, not typically available at the type level.Forthelatter, \nwe relyontag-basedcomponentdescrip\u00adtions.Eachcomponent sinputs andoutputs aredescribedby (likelydifferent)sets \nof tags. The .owdepictedinFigure1mighthavebeenassembled for a commoditiesbroker, whois concerned with \nrisks asso\u00adciated with commodity prices for, say, corn. She identi.es weather as a natural hazard, potentially \nposing an invest\u00adment risk(or opportunity).Figure2 shows some examples offacets relevant to thisdomain(Forecast \nMetrics, Geopoliti\u00adcal Regions, etc.)as wellas some examples oftagsbelonging to thesefacets(RelativeHumidity, \nBostonMetro, etc). Thesefacets and tagsplay a central rolein the speci.ca\u00adtion of users processinggoals,in \nthedescription of compo\u00adnents, and in the assembly of components into .ow-based applications. In addition, \nthey can be used in pattern tem\u00adplates thatguidein theprocess of architecting, engineering, and testing.ow-based \napplications. 3.1 Tag-BasedGoals Any given .ow-based application can be thought of as achieving some \nprocessing goal, typically the production of some kind of information needed by the user. In typical \ninformation systems, users express their information goals as queries against some data store. Some query \nprocessor takes that query, interprets embedded operations possibly optimizing toimproveaccess and thenexecutesthequery. \nOur approach is centered around the users expression of a goal to be achieved by some composed .ow. Goals \nrequire neither the identi.cation of the information source(s) nor thedescription ofthe means of retrieving \nandprocessingthe data.Thus,ifthe user wants an estimate ofthe size andspeed of a hurricane, she would \nexpress that and only that. How the result is determined whether using a .ow that draws theanswerfromsomeweb \nserviceorusing a .owwith com\u00adponents that examine satellite imagery would depend on which components \nwere available and tagged as delivering thisinformation,and which .owisdetermined best (by some measure \nof best ). While most users .nd it challenging to craft some for\u00admal description of their information \nneeds, many are quite comfortable withfaceted navigation.Look at any web-based shopping experience and \nyou ll see some form of faceted navigation of tags that quickly leads a potential customer from a vague \nnotion of shoes to browse to the style, size, and color of the shoes Igotta have. The same mechanism \ncanbeusedbyaninformation analystwho seeksinformation to inform some important decision. Thus, users formulate \ntheirprocessinggoals as simple collections of tags,possibly accumulated with thehelp of afacetedbrowsinginterface. \nFor example, a commoditiesbroker might want to watch for projected extremes in relative humidity that \nmight indi\u00adcate a drought, indicating an opportunity to trade corn fu\u00adtures. She would express this as \nthe goal RelativeHumidity, IA, WeightedAverage, GFS, Eta, ContourMapView, which rep\u00adresents a requestfor \na .owthatdeliversthe relativehumidity forecast for the state of Iowa, based on the weighted aver\u00adage \nof the forecasts as projected by two weather models, NOAA s GFS and Eta forecast models, respectively \n[17], presentedon a contour map.Shehas requested the weighted average of two different predictions, based \non two forecast models,perhaps to arrive at a morepreciseprediction. Thisgoalformsthebasisforcomposing \nthe .owinFig\u00adure1(any .owsatisfying thisgoal mustcontainthesetags, according to the composition modeldescribedin \nsection5). This particular .ow takes in raw data values from differ\u00adent sources andprocesses them toproduce \nthedesired result data. In the case of automated composition, agoal-driven user interaction paradigm \nshields the end-user from the com\u00adplexities of manually composing appropriate .ows. Using Figure 2. Example \nof faceted navigation menu and user\u00adselected, tag-basedgoal tag-based goals is appealing in its simplicity; \neven non\u00adprogrammers can easily constructgoalby selecting a set of tags. One effect of using tag based \ngoals is the potential am\u00adbiguity in interpreting a set of tags. The same set of tags can be interpreted \nin different ways by different users. We tackle this problem, in part, through a user-interface that \nshows(and speaks) a naturallanguageinterpretation of the goal from the set of tags, so as to provide \nfeedback to the end-user onhow the systeminterprets thegoal.In addition, theinterfacegenerates a naturallanguagedescription \nof the composed.ow sothatthe user canget anidea oftheprocess\u00adingperformed togenerate the results, as \nwell as the speci.c properties ofthe results. Figure 2 shows one of our faceted navigation inter\u00adfacesthatguidesthe \nuserinformulating agoal.Navigating through afaceted collection oftags, our commoditiesbroker clicks on \nany of the unexpandedfacets(depicted on theleft) to reveal a cloud oftags organized under thatfacet(depicted \non the right).1 1Note that some tags arelarger,indicating that they are relevant to alarger number of \nuser-speci.ablegoals. These tags appear in the faceted tag cloud because they are associated with information \nthat can be produced by at least one .ow built from a library of tag-described compo\u00adnents.Thatis,some \n.owiscapableofproducing RelativeHu\u00admidity, another is capable of producing a WeightedAverage, etc. The \nfact that all of the tags in the aforementioned goal arejointly selectableisbecause atleast one .ow canbe \nas\u00adsembledproducing information satisfying this collection of tags.Inthiscase,the .owdepictedinFigure \n1 wasselected by MARIO as the best assembly of known components to satisfy the user-speci.edgoal. As \nthe comodities broker selects the tags in any order the selected tags are added to the goal. As with \nfaceted catalog navigation, selection of these tags successively re\u00ad.nes thegoal.Asking merelyfor RelativeHumidity \nresultsin theassembly of alargenumberofdeployable .ows,each of which wouldproduce relativehumidity values, \nusing various models, for various forecast timeframes, etc., in the same way asking for running shoes \nwould display pages upon pages of shoesin all available sizes, colors,....Thekey for the useris to navigate \nto thedesired re.nedgoal,preferably with a minimum of clicks; thekeyfor application architects and component \ndesigners is to craft the components, their descriptive tags, and the organizing facets, such that users \ncan quickly pick the tags needed for their speci.c process\u00ading needs, resulting in one or more processing \ngraphs that ful.lls those needs. Theresult ofdeploying and running this .owmightlook like the marker \nmapin upper rightpanel ofFigure3.  3.2 TagsforComponentDescription Brie.y, componentdescriptions areblack-boxfunctionalde\u00adscriptions, \nusing tags to identify each component s applica\u00adbilityto sometask(s).We usetaxonomicallyarrangedtagsto \ndescribe a component sinputdata requirements, outputdata capabilities, and, in some cases, con.guration \nparameters. Using this information, .ows can be assembled to achieve some tag-described processing goals, \nconnecting a collec\u00adtionof componentsby associating thetagsdescribing some components outputs to tags \ndescribing other components inputs.Matching canbe either adirect match(Temperature = Temperature)or a \ntaxonomic match(Temperature satis.es WeatherMetric), since the latter is a parent tag of the for\u00admer \n-see .gure 4(c). Bothdomain-speci.c analytic components(e.g., weather or .nancial models) and generic \ncomponents (averages or comparisons of time series data), can be assembled into multiple .ows, each representing \nalternative means of ad\u00addressing aparticularprocessinggoal.MARIOperforms this assembly automatically, \nusing a planner, presenting multi\u00adple alternative componentassembliesfor agivenprocessing goal. Figure \n4 shows the tagging and assembly of a subset of the components in the Figure 1 .ow, with a simpli.ed \nsub\u00adset of the the components tags:4(a) shows the components and their tagging, 4(b) shows the assembly \nof the compo\u00adnents into a sub.ow, and 4(c) shows a fragment of the tag taxonomy. TheinputtotheRelativeHumidityCalculatorcomponent \nis tagged with Temperature and Dewpoint,indicating that,in order to calculate a relativehumidity value,both \nmetrics are needed.The outputis tagged with RelativeHumidity,indicat\u00ading that the component produces \na RelativeHumidity output, for consumption by some down-.ow component. So, the Relative Humidity Calculator \ncomponent canbeassembled with some up-.ow componentifthat up-.ow componenthas atleast one output tagged \nasproducing atleast Temperature and Dewpoint. The Weighted Average for Two Weather Metrics compo\u00adnenthastwoinputs, \neachdescribed with a WeatherModel tag and a ?WeatherMetric variable. It also has a single output described \nwith a WeightedAverage tag and a ?WeatherMetric variable.Asdepictedin4(c), the ?WeatherMetric variableis \nof type WeatherMetric and thus can be replaced by the tag Temperature, Dewpoint, or RelativeHumidity. \nNote that the variable also establishesthe constraintthatthe ?WeatherMet\u00adric variable on the twoinputs \nand the one output mustbe re\u00adplaced with thesametag inthiscase,the RelativeHumidity tag.(For a moreformal \ntreatment, see section5.) Inassemblingthe .owinFigure1 thesetwocomponents canbe assembledintothethree-component \nsub-.owin4(b), to produce the weighted average of relative humidity pre\u00addictions across the GFS and Eta \nmodels 1) because the Rel\u00adativeHumidity output of each Relative Humidity Calculator instance satis.es \nthe ?WeatherMetric constraint on each of the inputs of the Weighted Average for Two Weather Met\u00adrics \ncomponent, and2)because the GFS and Eta tags,prop\u00adagated from somewhere up-.ow, satisfy the WeatherModel \nconstraint on eachinput. The propagation occurs because some up-.ow compo\u00adnents (speci.cally, the NOAA \nGFS Forecast Data and the NOAAEtaForecastDatacomponents)introducedthosetags anddeclaredthem as sticky \ntags (oftype StickyTag).Bydo\u00ading this, these WeatherModel tags are automatically propa\u00adgated from the \npoint of introduction down the .ow to the right-most components outputs. Similarly, the Temperature and \nDewpoint tags are propagated from each of the Parse Temperature,DewpointForecasts components. This is \none of a family of propagation mechanisms that are key to allowing general-purpose components, such as \nthegeneric RelativeHumidityCalculator,tobeinsertedinto a speci.c .ow, without requiring any modi.cation \nto the generic component sdescription(in spite ofthefact that the tagis neededdown-.ow).So,for example, \nwedo notneedto create a special-purpose Relative Humidity Calculator that includes aWeatherModel tag \nonitsinput and outputdescrip\u00ad  Figure3. MARIOUI:GoalComposition(ul),Facets&#38;Tags(ll),AssembledFlow(lr), \nandProcessingResults(ur) tions,justbecausetheWeightedAveragecomponent requires a WeatherModel input.Stickytagpropagationhandles \nthat. 2 The tagsdepictedhere aredescriptive of theinformation .owing between components. Tags can also \nindicate the state ofprocessing of somepiece ofdata.Thetags can mean anything thedescription authordesires,but \nmustbe applied with caution,sinceeach tagin.uences .owassembly.So,a carelesslyplacedtag canleadtopotentiallymanyincorrectly \nassembled.ows, ortothe non-assemblyofotherwise correct .ows. There is a direct link here between the \nusers collective processing needs and the architects design of the associ\u00adated application.The same tags \nare navigatedby the userin formulating aprocessinggoal and also todescribe the com\u00adponents functional \ncapabilities. Thus, there is a necessary andproductiveinteractionbetweenthe users application re\u00adquirements \nand the application architects designs. Simply 2However, the programming model or the deployment infrastructure \n must support thepass-through of suchdata. put,this tag-centric approachforcesthe components design tobe \naligned with users information requirements.  3.3 ToolingforApplicationComposition So far, we have shown \na glimpse of faceted navigation of tags(Figure2), ahand-drawn example of an automatically generated .ow \n(Figure 1) and, in the introduction, a brief mention of mash-up visualizations of the .ows outputs. Each \nof these elements has been implemented in MARIO, one example of a system that supports the composition \nand deployment of .ow-based applications. This tooling provides support for a spectrum of compo\u00adsition \nmodes covering manual,partially automated(mixed initiative) and fully automated composition. The formally \nspeci.ed composition constraints, expressed in tag-based descriptions enable automated assembly, canguidepartially \nautomated assembly, and can help eliminate mistakes in manual and partially automated composition, depending \non the quality of component descriptions and the level of end user s understanding ofindividual component \ncapabilities.   T e m p e r a t u r e G F S D e w p o i n t R e l a t i v e H u m i d i t y  T \ne m p e r a t u r e D e w p o i n t W e i g h t e d A v e r a g e  R e l a t i v e H u m i d i t y \nG F S ? W e a t h e r M e t r i c E t a W e a t h e r M o d e l W e i g h t e d A v e r a g e T e m \np e r a t u r e ? W e a t h e r M e t r i c D e w p o i n t E t a T e m p e r a t u r e ? W e a t h \ne r M e t r i c  D e w p o i n t W e a t h e r M o d e l  (a) Taggedindividual components (b) Assembled.ow \n (c) Tagtaxonomyfragment, with variable typedeclaration Figure4. Assemblinga .ow usingtagged components \nFigure5depicts an architecture that supports a combina\u00adtionofautomated.owgeneration(left side)andmanualand \nmixedinitiative .owcomposition(right side). Goal Formulation UI Flow Execution Runtime Figure5. Flow \ncomposition anddeployment architecture 3.3.1 AutomatedComposition Inthefullyautomatedmode, .owsarecreatedanddeployed \nautomatically. The end user of the generated .ow does not need to understand the functionality of individual \ncompo\u00adnents. His central focus is on expressing processing goals, usingtagsdrawnfromfamiliar vocabularies. \nFor automatedcomposition,the FlowComposer consults a repositoryoftag-basedcomponentdescriptions andgener\u00adatesasetofallpossible \n.ows.TheFlowComposeralsogen\u00aderates a faceted tag cloud containing any tag that describes anycomponentinthe \nsetofgenerated.ows.Thetagcloudis sent to the Goal Formulation UI, whichpresents to the user a means of \nnavigating the facets and tags needed to spec\u00adify aprocessinggoal(.gures2 and3presenttwo views of one \nsuch UI). With each subsequent tag selection, the goal is expanded. The Flow Composer generates a new, \nsmaller set of .owsnarrowing thescopetothose .owsthatproduce the tags in the expanded goal and regenerates \nthe tag cloud accordingly. In apartially automated composition scenario, the appli\u00adcation .ow can be \npartially assembled automatically based on speci.ed goals, and later manually changed by the user before \ndeployment and execution. This approach requires enduserstohave abetter understandingofcomponentfunc\u00adtionality, \nbut can tolerate less precise component descrip\u00adtionsfromdevelopers. The Goal Formulation UI also displays \nthe the best .ow for the given goal (Figure 3) as determined by the Flow Composer, selected based on \na combination of result quality and resource consumption metrics. When the user has selected the tags \nexpressing her processing goal and is satis.ed with the generated .ow, she can push a button and the \ngenerated .ow is deployed to, and run in, the Flow ExecutionRuntime. Note, inFigure3, that theFlowComposerhasproduced \n47 alternative .ows. Including the .ow displayed, there are 48possible.owsforthegoal IA, RelativeHumidity, \nWeighte\u00addAverage, Eta, GFS. This is because the goal is general enough that there are many possible ways \nof achieving it. The user can explore these possible .ows by selecting ad\u00additional tagsfrom thedisplayed \ntag cloud.For example, the user can select additional Geopolitical Region tags to indi\u00adcate she wants \nthe results for multiple US States. The user  Figure6. Alternativeplansfor selectedgoal tags can also \nselect additional forecast metrics, like HeatIndex, for calculation and display. 3 The goals and the \nranks for some of the alternative .ows are shown in Figure 6. In this case, the ranks are obtained based \non a cost metric, where every component is associated with a cost, and the cost of an applicationis the \nsum of the costs of theindividual com\u00adponents. Our composer can support other de.nitions of the cost \nmetric as well[24]. Also note that the composerhasincluded Current (mean\u00ading current as opposed tohistoricaldata), \nNOAA, Dewpoint, and Temperature in the Current request and its interpreta\u00adtion. These are the remaining \ntags that describe the auto\u00admatically selected .rst-choice .owbutthat werenot explic\u00aditly requestedby \nthe user.Inthis case,thegoalisjust what the user wanted, and afew clicksless than mighthavebeen needed.If,however, \nthe userinstead wantedto resultsbased onhistoricaldata, she could explicitly select, e.g., TwoDays-Back \n(overridingthe composer-selected value of Current ), and thegenerated .owwould re.ectthat request.  \n3.3.2 Manual andAssistedComposition Manual and mixed initiative composition modes come into play when \na user wants or needs to manually compose or alter a .ow. This might arise for the application architect, \nwhensheisexperimenting with newcomponentsor .owsor needstoalterexisting.owstore.ect newapplicationneeds, \nor when a known composition is required but somehow is not supportedin the tags. In such cases the .ow \ncomposition is de.ned using the EditorUI, eitherfrom scratch or as aderivation of agener\u00ad 3This might \nsound complicated, but the faceted navigation mechanism simpli.es the user experience to something much \nlike the shoe shopper experiences whenlooking at various sizes or styles of shoes. ated .ow. In the partially \nautomated composition scenario, the application s components canbepartially assembled au\u00adtomatically,based \non speci.edgoals, and manually changed bythe userbeforedeploymentand execution.This approach can tolerate \nless precise component descriptions, but re\u00adquires the end user to understand component functionality, \nsomething not requiredin thefully automated case.  4. OverviewofSoftwareEngineering Methodology The \nmainpurpose ofour software engineering methodology is to build a library of reusable components that \ncan be as\u00adsembledintodifferent applications.AsintroducedbyPrieto\u00adD\u00b4iaz[19],faceteddescriptions canbe \nusedto aidinthe clas\u00adsi.cation and retrieval of components. For purposes of au\u00adtomated assembly, retrieved \ncomponents must be designed tobe assembledin a variety of contexts and assembled only with those other \ncomponents that are syntactically and se\u00admantically compatible.Thisplacesburden onthe application architect \ntobothdesign reusable(sub)assemblies and to ap\u00adpropriately constrainthe componentdescriptionstoprevent \nundesirable assemblies. In the absence of a comprehensive formal model and provably correct assemblies, \ntesting is a necessity, as are any other techniques thatimprove thequal\u00adityand reliability of component(sub)assemblies. \nWepropose an overall software engineeringprocessthat isspeci.callytailoredtotheneedsof.ow-basedapplication \ncomposition. Figure 7 shows the stages in our software en\u00adgineeringprocess.Ourprocess canbe roughly described \nas spiral-like re.nement, starting with requirements anditerat\u00ading over the development and testing of \napplication assem\u00adblies composed from both reusable components and newly developed components. Finally, \nthe set of all components is made available to end-users for composition into diverse .ows.In addition, \nuserinterfaces(suchasthethe one shown in .gures2and3)thatfacilitatethecompositionof.owsby end-users aregenerated. \nThe development and composition processes include a combination of top-down andbottom-up elements.The \ntop\u00addown elements provide structure to the design and devel\u00adopment processes, and guarantee that certain \ncompositions can be achieved from the set of developed components. Thebottom-upelements enable reuse \nofbothindividualand composite components in different contexts, and also allow for the serendipitous \nassembly of new .ows in response to new end-user requests or other runtime requirements. Theinterplaybetween \nthe top-downdevelopmentlifecy\u00adcle and the bottom-up composition approach is crucial in our methodology.As \na result of the top-downdevelopment, certain components are developed and associated with tag\u00adbased descriptions. \nThese components are guaranteed to be composableinto certain .owsthatmeetthe end-user require\u00adments.However, \nwhen an end-user submits agoaltothe sys\u00adtem, it constructs satisfying .ows, in a bottom-up manner, using \nthe tag-based descriptions of the components. These .owsincludethosethat weredesignedbythe application \nar\u00adchitectsduringthetop-downlifecyle.In addition,itmayalso come up with new .ows that were not explicitly \ndesigned. Thisdynamicbottom-upcomposition alsopotentiallyallows theassemblyof .owsforgoalsthat werenotpart \nof theini\u00adtial end-user requirements. B o t t o m U p R e u s e o f S p i r a l  E x i s t i n g R \ne f i n e m e n t C o m p o n e n t s a n d S u b - F l o w s B o t t o m U p G e n e r a t i o n o \nf D i f f e r e n t F l o w s a n d C o m p i l a t i o n o f n e w q u e r i e s  Figure 7. Software \nEngineering Process for Automated Composition We shall nowprovide an overview of thedifferent stages \nin our software engineeringprocess.Ourprocess starts with thedescription offunctionalrequirementsfrom \nend-users.In informationprocessingsystems,thefunctionalrequirements describe the kinds of data the end-user \ndesires. In our ap\u00adproach, these functional requirements are expressed as pat\u00adterns of goals that the \nuser would like to submit. Note that this paper focuses on functional requirements and not non\u00adfunctional \nrequirementslike security,performance and cost. The functional requirements are taken by an application \narchitect who comes upwithahigh-leveldesign ofthe over\u00adall application(s)and of individual components. \nThe archi\u00adtect .rst constructs one or more application templates that satisfy the requirements. An application \ntemplate is a high\u00adlevel description of the .ow structure and is modeled as a graph of abstract sub-.ows, \nwhere each abstract sub-.ow performs a certain segment of the overall required informa\u00adtionprocessing.Each \nabstract sub-.owin turn consists of a graph of component classes, where acomponentclassisan equivalence \nclass of components that share similar proper\u00adties and are substitutable in certain contexts. The modular \nand substitutable nature of components are critical in mak\u00ading compositionpossible.In addition, thedecomposition \nof the application into abstract sub-.ows allows reuse of not justcomponents,but also entire sub-.ows. \nThe application architect can reuse existing components (and component classes) in designing the application. \nIn some cases, however, new components may need to be de\u00adveloped, or existing components modi.ed, to \nsatisfy new end-user requirements. The new components may either be part of an existing component class, \nor may belong to en\u00adtirely new component classes. The architect de.nes the se\u00admantic requirements of \nthe component in terms of tags de\u00adscribing the input and output data. In addition, the architect de.nesthe \nsyntacticinterfaces ofthe componentso asto en\u00adableitsinteraction withother componentsinthe application. \nThese semantic and syntactic component requirements get passedto adeveloper, whodevelopsthe component.Also, \nas showninthe .gure,theprocessofapplicationtemplatecon\u00adstruction andre.nement, component requirements \nandcom\u00adponentdevelopedistypicallyiterativeinvolvingboththe ap\u00adplication architectandthedeveloper. Once \nthe component is developed, it goes through unit tests as de.ned by the application architect and/or \nthe de\u00adveloper. Integration testing is a crucial part of the process, especially for automated composition. \nThere are two levels at which integration tests are performed -at the goal com\u00adpilation level, where \nthe tag-based semantic composability of different components is checked; and at the deployment level, \nwhere the runtime interactions of different compo\u00adnents is checked. At both levels, an integration test \nis per\u00adformed by selecting sample goals that belong to the goal pattern. Each sample goal is tested by \nsubmitting it to the .ow composer, checking to see if the set of .ows gener\u00adatedincludes atleastonethatisprescribedbythe \napplication template, deploying a sample of the .ows generated on the underlyingplatform, andverifyingthe \nend-resultsgenerated bythe .ow. The .nalstepisdeployment ofanynewormodi.edcom\u00adponentsinthebackendplatform(s).Thedeployment \nresults in two changes to the system.First, the end-userinterfaceis modi.ed, automatically, to enable \nusers to express the new kinds ofgoals(asdescribedintherequirements).This may result in new tags or combinations \nof tags that can be se\u00adlectedfrom the tag cloudinFigure2.Second, the new com\u00adponentscanbeincludedin .ows.These \n.owsarenotjust the onesde.nedin the application templates,butpotentially new .owsthat maybecreatedbased \nonthesemanticde.ni\u00adtions of the new set of components. Although the methodology as presented has a top \ndown emphasis, it does support the bottom-up construction of .ows. First, in the application template \nconstruction stage, it is possible to reuse existing components or sub-.ows in de.ningthetemplate.Second, \nafterdeployment, our compo\u00adsition approach is not constrained by the pre-de.ned appli\u00adcation templates. \nInstead, our .ow composer can construct new .ows to satisfy user goals using the available com\u00adponents. \nThe .ow composer uses a planning approach; for eachgoal,itcomposes aplanby using theinputand output descriptions \nof individual components. The .ow composer is not aware of the application templates; instead it creates \n.ows anew from the goal speci.cation. This allows for the spontaneous generation of new .ows from existing \ncompo\u00adnents that were not necessarily designed by the application architect. One of the keyfeatures of \nour systemis the end-userin\u00adterface, whichpresents with atag cloudfrom whichthey can select one or moretagsto \nexpresstheirprocessinggoals.The tag cloudis automaticallygenerated,based on an analysis of the valid.owsthatcanbegeneratedforthegiven \nsetofcom\u00adponents.In other words, the tagcloudincludes allthose tags that appear in at least one valid \n.ow, assembled from pre\u00adviously developed and tagged components, thus presenting userswiththeabilitytodynamically \nassemble .owsrespon\u00adsive to their currentprocessing requirements.Thistag-based end-userinterface,together \nwith the automaticgoal compi\u00adlation, make it relatively easy for any users (in particular, non-programmers) \nto construct queries, deploy situational applications, and obtain thedesiredinformation. The roles involved \nin the creation and use of our .ow\u00adbased assemblies are the usual: Requirements Engineers, End-Users,ApplicationArchitects,Developers,UnitandIn\u00adtegrationTesters.Afewtasksdiffer,though.Users,Require\u00adments \nEngineers, and Application Architects are concerned with modeling the various facets, tags, and taxonomies \nthat convey the users perspective on relevant vocabularies and processing results. Application Architects \nare concerned with partitioning application functionality based on various blends of reusability and \nscalability, taking into considera\u00adtion the various semantic contextsin which the components and sub-assemblies \nmustfunction. 5. FormalModel ofTags,Goalsand Components The basic unit of describing requirements, components \nand goalsisatag(orakeyword).Thenotionof a tag issim\u00adilar to various collaborative tagging applications \n(or folk\u00adsonomies) thathave ariseninWeb2.0(such asdel.icio.us andFlickr) where users annotatevariouskindsof \nresources (likebookmarks andimages)with tags.Thesetagsarethen used to aid search and retrieval of resources. \nA key aspect of the tagging model is that it is relatively simple, in com\u00adparison to more expressive \nmodels such as those based on Semantic Web ontologies and other formal logics. Hence, the use of tags \noffers a lower barrier to entry, for both end\u00adusers and developers, to use tags to describe resources. \nIn our case, the resources are various types of data artifacts, likedatastreams, .les,messages,etc. There \nis, however, an important difference between our tagging model and other collaborative tagging applications \nin Web 2.0. For purposes of composition, we need greater control on the evolution of the set of available \ntags and on the way tags are assigned to various kinds of data and to components. Whilemost otherfolksonomiesallowfreeand \narbitrarytaggingofresourcesbyusers,taggingin our system requires more careful consideration since the \nassignment of tagshas rami.cations on the composability of components. 5.1 TagHierarchies Let T = {t1,t2,...,tk}be \nthe set of tagsin our system.In most social tagging applications, the set of tags, T, is com\u00adpletely \nunstructured, i.e. there is no relation between indi\u00advidual tags.Introducing ahierarchy structurein T,however, \nenhances the expressivity by allowing additional tags to be inferredfor resources, and also aids end-usersin \nnavigating alarge number of tags. A tag hierarchy(or taxonomy), H, is a directed acyclic graph(DAG) wherethe \nvertices arethetags, and the edges represent sub-tag relationships. It is de.ned as H = (T,S), where \nT is the set of tags and S . T \u00d7 T is the set of sub-tag relationships. A sub-tag has an associative \nsemantics, where if x is a sub-tag of y, then x is commonly associated with y by the community of users. \nIn other words, if a resource is tagged with x,thenit wouldbe semantically appropriateforittobe tagged \nwith y.Inthispaper, we usethe symbol . to repre\u00adsent sub-tag relationships. For example, NewYorkTimes \n. Newspaper, which implies that any resource tagged with NewYorkTimes may alsobe tagged with Newspaper.In \nour methodology, we assume that thetaghierarchyisde.nedby application architects and componentdevelopers. \nFormally, a tag t1 . T is a sub-tag of t2 . T, denoted t1 . t2, if all resources annotated by t1 can \nalso be anno\u00adtated by t2. The sub-tag relation is transitive, i.e. if t1 . t2 and t2 . t3 implies t1 \n. t3 for .t1,t2,t3 . T. For nota\u00adtional convenience, we willfurther assume that each tagis a sub-tag \nofitself,i.e. .t . T, t . t. 5.2 Data Model In our approach, tags are used to describe data artifacts. \nA data artifact may be a data stream, a table in a database, a .le, anRSSfeed, a webpage, a message exchangedbetween \nservices, etc.The tags maydescribeboth the syntax and the semantics of thedata artifacts. Each data artifact, \na is characterized by a set of tags d(a) . T. For example, consider a component that pulls in weather \nforecast data from an FTP server maintained by NOAA(NationalOceanographic andAtmosphericAdmin\u00adistration). \nThe current weather forecast obtained from one such model called Eta is available as an ASCII .le on \nthe FTP server. This data artifact, a1, may be described by the tags Eta, NOAA, Text, 3DayForecast, ASCII, \nCurrent, Tem\u00adperature}.These tagsprovide syntactic and semanticinfor\u00admation about thedata. Data artifacts \nneed not only be the raw data from vari\u00adous sources, but may also be processed data. For example, if \nthe ASCII .le was processed by a .ow of components to calculate the average temperature ofNewYorkCity \nover the threedayperiod, then the resultingdata artifact, a2, may be described by the tags Eta, NOAA, \nAverage, 3DayPeriod, NewYorkCity, Temperature}. Depending on the kind of .ow and the runtime environment, \nthe result data may be made available in a variety of forms, e.g. as a SOAP message in a web service \nenvironment, an RSS feed in a mashup envi\u00adronment, or a single streamed tuple in a stream processing \nenvironment. 5.3 End-UserGoal Model End-user goals describe the semantics of the desired data artifacts. \nA goal, q . T, selects a subset R.q of a resource set R = {r}such that each resource in the selected \nsubset has all the tagsin q or subtags thereof.Formally, '' R.q = {r . R|.t . q .t . d(r) such that t \n. t}. For example, thegoal{MOS, Average, NewYorkCity}will match the data artifact, a2 describedin Section5.2, \nmaking use of the sub-tag relationship Eta .MOS (Figure4).MOS, which standsforModelOutputStatistics, \nrefers to ageneral class of weatherforecast models, whichincludes Eta. The explicit matches of a goal \nare data artifacts that satisfythegoal requirements.Implicitly,however,the results of a goal are not \njust the data artifacts but the .ows that producethedesired artifacts.Goal satisfaction,thus,canbe viewed \nas a search in the space of all possible .ows that can be constructed from a given set of data sources \nand processingcomponents. Note that while thegoal,byde.nition, selects all match\u00ading dataartifacts(and \n.ows),theend-userdoesnothaveto bepresentedwith all matching resources,becausethere may be too many. Also, \nany algorithm that searches for satisfy\u00ading .ows need not actually come up with allpossible .ows because \nthere maybe too many of them, andit maybeinef\u00ad.cient to search for all of them. It may instead try to \ncome up with a ranked list of top .ows based on some ranking function. 5.4 Facets Facets represent dimensions \nfor characterizing resources (data artifacts). Let F = {fi} be the set of facets in our system.Eachfacetis \nmodeled as a set oftags,i.e. fi . T.In somefacet classi.cation systems,facets are mutually exclu\u00adsive. \nThat is, two facets share no common elements. In our approach, though, tags maybe shared acrossfacets. \nFacets play an important role in identifying sets of sim\u00adilar tags that can be grouped together and used \nto describe abstract .ows or components. They also help in organizing thepotentiallylarge number of tagsin \nthe userinterface and thus aid the userinlocatingdesired tags. 5.5 Component Model Our model uses the \ntags from the taxonomy to associate semantic information with the input and output data arti\u00adfacts of \ncomponents. This semantic information is comple\u00admentary to the syntactic(or structural)information that \nmay be provided in the interface description of the component (forexample,ina WSDLdocument).Boththesemanticand \nsyntactic information may be used together for purposes of checking composability of components. One \nofthekeyfeatures ofour modelifthatit capturesthe notion of semanticpropagation,i.e.the semanticdescription \nofthe outputdata artifacts of a componentdepend onthe se\u00admantics of the input data artifacts. Our model \nincludes two mechanisms to describe how semantic properties are prop\u00adagated from the input to the output \ndata artifacts. The .rst is through the use of common variables in the inputs and theoutputs. Whatevervalue(tag) \nthevariableisbound toin the input is the same value it is bound to in the output. The secondis through \nthe use of sticky tags.These arespecially designated tags that are directly copied to the output from \ntheinputdescription; evenif theydo not explicitly appearin the output description. In our model, stickiness \nis a uni\u00adversal property of the tag, i.e. it is not speci.c to a certain component. Typically sticky \ntags are those that refer to se\u00admantics of the sources(like NOAA)andhence canlogically be associated \nwith all raw and derived data produced from this source.Figure4 shows examples of components as well \nas the propagation of semantic information from inputs to outputsina .owof components. A variable, v, \nis a member of the set V where V is in.nite anddisjointfromT.A variableis represented with a preceding \n? .Each variableisassociated with oneormore types(which are alsotags).Let t : V . T be a function that \nmaps a variable in a component description to a set of types. A variable, v can be bound to a tag, t \nif thetagis a sub-tag of all the types of the variable,i.e. canbind(v,t) iff.x . t(v),t . x An input \ndata constraint of an component(or operator), o, denoted by Io describes the required properties of input \ndata artifactsto a component.Itisintheform ofa set oftags and variables,i.e. Io . (T .V). An output data \ndescription of a component, o, denoted by Oo describes the properties of an output data artifact produced \nby a component. It is in the form of a set of tags and variables,i.e. Oo . (T .V). Let C be the set of \nall components in the system. A component, o . C,isde.ned asthepair ({Io}, {Oo}) where 1. {Io}is a set \nof zero or moreinput message constraints 2. {Oo}is a set of one or more output message constraints \n3. The set of variables in the output set, {Oo}, is a subset of the set of variables in the input set, \n{Io}. This con\u00adstraint ensures that no free variables exist in the output description.  Ourmodel alsoincludesotherinformationsuch \nasbind\u00ading(i.e.how exactly toinstantiate orinvoke a component) andotherdocumentation onthe component.The \nactualbind\u00ading modeldependsonthe underlying deploymentplatform. We shall not cover this aspectin thispaper. \nWe note that the folksonomy-based model is less ex\u00adpressive than Semantic Web Service models like OWL-S \nand WSMO,which cancapturerichersemanticinformation about theinput and outputdata, using assertionsindescrip\u00adtionlogic,hornlogic \nor otherkinds oflogics.Our model,for instance, cannot capture relationships between tags. How\u00adever, based \non our experiences, our model can still capture suf.cient constraints for use in automated composition. \nIn addition, our model has a lower barrier for entry since it is easierto annotate components usingjust \na set ofkeywords rather than using assertionsin alogicalformalism.This will hopefully prompt more developers \nand end-users to anno\u00adtatecomponents and reap theimmediatebene.tsofdiscov\u00adery and composition. Once these \ndevelopers and end-users see the valuein annotating components, they can then move on to more expressive \nmodelsif the need arises. As ageneral designprinciple and in theinterest of mod\u00adularity,itispreferable \ntodesign components where the tags on each component sinputs and outputs are associated with a small \nnumber offacets.Thepresence of tagsfrom alarger number of facets is a likely indicator that the component \nis performing multiple operations crossing multiple domains, andis thus a candidateforfurtherpartitioning. \n5.5.1 ModelingComponentParameters Many components can be instantiated or con.gured with parameter values \nthat in.uence the way they behave. For example, a parameter to a contour map view visualization component \nusedfor visualizingthetemperature rangesisthe number of contours, whichis a measure ofthegranularity \nof the result visualization.We model componentparameters as inputconstraints.The value oftheparameter \ncanbe obtained intwoways -fromanend userorfromanothercomponent thatprovides a single value to this component. \n 5.5.2 CompositionConstraints An important part of composing .ows in information pro\u00adcessing systemsisdetermining \nwhether adata artifact,pro\u00adducedby some component, canbegiven asinput to another component.There aretwo \nmainkinds of constraints we con\u00adsider: semantic and syntactic. The semantic constraints can be expressed \nusing thetag-based model.The syntactic con\u00adstraints depend on the actual deployment platform, and are \nrelatedtothe actualdatatypes required andproducedby var\u00adious components. These syntactic constraints \ncan also, in some cases, be described using tags. For example, we can use tags to represent an XML schema \nor a Java interface name. The semantics of a data artifact, a, can be described by the set of tags, d(a). \nWe de.ne that d(a) matches an input constraint, Io (denotedbyd(a) . Io), witha variable substitutionfunction, \n. : V . T,iff 1. For each tag in Io, there exists a sub-tag that appears in d(a).Formally, .y . (Io nT), \n(.x . d(a),x . y). 2. For each variable in Io, there exists a tag in d(a) to which the variable can \nbe bound. Formally, .y . (Io n V), (.x . d(a), canbind(y,x)). Also, that mapping .(y)= x is created. \n If a component has n inputs, then a set of data artifacts {d(a1, ),...d(an)}match theinput constraints \n{I1 ,...In} oo if d(ai) . Ii ,i =1 ...n with a common variable substitu\u00ad o tionfunction. 5.5.3 OutputGeneration \nWhen a component s input requirements are satis.ed, the component generates new output data artifacts. \nThe seman\u00adtics of an output data artifact can be described based on the semantics of the corresponding \noutputdatadescription, Oo, after substituting any variables that appearinthedescription based on the \nsubstitution function, . and after propagating any sticky tagsfrom any of theinputs to the output. Let \nS . T be the set of all sticky tags. Let di(a),i = 1 ...n, be the n input data artifacts to the component. \nLet . be the common variable substitution function used for matchingtheinputdata artifactstotheinput \nrequirements of the component. The semantics of an output data artifact, b, correspondingtothe outputdescription, \nOo of a component, canbedescribedby the set of tags, d(b), where d(b)= {t : t . Oo nT}.{.(v): v . Oo \nnV} .{t : t . (.n di(a)) nS} i=1 Thismeansthatthe outputdataartifact canbedescribed byalltagsthatappearinthe \noutputdescription ofthe compo\u00adnent, alltagsthat are obtained after substitutingthe variables (basedon \nthe matches at the input side), and all sticky tags that appearin theinputdata artifacts.  5.6 OverallApplication \nModel Applications are modeled as .ows of components that jointlyprocessinformationtoproducedesiredend-results.A \n.owis agraph G(V,E) where Gis aDAG(DirectedAcyclic Graph). Each vertex v . V is a component instance. \nEach edge (u,v) represents a logical .ow of data artifacts from u to v.Thedataartifactcorresponding toeach \nedge, (u,v), can be described by a set of tags, d((u,v)). This model of applicationstranslateseasily \ntovarious .owmodels,includ\u00ading BPEL, .ows in stream processing systems and in data mashups. 5.6.1 GoalDrivenComposition \nTheproblem ofgoal-driven composition can nowbe simply de.ned astheproblemof constructing a .owthatproduces \nadata artifact satisfyingthegoal.Given a compositionprob\u00adlemP(T,C,g), where: T is a taghierarchy,  \nC is a set of components,  g is a compositiongoal, g . T,  the solution setisde.ned asfollows: The \nsetof solutions S(T,C,g) tothegoal-driven compo\u00adsitionproblem P(T,C,g) is the set of all valid applications, \nG, such that .G(V,E) .G, Thedata artifact corresponding to atleast one edgein E must satisfy thegoal,i.e. \nE.g \u00d8 = for all component instances in V, at least one data arti\u00adfactproducedby thisinstance serves asinputto \nanother componentinstance, or satis.es thegoal. The secondconditioninthede.nition abovehelps eliminate \nfrom consideration inef.cient compositions that have dead\u00adend componentinstancesproducing unused objects. \n 5.6.2 CompositionRanking Before the set of compositions S(T,C,g) can bepresented to the user, the compositions \nmust be ranked, with those mostlikely tosatisfy user sintentappearing .rstinthelist. The rankingisbasedon \naheuristic metric re.ecting compo\u00adsitionquality.Each component c .C is assigneda .xed cost cost(c). Cost \nof a component instance in a composition is equal to the cost of the corresponding component. Rank, rank(G), \nof a composition, G(V,E) .G, is the sum of the costs of componentsinstances,i.e. rank(G)= cost(ci). ci \n.V By default, for all components, cost(c)=1. Hence, the best compositions are the smallest ones. During \ncon.gura\u00adtion of the system, the number can be left equal to the de\u00adfault, or con.gured for some components \nto re.ect compo\u00adnentquality. The composition problem can be solved using manual, automated or assisted \napproaches. We shall brie.y describe ourplanning-based automated composition approachin this paper,inSection6.3. \n  6. Tag-basedSoftwareEngineering and Composition Thepervasive use of tags andfacets todescribe the \nartifacts produced during various parts of the software engineering lifecycle is key in establishing \nthe connection from end\u00aduser requirements to developed components and compos\u00adable .ows. We now describe, \nformally, how tags and facets are used in the speci.cation of requirements, of application templates \nand component classes.Finally, the tag-basedde\u00adscriptions of the components are used by a planner to \nsup\u00adportautomatic composition of.owsin responsetotag-based end-usergoals. 6.1 Multi-facetedRequirementsSpeci.cation \nIn our software engineering methodology, end-users can specifyrequirementsforthekinds ofinformationthey \nwould like to obtain. These requirements are used by the applica\u00adtion architects in designing the components \nand the overall applications. In any large scale information processing system, many kinds ofinformation \nmustbeprocessedin a varietyof ways. Hence, requirements are not speci.ed in terms of actual goals but \nas whole classes of goals, that are described by goalpatterns. A goal pattern is described as a set of \ntags and facets. Each facet is associated with a cardinality constraint. The cardinality constraint speci.es \nhow many tags in the facet shouldbepart of thegoal. We .rst de.ne the set of cardinality constraints, \nCC, as the set of all ranges ofpositiveintegers.Then agoalpattern, QP = {(x,c)|x . F,c . CC}.{t|t . T}.Agoalpattern \nrequirement means that end-users are interested in all data artifacts that canbedescribedby a combination \nof tags that are drawn from the facets in the goal pattern, according to the cardinality constraints. \nAn example ofagoalpatternis Source[= 1], WeatherForecastModel[= 2], MultipleModelAnalysis[1], BasicWeatherMetric[= \n1], Visualization[1]. This represents the class of all data artifacts that can be describedbyone or moretagsthatbelongtothe \nSource facet, 2or moretagsthatbelongtotheWeatherForecastModel facet, onetagbelongingtothe MultipleModelAnalysis \nfacet, andone tagbelonging to the Visualization facet. An important point to note is that the goal pattern \ncan refer to alarge number ofpossiblegoals.So,for example,if there are 5 tagsinthe Source facet,50 tagsintheModel \nfacet, 5 in MultipleModelAnalysis and 10 in Visualization, there are up to 25 \u00d7 250 \u00d7 5 \u00d7 10 possiblekindsofdatathat \nmaybe produciblebytheinformationprocessingsystem.Hence,the goalpatternhelpsin succinctlyexpressingthe \ncombinatorial number ofpossiblegoalsthatcanbe submittedtothe system. 6.1.1 ApplicationTemplates An application \narchitect takes a requirement, in the form of a goal pattern, and constructs one or more application \ntemplates that can satisfy all the goals in the goal pattern. An application template is a high-level \ndescription of the application structure. Each goal instance belonging to the goal pattern can be satis.ed \nby an application instance that belongstothede.nedapplicationtemplates.Figure8has an example of an applicationtemplate.Figure1 \nshows one such instantiation of the subgraph. The application templates are intended to guide the goal \nansweringprocess.Itisimportant to note that the templates do not capture all solutions. It is possible \nto assemble a different .ow that uses potentially different components to satisfy the samegoal. An applicationtemplateis \nadirectedacyclicgraph, where the vertices are abstract sub-.ows and edges represent trans\u00adfer of data \nartifacts between components in different sub\u00ad.ows. Each abstract sub-.ow, itself can be described by \na directed acyclic graph, where the vertices are component classesand edges representthetransfer ofdata \nartifactsbe\u00adtween component classes. Formally, an application templateisde.ned as adirected acyclicgraph \nG(V, E,p,.), where each vertex, v .V is an abstract sub-.ow and each edge e .E represents data .ow between \nabstract sub-.ows.Next, p : g .CC , where g is a subgraph of G. In other words, p associates each sub-graph \nwith a parallelism constraint. In the example above, one of the subgraphs is associated with a constraint \nthat at least 2 instances of the subgraph runinparallel.By default, a sub\u00adgraphis associatedwith a cardinality \nof1. Finally, . : V . GP, where GP is the set of allpossible goalpatterns.Eachabstractsub-.owinthe .owis \nassociated with a goal pattern that describes the kinds of goals that the sub-.owformedby this sub-.owplus \nallpreceding sub\u00ad.owsinthe .owcananswer. .isthefunctionthatassociates a sub-.ow with thegoalpatternitproduces \nas output. 6.1.2 AbstractSub-Flows An abstract sub-.owis adirected acyclicgraph S(VS ,ES ). Each vertex \nv . VS is a component class(de.nedlater). Each edge (u,v) . ES represents a logical .ow of data artifacts \nfrom a component in the class u to a component in the class v. Each stage can be viewed as a high-level \ncomponent withinput requirements and output capabilities. An example ofa stageis showninFigure9.It consists \nof twocomponent classes,the .rstfetches a .legivenaURL, and thesecondparsesaweatherforecast .le. Figure \n10 shows a concrete instance of the abstract sub\u00ad.ow, where the component classes have been instantiated \nwith speci.c component instances. In the case of the .rst component class, theinstantiation occurs through \nthe speci-Figure9. ExampleAbstractSub-FlowforWeatherForecast Extraction .cation of aparameter(a speci.cURL).The \nsecond compo\u00adnent class is instantiated with a speci.c component, called MOSParser, that parses MOS forecasts \nfrom NOAA to extract temperature and dew point predictions for various weather stationsin theUS. Figure \n10. Example Instantiation of Weather Forecast Ex\u00adtractionSub-Flow  6.2 ComponentClassandComponentRequirements \nComponentsthatperform similartasksandhave similarin\u00adput constraints canbegrouped togetherinto a class.For \nex\u00adample, all components that take a set of weather forecasts from various sources and aggregate them \nin some fashion (e.g.performingan average, or coming up with aprobability distribution, or .nding the \nminimum or maximum or clus\u00adtering ordetecting outliers) may begrouped togetherinto a class. The key intuition \nbehind a component class is that all the members of a component class are substitutable in a certaincontext.Thatis,inanygiven \n.ow,acomponentcan be replacedbyanother componentin the same class without any syntactic or semantic mismatch.Hence,thede.nition \nof acomponentclassisspeci.ctoacertain .ow(oracertain class of .ows). This notion of substitutability \nof components is critical in our approachto automatedcomposition.Our composition approach starts with \na high-level application template de.\u00adnitionthatismadeup of a .owof substitutablecomponents. Different \nsubstitutions of components result in different in\u00adstances of the templates that can satisfy speci.cgoals. \nLet C = {c}be the set of all components in the system. Thenthe setof all component classesis C. 2C .In \naddition, a component class, X .C, is speci.c to a certain position in a .ow, or set of .ows. If a . \nX appears in thisposition, thenit canbe substitutedby any b . X. The inputs and outputs of a component \nclass, X, can be describedbygoalpatternsthatinclude variables.Wede.ne Figure 8. Example of Application \nTemplate showing various abstract sub-.ows. Each abstract sub-.ow is associated with a parallelism constraint(defaultis1), \nandagoalpattern thatit can satisfy.  the set of all variable goal patterns as VQP = {(x,c)|x . F .V,c \n. CC}.{t|t . T .V}.Then a component class, X, canbede.ned as thepair ({IX }, {OX }) 1. {IX }is a setofvariablegoalpatternsthatdescribe \na class ofinput message constraints 2. {OX } is a set of goal patterns that describe a class of output \nmessages 3. The set of variables in the output set, {OX }, is a subset of the set of variables in the \ninput set, {IX }. This con\u00adstraint ensures that no free variables exist in the output description.  \nWe assumethateachcomponentbelongsto atrivialcom\u00adponent class, which is a singleton set. Figure 11 shows \nan example component class on the left. The input and out\u00adput descriptions include the variable ?source \nwhose type is WthrSource. This means that both the input and the output includethe sametag, whichis a \nsub-tagofWthrSource, such as NOAA.  Figure11. ExampleComponentClass andExampleComponent A component \nclass can also act as a requirement spec\u00adi.cation for a new component, or a set of components. A component \nrequirement is speci.ed according to the model described in Section 5.5, i.e. in terms of tag-based descrip\u00adtions \nof the inputs and outputs. A developer takes this re\u00adquirement, along with any other requirement provided \nby the application architect, and develops the component. Af\u00adter unit and integration testing, this new \ncomponent can be usedinnewapplication .ows.  6.3 Planning-based,Bottom-Up,Automatic Composition Once \nnew components are developed and tested, they can be used in new .ows. Our system includes an AI planner \nthat composes .ows from the available components given thegoal.Theplannerplays a crucialroleinthe serendipitous \nassemblyofnew .ows.Itisnot awareofthe .owtemplates; hence, it can compose .ows that follow the templates \nand also possibly new .ows, which don t fall into any of the explicitlydesigned templates. As an example, \nassume that there is a component de\u00adveloped in a different context that took weather data and stored \nit as tables in a database. Then this component can potentially replace any of the visualization components \nde\u00adveloped as part of the .ow template in Figure 8. Hence, a dynamic user goal such as RelativeHumidity, \nIA, Weighte\u00addAverage, GFS, Eta, DatabaseStorage maybe satis.able even thoughit was notpart of the original \nuser requirements. Wehavedescribedtheplanningalgorithmfor solvingthe composition problem P(T,C,g),in \nearlier work[25].The algorithm .nds a solution with the best possible rank and generates a weightedlistoftagsfor \nthe tagcloudbyanalyz\u00adingdescriptions ofoutputdata artifactsproducedbyalterna\u00adtive solutions.It can alsoprovide \na summarydescriptionfor a speci.ed range ofalternative solutions. The algorithm operates on an abstract \ndescription of the compositionproblem representedinSPPL(StreamProcess\u00ading Planning Language) that was \nintroduced in [24]. An SPPLplannerperforms muchbetterintypical.ow composi\u00adtionproblems than thebestgeneralAIplanners.By \nmaking objects apart ofthedomain model,SPPLplanner avoids un\u00adnecessarygrounding and resolvessymmetries, \nreducing the search space by an exponential factor. The planning algo\u00adrithmincludes aproblem analysis \nandpresolve stage, and a forward search stage. During the presolve stage the search space is reduced \nby several techniques that include intelli\u00adgent grounding of variables, elimination of irrelevant com\u00adponentsbasedonfastbackward \nsearchin a relaxedformula\u00adtion, andgroupingsymmetricalcomponents where appropri\u00adate.Theforward search \nstage composes and ranks candidate .ows startingfrom sources. Finding optimal plans is a theoretically \nhard problem. In general, there do not exist optimal or constant-factor\u00adapproximation SPPL planners that \ncan guarantee termina\u00adtion in polynomial time on all tasks. STRIPS planning, whichis a special case ofgeneral \nSPPLplanning,isknown tobePSPACE-complete[4]. In practice, however, such composition problems can be solved \nautomatically much faster than humans can solve them. In our experiments with an example based on a set \nof up to 273 Yahoo Pipes components and feeds, the time neededfor solving the compositionproblem andgenerating \nthe tag cloud for goal re.nement was consistently under 5 seconds, and typically under1 second orless[25]. \n 7. RelatedWork Faceted classi.cation, introduced in 1933 by S. R. Ran\u00adganathan[22], was applied to \nsoftware component reusein 1991[19],becomingthe industrial stateoftheart by1994 [15]. Subsequent approaches \nincorporated semantic models to improve searchprecision, viagoal-based search[32].Qual\u00aditymodels were \nadded,to enhancegoal-driven retrieval with non-functional applicability criteria[11].Still, thepredomi\u00adnantfocus \nwas on speci.cation and retrievalbut not compo\u00adsition. Component composition at the code level is addressed \nin[23].More recent workproposes adynamichierarchical component composition[10], which also emphasizestype\u00adoriented \ncomposition models. Faceted classi.cation, as applied to software require\u00adments, was introduced by Opdahl \n[18]. Goal-directed Re\u00adquirementsEngineeringwasintroducedintheKAOS system [33]. Web services compositionisdescribedin[28], \nand com\u00adposition usingUMLisdescribedin[30].Rule-basedservice compositionis addressedin[20] and[34].Semantic \nservice compositionin[5].Aplannerfor service compositionsde\u00adscribed in [27]. An approach to DL planning \nfor service compositionisdescribedin[21].Knowledge engineeringfor work.ow composition,[31], and ontology \nmodelingfor web service compositionin[7], alsofocus onthe use of rich se\u00admanticdescriptions, whichpose \nan extraburden onthosede\u00adscribing components and on those establishing composition goals. Other automatedsoftware \ncomposition workincludesthe workbyMargaria andSteffen[13], who were ableto syn\u00adthesizesequential orchestrations, \nexpressedinBPEL,given process constraintsde.nedinlinear temporallogic.Thekey difference in our approach \nis that we take a goal-directed planning approach to the task of composition, where the goals are expressedusingsets \noftags.Thegoal-directed,tag\u00adbasedapproach makesit easyfor end-users to come up with customized compositionsjustby \nselecting one or more tags. 8. Conclusion We have described a tag-based application design method\u00adology \nthat facilitates the composition of customized .ows to satisfy end-user goals. At the core of our approach \nis a novel tag model wheredomain-speci.c tags, organizedinto various facets, are used to describe 1) \nend-user information processing goals, 2) component functional processing and data semantics, and 3) \napplication requirements and struc\u00adtural constraints.Theprominent role that tags and tag-based descriptionsplayinall \nthree areas establishes a strong visi\u00adble threadfrom users information needs todynamically as\u00adsembled \n.ow-based applications. Wehave alsodescribed our applicationdesign and com\u00adposition methodology that \nincorporates both top-down and bottom-up elements in order to come up with a set of com\u00adponentsthatcanbecomposedintoalargenumberof \nappli\u00adcations.Some of the advantages of our methodology are : 1. The top-down development lifecyle guarantees \nthat the componentsdeveloped canbe composed to create appli\u00adcations that meet theinitial end-user requirements. \n 2. The tag-based descriptions of all components facilitates their recombination in new ways to create \nnew applica\u00adtionsthat satisfy new end-usergoals, which may may not havebeenpart of theinitial requirements. \n 3. The common, yet extensible, facets and tag hierarchies establish a simple, shared vocabulary that \nis used archi\u00adtects,developers and end users 4. End-user requirements are captured in a formal manner. \nThis enables us to verify that the requirements are actu\u00adally satis.edby a set of composable services. \n We have undertaken this application design process for adeploymentinthe .nancial servicesdomain.Thisdeploy\u00admentincluded \na total of135 components.The development and annotation of the services was undertaken by a team of 5 \npeople, with one person serving as a requirements engi\u00adneer and application architect, 3 component developers \nand one supporting the basic architecture. Some of the compo\u00adnents ran on the Project Zero platform [8], \nwhich allows the deployment of REST-based services and data mashups. Others were componentsinIBM sSystemS[9], \nwhichis a stream processing system. The .ow size ranged from 5 to 150 component instances. Our preliminary \nexperiences in this deployment have convinced us of the usefulness of ourapproachfordeveloping rapidly \ncomposable .owsfrom modular components.Ourfuture workinvolves studyingthe propertiesand theevolutionof \nthecomponentsand .owsin this deployment, as well as deploying in different domains, and ondifferentplatforms. \n  References [1] Yahoopipes. [2] Martin Abadi and Luca Cardelli. A Theory of Objects. Springer-VerlagNewYork,Inc.,Secaucus,NJ,USA,1996. \n[3] Mehmet Altinel, Paul Brown, Susan Cline, Rajesh Kartha, Eric Louie, Volker Markl, Louis Mau, Yip-Hing \nNg, David Simmen,andAshutoshSingh. Damia: adatamashupfabric for intranet applications. In VLDB 07: Proceedings \nof the 33rdinternationalconferenceonVerylargedatabases,pages 1370 1373.VLDBEndowment,2007. [4] T.Bylander. \nThe computational complexity ofpropositional STRIPS planning. Arti.cial Intelligence, 69(1-2):165 204, \n1994. [5] L Chen, N.R. Shadbolt, C. Goble, F. Tao, S.J. Cox, C. pule\u00adston,andP.Smart.Towardsaknowledge-based \napproach to semantic service composition. In The Second International SemanticWebConference(ISWC2003),2003. \n[6] Luba Cherbakov, Andy J. F. Bravery, and Aroop Pandya. SOA meets situational applications,2007. [7] \nJuntao Cui, Jiamao Liu, Yujin Wu, and Ning Gu. An ontology modeling method in semantic composition of \nweb services. In CEC-EAST 04:ProceedingsoftheE-Commerce Technology for Dynamic E-Business, IEEE International \nConference, pages 270 273, Washington, DC, USA, 2004. IEEEComputerSociety. [8] IBM. Projectzero. http://www.projectzero.org/. \n[9] Navendu Jain, Lisa Amini, Henrique Andrade, Richard King,YoonhoPark,PhilippeSelo, andChitraVenkatramani. \nDesign, implementation, and evaluation of the linear road bnchmark on the stream processing core. In \nSIGMOD 06: Proceedings of the 2006 ACM SIGMOD international conference on Management of data, pages 431 \n442, New York,NY,USA,2006.ACM. [10] In-Gyu Kim, Doo-Hwan Bae, and Jang-Eui Hong. A componentcompositionmodelproviding \ndynamic, .exible, and hierarchical composition of components for supporting software evolution. J.Syst.Softw.,80(11):1797 \n1816,2007. [11] JulioLeite,YijunYu,LinLiu,EricYu, andJohnMylopoulos. Quality-based software reuse. Lecture \nNotes in Computer Science,3520:535 550,January2005. [12] Zhen Liu, Anand Ranganathan, and Anton Riabov. \nA planning approach for message-oriented semantic web service composition. In AAAI, pages 1389 1394. \nAAAI Press,2007. [13] TizianaMargaria andBernhardSteffen. Ltlguidedplanning: Revisiting automatic tool \ncomposition in eti. In SEW 07: Proceedings of the 31st IEEE Software Engineering Workshop, pages 214 \n226, Washington, DC, USA, 2007. IEEEComputerSociety. [14] D. Mennie and B. Pagurek. An architecture to \nsupport dynamic composition ofservice components. 2000. [15] Rym Mili, Ali Mili, and Roland T. Mittermeir. \nStoring and retrieving software components:A re.nementbased system. IEEETrans.Softw.Eng.,23(7):445 460,1997. \n[16] J. Paul Morrison. Data responsive modular, interleaved task programming system. IBM Technical Disclosure \nBulletin, 13(8):2425 2426,January1971. [17] NOAA. Acronyms and abbreviations used by the statistical \nmodelingbranch,2008. [18] Andreas L. Opdahl and Guttorm Sindre. Facet models for problem analysis. In \nCAiSe 95: Proceedings of the 7th International Conference on Advanced Information Systems Engineering, \npages 54 67, London, UK, 1995. Springer-Verlag. [19] Rub\u00b4enPrieto-D\u00b4iaz. Implementing faceted classi.cationfor \nsoftware reuse. Commun.ACM,34(5):88 97,1991. [20] Ken Pu, Vagelis Hristidis, and Nick Koudas. Syntactic \nrule based approach to web service composition. In ICDE 06: Proceedings of the 22nd International Conference \non Data Engineering, page 31, Washington, DC, USA, 2006. IEEE ComputerSociety. [21] Lirong Qiu, Fen Lin, \nChanglin Wan, and Zhongzhi Shi. Semantic web services composition using ai planning of description logics. \nIn APSCC 06: Proceedings of the 2006 IEEEAsia-Paci.cConference onServicesComputing,pages 340 347, Washington, \nDC, USA, 2006. IEEE Computer Society. [22] S R Ranganathan. Colon Classi.cation. Asia Publishing House,Bombay,India,1933. \n[23] Alastair Reid, Matthew Flatt, Leigh Stoller, Jay Lepreau, and Eric Eide. Knit: Component composition \nfor systems software. In Proc. of the 4th Operating Systems Design and Implementation(OSDI),pages347 \n360,2000. [24] A. Riabov and Z. Liu. Planning for stream processing systems. In AAAI,2005. [25] Anton \nV. Riabov, Eric Bouillet, Mark D. Feblowitz, Zhen Liu, and Anand Ranganathan. Wishful search: Interactive \ncomposition ofdata mashups. In WWW,April2008. [26] Dennis Ritchie. The evolution of the unix time-sharing \nsystem. In Proceedings of aSymposium onLanguageDesign and Programming Methodology,pages 25 36,London,UK, \n1980.Springer-Verlag. [27] Mithun Sheshagiri, Marie desJardins, and Tim Finin. A Planner for Composing \nServices Described in DAML-S. In Proceedings of the AAMAS Workshop on Web Services and Agent-basedEngineering,,June2003. \n[28] Kaarthik Sivashanmugam, John A. Miller, Amit P. Sheth, and Kunal Verma. Framework for semantic web \nprocess composition. Int.J.Electron.Commerce,9(2):71 106,2003. [29] Maxym Sjachyn and Ljerka Beus-Dukic. \nSemantic compo\u00adnent selection SemaCS.InICCBSS 06:Proceedingsofthe Fifth International Conference on Commercial-off-the-Shelf \n(COTS)-Based Software Systems,page 83,Washington, DC, USA,2006.IEEEComputerSociety. [30] DavidSkogan,RoyGronmo,andIdaSolheim. \nWeb service composition in uml. In EDOC 04: Proceedings of the EnterpriseDistributedObjectComputingConference,Eighth \nIEEE International, pages 47 57, Washington, DC, USA, 2004.IEEEComputerSociety. [31] Renata Slota, Joanna \nZieba, Bartosz Kryza, and Jacek Kitowski. Knowledge evolution supporting automatic work.ow composition. \nIn E-SCIENCE 06: Proceedings of the Second IEEE International Conference on e-Science andGridComputing,page37,Washington,DC,USA,2006. \nIEEEComputerSociety. [32] Vijayan Sugumaran and Veda C. Storey. A semantic-based approachto component \nretrieval. SIGMISDatabase,34(3):8 24,2003. [33] Axel van Lamsweerde, Anne Dardenne, B. Delcourt, and \nF. Dubisy. The kaos project: Knowledge acquisition in automated speci.cation of software. In Proceedings \nof the AAAI Spring Symposium Series, pages 59 62, Stanford University, Stanford, CA, 1991. American Association \nfor Arti.cialIntelligence . [34] Jian Yang, Mike P. Papazoglou, Bart Orri\u00a8ens, and Willem-Jan van Heuvel. \nA rule based approach to the service composition life-cycle. In WISE 03: Proceedings of the FourthInternationalConference \nonWebInformationSystems Engineering, page 295, Washington, DC, USA, 2003. IEEE ComputerSociety. \n\t\t\t", "proc_id": "1449764", "abstract": "<p>In the realm of component-based software systems, pursuers of the holy grail of automated application composition face many significant challenges. In this paper we argue that, while the general problem of automated composition in response to high-level goal statements is indeed very difficult to solve, we can realize composition in a restricted context, supporting varying degrees of manual to automated assembly for specific types of applications. We propose a novel paradigm for composition in flow-based information processing systems, where application design and component development are facilitated by the pervasive use of faceted, tag-based descriptions of processing goals, of component capabilities, and of structural patterns of families of application. The facets and tags represent different dimensions of both data and processing, where each facet is modeled as a finite set of tags that are defined in a controlled folksonomy. All data flowing through the system, as well as the functional capabilities of components are described using tags. A customized AI planner is used to automatically build an application, in the form of a flow of components, given a high-level goal specification in the form of a set of tags. End-users use an automatically populated faceted search and navigation mechanism to construct these high-level goals. We also propose a novel software engineering methodology to design and develop a set of reusable, well-described components that can be assembled into a variety of applications. With examples from a case study in the Financial Services domain, we demonstrate that composition using a faceted, tag-based application design is not only possible, but also extremely useful in helping end-users create situational applications from a wide variety of available components.</p>", "authors": [{"name": "Eric Bouillet", "author_profile_id": "81100404534", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1223250", "email_address": "", "orcid_id": ""}, {"name": "Mark Feblowitz", "author_profile_id": "81479647994", "affiliation": "IBM Research, Cambridge, MA, USA", "person_id": "P1223251", "email_address": "", "orcid_id": ""}, {"name": "Zhen Liu", "author_profile_id": "81351591327", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1223252", "email_address": "", "orcid_id": ""}, {"name": "Anand Ranganathan", "author_profile_id": "81100282186", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1223253", "email_address": "", "orcid_id": ""}, {"name": "Anton Riabov", "author_profile_id": "81100023520", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P1223254", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449810", "year": "2008", "article_id": "1449810", "conference": "OOPSLA", "title": "A tag-based approach for the design and composition of information processing applications", "url": "http://dl.acm.org/citation.cfm?id=1449810"}