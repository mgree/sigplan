{"article_publication_date": "10-19-2008", "fulltext": "\n ConstrainedTypesfor Object-Oriented Languages * Nathaniel Nystrom * Vijay SaraswatJensPalsberg nystrom@us.ibm.com \nvsaraswa@us.ibm.com palsberg@cs.ucla.edu Christian Grothoff christian@grotho..org Abstract X10 is a modern \nobject-oriented language designed for pro\u00adductivity and performance in concurrent and distributed sys\u00adtems. \nIn this setting, dependent types offer signi.cant oppor\u00adtunities for detecting design errors statically, \ndocumenting design decisions, eliminating costly run-time checks (e.g., for array bounds, null values), \nand improving the quality of generated code. We present the design and implementation ofconstrained types, \na natural, simple, clean, and expressive extension to object-oriented programming:Atype C{c} names a \nclass or interface C and a constraint c on the immutable state of C and in-scope .nal variables. Constraints \nmay also be asso\u00adciated with class de.nitions (representing class invariants) and with method and constructor \nde.nitions (representing preconditions). Dynamic casting is permitted. The system is parametric on the \nunderlying constraint system: the com\u00adpiler supportsa simple equality-based constraint systembut, in \naddition, supports extension with new constraint systems using compiler plugins. Categories and Subject \nDescriptors D.3.2 [Language Classi.cations]: Object-oriented languages; D.3.3 [Lan\u00adguage Constructs andFeatures]: \nClasses and objects, Con\u00adstraints General Terms Languages * IBMT. J.Watson Research Center,P.O. Box 704,Yorktown \nHeights NY 10598 USA UCLA Computer Science Department, Boelter Hall, Los Angeles CA 90095 USA Department \nof Computer Science, University of Denver, 2360 S. Gaylord Street, John Green Hall, Room 214, Denver \nCO, 80208 USA Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n08, October 19 23, 2008, Nashville,Tennessee, USA. Copyright c . 2008ACM 978-1-60558-215-3/08/10... $5.00 \n1. Introduction X10 is a modern statically typed object-oriented language designed for high productivity \nin the high performance com\u00adputing (HPC) domain [58]. Built essentially on sequential imperative object-oriented \ncore similar to Scala or JavaTM , X10 introduces constructs for distribution and .ne-grained concurrency(asynchrony, \natomicity, ordering). The design of X10 requiresarichtype systemtopermita large variety of errors to \nbe ruled out at compile time and to generate ef.cient code. Likemost object-oriented languages, X10 supports \nclasses; however, it places equal emphasis on arrays, a central data structure in high performance com\u00adputing. \nIn particular, X10 supports dense, distributed multi\u00addimensional arraysofvalue and reference types,builtover \nindex sets known as regions. Akeygoal ofX10 is to rule out large classes of error by design.For instance, \nthe possibilityof indexinga 2-d array with 3-d points should simply be ruled out at compile-time. This \nmeans that one must permitthe programmer to express types such as Region(2), the type of all two-dimensional \nregions, and Array[int](r), the type of all int arrays de\u00ad.ned over a given region r. For concurrent \ncomputations, one needs the ability to statically check that a method is being invoked by an activity \nthat is registered with a given clock (i.e., dynamic barrier) [58].For distributed computa\u00adtions, the \ncompiler needs to be aware of the location of ob\u00adjects: for instance, Tree{loc==here} is the type of \nall Tree objects located on the current node. For performance, it is necessary that array accesses are \nbounds-checked statically. Further, certain regions (e.g., rectangular regions) may be represented particularly \nef.\u00adciently. Arrays de.ned over sparse regions may be imple\u00admented with less memory overhead. Hence, \nif a variable is to range only over rectangular regions, it is important that this information is conveyed \nthrough the type system to the code generator. In this paper we describe X10 s support for constrained \ntypes, a form of dependent type [37, 64, 49, 5, 6, 3, 16] types parametrized by values de.ned on predicates \nover the immutable state of objects. Constrained types statically capture manycommon invariants that \nnaturally arise in code. For instance, typically the shape of an array (the number of dimensions (the \nrank) and the size of each dimension) is determined at run time,but is .xed once the array is con\u00adstructed. \nThus, the shape of an array is part of its immutable state. Both mutable and immutable variables may \nhave a constrainedtype: the constraint speci.es aninvariant on the immutable state of the object referenced \nby the variable. X10 provides a framework for specifying and checking constrained types that achieves \ncertain desirable properties: Ease of use. The syntax of constrained types is a simple and natural extension \nof nominal class types.  Flexibility. The framework permits the development of concrete, speci.c type \nsystems tailored to the application area at hand. X10 s compiler permits extension with dif\u00adferent constraint \nsystems via compiler plugins, enabling a kind of pluggable type system [9]. The framework is parametric \nin the kinds of expressions used in the type system, permitting the installed constraint system to in\u00adterpret \nthe constraints.  Modularity. The rules for type-checking are speci.ed onceinaway thatis independentofthe \nparticularvocab\u00adulary of operations used in the dependent type system. The type system supports separate \ncompilation.  Static checking. The framework permits mostly static type-checking. The user is able to \nescape the con.nes of static type-checking using dynamic casts.  1.1 Constrained types X10 s sequentialsyntaxissimilartoScala \ns[47].Wepermit the de.nition of a class C to specify a list of typed param\u00adeters or properties, f1: T1,...,fk \n: Tk, similar in syntactic structure to a method formal parameter list. Each property in thislistis treatedasa \npublic .nal instance .eld.We also permit the speci.cation of a class invariant in the class def\u00adinition, \na boolean expression on the properties of the class. The compiler ensures that all instances of the class \ncreated at run time satisfy the invariant.For instance, we may specify a class List with an int length \nproperty as follows: class List(length: int){length >= 0} {...} The class invariant states that the length \nof the list is greater than zero. Given such a de.nition for a class C, types can be constructed by constraining \nthe properties of C with a boolean expression. In principle, any boolean expression over the properties \nspeci.es a type: the type of all in\u00adstances of the class satisfying the boolean expression. Thus, List{length \n== 3}, List{length <= 42} and even List{length * f() >= 0} (where f is function on the immutable state \nof the List object) are permissible types. 1 class List(n: int{self >= 0}) { 2 var head: Object = null; \n3 var tail: List(n-1) = null; 4 5 def this(): List(0) { property(0); } 6 7 def this(head: Object, tail: \nList): List(tail.n+1) { 8 property(tail.n+1); 9 this.head = head; 10 this.tail = tail; 11 } 12 13 def \nappend(arg: List): List(n+arg.n) { 14 return n==0 15 ? arg : new List(head, tail.append(arg)); 16 } 17 \n18 def reverse(): List(n) = rev(new List()); 19 def rev(acc: List): List(n+acc.n) { 20 return n==0 21 \n? acc : tail.rev(new List(head, acc)); 22 } 23 24 def filter(f: Predicate): List{self.n <= this.n} { \n25 if (n==0) return this; 26 val l: List{self.n <= this.n-1} = tail.filter(f); 27 return (f.isTrue(head)) \n? new List(head,l) : l; 28 } 29 } Figure 1. This program implements a mutable list of Ob\u00adjects. The \nsize of a list does not change through its lifetime, even though at different points in time its head \nand tail might point to different structures. In practice,the constraintexpressionis restrictedbythepar\u00adticular \nconstraint system in use. Our basic approach to introducing constrained types into X10 isto followthe \nspiritof generic types,butto useval\u00adues instead of types. In general, a constrained type is of the form \nC{e}, the name of a class or interface1 C, called the base class, followed by a condition e. The condition \nmay refer to the properties of the base class and also to any .\u00adnal variables in scope where the type \nappears. Such a type represents a re.nement of C: the set of all instances of C whose immutable state \nsatis.es the condition e. We write C for the vacuously constrained type C{true}, and write C(e1,..., \nek) for the type C{f1==e1,...,fk==ek} where C declares the kproperties f1,...,fk. Also, for brevity, \na con\u00adstraint may be written as a comma-separated list of con\u00adjuncts, e.g., Point{x>0,y<=0}. Constrained \ntypes may occur wherever normal types oc\u00adcur. In particular, they may be used to specify the types of \nproperties, (possibly mutable) localvariables or .elds, argu\u00adments to methods, return types of methods; \ntheymay also be used in casts, etc. 1In X10, primitive types such as int and double are object types; \nthus, for example, int{self==0} is a legal constrained type. Usingthe de.nitions above, List(n),shownin \nFigure1, is the type of all lists of length n. Intuitively, this de.nition states thata List has an int \nproperty n,which must be non\u00adnegative. The properties of the class are set through the in\u00advocation of \nproperty(...) (analogously to super(...)) in the constructors of the class. In a constraint, the name \nself is bound and refers to the type being constrained. The name this,bycontrast,isafree variable in \nthe constraint and refers to the receiver parameter of the current method or constructor. Use of this \nis not permitted in static methods. The List class has two .elds (lines 2 3) that hold the head and tail \nof the list. The .elds are declared with the var keyword, indicating that they are not .nal. Variables \ndeclared with the val keyword, or withoutakeyword (e.g., length:int)are .nal. Constructors have return \ntypes that can specify an in\u00advariant satis.ed by the object being constructed. The com\u00adpiler veri.es \nthat the constructor return type and the class invariant are implied by the property statement and any \nsuper calls in the constructor body. A constructor must either invoke another constructor of the same \nclass via a this call or must have a property statement on every non\u00adexceptional path to ensure the properties \nare initialized. The List class has two constructors: the .rst constructor returns an empty list; the \nsecond returns a list of length m+1, where m is the length of the second argument. In the second constructor \n(lines 7 11), as well as the append (line 13) and rev (line 20) methods, the return type depends on properties \nof the formal parameters. If an argument appears in a return type then the parameter must be .nal, ensuring \nthe argument points to the same object throughouttheevaluationofthe methodor constructorbody. A parameter \nmay also depend on another parameter in the argument list. The use of constraints makes existential types \nvery nat\u00adural. Consider the return type of filter (line 24): it spec\u00adi.es that the list returned is of \nsome unknown length. The only thing known about it is that its size is bounded by n. Thus, constrained \ntypes naturally subsumeexistential depen\u00addent types. Indeed, every base type C is an existential con\u00adstrained \ntype since it does not specify anyconstraint on its properties. Thus, code written with constrained types \ncan in\u00adteract seamlessly with legacy library code, using just base types wherever appropriate. The return \ntype of filter also illustrates the difference between self and this. Here, self refers to the List being \nreturned by the method; this refers to a different List:the method s receiver. 1.2 Constraint system \nplugins The X10 compiler allows programmers toextend the seman\u00adtics of the language with compiler plugins. \nPlugins may be used to support different constraint systems [57] to be used in constrained types. Constraint \nsystems provide code for checking consistencyand entailment. The condition of a constrained type is parsed \nand type\u00adchecked as a normal boolean expression over properties and the .nal variables in scope at the \ntype. Installed constraint systems translate theexpression into an internal form, reject\u00adingexpressions \nthat cannotbe represented.Agiven condi\u00adtion may be a conjunction of constraints from multiple con\u00adstraint \nsystems.ANelson Oppen procedure [42] is used to check consistencyof the constraints. The X10 compiler \nimplements a simple equality-based constraint system. Constraint solver plugins have been im\u00adplemented \nfor inequality constraints, for Presburger con\u00adstraints using the CVC3 theorem prover [8], and for set\u00adbased \nconstraints also using CVC3. These constraint sys\u00adtems are describedinSection3 and the implementationis \ndiscussed in Section 4.  1.3 Claims The paper presents constrained types in the X10 program\u00adming language.We \nclaim that the design is natural, easy to use, and useful. Many example programs have been written using \nconstrained types and are available at x10.sf.net/ applications/examples. As in staged languages [43, \n61], the design distinguishes between compile-time and run-time evaluation. Constrained types are checked \n(mostly) at compile-time. The compiler uses a constraint solver to perform universal reasoning (e.g., \nfor all possible values of method parameters ) for depen\u00addent type-checking. There is no run-time constraint-solving. \nHowever, run-time casts and instanceof checks involving dependent types are permitted; these tests involvearithmetic, \nnot algebra the values of all parameters are known. The design supports separate compilation: a class \nneeds to be recompiled only when it is modi.ed or when the method and .eld signatures or invariants of \nclasses on which it depends are modi.ed. We claim that the design is .exible. The language de\u00adsign is \nparametric on the constraint system being used. The compiler supports integration of different constraint \nsolvers into the language. Dependent clauses also form the basis of a general user-de.nable annotation \nframework we have im\u00adplemented separately [46]. We claim the design is clean and modular. We present \na simple core language CFJ, extending FJ [29] with con\u00adstrained types on top of an arbitrary constraint \nsystem.We present rules for type-checking CFJ programs that are para\u00admetric in the constraint system \nand establish subject reduc\u00adtion and progress theorems. Rest of this paper. Section2describes the syntax \nand se\u00admantics of constrained types. Section 3 works through a number of examples using a variety of \nconstraint systems. The compiler implementation, including support for con\u00adstraint system plugins, is \ndescribed Section 4.Aformal se\u00admantics for a core language with constrained types is pre\u00adsentedin Section5, \nanda soundness proofis presentedin the appendix. Section6reviews relatedwork. The paper con\u00adcludesin \nSection7witha discussionof futurework. 2. Constrained types This section describes constrained types \nin X10. 2.1 Properties A property is a public .nal instance .eld of a class that cannot be overridden \nby subclassing. Like any other .eld, a property is typed, and its type need not necessarily be primitive. \nProperties thus capture the immutable public state of an object, initialized when the object is created, \nthat can be classi.ed by constrained types. Syntactically, properties are speci.ed in a parameter list \nright after the name of the class in a class de.nition. The class body may contain speci.cations of other \n.elds; these .elds may be mutable. Propertiesmaybeof arbitrarytype.For instance,theclass Region in Figure \n2 has an int property called rank. In turn, the class Dist has a Region property, called region, and \nalso an int property rank. The invariant for Dist ensures that rank == region.rank. Similarly, an Array \nhas properties dist, region, and rank and appropriate constraints ensuring that the statically available \ninformation aboutthemis consistent.2Inthisway,rich constraintsonthe immutable portion of the object reference \ngraph, rooted at the current object and utilizing objects at user-de.ned types, may be speci.ed. 2.2 \nConstraints A constrained type is of the form C{e}, consisting of a base class C and a condition e, a \nboolean expression on the propertiesofthebase classandthe .nalvariablesin scopeat the type. Constraints \nspecify (possibly) partial information about the variables of interest. The type C{e} represents the \nset of all instances of C whose immutable state satis.es the condition e. Constraints may use the specialvariable \nself to stand for the object whose type is being de.ned. Thus, int{self>=0} is the set of natural numbers, \nand Point{x*x+y*y <= 1.0} representsthe interiorofa circle(fora class Point with two float properties \nx and y). When there is no ambiguity, a property reference self.x may be abbreviated to x. The type int{self==v} \nrepresents a singleton type, an int is of this type only if it has the same value as v. To be clear, \nself is not the same as this. In the code fragment in Figure 2, the method contains (line 2) has a parameter \np with type Point{self.rank==this.rank}. In the condition, self refers to the Point p; this refers 2All \nconstraint languages used in constrained types permit object refer\u00adences, .eld selection and equality. \nSuch constraint systems have been stud\u00adied extensively under the name of feature structures [2]. 1 class \nRegion(rank: int) { 2 def contains(p: Point{self.rank==this.rank}): 3 boolean { ... } 4 ... 5 } 6 7 class \nDist(region: Region, rank: int) 8 {rank == region.rank} { ... } 9 10 class Array[T](dist: Dist, region: \nRegion, rank: int) 11 {region == dist.region, rank == dist.rank} 12 { 13 def get(p: Point{region.contains(self)}: \nT { ... } 14 ... 15 } Figure 2. Fragment of X10 support for regions, distribu\u00adtions, and arrays to the \nmethod receiver, an instance of the enclosing class Region. Constraints are speci.ed in terms of an underlying \ncon\u00adstraint system [57] a pre-de.ned logical vocabulary of functions and predicates with algorithms for \nconsistency and entailment. The X10 compiler permits different con\u00adstraint systems to be installed using \ncompiler plugins [9]. Constraint system plugins de.ne a language of constraints by symbolically interpreting \nthe boolean expression speci\u00adfying a type s condition; plugins may report an error if the condition cannot \nbe interpreted. In principle, types may be constrained by any boolean expressionover the properties.For \npractical reasons, restric\u00adtions need to be imposed to ensure constraint checking is decidable. The condition \nof a constrained type must be a pure func\u00adtion only of the properties of the base class. Because proper\u00adties \nare .nal instance .elds of the object, this requirement ensures that whether or not an object belongs \nto a con\u00adstrained type does not depend on the mutable state of the object. That is, the status of the \npredicate this object be\u00adlongs to this type does not change over the lifetime of the object. Second, \nby insisting that each property be a .eld of the object, the question of whether an object is of a given \ntype can be determined merely by examining the state of the object and evaluating a boolean expression. \nOf course, an implementation is free to not explicitly allocate memory in the object for such .elds.For \ninstance, it may use some scheme of tagged pointers to implicitly encode the values of these .elds. Further, \nby requiring that the programmer distinguish certain .nal .eldsofa classas properties,we ensure thatthe \nprogrammer consciously controls which .nal .elds should beavailable for constructing constrained types.A.eld \nthat is accidentally .nal may not be used in the construction of a constrained type. It must be declared \nas a property. 2.3 Subtyping Constrained types come equipped with a subtype relation that combines the \nnominal subtyping relation of classes and interfaces with the logical entailment relation of the con\u00adstraint \nsystem. Namely, a constraint C{c} is a subtype of D{d} if C is a subtype of D and every value in C that \nsatis.es c also satis.es d. This de.nition implies that C{e1} is a subtype of C{e2} if e1 entails e2. \nIn particular, for all conditions e, C{e} is a subtype of C. C{e} is empty exactly when e conjoined with \nC s class invariant is inconsistent. Two constrained typesC1{e1} and C2{e2} are considered equivalent \nif C1 and C2 are the same base type and e1 and e2 are equivalent when considered as logical expressions. \nThus, for instance, C{x*x==4} and C{x==2 || x==-2} are equivalent types. 2.4 Final variables The useof \n.nal localvariables, formal parameters,and .elds in constrained types has proven to be particularly valuable \nin practice. The same variable that is being used in compu\u00adtation can also be used to specify types. \nThere is no need to introduce separate, universally and existentially quanti\u00ad.ed index variables as in, \nfor instance, DML [64]. Dur\u00ading type-checking, .nal variables are turned into symbolic variables some \n.xed but unknown value of the same type. Computationis performedina constraint-basedfash\u00adion on such \nvariables. Because of the usefulness of .nal variables in X10, vari\u00adables and parameters declared without \nanexplicit var or val keyword are considered .nal. 2.5 Method and constructor preconditions Methods \nand constructors may specify constraints on their (.nal) parameters, including the implicit parameter \nthis. For an invocation of a method or constructor to be type\u00adcorrect, the associated constraint must \nbe statically known to be satis.edbythe actual receiverand actualargumentsofthe invocation. The constraint \nthus imposes a precondition on callersof the method.For instance, the followingisavalid method declaration \nfor a recursive binary search method in a list class with a length property: def search(value: T, lo: \nint, hi: int) {0 <= lo, lo <= hi, hi < length}: T = ...; The precondition speci.es that the low and high \nsearch in\u00addices be within the list bounds and that the low index is less than or equal to the high index. \nThe precondition, anymethod parameter, and the method return type may all contain expressions involving \nthe formal parameters of the method. Anyparameter used in this way mustbe .nal, ensuringitisnot mutatedbythe \nmethodbody. 2.6 Inheritance Like Java, X10 supportsingle class inheritance and multiple interface inheritance. \nJava does not allow interfaces to specify instance .elds. Rather, all .elds in an interface are .nal \nstatic .elds (con\u00adstants). However, in X10 since properties play a centralrole in the speci.cation of \nre.nements of a type, it makes sense to permit interfaces to specify properties. Similarly, an inter\u00adface \nde.nition may specify an invariant on its properties: all classes implementing the interface must satisfy \nthe invariant. Methods in the body of an interface may have constraints on their parameters as well. \nAll classes implementing an interface must have a prop\u00aderty with the same name and type (either declared \nin the class or inherited from the superclass) for each property in the in\u00adterface. If a class implements \nmultiple interfaces and more than one of them speci.es a property with the same name, then they must \nall agree on the type of the property. The class must declarea single property with thegiven name and \ntype. Aclassmayextenda constrained class(or interface).The general form of a class declaration is thus: \nclass C(x1:C1{c1}, ..., xk:Ck{ck}){c} extends D{d} implements I1{c1}, ..., In{cn} {...} For all instances \nofC, the class invariant c, the invariants of the superclass and superinterfaces (speci.ed at their de.ni\u00adtions), \nas well as the constraints d and ci must hold. Declar\u00ading that C extends D{d} documents the programmer \ns intent that every call to super in a constructor for C must ensure that the invariant d is established \non the state of the class D. Our current implementation compiles X10 to Java [26], and erases dependent \ntype information. To simplify the translation no name mangling is needed when generating code it must \nbe the case that a class does not have two dif\u00adferent method de.nitions that con.ict with each other \nwhen the constrained clauses in their types are erased. A class inherits from its direct superclass and \nsuperin\u00adterfaces all their methods that are visible according to the access modi.ers and that are not \nhidden or overridden. A method m1ina class C1overridesamethod m2inasuperclass C2 if m1 and m2 have signatures \nwith equivalent unerased for\u00admal parameter types. It is a static error if m1 s erased signa\u00adture is the \nsame as m2 s,but m1 does not override m2. It is also a static error if the method precondition on m2 \ndoes not entail the precondition on m1. This restriction ensures that if the a call is type-checked against \nm2 at the superclass type C2,the precondition is satis.ed if the method is dispatched at run time to \nthe method m1 in the subclass C1. 2.7 Method dispatch Method dispatch takes only the class hierarchyinto \naccount, not dependent type information. Thus, X10 does not provide a form of predicate dispatch [11, \n39], evaluating constraints at run time to determine which method to invoke. This de\u00adsign decision ensures \nthat serious errors such as method in\u00advocation errors are captured at compile time. Such errors can arise \nbecause multiple incomparable methods with the same nameand acceptableargument listsmightbeavailableatthe \ndynamic dependent type of the receiver. 2.8 Constructorsfor dependent classes Constructors must ensure \nthat the class invariants of the given class and its superclasses and superinterfaces hold.For instance, \nthe nullary constructor for List ensures that the property length has the value 0: public def this(): \nList(0) { property(0); } The property statement is used to set all the properties of the new object simultaneously. \nCapturing this assignment in a single statement simpli.es checking that the constructor postcondition \nand class invariant are established. If a class has properties, every path through the constructor must \ncon\u00adtain exactly one property statement. Java-like languages permit constructors to throw excep\u00adtions. \nThis is necessary to deal with the situation in which the arguments to a constructor for a class C are \nsuch that no object can be constructed that satis.es the invariants for C. Dependent types make it possible \nto perform some of these checksat compile time.The classinvariantofa classexplic\u00aditly captures conditions \non the properties of the class that must be satis.ed by any instance of the class. Construc\u00adtor preconditions \ncapture conditions on the constructor ar\u00adguments. The compiler s static check for non-emptiness of thetypeofanyvariable \ncaptures theseinvariant violationsat compile time. The class invariant is part of the public interface \nof the class. Consequently, if the invariant of C is changed, a class that creates instances of C may \nneed to be recompiled to ensure the invariant is satis.ed by the instances. 2.9 Separation between compile-time \nand run-time computation Our design distinguishes between compile-time execution (performed during type-checking) \nand run-time execution. At compile time, the compiler processes the abstract syn\u00adtax tree of the program \ngenerating queries to the constraint solver. The only computation engine running is the con\u00adstraintsolver,which \noperatesonitsownvocabularyofpred\u00adicates and functions. Program variables (such as local vari\u00adables) that \noccur in types are dealt with symbolically. They are replaced with logical variables some .xed, but un\u00adknown \nvalue of the same type. The constraint solver must know how to process pieces of partial information \nabout these logical variables in order to determine whether some constraint is entailed. At run time, \nthe same program vari\u00adable will have a concrete value and will perform arith\u00admetic (calculations) where \nthe compiler performed alge\u00adbra (symbolic analysis). Constrained types may occur in a run-time cast eas \nT. Code is generated to check at run time that the expression e satis.es anyconstraints in T. 2.10 Equality-based \nconstraints The X10 compiler includes a simple equality-based con\u00adstraint system. All constraint systems \ninstalled using plug\u00adins must support at least the core equality-based constraints. Constraints are conjunctions \nof equalities between constraint terms: properties, .nal variables, compile-time constants, and self: \n(CTerm) t ::= x | self | this | t.f | n (Constraint) c,d ::= true | t==t | c&#38;c | x :T; c We use the \nsyntax x: T; c for the constraint obtained by existentially quantifying the variable x of type T in c. \n 2.11 Existential quanti.cation Constrained types subsume existential types.Forexample, the length of \nthe list returned by filter in Figure 1 is existentially quanti.ed. Operations on values of constrained \ntype propagate con\u00adstraints to the operation result by introducing existentially quanti.ed variables. \nConsider the assignment to c below: a: int{self >= 0} = ...; b: int{self >= 0} = ...; c: int{self >= \n0} = a*b; During type-checking, the type of a*b is computed from the types of a and b to be the type: \nint{x: int, y: int; self==x*y &#38; x>=0 &#38; y>=0} That is, there exist non-negative ints x and y whose \nprod\u00aduct is self. The constraint on this type is strong enough to establish the constraint required by \nc. If the computed con\u00adstraint cannotbe representedby anyinstalled constraint sys\u00adtem, the type of a*b \nis promoted to the unconstrained super\u00adtype int. 2.12 Real clauses Because object-oriented languages \npermit arbitrary mutual recursion between classes: classes A and B may have .elds of type B and A, respectively \nthe type/property graph may have cycles. The nodes in this graph are base types (class and interface \nnames). There is an edge from node A to node B if A has a property whose base type is B. Let us de.ne \nthe real clauseofa constrained type C{c} to bethesetof constraintsthatmustbe satis.edbyanyinstance of \nC{c}. This includes not only the condition c but also constraints that hold for all instances of C, as \ndetermined by C s class invariant. Let rc(C{c}) denote the real clause of C{c}.For simplicity, we consider \nonly top-level classes; thus, the only free variable in rc(C{c}) is self. We draw out self as a formal \nparameter and write rc(C{c}, z) for rc(C{c[z/self]}). Consider a general class de.nition: class C(x1:C1{c1}, \n..., xk:Ck{ck}){c} extends D{d} { ... } From this, we get: (c . d)[z/self,z/this] . rc(D,z) . rc(C,z) \n.. rc(C1{c1},z.x1) . \u00b7\u00b7\u00b7 . rc(Ck{ck},z.xk) That is, given a program P with classes C1,...,Ck, the set \nof real clauses for C1,...,Ck are de.ned in a mutually recursive fashion through the Clark completion \nof a Horn clause theory (over an underlying constraint system). The central algorithmic question now \nbecomes whether givenaconstrained claused,doesrc(C{c},z) entail d?From the aboveformulation the question \nis clearly semi-decidable. It is not clear however whether it is decidable. This is a direction for further \nwork. The X10 compiler is conservative and rejects programs with cyclic real clauses: programs where \nthe real clause of the type of a property p itself constrains p. In practice, manydata structureshave \nnon-cyclic real clauses.For these programs, the real clause can be computed quickly and only a bounded \nnumber of questions to the constraint solver are generated during type-checking.  2.13 Parametric consistency \nConsider the set of .nal variables that are referenced in a type T = C{c}. These are the parameters of \nthe type.Atype is said to be parametrically consistent if its (class) invari\u00adant c is solvable for each \npossible assignment of values to parameters.Types are required to be parametrically consis\u00adtent.Parametric \nconsistency is suf.cient to ensure that the extension of a type is non-empty.3 Consider a variation of \nList from Figure 1: class List(n: int{self >= 0}) { var head: Object; var tail: List{self!=null &#38; \nself.n==this.n-1}; ... } The type of the .eld tail is not parametrically consistent. There exists a value \nfor the property this.n, namely 0, for which the real clause self != null &#38; self.n == this.n-1 &#38; \nself.n >= 0 is not satis.able. Permitting tail to be null would allow the type to be non-empty. The compiler \nwill throwatype error whenit encounters the initializer for this .eld in a constructor since it will \nnot be able to prove that the initial value is of the given type. 3Parametric consistency is not necessary \nin that there may be programs whose types are parametrically inconsistent but which never encounter empty \ntypes at run time because of relationships in data values that are too complicatedtobe capturedbythetype \nsystem. 3. Examples The following section presents example uses of constrained types using several different \nconstraint systems. 3.1 Equality constraints The X10 compiler includes a simple equality-based con\u00adstraint \nsystem, described in Section 2. Equalities constraints are used throughout X10 programs.Forexample, to \nensure n-dimensional arrays are indexed only be n-dimensional in\u00addex points, the array access operation \nrequires that the ar\u00adray s rank property be equal to the index s rank. Equality constraints speci.ed \nin the X10 run-time library are used by the compiler to generate ef.cient code. For instance, an iteration \nover the points in a region can be optimized to a set of nested loops if the constraint on the region \ns type speci.es that the region is rectangular and of constant rank. 3.2 Presburger constraints Presburger \nconstraints are linear integer inequalities. A Presburger constraint solver plugin was implemented using \nCVC3[7,8].ThelistexampleinFigure1type-checksusing this constraint system. Presburger constraints are \nparticularly useful in a high\u00adperformance computing setting where array operations are pervasive. Xi \nand Pfenning proposed using dependent types for eliminating array bounds checks [63].APresburger con\u00adstraint \nsystem canbe usedtokeep trackof array dimensions and array indices to ensure bounds violations do not \noccur.  3.3 Set constraints:region-based arrays Rather than using Presburger constraints, X10 takes \nanother approach: following ZPL [10], arrays in X10 are de.ned over regions, sets of n-dimensional index \npoints [27]. For instance, the region [0:200,1:100] speci.es a collection of two-dimensional points (i,j) \nwith i ranging from 0 to 200 and j ranging from 1 to 100. Regionsandpoints were modeledinCVC3[8]to createa \nconstraint solverthat ensures array bounds violationsdo not occur: an array access type-checks if the \nindex point can be statically determinedtobeintheregionover whichthe array is de.ned. Region constraints \nare subset constraints written as calls to the contains method of the region class. The constraint solver \ndoes not actually evaluate the calls to the contains method, rather it interprets these calls symbolically \nas subset constraints at compile time. Constraints have the following syntax: 1 const NORTH: point{rank==2} \n= [1,0]; 2 const WEST: point{rank==2} = [0,1]; 3 4 def sor(omega: double, 5 G: Array[double]{rank==2}, \n6 iter: int): void { 7 outer: Region{self==G.region, rank==2} = G.region; 8 inner: Region{G.region.contains(self), \n9 rank==G.region.rank} 10 = outer &#38; (outer-NORTH) &#38; (outer+NORTH) 11 &#38; (outer-WEST) &#38; \n(outer+WEST); 12 13 d0: Region = inner.rank(0); // {i | (i,j) in inner} 14 d1: Region = inner.rank(1); \n// {j | (i,j) in inner} 15 16 if (d1.size() == 0) return; 17 18 d1min: int = d1.low(); 19 d1max: int \n= d1.high(); 20 21 for (var off: int = 1; off <= iter*2; off++) 22 finish foreach ((i): point in d0) \n23 if (i % 2 == off % 2) 24 for (ij: point in inner &#38; [i..i,d1min..d1max]) 25 G(ij) = omega / 4. \n26 * (G(ij-NORTH) + G(ij+NORTH) 27 + G(ij-WEST) + G(ij+WEST)) 28 * (1. -omega) * G(ij); 29 } Figure 3. \nSuccessive over-relaxation with regions (Constraint) c ::= r.contains(r) | ... (Region) r ::= t | [b1:d1,...,bk:dk] \n| r|r | r&#38;r | r-r | r+p | r-p (Point) p ::= t | [b1,..., bk] (Integer) b,d ::= t | n where t are \nconstraint terms (properties and .nal variables) and n are integer literals. Regions used in constraints \nare either constraint terms t, region constants, unions(|), intersections(&#38;), or differences (-), \nor regions where each point is offset by another point p using + or -. Forexample,the codein Figure3performsa \nsuccessive over-relaxation [54] of a matrix G with rank 2. The function declares a region variable outer \nas an alias for G s region and a region variable inner to be the subset of outer that excludes the boundary \npoints, formed by intersecting the outer region with itself shifted up, down, left, and right by one. \nThe function then declares two more regions d0 and d1, where di is set of points xi where (x0,x1) is \nin inner. The function iterates multiple times over points i in d0. The syntax finish foreach (line 22) \ntells the compiler to execute each loop iteration in parallel and to wait for all concurrent activities \nto terminate. The inner loop (lines 24 28) iterates over a subregion of inner. The type checker establishes \nthat the region property of the point ij (line 24) is inner &#38; [i..i,d1min..d1max], and that this \nregion is a subset of inner, which is in turn a subset of outer,the region of the arrayG. Thus, the accesses \nto the array in the loop body do not violate the bounds of the array. Akeyto making the program type-check \nis that the region intersection that de.nes inner (lines 10 11) is explicitly intersected with outer \nso that the constraint solver can determine that the result is a subset of outer. 4. Implementation The \nX10 compiler provides a framework for writing and checking constrained types. Constraints in the base \nX10 lan\u00adguage are conjunctions of equalities over immutable side\u00adeffect-free expressions. Compiler plugins \nmay be installed to support other constraint languages and solvers. The X10 compileris implementedasanextensionofJava \nusing the Polyglot compiler framework [44]. Expressions used in constrained types are type-checked as \nnormal non\u00addependent X10 expressions; no constraint solving is per\u00adformed on these expressions. During \ntype-checking, con\u00adstraints are generated and solved using thebuilt-in constraint solver or using solvers \nprovided by plugins. The system allows types to constrained by conjunctions of constraints in different \nconstraint languages. If constraints cannot be solved, an error is reported. 4.1 Constraint checking \nAfter type-checking a constraint as a boolean expression e, the abstract syntax tree for the boolean \nexpression is trans\u00adformed into a conjunction of predicates, e1 &#38; ... &#38;ek. Each conjunct ei is \ngiven to the installed constraint system plug\u00adins, which symbolically evaluate the expression to create \nan internal representation of the conjunct. If no constraint sys\u00adtem can handle the conjunct, an error \nis reported. To interoperate, the constraint solvers must share a com\u00admon vocabulary: constraint terms \nt range over the proper\u00adties of the base type, the .nal variables in scope at the type (including this), \nthe special variable self representing a value of the type, and .eld selections t.f. All constraint systems \nare required to support the trivial constraint true, conjunction, existential quanti.cation, and equality \non con\u00adstraint terms. In this form, the constraint is represented as a con\u00adjunction of constraints from \ndifferent theories. Constraints are checked for satis.ability using a Nelson Oppen pro\u00adcedure [42]. After \nconstructing a constraint-system speci.c representationofa conjunct,eachplugin computesthesetof term \nequalities entailedby the conjunct. These equalities are propagated to the other conjuncts, which are \nagain checked for satis.ability and any new equalities generated are prop\u00adagated. If a conjunct is found \nto be unsatis.able, an error is reported. During type-checking, the type checker needs to deter\u00admine \nif the type C{c} isa subtypeof D{d}. This is true if the base type C is a subtype of D and if the constraint \nc entails d.To check entailment, each constraint solver is asked if a given conjunct of d is entailed \nby c. If anyreportfalse, the entailment does not hold and the subtyping checkfails.  4.2 Translation \nAfter constraint-checking, the X10 code is translated to Java in a straightforward manner. Each dependent \nclass is trans\u00adlated into a single class of the same name without depen\u00addent types.Theexplicit propertiesofthe \ndependent class are translated into public final instance .elds of the target class.A property statementina \nconstructoris translatedto a sequence of assignments to initialize the property .elds. Foreach property,agetter \nmethodisalso generatedinthe target Java class. Properties declared in interfaces are trans\u00adlated into \ngetter method signatures. Subclasses implement\u00ading these interfaces thus provide the required properties \nby implementing the generated interfaces. Usually, constrained types are simply translated to non\u00adconstrained \ntypes by erasure; constraints are checked stati\u00adcally and need no run-time representation. However, depen\u00addent \ntypes may be used in casts and instanceof expres\u00adsions. The values of the properties of the object whose \ntype is being tested are suf.cient to implement the test. The lan\u00adguage does not allow existential constraints \nto be used in run-time type tests; this allows the tests of constrained types to be implemented by evaluating \nthe constraint with self boundtotheexpressionbeing tested.Forexample, castsare translated as: [e as C{c}] \n= new Object() { C cast(C self) { if return self; ([c]) throw new ClassCastException(); } }.cast((C) \n[e]) Wrapping theevaluationof c in an anonymous class ensures the expression e is evaluated only once. \nTo support separate compilation, abstract syntax trees for constraints are embedded into the generated \nJava code, and from there into the generated class .le. The compiler reconstructs dependent types in \nreferenced class .les from their ASTs. 5. Formal semantics In this sectionwe formalizea small fragmentof \nX10, CFJ an extension of Featherweight Java (FJ) [29] with con\u00adstrained types to illustrate the basic \nconcepts behind con\u00adstrained type-checking.Aproofof soundnessisgivenin the appendix. The language is \nfunctional in that assignment is not ad\u00admitted. However, it is not dif.cult to introduce the notion of \nmutable .elds, and assignment to such .elds. Since con\u00adstrained types may only refer to immutable state, \nthe valid\u00adity of these types is not compromised by the introduction of state. Further, we do not formalize \noverloading of methods. Rather, as with FJ, we simply require that the input program be such that the \nclass name C and method name m uniquely select the associated method on the class. The language is de.ned \nover a constraint system C that includes equality constraints over .nal access paths, con\u00adjunction, existential \nquanti.cation, and a vocabulary of for\u00admulas and predicates. 5.1 The Object constraint system Given a \nprogram P,wenowshowhowtobuildalarger con\u00adstraint system O(C) on top of C which captures constraints related \nto the object-oriented structure of P. O includes the inferencerulesshowninFigure4for structualand subtyping \nconstraints. In addition, O(C) subsumes C in that if G fC c then G fO c. The constraint class(C) is intended \nto be true for all classes C de.nedinthe program.Foravariable x,fields(x) is intendedtospecifythe (complete)setoftyped \n.eldsavail\u00adable to x. x has I is intended to specify that the member I (.eld or method) is available \nto x for instance it is de.ned at the class at which x is declared or inherited by it, or it is available \nat the upper bound of a type variable. The judg\u00adment G fO S <: T is intended to hold if S is a subtype \nof T in the environment G. We assume that the rules given are complete for de.n\u00ading the predicates C \n<: D and C has I, for classes C, D and members I;that is, if the rules cannot be used to establish fO \nC <: D (fO C has I), then it is the case that fO C <: D (fO \u00ac(C has I)). Such negative facts are important \nto es\u00adtablish inconsistency of assumptions (for instance, for the programming languages which permits \nthe user to state con\u00adstraints on type variables).  5.2 Judgments In the following G is a well-typed \ncontext, i.e., a .nite, possibly empty sequence of formulas x : T and constraints c satisfying: 1. for \nanyformula f in the sequence all variables x occur\u00adring in f are de.nedbya declaration x :T in the sequence \nto the left of f. 2. for any variable x , there is at most one formula x :T in G.  The judgments of \ninterest are as follows. (1)Type well\u00adformedness: G f T type, (2) Subtyping: G f S <: T, (3)Typ\u00ading: \nG f e :T, (4) Method OK (method M is well-de.ned for the class C): G f M OK in C, (5) Field OK (.eld \nf :T is well\u00adde.ned for the class C): G f f : T OK in C (6) Class OK: G f L OK (class de.nition L is \nwell-formed). In de.ning these judgments we will use G fO c, the judg\u00adment corresponding to the Object \nconstraint system. Recall Structural constraints: class C(...) extends D{...} . P fO class(C) (CLASS) \nfO new D(t).fi ==ti (SEL) G fO x :C,class(C) G fO inv(C, x) (INV) G fO fields(x) = f :T G fO x has fi \n:Ti (FIELD) x :Object fO fields(x)= (FIELDS-B) G, x :D fO fields(x)= g :V G,x :S fO fields(x)= f :V \nclass C(f :U){c} extends D{M}. C G, x :S{d}fO fields(x)= f :V{d[x/self]}G,x :C fO fields(x)= g :V, f \n:U[x/this] G,x :(y :U;S) fO fields(x)= f :(y :U;V) (FIELDS-I) (FIELDS-C,E) G, x :C fO class(C) . =[x/this] \nG,x :D fO x has m(z :V){c} :T = e G,x :S fO x has m(z :V){c} :T = e def m(z :V){c} :T = e . P class C(...) \nextends D{M} m . M G, x :S{d}fO x has m(z :V){c} :T{d[x/self]} = e (METHOD-I) G, x :C fO x has (m(z \n:V.){c.} :T. = e) G,x :C fO x has m(z :V){c} :T = e G,x :(y :U;S) fO x has m(z :V){c} :(y :U;T)= e (METHOD-B) \n(METHOD-C,E) Subtyping: fO T <: T (S-ID) G fO T1 <:T2 , T2 <: T3 class C(...) extends D{...}. P G f \nT{c} type (S-TRANS) (S-EXTENDS) (S-CONST-L) G fO T1 <:T3 fO C <: D G fO T{c}<: T G fO S<:T G,self :S \nfO c G f U type G fO S <: T (x fresh) G f t :UG fO S <: T[t/x] (S-CONST-R) (S-EXISTS-L) (S-EXISTS-R) \nG fO S <: T{c} G fO x :U;S <: T G fO S <: x :U;T For a classC andvariable x, inv(C,x) stands for the \nconjunction of class invariants for C and its supertypes, with this replaced by x. Figure 4. The Object \nconstraint system, O that O subsumes the underlying constraint system C. For simplicity, we de.ne G f \nc to mean s(G) fO c, where the constraint projection, s(G) is de.ned as allows. s(e)= true s(x :C,G) \n= s(G) s(x :T{c},G) = c[x/self], s(x :T,G) s(x :(y :S;T),G) = s(y :S,x :T, G) s(c, G) = c, s(G) Above, \nin the third rule we assume that alpha-equivalence is used to choose the variable x from a set of variables \nthat does not occur in the context G. We say that a context G is consistent if all (.nite) sub\u00adsets of \n{s(f) | G f f} are consistent. In all type judgments presented below (T-CAST, T-FIELD etc) we make the \nim\u00adplicit assumption that the context G is consistent; if it is in\u00adconsistent, the rule cannot be used \nand the type of the given expression cannotbe established (type-checkingfails).  5.3 CFJ The syntax \nand semantics of CFJ is presented in Figure 5. The syntax is essentially that of FJ with the following \nmajor exceptions. First, types may be constrained with a clause {c}. Second both classes and methods \nmay have constraint clauses c in the case of classes, c is to be thought of as an invariant satis.ed \nby all instances of the class, and in the case of methods, c is an additional condition that must be \nsatis.ed by the receiver and the arguments of the method in order for the method to be invoked. straints \nare well-formed if they are of the pre-given type o. The rules PRED and FUN ensure that predicates and \nformu\u00adlas are well-formed and appeal to the constraint system C. The set of types includes classes C \nand is closed un\u00adder constrained types(T{c})and existential quanti.cation (x:S;T). An object o is of \ntype C (for C a class) if it is an instance of a subtype of C;it is of typeT{c} if it is of type T and \nit satis.es the constraint c[o/self]4;it is of typex:S;T if there is some object q of type S such that \no is of type T[q/x] (treating at type as a syntactic expression). The rules for well-formedness of types \nare straightfor\u00adward,given the assumption that constraints areof type o. Typing rules. T-VAR is as expected, \nexcept that it asserts the constraint self==x which records thefact that anyvalue of this type is known \nstatically to be equal to x. This con\u00adstraint is actually crucial as we shall see in the other rules \nonce we establish that an expression e is of a given type T, we transfer the type to a freshly chosen \nvariable z. If in facte has a static name x (i.e., e is known statically to be equal to x;that is, e \nis of type T{self==x}), then T-VAR lets us assert that z:T{self==x}, i.e., z equals x. ThusT-VARprovides \nan important base case for reasoning statically about equality of values in the environment. We do away \nwith the three casts provided inFJ infavor of a single cast, requiring only that e be of some type U. \nAt run time e will be checked to see if it is actually of type T (see RuleR-CAST). We assume a constraint \nsystem C, with a vocabulary of 4Thus the constraint c in a type T{c} should be thought of as a unary \npredicates q and functions f. Constraints include true, con\u00ad predicate .self.c, an object is of this \ntype if it is of type T and satis.es junctions, existentials, predicates, and term equality. Con-this \npredicate. CFJ productions: (Class) L ::= class C(f :T){c} extends N {M}(Method) M ::= def m(x :T){c}:T \n= e; (Exp.) e ::= x | this | e.f | Constraint well-formedness rules: G f true :o q(T) :o . C G f t :T \nG f q(T) :o Type well-formedness rules: G f class(C) (TRUE) (PRED) (CLASS) G f C type Typing rules: G,x \n:T f x :T{self == x} (T-VAR) G f e :T, e :T e.m(e) | new C(e) | e as T G f c0 :oG f c1 :o G f (c0 , \nc1 ) :o f(T) :T . C G f t :T G f f(T) :T G f S type,T type G f x :S;T type G f e :U G f T type G,z \n:T, z :T f z has m(z :U){c} :S = e,T <: U,c (z,z fresh) (T-INVK) G f e.m(e) :(z :T;z :T;S) this :C f \nc :o this :C,x :U,c f T type, U type,e :S,S <: T def m(x :U){c} :T = e; OK inC (METHOD OK) Transition \nrules: x :C f fields(x)= f :T (R-FIELD) (new C(e)).fi . ei e . e (RC-FIELD) e.fi . e' .fi f C{self == \nnew C(d)}<: T (R-CAST) new C(d) as T . new C(d) e . e (RC-CAST) e as T . e' as T (AND) (FUN) (EXISTS-T) \n (T-CAST) G f e as T :T (Type) S,T,U ::= N | T{c} | x:S;T (NType) N ::= C | N{c}(CTerm) t ::= x | self \n| this | t.f | new C(t) | f(t) (Const.) c,d ::= true | t==t | c,c | x:T;c | q(t) G f t :TG f c[t/x] :o \n(EXISTS) G f x :T;c :o G f t0:T0 G f t1:T1 (G f T0<: T1. G f T1<: T0) (EQUALS) G f t0==t1:o G f T type \nG, self :T f c :o (DEP) G f T{c} type G f e :S G,z :S f z has f :T (z fresh) (T-FIELD) G f e.f :(z :S;T{self \n== z.f}) G f e :T f class(C) G,z :C f fields(z)= f :U (z,z fresh) G,z :C, z :T,z.f = z f T <: U,inv(C,z) \n(T-NEW) G f new C(e) :C{z :T;new C(z)= self, inv(C, self)} M OK in C this :C f c :o this :C,c f T type,N \ntype (CLASS OK) class C(f :T){c} extends N{M} OK x :C f x has m(x :T){c} :T = e (R-INVK) (new C(e)).m(d) \n. e[new C(e),d/this, x] e . e (RC-INVK-RECV) e.m(e) . e.m(e) ei . ei. (RC-INVK-ARG) e.m(..., ei,...) \n. e.m(...,ei,...) ei . ei. (RC-NEW-ARG) new C(..., ei,...) . new C(...,ei,...) Figure 5. Semantics \nof CFJ T-FIELD may be understood through proxy reasoning as follows. Given the context G assume the receiver \ne can be established to be of type S. Now we do not know the run\u00adtime value of e,sowe shall assumethatitis \nsome.xedbut unknown proxy value z (of type S)that is fresh in that it is not known to be related to anyknown \nvalue (i.e., those recorded in G). If we can establish that z has a .eld f of type T5, then we can assert \nthat e.f has type T and, further, that it equals z.f. Hence, we can assert that e.f has type (z:S; T{self==z.f}). \nT-INVK has a very similar structure to T-FIELD: we use proxy reasoning for the receiver and the arguments \nof the method call. T-NEW also uses the same proxy reasoning; however,inthiscasewecan establishthattheresultingvalue \nis equal to new C(v) for somevalues v of thegiven type. The rule requires that the class invariant of \nC be established. Operational semantics. The operational semantics is es\u00adsentially identical to FJ [29]. \nIt is described in terms of a non-deterministic reduction relation on expressions. The only novelty is \nthe use of the subtyping relation to check that the cast is satis.ed. In CFJ, this test simply involves \nchecking that the class of which the object is an instance is a subclassoftheclass speci.edinthegiventype;inricherlan\u00adguages \nwith richer notions of type this operation may involve run-time constraint solving using the .elds of \nthe object.  5.4 Results The following results hold for CFJ. THEOREM 5.1 (Subject Reduction). If G f \ne :T and e . ethen for some type S, G f e' :S,S <: T. The theorem needs the Substitution Lemma: LEMMA \n5.2. If G f d : U, and G,x : U f U <: V, and G,x : V f e :T, then for some type S, it is the case that \nG f e[d/x] :S,S <: x :V;T. We let values be of the formv ::= new C(v). THEOREM 5.3 (Progress). If f e \n:T then one of the follow\u00ading conditions holds: 1. e is a value, 2. e contains a cast sub-expression \nwhichis stuck, 3. there exists an e' s.t. e . e' .  THEOREM 5.4 (Type soundness). If f e :T and e reduces \nto a normal form e' then either e' is a value v and f v :S,S <: T or e' contains a stuckcast sub-expression. \n6. Related work Constraint-based type systems. The use of constraints in type systems has a history going \nback to Mitchell [40] and Reynolds [55]. These and subsequent systems are based 5Note from the de.nition \nof fields in O (Figure4) that all occurrencesof this in the declared type of the .eld f will have been \nreplaced by z. on constraints over types, but not over values. Constraint\u00adbased type systems for ML-like \nlanguages [62, 53] lead to HM(X) [59], a constraint-based framework for Hindley Milner-style type systems. \nThe framework is parametrized on the speci.c constraint system X; instantiating X yields extensions of \nthe HM type system. The HM(X) approach is an important precursor to our constrained types approach. The \nprincipal difference is that HM(X) applies to functional languages and does not integrate dependent types. \nSulzmann and Stuckey [60] showed that the type infer\u00adence algorithm for HM(X) can be encoded as a constraint \nlogic program parametrizedbythe constraint system X. This is very much in spirit with our approach. Constrained \ntypes permit user-de.ned predicates and functions, allowing the user to enrich the constraint system, \nand hence the power of the compile-time type-checker, with application-speci.c constraints using a constraint \nprogramming language such as CLP(C)[30] or RCC(C)[31]. Dependent types. Dependent type systems [64, 16, \n38, 6] parametrize types on values. Constrained types are a form of re.nement type [24, 1, 32, 28, 19, \n20, 56]. Introduced by Freeman and Pfenning [24], re.nement types are dependent types that extend a base \ntype system through constraints on values. Our work is closely related to DML, [64], an extension of \nML with dependent types. DML is alsobuilt parametri\u00adcallyona constraintsolver.Typesare re.nementtypes;they \ndo not affect the operational semantics and erasing the con\u00adstraints yields a legal DML program. The \nmost obvious dis\u00adtinction between DML and constrained types lies in the tar\u00adget domain: DML is designed \nfor functional programming whereas constrained types are designed for imperative, con\u00adcurrent object-oriented \nlanguages. But thereare several other crucial differences as well. DML achieves its separation between \ncompile-time and run-time processing by not permitting program variables to be used in types. Instead, \na parallel set of (universally or ex\u00adistentially quanti.ed) index variables are introduced. Sec-ond,DML \npermitsonlyvariablesof basic index sortsknown to the constraint solver (e.g., bool, int, nat)to occur \nin types. In contrast, constrained types permit program vari\u00adables at any type to occur in constrained \ntypes. As with DML only operations speci.ed by the constraint system are permitted in types. However, \nthese operations always in\u00adclude .eld selection and equality on object references. Note that DML-style \nconstraints are easily encoded in constrained types. Logically quali.ed types, or liquid types [56], \npermit types in a base Hindley Milner-style type system to be re\u00ad.ned with conjunctions of logical quali.ers. \nThe subtyping relation is similar to X10 s: two liquid types are in the sub\u00adtyping relation if their \nbase types are and if one type s qual\u00adi.er implies the other s. The Hindley Milner type inference algorithm \nis used to infer base types; these types are used as templates for inference of the liquid types. The \ntypes of certain expressions are over-approximated to ensure infer\u00adence is decidable.To improve precision \nof the inference al\u00adgorithm, and hence to reduce the annotationburden on the programmer, the type system \nis path sensitive. X10 does not (yet) support type inference. Hybrid type-checking [19, 20] introduced \nanother re.ne\u00adment type system. While typing is undecidable, dynamic checks are inserted into the program \nwhen necessary if the type-checker (which includes a constraint solver) cannot de\u00adtermine type safety \nstatically. In X10, dynamic type checks, including tests of dependent constraints, are inserted only \nat explicit casts orinstanceof expressions; constraint solving is performed at compile time. Theorem \nprovers have also been integrated into the pro\u00adgramminglanguage.For instance, Concoqtion [22]extends \ntypes in OCaml [34] with constraints written as Coq [15] rules. Constraints thus have a different syntax, \nrepresenta\u00adtion, and behavior than the rest of the language. Proofs must be provided to satisfy the type \nchecker. In contrast, X10 sup\u00adportsa more limited constraint language that canbe checked by a constraint \nsolver during compilation. ESC/Java [21] allow programmers to write object invari\u00adants and pre-and post-conditions \nthat are enforced statically by the compiler using an automated theorem prover. Static checking is undecidable \nand, in the presence of loops, is un\u00adsound (but still useful) unless the programmer supplies loop invariants. \nUnlike X10, ESC/Java can enforce invariants on mutable state. Constraints in X10 are over .nal access \npaths. Several other languages have dependent types de.ned over .nal ac\u00adcess paths [17, 48, 51, 45, 50, \n49, 14, 25]. In manyof these languages, dependent path types are used to enforce type soundness for virtual \nclasses [35, 36, 18] or similar mech\u00adanisms. Jif [41, 13] uses dependent types over .nal access paths \nto enforce security properties: the security policyof an expression may depend on the policies of other \nvariables in the program. Aspects of these type systems can be encoded using equality constraints in \nX10.Forexample, fora.nal ac\u00adcess path p, p.type in Scala is the singleton type containing the object \np. Scala s p.type can be encoded in X10 using an equality constraint C{self == p}, where C is a supertype \nof p s static type. Pluggable types. In X10, constraint system plugins can provide a constraint solver \nto check consistencyand entail\u00adment of the extended constraint language. Pluggable and optional type \nsystems were proposed by Bracha [9] and provide a means of extending the base lan\u00adguage s type system. \nIn Bracha s proposal, type annotations, implemented in compiler plugins, may only reject programs statically \nthat might otherwise have dynamic type errors; theymay not change the run-time semantics of the language. \nJavaannotations[26,33]maybeusedtoextendtheJavatype system with compiler plugins. Other approaches, such \nas user-de.ned type quali.ers [23, 12] or JavaCOP [4] allow programmers to declaratively specify new \ntyping rules in a meta language rather than through plugins. We have focused on de.ning constraint\u00adchecking \nrules for the control constructs in the basic lan\u00adguage; additional rules can be de.ned for type-checking \nadditional control constructs in the language.For instance, rules can be de.ned to ensure that distributed \nconstructs in X10 are place-type safe. Such type-checking rules may be implemented in JavaCOP, provided \nthat it is extended with the underlying constraint solver. 7. Conclusion and future work We have presented \nthe design and implementation of con\u00adstrained types in X10. The design considerably enriches the space \nof statically checkable types expressible in the lan\u00adguage. This is particularly important for data-structures \nsuch as lists and arrays. Several examples of constrained types were presented. Constrained types have \nbeen implemented in X10 and used for place types, clocked types, and array types. The implementation \nsupports extension with constraint solver plugins. In future work, we plan to further investigate optimizations \nenabledby constrained types.Wealsoplanto explore type inference for constrained types and to pursue more \nexpressive constraint systems and extensions of con\u00adstrained types for handling mutable state, control \n.ow, and effects. Acknowledgments The authors thank Radha Jagadeesan, Norman Cohen, Pra\u00addeepVarma, Satish \nChandra, Martin Hirzel, Igor Peshansky, Lex Spoon,Vincent Cave,Vivek Sarkar, and the X10 team for fruitful \ndiscussions and implementation of the X10 com\u00adpiler and examples. This material is based upon work sup\u00adported \nby the Defense Advanced Research Projects Agency under its Agreement No. HR0011-07-9-0002. References \n[1] AlexanderAiken,EdwardL.Wimmers,andT.K. Lakshman. Soft typing with conditional types. In Proceedings \nof the 21st AnnualACM SIGPLAN SIGACT Symposium on Principles of Programming Languages (POPL),pages 163 \n173, January 1994. [2] Hassan Ait-Kaci. Alattice theoretic approachto computation based on a calculus \nof partially ordered type structures (property inheritance, semantic nets, graph uni.cation). PhD thesis, \nUniversity of Pennsylvania, 1984. [3] Thorsten Altenkirch, Conor McBride, and James McKinna. Why dependent \ntypes matter. http://www.e-pig.org/ downloads/ydtm.pdf, April 2005. [4] Chris Andreae, James Noble, Shane \nMarkstrum, andTodd Millstein. A framework for implementing pluggable type systems. In Proceedings of \nthe 2006ACM Conference on Object Oriented Programming Systems, Languages, and Applications (OOPSLA), \nOctober 2006. [5] David Aspinall and Martin Hofmann. Dependent Types, chapter 2. In Pierce [52], 2004. \n[6] Lennart Augustsson. Cayenne: a language with dependent types. In Proceedings of theACM SIGPLAN International \nConference on Functional Programming (ICFP 98), pages 239 250, 1998. [7] Clark Barrett and Sergey Berezin. \nCVC Lite: A new implementationofthe cooperatingvaliditychecker.InRajeev Alur and Doron A. Peled, editors, \nProceedings of the 16th International Conference on Computer Aided Veri.cation (CAV 04), volume 3114 \nof Lecture Notes in Computer Science, pages 515 518. Springer-Verlag, July 2004. Boston, Massachusetts. \n[8] Clark Barrett, Cesare Tinelli, Alexander Fuchs, Yeting Ge, George Hagen, and Dejan Jovanovic. CVC3. \nhttp://www.cs.nyu.edu/acsys/cvc3. [9] Gilad Bracha. Pluggable type systems. In OOPSLA 04 Workshop on \nRevival of Dynamic Languages, October 2004. [10] Bradford L. Chamberlain, Sung-Eun Choi, Steven J. Deitz, \nand Lawrence Snyder. The high-level parallel language ZPL improves productivity and performance. In Proceedings \nof the IEEE International Workshop on Productivity and Performance in High-End Computing, 2004. [11] \nCraig Chambers. Predicate classes. In ECOOP 93 Conference Proceedings, 1993. [12] Brian Chin, Shane Markstrum, \nandTodd Millstein. Semantic type quali.ers. In ProceedingsoftheACM SIGPLAN Confer\u00adence on Programming \nLanguage Design and Implementation (PLDI), pages 85 95, 2005. [13] Stephen Chong, Andrew C. Myers, K. \nVikram, and Lan\u00adtian Zheng. Jif reference manual, Jif 3.0.0 version. http://www.cs.cornell.edu/jif, June \n2006. [14] Dave Clarke, Sophia Drossopoulou, James Noble, andTobias Wrigstad.Tribe:asimple virtual class \ncalculus.In AOSD 07: Proceedings of the 6th international conference on Aspect\u00adoriented software development, \npages 121 134, NewYork, NY, USA, 2007.ACM Press. [15] The Coq proof assistant: Reference manual, version \n8.1. http://coq.inria.fr/, 2006. [16] Thierry Coquand and Gerard Huet. The Calculus of Constructions. \nInformation and Computation, 76, 1988. [17] Erik Ernst. gbeta: A Language with Virtual Attributes, Block \nStructure, and Propagating, Dynamic Inheritance. PhD thesis, Department of Computer Science, University \nof Aarhus, \u00b0Arhus, Denmark, 1999. [18] Erik Ernst, Klaus Ostermann, and William R. Cook. A virtual class \ncalculus. In Proc. 33th ACM Symp. on Principles of Programming Languages (POPL), pages 270 282, Charleston, \nSouth Carolina, January 2006. [19] Cormac Flanagan. Hybrid type checking. In Proceedings of the 33rdAnnual \nSymposium on Principles of Programming Languages (POPL 06), pages 245 256, 2006. [20] Cormac Flanagan, \nStephen N. Freund, and Aaron Tomb. Hybrid types, invariants, and re.nements for imperative objects. In \nInternationalWorkshoponFoundationsof Object-Oriented Programming (FOOL), 2006. [21] Cormac Flanagan, \nK. Rustan M. Leino, Mark Lillibridge, GregNelson, James B. Saxe, and Raymie Stata. Extended static checking \nfor Java. In Proceedings ofACM SIGPLAN Conference on Programming Language Design and Imple\u00admentation \n(PLDI), June 2002. [22] SethFogarty, EmirPasali. \u00b4c, Jeremy Siek, andWalidTaha. Concoqtion: indexed types \nnow! In Proceedings of the 2007ACM SIGPLANWorkshop onPartial Evaluation and Semantics-based Program Manipulation \n(PEPM), pages 112 121, January 2007. [23] JeffreyS.Foster,TachioTerauchi, and Alex Aiken. Flow\u00adsensitive \ntype quali.ers. In Proc. 29th ACM Symp. on Principles of Programming Languages (POPL), pages 1 12.ACM \nPress, June 2002. [24] Tim Freeman and Frank Pfenning. Re.nement types for ML. In Proceedings of theACM \nSIGPLAN Conference on Programming Language Design and Implementation (PLDI), pages 268 277, June 1991. \n[25] Vaidas Gasiunas, Mira Mezini, and Klaus Ostermann. Dependent classes. In OOPSLA 07: Proceedings \nof the 22nd annualACM SIGPLAN Conference on Object-oriented Programming Systems, Languages, and Applications, \npages 133 152.ACM, 2007. [26] J. Gosling, W. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation, \nThird Edition. Addison Wesley, 2006. [27] Christian Grothoff, JensPalsberg, andVijay Saraswat. Safe arrays \nvia regions and dependent types. Technical Report RC23911, IBMT.J.Watson Research Center, 2006. [28] \nJohn Hughes, LarsPareto, and Amr Sabry. Provingthe cor\u00adrectness of reactivesystems using sized types. \nIn Proceedings of the 23rdACM SIGPLAN SIGACT Symposium on Princi\u00adples of Programming Languages (POPL), \npages 410 423, 1996. [29] A.Igarashi,B. Pierce, andP.Wadler. FeatherweightJava:A minimal core calculus \nfor Java and GJ. In ACM Symposium on Object-Oriented Programming: Systems, Languages and Applications, \n1999. [30] J. Jaffar and J.-L. Lassez. Constraint Logic Programming. In Proceedings of the 14th Annual \nACM Symposium on Principles of Programming Languages (POPL 87), pages 111 119.ACM Press,NewYork (NY), \nUSA, 1987. [31] RadhaJagadeesan, Gopalan Nadathur,andVijayA. Saraswat. Testing concurrent systems: An \ninterpretation of intuitionistic logic. In Ramaswamy Ramanujam and Sandeep Sen, editors, FSTTCS,volume \n3821 ofLectureNotes in Computer Science, pages 517 528. Springer, 2005. [32] Mark P. Jones. Quali.ed \nTypes: Theory and Practice. Cambridge University Press, 1994. [33] JSR 308: Annotations on Java types. \nhttp://jcp.org/en/ jsr/detail?id=308. [34] Xavier Leroy et al. The Objective Caml system. http://caml.inria.fr/ocaml/. \n[35] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and K. Nygaard. Object Oriented Programming in the BETA \nProgramming Language. Addison-Wesley, June 1993. [36] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. \nVirtual classes:Apowerful mechanism for object-oriented program\u00adming. In Proc. OOPSLA 89, pages 397 406, \nOctober 1989. [37] Per Martin-L\u00a8of. ATheoryofTypes. 1971. [38] Conor McBride and James McKinna. The view \nfrom the left. Journal of Functional Programming, 14(1):69 111, 2004. [39] Todd Millstein. Practical \npredicate dispatch. In Proceed\u00adings of the 19thACM Conference on Object-Oriented Pro\u00adgramming Systems, \nLanguages and Applications (OOPSLA), October 2004. [40] John C. Mitchell. Coercion and type inference. \nIn Proceedings of the 11th Annual ACM Symposium on Principles of Programming Languages (POPL 84), pages \n174 185, 1984. [41] Andrew C. Myers. JFlow: Practical mostly-static information .ow control. In Proc. \n26th ACM Symp. on Principles of Programming Languages (POPL), pages 228 241, San Antonio, TX, January \n1999. [42] G. Nelson and D. Oppen. Simpli.cation by cooperating decision procedures. ACMTransactions \non Programming Languages and Systems (TOPLAS), 1(2), October 1979. [43] Flemming Nielson and Hanne Riis \nNielson. Two-level functional languages. Cambridge University Press, 1992. [44] Nathaniel Nystrom, Michael \nR. Clarkson, and Andrew C. Myers. Polyglot: An extensible compiler framework for Java. InG\u00a8orel Hedin, \neditor, Compiler Construction, 12th International Conference, CC 2003, number 2622 in LNCS, pages 138 \n152. Springer-Verlag, April 2003. [45] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. J&#38;: Nested \nintersection for scalable software extension. In Pro\u00adceedings of the 2006ACM Conference on Object Oriented \nProgramming Systems, Languages, and Applications (OOP-SLA 06), pages 21 36, Portland, OR, October 2006. \n[46] Nathaniel Nystrom andVijay Saraswat. An annotation and compiler plugin system for X10.Technical \nReport RC24198, IBMT.J.Watson Research Center, 2007. [47] Martin Odersky. Report on the programming language \nScala. Technical report, EPFL, 2006. [48] Martin Odersky, Philippe Altherr, Vincent Cremet, Bu\u00adrak Emir, \nSebastian Maneth, St\u00b4 ephane Micheloud, Niko\u00ad lay Mihaylov, Michel Schinz, Erik Stenman, and Matthias \nZenger. An overview of the Scala programming lan\u00ad guage, June 2004. http://scala.epfl.ch/docu/files/ \nScalaOverview.pdf. [49] Martin Odersky,Vincent Cremet, ChristineR\u00a8ockl, and Matthias Zenger.Anominal \ntheoryof objects with dependent types. In Proceedings of 17th European Conference on Object-Oriented \nProgramming (ECOOP 2003), number 2743 in Lecture Notes in Computer Science, pages 201 224. Springer-Verlag, \nJuly 2003. [50] Martin Odersky and Christoph Zenger. Nested types. In 8thWorkshop onFoundationsof Object-Oriented \nLanguages (FOOL), 2001. [51] Martin Oderskyand Matthias Zenger. Scalable component abstractions. In Proc. \nOOPSLA 05, pages 41 57, San Diego, CA, USA, October 2005. [52] Benjamin C. Pierce, editor. AdvancedTopics \ninTypes and Programming Languages. MIT Press, 2004. [53] Franc\u00b8ois Pottier. Simplifying subtyping constraints. \nIn Proceedingsof theACM SIGPLAN International Conference on Functional Programming (ICFP 96), pages 122 \n133, 1996. [54] W. H. Press, B. P. Flannery, S. A. Teukolsky, and W. T. Vetterling. Numerical Recipes \nin FORTRAN: The Art of Scienti.c Computing, pages 866 869. Cambridge University Press, 1992. Successive \noverrelaxation (SOR). [55] John C. Reynolds. Three approaches to type structure. In ProceedingsofTAPSOFT/CAAP \n1985,volume 185 of LNCS, pages 97 138. Springer-Verlag, 1985. [56] Patrick Rondon, Ming Kawaguchi, and \nRanjit Jhala. Liquid types. In Proceedings of ACM SIGPLAN Conference on Programming Language Design and \nImplementation (PLDI), June 2008. [57] Vijay Saraswat. The category of constraint systems is Cartesian \nclosed. In LICS 92, pages 341 345, 1992. [58] Vijay Saraswat et al. The X10 language speci.cation. Technical \nreport, IBMT.J.Watson Research Center, 2006. [59] Martin Sulzmann, Martin Odersky, and MartinWehr. Type \ninference with constrained types. In Fourth International Workshop onFoundations of Object-Oriented Programming \n(FOOL 4), 1997. [60] Martin Sulzmann and Peter J. Stuckey. HM(X) type inference is CLP(X) solving. Journal \nof Functional Programming, 18(2):251 283, 2008. [61]WalidTaha andTim Sheard. Multi-stage programming \nwith explicit annotations. In ACM/SIGPLANWorkshop onPartial Evaluation and Semantics-Based Program Manipulation, \npages 203 217, 1997. [62] Valery Trifonov and Scott Smith. Subtyping constrained types. In Third International \nStatic Analysis Symposium (SAS), number 1145 in LNCS, pages 349 365, 1996. [63] Hongwei Xi and Frank \nPfenning. Eliminating array bound checking through dependent types. In Proceedings ofACM SIGPLAN Conference \non Programming Language Design and Implementation (PLDI), pages 249 257, Montreal, Canada, June 1998. \n[64] Hongwei Xi and Frank Pfenning. Dependent types in practical programming. In Proceedings of the 26th \nAnnual ACM Symposium on Principles of Programming Languages (POPL 99), pages 214 227, San Antonio, TX, \nJanuary 1999. A. Soundness Here we prove a soundness theorem for CFJ. LEMMA A.1 (Substitution Lemma). \nIf G f d : U, G,x :U f U <: V, and G,x : V f e :T, then for some type S, G f e[d/x] :S,S <: x :V;T. PROOF. \nStraightforward. D LEMMA A.2 (Weakening). If G f e :T, then G,x :S f e :T. PROOF. Straightforward. D \nLEMMA A.3 (Method body type). If G,z :T f z has m(z :U){c} :S = e, and G,z :T,z :T f T <: U, then for \nsome type S' it is the case that G,z :T, z :T f e :S',S' :S. PROOF. Straightforward. D LEMMA A.4. If \nG f S <: T, then (z :S; c0)[x/self] fO (z :T; c0)[x/self] where x is fresh. PROOF. Straightforward. D \nLEMMA A.5. If G,x :U,c fO c0 and G f t :U, then G, c[t/x] fO c0[t/x]. PROOF. Straightforward. D LEMMA \nA.6. If G f S <: T, and s(G,f : T) fO c0, then s(G, f :S) fO c0. PROOF. By induction on the derivation \nof G f S <: T. We proceed by cases for the last judgment in the derivation. S-ID.Trivial.  S-TRANS. \nStraightforward from the inductionhypothe\u00adsis.  S-EXTENDS.We have S = C and T = D. From the de.ni\u00adtion \nof s(\u00b7) we have  s(G,f :C)= s(G,f :D)= s(G). The conclusion follows easily. S-CONST-L.We have S = T{c}. \nAssume s(G,f :T) fO c0. From the de.nition of s(\u00b7) we have s(G, f :T{c})= s(G,f :T),c[f/self]. Since \ns(G,f : T) fO c0, it follows immediately that s(G,f :T),c[f/self] fO c0. S-CONST-R. We have T = U{c} \nand G f S <: U and G,self :S f c. Assume s(G,f :U{c}) fO c0. From the de.nition of s(\u00b7) we have s(G,f \n:U{c})= s(G,f :U),c[f/self]. Thus, s(G,f :U),c[f/self] fO c0. Since G,self :S f c, we have G,f :S f c[f/self], \nand hence s(G, f :S) fO c[f/self]. Since G f S <: U, applying the induction hypothesis to c[f/self],we \nhaves(G,f :U) fO c[f/self]. Therefore, in the judgment s(G, f :U),c[f/self] fO c0, c[f/self] is redundant \nand we can conclude s(G,f :U) fO c0. Finally,applyingthe inductionhypothesisto c0, we have s(G,f :S) \nfO c0. S-EXISTS-L.We have S = x :U; V and G f U type and G fO V <: T where x is fresh. Assume s(G, f \n:T) fO c0.By the inductionhypothesis, s(G,f : V) fO c0. Adding x : U to the assumptions, we can conclude \ns(G,x :U,f :V) fO c0. From the de.nition of s(\u00b7) we have s(G,f :(x :U; V)) = s(G,x :U,f :V). Thus, s(G,f \n:S) fO c0. S-EXISTS-R.We have T = x : U;V and G f t : U and G fO S <: V[t/x]. Assume s(G,f :T) fO c0. \nFrom the de.nition of s(\u00b7) we have s(G,f :(x :U; V)) = s(G,x :U,f :V). Thus, s(G,x :U,f :V) fO c0. Since \nG f x :U,we can show via Lemma A.5 that s(G,f :V[t/x]) fO c0[t/x]. Since G f c0:o, x is not freein c0. \nThus c0[t/x]= c0 and s(G,f : V[t/x]) fO c0. Since, G fO S <: V[t/x and s(G,f : V[t/x) fO c0, by the induction \nhypothesis, we have s(G,f :S) fO c0. D LEMMA A.7. if G,f :T f U <: U', and G f S <: T, then G,f : S f \nU <: U'. PROOF. Follows From Lemma A.6. D LEMMA A.8. if G f S <: T, then G f E{z : S;c0}<: E{z : T;c0}. \nPROOF. To prove the desired conclusion G f E{z :S;c0}<: E{z :T;c0}, we need to show that s(G,x :E{z :S;c0}) \nfO (z :T;c0)[x/self]. We have s(G,x :E{z :S;c0})= s(G,(z :S;c0)[x/self]) From Lemma A.4 and G f S <: \nT, we have (z :S;c0)[x/self] fO (z :T;c0)[x/self]. From s(G,x :E{z :S;c0})= s(G,(z :S;c0)[x/self]) and \n(z :S;c0)[x/self] fO (z :T;c0)[x/self], we conclude s(G,x :E{z :S;c0}) fO (z :T;c0)[x/self]. D LEMMA \nA.9. If G f S <: T, and G, z :S f fields(z)= F1, and G, z :T f fields(z)= F2, then F2 is a pre.x of F1. \nPROOF. Follows from Lemma A.6 and rules for fields in O. D LEMMA A.10. If G f S <: T, and G,z : T f z \nhas I, then G,z :S f z has I. PROOF. Follows from Lemma A.6. D LEMMA A.11. If G f (x : S;T{c}) type, \nthen G f (x : S;T{c})<: T{x: S; c}). PROOF. Straightforward. D THEOREM A.12 (Subject Reduction). If \nG f e :V and e . e ', then for some type V ' , G f e ' :V ' and G f V ' <: V. PROOF. We proceed by induction \non the structure of the derivation of G f e : T.We now have .ve cases depending on the last rule used \nin the derivation of G f e :T. T-VAR:Theexpression cannot takea step, so the conclu\u00adsion is immediate. \n T-CAST:Wehavetwo subcases. R-CAST: For the expression o as V, where o = new C(d), wehave fromT-NEW \nthat  G f o :C{z :T;new C(z)= self;inv(C,self)}. Additionally, wehave fromR-CAST that f C{new C(d)= \nself}<: V. We now choose V ' = C{z :T;new C(z)= self;inv(C, self)}. FromS-EXISTS-L, G f z :T;C{new C(z)= \nself;inv(C,self)} <: C{new C(d)= self}. From Lemma A.11, G f z :T;C{new C(z)= self;inv(C,self)} <: C{z \n:T;new C(z)= self;inv(C,self)} Thus, fromS-TRANS, G f V ' <: V. RC-CAST:For theexpressiono as V, we have \nfrom T-CAST that G f o : U. Additionally, we have from RC-CAST that o . o '. From the inductionhypothe\u00adsis, \nwe have U ' such that G f o ' :U ' and G f U ' <: U.We ' now choose V ' = V. From G f o :U ' and T-CAST \nwe ' derive G f o asV :V. From V ' = V andS-ID wehave G f V ' <: V. T-NEW:Wehavea single case. RC-NEW-ARG: \nFor the expression new C(e), we have fromT-NEW that G f e :T, f class(C), G f z :C f fields(z)= f :S, \nG f z :C,z :T,z.f = z f T <: S,inv(C,z). WechooseV = C{z :T;new C(z)= self,inv(C,self)}. Additionally, \nwehave fromRC-N EW-ARG that ei . ' ei. From the induction hypothesis, we have Ui such ' that G f ei :Ui \nand G f Ui<: Ti. ' For all jexcept i,de.neU j= T jand e = e j.We have j G f e ' :U and G f U <: T. From \nLemma A.2, we have G f z :C,z :U,z.f = z f U <: T. FromT-NEW, wehave G f z :C,z :T,z.f = z f T <: S. \nFrom Lemma A.7, G f z :C,z :U,z.f = z f T <: S. FromS-TRANS, wehave G f z :C,z :U,z.f = z f U <: S. FromT-NEW, \nG f z :C,z :T, z.f = z f inv(C,z). From Lemma A.7, G f z :C,z :U, z.f = z f inv(C,z). Thus, byT-NEW, \nG f new C(e ') :C{z :U;new C(z)= self,inv(C,self)} and we choose V ' = C{z :U;new C(z)= self,inv(C,self)}. \nFrom Lemma A.4, we have G f V ' <: V. T-FIELD:Wehavetwo subcases. R-FIELD:For theexpression(new C(e)).fi \n, we have fromT-FIELD that G f e :S, G,z :S f z has fi :Ui. Let V =(z :S;Ui{self==z.fi}). z is fresh. \nWe have S = C{z :T;new C(z)= self,inv(C,self)}. FromT-NEW, wehave G f e :T and G f z :C,z :T,z.f = z \nf Ti<: Ui. From G f e :T, we have G f ei :Ti.We now choose V ' = Ti. ByT-NEW, G,z :C,z :T,z.f = z f Ti<: \nUi. ByS-CONST-R, G,z :C,z :T,z.f = z f Ti<: Ui{self = zi}. Since z.fi = zi, by application of S-ID, S-CONST-L, \nandS-CONST-R, wehave G,z :C,z :T,z.f = z f Ti<: Ui{self = z.fi}. We can then show viaS-EXISTS-Rthat G \nf Ti<: (z :S;Ui{self = z.fi}), or more simply G f V ' <: V. RC-FIELD: Follows from the induction hypothesis \nand application of Lemma A.8. T-INVK:Wehave three subcases. R-INVK:For simplicity,de.ned0= new C(e).For \nthe expression d0.m(d) wehave fromT-INVK that G f d0:T0 G f d1:n :T1:n G,z0:n :T0:n f z0 has m(z1:n:U1:n){c} \n:S = e G,z0:n :T0:n f T1:n<: U1:n G,z0:n :T0:n f c where z0:n is fresh.ByT-NEW, wehave G f e :A and T0 \n= C{z :A;self = new C(z),inv(C,self)}. Since G,z0:n :T0:n f z0 has m(z1:n:U1:n){c} :S = e, and G, z0:n \n: T0:n f T1:n <: U1:n, by Lemma A.3, we have for some S ' Gz0:n :T0:n f e :S ' ,S ' <: S. Choose V =(z0:n \n:T0:n; S '). FromR-INVK, wehave d0.m(d) . e[d0,d/this, z]. By Lemma A.1, G f e[d0,d/this,z] : V ', and \nG f V ' <: z0:n :T0:n; S. RC-INVK-RECV:Follows from the inductionhypoth\u00adesis and application of Lemma \nA.8. RC-INVK-ARG:Follows from the inductionhypoth\u00adesis and application of Lemma A.8. D Let the normal \nform of expressions be given by values v ::= new C(v). THEOREM A.13 (Progress). If f e :T, then one of \nthe fol\u00adlowing conditions holds: 1. e is a value v, 2. e contains a subexpression new C(v) as T such \nthat f C <: T[new C(v)/self],  '' 3. there exists e s.t. e . e . PROOF.Theproofhasa structurethatis \nsimilartotheproof of Subject Reduction; we omit the details. D ' THEOREM A.14 (Type Soundness). If f \ne :T and e .* e , '' with e in normal form, then e is either (1) a value v with f v :S and f S <: T, \nfor some type S, or, (2) an ex\u00adpression containing a subexpression new C(v) as T where f C <: T[new C(v)/self]. \nPROOF. Combine Theorem A.12 and Theorem A.13. D    \n\t\t\t", "proc_id": "1449764", "abstract": "<p>X10 is a modern object-oriented language designed for productivity and performance in concurrent and distributed systems. In this setting, dependent types offer significant opportunities for detecting design errors statically, documenting design decisions, eliminating costly run-time checks (e.g., for array bounds, null values), and improving the quality of generated code.</p> <p>We present the design and implementation of <i>constrained types</i>, a natural, simple, clean, and expressive extension to object-oriented programming: A type C{c} names a class or interface C and a <i>constraint</i> c on the immutable state of C and in-scope final variables. Constraints may also be associated with class definitions (representing class invariants) and with method and constructor definitions (representing preconditions). Dynamic casting is permitted. The system is parametric on the underlying constraint system: the compiler supports a simple equality-based constraint system but, in addition, supports extension with new constraint systems using compiler plugins.</p>", "authors": [{"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P1223223", "email_address": "", "orcid_id": ""}, {"name": "Vijay Saraswat", "author_profile_id": "81100152268", "affiliation": "IBM Research, Yorktown Heights, NY, USA", "person_id": "P1223224", "email_address": "", "orcid_id": ""}, {"name": "Jens Palsberg", "author_profile_id": "81100375570", "affiliation": "UCLA, Los Angeles, CA, USA", "person_id": "P1223225", "email_address": "", "orcid_id": ""}, {"name": "Christian Grothoff", "author_profile_id": "81100392834", "affiliation": "University of Denver, Denver, CO, USA", "person_id": "P1223226", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449800", "year": "2008", "article_id": "1449800", "conference": "OOPSLA", "title": "Constrained types for object-oriented languages", "url": "http://dl.acm.org/citation.cfm?id=1449800"}