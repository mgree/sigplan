{"article_publication_date": "10-19-2008", "fulltext": "\n Ef.cient Software Model Checking of Soundness of Type Systems Michael Roberson Melanie Harries Paul \nT. Darga Chandrasekhar Boyapati Electrical Engineering and Computer Science Department University of \nMichigan, Ann Arbor, MI 48109 {roberme,melagnew,pdarga,bchandra}@eecs.umich.edu Abstract This paper \npresents novel techniques for checking the soundness of a type system automatically using a software \nmodel checker. Our idea is to systematically generate ev\u00adery type correct intermediate program state \n(within some .\u00adnite bounds), execute the program one step forward if pos\u00adsible using its small step operational \nsemantics, and then check that the resulting intermediate program state is also type correct but do so \nef.ciently by detecting similarities in this search space and pruning away large portions of the search \nspace. Thus, given only a speci.cation of type cor\u00adrectness and the small step operational semantics \nfor a lan\u00adguage, our system automatically checks type soundness by checking that the progress and preservation \ntheorems hold for the language (albeit for program states of at most some .nite size). Our preliminary \nexperimental results on several languages including a language of integer and boolean ex\u00adpressions, a \nsimple imperative programming language, an object-oriented language which is a subset of Java, and a \nlanguage with ownership types indicate that our approach is feasible and that our search space pruning \ntechniques do indeed signi.cantly reduce what is otherwise an extremely large search space. Our paper \nthus makes contributions both in the area of checking soundness of type systems, and in the area of reducing \nthe state space of a software model checker. Categories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: \nSoftware/Program Veri.cation; D.2.5 [Software Engineering]: Testing and Debugging; D.3.1 [Program\u00adming \nLanguages]: Formal De.nitions and Theory; F.3.1 [Logics and Meanings of Programs]: Specifying and Verify\u00ading \nand Reasoning about Programs General Terms Languages, Reliability, Veri.cation Keywords Software Model \nChecking, Type Soundness Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 08, October 19 23, 2008, Nashville, Tennessee, USA. Copyright c &#38;#169; 2008 \nACM 978-1-60558-215-3/08/10. . . $5.00 1. Introduction Type systems provide signi.cant software engineering \nben\u00ade.ts. Types can enforce a wide variety of program invari\u00adants at compile time and catch programming \nerrors early in the software development process. Types serve as docu\u00admentation that lives with the code \nand is checked through\u00adout the evolution of code. Types also require little program\u00adming overhead and \ntype checking is fast and scalable. For these reasons, type systems are the most successful and widely \nused formal methods for detecting programming er\u00adrors. Types are written, read, and checked routinely \nas part of the software development process. However, the type sys\u00adtems in languages such as Java, C#, \nML, or Haskell have lim\u00adited descriptive power and only perform compliance check\u00ading of certain simple \nprogram properties. But it is clear that a lot more is possible. There is therefore plenty of research \nin\u00adterest in developing new type systems for preventing various kinds of programming errors [8, 17, 28, \n45, 46, 54]. A formal proof of type soundness lends credibility that a type system does indeed prevent \nthe errors it claims to pre\u00advent, and is a crucial part of type system design. At present, type soundness \nproofs are mostly done on paper, if at all. These proofs are usually long, tedious, and consequently \ner\u00adror prone. There is therefore a growing interest in machine checkable proofs of soundness [2]. However, \nboth the above approaches proofs on paper (e.g., [20]) or machine check\u00adable proofs (e.g., [47]) require \nsigni.cant manual effort. This paper presents an alternate approach for checking type soundness automatically \nusing a software model checker. Our idea is to systematically generate every type correct in\u00adtermediate \nprogram state (within some .nite bounds), exe\u00adcute the program one small step forward if possible using \nits small step operational semantics, and then check that the resulting intermediate program state is \nalso type correct but do so ef.ciently by detecting similarities in this search space and pruning away \nlarge portions of the search space. Thus, given only a speci.cation of type correctness and the small \nstep operational semantics for a language, our system automatically checks type soundness by checking \nthat the progress and preservation theorems [50, 56] hold for the lan\u00adguage (albeit for program states \nof at most some .nite size). Our experimental results on several languages including the language of \ninteger and boolean expressions from [50, Chapters 3 &#38; 8], a typed version of the imperative lan\u00adguage \nIMP from [55, Chapter 2], an object-oriented lan\u00adguage which is a subset of Java, and a language with \nown\u00adership types [1, 6, 13] indicate that our approach is fea\u00adsible and that our search space pruning \ntechniques do in\u00addeed signi.cantly reduce what is otherwise an extremely large search space. This paper \nthus offers a promising ap\u00adproach for checking type soundness automatically, thereby enabling the design \nof novel type systems. In particular, this can enormously help programming language designers in debugging \ntheir language speci.cations. Currently there is no other technology around to automate this task effectively. \nNote that checking the progress and preservation theorems on all programs states up to a .nite size does \nnot prove that the type system is sound, because the theorems might not hold on larger unchecked program \nstates. However, in prac\u00adtice, we expect that all type system errors will be revealed by small sized \nprogram states. This conjecture, known as the small scope hypothesis [35], has been experimentally ver\u00adi.ed \nin several domains. Our preliminary experiments us\u00ading mutation testing [49, 41] suggest that the conjecture \nalso holds for checking type soundness. We also examined all the type soundness errors we came across \nin literature and found that in each case, there is a small program state that exposes the error. Thus, \nexhaustively checking type soundness on all programs states up to a .nite size does at least generate \na high degree of con.dence that the type system is sound. This paper also makes contributions in improving \nthe state of art in software model checking [3, 4, 11, 14, 15, 21, 24, 53, 29, 44]. Model checking is \na formal veri.cation tech\u00adnique that exhaustively tests a circuit/program on all possible inputs (sometimes \nup to a given size) to handle input non\u00addeterminism and on all possible nondeterministic schedules to \nhandle scheduling nondeterminism. For hardware, model checkers have been successfully used to verify \nfairly com\u00adplex .nite state control circuits with up to a few hundred bits of state information; but \nnot circuits in general that have large data paths or memories. Similarly, for software, model checkers \nhave been primarily used to verify control-oriented programs (with scheduling nondeterminism) with respect \nto temporal properties; but not much work has been done to verify data-oriented programs (with input \nnondeterminism) with respect to complex data-dependent properties. Thus, while there is much research \non state space reduc\u00adtion techniques for software model checkers such as partial order reduction [23, \n24] and tools based on predicate ab\u00adstraction [26] such as Slam [3], Blast [29], or Magic [11], none \nof these techniques seem to be effective in reducing the state space when checking the soundness of a \ntype system where one must deal with input nondeterminism (to check every input program state) and data-dependent \nproperties (type correctness properties that depend on input program states). In fact, because of input \nnondeterminism, it is dif.\u00adcult to even formulate the problem of automatically checking type soundness \nin the context of most model checkers. This paper describes techniques for ef.ciently checking type soundness \nautomatically using a software model checker by signi.cantly reducing the state space of the model checker. \nIt thus contributes to improving the state of art in software model checking. This paper builds on our \nrecent previous work on model checking properties of data structures [16]. This paper improves on the \ntechniques presented in [16] and applies them to checking soundness of type systems. The rest of this \npaper is organized as follows. Section 2 illus\u00adtrates our approach with an example. Section 3 describes \nour software model checker for checking of soundness type sys\u00adtems. Section 4 presents our experimental \nresults. Section 5 discusses related work and Section 6 concludes.  2. Example This section illustrates \nour approach with an example. Con\u00adsider the language of integer and boolean expressions in [50, Chapters \n3 &#38; 8]. The syntax of the language is shown in Figure 1. The small step operational semantics and \nthe type checking rules for this language are in [50]. To check type soundness, our system systematically \ngenerates and checks the progress and preservation theorems on every type correct program state within \nsome .nite bounds. Figure 2 shows three abstract syntax trees (ASTs) t1, t2, and t3.AST t1 represents \nthe term if (iszero 0) then true else false . AST t2 represents the term if (iszero 0) then (pred 0) \nelse (succ 0) . AST t3 represents the term if (iszero 0) then (if false then false else true) else false \n. Figure 2 shows the ASTs before and after a small step evaluation according to the small step operational \nsemantics of the language. Our state space reduction technique works as follows. As our system checks \nthe progress and preservation theorems on t1, it detects that the small step evaluation of t1 touches \nonly a small number of AST nodes along a tree path in the AST. These nodes are highlighted in the .gure. \nIf these nodes remain unchanged, the small step evaluation will behave similarly (e.g., on ASTs such \nas t2 and t3). Our system determines that it is redundant to check the progress and preservation theorems \non ASTs such as t2 and t3 once it checks the theorems on t1. Our system safely prunes those program states \nfrom its search space, while still achieving complete test coverage within the bounded domain. Our system \nthus checks the progress and preservation theorems on every unique tree path (and some nearby nodes) \nrather than on every unique AST. Note that the number of unique ASTs of a given maximum height h is exponential \nin n, where n = 3h, but the number of unique tree paths is only t ::= true | false | 0 | succ t | pred \nt | iszero t | if t then t else t term constant constant constant successor predecessor zero test conditional \ntrue false zero Figure 1. Abstract syntax of the language of integer and boolean expressions from [50, \nChapters 3 &#38; 8]. Figure 2. Three abstract syntax trees (ASTs) for the language in Figure 1, before \nand after a small step evaluation. The tree path touched by each evaluation is highlighted. Note that \nthe tree path is the same in all three cases. Once our system checks the progress and preservation theorems \non AST t1, it determines that it is redundant to check them on ASTs t2 and t3. polynomial in n. This \nleads to signi.cant reduction in the size of the search space and makes our approach feasible. Our system \nperforms even better if the operational semantics of the above language is implemented ef.ciently. For \nthe example in Figure 2, our system detects that only the nodes in the redex iszero 0 matter, as long \nas that is the next redex to be reduced. It therefore prunes all program states where those nodes remain \nthe same and that is the next redex to be reduced. This leads to even greater speedups. Our system then \nonly checks O(n) number of program states.  3. Model Checking Type Soundness While the basic idea presented \nin Section 2 is simple, one must overcome several technical challenges to make it work well in practice. \nThis section describes our approach. 3.1 Specifying Language Semantics To check the soundness of a type \nsystem, language designers only need to specify the small step operational semantics of the language, \nrules for checking type correctness of interme\u00addiate program states, and .nite bounds on the size of \ninter\u00admediate program states. The operational semantics must be speci.ed in an executable language to \nfacilitate our dynamic analysis (c.f. Section 3.6). The type system must be spec\u00adi.ed in a declarative \nlanguage to facilitate our static anal\u00adysis (c.f. Section 3.7). The operational semantics, however, may \nalso be speci.ed in a declarative language if the declar\u00adative speci.cations can be automatically translated \ninto ex\u00adecutable code. For example, a large subset of JML can be automatically translated to Java using \nthe JML tool set [40]. In our current system, we use Java as our executable lan\u00adguage for specifying \nan operation semantics. We use a vari\u00adant of Java as our declarative language for specifying a type system. \nWe use Java similarly to our previous work [16] for specifying .nite bounds on the size of intermediate \npro\u00adgram states. Figure 3 shows an example implementation of the expression language in Figure 1 in our \nsystem. An ob\u00adject of class ExpressionLanguage represents an interme\u00addiate program state of the expression \nlanguage. Every such class that implements Language must have two methods: i) a Java method smallStep \nthat either performs a small step of evaluation and terminates normally, or throws an excep\u00adtion if the \nevaluation gets stuck; and ii) a declarative method wellTyped that returns true iff the corresponding \ninterme\u00addiate program state is well typed. Declarative methods are annotated as declarative. A declarative \nmethod may not contain object creations, assignments, loops, or exceptions, and may only call other declarative \nmethods. A declarative method may however contain implications, universal quan\u00adti.cations, and existential \nquanti.cations to facilitate writ\u00ading .rst order logic formulas. We allow Java methods to call declarative \nmethods we automatically translate a declara\u00adtive method into executable code before running it. Finally, \nthe tree annotation on Line 14 denotes that the expression structure forms a tree, similarly to [16]. \nSuch annotations help reduce the search space of our model checker because it does not have to check \nnon-tree structures. We note that our model checking techniques are not tied to our above choice of speci.cation \nlanguages and can also be made to work with other languages (e.g., Ott [51]). public class ExpressionLanguage \nimplements Language { static final int TRUE = 0; static final int FALSE = 1; static final int ZERO = \n2; static final int SUCC = 3; static final int PRED = 4; static final int ISZERO = 5; static final int \nIF = 6; static final int BOOL = 0; static final int INT = 1; static class Expression { int kind; /* \nTRUE / FALSE / ZERO / SUCC / PRED / ISZERO / IF */ @tree Expression e1, e2, e3; /* Subexpressions */ \n @declarative boolean wellTyped() { return syntaxOk() &#38;&#38; ( kind == TRUE ==> true ) &#38;&#38; \n( kind == FALSE ==> true ) &#38;&#38; ( kind == ZERO ==> true ) &#38;&#38; ( kind == SUCC ==> e1.wellTyped() \n&#38;&#38; e1.type() == INT ) &#38;&#38; ( kind == PRED ==> e1.wellTyped() &#38;&#38; e1.type() == INT \n) &#38;&#38; ( kind == ISZERO ==> e1.wellTyped() &#38;&#38; e1.type() == INT ) &#38;&#38; ( kind == IF \n==> e1.wellTyped() &#38;&#38; e1.type() == BOOL &#38;&#38; e2.wellTyped() &#38;&#38; e3.wellTyped() &#38;&#38; \ne2.type()==e3.type() ); } Expression smallStep() throws StuckException { if ( isValue() ) { return this; \n} if ( e1 == null ) { throw new StuckException(); } if ( !e1.isValue() ) { e1 = e1.smallStep(); return \nthis; } if ( kind == PRED &#38;&#38; e1.kind == ZERO ) return e1; if ( kind == PRED &#38;&#38; e1.kind \n== SUCC ) return e1.e1; if ( kind == ISZERO &#38;&#38; e1.kind == ZERO ) return True(); if ( kind == \nISZERO &#38;&#38; e1.kind == SUCC ) return False(); if ( kind == IF &#38;&#38; e1.kind == TRUE ) return \ne2; if ( kind == IF &#38;&#38; e1.kind == FALSE ) return e3; throw new StuckException(); } // Helper \nfunctions @declarative boolean syntaxOk() { return ( ( kind == TRUE || kind == FALSE || kind == ZERO \n) &#38;&#38; e1 == null &#38;&#38; e2 == null &#38;&#38; e3 == null ) || ( ( kind == SUCC || kind == \nPRED || kind == ISZERO ) &#38;&#38; e1 != null &#38;&#38; e2 == null &#38;&#38; e3 == null ) || ((kind==IF \n)&#38;&#38; e1 != null&#38;&#38;e2!=null&#38;&#38;e3!=null); } @declarative int type() { if ( kind == \nTRUE || kind == FALSE || kind == ISZERO ) return BOOL; else if ( kind == ZERO || kind == SUCC || kind \n== PRED ) return INT; else /*( kind == IF )*/ return e2.type(); } @declarative boolean isValue() { return \nkind == TRUE || kind == FALSE || kind == ZERO || kind == SUCC &#38;&#38; e1.isValue(); } static Expression \nTrue () {Expression e = new Expression(); e.kind = TRUE; return e;} static Expression False() {Expression \ne = new Expression(); e.kind = FALSE; return e;} } Expression root; @declarative public boolean wellTyped() \n{ return root.wellTyped(); } public void smallStep() throws StuckException { root = root.smallStep(); \n} public boolean isFinalState() { return root.isValue(); } } Figure 3. An implementation of the language \nof integer and boolean expressions in Figure 1 in our system. Field Value Field Value n0.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n1.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n2.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n3.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n4.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n5.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n6.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n7.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n8.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n9.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n10.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n11.kind {TRUE, FALSE, ZERO, SUCC, PRED, ISZERO, IF} n12.kind {TRUE, \nFALSE, ZERO, SUCC, PRED, ISZERO, IF} n0.e1 {null, n1} n0.e2 {null, n2} n0.e3 {null, n3} n1.e1 {null, \nn4} n1.e2 {null, n5} n1.e3 {null, n6} n2.e1 {null, n7} n2.e2 {null, n8} n2.e3 {null, n9} n3.e1 {null, \nn10} n3.e2 {null, n11} n3.e3 {null, n12}  Figure 4. Search space for the language implemented in Figure \n3 with ASTs of height at most 3.  3.2 Search Space Traditional software model checkers [3, 11, 15, 21, \n24, 53, 29, 44] explore a state space by starting from the initial state and systematically generating \nand checking every successor state. While this approach works well to check software with scheduling \nnondeterminism, it is not convenient to check software with input nondeterminism. In fact, it is dif.cult \nto even formulate the problem of checking type soundness in the context of most software model checkers. \nInstead, our model checker organizes its search space as follows. Consider the language in Figure 3. \nSuppose our system must check the progress and preservation theorems on all ASTs up to a maximum height \nh=3. Figure 4 shows the corre\u00adsponding search space. The search space consists of all pos\u00adsible assignments \nto the .elds, where each .eld gets a value from its corresponding domain. Every element of this search \nspace is an AST. For example, the .rst element in Fig\u00adure 5 corresponds to the AST if (iszero 0) then \n(if false then false else true) else false . In Fig\u00adure 4, there are thirteen .elds with seven elements \nin their domains and twelve .elds with two elements in their do\u00admains, so the size of this search space \nis 713 *212. In general, for ASTs of height at most h, the size of the search space 3h-13h-3 is 7 2 * \n22 . Note that many elements of this search space are not type correct or even syntactically correct. \nFor example, the second element in Figure 5 is not type correct because iszero cannot be invoked on false. \nn0.kind IF n1.kind ISZERO n2.kind IF n3.kind FALSE n4.kind ZERO n5.kind * n6.kind * n7.kind FALSE n8.kind \nFALSE n9.kind TRUE n10.kind * n11.kind * n12.kind * n0.e1 n1 n0.e2 n2 n0.e3 n3 n1.e1 n4 n1.e2 null n1.e3 \nnull n2.e1 n7 n2.e2 n8 n2.e3 n9 n3.e1 null n3.e2 null n3.e3 null n0.kind ISZERO n1.kind FALSE n2.kind \n* n3.kind * n4.kind * n5.kind * n6.kind * n7.kind * n8.kind * n9.kind * n10.kind * n11.kind * n12.kind \n* n0.e1 n1 n0.e2 null n0.e3 null n1.e1 null n1.e2 null n1.e3 null n2.e1 * n2.e2 * n2.e3 * n3.e1 * n3.e2 \n* n3.e3 * Figure 5. Two elements of the search space in Figure 4. The .rst element represents the term \nif (iszero 0) then (if false then false else true) else false . The second element represents the term \niszero false . The symbol * denotes don t care. In general, the intermediate state of a program can include \nother components besides an AST, such as a dynamically allocated heap. Our system appropriately constructs \na .nite search space that includes all such components. 3.3 Search Algorithm Figure 6 presents the pseudo-code \nfor our search algorithm. Given a language to check for type soundness and .nite bounds on the size of \nits intermediate program states, our system .rst initializes the search space to the set of all well \ntyped program states within the .nite bounds. It then systematically explores this space by repeatedly \nselecting a program state w from the search space, running its analyses to identify a set of program \nstates Wi (including w) on which smallStep (described in Section 3.1) behaves similarly to w, checking \nthat the progress and preservation theorems hold on every program state in Wi, and pruning all the program \nstates in Wi from the search space. The next sections describe how to perform various steps of the above \nsearch ef.ciently. 3.4 Search Space Representation Consider the search space of the language in Figure \n3, with ASTs of height at most h=8. The size of this search space is about 212487. Of these, about 22523 \nASTs are type cor\u00adrect. However, as our experiments show, our system checks the progress and preservation \ntheorems explicitly on only 41 ASTs. (Our analyses determine that it is redundant to check the theorems \non the remaining elements of the search space.) Thus, if we are not careful, search space management \nit\u00adself could take exponential time and negate the bene.ts of 1 void search( SearchSpace S ) { 2 W = \n{ w . S | w.wellTyped() } 3 while ( W = \u00d8 ){ 4 w = Any element in W 5 W' ={w' . W | smallStep behaves \nsimil arly onw &#38;w' } 6 Check progress and preservation on all states in W' 7 W =W-W' 8 } 9} Figure \n6. Pseudo-code for the search algorithm. our search space pruning techniques. We avoid this by us\u00ading \na compact representation of the search space (that is, the set of intermediate program states). We explored \ntwo differ\u00adent approaches for representing the search space: (i) using a reduced ordered binary decision \ndiagram [10] or BDD, as in our previous work [16], and (ii) using an incremen\u00adtal SAT solver, MiniSat \n[22]. In our experiments, we found that while the BDD-based approach performs slightly better on tree-based \ntype constraints, the SAT-based approach per\u00adforms much better on languages that include non-tree-based \ntype constraints (that is, on languages whose program states include components other than ASTs). We \ntherefore discuss only our SAT-based approach in the rest of this paper. Our SAT-based approach works \nas follows. We represent a set of program states as a .nite propositional logic formula. For example, \nfor the search space in Figure 4, the formula (n0.kind=IF . n1.kind=ISZERO . n4.kind=ZERO . n0.e1=n1 \n. n0.e2=n2 . n0.e3=n3 . n1.e1=n4) rep\u00adresents the set of all the terms of the form if (iszero 0) then \nx1 else x2 , where x1 and x2 are any two terms. This includes the terms represented by ASTs t1, t2, and \nt3 in Figure 2. Every satisfying assignment of the formula rep\u00adresents a member of the set. If the formula \nis unsatis.able, then the set is empty. We use llog2 dl bits to encode a .eld with domain size d. For \nexample, we use 3 bits to encode a kind .eld , and 1 bit to encode an e1, e2,or e3 .eld. We use an incremental \nSAT solver to .nd satisfying assignments of the propositional logic formula. Line 7 in Figure 6, comput\u00ading \nthe difference of two sets, thus takes time linear in the size of the formula because it simply injects \nclauses into the incremental SAT solver. Line 3, checking if a set is empty, and Line 4, choosing an \nelement of a non-empty set, could be expensive operations because they invoke the SAT solver. 3.5 Search \nSpace Initialization Our search begins by initializing the search space to the set of all well typed \nintermediate program states (Line 2 in Fig\u00adure 6). We do this by automatically translating the declara\u00adtive \nmethod wellTyped (described in Section 3.1) and the declarative methods it transitively invokes, given \nthe .nite bounds on the size of intermediate program states, into a .\u00adnite propositional logic formula. \nThe translation process is somewhat similar to that of AAL [37]. However, because our declarative methods \ndo not contain object creations, as\u00adsignments, loops, or exceptions, the formulas for declara\u00adtive methods \nour system generates are considerably simpler than the formulas for regular Java methods that AAL gen\u00aderates. \nWe translate our declarative variant of Java directly into propositional logic, unlike AAL which translates \nJava into Alloy [34] and translates Alloy into propositional logic. 3.6 Dynamic Analysis This section \npresents our basic search space pruning tech\u00adnique. Consider the language implemented in Figure 3. Con\u00adsider \nchecking the progress and preservation theorems on the AST represented by the .rst element in Figure \n5. The theo\u00adrems hold on the AST. As our system evaluates the AST a small step forward, it monitors the \n.elds that the small step evaluator reads. In this case, smallStep reads n0.kind, n1.kind, n4.kind, n0.e1, \nand n1.e1. That means, regard\u00adless of the values of the remaining .elds, the small step eval\u00aduator will \nstill behave similarly if the values of the .elds that were read do not change. Our system then determines \nthat regardless of the values of the remaining .elds, if the AST is well typed before the small step \nevaluation, then the AST will be well typed after the small step evaluation. Our system therefore prunes \nall elements of the search space where (n0=IF . n1=ISZERO . n4=ZERO . n0.e1=n1 . n1.e1=n4). This is the \nbasic idea that makes our approach of exhaustive testing within a large but .nite domain feasible. 3.7 \nStatic Analysis The dynamic analysis described above in effect detects don t care .elds in a well typed \nprogram state w, and suggests that all states wi that differ from w only at the don t care .elds be pruned \nfrom the search space. The goal of the static analysis is to prove that it is indeed safe to prune those \nstates. To see why the static analysis is necessary, consider the following simple but arti.cial example \nwhere wellTyped returns true iff a implies b. Suppose we invoke smallStep on a=false and b=true. wellTyped \nreturns true before and after the execution of smallStep. smallStep reads only the .eld a while the .eld \nb is a don t care. The dynamic analysis above suggests that the progress and preservation theorems might \nhold on all states where a=false (and therefore those ele\u00adments be pruned from the search space). But \nthe suggestion is incorrect because the preservation theorem does not hold on a=false and b=false. wellTyped \nreturns true before the evaluation of smallStep but returns false after. 1 class WhyStaticAnalysis extends \nLanguage { 2 private boolean a, b; 3 @declarative 4 public boolean wellTyped() {return a ==> b;} 5 public \nvoid smallStep() throws StuckException {a = !a;} 6} Our static analysis works as follows. Consider checking \nthe progress and preservation theorems on a program state w, with .elds f1..n. Of these, without loss \nof generality, suppose smallStep neither writes to nor reads the original values of .elds f1..m, writes \nto but does not read the original values of .elds f(m+1)..k, and both writes to and reads the original \nvalues of .elds f(k+1)..n. Our dynamic analysis then identi\u00ad.es .elds f1..k as don t cares. Let the values \nof .elds f1..n i be v1..n before smallStep, and v1..n after smallStep.Re\u00adcall from Section 3.5 that our \nsystem automatically trans\u00adlates the declarative method wellTyped, given the .nite bounds on the size \nof program states, into a .nite proposi\u00adtional logic formula. Let wellTyped(f1..n) denote that for\u00admula. \nOur static analysis then attempts to prove that for all values of f1..k in the bounded domain, wellTyped(f1..k \ni v(k+1)..n) implies wellTyped(f1..m v(m+1)..n). Our system in\u00advokes the SAT solver to check if the implication \nholds. If the implication holds, our system safely prunes the search space as described in Section 3.6. \nIf the implication does not hold, then there is an error in the type system. An instance satisfying the \nnegation of the implication exposes the error. The above analysis requires careful handling if smallStep \nrearranges .elds. Consider the search space in Figure 4. Consider checking the term if true then (if \nfalse then false else false) else true . A small step of evaluation yields the term if false then false \nelse false . Note that even though smallStep does not read the .elds of nodes n2, n7, n8, and n9 in Figure \n4, it moves the nodes into the positions of nodes n0, n1, n2, and n3. Thus, for example, the .eld n2.kind \nbefore smallStep moves into the position of n0.kind after smallStep. Our system tracks such rearrangement \nof .elds and appropriately con\u00adstructs the formula for the static analysis described above. 3.8 Symbolic \nExecution The dynamic analysis in Section 3.6 identi.es a usually large set Wi of program states on which \nsmallStep behaves simi\u00adlarly (Line 5 in Figure 6). The static analysis in Section 3.7 ef.ciently checks \nthat the progress and preservation theo\u00adrems hold on all the program states in Wi (Line 6 in Figure 6), \nso that Wi can be pruned from the search space. This section describes optimizations that enable our \nsystem to identify and prune an even larger set Wi from the search space. Consider smallStep in the example \nbelow. Suppose it is invoked on b1=true, b2=true, b3=true, b4=true, and b5=true. The dynamic analysis \nin Section 3.6 detects that smallStep only reads .elds b1, b2, b3, and b5, and thus determines that if \nthe values of those .elds remain un\u00adchanged, smallStep will behave similarly. Suppose the declarative \nmethod wellTyped gets automatically trans\u00adlated into the formula wellTyped(b1, b2, b3, b4, b5), as described \nin Section 3.7. The static analysis in Section 3.7 then attempts to prove using a SAT solver that for \nall values of b4, wellTyped(true, true, true, b4, true) implies wellTyped(true, true, true, false, true). \nIf the im\u00adplication holds, our system prunes from the search space all states where (b1=true . b2=true \n. b3=true . b5=true). 1 class WhySymbolicExecution extends Language { 2 private boolean b1, b2, b3, b4, \nb5; 3 @declarative 4 public boolean wellTyped() {...} 5 public void smallStep() throws StuckException \n{ 6 if (b1 == b2 )if (b1 == b3 )b4=!b5; 7} 8} In the above example, even though the .eld b5 is read, \nit does not affect the control .ow of smallStep. Moreover, even though the .elds b1, b2, and b3 are read, \nthe control .ow of smallStep remains the same if (b1=b2 . b1=b3). Our system uses symbolic execution \n[39] to identify that smallStep behaves similarly, that is, follows the same con\u00adtrol .ow path, on all \nprogram states where (b1=b2 . b1=b3). Our system uses symbolic execution to also identify that the value \nof the .eld b4 after smallStep is the negation of the value of the .eld b5 before smallStep. Our static \nanalysis then attempts to prove using a SAT solver that for all val\u00adues of b1, b2, b3, b4, and b5, wellTyped(b1, \nb2, b3, b4, b5) and (b1=b2 . b1=b3) implies wellTyped(b1, b2, b3, \u00acb5, b5). If the implication holds, \nour system prunes from the search space all states where (b1=b2 . b1=b3). Our system currently symbolically \nexecutes assignments, comparisons, and boolean operations. Our system also sym\u00adbolically executes declarative \nmethods by automatically translating declarative methods into propositional logic for\u00admulas, as described \nin Section 3.5, and replacing every call to a declarative method with its corresponding propositional \nlogic formula. For example, when symbolically executing Line 30 or Line 32 in Figure 3, our system replaces \nthe call to the declarative method isValue with its corresponding propositional logic formula. Our system \nuses symbolic ex\u00adecution to build a path constraint formula which when true guarantees that smallStep \nwill follow the same control .ow path. Our system then performs a static analysis as de\u00adscribed above \nand prunes all states that satisfy the formula. If our system is unable to symbolically execute an operation \non a .eld f with original value v, it simply treats the .eld concretely instead of symbolically and adds \nthe clause (f=v) to the path constraint formula (that is, our system falls back to the dynamic analysis \nin Section 3.6 w.r.t. that .eld). 3.9 Isomorphism Analysis Consider a language whose intermediate program \nstates in\u00adclude an AST and a dynamically allocated heap. Figure 7 presents an example of such a search \nspace, where every ob\u00adject contains one pointer, the AST has height at most 2, and there are at most \n4 heap objects. Consider the two elements of the above search space in Figure 8. These two elements are \nisomorphic because o0 and o1 are equivalent mem\u00adory locations. Therefore, once we check the progress \nand preservation theorems on the .rst element, it is redundant to check the theorems on the second element. \nOur system avoids checking isomorphic structures as follows. Suppose the small step evaluator reads only \nn0.value, n1.value, n0.value {EQUALS, ..., o0, o1, o2, o3, null} n1.value {EQUALS, ..., o0, o1, o2, \no3, null} n2.value {EQUALS, ..., o0, o1, o2, o3, null} o0.value {o0, o1, o2, o3, null} o1.value {o0, \no1, o2, o3, null} o2.value {o0, o1, o2, o3, null} o3.value {o0, o1, o2, o3, null}  AST Heap Figure 7. \nSearch space for a language whose intermediate program states include an AST and a heap. and n2.value \nwhen evaluating the .rst element, and sup\u00adpose that the analyses in the previous sections conclude that \nall states where (n0.value=EQUALS . n1.value=o0 . n2.value=o1) can be pruned. Our isomorphism analysis \nthen determines that all structures that satisfy the following formula can also be safely pruned: (n0.value=EQUALS \n. n1.value=o1/o2/o3 . n0.value=EQUALS . n1.value= o0 . n2.value=o2/o3). In general, given a program state \nw, our system constructs such a formula Iw denoting the set of states isomorphic to w as follows. Recall \nfrom Section 3.8 that our symbolic execution on w builds a path constraint formula, say Pw. Suppose during \nsymbolic execution our system encounters a fresh object o that a .eld f points to, and the path constraint \nbuilt so far is Pw. Our isomorphism analysis includes in Iw all states that satisfy (Pw . f=oi), for \nevery oi in the domain of the .eld f that is another fresh object. Our system then prunes all the states \ndenoted by Iw from the search space. Note that some software model checkers also prune iso\u00admorphic program \nstates using heap canonicalization [32, 43]. The difference is that in heap canonicalization, once a \nchecker visits a state, it canonicalizes the state and checks if the state has been previously visited. \nIn our system, once our checker checks a state w, it computes a compact formula Iw denoting a (often \nexponentially large) set of states isomor\u00adphic to w, and prunes Iw from the search space. Our checker \nnever visits the (often exponentially many) states in Iw. 3.10 Handling Special Cases Our system also \nhandles the following special cases. 3.10.1 Handling Term Cloning Consider the following semantics for \nthe while statement of the imperative language IMP from [55, Chapter 2], which clones the entire loop \nbody. s contains values of variables. (whilec do b, s).(if c then (b; while c do b), s) The cloning of \ndifferent loop bodies could make smallStep follow different control .ow paths. However, in one iteration \nof the loop in Figure 6, the symbolic execution described Figure 8. Two isomorphic elements of the space \nin Figure 7. Field Value n0.value EQUALS n1.value o0 n2.value o1 o0.value null o1.value null o2.value \nnull o3.value null Field Value n0.value EQUALS n1.value o1 n2.value o0 o0.value null o1.value null \no2.value null o3.value null above only prunes states on which smallStep follows the same control .ow \npath. To enable the pruning of program states with different loop bodies in the same iteration of the \nloop in Figure 6, our system provides a special construct to implement cloning and replaces a cloning \noperation with an automatically generated formula during symbolic execution. Other examples of cloning \ninclude method calls that have a method inlining semantics (e.g., in Featherweight Java [31]). 3.10.2 \nHandling Substitution Consider a language where method calls have a method inlining semantics. Suppose \none small step of evaluation substitutes all the formals with actuals in the method body. Our model checker \nworks best when each small step of evaluation reads only a small part of the program state. However, \nthe above substitution reads the entire method body. Language designers can avoid the problem by de.ning \nthe semantics of method calls using incremental substitution, where each small step of evaluation performs \nsubstitution on at most one AST node, and by ensuring that the type checking rules handle partially substituted \nprogram states. 3.10.3 Handling Nondeterministic Languages The discussion so far assumes deterministic \nlanguages. Con\u00adsider a language L with with nondeterministic operational semantics. Its implementation \nin our system must include a deterministic method smallStep that takes an integer x as an argument, as \nshown below. If there are n transitions enabled on a given state, then smallStep must execute a different \ntransition for each different value of x from 1 to n. Our system then checks that the progress and preserva\u00adtion \ntheorems hold on every program state (within the .nite bounds), w.r.t. every transition that is enabled \non the state. 1 class L extends NondeterministicLanguage { 2 @declarative 3 public boolean wellTyped() \n{...} 4 public void smallStep(int x) throws StuckException {...} 5}   4. Experimental Results This \nsection presents our preliminary experimental results. We implemented a rudimentary software model checker \nas described in this paper. We extended the Polyglot [48] com\u00adpiler framework to automatically instrument \nthe operational semantics of languages to perform our dynamic analyses. We used MiniSat [22] as our incremental \nSAT solver to per\u00adform our static analysis. We ran all our experiments on a Linux Fedora Core 8 machine \nwith a Pentium 4 3.4 GHz processor and 1 GB memory using IcedTea Java 1.7.0. We present results for the \nfollowing languages, each with increasing complexity: 1. The language of integer and boolean expressions \nfrom [50, Chapters 3 &#38; 8], as implemented in Figure 3. 2. A typed version of the imperative language \nIMP from [55, Chapter 2]. This language contains integer and boolean variables, so its type checking \nrules include an environment context. This language also contains while statements.  3. An object-oriented \nlanguage Featherweight Java [31]. This language has classes, objects, and methods. The se\u00ad mantics of \nmethod calls require term level substitution (of the formal method parameters with their actual values). \n 4. An extension to Featherweight Java we call Mini Java. This language models the heap explicitly, supports \nmuta\u00adtions to objects in the heap, and includes a null value. This language also contains integers and \nbooleans, and operations on integers and booleans. 5. An extension to Mini Java to support ownership \ntypes  [1, 6, 13], that we call Ownership Java. This language has classes parameterized by owner pa\u00adrameters. \nTherefore the semantics of a method call re\u00adquire both term level and type level substitution. For each \nbenchmark, we checked the progress and preser\u00advation theorems exhaustively on all program states up to \na maximum size n. In all languages, we limited the maximum expression size to be bound by a balanced \nAST with n nodes. In the imperative language IMP, we limited program states to have at most n variables \nand n integer literals. In Feath\u00aderweight Java, Mini Java, and Ownership Java, we limited program states \nto have at most four classes, where each class can have at most two .elds and two methods (in addition \nto inherited .elds and methods). In Mini Java and Ownership Java, we limited program states to have at \nmost four heap objects and n integer literals. In Ownership Java, we limited classes to have at most \ntwo owner parameters. We report both the number of states explicitly checked by our checker and the time \ntaken by our checker. Note that we did not yet optimize the execution time of our checker, but we report \nit here nonetheless to provide a rough idea. The results indicate that our approach is feasible and that \nour model checker achieves signi.cant state space reduction. For example, the number of well typed IMP \nprograms of maximum size 511 is over 2786, but our checker explicitly checks only 652 states to exhaustively \ncover this space. Benchmark Max Expression Size States Checked Time (s) Expression Language 1 2 3 4 ... \n13 40 121 364 1093 3280 1 3 3 5 ... 11 17 23 29 35 41 0.068 0.093 0.105 0.122 ... 0.246 0.551 1.376 3.633 \n10.833 38.543 IMP 1 2 3 4 5 6 7 ... 15 31 63 127 255 511 1 7 11 19 34 34 34 ... 61 96 147 230 377 652 \n0.102 0.185 0.256 0.408 0.710 0.739 0.816 ... 2.158 5.107 10.066 21.013 52.208 331.138 Featherweight \nJava 1 2 3 4 5 ... 21 85 341 3 7 9 9 13 ... 70 298 1210 1.148 1.594 1.650 1.899 2.151 ... 6.905 43.756 \n475.022 Mini Java 1 2 3 4 5 ... 21 85 341 5 21 40 53 59 ... 275 1133 4565 2.721 3.117 3.897 5.750 6.191 \n... 37.354 342.435 5981.114 Ownership Java 1 2 3 4 5 ... 21 25 29 33 13 73 110 135 157 ... 733 877 1021 \n1165 50.818 77.135 103.230 231.328 247.954 ... 2760.734 3963.836 5271.509 6255.260 Figure 9. Experimental \nresults for checking soundness of type systems. Our system achieves signi.cant state space reduction. \nFor example, there are over 2786 well typed IMP programs of expression size up to 511, but our system \nchecks only 652 states to exhaustively cover this space. Finally, Figure 10 presents our experimental \nresults that sug\u00adgest that exhaustive testing within a small .nite domain does indeed catch all type \nsystem errors in practice, a conjecture also known as the small scope hypothesis [35, 41, 49]. We introduced \ntwenty different errors into the type system of Ownership Java (one at a time) and .ve different errors \ninto the operational semantics. Some are simple mistakes such as forgetting to include a type checking \nclause. Some are more subtle errors as the following examples illustrate. Max Expression Percentage of \nErrors Caught Size 1 0 2 8 3 40 4 68 5 76 6 80 7 84 8 100 Figure 10. Evaluating the small scope hypothesis. \nA max\u00adimum expression size of 8 is suf.cient to catch all the type system errors that we introduced into \nOwnership Java.  The Java compiler rejects as ill typed a term containing a type cast of a value of \ndeclared type T1 into a type T2 if T1 is neither a subtype nor supertype of T2. The Ownership Java (as \nalso the Featherweight Java) compiler, however, accepts such a term as well typed. We changed Ownership \nJava to re\u00adject such casts as ill typed. Our model checker then correctly detected that the preservation \ntheorem does not hold for the changed language. The term (T2) (Object<world>) new T1() provides a counter \nexample. It is well typed initially. But after the upcast, the term in effect simpli.es to (T2) new T1() \nwhich is ill typed in the changed language. The preservation theorem therefore does not hold. We also \nintroduced a subtle bug (c.f. [5, Figure 24]) into Ownership Java such that the owners as dominators \nproperty does not hold. Our checker correctly detected the bug. The results in Figure 10, while preliminary, \ndo indicate that exhaustive testing within a small .nite domain is an effec\u00adtive approach for checking \nsoundness of type systems. We also examined all the type soundness errors we came across in literature \nand found that in each case, there is a small pro\u00adgram state that exposes the error. This lends credibility \nto the validity of the small scope hypothesis in practice. 5. Related Work This section presents related \nwork on software model check\u00ading. Model checking is a formal veri.cation technique that exhaustively \ntests a circuit/program on all possible inputs (sometimes up to a given size) to handle input nondeter\u00adminism \nand all possible nondeterministic schedules to han\u00addle scheduling nondeterminism. There has been much \nre\u00adsearch on model checking of software. Verisoft [24] is a stateless model checker for C programs. Java \nPathFinder (JPF) [53, 38] is a stateful model checker for Java programs. XRT [27] checks Microsoft CIL \nprograms. Bandera [15] and JCAT [18] translate Java programs into the input language of model checkers \nlike SPIN [30] and SMV [42]. Bogor [21] is an extensible framework for building software model check\u00aders. \nCMC [44] is a stateful model checker for C programs that has been used to test large software including \nthe Linux implementation of TCP/IP and the ext3 .le system. For hardware, model checkers have been successfully \nused to verify fairly complex .nite state control circuits with up to a few hundred bits of state information; \nbut not circuits that have large data paths or memories. Similarly, for software, model checkers have \nbeen primarily used to verify control\u00adoriented programs (with scheduling nondeterminism) with respect \nto temporal properties; but not much work has been done to verify data-oriented programs (with input \nnondeter\u00adminism) with respect to complex data-dependent properties. Thus, most of the research on reducing \nthe state space of a software model checker has focused on checking programs with scheduling nondeterminism. \nTools such a Slam [3], Blast [29], and Magic [11] use heuristics to construct and check an abstraction \nof a program (usually predicate ab\u00adstraction [26]). Abstractions that are too coarse generate false positives, \nwhich are then used to re.ne the abstraction and redo the checking. This technique is known as Counter \nExample Guided Abstraction and Re.nement or CEGAR. There are also many static [24] and dynamic [23] partial \nor\u00adder reduction systems for concurrent programs. There are many other symmetry-based reduction techniques \nas well (e.g., [33]). However, none of the above techniques seem to be effective in reducing the state \nspace of a model checker when checking the soundness of a type system where one must deal with input \nnondeterminism (to check every input program state) and data-dependent properties (type correct\u00adness \nproperties that depend on input program states). In fact, because of input nondeterminism, it is dif.cult \nto even for\u00admulate the problem of checking type soundness automati\u00adcally in the context of most software \nmodel checkers. Tools such as Alloy [34, 36] and Korat [4] systematically generate all test inputs that \nsatisfy a given precondition. A version of JPF [38] uses lazy initialization of .elds to essentially \nsimulate the Korat algorithm. However, these tools generate and test every valid state and so do not \nachieve as much state space reduction as our system. Jalloy [52] and Miniatur [19] translate a Java program \nand its speci.cations into a SAT formula and verify it with a SAT solver. We experimented with a similar \napproach by trans\u00adlating both the operational semantics and the type system of a language into a SAT \nformula and verifying it with a SAT solver. However, translating operational semantics into SAT usually \nled to large formulas and the approach was less ef.\u00adcient than the model checker described in this paper. \nThis paper builds on our recent previous work on model checking properties of tree-based data structures \n[16]. This paper improves on the techniques presented in [16] and applies them to checking soundness \nof type systems. A recent paper [12] describes a technique for checking prop\u00aderties of programming languages \nspeci.ed in aProlog, us\u00ading a bounded backtracking search in an aProlog interpreter. However, [12] does \nnot use our search space reduction tech\u00adniques and does not scale as well as our model checker. 6. Conclusions \nThis paper presents a software model checker that automat\u00adically checks the soundness of a type system, \ngiven only the speci.cation of type correctness of intermediate program states and the small step operational \nsemantics. Currently, proofs of type soundness are either done on paper or are ma\u00adchine checked, but \nrequire signi.cant manual assistance in both cases. Consequently proofs of type soundness are usu\u00adally \ndone after language design, if at all. Our system can be used during language design with little extra \ncost. We have tested our system on several small to medium sized languages that include several features \nsuch as term and type level substitution, explicit heap, objects, etc., and found our approach to be \nfeasible. We expect our system to be partic\u00adularly useful to researchers who design novel type systems \nbut formalize only a core subset of their type systems, as is the standard practice in the research community. \nThis paper presents techniques that signi.cantly reduce the state space of a model checker for checking \ntype soundness. This paper thus makes contributions both in the area of checking soundness of type systems, \nand in the area of reducing the state space of a software model checker.  Acknowledgments This research \nwas supported in part by AFOSR Grant FA9550-07-1-0077. References [1] J. Aldrich, V. Kostadinov, and \nC. Chambers. Alias an\u00adnotations for program understanding. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOP-SLA), November 2002. [2] B. E. Aydemir et al. Mechanized metatheory for the masses: \nThe POPLMARK challenge, May 2005. http://www.cis.\u00adupenn.edu/ plclub/wiki-static/poplmark.pdf. [3] T. \nBall, R. Majumdar, T. Millstein, and S. K. Rajamani. Auto\u00admatic predicate abstraction of C programs. \nIn Programming Language Design and Implementation (PLDI), June 2001. [4] C. Boyapati, S. Khurshid, and \nD. Marinov. Korat: Automated testing based on Java predicates. In International Symposium on Software \nTesting and Analysis (ISSTA), July 2002. Winner of an ACM SIGSOFT distinguished paper award. [5] C. Boyapati, \nR. Lee, and M. Rinard. Ownership types for safe programming: Preventing data races and deadlocks. In \nObject-Oriented Programming, Systems, Languages, and Applications (OOPSLA), November 2002. [6] C. Boyapati, \nB. Liskov, and L. Shrira. Ownership types for object encapsulation. In Principles of Programming Languages \n(POPL), January 2003. [7] C. Boyapati, B. Liskov, L. Shrira, C. Moh, and S. Richman. Lazy modular upgrades \nin persistent object stores. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), \nOctober 2003. [8] C. Boyapati and M. Rinard. A parameterized type system for race-free Java programs. \nIn Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 2001. [9] C. Boyapati, \nA. Salcianu, W. Beebee, Jr., and M. Rinard. Ownership types for safe region-based memory management in \nReal-Time Java. In Programming Language Design and Implementation (PLDI), June 2003. [10] R. E. Bryant. \nSymbolic boolean manipulation with ordered binary decision diagrams. ACM Computing Surveys 24(3), 1992. \n[11] S. Chaki, E. Clarke, A. Groce, S. Jha, and H. Veith. Modular veri.cation of software components \nin C. In International Conference on Software Engineering (ICSE), June 2003. [12] J. Cheney and A. Momigliano. \nMechanized metatheory model-checking. In Principle and Practice of Declarative Programming (PPDP), July \n2007. [13] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. In \nObject-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 1998. [14] E. M. \nClarke, O. Grumberg, and D. A. Peled. Model Checking. MIT Press, 1999. [15] J. Corbett, M. Dwyer, J. \nHatcliff, C. Pasareanu, Robby, S. Laubach, and H. Zheng. Bandera: Extracting .nite-state models from \nJava source code. In International Conference on Software Engineering (ICSE), June 2000. [16] P. Darga \nand C. Boyapati. Ef.cient software model checking of data structure properties. In Object-Oriented Program\u00adming, \nSystems, Languages, and Applications (OOPSLA), October 2006. [17] R. DeLine and M. Fahndrich. Enforcing \nhigh-level protocols in low-level software. In Programming Language Design and Implementation (PLDI), \nJune 2001. [18] C. DeMartini, R. Iosif, and R. Sisto. A deadlock detection tool for concurrent Java programs. \nSoftware Practice and Experience (SPE) 29(7), June 1999. [19] J. Dolby, M. Vaziri, and F. Tip. Checking \nproperties of heap-manipulating procedures using a constraint solver. In European Software Engineering \nConference and Foundations of Software Engineering (ESEC/FSE), September 2007. [20] S. Drossopoulou and \nS. Eisenbach. Java is type safe probably. In European Conference for Object-Oriented Programming (ECOOP), \nJune 1997. [21] M. Dwyer, J. Hatcliff, M. Hoosier, and Robby. Building your own software model checker \nusing the Bogor extensible model checking framework. In Computer Aided Veri.cation (CAV), January 2005. \n[22] N. Een and A. Biere. Effective preprocessing in SAT through variable and clause elimination. In \nTheory and Applications of Satis.ability Testing (SAT), June 2005. [23] C. Flanagan and P. Godefroid. \nDynamic partial-order reduction for model checking software. In Principles of Programming Languages (POPL), \nJanuary 2005. [24] P. Godefroid. Model checking for programming languages using VeriSoft. In Principles \nof Programming Languages (POPL), January 1997. [25] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed \nautomated random testing. In Programming Language Design and Implementation (PLDI), June 2005. [26] S. \nGraf and H. Saidi. Construction of abstract state graphs with PVS. In Computer Aided Veri.cation (CAV), \nJune 1997. [27] W. Grieskamp, N. Tillmann, and W. Shulte. XRT Exploring runtime for .NET: Architecture \nand applications. In Workshop on Software Model Checking (SoftMC),July 2005. [28] D. Grossman, G. Morrisett, \nT. Jim, M. Hicks, Y. Wang, and J. Cheney. Region-based memory management in Cyclone. In Programming Language \nDesign and Implementation (PLDI), June 2001. [29] T. A. Henzinger, R. Jhala, and R. Majumdar. Lazy abstrac\u00adtion. \nIn Principles of Programming Languages (POPL), January 2002. [30] G. Holzmann. The model checker SPIN. \nTransactions on Software Engineering (TSE) 23(5), May 1997. [31] A. Igarashi, B. Pierce, and P. Wadler. \nFeatherweight Java: A minimal core calculus for Java and GJ. In Object-Oriented Programming, Systems, \nLanguages, and Applications (OOP-SLA), October 1999. [32] R. Iosif. Symmetry reduction criteria for software \nmodel checking. In SPIN workshop on Model Checking of Software (SPIN), April 2002. [33] C. N. Ip and \nD. Dill. Better veri.cation through symmetry. In Computer Hardware Description Languages, April 1993. \n[34] D. Jackson. Software Abstractions: Logic, Language, and Analysis. MIT Press, 2006. [35] D. Jackson \nand C. Damon. Elements of style: Analyzing a software design feature with a counterexample detector. \nIEEE Transactions on Software Engineering (TSE) 22(7), July 1996. [36] S. Khurshid and D. Marinov. TestEra: \nSpeci.cation-based testing of Java programs using SAT. In Automated Software Engineering (ASE), November \n2001. [37] S. Khurshid, D. Marinov, and D. Jackson. An analyzable annotation language. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), November 2002. [38] S. Khurshid, C. S. Pasareanu, \nand W. Visser. Generalized symbolic execution for model checking and testing. In Tools and Algorithms \nfor Construction and Analysis of Systems (TACAS), April 2003. [39] J. C. King. Symbolic execution and \nprogram testing. In Communications of the ACM (CACM) 19(7), August 1976. [40] G. T. Leavens, A. L. Baker, \nand C. Ruby. Preliminary design of JML: A behavioral interface speci.cation language for Java. Technical \nReport TR 98-06i, Department of Computer Science, Iowa State University, May 1998. [41] D. Marinov, A. \nAndoni, D. Daniliuc, S. Khurshid, and M. Rinard. An evaluation of exhaustive testing for data structures. \nTechnical Report TR-921, MIT Laboratory for Computer Science, September 2003. [42] K. McMillan. Symbolic \nModel Checking. Kluwer Academic Publishers, 1993. [43] M. Musuvathi and D. Dill. An incremental heap \ncanonical\u00adization algorithm. In SPIN workshop on Model Checking of Software (SPIN), August 2005. [44] \nM. Musuvathi, D. Y. W. Park, A. Chou, D. R. Engler, and D. Dill. CMC: A pragmatic approach to model checking \nreal code. In Operating System Design and Implementation (OSDI), December 2002. [45] A. C. Myers. JFlow: \nPractical mostly-static information .ow control. In Principles of Programming Languages (POPL), January \n1999. [46] G. C. Necula, S. McPeak, and W. Weimer. CCured: Type\u00adsafe retro.tting of legacy code. In Principles \nof Programming Languages (POPL), January 2002. [47] T. Nipkow and D. von Oheimb. Java light is type-safe \nde.nitely. In Principles of Programming Languages (POPL), January 1998. [48] N. Nystrom, M. R. Clarkson, \nand A. C. Myers. Polyglot: An extensible compiler framework for Java. In Compiler Construction (CC), \nApril 2003. [49] J. Offutt and R. Untch. Mutation 2000: Uniting the orthogonal. In Mutation 2000: Mutation \nTesting in the Twentieth and the Twenty First Centuries, October 2000. [50] B. C. Pierce. Types and Programming \nLanguages.MIT Press, 2002. [51] P. Sewell, F. Z. Nardelli, S. Owens, G. Peskine, T. Ridge, S. Sarkar, \nand R. Strnisa. Ott: Effective tool support for the working semanticist. In International Conference \non Functional Programming (ICFP), October 2007. [52] M. Vaziri and D. Jackson. Checking properties of \nheap\u00admanipulating procedures using a constraint solver. In Tools and Algorithms for Construction and \nAnalysis of Systems (TACAS), April 2003. [53] W. Visser, K. Havelund, G. Brat, and S. Park. Model checking \nprograms. In Automated Software Engineering (ASE), September 2000. [54] D. Walker. A type system for \nexpressive security policies. In Principles of Programming Languages (POPL), January 2000. [55] G. Winskel. \nThe Formal Semantics of Programming Languages. MIT Press, 1993. [56] A. K. Wright and M. Felleisen. A \nsyntactic approach to type soundness. In Information and Computation 115(1), November 1994.  \n\t\t\t", "proc_id": "1449764", "abstract": "<p>This paper presents novel techniques for checking the soundness of a type system automatically using a software model checker. Our idea is to systematically generate every type correct intermediate program state (within some finite bounds), execute the program one step forward if possible using its small step operational semantics, and then check that the resulting intermediate program state is also type correct--but do so efficiently by detecting similarities in this search space and pruning away large portions of the search space. Thus, given only a specification of type correctness and the small step operational semantics for a language, our system automatically checks type soundness by checking that the progress and preservation theorems hold for the language (albeit for program states of at most some finite size). Our preliminary experimental results on several languages--including a language of integer and boolean expressions, a simple imperative programming language, an object-oriented language which is a subset of Java, and a language with ownership types--indicate that our approach is feasible and that our search space pruning techniques do indeed significantly reduce what is otherwise an extremely large search space. Our paper thus makes contributions both in the area of checking soundness of type systems, and in the area of reducing the state space of a software model checker.</p>", "authors": [{"name": "Michael Roberson", "author_profile_id": "81331502480", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P1223231", "email_address": "", "orcid_id": ""}, {"name": "Melanie Harries", "author_profile_id": "81381603767", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P1223232", "email_address": "", "orcid_id": ""}, {"name": "Paul T. Darga", "author_profile_id": "81100650543", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P1223233", "email_address": "", "orcid_id": ""}, {"name": "Chandrasekhar Boyapati", "author_profile_id": "81319488571", "affiliation": "University of Michigan, Ann Arbor, MI, USA", "person_id": "P1223234", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449803", "year": "2008", "article_id": "1449803", "conference": "OOPSLA", "title": "Efficient software model checking of soundness of type systems", "url": "http://dl.acm.org/citation.cfm?id=1449803"}