{"article_publication_date": "10-19-2008", "fulltext": "\n * Deep Typechecking and Refactoring Zachary Tatlock Chris Tucker David Shuffelton UC San Diego UC San \nDiego UC San Diego ztatlock@cs.ucsd.edu cjtucker@cs.ucsd.edu dshu.el@cs.ucsd.edu Ranjit Jhala Sorin \nLerner UC San Diego UC San Diego jhala@cs.ucsd.edu lerner@cs.ucsd.edu Abstract Large software systems \nare typically composed of multiple layers, written in different languages and loosely coupled using a \nstring-based interface. For example, in modern web\u00adapplications, a server written in Java communicates \nwith a database back-end by passing in query strings. This widely prevalent approach is unsafe as the \nanalyses developed for the individual layers are oblivious to the semantics of the dynamically constructed \nstrings, making it impossible to statically reason about the correctness of the interaction. Further, \neven simple refactoring in such systems is daunting and error prone as the changes must also be applied \nto isolated string fragments scattered across the code base. We present techniques for deep typechecking \nand refac\u00adtoring for systems that combine Java code with a database back-end using the Java Persistence \nAPI [10]. Deep type\u00adchecking ensures that the queries that are constructed dy\u00adnamically are type safe \nand that the values returned from the queries are used safely by the program. Deep refactoring builds \nupon typechecking to allow programmers to safely and automatically propagate code refactorings through \nthe query string fragments. Our algorithms are implemented in a tool called QUAIL. We present experiments \nevaluating the effectiveness of QUAIL on several benchmarks ranging from 3,369 to 82,907 lines of code. \nWe show that QUAIL is able to verify that 84% of query strings in our benchmarks are type safe. Finally, \nwe * Supported in part by the NSF grants CCF-0427202, CNS-0541606, and CCF-0546170. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 08, October 19 23, \n2008, Nashville, Tennessee, USA. Copyright c &#38;#169; 2008 ACM 978-1-60558-215-3/08/10. . . $5.00 show \nthat QUAIL reduces the number of places in the code that a programmer must look at in order to perform \na refac\u00adtoring by several orders of magnitude. Categories and Subject Descriptors D.2.4 [Software En\u00adgineering]: \nSoftware/Program Veri.cation General Terms Reliability, Veri.cation Keywords JPA Query Analysis, Cross \nLanguage Type\u00adchecking, Cross Language Refactoring 1. Introduction Large software systems are built in \nmultiple layers, employ\u00ading various systems, languages, and run-times. For exam\u00adple, companies like Amazon, \nGoogle, and Yahoo all produce software that has three basic tiers: a browser front-end using HTML and \nJavascript, a middle-tier running Java, .NET, or a similar stack of server technology, and a storage \ntier using a relational database or other long-lived storage platform. A successful integration of these \nlayers must enjoy three prop\u00aderties: it must be ef.cient, in that it must be able to exploit the bene.cial \nproperties of the individual layers; it must be usable, in that it must allow engineers to easily utilize \nthe full range of functionality available in the individual layers; and it must be safe, in that it must \nprevent errors due to in\u00adteractions that cut across the different layers. Unfortunately these three properties \nhave hitherto re\u00adsisted reconciliation. For example, consider the problem of interfacing between an object-oriented \nprogramming lan\u00adguage and a relational database. A number of approaches ex\u00adist for translating data to \nand from objects and relations, each of which attempts to deal with the so-called impedance mis\u00admatch \n[13] that exists between relational data and object\u00adoriented data. Orthogonal persistence solutions [1, \n12] map the entire database into a collection of persistent objects that are di\u00adrectly manipulated and \nnavigated in the programming lan\u00adguage. This approach is safe, as the programming language s type system \nis in full control, but is often hard to use and sac\u00adri.ces opportunities for optimization of data access. \nIn par\u00adticular, the programming language and database are tightly coupled, resulting in a system whose \ndata design is de\u00adpendent on programming language decisions, which in turn leads to a less ef.cient and \nharder to use data store. Language-based solutions [18, 15] extend programming languages like Java [23] \nor Cq [2] with syntax inspired by functional programming constructs [24, 5] that can be di\u00adrectly compiled \ninto database queries. Not only are these approaches safe, but they can also be ef.cient. In particu\u00adlar, \nthe programming language and database can be more loosely coupled than in an orthogonal persistence solution, \nresulting in improvement ef.ciency of data storage and re\u00adtrieval. However, the usability of these techniques \nremains to be seen. One barrier to adoption is that these techniques hide the structure of the generated \nqueries, which can lead to unexpected performance bugs. Finally, call-level interfaces [20] such as Toplink \n[6], EJB [14], JDO [17], and Hibernate [9] recently consolidated under the Java Persistence API (JPA) \n[10, 11] standard for Java allow developers to describe mappings of relational constructs onto Java \ntypes, which can then be queried us\u00ading SQL-like query strings. This approach is both .exible and ef.cient \nbecause the query strings are expressed in a language speci.cally designed for data access, but are less \nsafe as the host language is unaware of the content of the query strings, and is unable to apply its \ntype constraints to those queries. This approach has the loosest coupling be\u00adtween programming language \nand database, and makes it easy for developers to ef.ciently query for and use data from the database \nwithout having any direct knowledge of the re\u00adlational structures used to hold that data, but at the \ncost of a loss of safety. In general the approach of loosely coupling different sys\u00adtems using a string-based \ninterface with a domain-speci.c interfacing language is .exible, can leverage the properties of each \nlayer effectively, does not force the developer to learn another language or paradigm, and hence is widely \nadopted by large-scale system developers. Unfortunately, this approach is unsafe in that it greatly complicates \ntwo standard software engineering tasks: type\u00adchecking and refactoring. Large systems that are made of \nloosely coupled heterogeneous components have little sup\u00adport for performing typechecking at the boundaries \nof differ\u00adent languages. Furthermore, performing even simple refac\u00adtoring in such systems is daunting \nand error prone, because the required changes cut across different layers, causing sub\u00adtle bugs to slip \nbetween the cracks. As an illustrative example, consider the Java code snippet from Figure 1. In this \nsnippet, Q0 is an abbreviation for the query string shown at the top of the .gure. On line 2 the code \ncreates a JPA query that returns the set of books owned by a given person ?1. The person ?1 is a parameter \n Figure 1. Sample JPA Code to the query, and this parameter is set (on line 3) using a call to setParameter. \nOnce the parameter is set, the query is executed (on line 4), and the result of the query, a list of \nBook objects, is stored in the result variable. The code then proceeds to print the name of each book \nin the result list (on lines 5-8). Note how in this code the Book and Person classes crosscuts both Java \nand the query language: they are meaningful in both contexts. This code snippet illustrates two of the \nmain dif.culties in writing and maintaining JPA code: Type Errors: As objects are passed to and from \nthe database back-end through a single interface (namely setParameter and getResultList), these interfaces \nuse Object for the type of parameters and results, which leads to the compiler missing type errors. For \nexample, if a Car object were passed in to setParameter on line 3, the compiler would not be able to \n.ag this as a type error. Furthermore, because getResultList() returns a list of Objects, the variable \non line 4 is declared as List<Object>, not List<Book>, and as a result there is an additional cast on \nline 6, which at run-time may fail if the programmer uses the wrong type in the type cast. Refactoring \nErrors: As names of classes appear in query strings, for example in Q0, changing the name of a class \nin\u00advolves renaming all the queries that mention the class. Un\u00adfortunately, there is little support for \nhelping the program\u00admer make sure that all such strings have been renamed. The class-rename refactoring \nin Eclipse does not refactor such strings, and furthermore forgetting to rename a string does not lead \nto a type error, unlike renaming a class directly in Java, where forgetting to rename a mention of the \nrenamed class leads to a type error. Our broad research agenda is to address these problems, and thus \nreconcile safety, usability and ef.ciency, by devel\u00adoping techniques and tools for deep typechecking \nand deep refactoring type-checking and refactoring that cut across different languages and systems. \nIn this paper we present techniques for deep typechecking and refactoring for sys\u00adtems that combine Java \ncode with a database back-end using JPA. For deep typechecking, the main challenges lie in the fact that \nthe problem cuts across Java and the JPA query lan\u00adguages in non-trivial ways. First, the Java code manipulates \nstrings that represent JPA queries, making it dif.cult to iden\u00adtify the queries that are executed. Second, \nthe Java code sets the parameters to the JPA queries, and uses the results that they produce, which requires \ntracking where these results .ow to determine if they are used correctly. We address these challenges \nby using different techniques for analyzing Java and JPA queries. We use a data.ow analysis on the Java \nside to compute the set of query strings that may be executed at a particular call site to getSingleResult, \nand to propagate the result type of exe\u00adcuted queries through the code to make sure that downcasts will \nnot fail at run-time. On the JPA side, we use a type sys\u00adtem, augmented with some simple constructs to \nrepresent sets of queries, to determine if a query (or set of queries) typechecks. Working together, \nthese two techniques allow us to identify (1) what query strings are executed by the Java code, (2) whether \nthese query strings typecheck given the parameters that the Java code has set on them, and (3) whether \nthe results of these queries are used correctly in the Java code. For deep refactoring, the main challenge \nlies in updat\u00ading raw strings that represent JPA queries or fragments of queries which are concatenated \ntogether by the Java code. Fragments are particularly dif.cult, not only for an auto\u00admated tool, but \nalso for humans, because there is no context available for understanding the query it is dif.cult to \ntell if a given substring should be refactored without knowing the context in which the substring is \ntyped. We address this challenge by building upon deep type\u00adchecking as follows. First our algorithm \ntags each query fragment with an identi.er that uniquely determines the Java string literal that the \nfragment originated from. The string data.ow analysis used for deep typechecking is used to com\u00adpute \nthe set of complete tagged query strings that reach an execution site. Next, our algorithm performs refactorings \nin the context of an entire query, using the deep typechecker as a subroutine to determine the types \nof identi.ers. Finally, our algorithm propagates the changes back to the Java code using the tags. In \nsummary, this paper takes a step towards enabling developers to safely combine different layers using \nef.cient and .exible call-level interfaces. In particular, we make the following concrete contributions: \nDeep Typechecking. We present techniques for checking that the parameters set by the Java code on JPA \nqueries are of the correct type, that all parameters of a query are set before it is executed, and that \nthe returned val\u00adues of JPA queries are used correctly in the Java code (Section 3). Figure 2. Query \nType Checking Deep Refactoring. We present techniques for perform\u00ading class-rename and .eld-rename refactorings \non classes and .elds that may appear in query strings (Section 4). Our refactoring technique renames \nnot only direct refer\u00adences from the Java code, but also references that appear in query strings that \nthe Java code manipulates.  Experimental validation. We implemented the above techniques in a tool called \nQUAIL, and present the re\u00adsults of running QUAIL on a variety of benchmarks (Sec\u00adtion 5), the largest \nof which is Roller, a web blogging software system comprising 82,907 lines of code. We show that QUAIL \nis able to verify that 84% of query execution sites in the Java code use types correctly (the remaining \ncases are false-positives where we incorrectly report safe query executions as potential errors), and \nwe show that our tool reduces the number of places in the code that a programmer must look at to perform \nrefactor\u00adings by several orders of magnitude.  2. Overview We begin with an overview of Deep Typechecking \nand Refactoring using simpli.ed versions of examples taken from the Roller code base. Deep Typechecking \nConsider the Java method shown in Figure 2. For clar\u00adity, we write Q1 as an abbreviation for the query \nstring shown at the top of the Figure. For the moment, ignore the shaded lines 2,4,6. The string Q1 corresponds \nto a SELECT query, which is used to .nd all WeblogTemplate objects w whose website and link .elds respectively \nmatch the arguments site and link passed into the method. To this end, in line 1 the string Q1 is used \nto create a query ob\u00adject q, and setParameter calls are used to bind the query parameters to the corresponding \nJava values on lines 3,5 respectively. Next, the query is executed by calling the getSingleResult method \non line 7. The output of the method, is downcast to WeblogTemplate and returned. Motivation. The goal \nof deep typechecking is to statically prove the absence of a variety of run-time errors (exceptions) \nthat can arise in buggy programs, but which, due to the poly\u00adlingual nature of the interaction, slip \nthrough the cracks of Java s type system. Query Correctness: First, suppose that the method con\u00adtained \nthe line 2, wherein the .rst query parameter is bound to a Book object. The Java type system would not \n.ag any errors as the setParameter method takes any Object as input. However, the subsequent query execu\u00adtion \nwill fail as the website .eld of a WeblogTemplate object is of type Weblog which cannot be compared against \na Book object. Of course, errors can be caused independent of the ways that the parameters are set e.g. \nif WeblogTemplate objects do not have a link .eld. Our .rst goal is to ensure that in each query object, \nthe pa\u00adrameters are set safely, i.e., so that the subseqent queries execute without errors. Query Completeness: \nSecond, suppose that the method contained the line 4, where the query is executed before the second parameter \nis bound. At run time, this line will cause the JPA implementation to throw an exception as the second \nquery parameter is not bound. Our second goal is to ensure that in each query object, all the pa\u00adrameters \nhave been set at the point where the query is executed. Output Correctness: Finally, suppose that the \nmethod con\u00adtained the line 6 where the query is executed and its result downcast to type Book. As the \nquery execution method getSingleResult returns an Object result, the line will typecheck but will cause \na failed downcast excep\u00adtion to be thrown at run-time as the actual object returned is of the type WeblogTemplate. \nOur third goal is to en\u00adsure that the objects, or as we shall see, lists of objects returned by queries \nare safely used by the rest of the Java code, i.e., do not cause failed downcast exceptions at run\u00adtime. \nAlgorithm. The key to connecting the Java code with the database back-end is the notion of a bound query \nwhich is a pair of a query object and a (partial) mapping from the parameters of the query to the types \nof the objects the parameters are bound to. For example, select w from Template w where w.website =?1, \n?1 :Weblog represents a bound select query where the .rst parameter is bound to an object of type Weblog. \nQUAIL uses bound queries to perform deep type checking via a three-step algorithm. In the .rst step, \nBound Query Analysis, QUAIL performs a data.ow analysis to determine the set of bound queries that .ow \nto each program point where a query is executed e.g. lines 6,7 from Figure 2. In the second step, Type \nAnalysis, QUAIL checks that each of the bound queries that reach an execution point represent Figure \n3. Multiple Query Flow a well typed JPA query namely that all the parameters are set to values of appropriate \ntypes. Further, in this step, QUAIL analyzes the structure of the query to infer the type of the query \nresult. In the third step, Result Analysis, QUAIL propagates the type inferred for the query result to \nthe points inside program where the result is downcast from Object, to verify that the downcast is safe. \nQUAIL veri.es the code in Figure 2 (ignoring the shaded lines), as exactly one bound query .ows to the \nexecution point on Line 7, and in this bound query, the two parameters ?1 and ?2 are set to objects of \ncorrect types. Further, the downcast succeeds as it is to the same type as that of w de.ned in the query. \nIf line 2 is used instead of line 3, QUAIL .ags a warning as the bound query reaching line 7 fails to \ntype check, as the comparison w.website =?1 fails to typecheck in a type en\u00advironment where w has type \nWeblogTemplate (whose .eld Website has type Weblog) and ?1 has type Book. If line 4 is used, QUAIL .ags \na warning as the type of the parameter ?2 is unde.ned in the bound query .owing to line 4, causing the \ncomparison w.link =?2 to not typecheck. If line 6 is used, QUAIL .ags a warning as the inferred type \nof the output of the query reaching the execution point is not a superclass of Book. Multiple Queries. \nThe JPA makes it easy to use run-time in\u00adformation to build different kinds of query objects. Consider \nthe method shown in Figure 3 which takes a start and end date and returns a list of websites that were \npublished be\u00adtween those dates. The start parameter is optional if it is null then the method should \nreturn all the sites published before the end date. As before, we use Q2 and Q3 as abbreviations for \nthe two query strings shown at the top of the Figure. The method checks if the start parameter is non-null. \nIn this case, the method uses Q2 to create a query with two parame\u00adters a start and end, and sets the \ntwo parameters. If the case that start is null, the method uses Q3 to create a query with only one parameter \nand sets the parameter ap\u00adpropriately. Finally, the method executes the query by call\u00ading getResultList \nand iterates over the list of objects re\u00adturned, downcasting each object in the list to a String be\u00adfore \nadding it to the list of results. QUAIL checks this method as follows. First, the bound query analysis \ndeduces that two bound queries .ow into q at the program point at line 11. The .rst bound query cor\u00adresponds \nto Q2 and has the parameters ?1 and ?2 bound to the type Timestamp. The second query corresponds to Q3 \nand has the parameter ?1 bound to Timestamp. Second, each of these bound queries typechecks as in the \ntype en\u00advironment where c is of type WeblogEntryComment, the term c.weblogEntry.pubTime has type Timestamp \nand so the comparison(s) typecheck. Third, both queries return as output the .eld c.weblogEntry.website.name \nwhich has type String. By propagating this output type through the assignments on Lines 11,13,14, we \ninfer that i.next() is of type String and so the downcast succeeds. Deep Refactoring Though query strings \nmake for a simple and expressive in\u00adterface between Java and the database back-end, they greatly complicate \nthe task of modifying the code or database schemas as now the programmer must painstakingly go through \neach of the strings to make sure they are appropri\u00adately modi.ed. For example, renaming (or deleting) \na .eld of a persistent class would require sifting through each query string scattered across multiple \n.les and appropriately re\u00adnaming (or deleting) references to the modi.ed .eld. Unfor\u00adtunately, the Java \ntype checker is of little help as the refer\u00adences are embedded within strings. Motivation. The goal of \ndeep refactoring is to simplify this task by using the machinery developed for deep typecheck\u00ading to \nautomatically and correctly update the query strings to re.ect the changes made to the classes or the \ndatabase. In particular, we consider two refactoring tasks Class Renam\u00ading and Field Renaming. It is \neasy to extend our techniques to other tasks like automatically determining which query strings are impacted \nby the deletion of .elds in persistent classes. Recall the example from Figure 3. Suppose that the pro\u00adgrammer \nwishes to change the name of the .eld name of the class Weblog to blogName. Unfortunately, one cannot \nsimply perform a search-and-replace of the string name with Figure 4. Query String Construction blogName \nas several other classes can also have .elds with the same name. To automatically refactor the query \nstrings, QUAIL per\u00adforms a modi.ed version of the bound query analysis, where each query string is tagged \nwith a unique identi.er that indi\u00adcates the location of the string in the program source. For the program \nin Figure 3, the set of tagged bound queries reach\u00ading the execution point at Line 11 is: {((Q2)4,...), \n((Q3)8,...)} Next, QUAIL refactors each tagged bound query by refac\u00adtoring each term appearing in the \nquery. For exam\u00adple, as c has the type WeblogEntryComment, the term c.weblogEntry.website has the type \nWeblog and hence, the term c.weblogEntry.website.name is changed to c.weblogEntry.website.blogName. A \nsimilar change is made to the second tagged query. Finally the tags are used to substitute the new query \nstrings in place of the old ones in the program source. Dynamic Query Construction. So far we have looked \nat queries built from contiguous strings. A common pattern is to dynamically construct queries by starting \nwith a base string to which extra conditions are appended depending on run-time values. Consider the \nmethod shown in .gure 4 which constructs a query from a base string Q4, to which, depending on whether \nor not the weblog variable is null, an extra condition is appended. Suppose that the programmer wishes \nto rename the .eld weblog of the class WeblogAggregate to blog. Again, we cannot simply rename the substring \nweblog without knowing the type of the preceding identi.er w. QUAIL does refactoring in the presence \nof such dynam\u00adically created query strings as follows. First, we extend our notion of bounded queries \nto extended bounded queries which comprise a base query concatenated with a regular ex\u00adpression over \nquery fragments that represent the set of pos\u00adsible extra conditions that can be appended to the end \nof the base query. Each query fragment appearing in the extension is also tagged with a unique identi.er \nindicating the frag\u00adment s position in the source. As the variable declarations are in the query pre.x \nstring and not scattered over the reg\u00adular extension, it is easy to extend both the type checking and \nrefactoring algorithms to handle the extensions. Thus, QUAIL starts by using a standard string analysis \nalgorithm [3] to compute the extended bounded queries that reach each query execution point, then it \nrefactors the extended queries at the point, and .nally replaces each tagged query fragment in the source \nwith its refactored version. Thus, for the code shown in Figure 4, QUAIL .rst deter\u00admines that the extended \nquery (Q4)2[(AND w.weblog =?2)5 + (AND w.weblog = NULL)8] reaches the execution point at line 10. Notice \nthe common pre.x with the declaration for the type of w, and the exten\u00adsion that includes the two possible \nextensions. Using the fact that w is of type WeblogAggregate obtained from the base query, QUAIL refactors \nthe above to: (Q4)2[(AND w.blog =?2)5 + (AND w.blog = NULL)8] after which, the strings at lines 5,8 are \nrefactored to: \"AND w.blog = ?2\" and \"AND w.blog = NULL\" respec\u00adtively. 3. Deep Type checking QUAIL performs \ndeep type checking in three steps: a Bound Query Analysis over the Java code determines the set of bound \nqueries that .ow to each program point where queries are executed; a Type Analysis over the JPA query \nlanguage then checks that each bound query is type-correct; .nally a Result Analysis over the Java code \nchecks that objects returned by the queries are used correctly in the Java code. We start by presenting \nour type analysis (Section 3.1), which consists of a type system for the JPA query language. We then \npresent the bound query analysis (Section 3.2), which computes the set of bound queries that the type \nsystem should be invoked with. Finally, we present the return anal\u00adysis (Section 3.3), which propagates \nthe return types from the type system through the Java code. 3.1 Type Analysis Type Environment. A type \nenvironment G is a partial func\u00adtion from parameter names and identi.er names to types. A type in our \nsystem can either be a base type or a class. Base types are primitives or classes that are not handled \nby the Java persistence API. As queries only refer to .elds, we do not need to capture methods or inheritance \nin classes. Thus, we simply abstract a class as a record containing typed .elds. Syntax. The core syntax \nof JPA queries is shown in Fig\u00adure 5. There are three kinds of queries: select, update and delete. Each \nof these queries contains a where clause that can be a conjunction, disjunction, or a comparison of two \nterms using an operator M which ranges over comparison operators like =, =, =, etc.. Each term is either \na query parameter, or an lvalue obtained by following the .elds of some identi.er declared in the query. \nWe brie.y and infor\u00admally summarize the semantics of queries the interested reader is referred to [10] \nfor details. A select t1,...,tn from G where e query returns the set of tuples t1,...,tn chosen from \nthe set of persistent classes described by the environment G, such that the condition e holds for each \ntuple.  An update x:C set a1,...,an where e query updates each instance of C that satis.es the condition \ne, using the assignments a1,...,an.  A delete x :C where e deletes each instance of C that satis.es \nthe condition e.  Tags. Observe that base part of the query, which consists of the select, update or \ndelete clause, is tagged with an identi.er i representing the location in the code where the base part \noriginated from. For example, in Figure 3, the query created on line 4 in our syntax will be (Q2)4. These \ntags allow our refactoring algorithm to map changes in the query back to the strings in the Java code. \nExtensions. To account for dynamically created queries, our syntax allows for query extensions. An extension \nr repre\u00adsents additions to the base query that have been made pro\u00adgramatically using string concatenation. \nFor example, (.e)i represents the fact that e has been added as a conjunct to the where clause of the \nbase query, and (.e)i represents the fact that e has been added as disjunct. Note that all the extensions \napply to the where clause of the base query. In some cases, for example the method shown in Figure 4, \nthe code that creates query strings contains control .ow. To account for such control .ow, query extensions \ncan contain regular ex\u00adpression operators like concatenation and sum. QUAIL uses standard string analysis \nalgorithms [3] to compute, for each site i in the code that calls CreateQuery, a query qi in our syntax \nthat overapproximates the set of queries that could be created at site i. Control .ow constructs in the \nquery\u00adbuilding code map directly to regular expression operators in our query syntax: linear code introduces \nconcat opera\u00adtors, branches introduce + operators. Like the base queries, the each query fragment appearing \nin an extension is tagged with the location in the code from which it originates. For example, for the \ncode shown in Figure 4, QUAIL would determine that the query created on line 10 is ex\u00adpressed in our \nsyntax as follows: q10 = (Q4)2[(. w.weblog =?2)5 +(. w.weblog = NULL)8] That is, the query created at \nline 10 is an extended query with the base query Q4 and an extension which is the sum of the q ::= Queries: \n|(select t1,...,tn from G where e)i r select |(update x :t set a1,...,an where e)i r update |(delete \nx :t where e)i r delete e ::= Expressions: | tM t atom | e . e conjunction | e . e disjunction r ::= \nExtensions: | empty | (.e)i and | (.e)i or | rr concat | r + r sum G ::= Type Envs: | x:t, G identi.er \n| ?p : t, G parameter t ::= Types: | C = {f1 :t1,...,fn : tn} Record | B Base a ::= lv:=t Assignments \nt ::= Terms: | ?p parameter | c constant | lv lvalue lv ::= Lvalues: | x identi.er | lv.f .eld-access \nFigure 5. Query Syntax two extensions of the then-and else-branch respectively. The QUAIL typechecker \ncurrently does not handle query strings that are created using a loop such query strings will fail to \ntypecheck. As our experiments will show in Section 5, JPA queries are rarely created in loops. Type System. \nThe type system for queries is shown in Fig\u00adure 6. The system has .ve kinds of judgements: Terms: G \nf t : t which state that under the environment G the term t has type t. The type of identi.ers and parameters \nis found from the environment, and type of .eld expressions lv.f is obtained via the type of the .eld \nf of the recursively computed (record) type of lv.  Assignments: G f lv:=t which state that under the \nenvi\u00adronment G the assignment lv:=t typechecks. An assign\u00adment only type checks if the type of the value \nt being assigned is a subtype of the lvalue lv to which the assign\u00adment occurs.  Expressions: G f e \nwhich state that under the environ\u00adment G the expression e typechecks. An expression type checks if each \natomic comparison within e is between  values of comparable types, a notion made precise by the ~ relation. \n Extensions: G f r which state that under the environ\u00adment G the extension r typechecks. An extension \ntype\u00adchecks if each of its constituent expressions typechecks.  Queries: G f q which state that under \nthe environment G the extended query q typechecks. Note that for the ex\u00adtended query to typecheck, its \nconstituent where clause and assignments must typecheck. Further, notice that we use the type environment \nor declaration from the base query to type check the extension.   3.2 Bound Query Analysis We now describe \nour Bound Query Analysis. The goal of this analysis is to compute the set of bound queries that could \nbe executed at each getSingleResult call site (where a bound query is a query combined with the parameters \nthat have been set on it) Domain. As described in Section 3.1, a type environment G is a partial function \nfrom parameter names and identi.er Terms G f t : t ty(c)= t ?p :t . G [T-CONST] [T-PARAM] G f c : t G \nf ?p : t G(x)= t G f lv : {...,f :t,...} [T-ID] [T-LVAL] G f x : t G f lv.f : t Assignment G f a G f \nlv : t G f t : t' t'<:t [ASGN] G f lv:=t Expressions G f e G f t : t G f t' : t' t ~ t ' [E-ATOM] ' G \nf tM t '' G f e G f eG f e G f e ' [E-AND] [E-OR] G f e . eG f e . e' Extensions G f r G f e G f e [R-AND] \n[R-OR] G f (.e)i G f (.e)i '' G f r G f rG f r G f r [R-CAT] [R-SUM] '' G f rr G f r + r Queries G f \nq G, G' f ti : ti,i . [1 ...n] G, G' f e G, G' f r [Q-SEL] G f(select t1,...,tn from G' where e)i r G,x:t \nf ai,i . [1 ...n]G,x: t f e G,x:t f r [Q-UPD] G f(update x:t set a1,...,an where e)i r G,x:t f e G,x:t \nf r [Q-DEL] G f(delete x :t where e)i r Figure 6. Rules for Type Checking Queries names to types. As \nthe types of identi.ers are declared inside the query string, the bound query analysis needs only track \nthe types of the values bound to the query parameters. Thus, we focus our attention on parameter type \nenvironments G, which map parameter names to types, not identi.ers. We use P to denote the set of parameter \nnames, T the set of types, and TE = P -T the set of all parameter type environments. We let Q be the \nset of queries. A bound query is a pair (q, G) where q . Q and G . TE. A bound query represents a query \nwhere some of the parameters have been set. We denote by BQ = Q \u00d7 TE the set of all bound queries. Our \nanalysis will map each variable in the program to a set of bound queries. If we denote by V the set of \nJava variables, then the domain D =(D, ., ., T, U, n) of our analysis is de.ned as:1 D \u00a3 V . 2BQ . is \nde.ned by a . b \u00a3 .x.a(x) . b(x)  . \u00a3 .x.\u00d8 and T \u00a3 .x.BQ  U is de.ned by (a U b)(x) \u00a3 a(x) . b(x) \n n is de.ned by (a n b)(x) \u00a3 a(x) n b(x)  Flow Function. We use F : Stmt \u00d7 D . D to denote the .ow function \nof our analysis, where Stmt represents the set of program statements. We now describe some representa\u00adtive \ncases of F . Given a map m, we denote by m[a . b] the map where a has been made to map to b. F (v = CreateQueryk(s), \nin)= in[v .{(qk, \u00d8)}] where qk is the (extended) query computed by the string analysis for creation site \nk. F (v.SetParam(p, x), in)= in[v . h(in(v))] where h(R)= {(q, G[p . typeof (x)] | (q, G) . R}and typeof \n(x) is the type of the Java variable x. For conditionals, the information coming into the condi\u00adtional \nis propagated to both the true and the false successors. At merge points, the information from the two \nsides of the merge is joined using the lattice join operator U. Checking. Now, consider a statement y.getSingleResult(), \nand let bq be the .nal infor\u00admation computed by the above data.ow analysis right before the getSingleResult \nstatement. Then we say that the given getSingleResult is param-type-correct iff the following condition \nholds: .(q, G) . bq(y) . G f q This condition states that for each bound query that .ows to the getSingleResult \nstatement, all the parameters of the query have been set using correct types. Note that this check will \ncatch type errors due to improper comparisons and assignments and also errors due to parameters not being \nset.  3.3 Return Analysis For clarity of exposition, we assume that the only way to execute a query \nis via a call to getSingleResult which re\u00ad 1 Throughout the paper we use the abstract interpretation \nconvention that . represents no behaviors of the program and T represents all possible behaviors. Thus, \n. is the most optimistic information, and T is the most conservative information. turns a single object. \nOur algorithms can be easily extended to handle methods like getResultList which return lists of objects, \nand our implementation handles these cases. As all objects returned from JPA queries pass through a single \nAPI, namely getSingleResult, the type of these objects is the most general Java type possible, namely \nObject. Conse\u00adquently, to access speci.c .elds of objects returned from the database, the programmer \nmust downcast to a more speci.c type. The goal of our return analysis is to guarantee that such downcasts, \nwhich are performed on values originating from a JPA query, will not fail at runtime, or dually, pointing \nout at compile-time, the downcasts that may fail. Domain. The algorithm PropagateTypes for checking re\u00adturn \ntypes, shown in Figure 7, computes at each program point a map that stores for each variable x the set \nof types that x may contain which could have originated from queries. Thus domain D of the analysis is \nD =(D, , ., T, U, n) where D \u00a3 V . 2T , . \u00a3 .x.\u00d8, T \u00a3 .x.T , and , U, n are de.ned as in Section 3.2. \nAlgorithm PropagateTypes. The algorithm maintains a global worklist of methods to be analyzed, and a \nglobal map GF from .eld names to the set of types stored in those .elds. As this map is global, .elds \nare treated in a .ow insensitive manner. We also store in the maps Sumin and Sumout an input and output \nsummary for each method. For simplicity of exposition, we assume that methods only take one param\u00adeter. \nThe input summary of a method is the set of types that .ow into its parameter, and the return summary \nis the set of types that the method returns. Below the declaration of globals in Figure 7, we de.ne a \nsimple construct that will help describe our algorithm. For a map s, we de.ne [s(i) := s(i) . v if changed \nadd m] to perform two tasks: .rst, it performs the update s(i) := s(i) . v; second it adds m to the global \nworklist of methods if the update to s(i) has changed the value of s(i). The algorithm PropagateTypes \nstarts by initializing worklist with the set of methods that contain calls to getSingleResult, after \nwhich it processes method from the worklist. In particular, while the worklist is not empty, PropagateTypes \nremoves a method from the worklist and calls FixPoint(F , m.cfg, Sumin (m)). The FixPoint proce\u00addure \n(not shown here) uses standard techniques to compute the intraprocedural data.ow-analysis .xpoint of \nthe .ow function F : Stmt \u00d7 D . D. In particular, FixPoint starts with . at every program point, and \nthen iteratively calls F until a .xed point is reached. Once the intraprocedural .x\u00adpoint has been computed, \nPropagateTypes uses ret info to extract from the .xpoint d the set of types computed for the return value \nof the method. This set, which is stored in r, is merged into the output summary of the current method, \nand if the output summary changes, then the method s callers callers(m) are added to the worklist using \nthe if changed add construct. Globals worklist :2M (worklist of methods) GF : Field . 2T (map from .elds \nto sets of types) Sumin : M . 2T (method input summaries) Sumout : M . 2T (method return summaries) \nNotation For map s, de.ne [s(i) := s(i) . v if changed add m] as: let n := s(i) . v if s(i) = n then \ns(i) := n worklist.Add(m) Procedure PropagateTypes() worklist := new empty worklist of methods for each \nm that contains a call to getSingleResult do worklist.Add(m) while worklist not empty do let m := worklist.Remove \nlet d := FixPoint(F , m.cfg, Sumin (m)) let r := ret info(d) Sumout (m) := Sumout (m) . r if changed \nadd callers(m) Flow Function F (x = y, in)= in[x . in(y)] F (x = y.getSingleResult(*), in)= in[x .{tq \n| (q, G) . bq(y)}] where tq is the return type of query q, and bq is the computed information for the \nincoming program point by the bound query analysis from Section 3.2. F (x =(t )y, in)= '' if .t . in(y) \n. \u00act<: t then raise Warning: JPA downcast may fail return in F (x = *.f, in)= in[x . GF (f)] F (*.f \n= y, in)= GF (f) := GF (f) . in(y) if changed add readers(f) return in F (x = y.m(a), in) Sumin (m) \n:= Sumin (m) . in(a) if changed add m return in[x . Sumout (m)] Figure 7. Propagating getSingleResult \nReturn Types Flow Functions. The cases for the .ow function F : Stmt \u00d7 D . D are shown at the bottom \nof Figure 7. For a sim\u00ad ple assignment x = y, the .ow function maps x to the set of types that y is mapped \nto. For a statement x = y.getSingleResulti(*), the .ow function maps x to the set of all types that could \nbe returned by the query. The .ow function for a type cast makes sure that the type cast is cor\u00adrect, \nand if not displays a warning. For a .eld read x = *.f, the .ow function maps x to what the current .ow-insensitive \ninformation is for the .eld f. For a .eld write *.f = y, the .ow-insensitive information for f is updated, \nand if this in\u00adformation changes for f then all the methods that read f readers(f) are added to the \nworklist. Finally, for a method call x = y.m(a), the input summary for method m is up\u00addated with the \nset of types that a contains, and if m s input summary changes, then m is added to the worklist (using \nthe if changed add construct). The .ow function also maps x to the current output summary of m (note \nthat this out\u00adput summary may not account for the new information that is coming into m, but if the new \nincoming information to m causes the analysis of m to change m s output summary, then m s callers, including \nthe current method, will be re\u00adanalyzed). 4. Deep Refactoring The goal of our refactoring algorithm is \nto automatically identify all the places in a JPA application that need to be updated if a class or .eld \nis renamed. Java references to the renamed entities can easily be handled using Eclipse s built\u00adin refactorings \nfor renaming a class or a .eld. The dif.culty lies in updating raw strings that represent JPA queries \nor fragments of queries which are concatenated together by the Java code, due to the lack of a context \nwithin which to understand the query. While building an extended query, QUAIL tags each query fragment \nwith an identi.er that uniquely determines the Java string literal that the fragment originated from. \nOnce an extended query is constructed, QUAIL refactors the entire query, which makes it is easy to understand \nidenti.ers and their types. Finally, QUAIL propagates the changes back to the Java code using the tags. \nWe now describe how we refactor an extended query q. Once the query is refactored, propagating changes \nback to the Java strings using the tags is straightforward. QUAIL currently handles two refactoring tasks \n class-and .eld\u00adrenamining. Algorithm RF(G, ., q). Our refactoring algorithm, shown in Figure 8, takes \nthree parameters: G, a type environment, which for the top-level call to RF is empty,  ., a refactoring \nspeci.cation, which is either a class renaming, written C . C ', or a .eld renaming, written C.f . C.f \n', and  q, an extended query.  Refactoring Function RF(G,C . C ' ,q)= q[C ' /C] RF(G, ., c)= c RF(G, \n., ?p)=?p RF(G, .,x)= x ' RF(G, C.f . C.f , lv.f '')= '' '''' if f = f and G f lv : C and C<:C ' '' \nthen lv.f else lv.f RF(G, .,tM t ')= RF(G, .,t) M RF(G, .,t ') RF(G, .,e . e ')= RF(G, .,e) . RF(G, .,e \n') RF(G, .,e . e ')= RF(G, .,e) . RF(G, .,e ') RF(G, ., lv:=t)= RF(G, ., lv):=RF(G, .,t) RF(G, ., (.e)i)= \n(.RF(G, .,e))i RF(G, ., (.e)i)= (.RF(G, .,e))i RF(G, .,r + r ')= RF(G, .,r)+ RF(G, .,r ') RF(G, .,r r \n')= RF(G, .,r) RF(G, .,r ') RF(G, ., (select t1,...,tn from G' where e)i r)= let G'' := G, G' let t ' \n1,...,t ' := RF(G'' , .,t1),..., RF(G'' , .,tn) n ' let e := RF(G'' , .,e) ' let r := RF(G'' , .,r) \n(select t ' 1,...,t ' from G' where e ' )i r n RF(G, ., (update x:t set a1,...,an where e)i r)= let \nG' := G,x:t '' let a1,...,a := RF(G' , .,a1),..., RF(G' , .,an) n ' let e := RF(G' , .,e) ' let r := \nRF(G' , .,r) '' ' (update x: t set a1,...,a where e ' )i r n RF(G, ., (delete x:t where e)i r)= let G' \n:= G,x:t ' let e := RF(G' , .,e) ' let r := RF(G' , .,r) ' (delete x: t where e ' )i r Figure 8. Refactoring \nGiven these three parameters, the RF function returns a refactored version of q as follows. Class-Renaming. \nThe .rst case in the de.nition of RF han\u00addles the class-rename refactoring C . C '. In this case RF simply \nreplaces all occurrences of the class name C with the new class name C '. We use the notation q[C ' /C] \nto repre\u00adsent q with class C replaced with C '. This substitution is syntactic and is performed by traversing \nthe abstract syntax tree (AST) of the query, and replacing each node in the AST that represents class \nC with C ' . Field-Renaming. The remaining cases in the de.nition of RF handle the .eld-rename refactoring \nC.f . C.f '. For this refactoring, RF performs a traversal of the query s AST, maintaining in G the set \nof accumulated bindings from the base query s type declarations. Using these bindings, the .fth case \nin the de.nition of RF renames a .eld access lv.f ' to lv.f if lv s type is a subtype of C. Loops. Whereas \nthe QUAIL typechecker fails to typecheck query strings that are created using a loop, a simple insight \nallows QUAIL to handle such query strings in the context of refactoring: for the purposes of refactoring, \nQUAIL simply needs to statically identify all query fragments, and this can be done by simply assuming \nthat the loop body creating the query executes once or zero times. This approach is guaranteed to refactor \nquery fragments correctly if there are no type errors to begin with. 5. Evaluation To evaluate our deep \ntypechecking and deep refactoring al\u00adgorithms, we implemented these algorithms in an Eclipse plugin called \nQUAIL. For bound query analysis and return analysis, we use Eclipse s libraries to walk over the Java \nin\u00adstructions. For the type analysis of queries, we built our own JPA query parser and type checker. \nThe type checker uses Eclipse s libraries to identify the types of lvalues (for exam\u00adple w.website and \nw.link in Figure 2). In total, QUAIL consists of 5700 lines of Java code. Our goal is to evaluate QUAIL \nalong two dimensions: Precision of deep typechecking. Can QUAIL prove a large fraction of query executions \ntype safe?  Utility of deep refactoring. Can QUAIL help program\u00admers perform refactorings that cross-cut \nJava and JPA?  To answer these questions, we ran QUAIL on several benchmarks, which are listed in Table \n1. These benchmarks were executed on a 2.6 GHz Core2DuoTM machine with 4GB of RAM running Ubuntu 7.10, \nEclipse 3.3, and Sun JDK 1.6. Table 1 shows for each benchmark the number of lines of Java code, the \nnumber of calls to CreateQuery, the number of calls to SetParam, and the number of sites that execute \nqueries. This last number is further split into the number of calls to getSingleResult, getResultList, \nand executeUpdate. The executeUpdate procedure is a query execution statement used for updates and delete \nqueries. The largest of our benchmarks is Roller, a web blogging software system that comprises 82,907 \nlines of code. Named queries, a feature of JPA that allows queries to be named in the object-relational \nmodel and then invoked later by name, are currently handled by inlining the query string at the query \nexecution site. However, we believe it would be straightforward to extend QUAIL to handle these directly \nin the object-relational mapping. Deep typechecking. Table 2 shows the results of deep type checking \non our benchmarks. For each benchmark, we count the number of query execution statements that pass each \nof the following QUAIL checks: param: parameters passed to the executed query using SetParam are of \nthe correct type.  completeness: parameters are set on all paths leading to the query execution statement. \n result: typecasts on objects originating from the query execution statement will not fail at runtime. \n The total column refers to the total number of query execution statements that were considered. For \nresult check\u00ading, the total is smaller than for param and complete\u00adness because result checking does \nnot check calls to executeUpdate (which does not return any objects from the database). The time column, \nwhich lists the number of seconds to perform typechecking on each benchmark, demonstrates the scalability \nof deep typechecking. The results show that overall QUAIL succeeds in 84% of the checks that it performs. \nThe correctness of 84% of the execution sites follows from the soundness of QUAIL. To increase our con.dence, \nwe manually examined all 84% to make sure that they are indeed type correct. Furthermore, although the \nbenchmarks presented do not contain query type errors, our regression test suite includes an array of \nerroneous queries which we check for failure. The query execution sites that QUAIL cannot analyze in\u00advolve \neither construction of the query string by iterating over heap-based data structures or re.ection to \nobtain the name of an object s class at run time. Our data.ow anal\u00adysis cannot currently handle such \ncases, but we believe that with some extra precision, QUAIL could be extended to deal with these programming \npatterns. Furthermore, al\u00adthough QUAIL s analysis is neither path sensitive nor inter\u00adprocedural, neither \nof these would increase precision across the 100,000 lines of deployed Java code in our benchmarks. That \nis, neither of these would eliminate any of the false positives. Furthermore, while imprecise aliasing \ninformation can lead to imprecision for any static analysis, we have found that in these benchmarks there \nare unique, method-local ref\u00aderences to query objects, and so a precise alias analysis is not required. \n Benchmark LOC CreateQuery SetParam Number of query execution sites Single + List + Update = Total CaveatEmptor \n3,369 6 5 1 + 5 + 0 = 6 PetStore 5,435 15 20 0 + 15 + 0 = 15 Planet 14,525 14 9 4 + 10 + 0 = 14 Roller \n82,907 128 165 19 + 65 + 17 = 101 Total 106,236 163 199 24 + 95 + 17 = 136 Table 1. Benchmark statistics \nBenchmark Kind of check # pass # fail Total Time (seconds) param 3 (50%) 3 (50%) 6 (100%) CaveatEmptor \ncompleteness 3 (50%) 3 (50%) 6 (100%) 2.8 result 3 (50%) 3 (50%) 6 (100%) param 11 (73%) 4 (27%) 15 (100%) \nPetStore completeness 11 (73%) 4 (27%) 15 (100%) 5.7 result 10 (67%) 5 (33%) 15 (100%) param 11 (79%) \n3 (21%) 14 (100%) Planet completeness 11 (79%) 3 (21%) 14 (100%) 6.1 result 12 (86%) 2 (14%) 14 (100%) \nparam 89 (88%) 12 (12%) 101 (100%) Roller completeness 89 (88%) 12 (12%) 101 (100%) 26.5 result 74 (88%) \n10 (12%) 84 (100%) Total 327 (84%) 64 (16%) 391 (100%) 41.1 Table 2. Number of checks that succeed in \ndeep type checking Deep refactoring. To evaluate QUAIL s utility for per\u00adforming deep refactoring, we \nperformed a variety of deep refactoring tasks using QUAIL. Table 3 summarizes the re\u00adsults of doing these \ntasks. We picked those refactorings of .elds/classes that occurred most often in query strings and query \nstring fragments. Our refactoring is implemented within the Eclipse refactoring framework, which makes \nsure that the appropriate preconditions are satis.ed before per\u00adforming any .eld/class rename refactoring. \nAll the results in Table 3 are for the part of the refactoring that deals with query strings refactoring \nreferences in Java is handled by Eclipse s refactorings, and we do not provide statistics for this part \nof the refactoring. For each refactoring, the column labeled # changes in Table 3 shows the number of \nchanges that QUAIL performed. The column labeled # refacstr shows the number of refac\u00adtorable strings, \nwhich are string literals occurring in the Java code that represent queries or fragments of queries. \nThese are the strings that a programmer using existing tools would have to consider to perform the refactoring. \nNote that in some cases, the number of changes is larger than the num\u00adber of refactorable strings, because \nthere can be multiple changes per string. The column labeled # refacloc shows the number of places in \nthe refactorable strings that are refac\u00adtorable: for a class-rename, this is the number of class refer\u00adences \noccurring in refactorable strings; for a .eld-rename, this is the number .eld references occurring in \nrefactorable strings. The # refacloc column is an estimate of number of places in the code that a programmer \nusing existing tools would have to consider to perform the refactoring. Finally, the column labeled # \nwarnings shows the number of lo\u00adcations in the code that QUAIL determined may need refac\u00adtoring, but \nthat QUAIL was not able to refactor because of imprecision in the QUAIL string analysis. These are left \nto the programmer to refactor. As Table 3 shows, the # warn\u00adings column is much smaller than the # refacloc \n, showing that QUAIL drastically reduces the number of places in the code that the programmer needs to \nlook at in order to per\u00adform a refactoring. The time to perform these refactorings is within 5% of the \ncorresponding typechecking time. Comparison with hand-refactoring. Performing refactor\u00adings by hand is \ndif.cult for two reasons. First, since some identi.ers like name are very common, it is not suf.cient \nto simply look at identi.er names when refactoring .eld names one has to also look at the type of the \nreceiver, and doing this inside query fragments is tedious and error prone, be\u00adcause type information \ninside these query strings is not read\u00adily available. This may lead the programmer to incorrectly change \na .eld having the correct name, but on the wrong class. Second, it is often hard to .nd all strings that \nrepresent Benchmark Refactoring performed # changes # refacstr # refacloc # warnings CaveatEmptor Bid \n. Offer Item . Product 4 1 3 3 5 5 0 0 Bid.amount . Bid.amt Item.id . Item.SerialNo 4 2 3 3 7 7 0 0 PetStore \nProduct . Pet Item . PetStoreItem 4 5 11 11 13 13 0 0 Product.productID . Product.id Item.productID . \nItem.id 2 5 11 11 24 24 0 0 Planet Planet . World Subscription . Feed 2 6 23 23 14 14 0 0 Planet.handle \n. Planet.alias Feed.feedURL . Feed.url 3 2 23 23 17 17 0 0 Roller WeblogEntry . Entry User . Blogger \nAutoPing . APing Weblog . Blog 13 20 5 6 262 262 262 262 119 119 119 119 4 4 4 4 WeblogEntry.pubTime \n. WeblogEntry.time 18 262 337 4 User.userName . User.name 7 262 337 4 User.enabled . User.valid 9 262 \n337 4 AutoPing.pingTarget . AutoPing.target 3 262 337 4 Weblog.name . Weblog.blogName 6 262 337 4 Table \n3. Statistics for deep refactoring query fragments, especially when the refactored .eld is a common identi.er \nlike name, for which a grep will .ood the programmer with false positives. This may lead the program\u00admer \nto miss changes that should be made. Neither of these two kinds of errors can be found using the Java \ntype system. QUAIL will not only avoid these errors altogether, but if the programmer for some reason \nchooses to perform JPA query refactoring by hand, the QUAIL type checker would be able to .nd such errors. \nAs anecdotal evidence, a software developer who works with Hibernate [9] in a production environment \nhas de\u00adscribed a problem he faces with a persistent class given the unfortunate name Test. The class \nneeds to be renamed to something more descriptive, but doing so is practically im\u00adpossible due to the \nfrequency with which the string Test occurs in the code-base: .xing occurrences by hand is too time consuming \nand error prone, and a search and replace will result in the incorrect replacement of far too many strings. \nThe developer expressed con.dence that using a tool like QUAIL the decision may be made to perform the \nrefac\u00adtoring. Unit Testing. In a realistic scenario, a programmer who would perform refactorings of query \nstrings by hand would make use of unit tests in order to make sure that the refac\u00adtoring is performed \ncorrectly, and also to identify places that need to be refactored further. However, even such safeguards \ncan easily fail. For example, in the case of Roller, we found that refactoring Weblog.handle causes 15 \nquery strings to be changed, but despite the many unit tests in Roller, only 8 of these queries are covered \nby unit tests. The remaining 7 are slight variations on the ones that are tested. If a program\u00admer inadvertently \nmakes a typo while refactoring one of the 7 queries that are not covered by unit tests, then the typo \nwill not be caught at the unit level, and may even make it into a production system. 6. Related work \nThe research most closely related to our work can be parti\u00adtioned into several categories. Static Analyses \nfor checking multi-lingual software are the most closely related line of work. Of these, we have drawn \ninspiration from [21] which gives a static technique for type\u00adchecking the SQL queries dynamically generated \nby pro\u00adgrams using JDBC [8]. The technique is based on using a string analysis [3] to compute an automaton \noverapproxi\u00admating the set of strings that can be sent as queries, and an algorithm for typechecking \nthe automaton. In contrast to QUAIL, this work focuses on the typechecking the SQL queries against the \ndatabase schema, and unlike QUAIL, ig\u00adnores parameterized queries and return value type checking. Further, \nas JDBC provides lower-level access to the database (in contrast to the higher level Object-Relational \nMap of JPA), the question of deep refactoring does not arise. Further a.eld, there have been several \nrecently proposed static analyses for checking multilingual software. Examples include [7] which presents \na type system and data.ow anal\u00adysis for checking the correctness of the OCaml/C foreign function interface, \nand [19] which presents a system for en\u00adsuring the type safety of programs that combine C and Java. Orthogonal \nPersistence is an approach to integrating pro\u00adgramming languages and databases in a manner that entirely \nsidesteps the need for deep typechecking and refactoring. Here, the entire database is exposed to the \nprogrammer as a collection of objects that can be navigated. Examples include the PJAMA [1] and THOR \n[12] projects. In this tight cou\u00adpling, the string based interface is eliminated and hence one can directly \nuse the language s typechecking and refactoring tools. The drawback with this approach is that it sacri.ces \nthe bulk-access optimizations possible by using SQL. To re\u00adcover some of the bene.ts of these optimizations \n[22] pro\u00adposes the use of abstract interpretation to statically extract SQL queries from the code. It \nremains to be seen whether in practice the query extraction yields systems with compet\u00aditive performance. \nProgramming Languages supporting SQL allow pro\u00adgrammers to ef.ciently interact with the database while \nstay\u00ading within a single programming language. This is achieved by providing syntax to describe queries \nin a manner that permits ef.cient compilation to SQL. Two classical exam\u00adples are the DBPL [18] and Tycoon \n[15] languages. More recently proposals include the functional languages Kleisli [24], and Links [5] \nwhich provides a single uni.ed language for Web-programming. A more backwards-compatible ap\u00adproach are \nspecial extensions to existing languages, like Linq [2] for Cq, and [23] for Java. The most compatible \nap\u00adproach is to embed queries as instances of special classes within Java [4] or C++ [16]. As for orthogonal \npersistence, each of these approaches eliminate the need for deep type\u00adchecking and refactoring. However, \nwe conjecture that adop\u00adtion has been limited by the fact query strings provide a more .exible and readable \nway to harness all of SQL, in contrast to these approaches which only incorporate restricted sub\u00adsets. \nMoreover, there is a large amount of legacy code that would have to be rewritten to bene.t from these \ntechniques. 7. Conclusions and Future Work In this paper we presented QUAIL, a tool for deep type\u00adchecking \nand refactoring Java code that uses query strings to interact with databases, thereby allowing programmers \nto use the ef.cient and .exible string-based interface in a safe manner. Based on our experiences building \nand evalu\u00adating QUAIL, we believe there are several avenues for fu\u00adture work. First, we would like to \nimprove the precision of our technique to eliminate the few false positives where we incorrectly .ag \nsafe query executions as potential errors. For example, we would like to extend QUAIL so that it can \ntypecheck queries with dynamically generated parameters, i.e., where the parameters are created and set \nby iterating over a list or array. Second, we would like to enrich the type system to prove more properties \nstatically. For example, ver\u00adifying that queries which are called with getSingleResult indeed determine \nat most one object. This would require a more precise modelling of the constraints of the database schema, \ne.g. primary keys, to verify that the query returned a unique result. Further, we would like to do some \nbasic se\u00admantic sanity checking on the queries, e.g. that the WHERE clause is not a tautology or contradiction. \nFinally, we would like to extend our techniques to obtain deep versions of other software engineering \ntasks that are standard within a single language. Examples include deep code completion, where the tool \nwould run in an online manner and suggest class and .eld completions for query string fragments, and \ndeep impact analysis, where the tool would alert the programmer to the string fragments that may change \ndue to alterations in the database schema or vice versa. References [1] Malcolm P. Atkinson, Laurent \nDayn`es, Mick J. Jordan, Tony Printezis, and Susan Spence. An orthogonally persistent java. SIGMOD Record, \n25(4):68 75, 1996. [2] Gavin M. Bierman, Erik Meijer, and Mads Torgersen. Lost in translation: formalizing \nproposed extensions to c#. In OOPSLA, pages 479 498, 2007. [3] Aske Simon Christensen, Anders M\u00f8ller, \nand Michael I. Schwartzbach. Precise analysis of string expressions. In SAS, pages 1 18, 2003. [4] William \nR. Cook and Siddhartha Rai. Safe query objects: statically typed objects as remotely executable queries. \nIn ICSE, pages 97 106, 2005. [5] Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web \nprogramming without tiers. In FMCO, LNCS 4709. Springer, 2006. [6] Jacques-Antoine Dub, Rick Sapir, and \nPeter Purich. Oracle application server toplink application developers guide, 10g (9.0.4). Oracle Corporation, \n2003. [7] Michael Furr and Jeffrey S. Foster. Checking type safety of foreign function calls. In PLDI, \npages 62 72, 2005. [8] G. Hamilton and R. Cattell. Jdbc: A java sql api. Sun Microsystems, 1997. [9] \nHibernate reference documentation, may 2005. http: //www.hibernate.org/hib_docs/v3/reference/en/ html. \n[10] Java persistence api faq. http://java.sun.com/javaee/ overview/faq/persistence.jsp. [11] Glass.sh \nimplementation of the java persistence api. https://glassfish.dev.java.net/downloads/ persistence/JavaPersistence.html. \n[12] Barbara Liskov, Atul Adya, Miguel Castro, Mark Day, Sanjay Ghemawat, Robert Gruber, Umesh Maheshwari, \nAndrew C. Myers, and Liuba Shrira. Safe and ef.cient sharing of persistent objects in thor. In SIGMOD \nConference, pages 318 329, 1996. [13] David Maier. Representing database programs as objects. In M. Atkinson, \neditor, Advances in Database Programming Languages, pages 377 386. Springer, 1990. [14] V. Matena and \nM. Hapner. Enterprise java beens speci.cation 1.0. Sun Microsystems, 1998. [15] F. Matthes, G. Schroder, \nand J. Schmidt. Tycoon: A scalable and interoperable persistent system environment. In M. Atkinson, editor, \nFully Integrated Data Environments, LNCS. Springer-Verlag, 1995. [16] Russell A. McClure and Ingolf H. \nKr\u00a8uger. Sql dom: compile time checking of dynamic sql statements. In ICSE, pages 88 96, 2005. [17] C. \nRussell. Java data objects (jdo) speci.cation jsr-12. Sun Microsystems, 2003. [18] Joachim W. Schmidt \nand Florian Matthes. The dbpl project: Advances in modular database programming. Inf. Syst., 19(2):121 \n140, 1994. [19] Gang Tan and Greg Morrisett. Ilea: inter-language analysis across java and c. In OOPSLA, \npages 39 56, 2007. [20] Murali Venkatrao and Michael Pizzo. Sql/cli -a new binding style for sql. SIGMOD \nRecord, 24(4):72 77, 1995. [21] Gary Wassermann, Carl Gould, Zhendong Su, and Premku\u00admar T. Devanbu. \nStatic checking of dynamically generated queries in database applications. ACM Trans. Softw. Eng. Methodol., \n16(4), 2007. [22] Ben Wiedermann and William R. Cook. Extracting queries by static analysis of transparent \npersistence. In POPL, pages 199 210, 2007. [23] Darren Willis, David J. Pearce, and James Noble. Ef.cient \nobject querying for java. In ECOOP, pages 28 49, 2006. [24] Limsoon Wong. Kleisli: a functional query \nsystem. J. Funct. Program., 10(1):19 56, 2000.  \n\t\t\t", "proc_id": "1449764", "abstract": "<p>Large software systems are typically composed of multiple layers, written in different languages and loosely coupled using a string-based interface. For example, in modern web-applications, a server written in Java communicates with a database back-end by passing in query strings. This widely prevalent approach is unsafe as the analyses developed for the individual layers are oblivious to the semantics of the dynamically constructed strings, making it impossible to statically reason about the correctness of the interaction. Further, even simple refactoring in such systems is daunting and error prone as the changes must also be applied to isolated string fragments scattered across the code base.</p> <p>We present techniques for deep typechecking and refactoring for systems that combine Java code with a database back-end using the Java Persistence API [10]. Deep typechecking ensures that the queries that are constructed dynamically are type safe and that the values returned from the queries are used safely by the program. Deep refactoring builds upon typechecking to allow programmers to safely and automatically propagate code refactorings through the query string fragments.</p> <p>Our algorithms are implemented in a tool called QUAIL. We present experiments evaluating the effectiveness of QUAIL on several benchmarks ranging from 3,369 to 82,907 lines of code.We show that QUAIL is able to verify that 84% of query strings in our benchmarks are type safe. Finally, we show that QUAIL reduces the number of places in the code that a programmer must look at in order to perform a refactoring by several orders of magnitude.</p>", "authors": [{"name": "Zachary Tatlock", "author_profile_id": "81392605383", "affiliation": "UC San Diego, San Diego, CA, USA", "person_id": "P1223148", "email_address": "", "orcid_id": ""}, {"name": "Chris Tucker", "author_profile_id": "81330499449", "affiliation": "UC San Diego, San Diego, CA, USA", "person_id": "P1223149", "email_address": "", "orcid_id": ""}, {"name": "David Shuffelton", "author_profile_id": "81330498193", "affiliation": "UC San Diego, San Diego, CA, USA", "person_id": "P1223150", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "UC San Diego, San Diego, CA, USA", "person_id": "P1223151", "email_address": "", "orcid_id": ""}, {"name": "Sorin Lerner", "author_profile_id": "81100399150", "affiliation": "UC San Diego, San Diego, CA, USA", "person_id": "P1223152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449768", "year": "2008", "article_id": "1449768", "conference": "OOPSLA", "title": "Deep typechecking and refactoring", "url": "http://dl.acm.org/citation.cfm?id=1449768"}