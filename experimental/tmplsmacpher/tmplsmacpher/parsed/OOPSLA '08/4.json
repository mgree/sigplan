{"article_publication_date": "10-19-2008", "fulltext": "\n Whiteoak: Introducing Structural Typing into Java Joseph (Yossi) Gil Itay Maman Department of Computer \nScience Technion Israel Institute of Technology Technion City, Haifa 32000, Israel yogi, imaman @cs.technion.ac.il \nAbstract This paper presents WHITEOAK: a JAVA extension that in\u00adtroduces structural type equivalence \nand subtyping into the language. We argue that structural subtyping addresses com\u00admon software design \nproblems, and promotes the devel\u00adopment of loosely coupled modules without compromising type safety. \nWe discuss language design issues, including subtyping in face of self-referencing structural types, \ncompile-time op\u00aderators for computing the new types from existing ones, and the semantics of constructors \nand non-abstract methods in structural types. We describe implementation techniques, in\u00adcluding the compile-time \nand run-time challenges that we faced (in particular, preserving the identity of objects). Mea\u00adsurement \nindicate that the performance of our implementa\u00adtion of structural dispatching is comparable to that \nof the JVM s standard invocation mechanisms. Categories and Subject Descriptors D.3.3 [Software]: Programming \nLanguages General Terms Languages, Performance Keywords Java, Structural Subtyping, Abstraction 1. Introduction \nA restaurant accounting library A purchased from an Ameri\u00adcan vendor expects parameters that conform \nto interface Check, but, the British maker of a large software mod\u00adule B in charge of serving orders \nfrom the kitchen to cus\u00adtomers, chose to produce objects which are instances of class Bill. Now, a Billoffers \nessentially the same set of services demanded by Check. How can components A and B be coerced to work \ntogether without modifying any one of them? Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 08, October 19 23, 2008, Nashville, Tennessee, USA. Copyright \nc . 2008 ACM 978-1-60558-215-3/08/10. . . $5.00. In programming languages which obey nominal typing (sometimes \ncalled nominative typing) rules, such retro.tting is not easy. Nominal typing dictates that two types \nare equiv\u00adalent only if they have the same name. Accordingly, types Check and Bill are nominally unrelated; \none must use techniques such as those offered by the ADAPTER design pattern [14] to make the necessary \nplumbing code. How is retro.tting done in languages such as ML and HASKELL where structural typing is \nthe rule? Recall that structural typing means that two types are the same if they have the same structure. \nAlso, structural subtyping follows from structure.1 Thus, in these languages compatibility can be achieved \nby the observation that Bill is a subtype of Check(or vice versa), or even by using the minimal super\u00adtype \nof the two types. The compatibility is therefore due to the overlap between the set of members of two \ntypes. 1.1 The Case for a Dual Nominal-Structural Typing The failure of nominal typing system in situations \ndemand\u00ading retroactive type abstraction is discussed in depth in the literature [6, 7, 11, 20, 22] making \nthe case for using struc\u00adtural typing in mainstream languages. We argue further that the importance of \nretro.tting even increases with the advent of compile once run everywhere languages such as JAVA, RUBY \nand PHP: The fact that hardware speed and memory constraints are not as sti.ing as they used to be, comple\u00admented \nby the huge body of open source modules accumu\u00adlated in the world wide web, has led to the emergence \nof a new kind of hybrid programs [13] that contain numerous modules, written by many different programmers. \nCrucial to such architectures is the concept of interoperability the ability to integrate modules written \nby independent authors. Dynamic type checking of RUBY and PHP may make inter\u00adoperability in these easier \nit is more dif.cult to achieve this goal while preserving the safety, clarity, and other bene.ts of static \ntyping. To make interoperability possible in a statically typed environment, independent modules must \nagree on the type of exchanged data; and structural subtyping contributes to the ability of reaching \nsuch an agreement. 1 Note that this implication is reversed in nominal type systems: the struc\u00adture of \na type follows (also) from any explicit subtype declarations. Another famous crucial issue in which nominal \ntype sys\u00adtems fail is in interaction with external data, be it persistent (e.g., residing in relational \nor XML databases) or originating from a distributed computing environment (e.g., a query to a web service). \nSuch data is described by its structure, and attaching internal program names to it is dif.cult (or even \nimpossible as it is the case in PASCAL). This is precisely the reason that languages designed for data \ninterchange such as ASN.1 [24] are structurally typed. Dif.culties in implement\u00ading con.icting types \nand class hierarchies is also mentioned in the literature [7] as a failure point of nominal typing sys\u00adtems. \nOn the other hand, it is also acknowledged that structural typing has its limitations, most notably, \naccidental con\u00adformance (discussed, together with some prospective so\u00adlutions by La\u00a8ufer, Baumgartner \nand Russo [20]), and the dif.culty of de.ning recursive types. Other pros of nomi\u00adnal type systems include \n(to use the words of Malayeri and Aldrich [22]): the fact that these systems support the explicit expression \nand enforcement of design intent, simplify dec\u00adlaration of recursive types, and make it possible to produce \nmore comprehensible error messages, etc. These, and the fact that dispatching is less ef.cient in structural \ntype systems may explain the fact that nomi\u00adnal typing is the dominating scheme in (statically typed) \nmainstream languages designed for large projects, including JAVA, C++ and EIFFEL, while at the same time, \nthe commu\u00adnity seeks ways of combining these two typing paradigms so that their respective bene.ts can \nbe used in tandem. The Unity language [22] is a recent example of a language design which combines the \ntwo concepts. The contribution of Unity is in formally showing a language model with a sound and complete \ntype system which combines the two paradigms. However, Unity leaves open issues such as separate compi\u00adlation, \ndynamic loading of classes and multiple inheritance of nominal types (a-la JAVA s/C# s interfaces), and \na host of problems arising in actual language implementation. The re\u00adcent release of SCALA [25] introduced \nstructural typing into the language through the notion of Re.nement of Compound Types. It appears though \nthat the performance of this feature is still poor. In their paper describing the Continuum project [17], \nHarrison Lievens and Walsh also arrive at the conclusion that nominal subtyping makes mainstream object-oriented \nlanguages in.exible. They even go further and claim that the standard dispatching mechanism, where a \nmethod is looked\u00adup in the context of a single receiver object, creates an involuntarily coupling between \nthe client and the structure of the service provider. Prior work on integrating structural typing with \ncon\u00adcrete, non-research languages, includes signatures, a C++ language extension which combines structural \ntyping with the existing nominative features of the languages [6, 7], safe structural types for JAVA \n[20] and the work of B\u00a8 uchi and Weck on Compound Types [11]. More generally, many aspects of the question \nof merging the two paradigms can be thought of as the problem of inter\u00adacting such nominative languages \nwith external, structurally typed data. Work on this dates back to the work of Schmidt on Pascal-R [27] \ngoing through the work of Andrews and Harris [3] in the context of C. (See also surveys in [4, 5]). Another \nrelated work is that of Jorgensen on Lasagne/J [19] who solved the retro.tting problem by means of language \nmechanisms that allow for automatic wrapping, but stays short of structural typing. Also worthy of mention \nhere is the proposal 2 for introduction of closures to JAVA which can be viewed as indicative of the \ndesire to introduce structural typing into the language. 1.2 WHITEOAK and JAVA This paper describes the \ndesign and implementation of WHITEOAK, a system that introduces structural type equiva\u00adlence and structural \nsubtyping into JAVA. This addition relies on a new keyword, struct, used to de.ne structural types whose \nsubtyping relation is determined solely by structure. In a sense, structtypes are similar to JAVA s interfaces, \nand in particular support multiple inheritance , except that subtyping among struct types is, as expected, \nstructural rather than nominal. Thus, the type XYZde.ned by struct XYZ { int x,y,z; } is a subtype of \nXYde.ned by struct XY { int x,y; } and of the unnamed structural type struct { int y,x; } Names of structural \ntype are optional, but once de.ned, they can be used as a shorthand for the full type declaration: The \nfunction de.nition int innerProduct(XY a, XY b) { return a.x * b.x+ a.y * b.y; } would be no different \nif it used the more verbose signature int innerProduct( struct {int x,y;} x, struct {int y,x;} y ) Any \nnominal (class or interface) type that conforms to the protocol of a structural type can be upcast into \nthat structural type: The method innerProduct can thus be applied to any conventional type which has \npublic, non-.nal integer .elds named x and y. A .eld access in the method, e.g., a.x, is mapped to the \n.eld declared by the referenced object runtime type. Thus, .elds declared by a structural type follow \na late binding semantics, just as methods. 2 http://www.javac.info/closures-v04.html We saw that WHITEOAK \nprovides for polymorphic ab\u00adstraction and retro.tting over .elds. The following WHITEOAK function demonstrates \nretro.tting over methods: struct Source { int read(); } void exhaust(Source s) { while (s.read() >= 0) \n; } Function exhaust is applicable to objects of both class Reader(the superclass of classes capable \nof digesting Uni\u00adcode input) and InputStream (the superclass of classes for processing byte-oriented \ninput), despite the fact that the two classes are unrelated. Further, the function call s.read() dispatches \ncorrectly in all cases, even though the dispatch target is not necessarily stored in the same loca\u00adtion \nin the virtual functions table. We saw that unlike interfaces, struct types allow, just like abstract \nclasses, the declaration of .elds. Another sim\u00adilarity to abstract classes is that struct types may de\u00ad.ne \nconcrete method implementations: abstract methods and .elds declared in a structde.ne the requirements \nthat any conforming type must provide, where the concrete methods de.ne default behavior which can be \nspecialized by the con\u00adforming type. Revisiting our opening dilemma, we can say that if Check was declared \nas a struct type rather than an interface type, then a Check variable can receive its value from Billobjects. \nBut, even if this was not the case, the bridging code is simpli.ed by using the most speci.c structural \ntype to which both Checkand Billconform. Unlike classes, struct types have no constructors, al\u00adthough \nthey may pose a constraint on the protocol of the class constructors a feature which naturally admits \nvirtual constructors into the language. Also, unlike classes, .elds cannot be initialized as part of \ntheir de.nition. There are no direct means for de.ning struct liter\u00adals, but anonymous classes provide \na substitute. One can therefore invoke function innerProductwith two ad-hoc types and their values int \nxmas = innerProduct( new Object() { int x= 3, y = 5; int a = 3; }, new Object() { int x= 5, y = 2; } \n); Conversely, we argue that user control over anonymous classes is enhanced with structural types. Two \nmore features should be mentioned at this stage: (i) support for dynamic run-time subtyping tests and \ndown\u00adcasts even against structural types; and (ii) operators for the intersection, commutative-and non-commutative-(i.e., \noverriding) union of structural types. The implementation of WHITEOAK comprises two com\u00adponents: 1. a \nmodi.ed JAVA compiler (based on Sun s JAVA 5 com\u00adpiler). This compiler generates standard bytecode, and \nconforming .class.les, and 2. a small runtime library of functions realizing the dy\u00adnamic dispatching \nsemantics of WHITEOAK.  Unlike many research languages, WHITEOAK s design had to deal with the issue \nof integrating with and supporting existing language features (including genericity, re.ection, annotations, \ndynamic loading of classes, etc.), as well as preserving the semantics of existing, previously compiled \ncode. A primary challenge that WHITEOAK faced was that of an ef.cient realization of the structural typing \naddition on top of the standard Java Virtual Machine [21] (JVM), which is nothing else than a nominally \n(and strongly typed) machine model. In this respect, our work was more dif.cult than that of e.g., Baumgartner \nand Russo classical implementation of signatures in C++, in which both translation to untyped assembly \nand the use of advertised loopholes in the type system of C++ could be used to support structural typing. \n 1.3 Contribution The ideas presented here are realized in the WHITEOAK compiler which is available \nfor download from the follow\u00ading address: http://whiteoak.sourceforge.net. In summary, the main contributions \nof this work are: 1. A statically typed object oriented language that enables the attachment of new, \nover-rideable, behavior to existing objects and the composition of these into Virtual Objects. This goes \nbeyond compositional mechanisms (including inheritance, mixins [2, 8] or traits [26]) which operate solely \non classes. 2. A demonstration that a rather complete structural typing system can be added to a non-toy, \nindustrial strength language, without ignoring issues such as preservation of object identity, static \nand .nal members, visibility, anonymous types, genericity and load-time veri.cation. 3. Implementation \nthat supports late binding for construc\u00adtors (virtual constructors [12]), and .elds despite the in\u00adherent \nlimitation imposed by the run-time system (the JVM).  Outline. The remainder of this paper is organized \nas fol\u00adlows: Section 2 overviews the features of the language, its grammar speci.cation and compares \nit with related work. Section 3 describes WHITEOAK s implementation strategy in terms of compiler modi.cation \nand required run-time sup\u00adport. This section then proceeds to presenting performance data and evaluation. \nWe conclude in Section 4 where we dis\u00adcuss the implications of structural typing on the style of pro\u00adgramming, \nre.ect on this work s position within the scheme of current research effort and outline directions for \nfuture work. 2. The WHITEOAK Language Backward compatibility, ef.ciency, simplicity, uniformity and expressive \npower where principal guidelines in the de\u00adsign of WHITEOAK. This section describes the main lan\u00adguage \ndesign alternatives encountered, explains the deci\u00adsions we took in light of these causes, and elaborates \non the challenges that these decisions entailed. The section con\u00adcludes with a detailed comparison of \nWHITEOAK s realiza\u00adtion of structural types within a nominative type system with previous efforts of \nthis sort. 2.1 De.nition of Structural Types A structural type can be used anywhere a nominal type can \nbe used, including variable-, parameter-, return type-, and .eld-de.nition just as in constraints on \ntype parameters to generics. Structural types cannot be used in the throw\u00adlist of exceptions, since all \nexceptions must inherit from the nominal library type Throwable. We also stayed short of allowing generic \nstructural types. A structural type may be de.ned in place, or refer to a named structural type de.nition. \nSuch named de.nitions may be made in any location a non-anonymous JAVA class can be de.ned, including \nthe outer package scope, in a class, or in a function. Which member kinds are allowed in structural types? \nFigure 2.1 demonstrates WHITEOAK s answer. 1 struct ErrorItem { 2 // bodiless method: 3 int severity(); \n4 // a .eld: 5 String description; 6 // a requirement on a .eld (read-only access) 7 final int lineNumber; \n8 // a method with default implementation 9 String where() { 10 return lineNumber + \": \" 11 + description; \n12 } 13 // constraints on constructors: 14 constructor(int l); 15 constructor(String d, int l); 16 } \nFigure 2.1: Structural type ErrorItem demonstrating the variety of member kinds allowed in WHITEOAK In \nthe .gure we see that structtypes may have bodiless functions, data members which may even be final, \nfunc\u00adtions with body, and constructor speci.cation. WHITEOAK does not allow static members3, initialized \ndata mem\u00adbers, or constructors with a body. Bodiless (abstract) methods, representing a constraint on \nthe actual type, are obviously essential. Data members were added for uniformity and in support of interaction \nwith external databases; The mechanisms for supporting these are no different than those required for \nbodiless functions. Constructor constraints were added, again for uniformity, but also in support of \nvirtual constructors and more ex\u00adpressive generics. For example, with the above de.nition of ErrorItem, \none may write ErrorItem bump(ErrorItem e, int diff) { return e.constructor( e.description, e.lineNumber \n+ diff ); } Again, constructor speci.cations are implemented as bodi\u00adless functions. Virtual Objects \nallow client code to obtain an object ref\u00aderence that offers a different set of methods than the actual \n(referenced) object. This is achieved by assigning an object into a variable of structural type S, where \nS de.nes non\u00adabstract methods. Each such method provides a default im\u00adplementation that will be invoked \nif the actual object does not provide its own implementation for that method. This is demonstrated by \nFigure 2.2. 1 struct LineReader { 2 int read() throws Exception; 3 String readLine() throws Exception \n{ 4 String s = \"\"; 5 for (int c = read(); 6 c>= 0 &#38;&#38; c != \\n ; 7 c = read()) 8 s +=(char) c; \n9 return s; 10 } 11 } 13 void f(Reader r) throws Exception { 14 LineReader lr = r; 15 System.out.println(lr.readLine()); \n16 } Figure 2.2: A structural type with a default function imple\u00admentation. In the .gure we see the structural \ntype LineReader. This type requires an int read() method and provides a String readLine() service based \non this method. 3 Still, we shall see that a .eld or method declaration in structcan be realized by a \nstatic.eld or method of a nominal type. Assigning an instance of any class with an appropriate read function \nto a variable whose type is LineReader will effectively attach the implementation of this function to \nthe object, as demonstrated in function f in the .gure: The assignment in Line 14 in this function is \nlegal, since the class Readerdeclares the method int read().4 If function f is invoked with an object \nwhose dynamic type is FileReader (a subclass of Reader that does not offer a readLine() method) then \nthe readLine() call in Line 15 is dynamically bound to the default im\u00adplementation found in LineReader. \nIn contrast, if the function is invoked with an instance of a class such as BufferedReader, which happens \nto implement this function, then Line 15 is bound to the object s own imple\u00admentation. Summarizing this \nprogram we note that the virtual object reference, lr, provides its own static protocol and its own run-time \nbehavior which differ from the ones provided by the referenced object, r. This means that in WHITEOAK \nprotocol and behavior can be associated with references (i.e.: variables) and not just with objects. \nThis provides the means for achieving better localization of concerns: there is no need to de.ne the \nfull behavior of the object at the class de.nition point. If a certain concern is needed only in a certain \npart of the program, we can package the relevant code as a virtual object and use it only when needed. \nOne reservation applies: a structural type in which a cer\u00adtain function is unimplemented cannot be assigned \nfrom a structural type which offers a default implementation for this function. Hence, the following \nfails to compile Reader r = ...; LineReader lr = r; struct { String readLine(); } x; x = lr; // Compilation \nerror! In the assignment x = lr we obtain a new reference, x, from an existing reference lr. Recalling \nthat the implemen\u00adtation of readLine() is associated with the reference lr and not with the actual object \nwe note that there is no as\u00adsurance that the actual object will contain an implementa\u00adtion for readLine(). \nTherefore, the assignment x = lr is ill-typed and is rejected by the compiler. Speci.cally, in an assignment \nfrom a virtual object, non-abstract methods are treated as if they were abstract. Further applications \nof virtual objects are discussed later in Section 2.2 Static members. WHITEOAK does not allow structural \ntypes to de.ne static members. In particular, we cannot make the demand that a function or a .eld is \nimplemented as static. Still, a static member in a nominal type 4 The fact that Reader.read()is an abstract \nmethod is not a prob\u00adlem. The JAVA language semantics forbidding instantiation of abstract classes guarantees \nthat the dynamic type of variable rwill offer a concrete implementation for all its methods. is allowed \nto realize a struct member speci.cation, thus allowing uniform treatment of static and non-static features. \nFor example, an instance of class Ade.ned by class A{ public static void f() {} public static int d; \n } may be assigned to a structrequiring a voidfunction f and an intdata member d: struct { void f(); \nint d; }a= new A(); and a.f() will be bound dynamically to A.f while the member reference a.dwill be \ndynamically delegated to the staticdata member A.d. WHITEOAK also supports recursive structural types \nas demonstrated by Figure 2.3, struct List { int head(); List tail(); } struct MutableList { int head(); \nMutableList tail(); void tail(MutableList t); } struct ReversableMutableList { ReversableMutableList \nreverse(); int head(); ReversableMutableList tail(); void tail(ReversableMutableList t); } Figure 2.3: \nRecursive structural types. MutableList and ReversableMutableList are subtypes of List. ReversableMutableList \nis not a subtype of MutableList. The List type in the .gure is (self) recursive in a co\u00advariant position: \nthe return type of List.tail()is List itself. This allows MutableList to be a structural sub\u00adtype of \nList. Examining MutableList we see that it is (self) recursive in a contra-variant position: the second \ntailmethod, MutableList.tail(MutableList), de.nes a parameter of type MutableList. Recursion in a contra-variant \nposition prohibits subtyping, so the type ReversableMutableList is not a subtype of MutableList. The \nformal criteria for subtyping of re\u00adcursive types are realized in the subtyping algorithm in Al\u00adgorithm \n1. 2.2 Composition This part of the paper examines the composition techniques available in WHITEOAK. \nAs we shall see shortly, the combi\u00adnation of these composition techniques along with the abil\u00adity to \nde.ne virtual objects (that is: structural types with non-abstract methods), allows the WHITEOAK program\u00admer \nto attach units of behavior to existing objects. This allows greater .exibility than traditional, statically-typed, \ncode reuse mechanisms inheritance, mixins and traits which manipulate classes but not objects. WHITEOAK \noffers three type composition operators: If T1 and T2 are structural types, then T1*T2 is the type obtained \nby the intersection of the set of members de.ned in T1 and T2, T1+T2 is the commutative union of these \nsets, and T1 T2 (type T1 concatenated with type T2) is the over\u00adriding union of these sets. If one of \nT1 and T2 is nominal, then it is cast to the corresponding structural type prior to the union. A function \nin T1 con.icts with a function in T2 if both have the same name and the same arguments, but a different \nreturn type.5 Similarly, two data member de.nitions con.ict if they have the same name, but different \ntype, or final speci.cation. Such con.icts are reported as errors. Otherwise, (i) pairs of data members \nof the same name, type and finalspeci.cation, (ii) pairs of constructors with the same signature, and \n(iii) pairs of functions with the same signature, return type, and name, are synonymous, and included \nonly once in the union. Type T1*T2 is obtained by taking an element of each synonymous pair. The following \nreservation applies: a synonymous pair of functions is con.icting if both have an implementation, ex\u00adcept \nfor non-commutative union, in which the implementa\u00adtion in T2 prevails, i.e., much like in overriding \ninheritance.6 The type union operator can be used to enrich an object with additional behavior but can \nstill allow the object to pro\u00advide its own, specialized, implementation for this behavior, e.g., in writing \nstruct Input { int read() throws Exception; int read(char[] a) throws Exception; } struct ImprovedInput \n= Input + LineReader; we de.ne a new structural type whose speci.cation is the union of LineReaderand \nInput. 5 In reality, also thrown exceptions are checked in a similar fashion, but discussion of declared \nexceptions is omitted from this manuscript. 6 In our design, in the case that only one function in the \npair has an implementation, this implementation prevails, even in the union. Other alternatives are legitimate, \njust as more elaborate designs, e.g., computing the least common ancestor of the return type. struct \nMCircle { abstract double radius(); double diameter() { return 2*radius(); } String name() { return \"Circle\";} \n}  struct MRed { Color color() { return Color.RED; } String name() { return \"Red\";} } struct CircleRed \n= MCircle MRed; CircleRed cr = new Object() { double radius() { return 3.0; } }; System.out.println(cr.name()); \n// Output is: Red Figure 2.4: A mixin composition of the Circle, Red classes. The methods of the second \noperand, Red override those of the .rst one. Mixins. Mixin composition also allows classes to be com\u00adposed \nfrom smaller building blocks. A mixin composition is non-commutative, i.e.: the order of the composition \nis im\u00adportant. This order imposes a natural overriding relation on the de.ned methods. In WHITEOAK we \nuse the concatena\u00adtion operator to generate a structural type by applying mixin\u00adcomposition on the two \noperands. This is shown in Fig\u00adure 2.4. The composition MCircle MRed yields a type with just one abstract \nmethod, radius(). Therefore, any con\u00adforming nominal type needs to specify only this method. A call to \nthe diameter() method on the cr variable will dispatch the (only) implementation from MCircle.A cr.name()call \nwill dispatch implementation from MRed, since the methods of the second operand override the meth\u00adods \nof the .rst operand. Traits. Traits were proposed [26] as a mechanism for al\u00adlowing better code reuse. \nA class de.nition can use one or more traits as building blocks that supply part (or even all) of its \nbehavior. Just like WHITEOAK s structural types, traits provide behavior but they cannot carry any state. \nFigure 2.5 shows a standard example for traits using the syntax offered by Hill, Quitslund and Black \n[23]. The .gure compares the JAVA with traits code with the WHITEOAK equivalent. The RedCircle class \nis ex\u00adpressed in WHITEOAK by using the + operator, to com\u00adpose the TCircle and TRed structural types. \nThis com\u00adposition yields a type with two implemented methods,  abstract class TCircle { abstract double \nradius(); double diameter() { return 2*radius(); } } abstract class TRed { Color color() { return Color.RED; \n} } class RedCircle uses TCircle, TRed { double radius() { return 3.0; } } struct TCircle { double radius(); \ndouble diameter() { return 2*radius(); } } struct TRed { Color color() { return Color.RED; } } struct \nRedCircle = TCircle + TRed; RedCircle rc = new Object() { double radius() { return 3.0; } }; Figure \n2.5: A red circle class. The .rst program shows JAVA with traits code. The second program shows WHITEOAK \ncode. diameter() and color(), and one abstract method: radius(). We then assign an instance of an anonymous \nclass, that implements all the abstract methods, into a variable of type RedCircle. The resulting variable \ncan respond to any of those three methods. 2.3 Grammar Figure 2.6 gives a grammatical speci.cation of \nthe four kinds of members allowed in structural types. The produc\u00adtions in the .gure rely on nonterminals \nsuch as Identi.er and FormalParameterList de.ned elsewhere in JAVA s gram\u00admar [16]. Examining the .gure \nwe see that structural types may not be generic (generic recursive structural types are known to be a \ndif.cult and elusive problem; see e.g., Hosoya et al. [18] for an explanation on circumstances in which \nsubtyp\u00ading in this setting might be undecidable, or lead to counter\u00adintuitive results, or require tagging \nbaggage.) Also note that with the exception of finalfor .eld declarations, no mod\u00adi.ers are allowed. \nAll members of a structural type are im\u00adplicitly public, and as discussed below, they can be real\u00adized \nby both staticand non-staticimplementations. Figure 2.7 de.nes how compound structural types are created, \nand how these types combine with the rest of JAVA. The .rst production in the .gure augments JAVA s gram\u00admar \nby stating that a structural type (nonterminal StructType) can be used anywhere a reference type can \nbe used. This includes e.g., arguments to generics, bounds on such argu\u00adments, etc. We then state that \na StructType is speci.ed either as a named structural type, de.ned by a StructDeclaration or as an UnnamedType \nwhich allows a direct use of a structural type expression. Such expressions are composed by applying \nthe three structural type operators, (i) union, speci.ed by operator + (lowest priority), (ii) intersection \n(operator *) and (iii) concatenation, whose semantics is reminiscent of inheritance with overriding (highest \npriority) to combine StructAtoms, i.e., atomic structural types. Named structural types are mostly a \ntyping aid, and the named type are more than shorthand for the entire type declaration; they make it \nis easy to de.ne recursive structural types. Also note that the production StructDeclaration: structStructId \n=StructUnion ; states that names can be also given to structural type expres\u00adsions. Nonterminal StructAtom \nis in turn a ReferenceType. The semantics of this production should be clear if this Refer\u00adenceType happens \nto be a structural type. However, if the reference type is a nominal type, the derivation effectively \ncomputes the structural equivalent of the nominal type, de\u00ad.ned as the set of all public method declarations \nand all public.elds declarations. In computing this set, all modi\u00ad.ers except for finaldata member modi.ers, \nmethod bod- StructBody: { StructMemberopt } StructMember: MethodDeclaration ; | MethodDe.nition | ConstructorDeclaration \n; | FieldDeclaration ; MethodDeclaration: Type Identi.er (FormalParameterListopt ) Throwsopt MethodDe.nition: \nMethodDeclaration MethodBody ConstructorDeclaration: constructor (FormalParameterListopt ) Throwsopt \nFieldDeclaration : finalopt Type Identi.ers Identi.ers: Identi.er | Identi.ers ,Identi.er Figure 2.6: \nGrammar speci.cation of the body of structural types. ReferenceType: \u00b7\u00b7\u00b7 | \u00b7 \u00b7\u00b7 | StructType StructType: \nStructId | UnnamedType StructId: Identi.er StructDeclaration: structStructId StructBody | structStructId \n=StructUnion ; UnnamedType: structStructUnion StructUnion: StructIntersection | StructIntersection +StructUnion \nStructIntersection: StructConcatenation |StructConcatenation *StructIntersection StructConcatenation: \nStructTerm | StructConcatenation StructTerm StructTerm: (StructUnion )| StructAtom StructAtom: ReferenceType \nFigure 2.7: Grammar speci.cation of the uses of structural types ies, initialization expressions of data \nmembers, just as anno\u00adtations are eliminated. 2.4 Type Checking Algorithm This section presents the \nalgorithm used by the WHITEOAK compiler for determining whether one type is a subtype of another. This \nalgorithm is invoked, for example, by the type checker module when it examines assignment statements. \nIn particular, this algorithm is used by the type checker to verify that the type of the right-hand side \nvalue in an assignment is compatible with the type of the left-hand side variable. The algorithm is based \non the algorithm of Amadio and Cardelli [1]. Its actual realization in the WHITEOAK com\u00adpiler is somewhat \nmore complicated due to optimizations. Nonetheless, the semantics (i.e.: the typing rules) is exactly \nthe same as the semantics presented here. The presentation uses the following notations and sym\u00adbols. \n x = y indicates the trivial type equality relation, that is: x and y are the same type. We naturally \nextend this notation for denoting equality of sets of types and of sequences of types.  x . y indicates \nWHITEOAK s type compatibility rela\u00adtion: x is a subtype of y.  As a convention we use the variable r, \nrequired , to denote a candidate supertype (or a member thereof); we use the variable f, found , to denote \na candidate subtype (or a member thereof).  The algorithm for computing x . y is presented below (Algorithm \n1). Following it are auxiliary procedures that are called (either directly or indirectly) from Algorithm \n1. Note that these algorithms are inherently recursive: In order to determine a type compatibility question \nwe need to determine member compatibility questions, which in turn rely on the results of further type \ncompatibility questions. A cache (from a pair of types to a Boolean value) is used to break this otherwise \nin.nite recursion. Function: IsAssignable(f, r) Input: f, r types (either structural or nominal) Output: \nTrue if f . r, False otherwise 1: if f = r then 2: return True 3: if r is a nominal type then 4: return \nIsNominallyAssignable(f, r) 5: if f is a non-anonymous JAVA class then 6: if f s visibility is not public \nthen 7: return False 8: if cache[f, r] is initialized then 9: return cache[f, r] 10: cache[f, r] . True \n11: cache[f, r] . MemberSetTest(f, r) 12: return cache[f, r] Algorithm 1: Testing that f is compatible \nto r, that is: f . r. Function IsNominallyAssignable(f, r) re\u00adalizes JAVA s standard nominal subtyping \ntest. Function MemberSetTest(f, r) checks that every member of r has a compatible member in f. cache[x, \ny] is a cache slot that holds the result of x . y. Initially all cache slots are unini\u00adtialized. Examining \nAlgorithm 1 we see that in step 3 the algo\u00adrithm falls back to Java s standard (nominal) typing scheme \nif the candidate supertype, r, is a nominal type. Steps 5 7 ensure proper visibility of the candidate \nsub\u00adtype. Access to public classes is allowed. Access to other classes is allowed only if they are anonymous. \nThis poses no security risks: During compilation, the only expressions that carry an anonymous-class \ntype are the anonymous-class in\u00adstantiation expressions. Therefore, f will be an anonymous class only \nif the developer deliberately assigns such an in\u00adstantiation expression directly into a structurally-typed \nvari\u00adable. Step 8 breaks the recursion: if the result for the current type-compatibility question is \nalready cached, we return that result. The last part of the algorithm, realizes the actual compu\u00adtation \nof the structural compatibility question. In step 10 we cache a (tentative) True answer for the f . r \nquestion. In step 11 the auxiliary function MemberSetTest() is called. This function will return False \nif, and only if, there is a member of r that has no compatible member in f. Hence, we assign the result \nreturned by this function to the appropriate cache slot and then return this result (step 12). The algorithm \nthat realizes function MemberSetTest() is depicted in Algorithm 2. Function: MemberSetTest(f, r) Input: \nf, r types Output: True if every member of r has a compatible mem\u00ad ber in f. 1: for all mr member of \nr do 2: s . f 3: for all mf member of f do 4: if MemberPairTest(mf ,mr) then 5: s . s .{mf } 6: if s \n= f then 7: return False 8: if s has overloading con.icts then 9: return False 10: return True Algorithm \n2: Testing that every member of r has exactly one compatible member in f. Function MemberPairTest(x, \ny) checks that x can replace y. The algorithm goes over every member of the r ( re\u00adquired ) type, .nds \nthe compatible members from f ( found ), and stores these in the set s (step 5) If no such member was \nfound (step 6) the algorithm returns a False answer. On the other hand, if such members were found the \nalgorithms makes sure (step 8) that there is one member in s which is more specialized than all other \nmembers in s. This check (which is essentially identical to Java s standard check for ambiguity due to \noverloading) ensures that every member of r is unambiguously mapped to a member of f. The details of \nfunction MemberPairTest() are pre\u00adsented in Algorithm 3. The body of Algorithm 3 is straightforward: \nit delegates to one of three other functions, each handling a different set of inputs (a pair of constructors, \na pair of methods, or a pair of .elds). The function for deciding the compatibility of constructors, \nis presented in Algorithm 4. Examining Algorithm 4 we see that steps 2 6 make sure that the candidate \nconstructor, f, can actually be invoked to produce a concrete object. In particular, constructors of \nnon-static inner classes are rejected due to their extra, implicit, parameter. We then require no-variance \nof the parameters (step 7) and covariance or no-variance of the throws clauses (9). Note that the type \ncompatibility decision issued by step 9 is essentially a nominal subtyping test: the candidate super\u00adtype \nis (per the JAVA language speci.cation) a subclass of Throwable which is a nominal type. Therefore it \nis safe to use JAVA s standard test for conformance of throws clauses, ThrowsClauseTest() . One may expect \nAlgorithm 4 algorithm to require co\u00advariance of the objects generated by the two constructors at hand. \nA careful look at Algorithm 1 reveals that this check is Function: MemberPairTest(f, r) Input: f, r members \nOutput: True if f can replace r, False otherwise 1: if f s visibility is not publicthen 2: return False \n3: if both f and r are constructors then 4: return ConstructorCompatibilityTest(f, r) 5: if the names \nof f and r are not identical then 6: return False 7: if both f and r are methods then 8: return MethodCompatibilityTest(f, \nr) 9: if both f and r are .elds then 10: return FieldCompatibilityTest(f, r) 11: return False Algorithm \n3: Testing the compatibility of two members. The three auxiliary functions: ConstructorCompatibilityTest(\u00b7, \n\u00b7) (see Algorithm 4 below), MethodCompatibilityTest(\u00b7, \u00b7) (Algorithm 5) and FieldCompatibilityTest(\u00b7, \n\u00b7) (Algorithm 6) determine the compatibility of a pair of constructors, methods and .elds (respectively). \nFunction: ConstructorCompatibilityTest(f, r) Input: f, r constructors Output: True if f can replace r, \nFalse otherwise 1: tf . f s declaring type 2: if tf is a nominal type then 3: if tf is abstractthen 4: \nreturn False 5: if tf is a non-staticinner class then 6: return False 7: if Params(f) = Params(r) then \n8: return False 9: return ThrowsClauseTest(f, r) Algorithm 4: Testing the compatibility of two construc\u00adtors. \nFunction Params() returns the sequence of the types of the formal parameters of its operand. Function \nThrowsClauseTest() realizes JAVA s standard (nominal) test for conformance of the throwsclauses of its \noperands. redundant: the ConstructorSignatureCompatibility func\u00adtion is (indirectly) called from step \n11 in Algorithm 1. In the preceding step, Algorithm 1 cached a True answer for the question of subtyping \nof the f and r types, which are essen\u00adtially the declaring types of the f and r constructors in Al\u00adgorithm \n4. Thus, if Algorithm 4 will check for co-variance of the objects generated by the constructors it will \nget the inevitable (tentative) True answer from the cache. The algorithm for determining compatibility \nof methods is presented in Algorithm 5. Function: MethodCompatibilityTest(f, r) Input: f, r methods Output: \nTrue if f can replace r, False otherwise 1: if \u00ac(Type(f) . Type(r)) then 2: return False 3: if Params(f)= \nParams(r) then 4: return False 5: return ThrowsClauseTest(f, r) Algorithm 5: Testing the compatibility \nof two meth\u00adods. Function Type() returns the return type of its operand. Function Params() returns the \nsequence of the types of the formal parameters of its operand. Function ThrowsClauseTest() realizes JAVA \ns standard (nominal) test for conformance of the throwsclauses of its operands. Looking at Algorithm \n5 we see that compatibility of methods is established if we have: no-variance or co-variance of the return \ntype (step 1); no-variance of the parameters (step 3); no-variance or co-variance of the exceptions de\u00adclared \nin the throws clauses (step 5). Finally, the compatibility of a pair of .elds is determined by Algorithm \n6. Function: FieldCompatibilityTest(f, r) Input: f, r .elds Output: True if f can replace r, False otherwise \n1: if r is a read-only .eld then 2: return Type(f) . Type(r) 3: if f is a read-only .eld then 4: return \nFalse 5: return Type(f)= Type(r) Algorithm 6: Testing the compatibility of two .elds. Func\u00adtion Type() \nreturns the type of its operand. Examining Algorithm 6 we see that if the required .eld, r, is a read-only \n.eld, it can be matched with either a read-only or a mutable .eld, with a possibly co-variant type (step \n2). On the other hand, if the required .eld is mu\u00adtable, the matched .eld must be mutable (step 3), and \nof the exact same type (step 5). Having presented WHITEOAK s type compatibility algo\u00adrithm we can discuss \na few implications. The .rst point to note is that of constructor calls on a receiver typed with a type \nparameter. Consider a type Ude.ned by struct U{ U constructor(); void m(); } and a nominal type N conforming \nto U. Then, N must have a no-arguments constructor creating an N object. Using such a value in generics \n[9] seems to be legal: static<T extends U> void f(T t) { t = t.constructor(); // Returned value is T? \nt.m(); } One may think that the semantics of a constructor() call in WHITEOAK is that of a self type \n[10]: the returned object has the same dynamic type as the receiver, thus en\u00adsuring that the assignment \nt = t.constructor() is well typed. This assumption is in some sense similar to the special handling of \nthe getClass() calls in the standard JAVA compiler [16, Sec. 4.3.2]. By examining the ConstructorCompatibilityTest() \nfunc\u00adtion one can see that if the function returns a True answer we can only assert that the f constructor \nwill return an ob\u00adject whose type is at least as speci.c as f s declaring type, which in our case is \nthe static type of the receiver. Due to type erasure, the static type of the receiver is U(the erased \ntype of T). Thus, one can only assume that returned object will be as speci.c as U, which, alas, is not \na speci.c enough type to be assigned to the variable t. Another subtle issue is related to the recursive \nnature of the algorithms presented here. These algorithms are recur\u00adsive in the sense that in order to \ncheck that one type is a subtype of another, one needs to check subtyping relation\u00adship of individual \nmethods. Method subtyping is de.ned (as usual in JAVA) by the demand that the return type changes co-variantly, \nand the argument types are the same. The re\u00adcursive call may therefore yield more subtyping problems. \nWe deviate from the usual implementation of [1] in that if, in these generated problems, the candidate \nsupertype is nom\u00adinal, we apply JAVA s nominal type testing algorithm. Also, the subtyping test invariably \nfails if the candidate subtype is structural and the candidate supertype is nominal. Recursion proceeds \nonly if the candidate supertype is structural. This ensures that a method that declares a parameter of \na nominal type can safely assume that the dynamic type of this parameter will be a nominal subtype. Otherwise, \nevery invocation of a method, on a parameter, had to be treated as a structural invocation. Even more \nseriously, the method s code may use re.ection in ways that will break if the dy\u00adnamic type is not a \nnominal subtype (e.g.: a parameter of type Serializableis sent to a serializing data stream).  2.5 Comparison \nwith Related Work Tab. 1 shows a feature based comparison of WHITEOAK with some of the main work on introducing \nstructural typ\u00ading into nominative languages, or for producing synergetic language, including C++ Signatures \n[7], Brew [20], Com\u00adpound [11], Unity [22] and Scala. The .rst section in the table compares the admissible \nmember kinds. We see that WHITEOAK s repertoire of mem\u00adber kinds is fairly complete. Still, unlike WHITEOAK \nand all the other compared languages, only C++ signatures support .eld de.nition, that is, .elds together \nwith a default initial\u00adization expressions. But since the C++ signatures semantics is restricted, the \nproblem of .nding appropriate semantics to default initialization expressions remains open. We know of \nno support in current work of constructor bodies in structural types. The next section compares integration \nwith other lin\u00adguistic mechanisms and composability of structural types through recursion or type operators. \nAs expected, most lan\u00adguages chose to provide support for anonymous types on top of structural types \n(unlike instances of anonymous classes, anonymous types are practically useless in a purely-nominal setting). \nNote that Scala s parametrization of structural types in restricted in the sense that type parameter \ncan only be used in co-variant positions (e.g.: return types). The third section is concerned with implementation. \nOther than WHITEOAK only C++ Signatures provide per\u00adformance data. In Scala, although no such data is \navailable, it is mentioned that it is slow, probably due to heavy reliance on re.ection information. \nTurning to the preservation of object identity we see that C++ signatures implement this (by enhancing \nthe compiler existing mechanism for comparison of this-adjusted refer\u00adences), while Brew, a previous \naddition of structural types to JAVA fails to preserve object identity. Compound also preserves object \nidentity, by relying on a fundamental property of this JAVA language extension, by which structural types \ncan only be de.ned as the union of existing nominal JAVA interfaces. Every structural reference in Compound \nis represented as multiple variables, one for each of what the authors call constituent type . Finally, \nas the last table row indicates, only Compound and Unity enjoy a formalized basis. 3. Implementation \nand Performance This section describes the compilation and run-time tech\u00adniquesthatweusedinordertoaugment \nJAVA with WHITEOAK s additional constructs while preserving these fundamental principles: 1. WHITEOAK \nclasses should run on any standard, JAVA 5 compliant JVM; hence the run-time system must be implemented \nas a JAVA library. 2. Object identities must be preserved; a structural type reference to an object must \nbe the same as a nominal type reference to it. 3. Compilation should be separate without relying on \na whole-world analysis; WHITEOAK compiler cannot con\u00adsult all uses of a given reference type. 4. No \nexecutable blowup; the compiler cannot generate a nominal type system re.ecting the structural hierarchy \nby generating a nominal type for each subset of the set members of all structural types; in fact our \nimplementa\u00adtion generates one interface for each structural type, and optionally an implementing class \nif this reference type includes method implementations.  3.1 The Object Identity Problem In order to \nbetter understand the dif.culty in preserving the identities of objects, let us consider the following \ncode fragment: struct S { Object me() { return this;}} Object o = new Object(); S s = o; assert o == \ns &#38;&#38; o == s.me(); In this fragment we have three object references, o, s and s.me(). Given that \ns is assigned from o and that S.me() returns this, it is only natural to expect the two equalities o \n== s and o == s.me() to hold. Follow\u00ading JAVA s standard semantics, one can also conclude that s == s.me(). \nExamining the standard techniques for adding behavior to existing objects, such as the DECORATOR pattern \n[14], we note they prescribe the use of a wrapper object whose iden\u00adtity is inevitably different than \nthe identity of the wrapped object. Speci.cally, na\u00a8ive wrapper-based techniques stop identities such \nas o ==s and o == s.me() from hold\u00ading. Alternatively, object identity could also have been as\u00adsured \nby overriding the compiler default implementation of reference comparison operation. This seems to be \nthe de\u00adsired alternative in C++, where the frequent use of this\u00adadjustment [15] forces such specialized \ncomparison code even for nominal types. In JAVA however, such an addition is not only foreign to the \nlanguage, but would have come at the cost of breaking previously compiled code. For example, the invariants \nof libraries relying on re.ection may be invali\u00addated even if the wrapper is hidden using a this-adjustment \ntechnique. WHITEOAK s design insists on both binary compatibility and on semantics of object identity \n(in particular the afore\u00admentioned assertions hold in WHITEOAK). This is achieved by a technique which \nmay be called Invisible Wrapper de\u00adscribed below. (Note that the object identity challenge is accentuated \nwith default function implementations: we must be able Signatures [7] Brew [20] Compound [11] Unity \n[22] Scala Whiteoak Kinds of Members Method declaration + + + + + Method de.nition + + + Mutable Field \ndeclaration + + + Readonly Field declaration + + + + Field de.nition + Constructor declaration + Constructor \nde.nition Expressiveness Parametrization + + Bounds on type parameters + + Unnamed types + + + + Type \noperators + + + Recursive types + + + + Impl. Invariance of identity + + + + + Separate compilation + \n+ + + + Performance data + + Formalization + + Table 1. A comparison of recent work on introducing structural \ntyping into nominally typed languages. to attach an implementation to an existing object without changing \nthe object nor the reference to it.)  3.2 Compile Time Representation The WHITEOAK compilerrepresentseverystructuraltype, \nS, as an interface Is. This interface is generated as soon as the parsing of S is complete and therefore \nit serves as the only representation of S during compilation. In other words, from the compiler s point \nof view, the structural type exists only as Is; there is no representation for S per-se. The mapping \nfrom S to Is is straightforward: Each method (either abstract or non-abstract) declared in S is rep\u00adresented \nas an abstract method declaration in Is. If S con\u00adtains at least one method with default behavior, Is \nwill de\u00adclare an abstract, inner, static class, Cs, which implements the interface Is. Each de.nition \nof a non-abstract method in S is translated into a similar de.nition in Cs. Hence, Cs is referred to \nas the Partial Implementation Class of Is. Similarly, a constructor with a certain signature is repre\u00adsented \nas a method named constructor with this signa\u00adture whose return type is Is. A .eld f declared in S is \ntranslated into a static final .eld of the same name and type in Is. Also, a uniquely named getter method \ncorresponding to f is de\u00adclared in Is. If f is a non-.nal .eld, Is also contains a cor\u00adresponding uniquely \nnamed setter method. Finally, The Is interface carries a special annotation that distinguishes Is from \nnormal interfaces (that is: interfaces that are not an artifact of a structural type declaration). Under \nthis translation scheme, Is is a faithful represen\u00adtation of S: all elements of the structural type S \nare rep\u00adresented, without loss of information, as standard JAVA en\u00adtities in Is and its inner class Cs. \nAlso note that Is is the primary representation of S: whenever S is speci.ed in the program as the type \na variable, a return type of a method, or a bound on a type parameter, it is Is that will replace it \nin the compiler s internal representation. The class Cs is merely a vehicle which carries the implementations \nof non-abstract methods from S: there is no way for the programmer to spec\u00adify Cs as a type in the program. \nType Checking. Given that Is and Cs are plain JAVA def\u00adinitions, type checking can largely follow JAVA \ns familiar semantics. In particular, access to a method of a struc\u00adtural type is type-checked in the \nsame manner as access to an interface-declared method. Access to a constructor of a structural type is \nsyntactically identical to a method call (e.g.: x= y.constructor(5)). Consequently, con\u00adstructor calls \nare type-checked like method calls. Finally, a read operation from a .eld of a structural type is handled \nas a read operation from a (staticfinal) interface .eld. The primary changes to the type checker are \nas follows: Assignment to a .eld of a structural type is allowed only if the .eld has a corresponding \nsetter method.  When a type conformance test is in order (e.g.: as\u00adsignments, instantiation of generics) \nWHITEOAK s type checking algorithm (Section 2.4) is used in place of JAVA s nominal subtyping rules. \n 3.2.1 Code Generation and Invisible Wrappers In order to support WHITEOAK constructs the bytecode gen\u00aderator \nhas to deal with three primary issues: assignments into variables, run-time type tests and method invocation. \nAssignments. The structural type Sde.ned by struct Subbable { String substring(int i); } is a supertype \nof the nominal type String, so if sub is a variable of type Subbablethe assignment sub = \"whiteoak\" type \nchecks correctly by the compiler. The JVM veri\u00ad.er [21, Sec. 4.9.1] however will reject the assignment \nif sub is a .eld or a method argument 7 since two the types class String and interface Subbable (repre\u00adsenting \ninternally the structural type) are nominally incom\u00adpatible. The dif.culty is resolved by a technique \nsimilar to the implementation of type erasure of generic classes: variables of structural types take \nthe type Object in their .class representation. The real (structural) type of these is preserved in an \nannotation so the symbol table can still re\u00ad.ect the correct type of de.nitions from separately compiled \nmodules.8 Type tests. Typecasts and runtime subtyping tests [28] ex\u00adecuted at runtime are another dif.culty. \nThe JVM does not acknowledge that Stringis a subtype of Subbable. This is the reason that the WHITEOAK \ncompiler carefully replaces such tests by a call to a library function which executes, at runtime, the \nstructural subtyping algorithm to compare the object s dynamic type with the given structural type. This \nfunction, just as other similar portions of the runtime library makes heavy use of caching. As it turns \nout, typecasts in the JVM are no different than subtyping tests. More dif.cult is the problem of dispatching. \nAgain, the call sub.substring(5) type checks correctly since interface Subbable has a public String substring(int) \nmethod. The emitted code must however dispatch the call to substring(int) from class String despite the \nfact that type Object has no such method (as a direct result of the erasure process de\u00adscribed above, \nthe JVM considers the sub variable to be of type Object). Even if the JVM type of sub was inter\u00adface \nSubbablewhich includes such a method, and even if the assignment of a String to such a variable would \nhave been possible, dispatching would be dif.cult since we have no access to the mechanism by which the \nJVM dispatches in\u00adterface calls to the correct class implementation. (Note that in Section 4 we discuss \nthe relation between WHITEOAK s structural dispatching and the proposed invokedynamic instruction). Dispatching. \nDispatching is realized in our implementa\u00adtion by class Wrapper of WHITEOAK s runtime library. This class \neffectively augments the JVM with an ability to virtual dispatch a method through a structural method \nselec\u00adtor. The factory method public static<I> I make(Object content, 7 Unlike local variables, the veri.er \nis aware of the declared type of .elds and arguments. 8 Incidentally, the JVM s type veri.cation of interfaces \nmakes it possible to avoid using this technique for .elds (but not for method arguments). Class<I> description); \nin this class produces an invisible wrapper around its content argument, through which dispatching is \ncarried out. Method makerequires these two preconditions: The actual type passed to I is some Is interface \nrepre\u00adsenting a structural type S.  For a given Is, the dynamic type of the contentobject is an instance \nof a class D that is structurally conforming to S.  The method s contract guarantees that it will return \nan in\u00adstance of a wrapper class , W, that is a nominal subclass of class Cs corresponding to Is. Given \nthat class Cs always implementsIs (ensured by the way it is built by the com\u00adpiler) we have that W is \na nominal subtype of Is. Moreover, the fact that Wsubclasses Cs elegantly injects into the wrap\u00adper object \nthe default implementation declared by the struc\u00adtural type. The creation of W by make() follows this \npattern: for each method m of Is that has a compatible method m. in the D, class Wde.nes a corresponding \nnon-abstract method with the same signature as m whose body delegates to m. on the contentobject. This \nensures that methods provided by the contentwill override default implementations of methods from S. \nMethod dispatching is realized by .rst creating an invis\u00adible wrapper around the receiver, and then using \na nomi\u00adnal invokeinterfacecall to dispatch the call correctly. More speci.cally, the compiler emits bytecodes \npatterned after the algorithm depicted in Algorithm 7. 1: Load the receiver onto the stack. 2: Load the \nclass literal Is onto the stack. 3: Call Wrapper.make()via invokestatic. 4: Downcast the object at the \ntop of the stack to Is. 5: Load m s parameters onto the stack 6: Call m()via invokeinterface. Algorithm \n7: JVM code to dispatch method m on a receiver of structural type S It is straightforward to check that \nthe downcast at the 4th step always succeeds (since W is a nominal subtype of Is). This ensures that \nthe invokeinterface instruction at the 6th step of the algorithm veri.es correctly, since the receiver \nimplementsIs. A concrete bytecode-level incar\u00adnation of this pattern is shown in Figure 3.1. In the .gure, \neach of the instruction (1)-(6) represents the corresponding step from Algorithm 7. Note that the in\u00advoked \nmethod takes only one parameter of type intso that step 5 becomes a single bipushinstruction. Also note \nthat steps (1), (5), (6) and (7) are the same as any virtual function call, and that the invisible wrapper, \ngenerated at step (3)vanishes when the call is .nished. (1) aload_1 // Load variable sub (2) ldc_w #3 \n// class Subbable (3) invokestatic #4 // Method Wrapper.make(Object,Class) (4) checkcast #3 // class \nSubbable  (5) bipush 5 // Push the constant 5 (6) invokeinterface #5 // Method Subbable.substring(int) \n(7) pop // Returned value is ignored Figure 3.1: The bytecodes generated for the invoca\u00adtion sub.substring(5), \nwhere sub is a variable of a structural type Subbable that declares the method String substring(int). \nThe WHITEOAK compiler generates the aforementioned sequence of instructions only when it generates the \ncode for an invocation of a method on a receiver of a (static) structural type. Assignments to such variables \nare allowed only if the static type of assigned value is structurally conforming to the type of the variable. \nThis guarantees that in each compiler\u00adgenerated invocation of Wrapper.make() the precondi\u00adtions required \nby the method are met. We further argue that class W is always a concrete class: If the content object \ndoes not provide a suitable imple\u00admentation for m and m is non abstract in S, then class Cs will have \na concrete m method (again, this is ensured by its building process). class W will inherit this implementation \nfrom its superclass Cs. In the dual case D does not provide a suitable imple\u00admentation for m and m is \nabstract in S we have that in all the nominal supertypes of D (including D itself) there is no declaration \nof a method m, not even an abstract declaration. If there were such an abstract declaration then D were \nan abstract class which cannot, by de.nition, be the dynamic type of an object. Given that no de.nition \nfor m exists in the hierarchy above D we have that D is not struc\u00adturally conforming to S (see Section \n2.4) in contradiction to the precondition of the make()method. The fact that W is a concrete class guarantees \nthe fol\u00adlowing: (i) Wrapper.make() will be able to create an instance of W; (ii) the method invocation \nin the 6th step of Algorithm 7 will succeed. Constructors and Fields. Dispatching to constructors is \nno different than methods. A call to a constructor() method on a structurally typed receiver is handled \nby a corresponding constructor()method in class Wwhose body carries out the standard bytecode sequence \nfor creating a new object of type S. Access to .elds of a structural type is made possible by invocation \nof the appropriate getter or setter method intro\u00adduced by the compiler into Is. In the wrapper class \nWthe im\u00adplementation of such methods uses either a GETFIELDor a PUTFIELD) instruction to carry out the \nactual operation on the .eld of the contentobject. thisReferences. In a structural type that de.nes only \nab\u00adstract methods, the identity of the wrapper object is never leaked to the actual program code: the \nmethods of the wrap\u00adper object merely delegate to the methods of the content object without exposing \nthe thisreference. Things are more complicated when considering methods with default implementations. \nWhen such a method gets executed (that is: the content object does not provide a suitable implementation), \nthe actual program code runs in the context of the wrapper object thereby exposing the identity of the \nwrapper. To solve this dif.culty, the compilation of methods with default implementations into the partial \nimplementation class, Cs, is altered so that each this reference is re\u00adplaced by a reference to the wrapped \nobject. To achieve this, the partial implementation class de.nes an abstract func\u00adtion getReceiver() \nwhose return type is Is. In meth\u00adods of a partial implementation class, the code generator inserts a \ngetReceiver() call immediately after every load this instruction (bytecode: aload_0). The net effect \nis two fold: First, the reference to the wrapper object is replaced by a reference to the wrapped content, \nthus maintaining the transparency of the identity of the wrapper object. Second, in self calls, such \nas m1 invoking m2, the static type of the receiver becomes Is (since getReceiver() returns Is) so the \ncompiler will treat the call as a structural invocation thereby ensuring correct dispatching semantics \nof self calls. We note that this process however does not need to gener\u00adate a new delegating class, since \nboth the dynamic nominal type and the structural static description are the same as in the context which \ngenerated the wrapper object.  3.3 Performance The implementation approach described above realizes \nstruc\u00adtural dispatching by these steps: (i) creation of an invisible wrapper and (ii) using the JVM s \nnative invokeinterface instruction to dispatch to a delegator and (iii) delegation to the actual implementation. \nAs it turn out, the .rst such step is the most time-intensive. This step involves two operations which \nare notoriously slow: the examination of a re.ection object, and the creation, at runtime, of a new class. \nIn fact, in an early implementation of WHITEOAK we found that dispatching based on re.ection information \nwas at least three order of magnitude slower than native dispatching. The current WHITEOAK implementation \nachieves good performance by relying on two levels of caching inside the factory method make: First, \na .xed size cache containing 8 entries and implemented with no looping instructions is used to check \nwhether an invisible wrapper was previously created for the speci.ed value of the receiver and the static \nFigure 3.2: Execution time of a program vs. # number of method invocations. (structural) type of the \nreceiver. If the pair is not found in this cache, a hash table containing all previously returned wrappers \nis examined. In both caches the searching strategy is similar: we .rst check whether an exact match is \nfound, that is, match in both receiver value and in the receiver s (structural) type. If this fails, \nthe dynamic type of the receiver is fetched, and the cache is examined again to see whether a wrapper \nclass appropriate for the receiver s dynamic type and the receiver s static type exists already and can \nbe instantiated to create the invisible wrapper. In addition, within any single thread the cache may \neven recycle wrappers by changing their contained wrapped ob\u00adjects. Such recycling is restricted to plain \nstructural types though. Figure 3.2 compares the timings of runs of a reference program in WHITEOAK with \nthat of the JAVA equivalent using runtime interface dispatch. (Experiments were con\u00adducted on a single \nprocessor Pentium-4 3GB RAM, 3GHz, Windows XP machine.) The curve marked Interface refers to the plain \nJAVA run. The Hit-1 curve describes the WHITEOAK timing when the program mostly hits the primary cache. \nThe curve marked Hit-2 corresponds to the situation where structural dispatching mostly hits the secondary \ncache, while the Hit\u00ad1/2 curve denotes an intermediate situation. As expected, the curves are linear \nat large, indicating that the invocation time is constant. Hits on the primary cache incur a slowdown \nof a factor of about two in comparison to the reference invokeinterface implementation. Note that we \ncannot hope for more; the dispatching algorithm described above, even if caching requires no resources, \nre\u00adplaces each structural dispatch with one interface dispatch and two ordinary class based dispatches. \nThe hit-1/2 sce\u00adnario is more than three times slower where the hit-2 sce\u00adnario is about seven times \nslower. The experiment depicted in this .gure represents an unre\u00adalistic situation where the program \nspends an overwhelming majority of its time invoking an empty method. A more real\u00adistic program is likely \nto take additional computation which will mitigate the in.uence of dispatching on the overall exe\u00adcution \ntime. To evaluate performance under these circumstances we took two standard benchmarks, JESS and JAVALEX9 \nfrom the famous SpecJVM98 suite and changed them such that every interfacewas replaced by a corresponding \nstruct. Of course, this change meant that implements clauses were eliminated from all classes. The JESS \nprogram is a rule-based inference system. The JAVALEX benchmark measures the time needed for a JAVA compiler \nto compile a 60,000 lines program. In the orig\u00adinal benchmark, the compiler whose compilation time is \nmeasured is one of the early versions of Sun s JAVA com\u00adpiler. We changed the benchmark to measure the \ncompila\u00adtion time of Sun s JAVA 5 compiler against that of the boot\u00adstrapped WHITEOAK compiler (The bootstrapped \nversion uses structs instead of interfaces). The use of inter\u00adfaces in the remaining SpecJVM benchmark \nprograms was minimal, so applying this techniques in these did not yield useful data. In both benchmarks \nthe performance of the WHITEOAK program was less than 5% slower than JAVA program. Speci.cally, In JESS \nWHITEOAK time was 1.95 seconds while the JAVA time was 1.89 seconds, while in JAVALEX the respective \ntimes were 3.9 and 3.75 seconds; Finally, we compared WHITEOAK s structural dispatch\u00ading implementation \nwith that of SCALA, in the simple case of repeatedly invoking a method on a single receiver. The slowdown \nin SCALA was more than two orders of a mag\u00adnitude, compared to less than one order of a magnitude in \nWHITEOAK (as shown in Figure 3.2). Note, that we chose such a simple case since some of the features \nthat are needed for a more complicated test, e.g., array access, incur substan\u00adtially different run-time \ncosts in the two languages, thereby biasing the method invocation measurement that we seek. Due to space \nconsiderations we could not discuss all is\u00adsues related to the synergy of the two typing paradigms. In \nparticular, we left out dif.culties arising from Java s secu\u00adrity system, and the implications of multithreading \non our caching mechanism. 4. Summary and Future Work The introduction of structural types into a nominally \ntyped language has two major implication on the style of program\u00adming and design in that language. First, \nthe use of structural types increase locality: If a type is needed in some place in the program we only \nneed to de.ne it in the point where it is used. There is no need to 9 We use the term JAVALEX instead \nof the formal name of this benchmark, JAVAC, which is confusing in the context of this paper. change \nthe de.nition of classes (which are typically scat\u00adtered around the program) in order to make this new \ntype viable. This enables concerns to be con.ned to a well-de.ned region of the program, resulting in \nincreased coherence of the program s modules. Locality is particularly important in maintaining the balance \nof power between supplier s and client s code. A change in a supplier module due to a client s needs \nmay eventually lead to deterioration of the design of the supplier, especially when there are multiple \nclients that in.ict changes onto one supplier. Retroactive abstraction ob\u00adviates many of these changes, \nthereby preserving the quality of the supplier s design. The second effect is that of increased uniformity. \nAs ar\u00adgued by Meyer s principle of uniform access similar services should be accessible through a single \nsyntactic device carry\u00ading a simple, uniform semantics. Looking at JAVA, we see several breaches of this \nprinciple, for example: methods and .elds are accessed through the same syntax, but with differ\u00adent binding \nsemantics; Procedural abstraction is realized by two kinds of methods, static and instance methods ac\u00adcessible \nby slightly different notations, and carrying differ\u00adent binding semantics; .nally, there is a dedicated \nsyntax for constructor calls. WHITEOAK allows the programmer to ab\u00adstract away most of these differences, \nthus making it easier to read, write, and maintain the source code. Moreover, the on-going struggle of \naugmenting the pre\u00adcision and expressiveness of static type systems leads to the emergence of multi-paradigm \nlanguages which exhibit a large, feature-rich core that only emphasizes the point in favor of uniform \naccess (In contrast, the elegant, minimal structure of dynamically typed languages enable these to better \nmaintain Meyer s principle). The semantics of dispatching methods on plain structural types is quite \nclose to that of the proposed invokedynamic instruction10. Indeed every language implementation with \nstructural types could rely on this new instruction when it becomes available. Alternatively, the performance \ndata re\u00adported in this paper provide a reference point for evaluating future implementations of invokedynamic. \nSupport for structs with non-abstract methods, ex\u00adceeds, the abilities of invokedynamic. The implemen\u00adtation \ndetails presented here are therefore important for any language that will attempt to provide similar \nservices, with\u00adout changing the underlying virtual machine. We assume that the research effort aimed \nat better utilization of the JVM will become more and more important as the JVM gradu\u00adally turns into \na safe and powerful computing platform that can host a large array of languages. (The JVM s support for \nscripting languages, in which invokedynamic plays a major role, is one of the signs in that direction). \nIn fact, at this point one can reasonably predict that the JVM will actually outlive the JAVA language. \n10 http://www.jcp.org/en/jsr/detail?id=292 A promising direction for future research is the use of structural \ntypes in conjunction with .rst-class support for data queries. One of the major predicaments facing the \nin\u00adtegration of (say) SQL queries into JAVA is the correct typ\u00ading of the query results. If two different \nprogram-embedded SQL queries return similarly structured data it is only natural to expect this data \nto be of the same type. Locally inferring the nominal type of the result is only a partial solution since \nthe queries may be located at two separately compiled mod\u00adules. In the absence of a whole program analysis, \nthe inferred types will be nominally different. A structural typing scheme is therefore the natural solution \nfor allowing the interplay of such two types. References [1] R. M. Amadio and L. Cardelli. Subtyping \nrecursive types. ACM Trans. on Prog. Lang. Syst., 15(4):575 631, 1993. [2] D. Ancona, G. Lagorio, and \nE. Zucca. Jam a smooth extension of Java with mixins. In E. Bertino, editor, Proc. of the 14th Euro. \nConf. on OO Prog. (ECOOP 00), volume 1850 of LNCS, pages 154 178, Sophia Antipolis and Cannes, France, \nJune 12 16 2000. Springer. [3] T. Andrews and C. Harris. Combining language and database advances in \nan object-oriented development environment. In N. K. Meyrowitz, editor, Proc. of the 2nd Ann. Conf. on \nOO Prog. Sys., Lang., &#38; Appl. (OOPSLA 87), pages 430 440, Orlando, Florida, Oct. 4-8 1987. ACM SIGPLAN \nNotices 22(12). [4] M. P. Atkinson and O. P. Buneman. Types and persistence in database programming languages. \nACM Comput. Surv., 19(2):105 170, 1987. [5] M. P. Atkinson and R. Welland. Fully Integrated Data Env.: \nPersistent Prog. Lang., Object Stores, and Prog. Env. Springer, Secaucus, NJ, USA, 2000. [6] G. Baumgartner \nand V. F. Russo. Implementing signatures for C++. In Proc. of the 6th USENIX C++ Conf., pages 37 56, \nCambridge, MA, Apr. 1994. USENIX Association. [7] G. Baumgartner and V. F. Russo. Implementing signatures \nfor C++. ACM Trans. on Prog. Lang. Syst., 19(1):153 187, Jan. 1997. [8] G. Bracha. The Programming Language \nJigsaw: Mixins, Modularity and Multiple Inheritance. PhD thesis, Dept. of Comp. Sci., University of Utah, \n1992. [9] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Making the future safe for the past: Adding \ngenericity to the Java programming language. In Proc. of the 13th Ann. Conf. on OO Prog. Sys., Lang., \n&#38; Appl. (OOPSLA 98), pages 183 200, Vancouver, British Columbia, Canada, Oct.18-22 1998. ACM SIGPLAN \nNotices 33(10). [10] K. B. Bruce and J. N. Foster. LOOJ: Weaving LOOM into Java. In Proceedings of the \n18th European Conference on Object-Oriented Programming (ECOOP 04), pages 389 413, Oslo, Norway, June \n14-18 2004. [11] M. Buchi and W. Weck. \u00a8 Compound types for java. In Proc. of the 13th Ann. Conf. on \nOO Prog. Sys., Lang., &#38; Appl. (OOPSLA 98), pages 362 373, Vancouver, British Columbia, Canada, Oct.18-22 \n1998. ACM SIGPLAN Notices 33(10). [12] B. Eckel. Thinking in C++. Prentice-Hall, Upper Saddle River, \nNJ, USA, 1995. [13] R. P. Gabriel, L. Northrop, D. C. Schmidt, and K. Sullivan. Ultra-large-scale systems. \nIn OOPSLA 06: Companion to the 21st ACM SIGPLAN conference on Object-oriented programming languages, \nsystems, and applications, pages 632 634. ACM Press, 2006. [14] E. Gamma, R. Helm, R. E. Johnson, and \nJ. M. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Professional Computing \nseries. Addison-Wesley, Reading, Massachusetts, 1995. [15] J. Gil and P. F. Sweeney. Space-and time-ef.cient \nmemory layout for multiple inheritance. In Proc. of the 14th Ann. Conf. on OO Prog. Sys., Lang., &#38; \nAppl. (OOPSLA 99), pages 256 275, Denver, Colorado, Nov.1 5 1999. ACM Press, ACM SIGPLAN Notices 34 (10). \n[16] J. Gosling, B. Joy, G. L. J. Steele, and G. Bracha. The Java Language Speci.cation. Addison-Wesley, \nReading, Massachusetts, 3rd edition, June 2005. [17] W. Harrison, D. Lievens, and T. Walsh. Using recombinance \nto improve modularity. Technical Report 104 Software Structures Group, Trinity College Dublin, Dublin, \nIreland, March 2007. [18] H. Hosoya, A. Frisch, and G. Castagna. Parametric polymorphism for XML. In \nJ. Palsberg and M. Abadi, editors, Proc. of the 32nd ACM SIGPLAN-SIGACT Symp. on Principles of Programming \nLang. (POPL 05), pages 50 62. ACM Press, 2005. [19] B. N. J\u00f8rgensen. Integration of independently developed \ncomponents through aliased multi-object type widening. Journal of Object Technology, 3(11):55 76, 2004. \n[20] K. L\u00a8aufer, G. Baumgartner, and V. F. Russo. Safe structural conformance for Java. The Computer \nJournal, 43(6):469 481, 2001. [21] T. Lindholm and F. Yellin. The Java Virtual Machine Speci.cation. \nAddison-Wesley, Reading, Massachusetts, 2nd edition, 1999. [22] D. Malayeri and J. Aldrich. Integrating \nnominal and structural subtyping. In Proceedings of the 22nd European Conference on Object-Oriented Programming \n(ECOOP 08), pages 260 284, Paphos, Cyprus, July 7-11 2008. [23] E. R. Murphy-Hill, P. J. Quitslund, and \nA. P. Black. Removing duplication from java.io: a case study using traits. In OOPSLA 05: Companion to \nthe 20th ACM SIGPLAN conference on Object-oriented programming languages, systems, and applications, \npages 282 291, New York, NY, USA, 2005. ACM Press. [24] G. W. Neufeld and S. T. Vuong. An overview of \nASN.1. Comp. Networks and ISDN Sys., 23(5):393 415, Feb. 1992. [25] M. Odersky. The Scala experiment: \ncan we provide better language support for component systems? In Proceedings of the 33rd ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL 06), pages 166 167, Charleston, South Carolina, \nUSA, January 11-13 2006. [26] N. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and A. P. Black. Traits: Composable \nunits of behavior. In L. Cardelli, editor, Proc. of the 17th Euro. Conf. on OO Prog. (ECOOP 03), volume \n2743 of LNCS, pages 248 274, Darmstadt, Germany, July 21 25 2003. Springer. [27] J. W. Schmidt. Some \nhigh level language constructs for data of type relation. ACM Trans. on Database Sys., 2(3):247 261, \nSept. 1977. [28] Y. Zibin and J. Gil. Ef.cient subtyping tests with PQ\u00adencoding. In Proc. of the 16th \nAnn. Conf. on OO Prog. Sys., Lang., &#38; Appl. (OOPSLA 01), pages 96 107, Tampa Bay, Florida, Oct. 14 \n18 2001. ACM Press, ACM SIGPLAN Notices 36(11).   \n\t\t\t", "proc_id": "1449764", "abstract": "<p>This paper presents WHITEOAK: a JAVA extension that introduces structural type equivalence and subtyping into the language. We argue that structural subtyping addresses common software design problems, and promotes the development of loosely coupled modules without compromising type safety.</p> <p>We discuss language design issues, including subtyping in face of self-referencing structural types, compile-time operators for computing the new types from existing ones, and the semantics of constructors and non-abstract methods in structural types. We describe implementation techniques, including the compile-time and run-time challenges that we faced (in particular, preserving the identity of objects). Measurement indicate that the performance of our implementation of structural dispatching is comparable to that of the JVM's standard invocation mechanisms.</p>", "authors": [{"name": "Joseph Gil", "author_profile_id": "81100349003", "affiliation": "Technion - Israel Institute of Technology, Haifa, Israel", "person_id": "P1223154", "email_address": "", "orcid_id": ""}, {"name": "Itay Maman", "author_profile_id": "81100460201", "affiliation": "Technion - Israel Institute of Technology, Haifa, Israel", "person_id": "P1223155", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449771", "year": "2008", "article_id": "1449771", "conference": "OOPSLA", "title": "Whiteoak: introducing structural typing into java", "url": "http://dl.acm.org/citation.cfm?id=1449771"}