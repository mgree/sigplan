{"article_publication_date": "10-19-2008", "fulltext": "\n Verifying Correct Usage of Atomic Blocks and Typestate Nels E. Beckman Kevin Bierhoff Jonathan Aldrich \nSchool of Computer Science Carnegie Mellon University {nbeckman,kbierhof,aldrich}@cs.cmu.edu Abstract \nThe atomic block, a synchronization primitive provided to programmers in transactional memory systems, \nhas the po\u00adtential to greatly ease the development of concurrent soft\u00adware. However, atomic blocks can \nstill be used incorrectly, and race conditions can still occur at the level of application logic. In \nthis paper, we present a intraprocedural static analy\u00adsis, formalized as a type system and proven sound, \nthat helps programmers use atomic blocks correctly. Using access per\u00admissions, which describe how objects \nare aliased and mod\u00adi.ed, our system statically prevents race conditions and en\u00adforces typestate properties \nin concurrent programs. We have implemented a prototype static analysis for the Java lan\u00adguage based \non our system and have used it to verify several realistic examples. Categories and Subject Descriptors \nD.3.2 [PROGRAM-MING LANGUAGES]: Concurrent, distributed, and paral\u00adlel languages; F.3.1 [LOGICS AND MEANINGS \nOF PRO-GRAMS]: Mechanical Veri.cation General Terms Languages, Veri.cation Keywords Transactional memory, \nTypestate, Permissions 1. Introduction It is now taken for granted in the .eld of computer science that \nthe age of parallelism is upon us, and with good reason; with more and more of the transistors given \nto us by Moore s Law going into an ever-increasing number of on-chip cores, we can no longer expect predictable \nincreases in single\u00adthreaded performance. With this in mind, many researchers in the .eld of computer \nscience have begun investigating new techniques for the development of software that can actually take \nadvantage of more cores. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 08, October 19 23, 2008, Nashville, Tennessee, USA. Copyright c . 2008 ACM 978-1-60558-215-3/08/10. \n. . $5.00 Among the large number of recent proposals, transac\u00adtional memory (TM) seems to have gained \nthe greatest amount of traction. Transactional memory attempts to sim\u00adplify the construction of concurrent \napplications that make use of shared memory. Most realizations of transactional memory provide programmers \nwith a simple concurrency primitive, the atomic block. Code that is executed within an atomic block will \nexecute sequentially, and as if no other threads were executing at the same time. The approach is transactional, \nbecause atomic blocks are usually imple\u00admented as memory transactions which abort and retry in the event \na thread witnesses an inconsistent view of memory. However, as some of TM s greatest proponents will \ntell you, while atomic sections are a vast improvement over lock\u00adbased synchronization, they are far \nfrom perfect (Grossman 2007). Atomic sections by themselves do not guarantee cor\u00adrect synchronization, \neven when mutual exclusion is the only synchronization primitive needed, because they can still be used \nincorrectly. Even if every access to thread-shared mem\u00adory is performed inside of an atomic block, race \nconditions at the level of program logic, or high-level data races, (Artho et al. 2003) can still occur. \nFor the scope of this work, we consider how these race conditions can lead to misuse of object protocols. \nOur goal is to statically prevent races on the abstract state of an object, as well as violations of \nan object s concrete state invariants due to concurrent access. As motivation, consider a hypothetical \nnetwork chat ap\u00adplication, used as a running example throughout this paper and partially shown in Figures \n1 and 2. In this application, two threads, a GUI event thread and a network-monitoring thread, each modify \none shared object of the Connection class. This class abstractly represents a connection between a remote \nand local host. The GUI thread sends messages, and opens and closes the connection in response to local \nuser events, while the network-monitoring thread closes the con\u00adnection in response to a remote user \nevent. In Figure 1 the trySendMsg method, invoked in response to a GUI event, checks to see if the connection \nis active, and if so sends a message by calling the send method of the Con\u00adnection class. Both the isConnected \nand send methods of the Connection class are properly synchronized, reading class Connection { ... void \ndisconnect() { /* see fig. 2 */ } boolean isConnected() { atomic: { return (this.socket != null); } } \n void send(String msg) { atomic: { this.socket.write(msg); this.counter.increment(); } } ... } class \nGUI { ... boolean trySendMsg(String msg) { if( this.myConnection.isConnected() ) { this.myConnection.send(msg); \nreturn true; } else { return false; } } ... } Figure 1. An example where a race condition could occur. \nand modifying thread-shared .elds inside of atomic blocks. However, a race condition exists on the abstract \nstate of the connection object. The GUI thread relies on the connec\u00adtion remaining in the connected state \nin between the call to isConnected and the call to send. If the network thread were to close the connection \nbefore the GUI thread s call to send, this call would be invalid and would cause a null\u00adpointer exception. \nThe second example, shown in Figure 2, shows how mis\u00aduse of atomic blocks can lead to violations of object \ninvari\u00adants, thus leading to improper implementation of object pro\u00adtocols. The Connection class also \nprivately keeps a counter to track the number of messages that have been sent during the lifetime of \na connection. At the time of class creation this counter is initialized to zero, and each time a connection \nis disconnected, this counter is reset using the reset method. In fact, the Connection class has an invariant \nthat its meth\u00adods rely on: whenever a Connection object is not connected, the socket .eld will be null \nand the message counter will be reset. This helps to ensure that the message count will be accurate. \nWe will assume that the reset method is imple\u00ad class Connection { ... final Counter counter; Connection \n{ this.socket = null; this.counter = new Counter(); } void disconnect() { atomic: { this.socket.close(); \nthis.socket = null; } this.counter.reset(); } ... } Figure 2. An example where object invariants might \nbe violated. mented in such a way that all access to its member variables is done within atomic blocks. \nOnce again, trouble occurs even though shared memory is accessed exclusively within atomic blocks. Concurrent \naccess to the connection object has the potential to cause a violation of its invariants. Assume that \nthe disconnect method is being executed by the network thread. If the GUI thread were to call the connect \nmethod and begin sending messages using the send method precisely at a point in time where the network \nthread had exited the atomic block but had not yet reset the counter, we would lose count of each of \nthose sent packets when the network thread eventually resets the counter1. In this paper, we describe \na Java-like programming lan\u00adguage whose type system statically prevents misuse and incorrect implementation \nof object protocols in concurrent systems. Up to the invariants that are speci.ed by the pro\u00adgrammer, \nthis type system prevents race conditions and guar\u00adantees that invariants are reestablished at the end \nof method bodies, even in the face of concurrent access to an object and its .elds. Our system uses typestate \n(Strom and Yemini 1986) speci.cations as the language of invariants, and object permissions (Boyland \n2003) to approximate whether or not an object can be thread-shared. Our work builds upon recent work \nfor verifying typestate of aliased objects (Bierhoff and Aldrich 2007). The contributions of this paper \nare as follows: We have developed a programming language that begins to address the problem of improper \natomic block usage. 1 While the race condition in this short illustrative example may seem unrealistic, \nit is more likely to occur in a situation when the method is longer and the programmer is motivated to \nmake atomic blocks as short as possible to maximize concurrency. The type system of this language guarantees \nthat there are no race conditions on the abstract state of an object. If a method call requires the receiver \nobject to be in some state, at run-time the object will be in that state. Furthermore, the speci.ed invariants \nof these abstract states will be preserved, even in the face of concurrent access. In this paper, we \nreinterpret access permissions, which we previously used as an alias-control mechanism, as an approximation \nof the thread-sharedness of a location in memory. Our solution is an improvement over existing, lock-based \napproaches (Jacobs et al. 2005; Rodriguez et al. 2005) because it does not impose hierarchical re\u00adstrictions \non aliasing, and because our speci.cations are more compositional.  We have proved soundness for a core \nsubset of this lan\u00adguage in the accompanying technical report (Beckman and Aldrich 2008).  To our knowledge \nthis is the .rst work that statically veri.es the proper placement of atomic blocks in object\u00adoriented \ncode.  We have developed a prototype analysis for the Java language based on this type system and have \nused it to verify several realistic examples.  Existing work on data race detection (Boyapati et al. \n2002; Pratikakis et al. 2006; Engler and Ashcraft 2003) does a good job of ensuring that access to thread-shared \nmemory is protected by locks or other mutual exclusion primitives, but it does not prevent a program \ns threads from interleaving in ways that destroy application invariants. Preventing thread interleavings \nthat destroy program in\u00advariants is an important goal, because invariants allow pro\u00adgrammers to reason \nabout the behavior of their programs. Toward this goal, several earlier works (Jacobs et al. 2005; Jones \n1983; Owicki and Gries 1976; Vaziri et al. 2006) at\u00adtempt to statically prevent or prove impossible thread \ninter\u00adactions that might invalidate invariants. Compared to these approaches, our work allows for a larger \nvariety of thread\u00adsharing patterns, and additionally helps to ensure the proper use of object protocols, \nan abstraction of object state that forms an implicit but unchecked interface in many object\u00adoriented \nprograms. This paper proceeds as follows. In Section 2 we describe our technique at an informal level, \nusing our chat program as a running example. By the end of this section, readers should understand the \nintuition behind our approach. Section 3 de\u00adscribes the formal language in greater detail. Section 4 \nde\u00adscribes our prototype implementation, as well as its use in verifying several real or realistic Java \nprograms. In Section 5 we discuss the wealth of existing work in veri.cation of con\u00adcurrent software. \nIn Section 6 we discuss how we would like to improve our technique, and in Section 7 we conclude.  2. \nOverview At a high level, our approach is as follows: We use typestate speci.cations on methods and \nclasses to say which abstract state an object must be in before calling a method on it, and which concrete \nstates an object s .elds must be in at the end of a method call. (In principle, other behavioral speci.cations \nwould work as well.)  Object references are annotated with access permissions which describe how an \nobject pointed to by a reference is shared. Permissions were originally proposed as a means for guaranteeing \nthe non-interference of threads. In pre\u00advious work, we used interfering permissions to control aliasing. \nNow we reinterpret the same interfering permis\u00adsions to describe how threads share objects.  Finally, \nwe track the state of objects as they .ow through method bodies, discarding knowledge about the state \nof an object when the reference to that object indicates it maybe modi.edbyother threads and we cannot \ndeter\u00admine statically that we are within an atomic section.  In the next several sub-sections, we describe \neach part of the process in greater detail. 2.1 Typestate Speci.cations Our approach uses typestate (Strom \nand Yemini 1986) as the language of behavioral speci.cation. A speci.cation tells the system which application-speci.c \nlogic must be upheld in the face of concurrent access. Typestate speci.cations allow programmers to develop \nabstract protocols describing a method or class behavior. The abstractions take the form of state-machines, \nan abstrac\u00adtion with which most programmers are familiar. As an exam\u00adple, the developer of a .le class \nmight specify that a .le can be in either the open or closed states, and that data can only be read from \nthat .le when it is in the open state. For a more relevant example, consider the following speci.cation \nof the Connection class: disconnect() isConnected() isConnected()is true is false CONNECTED IDLE connect() \nsend() This indicates that a connection can abstractly be idle or connected. Calling the connect method \nwill take an object from the idle state to the connected state, while the reverse holds for the disconnect \nmethod. The sending of messages can only occur while the object is in the connected state, but sending \na message does not affect the object s state. Finally, we can dynamically test whether or not we are \nin the connected state by calling isConnected. Existing work has been done in statically verifying that \nan object s behavior will conform to its typestate speci.cation at run-time (DeLine and F\u00e4hndrich 2004). \nOur work, in par\u00adticular, adapts the approach of Bierhoff and Aldrich (2007) for use in concurrent settings. \nIn the approach proposed by Bierhoff and Aldrich, object states are tracked statically us\u00ading linear \nlogic predicates (Girard 1987) which treat object state information as a resource that can be consumed \nand transformed. Methods that transform the state of an object will consume its old state, and return \na new state, and the type of the reference to that object will re.ect its new state in subsequent lines \nof code. Usually state names are de.ned by an application, how\u00adever, this paper mentions two special \nstates, ? and default, which are known ahead of time. ? represents a lack of knowledge about the state \nof an object. default, on the other hand, is the default state given to an object whose class de.nes \nno abstract states.  2.2 Access Permissions Access permissions (Bierhoff and Aldrich 2007) are a means \nof associating object references with (a) the state of the ob\u00adject referenced and (b) the ways in which \nthat object can be aliased. This is important because statically tracking the state of an object in the \nface of unrestricted aliasing is unde\u00adcidable. In this section we will show how access permissions can \napproximate information on whether or not an object is thread-shared, and why this is a sound approximation. \nThe access permissions system that we use has .ve dif\u00adferent permission types, each one describing whether \nor not the object is aliased, whether the given reference can be used to modify the object, and whether \nother references to the ob\u00adject, if they exist, are allowed to modify the object. These permissions are \nnamed as follows: unique permission to an object indicates that this refer\u00adence is the sole reference \nto an object in the program. This is the same as a linear reference in other type\u00adsystems (Wadler 1990). \n full permissions are exclusive read/write references that can coexist with any number of read-only \nreferences.  immutable permissions are associated with references that point to immutable objects. Any \nnumber of these references can point to the same object, but no reference may have modifying access. \n pure permissions are read-only permissions to objects that may be modi.ed through other references. \n share permissions are associated with references that can read and write objects that can also be read \nand modi.ed by any number of other references in the system. This is the least restrictive permission, \nand is effectively the default in languages like Java.  The access permissions are arranged in a partial \norder and can be split in order to create other permissions to the same object. This is necessary because \nwhen an object constructor is called, a single unique reference is returned, but we may want to then \ncreate multiple references to distribute to differ\u00adent parts of the program. These splitting rules are \ndescribed in Figure 3. In the formal language, it is the responsibility of the linear logic proof judgment \nto automatically determine when and how permissions should be split into other per\u00admissions. If several \nexpressions in a method require differ\u00adent permissions to the same reference, the implementation of this \njudgment must solve these constraints by splitting the permission in an appropriate way. In our implementation \n(Section 4), this is done with a constraint solver. An example access permission is shown below: unique(counter, \nRESET) This permission tells us that the counter .eld points to an object that can only be reached via \nthis .eld, and therefore this reference has exclusive read/write access. Furthermore, it is known at \nthis point that the counter is in the RESET abstract state. k = share|pure|immutable S-SYM k(r, s) = \nk(r, s) . k(r, s) k = full|share|pure|immutable S-UNIQUE unique(r, s) = k(r, s) k = share|pure|immutable \nS-FULL full(r, s) = k(r, s) S-IMM immutable(r, s) = pure(r, s) k = full|share S-ASYM k(r, s) = k(r, s) \n. pure(r, s) G; . f P i P i = P SUBST G; . f P Figure 3. Permission splitting rules 2.2.1 Method Speci.cations \nNow that we have seen access permissions, we can string them together with linear logic connectives to \ncreate speci\u00ad.cations. The -connective is used to specify method pre and post-conditions. Predicates \non the left-hand side form the method pre-condition, and those on the right-hand side form the post-condition. \nPredicates in the pre-condition are consumed and cannot be reused unless explicitly returned by the post-condition. \nLinear conjunction (.)is usedwhen we wish to say that multiple objects must be in speci.c states at the \nsame time, and linear disjunction (.) is used when one of several state predicates may be true. We have \nannotated the methods of the Connection class with behavioral anno\u00adtations in Figure 4. For example, \nthe isConnected method is described in the following manner: If the method is called when the receiver \nis a shared object in an unknown state, af\u00adter the method completes the receiver object will either be \nin the CONNECTED state, signi.ed by a return value of true, or the receiver will be in the IDLE state, \nsigni.ed by a return value of false. Other methods are annotated similarly.  2.2.2 State Invariants \nand Packing The same access permissions can be used to annotate classes with invariant predicates. In \nour system, an object s invari\u00adants are tied to the abstract states in which that object re\u00adsides. When \ndesigning a class, a programmer has the ability to declare abstract states for a class. He can also decide \nthat certain predicates over the .elds of an object must hold true whenever the object is in one of those \nstates. These predi\u00adcates are called state invariants. In Figure 5, we have anno\u00adtated the Connection \nclass with state invariants, predicates that should hold true when that connection is either open or \nclosed. Take, for example, the following invariant: CONNECTED := unique(counter, COUNTING) . unique(socket, \ndefault) It speci.es that when a connection is in the CONNECTED state, its counter .eld must be in the \nCOUNTING state and its socket must be in the default state. In order to allow methods to modify the .elds \nof an object and still modularly verify that these invariants hold, we employ a packing/unpacking methodology \n(Barnett et al. 2004; DeLine and F\u00e4hndrich 2004). Unpacking is a means of statically delineating the \npor\u00adtions of code during which object invariants are not expected to hold. Normally, objects are packed, \nmeaning that their state invariants hold. However, in order to read or modify the .elds of an object \ninside of a method call, that object must .rst be unpacked, which allows the invariants to be temporarily \nbroken. Packing itself is a concept, and the act of either packing or unpacking can be done explicitly \nby the programmer or can be left implicit. The formal system we present in Sec\u00adtion 3 takes the former \napproach. The examples presented throughout this paper, on the other hand, are written in a Java-like \nlanguage without pack and unpack expression. Fig\u00adures 7 and 8, which walk through a veri.cation example, \nil\u00adlustrate where packing and unpacking implicitly occur. Sim\u00adilarly, our implementation (Section 4) \ndoes not require ex\u00adplicit annotations and instead infers them. It is important to note that an object \nmust be unpacked before its .elds can be written to or read from. Similarly, before a method returns, \nthe receiver object must be packed, and within the method body the receiver must be packed before method \ncalls. The class Connection { boolean isConnected() : share(this, ?) \u00ad(result == true . share(this, CONNECTED)) \n. (result == false . share(this, IDLE)) { atomic: { return (this.socket != null); } } void connect(String \naddr) : immutable(addr, default) . share(this, IDLE) \u00adshare(this, CONNECTED) { atomic: { this.socket \n= new Socket(addr); this.counter.startCounting(); } }  void send(String msg) : immutable(msg, default) \n. share(this, CONNECTED) \u00adshare(this, CONNECTED) { atomic: { this.socket.write(msg); this.counter.increment(); \n } } void disconnect() : share(this, CONNECTED) -share(this, IDLE) { atomic: { this.socket.close(); \nthis.socket = null; } this.counter.reset(); } // ... continued } Figure 4. Method speci.cations and \nimplementations for the Connection class. The class de.nition is continued in Figure 5. latter is a requirement \nthat ensures the receiver will be con\u00adsistent in case of re-entrant calls. At the point of unpacking, \nwe are allowed to assume the information about the .elds of the unpacked object that is implied by the \nstate invariant of the object that is being unpacked. For example, at the beginning of the send method \nof the Connection class, seen in Figure 4, we know that the receiver object (this)is CONNECTED.Af\u00ad class \nConnection { // ... from above states IDLE, CONNECTED; IDLE := unique(counter, RESET) . socket == null \nCONNECTED := unique(counter, COUNTING) . unique(socket, default) private final Counter counter; private \nSocket socket; Connection() : 1 -unique(this, IDLE) { this.socket = null; this.counter = new Counter(); \n } } Figure 5. State, invariant and constructor speci.cations for the Connection class, where 1 means, \nrequires no permis\u00adsion. ter the receiver is unpacked, we know that the counter .eld is in the COUNTING \nstate, but the receiver is no longer known to be in the CONNECTED state since the invariants for that \nstate may not hold. Our formal system tracks this information using a separate access permission, unpacked(share, \nCONNECTED), which tells us what state the receiver was in before unpacking. When an object is packed, \neither to the same state or to a different state, it is at the point of packing that we are required \nto prove the invariant of that state.  2.2.3 Access Permissions as Thread-Sharing In order to determine \nwhen the state of an object could po\u00adtentially be changed by another thread, we need to know which objects \nare shared across threads. In our system, we use access permissions as an approximation of this informa\u00adtion. \nIf a reference is annotated with a permission that indi\u00adcates the referred object can be reached via \nother references, we assume that those references are held by other threads, and all consequences that \nthis might imply. This is a sound, if potentially imprecise, approximation because in order for a new \nthread to be spawned, a new thread object must be created, with the relevant object refer\u00adences passed \nto that thread s constructor. Alternatively, as in our formalization (see Section 3), if threads can \nbe spawned by calling a method on an object, objects that must be used by both spawning thread and the \nspawnee must be passed to this method. In our system, the only means by which refer\u00adence to an object \ncan be passed to a method or constructor and still be held by the caller is by splitting that permission \nto one of the potentially-shared permissions. We now reexam\u00adine our access permissions in the context \nof thread sharing: unique permissions are permissions to objects that only one thread has access to \nat a given time. These objects can be passed from one thread to another in a linear manner.  full permissions \nare permissions to objects that only one thread can modify, but many threads can read. The thread with \nfull permission can rely on the fact that no other threads can change the state of the object.  immutable \npermissions are permissions to objects that will only ever be read. All threads can rely on this object \nnever changing state.  pure permissions are reading permissions to objects that another thread could \npotentially modify. Unless inside an atomic block, a thread with a pure permission must as\u00adsume that \nthe object s state could change at any moment.  share permissions are modifying permissions to objects \nthat could potentially be modi.ed by a number of other threads. Again, unless inside an atomic block, \nwe must assume that the object s state could change at any mo\u00adment.  Given access permissions in this \nlight, our analysis works by discarding state information for each reference that passes through code \nthat may not be executing atomically and whose permission indicates the referred object might be modi.ed \nby another thread. For objects referenced by local variables, our analysis discards state information \nfor refer\u00adences of pure and share permission. For objects referenced by object .elds, there are additional \nconcerns. Unpacking an object may give us access to the .elds of that object, and those .elds often may \nhave permissions that we have said cannot be modi.ed by other threads. But if the object that is being \nunpacked has pure or share permis\u00adsions, then multiple threads could read these safe objects by traversing \nthrough the thread-shared reference. There\u00adfore, in order to reestablish the condition that all unique \nand full .elds of an object could not be modi.ed concurrently by another thread, we require that the \nunpacking of a pure, share,or full object be done within a transaction. Now, re\u00adgardless of whether a \nvariable is a .eld or local variable, our analysis only needs to forget state information if the permis\u00adsion \non the variable is pure or share. The soundness of this technique boils down to this intu\u00adition. If a \nmethod has access to a unique (or full) permission, one of the following two cases must be true: The \nobject referred to is only accessible through local variables in the current thread s stack, and therefore \ncould not be accessed by any other threads.  The object is referred to by a .eld of another object. \nSince thread-shared objects cannot be unpacked outside of an atomic block, if the referring object is \nthread-shared we  must already be inside of one. This situation is shown pictorially in Figure 6. Threads \n Shared Object Figure 6. Unique and full .elds within a thread-shared ob\u00adject have necessarily been unpacked \nwithin a transaction. The single thread inside is free to modify at will. Finally, we require that all \nstatic member variables are read or written to inside of atomic blocks. Our formal sys\u00adtem (Section 3) \nhas no notion of static member variables and therefore does not enforce this requirement. Our implemen\u00adtation, \non the other hand, does. In summary, the following additions are required to make access permissions \nfunction as a sound approximation of thread-sharing: We immediately forget state information about refer\u00adences \nwhose access permission indicates that the re\u00adferred object could be modi.ed by other threads (pure and \nshare).  We require that share, pure,and full references are only unpacked inside of atomic blocks. \nThis ensures that we have exclusive access to the .elds of that object. This is required for full permissions \nonly because our system uses weak transactional semantics, and is done for the bene.t of the other, pure, \nreferences to the same object.  All static .elds must be read from and written to inside of atomic blocks. \n One of the nice aspects of this methodology is that there is no additional annotation burden over and \nabove the per\u00admission annotations. If you are already using them to track typestate in a single-threaded \napplication, no additional an\u00adnotations, with the exception of atomic blocks, are necessary if you decide \nto make that application concurrent.  2.3 Tracking Transactions In order to track whether or not a given \nline of code must be executing within an atomic block, we use a simple type and effect system recently \nformalized (Moore and Grossman 2008). Atomic blocks are dynamically scoped. At run-time, a statement \nwithin a method body could very well be execut\u00ading within a transaction, even if the method itself never \nex\u00adplicitly opened an atomic block. This is because any methods called within an atomic block will execute \nwithin the same transaction. This also means that if we use a modular analy\u00adsis, it may be impossible \nto tell if a method body is inside of an atomic block. This intuition corresponds to three effect values \nin our system: Expressions type-checked with the wt effect are known to de.nitely be executing within \na transaction. State\u00adments inside of an atomic block are type-checked in this manner. Expressions type-checked \nwith the ot effect are known to be executing outside of a transaction. Because of the dynamic nature \nof an atomic block only the single, top\u00adlevel expression is type-checked with this effect. You might \nalso imagine type-checking the main method of a Java pro\u00adgram in this way. Finally, the emp effect indicates \nthat the type-system cannot be sure one way or the other. Method bodies are type-checked with this effect \nsince they could po\u00adtentially be called within an atomic block. The tracking of transactions is treated \nmore formally in Section 3.  2.4 Examples Revisited Now that we have seen typestate speci.cations, access \nper\u00admissions and we can statically track whether or not code is executing inside of a transaction, we \ncan revisit our original examples and see where these examples would fail to check. In Figure 7 we have \ntaken the original trySendMsg method from Figure 1 and annotated it with the typestate and permis\u00adsion \ninformation that is known statically at each line of the method, as well as the in-transaction effect \nthat the line is currently being checked under. The transaction effect is al\u00adways emp in this example, \nsince no atomic blocks are ever entered. It may also be helpful to refer to Figure 4 which shows the \nmethod speci.cations. At the beginning of the method, we have a unique per\u00admission to the receiver, and \nthis receiver is in the default state, as no states were de.ned for the GUI class. In order to access \n.elds of the receiver, the receiver is immediately un\u00adpacked, introducing an unpacked predicate. The \nunpacked predicate is technical device that is used to ensure that a.) objects are packed before method \ncalls and method returns, and that b.) a given object cannot be unpacked twice before it is packed, which \ncould have the effect of duplicating per\u00admissions. Here, unpacking also gives us a share permission to \nthe myConnection .eld, which is in some unknown state ( ? ). This is enough to satisfy the pre-condition \nfor the dy\u00adnamic state test isConnected, which consumes the original permission to the .eld, and returns \na predicate indicating that if the return value is true we will know that the connection is open, and \nthe reverse if the return value is false. It is at this point that the analysis discards all known state \ninformation about pure and share permissions. Intuitively, this process simulates the possible interleavings \nof other threads execut\u00ading at this point in the program. When the analysis arrives at the true branch \nof the conditional, it knows that the re\u00adsult of the method call must have been true, and therefore \nboolean trySendMsg(String msg) { void disconnect() { emp : unique(this, default) emp : unpacked(unique, \ndefault), share(myConnection, ?) emp : unpacked(unique, default), share(myConnection, ?) Error! Precondition \nnot met. this.myConnection.send(msg); emp : unique(this, default) return true; } else { emp : unpacked(unique, \ndefault), share(myConnection, ?) emp : unique(this, default) return false; } } Figure 7. Veri.cation \nof the trySendMsg method of the GUI class from Figure 1. Immediately after the conditional expression, \ntwo versions of the context are shown in order to illustrate the effect of forgetting. can reduce the \npredicate describing myConnection. Unfor\u00adtunately, because we discarded knowledge of the abstract state \nof the myConnection .eld, the pre-condition of the send method cannot be ful.lled, and an error is signaled. \nBefore each method return the receiver is packed to the post\u00adcondition. The object invariant example \nfrom Figure 2 proceeds in a similar manner. In Figure 8 we successfully verify a version of the disconnect \nmethod that we have corrected by pulling the call to reset into the atomic block. Initially we begin \nwith the method pre-condition, which we unpack inside the atomic block. Unpacking gives us the knowledge \nthat we have a unique permission to both the socket and the counter .elds of the receiver, and that the \ncounter is in the COUNTING state. One may wonder why we are not forced to forget that the receiver is \nin the connected state in between the pre\u00adcondition and the entry into the atomic block. The rules of \nour system allow state information for all permissions to .ow from pre-conditions into the .rst expression \nof a method body, and from the last expression of a method body out to the post-condition. If this .rst \nexpression is inside an emp : share(this, CONNECTED) atomic: { this.socket = null; wt : unpacked(share, \nCONNECTED), (socket==null), unique(counter, COUNTING)  } Figure 8. Veri.cation of the corrected disconnect \nmethod. atomic block, then no state information is discarded for any permission type. This works because, \nat the calling context for a method, if we were able to establish the pre-condition for a share or pure \nreference, this implies that either it was established inside of an atomic block, or split from a stronger \npermission (unique, full or immutable) that did not need to be inside of an atomic block anyway. This \nfeature allows methods to be used in a larger number of permission con\u00adtexts. This point is discussed \nin more detail when the P-METH rule is discussed in Section 3. Inside the atomic block, we check under \nthe wt effect, and therefore are not required to forget the state of share or pure permissions. The socket \n.eld is assigned null, and this fact is recorded in our resource context. Then the reset method is called \non the counter .eld. While we have not given the full speci.cation for this method, the speci.cation \ncan be paraphrased as, given a unique pointer to a counter that is COUNTING, the method will return a \nunique pointer to a counter that is RESET. Finally we have enough facts to pack the receiver to the IDLE \nstate, which satis.es the post\u00adcondition. Both Figure 7 and Figure 8 elide certain details. In order \nto ensure that re-entrant method calls see objects in consis\u00adtent states, we are required to pack before \nmethod calls when object re-entrancy is possible. Also, some permissions were shortened or ignored (e.g., \nthe immutable permission to the msg parameter in trySendMsg) for space reasons. In the introduction we \nsay that race conditions are pre\u00advented up to the program behavior that is speci.ed, and now hopefully \nit is clear why. Only those method behaviors and class invariants that can be expressed in terms of typestate, \nand that are actually annotated by the programmer will be guaranteed in the face of concurrency.  3. \nLanguage We have formalized our analysis as a core, Java-like lan\u00adguage. We chose a language-based approach \nso that our proof could model threads and their non-determinism at run\u00adtime. In this section we will \npresent this formal language. The syntax of this language is given in Figure 9. program PG ::= (CL,e) \nclass decls. CL ::= .eld decls. F ::= f : T methods M ::= Tm(Tx): MS = e terms t ::= x |o | true |false \n|t1 or t2 | t1 and t2 |not t expressions e ::= t |t.f |f := t | new C(t) |to.m(t) | if(t, e1,e2) | let \nx = e1 in e2 | spawn (to.m(t)) |atomic e | unpack(k, S) in e | pack to(S) in e values v ::= o |true |false \nreferences r ::= x |o |o.f types T ::= C |bool permissions p ::= k(r, S) |unpacked(k, S) states S ::= \ns |? facts q ::= t = true |t = false predicates P ::= p |q |P1 .P2 |P1 .P2 | 1 |0 |Tmethod specs MS ::= \nP -E expr types E ::= .x : T.P state inv. N ::= s = P initial state I ::= initially (s) k ::= full |pure \n|share | immutable |unique atomic E ::= wt |ot |emp valid contexts G ::= \u00b7|G,x : T |G,q linear contexts \n. ::= \u00b7|.,P classes C .elds f variables x, y, z objects o methods m states s   Figure 9. Language and \nPermission syntax. Our formal language builds heavily upon two existing systems in the literature. We \nwill point out the major dif\u00adferences. Our system of access permissions reuses many of the pieces developed \nby Bierhoff and Aldrich (2007), but leave out some of the more advanced features, like state di\u00admensions \nand sub-typing in order to focus on concurrency. Our implementation does inherit these features. Our \nformal\u00adization is in.uenced by Boyland (2003) and Zhao s (2007) work on fractional permissions but we \ngive fractions a dif\u00adferent semantics (full, pure,and share are not part of their work). Much of the \nformalism regarding transactional memory, threads and their operational semantics was adapted from Moore \nand Grossman (2008). In particular we use their Weak language, a language that provides weak atomicity \nand does not explicitly model transaction roll-back, as a starting point. Expressions are type-checked \nusing the following judg- C ment: G; .; Efe : .x : T.P . The rules de.ning the judgment are the .rst \ntwelve rules in Figure 11. This judg\u00adment says, given a list of variable types that can be used many \ntimes, G, and a list of consumable predicates that can be used only once, ., and an effect describing \nwhether or not we are known statically to be within an atomic block, E, the expression e being executed \nwithin receiver class C has type T and produces a new permission P . This permis\u00adsion may contain existentially \nbound variables. Note that for clarity of presentation the receiver class annotation is left off unless \nit is needed in a typing rule. The existential type of an expression is somewhat unusual and therefore \ndeserves further mention. The reason a per\u00admission can contain existentially bound variables is because, \nwhile normally a permission is associated with a reference, there are times when our system tracks the \npermissions of an object to which no reference points. For instance, after the .rst subexpression of \na let binding is evaluated, the result (if of a class type) is an object, and before it is bound to a \nvari\u00adable, the available permission to this object must be tracked. Similarly, after a .eld has been \nreassigned, the permission to the object to which it previously referred still exists and can be reassigned \nto another reference. In rule P-ASSIGN, one can see this process occurring in the resulting permis\u00adsion \n[fi/x]P , where the .eld to which object is assigned, fi, is being substituted in for the bound variable \nx. Thus, giv\u00ading expressions existential types allows us to keep consis\u00adtent object permissions and the \nreferences that point to those objects. The last six rules, beginning with P-METH, describe gen\u00aderal \nwell-formedness rules, rather than the expression typing judgment. We use a decidable fragment of linear \nlogic, the multi\u00adplicative additive fragment (MALL), as our language of be\u00adhavioral speci.cation (Lincoln \nand Scedrov 1994). Through\u00adout the typing rules, we will use the standard linear logic proof judgment, \nG; . fP , extensively. This judgment can be read as, in the context of some typing information and a \nlist of consumable resources, the predicate P can be proven true. The syntax for the permissions themselves \nare also given in Figure 9. The declarative nature of the linear logic judgment can make for typing rules \nthat appear to come up with permis\u00adsions from almost no information. See, for example, the G; . fE P \npremise of the P-TERM rule. Similarly, several typing rules divide the linear context in a seemingly \narbitrary manner, written as (., .i). In reality, the linear logic judg\u00adment works more like a constraint \nsolver. In a typing deriva\u00adtion, different rules restrict the permissions or the context in various ways, \nand it is the job of the implementation to .nd a rearrangement of permissions that satis.es all of these \nconstraints. The same judgment is also allowed to split per\u00admission types (Figure 3), and can therefore \nlegally try even more possible rearrangements. The most important new additions to the type system are \nthe judgments shown in Figure 10. Rather than dispatch di\u00adrectly to the linear logic proof-judgment, \nthe typing rules .rst dispatch to the atomic-aware version of this judgment, G; . fE P , which is distinguished \nby the E subscript. It is the job of this judgment to ensure that predicates that must be proven do not \ndepend on permissions of share or pure type being in a known abstract state, unless it is known stat\u00adically \nto be within an atomic block. In order to maintain this invariant, it is occasionally necessary to actively \nforget the state of an object pointed to by a share or pure permission. The forget judgment, whose action \nis also predicated upon E, accomplishes this deliberate loss of information. For ex\u00adample, in the typing \nrule for a method call, P-CALL (Fig\u00adure 11), we sometimes must forget state information for po\u00adtentially \nthread-shared permissions in the post-condition of a method s contract. It is acceptable for a method \ns post\u00adcondition to include share and pure permissions since that method could be called within an atomic \nblock, but if that is not the case, these permissions must not be relied upon. The typing rules themselves \nare given in Figure 11. Here we discuss each rule in turn. P-ATOMIC: The rule for typing atomic blocks \ntypes the sub-expression under the wt effect, since it is trivially known that this expression must be \ninside an atomic block. Because the atomic block itself may or may not be used inside of another atomic \nblock (nesting atomic blocks is legal) we must use the forgetE judgment on the resulting permission. \n P-LET: In order to prove that a let expression is well\u00adtyped, we rely on e1 being well-typed. Like \nthe standard let rule, we then type e2 assuming x has e1 s type. The somewhat unusual premise G; .i,P \nfE P i does not ac\u00adtively forget state information, which is done in other rules, rather it reestablishes \nfor the purposes of the sound\u00adness proof that we do not know anything we should not about the state of \npure and share permissions.  P-CALL: This rule describes method calls. We retain the original restriction \nof Bierhoff and Aldrich s system that the receiver object must be in a packed state by noting that we \ncould always pack to some intermediate state in the event of recursive calls. Since the post-condition \ncould potentially contain state information about shared objects, we again use the forgetE judgment. \nThe notation  E forget(P )= P ' = wt forgetwt(P )= P forgetE (P )= P ' k = immutable|unique|full k = \npure|share forget(k(r, S)) = k(r, S) forget(k(r, S)) = k(r, ?) forget(P1)= P'forget(P2)= P'op = .|. 12 \nforget(P1 op P2)= P1'op P' 2 P = q|1|0|T G; . f P forget(P )= P G; . fwt P E = ot|emp G; . f P (k(r, \nS) . .) . (S =?) where k = pure|share G; . fE P k(r, s) ./Pk(r, s) ./. k(r, s) .\u00b7/k(r, s) ./.,P (k = \nr)(k ) = k'|r '= k'|r= r'|s= s' '''' k(r, s) ./k'(r, ?) k(r, ?) ./k'(r,S) k(r, s) ./k'(r,s) k(r, s) \n./P1 k(r, s) ./P2 op = .|. P = q|1|0|T k(r, s) ./P1 op P2 k(r, s) ./P Figure 10. Forgetting and atomic-aware \nlinear judgment [t/x]P signi.es capture-avoiding substitution and is used throughout. It means, replace \nx with t in P , alpha\u00adconverting if necessary. P-SPAWN: In our language thread spawns are very sim\u00adilar \nto method calls. We require that threads be spawned at the outermost program expression, enforced by \nrequir\u00ading the ot effect. This restriction can be relaxed by using one of the more permissive languages \nproposed by Moore and Grossman (2008). In some ways this rule is the most interesting because it formalizes \nour notion of aliased ob\u00adjects as an approximation of thread-shared objects. This rule returns no permissions \nto the calling context (sig\u00adni.edbythe 1 permission). Unlike synchronous method calls that can temporarily \nborrow an unshared writing permission and then return it to the calling context, this restriction requires \nthe calling context to either give up its own writing permission permanently, or use permis\u00adsion splitting \nrules to create two shared permissions, one for the caller and one for the new thread.  P-UNPACK-WT: \nThe unpack expression is broken into two rules. As discussed in Section 2, our system requires that share, \npure and full permissions be unpacked within an atomic block. Therefore, if the unpack expression is \ntype-checked under the wt effect, k is allowed to be a per\u00admission of any type. This is in contrast to \nthe P-UNPACK rule which requires k = immutable|unique. First off, in  G; .; wt fe : .x : T.P G; .; \nEfe1; .x : T.P forgetE (P )= P ' G; .; Efatomic (e): .x : T.P ' P-ATOMIC G; . ' ,P fE P ' (G,x : T ); \nP ' ; Efe2 : E G; (., . ' ); Eflet x = e1 in e2 : E P-LET  G fto : Co G ft : T G; . fE [to/this][t/x]P \nmtype(m, Co)= .x : T.P -.result : T.Pr unpacked(k ' ,S ' ) ./. forgetE (Pr)= P ' r P-CALL G; .; Efto.m(t \n): .result : T.[to/this][t/x]Pr '  G fto : Co G ft : T G; . fot [to/this][t/x]P mtype(m, Co)= .x : T.P \n-E unpacked(k ' ,S ' ) ./. P-SPAWN G; .; ot fspawn (to.m(t)) : ._ : bool.1 C G; . fwt k(this, S) unpacked(k \n' ,S ' ) ./(., . ' ) G; (. ' , invC (S, k), unpacked(k, S)); wt fC e : E P-UNPACK-WT G; (., . ' ); wt \nfC unpack(k, S) in e : E E= wt k = immutable|unique C G; . fE k(this, S) unpacked(k ' ,S ' ) ./(., . \n' ) G; (. ' , invC (S, k), unpacked(k, S)); EfC e : E P-UNPACK G; (., . ' ); EfC unpack(k, S) in e : \nE G; . fE invC (S, k) .unpacked(k, S ' ) G; (. ' ,k(this, S '' )); E; fC e : E forgetE (k(this, S)) = \nk(this, S '' ) readonly(k) implies S ' = S no .elds in . ' P-PACK G; (., . ' ); EfC pack to S in e \n: E C ' G; .; Eft : .x : Ti.P G; . ' fE [fi/x ' ]P .p localFields(C)= f : Tp = unpacked(k, s) writes(k) \nP-ASSIGN C '' G; (., . ' ); Effi := t : .x : Ti.P .[fi/x]P .p G ft : T init(C)= (. f : T.P, s) G; . \nfE [t/f]P G ft : T G; . f E P P-NEW P-TERM G; .; Efnew C(t): .x : C.unique(x, s) G; .; Eft : .x : T.[x/t]P \n(G,t = true); .; Ef.x : T.P1 G ft : bool (G,t = false); .; Ef.x : T.P2 localFields(C)= f : T G; . fE \nP P-IF C P-FIELD G; .; Efif(t, e1,e2): .x : T.P1 .P2 G; .; Effi : .x : Ti[x/fi]P (x : T, this : C); \nP ; emp fC e : E ' (x : T, this : C); P ; wt fC e : .result : Tr.Pr .T E = .result : Tr.Pr E = forgetemp(E \n' ) P-METH Tr m(Tx): P -E = e ok in C CL ok \u00b7; \u00b7; ot fe : Efi unique Ti .CL .{bool} F ok in C... M ok \nin C P-PROG P-CLASS P-FDECL (CL, e): E class C { FINM} ok f : T ok in C si unique r .Pi .r .F .C class \nC{...s = P ...}.CL r(k, S) .Pi where k = share|pure .S =? P-CTR P-SINV initially(s)ok in Cs = P ok in \nC Figure 11. Typing Rules. Helper judgments (localFields, init, mtype, inv,and writes) de.ned in Figure \n12. order to unpack an object we must prove that the receiver for state S may not hold. Then, the sub-expression \ncan be object is in the state that we claim. This is done using the typed with information about the \nobject s .elds implied linear proof judgment, G; . fwt k(this, S).Since we di-by the state invariant, \ninvC (S, k). This judgment, shown vided the linear context into two, this will also prevent the in Figure \n12, has two roles. It will look up that state in\u00adsub-expression from relying on this fact, as the invariant \nvariant predicate for state S from the class de.nition, and it will also down-grade writing permissions \nif neces\u00adsary. Down-grading is necessary when a read-only per\u00admission (immutable or pure) is being unpacked. \nDuring this process, we temporarily change writing permissions on that object s .elds to read-only permissions. \nThis is performed by the dg predicate, also seen in Figure 12. The sub-expression is also given unpacked(k, \nS),which signi.es that the receiver is temporarily unpacked. P-UNPACK: This rule is similar to P-UNPACK-WT,but \noccurs when not inside a transaction. We are limited to unpacking unique and immutable permissions. \n P-PACK: In order to pack, we treat the linear context as if it has been split in two. With the .rst \npart, .,we must be able to prove all of the invariants of the state S of class C to which the programmer \nwants to pack. These invari\u00adant permissions are retrieved with the invC function. In our small calculus, \nonly the object receiver of a method call can be packed and unpacked, so there is no need to specify \nwhich object is to be packed. We must also be able to show that the receiver has already been unpacked \nby producing the unpacked predicate. Then, we combine the remainder of the linear context, .i, and the \ninforma\u00adtion that this has been packed to state Sii to prove that the subexpression e has type E. Sii \nis S passed through the forget function. If k, the permission with which the reference was unpacked, \nis a read-only permission, then the state from which the object was unpacked Si must match S: A read-only \npermission should not be used to change the abstract state of an object. Finally, the require\u00adment that \nthere are no .elds in .i ensures that .elds can only be read when their object is unpacked.  P-ASSIGN: \nWhen we assign a value to a .eld, the only sort of effect allowed in the calculus, we must .rst prove \nthat the value has some permission and that it is the same type as the ith .eld of class C to which we \nare assigning. The next premise says that we can prove the .eld cur\u00adrently has some permission and that \nthe receiver is un\u00adpacked. The unpacked permission must be a modifying permission. The resulting permission \nof the entire expres\u00adsion is the permission to the .eld s old value, suitable for assignment to another \n.eld, as well as permission to the .eld s new value and the unpack predicate.  P-NEW: In order to instantiate \na new object, we must be able to prove the state invariant for the initial state of that object. This \nis done by looking up the state invariant P for the initial state, and proving it when treating the permissions \nto the constructor arguments as .elds of the object. These permissions are consumed, and the result is \na unique permission to the object in the initial state.  P-TERM: Individual terms are given a permission \nand a type by type-checking the term, proving some permission P from the linear context and then pulling \nthe term itself  out of the permission, resulting in an existentially bound one. P-IF: The conditional \nexpression binds a boolean term in both the branch expressions. Each branch is type\u00adchecked with the \nknowledge that the term is either true or false. The resulting permission for the entire expression is \na disjunction, since the permission from either branch could be produced.  P-FIELD: A .eld read proves \nsome permission P which contains permissions for fi and existentially binds it so that it can be assigned \nto another reference.  P-METH: Method bodies are actually type-checked twice. Because we do not know \nstatically whether or not a method will be executing within a transaction, we type\u00adcheck method once \nwith the emp effect, which estab\u00adlishes that the method is legal outside of a transaction. Then the method \nis type-checked a second time with the wt effect in order to verify that it meets its speci.cation. This \nbehavior is essential to typing examples such as the trySendMsg method in Figure 1, where state informa\u00adtion \nabout share or pure references is used in subsequent lines of code. It is the responsibility of the P-CALL \nrule, to not allow these sorts of methods to be called, nor their post-conditions to be relied upon, \noutside of transactions. Note also that the post-condition that is actually proved is Pr ... The linear \nlogic we use does not allow for unused linear resources. Therefore, if there are extra per\u00admissions created \nduring the course of the method body, those permissions can legally be ignored by using them to prove \n..  P-PROG: A program type-checks if all of its classes are well-formed and the single, top-level expression \ntype\u00adchecks outside of a transaction.  P-CLASS: A class declaration is well-formed if its parts are \nwell-formed.  P-FDECL: The well-formedness rule for .eld declara\u00adtions is somewhat informal, as are \nthe remaining well\u00adformedness rules. This rule states that a .eld declaration is well-formed if its name \nis unique inside the current class, and if it type is either a boolean or one of the de\u00adclared class \ntypes.  P-CTR: A declaration of the initial state is well-formed if the state it mentions is actually \none de.ned in the current class.  P-SINV: A state invariant declaration is well-formed if three conditions \nhold. The state name must be unique within the current class. Any references mentioned in ac\u00adcess permissions \ninside P must be .elds of the current class. Finally, invariants describing share and pure per\u00admissions \nto .elds cannot mention speci.c state informa\u00adtion.  class C {...s=P ...}.CL invC (s)=P dg(P,k)=Pi \ninvC (s)=P invC (s,k)=Pi invC (?,k)=1 dg(P1,k)=Pi dg(P2,k)=Pi op =.|. dgi(k,ki)=kii 12 dg(P1 op P2,k)=P1 \ni op Pi dg(k(r,S),ki)=kii(r,S) 2 ki k ki =pure|immutable =pure|immutable =unique|full|immutable dgi(k,ki)=k \ndgi(k,ki)=immutable k =share|pure ki =pure|immutable class C{...F ...}.CL dgi(k,ki)=pure localFields(C)=F \nclass C{...M...}.CL Tr m(Tx):P -.result :Tr.Pi .M mtype(m,C)=.x:T.P -.result :Tr.Pi class C{...initially(s)...} \ninvC (s)=P init(C)=(.f :T.P,s) writes(unique) writes(full) writes(share) readonly(pure) readonly(immutable) \nFigure 12. Helper judgments. Note that the dgi function is a helper function for dg that operates directly \non permission kinds. Dynamic semantics for our language are given in the ac\u00adcompanying technical report \n(Beckman and Aldrich 2008). These rules are extremely similar to those of the Weak lan\u00adguage (Moore and \nGrossman 2008). They differ primarily in that there are additional technical requirements for the .r\u00ading \nof rules, necessary for our proof of soundness. While the formal operational semantics of this language \nmust actively maintain information regarding the states and permissions of each object, the language \nitself does not actually change the run-time behavior of a Java-like language with weak atomic\u00adity, and \nrequires none of our typing information to be present at run-time. In the technical report, we prove \nthat this core language is sound. Informally soundness means the following: 1. Well-typed thread pools \neither consist exclusively of evaluated threads, or can take an evaluation step. There are two sub-cases \nfor individual threads: (a) No single thread in the thread pool is executing inside of an atomic region, \nand therefore any arbitrary thread in the thread pool must be able to take a step. (b) Exactly one thread \nin the thread pool is executing inside of an atomic region, and therefore that thread must be able to \ntake a step.  2. Any thread pool that is well-typed and can take an evalu\u00adation step must step to a \nwell-typed thread pool. The bur\u00adden of proof for this fact is delegated to individual threads which must \nin turn step to a well-typed expression. The most important part of maintaining a well-typed thread pool \nis maintaining a well-typed heap and per-thread stacks. This well-typedness restricts how many threads \ncan know the de.nite state of objects in the system. For instance, in a well-typed thread pool, at most \none thread can have de.nite knowledge about the state of a share or pure object at any given time. Since \nwe must reestablish well-typedness after each step, we know that this invariant holds. Because well-typed \nthreads can always step, it is never the case that the running system arrives at a evaluation step where \nan object should be in one state but instead is in another.  4. Implementation and Examples We have \nbegun investigating the applicability of our ap\u00adproach by annotating several real and realistic programs \nand verifying them with a prototype checker. In this section we brie.y describe the checker as well as \nthe examples that we have veri.ed thus far. 4.1 Prototype Checker We have extended a static typestate \nchecker (Bierhoff and Aldrich 2008) to check the rules described in this paper in Java language programs. \nThis checker is a modular, branch\u00adsensitive data-.ow analysis that uses specialized Java anno\u00adtations \nas behavioral and access speci.cations. For example, the disconnect method of the Connection class from \nFig\u00adure 2 is annotated with the following speci.cation: @Share(requires=\"CONNECTED\", ensures=\"IDLE\") \nThis indicates the method requires a share permission to the receiver which must be in the connected \nstate, and will return that same permission but with the receiver in the idle state. Similar annotations \nexist for state invariants. Because of our desire to use existing, Java-based tools, we use Java s labeled \nstatement with the label value atomic to delineate atomic blocks, as follows: atomic: { /* code that \nwill execute atomically */ } This legal Java code allows us to get around our inabil\u00adity to annotate \narbitrary blocks using Java s annotation facil\u00adity. We have modi.ed AtomJava (Hindman and Grossman 2006), \na tool which provides atomicity via source-to-source translation, to use labeled statements as atomic \nblocks so that our examples can be run. While the formal language presented in this paper re\u00adquires the \nprogrammer to explicitly pack and unpack the receiver, our checker does not. Before method calls and \nmethod returns, the checker automatically attempts to pack the receiver to some reasonable state. If \none state does not permit permission constraints to be satis.ed, other states are tried until a good \none can be found or no more states are available. Unpacking is also done automatically before .eld reads \nand writes. Our checker does allow some of the more advanced fea\u00adtures of the Bierhoff and Aldrich (2007) \nsystem that were not discussed in this work. For instance, it supports fractional permissions which allow \nmultiple share permissions to be joined together to reconstruct a unique one. It also allows a developer \nto create more complex state hierarchies. As this time our checker does not recognize full linear logic \nspeci.cations, and accepts only a limited sub-set, al\u00adthough enough to specify all of the examples in \nthis paper. Finally, reading from or writing to static .elds requires being within an atomic block, since \nin general, even if a static .eld is the only .eld to point to a particular object many threads can access \nit simultaneously. 4.2 Veri.ed Examples In addition to a corrected version of the running example from \nFigures 4 and 5, we have used our implementation to verify several other examples2. JGroups Application \nIn this example, we annotated the JChannel class of the JGroups open source library and veri\u00ad.ed that \na demo application was using it correctly. JGroups3 is an open-source library for use by developers of \nmulti\u00adcast network applications. The JChannel class is a thread\u00adsafe channel abstraction that allows \na host to connect and send messages to a group of other hosts. This particular class seemed to be a good \ncandidate for speci.cation because its 2 Full source for all of the examples in this paper can be found \nat: www.cs. cmu.edu/~nbeckman/research/atomicver/. 3 www.jgroups.org original developers provided a \n.nite state machine (FSM) based speci.cation in the source-code comments: The FSM for a channel is roughly \nas follows: a channel is created (unconnected). The channel is connected to a group (connected). Messages \ncan now be sent and received. The channel is disconnected from the group (unconnected). The channel could \nnow be connected to a different group again. The channel is closed (closed). Therefore formally specifying \nand statically checking that this class is used in accordance with its informal speci\u00ad.cation seemed \nappropriate. After specifying this class, we ran our analysis on the CausalDemo class. This demo, pro\u00advided \nwith JGroups, creates multiple threads, one of which is responsible for closing the channel. This client \nwas suc\u00adcessfully veri.ed. Reservation Manager Reservation Manager is a multi\u00adthreaded application of \nour own design. It is meant to be similar in architecture to a vacation reservation system. In it, various \nthreads acting on behalf of clients attempt to re\u00adserve bus or plane tickets. This application requires \nclient threads to atomically check for seat availability and make a reservation. This application has \nsome interesting object in\u00advariants. For example, once an bus itinerary has been issued to a passenger, \nhe can upgrade to a plane .ight, as long as the demand for bus tickets is high enough. Once an itinerary \nhas been issued, it must at all times represent either a valid bus or plane trip. At the same time, a \ndaemon thread will oc\u00adcasionally send a (simulated) email describing an itinerary to each itinerary holder, \ntherefore it is important that any upgrades happen atomically. We have successfully veri.ed this entire \napplication. Request Processor Request Processor is another multi\u00adthreaded application of our own design, \npartially shown in Figure 13. This program is meant to be similar in spirit to a server application where \nprocesses are received and farmed off to other threads for handling. Upon initialization, the Re\u00adquestProcessor \ncreates a request pipe object which acts as an intermediary between the request processor, which re\u00adceives \nthe requests, and the request handlers which handle them. This program is notable because each side of \nthe pro\u00adducer/consumer architecture has a different permission to the shared object. The RequestProcessor \nhas a full permis\u00adsion while the handlers themselves have only pure permis\u00adsions. In the future we hope \nto improve the quality of our checker, and verify larger and more realistic examples. Our experiences \nwith these smaller examples, however, lead us to believe that this is a feasible goal.  5. Related Work \n5.1 Verifying Behavior of Concurrent Programs. The work that most closely resembles our own was devel\u00adoped \nas part of the Spec# Project. Jacobs et al. (2005) have class RequestProcessor { states IDLE, RUNNING; \nIDLE := full(requestPipe, closed) RUNNING := full(requestPipe, opened) RequestPipe requestPipe = new \nRequestPipe(); void start() : unique(this, IDLE) -unique(this, RUNNING) { this.requestPipe.open(); // \nHandler(rp) : pure(rp, ?) -1 (new Thread(new Handler(this.requestPipe))).start(); (new Thread(new Handler(this.requestPipe))).start(); \nreturn; } void send(String str) : unique(this, RUNNING) . immutable(str, default) \u00adunique(this, RUNNING) \n{ this.requestPipe.send(str); return; } void stop() : unique(this, RUNNING) -unique(this, IDLE) { this.requestPipe.close(); \nreturn; } } Figure 13. RequestProcessor, an example of a server-like program where class invariants \ndepend on thread-shared ob\u00adjects. also created a system that will preserve object invariants even in \nthe face of concurrency. Moreover, our system uses a very similar unpacking methodology which comes from \na shared heritage in research methodology (Barnett et al. 2004). Nonetheless, we believe our work to \nbe different in several important ways. First, they use ownership as their un\u00adderlying means of alias-control, \nwhich imposes some hierar\u00adchical restrictions on the architecture of an application. On the other hand, \ntheir system allows more expressive speci.\u00adcations, as behaviors can be speci.ed in .rst-order predicate \nlogic, rather than typestate. While we believe our approach would neatly accommodate more expressive \nspeci.cations which we plan to investigate as part of future work, typestate provides a simple abstraction \nof object state and of effects on that object. This system does have a proof of soundness but provides \nneither formal typing rules nor a formal semantics. Their system also is restrictive in the types of \nobjects that can be mentioned in object invariants. Once an object becomes thread-shared, a process which \nmust be signi.ed by the share annotation, it can no longer be mentioned in another object s invariant. \nTherefore, examples like the one shown in Figure 13 where the invariant of the RequestPro\u00adcessor class \ndepends on the thread-shared RequestPipe ob\u00adject, cannot be veri.ed. Finally, our system uses atomic \nblocks while the Ja\u00adcobs approach is based on locks. While this may seem like a minor detail, it actually \nprovides our system with nice bene.ts. In their approach, in order to determine whether it is the responsibility \nof the client or provider to en\u00adsure proper synchronization, there is a notion of client\u00adside locking \nversus provider-side locking. Methods using client-side locking can provide more information-laden post-conditions, \nwhile provider-side locking methods can\u00adnot. Because atomic blocks are a composable primitive, it is \nsuf.cient in our system to create one method with a full post\u00adcondition. This method can then be type-checked \ncorrectly in atomic and non-atomic contexts. Some related work has also been done within the con\u00adtext \nof the JML project (Rodriguez et al. 2005). This work is mainly focused on introducing new speci.cations \nuseful for those who would like to verify lock-based, concurrent object-oriented programs. Some of the \nspeci.cations can be automatically veri.ed, however due to the fact that this ver\u00adi.cation is done with \na model-checker, veri.cation failed to terminate on about half of their examples. There are a number \nof popular logics for concurrency, which can be used to prove important properties of con\u00adcurrent programs. \nThese logics include the logic of Owicki and Gries (1976), Concurrent Separation Logic (O Hearn 2007), \nand Rely-Guarantee Logic (Jones 1983). All three allow you to specify invariants over thread-shared, \nmutable data in simple imperative languages. Owicki-Gries and Con\u00adcurrent Separation Logic are similar, \ndiffering in the expres\u00adsive power of the logics they each use. In these systems, one associates both \na lock and an invariant with a piece of thread\u00adshared data. Upon entering a critical section, the invariants \nover thread-shared data are revealed. These invariants can be used to prove other propositions, but must \nbe reestablished before the end of the critical section. This characteristic is quite similar to unpacking \nof state invariants in our system which, for references of full, share,and pure permission, must be performed \ninside of an atomic block. Concurrent Separation Logic furthermore allows one to reason modu\u00adlarly about \nheap memory that cannot be thread-shared, and does so in a manner that is similar to our unique permission. \nOverall it lacks the .exibility of our permissions, which al\u00adlow a larger variety of thread-sharing patterns. \nIn the Rely-Guarantee approach, a thread must specify invariants which describe how it will not interfere \nwith par\u00adticular conditions required by other threads. Simultaneously a thread must specify the non-interference \nconditions that it requires of other threads. When a program is correct, the rely and guarantee speci.cations \nof each thread weave to\u00adgether to form a global proof of correctness. However, the Rely-Guarantee approach \nsuffers because system speci.ca\u00adtions must be written in a global manner. A thread states not only its \npre and post conditions, but also which invariants of other threads it promises to not invalidate. These \ninvariants could have nothing to do with the memory that it modi.es. All three logics are pen and paper-based \ntechniques and are not, as described in these works, automated analyses. Calvin-R (Freund and Qadeer \n2003) is an automation of the Rely-Guarantee concept, where the rely and guarantee predicate for every \nthread is a conjunction of access pred\u00adicates, describing which locks must be held when access\u00ading shared \nvariables. Calvin-R uses this information, along with the Lipton (1975) theory of reduction, to prove \nmethod behavioral speci.cations. Calvin-R must assume that every method could be called concurrently, \nand therefore variables must always be accessed in accordance with their access predicate. Whereas in \nour system, a unique permission to the receiver of a method call says that the object cannot be thread-shared \nfor the duration of that call, and therefore .elds do not require protected access. Also, this work does \nnot mention the effect that aliasing might have on the valid\u00adity of access predicates, but presumably \nsomething must be done to ensure soundness. In recent work, Vaziri et al. (2006) have proposed a sys\u00adtem \nto help programmers preserve the consistency of objects with a feature called atomic sets. In this approach, \nprogram\u00admers specify that certain .elds of an object are related, and must be modi.ed atomically. An \ninterprocedural static anal\u00adysis then infers code locations where synchronization is re\u00adquired. While \na promising approach, it does not allow veri\u00ad.cation of functional properties of code, such as the correct \nusage of object protocols. Finally, Harris and Jones (2006) introduce a mechanism for STM Haskell that \nensures a data invariants will not be vi\u00adolated during a given execution of a program. However, this \nis a dynamic technique that cannot guarantee conformance for all executions. 5.2 Race Detection. There \nhas been much work in the automated prevention of data races. Dynamic race detectors (Savage et al. 1997; \nYu et al. 2005) check for unordered reads and writes to the same lo\u00adcation in memory at execution time \nby instrumenting pro\u00adgram code. Model-checking approaches have also been ex\u00adplored (Henzinger et al. \n2004; Stoller 2000). These work by abstractly exploring possible thread interleavings in order to .nd \nones in which there is no ordering on a read and write to the same memory location. There have also been \na num\u00adber of static analyses and type systems for data race preven\u00adtion (Boyapati et al. 2002; Greenhouse \nand Scherlis 2002; Grossman 2003; Pratikakis et al. 2006; Engler and Ashcraft 2003) as well, each making \ntrade-offs in the number of false\u00adpositives and the complexity of annotations required. The fundamental \ndifference between each of these race detection approaches and our approach is the presence or absence \nof behavioral speci.cations. None of the other ap\u00adproaches require behavioral speci.cations, and therefore \ncan check only an implicit speci.cation; that the program should contain no data races. In our system, \ntypestate speci.cations, which describe the intended program behavior, allows us to prevent more semantically \nmeaningful race conditions. Atomicity checkers (Flanagan and Qadeer 2003; Sas\u00adturkar et al. 2005; Hicks \net al. 2006) help programmers achieve atomicity using locks, but can only ensure the atom\u00adicity that \nthe programmer deems necessary. Given a speci.\u00adcation of a piece of code that must execute as if atomic \nand speci.cations relating locks to the memory that they protect, an atomicity checker will tell the \nprogrammer whether or not locks are used correctly, according to the theory of reduc\u00adtion (Lipton 1975). \nOnce again, because atomicity checkers do not require behavioral speci.cations, they do not tell the \nprogram which sections of code must execute atomically in order to ensure program correctness.  6. Future \nWork We are currently pursuing a number of future courses of re\u00adsearch. While our work is an attempt \nto advance the work of Bierhoff and Aldrich (2007) to the world of concurrent soft\u00adware, we .rst wanted \nto study the problems of concurrency in relative isolation. Therefore, we have not included many of the \nmore advanced features of that system into the work presented here. These features, like fractional permissions \nand support for sub-typing and inheritance, would make our system even more expressive, and we plan to \nreintroduce them into our system. We believe these features are orthog\u00adonal and can be added without \ndif.culty. Additionally, we are attempting to determine what sorts of access permissions might be more \nuseful in a thread\u00adshared context. At the moment, permissions that are thread\u00adshared, and permissions \nthat are merely aliased locally are not distinguishable, and we would like to tease them apart. For instance, \nwe would like to have a thread-local version of the share permission that would not require synchronization. \nWe have also begun developing an implementation of software transactional memory that uses these same \npermis\u00adsion annotations as a means of improving run-time perfor\u00admance by eliminating unnecessary synchronization \nand log\u00adging. While the implementation is complete, we have only performed preliminary experiments and \nhave not yet estab\u00adlished the ef.cacy of our technique. Finally, we would like to see a greater usage \nof TM for the purposes of static veri.cation. Currently, most existing .ow analyses and veri.cation tools \nare unsound in the face of concurrency, and those that are not impose a great an\u00adnotation burden on the \nprogrammer, in addition to any bur\u00adden imposed by the single-threaded version of the analy\u00adsis. In this \nwork we were able to prove our concurrent lan\u00adguage sound, thanks in part to the clean dynamic seman\u00adtics \nof atomic blocks. If we were to extend Dan Grossman s Garbage Collection/STM analogy (2007), we would \nsay the following: In the same way garbage collection allows proofs of program properties that would \nbe dif.cult or impossible in a language with explicit memory allocation and reclamation, transactional \nmemory will allow proofs of program proper\u00adties for multi-threaded languages, when doing the same with \nlock-based synchronization would be dif.cult or impossible. The performance of TM implementations continues \nto im\u00adprove (Adl-Tabatabai et al. 2006), and we believe this will also help to encourage the adaptation \nof static analyses for use in concurrent programs. 7. Conclusion In this paper we described an intraprocedural \nstatic analy\u00adsis, formalized as a type system, that can help to ensure the proper usage of atomic blocks. \nThe atomic block, provided by transactional memory implementations, is a simple con\u00adcurrency primitive, \nwhen compared with locks, but can still be used incorrectly. Our type system ensures that, up to the \nmethod and object behavioral speci.cations, race conditions will not occur and object invariants will \nbe preserved. We believe this is the .rst work to attempt to statically ensure the correct usage of transactional \nmemory in object-oriented languages. This language uses access permissions, a means of denoting the manner \nin which objects may be aliased, as an approximation for whether or not objects are thread\u00adshared, which \nin turn helps determine whether or not code must be inside of an atomic block. We use typestate as our \nlanguage of speci.cation, and track transactions using a sim\u00adple type-and-effect system. We have proved \nthis language sound in our accompanying technical report (Beckman and Aldrich 2008). Finally, we have \ncreated a prototype static analysis for the Java programming language based on the system described in \nthis paper. We have used it to verify sev\u00aderal realistic concurrent programs.  Acknowledgments The \nauthors would also like to acknowledge the PLAID group, Todd Millstein and John Boyland for their helpful \ncomments. Additionally, we are very grateful for the detailed feedback we received from the anonymous \nreviewers. The authors would like to acknowledge the sponsors who helped fund this work. This work was \nsupported by a Uni\u00adversity of Coimbra Joint Research Collaboration Initiative, DARPA grant #HR00110710019, \nArmy Research Of.ce grant #DAAD19-02-1-0389 entitled Perpetually Available and Secure Information Systems \n, the Department of De\u00adfense, and the Software Industry Center at CMU and its sponsors, especially the \nAlfred P. Sloan Foundation. The .rst author is supported by a National Science Foundation Graduate Research \nFellowship (#DGE0234630). References Ali-Reza Adl-Tabatabai, Brian T. Lewis, Vijay Menon, Brian R. Murphy, \nBratin Saha, and Tatiana Shpeisman. Compiler and runtime support for ef.cient software transactional \nmemory. In PLDI 06: Proceedings of the 2006 ACM SIGPLAN conference on Programming language design and \nimplementation, pages 26 37. ACM Press, 2006. Cyrille Artho, Klaus Havelund, and Armin Biere. High level \ndata races. In VVEIS 03: Proceedings of the Workshop on Veri.cation and Validation of Enterprise Information \nSystems, pages 82 93, April 2003. Mike Barnett, Robert DeLine, Manuel F\u00e4hndrich, K. Rustan M. Leino, \nand Wolfram Schulte. Veri.cation of object-oriented programs with invariants. Journal of Object Technology \nSpecial Issue: ECOOP 2003 workshop on Formal Techniques for Java\u00adlike Programs, 3(6):27 56, June 2004. \nNels E. Beckman and Jonathan Aldrich. Verifying correct usage of atomic blocks and typestate: Technical \ncompanion. Tech\u00adnical Report CMU-ISR-08-126, Carnegie Mellon University, 2008. http://reports-archive.adm.cs.cmu.edu/anon/ \nisr2008/CMU-ISR-08-126.pdf. Kevin Bierhoff and Jonathan Aldrich. Modular typestate checking of aliased \nobjects. In OOPSLA 07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented program\u00adming \nsystems and applications, pages 301 320. ACM Press, 2007. Kevin Bierhoff and Jonathan Aldrich. Plural: \nChecking protocol compliance under aliasing. In Companion Proceedings of ICSE\u00ad30, pages 971 972. ACM \nPress, May 2008. Chandrasekhar Boyapati, Robert Lee, and Martin Rinard. Own\u00adership types for safe programming: \npreventing data races and deadlocks. In OOPSLA 02: Proceedings of the 17th ACM SIG-PLAN conference on \nObject-oriented programming, systems, languages, and applications, pages 211 230. ACM Press, 2002. John \nBoyland. Checking interference with fractional permissions. In R. Cousot, editor, Static Analysis: 10th \nInternational Sympo\u00adsium, volume 2694 of Lecture Notes in Computer Science, pages 55 72, Berlin, Heidelberg, \nNew York, 2003. Springer. Robert DeLine and Manuel F\u00e4hndrich. Typestates for objects. In ECOOP 04: European \nConference on Object-Oriented Pro\u00adgramming, pages 465 490. Springer, 2004. Dawson Engler and Ken Ashcraft. \nRacerX: effective, static detec\u00adtion of race conditions and deadlocks. In SOSP 03: Proceedings of the \nnineteenth ACM symposium on Operating systems princi\u00adples, pages 237 252. ACM Press, 2003. Cormac Flanagan \nand Shaz Qadeer. A type and effect system for atomicity. In PLDI 03: Proceedings of the ACM SIGPLAN 2003 \nconference on Programming language design and implementa\u00adtion, pages 338 349. ACM Press, 2003. Stephen \nFreund and Shaz Qadeer. Checking concise speci.cations for multithreaded software. In Workshop on Formal \nTechniques for Java-like Programs, 2003. Jean-Yves Girard. Linear logic. Theor. Comput. Sci., 50(1):1 \n102, 1987. Aaron Greenhouse and William L. Scherlis. Assuring and evolving concurrent programs: annotations \nand policy. In ICSE 02: Proceedings of the 24th International Conference on Software Engineering, pages \n453 463. ACM Press, 2002. Dan Grossman. Type-safe multithreading in cyclone. In TLDI 03: Proceedings \nof the 2003 ACM SIGPLAN international workshop on Types in languages design and implementation, pages \n13 25. ACM Press, 2003. Dan Grossman. The transactional memory / garbage collection analogy. In OOPSLA \n07: Proceedings of the 22nd annual ACM SIGPLAN conference on Object oriented programming systems and \napplications, pages 695 706. ACM Press, 2007. Tim Harris and Simon Peyton Jones. Transactional memory \nwith data invariants. In TRANSACT 06: First ACM SIGPLAN Workshop on Languages, Compilers, and Hardware \nSupport for Transactional Computing, 2006. Thomas A. Henzinger, Ranjit Jhala, and Rupak Majumdar. Race \nchecking by context inference. In PLDI 04: Proceedings of the ACM SIGPLAN 2004 conference on Programming \nlanguage design and implementation, pages 1 13. ACM Press, 2004. Michael Hicks, Jeffrey S. Foster, and \nPolyvios Pratikakis. Lock inference for atomic sections. In TRANSACT 06: First ACM SIGPLAN Workshop on \nLanguages, Compilers, and Hardware Support for Transactional Computing, 2006. Benjamin Hindman and Dan \nGrossman. Atomicity via source-to\u00adsource translation. In MSPC 06: Proceedings of the 2006 work\u00adshop on \nMemory system performance and correctness, pages 82 91. ACM Press, 2006. Bart Jacobs, Frank Piessens, \nK. Rustan M. Leino, and Wolfram Schulte. Safe concurrency for aggregate objects with invariants. In SEFM \n05: Proceedings of the Third IEEE International Con\u00adference on Software Engineering and Formal Methods, \npages 137 147, Washington, DC, USA, 2005. IEEE Computer Soci\u00adety. Cliff B. Jones. Speci.cation and design \nof (parallel) programs. In Proceedings of IFIP 83, pages 321 332. North-Holland, 1983. Patrick Lincoln \nand Andre Scedrov. First-order linear logic without modalities is NEXPTIME-hard. Theor. Comput. Sci., \n135(1): 139 153, 1994. Richard J. Lipton. Reduction: a method of proving properties of parallel programs. \nCommun. ACM, 18(12):717 721, 1975. Katherine F. Moore and Dan Grossman. High-level small-step op\u00aderational \nsemantics for transactions. In POPL 08: Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on \nPrin\u00adciples of programming languages, pages 51 62. ACM Press, 2008. Peter W. O Hearn. Resources, concurrency, \nand local reasoning. Theor. Comput. Sci., 375(1-3):271 307, 2007. Susan Owicki and David Gries. Verifying \nproperties of parallel programs: an axiomatic approach. Commun. ACM, 19(5):279 285, 1976. Polyvios Pratikakis, \nJeffrey S. Foster, and Michael Hicks. Lock\u00adsmith: context-sensitive correlation analysis for race detection. \nIn PLDI 06: Proceedings of the 2006 ACM SIGPLAN con\u00adference on Programming language design and implementation, \npages 320 331. ACM Press, 2006. Edwin Rodriguez, Matthew B. Dwyer, Cormac Flanagan, John Hatcliff, Gary \nT. Leavens, and Robby. Extending JML for mod\u00adular speci.cation and veri.cation of multi-threaded programs. \nIn ECOOP 05: Object-Oriented Programming 19th European Conference, pages 551 576, 2005. Amit Sasturkar, \nRahul Agarwal, Liqiang Wang, and Scott D. Stoller. Automated type-based analysis of data races and atom\u00adicity. \nIn PPoPP 05: Proceedings of the tenth ACM SIGPLAN symposium on Principles and practice of parallel programming, \npages 83 94. ACM Press, 2005. Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas \nAnderson. Eraser: a dynamic data race detector for multithreaded programs. ACM Trans. Comput. Syst., \n15(4): 391 411, 1997. Scott D. Stoller. Model-checking multi-threaded distributed Java programs. In Proceedings \nof the 7th International SPIN Work\u00adshop on SPIN Model Checking and Software Veri.cation, pages 224 244, \nLondon, UK, 2000. Springer-Verlag. Robert E. Strom and Shaula Yemini. Typestate: A programming language \nconcept for enhancing software reliability. IEEE Trans. Softw. Eng., 12(1):157 171, 1986. Mandana Vaziri, \nFrank Tip, and Julian Dolby. Associating synchro\u00adnization constraints with data in an object-oriented \nlanguage. In POPL 06: Conference record of the 33rd ACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages, pages 334 345. ACM, 2006. Philip Wadler. Linear types can change the world! In M. Broy and \nC. Jones, editors, IFIP TC 2 Working Conference on Pro\u00adgramming Concepts and Methods, Sea of Galilee, \nIsrael, pages 347 359. North Holland, 1990. Yuan Yu, Tom Rodeheffer, and Wei Chen. Racetrack: ef.cient \ndetection of data race conditions via adaptive tracking. In SOSP 05: Proceedings of the twentieth ACM \nsymposium on Operating systems principles, pages 221 234. ACM Press, 2005. Yang Zhao. Checking Interference \nwith Fractional Permissions. PhD thesis, University of Wisconsin-Milwaukee, August 2007.  \n\t\t\t", "proc_id": "1449764", "abstract": "<p>The atomic block, a synchronization primitive provided to programmers in transactional memory systems, has the potential to greatly ease the development of concurrent software. However, atomic blocks can still be used incorrectly, and race conditions can still occur at the level of application logic. In this paper, we present a intraprocedural static analysis, formalized as a type system and proven sound, that helps programmers use atomic blocks correctly. Using <i>access permissions</i>, which describe how objects are aliased and modified, our system statically prevents race conditions and enforces typestate properties in concurrent programs. We have implemented a prototype static analysis for the Java language based on our system and have used it to verify several realistic examples.</p>", "authors": [{"name": "Nels E. Beckman", "author_profile_id": "81363604007", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1223190", "email_address": "", "orcid_id": ""}, {"name": "Kevin Bierhoff", "author_profile_id": "81100267548", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1223191", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P1223192", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449783", "year": "2008", "article_id": "1449783", "conference": "OOPSLA", "title": "Verifying correct usage of atomic blocks and typestate", "url": "http://dl.acm.org/citation.cfm?id=1449783"}