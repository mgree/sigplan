{"article_publication_date": "10-19-2008", "fulltext": "\n Safer Unsafe Codefor .NET Pietro Ferrara Francesco Logozzo Manuel F\u00a8ahndrich \u00b4Ecole Polytechnique, \nFrance, Microsoft Research, USA Microsoft Research, USA Universit`a Ca Foscari, Italy logozzo@microsoft.com \nmaf@microsoft.com pietro.ferrara@polytechnique.edu Abstract The .NET intermediate language (MSIL) allows \nexpressing both statically veri.able memory and type safe code (typi\u00adcally called managed), as well as \nunsafe code using direct pointer manipulations. Unsafe code can be expressed in C# by marking regions \nof code as unsafe. Writing unsafe code can be useful where the rules of managed code are too strict. \nThe obvious drawback of unsafe code is that it opens the door to programming errors typical ofC and C++, \nnamely memory access errors such asbufferoverruns.Worse,a sin\u00adgle piece of unsafe code may corrupt memory \nand destabi\u00adlize the entire runtime or allow attackers to compromise the security of the platform. We \npresent a new static analysis based on abstract in\u00adterpretation to check memory safety for unsafe code \nin the .NET framework. The core of the analysis is a new numeri\u00adcal abstract domain, Strp, whichis used \nto ef.ciently com\u00adpute memory invariants. Strp is combined with lightweight abstract domains to raise \nthe precision, yet achieving scala\u00adbility. We implemented this analysis in Clousot, a generic static \nanalyzer for .NET. In combination with contracts ex\u00adpressed in FoxTrot, an MSIL based annotation language \nfor .NET, our analysis provides static safety guarantees on memory accesses in unsafe code.We tested \nit on all the as\u00adsemblies of the .NET framework. We compare our results with those obtained using existing \ndomains, showing how they are either too imprecise(e.g., Intervals or Octagons) or too expensive (Polyhedra) \nto be used in practice. Categories and Subject Descriptors D.2.4[SoftwareEngi\u00adneering]: Software/ProgramVeri.cation; \nF.3.1[Logic and Meaning of Programs]: Specifying andVerifying and Rea\u00adsoning about Programs; F.3.2[Logic \nand Meaning of Pro- Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 08, October 19 23, 2008, Nashville,Tennessee, USA. Copyright c . 2008ACM 978-1-60558-215-3/08/10... \n$5.00 grams]: Semantics of Programming Languages Program Analysis GeneralTerms Documentation, Reliability,Veri.cation \nKeywords Abstract domains, Abstractinterpretation, Bounds checking, Pointer indexing, Design by Contract, \nStatic anal\u00adysis, .NET 1. Introduction The .NET framework provides a multi-language execution environment \nwhich promotesthesafeexecutionof code.For instance, in (safe) C# it is not possible to have un-initialized \nvariables, unchecked out-of-bounds runtime accesses to ar\u00adrays or dangling pointers. Memory safety is \nenforced by the type system andthe runtime: it is not possible to access arbi\u00adtrary memory locations. \nObject creation and references are allowed freely,but objectlife-timeis managedbyagarbage collector and \nit is not possible to get the address of an ob\u00adject. As a consequence, safe C# provides a safer execution \nenvironment thanC or C++. Nevertheless, there are situations where direct pointer manipulations and direct \nmemory accesses become a ne\u00adcessity. This is the case when interfacing with the underly\u00ading operatingsystem, \nwhen implementing time-critical algo\u00adrithms or when accessing memory-mappeddevices.For this purpose, \nC# provides the ability to write unsafe code (un\u00adsafeC#).In unsafe code,itis possibleto declareand operate \non pointers, to perform arbitrary casts, to take the address of variables or .elds. C# provides syntactic \nsugar to denote blocks of unsafe code, which avoids the accidental use of unsafefeatures. Unsafe code \ncannot run in untrusted envi\u00adronments. Most of the checks commonly enforced by the runtime, such as bounds \nchecking, are not present on pointer manip\u00adulating code. As a consequence the programmer is exposed to \nall the vagaries of C/C++ programming, such as buffer and array over.ows, reading of un-initialized memory, \ntype safety violations, etc.. Those errors are dif.cult to detect and track down, as no runtime exception \nis thrown at the error source.For instance, an application cannot immediately de\u00adtect that somebufferover.ow \ncompromising its data consis\u00adtency has occurred. Instead, it continues its execution in a bad state,onlytofail \n(much) laterduetoa corruptedstate. Tracingbackthe causeofsuchbugstothe original memory corruption is \noften very complicated and time consuming. Our work appears in the context of an ongoing effort to improve \nthe reliability of the .NET platform by systematic use of the Design by Contracts (DbC) methodology [25] \nsupported by static checking tools. In this scenario, static checkingis enabledat eachbuildoreveninan \ninteractive development environment to catchbugs early during devel\u00adopment. Our Analysis We present a \nsound and scalable analysis tostatically check memory safety in unsafe code. Scalability, without giving \nup precision, was a main goal for the analysis. Similar work forC does not ful.ll these two requirements.For \ninstance the analysis introducedbyWagner et al. [34] is not precise enough to check memory accesses that \ninvolve a pointer, a base and an offset, which we found to be pervasive in mscorlib.dll, the main library \nof the .NET framework.On the other hand, the analysis of Dor et al. [13, 12] is pre\u00adcise enough to capture \nthese relations,but it is based on the use of the Polyhedra(Poly)abstract domain [10] which is knowntohavesevere \nscalability problems1.TheworkofSi\u00admon and King [31, 32] improved on that by using an ab\u00adstraction of \nPoly, where linear inequalities were restricted to bucketsof two variables. However, we did not .nd it \nprecise enough to match the programming style adopted in the code we analyzed. Our approach differs from \nearlier work in that it is based on the combination of lightweight and focused abstract domains, instead \nof a monolithic, precise domain. Each abstract domain is specialized (and optimized) toward a particular \nprogram property, and their combination pro\u00advides a powerful analysis without sacri.cing performance. \nOur analysis is based on abstract interpretation [8]. It infers and checks the memory regions accessed \nby read and write operations. A region of memory is denoted by a pair \\p, WB(p)), where p is a pointer \nand WB(p) stands for the WritableBytes of p, i.e., the size of the region in bytes accessible from p.We \nonly allow positive offsets off pointers, thus WB(p) is always non-negative. Differently stated, the \npair stands for the range of ad\u00addresses [p, p + WB(p) - 1]. For instance, if x is an Int32 and p is an \nInt32*, then the read operation x = *(p + 2) is safe in the region \\p, 12): It reads 4 bytes (the size \nof an Int32 in .NET)starting from the addressp +8 (as p is a pointer to Int32). Weuseacombinationofthree \ndomainstoinferboundson memory-accessingexpressions. The coreis the new abstract domain of Stripes(Strp)which \ncaptures properties of the form of x - a * (y[+z]) = b, where a and b are integer 1The worst case complexity \nof Poly is exponential. To the best of our knowledge, at the moment of writing, the most optimized implementations \ndo not scale to more than 40 variables [1, 2]. In the analysis of .NET assemblies, we need to capture \nup to 965 variables. constants, x and y arevariables and z is an optionalvariable. Intuitively, a stripe \nconstraint is used to validate the upper bound onmemory accesses. Intervals(Intv)[8] are used to validate \nthe lower bound of accesses. We use (a modi.ed version of) the Linear equalities domain(LinEq)[18] to \ntrack equalities between variables. We implemented our analysis in Clousot, a generic, intraprocedural \nand language-agnostic static analyzer for .NET [3, 23]. It uses FoxTrot contracts to re.ne the anal\u00adysis \nand to support assume/guarantee reasoning for method calls. FoxTrot allows specifying contractsin .NET \nwithout requiring anylanguage support. Contracts are expressed di\u00adrectly in thelanguage as method calls \nand are persisted to MSIL using the normal compilation process of the source language.We tried our analysis \non all the assemblies of the .NET framework, validating on average more than 54% of unsafe memory accesses \nautomatically in a few minutes. In practice, the false alarms that we get are due to miss\u00ading contracts: \nthe use of contracts will allow us to improve the precision. The analysis isfast enough to be used in \ntest builds. Our Contribution The main contributions of the present work can be summa\u00adrized as follows: \nWe introduce the .rst static analysis to check memory safety in unsafe managed code. Our analysis handles \nthe entire MSIL instruction set and is fully implemented in Clousot. It statically checks contracts, \nand can use them to re.ne the precision of the analysis, e.g. by exploiting preconditions. We tested \nit on all the assemblies of the .NET framework. We de.ne the concrete and abstract semantics for an \nidealized MSIL-like bytecode. We prove soundness by using the abstract interpretation framework to relate \nthe abstract semantics with the concrete semantics. We present a new abstract domain for the analysis \nof memory bounds.Itis basedonthe co-operationofseveral specialized domains. We prove its soundness, and \nwe showhowitiseffectivein practice,by enablingafast, yet precise analysis. We discuss some implementation \nissues necessary to avoid loss of precision, as e.g. the special handling that is required for the C# \nfixed statements.  2. Examples We illustrate the analysis with some representative exam\u00adples, given \nin increasing order of complexity. The examples aretaken from,or inspiredbycode patterns thatwe foundin \nthe .NET framework assemblies. static unsafe void InitToZero( int* a, uint len) { Contract.Requires( \nContract.WritableBytes(a) >= len * sizeof( int )); for (int i =0; i < len; i++) { *(a+i) =0; // (1) }} \nFigure1. Amethodthat zerosaregionof memory.Thepre\u00adcondition speci.es that there are at least len * sizeof(int) \nbytes allocated starting from a. Clousot propagates the pre\u00adcondition, and checks that the write operation \nat (1) is within bounds. 2.1 Array initialization As a .rst example, consider the InitToZero method in \nFig. 1. It initializes the memory region [a, a +4 * len - 1] to zero. The precondition requires that \nat least len * sizeof(int) bytes starting from a are allocated. We express it using FoxTrot notation: \ncontracts are speci.ed by static method calls (e.g. Contract.Requires(... ) for preconditions), and lengths \nof memory regions are denoted by Contract. WritableBytes(... ). Section 3.1 contains more informa\u00adtion \nabout contracts. The write operation at (1) is correct provided that: (a) i = 0, and that (b) WB(a) - \n4 * i = 4.We prove (a) using the Intv abstract domain, which infers the loop invariant i = 0.We prove \n(b) using the Strp abstract domain, which propagates the entry state WB(a) - 4 * len = 0 to the loop \nentry point, discovering the loop invariant WB(a) - 4 * (i + 1) = 0.  2.2 Callee checking Methods such \nas InitToZero that use unsafe pointers are typically internal to the .NET framework and accessible only \nthrough safe wrappers such as FastInitToZero shown in Fig. 2. This code casts the parameter array of \nint toapointer to int,and then invokes InitToZero. Thispatternofa safe wrapper around unsafe pointer \nmanipulating code is perva\u00adsive in the .NET framework. Using our analysis together with method pre-conditions \nallows us to validate that callers into the framework cannot cause unintended memory access via the internal \npointer operations. In this example, Clousot .gures out that at line 4 of Figure2theinvariant WB(a)= \n4 * arr.Length holds, which is enough to prove the pre-condition of InitToZero. In order to track af.ne \nlinear equalities as above, we use the abstract domain of LinEq. The combination of Strp, Intv and LinEq \nallows us to precisely analyze memory accesses in unsafe code without turning to expensive (exponential) \nabstract domains. 1 static public unsafe void FastInitToZero( int [] arr) 2 { 3 .xed ( int* a = arr) \n4 { 5 InitToZero(a, (uint) arr .Length); 6 } 7 } Figure 2. A recurrent code pattern in mscorlib.dll: \nan array is manipulated by taking a pointer to it, and the ele\u00adments are accessed directly to avoid the \nruntime overhead of bounds checking. The fixed statement pins an object, avoidingittobemovedbythegarbage \ncollector. 2.3 Interaction with the operating system Unsafe code is also necessary for interfacing with \nthe un\u00adderlying operating system. Consider the code in Fig. 3. FastCopy uses the CopyMemory method from \nthe Win32 API to copy the values of the array s into the array p. FoxTrot allows attaching out-of-band \ncontracts to assem\u00adblies,andinparticularto annotateexternal calls.Forthesake of presentation,wemadethe \nout-of-band contractexplicitin a proxy method. The precondition for CopyMemory, informally stated in \ntheWin32 documentation,is formalizedin CopyMemoryProxy. It requires that (a) the destinationbuffer is \nlarge enough to hold szsrc bytes;(b)thetwobuffers are de.nedatleaston the memory regions accessedby CopyMemory. \nClousot can then statically check the right usage of the API. For instance, it checks that FastCopy satis.es \nthe precondition, provided that the length of the destination array is not strictly smaller than the \nsource. Discussion: Application to security. The example shows the relevance of our analysis to enforce \nsecurity. Unsafe code in the .NET framework is a potential security risk if it is exploitable from safe \nmanaged code. Analyses such as Clousot provide more con.dence that the managed to unmanaged transitiondoesnotexposetheframeworktosuch \nattacks. The same technique could be applied at the Java to native boundary which exhibits the same problems. \n 2.4 Inheritance When combined with inheritance, unsafe code can make the code fragile because of implicit \n(or informal) contracts in the application. The example in this section shows how the combination of \nFoxTrot with Clousot can make the existing code more robust at almost no extra-cost. Consider the class \nin Fig. 4, extracted from the names\u00adpace System.Text, part of mscorlib.dll. The method GetBytes encodes \na set of characters into a sequence of bytes.For performance reasons it uses pointers and it is de\u00adclared \nunsafe. It can be directly invoked by clients of the library (it is a public method of a public class), \nor internally by the library itself. [DllImport( kernel32. dll )] unsafe static extern void CopyMemory(char* \npdst, char* psrc, int size ); static unsafe private void CopyMemoryProxy(char* pdst, char* psrc, int \nszdst , int szsrc ) { Contract.Requires(szdst >= 0 &#38;&#38; szsrc >= 0); Contract.Requires(szdst >= \nszsrc); Contract.Requires( Contract.WritableBytes(pdst) >= szdst*sizeof(char)); Contract.Requires( Contract.WritableBytes(psrc) \n>= szsrc*sizeof(char)); CopyMemory(pdst, psrc, szsrc ); } public unsafe static void FastCopy(char[] d, \nchar [] s) { Contract.Requires(d.Length >= s.Length); .xed (char* pdst =d,psrc =s) { CopyMemoryProxy(pdst, \npsrc, d.Length, s.Length); }} Figure 3. An example illustrating the invocation of the Win32 API. FoxTrot \ncan produce out-of-band contracts for CopyMemory, but we made them explicit as a proxy. Clousot checks \nthat FastCopy respects theprecondition, provided that d.Length >= s.Length. As a consequence, nobufferoverrun \noccurs, making potentially dangerous code safe. This method is inherently dangerous for two main rea\u00adsons. \nFirst, the client of the library can pass wrong param\u00adeters, e.g. charCount can be larger than the memory \nallo\u00adcated for chars, causingabufferover.ow.Itisthe respon\u00adsabilityofthe callertokeep charCount in sync \nwith the re\u00adgion for chars. The .NET BaseClass Library (BCL) makes sure that pointers and indexes are \ncorrect when GetBytes is invoked internally(e.g. Fig. 5). Third-party code should obey the informal documentation, \nbut it cannot easily de\u00adtect that an overrun has occured, as no exception is thrown (e.g.,unlikeArrayOutOfBoundsException \nfor arrayover\u00ad.ows). Second, GetBytes is virtual, so clients can create a sub\u00adclass of Encoding,overrideGetBytes,and \npass an instance ofittotheBCL.Abuggy rede.nitionof GetBytes can com\u00adpromise the stability of the runtime, \neven if the caller has passed the correct parameters. For instance the BCL may contain some internal \ncode that looks like the one in Fig. 5. When invoked with an instance of Buggy (de.ned in Fig. 6), 1 \npublic abstract class Encoding 2 { 3 public virtual unsafe int GetBytes(char* chars, 4 int charCount, \nbyte* bytes , int byteCount) 5 6 7 { if (bytes == null || chars throw new Exception(); == null) 8 9 if \n(charCount < 0 || byteCount < 0) throw new Exception(); 10 11 char [] arrChar = new char[charCount]; \n12 13 for ( int index = 0; index < charCount; index++) 14 // Possible bu.er overrun 15 arrChar[ index] \n= chars[index ]; 16 17 // ... rest of the methdod omitted ... 18 19 }// ... rest of the class omitted \n... 20 } Figure 4. An example extractedfrom the .NET Base Class Library (BCL). The method GetBytes has \ntwo potential .aws:(a)Abufferoverrunat line15if charCount is larger than the length of the buffer chars \nand (b) it makes the client code fragile, by enabling overriden methods to do whateverthey want with \nthe chars and the bytes pointers. As GetBytes is also called internallyin the BCL,abugin the overriden \nmethod may compromise the stability of the whole platform. private unsafe void UseGetChars(Encoding e) \n{ char* chars = stackalloc char [16]; char* myPrivateData = stackalloc char[32]; // ... init myPrivateData \n... byte* localBu.er = stackalloc byte [16]; e.GetBytes(chars, 16, localBu.er , 16); // ... } Figure \n5. An example of the use of GetChars. The pro\u00adgrammer is carefull in passing the right length for the \nbuffers, but he cannot protect himself from wrong imple\u00admentations of GetChars which can corrupt the \nlocal state, for instancebyoverwritingthe contentof myPrivateData. the .rst byte of myPrivateData isoverwritten, \ncompromis\u00ading the integrity of the private state of UseGetChars. We can make the code more robust by \nadding suitable memory safety contracts and use Clousot to enforce them statically. First, it is worth \nnotingthat when executed on the class in Fig. 4 as-is, Clousot complains about a possible overrun at \nline 15. Therefore we add the following contract 1 class Buggy : Encoding 2 { 12 } 3 override public \nvirtual unsafe 4 int GetBytes(char* chars, int charCount, 5 byte* bytes , int byteCount) 6 7 { for( int \nindex = 0; index <= charCount; index++) 8 9 { chars [index ] = a ; // An o.-by-one 10 11 }} Figure6. \nAsubclass ofEncoding which hasabug that pro\u00adduces a buffer overrun. When an instance is passed as ac\u00adtual \nparameter for UseGetChars, it corrupts the local state. Clousot reports that Buggy.GetBytes violates \nthe inher\u00adited contract. to the method: Requires(WritableBytes(chars) = charCount * sizeof(char)). Under \nthis precondition, Clousot automaticallyveri.es: (a) that the body of Encoding.GetBytes does not cause \nany overrun; and (b)UseGetChars in Fig.5estabilishes the pre\u00adcondition for GetBytes. This is now checked \nstatically and automatically, without relying on the programmer s good will to obeythe documentation. \nSince FoxTrot contracts are inherited, Clousot points outtheoff-by-onebugat line9,in Fig. 6. The programmer \nof Buggy can then correct thebug. Discussion. Even if Clousot can help to make the code more robust, \nit cannot solve the fragility introduced by the use of public virtual unsafe methods.One solutionistoavoid \ntheir use. Another would be to use Clousot during class loading to statically check whether it respects \nthe necessary contracts or not. 3. Background Weprovide some background material onFoxTrot,Clousot, and \nabstract interpretation. 3.1 Foxtrot FoxTrot is a language independent solution for contract speci.cations \nin .NET. It does not require any source lan\u00adguage support or compiler modi.cation. Preconditions and \npostconditions are expressed by invocations of static meth\u00adods(Contract.Requires and Contract.Ensures)at \nthe start of methods. Class invariants are contained in a method with an opportune name (ObjectInvariant) \nor tagged bya special attibute([ObjectInvariant]). Dummy static methods are used to express meta-variables \nsuch as e.g. Contract.Old(x) for the value in the pre-state of x or  Figure 7. Clousot architecture \n Contract.WritableBytes(p) for the length of the mem\u00adory region associated with p. These contracts are \npersisted to MSIL using the standard source language compiler. Contracts in the FoxTrot notation (using \nstatic method calls) can express arbitrary boolean expressions as pre\u00adconditions and post-conditions. \nWe expect the expressions to be side effect free (and only call side-effect free methods). We use a separate \npurity checker to optionally enforce this. A binary rewriter tool enables dynamic checking. It ex\u00adtracts \nthe speci.cations and instruments the binary with the appropriate runtime checks at the applicable program \npoints, taking contract inheritance into account. Most FoxTrot con\u00adtracts can be enforced at runtime, \nhowever contracts using Contract.WritableBytes(... ) are a notable exception. We do not dynamically check \nfor buffer overruns as there is no easy way to obtain the writable extend of a pointer at runtime. For \nstatic checking, FoxTrot contracts are presented to Clousot as simple assert or assume statements. E.g., \na pre-condition of a method appears as an assumption at the method entry, whereas it appears as an assertion \nat every call-site. 3.2 Clousot Clousot is a generic, language agnostic static analyzer based on abstract \ninterpretation for .NET. It is generic in that it presents a pluggable architecture: analyses can be \neasily addedby providing animplementationofa suitable abstract domain interface. It is language agnostic \nas it an\u00adalyzes MSIL. All the programming languages in .NET emit MSIL: Using the debug information we \ncan trace back the resultsofthe analysistothe source program. Clousot has a layered structure as shown \nin Fig. 7. Each layer on the left presents an increasingly abstract view of the code. An MSIL reader \nsits at the lowest level, which presents a stack-based view of the code. Above that sits the FoxTrot \nextractor, which turns thedummy method callsexpressing pre-and post-conditions into actual representations \nof these, seperating them from the method body. ldstack.i duplicate i-th value on evaluation stack ldresult \nload the current result value assert assume begin old evaluate next instructions in method pre-state \nend old switch back to state at matching begin old Table 1. MSIL+ synthetic instructions The layer labeled \nMSIL+ represents an extension of MSIL with a number of synthetic instructions that allow us to express \nallcontract code as simple stack instructions, similarto MSIL.Theextensionsused are listedinTable1. Instruction \nldstack.i is a generalization of a typical dup instruction that allows one to access values on the evalua\u00adtion \nstack that are not at the top. This instruction is useful for example to access the parameters inside \na pre-condition inserted at a call-site. The ldresult instruction is used in post-conditions to refer \nto the result of the method. The meaning of assert and assume is equivalent for run-time checking: theyboth \nresultinfailureif the conditionisfalse. For static checking, they differ in that the checker tries to \nvalidate an assert condition and issues an error if it cannot be proven. However, the static checker \nsimply adds the con\u00addition of an assume to its knowledge base without trying to validate it. The next \nlayers in the Clousot infrastructure (1) get rid ofthestackbyprovidingaviewofthecodeinthe 3-address form \n(the direct analysis of a stack-based language is hard and error-prone,[17]);(2) abstractawaytheheapbyprovid\u00ading \na view of the code as a scalar program, where aliasing has been resolved (a common approach to separate \nheap\u00adanalysis and value analysis, e.g. [5, 21]); and (3) reconstruct (mostofthe)expressionsthathavebeenlostduringthe \ncom\u00adpilation (large chunks of expressions are vital for a precise static analysis [22]). On top of this \ninfrastructure we build particular analy\u00adses, such as the one presented in this paper regarding unsafe \nmemory accesses. Such analyses arebuilt out of atomic ab\u00adstract domains(e.g. Intv, LinEq, Pntg [23]), \na set of generic domains(e.g. .nite set of constraints), and a set of operators on abstract domains(e.g. \nthe reduced cartesian product [9], the functional lifting). As a consequence Clousot allows building \nnew and powerful abstract domains by re.nement and composition of existing ones.  3.3 Basics of Abstract \nInterpretation Abstract interpretation is a theory of approximations [8]. It formalizes the intuition \nthat semantics are more or less pre\u00adcise depending on the observation level. The more precise the abstract \nsemantics, the more precise the properties about the execution of the program it captures. A static analysis \nis an abstract semantics which is rough enough to be com\u00adputable, and precise enough to capture the properties \nof in\u00adterest. The design of an abstract interpreter involves: (i) the design of an abstract domain; (ii)the \ndesign of a widening operator; (iii) the design ofthe transfer functions. Abstract Domains An abstract \ndomain D \u00af isacomplete lattice \\E, ., ., T, U, n), where E is the set of abstract elements, ordered according \nto the relation .. The order relation . can be thought of as an abstraction of the logical implication \n[30]. The smallest abstract element is ., the largest is T. The join is U, and the meet is n.With a slight \nabuse of notation, we will confuse an abstract domain D \u00af with the set of its elements E. The elements \nof an abstract domain are related to the concrete domain D (also a complete lattice), by means of a monotonic \nconcretization function . . [D \u00af . D].We will . denote it by D .- D\u00af . If . is a complete n-morphism, \nthen there exists an abstraction function a . [D . D\u00af], mapping concrete elements to their best abstract \nrepresentation, [8]. In this case, we have a Galois connection between D and D\u00af , . .-- \u00af which we denote \nby D --.D. In this paper we assume the a concrete domain to be the complete boolean lattice P(S), where \nS is the set of concrete program states. Abstract domains can be systematically re.ned to aug\u00ad \u00af ment \ntheir precision, [9]. Given two abstract domains, D1 and D\u00af 2, their reduced cartesian product is D\u00af \n1 . D\u00af 2, whose elements are pairs which satisfy the reduction condition: \u00af\u00af .\\d\u00af 1, d2). D\u00af 1.D\u00af 2..D\u00af1.\u00af(\\d\u00af \n1, d2)) . .\u00af(d\u00af 1)n.\u00af(d\u00af 2) . D2 D1 D2 Widening operator Most of the abstract domains used in practice \ndo not satisfy the ascending chain condition (ACC), so that the least .x\u00adpoint computation on such domains \nmay not terminate. A widening operator is then used to extrapolate the sequence limit. Stated otherwise, \nit enables dynamic approximation. \u00af Formally, a widening operator v . [D \u00af \u00d7 D \u00af . D] is such \u00af\u00af that \n. \u00af d1, d2 . D\u00af . d1.d\u00af 1vd\u00af 2 and d\u00af 2.d\u00af 1vd\u00af 2 and for allthe \u00af\u00af increasing chains d0. ... dn. ... \nthe increasing chain de\u00ad \u00af .ned as w\u00af0 = d0,... w\u00afi+1 = w\u00afivd\u00af i+1 is not strictly in\u00adcreasing. Then, \nthe upward .xpoint iterations with widening will converge to a post-.xpoint[8]. Transfer functions Given \nan abstract domain D\u00af, a transfer function t\u00af. [D \u00af . \u00af D] is an overapproximation of the concrete semantics \nt . [P(S) . P(S)], i.e. it satis.es the soundness relation .d \u00af . \u00af D.t ..(d\u00af) . . .t\u00af(d\u00af). Note that \nin general we do not require to have the most precise (complete) transfer function, just a sound (yet \nprecise) approximation. The Intv abstract domain The elements of the abstract domain of intervals, Intv \n[8], belong to the set {[i, s] | i, s . Z . {-8, +8}}. The concretization function, .Intv . [Intv . P(Z)] \nis de.ned as .Intv([i, s]) = {z . Z | i = z = s}. The order is in\u00adterval inclusion, the bottom element \nis the empty interval istr ::= T* p = stackalloc T[exp] | fixed(T * p = &#38;x + exp) { istr }| x = *(p \n+ exp) |*(p + exp) = x | istr;istr Table 2. uMSIL:an idealized version of the MSIL instructions that \nare peculiar to direct memory access.T denotes a type, p a pointer, x a variable, exp a side-effects \nfree expression. (i.e., an interval where s<i), the largest element is the line [-8, +8]. The join and \nthe meet are respectively the union and the intersection ofintervals. Intv does not satisfy theACC, soa \nwideningoperatoris required. The traditional widening on intervals preserves the bounds which are sta\u00adble, \n[8]. Example (Widening of Intv) Let us consider the code in Fig. 1. The abstract values that the indexing \nvariable i as\u00adsumes during the .xpoint iterations formastrictly increasing chain: [0, 0] [0, 1] [0, 2] \n[0, 3] ... The wideningkeepsthe stable bound(thelower bound),and extrapolates the unstable bound (the \nupper bound) to +8. A further iteration suf.ces to prove that i . [0, +8] is a .xpoint, and hence a loop \ninvariant. nU The abstract domain of interval environments, Boxes, is the functional lifting of Intv, \ni.e., Boxes =[Vars . Intv]. The lattice operations are hence the functional extension of those de.ned \non a single interval. The concretization of a box, .Boxes . [Boxes . P(S)] is de.ned as .Boxes(f)= {s \n. S |.x.x . f =. s(x) . .Intv(f(x))}. The transfer functions for the assignmentand the boolean guards \nin the interval environment are de.ned as usual in interval arithmetic, [7]. The complexity of the operations \nand transfer functions is linear in the number of variables n:O(n). In the sequel, we will not distinguish \nbetween Intv and Boxes. The LinEq abstract domain The elements of the LinEq abstract domain [18, 27] \nare sets of af.ne linear equalities over rationals:  L . Pai * xi = b | ai,b . Q. i The meaningisgivenbythe \nconcretization .LinEq . [LinEq . P(S)]:  .LinEq(L)=s . S |ai * s(xi)= b, =b.Li i ai *xi therefore elements \nof LinEq are af.ne sub-spaces. The order is sub-space inclusion, the bottom is the empty space, the top \nis the whole space, the join is the smallest space which contains the two arguments, the meet is space \nintersection. LinEq satis.es theACC condition, so that the joinsuf.ces to ensure analysis termination. \nThe complexity of the do\u00admain operations and transfer functions is subsumed by the complexity of the \nGaussian reduction that is used to provide a canonical representation for the equations. Therefore it \nis O(n3). 4. Syntax and Concrete Semantics We present an idealized and simpli.ed subset of MSIL, uMSIL.We \nde.ne its transition semantics. The concrete se\u00admantics is instrumentedto trace the region of allocated \nmem\u00adory associated withapointer.Wetreat out-of-region memory accesses as errors. 4.1 Syntax We focus \nour attention on the MSIL instructions that are particular to our unsafe analysis. Thus, we do not discuss: \n(a) instructionsthat are standard such as jumps, assignments, method invocations, etc. (b) issues that \nare orthogonal to the unsafe code analysis, such as the precise handling of tests, expressions re.nement, \netc. We refer the interested reader to [22]. The instruction set we consider, uMSIL, is shown in Tab. \n2.T* p = stackalloc T[exp] allocates exp elements of type T on the stack. In .NET, memory can be allocated \nin the heap in two ways : (a) use the new keyword to allocate an object or (b) directly call the underlying \noperating sys\u00adtem(e.g. by using the HeapAlloc Win32 API). In general, thegarbage collectoris freeto move \nheap allocated objects. However, the construct fixed(T * p =&#38;x + exp){istr} (a) setsa pointer p to \nthe address &#38;x + exp;and (b)pins the variable p during the execution of the sequence of instruc\u00adtions \nistr, to prevent thegarbage collector from moving it. The instruction x = *(p + exp) reads the value \nat address p + exp and stores its value in x whereas *(p + exp)= x stores at the address p + exp thevalue \nof x. Finally,we have instruction sequencing. 4.2 Concrete domain Let Vars be a set of variables, let \nAdd be a set of addresses, Nbethesetof numericalvalues(notethat Add . N)andO a specialstate standingfora \nprogramerror.For eachvariable v . Vars weexpressby WB(v) the number of bytes on which itisde.ned(ifitisnotapointer,the \ndomainwouldnot trace information about it). We let WB(Vars)= {WB(v) | v . Vars} and VarsWB = Vars . WB(Vars). \nThe domain of concrete execution states is C = ([VarsWB . N] \u00d7 [Add . Byte] \u00d7 Add) .{O} Aconcrete state \nis either: (a) a tuple consisting of an envi\u00adronment f mappingvariablestovalues,amemory g mapping n = \neval(exp, (f, g)),n = 0 (a, g') = alloc(T, n, g) eval(exp, (f, g)) < 0 f' = f [p . a][WB(p) . n * sizeof(T)] \nC[T * p = stackalloc T[exp]](f, g, t) . O C[T * p = stackalloc T[exp]](f, g, t) . (f', g', t) WB(p) . \ndom(f),n = eval(exp, (f, g)),n = 0 WB(p) ./dom(f) . eval(exp, (f, g)) < 0 . f(WB(p)) = sizeof(x)+ n * \nsizeof(*p) ' f(WB(p)) < sizeof(x)+ eval(exp, (f, g)) * sizeof(*p) g= write(g, f(p)+ n * sizeof(*p), \nsizeof(*p), f(x)) *(p + exp)= x](f, g, t) . O *(p + exp)= x](f, g, t) . (f, g', t) C[C[ WB(p) . dom(f) \nn = eval(exp, (f, g)),n = 0 f(WB(p)) = sizeof(x)+ n * sizeof(*p) WB(p) ./dom(f) . f(eval(exp, (f, g))) \n< 0 . v = read(g, f(p)+ n * sizeof(*p), sizeof(x)) f(WB(p)) < sizeof(x)+ eval(exp, (f, g)) * sizeof(*p)= \nf[x . v] f' C[x = *(p + exp)](f, g, t) . O C[x = *(p + exp)](f, g, t) . (f', g, t) var is a T array f' \n = f [p . f(var)+(eval(exp, (f, g))) * sizeof(T)] [WB(p) . (eval(var.length - exp, (f, g))) * sizeof(T)] \nt' = t .{f(var)} C[istr](f', g, t') . (f'', g'', t'') C[istr1 ](f, g, t) . O C[fixed(T * p =&#38;var \n+ exp){istr}](f, g, t) . (f'', g'', t) C[istr1 ; istr2 ](f, g, t) . O var is a string f' = f [p . f(var)+(eval(exp, \n(f, g))) * 2] [WB(p) . (eval(var.Length - exp, (f, g))) * 2] t' = t .{f(var)} C[istr](f', g, t') . (f'', \ng'', t'') C[istr1 ](f, g, t) . (f', g', t') '''' C[fixed(T * p =&#38;var + exp){istr}](f, g, t) . (f'', \ng, t}) C[istr1 ; istrs2 ](f, g, t) . C[istr2 ](f' , g , t) Figure 8. The concrete transition semantics. \nalloc, eval, sizeof are auxiliary functions for handling memory allocation, evaluation of pure expressions \nand obtraining the size of variables and types. O is a the error state, which blocks the computation. \naddresses to bytes, and a set t of addresses of objects pinned for thegarbage collector, or(b)the specialvalue \nO denoting that an error has occurred.  4.3 Concrete transition semantics Figure8formally de.nes the \nconcrete transition semantics. We use some auxiliary functions: (1)eval(exp, (f, g)) eval\u00aduates a side-effect \nfree expression exp in state (f, g); (2) alloc(T, n, g) returns a pair \\a, g') where a is the starting \nad\u00addressofafreshlyallocatedregionof g containing n elements of type T, and g' is the modi.ed memory; \n(3) write(g, a, n, v) returns the updatedmemory g[a + i . v[i] | i . [0,n)], v[k] denotes the k-th signi.cant \nbyte of v;(4)read(g, a, n) reads n bytes from memory g and returns them packed as an integer; (5) sizeof(T) \nand sizeof(x) return the length, ex\u00adpressed in bytes, respectively of an element of type T and of the \nvariable x. The description of the transitions in Fig.8 follows. The semantics for stackalloc .rst evaluates \nexp. If it is neg\u00adative, it fails. Otherwise, it allocates a new region, sets a pointer for it to p and \nrecords the length of the region, ex\u00adpressed in bytes, in WB(p). A write operation *(p + exp)= x stores \na number of bytes equal to the size of the type of x in the memory location p + exp * sizeof(*p). If \nthe region for p does not contain at least sizeof(x)+ exp * sizeof(*p) bytes, a buffer overrun occurs, \ndenoted by the error state O. The read operation is analogous. The semantics for fixed is de.ned according \nto the type of var. In thetwocases, (a) p willpointtoamemoryaddress that is obtained by combining the \naddress value f(var) and the offset exp * s, where s is the size of the elements; (b) the address of \nthe pinned object f(var) is added to the set of pinned objects during the execution of st. As for the \nlength of the memory regions associated with p: when var is (a) an array, then the size of the memory \nregion associated with p is given by the length of the array minus the offset of the .rst element times \nthe size of an element; (b) a string, then p will point to an element to the internal representation \nof the string as an array of char, and the length of the memory regions is computed accordingly. The \nsemanticsofa sequenceof instructionsisthe compo\u00adsitions of the semantics, unless the result is O. In \nthis case, the error state is propagated. 5. Abstract Semantics We derive our analysisbystepwise abstraction, \n[7]. First, we abstractaway thevalues read and written trough pointers and the aliasing introduced by \nthe fixed instruction. Then, we Figure 9. The abstract transition semantics for uMSIL: concrete values \nand pinned variables have been abstracted away. eval is the lifting of eval to handle T. We assume = \nand + to be T-strict: e.g. T= n = n =T = T. !(b) is de.ned as !(false) =!(T)= true and !(true)= false. \nO? is the unknown state, which causes the computation to block, signaling that an erroneus memory access \nhas happened. \u00af !(eval(exp, f) = 0) A[T * p = stackalloc T[exp]](\u00aff) . O? \u00af !(eval(exp, f) = 0) . WB(p) \n./dom(\u00aff). \u00af !(\u00aff(WB(p)) = sizeof(x)+ eval(exp * sizeof(*p), f)) A[*(p + exp)= x](\u00aff) . O? \u00af !(eval(exp, \nf) = 0) . WB(p) ./dom(\u00aff). \u00af !(\u00aff(WB(p)) = sizeof(x)+ eval(exp * sizeof(*p), f)) A[x = *(p + exp)](\u00aff) \n. O? var is T array \u00af' \u00af \u00af f = f[WB(p) . eval(var.length - exp, f) * sizeof(T)] \u00af'' ' f = A[istr](\u00aff \n) A[fixed(T * p =&#38;var + exp){istr}](\u00aff) . \u00aff '' var is a string \u00af \u00aff ' = f[WB(p) . (eval(var.Length \n- exp, \u00aff)) * 2] \u00aff '' = A[istr](\u00aff ' ) A[fixed(T * p =&#38;var + exp){istr}](\u00aff)= \u00aff '' \u00af eval(exp, \nf) = 0 \u00af' \u00af\u00af f= f [WB(p) . eval(exp, f) * sizeof(T)] ' A[T * p = stackalloc T[exp]](\u00aff) . f\u00af\u00af WB(p) . \ndom(\u00aff) eval(exp, f) = 0 \u00af\u00af f(WB(p)) = sizeof(x)+ eval(exp * sizeof(*p), f) A[*(p + exp)= x](\u00aff) . \u00aff \n\u00af WB(p) . dom(\u00aff) eval(exp, f) = 0 \u00af\u00af f(WB(p)) = sizeof(x)+ eval(exp * sizeof(*p), f) A[x = *(p + exp)](\u00aff) \n. \u00aff A[istr1 ](\u00aff) . O? A[istr1 ; istr2 ](\u00aff) . O? A[istr1 ](\u00aff) . \u00aff ' A[istr1 ; istr2 ](\u00aff) . A[istr2 \n](\u00aff ' ) derivea generic analysis for checkingbufferoverruns. The analysis is parameterized by the numerical \nabstract domain used to evaluate region indices. 5.1 Abstracting away the values 5.1.1 The domain We \npreserve just the information on memory regions. We abstract away the second and the third component \nof C, and we project the .rst component onto the memory regions, i.e. WB(Vars). The abstract domain is \nC \u00af =([WB(Vars) . N . {T}]) .{O?}.We add (a) T to model values that are abstractedaway, (b) O? to modela \nsetof concrete states that may contain the error state O.  5.1.2 The abstract transition semantics The \nabstract semantics is in Fig. 9. The abstract function eval lifts its concrete counterpart to handle \nT. T values occur for instance when exp contains a variable x whose value is read through a pointer and \nwe do not trace the value for x. eval simply propagates T through all strict operator positions, e.g., \neval(5 + T,f)= eval(T,f)= T. The semanticsisalittlebit morethanthe projectionofthe concrete semantics \non its .rst component: if eval(exp,f)= T, then we cannot decide if exp = 0 and henceifabuffer overrun \nhas occured. In this case, we force the transition to the O? state, which means thatabufferoverrun may \noccur. For thefixed instruction, we abstractaway(a) thefact that the object is pinned: in our abstract \nsemantics we do not needtomodelthegarbage collector;(b)thealiasing between p and &#38;var + exp: we are \ninterested just in checking that memory accesses are valid.  5.1.3 Abstraction and concretization function \nThe concretization function returns the set of all the concrete states such that the .rst component is \ncompatible with one of the abstract states. If the abstract state contains the unknown state O?, then \nall the concrete states are returned, included the error state O. As a consequence, in order to show \nthat a program has no memory access violations, it suf.ces to prove thatitsabstract semanticsinFig.9 \nnever reducesto O?. The next two theorems guarantee the soundness of the approach. The .rst states that \nthe abstract elements are a correct approximation of the abstract ones. The second one states that no \nconcrete behavior is forgotten in the abstract semantics. Theorem: Soundness of the abstraction. Let \n. . [P(C\u00af) . P(C)] be the concretization function de.ned as \u00af .(F\u00af) =\u00aff.\u00aff). {(f, g, t) |.WB(p) . dom(\u00af \nf(WB(p))= T F =. f(WB(p)) = \u00af f(WB(p)) . p . dom(f)}.{(f, g, t) | O? . F\u00af }. Then . is a complete n-morphism, \nso that it exists an ab\u00ad . .-- straction function a . [P(C) . P(C\u00af)] such that P(C) --. a P(C\u00af). nU \nFigure 10. The generic abstract semanticsfor memory accessvalidity checking.Itis parameterizedbya numerical \nabstract check(exp = 0,\u00afs)= T check(WB(p) = sizeof(x)+ exp * sizeof(*p), \u00afs)= T .check(exp = 0,\u00afs)= T \nF[*(p + exp)= x](\u00afs) . O? check(WB(p) = sizeof(x)+ exp * sizeof(*p), \u00afs)= T .check(exp = 0,\u00afs)= T F[x \n= *(p + exp)](s) . O? var is a T array \u00afs ' = assign(WB(p), (var.length - exp) * sizeof(T), \u00afs) F[istr](\u00afs \n' ) . \u00afs '' F[fixed(T * p =&#38;var + exp){istr}](\u00afs) . \u00afs '' var is a string \u00afs ' = assign(WB(p), (var.length \n- exp) * 2,\u00afs) F[istr](\u00afs ' ) . \u00afs '' F[fixed(T * p =&#38;var + exp){istr}](\u00afs) . \u00afs '' domain endowed \nwith two primitives: assign and check. Theorem: Soundness of the abstract semantics. Let \u00af f . C\u00af , (f, \ng, t) . .(\u00af f) and ist . uMSIL. If A[ist](\u00af f) . \u00af f ' and ' '' C[ist](f, g, t) . (f ' , g , t '), then \n(f , g , t ') . .(\u00af f '). nU  5.2 Generic memory access analysis If we extend uMSIL with (conditional) \njumps, e.g. to enable loops, then the abstract semanticsin Fig.9will no longerbe computable. In particular, \nthe expressions used for memory accessesmayevaluateto in.nitely manyvalues.Asa conse\u00adquence, in order \nto cope with a more realistic scenario, we need to perform a further abstraction, to capture the values \nof index expressions. We assume a numerical domain N \u00af which correctly ap\u00ad .\u00af N proximates P(C\u00af) (\\P(C\u00af), \n.) .- \\ N\u00af , .)) and with two \u00af primitives: (a) assign(x, exp, s) . N which is (an over\u00adapproximation \nof) the assignment x := exp in the abstract state s (. N\u00af); (b) check(exp, s) .{true, T} which checks \n\u00af whether, in the abstract state s (. N), the expression exp holds(true)orit cannotbe decided(T). The \ngeneric abstract semantics for checking memory safety, parameterizedby N \u00af is reported in Fig. 10. 6. \nThe right numerical abstract domain The generic abstract semantics in Fig. 10 can be instantiated with \nany numerical abstract domain containing the primi\u00adtives assign and check. As a consequence the problem \nof checking the validity of memory accesses boils down to the problem of chosing the right abstract domain. \nExisting numerical domains can be classi.ed according to their precision/cost ratio. The ideal of a static \nanalysis is check(exp = 0,\u00afs)= true \u00afs ' = assign(WB(p), size * sizeof(T),\u00afs) F[T * p = stackalloc T[exp]](\u00afs) \n. \u00afs ' check(WB(p) = sizeof(x)+ exp * sizeof(*p),\u00afs)= true check(exp = 0,\u00afs)= true F[*(p + exp)= x](\u00afs) \n. \u00afs check(WB(p) = sizeof(x)+ exp * sizeof(*p),\u00afs)= true check(exp = 0,\u00afs)= true F[x = *(p + exp)](\u00afs) \n. \u00afs F[istr1 ](\u00afs) . O? F[istr1 ; istr2 ](\u00afs) . O? F[istr1 ](\u00afs) . \u00afs ' F[istr1 ; istr2 ](\u00afs) . F[istr2 \n](\u00afs ' )  to use the least expensive domain which is precise enough to prove the property of interests. \nLet us consider the set of points A of Fig. 11(a) corre\u00adsponding to all the possible values that WB(p) \nand index as\u00adsume at some memory access c = *(p + index). Geometri\u00adcally,thememory accessissafeasallthe \nconcretevaluesare included in the upper-right quadrant delimeted by the lines index = 0 and WB(p)= base \n+ index * sizeof(*p). Prov\u00ading it using an abstract domain A \u00af requires inferring an ab\u00adstract element \n\u00afa . A \u00af such that A . .(\u00afa) . R. Fig. 11(b) shows that Intv alone is not precise enough for our purposes: \nthe best approximation for A with Intv is not completely included in R. Intuitively, this is because \nIntv does notkeep relational information, e.g., anyrelation between WB(p) and index is abstracted away. \nWeakly-relational numerical abstract domains such as Octagons [26] or Pentagons [23] have been introduced \nas lightweight solutions for array bounds checking2. Fig. 11(c) shows that Octagons are more precise \nthan Intv, but they arestillnotpreciseenoughtovalidate memory accessesdue to the multiplicative factor \nsizeof(*p) which makes the slopes in Fig. 11 possibly non-45. . Fig. 11(d) showsthat the convexhull CH(A) \nof the points A is included in R. The geometrical interpretation of the elements of the abstract domain \nof Polyhedra(Poly)[10] is exactly their convex hull3. The main drawback of using Poly is its worst case \ncost, which for the most common 2Octagons capture relations in the form \u00b1x \u00b1 y = a, and Pentagons in \nthe form of a = x = b . x < y. 3Polyhedra capture arbitrary linear inequalities among variables: Siai \n\u00b7 xi = b.  (a) Concrete points (b) Intervals, O(n) (c) Octagons, O(n3) (d) Polyhedra, O(2n) in prac-(e) \nStripes.Intervals.LinEq, tice O(n3), O(n) in practice Figure11. The concrete points, and some approximations \ndepending on the numerical abstractdomain. Intervals and Octagons are not precise enough to prove the \nproperty. Polyhedra are precise, but also very expensive: they have an exponential complexity which showsupin \npractice.The reduced productof Stripes.Intervals.LinEq represents a good trade offbetween precision and \ncost: the theoretical complexityis cubic,butin practice weexperienceda linear behavior. operations is \nexponential in time and space (and this is a lower-bound[19]).In Sect.9 wewillprovideexperimental evidence \nthat that the worst case is attained in practice. In Clousot we are interested in the scalability of \nthe analyses. Therefore, we rejected the use of general purpose, precisebutveryexpensiveabstract domains \nsuch as Poly. In\u00adstead, we have chosen a different path, which consists in (a) designing abstract domains \nfocused ona particular property; and (b) combining domains using well-known techniques such as the reduced \nproduct.For our analysis, we designed a new numerical abstract domain, Strp, and we combined it with \nIntv and LinEq to achieve precision without giving up on performance. Fig. 11(e) illustrates the (best) \napproxima\u00adtion for A within the abstract domain Strp . Intv . LinEq, which is included in R. In the next \nsections we present the details of Strp, its re\u00adduction with Intv and LinEq, and the results of our practical \nexperiments. 7. The Stripes abstract domain We introduce a novel, weakly-relational domain Stripes, Strp, \nfocused on the inference and checking of (upper boundson) memory accesses that usea base,an index,anda \nmultiplicativefactor.We de.ne the order, thejoin, the meet and the widening operators. 7.1 Constraints \nAs a .rst approximation, Strp captures constraints of the form WB(p)-sizeof(T)*(count[+base]) >k where \nWB(p), count, and optionally base are variables, T is a type, and k is an integer constant.The intuition \nbehind it is that the pointer p is de.ned at least on count[+base] elements of its type, and on k additional \nbytes. In practice, these constraints are used in a more generic way: the .rst element may be anyvariable \n(and not only the writable bytes of a pointer) and the sizeof(T) may be any numerical value (and not \nonly the size of the type of the pointer target). Then the constraints captured by the Stripe domain \nare z - k1 * (x[+y]) >k2. 7.2 Abstract domain structure Abstract elements We representStrp elements as \nmaps from variables to con\u00adstraints.Wehave chosenmapsastheyallowef.cientmanip\u00adulation of directional \nconstraints: Strp =[VarsWB . P((VarsWB \u00d7 (VarsWB ..) \u00d7 N\u00d7 N))]. Intuitively, the domain of the map contains \nthe variable z, the .rst and second component of the 4-tuple represent the two variables x and y (. if \nit is not present), the third com\u00adponent is k1 and the last one is k2. Example (Representation of stripes \nconstraints) The two constraints z-4*y > 0 and z-2*(x+u) = 5 are represented in Strp by the map [z .{(y, \n., 4, 0), (x, u, 2, 4)}]. nU Order An abstract state \u00afs1 in Strp is more precise than \u00afs2 iff for each \nconstraint in \u00afs2, \u00afs1 contains a constraint such that (a) the three variables and the integer constant \nk1 are the same; and (b) k2 is less or equal than the k2 of \u00afs2 since if x > y and y > z then x > z by \ntransitivity of >.Formally: \u00afs1 \u00afs2 .. .z . dom(\u00afs2), .(y, x, k1, k2 2) . \u00afs2(z). z . dom(\u00afs1) . .(y, \nx, k1, k1 2) . \u00afs1(z).k2 2 = k1 2 Top and Bottom The largest element of Strp is a map with no information: \n.z. \u00d8. An abstract state \u00afs is bottomiffit containsa contra\u00addiction: e.g. [z .{(y, ., 1, 0)}, y .{z, \n., 1, 0)]. Join The upper bound operator (a)keeps the constraints that are de.ned in both operands; (b) \ntakes the smallest lower bound k2 if it is different in the two constraints since if exp >a, exp >b and \na = b then exp >b is an upper bound for both constraints.Formally: \u00afs1 U \u00afs2 = .z.{(y, x,k1,k2) | (y, \nx,k1,k1) . \u00afs1(z), 2(y, x,k1,k2) . \u00afs2(z),k2 = min(k21 ,k2)}. 22 Meet The lower bound operator traces \nthe constraints of both operands.Ifboth containaconstraintwiththe samevariables x,y,andz,and the same \nintegervaluek1,the operatorkeeps the largest integervalue forthe numericallower bound. .. .. (y, x,k1,k2) \n| (y, x,k1,k1) . \u00afs1(z), 2 (y, x,k1,k2 s2(z), \u00afs1 n \u00afs2 =.z. ) . \u00af 2 .  7.3 Re.nement of the abstract \nstate A state of the Stripe domain may be internally re.ned, by carefully propagating information between \nconstraints. Example (Re.nement of constraints) Consider the two stripes constraints x - 2 * (y + u) \n> 4 and y - z > 0. From the .rst constraint we derive: x-2*(y+u) > 4 .. x-2*u-4 > 2*y .. x/2-u-2 > y. \nFrom the second constraint we derive that y > z .. y = z +1. Combining the two, we derivea new stripe \nconstraint: x/2 - u - 2 > z +1 .. x - 2 * (u + z) > 6. nU The above example can be easily generalized: \n Lemma (Saturation) If an abstract state contains the two constraints x - k1 * (y[+u]) >k2 y - 1 * z \n>k3 then we can infer the constraint x -k1 *(z[+u]) >k2 + k1 * (k3 + 1). nU The re.nement enabled by \nthe lemma above is important in practice. It allows adding new constraints to the abstract . state, \nwithout requiring an expensive closure to propagate k2 = max(k21 ,k2) 2 the information. Of course, \nLemma 7.3 does not guarantee the completenessofthe saturation,butitissuf.centfor our purposes, as illustratedbythe \nnextexample. . . . . . . . (y, x,k1,k2) | ((y, x,k1,k2) . \u00afs1(z). (y, x,k1, ) . \u00afs2(z)) .z. . ((y, x,k1,k2) \n. \u00afs2(z). (y, x,k1, ) . \u00afs1(z)) Example (Saturation) Let us consider the example in . . . . Fig. 1. \nInside the loop, we have the abstract state \u00afs = Widening Strp does not satisfy theACC condition.Asa \nconsequence, we need to de.ne a widening operator to ensure conver\u00adgence. Our widening simply drops the \nconstraints that are not stable between two iterations: \u00afs1v\u00afs2 = .z.\u00afs1(z) n \u00afs2(z). Concretization \nThe concretization function .Strp . [Strp . P(C\u00af)] returns all the possible states that satisfy the constraints \nrepresented by the abstract state: .Strp(\u00afs)= {\u00af f |.z . dom(\u00afs).(y, x,k1,k2) . \u00afs(z). \u00af f(z) - k1 * \n(\u00af f(y)+ \u00af f(x)) >k2}. It is immediate to see that .Strp is monotonic, and fur\u00adthermore thatitisa complete \nn-morphism. Therefore, as the composition of monotonic functions is monotonic, the fol\u00adlowing theorem \nstating that Strp is a sound approximation holds: Theorem (Abstraction) .Strp as de.ned above is a com\u00adplete \nn-morphism. Therefore, it exists an aStrp such that .Strp .---- \\P(C\u00af), .) ----. \\Strp, .) . As a consequence, \n\\P(C), .) aStrp...Strp .----- \\Strp, .). Un- ----. aStrp.a {WB(a) - 4 * len > -1, len - i > 0} 4. We \nhave to check whether WB(a) = 4 * i +4.We cannot do it directly by inspecting \u00afs as there is no direct \nrelation between WB(a) and i. Applying the re.nement of Lemma 7.3, we infer the constraint WB(a) - 4 \n* i > 3 which suf.ces to validate the access: WB(a) - 4 * i > 3 .. WB(a) > 4 * i +3 .. WB(a) = 4 * i \n+4 . nU In our implementation we perform this re.nement only on-demand when we need to check the proof \nobligations. 7.4 Transfer functions Assignment When an expression is assigned to a variable, we .rst \ndrop all the constants that are de.ned on the assigned variable, and then we add some inferred constraints.Formally: \n' assign(x, exp,\u00afs) =let \u00afs = drop(x,\u00afs) in \u00afs ' . C(x, exp,\u00afs '). where drop(x,\u00afs)= .y.{(z, u,k1,k2) \n| y = x, (z, u,k1,k2) . \u00afs(y)=. z = x . u = x}; 4To simplify the reading, we present a stripe abstract \nstate as a set of constraints. and C infers new constraints from an assignment and an abstract state. \nFew representative cases for C follow. In our implementationwe consideraricher structureofexpressions \nand cases. C(x, y,\u00afs) =[x . \u00afs(y)]. [v1 .{(x, v2 ,k1,k2) | (y, v2 ,k1,k2) . \u00afs(v1 )}] C(x, u + v,\u00afs)= \n[v1 .{(u, w,k1,k2) | (x, .,k1,k2) . \u00afs(v1 )}] ... Abstract checking To check a boolean expression, we \n.rst try to normalize it into a form like x - k1 * (y[+z]) >k2, and then we check if the abstract state \ncontains a constraint which implies it. Formally: check(exp,\u00afs)= let(x - k1 * (y + z) >k21,b)= normalize(exp) \nin if (b ..(y, z,k1,k2) . \u00afs(x).k21 = k2) then true else T 22 We skip the details of normalize. Roughly, \nit applies basic arithmetic identities to rewrite the expression. If it fails to put the expression into \na stripe constraint form, it returns a booleanvalue signaling thefailure. 8. Re.ned Abstract Semantics \nWe re.ne the information captured by theStrp domain with Intv and the LinEq domain. Intv is needed to \ncheck lower bounds of accesses. LinEq is needed to track linear equali\u00adties, and in particular to handle \nthe compilation schema for fixed in C#. 8.1 Checking lower bounds of accesses Strp allows representing \njust partial numerical bounds on variables. In fact, when k1 =0, a stripe constraint boils down to a \nnumerical lower bound: z >k2. Nevertheless, in general we need to track numerical upper bounds on variables: \nThose may appear in expressions that must be evaluated to check under-.ow accesses.We use Intv to track \nthe numerical bounds on variables. Example (Need for numerical bounds) Let us consider the following \ncode snippet( ... denotes an arbitrary boolean expression): int *p; ... // suppose that WB(p) = 12, a \n= 5 if (...) {b =3; }else { b =4; } *(p +(a-b)) = 0; // (*)  If we track just lower bounds, at (*) we \nhave a > 4, b > 2, so that we cannot prove the memory access correct. If we track both numerical bounds, \nat (*) we have that a =5, b . [3, 4], so that b - a . [1, 2] which suf.ces to prove the access correct. \nnU The numerical abstract domain for the analysis is the product domain Intv . Strp. All the domain operations \nare lifted pair-wise to the product domain. Sometimes we may want to use the information contained in \nIntv to re.ne the information in Strp.For instance, to improve the precision of the join operator, as \nshown by the next example. Example (Re.nement of Strp with Intv) Consider the fol\u00adlowing piece of code: \nint [] array ; ... // suppose that array.Length - count > 0 if (count == 0) array = new int[1]; else \n/* do nothing */ ; Using just Strp, at the join point we cannot conclude that array.Length - count > \n0:inside the conditional,array is assigned a new value, so that the entry constraint is dropped. Using \nIntv . Strp, the abstract state after array creation is p\u00af1 = \\\\count . [0, 0], array.Length . [1, 1]),.z. \n\u00d8); the abstract state at the end of the false branch is p\u00af2 = \\\u00d8, [array.Length . (count, 1, 0)]). The \njoin is \\\u00d8, [array.Length . (count, 1, 0)]), as the interval compo\u00adnent of p\u00af2 implies that array.Length \n- count > 0. Un 8.2 Compilation of fixed When the C# compiler compiles a fixed statement which assigns \nan array arr of type T[] to a pointer p, it generates code to check whether the arr is null orifits lengthis0.If \nit is the case, then it assigns null to p. Otherwise it assigns the address of the .rst element of arr \nto p. Fig. 12 depicts this compilation schema. Without anyre.nement, the analysis performedbyClousot \ncannot capture that WB(p)= sizeof(T)*array.length.Two main reasonsforthat:(1)itisnotpossibleto representacon\u00adstraint \nin the form of x - a * y =0 in Intv . Strp;(2) At the if ( arr == null) p= null; else if (arr .Length \n== 0) p= null; else p = &#38;arr[0]; Figure 12. The (schema of the) code generated by the C# compiler \nfor the statement fixed(T * p = arr) ... when arr is an array. Assembly #Methods Time #AChecked ccesses \nValidated % mscorlib.dll 18 084 3m43s 3069 1835 59.79 System.dll 13 776 3m18s 1720 1048 60.93 System.Data.dll \n11 333 3m45s 138 59 42.75 System.Design.dll 11 419 2m42s 16 10 62.50 System.Drawing.dll 3120 19s 48 29 \n60.42 System.Web.dll 22 076 3m19s 88 44 50.00 System.Windows.Forms.dll 23 180 4m31s 364 266 73.08 System.XML.dll \n10 046 2m41s 772 311 40.28 Average 57.96 Table 3. The results of our analysis tested on the .NET assemblies \nwithout using anycontract. The average analysis time is of 12ms per method. join point, a state where \np is null is merged with one where WB(p)= sizeof(T) * array.length. For (1), we re.ne the abstract domain \nto use LinEq, to retain linear equalities: the abstract domain used in the anal\u00adysis becomes LinEq . \nIntv . Strp. For (2), if arr = null or arr. Length = 0, then 0 = sizeof(T)* array.Length = WB(p) trivially \nholds. As we are performing an over-approximation of the reachable states, we can safely add WB(p)= sizeof(T)*array.length \nto our abstract state. 9. Experiments We have implemented the analysis for unsafe memory ac\u00adcesses using \nthe Stripes domain in Clousot.We have ex\u00adtensively tested our analysis on all the libraries of the .NET \nframework. Our experiments were conducted on a 2.4Ghz Intel Core Duo laptop, with 4Gbytes of RAM, running \nWindowsVista(Windows processor score 5.3). The target assemblies are taken from the %WINDIR%\\ Microsoft\\ \nFramework\\ v2.0.50727 directory of the test laptop. No pre-processing, manipulation or .ltering of the \nassemblies has been conducted. A primary goal for Clousot is its use at development time during compilation \nor even within the integrated devel\u00adopment environment. Thus, the performance of the analysis is crucial. \nOur specialized domains provide us withexcellent performance as reportedinTab.3. The analysisisfast:theaverage \nanalysis timeper method is 12ms.Wevalidate onaverage 57.96% of the unsafe mem\u00adory accesses. This may \nnot seem high at .rst glance. How\u00adever, consider theburdenof human code reviews for unsafe code which \nis currently a necessary practice. Our analysis cuts down the work load in half, focussing the reviews \non accesses that seem non-obvious to prove correct. Neverthe\u00adless, we feel that we can improve the precision \nof the unsafe analysis in two ways: 1.We intendto remove short-comingsinthe current imple\u00admentation of \nthe domains, resulting in unnecessary pre\u00adcision loss or inability to provefacts thatare implied.We intend \nto improve the domains as described e.g., in Sec\u00adtion 7.3. 2. The code we analyzed does not contain contracts. \nThis leads to loss of precision when the proof obligation re\u00adquired in one method is established by the \ncaller of the method, or sometimes several call frames higher on the stack. As a consequence, without \ncontracts on the in\u00adtermediate methods Clousot reports warnings on those memory accesses. We are actively \nworking on adding contracts to eventu\u00adally validate all memory accesses. Furthermore, to simplify checkingofWindowsAPIuses,weplanto \nwritea toolto convert SAL annotations [15] into FoxTrot annotations. In Section 9.2 we discuss the results \nof manually inspecting the warnings for System.Drawing.dll andformulating neces\u00adsary contracts. 9.1 Comparison \nwithPolyhedra The main claim of our work is that specialized domains targettingaparticular setof proof-obligations \nare required to make such analyses practical. If we were able to use off-the\u00adshelf solvers for more powerful \ndomains, such as Polyhedra, specialized domains would not be necessary. We used our experience with the \nPolyhedra implementation used to infer loop invariants in Boogie [2], to evaluate the cost of using Polyhedra \nfor the analysis of unsafe MSIL code. Although this implementation of Polyhedra is not as optimized as \nfor example [1], it has been well debugged and in use for a number of years. In our experiment, we replaced \nthe Strp . Intv . LinEq domain in our analysis with the Polyhedra domain implementation of Boogie and \nran it on the two largest libraries in .NET. The results are showninTable4. Asis apparent fromthe timings, \nthe Polyhedra domainis orders of magnitude slower than our implementation using Strp.In our runs, we \nuseda2 minute timeout per method. The timeoutwas reached23 times on mscorlib.dll and 13 times on System.dll.Inallfairness,theParma \nlibrary[1]is likelytobemuchfasterthanthe implementationof Polyhe\u00addra we used. However, it is unlikely \nto consistently improve Table 4. Unsafe code analysis usingthe Polyhedra domain #Accesses Assembly Time \nChecked Validated % mscorlib.dll 125m52s* 3070 1610 52.46 System.dll 257m27s* 1576 744 44.94 the execution \nby two orders of magnitude and it would still suffer from exponential behavior on some methods where \nthe2minute timeoutwas reached.When removingthe time\u00adout, one method in mscorlib.dll took 49 minutes to \nreach a .xpoint using Polyhedra.  9.2 System.Drawing case study We analyzed the 19 warnings in System.Drawing.dll \nto determine what contracts need to be written to avoid them, or whether theyrepresent true vulnerabilities. \nFirst, we found the use of two helper methods that re\u00adquired pre-conditions: short GetShort(byte* ptr) \n{Contract.Requires(Contract.WritableBytes(ptr) >= sizeof(short)); ... int GetInt(byte* ptr) {Contract.Requires(Contract.WritableBytes(ptr) \n>= sizeof(int)); ... These helper methods simply load 16 bits or 32 bits from the given pointer location \nusing little-endian encoding and avoiding unaligned accesses. With the pre-conditions written as above, \nClousot no longer reports warnings within these helper methods. In\u00adstead, it reports warnings at 26 call-sites \nto these methods. The remaining warnings are all located within 5 distinct methods. 1. One method uses \nan unmanagedheap allocation routine to obtain memory from the marshal heap. Writing an appropriate post-condition \nfor this allocator eliminates the warnings in that method. public static IntPtr AllocHGlobal(int cb) \n{Contract.Ensures(Contract.WritableBytes( Contract.Result<IntPtr>()) == cb); ... 2. The next method we \nexamined actually contained an error leadingtobufferoverrunsonread accesses. 3. The third method uses \na complicated invariant on a data structure that involves indexing using a product expres\u00adsionoftwovariables.Our \ndomains cannotcurrently track such products (only variables multiplied with constants). However, the \ncode appears to be safe.  4. The fourth method extracts a byte[] from an auxiliary data structure and \nindexes it assuming the array contains 1K elements. Examining the data structure and all its construction \nsites,we determined thatitisbuiltvia mar\u00adshalling from an unmanagedWindows API call and the marshal annotation \nspeci.es that thebuffer is to be allo\u00adcated with the .xed size of 1K. Although we can specify this size \nas an object invariant on the auxiliary structure leading to the removal of the warning by Clousot, our \ntool chain does not yet understand the marshalling con\u00adstraints establishing the invariant. 5. Finally, \nthe last function containing most of the accesses and calls to the helper functions GetShort and GetInt, \nwhose pre-conditions mustbevalidated,exposeda short\u00adcoming in our implementation. Upon examination, we \ndetermined that the analyzer infers a suf.ciently strong loop invariant which implies the safety of the \nmemory accesses and pre-conditions. However, our implementa\u00adtion was not able to show this implication \nautomatically.  With the above contracts and .xes, Clousot would vali\u00addate3additional methods,but reportfalsewarningsin \none method due to an index expression we cannot handle, and another false warning in a new method due \nto the lack of support for marshal annotations. 9.3 Summary Overall,the analysisisfastenoughtouseinintegrateddevel\u00adopment \nenvironments. It achieves a higher level of automa\u00adtionand scalability thanexisting tools.Infact,we found \nthat the tool rarelyfails to infer the necessary loop invariants to validate the memory accesses. More \noften, it is the lack of contracts that limits our modular intra-procedural analysis. The useof contracts \nnot only allows reducing thefalse pos\u00aditive rate, the contracts furthermore serve as checked docu\u00admentation \non important safety invariants. Clousot can catch code changesor additions thatfailtoliveuptotheexisting \nspeci.cations and thereby provideexcellent static regression checking. 10. Related work In addition to \nthe work cited in the introduction, we wish to place our work in the context of the following other related \nwork. Bounds analysisforC Rinardand Rugina publishedapowerful analysisofCpro\u00adgrams to determine aliasing, \nbounds, and sharing of memory, enabling bounds optimizations, andparallelization [28, 29]. Their analysis \ninfersasetof polynomial boundsonvariables that are solved using a linear programming problem to min\u00adimize \nthe spread of the bound. The reported analysis times arefast (in the same range as ours),but theyonly \nreport re\u00adsults for small examples. Their technique based on solving a linear programming problem is \nquite different from using symbolic abstract domains,but equally promising.Abene.t of their approach \nis that it performs inter-procedural analysis by inferring relations for function inputs and outputsusinga \nbottomup call graph approach.However,thisis alsoa major drawback, as for strongly connected components \nof func\u00adtions (recursively calling each other), their analysis needs to compute a .xpoint. It is well \nknown that call-graphs built forverylarge applications(in particular object-orientedpro\u00adgrams)are imprecise,leadingtoverylarge \ncomponents[11], making such an approach unlikely to scale. Das et. al. describebufferover.owchecking \nand anno\u00adtation inference on large Microsoft C/C++ code bases [15]. Few details of the used numerical \ndomains are public,but from the paper it is apparent that for precision, their analysis performs path \nsplitting, meaning it analyzes paths separately through a function whenever the abstract state at join \npoints disagrees. The Stripes domain described in this paper and the associated transfer functions and \njoin operations are geared towards providing precision without path splitting (our ana\u00adlyzer does not \nperform path splitting). Analysis of JNI A few analyses for Java handle programs using the Java Native \nInterface (JNI) [20]. Furr andFoster in [14] present a restricted form of dependent types used to infer \nand type\u00adcheck the types passed to foreign functions via the JNI. Tan et al. proposed a mixed dynamic/static \napproach to guarantee type safety in Java programs that interface with C.We are not interested in type \nsafety: in unsafe C#, type errors are less common than with the JNI, since the unsafe context is integrated \nin C#, so that (a) the compiler can still perform most type checking and (b)types do not need to be serialized \nas strings (the most common type error in using the JNI). Instead our analysis focuses directly on memory \nusage via pointers, whereaspreviouswork did not. Interoperability of languages Recentwork focuses on \nlanguage interoperability.Tan and Morrisett, [33], advocate an approach in which the Javabyte\u00adcode language \nis extended with a few instructions useful to modelC code. Hirzel and Grimm,[16], take an alternative \napproach with Jeannie, whichisa language which subsumes JavaandC,andtheburdenofcreatingthe right JNIforin\u00adterfacing \nthe two languages is left to the compiler. Matthews and Findler, [24], give an operational semantics \nfor multi\u00adlanguage programs which uses contracts as glue for the inter\u00adoperating languages. The MSIL \ninstruction set is rich enough to allow an agile compilation of several languages: our anal\u00adysis, working \nat the MSIL level does not need to take into account inter-operability issues. Static analyzers ESC/Java2[6]andSpec#[4]use \nautomatic theoremprovers to check programs. Automatic theorem provers provide a strong engine for symbolic \nreasoning(e.g. quanti.ers han\u00addling). The drawbacks are that: (a) theyrequire the program\u00admer to provide \nloop invariants and (b) theypresent scalabil\u00adity problems. Analysis times close to the one we obtain \nin Clousot on shipped code are well beyond the state-of-the artin automatic theoremproving. 11. Conclusions \nWe presenteda new static analysis for checking memory ac\u00adcesses in unsafe code in .NET. The core of the \nanalysis is a new abstract domain, Strp, which combined with Intv and LinEq, allows the analysis to scale \nto hundreds of thousands of lines of code.We have proven the soundness of the ap\u00adproach by designing \nthe static analysis using stepwise ab\u00adstraction of a concrete transition semantics. References [1] R. \nBagnara, P.M. Hill, and E. Zaffanella. The Parma Polyhedra Library. http://www.cs.unipr.it/ppl/. [2] \nM. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs, and K.R.M. Leino. Boogie:A modular reusable veri.erfor \nObject-Oriented programs. In FMCO 05. Springer-Verlag, November 2005. [3] M. Barnett, M. F\u00a8 Foxtrot and \nahndrich, and F. Logozzo. Clousot: Language Agnostic Dynamic and Static Contract Checking for .Net. Technical \nReportMSR-TR-2008-105, Microsoft Research, Redmond,WA,August 2008. [4] M. Barnett, K.R.M. Leino, and \nW. Schulte. The Spec# programming system: An overview. In CASSIS 2004, 2004. [5] G.P. Brat andA.Venet. \nPrecise and scalable static program analysis atNASA. In IEEE Aerospace Conference. IEEE, 2005. [6] D. \nR. Cok and J. Kiniry. ESC/Java 2: Uniting ESC/Java and JML. In CASSIS 2004, 2004. [7] P. Cousot. The \ncalculational design of a generic abstract interpreter. In Calculational System Design. NATO ASI SeriesF. \nIOS Press, Amsterdam, 1999. [8] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed lattice model \nfor static analysis of programs by construction or approximation of .xpoints. In POPL 77. ACM Press, \nJanuary 1977. [9] P. Cousot and R. Cousot. Systematic design of program analysis frameworks. In POPL \n79, pages 269 282.ACM Press, January 1979. [10] P. Cousot and N. Halbwachs. Automatic discovery of linear \nrestraints among variables of a program. In POPL 78.ACM Press, January 1978. [11] Manuvir Das. Uni.cation-based \npointer analysis with directional assignments. In Proceedings of the ACM SIGPLAN 2000 Conference on Programming \nLanguage Design and Implementation (PLDI-00), pages 35 46.ACM, 2000. [12] N. Dor, M. Rodeh, and M. Sagiv. \nCleanness checking of string manipulations inCprograms via integer analysis. In SAS 01, LNCS. Springer-Verlag, \nJune 2001. [13] N. Dor, M. Rodeh, and M. Sagiv. CSSV: towards a realistic tool for statically detecting \nall buffer over.ows in c. In PLDI 03.ACM Press, 2003. [14]M.FurrandJ.S.Foster. Polymorphictype inferenceforthe \nJNI. In ESOP 06. Springer-Verlag, April 2006. [15]B.Hackett,M.Das,D.Wang,andZ.Yang. Modularchecking forbufferover.owsin \nthe large. In ACM ICSE 06.ACM Press, 2006. [16] M. Hirzel and R. Grimm. Jeannie: granting Java native \ninterface developers their wishes. In OOPSLA 07.ACM, October 2007. [17] R. N. Horspool and J.Vitek. Static \nanalysis of postscript code. In ICCL 92. IEEE, 1992. [18] M. Karr. On af.ne relationships among variables \nof a program. Acta Informatica, 6(2):133 151, July 1976. [19] L. Khachiyan, E. Boros, K. Borys, K. M. \nElbassioni, and M. Gurvich. Generating all vertices of a polyhedron is hard. In ACM SODA 06.ACM Press, \n2006. [20] S. Liang. Java Native Interface: Programmer s Guide and Speci.cation. Sun Microsystems, 2001. \n[21] F. Logozzo. Cibai: An abstract interpretation-based static analyzerfor modular analysisandveri.cationofJavaclasses. \nIn VMCAI 07. Springer-Verlag, January 2007. [22] F. Logozzo and M. A.F\u00a8ahndrich. On the relative complete\u00adness \nof bytecode analysis versus source code analysis. In CC 08, LNCS. Springer-Verlag, March 2008. [23] F. \nLogozzo and M. A. F\u00a8ahndrich. Pentagons: A weakly relational abstract domain for the ef.cient validation \nof array accesses. In ACM SAC 08 -OOPS.ACM Press, March2008. [24] J. Matthews and R. B. Findler. Operational \nsemantics for multi-language programs. In POPL 07.ACM, January 2007. [25] B. Meyer. Object-Oriented Software \nConstruction (2nd Edition). ProfessionalTechnical Reference. Prentice Hall, 1997. [26] A. Min\u00b4 e. The \noctagonabstract domain. In WCRE 2001. IEEE Computer Society, October 2001. [27] M.M\u00a8uller-Olm andH. Seidl.A \nnote on karr s algorithm. In Springer-Verlag, editor, ICALP 04, LNCS, 2004. [28] R. Rugina and C. R. \nRinard. Symbolic bounds analysis of pointers, array indices, and accessed memory regions. In Proceedings \nof theACM SIGPLAN 2000 Conference on Programming Language Design and Implementation (PLDI\u00ad00), volume \n35.5 of ACM Sigplan Notices, pages 182 195, N.Y., June 18 21 2000.ACM Press. [29] R. Rugina and M. C. \nRinard. Symbolic bounds analysis of pointers, array indices, and accessed memory regions. ACMTransactionsonProgramming \nLanguagesand Systems, 27(2):185 235, 2005. [30] D. A. Schmidt. The internal and external logic of abstract \ninterpretations. In VMCAI 08. Springer-Verlag, January 2008. [31] A. Simon and A. King. Analyzing stringbuffers \nin c. In AMAST 02, LNCS. Springer-Verlag, September 2002. [32] A. Simon, A. King, and J. Howe. Two variables \nper linear inequality as an abstract domain. In LOPSTR 02, LNCS. Springer-Verlag, September 2002. [33] \nG.Tan andG. Morrisett. Ilea: inter-language analysis across java and c. In OOPSLA 07.ACM, October 2007. \n[34] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken. A .rst step towards automated detection of \nbuffer overrun vulnerabilities. In NDSS 00, 2000.     \n\t\t\t", "proc_id": "1449764", "abstract": "<p>The .NET intermediate language (MSIL) allows expressing both statically verifiable memory and type safe code (typically called managed), as well as unsafe code using direct pointer manipulations. Unsafe code can be expressed in C# by marking regions of code as <i>unsafe</i>. Writing unsafe code can be useful where the rules of managed code are too strict. The obvious drawback of unsafe code is that it opens the door to programming errors typical of C and C++, namely memory access errors such as buffer overruns. Worse, a single piece of unsafe code may corrupt memory and destabilize the entire runtime or allow attackers to compromise the security of the platform.</p> <p>We present a new static analysis based on abstract interpretation to check memory safety for unsafe code in the .NET framework. The core of the analysis is a new numerical abstract domain, Strp, which is used to efficiently compute memory invariants. Strp is combined with lightweight abstract domains to raise the precision, yet achieving scalability.</p> <p>We implemented this analysis in Clousot, a generic static analyzer for .NET. In combination with contracts expressed in FoxTrot, an MSIL based annotation language for .NET, our analysis provides <i>static</i> safety guarantees on memory accesses in unsafe code. We tested it on all the assemblies of the .NET framework. We compare our results with those obtained using existing domains, showing how they are either too imprecise (<i>e.g.</i>, Intervals or Octagons) or too expensive (Polyhedra) to be used in practice.</p>", "authors": [{"name": "Pietro Ferrara", "author_profile_id": "81385592815", "affiliation": "Ecole Polytechnique, Paris, France and Universit&#224; C&#225; Foscari, Italy", "person_id": "P1223204", "email_address": "", "orcid_id": ""}, {"name": "Francesco Logozzo", "author_profile_id": "81100572523", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P1223205", "email_address": "", "orcid_id": ""}, {"name": "Manuel F&#228;hndrich", "author_profile_id": "81100288438", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P1223206", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449791", "year": "2008", "article_id": "1449791", "conference": "OOPSLA", "title": "Safer unsafe code for .NET", "url": "http://dl.acm.org/citation.cfm?id=1449791"}