{"article_publication_date": "10-19-2008", "fulltext": "\n Join Patterns for Visual Basic Claudio V. Russo Microsoft Research Ltd., Cambridge, U.K. crusso@microsoft.com \nAbstract We describe an extension of Visual Basic 9.0 with asyn\u00adchronous concurrency constructs -join \npatterns -based on the join calculus. Our design of Concurrent Basic (CB) builds on earlier work on Polyphonic \nC# and C.. Since that work, the need for language-integrated concurrency has only grown, both due to \nthe arrival of commodity, multi-core hardware, and the trend for Rich Internet Applications that rely \non asynchronous client-server communication to hide latency. Unlike its predecessors, CB adopts an event-like \nsyntax that should be familiar to existing VB programmers. Coupled with Generics, CB allows one to declare \nre-useable concurrency abstractions that were clumsy to express pre\u00adviously. CB removes its ancestors \ninconvenient inheritance restriction, while providing new extensibility points useful in practical applications \nthat must co-exist with or want to exploit alternative threading models available on the plat\u00adform. CB \nis implemented as an extension of the production VB 9.0 compiler. Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language constructs and features Concurrent programming structures;control \nstructures; classes and ob\u00adjects General Terms Languages Keywords Visual Basic, join patterns, asynchronous \nmes\u00adsage passing. 1. Introduction This paper presents Concurrent Basic (CB), an extension of Visual Basic \n9.0 (11) with asynchronous concurrency con\u00adstructs -join patterns -derived from the join calculus (5). \nThe name CB is a deliberate pun on the channel-based Citi\u00adzen s Band radio popular in Basic s heyday. \nOur motivation Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 08, October 19 23, 2008, Nashville, Tennessee, USA. Copyright c &#38;#169; 2008 ACM 978-1-60558-215-3/08/10. \n. . $5.00 is to let VB rise to the occasion of both parallel program\u00adming on multi-core hardware, and \ndistributed programming of Rich Internet Applications, using asynchronous commu\u00adnication to hide latency. \nUnlike its C# based predecessors, Polyphonic C# (4) and C. (12), CB adopts an accessible, event-like \nsyntax that should be familiar to modern VB pro\u00adgrammers. By exploiting Generics in Visual Basic, CB \nal\u00adlows one to declare parametric, thus reusable, concurrency abstractions that were awkward to express, \nless ef.cient and less safe in the original C# proposals: these pre-dated Generics and had to resort \nto expensive boxing and failure\u00adprone casts. CB offers more natural support for inheritance, enabling \na subclass to augment the set of patterns declared on inherited channels: the C# variants forced users \nto copy existing patterns into the subclass, breaking encapsulation. CB also provides novel, semi-declarative \nhooks to let users control the execution of patterns as an ad-hoc, yet impor\u00adtant, concession to manual \noptimization and the integration with other concurrency frameworks available on the plat\u00adform. The CB \ncompiler is an extension of the production Visual Basic 9.0 compiler that generates code for the Com\u00admon \nLanguage Runtime (CLR) with performance similar to C#. Our compiler is available both from the command-line \nand from within Visual Studio. Although less fashionable amongst researchers, Visual Basic is hugely \npopular. Having evolved into a statically typed, class-based object-oriented language there is very lit\u00adtle \nto distinguish VB 9.0 from C# 3.0. Both support Gener\u00adics, type inference, language integrated query \n(LINQ), and lambda expressions. Where they currently differ is in C# s support for CLU-style iterators, \nunsafe code, and lambda statements. VB, for its part, provides optional and named ar\u00adgument passing, \nC.-style XML literals, dynamic typing and late-binding (runtime member resolution). Interestingly, one \nof the features that has distinguished VB and C# from the start is VB s support for declarative event \nhandling. Events support a simple publish/subscribe model: a class publishes some internally raised events \nthat zero or more, typically unknown, subscribers can handle. While both languages let you de.ne event \nmembers, only VB allows a method to declare that it handles some named events -C# users have to add and \nremove event callbacks imperatively. Public Class Document Inherits Form Private WithEvents SaveButton \nAs Button Private WithEvents SubmitButton As Button Public Event Saved( sender As Object, args As EventArgs) \nPrivate Sub CaseSaveOrSubmit( sender As Object, args As EventArgs) _ Handles SaveButton.Click, SubmitButton.Click \nSave this document to disk RaiseEvent Saved(Me, Nothing) End Sub Public Event Submitted( sender As Object, \nargs As EventArgs) Private Sub CaseSubmit( sender As Object, args As EventArgs) Handles SubmitButton.Click \nSubmit this document to the server RaiseEvent Submitted(Me, Nothing) End Sub End Class Figure 1. Declarative \nevent handling in Visual Basic. For instance, a VB GUI application might declare the class Document in \nFigure 1.1 This class publishes two 2\u00adargument events, Saved(s,e) and Submitted(s,e), raised by methods \nCaseSaveOrSubmit and CaseSubmit. Method CaseSaveOrSubmit is a handler that runs whenever the but\u00adton \nin variable SaveButton or SubmitButton raises its Click event.2 This relationship is established by the \nHandles key\u00adword after the method header, followed by a list of qual\u00adi.ed event identi.ers. The Click \nevents (not shown) have the same argument signature as the handler. A single event may have more than \none handler. When the event is raised, all of its handlers are executed, on the raising thread and in \nthe order in which they were added to the event. Here, CaseSaveOrSubmit and CaseSubmit will both run \n(sequen\u00adtially) in response to SubmitButton.Click. Since events may have zero or many registered handlers \nthey are, by design, not allowed to have a return type.3 CB leverages the Basic programmer s familiarity \nwith event-based programming but then turns it on its head. In ad\u00addition to events, a CB class can declare \nchannels on which to receive asynchronous messages and synchronous requests. A method may be declared \nto execute when communication has occurred on a particular set of local channels, forming a join pattern. \nCommunications are queued until or unless some method is enabled and run. More precisely, a message that \nenables some join pattern causes its method to run (on some other thread) otherwise the message is queued \nuntil one of its patterns is enabled; a request that enables some 1 VB is line-based, _ is the line-continuation \nmarker. 2 The WithEvent modi.ers on the button declarations expose their events for event handling. Since \nWithEvent variables are mutable, setting the value of a WithEvents variable implicitly causes its handlers \nto be re\u00admoved from the current value s event and added to the new value s event. 3 VB includes a few \nmore event-related constructs: property-like custom event declarations and imperative AddHandler and \nRemoveHandler statements. We can ignore these for our purposes. join pattern runs its method (on the \nsame thread) otherwise the request blocks until one of its patterns is enabled. Unlike an event handler, \nwhich services one of several alternative events at a time, in conjunction with all other handlers on \nthat event, a join pattern waits for a conjunction of channels and competes for execution with any other \nenabled pattern. Figure 2 is the simplest interesting example of CB, a module declaring a thread-safe, \nunbounded, unordered string buffer. This example presents all three keywords intro\u00adduced by CB: Asynchronous, \nSynchronous and When (which already exists for exception handling). This module declares two channels: \nan asynchronous channel, Put(s), which takes a string argument and (like all asynchronous methods) re\u00adturns \nno result; and a synchronous channel, Take(), which takes no arguments but returns a string. The private \nmethod CaseTakeAndPut is the continuation of a join pattern that can run only When both the Take and \nPut methods have been called. (The name CaseTakeAndPut is arbitrary; as a conven\u00adtion, we choose to derive \nthe name of the continuation from the channels following When.) Suppose several producer and consumer \nthreads wish to communicate via the Buffer module. Producers call Buffer.Put(s) to post a string, without \nblocking. Con\u00adsumers call Buffer.Take() to request a string, possibly blocking. Once Buffer has received \nboth a Put(s) and a Take() the body of CaseTakeAndPut can run, returning the actual argument s of Put \nas the result of the call to Take. Since this is the only applicable pattern, a caller of Take will wait \nuntil or unless a call to Put has arrived. Multiple calls to Take may be pending before a Put is received \nto reawaken one of them, and multiple calls to Put may be queued before their arguments are consumed \nby a subsequent Take. Note that: 1. The body of the continuation runs in the (reawakened) thread corresponding \nto the matched call to Take. Hence no new threads are spawned in this example. Module Buffer Public Asynchronous \nPut( s As String) Public Synchronous Take() As String Private Function CaseTakeAndPut( s As String) \nAs String When Take, Put Return s End Function End Module Figure 2. An unbounded, unordered string buffer \nin CB. 2. The code produced for the Buffer module is completely thread-safe. The compiler generates the \nnecessary lock\u00ading to ensure that channel invocations are consumed atomically. Furthermore, this locking \nis .ne-grained and brief -method CaseTakeAndPut does not lock the en\u00adtire Buffer module during its execution. \nMore generally, continuation methods are not executed with monitor se\u00admantics , acquiring and releasing \ntheir object s lock like Java s synchronized methods. 3. The result of a continuation is returned on \nits syn\u00adchronous channel, of which there can be at most one following When.  In general, a channel may \nbe involved in more than one join pattern, each of which de.nes a different continuation that may run \nwhen the channel is invoked (provided the rest of the pattern is enabled). For example, in the Either \nmodule of Figure 3, calls to Receive synchronize with calls to First or Second. Now we have two asynchronous \nchannels and a synchronous channel that can wait for either one, with a different continuation and argument \ntype in each case. A single join pattern may involve more than one asyn\u00adchronous channel; module Both \nin Figure 4 contains one synchronous join pattern that waits for messages on both First and Second (as \nwell as Receive). Notice that it takes two parameters, one from each channel. A join pattern may also \nbe purely asynchronous, provided its continuation is a subroutine and its When clause only lists asynchronous \nchannels. The pattern CaseAsyncTakeAndPut in Figure 5 spawns a new thread that executes the call\u00adback \nc(i) whenever messages arrive on both AsyncTake and Put (in any order).4 Merging the declarations of \nBuffer and AsyncBuffer would yield a module that supports both syn\u00adchronous and asynchronous consumers. \nThe paper is structured as follows: Section 2 describes our proposal in more detail; Section 3 gives \nmore motivating examples; Section 4 describes our implementation; Section 5 considers two pragmatic extensions \n(custom dispatch of patterns and synchronous rendezvous); Section 6 surveys related work and concludes. \n4 The Delegate declaration de.nes a nominal type, Callback, for .rst\u00adclass methods matching the speci.ed \nsignature. Delegate values are con\u00adstructed by applying VB s AddressOf operator to a named static or \nin\u00adstance method or, in VB 9.0, by writing an anonymous lambda-expression. 2. Detailed Proposal CB extends \nVB with just two new constructs: channels and declarative message handling. The syntactic extensions \nto VB 9.0 (11) appear in Figure 6. Channels are used to synchronize and pass messages be\u00adtween concurrently \nexecuting threads. A channel declaration consists of any optional attributes and access modi.ers, op\u00adtional \nShadows or Shared keyword, followed by keyword Asynchronous or Synchronous, a method signature (iden\u00adti.er, \nparameter list and optional return type) and an op\u00adtional Implements clause. If the channel is Asynchronous, \nit must not have a return type. A channel may not declare type parameters. The parameter list may not \ncontain ByRef, Optional or ParamArray parameters. A channel may not overload another member of the same \nname. Channels may be declared in modules, classes and structs. A channel in a struct must be marked \nShared. A channel may implement an interface method of a matching signature, but there is no spe\u00adcial \nsyntactic support for specifying channels in interfaces. From a client s perspective, a channel just \ndeclares a method of the same name and signature. The client posts a message or issues a request by invoking \nthe channel as a method. Methods can declaratively service requests and consume messages arriving on \nchannels belonging to the same in\u00adstance or type. To do so, a method declaration speci.es the When keyword \nand lists one or more (distinct) chan\u00adnels. A When clause may appear wherever a Handles or Implements \nclause can in the existing VB syntax. A channel in the When list is speci.ed by an identi.er, possibly \npre\u00ad.xed by MyClass, MyBase or Me. The (quali.ed) identi.er must denote a Synchronous or Asynchronous \nchannel de\u00adclared in the containing type of the method or one of its base classes. The When clause of \na Shared method may only men\u00adtion Shared channels, conversely, the When clause of a non-Shared method \nmay only mention non-Shared channels. The argument types of the method must exactly match the con\u00adcatenation \nof the (inherited) argument types of the channels in the When clause. The return type of the method must \nmatch the return type of the .rst channel following When. Only the .rst channel following a When clause \nmay be Synchronous, all subsequent channels must be Asynchronous. A type in\u00adherits all non-Shared When \nclauses provided by its base type. Module Either Public Asynchronous First( s As String) Public Asynchronous \nSecond( i As Integer) Public Synchronous Receive() As String Private Function CaseReceiveAndFirst( s \nAs String) As String When Receive, First Return s End Function Private Function CaseReceiveAndSecond( \ni As Integer) As String When Receive, Second Return i.ToString() End Function End Module Figure 3. Waiting \non a disjunction of channels. Module Both Public Asynchronous First( s As String) Public Asynchronous \nSecond( i As Integer) Public Synchronous Receive() As String Private Function CaseReceiveAndFirstAndSecond( \ns As String, i As Integer) As String _ When Receive, First, Second Return s + i.ToString() End Function \nEnd Module Figure 4. Waiting on a conjunction of channels. Module AsyncBuffer Public Delegate Sub Callback( \ni As Integer) Public Asynchronous AsyncTake( c As Callback) Public Asynchronous Put( i As Integer) Private \nSub CaseAsyncTakeAndPut( c As Callback, i As Integer) When AsyncTake, Put c(i) End Sub End Module Figure \n5. Spawning new tasks. A derived type cannot in any way alter the When clauses it inherits from its base \ntype, but may declare additional ones. Intuitively, a continuation method must wait until/unless a single \nrequest or message has arrived on each of the channels following the continuation s When clause. If the \ncontinuation gets to run, the arguments of each channel invocation are de\u00adqueued (thus consumed) and \ntransferred (atomically) to the continuation s parameters. For this reason, the method s ar\u00adgument signature \nmust be compatible with the concatenation of the argument signature of its channels. Similarly, when \nthe continuation returns, it will return its value to the in\u00advoker of the synchronous channel (if any). \nThus the return type of the continuation must match the return type of any synchronous channel in its \nWhen clause. A type may declare multiple channels and multiple join patterns on subsets of those channels. \nPatterns may (but are not recommended to) specify overlapping sets of channels, in which case the patterns \nwill compete for execution. A subclass may extend its set of inherited channels and/or reference accessible \nchannels of its base classes in its own patterns. The act of invoking a channel may enable zero, one \nor more join patterns involving that channel: If no pattern is enabled then the channel invocation is \nqueued up. If the channel is asynchronous, then this sim\u00adply involves adding the arguments of the invocation \n(the contents of the message) to a queue. If the channel is syn\u00adchronous, then the calling thread is \nblocked, joining a no\u00adtional queue of threads waiting on this channel.  If there is a single enabled \npattern, then the arguments of the channels involved in the match are de-queued, and any blocked thread \ninvolved in the match is awakened to run the join pattern s continuation in that thread. The con\u00adtinuation \nof a join pattern involving only asynchronous channels is run in a newly spawned thread.  ModuleMemberDeclaration \nClassMemberDeclaration StructMemberDeclaration ChannelMemberDeclaration* := := := := . . . | ChannelMemberDeclaration \n. . . | ChannelMemberDeclaration . . . | ChannelMemberDeclaration [Attributes] [ChannelModi.ers+] ChannelSignature \n[ImplementsClause] [StatementTerminator] ChannelSignature* := Asynchronous Identi.er [([ParameterList])] \nChannelModi.ers* HandlesOrImplements WhenClause* |:= := := Synchronous Identi.er [([ParameterList])] \n[As [Attributes] TypeName] AccessModi.er | Shadows | Shared . . . | WhenClause When WhenList WhenList* \n:= ChannelMemberSpeci.er ChannelMemberSpeci.er* |:= WhenList, ChannelMemberSpeci.er Identi.er ||| MyBase.Identi.er \nMe.Identi.er MyClass.Identi.er Figure 6. Required extensions to the VB 9.0 syntax (11); nonterminals \nmarked with * are additions. If several join patterns are enabled, an unspeci.ed one is selected to \nrun.  If multiple calls to one channel are queued up, which call will be de-queued by a match is unspeci.ed. \n The underspeci.cation in this idealized description is de\u00adliberate. While CB s implementation of asynchronous \nmes\u00adsage queues have FIFO semantics, the programmer is not meant to exploit this. In a distributed setting, \nasynchronous calls issued in one sequential order may well arrive in a dif\u00adferent one (due to latency \nand routing effects). The FIFO or\u00adder of synchronous calls (from separate threads) is not guar\u00adanteed \nbecause the underlying CLR/Windows locks used to implement synchronous call queues do not, for performance \nreasons, guarantee deterministic ordering. Finally, in the im\u00adplementation, the message that awakens \na synchronous call may not be the one consumed by it since the message is ac\u00adtually left available in \nthe queue to be stolen by some in\u00adtervening thread; indeed, the awakened thread may have to wait again \nif none of its patterns are enabled by the time it actually wakes up (4). 3. Examples 3.1 Example: A \nOne-Place Buffer The original Buffer module is unbounded: any number of calls to Put could be queued \nup before matching a Take. We now describe a variant in which only a single data value may be held in \nthe buffer at any one time. This time, we de.ne a generic class, OnePlaceBuffer(Of T), to support multiple \ninstances of varying content types T (Figure 7): The public interface of OnePlaceBuffer(Of T) is similar \nto that of Buffer, but calling Put(t) is now synchronous and will block if the buffer is not empty. The \nimplementation of OnePlaceBuffer makes use of two private asynchronous messages: Empty and Contains(t). \nThese are used to carry the state of the buffer and illustrate a very common pro\u00adgramming pattern in \nCB. The class is best understood by reading its code declaratively. When a New buffer is cre\u00adated, it \nis initially Empty(). If someone calls Put(t) on an Empty() buffer then it subsequently Contains(t) and \nthe call to Put(t) returns. If someone calls Take() on a buffer which Contains(t) then the buffer is \nsubsequently Empty() and t is returned to the caller of Take(). Implicitly, in all other cases, calls \nto Put(t) and Take() block. The construc\u00adtor establishes and the patterns maintain the invariant that \nthere is always exactly one Empty() or Contains(t) mes\u00adsage pending on the buffer.  3.2 Example: Futures \nFutures are an established concurrency abstraction used to represent the eventual value of a concurrent \ncomputation. Generic futures with explicit waiting are simple to code up with CB (Figure 8). Creating \na new Future(Of T) from a Computation returning a value of type T (expressed as a del\u00adegate or VB 9.0 \nlambda expression) spawns a new thread to Execute the computation in parallel. When the current (or another) \nthread actually needs the value of the compu\u00adtation it calls a method on the future to Wait until/unless \nPublic Class OnePlaceBuffer(Of T) Private Asynchronous Empty() Private Asynchronous Contains( t As T) \nPublic Synchronous Put( t As T) Public Synchronous Take() As T Private Sub CasePutAndEmpty( t As T) \nWhen Put, Empty Contains(t) End Sub Private Function CaseTakeAndContains( t As T) As T When Take, Contains \nEmpty() Return t End Function Public Sub New() Empty() End Sub End Class Figure 7. A generic, one-place \nbuffer. Public Class Future(Of T) Public Delegate Function Computation() As T Public Synchronous Wait() \nAs T Private Asynchronous Execute(Comp As Computation) Private Asynchronous Done(t As T) Private Function \nCaseWaitAndDone(t As T) As T When Wait, Done Done(t) Return t End Function Private Sub CaseExecute(Comp \nAs Computation) When Execute Done(Comp()) End Sub Public Sub New(Comp As Computation) If Comp Is Nothing \nThen Throw New ArgumentNullException() Execute(Comp) End Sub End Class Figure 8. Generic Futures. the \nworker has .nished the computation and issued Done(t). Between creating the future and obtaining its \nvalue, the cur\u00adrent thread is free to perform other tasks. Notice the use of the asynchronous pattern, \nCaseExecute, to spawn a new thread. The motivation for reposting the consumed Done(t) message in CaseWaitAndDone \nis to allow multiple Waits (i.e. reads) to succeed. Modifying this class to propagate excep\u00adtions thrown \nby Comp, cancellation of Comp or to execute Comp using a thread from the thread pool is straightforward. \nA use\u00adful optimization is to cache the value of Comp() in a private .eld of type T protected by an argument-less \nDone() chan\u00adnel. This would be an improvement because an argument\u00adless asynchronous channel is actually \nrepresented more ef.\u00adciently as a count of pending invocations rather than a heap\u00adallocated queue of \narguments.  3.3 Example: Active Objects Active object or actors are a popular pattern for asyn\u00adchronous \nprogramming (1). Active objects communicate by asynchronous messages that are processed sequentially \nby object-speci.c threads: each active object runs a pri\u00advate event loop. One way of programming active \nobjects in CB is by inheritance from a common base class, the class ActiveObject in Figure 9. Sending \na Start() mes\u00adsage spawns a new thread that loops calling the synchronous channel ProcessMessage() waiting \nuntil or unless the next enabled pattern on ProcessMessage can run. The Halt mes\u00adsage terminates the \nloop. Concrete subclasses of ActiveObject declare additional patterns on the protected ProcessMessage \nchannel, joining it with locally declared asynchronous messages particular to that class. Public Class \nActiveObject Private Done As Boolean Protected Synchronous ProcessMessage() Public Asynchronous Start() \nPrivate Sub CaseStart() When Start While Not Done ProcessMessage() End While End Sub Public Asynchronous \nHalt() Private Sub CaseHalt() When ProcessMessage, Halt Done = True End Sub End Class Figure 9. The \nbase class for an active object. To illustrate, here is an extract from a lift (elevator) sim\u00adulation \nsample written in CB. The sample is derived from the Erlang Lift controller example (1), but we added \nsome animation and people to drive the simulation. In the code, a subclass of ActiveObject is used to \nrepresent each type of agent (lift, cabin, .oor or person) involved in the simulation. Figure 10 contains \nan extract from the Person class. It publishes a GotoFloor() message whose executions, by syn\u00adchronizing \nwith ProcessMessage(), are guaranteed to be se\u00adrialized. Hence there is no need to protect the private \nfloor (and indeed Done) .eld with a lock. Notice the use of inheritance: Person declares an addi\u00adtional \npattern on the inherited ProcessMessage() channel. Similarly, a derived class of Person will inherit \nthis pattern but is free to declare additional channels and patterns. CB s support for inheritance and \nincremental extension of patterns is an important feature that distinguishes it from its predeces\u00adsors \nPolyphonic C# and C. (see Section 6). Although active objects typically communicate asyn\u00adchronously, \nif needed, an object can synchronize with an\u00adother (here floor) by posting, with its message, an explicit \nacknowledgement, a, to wait on (a.Receive() waits for an asynchronous call to a.Send()). The join based \nimplementa\u00adtion of class Ack is trivial and similar to our Buffer module. We will revisit and simplify \nthis code in Section 5.2. Threads are expensive on the CLR; having more than a few hundred ActiveObjects \naround at once will typically exhaust the machine s resources or bring execution to a crawl. However, \nactive objects are not built-in to CB: they are just an example of an abstraction built with join patterns. \nImplementing variants of this abstraction, such as families of active objects that share a thread pool \nfor better scalability, is also possible.  3.4 Example: Parallel Life Another application we developed \nis a simple parallel im\u00adplementation of Conway s Game of Life. The virtual grid of cells is partitioned, \nvertically and horizontally, amongst p\u00d7q concurrent nodes. Each node computes an m \u00d7 n subregion of the \ngrid using a dedicated worker thread. A node main\u00adtains a (double buffered) private array with (m +2) \n*(n +2) cells, overlapping one edge with each neighbour. To syn\u00adchronize, a node repeatedly: posts its \n4 interior edges to its neighbours;  waits to receive 4 exterior edges on 4 separate channels from its \nneighbours;  computes new cell values in parallel with other nodes.  To simplify the algorithm, exterior \nnodes post exterior edges to themselves. Figure 11 outlines the code for a Node (ignoring boundary conditions). \nNodes Up through Left reference neighbouring nodes. The arrays TopBuff through LeftBuff are buffers, \nal\u00adlocated (just once) in New(). The buffers migrate between nodes, but are only owned and modi.ed by \none node at a time. Send copies the node s computed interior edge values into the buffers, before posting \nthem on its neighbours chan\u00adnels. Receive() waits to receive exterior edge values and then copies them \ninto the current subgrid. Relax() computes the next generation of the node s subgrid (code omitted). \nSome observations are in order. Since no subgrids are shared, this algorithm is easy to distribute across \nmachines. All synchronization is local: for this reason, two nodes (x1,y1) and (x2,y2) may be working \non different iterations in parallel, but will never be more than |x1 - x2| + |y1 - y2|iterations apart. \nWaiting simultaneously on four separate channels is both simpler and more ef.cient than waiting for one \nedge to arrive from each neighbour over a single, shared channel. The latter design would require a node \nto wakeup more often and manually queue edges arriving from differ\u00adent neighbours until it had received \nat least one edge from each. Finally, Cell is a type parameter of an enclosing class, so we can reuse \nthis algorithm for different cell types (i.e. automata). Public Class Person Inherits ActiveObject Private \nfloor As Floor Public Asynchronous GotoFloor(f As Floor) Private Sub CaseProcessMessageAndGotoFloor(f \nAs Floor) When ProcessMessage, GotoFloor floor = f Dim a As New Ack() floor.PersonArrived(Me, a) a.Receive() \nChooseDir(floor) End Sub ... End Class Figure 10. A derived active object class representing a person \nin the lift simulation. Class GenericPCA(Of Cell) Class Node ... Private Asynchronous StartWorker() Private \nSub CaseStartWorker() When StartWorker While True Send() Receive() Relax() Relax() computes the next \nsubgrid End While End Sub Private TopBuff, RightBuff, BottomBuff, LeftBuff As Cell() Public Up, Right, \nDown, Left As Node Public Asynchronous TopChan(Edge As Cell()) Public Asynchronous RightChan(Edge As \nCell()) Public Asynchronous BottomChan(Edge As Cell()) Public Asynchronous LeftChan(Edge As Cell()) Private \nSub Send() ... Copy computed edge values from grid into buffers Up.BottomChan(TopBuff) : Right.LeftChan(RightBuff) \nDown.TopChan(BottomBuff) : Left.RightChan(LeftBuff) End Sub Private Synchronous Receive() Private Sub \nCaseReceiveAndEdges _ (TopEdge As Cell(),RightEdge As Cell(), BottomEdge As Cell(), LeftEdge As Cell()) \n_ When Receive, TopChan, RightChan, BottomChan, LeftChan TopBuff = TopEdge : RightBuff = RightEdge BottomBuff \n= BottomEdge : LeftBuff = LeftEdge ... Copy received exterior edge value from buffers into grid End \nSub End Class Figure 11. Nodes of a generic parallel cellular automata class (outline). Running an \ninstrumented version of this code on a work station with 2 quad-core 2.33MHz Intel Xeon chips and 3GB \nof memory (running 32-bit Vista) shows, unsurpris\u00adingly, near linear speedups as we up the number of \nnodes (keeping the overall grid size .xed), up until we exceed the 8-core count. The graph in Figure \n12 plots the ratio between running times of a 1-node sequential and N-node parallel simulation, each \ncomputing a 2048 x 2048 cell grid for 1000 iterations. The nodes are arranged horizontally, halving the \nsubgrid width as we double N. Running times are wall-clock times measured from a master thread as the \ntime between starting the simulation and receiving a .nal done signal from the last node to .nish. The \ngraph plots the speedups averaged over 8 runs, with standard deviation marked using error bars. For a \nfair comparison, the single node simulation is modi.ed to avoid the cost of self-synchronization. Figure \n13 shows a screenshot of a (slower) animated ver\u00adsion -notice the utilization of all 8 cores and that \nneighbour\u00ading nodes may be computing adjacent generations (shown centred in each node). 4. Compilation \nThe CB compiler uses the author s Joins library (14; 15) as a runtime. Consequently, adding join patterns \nto Microsoft s production VB 9.0 compiler (implemented in C++) required relatively modest changes, mostly \nto the front-end of the compiler. Indeed, the implementation closely follows the current implementation \nof events and declarative event han\u00addling. All code is generated as intermediate source code for synthetic \nmembers of various kinds, using pre-existing compiler support. The body of each synthetic member is later \ncompiled to MSIL bytecode by the back end. The syn\u00adthesized source code relies heavily on type inference \nand would be tedious to emit directly as explicitly typed MSIL. 4.1 The Joins Runtime Library This section \ngives a brief overview of the supporting Joins library, with enough detail to support the translation \npro\u00adcess described in later sections. We omit some library fea\u00adtures that are not exploited in the translation. \nThis section is adapted from (14), which describes the full API and its implementation in more detail. \nIn the Joins library, the scheduling logic associated with a CB module, class or struct has a separate, \n.rst-class rep\u00adresentation as an object of a special Join class. It is best to think of a join object \nas a mini-scheduler (or glori.ed lock) responsible for managing its own set of channels and pat\u00adterns. \nInstead of representing channels as special methods belonging to some type, in the library, channels \nare special delegate values (.rst-class methods) obtained from some common Join object. Communication \nand/or synchroniza\u00adtion takes place by invoking these delegates, passing argu\u00adments and optionally waiting \nfor return values. In the library, a join pattern is some code whose execution is guarded by a (linear) \ncombination of distinct channel delegates owned by the same Join object. The continuation of a join pattern \nis provided by the user, not as a method as in CB, but as a delegate. The continuation delegate is free \nto manipulate re\u00adsources external to the Join object simply by accessing the continuation s private target \nobject. Users of Joins reference the assembly Microsoft.Research.Joins.dll and import the namespace Microsoft.Research.Joins. \nA new Join instance j is allocated by calling a factory method: Join.Create(size, allowRedundantPatterns) \nThe integer size bounds the number of channels supported by j; it also sets the constant property j.Size. \nThe boolean allowRedundantPatterns determines whether the join ob\u00adject accepts or rejects patterns declared \non overlapping sets of channels. Its value affects the scheduling of patterns (a round-robin scheduler \nis used if allowRedundantPatterns is True; otherwise, a default .rst-match scheduler is used). CB s compiler \nalways passes True to allow overlapping pat\u00adterns. A Join object notionally owns a set of asynchronous \nand synchronous channels, each obtained by calling an overload of method Initialize, passing the location \nof a channel using a VB call-by-reference (ByRef or C# out) argument: j.Initialize(channel) Channels \nare instances of the following delegate types, summarized by a simple grammar of type expressions: (Asynchronous|Synchronous[(Of \nR)]).Channel[(Of A)]  A channel s outer class, Asynchronous, Synchronous or Synchronous(Of R), should \nbe read as a modi.er that speci.es its blocking behaviour and optional return type R. Type A, if present, \ndetermines the channel s optional argument type. The six channel .avours support zero or one arguments \nof type A and zero or one results of type R. Multiple arguments or results must be passed in tuples, \nusing the provided generic Pair(Of A, B) struct or by other means. Apart from its channels, a Join object \nnotionally owns a set of join patterns. A join pattern is constructed by invoking an overload of the \ninstance method When followed by zero or more invocations of instance method And (or AndPair), followed \nby a .nal invocation of instance method Do.A constructed join pattern typically takes the form: j.When(a1).And(a2) \n\u00b7\u00b7\u00b7 .And(an).Do(d) where a1 through an are channel delegates and d is a con\u00adtinuation delegate. Argument \na1 of When(a1) may be a synchronous or asynchronous channel or an array of asyn\u00adchronous channels. Each \nsubsequent argument ai to And(ai) (for i> 1) must be an asynchronous channel; it cannot be a synchronous \nchannel. The argument d to Do(d) is a continu\u00adation delegate that de.nes the body of the pattern. Although \nits precise type varies with the pattern, the continuation al\u00ad ways has a delegate type of the form: \nDelegate Function Continuation(p1 As P1, . . . , pm or Delegate Sub Continuation(p1 As P1, . . . , pm \nAs Pm) As As Pm) R The precise type of the continuation d, including its arity or number of arguments \nm, is determined by the sequence of channels guarding it. If the .rst argument a1 in the pat\u00adtern is \na synchronous channel with return type R, then the continuation is a function with return type R; otherwise \nthe continuation is a subroutine. The continuation receives the arguments of the joined channel invocations \nas delegate parameters p1 As P1, ..., pm As Pm, for m = n. The presence and types of any ad\u00additional \nparameters p1 As P1 ..., pm As Pm varies accord\u00ading to the type of each argument ai joined with invocation \nWhen(ai)/And(ai) (for 1 = i = n): If ai is of type Channel (regardless of .avour), then When(ai)/And(ai) \nadds no parameter to delegate d.  If ai is of type Channel(Of P ) (regardless of .avour), then When(ai)/And(ai) \nadds one parameter pj of type Pj = P to delegate d.  Parameters are added to d from left to right, in \nincreasing order of i. A continuation can receive at most m = max pa\u00adrameters (max =8 in the current \nimplementation). If nec\u00adessary, it is possible to join more than max generic chan\u00adnels by calling method \nAndPair(ai) instead of And(ai). AndPair(ai) modi.es the last argument of the new contin\u00aduation to be \na pair consisting of the last argument of the pre\u00advious continuation and the new argument contributed \nby ai. Readonly property j.Count is the current number of channels initialized on j; it is bounded by \nj.Size. Any in\u00advocation of j.Initialize that would cause j.Count to ex\u00adceed j.Size throws JoinException. \nJoin patterns must be well-formed, both individually and collectively. Executing Do(d) to complete a \njoin pattern will throw JoinException if d is null, the pattern repeats an asynchronous channel (i.e. \nis non-linear), an (a)synchronous channel is null or foreign to this pattern s Join instance, or the \njoin pattern is redun\u00addant (and allowRedundantPatterns was False). A channel is foreign to a Join instance \nj if it was not allocated by some call to j.Initialize. A pattern is redundant when the set of channels \njoined by the pattern subsets or supersets the channels joined by another pattern on this Join instance. \nThe code generated by CB will, in fact, never raise a JoinException: CB s syntactic restrictions and \nstatic checks ensure this. A dedicated CB runtime library could avoid checking for these errors and provide \na leaner, more tailored API than Joins does. The implementation described here differs only slightly \nfrom the one in (14). The bitmask-indexed tables of pat\u00adterns used to .nd pattern matches (called Actions \nand Patterns in (14, Section 5.1)) are now cyclic instead of null-terminated linked lists. Our support \nfor overlapping patterns, exploited by CB but not described in (14), is im\u00adplemented simply by advancing \nthe pointer to Actions or Patterns, respectively, to the node following the selected one, each time an \nenabled action or pattern is selected for ex\u00adecution (leaving the pointer unchanged if there is no match). \nSince this round-robin strategy does not, as far as we are aware, guarantee any formal fairness property, \nusers should not assume that competing patterns are executed fairly. 4.2 Basic Translation To give a \ntaste of the source to source transformation from CB to vanilla VB using the Joins library, consider \nthe Buffer module from the introduction (Figure 2). The translation performed by the CB compiler yields \nthe code in Figure 14. The Put channel is compiled to a pair of a method named Put and a .eld named PutChannel \nthat contains the actual Joins library asynchronous channel. The compiler-generated body of the Put method \ninvokes the delegate PutChannel to enqueue its argument. The <AsynchronousChannel()> attribute on method \nPut records that it is a channel to support separate compilation, so that, for instance, a subclass can \nregister patterns on an instance channel from an imported base class. Similarly, the Take channel is \ncompiled to a pair of a method named Take and a .eld named TakeChannel that contains the actual Joins \nlibrary synchronous channel. The compiler-generated body of Take invokes the delegate TakeChannel to \nenqueue its request. Again, the attribute <SynchronousChannel()> on Take aids separate compila\u00adtion. \nEach join pattern is compiled to a pair of methods: the original continuation method (e.g. CaseTakeAndPut), \nand a new wrapper method (e.g. CaseTakeAndPutContinuation) that is the actual continuation registered \nwith the Joins library. Although redundant in this simple example, the xxxContinuation method for source \nmethod xxx typically receives all of the arguments from its channels as a single tuple. The n components \nof this tuple are then forwarded as separate arguments to the source continuation xxx. Finally, the compiler \nadds a .eld, SharedJoin that holds the Join object for the module. The Join object itself is initialized \nby a call to Join.Create(2,True). The size ar\u00adgument, 2, speci.es the number of channels required. The \nTrue argument tells the Join object to allow overlapping patterns. A synthetic shared constructor calls \nthe generated method SharedJoinInitialize(). This method takes the lo\u00adcation of each channel (as a ByRef \nargument) and uses the Join object to initialize them. It then registers each gen\u00aderated xxxContinuation \nmethod (one per source join pat\u00adtern) with the Join object as the continuation delegate of a pattern \nconstructed from the generated channel delegates. Although the channel .elds are declared Readonly (to \npre\u00advent direct or indirect malicious updates), since the call to SharedJoinInitialize() is from within \na constructor, this particular call can take the addresses of our Readonly .elds without violating the \nVB or CLR type system.  4.3 Compiling Inheritance The translation for a class with instance channels \nand pat\u00adterns is slightly more involved: a subclass can extend both the set of channels and the set of \npatterns declared in that class. Our .rst problem is that when compiling a class, the compiler will only \nknow the size of the Join object to allo\u00adcate for an instance of that class, but not for any of its sub\u00adclasses. \nOur second problem is that a subclass may declare additional patterns involving both its own and any \ninherited channels, all of which must be properly initialized before the patterns are registered on the \nJoin object. Our solution to these problems relies on virtual dispatch and base calls. The class that \ndeclares the .rst channel (and is thus uppermost in the inheritance hierarchy) declares a protected .eld, \ncalled Join, of library type Join. This .eld Module Buffer Private ReadOnly PutChannel As [Asynchronous].Channel(Of \nString) <AsynchronousChannel()> _ Public Sub Put( t As String) PutChannel(t) End Sub Private ReadOnly \nTakeChannel As [Synchronous](Of String).Channel <SynchronousChannel()> _ Public Function Take() As String \n Return TakeChannel() End Function Private Function CaseTakeAndPut( t As String) As String Return t \nEnd Function Private Function CaseTakeAndPutContinuation( Arg As String) As String Return CaseTakeAndPut(Arg) \nEnd Function Private ReadOnly SharedJoin As Join = Join.Create(2, True) Sub New() SharedJoinInitialize(TakeChannel, \nPutChannel) End Sub Private Sub SharedJoinInitialize( _  ByRef TakeChannel As [Synchronous](Of String).Channel, \n_ ByRef PutChannel As [Asynchronous].Channel(Of String)) SharedJoin.Initialize(TakeChannel) SharedJoin.Initialize(PutChannel) \nSharedJoin.When(TakeChannel).And(PutChannel).Do(AddressOf CaseTakeAndPutContinuation) End Sub End Module \n Figure 14. Generated code for the buffer module. is initialized with Join.Create(JoinSize(),True). The \ncompiler-generated JoinSize() method that is Protected, but Overridable, computes the size (number of \nchannels) of the Join object. Each derived class that declares a new in\u00adstance channel must override \nthe virtual JoinSize() method to return the required number of channels for that class, ex\u00adpressed as \nan increment of MyBase.JoinSize(). Since the Join .eld is Protected, each class that declares new chan\u00adnels \nor patterns can reference it to initialize any channels and/or construct any patterns. When necessary, \nthis is han\u00addled by a private, compiler generated JoinInitialize() in\u00adstance method, called from a (possibly \nsynthetic) constructor method. The usual chaining of constructor calls ensures that the channels of a \nbase class are properly initialized before a derived class can attempt to add patterns involving them. \nFor a concrete example, the ActiveObject and derived Person class compile to the code in Figures 15 and \n16. No\u00adtice that only ActiveObject declares the protected Join .eld but that Person overrides the JoinSize() \nmethod to calcu\u00adlate the size of the Join .eld from MyBase.JoinSize(). It also obtains a private JoinInitialize() \nmethod to perform its own channel initialization and pattern construction. In this way, calling New ActiveObject() \ncreates a Join object of size 3 (for channels Start, Halt and ProcessMessage), but calling New Person() \ncreates a Join object of size 3+1+ n (n is for channels declared in Person but not shown).  4.4 Compiling \nMulti-Parameter Channels and Continuations The .nal wrinkle in the translation is dealing with channels \nand continuations that take multiple parameters. The .rst problem is that the Joins library only supports \nchannels that take zero-or-one parameters. The second is that the library has a ceiling (max) on the \nnumber of arguments that may be bound in a continuation. Fortunately, both limitations are easily avoided \nby tupling arguments before sending them on a channel and by untupling arguments before passing them \nto a join pattern continuation. Tuples are constructed as nested values of a generic Pair(Of A,B) structure, \nnot a class, avoiding some allocation. 5. Extensions 5.1 Customizing Dispatch via Attributes As described \nso far, the semantics of CB is that: 1. the continuation of a synchronous pattern runs in the thread \nof the synchronous sender; Public Class ActiveObject Private Done As Boolean Protected ReadOnly ProcessMessageChannel \nAs [Synchronous].Channel <SynchronousChannel()> _ Protected Sub ProcessMessage() ProcessMessageChannel() \nEnd Sub Protected ReadOnly StartChannel As [Asynchronous].Channel <AsynchronousChannel()> _ Public Sub \nStart() StartChannel() End Sub Protected ReadOnly HaltChannel As [Asynchronous].Channel <AsynchronousChannel()> \n_ Public Sub Halt() HaltChannel() End Sub Private Sub CaseStartContinuation() CaseStart() End Sub Private \nSub CaseStart() While Not Done : ProcessMessage() : End While End Sub Private Sub CaseHaltContinuation() \n CaseHalt() End Sub Private Sub CaseHalt()  Done = True End Sub Protected Overridable Function JoinSize() \nAs Integer Return 3 End Function Protected ReadOnly Join As Join = Join.Create(JoinSize(), True) Private \nSub JoinInitialize(ByRef ProcessMessageChannel As [Synchronous].Channel, _ ByRef StartChannel As [Asynchronous].Channel, \n_ ByRef HaltChannel As [Asynchronous].Channel) Join.Initialize(ProcessMessageChannel) Join.Initialize(StartChannel) \nJoin.Initialize(HaltChannel) Join.When(StartChannel).Do(AddressOf CaseStartContinuation) Join.When(ProcessMessageChannel).And(HaltChannel).Do(AddressOf \nCaseHaltContinuation) End Sub Sub New() JoinInitialize(ProcessMessageChannel, StartChannel, HaltChannel) \nEnd Sub End Class Figure 15. Generated code for the ActiveObject base class with instance channels. Public \nClass Person Inherits ActiveObject Private floor As Floor Protected ReadOnly GotoFloorChannel As [Asynchronous].Channel(Of \nFloor) <AsynchronousChannel()> _ Public Sub GotoFloor( f As Floor) GotoFloorChannel(f) End Sub Private \nSub CaseProcessMessageAndGotoFloorContinuation( Arg As Floor) CaseProcessMessageAndGotoFloor(Arg) End \nSub Private Sub CaseProcessMessageAndGotoFloor( f As Floor) floor = f : Dim a As New Ack() : floor.PersonArrived(Me, \na) : a.Receive() : ChooseDir(floor) End Sub Protected Overrides Function JoinSize() As Integer Return \n(MyBase.JoinSize() + 1 + n) n is the number of other channels declared in Person End Function Private \nSub JoinInitialize(ByRef GotoFloorChannel As [Asynchronous].Channel(Of Floor), ...) MyBase.Join.Initialize(GotoFloorChannel) \n... Initialize other n channels MyBase.Join.When(MyBase.ProcessMessageChannel).And(GotoFloorChannel). \n_ Do(AddressOf CaseProcessMessageAndGotoFloorContinuation) ... construct remaining local patterns End \nSub Public Sub New() JoinInitialize(GotoFloorChannel) ... End Sub ... End Class Figure 16. Generated \ncode for the Person derived class with a new channel and pattern. 2. the continuation of an asynchronous \npattern runs in a newly spawned thread. One criticism of this design is that it integrates poorly with \nother threading models available on the platform such as the CLR ThreadPool, Windows.Forms event loops \nand Mi\u00adcrosoft s new parallel task library (10). Even disregarding other models, spawning a new thread \nis often unnecessary when the body of an asynchronous pattern is known to exe\u00adcute quickly. Examples \nof this are when the body just does some trivial calculation before posting a message on another asynchronous \nchannel or when the body just queues a task to some task library. Ideally, the compiler should be able \nto identify and optimize these cases using some static analy\u00adsis. However, until such an analysis materialises, \nit might be preferable to simply let the programmer annotate patterns to indicate how they should be \ndispatched. The only question is how to surface this in the syntax, without detracting from the pleasing \nsimilarity with declarative event handlers. This section describes a simple proposal that addresses these \nissues in a semi-declarative yet extensible manner. The idea is that instead of enlarging the syntax \nof patterns to ac\u00adcommodate some .xed set of options, we instead allow the programmer to use user-de.ned \ncustom attributes to con\u00adtrol the execution aspect of individual patterns. Although at\u00adtributes are typically \nused to de.ne custom metadata, here we (ab)use them to provide both data and behaviour. This experimental \nfeature turns out to be surprisingly useful. To support this extension, we extended the Joins library \nto expose a well-known (abstract) custom attribute class, ContinuationAttribute, that provides two virtual \nmethods (Figure 17). Method BeginInvoke(task) should execute its continuation argument asynchronously \n(somehow). Method Invoke(task) should execute its continuation argument syn\u00adchronously (somehow).5 A \nuser may de.ne derived classes of ContinuationAttribute and then use them to specify the execution behaviour \nof individual patterns, simply by an\u00adnotating a pattern with an instance of the derived attribute. An \nattribute on a type implicitly applies to each pattern in its de.nition, giving a simple way to specify \ndefault be\u00adhaviour. The CB compiler recognizes derived instances of ContinuationAttribute placed on modules, \ntypes or meth\u00adods and squirrels away a fresh instance of the attribute for each pattern that speci.es \none. The runtime library then uses 5 The names BeginInvoke and Invoke, though odd, follow .NET con\u00adventions. \n Public MustInherit Class ContinuationAttribute Inherits Attribute Public MustOverride Sub BeginInvoke( \ntask As Continuation) Public MustOverride Sub Invoke( task As Continuation) End Class Public Delegate \nSub Continuation()  Figure 17. The abstract ContinuationAttribute class. the attribute to (a)synchronously \ndispatch the pattern s con\u00adtinuation. For the optimization scenario, where the user wants to execute \na quick asynchronous pattern immediately, she might decorate the method with an instance of attribute \nImmediate() (Figure 18). An example of ImmediateAttribute s use is the generic Cell(Of T) class in Figure \n19 that supports an asynchronous Write(v) and a synchronous Read() channel. The operations are rendered \natomic by joining each with a private Token() message (acting as a lock). Since CaseWriteAndToken just \nstores its value before reposting Token(), we can execute it immediately in the last thread to issue \nWrite or Token instead of spawning a transient thread. If the user wishes to run asynchronous patterns \nin the CLR s built-in ThreadPool, to save creating new OS threads, she can de.ne the ThreadPoolAttribute \nclass in Figure 20. In the following example, the <ThreadPool()> attribute ensures that CaseStartAndIdle \nis executed in the CLR ThreadPool in response to a Start and Idle message, with\u00adout the cost of spawning \na new thread each time. Asynchronous Start() Asynchronous Idle() <ThreadPool()> _ Private Sub CaseStartAndIdle() \nWhen Start, Idle do some work Done(Not cancelled) End Sub Similarly, to ensure that a continuation is \nmarshalled back to the Windows.Forms user-interface thread, she might de.ne the UI attribute in Figure \n21, and use it as follows: Asynchronous Done( completed As Boolean) <UI()> _ Sub CaseDone( completed \nAs Boolean) When Done Status.Text = _ If(completed, \"Completed\", \"Cancelled\") End Sub The <UI()> attribute \nensures CaseDone(b) is executed asynchronously when Done, but on the UI thread, where it is safe to modify \nthe state of the control Status. Note that, without the <UI()> attribute, CaseDone would be executed \nin a new thread which would then have to marshal the modi.\u00adcations back to the UI thread using the form \ns eponymous, but weakly typed, BeginInvoke(d As Delegate) method. Here s one of several ugly alternatives \nusing plain CB: Asynchronous Done( completed As Boolean) Sub CaseDone( completed As Boolean) When Done \n BeginInvoke(Function() CaseDoneBody(completed)) End Sub Function CaseDoneBody( completed As Boolean) \nStatus.Text = _ If(completed, \"Completed\", \"Cancelled\") End Function This is expensive, type-unsafe and \nclumsy: Delegate is the base class of all delegates, so d is invoked by Re.ection; VB s lack of lambda-statements \nforces us to wrap our state\u00adment in a function, called from a lambda-expression. Custom patterns are \nsupported by the CB compiler by copying any attribute that is placed on a pattern xxx and derives from \nContinuationAttribute to its corresponding xxxContinuation method. The Joins library has been mod\u00adi.ed \nto allocate a fresh instance of the attribute, if any, when a pattern is constructed from an xxxContinuation \nmethod. The library currently uses Re.ection to retrieve the attribute instance from a continuation delegate \ns target method or its declaring class or module. This is expensive and re\u00adquires some security permissions. \nHowever, since attributes are statically known, a better implementation could short\u00adcut Re.ection by \nallocating the required attributes in the (Shared)JoinInitialize method and passing them on to a modi.ed \nJoins library. 5.1.1 Example Figure 22 contains a more realistic example, a form that uses the thread \npool to execute a cancellable background task. The task executes concurrently, perhaps in parallel, periodically \nupdating the form asynchronously to indicate progress and .nal completion. This is a simpli.ed version \nof what the .NET Framework s existing BackgroundWorker class accomplishes. The code assumes that class \nForm declares four con\u00adtrols: two buttons, Go and Cancel,a ProgressBar and a Status label. Clicking Go \nstarts one ThreadPool thread that asynchronously does some (presumably expensive) work in a loop, updating \nthe Form s ProgressBar until Cancelled or Done. Clicking Cancel sets the Cancellation cell to True. The \ntask polls the cancellation cell to continue work\u00ading or exit prematurely. Since there is a race between \nsending a cancellation signal and the task completing, the task s Done(completed) message reports the \nactual comple\u00ad Class ImmediateAttribute Inherits ContinuationAttribute Public Overrides Sub BeginInvoke( \ntask As Continuation) task() End Sub Public Overrides Sub Invoke( task As Continuation) task() End Sub \nEnd Class Figure 18. Executing quick asynchronous tasks immediately. Class Cell(Of T) Private value \nAs T Public Asynchronous Write(v As T) Public Synchronous Read() As T Private Asynchronous Token <Immediate()> \n_ Private Sub CaseWriteAndToken( value As T) When Write, Token Me.value = value : Token() End Sub Private \nFunction CaseReadAndToken() As T When Read, Token Dim value = Me.value : Token() : Return value End Function \nSub New( value As T) Me.value = value : Token() End Sub End Class Figure 19. An asynchronous write, \nsynchronous read cell class. Class ThreadPoolAttribute Inherits ContinuationAttribute Public Overrides \nSub BeginInvoke( task As Continuation) ThreadPool.QueueUserWorkItem(AddressOf task.Invoke) End Sub Public \nOverrides Sub Invoke( task As Continuation) task() End Sub End Class Figure 20. Delegating asynchronous \ntasks to the CLR ThreadPool. Class UIAttribute Inherits ContinuationAttribute Private SC As System.Threading.SynchronizationContext \n= _ System.Threading.SynchronizationContext.Current() Public Overrides Sub BeginInvoke( task As Continuation) \n SC.Post(Function(state As Object) task(), Nothing) End Sub Public Overrides Sub Invoke( task As Continuation) \n SC.Send(Function(state As Object) task(), Nothing) End Sub End Class Figure 21. Marshalling asynchronous \ntasks to the UI thread. Public Class Form Inherits System.Windows.Forms.Form Private Asynchronous Start() \nPrivate Asynchronous Idle() Private Asynchronous Done(completed As Boolean) Private Asynchronous Progress( \ni As Integer) Private Synchronous Await() Private Cancelled As New Cell(Of Boolean)(False) <ThreadPool()> \n_ Private Sub CaseStartAndIdle() When Start, Idle Dim cancelled = False For i As Integer = 1 To 100 cancelled \n= Me.Cancelled.Read() If cancelled Then Exit For Do some work Progress(i) Next Done(Not cancelled) Idle() \n End Sub <UI()> _ Private Sub CaseDone( completed As Boolean) When Done Cancel.Enabled = False : Go.Enabled \n= True Status.Text = If(completed, \"Completed\", \"Cancelled\") End Sub <UI()> _ Private Sub CaseProgress( \ni As Integer) When Progress ProgressBar.Value = i End Sub Sub New() InitializeComponent() Go.Enabled \n= True : Cancel.Enabled = False Idle() End Sub Private Sub Go_Click() Handles Go.Click Go.Enabled = \nFalse : Cancel.Enabled = True : Status.Text = Nothing Cancelled.Write(False) Start() End Sub Private \nSub Cancel_Click() Handles Cancel.Click Go.Enabled = True : Cancel.Enabled = False Cancelled.Write(True) \n End Sub Public Sub CaseAwaitAndIdle() When Await, Idle End Sub Protected Overrides Sub OnClosing( e \nAs CancelEventArgs) Cancelled.Write(True) Await() MyBase.OnClosing(e) End Sub End Class Figure 22. \nUsing continuation attributes to control the execution of patterns. tion reason back to the Form. Both \nthe CaseProgress and CaseDone patterns carry the UI attribute since they must be executed on the Form \ns event loop in order to safely modify its controls. Not that the Progress channel is asynchronous to \nprevent a non-responsive Form from blocking the task. The Idle() message merits further explanation. \nIt is used to prevent the form from closing while a background task is active. Otherwise, the form could \nreceive a CaseDone or CaseProgress task after its event loop has shut down, causing a run-time error. \nTo avoid this, we override the OnClosing method to cancel the task and (synchronously) Await the Idle \ntoken before calling its base method. The Form itself is initially Idle, but the Idle token is consumed \nand reissued on entry and completion of CaseStartAndIdle.  5.2 Synchronous Rendezvous, Revisited One \nsubtle restriction of CB is that a pattern may mention at most one synchronous channel. This restriction \nis inherited from its C# based predecessors. It has the nice property of guaranteeing that the continuation \nof a synchronous pattern will be run on the thread of its (one and only) synchronous caller. This property \nis important when the continuation has to run on the same thread as the caller, say to release a lock \nor access thread local storage. But the guarantee is certainly not always required. Relaxing the restriction \nwould make the syntax of patterns more symmetric and, more importantly, support Ada-style synchronous \nrendezvous. Addressing the issue of rendezvous, Cardelli, Benton and Fournet (4)[Section 3.1] propose \nsome syntax (inspired by JoCaml (7)) that allows a pattern s body to return to any of several synchronous \nmethod headers independently, using a generalized return e to m; statement. The statement returns the \nvalue of e to the waiting synchronous caller of m. For example, the following Polyphonic C# class would \nallow two threads to exchange values passed to synchronous yet joined methods f and g. class rendezvous \n{ public B f(A a) &#38; public A g(B b) { return a to g; return b to f; } } Whilst appealing, the authors \ndo not discuss how to han\u00addle continuations that fail to return exactly once to each caller, and whether \nthis should be detected statically (as in JoCaml (7)) or dynamically. Instead, we propose a simpler construct \nthat is slightly less expressive, but much easier to explain to users, and no more dif.cult to implement \n-in fact, we expect that implementation will be simpler. The idea is to allow multiple channels in a \npattern to be synchronous, provided they all have the same return type (if any). All syn\u00adchronous callers \ninvolved in a pattern block until the con\u00adtinuation returns one value or exception (the same one) to \nall of them. This still allows an ef.cient implementation in which the last caller to enable the pattern \ncan either (if synchronous) immediately execute it without blocking or (if asynchronous) wake up any \none waiting caller as appropri\u00adate. The drawback is that the continuation can no longer re\u00adturn earlier \non some channels than others, forfeiting some concurrency. As a concrete example, supporting rendezvous \nwould allow us to simplify the code from Section 3.3, removing the need to pass an explicit acknowledgement \nobject, a, in the call floor.PersonArrived(Me,a). In the original code, the explicit synchronization \nafter calling PersonArrived is needed to avoid a race condition. The person agent needs to be certain \nthat the floor has noted its arrival before call\u00ading ChooseDir(floor) to request a lift. So why can t \nwe just make PersonArrived synchronous? Unfortunately, object floor of class Floor (Figure 23) is also \nan active object that serializes calls to PersonArrived using its own synchronous ProcessMessage channel. \nThis uses up the one synchronous slot available to the pattern implementing PersonArrived, forcing PersonArrived \nto be asynchronous. To work around this restriction, CaseProcessMessageAndGotoFloor synchro\u00adnizes with \ncompletion of PersonArrived(Me,a) by waiting on a.Receive() assuming that floor follows protocol and \nacknowledges with a message a.Send(). However, allowing PersonArrived to be synchronous and joined with \nthe synchronous ProcessMessage lets us simplify the code considerably (Figure 24). The revised CaseProcessMessageAndPersonArrived \njust waits for two synchronous channels with the same (i.e. no) return type. Notice that we have eliminated \nsome complexity (and proto\u00adcol) from both the caller of and the pattern on PersonArrived. We intend to \nimplement this simple but useful form of rendezvous in future versions of CB. 6. Related Work and Conclusion \nJoin patterns .rst appeared in Fournet and Gonthier s foun\u00addational join calculus (5; 6), an asynchronous \nprocess alge\u00adbra designed for ef.cient implementation in a distributed set\u00adting. JoCaml (7) and Funnel \n(13) are functional languages supporting declarative join patterns. Cardelli, Benton and Fournet later \nproposed an object-oriented version of join pat\u00adterns for C# called Polyphonic C# (3); (4) describes \nthe programming model and an implementation in more detail; while (2) uses Polyphonic C# to provide a \nmodel solution to the Santa Claus Problem. Similar extensions to (non\u00adgeneric) Java, JoinJava, were independently \nproposed by von Itzstein and Kearney (8). Another implementation of a syn\u00adtactic variant of Polyphonic \nC# was included in the pub\u00adlic release of C. (a.k.a. Comega) in 2004. C. itself was an extension of C# \n1.1 with both concurrency and, separately, LINQ-like features for SQL and XML data integration (9). Mostly \nbecause of their age, rather than any fundamen\u00adtal restriction, neither Polyphonic C# ,C. nor JoinJava \nsupported Generics, limiting the range of reusable concur\u00ad Public Class Floor Inherits ActiveObject \nPrivate people As List(Of Person) Public Asynchronous PersonArrived(p As Person,a As Ack) Private Sub \nCaseProcessMessageAndPersonArrived(p As Person,a As Ack) When ProcessMessage, PersonArrived people.Add(p) \na.Send() End Sub ... End Class Figure 23. The Floor class using emulated rendezvous. Public Class Person \nInherits ActiveObject Private floor As Floor Public Asynchronous GotoFloor(f As Floor) Private Sub CaseProcessMessageAndGotoFloor(f \nAs Floor) When ProcessMessage, GotoFloor floor = f floor.PersonArrived(Me) ChooseDir(floor) End Sub End \nClass Public Class Floor Inherits ActiveObject Private people As List(Of Person) Public Synchronous PersonArrived(p \nAs Person) Private Sub CaseProcessMessageAndPersonArrived(p As Person) When ProcessMessage, PersonArrived \npeople.Add(p) End Sub ... End Class Figure 24. Simpli.ed Person and Floor classes exploiting rendezvous. \nrency abstractions that could be expressed with join patterns. Though essentially for free, CB s combination \nof join pat\u00adterns and Generics (also found in JoCaml and Funnel), is hopefully much more compelling. \nWhile JoinJava (8) provides no support for inheritance (concurrent classes must be .nal), Polyphonic \nC# and C. had a more subtle inheritance restriction: (9) If any chord-declaration [pattern] includes \na virtual method m [channel] with the override mod\u00adi.er, then any method [channel] n that appears in \na chord with m in the superclass containing the over\u00adridden de.nition of m must also be overridden in \nthe subclass. (4, Section 3.2). Although concisely stated, this condition is arguably dif\u00ad.cult to understand. \nSince the compiler will reject code that fails to override inherited, but conjoined, virtual meth\u00adods, \nit effectively forces patterns, not just method signa\u00adtures, into the interface of a class. But the restriction \nalso has practical rami.cations. In our ActiveObjects example of Section 3.3 the restriction, if applied, \nprevents the user from placing the common CaseHalt() pattern where it nat\u00adurally belongs -within the \nActiveObject base class. In\u00adstead, the user is forced to re-declare the pattern within the Person subclass \nand, transitively, within every subclass de\u00adrived from it. Since the inherited pattern accesses private \nstate (i.e. Done), that state must now either be revealed as Protected Done or be accessed from a revealed \nmethod (i.e. Protected Sub CaseHalt) in the base class, compromising encapsulation (cf. (4, Section 4.4)). \nThe CB approach to inheritance, which allows incremen\u00adtal addition of join patterns, seems more natural. \nCB also makes it easy to override the behaviour of individual pat\u00adterns, just by marking the declaration \nof the continuation method as Overridable in the base class. The syntax of Polyphonic C# and C., allowing \na sin\u00adgle method to have multiple bodies and a single body to have multiple method headers, is quite \nalien. The CB de\u00adsign, though verbose, does at least have some resemblance to an existing language feature: \ndeclarative event handling. We hope that this familiarity might ease adoption, by both users and language \narchitects. Nevertheless, one might con\u00adsider departing from the Handles-like syntax to use a pa\u00adrameter \nbinding When construct that makes it easier to dis\u00adtinguish channel arguments. Our current syntax, with \nits explicit method signature, has the advantage of supporting overriding and recursion, which the other \nsyntax does not. The arrival of Generics in C# 2.0 and VB 8.0 made it possible to encapsulate join pattern \nconstructs in the Joins library (15; 14). As well as exploiting Generics in its con\u00adstruction, the library \nallows users to program generic con\u00adcurrency abstractions, increasing the utility of join patterns. Compared \nwith CB, a nice feature of Joins is that join objects, channels and even partially constructed patterns \nare .rst-class values, making it easier to construct higher\u00adlevel abstractions. The library s main drawback \nis its re\u00adliance on runtime checking to detect what are static errors in CB. While accessible from VB \n8.0 and 9.0, VB s lack of support for C# s anonymous delegates, let alone implicitly typed lambda statements, \nmeans that Joins remains more awkward to use from VB than C#(even VB 9.0 s lambda\u00adexpressions are not \nquite enough). Our implementation of CB relies on the Joins library for runtime support, but it doesn \nt have to. Although ade\u00adquate, performance could be further improved by adapting and extending the static \ncompilation techniques originally described for Polyphonic C# and implemented in C. (see (14) for a comparison \nbetween C. and Joins). However, factoring most of the implementation into a runtime library does make \nit easier to retarget CB to other platforms, by port\u00ading the library without modifying the compiler. \nOne feature we ve left out from CB, that was present in Polyphonic C# and C., is the introduction of \na new async type as a subtype of void. Although useful for specifying asynchronous behaviour in interfaces \nand on delegate return types, the async type must be erased to void on the under\u00adlying platform (the \nCLR). So, in practice, CB code, expect\u00ading to receive an async delegate argument, might actually be passed \na C# void returning delegate that blocks, violating the expected async contract. Our hope is that CB \ns natural syntax, support for inher\u00aditance, interplay with Generics, and pragmatic extensibility make \njoin patterns viable for inclusion in a future release of Visual Basic; the proposal is now under consideration \nby Microsoft s Visual Basic team. Acknowledgments Thanks to Erik Meijer for suggesting and supporting \nthis work, Harish Kantamneni for detailed code reviews, Danny van Velzen for help with VB sources and \nPaul Vick, Amanda Silver and the anonymous referees for feedback. Particular thanks to Nick Benton whose \nexamples and prose have been adapted from Polyphonic C# and C. to Joins and CB. References [1] J. Armstrong, \nR. Virding, C. Wikstr\u00a8om, and M. Williams. Concurrent programming in ERLANG (2nd ed.). Prentice Hall, \n1996. [2] N. Benton. Jingle bells: Solving the Santa Claus problem in Polyphonic C# , http://research.microsoft.com/ \n~nick/santa.pdf, March 2003. [3] N. Benton, L. Cardelli, and C. Fournet. Modern concur\u00adrency abstractions \nfor C# . In Proceedings of the 16th Euro\u00adpean Conference on Object-Oriented Programming (ECOOP 2002), \nnumber 2374 in LNCS. Springer-Verlag, June 2002. [4] N. Benton, L. Cardelli, and C. Fournet. Modern concurrency \nabstractions for C# . ACM Transactions on Programming Languages and Systems, 26, September 2004. [5] \nC. Fournet and G. Gonthier. The re.exive chemical ab\u00adstract machine and the join-calculus. In Proceedings \nof the 23rd ACM-SIGACT Symposium on Principles of Program\u00adming Languages (POPL 96), pages 372 385. [6] \nC. Fournet and G. Gonthier. The join calculus: a language for distributed mobile programming. In APPSEM \nSummer School, Caminha, Portugal, September 2000, volume 2395 of LNCS. Springer-Verlag, 2002. [7] C. \nFournet, F. Le Fessant, L. Maranget, and A. Schmitt. Jo-Caml: a language for concurrent distributed and \nmobile pro\u00adgramming. In Advanced Functional Programming, 4th Inter\u00adnational School, Oxford, August 2002, \nvolume 2638 of LNCS. Springer-Verlag, 2003. [8] G. S. Itzstein and D. Kearney. Join Java: An alternative \nconcurrency semantics for Java. Technical Report ACRC-01\u00ad001, University of South Australia, 2001. [9] \nMicrosoft Corporation. Language-Integrated Query (LINQ), http://msdn2.microsoft.com/en-us/library/ bb397926(VS.90).aspx, \n2007. [10] Microsoft Corporation. Microsoft Parallel Extensions Framework, http://msdn2.microsoft.com/en-us/ \nconcurrency/default.aspx, 2007. [11] Microsoft Corporation. Visual Basic Language Speci.cation 9.0 (beta \n2), available from http://www.microsoft.com/ downloads, 2007. [12] Microsoft Research. C., http://research.microsoft. \ncom/Comega, 2004. [13] M. Odersky. An overview of functional nets. In APPSEM Summer School, Caminha, \nPortugal, September 2000, volume 2395 of LNCS. Springer-Verlag, 2002. [14] C. Russo. The Joins Concurrency \nLibrary. In Michael Hanus, editor, Ninth International Symposium on Practical Aspects of Declarative \nLanguages (PADL 2007), volume 4354 of LNCS, pages 260 274. Springer-Verlag, January 2007. [15] C. V. \nRusso. Joins: A Concurrency Library, 2006. Binaries with tutorial and samples: http://research.microsoft. \ncom/research/downloads.   \n\t\t\t", "proc_id": "1449764", "abstract": "<p>We describe an extension of Visual Basic 9.0 with asynchronous concurrency constructs - join patterns - based on the join calculus. Our design of Concurrent Basic (CB) builds on earlier work on Polyphonic C# and Comega. Since that work, the need for language-integrated concurrency has only grown, both due to the arrival of commodity, multi-core hardware, and the trend for Rich Internet Applications that rely on asynchronous client-server communication to hide latency. Unlike its predecessors, CB adopts an event-like syntax that should be familiar to existing VB programmers. Coupled with Generics, CB allows one to declare re-useable concurrency abstractions that were clumsy to express previously. CB removes its ancestors' inconvenient inheritance restriction, while providing new extensibility points useful in practical applications that must co-exist with or want to exploit alternative threading models available on the platform. CB is implemented as an extension of the production VB 9.0 compiler.</p>", "authors": [{"name": "Claudio V. Russo", "author_profile_id": "81100638789", "affiliation": "Microsoft Research Ltd, Cambridge, United Kingdom", "person_id": "P1223153", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449770", "year": "2008", "article_id": "1449770", "conference": "OOPSLA", "title": "Join patterns for visual basic", "url": "http://dl.acm.org/citation.cfm?id=1449770"}