{"article_publication_date": "10-19-2008", "fulltext": "\n Enforcing ObjectProtocolsby Combining Static and Runtime Analysis Madhu Gopinathan Indian Institute \nof Science Bangalore, India gmadhu@csa.iisc.ernet.in Abstract In this paper, we consider object protocols \nthat constrain in\u00adteractions between objects in a program. Several such pro\u00adtocolshave been proposedinthe \nliterature[3,9,6,5].For manyAPIs (such as JDOM [23], JDBC [22]), API design\u00aders constrain how API clients \ninteract with API objects. In practice, API clients violate such constraints, as evidenced by postings \nin discussion forums for these APIs. Thus, it is important that API designers specify constraints using \nap\u00adpropriate object protocols andenforce them. The goal of an object protocol is expressed as a proto\u00adcolinvariant. \nFundamental properties suchasownership can beexpressedas protocolinvariants.We presenta language, PROLANG, \nto specify object protocols along with their pro\u00adtocolinvariants,andatool,INVCOP++,to checkifapro\u00adgram \nsatis.esaprotocolinvariant.INVCOP++separatesthe problem of checking if a protocol satis.es its protocol \nin\u00advariant (called protocol correctness), from the problem of checking if a program conforms to a protocol \n(called pro\u00adgram conformance). The former is solved using static anal\u00adysis, and the latter using runtime \nanalysis. Due to this sep\u00adaration (1) errors made in protocol design are detected at a higher level of \nabstraction, independent of the program s source code, and (2) performance of conformance checking is \nimproved as protocol correctness has been veri.ed stat\u00adically.We presenttheoretical guarantees about \ntheway we combine static and runtime analysis, and empirical evidence that our tool INVCOP++ .nds usage \nerrors in widely used APIs. We also show that statically checking protocol cor\u00adrectness greatly optimizestheoverheadof \nchecking program conformance, thus enabling API clients to test whether their programs use the API as \nintended by the API designer. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page.To \ncopyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 08, October 19 23, 2008, Nashville,Tennessee, USA. Copyright c &#38;#169; 2008ACM \n978-1-60558-215-3/08/10... $5.00 Sriram K. Rajamani Microsoft Research India Bangalore, India sriram@microsoft.com \nCategories and Subject Descriptors D.1.5 [Program\u00adming Techniques]: Object-oriented Programming; D.2.1 \n[Requirements/Speci.cations]: Tools; D.2.4 [Soft\u00adware/Program Veri.cation]: Class invariants; D.2.5 [Testing \nand Debugging]: Monitors General Terms Design, Languages, Reliability, Veri.ca\u00adtion Keywords Invariants, \nAspect Oriented Programming, Pro\u00adgramVeri.cation 1. Introduction Design decisions impose constraints \non both the structure and behavior of software. Most practitioners of software engineering believe that \nthere is value in capturing these design decisions as rules, and using tools to automatically enforce \nthat programs follow these rules. In practice, data types are the only rules that are widely documented \nin pro\u00adgrams and enforced by programming languages. Re.ning types by adding stateful protocols was pioneered \nby [30]. Recent work has extended this approach to handle pointer aliasing and demonstrated its utility \nfor interesting programs writtenin realistic programming languages[2,13,16,8,15]. These approaches treat \neach object independently. Examples include checking if a lock is acquired and released in strict alternation, \nor checking if a .le is opened before being read or written. Object Invariants. The next challenge in \nthis line of re\u00adsearch is to specify and check rules that involve multiple inter-related objects. The \nsimplest form of such rules are ob\u00adject invariants.For example, consider a class Node ina bi\u00adnary search \ntree with a Key.eld k, and .elds left and right thatpointrespectivelytotheleftandright childrenofanode. \nThe object invariant of Node states that left.k < k and k < right.k. Furthermore, the invariant needs \nto hold recursively for the nodes pointed toby left and right. Thus, the invariant of Node depends on \nits .elds k, left and right. The fundamental dif.culty with checking object invari\u00adants is that the invariant \nof an object o may depend on several objects p1,p2,.... Thus, a change to pi (possibly through aliases \nto pi), may break the invariant of o, and there is no easy way to know the objects that depend on pi.For \nexam\u00adple,ifa clientof binary search tree changesakey k, it might break the invariant of a node n that \ndepends on k. Sincekey kdoes not refer to node n, such violations are hard to detect. In recent work \nwe have designed a tool INVCOP [18] to enforce object invariants at runtime. INVCOP tracks de\u00adpendencies \nof objects automatically, and validates if a state change of object p breaks the invariant of anyobject \no that depends on p.In ourexample,INVCOPautomatically tracks that Node n depends on Keyk. When kchanges, \nit validates whether the change breaks theinvariant of n. Thus,INVCOP guarantees that when an object \no is in a steady state, anyvi\u00adolation of o s invariant is detected exactlywhere it occurs. Object Protocols. \nObject protocols specify generic con\u00adstraints to structure interactions between objects. Several such \nprotocols have been proposed in the literature [3, 9, 6, 5]. In order to check if programs follow these \nprotocols, several techniques such as ownership type systems [9, 6], and program veri.cation tools [4] \nhave been proposed. The goal of an object protocol is expressed as a protocol invari\u00adant, which is parameterized \nover the object invariants of the participating objects. As an example consider the Representation Containment \nprotocol from [9]. The goal of this protocol is to ensure that if an object with an owner is accessed, \nthen its owner must also have been accessed. Thus, an owner is assured that if the protocol is followed, \nthen the objects it owns are not accessed without its knowledge. Additionally, if an object is not accessed, \nthen its object invariant must hold. Object protocols can be described operationally with: (1) auxiliary \n.elds added to each object, (2) protocol methods that manipulate auxiliary .elds, and (3) a protocol \ninvariant over the auxiliary .elds. For example, the Representation Containment protocol canbe describedby \nadding2 auxil\u00adiary .elds to each participating object: (1) accessed, which is true if o is being accessed, \n(2) owner, which points to the object that owns o. The protocol .elds accessed and owner are manipulatedby \nprotocol methods (See Figure3in Sec\u00adtion 3). The protocol invariant for this protocol is: .o. (o.accessed \n. (o.owner = null . o.owner.accessed)) .(\u00aco.accessed . o.Inv()) Note that the protocol invariant is parameterized \nover object invariant o.Inv() of participating objects. Each object type provides its own de.nition of \nthe Inv() method. Since an object protocol is speci.ed separately, we need to associate protocol methods \nwith interesting program points using an appropriate binding.Forexample, when the key .eld of Node n \nis set to Key k, using a binding, the protocol method Own(n,k) (Figure 5) is invoked which sets k.owner \nto n. Suppose the root node r is made the owner of all the nodes n in a search tree. Then according to \nthe Represen\u00adtation Containment protocol, whenever the auxiliary .eld accessed of each node n is true, \nthe accessed .eld of r must also be true and whenever n.accessed isfalse, theobject in\u00advariant n.Inv() \nmust hold. Importance of ObjectProtocols. For manyAPIs (such as JDOM [23], JDBC [22]), API designers \nconstrain how API clients interact with API objects. Several realistic design sce\u00adnarios requirea designer \nto constraininteractions between objects (see Sections 6.2.3,6.2.4).API designers need to de\u00adsign and \ncustomize object protocols according to the needs oftheAPI(see Section5).APIclients commonlymake mis\u00adtakes \nin followingthese protocols (see Section 6). Therefore, we believe that it is important for API designers \nto state ob\u00adject protocols and enforcethat API clients follow such pro\u00adtocols. Checking Object Protocols. \nAn obvious technique to check protocol invariants is to encode the object protocol with its auxiliary \n.elds (for example, accessed and owner in the Representation Containment protocol) as part of the partici\u00adpating \nobject, and encode the protocol invariant as the object invariant.Then,we can usea toolfor checking objectinvari\u00adants(suchasINVCOP)tocheck \nprotocolinvariants. However, this technique has two major dif.culties. First, errors can be made in the \ndescription of the protocol. It is un\u00adsatisfactory to detect such protocol errors while checking if a \nparticular program conforms to a protocol, since these are generic errors independent of the particular \nprogram being checked. It is desirable to detect such errors at the level of the protocol description \nitself (without bringing the program into the picture). Second, as our empirical results show, the overheadof \ncheckingifaprogramobeysaprotocolinvariant purely at runtime is unacceptably high (seeTable2in Sec\u00adtion \n6). This overhead is due to a large number of changes to protocol .elds, and validations thatare consequently \ntrig\u00adgered by automatic dependencytracking. We solve both these problems using the following methodology.We \nspecify the object protocol outside of the program using a simple language PROLANG. A PROLANG description \nof an object protocol consists of auxiliary .elds, methods that manipulate auxiliary .elds, and a protocol \nin\u00advariant. Each protocol method makes assumptions about the values of the auxiliary .elds, and changes \nthe values of the auxiliary .elds(See Figure3in Section3). Our goal is to check if a given program M \nfollows a protocol P with protocol invariant PI. Our methodology decomposes this check into two parts: \n First, we perform a protocol correctness check using static analysis (using automated theorem provers). \nThis checks if the protocol description of P in PROLANG, satis.es the protocol invariant PI.  Next, \nwe perform a program conformance check at run\u00adtime. This checks if a run r of a program M satis.es the \nprotocol P .  The protocol correctness check involves analyzing the proto\u00adcol methods that manipulate \nthe auxiliary .elds, and check\u00ading if every method satis.es the protocol invariant under certain assumptions \nspeci.ed in the method body. The pro\u00adgramconformance checkinvolvesonly discharging these as\u00adsumptions, \nand the entire protocol invariant is never directly checkedat runtime. Consequently,weareabletogreatlyop\u00adtimize \nthe runtime overheads during program conformance checking. Our work has two main researchcontributions: \n Dueto carefuldesignofthe protocol languagePROLANG and the runtime system, we are able to formally prove \nthat if the protocol correctness check (static) passes, and program conformance check (runtime) passes \nfor a run r, then the program indeed satis.es the protocol invariant for r (see Theorem3 in Section 4). \nThus, violations of protocol invariants are guaranteed to be detected exactly where they occur.  We \ndemonstrate that our language PROLANG is rich enough to express several object protocols from pub\u00adlished \nliterature (Section 5), and that the separation of concerns greatly reduces the overhead of checking \npro\u00adgram conformance (Section6).We also demonstrate that by bindingpubliclyavailable APIs with object \nprotocols, we can detect usage errors reported in discussion forums for commonly used APIs (Section 6). \n  Bene.ts to API designers. INVCOP++ enables API de\u00adsigners to create a library of veri.ed object protocols, \nand bind API classes or interfaces to appropriate protocols. De\u00adsign mistakes in protocols are detected \nstatically.A proto\u00adcol descriptioninPROLANG togetherwitha bindingtoAPI classes provides precise documentation \non how the API is to be used. Bene.ts to API clients. INVCOP++ enables API clients 1 to detect API protocol \nviolations at runtime, exactly where 32 they occur with noextraeffort on theirpart (assuming that 4 5 \ntheAPI designerhas includedPROLANGdescriptionsofthe object protocols governing API usage, bound to the \nAPI). 6 By verifying protocols statically, the overhead in checking 78 program conformance is signi.cantly \nreduced. 9 10 Limitations. We are aware of two main limitations of our work: 11 12 While our protocol \ncorrectness check is static and com-13 14 plete, our program conformance check is dynamic and 15 incomplete. \nThat is, we are able to guarantee program 16 17 correctness only for the runs that we check, and we are \n unable to show that a program satis.es a given proto-18 col invariant for all runs. This is the price \nwe pay for 19 20 .exibility. Unlike earlier approaches to object protocol 21 22 speci.cation, which \nforce API designers to use particular ownership type systems, or particular prede.ned object 23 24 protocols, \nwe allow different classes of the API to use 25 different protocols.We also allow API designers to .ne\u00ad \n26 tune object protocols according to their requirements (see Section 5). Our techniques work only for \nsequential programs, and furtherwork needstobe donetoextend thisto concurrent programs. Outline. The \nremainder of this paper is organized as fol\u00adlows.To make this paper self-contained, Section2 reviews \nthe core ideas behindINVCOP. Section3presents our proto\u00adcoldescription languagePROLANG. Section4describes \nthe static and runtime analyses performedby our new toolI N-VCOP++, and states the formalguarantees behind \nthe com\u00adbinationof staticand runtime analysis. Section5illustrates that several object protocols from \npublished literature can be modeled using P ROLANG, and hence consequently veri.ed and enforced usingINVCOP++. \nSection6presents empiri\u00adcal results from running INVCOP++on several APIs avail\u00adableinthe public domain. \nSection7compares ourwork with relatedwork, and Section8concludes the paper. 2. Background In this section, \nwe brie.y explain the core ideas behind INVCOP[18]. Consider the class Node in Figure1that is used to \ncon\u00adstructabinary search tree.Theinvariantof Node isexpressed by the Inv() method whichstates that if \nthe left child is not null, then itskey must be less than this node skey, and the treerootedattheleftchildmustbeavalidbinary \nsearchtree, i.e. left.Inv() must hold.Asimilar condition must hold if the right child is not null. Consider \nthe following client code that uses the BinarySearchTree API: class IntKey implements Key { int x; boolean \nLess(Key k) { IntKey o = (IntKey)k; return x < o.x; } } Key k1 = new IntKey(10); Key k2 = new IntKey(5); \nKey k3 = new IntKey(15); BinarySearchTree bst = ..; bst.Insert(k1); bst.Insert(k2); bst.Insert(k3); \n//now, we have a tree with k1 as the key //of the root node, k2 the key of its left //child and k3 the \nkey of the right child //the following statement breaks the invariant of root k2.x = 20; ... //assertion \nfails in bst.Insert bst.Insert(new IntKey(..)); interface Key{ //this < k? boolean Less(Key k); } class \nNode { Key k; Node left; Node right; Node(Key key) { k = key }; //object invariant of this node boolean \nInv(){ return((left==null || left.k.Less(k) &#38;&#38; left.Inv()) &#38;&#38; (right==null || k.Less(right.k) \n&#38;&#38; right.Inv())); } } class BinarySearchTree { Node root; //insert a key void Insert(Key k) { \n//code to create a new node //and insert k .. assert root.Inv(); } boolean Inv() { return (root==null \n|| root.Inv()); } } Figure 1. Binary SearchTree In the above example, the invariant of bst is violated \nby the statement k2.x = 20 (line 23),but goes undetected, since there is no way for the runtime to know \nthat an update to k2.x breaks the invariant of bst. Later in line 26, when bst.Insert is called and root.Inv() \nis checked, this violation is detected. Although it is not a good practice to insert mutable keys, API \nclient programmers make such mistakes and it is dif.cult to .nd the root cause of the violationin large \nprograms[10, 11]. The goal of INVCOPis to detect such violations exactly where they occur. I NVCOPuses \nruntime veri.cation to en\u00adforce the following inv-rule: The invariant of an object o (which can refer \nto the state of other objects p)must hold when control is outside of any of o s methods. The unique feature \nof I NVCOPis that it tracks object dependencies au\u00adtomatically.In this case, after inserting thekey k3 \n(line 17), during the execution of root.Inv(), it detects that root depends uponkeys k1,k2 and k3 since \nthese .elds are re\u00adferred in root.Inv(). When k2 is changed (line 23), IN-VCOP validates this change \nby asserting root.Inv() as root depends on k2. Using such dependencytracking,IN-VCOPguarantees that violations \nof theinv-rule are detected exactly when theyoccur. INVCOP assigns therole ObjWInv (object with invari\u00adant) \nto participating objects. This role has a boolean .eld inv,a side effect free function Inv() that returnsa \nboolean, and a set dependents. The .eld o.dependents contains the objects that depend on o. role ObjWInv{ \nboolean inv; boolean Inv(); Set<ObjWInv> dependents; } The participating objects are required to provide \nonly the Inv() function (as in Node in Figure 1). The .elds inv and dependents are automatically managed \nby I NVCOP. IN-VCOP must ensure that whenever o.inv is true, the func\u00adtion o.Inv() returns true in a \nprogram. By default, IN-VCOP sets o.inv to true when control exits public meth\u00adods of o, and sets o.inv \nto false when control enters pub\u00adlic methods of o. In the case of reentrant code, this can be modi.ed \nas desired. INVCOP sets o.inv to true only after asserting that o.Inv() returns true. In addition, during \nthe execution of o.Inv(), INVCOPmonitors all objectsp that are accessedby o.Inv() and adds o to p.dependents. \nWhen p is modi.ed,INVCOPautomatically checksthat forevery o . p.dependents, if o.inv is true, then o.Inv() \nindeed holds. If o.Inv() does not hold, then a violation of o s in\u00advariant has been detected exactly \nwhere it occurred. INVCOPguarantees that when a programP is executed with the code generated by INVCOP, \nfor anyrun r of pro\u00adgram P ,if no assertion violations are reportedbyINVCOP, then the following holds \nin all states of r: .o . ObjWInv.(o.inv = true) . (o.Inv() = true) For more details, see [18]. 3. Object \nProtocols In this section, we .rst describe the problems with checking protocol invariants purely at \nruntime using INVCOP. Then we introduce PROLANG, a language for describing object protocols. 3.1 Checking \nprotocol invariants at runtime Recall the Representation Containment protocol from Sec\u00adtion 1. This protocol \nensures that every object o with an owner is accessed only withthe knowledge of o sowner,and forevery \nobject o,its object invariant holds when it is not ac\u00adcessed. As we stated before, the protocol adds \ntwo auxiliary .elds accessed and owner for each object, and the protocol invariant is: .o. (o.accessed \n. (o.owner = null . o.owner.accessed)) .(\u00aco.accessed . o.Inv()) Suppose we want a binary search tree \nto behave accord\u00ading to this protocol.We could treat the protocol s auxiliary .elds as object .elds, \nencode the above invariant as the ob\u00adject invariant, and use INVCOPto ensure that the object in\u00advariant \nholds. This schemeisveryinef.cient.To seewhy, recall the class Node class from Section 2. The protocol \ncan be encoded in the class Node as follows: class Node : ObjWInv { //program fields Key k; Node left; \nNode right; //protocol fields boolean accessed; ObjWInv owner; //protocol invariant encoded as object \ninvariant boolean Inv(){ return((!accessed || (owner==null || owner.accessed)) &#38;&#38; (accessed || \n(left==null || left.k.Less(k) &#38;&#38; left.Inv()) &#38;&#38; (right==null || k.Less(right.k) &#38;&#38; \nright.Inv()))); } } Note that the encoded object invariant of Node is ob\u00adtained by substituting the original \nobject invariant of Node for o.Inv() in the protocol invariant (we have also rewrit\u00adtenimplicationsusing \ndisjunctions).Ifwe attempttouseIN-VCOPto enforce the object invariantofNode,it suffers seri\u00adous performance \nproblems as changes to the protocol .elds need to be tracked in addition to changes to program .elds, \nand additionally, changes to protocol .elds need to be vali\u00addatedby nodes that depend onthem. Consider \na tree with 100,000 nodes. Assume that the root owns all the nodes in the tree. This is in conformance \nwith the protocol, since the root (owner) is accessed before any node is accessed. However, if the protocol \nis encoded into theprogram, the Inv() function for each node depends on root, since the Inv function \nmentions owner.accessed and the root is the owner for all nodes in the tree. This depen\u00addencyis automatically \ntracked by INVCOP. When the tree is traversed, the root node is accessed .rst and its accessed .eld is \nset to true. INVCOP needs to validate this change with every node in the tree since every node in the \ntree de\u00adpends on the accessed .eld of the root! As our empirical results show (seeSection6,Table2, scenariosS3 \nand S4), this encoding is very inef.cient due to a large number of in\u00advariantvalidations triggeredbyautomatic \ndependencytrack\u00ading. Additionally, when the object protocol is encoded as part of a program, mistakes \ncould be made. Such errors at the protocol level can be detected only when a protocol is ap\u00adplied to \na speci.c program, which is unacceptable. There\u00adfore, we must detect errors in the protocol description \nat a higher level of abstraction. P ::= protocol pn body body ::= {auxfld+ method+ invariant} auxfld \n::= t ObjWInv.fn := c method ::= mn (arg +) {s} arg ::= ObjWInv o | Object[] p s ::= assume le|s; s \n| if(o.fn){s} else{s}| for(p in o.sfn){s}| o.fn := v | CheckAndSetInv(o) | o.sfn.Add(p) | o.sfn.Remove(p) \ninvariant ::= (.o : ObjWInv :: qle) t ::= boolean | ObjWInv | enum type | Set(ObjWInv) c ::= true | false \n| null | enum constant v ::= c | e e ::= o | o.fn | o.prn() | o.prn(Object[] p) le ::= logical expression \nqle ::= quanti.ed le that has inv pn . protocol names fn . aux. .eld names of anytype sfn . aux. .eld \nnames of Set type mn . method names prn . predicate names o, p . variable names Figure 2. Syntax ofPROLANG \n 3.2 Alanguageto specifyobjectprotocols We have designed a language PROLANG to describe object protocols \nseparately from programs, and solveboth the prob\u00adlems mentioned above. A PROLANG description of a pro\u00adtocol \nlooks like a class declaration with (1) auxiliary .eld declarations, (2) method declarations, and (3) \na protocol in\u00advariant speci.cation. However, the meaning of a auxiliary .eld declarations, method declarations, \nand protocol invari\u00adant are quite different from the usual notions associated with a class. Intuitively, \nthe auxiliary .eld declarations add auxil\u00adiary state to all objects, method declarations manipulate aux\u00adiliary \nstates of multiple objects, and protocol invariants are inductive invariants over the auxiliary state \nof all objects. Figure2shows the grammar forPROLANG. Below,wegive informal descriptionsofvariouspartsof \nthe grammar, fol\u00adlowedby anexample. Auxiliary .eld declarations.Object protocols are speci.ed by adding \nauxiliary .elds to each object which is assigned 1 the role ObjWInv, in addition to the .elds we introduced \nin Section 2. In particular, the boolean inv existsby default, 2 3 and can be manipulated by the protocol \nmethods. The set 4 dependents used by dependency tracking also exists. This 5 .eld cannot be accessed \nby the protocol methods. 6 Method declarations. Method declarations take one or 7 8 more objects as arguments, \nmake assumptions about the 9 protocol state, and change the protocol state. There are 10 two special \nmethods which are called by INVCOP++: 11 (1) Init(ObjWInv o). This method is called every time 12 13 \nan object o with subtype ObjWInv is initialized. (2) 14 15 Validate(ObjWInv o). Whenever an object p \nchanges, for every o whose Inv() method depends on p, this method is 16 called. 17 18 There are two \nrestrictions on coding the protocol meth\u00ad 19 20 ods. First, we stipulate that o.inv can be set to true \nonly by using CheckAndSetInv(o), which asserts o.Inv() before 21 22 setting o.inv to true: 23 CheckAndSetInv(ObjWInv \no) { 24 } 25 assert(o.Inv()); 26 o.inv := true; 27 28 29 30 Next, we require that every code path in \nthe method body for Validate(o) must either call CheckAndSetInv(o) or set 31 o.inv tofalse. 32 33 Protocol \ninvariant declaration. The protocol invariant 34 35 needs to be universally quanti.ed over all objects \nof type ObjWInv. i.e., of the form .o . ObjWInv..(o). 36 37 Binding. After specifying object protocols, \nAPI designers 38 need to associatetheir programs with appropriate protocols. 39 40 This is done using \na binding which speci.es the classes to be bound to the role ObjWInv and the program points 41 42 at \nwhich protocol methods need to be invoked. Mistakes 43 could be made in specifying the binding,but our \nchecking methodology is robust against such mistakes since we track dependencies automatically. Example. \nFigure3 shows the Representation Containment protocol [9] speci.ed using PROLANG. Note that this spec\u00adi.cation \nseparates the protocol from the program unlike our earlier encoding, which mixed the protocol description \nwith the program. This protocol adds two auxiliary .elds for every ob\u00adject that is assigned the role \nObjWInv: (1) a boolean .eld accessed, and (2) a reference .eld owner. In addition, the boolean .eld inv \nis available to the protocol methods. The protocol description has5methods: Init, Validate, Own, Access \nand Done. Recall the restriction that every code path in Validate(o) needs to either call CheckAndSetInv(o) \nor set o.inv tofalse. Note that the de.\u00adnition of Validate(o) in Figure3indeed satis.es this restric\u00adtion. \nTheprotocolis associated withaprogram througha bind\u00ading using Aspect Oriented Programming (AOP) [25]. \nSup\u00adpose that the API designer of binary search tree requires ev\u00ad protocol RepresentationContainment \n{ // boolean ObjWInv.inv exists by default boolean ObjWInv.accessed; ObjWInv ObjWInv.owner; Init(ObjWInv \no) { o.inv := false; o.accessed := true; o.owner := null; } Validate(ObjWInv o){ assume(o.accessed = \ntrue); o.inv := false; } Own(ObjWInv o, ObjWInv p) { assume(o.accessed = true); assume(p.owner = null \n|| p.owner = o); p.owner := o; } Access(ObjWInv o) { assume(o.accessed = false); assume(o.owner = null \n|| o.owner.accessed = true); o.accessed := true; } Done(ObjWInv o) { assume(o.accessed = true); CheckAndSetInv(o); \no.accessed := false; } invariant(forall o : ObjWInv :: (o.accessed ==> o.owner = null || o.owner.accessed) \n&#38;&#38; (!o.accessed ==> o.inv = true)); } Figure 3. Representation Containment Protocol declare parents: \nNode implements ObjWInv; declare parents: Key implements ObjWInv; //Inv method for Key public boolean \nKey.Inv() { return true; } Figure 4. Binding classes to the role ObjWInv ery node n in the treetoown \nthekey k it points to. First, the class Node and the interface Key needs to be bound to the role ObjWInv. \nThis is speci.ed (using AspectJ [1] syn\u00adtax) as shown in Figure 4. Then, after the .eld Node.key is set, \nthe protocol method Own needs to be invoked. This is speci.ed as shown in Figure 5. The pointcut (a speci.cation \nof interesting points in the program) setKey captures setting the .eld Node.key. The pointcut setKey(ObjWInv \nn, ObjWInv k) : set(private Key Node.key) &#38;&#38; target(n) &#38;&#38; args(k); after(ObjWInv n, ObjWInv \nk) returning : setKey(n,k) { Own(n,k); } Figure 5. Invoking protocol methods target is the node n whose \n.eldisbeingsetandtheargument is the key k. After the .eld Node.key is set, the protocol method Own(n, \nk) is invoked. Similarly, before anypublic method call on anyobject that implements Key, Access(k) is \ninvoked and after the call, Done(k) is invoked. Finally, note that the object protocol invariant is also \npart of the protocol description in Figure 3. 4. Analysis Given an object oriented program and an object \nprotocol witha protocolinvariantexpressedinPROLANG, wewould like to ensure that the program satis.es \nthe protocol invari\u00adant. Recall our .rst attempttodo thisin Section3,byencod\u00ading the protocol into the \nprogram, and encoding the protocol invariant as the object invariant, and the dif.culties faced with \nsuch an approach. We separate this veri.cation problem into two parts. Protocol correctness: check if \nthe object protocol P sat\u00adis.es its protocol invariant PI.  Program conformance: check if the program \nM con\u00adforms to the protocol P .  Our new tool INVCOP++ solves the protocol correctness problem using \nstatic analysis, and the protocol conformance problem using runtime analysis.We describe the two analy\u00adses \nbelow,and formally state and prove that the two analyses together ensure that the program M indeed satis.es \nthe pro\u00adtocol invariant. 4.1 Protocol correctness. We assume that the object protocol P is speci.ed in \nPROLANG. Using automated theorem proving (our imple\u00admentation uses Simplify [14]) we check whether P \nsatis.es its protocol invariant PI. The object protocol P is consid\u00adered as a state transition system \nof an unbounded number of objects, with the initial state of each object speci.ed by ex\u00adecuting the Init \nmethod, and subsequent states obtained by executing the other methods in the protocol.We wish to es\u00adtablish \nthat the set of all possible states that can be reached by executing the methods of the protocol P satisfy \nthe pro\u00adtocol invariant PI. Let PI be of the form .o \u00b7 .(o).For the base case, we need to show that the \nInit method satis.es the protocol invariant. Let Init(S) be a predicate that holds whenever S is the \nauxiliary state produced by running the Init action.We need to show that: .(S) \u00b7 Init(S) . S |= PI For \nthe inductive case, we need to show that for each method A in the protocol description, if we execute \nA from a state S1 that satis.es PI to reach a state S2, then S2 satis.es PI: .(S1,S2) \u00b7 S1 |= PI . A(S1,S2) \n. S2 |= PI Our tool, INVCOP++, automatically generates these proof obligations from the protocol description, \nand uses an auto\u00admated theorem prover to check these proof obligations. If the proofobligationisnotvalid,thenthe \ntheoremprovergivesa counterexample, which indicates whythe protocol does not satisfy the protocol invariant. \nThe following theorem states that our static analysis in\u00addeed establishes that a protocol satis.es its \nprotocol invari\u00adant. Theorem 1. Let P be any PROLANG protocol with proto\u00adcol invariant PI, such that \nthe Init action satis.es .(S) \u00b7 Init(S) . S |= PI and every other protocol method A satis.es .(S1,S2) \n\u00b7 S1 |= PI . A(S1,S2) . S2 |= PI. Then, foreveryreachable auxiliary state S suchthat S is ob\u00adtained by \nsuccessive execution of protocol methods, we have that S |= PI Proof. By induction over the sequence \nof protocol methods executed. Example. Recall the Representation Containment proto\u00adcol description from \nFigure 3. Let init(o) be a formula that holds whenever o is the result of executing the Init method. \nIn this example, init(o) is given below: init(o)= o.inv = false . o.accessed = true . o.owner = null \nNote that init(o) can be generated automatically from the body of Init in Figure 3. The protocol invariant \nPI is given by .o. .(o), where .(o)= o.accessed . (o.owner = null . o.owner.accessed) . (\u00aco.accessed \n. o.inv) The proof obligation for the Init method is thus given by: .o \u00b7 init(o) . .(o) Toprovethat theDone \nmethod preserves the protocol invari\u00adant, we proceed as follows.We wish to producea formula done(o1,o2) \nthat holds whenever an object can transition from state o1 to o2 by executing the Done method. Such a \nformula is given below: done(o1,o2)= o1.accessed . o2.inv .\u00aco2.accessed . o1.owner = o2.owner Again, \nwe notethat done(o1,o2) can be generated automat\u00adically from the body of Done in Figure 3. The proof \nobliga\u00adtion for the Done method is given by: .o1,o2 \u00b7 .(o1) . done(o1,o2) . .(o2) Suppose the protocol \ndesigner forgets to set o.inv to true in the method Done, i.e. line 34 is missingin Done. Then the above \nimplication does not hold as there exists an ob\u00adject o2 such that \u00aco2.accessed .\u00aco2 .inv which satis.es \n.(o1) .done(o1,o2) .\u00ac.(o2). The proof obligation forthe Done methodfails witha counterexample that shows \nsuch an object o2.  4.2 Program conformance. After verifying a protocol P as above, we use runtime anal\u00adysis \nto check if the runs of a program M conform to the protocol P . INVCOP++ uses Aspect Oriented Program\u00adming(AOP) \nto bind the protocol P s methods to appropriate points in the program M. After creation of every object \no with role ObjWInv, Init(o) is called to initialize o s auxil\u00adiary state. If an object p changes, then \nINVCOP++ guaran\u00adtees to invoke Validate(o) forevery o whose Inv() depends on p. INVCOP++converts the \nassume statements in the meth\u00adods of the protocol description P to assertions and checks them at runtime. \nThis ensures that the assumptions made by the static analysis to prove the protocol invariant are indeed \ndischarged at runtime. For anyprotocol invariantPI let PI be the formula ob\u00adtained by replacing every \npositive occurrence of o.inv with o.Inv().We refer to PI as the instantiated protocol invari\u00adant, since \nthe occurrences of o.inv have been instantiated with actual invariants from the program M.For the protocol \ninvariant PI in our example, PI is: forall o : ObjWInv :: (o.accessed = true ==> o.owner = null || o.owner.accessed \n= true) &#38;&#38; (o.accessed = false ==> o.Inv() = true) Our main theorem composes the results of the \nprotocol correctness and the program conformance phases. Theorem 2. Consider any protocol P with protocol \ninvari\u00adant PI and methods that satisfy conditions of Theorem 2. Let r be any run of program M superimposed \nwithprotocol P using some binding. Suppose r does not have any assertion violations. Then, in all states \nof r we have that the instanti\u00adated protocol invariant PI holds. Proof. Three sets of assumptions made \nby the static anal\u00adysis phase are guaranteed to be discharged by the runtime analysis. First, the static \nanalysis assumes that every ob\u00adject o s auxiliary state is initialized by the method Init(o), and the \nruntime ensures that the method Init(o) is indeed called for every object with the role ObjWInv. Second, \nthe static analysis assumes conditions stated in the method body on the auxiliary state during the veri.cation \nof each method. Theseassumptions are converted into assertions and checked by the runtime analysis. Finally, \nautomated depen\u00addencytracking ensures that Validate(o) is called whenever an object p that o depends \non changes. Since every code path in Validate(o) either establishes o.Inv() or sets o.inv tofalse,weareableto \nreuse Theorem1in Section2,anden\u00adsure that for every run r, the instantiated protocol invariant PI holdsifno \nassertionfailureis detectedat runtime. Our work employs an intricate interplay between static and runtime \nanalysis. During static analysis (to check pro\u00adtocol correctness) we assume conditions stated in protocol \nmethod bodies, and prove the protocol invariant inductively. During runtime analysis (to check program \nconformance), we merely discharge these assumptions, without having to check the entire protocol invariant. \nHowever, this alone is not suf.cient to get the guarantee obtained in Theorem 3, since the object invariant \nof o can be changed if some p that o depends on changes. In addition, we need the automatic dependencytracking \nand invalidation scheme from our ear\u00adlier work [18], and the constraints on the protocol methods (see \nSection 3.1) to prove Theorem 3. Performance and correctness bene.ts.Consider again, the binary tree \nexample from Section 3. Recall that when the object protocol invariant was encoded in the program, every \ntime the root node was accessed, the protocol invariant had to be checked for all the nodes of the tree \ndue to dependency tracking.However,by describing theprotocol separately us\u00ading PROLANG, and verifying \nthe object protocol invariant statically,I NVCOP++greatly reducesthe numberofchecks that need to be done \nat runtime. Indeed, the protocol invari\u00adant is never directly checked at runtime, and only the local \nassumptions made in the method bodies of the protocol de\u00adscription are checked at runtime. As our empirical \nresults show in Section 6, this greatly enhances the performance of the runtime analysis. Further,errors \nmade in the protocol de\u00adscription are now detected during the static analysis phase itself, independent \nof the program on which the protocol is enforced, leading to correctness bene.ts. 5. Scenarios In this \nsection, we demonstrate the expressiveness of PROLANG by encoding various object protocols from pub\u00adlished \nliterature.We motivate the need for each protocolby presenting a scenario that cannot be handled by the \nproto\u00adcols discussed prior to it. In Section 5.2, we show a scenario where we need to .ne-tune a protocol \nfrom the literature to suit the needs of the particular API under consideration. In addition to the Representation \nContainment protocol that we have discussed in Section 3, we consider three other protocols: (1) the \nPrivileged Reader protocol [6] that enables an object o to grant another object read access to objects \nowned by o, (2) the Boogie protocol [3] that enables an ob\u00adject o to own another object p and later, \ntransfer the owner\u00adship of p to a third object and (3) the Friends protocol [5] that enables several \nfriends to constrain state changes of a granter object that theyalldepend on. 5.1 Privileged Reader Suppose \nthat theAPI designerof BinarySearchTree used the Representation Containment protocol such that a tree \nowns all itsnodes andkeys. Consider implementing an it\u00aderator for iterating over the nodes in a tree \nas shown below. For simplicity, we show the protocol methods invoked (in bold) in the program itself. \nNote that the methods shown in bold are not actually writtenin the program,but are inserted by anAOP \ncompiler. class NodeIterator { BinarySearchTree tree = ..; //preorder traversal Node Next() { //current \npoints to //the node on top of //a stack of nodes .. Access(current); Push(current.left); Done(current); \n.. return current; } } The Next method needsto access the nodes directly with\u00adout accessing thetree. \nThe Representation Containment pro\u00adtocol is too restrictive for this scenario.Figure6 shows an extension \nof this protocol called Privileged Reader [6]. This protocol enables BinarySearchTree to let NodeIterator \nread its nodes. The protocol invariant states that if an object o is accessed, then either it has no \nowner or its owner has been accessed or a privileged object has accessed o. Instead of invoking Access, \nthe newly added method PAccess mustbeinvoked before an iterator accessesa node. The protocol invariant \nis maintained even though the owner ofanode(tree)isnot accessedas PAccess sets paccessed to true. 5.2 \nOwnershipTransfer In the protocols that we have discussed, once an object o owns another object p,it \nnevergivesupownershipof p. The API designer of BinarySearchTree would like thekeys in\u00adsertedbytheAPI \nclienttobeownedbyatreeonlywhenthe keys are partof that tree. Whenakeyis deleted froma tree, thenit mustgiveupownershipof \nthatkey. Figure7shows the Boogie protocol [3] that allows ownership transfer. The auxiliary .eld o.st \nkeeps track of whether object o is valid, invalid, or committed. The objects owned by o are elements \nof the set o.comp. The protocol invariant states that if an object o is either valid or committed, then \no s invariant holds and all objects p onwhich o depends are also committed. protocol PrivilegedReader \n{ //in addition to the fields in //representation containment protocol boolean ObjWInv.paccessed := false; \n//Methods not shown are the same as in //the representation containment protocol. Done(ObjWInv o) { assume(o.accessed \n= true); CheckAndSetInv(o); o.accessed := false; o.paccessed := false; } //PAccess is a new method PAccess(ObjWInv \no) { assume(o.accessed = false); o.accessed := true; o.paccessed := true; } invariant(forall o : ObjWInv \n:: (o.accessed = true ==> (o.owner = null || o.owner.accessed || o.paccessed)) &#38;&#38; (o.accessed \n= false ==> o.inv)); } Figure 6. Privileged Reader Protocol. The .eld o.st is modi.ed by the methods \nPack and Unpack. When an object o is packed, it transitions from in\u00advalid to valid state and all objects \np owned by o are com\u00admitted to o. The API designer must pack an object o after construction and after \na public method execution. When object o is unpacked, it transitions from valid to invalid state and \nall objects p ownedbyit becomevalid.The API designer must unpack o beforeapublic methodexecutes on o. \nNote that o can be unpacked only if it is not committed. If o is committed, then all objects which depend \non o must be unpacked before unpacking o. The method Own(o, p) adds p to the set o.comp, i.e. o owns \np. The method Giveup(o, p) removes p from o.comp, i.e. o gives up ownership of p. Using this protocol, \nevery node canown its children and the associatedkey. The tree canown the root node. Whenakeyis deleted \nfrom the tree, the node thatowneditmustgiveupownershipof thekey as follows: class BinarySearchTree { \nvoid Delete(Key k) { Unpack(this); //Locate the node z that owns k Node z=.. //Delete z from the tree \n.. Giveup(z,k); Pack(this); } } protocol Boogie { enum State {Invalid, Valid, Committed}; State ObjWInv.st; \nSet<ObjWInv> ObjWInv.comp; Init(ObjWInv o) { //Body supplied by rule designer o.inv := false; o.st := \nState.Invalid; o.comp := nullset; } Validate(ObjWInv o) { assume(o.st = State.Invalid); o.inv := false; \n } Pack(ObjWInv o) { assume(o.st = State.Invalid); CheckAndSetInv(o); for(p in o.comp) { assume(p.st \n= State.Valid); p.st := State.Committed; } o.st := State.Valid; } Unpack(ObjWInv o) { assume(o.st = \nState.Valid); o.st := State.Invalid; for(p in o.comp) p.st := State.Valid; } //o owns p Own(ObjWInv \no, ObjWInv p) { assume(o.st = State.Invalid); o.comp.Add(p); } //o gives up p Giveup(ObjWInv o, ObjWInv \np) { assume(o.st = State.Invalid); o.comp.Remove(p); } //rule invariant invariant (forall o: ObjWInv \n:: (o.st = State.Invalid || (o.inv &#38;&#38; (for all p: ObjWInv :: (p in o.comp ==> p.st = State.Committed))))); \n} Figure 7. Boogie Protocol. Conceptually, this protocol serves the purpose of the API designer,i.e.preventkeysthat \narepartofthe treefrombeing modi.edby an API client andgiveup ownershipof thekey when it is deleted. However, \nthis protocol does not allow the BinarySearchTree.Delete method to be implemented as in [12]. Suppose \nthat the tree bst containsthree nodes root, y and z with y astheleft childof root and z as the left child \nof y andthekeytobe deletedisownedbythenode z. The value of the st .eld for these objects are shown in \nFigure 8. The tree bst is invalid as it has already been unpacked. Therefore, the root is valid and the \nnodes y and z are committed.Todelete node z,nodey must be unpacked. However, to unpack y, all the nodes \nalongthe path from the root to the node y must be unpacked and later theymust be packed again in the \nreverse order. Thus, this protocol as it is, does not permit a straightforward implementation of the \nDelete method. Figure 8. Problem deleting node z. However, we can implement the Delete method as is \nby changing the ownership structure of this protocol, based on an idea in [9]. The tree can own all the \nnodes (as opposed to every node owning its children) and each node can own its associated key. Therefore, \nwe modify the Boogie protocol to allow indirect references to owned objects as shown in Figure 9. A new \nauxiliary .eld owner is added. The protocol in\u00advariant has the additional condition that if an object \nis in\u00advalid,thenitsowneris eithernullorinvalid.Thenewmethod ToOwner(o, p) lets o.owner to own p. This \nmethod must beinvoked whena child .eld(left or right)of a node is set.Asthenodewhose .eldisbeingsetisownedbythetree, \nits child will also be ownedby the tree even though the tree does not refer directly to the child node. \nWith the modi.ed protocol, all nodes along the path from root to the node y are valid since the tree \nhas already been unpacked. Therefore, y can be unpacked to delete node z. Thus, the Delete method need \nnot be modi.ed to accom\u00admodate the Boogie protocol. The modi.ed protocol also al\u00adlows a node to give \nup the key it owns when the key is deleted from the tree. This discussion illustrates the need for mixing-and-matching \nideas from various protocols to .ne\u00adtune a protocol accordingtothe requirementsoftheAPIde\u00adsigner.  5.3 \nFriends Constrain Granter Consider the classes Connection and Statement in the JDBC API [22]. The API \ndesigner must express the con\u00adstraint that if any statement s created using a connection c is open, then \nthe connection c must not be closed. Since protocol IndirectReference { //new auxiliary field //initialized \nto null ObjWInv ObjWInv.owner; ToOwner(ObjWInv o, ObjWInv p) { assume(o.owner != null &#38;&#38; o.owner.st \n= State.Invalid); o.owner.comp.Add(p); p.owner := o.owner; } Unpack(ObjWInv o) { assume(o.owner = null \n|| o.owner.st = State.Invalid); assume(o.st = State.Valid); o.st := State.Invalid; for(p in o.comp) \np.st := State.Valid; } invariant (forall o : ObjWInv :: (o.st = State.Invalid ==> (o.owner = null || \no.owner.st = State.Invalid)) &#38;&#38; (o.st != State.Invalid ==> (o.inv &#38;&#38; (p in o.comp ==> \np.st = State.Committed)))); } Figure 9. Boogie Protocol with Indirect Reference. several statements can \nshare the same connection, this con\u00adstraint cannot be enforced by letting a statement s own its connection \nc using one of the protocols above as all of them allow an object to have at most one owner. The Friends \nprotocol [5] shown in Figure 10 can be usedby the JDBC API designer. The auxiliary .eld granter points \nto the shared object on which constraints are imposed and the .eld friends contains the objects which \nimpose constraints on the granter. In this example, the granter .eld of all statements s point to the \nconnection c and the friends .eld of c contains all statements s created using c. If the .eld ok of a \nfriend is true, then that friend agrees to a proposed state change of the granter. The protocol invariant \nstates that if a friend f is valid and its granter is not null, then the granter must know about f, i.e. \nf . f.granter.friends and f agreed to the last state change of thegranter, i.e. f.ok is true. The API \ndesigner can invoke the methods Attach and Detach toaddandremove friendstoa granter.The auxiliary .eld \nok of a friend f is set to true when the object f is packed. The API designer invokes UpdateGuard before \na state change of the granter. This method queries each friend using the method OK. If the friend f agrees \nto the change, then the .eld f.ok issetto true, otherwiseitissettofalse. Figure 11 shows how the JDBC \nAPI designer would use the Friends protocol. In scenario 1, a statement s created using a connection \nc is attached as a friend of the granter protocol Friends { enum State {Invalid, Valid}; State ObjWInv.st; \nboolean ObjWInv.ok; ObjWInv ObjWInv.granter; Set<ObjWInv> ObjWInv.friends; Init(ObjWInv f) { f.inv := \nfalse; f.st := State.Invalid; f.ok := false; f.granter := null; f.friends := nullset; } Validate(ObjWInv \nf) { if(f.st = State.Valid) CheckAndSetInv(f); else f.inv := false; } Attach(ObjWInv g, ObjWInv f) { \nassume(g != null); assume(g.st = State.Invalid); assume(f.granter = null); f.granter = g; g.friends.Add(f); \n } Detach(ObjWInv g, ObjWInv f) { .. } UpdateGuard(ObjWInv g, Object[] args) { assume(g.st = State.Invalid); \nfor(f in g.deps) { assume(f.granter = g); f.ok := f.OK(args); assume(f.st = State.Invalid || f.ok); \n } } Pack(ObjWInv f) { assume(f.st = State.Invalid); .. f.ok := true; f.st := Valid; } Unpack(ObjWInv \no) { assume(o.st = State.Valid); o.st := State.Invalid; } invariant(forall f : ObjWInv :: f.st = State.Valid \n==> f.inv &#38;&#38; (f.granter = null || (f in f.granter.friends &#38;&#38; f.ok))); } Figure 10. FriendsProtocol. \nc. If the statement s is open, then it constrains updates of the .eld Connection.closed of the granter \nc such that Connection.closed is not set to true. In scenario 2, an API client closes the connection \nc without being aware that the statement s is still open. Before updating this .eld, the protocol method \nUpdateGuard isinvoked. Thisinvokes the method OK on the friend s which returnsfalse and the auxil\u00adiary \n.eld s.ok is set tofalse. At runtime, this causes an as\u00adsertion violation as the statement s is valid \nand not ok with the proposed state change of connection c. 6. Experience We present our experiences \nin implementing the above methodology in a tool I NVCOP++ and using it to enforce API protocols.INVCOP++hastwocomponents:(1)theVer\u00adi.er \nimplements the protocol correctness check describedin Section 4.1, and (2) the Enforcer implements the \nprogram conformance check described in Section 4.2. 6.1 Protocol Correctness TheVeri.er implementsthe \nprotocol correctness check we saw in Section 4.1. In particular, it veri.es that the object protocol \naction Init establishes the protocol invariant and the other protocol actions maintain the protocol invariant. \nTheVeri.er generatesproofobligationstobeveri.edbyan automated theorem prover. If a proof obligation is \nnot valid, then the theorem prover returns a counterexample which can help the protocol designer in correcting \nmistakes in the protocol. Table 1 summarizes the results of protocol veri.cation. Our implementation \nuses the Simplify theorem prover [14]. For each protocol, the columns show the number of proof obligations, \nwhether it was veri.ed and the time taken in milliseconds. IndirectReferencev1is obtainedby comment\u00ading \nout the assumptions to the Unpack action in Figure 9. Simplify generates a counterexample stating that \nthe proto\u00adcol invariant cannot be preserved since o becomes invalid and its owner can still be valid. \nAfter correcting this mis\u00adtake,the protocol IndirectReferencev2asshowninFigure9 is veri.ed correct. The \nproof obligations corresponding to the object protocols we have considered from the literature seems \nsimple enough for Simplify that each protocol is ver\u00adi.ed in 70 ms.  6.2 Program Conformance The Enforcer \nimplements the program conformance check wesawin Section 4.2.Foragivenprotocol descriptionand a binding \nto API classes, the Enforcer generates an aspect. If the API clients include this aspect in their build, \nthen protocol violations are detected exactly where they occur in client programs. Our implementation \ntakes as input a protocol description in PROLANG and a binding written using AspectJ [1] syntax. It then \ngenerates an aspect which canbe compiled using theAspectJ compiler. Each protocol method is mapped to \na method in the as\u00adpect. Assume statements in protocol actions are translated to assert statements. Based \non the binding, the protocol meth\u00adodsareinvokedandtheexecution proceedsonlyifthepre\u00adcondition of the \nprotocol method is satis.ed. At runtime, a singleton instance of the generated aspect is created in the \nvirtual machine and it enforces the associated protocol. The generated aspect computes dependencies of \nan object o dynamically by recording all the objects and .elds refer\u00adenced during the execution of o.Inv() \nas in our earlier tool INVCOP [18]. Whenever a .eld f of object p is changed, for all objects o such \nthat o depends on p.f, the Validate method from the PROLANG description of the protocol is called. Table2shows \nresults from enforcing object protocols on two realworld APIs, JDOM and MySQL JDBC, and several other \nprograms that illustrate violations typical of realistic design scenarios involving multiple API objects. \nThe .rst columngives the API name, and the column Num Classes gives the number of classes exposed by \nthe API. The col\u00adumn Scenario gives the protocol scenario enforced. Ta\u00adble3gives more details on each \nscenario. The column Pro\u00adtocol gives the name of the object protocol on which the program is checked \nfor conformance. The column n gives the number of scenarios executed and d gives the number ofobjects \nthat each object depends upon. The columnIN-VCOP shows the time taken to check protocol correctness andprogram \nconformance at runtime with our old toolIN-VCOP. The column INVCOP++ shows the time taken to check program \nconformance with our new toolINVCOP++. When the number of dependents for an object is small, we get a \n2X performance improvement using static analysis, When the number of dependents is large, the performance \nimprovement is even larger, and for large values of d, the time taken by the unoptimized tool INVCOP \nis unaccept\u00adably high. Protocol #of proof obligations Veri.ed Time (millisec) Representation Containment \n5 yes 70 PrivilegedReader 6 yes 70 Boogie 6 yes 70 IndirectReference v1 7 no 70 IndirectReference v2 \n7 yes 70 Friends 7 yes 70 Table 1. ProtocolVeri.cation API Num Classes Scenario Protocol n d INVCOP \n(ms) INVCOP++ (ms) JDOM 69 S1 Boogie 2000 4000 8000 16000 1 1 1 1 3915 8452 14461 43663 3324 5437 9834 \n21191 MySQL 95 S2 Friends 900 1000 2000 4000 900 1000 2000 4000 3055 4046 * * 160 161 180 231 BinarySearchTree \n3 S3 Representation Containment 50 100 150 200 50 100 150 200 2043 14942 53788 124489 1011 7721 22893 \n59596 BinarySearchTree 3 S4 Representation Containment variant 100 200 400 800 100 200 400 800 5618 39707 \n* * 220 540 1802 7360 Patient Observations 3 S5 Representation Containment 2000 4000 8000 16000 1 1 1 \n1 471 831 1492 2714 280 490 841 1492 Deserialization 3 S6 Representation Containment 2000 4000 8000 16000 \n1 1 1 1 140 170 250 371 50 50 80 110 Table 2. Execution time in milliseconds for INVCOP and INVCOP++, \nillustrating performance improvement obtained by combining static and dynamic analysis. The column labeled \nn shows the number of times a usage scenario was executed. Thecolumn labeled d showsthenumberofobjectsthatdependonaprotocol.eldand \nthereforethenumberoftimes Validate is called when sucha .eld changes. Thevalue Num Classes shows the \ntotal numberof API classes.A subsetof these are boundtoa protocol.Acellwith a * indicatesthatthetimetakenis \nmorethan3minutes. As described earlier, in the old tool INVCOP the object protocol is encoded into the \nprogram as described in the .rst partof Section3and therefore protocolcorrectness and pro\u00adgram conformance \nare checked at runtime. The new toolIN-VCOP++ exploits the static analysis (i.e, the protocol cor\u00adrectness \ncheck) to optimize the runtime check. In particular, no validation checks are triggered for updates to \nprotocol .elds since the protocol has been statically validated. The only runtime checks are (1) the \nassertions thatarise from the assume statementsinthe methodsoftheP ROLANGdescrip\u00adtion of the protocol, \nand (2) the dependencychecks that arise from updates to the existing .elds ofthe objects (excluding the \nauxiliary .elds used to model the protocol). Below, we give details on the APIs for each scenario in \nTable 2. For more details, see [27]. Scenario Num Classes Description involved S1 3 Iterate over an \nXML document and remove certain elements through the iterator S2 3 Create statements using the same connection \nS3 3 Search keys in a tree S4 2 Insert keys into a tree S5 2 Print observations through patient S6 2 \nAccess content of review through deserialized manager Table 3. Description of scenarios 6.2.1 JDOM [23] \nJDOM is an API that facilitates in-memory representation of XML documents and iterating over and manipulating \nthe contentofsuch documents.Figure12showsausageofclass Document in JDOM.Adocument iterator for navigating \nan XML document(intheformofatree)usesastackoflistiter\u00adators where each list iterator is used for iterating \nover nodes at each level in the tree. An element in the tree is returned bythelist iteratorontopofthe \nstack.Ifthe clientcodecalls detach on an element, then it is removed from the list of nodes at that level. \nThe iterator becomes invalid if the un\u00adderlying collection is modi.ed without its knowledge. This happens \nif the client code invokes detach during iteration. The iterator throws ConcurrentModificationException \nif the next methodis calledagain.Fromtheexception trace, it is dif.cult for JDOM developers to .nd out \nwhere exactly the API protocol was violated[24]. After compiling with the aspect generated by IN-VCOP++ \nfrom the Boogie rule, the stack trace is as shown below. Here, the iterator owns the list when iteration \nstarts andgivesupownershipof thelist after iteration ends. java.lang.AssertionError: Unpack(o) o.st != \nState.Valid, o.st = Committed o.class = class jdom.ListProxy at rules.Boogie_jdom.Unpack(Boogie_jdom.aj:319) \n.. at org.jdom.Content.detach(Content.java:91) at ItemHandler.processItem(OrderHandler.java:10) at OrderHandler.processOrder(OrderHandler.java:23) \n This clearly points out thatthe client code processItem violated the API protocol by calling Content.detach \nwhichmodi.esthelist withouttheknowledgeofthe iterator. Note thataclass C canbeboundtothe role ObjWInv \nbyAs\u00adpectJ only if the byte code of C is under its control. Since we cannot bind java.util.Iterator to \nObjWInv,our proto\u00adtype implementation uses proxy objects tokeep track of the relationship between an \niterator and its collection. 6.2.2 MySQL JDBC [28] As we discussed in Section 5.3, a connection must \nnot be closed before closing any statement created by that con\u00adnection. However, JDBC API programmers \nmake such mis\u00adtakes [21] and it is hard to locate where exactly the connec\u00adtionwas closed whena statementdependingon \nthat connec\u00adtion is still open. The Friends protocol shown in Figure 10 is bound to classes Statement \nand Connection such that all the state\u00adments s created using a connection c share the connection c and \nc can be closed only if all statements s that depend on it are closed. 6.2.3 Patient and Observations \n[17] Consider a scenario where two objects need to be merged. For example, in a hospital management system, \non admit\u00adting a patient, a record is created. Later, it might be discov\u00adered that a separate patient \nrecord had already been created for the same patient. It is important to tie the two records together \nbecause the subsequent treatment might depend on the observations in both the records. For this, the \nAPI de\u00adsigner uses a superseding strategy in which one patient ob\u00adject is marked as active and the other \nobject for the same patient as superseded. The superseded object is not deleted because it contains the \ninformation based on which a patient was treated before the objects were tied together. All data in the \nsuperseded object is copied to the active object and method calls on the superseded object are delegated \nto the active object. The clients of this API may not know about the details of the superseding strategy \nand therefore may write a program in which a reference to the observations part of patient is retained \nassuming that it contains all the observations for a patient. Later, if two patient objects are merged, \nthen this assumption does not hold anylonger and could cause errors as shown in Figure 13. The Representation \nContainment protocol can be used to prevent an API client from directly accessing observations without \naccessing patient. If the API designer wants clients to iterate over observations, then the Privileged \nReader pro\u00adtocol can be used. 6.2.4 Deserialization [29] A class may depend on the fact that the objects \nit refers to through private .elds are not available through object references outside the class.Forexample, \nconsider classes Manager and Reviews. Even if a manager refers to the reviews object through a private \n.eld, it may be possible to steala reference to the reviews object during deserialization. Usingsuchareference,thereviewscouldbereadwithoutthe \nknowledge of a manager. The Representation Containment protocol can be used to prevent this. 7. RelatedWork \nSeveral papers have pointed out the need to specify and check protocols involving multiple objects. In \n[19], behav\u00adioral compositions and obligations on participants have been identi.ed as key to object oriented \ndesign. Recently, [20] has pointed out the need to enforce framework constraints (which typically involve \nmultiple objects) so that plugin writers cannot violate them. Several ownership type systems have been \ninvented to track dependencies between objects [9, 6]. The proposals in the literature differ in how \ntheyconstrain programs: for ex\u00adample, some allow ownership transfer whereas some others do not. Programveri.cation \ntoolshave beenbuiltto check if programmers follow particular programming methodolo\u00adgies [3]. When multiple \nobjects depend on a shared object (as in manystatements depend on the same connection), the methodology \nneeds to be extended [5]. Also, these systems do notwork withexisting programming languages.For each \nprotocol, one has to use the corresponding veri.cation sys\u00adtem thatworksonlyfor that protocol.Wehavebeen \nableto encode,verify and enforce all theseprotocols uniformlyin ourwork.With our approach,the user can \nmix-and-match various protocols for various parts of the API, and .ne\u00adtune the protocol while still being \nable to use INVCOP++ to verify and enforce the protocol. However, the price paid for this .exibility \nis that our program conformance check is dynamic, whereasownership type systems and programver\u00adi.cation \ntools are able to check program conformance stati\u00adcally. JML [26] requires that an invariant must hold \nat the end ofeach constructor sexecution,andatthebeginningandend of all public methods. JML s runtime \nchecker does not auto\u00admatically track dependencies of objects. Thus, if o depends on p, and p gets modi.ed \nin a way that violates o s invari\u00adant, the JML checker is not able to detect this at the point of violation. \nMOP [7] also generates aspects for runtime veri.cation from speci.cations. It is possible that such aspects \nacting as observers will miss relevant events in the program. There\u00adfore, one cannot guarantee that protocol \nviolations are de\u00adtectedexactly wheretheyoccurinAPI client programs.With INVCOP++,we offer the guarantee \nas stated in Theorem 2. 8. Conclusion We have presented a methodology to check if client pro\u00adgrams that \nuse object oriented APIs satisfy API protocol in\u00advariants. Our methodology involves stating reusable \nobject proto\u00adcols involving inter-related objects in PROLANG. Our tool INVCOP++ checks statically that \nmethods of a protocol es\u00adtablish and maintain its protocol invariant and checks at run\u00adtime whether a \nprogram conforms to a protocol. We have validated this methodology by stating and verify several ob\u00adject \nprotocolsinPROLANG andusingINVCOP++to detect protocol violations reported in discussion forums on widely \nused APIs. By judiciously combining static and dynamic analysis, we are able to reduce the performance \noverhead of runtime checking. When compared to approaches such as ownership type systems, our approachisfar \nmore .exible, and allows mix\u00adand-match and .ne-tuning of object protocols. However, we are able to check \nprogram conformance only at runtime. Checking program conformance statically with an arbitrary protocol \nspeci.ed in PROLANG requires further research. Also, extending our work to concurrent programs, and han\u00addling \nsubclasses, require further research. Acknowledgement. We thank Mike Barnett, Rustan Leino,ToddMillstein,AdityaNori,G. \nRamalingamandSer\u00addarTasiran for helpful comments on draftsof this paper. References [1] AspectJ http://www.eclipse.org/aspectj/. \n[2] T. Ball and S. K. Rajamani. The SLAM project: Debugging system software via static analysis. In POPL \n02: Principles of Programming Languages, pages 1 3.ACM, January 2002. [3] M. Barnett, R. DeLine, M.F\u00a8ahndrich, \nK. R. M. Leino, and W. Schulte. Veri.cation of object-oriented programs with invariants. JOT, 3(6):27 \n56, 2004. [4] M. Barnett,K.R.M.Leino, andW. Schulte.The Spec# pro\u00adgramming system: An overview. In CASSIS \n04: Construction and Analysis of Safe,Secureand Interoperable Smart devices, LNCS 3362. SpringerVerlag, \n2004. [5] M. Barnett and D. A. Naumann. Friends need a bit more: Maintaining invariants over shared state. \nIn MPC, pages 54 84. Springer-Verlag, 2004. [6] C. Boyapati, B. Liskov, and L. Shrira. Ownership types \nfor object encapsulation. In POPL, pages 213 223.ACM, 2003. [7] F. Chen and G. Rosu. Mop: an ef.cient \nand generic runtime veri.cation framework. In OOPSLA, pages 569 588, 2007. [8] B. Chin, S. Markstrum, \nand T. Millstein. Semantic type quali.ers. In PLDI 05:Programming LanguageDesign and Implementation, \npages 85 95.ACM, 2005. [9] D. G. Clarke, J. Potter, and J. Noble. Ownership types for .exible alias protection. \nIn OOPSLA, pages 48 64, 1998. [10] http://www.servlets.com/archive/servlet/ ReadMsg?msgId=539019&#38;listName=jdom-interest. \n[11] http://bugs.mysql.com/bug.php?id=2054. [12] T. H. Cormen, C. E. Leiserson, and R. L. Rivest. Introduction \nto Algorithms. The MIT Press, 1992. [13] R. DeLine andM.F\u00a8ahndrich. Enforcing high-level protocols in \nlow-level software. In PLDI 01: Programming Language Design and Implementation.ACM, 2001. [14] D. Detlefs, \nG. Nelson, and J. B. Saxe. Simplify: a theorem prover for program checking. J.ACM, 52(3):365 473, 2005. \n[15] S. Fink, E.Yahav, N. Dor, G. Ramalingam, and E. Geay. Effective typestate veri.cation in the presence \nof aliasing. In ISSTA06: SoftwareTesting and Analysis.ACM, 2006. [16] J. S.Foster,T.Terauchi, and A. \nAiken. Flow-sensitive type quali.ers. In PLDI 02: Programming Language Design and Implementation, pages \n1 12.ACM, 2002. [17] M. Fowler. Analysis Patterns: Reusable Object Models. Addison-Wesley, 1997. [18] \nM. Gopinathan and S. Rajamani. Runtime monitoring of object invariants with guarantee. In RV 08: Runtime \nVeri.cation, LNCS 5289. Springer, 2008. [19] R. Helm, I. M. Holland, and D. Gangopadhyay. Contracts: \nSpecifying behavioural compositions in object-oriented systems. In OOPSLA/ECOOP, pages 169 180, 1990. \n[20] C. Jaspan and J. Aldrich. Checking framework plugins. In OOPSLA Companion, pages 795 796, 2007. \n[21] http://archives.postgresql.org/pgsql-jdbc/ 2003-10/msg00062.php. [22] http://java.sun.com/products/jdbc/download. \nhtml#corespec40. [23] JDOM http://www.jdom.org. [24] JDOMFAQ http://www.jdom.org/docs/faq.html# a0390. \n[25] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C.V. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented \nprogramming. In ECOOP, pages 220 242, 1997. [26]G.LeavensandY. Cheon. Designby contractwithjml,2003. \n[27] http://people.csa.iisc.ernet.in/~gmadhu/oopsla. [28] MySQL http://www.mysql.com. [29] http://java.sun.com/javase/6/docs/platform/ \nserialization/spec/security.html#4271. [30] R. E. Strom and S. Yemini. Typestate: A programming language \nconcept for enhancing software reliability. IEEE Trans. Softw. Eng., 12(1):157 171, 1986.    \n\t\t\t", "proc_id": "1449764", "abstract": "<p>In this paper, we consider object protocols that constrain interactions between objects in a program. Several such protocols have been proposed in the literature. For many APIs (such as JDOM, JDBC), API designers constrain how API clients interact with API objects. In practice, API clients violate such constraints, as evidenced by postings in discussion forums for these APIs. Thus, it is important that API designers specify constraints using appropriate object protocols and enforce them. The goal of an object protocol is expressed as a protocol invariant. Fundamental properties such as ownership can be expressed as protocol invariants. We present a language, PROLANG, to specify object protocols along with their protocol invariants, and a tool, INVCOP++, to check if a program satisfies a protocol invariant. INVCOP++ separates the problem of checking if a protocol satisfies its protocol invariant (called protocol correctness), from the problem of checking if a program conforms to a protocol (called program conformance). The former is solved using static analysis, and the latter using runtime analysis. Due to this separation (1) errors made in protocol design are detected at a higher level of abstraction, independent of the program's source code, and (2) performance of conformance checking is improved as protocol correctness has been verified statically. We present theoretical guarantees about the way we combine static and runtime analysis, and empirical evidence that our tool INVCOP++ finds usage errors in widely used APIs. We also show that statically checking protocol correctness greatly optimizes the overhead of checking program conformance, thus enabling API clients to test whether their programs use the API as intended by the API designer.</p>", "authors": [{"name": "Madhu Gopinathan", "author_profile_id": "81375603298", "affiliation": "Indian Institute of Science, Bangalore, India", "person_id": "P1223193", "email_address": "", "orcid_id": ""}, {"name": "Sriram K. Rajamani", "author_profile_id": "81100468626", "affiliation": "Microsoft Research India, Bangalore, India", "person_id": "P1223194", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1449764.1449784", "year": "2008", "article_id": "1449784", "conference": "OOPSLA", "title": "Enforcing object protocols by combining static and runtime analysis", "url": "http://dl.acm.org/citation.cfm?id=1449784"}