{"article_publication_date": "01-26-2011", "fulltext": "\n Verifying Higher-Order Functional Programs with Pattern-Matching Algebraic Data Types C.-H. Luke Ong \nOxford University Computing Laboratory lo@comlab.ox.ac.uk Abstract Type-based model checking algorithms \nfor higher-order recursion schemes have recently emerged as a promising approach to the veri\u00ad.cation \nof functional programs. We introduce pattern-matching re\u00adcursion schemes (PMRS) as an accurate model \nof computation for functional programs that manipulate algebraic data-types. PMRS are a natural extension \nof higher-order recursion schemes that in\u00adcorporate pattern-matching in the de.ning rules. This paper \nis concerned with the following (undecidable) veri\u00ad.cation problem: given a correctness property ., a \nfunctional pro\u00adgram P (qua PMRS) and a regular input set I, does every term that is reachable from I \nunder rewriting by P satisfy .?Tosolve the PMRS veri.cation problem, we present a sound semi-algorithm \nwhich is based on model-checking and counterexample guided ab\u00adstraction re.nement. Given a no-instance \nof the veri.cation prob\u00adlem, the method is guaranteed to terminate. From an order-n PMRS and an input \nset generated by a regular tree grammar, our method constructs an order-n weak PMRS which over-approximates \nonly the .rst-order pattern-matching behaviour, whilst remaining completely faithful to the higher-order \ncontrol .ow. Using a variation of Kobayashi s type-based approach, we show that the (trivial automaton) \nmodel-checking problem for weak PMRS is decidable. When a violation of the property is detected in the \nabstraction which does not correspond to a violation in the model, the abstraction is automatically re.ned \nby unfolding the pattern-matching rules in the program to give successively more and more accurate weak \nPMRS models. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; \nF.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General \nTerms Languages, Veri.cation 1. Introduction In the past decade, huge strides have been made in the \ndevelopment of .nite-state and pushdown model checking for software veri.ca\u00adtion. Though highly effective \nwhen applied to .rst-order, imper\u00adative programs such as C, these techniques are much less useful for \nhigher-order, functional programs. In contrast, the two standard Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 Steven J. Ramsay Oxford University \nComputing Laboratory ster@comlab.ox.ac.uk approaches to the veri.cation of higher-order programs are \ntype\u00adbased program analysis on the one hand, and theorem-proving and dependent types on the other. The \nformer is sound, but often impre\u00adcise; the latter typically requires human intervention. Recently, a \nmodel-checking approach, based on higher-order recursion schemes (HORS), has emerged as a veri.cation \nmethod\u00adology that promises to combine accurate analysis and push-button automation. HORS are a form of \nsimply-typed lambda-calculus with recursion and uninterpreted function symbols that is presented as a \ngrammar and used as a generator of (possibly in.nite) trees. Ong showed that the trees generated by HORS \nhave a decidable modal mu-calculus theory [14] and Kobayashi introduced a novel approach to the veri.cation \nof higher-order functional programs by reduction to their model-checking problems [6]. This method has \nbeen applied successfully to the Resource Us\u00adage Veri.cation Problem [3] (and, through it, to such problems \nas reachability and control-.ow analysis) for a simply typed func\u00adtional language with .nite data-types \nand dynamic resource cre\u00adation and resource access primitives. The method relies on the exis\u00adtence of \ncertain transformations which, given a functional program and a resource usage speci.cation, reduce the \ncorresponding ver\u00adi.cation problem to the question of whether the computation tree of the program, generated \nby a HORS, satis.es a resource-wise speci.cation encoded by an automaton on in.nite trees. Despite the \nhigh worst-case time complexity of the modal mu-calculus model\u00adchecking problem for recursion schemes, \nwhich is n-EXPTIME complete for order-n schemes, an implementation of this approach, TRecS, performs \nremarkably well on realistic inputs [7]. From a veri.cation perspective, a serious weakness of the HORS \napproach is its inability to naturally model functional pro\u00adgrams with in.nite data structures, such \nas integers and algebraic data-types. This severely limits the potential impact of this pro\u00adgramme as \nfunctions de.ned by cases on algebraic data types are ubiquitous in functional programming. A model of \nfunctional programs. Our .rst contribution is the introduction of pattern-matching recursion schemes, \nwhich are HORS extended with a notion of pattern matching. A PMRS is a kind of restricted term-rewriting \nsystem. We believe that PMRS have a very natural syntax into which large classes of functional programs \ncan readily be translated. A typical rule, which is re\u00adquired to be well typed, has the shape: Fx1 \u00b7\u00b7\u00b7 \nxm p(y1, \u00b7\u00b7\u00b7 ,yk) -. t where the variables x1, \u00b7\u00b7\u00b7 ,xm are (possibly higher-order) formal parameters \nof the non-terminal (or de.ned operator) F .The ex\u00adpression p(y1, \u00b7\u00b7\u00b7 ,yk), which takes the place of \nthe .nal parame\u00adter, is a pattern constructed from terminal (or constructor) symbols and variables y1, \n\u00b7\u00b7\u00b7 ,yk.  Example 1. The following PMRS de.nes a function Merge : ablist . ablist . ablist that merges \ntwo lists of a and b by recursively destructing them. Merge x nil -. x Merge x (cons a y) -. cons a (Merge \nyx) Merge x (cons b y) -. cons b (Merge yx) The patterns in the second argument position are used both \nto decompose compound data structures (so as to select the required components), and to determine control \n.ow. Selected components are communicated to the right-hand side of the chosen rule by means of binding \nto the variables in the pattern. Remark 1. Our work is not the .rst to propose a pattern-matching extension \nto HORS. A recent paper by Kobayashi, Tabuchi and Unno [9] introduces an extension of HORS called higher-order \nmulti-parameter tree transducers (HMTT). HMTT model func\u00adtions that may employ pattern matching but, \nin return, must satisfy a rigid type constraint. An HMTT function takes tree arguments of input sort \ni (which are trees that can only be destructed) and re\u00adturns a tree of sort o (which are trees that can \nonly be constructed). Pattern matching is only allowed on trees of sort i. Consequently HMTT functions \nare not compositional in the natural way. We be\u00adlieve our PMRS model to be both simpler and more natural. \nA veri.cation problem. This paper is concerned with the follow\u00ading veri.cation problem. Given a correctness \nproperty ., a func\u00adtional program P (qua deterministic PMRS) and a regular set I of input (constructor) \nterms, does every term that is reachable from I under rewriting by P satisfy .? It is straightforward \nto see that the problem is undecidable. Example 2. Consider the PMRS P which, when started from Main \ntakes as input a list of natural numbers and returns the same list with all occurrences of the number \nzero removed. The de.ning rules of P are given by: Main m -. Filter Nz m If ab true -. a If ab false \n-. b Nz z -. false Nz (s n) -. true Filter p nil -. nil Filter p (cons xxs) -. If (cons x (Filter pxs)) \n(Filter pxs)(px) The input set I is given by a regular tree grammar G (equivalently order-0 recursion \nscheme). The de.ning rules of G are: S -. ListN N -. z N -. s N ListN -. nil ListN -. cons NListN As \nusual, the start symbol of G is taken to be S. The correctness property . is: any outcome of the program \nis a list containing no zeros . This is easily expressible as a trivial automaton A, whose de.nition \nis omitted. An algorithmic solution. Our second contribution is a sound but incomplete semi-algorithm \nfor solving the problem, which is based on a counterexample-guided abstraction re.nement loop [2, 11]. \nThe input to the algorithm consists of a PMRS P representing the program, a regular tree grammar G (equivalently \nan order\u00ad0 recursion scheme) representing the set I of possible inputs to Input  no Feasible? Violation? \n no yes yes No Yes Figure 1. Counterexample-guided abstraction-re.nement loop. the program and a trivial \ntree automaton A (which is to say, an automaton on in.nite trees with a trivial acceptance condition) \nrepresenting a speci.cation . of good behaviour. The algorithm proceeds according to the diagram in Figure \n1. In step (1) we compute a sound abstraction of the behaviour of P when started from terms in I. From \nan order-n PMRS P and an order-0 recursion scheme G, we build an order-n weak pattern\u00admatching recursion \nscheme (wPMRS) which over-approximates the set of terms that are reachable from I under rewriting by \nP. A wPMRS is similar to a PMRS, except that its pattern matching mechanism is only able to determine \ncontrol .ow; it is unable to decompose data structure. Our method is a kind of .ow analysis. The .rst \n and key stage of the algorithm is a binding analysis which is inspired by Jones and Andersen [5]. It \nperforms a .xpoint construction of a .nite set . of variable-term bindings such that, for every variable \nx (formal parameter of rewrite rule), every term that is ever bound to x during the computation is derivable \nfrom .. In the second stage, we use the .xpoint set . to build rules of the over-approximating wPMRS. \nThese rules model the bindings of all non-pattern-matching (in\u00adcluding all higher-order) variables precisely; \nthey only approximate the binding behaviours of the pattern-matching variables. This is in contrast to \nJones and Andersen s algorithm, which builds a regu\u00adlar tree grammar that over-approximates the binding \nset of every variable. For an order-n PMRS, our algorithm produces an order\u00ad n wPMRS PfG as an abstraction, \nwhich is a tighter approximation of the order-n PMRS being analysed than regular tree grammars (which \nare equivalent to order-0 wPMRS). To our knowledge, our algorithm gives the most accurate reachability \n/ .ow analysis of its kind. The weakened pattern-matching mechanism of wPMRS makes it possible to decide \na model checking problem for it, which is the content of step (2). Given a wPMRS W, a closed term t and \na B\u00a8 uchi automaton with a trivial acceptance condition A, we decide if every (possibly in.nite) tree \ngenerated by W on input t is accepted by A. The proof uses a variation of Kobayashi s type-based approach. \nIf the model-checker fails to .nd any violation of the property then, since the approximating wPMRS PfG \nde.nes a superset of the terms reachable under P from I, the loop in Figure 1 will terminate because \nP satis.es A on I. However, if the model-checker reports a counterexample, then it may be that P also \nviolates the property (for some term in I), but it may also be that the counterexample is an artifact \nof an inaccuracy in the abstraction. To determine which of these possibilities is the case, in step (3) \nwe analyse the non\u00addeterminism introduced in the abstraction to see whether, in this particular counterexample, \nit behaves well or behaves badly.  In step (4) the abstraction process is re.ned. Due to the fact that \nthe abstractions only ever approximate the (.rst-order) pat\u00adtern matching variables, whilst remaining \nfaithful to all the oth\u00aders, there is a simple notion of automatic abstraction-re.nement, whereby patterns \nare unfolded to a certain depth in the PMRS P, . : s . S .N (VAR) (CONST) G,x : s f x : s G f . : s G \nf t0 : s . t G f t1 : s (APP) G f t0 t1 : t Figure 2. A simple type system for applicative terms. Outline. \nThe rest of the paper is organised as follows. Sec\u00ad forming a new PMRS P'. In the abstraction P' fG of \nP', the rules tion 2 introduces PMRS, wPMRS and other technical preliminar\u00ad that de.ne the approximation \nwill be more accurate and, in partic-ies. In Section 3, the abstraction algorithm, which takes a program \nular, the spurious counterexample will no longer be present. Since (PMRS) and an input set (order-0 recursion \nscheme) and returns a any rule in a wPMRS abstraction P' fG is perfectly accurate when\u00adwPMRS, is presented; \ntermination and soundness of the approxi\u00ad ever the pattern parameter contains no free variables, this \nmethod mation are proved. Section 4 presents a type-inference algorithm of unfolding gives rise to a \nsemi-completeness property. Given any no-instance of the PMRS veri.cation problem, the loop in Figure \n1 will eventually terminate with the answer No . Returning to Example 2, whilst performing step (1) we \nobtain an over-approximation of the binding behaviour of the variables in the program .. This .xpoint \nset contains, amongst others, the bindings: x . N and xs . ListN . From this set, we construct an for \ndeciding if every tree generated by a given wPMRS is accepted by a trivial automaton. The abstraction \nre.nement algorithm is the topic of Section 5. Finally Section 6 presents related work. Note: a long \nversion of the paper is available [15], which contains the proofs and additional material.  2. Preliminaries \napproximating wPMRS PG, whose rule-set contains the following: Filter p nil -. Nil f We introduce PMRS, \na model for functional programs manipulat\u00ading algebraic data types; wPMRS, a restriction of PMRS with \ngood algorithmic properties and the PMRS Veri.cation Problem, whose Filter p (cons xxs) -. solution is \nthe subject of the remainder of this work. If (Cons X (Filter pXS)) (Filter pXS)(pX) X -. N XS -. ListN \ntogether with, amongst others, all the P and G rules in Example 2 except those for Filter. Unfortunately \nthe wPMRS is too coarse to be useful: there are trees (representing lists) that are obtained by rewriting \nfrom Main S that are not accepted by the trivial automaton A. However, these are spurious counterexamples. \nFor an illustration, consider the error trace in the wPMRS: Main S . * Main (cons (sz) nil) . * Filter \nNz (cons (sz) nil) . If (Cons X (Filter Nz XS)) (Filter Nz XS)(Nz X ) . * If (cons z (Filter Nz nil)) \n(Filter Nz XS)(Nz (sz)) . * cons z (Filter Nz nil) . * cons z nil The problem can be traced to the second \nclause of Filter in the wPMRS: when replacing the variable x by the non-terminal X, the connection between \nthe two occurrences of x in the RHS is lost, as the reduction of one occurrence of X is independent of \nthat of the other. The re.nement algorithm produces a new, unfolded PMRS P' that replaces the two de.ning \nrules of Filter by .ve new rules. The two rules that cover the case when the list is a singleton are \nshown below: Filter p (cons z nil) -. If (cons z (Filter p nil)) (Filter p nil)(p z) Filter p (cons (s \nv2) nil) -. If (cons (s v2)(Filter p nil)) (Filter p nil)(p (s v2)) Applying the approximation algorithm \nto PMRS P' (and input 2.1 Types, terms and substitutions Fix a .nite set (b, o .) B of base types.The \nsimple types (s, t .) S are those expressions that can be constructed from the base types using the arrow: \ns, t ::= b | s . t. We adopt the usual convention that arrows associate to the right and omit parenthesis \naccordingly. The order of a type t , denoted ord(t ), is a measure of the nestedness of the arrow constructor \non the left; it is de.ned by ord(b)=0 and ord(s . t )= max{ord(s)+1, ord(t )}. Applicative terms. Fix \na .nite, simply-typed alphabet (f, g, a .) S of .rst-order terminal symbols (or constructors), a .nite, \nsimply\u00adtyped alphabet (F, G, H .) N of (arbitrary-order) non-terminal symbols (or de.ned operators) and \na denumerable set (x, y, z .) V of variables. The constructor terms T (S) are those expressions that \ncan be built from terminals using application.  The closed terms T (S, N ) are those expressions that \ncan be built from terminals and non-terminals using application.  The patterns are those expressions \np, q of base type that can be built from variables of base type and terminals.  The applicative terms \nT (S, N , V) are those expressions that can be built from terminals, non-terminals and variables using \napplication.  We denote the free variables of a term t by FV(t). Standardly, applicative terms may be \nassigned simple types via a formal system of typing judgements, G f s : t (where G is a .nite set of \ntype bindings) de.ned by the rules in Figure 2. When an applicative term t can be assigned a simple type \nt1 . \u00b7\u00b7\u00b7 . tm . b wesaythatithas arity m and write ar(t)= m. Henceforth, by term we shall mean well-typed, \napplicative term. grammar G), we obtain a wPMRS fG P' that does accurately capture Labelled trees. \n symbols in O, such that dom(t) is pre.x-closed, and if t(x)= f then { i | xi . dom(t) } = { 1, \u00b7\u00b7\u00b7 , \nar(f) }. Standardly we identify T (S) with .nite S-labelled trees, and write T 8(S) for the collection \nof (possibly in.nite) S-labelled trees. Let S. be S .{.} with ar(.)=0. Given a closed term t, we write \nt. for the .nite, S.-labelled tree de.ned by recursion as follows: for m = 0 ( . if . = F .N (.s1 \u00b7\u00b7\u00b7 \nsm). := fs. \u00b7\u00b7\u00b7 s . otherwise . = f . S 1 m E.g. (f(g(Ga))b). = f(g .)b. S.-labelled trees can be en\u00addowed \nwith a natural complete partial order . in which, for all trees t, .. t and fs1 \u00b7\u00b7\u00b7 sm . ft1 \u00b7\u00b7\u00b7 tm iff \nfor all i, si . ti. Substitutions. A substitution is just a partial function . in V. T (S, N , V). By \nconvention, we do not distinguish between a substitution and its homomorphic extension to the free algebra \nT (S, N , V) and we will write the application of both using pre.x juxtaposition. A term t is said to \nmatch aterm u precisely when there exists a substitution . such that t = .u. We shall say that a substitution \n. is closed whenever every term in its image is closed.  2.2 Pattern-matching recursion scheme (PMRS) \nA pattern-matching recursion scheme (PMRS) is a quadruple P = (S, N , R, Main) with S and N as above. \nR is a .nite set of rewrite rules, each of which is one of the following shapes (m = 0): (pure) Fx1 \u00b7\u00b7\u00b7 \nxm -. t (pattern-matching) Fx1 \u00b7\u00b7\u00b7 xm p -. t where p is a pattern (which may be trivial). Main : b . \no is a distinguished non-terminal symbol whose de.ning rules are always pattern-matching rules. In this \npaper we will assume that the variables appearing as formal parameters to de.ning rules in a PMRS will \nalways be distinct. A pure rule Fx1 \u00b7\u00b7\u00b7 xm -. t is well-typed when F : t1 . \u00b7\u00b7\u00b7 . tm . o .N and the judgement: \nx1 : t1, ..., xm : tm f t : o is provable. A pattern-matching rule Fx1 \u00b7\u00b7\u00b7 xm p -. t is well-typed when \nF : t1 .\u00b7\u00b7\u00b7 . tm . b . o .N and there exist base-types b1, ..., bk such that the judgements: y1 : b1, \n..., yk : bk f p : b and x1 : t1,...,xm : tm,y1 : b1, ..., yk : bk f t : o are provable. We say that \na PMRS is well-typed just when each of its rules is well-typed. We will only consider well-typed PMRS \nin the following. We de.ne the order of a PMRS to be the maximum order of (the type of) any of the non-terminal \nsymbols in N . Since a pure rule can be simulated by a pattern-matching rule with a trivial pattern (e.g. \na nullary terminal of a distinguished base type), we shall sometimes .nd it convenient to treat all PMRS \nrules as pattern\u00admatching rules. Reduction. We associate with each PMRS a notion of reduction as follows. \nA redex is a term of the form F.x1 \u00b7\u00b7\u00b7 .xm .p whenever . is a closed substitution and Fx1 \u00b7\u00b7\u00b7 xm p -. \nt is a rule in P.The contractum of the redex is .t. We de.ne the one-step reduction relation, .. T (S, \nN ) \u00d7 T (S, N ),by C[s] . C[t] whenever s is a redex, t is its contractum and C is a one-hole context. \nWe say that a PMRS is deterministic just if, given some redex Fs1 \u00b7\u00b7\u00b7 sn there is exactly one rule l \n-. r .R such that Fs1 \u00b7\u00b7\u00b7 sn = .l for some .. Given a PMRS P = (S, N , R, Main),let s . T (S, N ) beaclosedtermofbasetype.Wewrite \nL(P,s) to mean the language of S.-labelled trees obtained by in.nitary rewriting of the term s. More \nprecisely, de.ne L(P,s) as the collection of S.\u00adlabelled trees t such that there are (ti)i.. with s . \nt1 . t2 . t3 \u00b7\u00b7\u00b7 a fair reduction sequence (in the sense that for each Fi,every outermost redex in ti \nis eventually contracted) and t = { t. |i . . }. In case P is a deterministic PMRS, L(P,s) is a singleton \nset; we write the unique S.-labelled tree as [[s]]P . Example 3. Let S= {zero : nat, succ : nat . nat, \nnil : natlist, cons : nat . natlist . natlist} and N = {Rev : natlist . natlist, RevA : natlist . natlist \n. natlist}. The following deterministic, order-1 PMRS contains rewrite rules that implement list reversal \nwith an accumulating parameter: Main zs -. RevA nil zs RevA xs nil -. xs RevA xs (cons yys) -. RevA (cons \nyxs) ys When started from the term t = cons z nil, the only possible reduction sequence is: Main t . \nRevA nil t . RevA t nil . t and hence [[Main t]]P = t, as expected. 2.3 Weak pattern matching recursion \nschemes (wPMRS) A weak pattern-matching recursion scheme (wPMRS) is a quadru\u00adple W = (S, N , R, Main) \nwith S, N and Main as for PMRS. The (.nite) set R consists of rewrite rules of the shape (m = 0): (pure) \nFx1 \u00b7\u00b7\u00b7 xm -. t (weak-matching) Fx1 \u00b7\u00b7\u00b7 xm p -. t in which FV(p) n FV(t)= \u00d8. A pure rule is well typed \naccording to the same criteria as for pure PMRS rules. A weak-matching rule Fx1 \u00b7\u00b7\u00b7 xm p -. t is well-typed \njust when F : t1 .\u00b7\u00b7\u00b7 . tm . b . o .N and there exist base-types b1, ..., bk such that the judgements: \ny1 : b1, ..., yk : bk f p : b and x1 : t1, ..., xm : tm f t : o are provable (note that none of the \npattern-matching variables yj occurs in t). Henceforth we will only consider wPMRS with well\u00adtyped rules. \nwPMRS have exactly the same notion of reduction as PMRS: a redex is a term of the form F.x1 \u00b7\u00b7\u00b7 .xm .p \nwhenever . is a substitution and Fx1 \u00b7\u00b7\u00b7 xm p -. t is a rule in P. The contractum of the redex is .t \n= t[.x1/x1] \u00b7\u00b7\u00b7 [.xm/xm] (as the pattern-matching variables do not occur in t). The one-step reduction \nrelation, .,isde.nedasforPMRS. We de.ne the order, determinism and language of a wPMRS analogously with \nPMRS.  2.4 A veri.cation problem We are interested in solving the following veri.cation problem. Given \na program in the form of a PMRS P, a regular set I of in\u00adput terms, and a correctness property ., does \nthe output [[Main t]] of the program Main t satisfy ., for every input t .I?Topro\u00adpose a solution, we \nrequire two further stipulations, both of which concern the representation of the entities involved. \nHigher-order recursion schemes. A higher-order recursion scheme (HORS) is a quadruple G = (S, N , R,S) \nwith S and N as before and R is a .nite set of well-typed, pure wPMRS rewrite rules. The component S \nis a distinguished non-terminal called the start symbol . The reduction relation for HORS, ., is just \nthat of wPMRS, noting that all redexes will necessarily be of the form F.x1 \u00b7\u00b7\u00b7 .xm since there are no \npattern-matching arguments. We can associate with a recursion scheme G its language L(G) of terms in \nT (S) that can be derived from the start symbol S by rewriting away all occurrences of non-terminals. \nMore precisely, we make the following de.nition:  L(G):= { t | S . * t, t . T (S) } We de.ne the order \nof a recursion scheme analogously with PMRS and wPMRS. Note that (as generators of .nite ranked trees) \norder-0 recursion schemes are equivalent to regular tree grammars. Trivial automata. Let S be as before. \nA B\u00a8 uchi tree automaton with a trivial acceptance condition (or simply, trivial automaton) is a quadruple \nA = (S,Q, .,q0) where S is as before, Q is a .nite set of states, q0 . Q is the initial state, and ., \nthe transition relation, is a subset of Q\u00d7S\u00d7Q * such that if (q, f, q1 \u00b7\u00b7\u00b7 qn) . . then n = ar(f).A S-labelled \ntree t is accepted by A if there is a Q-labelled tree r such that (i) dom(t)= dom(r), (ii) for every \nx . dom(r), (r(x),t(x),r(x 1) \u00b7\u00b7\u00b7 r(xm)) . . where m = ar(t(x)). The tree r is called a run-tree of A \nover t. We write L(A) for the set of S-labelled trees accepted by A. The PMRS Veri.cation Problem. Given \na deterministic PMRS P = (S, NP , RP , Main), a (non-deterministic) order-0 recur\u00adsion scheme G = (S, \nNG, RG, S),and aB\u00a8uchi tree automaton with a trivial acceptance condition A = (S,Q, .,q0), we write: \nF (P, G, A) iff .t .L(G) \u00b7 [[Main t]]P .L(A) The PMRS Veri.cation Problem is to decide the truth of F(P, \nG, A).  3. Constructing an abstraction In this section we will present an algorithm which, given an \norder\u00adn deterministic PMRS P and an order-0 recursion scheme G, con\u00adstructs an order-n wPMRS PfG whose \nlanguage of S-labelled trees is an over-approximation of the set of S-labelled trees reachable from L(G) \nunder rewriting by P. At the heart of the algorithm is an analysis of the composite PMRS PG := (S, NG \n.NP , RG .RP , Main). Since every term s reachable from L(G) under rewriting by P (i.e. Main t . * s, \nP for some t .L(G)) is certainly reachable from S under rewriting by PG (i.e. Main S . * Main t . * s), \nit suf.ces to look only PG PG at the behaviours of PG in order to construct a safe abstraction of those \nof P. We detail the nature of this analysis and its properties separately before showing how it underlies \nthe construction of the approximating wPMRS PfG. Some nomenclature. A simple term is a subterm of the \nRHS of a PG-rule or is the starting term Main S.A compound term has the shape .t1 \u00b7\u00b7\u00b7 tm with m = 0, \nwhere the head symbol . is either a variable, or a terminal, or a non-terminal, and each ti is simple. \nIt follows from the de.nition that a simple term is compound, but the converse is not true. 3.1 Binding \nanalysis In a PMRS, the pattern matching rules use pattern matching both to determine control .ow (by \nselecting which of a number of de.ning rules is used to reduce a redex) as well as to decompose compound \ndata structure (by binding components to variables in the pattern that then occur on the RHS of the rule). \nHowever, the weak pattern matching mechanism in a wPMRS exhibits only the former capa\u00adbility: although \npatterns are matched, since there are no pattern\u00admatching variables on the RHS of de.ning rules, data \nstructures cannot be decomposed. Therefore, to build an effective abstraction of a PMRS requires some \nknowledge of the substitutions that can occur in redex/contractum pairs during PMRS reduction. To this \nend, we de.ne a binding analysis, which determines a (.nitary) over-approximation . to the set of variable-term \nbindings S { . | Main S . * C[F.x1 \u00b7\u00b7\u00b7 .xm .p] . C[.t] } which occur in redex/contractum substitutions \n. arising in PG-reductions from Main S . The analysis is based on the observation that every such redex \nis either Main S , or arises as an instance of a simple term. It proceeds by an iterative process in \nwhich bindings, by which instances of simple terms can be derived, give rise to redexes which in turn \ngive rise, via contraction, to more bindings, until the desired set . is reached in the limit. Before \nwe give the details of the analysis, let us make precise what it means for a set of bindings S to give \nrise to an instance of a term. Given such a set S, we de.ne the relation s .S t, which is a subset of \nT (S, N , V) \u00d7 T (S, N ), inductively, by the system RS: (R) t .S t (S) If x . s .S and C[s] .S t,then \nC[x] .S t  where C ranges over one-hole contexts. We say that an instance of rule (S) is a head-instance \njust if the hole in C[] occurs in head position. Example 4. Let S1 = {x . y b,x . N ,y . f z, z . a}. \nThen, using the system RS, it is possible to derive: Fxz .S1 F (fab) a and Fxz .S1 FN a Note that the \nform of rule (S) does not constrain bindings to be used consistently within non-linear terms. Let S2 \n= {x . f yz, y . z, y . a,z . b}. Then we have, for example: Fx (Gx) .S2 F (fab)(G (fbb)) in which the \nbinding y . a has been used in the derivation of the .rst argument of F whereas y . z has been used in \nthe derivation of the second argument. To ensure that the analysis is computable, we cannot afford to \nwork with instances of simple terms directly. We instead work with terms in which bindings have been \napplied only where strictly necessary in order to uncover new redexes. The construction of such terms \nis the purpose of the function head. The head function. Given a set S of bindings, we de.ne the head \nfunction, headS : T (S, N , V) -. 2T (S,N ,V) given by: headS(.t1 \u00b7\u00b7\u00b7 tm)= { dt1 \u00b7\u00b7\u00b7 tm | d . hsS (., \n\u00d8) } where hsS is an auxiliary function de.ned by the following: hsS(k, X)= {k} (whenever k . S .N ) \nhsS(x, X)= if x . X then \u00d8 else { dt1 \u00b7\u00b7\u00b7 tm | x . .t1 \u00b7\u00b7\u00b7 tm .S,d . hsS (., X .{x}) } Thus headS(u) \nis the set of terms that are obtainable from u by iteratively replacing the head symbol provided it is \na variable by a term bound to it in S. The second argument of hsS disre\u00adgards any cyclic chain of bindings. \nFor example, let S = { x . y, y . x }, then: headS(x)= hsS(x, \u00d8)= hsS (y, { x })= hsS(x, { x, y })= \u00d8 \nExample 5. Let S1 and S2 be as in Example 4. Then: headS1 (x c)= { N c, f z bc }headS2 (x c)= {f yz \nc} headS2 (Fx (Gx)) = {Fx (Gx)} Notice that since head performs variable-substitutions accord\u00ading to \nbindings from S, its behaviour is consistent with a strategy for constructing initial pre.xes of derivations \nin the system RS. Each use of the recursive clause of hsS corresponds to a head\u00adinstance of rule (S). \nA consequence of this relationship is made precise by the following lemma.  Lemma 1. If u S .v1 \u00b7\u00b7\u00b7 \nvm then there is a compound term .u1 \u00b7\u00b7\u00b7 um . headS (u) and, for all 1 = i = m, ui S vi. One .nal property \nto note about head is that, whenever its argument is compound and all the variables in S are bound to \nsimple terms, the terms in (sets in) its image are all compound. This is due to the fact that, in this \ncase, the action of the head function is to construct new, compound terms by prepending old, simple terms \ninto head position. This limited behaviour of the head-function will contribute towards guaranteeing \nthe termination of the analysis. Lemma 2. We say that a set of bindings S is image-simple just if every \nterm in the image of S is simple. Suppose S is image-simple. If u is compound, then every term in headS(u) \nis compound. The goal of the analysis is to discover the possible redexes F.x1 \u00b7\u00b7\u00b7 .xm .p that occur \nduring reduction sequences of PG starting from Main S. The head function headS (u) is able to determine, \nin a way that is computable, when an F -redex is an instance (according to S)ofasimpleterm u. In this \ncase, according to Lemma 1, a term of the shape Ft1 \u00b7\u00b7\u00b7 tm s is an element of headS (u). However, to \nknow which de.ning rule of F is triggered, it is necessary to .nd out which patterns are matched by residuals \nof instances of s. The approximate reduction. To this end, we introduce a new no\u00adtion of reduction CS \n. T (S, N , V) \u00d7 T (S, N , V) parametrised by a set of bindings S. This reduction approximates the usual \nPMRS reduction by performing redex/contractum substitutions only where absolutely necessary and only \nwhen the relevant bindings are contained in S.A CS-redex is a term of the form F.x1 \u00b7\u00b7\u00b7 .xm .p whenever \nthere is a PG0 -rule of the form Fx1 \u00b7\u00b7\u00b7 xm p -. t and . is a substitution (not necessarily closed). \nThe contractum of the redex is t, no substitution is per\u00adformed upon contraction. We de.ne the one step \nreduction CS by the following rules. Let C range over one-hole contexts. (s, t) a C-redex/contractum \npair t . headS(xt1 \u00b7\u00b7\u00b7 tm) C[s] CS C[t] C[xt1 \u00b7\u00b7\u00b7 tm] CS C[t] As is standard, we write C * S to mean \nthe re.exive, transitive closure of CS ,and Cn S to mean a n-long chain of CS . Example 6. Consider the \ncomposite PMRS PG constructed from the PMRS and grammar given in Example 2 and let S contain the bindings \np . Nz and x . N . Then the following: pxCS Nz xCS Nz N CS Nz (s N) CS true is a CS -reduction. Observe \nhow, as demonstrated by the third step, approximate reduction is accurate for order-0 G-rules. Given \na substitution . and a pattern p, we say that a CS \u00adreduction sCi .p is minimal just if it is not the \ncase that there S exist j<i and substitution . ' such that sCj . ' p. Consider the S two rules de.ning \nCS-reduction. In the RHS of the conclusion of each rule is the term t. In both cases, assuming S is image \nsim\u00adple, t is a compound term. Since there are only .nitely many such terms t and since there are only \n.nitely many patterns (drawn from the PMRS) p, the problem of .nding such minimal reductions is computable. \nLemma 3. Assume S is image-simple. Given a compound term s and a pattern p drawn from the de.ning rules \nof PG, the problem of .nding a substitution . and a minimal reduction sC * .p is S computable. The .xpoint \nconstruction. Let S be a set of bindings. We de.ne F(S) as the least set X of bindings that contains \nS and is closed under Rule C:if (i) u is simple term of base type, (ii) Ft1 \u00b7\u00b7\u00b7 tm s . headS (u),  \n(iii) Fx1 \u00b7\u00b7\u00b7 xm p -. t is a PG0 -rule, (iv) there is a minimal reduction sC * S .p then . .{ xi . ti \n| 1 = i = m }. X. Thus F :2V\u00d7T (S,N ,V) -. 2V\u00d7T (S,N ,V) is, by construction, a monotone (endo)function \non the complete lattice 2V\u00d7T (S,N,V) ordered by subset-inclusion. By the Tarski-Knaster Fixpoint Theo\u00adrem, \nthe least .xpoint of F, which we shall denote ., exists, and is constructable as the supremum of the \nchain \u00d8.F\u00d8.F(F\u00d8) .F(F(F\u00d8)) . \u00b7\u00b7\u00b7 Example 7. Consider again the composite PMRS PG composed from the PMRS \nP and tree grammar G given in Example 2. We shall apply the .xpoint construction to this structure. Initially, \nthe only fruitful choice of simple term is the starting term Main S which otherwise trivially satis.es \nthe premises of Rule C and yields the single binding m . S. Subsequently, taking u = Filter Nz m matches \nboth the de.ning rules for Filter after approximate-reductions of: mC{* m .S} nil and mC{* m .S} cons \nNListN respectively. This choice adds the bindings p . Nz, x . N and xs . ListN . Examining the term \npx in the RHS of the second de.ning rule for Filter then gives n . N . Finally, taking u as the entire \nRHS of the second de.ning rule for Filter and approximate-reducing px as in Example 6 gives bindings \na . cons x (Filter pxs) and b . Filter pxs. In this case, no other choices of simple term yield any new \nbindings, so the .xpoint . is obtained as: m . S, p . Nz,x . N ,xs . ListN n . N ,a . cons x (Filter \npxs),b . Filter pxs Though the complete lattice 2V\u00d7T (S,N ,V) is in.nite, the least .xpoint . is .nitely \nconstructable (i.e. the closure ordinal of F is .nite); it is in fact a .nite set. Observe that, in Example \n7, the form of every binding in the .xpoint is v . t in which t is a simple term. This is the key to \nshowing the convergence of the analysis. Since every term Ft1 \u00b7\u00b7\u00b7 tm s . headS(u) is compound (whenever \nS is image-simple and u is compound) so every binding xi . ti is image-simple. Since, whenever S is image-simple, \nevery CS \u00adcontractum is compound, so the bindings due to .p are image\u00adsimple. Since there are only .nitely \nmany simple terms, termination follows. Theorem 1 (Termination). The least .xpoint of F, ., is a .nite \nset. To see that this .nite set of bindings . is suf.cient to describe all the all the substitutions \nthat occur during redex contractions in reduction sequences of PG starting from Main S, one should .rst \nnotice that the approximate reduction, when instantiated with the .xpoint, acts on simple terms in a \nway which is consistent with the way PMRS reduction acts on their instances in a trivial context. .+ \nLemma 4. Assume .t is a contractum s .t and u is a simple term. If s .+ .t and u . s,then uC * . t and \nt . .t. . . u . * . t  To lift this fact to the level of arbitrary reduction sequences starting from \nMain S, it is enough to observe that any redex in such a sequence (apart from the .rst), can be seen \neither to be itself a simple term or to arise as a subterm of some previous contractum, regardless of \nthe context in which the redex occurs. As a consequence of Lemma 4, the variable-term bindings necessary \nto derive the redex as an instance of the corresponding simple term After applying the .xpoint construction \nto this example, the set of bindings . consists of the following: m . S . . KZero . . . x . 0 . . KOne \n. . . x1 . xx2 . x xs . S will already be contained in the .xpoint. Hence, if the reduction and hence \nthe approximating wPMRS sequence reaches any contractum, the .xpoint will contain the bindings necessary \nto reconstruct the substitution associated with the contraction. Lemma 5. Assume .t is a contractum. \nIf Main S .+ C[.t] is a PG-reduction sequence then t . .t.  3.2 Construction of the over-approximating \nwPMRS We are now ready to de.ne the wPMRS which is an abstraction of the composite PMRS PG = (S, N , \nR, Main).Let . be the .xpoint set of bindings and let NV = { Vx | x .V} and NS = { Ka | a . S } be two \nsets of fresh non-terminal symbols which we call pattern-symbols and accounting-symbols respectively. \nWe de.ne the approximating wPMRS: PG is as follows. f Main m -. Map2 KZero KOne M Map2 .. nil -. Nil \nMap2 .. (cons xxs) -. Cons (. X )(Map2 .. XS) KZero x1 -. Zero KOne x2 -. One M -. S X -. Zero XS -. \nS S -. Nil | Cons Zero S PG := (S, N.NV .NS, R ' consists of the following three kinds of rules: One \n-. 1 f , Main) Zero -. 0 where R ' I. Weak pattern-matching rules. For each (pure or pattern-Nil -. \nnil matching) PG-rule Fx1 \u00b7\u00b7\u00b7 xm p -. t, R ' contains the following rule: Cons v1 v2 -. cons v1 v2 Fx1 \n\u00b7\u00b7\u00b7 xm p -. t Since ., ., x1 and x2 are not pattern-matched variables, the rules II. Instantiation rules. \nFor each binding x . t in . where for V., V., Vx1 and Vx2 are, in this case, never used and so play \nno FV(t)= { x1, \u00b7\u00b7\u00b7 ,xl }, R ' contains the following rule: part in the approximation process: they have \nbeen omitted. It is easy f f PG, Main S) are exactly the .nite pre.xes of [0 1 01 \u00b7\u00b7\u00b7 ] i.e. the approximation \nis exact in where each zi is a fresh variable of the appropriate types. this case. III. Accounting rules. \nFor each terminal symbol Given any PG-reduction Main S .+ t, the reduction can a : b1 .\u00b7\u00b7\u00b7. bn . o in \nS, R ' contains the following rule: PG [Vx1 /x1] \u00b7\u00b7\u00b7 [Vxl /xl]) z1 \u00b7\u00b7\u00b7 zar(x) to see that the constructor \nterms in L( Vx z1 \u00b7\u00b7\u00b7 zar(x) -. (t be faithfully simulated in the abstractionusing the weak Ka z1 \u00b7\u00b7\u00b7 \nzn -. a z1 \u00b7\u00b7\u00b7 zn f pattern-matching rules and the instantiation rules. Whenever the PG-reduction contracts \na P-rule which binds data .y to a pattern matching variable y, the simulation can contract the corresponding \nredex using a weak pattern-matching rule and, by Lemma 5, can then reconstruct the bound data .y from \nVy using the instantiation rules. Theorem 2 (Soundness). Let the composite PMRS PG and the PG be as before. \nThen L(PG, Main S) . where each zi is a fresh variable of type bi. where we have written t to denote \nthe term t in which every oc\u00adcurrence of a pattern matching variable y . FV(p) has been re\u00adplaced by \nthe corresponding pattern-symbol Vy and every occur\u00adrence of a terminal symbol a has been replaced by \nthe correspond\u00ading accounting-symbol Ka . approximating wPMRS Example 8. Consider the following order-2 \nPMRS, whose de.n\u00ad f PG, Main S). Main m -. Map2 KZero KOne m The third class of rules is not essential \nto the achieving soundness. The purpose of the accounting rules is to enforce a strict corre\u00ad ing rules \nare given by: L( Map2 .. nil -. nil Map2 .. (cons xxs) -. cons (.x)(Map2 .. xs) KZero x1 -. 0 KOne x2 \n-. 1 and input grammar G consisting of two rules: S -. nil | cons 0 S The function Map2 behaves like \nthe standard Map function, except that it swaps the .rst two function arguments as it .l\u00adters through \nthe successive elements of the list argument. The reachable constructor terms are .nite lists that are \npre.xes of [0 10101 \u00b7\u00b7\u00b7 ]. spondence between the length of a f PG reduction sequence and the maximum \nsize of any constructor term created within it. This eases the justi.cation of the semi-completeness \nproperty of re.nement in Section 5.  4. Model checking by type inference In this section, we exhibit \nan algorithm to decide the wPMRS Model Checking Problem: given a non-deterministic wPMRS W = (S, N , \nR, Main) in which Main : b . o, a closed term t : b and a trivial automaton A,is L(W, Main t) .L(A)? \nFollowing work by Kobayashi [6] and Kobayashi and Ong [8], we characterise the model checking problem \nas a type inference problem in a particular, .nitary intersection type system induced by the automaton. \n Eliminating non-determinism. The.rststepwetakeistosim\u00adplify the problem at hand by eliminating the \nnon-determinism in W. To this end we construct a new wPMRS W# in which multiple de.ning rules for a given \nnon-terminal are collapsed using a fam\u00adily B := { brb | b . B } of non-deterministic choice terminal \nsymbols brb of type b . b . b.Wede.ne: W# := (S .B, N , { l -. BR(l) |.r \u00b7 l -. r .R}, Main) in which, \nby way of a short-hand, we de.ne: BR(Ft1 \u00b7\u00b7\u00b7 tn):= brb r1 (brb r2 (\u00b7\u00b7\u00b7 (brb rm-1 rm) \u00b7\u00b7\u00b7 )) where {r1, \n..., rm} = { r | Ft1 \u00b7\u00b7\u00b7 tn -. r .R} and the type of F is of the form t1 .\u00b7\u00b7\u00b7. tn . b. We must modify \nthe automaton A accordingly, so we de.ne: A# := (S .B,Q, . .{ (q, brb ,qq | q . Q, b . B },q0) Lemma \n6. For all terms t of base-type: L(W, Main t) .L(A) iff [[Main t]]W# .L(A#) Model checking as type inference. \nWe .rst introduce recursion schemes with weak de.nition-by-cases, which is a term rewriting system similar \nto (in fact, equi-expressive with) wPMRS; the dif\u00adference is that (weak) matching is explicitly provided \nby a case construct. Assume for each base type b, an exhaustive and non\u00adoverlapping family of patterns \nPb = { p1, \u00b7\u00b7\u00b7 ,pk }.A recur\u00adsion scheme with weak de.nition-by-cases (wRSC) is a quadruple G = (S, N \n, R,S) where S, N ,and S are as usual, and R is a set of (pure) rules of the form Fx1 \u00b7\u00b7\u00b7 xm -. t We \nwrite rhs(F )= .x1 \u00b7\u00b7\u00b7 xm.t. The set of applicative terms is de.ned as before, except that it is augmented \nby a de.nition-by\u00adcases construct caseb(t; t1, \u00b7\u00b7\u00b7 ,tk) with typing rule: G f t : b G f ti,o (for 1 = \ni = k) G f caseb(t; t1, \u00b7\u00b7\u00b7 ,tk): o We say that G is deterministic just if there is one rule for each \nF .N . There are two kinds of redexes: (i) Fs1 \u00b7\u00b7\u00b7 sm which contracts to t[s1/x1] \u00b7\u00b7\u00b7 [sm/xm] for each \nrule Fx1 \u00b7\u00b7\u00b7 xm -. t in R (ii) caseb(t; t1, \u00b7\u00b7\u00b7 ,tk) which contracts to ti, provided t of base type \nb matches pattern pi . Pb = { p1, \u00b7\u00b7\u00b7 ,pk }.  We de.ne evaluation contexts E as follows E ::= [] | ft1 \n\u00b7\u00b7\u00b7 ti-1 Eti+1 \u00b7\u00b7\u00b7 tar(f) and write . for the one-step reduction relation E[.] . E[ \u00b7 .] where (., \u00b7 \n.) ranges over redex/contractum pairs and E over eval\u00aduation contexts. Assuming G is deterministic, we \nde.ne the S.\u00adlabelled tree generated by G by in.nitary rewriting from S as [[G]] := { t. | S . * t }. \nLemma 7. Deterministic wPMRS and deterministic wRSC are equi-expressive as generators of S-labelled trees. \nWe present an intersection type system for characterising the model checking problem. The intersection \ntypes of the system are given by the grammar: m ^ s, t ::= q | p | ti . t i=1 where q . Q and p is one \nof the .nitely many patterns associated with a de.nition by cases in the scheme G. Judgements of the \ntype system are sequents of the form G f t : t ,inwhich G is simply a set of type bindings . : s where \n. .N .V. The de.ning rules of the system are as follows: (VAR) G,x : t f x : t (q, f, q1 \u00b7\u00b7\u00b7 qn) . .A# \n(TERM) G f f : q1 .\u00b7\u00b7\u00b7 . qn . q .. \u00b7 sp1 \u00b7\u00b7\u00b7 pn = .p (MATCH) G f s : p1 .\u00b7\u00b7\u00b7. pn . p G f t : pi G f ti \n: t (CASE) G f caseb(t; t1, \u00b7\u00b7\u00b7 ,ti, \u00b7\u00b7\u00b7 ,tn): t V n G f s : i=1 ti . t G f t : ti (for each 1 = i = \nn) (APP) G f st : t G,x : t1, \u00b7\u00b7\u00b7 ,x : tn f t : t V (ABS) G f .x.t : ni=1 ti . t Note that we have the \nfollowing derived rule from (Match): if aterm s (of the appropriate type) matches the pattern p,then \nG f s : p. We write fA G :G if G f rhs(F ): t is provable for every F : t . G.AwRSC is well-typed, written \nfA G,justif there exists G such that (i) fA G :G, (ii) S : q0 . G, (iii) for each F : t . G, t :: .,where \nF : . .N , meaning that t is an intersection type compatible with type . (as assigned to F by the wRSC), \nwhich is de.ned by: (i) q :: o, (ii) p :: b for each p . Pb, Vk (iii) i=1 ti . t ::. ' . . if t :: . \nand for each 1 = i = k, ti ::. ' . Theorem 3. Let A be a trivial automaton, and G be wRSC. Then fA G \nif and only if [[G]] .L(A). The proof is omitted as it is very similar to the proof of the soundness \nand completeness theorems in [6]. Corollary 1. The wPMRS model checking problem is decidable. Proof. \nThis follows from Lemma 6, Lemma 7 and Theorem 3, and the decidability of typability fA G. The latter \nfollows from the fact that for each non-terminal, there are only .nitely many candidate intersection \ntypes compatible with a given type.  5. Abstraction re.nement When the model checking stage reports \na counterexample in the form of an error trace, the trace may be feasible , that is, it corre\u00adsponds \nto a concrete reduction sequence in the original PMRS P, or it may be spurious : an artifact of the abstraction \nprocess. In the case the counterexample is spurious, we will want to ignore it and perform the process \nagain, but in a new setting in which we are guaranteed never again to encounter this unwanted trace. \nTo achieve this we restart the cycle from a modi.ed PMRS P ' ,which has had some of its de.ning rules \nunfolded, so as to reduce the amount of non-determinism in the corresponding wPMRS abstrac\u00adtion.  5.1 \nCounterexamples and feasibility. Labelling. The labelling procedure, labelSeq, keeps track of how non-determinism \nis resolved in an abstract reduction sequence by When the model-checker reports a violation of the property, \na coun\u00adannotating each live-symbol X with a set of (possibly open) terms, terexample error trace is returned. \nThis error trace is a reduction which represent all the closed terms to which it reduces. When the sequence \nin the abstract wPMRSPG.Since PfG is not completely faithful to the PMRS P, it is necessary to determine \nwhether such f terms are given by the set l, we write the annotated term Xl and we identify an unlabelled \nlive-symbol X with X\u00d8. Given a term ta counterexample trace corresponds to a reduction sequence in P \nwhich itself witnesses the violation or whether it is an artifact of which may include labelled subterms, \nwe de.ne the resolution of t, which is a set of terms t\u00af, de.ned as follows: 8 >>>< the abstraction. \n{a} when t = a . SAnatomy of a counterexample. It is useful to highlight two im\u00adwhen t = F is not a live-symbol \nportant features of any given counterexample trace, namely, (i) the t = {F } l when t = F l is a live-symbol \n{ uv | u . t0,v . t1 } when t = t0 t1 shape of the last term in the reduction sequence and (ii) the type \nof each constituent reduction . >>>: Any counterexample trace must end in a term t which witnesses where \nl denotes the set l when l is non-empty and {z} for some fresh variable z otherwise. If any pattern-symbol \nreduces to two the violation of the property .. Since the property is a collection of (possibly in.nite) \nS-labelled trees, the witnessing term can be seen to be of the form .q where q is a pattern which does \nnot match any incompatible terms or to a term which is inconsistent with the term pre.x of a tree t . \n.. We say that the pattern q which witnesses that it represents in the matching, then the procedure will \ndetect a the violation of the property is the error witness. con.ict and record it in the set Failures. \nPG classi.ed into one of two kinds based on the head symbol occurring f In any reduction sequence, each \nreduction u . v can be labelSeq(Main S) in the redex. In case we want to emphasise that the head symbol \nis a non-terminal belonging to P we say the contraction of this redex is an abstract P-reduction and \nwrite u .P v. Otherwise the head symbol is either a pattern-symbol, an accounting-symbol or it belongs \nto G. In this case we say that the head symbol in question is a live-symbol and that the contraction \nof this redex is an abstract If S is labelled by l and there is a term t .L(G) which is an instance of \nmgci(l) then do nothing else add (Main,l) to Failures. labelSeq(Main S . * u . v) 1. Analyse the reduction \nu . v: PG-reduction; we write u .g v. PG C[F.x1 \u00b7\u00b7\u00b7 .xm] .g C[t.x1 \u00b7\u00b7\u00b7 .xm]: PG Example 9. Consider \nthe following abstract error trace which is Label the head symbol F by t. PG of the PMRS P and grammar \nG f f derived from the abstraction C[F.x1 \u00b7\u00b7\u00b7 .xm .p] .P C[.t ]: given in Example 2: lk For each y S \n. FV(p),let {Vyl1 belled pattern-symbols in v created by the contraction. } be the la\u00ad , ..., V y Main \nS S Perform labelTm(.y)( {l1, ..., lk}) on the sponding occurrence of .y in .p.If labelTm fails, then \ncorre\u00ad . Filter Nz M . * Filter Nz (cons NListN ) add (F, . If (Cons X (Filter Nz XS)) (Filter Nz XS)(Nz \nX ) {l1, ..., lk}) to Failures. 2. For each occurrence of an unlabelled live-symbol N in u, . * If (Cons \nX (Filter Nz XS)) (Filter Nz XS)(Nz (s N )) let {Nl1 , ..., Nlk 1 Label this occurrence of N with k S \n} be the set of labelled descendants in v. {l1, ..., lk}. . If (Cons X (Filter Nz XS)) (Filter Nz XS) \nTrue 3. Perform labelSeq(Main S . * u). . * Cons X (Filter Nz XS) . cons X (Filter Nz XS) where the \nprocedure labelTm, which is designed to resolve the data bound in a pattern match and the data created \nby the abstraction, is . * cons z (Filter Nz XS) given by: which violates the property since it is the \nstart of a list that contains labelTm(t)({s1, ..., sk}) a zero. The error-witness for this trace is cons \nz v (for some variable v). The .rst reduction is an abstract P-reduction,asisthe Analyse the form of \nt: reduction written over lines 3 and 4 and that of lines 5 and 6. All the other reductions in the sequence \nare abstract f PG-reductions. The trace in the above example is spurious since there are no reduction \nsequences of the PMRS P (starting from terms in L(G)) from Example 2 which result in a list headed by \na zero. Intuitively, we can see that this trace is infeasible because the non-determinism introduced \nby the abstraction has been resolved in an inconsistent way during the sequence. The data bound by the \npattern match for Filter, which is given as N (i.e. some number) has been resolved on the one hand (line \n5) to a non-zero number and on the other hand (line 9) to zero. In the following, we de.ne a process \nof labelling of the coun\u00adterexample trace that will reveal information about the resolution of non-determinism \nthat has been introduced as a consequence of the abstraction. The information that is exposed will allow \nus to see t = a: If .i a matches si then do nothing else fail. t = F : If F is not a live-symbol and \n.iF matches si then do nothing else, if F is a live-symbol and w = mgci({s1, ..., sk}) exists then label \nF by {w} else fail. t = t0 t1: If .i either si is a variable or si = si0 si1 then (let sj0 = z0 and sj1 \n= z1 for fresh z1,z2 whenever sj is a variable) and perform labelTm(t0)({s10 , ..., sk0 }) and perform \nlabelTm(t1)({s11 , ..., sk1 }) else fail. where mgci(l) denotes the most general common instance (MGCI) \nof the set of terms l (regarding a single fresh variable as the MGCI of the empty set)1. We call a counterexample \ntrace that has been labelled by labelSeq a labelled trace. 1 For the purposes of calculating MGCIs, terms \nare considered as .rst order f PG has any corresponding trace in P starting form I, that is, whether \nthe trace is feasible. operator. Example 10. Consider again the abstract reduction sequence in from \nN , let the depth pro.le of R, denoted dp(R), be the function: Example 9, after performing labelSeq the \nfollowing labelled trace is produced (the set bracket notation has been elided since all labels dp(R)(F \n)= G are singleton sets): N { depth(p) | Fx1 \u00b7\u00b7\u00b7 xm p -. t .R} v1 v2 Main Scons cons v1 v2 . Filter \nNz M . * Filter Nz (cons NListN v2 ) cons z s . If (ConsX (Filter Nz XS)) (Filter Nz XS)(Nz X v0 ) cons \n. * If (ConsX z (Filter Nz XS)) (Filter Nz XS)(Nz (s N v0 )) cons true z . If (ConsX (Filter Nz XS)) \n(Filter Nz XS) True cons z . * ConsX (Filter Nz XS) z . cons X (Filter Nz XS) . * cons z (Filter Nz XS) \n After labelling, we have Failures = {(Filter, {z, s v0})}.Ob\u00adserve that there are no labels on N in \nline 2, due to the fact that labelTm failed. Depth pro.les can be naturally ordered pointwise, so that \nif d and d ' are depth pro.les over the same domain N ,then d = d ' iff d(F ) = d ' (F ) for all F .N \n. Unfolding. To capture the result of unfolding we .rst introduce two auxiliary de.nitions. To aid readability, \nin each of them we will annotate fresh variables with their implied types by a su\u00adperscript. The set \nof atomic patterns of type b, Ab is the set b b1 ar(a) { az \u00b7\u00b7\u00b7 z | a : b1 . \u00b7\u00b7\u00b7 . bar(a) . b . S }. \n1 ar(a) For each n . N we de.ne the non-overlapping, exhaustive set of patterns of type b and depth n, \npatsb(n): patsb(0) = {z b} b1 bm patsb(n +1) = { p[q1, ..., qm/x1 , \u00b7\u00b7\u00b7 ,xm ] | . } where . stands for \nthe conjunction: Feasibility. For a trace a in PG to be feasible two properties are required. First, \nthe non-determinism introduced by the abstraction f should be well behaved and second, there should be \na term in the p . patsb(n)&#38; FV(p)= {x b1 , ..., x bm } &#38; .iqi . Abi 1 m Hence, the depth 2 family \nof patterns of type natlist are given by input that is able to trigger the trace, i.e. when given as \nan argument to Main, the rest of the trace follows. The .rst of these conditions is the subject of the \nstep case in labelSeq, the second is the subject of the base case. Hence, if after performing labelSeq(a) \nit is the case that Failures = \u00d8,thenwesay a is feasible. The justi.cation is the following lemma. (n, \nx and xs arbitrary variables): nil, cons z nil, cons z (cons xxs), cons (s n) nil, cons (s n)(cons xxs) \nTo unfold the rules of a PMRS P according to a depth pro.le d, one constructs a new PMRS P ' whose rule-set \nis enlarged so that, for a given non-terminal F of type t1 .\u00b7\u00b7\u00b7. tm . b . o, f PG error-witness q. Then \nthere exists a term t .L(G) and a .nite Lemma 8. Let a be a feasible reduction sequence inwith there \nis a number of de.ning rules which is equal to the number of patterns of type b and depth d(F ). For \neach of these rules the reduction sequence Main t .\u00b7\u00b7\u00b7 in P with error witness q. corresponding right-hand \nside is constructed by using the existing The witness to soundness, which appears in the proof of Theorem \nP rulesasatemplate. 2, will always be feasible. We say that any trace that is not feasible Let P = (S, \nN , R, Main) beaPMRSand let d be a depth is spurious. pro.le with domain N such that dp(R) = d.The d-unfolding \nof P is the PMRS (S, N , R ' , Main),where R ' is the set such that, 5.2 Re.nement for all substitutions \ns, Fx1 \u00b7\u00b7\u00b7 xm sp -. st .R ' iff: f PG problem can always be traced back to an occurrence of pattern-When \na reduction sequence inis shown to be spurious, the (i) Fx1 \u00b7\u00b7\u00b7 xm p -. t .R (ii) and p is of type b \n(iii) and q . patsb(d(F )) (iv) and q = sp matching (notice that, by de.nition, the single parameter \nof the de.ning rule for Main is always a pattern). Since the only loss of accuracy in the abstraction \nis in the way that data bound in pattern matches is handled during reduction, our remedy for infeasibility \nis f PG. Our strategy is based on the observation that, due to the par\u00adticular way in which the abstract \nwPMRS is constructed from the Example 11. Let P be as in Example 2 and let d be the depth pro.le given \nby the following rule: to increase precision in the pattern matching rules of ( 2 when F = Filter dp(R)(F \n) otherwise composite PMRS, the terminal symbol-labelled parts of each pat-d(F )= tern are accurately \npreserved in the RHS of the de.ning rules of the abstraction. Based on the depth of pattern matches in \nthe coun\u00adterexample trace, we unfold patterns in the de.ning rules of P in a Then the d-unfolding of \nP is the PMRS P ' , whose rules are the same as P except that the two rules for Filter have been replaced \nway that preserves the the set of possible reduction sequences. by the .ve rules in Figure 3. Pattern-matching \ndepth. To determine how much to unfold we fG P ' ' of the PMRS P in Example 11 Consider an abstractionde.ne \na measure depth : T (S, N , V) . N, which quanti.es the (with G as given in Example 2). The only non-determinism \nthat extent to which a term can be matched, as follows: is introduced in constructing the abstraction \nis in replacing the f depth(x)=0 pattern-matching variables in the right-hand sides of the de.ning rules \nby pattern-symbols. Due to the unfolding of the Filter rules \u00b7\u00b7\u00b7 tm)=1 P ' depth(Ft1 ' G in P (and \nhence in), there is no longer a possibility to make G depth(at1 \u00b7\u00b7\u00b7 tm)=1+ { depth(ti) | 1 = i = m } \nthe problematic reduction: N Filter (Nz (cons NListN ) Given a set of non-terminals N ,a depth pro.le \nfor N is a map . If (Cons X (Filter Nz XS)) (Filter Nz XS)(Nz X ) N. N. We assign a depth pro.le to \na set of rules to quantify, for each non-terminal F , how accurately the de.ning rules for F model since \nthe unfolded rules require more of the non-determinism (in pattern-matching. Given a set of rules R de.ning \nnon-terminals the non-terminal symbols N and ListN ) to be resolved earlier. Filter p nil -. nil Filter \np (cons z nil) -. If (cons z (Filter p nil)) (Filter p nil)(p z) Filter p (cons z (cons v0 v1)) -. If \n(cons z (Filter p (cons v0 v1))) (Filter p (cons v0 v1)) (p z) Filter p (cons (s v2) nil) -. If (cons \n(s v2)(Filter p nil)) (Filter p nil)(p (s v2)) Filter p (cons (s v3)(cons v4 v5)) -. If (cons (s v3)(Filter \np (cons v4 v5))) (Filter p (cons v4 v5)) (p (s v3)) Figure 3. Depth-2 unfolding of the de.ning rules \nfor Filter. Re.nement. Given a PMRS P and an infeasible error trace a that the input trees meet the input \nspeci.cation, where both input in the abstraction of P, we can obtain re.ned abstractions by and output \nspeci.cations are regular tree languages. A sound but unfolding the rules of P according to the depths \nof terms in the incomplete algorithm has been proposed for the HMTT veri.ca-Failures set, then using \nthe unfolded PMRS as the input to the next tion problem by reduction to a model checking problem for \nrecur\u00adcycle of the abstraction-re.nement loop. sion schemes with .nite data domain (which can then be \nsolved PG f by a variation of Kobayashi s type-based algorithm). Though our Lemma 9. Let P = (S, N , \nR, Main) be a PMRS andthe abstraction of P (starting from terms in L(G)). Let a be a be algorithm in \nthe present paper solves a similar kind of veri.cation problem, it is not straightforward to compare \nit with the HMTT counterexample trace of PG which is spurious with Failures set S. Let d be the depth \npro.le with domain N de.ned by: ural) formalism than HMTT. What is clear is that our approach to f work \n[9]. It would appear that PMRS is a more general (and nat- G the over-approximation is very different: \nwe use binding analysis to obtain a wPMRS which generates an over-approximation of the d(F )= dp(R)(F \n)+ { depth(t) | (F, P ) . S, t . P } N reachable term-trees, whereas Kobayashi et al. use automaton states \n and let P ' be the d-unfolding of P.Then a is not a reduction to approximate input trees. sequence in \nthe abstraction P ' fG of P ' . Although it is clear that, given any spurious trace in some ab- Approximating \ncollecting semantics and .ow analysis. In a sem\u00ad f PG, it is possible to construct a re.nement that eliminates \nit from any future abstractionP ' PG and the f f straction inal paper [5], Jones and Andersen studied \nthe (data) .ow analysis of functional programs by safely approximating the behaviour of , the set of \ntraces of G a certain class of untyped, .rst-order, term rewriting systems with pattern matching. Their \nalgorithm takes a regular set I of input terms, a program P and returns a regular tree grammar which \nis a safe description of the set of all reachable (constructor) terms of the computation of P with inputs \nform I. Precisely, the algo\u00ad rithm computes a safe approximation of the collecting semantics of P relative \nto I, which assigns to each rewrite rule a set of pairs (., g.) such that . is a substitution (realisable \nin the course of set of traces of P ' fG are incomparable since, in general, there are new pattern-variables \nintroduced in the re.nement and hence new pattern-symbols into P ' fG . However, there is a very close \nrelation\u00ad ship between the depth of a PMRS and the feasibility of reduction sequences in its abstraction. \nLemma 10. Fix n . N. Then given any PMRS P and input gram\u00ad mar G, there is a depth-pro.le d such that, \nif fG P ' is the abstraction such a computation) of actual parameters to the formal parame\u00ad of the d-unfolding \nof P, then all length-m = n reduction sequences ters of the rule, and g. is a term reachable from the \nRHS of the rule with the substitution .. The collecting semantics is undecidable in in P ' fG are feasible. \nA consequence of this close relationship between depth and feasibility is that, under the assumption \nthat the model-checker always reports the shortest counterexample trace, if the PMRS P (when run from \na term in I) does violate the property then eventually the abstraction-re.nement cycle will produce a \nfeasible counterexample trace demonstrating the fact. Theorem 4 (Semi-completeness). Let (P, I, A) be \na no-instance of the veri.cation problem. Then the algorithm terminates with a feasible counterexample \ntrace.   6. Related work We compare and contrast our work with a number of topics in the literature \nbroadly related to .ow analysis and veri.cation of functional programs. Higher-order multi-parameter \ntree transducer. As discussed in the Introduction, Kobayashi [6] introduced a type-based veri.ca\u00adtion \nmethod for temporal properties of higher-order functional pro\u00adgrams generated from .nite base types. \nIn a follow-up paper [9], Kobayashi et al. introduced a kind of tree transducer, called HMTT, that uses \npattern-matching, taking trees as input and returning an output tree. They studied the problem of whether \nthe tree gener\u00adated by a given HMTT meets the output speci.cation, assuming general. Jones and Andersen \nwas able to obtain, for each rewrite rule, a regular over-approximation of the set of realisable bindings \n{ x . .x | realisable . } for each formal parameter x of the rule, and the set of reachable terms { g. \n| realisable . }, by decoupling the pair (., g.). There are two directions in which Jones and Andersen \ns algo\u00adrithm may be re.ned. Consider the setting of simply-typed func\u00adtional programs with pattern-matching \nalgebraic data types. Recent advances in the model checking of higher-order recursion schemes (notably \nthe decidability of MSO theories of trees generated by higher-order recursion schemes [14]) indicate \nthat the bindings of non pattern-matching variables, whether higher-order or not, can be precisely analysed \nalgorithmically (though with extremely high asymptotic complexity). Jones and Andersen s algorithm builds \na regular approximation of the binding set of every variable. A nat\u00adural question is whether one can \nimprove it by approximating only the bindings of pattern-matching variables, while analysing other variables \n(including all higher-order variables) precisely using the method in [14]. The work presented here offers \na positive answer to the question. Another direction worth investigating is to seek to preserve, for \neach rewrite rule, as much of the connection between realisable substitutions . and reachable terms g. \nas one can get away with. In an recent dissertation [10], Kochems has presented just such an algorithm \nusing a kind of linear indexed tree grammars (which are equivalent to context-free tree grammars) whereby \nthe indices are the realisable substitutions.  To compare our algorithm with Jones and Andersen s, it \nis instructive to apply their algorithm to our Example 8. Their framework can be extended to simply-typed \nand higher-order programs. It is an old idea in functional programming that an higher-order expression, \nsuch as an incompletely applied func\u00adtion (\u00b7\u00b7\u00b7 (fe1) \u00b7\u00b7\u00b7 )em where the type of f has arity greater than \nm, may be viewed as a closure. (Indeed, closures are a standard implementation technique.) From this \nviewpoint, a higher-order non-terminal is regarded, not as a de.ned operator, but as a con\u00adstructor, \nand closures are formed using a binary closure-forming operator @. Thus, the second clause of Map2 is \nwritten in their system as @(@(@ Map2 .) .)(cons xxs) -. cons (@ .x)(@(@(@ Map2 .) .) xs) Observe that \nin this setting, Map2 is a constructor (i.e. terminal) symbol, and the expression (@ (@ Map2 .) .) a \npattern. Call the binding set of a variable the set of terms that may be bound to it at some point in \nthe course of a computation. The approxi\u00admating grammar produced by Jones and Andersen s algorithm is \nalways regular (equivalently an order-0 recursion scheme). This is achieved by over-approximating the \nbinding set of every variable (including higher-order ones, such as .). The resultant grammar generates \nall .nite lists of 0 s and 1 s, which is less precise than our algorithm. Control .ow analysis. Established \nin the 80 s by Jones [4], Shiv\u00aders [17] and others, Control Flow Analysis (CFA) of functional programs \nhas remained an active research topic ever since (see e.g. Midtgaard s survey [12] and the book by Nielson \net al. [13]). The aim of CFA is to approximate the .ow of control within a pro\u00adgram phrase in the course \nof a computation. In a functional computation, control .ow is determined by a se\u00adquence of function calls \n(possibly unknown at compile time); thus CFA amounts to approximating the values that may be substituted \nfor bound variables during the computation. Since these values are (denoted by) pieces of syntax, CFA \nreduces to an algorithm that assigns closures (subterms of the examined term paired with sub\u00adstitutions \nfor free variables) to bound variables. Reachability anal\u00adysis and CFA are clearly related: for example, \nthe former can aid the latter because unreachable parts of the term can be safely ex\u00adcluded from the \nrange of closure assignment. There are however important differences: on one hand, CFA algorithms are \napprox\u00adimation algorithms designed to address a more general problem; on the other, because CFA considers \nterms in isolation of its pos\u00adsible (program) contexts, the corresponding notion of reachability essentially \namounts to reachability in the reduction graph. Functional reachability. Based on the fully abstract \ngame se\u00admantics, traversals [1, 14] are a (particularly accurate) model of the .ow of control within \na term; they can therefore be viewed as a CFA method. Using traversals, a new notion of reachability \nof higher-order functional computation (in the setting of PCF) is stud\u00adied in [16], called Contextual \nReachability:given aPCF term M of type A and a subterm Na with occurrence a, is there a program context \nC[-] such that C[M] is a closed term of ground type and the evaluation of C[M] causes control to .ow \nto Na?  7. Conclusion Recursion schemes with pattern matching (PMRS) are an accurate and natural model \nof computation for functional programs have pattern-matching algebraic data types. We have given an algorithm \nthat, given a PMRS P and a regular set I of input terms, con\u00adstructs a recursion scheme with weak pattern-matching \n(wPMRS) that (i) over-approximates the set of terms reachable from under rewriting from P (ii) has a \ndecidable model checking problem (rel\u00adative to trivial automata). Finally, because of the precise analysis \nat higher-orders, we show that there is a simple notion of automatic abstraction-re.nement, which gives \nrise to a semi-completeness property. For future work, we plan to build an implementation of the veri.cation \nalgorithm for a real functional programming language. We shall be especially interested in investigating \nthe scalability of our approach. Acknowledgements. We would like to thank the anonymous re\u00adviewers for \nmany useful comments.  References [1] W. Blum and C.-H. L. Ong. Path-correspondence theorems and their \napplications. Preprint, 2009. [2] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided \nabstraction re.nement. In CAV 00: Proceed\u00adings of the 12th International Conference on Computer Aided \nVeri.\u00adcation, pages 154 169, London, UK, 2000. Springer-Verlag. [3] A. Igarashi and N. Kobayashi. Resource \nusage analysis. ACM Trans. Program. Lang. Syst., 27(2):264 313, 2005. [4] N. D. Jones. Flow analysis \nof lambda expressions (preliminary ver\u00adsion). In Proceedings of the 8th Colloquium on Automata, Languages \nand Programming, pages 114 128. Springer-Verlag, 1981. ISBN 3\u00ad540-10843-2. [5] N. D. Jones and N. Andersen. \nFlow analysis of lazy higher-order functional programs. Theoretical Computer Science, 375:120 136, 2007. \n[6] N. Kobayashi. Types and higher-order recursion schemes for veri.ca\u00adtion of higher-order programs. \nIn Proceedings of POPL 2009, pages 416 428. ACM Press, 2009. [7] N. Kobayashi. Model-checking higher-order \nfunctions. In PPDP, pages 25 36, 2009. [8] N. Kobayashi and C.-H. L. Ong. A type theory equivalent to \nthe modal mu-calculus model checking ofhigher-order recursion schemes. In Proceedings of LICS 2009. IEEE \nComputer Society, 2009. [9] N. Kobayashi, N. Tabuchi, and H. Unno. Higher-order multi\u00adparameter tree \ntransducers and recursion schemes for program veri\u00ad.cation. In POPL, pages 495 508, 2010. [10] J. Kochems. \nApproximating reachable terms of functional programs. University of Oxford MMathsCompSc thesis, 2010. \n[11] R. P. Kurshan. Computer Aided Veri.cation of Coordinating Pro\u00adcesses. Princeton University Press, \n1994. [12] J. Midtgaard. Control-.ow analysis of functional programs. Tech\u00adnical Report BRICS RS-07-18, \nDAIMI, Department of Computer Science, University of Aarhus, Aarhus, Denmark, Dec 2007. URL http://www.brics.dk/RS/07/18/BRICS-RS-07-18.pdf. \n[13] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Program Analysis. Springer-Verlag New York, \n1999. [14] C.-H. L. Ong. On model-checking trees generated by higher\u00adorder recursion schemes. In Proceedings \n21st Annual IEEE Sym\u00adposium on Logic in Computer Science, Seattle, pages 81 90. Com\u00adputer Society Press, \n2006. Long version (55 pp.) downloadable at users.comlab.ox.ac.uk/luke.ong/. [15] C.-H. L. Ong and S. \nJ. Ramsay. Verifying higher\u00adorder functional programs with pattern-matching al\u00adgebraic data types. Long \nversion, available from: https://mjolnir.comlab.ox.ac.uk/papers/pmrs.pdf. [16] C.-H. L. Ong and N. Tzevelekos. \nFunctional reachability. In LICS, pages 286 295, 2009. [17] O. Shivers. Control-.ow analysis of higher-order \nlanguages.PhD thesis, Carnegie-Mellon University, 1991.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Type-based model checking algorithms for higher-order recursion schemes have recently emerged as a promising approach to the verification of functional programs. We introduce <i>pattern-matching recursion schemes</i> (PMRS) as an accurate model of computation for functional programs that manipulate algebraic data-types. PMRS are a natural extension of higher-order recursion schemes that incorporate pattern-matching in the defining rules.</p> <p>This paper is concerned with the following (undecidable) verification problem: given a correctness property &#966;, a functional program &#8472; (<i>qua</i> PMRS) and a regular input set &#8465;, does every term that is reachable from &#8465; under rewriting by &#8472; satisfy &#966;? To solve the PMRS verification problem, we present a sound <i>semi-algorithm</i> which is based on model-checking and counterexample guided abstraction refinement. Given a no-instance of the verification problem, the method is guaranteed to terminate.</p> <p>From an order-<i>n</i> PMRS and an input set generated by a regular tree grammar, our method constructs an order-<i>n weak</i> PMRS which over-approximates <i>only</i> the first-order pattern-matching behaviour, whilst remaining completely faithful to the higher-order control flow. Using a variation of Kobayashi's type-based approach, we show that the (trivial automaton) model-checking problem for weak PMRS is decidable. When a violation of the property is detected in the abstraction which does not correspond to a violation in the model, the abstraction is automatically refined by `unfolding' the pattern-matching rules in the program to give successively more and more accurate weak PMRS models.</p>", "authors": [{"name": "C.-H. Luke Ong", "author_profile_id": "81406597480", "affiliation": "Oxford University Computing Laboratory, Oxford, United Kingdom", "person_id": "P2509704", "email_address": "lo@comlab.ox.ac.uk", "orcid_id": ""}, {"name": "Steven James Ramsay", "author_profile_id": "81548018878", "affiliation": "Oxford University Computing Laboratory, Oxford, United Kingdom", "person_id": "P2509705", "email_address": "ster@comlab.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926453", "year": "2011", "article_id": "1926453", "conference": "POPL", "title": "Verifying higher-order functional programs with pattern-matching algebraic data types", "url": "http://dl.acm.org/citation.cfm?id=1926453"}