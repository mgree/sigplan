{"article_publication_date": "01-26-2011", "fulltext": "\n Formal Veri.cation of Object Layout for C++ Multiple Inheritance Tahina Ramananandro Gabriel Dos Reis \n* Xavier Leroy INRIA Paris-Rocquencourt Texas A&#38;M University INRIA Paris-Rocquencourt Tahina.Ramananandro@inria.fr \ngdr@cs.tamu.edu Xavier.Leroy@inria.fr Abstract Object layout the concrete in-memory representation \nof objects raises many delicate issues in the case of the C++ language, owing in particular to multiple \ninheritance, C compatibility and separate compilation. This paper formalizes a family of C++ object layout \nschemes and mechanically proves their correctness against the operational semantics for multiple inheritance \nof Wasserrab et al. This formalization is .exible enough to account for space\u00adsaving techniques such \nas empty base class optimization and tail\u00adpadding optimization. As an application, we obtain the .rst \nformal correctness proofs for realistic, optimized object layout algorithms, including one based on the \npopular common vendor Itanium C++ application binary interface. This work provides semantic foundations \nto discover and justify new layout optimizations; it is also a .rst step towards the veri.cation of a \nC++ compiler front\u00adend. Categories and Subject Descriptors D.2.4 [Software Engineering]: Software/Program \nVeri.cation Correctness proofs; D.3.3 [Programming Languages]: Language Constructs and Features Classes \nand objects; D.3.4 [Programming Languages]: Processors Compilers; E.2 [Data storage repre\u00adsentations]: \nObject representation; F.3.3 [Logics and meanings of programs]: Studies of program constructs Object-oriented \nconstructs General Terms Languages, Veri.cation 1. Introduction One of the responsibilities of compilers \nand interpreters is to rep\u00adresent the data types and structures of the source language in terms of the \nlow-level facilities provided by the machine (bits, pointers, etc.). In particular, for data structures \nthat must be stored in mem\u00adory, an appropriate memory layout must be determined and imple\u00admented. This \nlayout determines the position of each component of a compound data structure, relative to the start \naddress of the mem\u00adory area representing this structure. * Partially supported by NSF grants CCF-0702765 \nand CCF-1035058. Partially supported by ANR grant Arp`ege U3CAT. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11 January 26 28, Austin, TX, USA Copyright \nc &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 Many programming languages are implemented \nusing straight\u00adforward memory layouts. In Fortran and C, for example, compound data structures are laid \nout consecutively in memory, enumerat\u00ading their members in a conventional order such as column-major \nordering for Fortran arrays or declaration order for C structures. Padding is inserted between the members \nas necessary to satisfy the alignment constraints of the machine. Higher-level languages leave more .exibility \nfor determining data representations, but practi\u00adcal considerations generally result in simple memory \nlayouts quite similar in principle to those of C structures, with the addition of tags and dynamic type \ninformation to guide the garbage collector and implement dynamic dispatch and type tests. This paper \nfocuses on data representation for objects in the C++ language. C++ combines the many scalar types and \npointer types inherited from C with a rich object model, featuring multiple inheri\u00adtance with both repeated \nand shared inheritance of base classes, ob\u00adject identity distinction, dynamic dispatch, and run-time \ntype tests for some but not all classes. This combination raises interesting data representation challenges. \nOn the one hand, the layout of ob\u00adjects must abide by the semantics of C++ as de.ned by the ISO standards \n[8]. On the other hand, this semantics leaves signi.cant .exibility in the way objects are laid out in \nmemory, .exibility that can be (and has repeatedly been) exploited to reduce the memory footprint of \nobjects. A representative example is the empty base optimization described in section 2. As a result \nof this tension, a number of optimized object layout algorithms have been proposed [6, 7, 13, 17], implemented \nin pro\u00ad duction compilers, and standardized as part of application binary interfaces (ABI) [3]. Section \n2 outlines some of these algorithms and their evolution. These layout algorithms are quite complex, sometimes \nincorrect (see Myers [13] for examples), and often dif.\u00ad cult to relate with the high-level requirements \nof the C++ speci.ca\u00adtion. For example, the C++ common vendor ABI [3] devotes sev\u00ad eral pages to the speci.cation \nof an object layout algorithm, which includes a dozen special cases. The work reported in this paper \nprovides a formal framework to specify C++ object layout algorithms and prove their correct\u00adness. As \nthe high-level speci.cation of operations over objects, we use the operational semantics for C++ multiple \ninheritance formal\u00adized by Wasserrab et al [19], which we have extended with struc\u00ad ture .elds and structure \narray .elds (section 3). We then formalize a family of layout algorithms, independently of the target \narchi\u00adtecture, and axiomatize a number of conditions they must respect while leaving room for many optimizations \n(section 4). We prove that these conditions are suf.cient to guarantee semantic preserva\u00adtion when the \nhigh-level operations over objects are reinterpreted as machine-level memory accesses and pointer manipulations \n(sec\u00adtion 5). Finally, we formalize two realistic layout algorithms: one based on the popular common \nvendor C++ ABI [3], and its ex\u00ad tension with one further optimization; we prove their correctness by \nshowing that they satisfy the suf.cient conditions (section 6). All the speci.cations and proofs in \nthis paper have been me\u00adchanically veri.ed using the Coq proof assistant. The Coq devel\u00adopment is available \nonline [15]. The contribution of this paper is twofold. On one hand, it is (to the best of our knowledge) \nthe .rst formal proof of semantic correctness for realistic, optimizing C++ object layout algorithms, \none of which being part of a widely used ABI. Moreover, we hope that large parts of our formalization \nand proofs can be reused for other, present or future layout algorithms. On the other hand, just like \nthe subobject calculus of Rossie and Friedman [16] and the operational semantics for multiple inheritance \nof Wasserrab et al [19] were important .rst steps towards a formal speci.cation of the semantics of (realistic \nsubsets of) the C++ language, the work presented in this paper is a .rst step towards the formal veri.cation \nof a compiler front-end for (realistic subsets of) C++, similar in principle and structure to earlier \ncompiler veri.cation efforts for other languages such as Java [9], C0 [10], and C [11]. 2. Overview 2.1 \nThe object layout problem Generally speaking, an object layout algorithm is a systematic way to map an \nabstract, source-level view of objects down to machine\u00adlevel memory accesses and pointer operations. \nAt the source level, aC++ object is an abstract entity over which various primitive operations can be \nperformed, such as accessing and updating a .eld, converting ( casting ) an object or an object descriptor \nto another type, or dispatching a virtual function call. At the machine level, an object descriptor is \na pointer p to a block of memory containing the current state of the object. The object layout scheme \ndetermines, at compile-time, how to reinterpret the source-level object operations as machine instructions: \n Accessing a .eld f de.ned in the class C of the object becomes a memory read or write at address p + \nd, where the constant offset d is determined by the layout algorithm as a function of C and f.  Dispatching \na virtual function call is achieved by querying the dynamic type information attached to the object (typically, \na virtual function table), a pointer to which is stored at a .xed offset relative to p.  Converting \nto a base class (super-class) D of C is also achieved by adding an offset d to the pointer p, making \nit point to the subobject of class D contained within. The offset d can be statically determined in many \ncases, but owing to multiple virtual inheritance, it may have to be determined at run-time by querying \nthe dynamic type information of the object.  Accessing a .eld f de.ned in a base class D of C is achieved \nby converting p to D, then accessing f at a .xed offset from the resulting pointer.  For the generated \nmachine operations to correctly implement the C++ semantics of object operations, the object layout scheme \nmust satisfy a number of correctness conditions. First, when a scalar .eld is updated, the values of \nall other .elds must be preserved. This immediately translates to the following requirement: Field separation: \ntwo distinct scalar .elds, reachable through inheritance and/or .elds from the same object, map to disjoint \nmemory areas. Moreover, the hardware architecture can impose alignment con\u00adstraints on memory accesses: \nfor example, loading a 32-bit integer is possible only from an address that is a multiple of 4. This \nleads to a second requirement: Field alignment: for any .eld f of scalar type t, the natural alignment \nof type t evenly divides its memory address. Besides containing .elds, C++ objects also have an identity, \nwhich can be observed by taking the address of an object and comparing it (using the == or != operators) \nwith addresses of other objects of the same type. The C++ semantics speci.es precisely the outcome of \nthese comparisons, and this semantics must be preserved when the comparisons are reinterpreted as machine-level \npointer compar\u00adisons: Object identity: two pointers to two distinct (sub)objects of the same static type \nA, obtained through conversions or accesses to structure .elds, map to different memory addresses. This \nrequirement is further compounded by the fact that C++ operates under a simplistic separate compilation \nmodel inherited from C, and the fact that every class can be used independently to create complete objects, \nand every subobject in isolation is a potential target of most operations supported by any complete object \nof the same type. Furthermore, some classes are considered to be dynamic: those classes that need dynamic \ntype data to perform virtual function dis\u00adpatch, dynamic cast, access to a virtual base, or other dynamic \nop\u00aderations. The concrete representation for objects of these dynamic classes must include dynamic type \ndata (usually as a pointer to a data structure describing the class), and such data must be pre\u00adserved \nby .eld updates. Dynamic type preservation: any scalar .eld maps to a mem\u00ad ory area that is disjoint \nfrom any memory area reserved to hold dynamic type data. The separation conditions between two areas \nholding dynamic type data are weaker than the separation conditions for .elds. Indeed, most layout algorithms \narrange that the dynamic type data for a class C is shared with that of one of its dynamic non-virtual \ndirect bases, called the non-virtual primary base of C and chosen during layout, in a way that preserves \nthe semantics of virtual function dispatch and other dynamic operations. Dynamic type data separation: \nfor any two dynamic classes, the memory areas of their respective dynamic type data must be disjoint, \nunless one of the classes is the non-virtual primary base of the other.  2.2 The historic layout scheme \nEarly C++ compilers such as Cfront (Stroustrup s C++-to-C trans\u00adlator) used a simple object layout algorithm \nthat obviously satis\u00ad.es the requirements listed above. In effect, all components of a class (.elds, \nbase classes, and dynamic data if needed) are laid out contiguously following a conventional order, inserting \npadding (un\u00adused bytes) between components and after the last component as necessary to satisfy alignment \nconstraints. In this approach, each component (base or .eld) of a class C has its own memory area, disjoint \nfrom those of all other components of C. Moreover, each class is represented by at least one byte of \ndata, even if it contains no .elds nor dynamic type data. This trivially enforces the object identity \nrequirement. 2.3 Tail padding optimization The simple layout scheme just described is inef.cient in \nspace, because it never attempts to reuse padding to store useful data. Consider: struct A{ int a; }; \nstruct B:A{ char b; }; struct C:B{ char c; };  Assume the size and natural alignment ab c of type int \nare 4 bytes. To ensure proper 0 4 8 12 alignment of .eld a, 3 bytes of padding are inserted after .eld \nb in B, and 3 more bytes B of padding are inserted after .eld c in C. (To understand why, consider arrays \nwhose elements have type B or C.) Consequently, B has size 8 while C has size 12. However, it is perfectly \nlegitimate to reuse one a bc of the 3 bytes of padding present at the end of B 0 458 to hold the value \nof .eld c of C. In this case, C occupies only 8 bytes, for a nice space saving of 1/3. This layout trick \nis known as the tail padding optimization, and is used by many C++ compilers.  2.4 Empty base class \noptimization Empty classes offer another opportunity for reusing space that is unused in a base class. \nConsider: struct A {}; struct B1 :A {}; struct B2 :A {}; struct C :B1, B2 { char c1 ; char c2; }; C \nc; A * a1 =(A *) (B1 *) &#38;c; A * a2 =(A *) (B2 *) &#38;c; Here, the classes A, B1 and B2 are empty: \nthey contain c1 c2 no .eld and need no dynamic type information. It is L tempting to give them size 0, \nso that their instances a1 == a2 occupy no memory space at all. However, this would violate the object \nidentity requirement: as depicted to the right, the pointers a1 and a2 (to the two instances of A logically \ncontained within C) would compare equal, while C++ s semantics mandate that they are different. The layout \nalgorithm must therefore insert (at least) c1 c2 one byte of padding in A, resulting in A, B1 and B2 \nhaving size 1. Following the naive approach out-B1 B2 lined in section 2.2, C therefore occupies 4 bytes. \na1 a2 However, it is unnecessary to keep the .elds c1 and c2 disjoint from the subobjects of c1 c2 types \nB1 and B2: the padding inserted in the latter to satisfy the object identity require-(B1*)c LL(B2*)c \na1 a2 ment can be reused to hold the values of .elds c1 and c2, as shown to the right. This technique \nis known as the empty base class optimization. It is implemented by many C++ compilers, but often in \nrestricted cases only. Here is an example where GCC 4.3 misses an opportu\u00adnity for reusing the tail padding \nof an empty base class. struct A {}; struct B1 :A {}; struct B2 :A {}; struct C :B1, B2 { char c; }; \nstruct D:C { char d; }; As in the previous example, B1 and B2 must be laid out at different offsets \nwithin C, to allow distinguishing the two A contained in C. Thus, C must have size at least 2. This lower \nbound can be achieved by placing c at offset 0, as explained above. What about D? GCC places d at offset \n2, resulting in a size of 3 for D. However, the second byte of C is just padding introduced to preserve \nthe identity of empty base classes, and it can be reused to hold data such as .eld d. This optimized \nlayout .ts D in just two bytes. Why empty classes matter Over the years, successful C++ soft\u00adware, such \nas the Standard Template Libraries (STL), has become dependent on C++ s ability to deliver ef.cient code \nbased on simple techniques such as empty classes and inlining. Part of the success of the STL is based \non its archetypical use of function objects: these are objects of classes with the function call operator \noverloaded. These objects typically do not carry any runtime data. Rather, their semantics is their static \ntypes. As an example, consider sorting an array of integers. The STL provides the following template: \ntemplate < typename Ran , typename Comp > void sort(Ran first, Ran last, Comp cmp); The comparator cmp \ncould be a pointer to function (like the qsort function in C), but in idiomatic C++ it is any object \nwhose type overloads the function call operator. struct MyGreater { typedef int first _argument_type \n; typedef int second _argument _type ; typedef bool result_type ; bool operator ()( int i, int j) const \n{ return i >j; } }; The sort template can, then, be invoked as sort(t, t + n, MyGreater()). The comparator \nobject constructed by MyGreater() is of interest not for its runtime data (it carries none), but for \nits type: the comparison function is not passed to the sorting routine through data, but through the \ntype of the object. Consequently, it is directly called, and in most cases inlined since the body is \na simple integer comparison, which typically reduces to a single machine instruction. This simple technique, \na cornerstone of the STL success, is effective. One can think of it as a simulation of dependent types, \nwhere data is encoded at the level of types, therefore making data .ow obvious. The function object technique \njust described is at the basis of a composable component of the STL. Composition implies a proto\u00adcol \nthat parts being composed should adhere to. For example, if we want to combine two unary function objects, \nwe need a mechanism to ensure that the result type of one function object agrees with the argument type \nof the other. To that end, the STL requires the existence of certain nested types, such as first_argument_type, \nsecond_argument_type and result_type in the MyGreater class above. To reduce clutter, the STL provides \nready-to-use classes that de.ne those types. In this case, idiomatically, one would write struct MyGreater \n: std::binary_function < int , int , bool >{ bool operator ()( int i, int j) const { return i >j; } }; \n The sole purpose of std::binary_function<int,int,bool> is to provide those nested types. It is an empty \nbase class that introduces no data and no virtual functions. Its semantics is purely static. This usage, \nwhile not object-oriented programming by most popular de.nitions, is very common in modern C++ programs. \nThe pattern is not restricted to only one empty base class: a class can simulatenously inherit from several \nempty base classes. This is the case of bidirectional_input_iterator_tag, which inherits both from forward_iterator_tag \nand output_iterator_tag.A compiler that effectively supports C++ should not have to allocate space for \nsuch empty classes since their runtime semantics are completely irrelevant. While an optimization in \nC++03, the empty base optimization is considered so important that it is required in the next version \ndubbed C++0x [4].  3. Semantic model To capture the expected behavior of C++ object operations, we build \non the model of multiple inheritance introduced by Rossie and Friedman [16] and further developed and \nmechanized by Wasserrab et al. [19] using the Isabelle proof assistant. In this section, we brie.y recall \nthe main aspects of this model, referring the reader to [19] for full details, then describe how we extended \nit to handle .elds that are themselves structures or arrays of structures, and .nally use the model to \ngiven an operational semantics to a simple calculus of C++ objects. 3.1 Modeling multiple inheritance \nAC++ class can inherit from several base classes. Consequently, a class D can inherit from another class \nA through several different ways. Consider for example: AAA struct A{ int a; }; LLL struct B1: A {}; \nB1 B2 C struct B2: A {}; struct C:A {}; L/ struct D : B1, B2, C {}; / D An instance of D contains as \nmany copies of A as ways to inherit. Each copy of A is called a subobject of D, of static type A. In \nthis example, D has three different subobjects of static type A, obtained through the base classes B1, \nB2 and C. This is called non-virtual inheritance by Stroustrup [5], replicated inheritance by Rossie \nand Friedman [16], or repeated inheritance by Wasserrab et al [19]. However, the programmer can elect \nto declare some base classes as virtual, as in the following example: AA struct A{ int a; }; struct \nB1 : virtual A {}; B1 B2 C struct B2 : virtual A {}; struct C:A {}; struct D : B1, B2, C {}; D In this \ncase, B1 and B2 contribute only one subobject of static type A to class D: the paths B1::A and B2::A \ndesignate the same subobject. This is called virtual inheritance [5] or shared inheritance [19]. Note, \nhowever, that C contributes another, distinct subobject A to D, since C inherits from A in a non-virtual \nmanner. Following Wasserrab et al [19], we capture this notion of sub\u00ad object and these two .avors of \ninheritance as follows. A base class subobject of a given object is represented by a pair s =(h, l) where \nh is either Repeated or Shared, and l is a path in the non-virtual inheritance graph (the directed graph \nhaving classes as nodes and edges U . V if and only if V is a direct non-virtual base of U). More formally, \nwe write C - s'I . A to mean that s designates a base class subobject of class C, this subobject having \nstatic type A. This predicate is de.ned inductively: C - (Repeated,C :: E)'I . C B direct non-virtual \nbase of CB -. A (Repeated,l)'I C - (Repeated,C :: l)'I . A I B virtual base of CB - (h, l)'. A C - (Shared,l)'I \n. A The .elds of a full instance of a class C, then, are the pairs (s, f) where C - s'I . A and f is \na .eld de.ned in class A. In the .rst example above, the .elds of D are {((Repeated, D :: B1 :: A :: \nE), a); ((Repeated, D :: B2 :: A :: E), a); ((Repeated, D :: C :: A :: E), a)}, while in the second example \n(involving virtual inheritance), they are {((Shared, A :: E), a); ((Repeated, D :: C :: A :: E), a)}. \n 3.2 Structure .elds and structure array .elds In the original formalization of Wasserrab et al [19], \n.elds are restricted to scalar types (arithmetic types or pointer types). We extended this formalization \nto support .elds that are themselves structures or arrays of structures. To simplify presentation, we \nonly consider arrays of structures, treating a structure .eld or variable C x; as a one-element array \nC x[1];. In our formalization, a full object is always an element of a (possibly one-element) array of \nstructures, which is either bound to a program variable, or dynamically created using new, or appears \nas a structure array .eld of a larger object. To designate a subobject of an array of structures, we \ntherefore proceed in three steps: 1. select an array of structures contained in this array; 2. select \nan element of this sub-array; 3. select a base class subobject of this element (in the sense of section \n3.1).  To select an array of structures contained in a larger array, we in\u00adtroduce the notion of an \narray path a from an array of n struc\u00adtures of type C to an array of n' structures of type C', written \n' C[n] - a'.AC'[n]. Array paths are de.ned inductively by the following rules: I' i = nC - s'. An= n \nCI' C[n] - i, s'. A . C[n C[n] - E'A] F =(f, D, m) is a structure .eld de.ned in A CI'' C[n] - i, s'. \nA . C[n] D[m] - a'A '' C[n] - (i, s, F ) :: a'.AC[n] Then, a generalized subobject of type A of a full \nobject of type C[n] is a triple (a, i, s) where a is an array path from C[n] '' to some C'[n] and i . \n[0,n) is an index in the array of type ' C'[n] and s is a base class subobject of C' of type A. We write \nC[n] - (a, i, s)'. A and formally de.ne this relation by: CI '' C [n] - a'An. A . C- i, s' C [n] - (a, \ni, s)'. A Consider for example: struct Z {}; struct A : Z {}; struct B { A a [4] ; }; struct C1 : vi \nr tua l B {}; struct C2 : vi r tua l B {}; struct D : C1 , C2 {}; struct E { D d [5] ; }; E e [7]; The \nexpression (Z *) &#38;(e[2].d[0].a[3]) denotes the generalized subobject (a, i, s) within e, where a \n= (2, (Repeated, E :: E), d) :: (0, (Shared, B :: E), a) :: E i =3 s =(Repeated, A :: Z :: E) The static \ntype of a generalized subobject (a, i, s) is the static type of the base class subobject s. This generalized \nsubobject denotes a full instance of class C if and only if s is the trivial subobject of C of static \ntype C, that is, s =(Repeated,C :: E).  3.3 An operational semantics Building on these notions of subobjects, \nwe now give an opera\u00adtional semantics for a small 3-address intermediate language fea\u00adturing a C++-style \nobject model. The syntax of this language is as follows. (x ranges over variable names.) Stmt ::= x := \nop(x1,...,xn) arithmetic | x := nullptr null pointer | x := x ' ->C .eld .eld access | x->C .eld := x \n' .eld assignment | x := &#38;x1[x2]C array indexing | x := x1 == x2 pointer equality test | x := static \ncast C ' ' C (x1) static cast | x := dynamic cast C ' ' C (x1) dynamic cast Object operations are annotated \nwith static types C (subscripted) as determined during type-checking. For instance, in .eld opera\u00adtions, \nC is the class that de.nes the .eld being accessed; in con\u00adversions, C is the static type of the argument \nof the conversion, and C ' is the destination type. Our Coq formalization also includes some control \nstructures (sequence, conditional, loops), which we omit for simplicity. Also omitted are virtual function \ncalls, object creation and object destruction, which we have not fully formalized yet. The operational \nsemantics uses the following semantic objects: v ::= Atom baseval base value | Ptr \u00d8 null pointer | Ptr \n(objid, a, n, s) pointer to a subobject V ::= x . v variable environment . ::= (a, n, s, (f, t)) . v \nvalues of scalar .elds H ::= objid . (C, n, .) object heap The state of the execution is a pair (V, H) \nof an environment V mapping variable names to scalar values (either base values or pointers), and a heap \nH mapping top-level object identi.ers objid to their type C[n] and their contents .. The contents . is, \nin turn, a mapping from scalar .eld designators (pairs of a generalized subobject (a, n, s) and a .eld \n(f, t)) to scalar values. The operational semantics is given as a transition relation Stmt f (V, H) . \n(V ' ,H ' ) relating the state (V, H) before and the state (V ' ,H ' ) after executing Stmt. We show \nsome representative rules. V (x ' )= Ptr(o, a, i, s) H(o)=(C, n, .) C[n] - (a, i, s)'. AF is a scalar \n.eld of A x := x ' ->AF f (V, H) . (V {x . .(a, i, s, F )},H) V (x)= Ptr(o, a, i, s) H(o)=(C, n, .) \nC[n] - (a, i, s)'. A F is a scalar .eld of A. ' = .{(a, i, s, F ) . V (x ' )} x->AF := x ' f (V, H) \n. (V, H{o . (C, n, . ' )}) V (x ' )= Ptr(o, a, i, s) H(o)=(C, n, .) C[n] - (a, i, s)'. AF =(f, A ' ,n \n' ) is an array .eld of A p ' =(o, a+-(i, s, F ) :: E, 0, (Repeated,A ' :: E)) x := x ' ->AF f (V, H) \n. (V {x . Ptr p ' },H) V (x1)= Ptr(o, a, i, (Repeated,A :: E)) H(o)=(A ' ,n ' ,.) A A ' n '- a'. A [n]0 \n= i<n V (x2)= Atom j 0 = i + j<n p ' =(o, a, i + j, (Repeated,A :: E)) x := &#38;x1 [x2] f (V, H) . (V \n{x . Ptr p ' },H) For reads and writes over scalar .elds (.rst two rules above), the content map . of \nthe top-level object o being accessed is consulted or updated at the path (a, i, s) to the subobject \nand the accessed .eld. In contrast, accessing a structure array .eld (third rule) and addressing an array \nelement (fourth rule) just synthesize the appro\u00adpriate subobject from that given in the object pointer. \nIn the case of a structure array .eld, the given subobject (a, i, s) is re.ned into the sub-subobject \n(a-+(i, s, F ) :: E, 0, (Repeated,A ' :: E)) des\u00adignating the structure array. (+ - stands for list concatenation.) \nFor array addressing, only the i part of the given subobject is modi.ed. By lack of space, we omit the \nrules for static and dynamic casts, which are complicated but similar to those given by Wasserrab et \nal [19]. 4. Formalization of a family of layout algorithms In this section, we formalize the interface \nto a family of layout algo\u00adrithms and suf.cient conditions ensuring that they are semantically correct. \n4.1 Platform-dependent parameters Our formalization is independent of the characteristics of the hard\u00adware \nplatform. It is parameterized by a set of scalar types, compris\u00ading arithmetic types (e.g. int, short, \nchar, float, double, etc.) and pointer types. For each scalar type t, we take as parameters its size \nscsizet and its natural alignment scalignt. The only assumptions we make about size and alignment is \nthat they are positive and that all pointer types have the same size and alignment. The unit of size \nis not even speci.ed: a natural choice is bytes, but bits could be used as well. Likewise, natural alignments \nare not required to be powers of 2. As additional parameters, we also assume given a positive size dtdsize \nand a positive natural alignment dtdalign for dynamic type data. For simplicity, we assume that dynamic \ntype data has the same size for all classes. This was not always the case in early compilers [17], but \nnowadays the trend is to store only a pointer to a class descriptor, thus incurring a constant access \noverhead (one or two more indirections) but signi.cant improvements on the size of objects.  4.2 Interface \nof a layout algorithm Let C be a class. We introduce the following notations: dnvbasesC is the set of \ndirect non-virtual bases of C.  vbasesC is the set of (direct or indirect) virtual bases of C.  sc.eldsC \nis the set of scalar .elds declared in C. Each such .eld is of the form (f, t) where f is an identi.er \nand t is a scalar type.  st.eldsC is the set of structure array .elds declared in C. Each such .eld \nis of the form (f, B, n) where f is an identi.er, B is the structure type of the .eld, and n> 0 is the \nnumber of elements in the array.  .eldsC = sc.eldsC . st.eldsC is the set of all .elds declared in C. \n For every class C in the program, a layout algorithm is expected to compute each of the following (as \ndepicted in .gure 1): pbaseC is the primary base of C, if any. More precisely, either pbaseC = \u00d8, or \npbaseC = {B} for some direct non-virtual base B of C.  dnvbo.C : dnvbasesC . N assigns offsets to the \nnon-virtual direct bases of C.  fboundaryC . Nis an offset within C representing the bound\u00adary between \nnon-virtual base data and .eld data.  fo.C : .eldsC . Nassigns offsets to the .elds declared in C. \n nvdsizeC . Nis the non-virtual data size of C: the data size of its non-virtual part.  nvsizeC . N \nis the non-virtual size of C: the total size of its non-virtual part.   dsizeC nvdsizeC fboundaryC \ndnvbo.C (B2) nvdsizeB1 nvdsizeB2 dtdsize 0 B1 B2 dynamictype data for C and B1 ({B1} = pbaseC ) non-virtual \ndata of B1 non-virtual base data non-virtual data data of C sizeC nvsizeC dnvbo.C (B3) (B3 empty) dnvbo.C \n(B2) nvsizeB1 nvsizeB2 0 B1 B2 offsets to empty bases of B1 non-virtual part of B1 non-virtual part \nof C fo.C (f) vbo.C (V ) fdsize(f) nvdsizeV fV .eld data virtual base data fo.C (f) vbo.C (V ) fsize(f) \nnvsizeV fV offsets to empty offsets classes accessible to empty from f bases of V .eld f virtual base \nV Figure 1. A proposed layout for a full instance of a dynamic class C having a primary non-virtual base \nB1, a non-empty non\u00advirtual base B2, an empty non-virtual base B3, a .eld f and a virtual base V . Grayed \nareas represent padding. Bullets represent offsets to (inheritance or .eld) subobjects of C of empty \ntypes. The top part depicts the layout parameters related to data; the bottom part, those related to \nobject identity. vbo.C : vbasesC . N gives the offsets of the virtual bases of C.  dsizeC . Nis the \ntotal data size of C.  sizeC . N is the total size of C. This is the quantity that sizeof(C) evaluates \nto.  For the purpose of our formalization, C can be considered as a virtual base of itself. Thus we \nintroduce the notion of a class B being a generalized virtual base of C: either B = C, or B is a direct \nor indirect virtual base of C. Thanks to this notion, we can state that the layout of a full instance \nof C is composed of the layout of the non-virtual parts of the generalized virtual bases of C for this \ninstance, with the non-virtual part of C starting at offset 0. Thus, we may safely extend the domain \nof vbo.C by taking vbo.C (C)=0.  4.3 Empty classes and dynamic classes Our formalization leaves partially \nspeci.ed the notions of empty classes and dynamic classes, leaving their exact de.nitions to the layout \nalgorithm, subject to the following conditions: An empty class must not contain any scalar .eld. An \nempty class must not contain any structure .eld of a non\u00adempty class type.  An empty class must not \nhave any non-empty base.  A dynamic class is not empty.  If a class C has a virtual base, then C is \ndynamic  If a class C has a non-virtual primary base B, then both C and B are dynamic.  In our formalization, \nthe data size and the non-virtual data size of a class are of interest only if the class is not empty. \nOur way of classifying empty classes and dynamic classes can be understood as follows: the data of a \nclass is composed of all its reachable scalar .elds and dynamic type data; an empty class is a class \nthat requires no data; and a dynamic class is a class that requires dynamic type data.  4.4 Computing \noffsets and compiling object operations Once the quantities listed in section 4.2 have been computed \nby a layout algorithm, all the offsets mentioned in section 2.1 and required during compilation can be \ncomputed as follows. The offset nvso.(C :: l) of a non-virtual, base class subobject (Repeated,C :: l) \nwithin the low-level representation of a subobject of static type C is: nvso.(C :: E)=0 nvso.(C :: B \n:: l ' )= dnvbo.C (B)+ nvso.(B :: l ' ) The offset so.C (h, l) of the base class subobject (h, l) of \nC within the low-level representation of a full instance of C is computed as follows: so.C (Repeated,C \n:: l ' )= nvo.(C :: l ' ) so.C (Shared,B :: l ' )= vbo.C (B)+ nvso.(B :: l ' ) If l is an array path \nfrom C[n] to C ' [n ' ], then the offset ao.C (l) of (the .rst element of) the array of n ' elements \nof type C ' designated by l within the low-level representation of an array of n elements of type C is \ndetermined by ao.C (E)=0 and ao.C ((i, s, (f, A, m)) :: a) = i \u00b7 sizeC + so.C (s)+ fo.B (f, A, m)+ ao.A(a) \n(where B is the static type of s) Finally, the offset o.C (a, i, s) of a generalized subobject (a, i, \ns) within an array of structures of type C is computed as follows: o.C (a, i, s)= ao.C (a)+ i \u00b7 sizeB \n+ so.B(s) (where B[m] is the destination type of a) Using these offsets, we now outline a compilation \nscheme for the C++-like intermediate language of section 3.3. The target lan\u00adguage is a conventional \nlow-level intermediate language, featur\u00ading a .at, byte-addressed memory, pointer arithmetic, and explicit \nload(n, p) and store(n, p, x) operations to read and write n-byte quantities at address p. For .eld and \narray accesses, we have: [ x := x ' ->C F ] = x := load(scsizet,x ' + fo.C (F )) (if F =(f, t) is a scalar \n.eld of C) [ x->C F := x ' ] = store(scsizet,x + fo.C (F ),x ' ) (if F =(f, t) is a scalar .eld of C) \n[ x := x ' ->C F ] = x := x ' + fo.C (F ) (if F is a structure array .eld of C) [ x := &#38;x1[x2]C ] \n= x := x1 + sizeC \u00d7 x2 [ x := x1 == x2] = x := x1 == x2 For static casts, we have two cases depending \non whether inheri- I tance is virtual or not. If C - (Repeated,l)'. A for a uniquely\u00adde.ned path (Repeated,l) \n(conversion to or from a non-virtual base), the static cast is achieved by adjusting the pointer by a \ncon\u00adstant offset:  [ x := static cast A' C (x ' )]] = x := x ' + nvso.(l) [ x := static cast C' A(x \n' )]] = x := x ' - nvso.(l) I If C - (Shared,B :: l)'. A and (Shared,B :: l) is unique (conversion through \na virtual base), the offset of the virtual base B of C must be looked up in the dynamic type data: [ \nx := static cast A' C (x ' )]] = t := load(dtdsize,x ' ); x := x ' + vboff(t, B)+ nvso.(l) Finally, the \ncode [ x := dynamic cast A' C (x ' )]] for a dynamic cast is: t := load(dtdsize,x ' ); ' if (dyncastdef(t, \nA)) then x := x + dyncastoff(t, A) else x := NULL As shown in the last two cases, the target language \nfeatures three operations over the run-time representation t of dynamic type data: vboff(t, B) returns \nthe offset appropriate for virtual base B; dyncastdef(t, A) returns 1 if a dynamic cast to A is possible, \n0 otherwise; and dyncastoff(t, A) returns the offset appropriate for a dynamic cast to A. In the semantics \nof our target language, we formalize these op\u00aderations at an abstract level through queries to an oracle \n. The ac\u00adtual concrete implementation (virtual table, dictionary, etc.) is left unspeci.ed. However, \nwe have formally proved that such an oracle can always be constructed from a well-founded class hierarchy. \n 4.5 Soundness conditions We now state a number of soundness conditions over the results of the layout \nalgorithm. Section 5 shows that these conditions are suf.cient to guarantee semantic preservation. Sizes \nThe .rst set of conditions ensures that the total non-virtual size and total size of a class C are large \nenough to enclose all corresponding components of C. (C1) dnvbo.C (B)+ nvsizeB = nvsizeC if B direct \nnon-virtual base of C (C2) fo.C (f)+ fsize(f) = nvsizeC if f .eld of C (C3) vbo.C (B)+ nvsizeB = sizeC \nif B generalized virtual base of C (C4) dsizeC = sizeC (C5) 0 < nvsizeC The .rst two conditions ensure \nthat the total non-virtual size of C is large enough to hold the non-virtual part of any non-virtual \nbase of C (C1) as well as any .eld of C (C2). We write fsize(f) for the size of the .eld f, computed \nas follows: fsize(f)= scsizet if f has scalar type t fsize(f)= n \u00b7 sizeB if f has array type B[n] Likewise, \nthe total size of C must be large enough to hold a full instance of C, including any virtual base of \nC (C3), the non\u00advirtual part of C itself (C3 again), and all data of C excluding its tail-padding (C4). \nBy contrast, it is not required that nvdsizeC = nvsizeC . More precisely, the non-virtual size of a class \nis an upper bound of the interval in which offsets to .elds or subobjects within the non\u00advirtual part \nof the class must appear. The non-virtual size plays no role in the correctness of data access. However, \n(C4) is used to show that the data of two disjoint cells of a structure array (or of two cells of distinct \nstructure arrays) are disjoint, which guarantees that data access within an object does not affect other \nobjects. Conversely, the non-virtual data size, and data sizes in general, play no role in the correctness \nof subobject identi.cation. The C++ standard [8] mandates that the total size of a class be positive. \nThis is necessary to ensure that distinct elements of an array of structures have different offsets. \nWe require a stronger condition, imposing that the total non-virtual size of a class be positive (C5). \nThis is necessary to preserve object identity, as the following example demonstrates. (A*)(B1*)&#38;c[1] \nstruct A {}; (A*)(B0*)&#38;c[1] struct B0: A {}; struct B1: A {}; struct C : B0, B1 {}; C[2] c; LL \nA * a0 = (A*) (B1*) &#38;c[0]; A * a1 = (A*) (B0*) &#38;c[1];(A*)(B1*)&#38;c[0] (A*)(B0*)&#38;c[0] If \nthe non-virtual size of A were 0, then (C1) would allow the non-virtual sizes of B0 and B1 to be 0, so \nthat the non-virtual size of C could be 1. Thus, (C3) would allow the size of C to be 1. But in that \ncase, assuming B0 at offset 0 and B1 at offset 1 in C, the pointers a0 and a1 would compare equal, even \nthough they refer to logically different subobjects. Field separation We now present a set of conditions \nsuf.cient to guarantee separation between scalar .elds and, therefore, the good variable property (updating \na .eld preserves the values of all other .elds). These conditions are pleasantly local: they only involve \nthe .elds de.ned in the class C under consideration, as well as the layout quantities for its direct \nbases, but do not need to consider inherited .elds nor indirect bases. They focus on relevant components \nof the class C under consideration. A base class is not relevant if, and only if, it is of an empty class \ntype. A .eld is not relevant if, and only if, it is an array of structures of an empty type. We write \nS # T to say that two sets are disjoint (SnT = \u00d8). (C6) [dnvbo.C (B1), dnvbo.C (B1)+ nvdsizeB1 ) #[dnvbo.C \n(B2), dnvbo.C (B2)+ nvdsizeB2 ) if B1, B2 distinct non-empty non-virtual direct bases of C (C7) dnvbo.C \n(B)+ nvdsizeB = fboundaryC if B non-empty non-virtual direct base of C (C8) fboundaryC = fo.C (f) if \nf relevant .eld of C (C9) [fo.C (f1), fo.C (f1)+ fdsize(f1)) #[fo.C (f2), fo.C (f2)+ fdsize(f2)) if f1 \nand f2 are distinct relevant .elds of C (C10) fo.C (f)+ fdsize(f) = nvdsizeC if f relevant .eld of C \n(C11) fboundaryC = nvdsizeC (C12) [vbo.C (B1), vbo.C (B1)+ nvdsizeB1 ) #[vbo.C (B2), vbo.C (B2)+ nvdsizeB2 \n) if B1, B2 distinct non-empty generalized virtual bases of C (C13) vbo.C (B)+ nvdsizeB = dsizeC Condition \n(C6) states the absence of overlap between the data of two distinct, non-empty, non-virtual direct bases \nof a class. To separate the data of direct non-virtual bases of C from the data of the .elds of C, our \nformalization introduces a boundary fboundaryC such that every non-empty direct non-virtual base of C \nhas its data laid out below this boundary (C7), and every relevant .eld f of C is laid out above this \nboundary (C8). It is however possible for the tail padding of a direct non-virtual base of C to straddle \nthe data, or even the tail padding, of a .eld of C.  De.ne the data size fdsize(f) of a relevant .eld \nf as: fdsize(f)= scsizet if f has scalar type t fdsize(f)=(n - 1) \u00b7 sizeB + dsizeB if f has array type \nB[n] In other words, the tail padding of a structure array .eld is that of the last element of the array, \nwhile the tail padding of the .rst n -1 elements is part of the data area for this .eld (so that this \ndata area is contiguous in memory). Then, condition (C9) states that the data areas of two distinct relevant \n.elds f1 and f2 of C are disjoint. Note, however, that the tail padding of a .eld of C can be reused \nto hold some of the next .elds of C. The non-virtual data size of C, like the non-virtual size and the \nsize of C, is not computed directly. Instead, it is constrained as follows: the data of any relevant \n.eld f of C is included in the non-virtual data of C (C10), and the non-virtual data of any direct non-virtual \nbases of C is embedded in the non-virtual data of C (C11). This condition is redundant if C has at least \none relevant .eld. Finally, as regards virtual inheritance, two distinct, non-empty, generalized virtual \nbases B1 and B2 of C are laid out in such a way that they do not overlap (C12). Recall that a generalized \nvirtual base of C is C itself or a direct or indirect virtual base of C. Then, if B is a non-empty virtual \nbase of C, then C is not empty (as it has a non-empty base), so the above condition holds for generalized \nvirtual bases B and C, which guarantees that the data of the non\u00advirtual part of the virtual base B does \nnot overlap the data of the non-virtual part of C. Finally, the data of C (excluding its tail-padding) \ncontains the non-virtual data of any generalized virtual base B of C (C13). By contrast, since neither \nany scalar value nor any virtual function can be accessed from an irrelevant component, the data of an \nirrelevant component need not be disjoint from other .elds or bases of the same type. Likewise, it is \nnot required that an irrelevant .eld starts at the .eld boundary: it may also straddle non-virtual base \ndata. Field alignment The next set of conditions ensures that every .eld is laid out at an offset that \nis naturally aligned with respect to its type, even if the .eld appears in a base class or an array. \nDe.ne the natural alignment falign(f) of a .eld f as falign(f)= scalignt if f has scalar type t, and \nfalign(f)= alignB if f has type B[n]. Besides its alignment alignC , a class C has a non-virtual align\u00adment \nnvalignC used whenever C is laid out as a base of another class. This distinction allows the non-virtual \npart of C to be laid out under weaker alignment constraints than for a full instance of C, especially \nif the alignment of a full instance of C is constrained by that of a virtual base. The conditions related \nto alignment are as follows. We write p | q to mean that p evenly divides q. (C14) (falign(f) | fo.C \n(f)) and (falign(f ) | nvalignC ) if f .eld of C (C15) (nvalignB | dnvbo.C (B)) and (nvalignB | nvalignC \n) if B non-virtual base of C (C16) (dtdalign | nvalignC ) if C is dynamic (C17) (nvalignB | vbo.C (B)) \nand (nvalignB | alignC ) if B is a generalized virtual base of C (C18) (alignC | sizeC ) In particular, \n(C17) implies that (nvalignC | alignC ), as ex\u00adpected. (C16) ensures correctly-aligned accesses to the \ndynamic type data of a class. Finally, (C18) is used to show that an access to an element of an array \nof type C is correctly aligned. It is, however, not necessary for non-virtual sizes, as there are never \nany arrays composed only of non-virtual parts of a class. Dynamic type data Similarly to compilers such \nas GCC, we chose to store the dynamic type data of a subobject at the beginning of the subobject. This \nleads to the following conditions for a dynamic class C: (C19) dtdsize = fboundaryC (C20) pbaseC = \u00d8 \n. dtdsize = dnvbo.C (B) if B is a non-empty non-virtual direct base of C (C21) pbaseC = {B}. dnvbo.C \n(B)=0 Any relevant .eld must be laid out after the dynamic type data (C19). If C is dynamic but has no \nprimary base, (C20) ensures that all non-empty non-virtual direct bases of C start after the dynamic \ntype data of C. Finally, the primary base of a class is laid out at offset 0, so that the class and its \nprimary base can share the same storage for their dynamic type data (C21). As a consequence of (C20), \n(C21) and (C6), it follows that non\u00ad empty, direct, non-virtual bases of C other than its primary base \nare laid out at offsets at least dtdsize. Identity of subobjects The .nal set of conditions guarantees \nthat two different subobjects of a class C of the same type B map to dif\u00adferent offsets in memory. This \nidentity requirement is achieved in two completely different ways, depending on whether B is empty or \nnot. If B is non-empty, the requirement follows immediately from (C22) C non-empty . 0 < nvdsizeC In \npractice, actual layout algorithms de.ne empty bases in such a way that this condition automatically \nholds (a non-empty base contains at least one byte of .eld data or some dynamic type data), but we still \nneed to include it in the speci.cation. If B is an empty base of C, neither condition (C22) nor the .eld \nseparation conditions suf.ce to show that two different B subob\u00adjects map to distinct memory offsets. \nWe therefore need speci.c conditions for empty bases. Unfortunately, we found no local condition to ensure \nthat two different subobjects of the same empty type are mapped to distinct offsets: we need to involve \nnot only the layout parameters of the direct bases of the class C under consideration, but also those \nof all classes transitively reachable from C by inheritance or structure .elds. Indeed, if we took a \nlocal interval-based condition similar to the one used for .eld separation for instance, if we required \nthe whole non-virtual zones (not only the data) of non-virtual bases to be disjoint , then we would lose \ntail padding optimization, and fall back to a naive implementation similar to that of section 2.2. Therefore, \nwe have to compute, for any class C, the set ebo.sC of empty base offsets, i.e. the offsets of all empty \nclasses reachable from C through inheritance or structure .elds. Similarly, we compute, for any class \nC, the set nvebo.sC of non-virtual empty base offsets, i.e. the offsets of all empty classes that are \nsubobjects of direct non-virtual bases, or that are reachable through a .eld of C or a .eld of a non-virtual \nbase. De.ne: . + S =def {(A, . + o) | (A, o) . S} Then, the sets nvebo.sC of the non-virtual empty base \noffsets of C and ebo.sC of empty base offsets of C are de.ned as follows: [ ebo.sC =def vbo.C (B)+ nvebo.sB \nB.vbasesC .{C} nvebo.sC =def if C is empty then {(C, 0)} else \u00d8 [ . dnvbo.sC (B)+ nvebo.sB B.dnvbasesC \n[ . fo.C (f, B, n)+ i \u00b7 sizeB + ebo.sB (f,B,n).st.eldsC 0=i<n  For the purposes of the Coq proofs, \nthose sets are described as (mutually) inductive predicates and intended to be computed separately by \nalgorithms. From an implementation point of view, we can assume that those sets are computed incrementally: \nwhen it comes to computing those offsets for C, they are assumed to be computed for all of the bases \nand structure .eld types of C. Now, we impose that the unions de.ning nvebo.sC and ebo.sC be disjoint: \n(C23) (dnvbo.C (B1)+ nvebo.sB1 ) #(dnvbo.C (B2)+ nvebo.sB2 ) if B1, B2 distinct non-virtual bases of \nC (C24) (dnvbo.C (B1)+ nvebo.sB1 ) [ # fo.C (f, B2,n)+ j \u00b7 sizeB2 + ebo.sB2 0=j<n if B1 non-virtual base \nof C and (f, B2,n) structure .eld of C [ (C25) fo.C (f1,B1,n1)+ j1 \u00b7 sizeB1 + ebo.sB1 0=j1<n1 [ # fo.C \n(f2,B2,n2)+ j2 \u00b7 sizeB2 + ebo.sB2 0=j2<n2 if (f1,B1,n1) and (f2,B2,n2) distinct structure .elds of C \n(C26) (vbo.C (B1)+nvebo.sB1 )#(vbo.C (B2)+nvebo.sB2 ) if B1, B2 distinct generalized virtual bases of \nC In practice, whenever the algorithm tries to lay out a base or a .eld, it can check its empty base \noffsets against the empty base offsets laid out so far for the main class; whenever this check fails, \nthe offset is incremented by the alignment of the component. As the algorithms in section 6 show, these \nchecks can be simpli.ed by imposing tighter layout constraints, at the cost of losing some tail padding \noptimizations. 5. Correctness proof We now show that the conditions stated in section 4 are suf.cient \nto guarantee the various separation, alignment and disjointness properties discussed in section 2.1, \nthese properties being, in turn, suf.cient to ensure semantic preservation during compilation. All the \nresults below have been mechanically veri.ed using the Coq proof assistant. We therefore only sketch \nthe proofs, giving an idea of how the various conditions are used. 5.1 Field separation Consider a generalized \nsubobject p of static type A from an array of structures of type C, and a .eld f de.ned in class A. De.ne \nFo.C (p, f ) to be the offset of the .eld f of the subobject desig\u00adnated by p, within the representation \nof the array of type C: Fo.C (p, f)= o.C (p)+ fo.A(f) Theorem 1. If p1,p2 are two generalized subobjects \nof static type A1,A2 within an array of structures of type C, and if f1,f2 are scalar .elds of A1,A2 \nof types t1,t2 respectively, such that (p1,f1) (p2,f2), then the memory areas associated with these = \n.elds are disjoint: [Fo.C (p1,f1), Fo.C (p1,f1)+ scsizet1 ) #[Fo.C (p2,f2), Fo.C (p2,f2)+ scsizet2 ) \nProof. First we show that two distinct scalar .elds reachable through base class subobjects s1 and s2 \nof a class C are disjoint. There are two cases. If s1 = s2, then f1= f2 and (C9) concludes. Otherwise, \nwe show that, if Ai is the static type of si, then each fi is included (C8, C7, C11, C10) in the .eld \ndata zone of Ai (the memory zone between offsets fboundaryAi and nvdsizeAi within Ai) such that the two \n.eld data zones of s1 and s2 are disjoint. Then we show that if s1 and s2 are two distinct base class \nsubobjects of C through non-virtual inheritance only, then their .eld data zones are disjoint. There \nare two cases. If one subobject, say s1, is a subobject of the other s2, then, A2 denoting the static \ntype of s2, .eld f2 is on the right-hand side of the .eld boundary of A2 (C8), whereas f1 is included \nin a direct non-virtual base of A2, which is on the left-hand side of the .eld boundary of A2 (C7), which \nconcludes. Otherwise, s1 and s2 are subobjects of some classes A1 and A2 that are distinct direct non-virtual \nbases of some class A, so a similar inclusion scheme, combined with (C6), concludes. Then, if s1 and \ns2 are distinct base class subobjects of C, we consider the generalized virtual bases of which s1 and \ns2 are non\u00advirtual subobjects. If they are equal, then the non-virtual case above can be reused. Otherwise, \n(C12) concludes. Finally, we can show our main theorem by induction on the length of the array path of, \nsay, p1. Then, for each i, (pi,fi) can be decomposed into (ji,si,f i ' ,P i ' ) where ji is an integer \nless than the size n of the array of type C[n] from which p1 and p2 start, and si is a base class subobject \nof C of some static type Bi, and ' '' fi is a .eld of Ai such that either (fi ,P i )=(fi, \u00d8) (no structure \n.elds are traversed), or fi ' is a structure .eld of type Ai[ni] and P ' = {pi' } for some generalized \nsubobject pi from the array i Ai[ni]. In that case, the array path of p1 ' is one element shorter than \nthe one of p1, which allows induction. There are .ve cases. If j1 j2, then the scalar .elds are included \nin distinct cells of = the initial array. As two distinct .elds of an array are necessarily disjoint, \nwe conclude, additionally using (C13, C4). If s1 s2, = then .elds f1 ' and f2 ' are included in disjoint \n.eld data zones; as .elds f1 and f2 are included in the data zones of f1 and f2, this concludes. If f1' \n= f2' , then their data zones are disjoint; as the data zone of each fi is included in the data zone \nof fi ' (which may be ' '' the same, if fi = fi). Otherwise, f1 = f2 is a structure .eld, and we may \nuse the induction hypothesis. It is legal to use all those conditions, as all considered classes are \nnon-empty: as f1 and f2 are scalar .elds, the classes de.ning them are non-empty, so are their derived \nclasses, the structure .elds containing them, and so on. 5.2 Alignment Theorem 2. If p is a generalized \nsubobject of static type A within an array of structures of type C, and if f is a scalar .eld of A of \ntype t, then the access to f via p is correctly aligned: (scalign| Fo.C (p, f )) and (scalign| alignC \n) tt Proof. Easy induction on the path, using transitivity of the evenly divides relation, alignment \nconditions (C14, C15, C17), and addi\u00ad tionally (C18) for array cell accesses. Access to the i-th cell \nof an array of structures of type B corresponds to shifting by i \u00b7 sizeB , which requires an alignment \ncondition for sizeB . Theorem 3. If p is a generalized subobject of static type A within an array of \nstructures of type C, and if A is dynamic, then the access to the dynamic data of p is correctly aligned: \n(dtdalign | o.C (p)) and (dtdalign | alignC ) Proof. Same reasoning as above, additionally using (C16). \n 5.3 Identity of subobjects Theorem 4. If p1,p2 are two different generalized subobjects of the same \nstatic type A within an array of structures of type C, then their corresponding offsets are distinct: \np1 = p2 . o.C (p1)= o.C (p2)  Proof. There are two radically different sub-proofs depending on whether \nA is empty. If it is not empty, then the proof is similar to that of theorem 1, thanks to condition (C22). \nIf A is empty, all those conditions no longer apply. By induction on the length of the array path of \np1, there are two cases. If p1 and p2 originate from the same cell of the array of structures of type \nC, then, (C23, C24, C25, C26) and the induction hypothesis conclude. Otherwise, we know that the two \ncells are entirely disjoint (not only their data), so we simply have to show that each pi is included \nin its own cell, using (C1, C2, C3) and also (C5).  5.4 Preservation of dynamic type data The following \ntheorem ensures that writing a scalar .eld does not change the dynamic type data of subobjects. Theorem \n5. If p1,p2 are two generalized subobjects of static type A1,A2 within an array of structures of type \nC, and if A1 is a dynamic class and if f2 is a scalar .eld of A2 of type t2, then the memory area occupied \nby the dynamic type data of A1 is disjoint from the memory area occupied by .eld f2: [o.C (p1), o.C (p1)+ \ndtdata) #[Fo.C (p2,f2), Fo.C (p2,f2)+ scsizet2 ) Proof. The proof resembles that of theorem 1, except \nthat data in\u00adclusions (not only .eld data inclusions) must be checked. (C19) ensures that dynamic type \ndata is included in the data of a subob\u00adject, but it also ensures that it is disjoint from the .eld data \nzones if p1 is a generalized subobject that is reachable from p2 by inher\u00aditance and/or scalar .elds. \nConversely, if p2 is reachable from p1, then (C20, C21) must be additionally used. A dynamic class C \nmay share its dynamic type data with one of its dynamic non-virtual bases B: the primary base of C. But \nthe semantics of C++ guarantees that dynamic operations (e.g. dynamic cast, dynamic function dispatch) \non a base class subobject s2 of C give the same result as on a base class subobject s1 of C if s2 is \nreachable from s1 (i.e. if s1 dominates s2 [19]). As the primary base B isabase of C, this sharing is \nsemantically sound. However, initialization of dynamic data has still to be checked. Even without a detailed \nsemantics of object construction and de\u00adstruction, which is out of the scope of this paper, we still \nhave to know whether initializing the dynamic data of a subobject does not change the dynamic data of \nother subobjects. We proved formally that this is the case, except for two subobjects s1 and s2 such \nthat s2 can be reached by s1 through primary bases only. A primary path is a path in the primary path \ngraph (where classes are the vertices, and (U, V ) is an edge if and only if V is the primary base of \nU). Any non-virtual path B :: l can be decomposed into a reduced path red(B :: l) such that: if B :: \nl is primary, then red(B :: l)=def B :: E; otherwise, B :: l can be rewritten as l1-+B1 :: B2 :: l2 where \nB2 is a non-virtual base of B1 that is not the primary base of B1, and B2 :: l2 is a primary path. Then, \nred(B :: l)=def l1-+B1 :: B2 :: E. In other words, the reduced path of a non-virtual path l ' is obtained \nby truncating the longest primary path on the right of l ' . Theorem 6. Let p1 =(a1,i1, (h1,l1)), p2 \n=(a2,i2, (h2,l2)) be two generalized subobjects of static types A1 and A2 respectively, from an array \nof structures of type C. Assume A1 and A2 are dynamic classes. If (a1,i1)=(a2,i2) or red(l1)= red(l2), \nthen the dynamic type data of the two subobjects are disjoint: [o.C (p1), o.C (p1)+ dtdata) #[o.C (p2), \no.C (p2)+ dtdata) Proof. The proof proceeds like that of theorem 5, but replacing each li ' with its \nreduced path red(li' ).  5.5 Semantic preservation To conclude this section and exercise the theorems \nabove, we now sketch a proof of semantic preservation for the compilation scheme given in section 4.4. \nThe semantics of the target language is given in terms of states (V ' ,M), where V ' maps variables to \ntarget values and M is a machine-level, byte-addressed memory state in the style of Tuch [18]. Target \nvalues v ' are the union of base values Atom bv, data pointers Ptr i (where i, an integer, is the address \nof a byte in memory), and pointers to dynamic type data Vptr(C, s). Memory states are presented abstractly \nthrough the two partial operations load(i, n, M) and store(i, n, v ' ,M) where i, an integer, is the \naddress of a byte, and n is a byte count. By lack of space, we omit the operational semantics of the \ntarget language, referring the reader to the online supplement [15] instead. We now de.ne a predicate \n(V, H) c (V ' ,M) relating the exe\u00adcution states of the program before and after compilation. We start \nwith the relation H f vc v ' between source values and target val\u00adues: H f Atom bv c Atom bv H f Ptr \n\u00d8c Ptr\u00d8 H(o)=(C, n, .) C[n] - (a, i, s)'. A H f Ptr(o, a, i, s) c Ptr(objo.(o)+ o.C (a, i, s)) In the \nlast rule, objo. is a partial mapping from source-level object identi.ers o to memory addresses. It represents \nthe initial place\u00adment of top-level objects in memory. Agreement (V, H)c(V ' ,M) between a source state \nand a target state is, then, the conjunction of the following conditions: 1. Variable agreement: H f \nV (x) cV ' (x) for all x . Dom(V ). 2. Alignment of top-level objects: (alignC | objo.(o)) if H(o)= \n(C, n, .). 3. Separation between top-level objects:  [objo.(o1), objo.(o1)+ n1 \u00d7 sizeC1 )# [objo.(o2), \nobjo.(o2)+ n2 \u00d7 sizeC2 ) if H(o1)=(C1,n1,.1) and H(o2)=(C2,n2,.2) and o1 = o2. 4. Correct values for \nscalar .elds: H f .(a, i, s, (f, t)) c load(objo.(o)+ o.C (a, i, s)+ fo.A(f, t), scsizet,M) if H(o)=(C, \nn, .) and C[n] - (a, i, s)'. A and (f, t) is a scalar .eld of A. 5. Correct values for dynamic data: \nload(objo.(o)+ o.C (a, i, red(s)), dtdsize,M)= Vptr(B, red(s)) if  ACI H(o)=(C, n, .) and C[n] - a'. \nB[m] - i, s'. A and A is a dynamic class. Theorem 7. Every execution step of the source program is sim\u00adulated \nby one or several execution steps of the compiled code: if (V1,H1)c(V1 ' ,M1) and Stmt f (V1,H1) . (V2,H2), \nthen there + exists a target state (V2 ' ,M2) such that [ Stmt] f (V1 ' ,M1) . (V2 ' ,M2) and (V2,H2) \nc (V2 ' ,M2). Proof. If Stmt is an assignment to a scalar .eld, the existence of M2 follows from theorem \n2, which guarantees that the store is properly aligned and therefore succeeds. Theorem 1, combined with \nthe good variable properties of the target memory model, shows part (4) of the agreement between the \n.nal states. Part (5) likewise follows from theorem 5 and the good variable properties. If Stmt is a \npointer comparison, theorem 4 ensures that the address comparison generated by the compilation scheme \nproduces the same boolean outcome.  The remaining cases follow more or less directly from the hy\u00adpothesis \n(V1,H1) c (V1 ' ,M1). 6. Veri.cation of representative layout algorithms We now put our formalization \ninto practice by using it to prove the correctness of two realistic, optimizing C++ object layout algo\u00adrithms. \n6.1 The common vendor C++ ABI The .rst layout algorithm we study is the one speci.ed in the common vendor \nC++ ABI [3], .rst introduced for Itanium and now used by the GCC compiler on many other platforms. Our \nalgorithm is faithful to the ABI speci.cation with one exception: we do not allow the use of nearly empty \nvirtual bases as primary bases, an optimization of dubious value discussed in section 7. Following the \nABI, we de.ne a class C to be dynamic if, and only if, it has a virtual function, or a non-virtual dynamic \nbase, or a virtual base. In the latter case, C is considered dynamic as its dynamic type data is actually \nused to .nd the offsets of the virtual bases of C. Likewise, we de.ne a class to be empty if, and only \nif, all the following conditions hold: it has no virtual function; it has no non-static .elds; it has \nno virtual bases; all its direct non-virtual bases are empty. In particular, an empty class cannot be \ndynamic. The layout algorithm is summarized below. (See [15] for the full pseudocode.) It takes as input \na class C and the layout of all classes B mentioned in C (i.e. B is a direct or indirect base of C, or \nB is the type of a .eld of C, or depends on a base of C or of the type of a .eld of C). Besides the layout \nparameters listed in section 4.2, it also computes the set ebo.s ' C of the offsets of all subobjects \nof an empty virtual base of C or an empty non-virtual direct base of C. 1. Start from nvdsizeC =0 and \nnvalignC = nvsizeC =1. 2. Arbitrarily choose a dynamic non-virtual direct base B, if any. This will \nbe the primary base. Give it offset 0 within C, and update nvebo.sC , nvdsizeC , nvsizeC and nvalignC \nto their B counterparts. 3. If there is no primary base but the class is dynamic, then reserve some \nspace for the dynamic type data: update nvdsizeC and nvsizeC to dtdsize, and nvalignC to dtdalign. Start \nat offset equal to the size of dynamic type data. 4. Then, for each non-primary non-virtual direct base \nB of C:  Try to give it an offset dnvbo.C (B) within C, starting from the least multiple of nvalignB \nno less than nvdsizeC . If there is a type con.ict with empty base offsets, then try at a further offset \nby increasing dnvbo.C (B) by nvalignB , knowing that for dnvbo.C (B) = nvsizeC there will be no con.ict. \nHowever, if B is empty, .rst try 0 before trying any offset from nvdsizeC .  Update nvsizeC to max(nvsizeC \n, dnvbo.C (B)+nvsizeB ), and nvalignC to lcm(nvalignC , nvalignB).  If B is not empty, also update nvdsizeC \nto dnvbo.C (B)+ nvsizeB : in this case, note that the whole non-virtual part of B (not only its data) \nis included in the data of C  5. Set fboundaryC to nvdsizeC . 6. Then for each .eld, try to lay it \nout. Starting from nvdsizeC , .nd a correctly aligned offset (incrementing by falign(f)), and set nvdsizeC \nto fo.setC (f)+ fsize(f), so that the next .eld starts after the end of the whole previous .eld (not \nonly its data). This explains why any class having a .eld, even an irrelevant one, is not empty. 7. \nThen for each virtual base, try to lay out its non-virtual part, the same way as for non-virtual bases, \nbut updating alignC , sizeC , etc. instead of nvalignC , nvsizeC , etc.  Type con.icts with empty base \noffsets are detected as follows. When trying to lay out an empty base B, check between B s non-virtual \nempty base offsets and the whole set of empty base offsets so far. When trying to lay out a non-empty \nbase B, or a .eld of type B[n], check between the base s or the .eld s non\u00advirtual empty base offsets \nand the offsets of C so far reachable by inheritance only through an empty direct non-virtual base or \nan empty virtual base. In other words, ignore those offsets of bases reachable through .elds, or through \nnon-empty bases of C. Indeed, those offsets are guaranteed to be laid out in the data zone of C, as this \nalgorithm ensures that a .eld, or a non-empty base, is wholly included (not only its data) in the data \nof C. As the data zone of already laid out relevant components is disjoint from the data zone of the \ncurrent relevant component, there is no need to check whether those offsets are present in the empty \nbase offsets of the current component. These details about type con.ict resolution were not present in \nthe ABI speci.cation [3]: it gave no clue about which offsets to empty subobjects need to be checked. \nWe proved that this algorithm satis.es all the conditions stated in section 4. Thus, it is semantically \ncorrect with respect to .eld access, dynamic operations and subobject identi.cation. 6.2 A more ef.cient \nlayout: empty member optimization The previous algorithm misses several opportunities for saving space. \nConsider: struct A0 {}; struct A: A0 {}; struct B{ char f; A a; }; struct C {Bb; char f; }; struct D: \nA {Aa; }; struct E: D { char f; }; Running this example through GCC 4.3 (which follows the com\u00admon vendor \nABI), we obtain sizeof(C) == 3 and sizeof(E) == 3. This indicates that .eld f of C is laid out completely \ndisjointly from b, even though b.a contains no data (A is empty). The space for b.a could be reused, \ngiving sizeof(C) == 2. Likewise, .eld f of E is laid out completely disjointly from the subobject D, \nwhich is con\u00adsidered as not empty even though D::a contains no data. The space for D could be reused, \nresulting in sizeof(E) == 2. This optimisa\u00adtion is justi.ed insofar as an object of empty class has no \nsource of observable behavior other than its address: it carries no runtime data. Consequently a conforming \nC++ implementation can system\u00adatically compile assignments to such objects as no-ops. We propose an algorithm \nthat performs these space optimiza\u00adtions by re.ning the notion of empty classes. Say that a class is \nempty if, and only if, all the following conditions hold: it has no virtual functions;  it has no scalar \n.elds;  it has no virtual bases;  all its direct non-virtual bases are empty;  all its structure .elds \nare of an empty type.  In particular, an empty class cannot be dynamic. (This de.nition of empty classes \nis the smallest that satis.es the conditions from section 4.3.) Then, the previous algorithm is modi.ed \nas follows: When laying out an irrelevant component, all correctly aligned offsets starting from 0 are \ntried, until the offsets to empty subobjects do not clash, or nvsizeC is reached  A .eld can start in \nthe tail padding of the previous .eld: when a relevant .eld is being laid out, the data size is updated \nto fo.C (f)+ fdsize(f ) instead of fo.C (f)+ fsize(f). Similarly for a non-empty base.   This requires \na modi.cation when checking for type con.icts with empty base offsets: the whole sets of offsets must \nbe consid\u00adered every time. Indeed, as there are no more conditions about the sizes of the .elds or the \nnon-virtual sizes of the bases, there are no more guarantees that an empty subobject reachable from an \nal\u00adready laid out component will not clash with the current component being laid out. Similar modi.cations \noccur for .elds, and virtual bases (in the latter case, checking against ebo.sC ). As all offsets are \nchecked, the auxiliary set ebo.s ' C is no longer useful. We proved this algorithm to be correct. In \nfact, the proof is easier than for the previous algorithm, as this algorithm is closer to the conditions \nstated in Section 4. 7. Limitations and extensions Bit .elds In our formalization, we did not specify \nthe size unit, so that sizes and offsets can be expressed in bits instead of bytes. However, this may \nnot be enough to fully implement bit .elds, as they require speci.c alignment constraints. Consider: \nstruct A{ int i : 29; int j: 2; int k: 3; } On a 32-bit platform, .elds i and j can be packed into a \nsingle 32\u00adbit integer, and retrieved by shifting and masking from this integer. However, the .eld k should \nnot be packed adjacent to j, otherwise two correctly-aligned memory accesses would be required to re\u00adcover \nthe value of k. Our alignment constraints over .eld offsets would have to be strengthened accordingly. \nPOD Our work does not consider the speci.cities of POD (Plain Old Data), and treats them in an ordinary \nway, not distinguishing them from general C++ structures. Roughly speaking, a POD struc\u00adture is a structure \nwith no inheritance, and no non-POD .elds: as such, it is roughly equivalent to a C structure. The Standard \nman\u00addates the layout of POD structures to be compatible with C, allow\u00ading in particular bitwise assignment \nbetween POD structures using memcpy. By contrast, our work considers that structures are al\u00adways assigned \nto by memberwise assignments of .elds. However, we suspect that constraining nvdsizeC = nvsizeC = sizeC \nwhen\u00adever C is a POD could help us prove the correctness of bitwise copy, even if a POD is inherited \nby another class. Unions Just like structures, unions offer opportunities for reusing tail padding that \nis common to all of its members. The practical bene.ts are low: unions are used infrequently enough that \ntreat\u00ading them like POD is a reasonable choice. The main dif.culty in extending our formalism to unions \ncomes from the operational se\u00admantics, which must be instrumented to enforce the policy that, at any \ntime, the only member of an union that can be accessed is the one most recently initialized. Virtual \nprimaries In our work, a class can share its dynamic type data only with a non-virtual primary base. \nHowever, the common vendor ABI [3] allows a class to share its dynamic type data with one of its virtual \nbases, as long as the latter has no .elds. In practice, the layout of such a virtual base (called a nearly \nempty virtual base) is reduced to its dynamic type data, so that it can be shared with the dynamic type \ndata of its derived class. However, such a layout would break the schema of laying out the non-virtual \npart of a class separately from the non-virtual parts from its virtual bases, as some non-empty virtual \nbases may be actually laid out in the non\u00advirtual part of the class. Moreover, indirect primary virtual \nbases may appear several times in a class layout because they have been chosen as primary bases by different \nnon-virtual bases. We do not know how to solve this layout ambiguity. In practice, the latter case also \nactually poses ef.ciency problems in most compilers, so much so that the virtual primary optimization \nis described as an error in the design of the common vendor ABI [3]. Alternate layout of dynamic type \ndata Our work assumes that dynamic type data is laid out at the beginning of a class. Some C++ compilers \nsuch as Cfront or Compaq s compiler elect to place it at a different offset. That layout scheme has the \nproperty that a pointer to the complete object is also a pointer to the data of the primary base class \nsubobject, which may not need dynamic type data. How frequently that situation occurs in practice is \nunclear. Moreover, it can lead to alignment padding that is more dif.cult to reuse in derived classes. \nBidirectional layout In our work as in production C++ compilers, object representation can only be extended \non one side in derived classes. There are, however, some layouts [7] that may extend an object representation \nto both sides, so that for instance a class may share its dynamic type data with two of its bases. However, \nan ef.cient implementation of such layout would need to know the derived classes of a class in advance, \nwhich would impede separate compilation. Reusing padding holes Our work assumes that the non-virtual \ndata of a class is a contiguous memory zone. Consequently, holes arising from inter-.eld padding cannot \nbe detected and reused, as in the following example: struct A0 {} struct A: A0 { char x; int y; }; struct \nB: A { char z; }; There is some alignment padding between A::x and A::y, but in the layout of B, our \nformalization does not allow z to be stored in this unused space, as the data of A is considered to be \ncontiguous. Virtual table layout Our work focused so far on the represen\u00adtation of objects, leaving unaddressed \nthe concrete representation of dynamic type data. Future work includes formalizing the lay\u00adout of virtual \ntables as studied by Sweeney and Burke [17], as well as this pointer adjustment during virtual function \ndispatch. This would lead to mechanized veri.cation of the implementation of dynamic operations such \nas virtual function dispatch and dynamic cast. Object construction and destruction A related piece of \nfuture work is the formalization of object construction and destruction, especially the updates to the \ndynamic type data of objects that take place during this process. 8. Related work Obviously, any C++ \ncompiler includes an object layout algorithm. However, to the best of our knowledge, none has been reported \nas formally veri.ed. Stroustrup [5] extensively discusses object layouts found in earlier C++ compilers. \nAlthough he explicitly stated Objects of an empty class have a nonzero size [5, p. 164], he did not consider \nempty base class optimization. Nor was that optimization implemented in Cfront. The nonzero size requirement \nwas later clari.ed by the C++ standard [8, paragraph 10/5]. The empty base optimization, as a basis for \nef.cient program\u00adming technique, was popularized by Myers [13]. He credited Jason Merrill for the possibility \nof optimizing empty member subobjects, as we consider in this paper. However, there was no proposed al\u00adgorithm, \nand as we observed such an optimization requires careful assumptions about PODs (Plain Old Data). The \nempty base class optimization is explicitly mandated by the common vendor ABI [3], which is a practical \nbasis of our formalization and improve\u00ad ments. Our present work is based on the algebraic model of inheri\u00adtance \nby Rossie and Friedman [16], and the operational semantics of Wasserrab et al [19]. These foundational \npapers do not consider concrete object layout algorithms. Rather, they purposefully focus on abstract \nobject semantics independent of concrete machine rep\u00adresentations.  There are other formalizations of \naspects of the compilation of C++, but none of them considers concrete data representation. Chen [2] \nproposed a typed intermediate language for compiling multi\u00adple inheritance. This work formally describes \nwhich pointer adjust\u00adments are necessary for virtual function calls and conversions, in\u00adcluding offset \ncomputations and thunks, and proves type soundness results about them. However, Chen s formalization, \nfocusing only on an intermediate language, leaves largely unspeci.ed the con\u00adcrete object layout. The \ndelicate issue of subobject identity is not addressed either. Luo and Qin [12] proposed a separation \nlogic-based formalism for reasoning about C++-style multiple inheritance. This paper does not address \nthe thorny issues of concrete object layout. Rather, it relies on a syntactic form of .eld resolution \nclose to the algorithm of Ramalingam and Srinivasan [14], itself a reformulation of the calculus of Rossie \nand Friedman [16]. Furthermore, Luo and Qin restricted themselves to non-virtual multiple inheritance \nonly, con\u00adsidered a rather abstract storage model, and de.ned the semantics of .eld access through substitution. \nIn a completely different direction, Gil and Sweeney [6] pro\u00ad posed an arguably space and time-ef.cient \nbidirectional object lay\u00adout scheme for multiple inheritance. The core of their algorithms is based on \nthe assumption that the compiler knows the complete class hierarchy. That assumption holds only in special \ncases (e.g. in a closed world with whole program analysis), and is inadequate for most realistic C++ \ncompilers at large, which must cope with a sep\u00adarate compilation model inherited from C. This theoretical \nwork was followed up by an quantitative study by Sweeney and Burke [17]. They developed a formalism to \ncharacterize when compiler artifacts (to support runtime semantics of C++-style inheritance) are required. \nTheir work in.uenced design choices in the memory layout of the IBM Visual Age C++ V5 compiler. The core \nof the bidirectional layout was later re.ned by Gil, Pugh, Weddell and Zibin [7] to a language-independent \nobject layout algorithm for multiple inheritance. However, they explicitly exclude C++-style non-virtual \nmultiple inheritance on the ground that it is a rarity or [. . . ] an abomination . It is not rare, and \nwe cannot afford such assumption for formally veri.ed layout algorithms in real world compilers for ISO \nstandard C++. Leaving C++ objects for the simpler world of C structures, Tuch [18] axiomatized a .eld \nseparation property of structure layout and used it in a separation logic able to verify low-level system \nC code. The Clight formal semantics of Blazy and Leroy [1] de.nes a sim\u00ad ple structure layout algorithm; \nthe .eld separation, .eld alignment and pre.x compatibility properties were mechanically veri.ed. 9. \nConclusions C++ object layout is one of those seemingly-simple implementa\u00adtion issues that turn out to \nrequire a 18 000 line Coq development to start making formal sense. Between the few compilers in the \npast that over-optimized the layout, losing object identity in the process, and the great many contemporary \ncompilers that err on the side of caution and miss opportunities for saving space, our formalization \nand mechanized veri.cation delineate a design space of trustwor\u00adthy, yet ef.cient layout algorithms, \nbringing more con.dence in commonly-used ABIs and suggesting further safe optimizations. This work is \nalso a .rst step towards formally verifying a com\u00adpiler front-end for a realistic subset of C++, even \nthough much work remains to be done on other aspects of the C++ object model (vir\u00adtual dispatch, construction \nand destruction, etc). Acknowledgments We are grateful to the anonymous reviewers for their very helpful \nsuggestions to improve our results and their presentation. We thank Bjarne Stroustrup and Lawrence Rauchberger \nfor their feedback, which helped us to keep our formalization connected to the realistic practices of \nC++ compilers. References [1] S. Blazy and X. Leroy. Mechanized semantics for the Clight subset of the \nC language. Journal of Automated Reasoning, 43(3):263 288, 2009. [2] J. Chen. A typed intermediate language \nfor compiling multiple inher\u00aditance. In 34th symp. Principles of Programming Languages, pages 25 30. \nACM, 2007. [3] CodeSourcery, Compaq, EDG, HP, IBM, Intel, Red Hat, and SGI. Itanium C++ ABI, 2001. URL \nhttp://www.codesourcery.com/ public/cxx-abi. [4] B. Dawes. POD s Revisited; Resolving Core Issue 568 \n(Re\u00advision 2). Technical report, ISO/IEC SC22/JTC1/WG21, March 2007. URL http://www.open-std.org/JTC1/SC22/WG21/docs/ \npapers/2007/n2172.html. [5] M. A. Ellis and B. Stroustrup. The Annotated C++ Reference Manual. Addison-Wesley, \n1990. [6] J. Gil and P. F. Sweeney. Space and time-ef.cient memory layout for multiple inheritance. In \n14th conf. on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 1999), pages \n256 275. ACM, 1999. [7] J. Y. Gil, W. Pugh, G. E. Weddell, and Y. Zibin. Two-dimensional bidirectional \nobject layout. ACM Trans. Program. Lang. Syst., 30(5): 1 38, 2008. [8] International Standard ISO/IEC \n14882:2003. Programming Lan\u00adguages C++. International Organization for Standards, 2003. [9] G. Klein \nand T. Nipkow. A machine-checked model for a Java-like language, virtual machine and compiler. ACM Trans. \nProg. Lang. Syst., 28(4):619 695, 2006. [10] D. Leinenbach, W. Paul, and E. Petrova. Towards the formal \nveri\u00ad.cation of a C0 compiler: Code generation and implementation cor\u00adrectness. In Int. Conf. on Software \nEngineering and Formal Methods (SEFM 2005), pages 2 11. IEEE, 2005. [11] X. Leroy. Formal veri.cation \nof a realistic compiler. Commun. ACM, 52(7):107 115, 2009. [12] C. Luo and S. Qin. Separation Logic for \nMultiple Inheritance. Elec\u00adtron. Notes Theor. Comput. Sci., 212:27 40, 2008. [13] N. Myers. The empty \nmember C++ optimization. Dr Dobb s Journal, Aug. 1997. URL http://www.cantrip.org/emptyopt.html. [14] \nG. Ramalingam and H. Srinivasan. A member lookup algorithm for C++. In Programming Language Design and \nImplementation (PLDI 97), pages 18 30. ACM, 1997. [15] T. Ramananandro. Formal veri.cation of object \nlayout for C++ multi\u00adple inheritance Coq development and supplementary material, 2010. URL http://gallium.inria.fr/ \ntramanan/cxx/. [16] J. G. Rossie and D. P. Friedman. An algebraic semantics of subobjects. In 10th conf. \non Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 1995), pages 187 199. ACM, \n1995. [17] P. F. Sweeney and M. G. Burke. Quantifying and evaluating the space overhead for alternative \nC++ memory layouts. Software: Practice and Experience, 33(7):595 636, 2003. [18] H. Tuch. Formal veri.cation \nof C systems code: Structured types, sep\u00adaration logic and theorem proving. Journal of Automated Reasoning, \n42(2):125 187, 2009. [19] D. Wasserrab, T. Nipkow, G. Snelting, and F. Tip. An operational semantics \nand type safety proof for multiple inheritance in C++. In 21st conf. on Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA 2006), pages 345 362. ACM, 2006.    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Object layout - the concrete in-memory representation of objects - raises many delicate issues in the case of the C++ language, owing in particular to multiple inheritance, C compatibility and separate compilation. This paper formalizes a family of C++ object layout schemes and mechanically proves their correctness against the operational semantics for multiple inheritance of Wasserrab et al. This formalization is flexible enough to account for space-saving techniques such as empty base class optimization and tail-padding optimization. As an application, we obtain the first formal correctness proofs for realistic, optimized object layout algorithms, including one based on the popular \"common vendor\" Itanium C++ application binary interface. This work provides semantic foundations to discover and justify new layout optimizations; it is also a first step towards the verification of a C++ compiler front-end.</p>", "authors": [{"name": "Tahina Ramananandro", "author_profile_id": "81350579834", "affiliation": "INRIA Paris-Rocquencourt, Le Chesnay, France", "person_id": "P2509562", "email_address": "Tahina.Ramananandro@inria.fr", "orcid_id": ""}, {"name": "Gabriel Dos Reis", "author_profile_id": "81309496659", "affiliation": "Texas A&#38;M University, College Station, TX, USA", "person_id": "P2509563", "email_address": "gdr@cs.tamu.edu", "orcid_id": ""}, {"name": "Xavier Leroy", "author_profile_id": "81100078576", "affiliation": "INRIA Paris-Rocquencourt, Le Chesnay, France", "person_id": "P2509564", "email_address": "Xavier.Leroy@inria.fr", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926395", "year": "2011", "article_id": "1926395", "conference": "POPL", "title": "Formal verification of object layout for c++ multiple inheritance", "url": "http://dl.acm.org/citation.cfm?id=1926395"}