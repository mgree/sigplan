{"article_publication_date": "01-26-2011", "fulltext": "\n Correct Blame for Contracts No More Scapegoating Christos Dimoulas Robert Bruce Findler Cormac Flanagan \nMatthias Felleisen Northeastern University Northwestern University University of California, Santa Cruz \nNortheastern University Abstract Behavioral software contracts supplement interface information with \nlogical assertions. A rigorous enforcement of contracts pro\u00advides useful feedback to developers if it \nsignals contract violations as soon as they occur and if it assigns blame to violators with precise explanations. \nCorrect blame assignment gets programmers started with the debugging process and can signi.cantly decrease \nthe time needed to discover and .x bugs. Sadly the literature on contracts lacks a framework for mak\u00ading \nstatements about the correctness of blame assignment and for validating such statements. This paper .lls \nthe gap and uses the framework to demonstrate how one of the proposed semantics for higher-order contracts \nsatis.es this criteria and another semantics occasionally assigns blame to the wrong module. Concretely, \nthe paper applies the framework to the lax enforce\u00adment of dependent higher-order contracts and the picky \none. A higher-order dependent contract speci.es constraints for the do\u00admain and range of higher-order \nfunctions and also relates argu\u00adments and results in auxiliary assertions. The picky semantics en\u00adsures \nthat the use of arguments in the auxiliary assertion satis.es the domain contracts and the lax one does \nnot. While the picky semantics discovers more contract violations than the lax one, it occasionally blames \nthe wrong module. Hence the paper also in\u00adtroduces a third semantics, dubbed indy, which .xes the problems \nof the picky semantics without giving up its advantages. Categories and Subject Descriptors D.3.1 [Formal \nDe.nitions and Theory]: Semantics; D.3.3 [Language Constructs and Fea\u00adtures]: Constraints General Terms \nLanguages, Design, Reliability Keywords Higher-order Programming, Behavioral Contracts, Blame Assignment \n* Dimoulas and Felleisen were partly supported by AFOSR (FA9550-09-1\u00ad0110) and NSF (CRI 0855140 &#38; \nCCF 0540818), Findler by NSF (0846012) and Flanagan by NSF (CNS-0905650). Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, \nUSA. Copyright c 2011ACM 978-1-4503-0490-0/11/01. . . $10.00 1. Dependent Contracts: Lax or Picky? Software \nengineers embrace behavioral1 software contracts for two reasons. On one hand, contracts help explain \nand protect the inter\u00adface of components, e.g., modules, classes, procedures, functions. On the other \nhand, programmers can use the familiar programming language to specify contracts, which makes it easy \nto read, write, and interpret them. While both arguments obviously apply to contracts for .rst\u00adorder \nlanguages, Findler and Felleisen (2002) s introduction of con\u00adtracts for higher-order functions raises \nsubtle, yet practically in\u00adteresting questions. One particular question concerns dependent higher-order \ncontracts that is, contracts that can state assertions relating the potentially higher-order argument \nto the potentially higher-order result. Such contracts come with two distinct seman\u00adtics in the literature. \nThe .rst is the so-called lax semantics of Find\u00adler and Felleisen, which uses the argument in the assertion \nwithout monitoring the argument contract. In contrast, the second, picky se\u00admantics of Blume and McAllester \n(2006) monitors the argument contract during the evaluation of the component and during the evaluation \nof the assertion. ;; for some natural number n and real d (->d ([f (-> real? real?)][e real?]) (fp (-> \nreal? real?)) #:post-cond (for/and ([i (in-range 0 n)]) (define x (random-number)) (define slope \n (/ (-(f (-x e)) (f (+ x e))) (* 2 e))) (<= (abs (-slope (fp x))) d))) Figure 1. A higher-order, dependent \ncontract To make this discussion concrete, consider the dependent func\u00adtion contract in .gure 1. This \nRacket fragment (formerly known as PLT Scheme) (Flatt and PLT 2010) speci.es a function that maps a real-valued \nfunction f (and a real number e) to a real-valued func\u00adtion fp. The post-condition adds that for some \nnumber n of num\u00adbers x, the slope of f at x is within d of the value of fp at x.A picky interpretation \nenforces that f and fp are applied to real num\u00adbers and produce such numbers during the evaluation of \nthe post\u00adcondition; a lax interpretation does not check these speci.cations. Greenberg et al. (2010) \ncompare these two forms of depen\u00addent contracts (and relate contracts to Flanagan (2006) s hybrid types). \nThey come to the conclusion that picky contracts signal the same violations as lax contracts and possibly \nmore. For exam\u00adple, random-number may actually produce a complex number and 1 We use Beugnard et al. \n(1999) s terminology.  Types t ::= o | t . t o ::= num | bool Terms e ::= v | x | ee | \u00b5x:t.e | e+e \n| e-e | e.e | e .e | zero?(e) | if eee Values v ::= 0 | 1 |- 1 | ... | .x:t.e | tt | ff E.Contexts E \n::=[] | Ee | vE | E + e | v+E | E -e | v-E | E .e | v .E | E .e | v.E | zero?(E ) | if Eee Figure 2. \nPCF syntax the contract may thus misapply f;the picky interpretation catches this potential problem, \nwhile the lax one doesn t. Our experience shows, however, that Greenberg et al. (2010) s result doesn \nt truly settle the issue. When a picky contract signals a contract violation, it may blame the wrong \nparty. In this paper, we develop a third notion of contract monitor\u00ading and demonstrate that it satis.es \nan intuitive correctness crite\u00adrion. We start from the observation that Greenberg et al. are correct \nin that a picky interpretation is important for dependent contracts. If the dependency assertion violates \na contract, the computation may go wrong in all kinds of ways. The question is which party the monitoring \nsystem should blame for such a problem. The picky interpretation blames either the server or the client. \nOur new inter\u00adpretation, dubbed indy, treats the contract as an independent party and blames it for problems \nwhere picky blames the wrong party. To compare the three possible interpretations, we develop a uni\u00ad.ed \nsemantic framework, based on a reduction semantics (Felleisen et al. 2009) for a PCF-like language with \ncontracts. The three inter\u00adpretations are expressed as three different, one-rule extensions that specify \nthe semantics of dependent contracts. We then enrich the framework with the necessary information to \ntrack code ownership and contract obligations, two novel technical notions that might prove useful in \nother contexts. This enriched framework is used to formalize the following correctness criterion: a contract \nsystem should only blame a party if the party controls the .ow or return of values into the particular \ncontract check that failed. We can prove that our new indy interpretation satis.es this cri\u00adterion while \npicky fails to live up to it. Inspired by our theoretical result, we equip Racket with an indy dependent \ncontract combina\u00adtor, ->i, in addition with the existing lax combinator, ->d. Finally, we explain how \nto use the framework to implement a tool that explains the responsibilities that contracts imposes. Speci.cally, \nthe tool teases out contract obligations from com\u00adplicated contracts and highlights them with colors. \nWe have im\u00adplemented the tool and include some screenshots to illustrate its usefulness.  2. Contract \nPCF PCF (Plotkin 1977) is the starting point for our model; .gure 2 summarizes the well-known syntactic \ndomains. In this setting, a program is a closed term. Also, we equip the language with a stan\u00addard type \nsystem and a call-by-value reduction semantics, though for lack of space, we omit the details (Plotkin \n1975; Felleisen et al. 2009). Similarly, we use type annotations only when needed. 2.1 Adding Higher-Order \nContracts Adding plain higher-order contracts (Findler and Felleisen 2002) to PCF is straightforward: \nsee .gure 3. First, PCF is enriched with contracts, a contract type, and new terms for attaching contracts \nto terms and raising contract violations. Second, we extend our type system with rules for the extra \nterms. The resulting language is CPCF, PCF with contracts. CPCF is equipped with two kinds of contracts: \n.at contracts, flat(e), and higher-order contracts, .1 The former are . .2. predicates on base values. \nThe latter combine a contract, .1,on the arguments of a function with a contract, .2, on the result of \nthe function. Contracts . ::= flat(e) | . . . Types t ::= ... | con(t) l,ll Terms e ::= ... | mon (.,e) \n| error l G f e : o . bool G f flat(e) : con(o) G f .1: con(t1) G f .2: con(t2) G f .1 . .2: con(t1 \n. t2) G f . : con(t) G f e : t G f mon kj ,l (.,e) : tG f error l : t Figure 3. CPCF: syntax and types \nThe most important new construct is the monitoring construct mon k,l (., e), which places a contract \n. between a term e (the server) j and its context (the client). It demands that any value that .ows between \ne and its context is monitored for conformance with the contract. For a .at contract, the predicate is \napplied to the value; for a higher-order contract, the pieces of the contract are attached to the argument \nand range position of a wrapper function and the contract is monitored as the function .ows through the \nprogram. A monitor comes with three labels:2 a pair of distinct blame labels k and l for the two parties \nto the contract and a contract label j, for the origin of the contract. In source code, the contract \nlabel j usually differs from k and l but under some circumstances it may be equal to either of the two. \nLabels are drawn from the enumerable set L. The label lo is used as the label of the whole program; l\u00afdenotes \na subset of L. When a contract fails a contract error, error l ,israised where l denotes the party responsible \nfor the violation. l,l E.Contexts E ::= ... | mon (., E ) l k,l k,ll,k E [mon j (.1 . .2,v)] -. E [.x.mon \nj (.2,v mon j (.1,x))] k,l E [mon j (flat(e),v)] -. E [if (ev) v error k] l E [error l ] -. error Figure \n4. CPCF: semantics The introduction of contracts requires small changes to the reduction semantics. Figure \n4 spells out the details, starting with the slight modi.cation of the set of evaluation contexts. The \nbottom half shows the reduction rules for contract checking and blame assignment, adapted from Findler \nand Felleisen (2002) s original semantics. A higher-order monitor is split into two parts: 1. a monitor \nfor the argument with reversed blame labels; 2. a monitor for the result with the original blame labels. \n 2 In an implementation, these labels are synthesized from the program text.  A .rst-order monitor \nis transformed to an if statement that checks whether the guarded value satis.es the contract s predicate. \nIf the predicate is satis.ed, the value is returned; otherwise a contract error is signaled using the \n.rst blame label to pinpoint the guilty party. Finally, when a contract error is raised the evaluation \nis aborted and the contract error is returned as the .nal result.  2.2 Adding Dependent Contracts In \ncontrast to conventional contracts for .rst-order functions, the higher-order contracts of the preceding \nsection cannot express de\u00adpendencies between arguments and results. Therefore Findler and Felleisen (2002) \nequip CPCF with a functional contract form that parameterizes the result contract over the argument: \n| . d Contracts . ::= ... .(.x..) Findler and Felleisen (2002) s reduction rule for these dependent contracts \ncaptures this intention: k,ld E [mon j (.1 .(.x..2),v)] -.l (lax) k,ll,k E [.x.mon (.2,v mon j (.1, x))] \nj A dependent monitor acts like a higher-order monitor. The subtle difference is that the parameter x \nof the proxy function captures the free occurrences of x in the contract s postcondition .2.Asa result, \nany argument to the proxy function is substituted for x in .2 and is then used in the argument position, \nsuitably wrapped with an argument monitor. Blume and McAllester (2006) observe that the precondition \n.1 is not enforced during the evaluation of postcondition .2.Thisgap opens the door for potential abuses \nof the argument in .2, i.e., uses that don t conform to .1. They rightly consider this a problem and, \nin turn, they propose the following change to the rule:3 k,ld E [mon (.1 .(.x..2), v)] -.p (picky) j \nk,ll,kl,k E [.x.mon j ({mon j (.1, x)/x}.2, v mon j (.1,x))] Speci.cally, every free occurrence of x \nin .2 is replaced with mon lj ,k(.1,x). Thus, any argument to the function remains protected by .1 even \ninside .2. Note how the injected monitor carries the same blame labels as the monitor for the argument \nin the body of the function.4 Greenberg et al. (2010) compare the lax and picky contract sys\u00adtems and \nconclude that the former signals strictly fewer contract errors than a picky contract system. More precisely, \nfor any pro\u00adgram, the following statements hold: neither contract system signals a contract error; \n both raise an error and blame the same party; or  the picky contract system discovers a contract violation \nand the lax system does not raise a contract error.  Their results characterizes two different philosophies \nof contract code. On the one hand, a lax contract system treats contracts as trusted code. Both parties \nhave agreed to the contract and have pre\u00adsumably ensured that its evaluation doesn t violate any invariants. \nOn the other hand, a picky contract system considers contracts to contain potentially faulty code. To \nenforce the contracts within this code, a picky system protects values that .ow into the contracts. The \nproblem with the picky system is that it may blame the server or the client for violations of a contract \n. when neither of 3 In principle, this reduction rule should use a let to preserve a strict call\u00adby-value \nregime. But, due to the restrictions on our grammar for contracts, a straight substitution is technically \ncorrect and superior. 4 An alternative de.nition for the picky rule is to not switch the blame labels \non the internal monitor. Doing so does not affect our results. them can control the .ow of values into \nthe responsible monitor. To illustrate this point and to provide an alternative, we introduce a third \ncontract monitoring system that considers contracts as inde\u00adpendent entities. When a dependent contract \nabuses a value accord\u00ading to .1, this revised system blames the contract for the violation. Here is the \nreduction rule: k,ld E [mon j (.1 .(.x..2),v)] -.i (indy) k,ll, jl,k E [.x.mon j ({mon j (.1,x)/x}.2, \nv mon j (.1, x))] The rule makes the contract responsible if it supplies an inappro\u00adpriate value to a \nfunction argument during the evaluation of the dependency. It accomplishes this switch of responsibility \nwith the creation of a new monitoring expression for the argument with the contract label as the negative \nblame label. This new argument expression is substituted into the range part of the contract.5 For an \nexample, consider this monitor expression: .0 = mon k,l (.,.x.( 0 )) .x.( 1 ) j where d . = .1 .(. f \n.flat(.x. f (.x.( 2 )) > 0)) .1 =(P? . P?) d .(.g.flat(.x.g 3 > 0)) Here the server is the function .x.( \n0 ), while the client is the context [] .x.( 1 ). The mediating contract . is a higher-order, dependent \ncontract where P? checks for positive numbers, i.e., P? = flat(.x.x > 0) and > has the standard recursive \nde.nition. The argument .x.( 1 ) .ows to the postcondition of . and replaces f . To protect it from potentially \nmisbehaving contract code, it is wrapped with a monitor that enforces .1: mon lj , j(.1, .x.( 1 )) . \nSince .1 is a dependent contract, too, the story continues. When the postcondition is eventually checked, \nthis proxy function for .x.( 1 ) is applied to .x.( 2 ). In that case, the latter .ows to the postcondition \nof .1 and replaces g with another monitored domain contract. Each of the three rules gives rise to a \nsemantics for CPCF. In principal, we extend -. with -.m where m .{l, p,i} to get the three complete reduction \nrelations. Since there is no danger of ambiguity, we overload the symbol -.m and use it for the complete \nsemantics.  2.3 Two More Flavors The treatment of contracts as independent parties is compatible with \nsome practical uses in our Racket implementation. First, con\u00adtracts for Racket s unit system are given \nas part of the signature. Strickland and Felleisen (2009) show that linking such units may necessitate \nblaming the signature itself. Our framework .nally pro\u00advides a semantic explanation for this phenomenon. \nSecond, in Racket s .rst-order module system, contracts are speci.ed via provide/contract, i.e., in the \nexport interface of modules. This form combines identi.ers with contracts and at\u00adtaches contracts to \nthese values as they .ow across the module boundary. When things go wrong with the dependencies in such \n5 Morally, the monitor should not apply when the client is already labeled with the contract label. In \nthat case, the value .ow is entirely within the contract party and should strictly speaking not be monitored. \nTo model this behavior, we would have to add the side condition l .j and add a second = rule: k,ldk,ll,k \nE [mon (.1 .(.x..2),v)] -.iE [.x.mon (.2,v mon (.1, x))] j jj if l = j Both variants of indy satisfy \nthe main theorem, which is why this paper focuses on the theoretically simpler approach.  contracts, \nthe monitoring system considers the contract a part of the server module and blames the server module. \nWe can express this idea dubbed +indy in our framework with the small change of using the module name \nas the contract label. Finally, Typed Racket (Tobin-Hochstadt and Felleisen 2010, 2008) protects the \ninteraction of typed and untyped modules with contracts derived from types. Since one of the basic assumptions \nof Typed Racket is that untyped modules stay unchanged, it imple\u00adments this protection mechanism with \nrequire/contract.This contract form guarantees that values from an untyped module sat\u00adisfy the speci.ed \ncontract. Put differently, the form protects the im\u00adport boundary. If a programmer attached dependencies \nto these con\u00adtracts, the code would have to be considered as a part of the client module. We can capture \nthis semantics, dubbed -indy,byusingthe importing module s name as the contract label.  2.4 Comparing \nContract Systems Equipped with three additional contract monitoring systems, we can now explore their \nrelationship. Consider this example: .1 = mon* k,l (.,. f . f 42) .x.x where . =(P? . P?) d .(. f .flat(.x. \nf 0 > -1)) The example uses the placeholder * for the contract label so that we can include +indy and \n-indy the two additional .avors of indy in our comparisons. As needed, we replace * with k for +indy, \nwith l for -indy, and a distinct label j for indy. Recall that the reduction rules for the lax and picky \ncontract monitoring systems do not employ the contract label. The evaluation of .1 yields the following \nresults for the .ve different contract monitoring systems: program * monitoring system result .1 lax \n42 .1 k picky error .1 j j indy error k .1 k +indy error .1 l l -indy error The table demonstrates several \npoints. First, when a program yields a plain value according to the lax system, the picky system may \nstill .nd a fault during contract checking and signal a violation. Second, the picky system here blames \nparty k, the server component, for a contract violation. The speci.c violation is that f is applied to \n0 in the dependency assertion, even though the domain contract promises that the function is only applied \nto positive numbers. Third, the indy system blames the contract itself, rather than the server. Fourth, \nthe system based on the +indy rule agrees with the picky system, because it considers all code in a contract \nas part of the server. Finally, the -indy system blames party l; after all, the misapplication of f is \ninternal to the client, which chooses to defy the restrictions on the domain of f . Another example shows \nthat picky can also blame the client when things go wrong with the contract: .2 = mon k* ,l (.,. f . \nf .x.x) .g.g 42 where . =((P? . P?) d .(. f .flat(.x. f 0 > -1))) . P? Speci.cally, evaluating .2 yields \nthe following results: program * monitoring system result .2 lax 42 .2 l picky error .2 j indy error \nj k .2 k +indy error .2 l l -indy error Again the lax system does not signal contract violations, while \nthe other four report one. Here the indy system blames the contract itself rather than the client, which \nis blamed by the picky and -indy systems. The +indy system blames the server. Together the two examples \ndemonstrate that none of our new monitoring rules are logically related to picky if we take blame into \naccount. In short, the introduction of contracts as independent parties calls for a comparison that takes \ninto account why a contract violation is detected and why the accused party is blamed. Note, however, \nthat the indy contract system signals an error when the picky system signals an error and vice versa, \nthough the errors aren t necessarily labeled with the same party. ** k PROPOSITION 1. e -.i error k iff \ne -.p error PROOF IDEA. By a straightforward bi-simulation argument. The bi-simulation used for the proof \nrelates two expressions that are structurally identical except that their labels can differ.  3. Tracking \nOwnership and Obligations While the preceding section illuminates the problems of the picky contract \nsystem and the dif.culty of comparing contract systems in general, it also implies a new way of thinking \nabout contract violations. The .rst major insight is that the picky system may blame either the server \nmodule or the client module when, in fact, the contract itself is .awed. From here, it is obvious to \ninspect what a contract monitoring system would do if contracts were a part of the server, a part of \nthe client, or a third party. Doing so produces the second major insight, namely, that none of these \nalternatives agrees with the picky semantics. Putting the two insights together implies that we need \na seman\u00adtics that (1) for each party, keeps track of its contract obligations and (2) for each value, \naccounts for its origin. Once a semantics provides this additional information, we can check whether \na con\u00adtract system ever blames a party for violating an obligation if the party has no control over the \nvalue s .ow into the contract. In this section, we equip CPCF s semantics with ownership and obligation \ninformation, which is maintained across reductions. In the next sec\u00adtion, we use this information to \nstate a contract correctness property and to measure how the various monitoring systems fare with re\u00adspect \nto this property. 3.1 Ownership . . . To model an ownership relationship between parties and code, we \nextend CPCF with a new construct that relates terms and values to parties:6 Terms e ::= ... |lell Values \nv ::= ... |lvll During reductions, terms and values come with a stack of own\u00aders, re.ecting transfers \nfrom one party to another. The notations .. ln ln lel and lel are short-hands for such stacks, abbreviating \nl...lell1 ...lln and l...lelln ...ll1, respectively. Ownership l for an expression means its result is \nattributed to l. In turn, a value with an ownership l originates from component l or is affected by a \ntraversal through component l.  3.2 ...and Obligations CPCF contracts consist of trees with .at contracts \nat the leafs. Exploiting the analogy with function types, Findler and Felleisen (2002) implicitly decompose \nthese trees into obligations for servers 6 The inspiration of ownership comes from the work of Zdancewic \net al. (1999) on principals. For a comparison, see section 6.  (positive positions) and clients (negative \npositions). Their seman\u00adtics tracks this connection via labels; errors use them to pinpoint contract \nviolators. Dimoulas and Felleisen use this idea for a static decomposition of contracts into server and \nclient obligations. They de.ne two functions from contracts to contracts that tease out the respective \nobligations. The one for teasing out server obligations replaces .at contracts in negative positions \nwith T = flat(.x.tt) and then reconstructs the overall contract; analogously, the decomposition map for \nteasing out client obligations replaces .at contracts in positive positions with T. For instance the \ncontract of the .2 example in section 2 yields these decompositions: ((P? . P?) d .(. f .flat(.x. f 0 \n> -1))) . P? server ((T . P?) d .(. f .T)) . P? client ((P? .T) d .(. f .flat(.x. f 0 > -1))) .T Decomposition \nimplies that each .at contract imposes obliga\u00adtions on a speci.c component, i.e., party to a contract. \nSince one and the same server may connect with many different clients and since indy systems may use \nthe contract itself as a component, it is not just one party that is associated with a .at contract but \nmany. Hence we modify the syntax of contracts to statically associate .at contracts and owners: Contracts \n. | . . . | . d ::= lflat(lell )Jl\u00af .(.x..) In contrast with ownership, obligations come as sets of labels \nl\u00af, not vectors. After all, there is no need to order obligations or to change them during an evaluation. \nOf course, a static attribute about a dynamic obligation calls for a way to determine whether such annotations \nare well-formed.  3.3 Well-formed Ownership and Obligations Only some annotations make sense for a source \nprogram. Both ownership and contract monitors specify boundaries and, at the source level, these boundaries \nshould coincide. We therefore intro\u00adduce a well-formedness judgment to enforce these conditions for source \nprograms. Before doing so, we present the simple typing rules for the two new constructs: G f e : o . \nbool G f e : t G flflat(e)Jl\u00af: con(o) G flell : t Concerning ownership annotations, a CPCF source program \nmay contain those at only two places: in contract monitors and in .at contracts. Since contract monitors \nestablish a boundary be\u00adtween the client component and the server component, we demand an ownership annotation \non the server component and that a match of these annotation with the positive label of the monitor. \nCon\u00adversely, the context of such an expression must belong to the client. Finally, .at contracts must \ncome with ownership labels consistent with the surrounding monitors because they are turned into plain \ncode during the evaluation, and the semantics must track where they originated from. We express this \nconstraint with the well-formedness relation l f e, which says that l owns e and checks that e is well-formed. \nEquivalently, l is the owner for the context of e. A closed expression e is a well-formed program if \nlo f e where lo is the label reserved for the owner of the program. Figure 5 de.nes most of this well-formedness \njudgment. For terms that do not involve monitors and contracts the de.nition is a structural judgment, \nand base values and variables are well\u00adformed under any owner. The actual key is the one for contract \nmonitor, which we present separately. According to our informal description, a well-formed contract monitor \nis a boundary between l f e l f if e1 e2 e3 l f e1 l f e2 l f e l f e l f e1 e2 l f .x.e l f \u00b5x.e l f \ne1 l f e2 l f e3 l f e1 l f zero?(e1) l f e1 l f e2 l f e1 l f e2 l f e1 +e2 l f e1 -e2 l f e1 l f \ne2 l f e1 l f e2 l f e1 .e2 l f e1 .e2 l f n l f tt l f ff l f x Figure 5. Ownership coincides with \ncontract monitors a client and a server, implying this shape for the judgment: k,l l f mon j (., lelk) \nIt says that if l owns the context and k is the blame label for the server, then the blame label for \nthe client should be l and the wrapped expression e should come with an ownership annotation that connects \nit to k.Next, e must be well-formed with respect to its owner k, because it may contain additional contract \nmonitors. But even with this antecedent, the well-formedness judgment is incomplete. After all, the contract \n. that governs the .ow of values between the server and the client contains code and this code must be \ninspected. Furthermore, we must ensure that all .at contracts within . are obligations of the appropriate \nparties including the contract monitor itself, which is represented by the contract label j. Putting \neverything together, we get this well-formedness rule for contract monitors in source programs: k f e \n{k};{l}; j > . k,l l f mon j (., lelk) It relies on a secondary well-formedness judgment for contracts, \nto which we turn next. l\u00af; k\u00af; j > .1 k\u00af; l\u00af; j > .2 \u00af k; l\u00af; j > .1 . .2 \u00af l\u00af;k\u00af.{ j}; j > .1 k;l\u00af; \nj > .2 d \u00af k;l\u00af; j > .1 .(.x..2) j f e \u00afk\u00af k;l\u00af; j > lflat(lelj)J Figure 6. Obligations coincide with \nlabels on monitors Roughly speaking, k\u00af;l\u00af; j > . says that contract . is well-formed for sets of positive \nand negative obligation labels k\u00afand l\u00af, respec\u00adtively, and the owner j of the contract monitor that \nattaches the contract to a boundary. As the de.nition in .gure 6 shows, the two sets are swapped for \nthe antecedents of higher-order (dependent) contracts. For the negative positions in the precondition \nof depen\u00addent contract label j is added to indicate that these are also obli\u00adgations of the owner of \nthe contract monitor. For .at contracts the positive obligation labels must coincide with the obligation \nlabels of the contract.  Note that the well-formedness of .at contracts also enforces an ownership annotation. \nSpeci.cally, the owner of the context which, by assumption, is a contract monitoring construct labeled \nwith j is also the owner of the predicate in the .at contract. The antecedent of the rule recursively \nuses the well-formedness judgments for ownership to ensure that e itself is well-formed.  3.4 Ownership \nand Obligations Semantics The .nal change to the CPCF model concerns the reduction seman\u00adtics. Speci.cally, \nwe change the reduction relations so that each re\u00adduction step keeps track of ownership rights and obligations. \nWhile ownership and obligations do not affect the semantics per se, the information is critical for characterizing \nthe behavior of contract monitoring systems, as we show in the next section. Our .rst step is to equip \nthe grammar of evaluation contexts with a parameter that accounts for the owner of the hole. In the parameterized \ngrammar, El , of .gure 7 the parameter l points to the ownership annotations that is closest to the hole \nof the context. E.Contexts El ::= Gl Gl ::= e | vGl | Gl + e | v+Gl Gl | Gl -e | v -Gl | Gl .e | v.Gl \n| Gl .e | v.Gl | zero?(Gl ) k,l | if Gl ee | mon j (., Gl ) |lFll |lGl ll F ::=[] | Fe | vF | F +e | \nv+ F | F -e | v-F | F .e | v.F | F .e | v.F | zero?(F) k,l | if Fee | mon j (.,F) Figure 7. Parameterized \nevaluation contexts Evaluation contexts are labeled with the label lo the label re\u00adserved for the whole \nprogram if they do not contain an ownership constructs on the path from the hole to the root: Elo ::= \nF. From now on, all reduction relations assume labeled evalua\u00adtion contexts. This implies that newly \ncreated values are always assigned an owner. For the reduction relations concerning primi\u00adtive operators \nand conditionals, the changes are straightforward and summarized in the top part of .gure 8. For the \nrules concerning monitors with .at and plain higher-order contracts and their blame assignments, speci.ed \nin the lower part of the same .gure, we also know that they do not need to manipulate any ownership annota\u00adtions. \nThese reduction rules remain unchanged, modulo the labeled evaluation contexts. The obligation annotation \non .at contracts is ignored. For details, see the bottom part of .gure 8. We add one last simple rule \nseparately: k El [error k] -.m error Since the act of signaling errors erases the surrounding evaluation \ncontext, the format of this rule doesn t .t the table. Note that the context on the right is []lo and \nl may not equal lo. The reduction of \u00dfv redexes typically demands several re\u00adalignments with respect \nto ownership. To start with, the function and the argument may belong to different parties. Furthermore, \nthe context brings together the operand and operator, and the se\u00admantics should keep track of this responsibility. \nTogether, the two observations suggest the following relation: . .. El [l.x.elln v] -.m El [l{lvllln \n/x}elln ] El [\u00b7\u00b7\u00b7] -.m El [\u00b7\u00b7\u00b7] . . ln1l k + ln2l l \u00b7 n where n1 + n2 = n . . ln1l k -ln2l l \u00b7 n where \nn1 - n2 = n . zero?(l0l l ) . \u00b7 tt zero?(lnlk ) . . \u00b7 ff if n .= 0 lv1l k .lv2l l \u00b7 v where v1 . v2 = \nv . . lv1l k .lv2l l \u00b7 v where v1 . v2 = v . if lttl l e1e2 \u00b7 e1 . if lffl l e1e2 \u00b7 e2 mon k,l j (.1 \n. .2,v) mon k,l j (lflat(e)Jl\u00af ,v) \u00b7 . .x.mon k,l j (.2,v mon l,k j (.1,x)) if (ev) v error k Figure \n8. Ownership and obligation propagation The relation says that after tagging the value with the ownership \nlabel l of the context, the value moves under the ownership annota\u00adtions of the function. The result \nis a value whose innermost owner is l and whose outermost owner is l1 of l. n: lvll . ln The properly \nannotated value is then substituted into the body e of the function for its parameter x. The result itself \nis owned by the same owner as the function. Put differently, it is best to view function application \nas a form of communication between two components: the function and its context. The context picks the \nargument, declares itself its owner, and then passes it to the function. The function accepts the argu\u00adment, \nadjusts its ownership, and integrates the result into its body. Recursion is treated as a special form \nof function application: El [\u00b5x.e] -.m El [{l\u00b5x.ell /x}e] The owner of the context l and user of the \nrecursive function declares itself owner of \u00b5x.e before substituting it in the body of the recursive \nfunction. All the complexity of tracking ownership is due to dependent function contracts. Consider the \nsimplest variant, lax: k,ld E [mon j (.1 .(.x..2),v)] -.l (lax) k,ll,k E [.y.mon j ({y/x}.2,v mon j (.1, \ny))] For emphasis, this version of the reduction rule uses y as the parameter of the proxy function on \nthe right hand side. The use of y as parameter demands that we also replace all occurrences of x in .2 \nwith y so that when the proxy function is applied, the actual argument is substituted into the dependent \nrange contract; without the substitution, the reduction would create free variables.7 Rewriting the lax \nrule in this way reveals that it encodes a masked function application. The problem is that, as discussed \nabove, a function application must add the label of the responsi\u00adble owner at the bottom of the stack, \nand this label is not available here. Instead, it is found at the .at leafs of the contract, which according \nto the static semantics of the preceding subsection must come with an ownership annotation. The solution \nis to intro\u00adduce the substitution function {e/cx}., which copies the ownership label from .at contracts \nto the substituted term. 7 The value v is unaffected by this change of parameters, because we assume \nthe usual hygiene condition (Barendregt 1984) for metavariables.  With this substitution function in \nplace, it is easy to specify the three variants for the reduction of dependent functional contracts: \nEl [\u00b7\u00b7\u00b7] ... El [\u00b7\u00b7\u00b7] k,ld mon j (.1 .(.x..2),v) -.l k,ll,k .x.mon j ({x/cx}.2,v mon j (.1,x)) (lax) \nk,ld mon j (.1 .(.x..2),v) -.p k,ll,kl,k .x.mon j ({mon j (.1, x)/cx}.2,v mon j (.1,x)) (picky) k,ld \nmon j (.1 .(.x..2),v) -.c k,ll, jl,k .x.mon ({mon j (.1, x)/cx}.2,v mon j (.1,x)) (indy) j We conclude \nthis section with the de.nition of the auxiliary substitution function: l\u00af l\u00af {e/cx}lflat(le ll )J= lflat({lell \n/x}le ll )J{e/cx}.1 . .2 = {e/cx}.1 .{e/cx}.2 dd {e/cx}.1 .(.x..2)= {e/cx}.1 .(.x..2) {e/cd{e/cd x}.1 \n.(.y..2)= x}.1 .(.y.{e/cx}.2) where x . = y The de.nition is total. The rede.nition of the contract syntax \nen\u00adforces that .at contracts always have the annotations expected by the domain of the substitution function. \nThis also guarantees that the reduction relations -.m are well-de.ned.  4. Correct Blame Using ownership \nand obligation annotations, we can formulate what it means for a contract system to correctly blame a \nviolator. After all, the tracking of ownership and obligations is entirely independent of the contract \nchecking, and it is thus appropriate to use tracking as an independent speci.cation of contract monitoring. \nValues should be originating from one of the parties of the contract are checked only against .at pieces \nof the contract for which the party is responsible. Now we can phrase this property in terms of ownership \nand obligations: when the evaluation reaches a redex that checks a .at contract on a value, then the \nowner of the value must be the same as the positive party of the monitor and in addition the positive \nparty is included in the obligations of the contract. DEFINITION 2 (Blame Correctness). A contract system \nm is blame correct if for all terms e0 such that lo f e0, and * k, l\u00af e0 -.mE [mon (lflat(e1)J, v)] \nv = lv1lk and k . \u00afl. The identity of the labels is irrelevant. The de.nition says that when the reduction \nof a well-formed program reaches a state in which it checks a .at contract, then the server (positive) \nlabel of the monitor and the ownership label on the value must coincide and, furthermore, the set of \nobligations for the .at contract must contain this label. Conversely, if these obligations are not met, \nthe monitor may blame k for a contract failure even though the party had no control over the .ow of v \ninto this monitor. We can prove that the indy contract system and even the lax sys\u00adtem are blame correct, \nwhile picky isn t. The proof of the positive theorem directly follows from a subject reduction theorem \nfor own\u00adership annotations. This latter theorem requires a complex proof, which is the subject of the \nsecond subsection. The third subsection explains how to prove the two main theorems. To start with, how\u00adever, \nwe clarify that ownership annotations and obligations do are orthogonal to semantics. 4.1 It is all about \nInformation Propagation The addition of ownership and obligation annotations does not affect the behavior \nof any programs. Our revised semantics simply propagates this information so that it can be used to characterize \nexecution states. In order to formulate this statement, we use the * cpc f symbol -.m for the transitive-re.exive \nreduction relations of * section 2 and -.manno for the relations of section 3. PROPOSITION 3. The following \nstatements hold for m .{l, p,c}. 1. Let e be a well-formed CPCF program: lo f e. Let \u00af ebethe plain CPCF \nexpression that is like e without annotations. If * anno * cpc f \u00af e -.m e,then e\u00af-.m e. 2. Let \u00afe be \na plain CPCF program. There exists some labeled * cpc f \u00af CPCF program e such that lo f e. Furthermore, \nif e\u00af-.m e, * anno then e -.m e. PROOF IDEA. By a straightforward bi-simulation argument. One consequence \nof this proposition is that picky and indysignal still the same number of contract violations (proposition \n1).  4.2 Subject Reduction While l f e speci.es when source programs are well-formed, the reduction \nsemantics creates many expressions that do not satisfy these narrow constraints. For example, a well-formed \nprogram con\u00ad k,l tains only monitor terms of the form mon j (.,le0lk). A reduction sequence may contain \nprograms with differently shaped monitors, however. In particular due to the reductions of higher-order \nde\u00adpendent contracts, the monitored expressions may be applications, k,lk,l mon j (., le0lk er), or variables, \nmon j (.,x). Fortunately, such de\u00adviations are only temporary. In the case of the application the ar\u00adgument \ner is always well-formed under l and, when it is absorbed by le0lk, the monitor expression is once again \nwell-formed. In the case of the free variable we can show that x is always replaced with a value of the \nform lv0lk, which conforms to the standard form. To formulate a subject reduction theorem, we must generalize \nboth the judgment for well-formed programs, l f e, and the one for well-formed contracts, k\u00af;l\u00af; j > \n.. First, we equip the two relations with an environment that records the label of bound variables: l; \nG {x : l}f el;G \\{x}f e l; G f .x.el;G f \u00b5x.e With environments, it becomes possible to check variable \noccur\u00adrences in monitor terms. Second, we add a rule for checking expressions that already have an owner: \nk;G f e l; G flelk While these terms show up only within monitors in source pro\u00adgrams, they .ow into \nmany positions during evaluations. Using this new rule, we can check these cases, too. All other rules \nexcept those concerning monitors propagate the environment and otherwise check expressions in the same \nway as the corresponding rules of the preceding section. The rule for variables ignores the environment. \nVariables not in monitor terms can be replaced with well-formed terms of any owner. For details, see.gure9. \nThe purpose of the environment is to check expressions without ownership annotations in monitor terms. \nHere is the key rule: k;G f e {k}; {l}; j;G > . l;G f mon kj ,l (.,e) To check whether the wrapped expression \nis well-formed, it dele\u00adgates to the auxiliary relation k; G f e. The contract is checked as before, \nthough, with an environment. With k;G f e, we can check the ordinary ownership terms but also applications \nand variables as introduced during reductions. For  j;G f e j; G f e1 j;G f e2 j; G f e1 j; G f e1 e2 \nj; G f zero?(e1) j;G f e1 j;G f e2 j; G f e3 j; G f error kj;G f if e1 e2 e3 j;G f e1 j;G f e2 j;G f \ne1 j;G f e2 j;G f e1 +e2 j;G f e1 -e2 j;G f e1 j;G f e2 j;G f e1 j;G f e2 j;G f e1 .e2 j;G f e1 .e2 \nj; G f n j;G f tt j;G f ff j; G f x \u00af k;l\u00af; j;G > . l\u00af; k\u00af; j;G > .1 k\u00af;l\u00af; j;G > .2 \u00af k; l\u00af; j;G > .1 \n. .2 l\u00af;k\u00af.{ j}; j; G > .1 k;l\u00af; j;G > .2 \u00af d \u00af k;l\u00af; j;G > .1 .(.x..2) j;G f ek . k\u00af \u00af\u00afk\u00af k; l\u00af; j;G \n> lflat(lelj)J Figure 9. Obligations coincide with labels on monitors (2) function applications, the \nlabel serves as ownership label for the operator and the operand, similar to the standard application \nrule: k;G f e1 k;G f e2 k; G f le1lke2 For free variables, the environment serves as the source of the \nownership label: G(x)= k k; G f x After all, the variable in this position is going to be replaced by \na value via a function application, and the substitution is going to use a value with the speci.ed label. \nFinally, for a guarded term with an ownership annotation, it suf.ces to check if it is well-formed with \nrespect to the speci.ed owner: k; G f e k; G f lelk A well-formed program in the sense of the preceding \nsection is a well-formed program in the sense of revised judgment, too. PROPOSITION 4. Forall e andl,l \nf e implies l;\u00d8 f e. PROOF IDEA. By straightforward induction on the height of the derivation l f e. \nA program that is well-formed according to l; G f e reduces to well-formed programs. This statement holds \nfor a contract system using the lax reduction rule as well as for or those using indy. THEOREM 5. Let \ne be a program such that lo;\u00d8 f e. Then: 1. ife -.le0,thenlo;\u00d8 f e0; 2. ife -.ie0,thenlo;\u00d8 f e0.  PROOF. \n(1) We proceed by case analysis on the reduction of e: El [ln1l. k +ln2l. l ] -. lEl [n]. By assumption \nlo;\u00d8 f e,for which lemma 6 implies that l; \u00d8 fln1l. k +ln2l. l . We can use the same label to check \nn via the inference rules, i.e., l;\u00d8 f n. Hence, lo;\u00d8 f El [n].  The cases for other primitive operations \nare similar to the .rst.  El [\u00b5x.e] -.l El [{l\u00b5x.ell /x}e]: By assumption and lemma 6, l;\u00d8 f \u00b5x.e. From \nlemma 7 we get that l; \u00d8 f{l\u00b5x.ell /x}e and, in turn, lo;\u00d8 f El [{l\u00b5x.ell /x}e].  . .. El [l.x.e0lkv] \n-.l El [l{lvllk /x}e0lk ]: Again by assump\u00ad tion and lemma 6, we conclude that l;\u00d8 fl.x.e0l. kv and, \ntherefore, l;\u00d8 fl.x.e0l. k and l;\u00d8 f v. Next we distinguish two cases, depending on the length of . k. \nFirst assume the vector is empty. In that case, the inference rules imply l;{x : l}f e0. Combining this \njudgment with l;\u00d8 f v, we may conclude that l;\u00d8 f{lvll /x}e0 via lemma 8. Finally from here it is easy \nto get lo;\u00d8 f El [{lvll /x}e0], the desired conclusion. Second, let k1 be the .rst element of . k. In \nthat case, the infer\u00adence rules imply k1;{x : k1}f e0.Since l; \u00d8 f v still holds, we conclude again via \nlemma 8 that k1;\u00d8 f{lvll . k /x}e0.Since k1 is the outermost element of . k, we .nally get the desired \nconclu\u00ad sion, lo; \u00d8 f El [l{lvll . k /x}e0l. k ]. k,ll\u00af El [mon (lflat(ec)J,v)] -.l El [if (ec v) v error \nk]:The j k,ll\u00af assumptions imply l;\u00d8 f mon j (lflat(ec)J, v) via lemma 6 and hence, ec = leclj with j; \n\u00d8 f ec. Furthermore, the same reasoning yields v = lv0lk and k; \u00d8 f v0. Since the rules for k well-formed \nexpressions imply l; \u00d8 f if (ec v) v error is well-formed, the desired conclusion follows immediately. \nk,lk,ll,k El [mon (.1 . .2, v)] -.l El [.x.mon j (.2, v mon j (.1, x))]: j k,l With the usual reasoning, \nwe get l;\u00d8 f mon j (.1 . .2, v), v = lv0lk,and k;\u00d8 f v0. The contract check yields two pieces of knowledge: \n{l};{k}; j;\u00d8 > .1 and {k};{l}; j;\u00d8 > .2 From an additional application of the inference rules for well\u00ad \nl,k formedness we get k;{x : l} f v mon j (.1, x) and, with the help k,ll,k of lemma 9, l; {x : l}f mon \nj (.2, v mon j (.1, x)). Finally from a last application of the inference rules for well-formedness we \nk,ll,k get l;\u00d8 f .x.mon j (.2,v mon (.1,x)). j k,ld Finally, let e = El [mon (.1 .(.x..2), v)] and observe \nthat j k,ll,k e -.l El [.x.mon j ({x/cx}.2,v mon j (.1,x))]. k,ld Vialemma6wederive l; \u00d8 f mon j (.1 \n.(.x..2), v) . Thus, v = lvlk with k; \u00d8 f v,but also {l};{k, j}; j;\u00d8 > .1 and {k};{l}; j; \u00d8 > .2 . The \nrest of this argument uses the same strategy as the preced\u00ading case, except that we use lemmas 10 and \n14 to derive the key k,ll,k result, l; {x : l}f mon j ({x/cx}.2,v mon j (.1,x)).  (2) The proof of part \n(2) differs from the proof of part (1) only in the case for monitors with dependent contracts. Therefore, \nk,ld let e = El [mon j (.1 .(.x..2),v)] and recall that the contraction proceeds as follows: k,ll, jl,k \ne -.i El [.x.mon ({mon j (.1, x)/cx}.2,v mon j (.1,x))]. j k,ld Once again, we derive l;\u00d8 f mon j (.1 \n.(.x..2),v) via lemmas 6. Hence, v = lvlk with k;\u00d8 f v,but also {l};{k, j}; j;\u00d8 > .1 and {k}; {l}; j;\u00d8 \n> .2 . l,k By the well-formedness, k;{x : l} f v mon j (.1, x).Now,withthe help of lemmas 12 and 14, \nwe can derive k,ll, jl,k l;{x : l}f mon ({mon j (.1, x)/cx}.2,v mon j (.1,x)) . j Thus we conclude the \nproof with another application of the infer\u00adence rules for well-formedness. The proofs of the central \nlemmas depend on a series of auxiliary lemmas about the properties of well-formed terms and contracts, \nsubstitution, and contract substitution. LEMMA 6. If l;\u00d8 f Ek[e] then k;\u00d8 f e. PROOF IDEA. By induction \non the size of Ek . LEMMA 7. If l;G f e, k; G f e0, and x .. dom(G),l;G f{le0lk/x}e. PROOF IDEA. By induction \non the height of l;G f e. LEMMA 8. If l;G {x : k}f e, v = lv0lk and k;G f v0,then l; G f{v/x}e . PROOF \nIDEA. By induction on the height of l; G {x : k}f e.Note k,l that l; G {x : k}f mon j (.,x) is a base \ncase. LEMMA 9. If l;G f e and x ./dom(G),thenl; G {x : k}f e. PROOF IDEA. By induction on the height \nof l;G f e. LEMMA 10. If k;l\u00af; j;G > . and x ./dom(G),then \u00af \u00af k; l\u00af; j;G {x : l } > {x/cx}. . PROOF \nIDEA. By induction on the height of k\u00af;l\u00af;l; G > .. For the .at contracts case we employ lemma 11. LEMMA \n11. If l;G f e and x ./dom (G),l; G {x : k}f{lxll /x}e. PROOF IDEA. First, we generalize the lemma s \nstatement: If l; G f e and x ./dom (G), l;G {x : k}f{lxlj/x}e. Then we proceed by induction on the height \nof l; G f e. k,l \u00af LEMMA 12. If k;l\u00af; j;G > . and k;G {x : l}f mon j (. , x),with k,l x ./dom(G) then \nk\u00af;l\u00af; j; G {x : k} > {mon j (. ,x)/cx}. PROOF IDEA. By induction on the height of k\u00af; l\u00af; j;G > .. For \nthe .at contracts case we employ lemma 13. k,l LEMMA 13. If l;G f e, l; G {x : k}f mon j (. ,x),&#38;x \n./dom(G), k,l then l;G {x : k}f{lmon (. , x)ll /x}e j PROOF IDEA. First, we generalize the lemma s statement \nas fol\u00ad k,l lows: If l ;G f e, l;G {x : k}f mon j (. ,x),&#38; x ./dom(G),then k,l l ; G {x : k}f{lmon \nj (. ,x)ll /x}e We proceed by induction on the height of l ;G f e. \u00af\u00af\u00af LEMMA 14. If k;l\u00af; j; G > ., kand \nl\u00af . \u00afk ; l\u00af; j; G > .. k . \u00aflthen PROOF IDEA. By induction on the height of k\u00af; l\u00af; j;G > ..  4.3 Main \nTheorems When a program is well-formed, its monitors obviously satisfy the blame correctness criterion. \nTHEOREM 15. -.l and -.i are blame correct. PROOF. This theorem is a straightforward consequence of theo\u00adrem \n5. To wit, the subject reduction theorem says that a program satis.es the subject including when its \nredex is a monitor term con\u00adtaining a .at contract. From the proof of the subject reduction the\u00adorem, \nwe know that the subject implies k,ll\u00af l;\u00d8 f mon j (lflat(ec)J,lvlk) The label on the context is the \nsame as the client label by lemma 6 but we also need to know that the server label l is a member of the \ncontract s obligations l\u00af . This has to be the case given that the monitor term is well-formed. Note \nhow the proof is independent of the reduction semantics as long as it satis.es the subject reduction \nproperty. The picky contract system fails to satisfy an analogous theorem. THEOREM 16. There exists a \nprogram e such that lo f e and * k,l2 l\u00af e -.p El [mon j (lflat(e)J,lvll1 )] but k .= l1. PROOF. Here \nis one such program where k . = lo: .3 l = mon kl ,lo (.l ,l.h1.h1 .x.5 (.g.g 1)lk)(. f ..h2.h2 .x.6) \nThe restriction on the labels intuitively corresponds to the compo\u00adsition of the two different modules \nk and lo through the contract .l . Note that .3 is a family of programs, one per label l. This label \nl is the label of the contract monitor and, consequently, must be the owner of all embedded .at contracts. \nIn principle, l could be the label of the client, the server, or any other non-top-level (lo) label but \nin the end, our choice must obey subject reduction. While .3 performs no interesting computation, its \ncontract .l l plays a critical role. To explain the contract though, it is best to start with the type \nof h1: [(num . num) .{([num . num] . num) . num}] . num The type tells us that h1 consumes a complex \nhigher-order function and produces a number. Instead of plain numbers, however, we wish to deal with \npositive numbers only. We thus know that .l must have at least something like the following shape: [(P?l \n. P?l ) .{([P?l . P?l ] . P?l ) . P?l }] . P?l Next we add two dependencies: [(P?l . P?l ) d.(.g.P?l \n)) . P?l })] . P?l .(. f .{([P?l . P?l ] d The two key points to notice are: (1) in this contract, g \nis in the scope of f and (2) while f originates in the server (wrapped expression), g originates in the \nclient (context) and both .ow into the contract. Equipped with this informal and approximate understanding, \nwe can now turn to the actual contract: .l =((lP?l Jlo .(. f ..1 .lP?l Jk) dl )) .lP?l Jk .1 =((lP?l \nJk .lP?l Jlo ) dl )) .lP?l Jk .(.g..2 l .2 = lflat(l.x.zero?( f 1 -g 0)ll )Jk l P?l = flat(l.x.x > 0ll \n) Note how .2 invokes f on a positive number and g on 0. l  Nowweshowthat l must be set to lo in order \nto satisfy blame correctness. First, note that for for all l . L, lo f .3 l if k =.lo. Second, the reduction \nof .3 l eventually checks that 1 is greater than 0, i.e., that the post-condition contract .2 is satis.ed: \nl * lo ,k .3 l -.pE0l [monl (lP?l Jlo ,ll1ll ll )] In order for the picky system to satisfy the blame \ncorrectness con\u00addition, l must be equal to lo, which means the term looks like this: lo ,k E0 lo [mon \n(lP?lo Jlo ,ll1llo llo )] lo Unfortunately, the next few steps of the reduction process pro\u00adduces a state \nthat is inconsistent with blame correctness. Speci.\u00adcally, .2 also checks that g s pre-condition holds \nfor 0: l lo ,k * E0 lo [mon (lP?lo Jlo , ll1llo llo )] -.p lo E1 lo [mon klo ,lo (lP?lo Jlo ,ll0llo llo \n)] This last state, however, is inconsistent with the subject because k cannot equal lo. Indeed, the \nnext few reduction steps result in a failed check. The contract monitor blames k, which isn t the owner \nlo of the value. The picky system fails to assign blame properly. In essence the proof of the theorem \nshows that there is no correct strategy for associating (pieces of) contracts with components in a picky \nsemantics. No matter which labeling strategy we use, a contract violation may blame a component that \nhas no control over the faulty value.  5. Consigliere Our model introduces two concepts that are potentially \nuseful for practical programmers: obligations and ownership. According to our judgments for well-formed \ncontracts and expressions, a con\u00adtractual obligation is a static property of contract text. When con\u00adfronted \nwith complex contracts, a programmer may bene.t from displaying such information in the IDE. In contrast, \nownership in\u00adformation is a dynamically evolving property, and it is particularly useful in a debugger \nfor determining the creator and current owner of values as they .ow from one component to another. To \ntest the practicality of displaying obligation information, we have implemented a tool that analyzes \nmodules and contracts and annotates them with obligation information. The tool is a plug-in for DrRacket \n(Findler et al. 2002), our IDE for the Racket program\u00adming language. In this section, we refer to the \ntool as consigliere, though in DrRacket, it is simply a part of the CheckSyntax tool. The consigliere \ntool operates on Racket modules in two differ\u00adent modes. In server mode, consigliere analyzes the module \nfrom the perspective of the supplier of services. It retrieves all the con\u00adtracts that are attached to \nexported identi.ers and uses red to tag the server s obligations;  green to highlight the server s \nassumptions, i.e., the parts of the contract that the other party is responsible for; and  yellow to \nsignal that a part of the contract is both an assumption and an obligation.  In client mode, consigliere \nanalyzes the module from the per\u00adspective of a consumer of services. Once it has the results, it pro\u00adceeds \nas in server mode except that it uses red for the client s obli\u00adgations and green for the client s assumptions. \nFor a simple example, consider the module in .gure 10. The module provide/contract speci.cation lists \none exported func\u00adtion, pick-one. According to its contract, the function consumes a non-empty list of \nnumbers and returns an number. A code inspec\u00adtion shows that the function actually returns a random element \nof the given list. The top of .gure 10 shows the result of using the tool in client mode. As expected, \nthe non-empty list part of the contract is colored in red, because any user of pick-one is required to \nuse a non-empty list of numbers as an argument. Also, because the client may assume that pick-one is \na function and not some arbitrary value, consigliere colors the -> contract constructor with green. The \nreverse reasoning explains the coloring of the lower part of .gure 10, which shows the result of using \nconsigliere in server mode. For a second example, consider a deriv function with the con\u00adtract from section \n1. Its contract is signi.cantly more complex than pick-one, because it comes with two higher-order components \nand a post-condition. Note that this contract uses the ->i contract com\u00adbinator, turning the contract \nprovider into a party with obligations and assumptions. Here the contract provider is the server module, \nmeaning ->i is interpreted using the +indy semantics. Practically speaking, the obligations and assumptions \nof the server also include the obligations and assumptions of the contract provider. The top screenshot \nof .gure 11 shows the result of using the tool in client mode. The color assignment roughly follows the \nsame contravariant traversal of pattern as the contract in .gure 10. When it comes to the #:post-cond \ncode, however, the color of the keyword indicates that the post-condition is an assumption for the client \njust like the other post-condition of the contract. The lower screenshot depicts the server s obligations \nand as\u00adsumptions, which are more interesting than the client s. The dif\u00adference is due to the server \ns dual role as both a service provider and as the owner of the contract. Recall that the contract provider \nis responsible for meeting the pre-conditions of f and fp in the post-condition, while the server may \nassume that f and fp meet their post-conditions. As a result, the colors used for f from the server s \nperspective coincide with those used in the client mode. For fp, however, both parts are colored yellow \nbecause the obli\u00adgation of the server is the contract provider s assumption and vice versa. Since the \nserver is both the server and the contract provider party in this case, the user must be ready to treat \nthe pre-condition and post-condition of fp either as an assumption or as an obligation depending on the \nuse.   6. Related Work Provenance is the book-keeping of origin, context and history infor\u00admation \nof data. It plays an important role for the correct and secure behavior of large software and hardware \nsystems (Simmhan et al. 2005; Bose and Frew 2005). The study of provenance from a for\u00admal linguistic \nperspective is still at an initial stage (Cheney et al. 2009). Our notion of ownership is a means of \nkeeping around some origin and context information about program values. So it can be viewed as a form \nof provenance. Also ownership can be used as a basis for studying formal properties of this kind of provenance. \nHowever our technique and its use to prove properties of contract systems is not related to any provenance \ntracking technology. Tracking information .ow in a computer system is a specialized kind of provenance. \nSecure information .ow as pioneered by Den\u00adning (1976) is the restriction of .ow of data in a computer \nsystem only between agents that have the appropriate level of clearance. There are both software and \nhardware techniques for imposing se\u00adcure information .ow. Our instrumentation of the dynamic seman\u00adtics \nresembles techniques used for proving sound type systems that enforce secure information .ow. Zdancewic \net al. (1999) introduce (program) principals as a means to prove type abstraction properties related \nto information .ow with a syntactic proof technique. In a principal semantics, dif\u00adferent principals \nown different components and exported values carry the principal of their component of origin. Since \nthe prin\u00adcipals semantics prevents reductions that involve values with dif\u00adferent principals, a client \ncomponent is obliged to use a server s functions on the server s values. In short, the semantics dynami\u00adcally \nenforces a form of information hiding. It is now easy to see how a principals semantics supports a syntactic \nsoundness proof for abstract types. If the interface between the server component and the client employs \nabstract types and if the type system soundly enforces type abstraction, stuck states become unreachable \nduring computation. Although both principals and ownership annotations point to the source of values \nand functions, the principal semantics differs sub\u00adstantially from our ownership semantics. Most importantly, \nprin\u00adcipals may change the evaluation of a program; ownership does not. When a function from one server \nis applied to a value from a client or a different server, the principal semantics is stuck. In con\u00adtrast, \nownership annotations are simply propagated in our reduction rules; they do not affect computation. Ownership \ninformation is in\u00adstead used to formulate a criteria for determining the correctness of blame assignment. \nWe can imagine using an ownership semantics to formulate syntactic soundness proofs for type abstraction, \nwhile we do not see any advantages over the principals semantics for this application. As explained in \nthe introduction, Greenberg et al. (2010) study the full relationship between lax and picky contract \nsystems on one hand and manifest contract systems on the other. For the latter, the type system propagates \nsome of the contract constraints. While Gronski and Flanagan (2007) established a tight relationship \nfor a world without dependent contracts, Greenberg et al. (2010) demon\u00adstrate that the full picture is \nrather complex. In particular, they show that as far as contract violations are concerned, manifest contracts \nsit strictly between lax contracts and picky contracts. In general, this work extends our decade-old \nlinguistic investi\u00adgation of behavioral software contracts. Meyer (1988, 1991, 1992) introduced software \ncontracts via the design of the Eiffel program\u00adming language and the creation of a contract-oriented \nsoftware en\u00adgineering curriculum. Since then contracts have been used both for extended static checking \n(Detlefs et al. 1998; Barnett et al. 2004) and runtime monitoring of higher-order programs (Findler and \nFelleisen 2002). Blume and McAllester (2006) introduce picky contract monitoring and explore a quotient \nmodel for higher-order contracts and use it to prove properties of Findler and Felleisen s higher-order \ncontracts. Findler et al. (2004; 2006) propose an al\u00adternative view, namely, contracts as projections, \nwhich relates contracts to Scott (1976) s denotation model of types. Gronski and Flanagan (2007) relate \nFindler and Felleisen s higher-order con\u00adtract to type casts. Their result motivates a type-oriented \nform of extended static checking (Knowles et al. 2006), which Greenberg et al. consider a manifest form \nof contract. Xu et al. (2009) use Blume and McAllester s ideas to develop static contract checking for \nHaskell using symbolic evaluation. Hinze et al. (2006) and Chi\u00adtil et al. (2003) both introduce contracts \nto Haskell but end up with two different contract systems. The .rst performs eager contract checking \nwhile the second is lazy. Degen et al. (2010) compare ea\u00adger and lazy contract checking for lazy languages \nthrough a series of formal properties but do not reach a de.nite conclusion. Finally, in the context \nof JML (Leavens et al. 1999), Rudich et al. (2008) develop a method for proving the well-formedness of \npure-method speci.cations and they discuss how their technique can bene.t from automated theorem proving. \nThe goal of this line of research is signi.cantly different than ours. It concerns extrac\u00adtion of proof \nobligations for the veri.cation of JML contracts in\u00adternal consistency. Unfortunately, JML contracts \ncapture only .rst\u00adorder properties, and it is unclear if their technique is applicable in a higher-order \nworld. Furthermore, their static semantics lacks a formalization of the contract parties which plays \nan important role in our work.  7. Conclusion This paper introduces a new semantics for dependent contracts \nin response to Greenberg et al. (2010) s comparison of two alterna\u00adtives. Our work acknowledges the motivation \nbehind the picky con\u00adtract system and turns the lax system into a choice for the con.dent programmer. \nLike the picky system, the new indy system protects arguments and results inside dependency assertions. \nIn contrast to the picky system, each contract is treated as an independent party with its own obligations \nto meet.  Most importantly, we introduce a semantics that tracks value ownership and contract obligations, \nand we formulate the .rst ever correctness criterion for blame assignment. Our major theorems show that \nthe indy system guarantees that contract monitors blame only components that are in control while the \npicky system fails to satisfy this intuitive correctness property for blame assignment. Our results suggest \nseveral changes to the implementation of contracts in Racket. First, even though the lax semantics is \nblame correct, we now support the indy semantics for dependent contracts to ensure that only guilty parties \nare blamed. Second, by instantiat\u00ading the contract party, we obtain .avors of an indy semantics that \nsupport the entire variety of Racket contracts in use: server-side contracts, client-side contracts, \nand contracts for ML-like modules where signatures have an independent existence.Third, the notion of \nwell-formed contractual obligations is the basis of a DrRacket tool that can remind module programmers \nof their obligations and assumptions in complex, higher-order contracts.  Acknowledgments Thanks to \nMatthew Flatt for suggesting how to exploit Racket s macro system to implement consigliere. We appreciate \nfruitful discussions with Riccardo Pucella, Sam Tobin-Hochstadt, Stevie Strickland and Carl Eastlund. \nWe are grateful to the anonymous reviewers of POPL 2011 for their useful feedback.  References H. P. \nBarendregt. The Lambda Calculus Its Syntax and Semantics, volume 103 of Studies in Logic and the Foundations \nof Mathematics.North-Holland, 1984. M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# programming \nsystem: an overview. In Construction and Analysis of Safe, Secure and Interoperable Smart Devices, pages \n49 69, 2004. A. Beugnard, J.-M. J\u00b4equel, N. Plouzeau, and D. Watkins. Making com\u00ad ez\u00b4ponents contract \naware. IEEE Computer, 32(7):38 45, July 1999. M. Blume and D. McAllester. Sound and complete models of \ncontracts. Journal of Functional Programming, 16(4-5):375 414, 2006. R. Bose and J. Frew. Lineage retrieval \nfor scienti.c data processing: a survey. ACM Computing Survey, 37(1):1 28, 2005. J. Cheney, S. Chong, \nN. Foster, M. Seltzer, and S. Vansummeren. Prove\u00adnance: a future history. In Proceeding of the 24th ACM \nSIGPLAN Conference Companion on Object Oriented Programming Systems Lan\u00adguages and Applications: Onward! \nSession (OOPSLA Onward!), pages 957 964, 2009. O. Chitil, D. McNeill, and C. Runciman. Lazy assertions. \nIn Revised Papers of the 15th International Workshop on Implementation of Functional Languages (IFL), \npages 1 19, 2003. M. Degen, P. Thiemann, and S. Wehr. Eager and delayed contract monitor\u00ading for call-by-value \nand call-by-name evaluation. Journal of Logic and Algebraic Programming, page to appear, 2010. D. E. \nDenning. A lattice model of secure information .ow. Communications of the ACM, 19(5):236 243, 1976. D. \nL. Detlefs, K. R. M. Leino, G. Nelson, and J. B. Saxe. Extended static checking. Technical Report 158, \nCompaq SRC Research Report, 1998. C. Dimoulas and M. Felleisen. On contract satisfaction in a higher-order \nworld. ACM Transactions on Programming Languages and Systems. accepted (with revisions) for publication. \nM. Felleisen, R. B. Findler, and M. Flatt. Semantics Engineering with PLT Redex. MIT Press, 2009. R. \nB. Findler and M. Blume. Contracts as pairs of projections. In Pro\u00adceedings of the 8th International \nSymposium on Functional and Logic Programming (FLOPS), pages 226 241, 2006. R. B. Findler and M. Felleisen. \nContracts for higher-order functions. In Proceedings of the 7th ACM SIGPLAN International Conference \non Functional Programming (ICFP), pages 48 59, 2002. R. B. Findler, J. Clements, C. Flanagan, M. Flatt, \nS. Krishnamurthi, P. Steckler, and M. Felleisen. DrScheme: A programming environment for Scheme. J. Funct. \nProgram., 12(2):159 182, Mar. 2002. R. B. Findler, M. Felleisen, and M. Blume. An investigation of contracts \nas projections. Technical Report TR-2004-02, University of Chicago, Computer Science Department, 2004. \nC. Flanagan. Hybrid type checking. In Proceedings of the 33th An\u00adnual ACM SIGPLAN-SIGACT Symposium on \nPrinciples of Program\u00adming Languages (POPL), pages 245 256, 2006. M. Flatt and PLT. Reference: Racket. \nTechnical Report PLT-TR-2010-1, PLT Inc., 2010. http://racket-lang.org/tr1/. M. Greenberg, B. C. Pierce, \nand S. Weirich. Contracts made manifest. In Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium \non Programming Languages (POPL), pages 353 364, 2010. J. Gronski and C. Flanagan. Unifying hybrid types \nand contracts. In Pro\u00adceedings of the 8th Symposium on Trends in Functional Programming (TFP), pages \n54 69, 2007. R. Hinze, J. Jeuring, and A. L\u00a8oh. Typed contracts for functional program\u00adming. In In Proceedings \nof the 8th International Symposium on Func\u00adtional and Logic Programming (FLOPS), pages 208 235, 2006. \nK. Knowles, A. Tomb, J. Gronski, S. N. Freund, and C. Flanagan. Sage: Uni.ed hybrid checking for .rst-class \ntypes, general re.nement types, and dynamic, 2006. URL http://sage.soe.ucsc.edu/. G. T. Leavens, A. L. \nBaker, and C. Ruby. JML: A notation for detailed design. In H. Kilov, B. Rumpe, and I. Simmonids, editors, \nBehavioral Speci.cations of Businesses and Systems, pages 175 188. Kluwer Aca\u00addemic Publishers, 1999. \nB. Meyer. Design by contract. In Advances in Object-Oriented Software Engineering, pages 1 50. Prentice \nHall, 1991. B. Meyer. Eiffel: The Language. Prentice Hall, 1992. B. Meyer. Object-oriented Software Construction. \nPrentice Hall, 1988. G. D. Plotkin. Call-by-name, call-by-value, and the .-calculus. Theoretical Computer \nScience, 1(2):125 159, 1975. G. D. Plotkin. LCF considered as a programming language. Theoretical Computer \nScience, 5(3):223 255, 1977. A. Rudich, A. Darvas, and P. M\u00a8uller. Checking well-formedness of pure\u00admethod \nspeci.cations. In Proceedings of the 15th International Sympo\u00adsium on Formal Methods (FM), pages 68 83, \n2008. D. S. Scott. Data types as lattices. SIAM Journal of Computing, 5(3):522 587, 1976. Y. L. Simmhan, \nB. Plale, and D. Gannon. A survey of data provenance in e-science. ACM SIGMOD Record, 34(3):31 36, 2005. \nT. S. Strickland and M. Felleisen. Contracts for .rst-class modules. In Proceedings of the 5th Symposium \non Dynamic Languages (DLS), pages 27 38. ACM, 2009. S. Tobin-Hochstadt and M. Felleisen. Logical types \nfor untyped languages. In Proceedings of the 15th ACM SIGPLAN Internation Conference on Functional Programming \n(ICFP), pages 117 128, 2010. S. Tobin-Hochstadt and M. Felleisen. The design and implementation of Typed \nScheme. In Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on the Pronciples of Programming \nLanguages (POPL), pages 395 407, 2008. D. Xu, S. Peyton Jones, and K. Claessen. Static contract checking \nfor Haskell. In Proceedings of the 36th Annual ACM SIGPLAN-SIGACT Symposium on Programming Languages \n(POPL), pages 41 52, 2009. S. Zdancewic, D. Grossman, and G. Morrisett. Principals in programming languages: \nA syntactic proof technique. In Proceedings of the 4th ACM SIGPLAN International Conference on Functional \nProgramming (ICFP), pages 197 207, 1999.   \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Behavioral software contracts supplement interface information with logical assertions. A rigorous enforcement of contracts provides useful feedback to developers if it signals contract violations as soon as they occur and if it assigns blame to violators with preciseexplanations. Correct blame assignment gets programmers started with the debugging process and can significantly decrease the time needed to discover and fix bugs.</p> <p>Sadly the literature on contracts lacks a framework for making statements about the correctness of blame assignment and for validating such statements. This paper fills the gap and uses the framework to demonstrate how one of the proposed semantics for higher-order contracts satisfies this criteria and another semantics occasionally assigns blame to the wrong module.</p> <p>Concretely, the paper applies the framework to the <i>lax</i> enforcement of dependent higher-order contracts and the <i>picky</i> one. A higher-order dependent contract specifies constraints for the domain and range of higher-order functions and also relates arguments and results in auxiliary assertions. The picky semantics ensures that the use of arguments in the auxiliary assertion satisfies the domain contracts and the lax one does not. While the picky semantics discovers more contract violations than the lax one, it occasionally blames the wrong module. Hence the paper also introduces a third semantics, dubbed <i>indy</i>, which fixes the problems of the picky semantics without giving up its advantages.</p>", "authors": [{"name": "Christos Dimoulas", "author_profile_id": "81413601733", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2509603", "email_address": "chrdimo@ccs.neu.edu", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "Northwestern University, Evanston, IL, USA", "person_id": "P2509604", "email_address": "robby@eecs.northwestern.edu", "orcid_id": ""}, {"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "University of California, Santa Cruz, Santa Cruz, CA, USA", "person_id": "P2509605", "email_address": "cormac@ucsc.edu", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2509606", "email_address": "matthias@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926410", "year": "2011", "article_id": "1926410", "conference": "POPL", "title": "Correct blame for contracts: no more scapegoating", "url": "http://dl.acm.org/citation.cfm?id=1926410"}