{"article_publication_date": "01-26-2011", "fulltext": "\n Dynamic Multirole Session Types Pierre-Malo Deni\u00b4elou Nobuko Yoshida Imperial College London Abstract \nMultiparty session types enforce structured safe communications between several participants, as long \nas their number is .xed when the session starts. In order to handle common distributed interaction patterns \nsuch as peer-to-peer protocols or cloud algorithms, we pro\u00adpose a new role-based multiparty session type \ntheory where roles are de.ned as classes of local behaviours that an arbitrary number of participants \ncan dynamically join and leave. We offer program\u00admers a polling operation that gives access to the current \nset of a role s participants in order to fork processes. Our type system with universal types for polling \ncan handle this dynamism and retain type safety. A multiparty locking mechanism is introduced to pro\u00advide \ncommunication safety, but also to ensure a stronger progress property for joining participants that has \nnever been guaranteed in previous systems. Finally, we present some implementation mech\u00adanisms used in \nour prototype extension of ML. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal \nDe.nitions and Theory; F.3.2 [Semantics of Pro\u00adgramming Languages]: Process models General Terms Theory, \nTypes, Design Keywords communications, roles, multiparty, session types, mo\u00adbile processes, dynamic protocols, \njoin-leave, peer-to-peer, auction. 1. Introduction As a type foundation for structured distributed, communication\u00adcentred \nprogramming, session types [18, 31] have been studied over the last decade for a wide range of process \ncalculi and pro\u00adgramming languages. The original binary theory has been gener\u00adalised to multiparty session \ntypes [19] in order to guarantee stronger conformance to stipulated session structures between cooperating \nmultiple end-point participants. Since the .rst work [19] was pro\u00adposed, the multiparty session type \ntheory has been developed in process calculi [4, 10, 14, 22], and used in several different con\u00adtexts \nsuch as distributed object communication optimisations [29], security [5, 9], design by contract [6], \nparallel and web service pro\u00adgramming [25, 35, 36] and medical guidelines [23], some of which initiated \nindustrial collaborations (see \u00a7 6 and 7). While many inter\u00adaction patterns can be captured in the existing \nmultiparty sessions framework, there are signi.cant limitations for describing and val\u00adidating loosely-coupled, \nungoverned, dynamic protocols, since the number of participants is required to be .xed both when the \nsession is designed and when the session execution starts. This makes it un\u00adable to express interaction \npatterns frequently found in messaging oriented middleware and service-oriented computing. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 11, January \n26 28, 2011, Austin, Texas, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 \nThe central underpinning of multiparty session types is that crit\u00adical properties, such as communication \nsafety (essentially a corre\u00adspondence between send and receive) and deadlock-freedom, are guaranteed \nby the combination of two means: .rst, a static type\u00adchecking methodology based on the existence of a \nglobal type (a description of a multiparty protocol from a global viewpoint) and of its end-point projections \n the global type is projected to end-point types against which processes can be ef.ciently type-checked; \nsec\u00adond, a synchronisation mechanism which ensures that all the well\u00adbehaved (i.e. well-typed) participants \nare actually present when the session starts. This paper introduces a new role-based multiparty type \nsystem and synchronisation mechanism that, together, can specify, verify and govern dynamically evolving \nprotocols. In the rest of this section, we illustrate our motivation, ap\u00adproach and solutions through \nprotocols of increasing complexity: (1) Map/Reduce (introduction of the notion of roles and universal \nquanti.cation); (2) P2P chat (projection challenges) and (3) Auc\u00adtion (branching and communication safety). \n (1) Map/Reduce We imagine a server that wants a task to be computed on a cluster made of three cluster \nclients: the server sends them jobs and they give back their answers. We give a picture il\u00adlustrating \nthis communication pattern and the corresponding global multiparty session type written in the original \ntheory [19].  Gorg =\u00b5x.(server.client1(Map); Map client1 RRReduce server.client2(Map); RR server.client3(Map);serverserver \nclient2  RRRR client1.server(Reduce);  client2.server(Reduce); client3.server(Reduce));x client3  \nThis session starts with the server sending asynchronously the messages Map to participants client1, \nclient2 and client3. Each of them answers back with a message Reduce.1 Recursion \u00b5x denotes an unbounded \nnumber of repeated interactions. The problem here is that such a session cannot start without one of \nthe clients and, once running, is not able to handle a fourth client joining or one of the current clients \nleaving. In the original multiparty sessions, any of these scenarios requires ending the session, writing \nan appropriate global type for the new situation, and starting a fresh session again. This paper proposes \na theory of dynamic multirole session types that can describe global interactions between roles, which \nare classes of participants that share a common behaviour (e.g. the clients in the above example). Dynamism \nis disciplined by a simple universally quanti.ed type that allows to spawn further interactions by polling \nthe set of participants currently playing a given role. In the above session, we notice that the three \nclients have the exact same behaviour (receiving a Map message and sending a Reduce message). We call \nthis behaviour the client role and now expect a varying number of participants to inhabit it. On the \nother hand, the server role is as usual instantiated by exactly one partici\u00adpant and the session does \nnot start without its presence. The follow\u00ad 1 Since the previous multiparty session types [4, 19] do \nnot support explicit parallelism, we rely on asynchrony to express the desired behaviour.  ing picture \nillustrates this dynamic protocol. Its global type features the new universal type. G =\u00b5x..x:client.{server.x(Map); \nclient x.server(Reduce)}; x  MapReduce   The repeated interaction in the glo\u00ad .server server .  bal \ntype G involves a Map mes\u00ad . sage to be sent by the server to ev\u00adclient  ery participants x of the \nclient role; the server then expects a message Reduce in answer. At the type level, such an operation \nis speci.ed using a universal quanti.cation: .x : r.G' polls the current participants p1,...,pn of role \nr and, in parallel processes, binds x to each in the subsequent interaction, as in G'{p1/x}| ... | G'{pn/x} \nIn our example, G' = server.x(Map); x.server(Reduce) is exe\u00adcuted in parallel for each client x. Then, \nthe recursion variable x points the interaction back to its beginning. Local types Since the implementation, \nwritten here in a variant of the p-calculus, is distributed, the typing system .rst projects the global \ntype to each end-point (local) type. For each role, the projec\u00adtion algorithm computes a local type that \ndescribes the behaviour of any participant that wants to play it. The local types for this session are \nthe following: Tclient = \u00b5x.?(server,Map);! (server,Reduce); x Tserver = \u00b5x..x:client.{! (x,Map);?(x,Reduce)}; \nx First, the client behaviour Tclient is straightforward as it is only involved in two messages at each \niteration with the server. The local type of the client expresses that it expects a message Map from \nthe server (?(server, Map)) and that it sends a message Reduce as an answer (!(server,Reduce)). The server \nrole is involved in all the messages of this session. We note the presence of the quanti.cation over \nall x playing the client role. Processes We write some process examples that would be well typed against \nthe local types. The session identi.er s denotes an active session: Pclient(z)=a[z:client](s).\u00b5X.s?(server, \nMap);s!(server,Reduce);X Pserver(z)=a[z:client](s).\u00b5X.s.(x :client).{s!(x,Map); s?(x,Reduce)}; X A session \nstarts through the join operation (a[z : client](s)) which gets the session name s of a running session \nadvertised on a.A participant z playing the client with Pclient(z) is simply exchang\u00ading messages Map \nand Reduce with the server through sending (s!) and receiving (s?) operations. The server needs to fork \nsub\u00adprocesses for its interactions with each client. To this effect, the polling operation s.(x :client).{s! \n(x,Map); s?(x,Reduce)} creates as many processes s! (x,Map); s?(x,Reduce) as there are partici\u00adpants \nx playing the client role. Note that late joining client partici\u00adpants are incorporated in the session \nat each iteration: the repetition of the polling operation s.(x :client) is able to ensure a safe inter\u00adaction \nbetween all parties. (2) Peer-to-peer chat In this session, there is only one role, the client, whose \nbehaviour is to always broadcast its messages to all the other clients. We give the global type and a \nrepresentation of the interaction when four clients are present. G =\u00b5x.(.x :client..y:client \\ x.{x.y \nMsg(string)});x This type features a double quanti.cation clientclient Msg which speci.es that each \npair of clients x,y Msg    Msg will interact in the form of a unique Msg.  Msg  The explicit exclusion \nof x from the list of clientclient clients y prevents self-sent messages. This second example shows the \nprojection dif.culties that arise from quanti.cation. Local types To illustrate the projection of nested \nquanti.ers, we .rst rely on our intuition: each client should send a message Msg to every other client \nand, concurrently, should expect a message Msg from each of them. Tclient(z)= \u00b5x.(.y :client \\ z.{! (y:client,Msg(string))} \n| .x :client \\ z.{?(x :client,Msg(string))});x Let us examine how the projection algorithm gives this \nlocal type. Suppose we project for a generic client z. The .rst quanti.er .x : client of the global type \nnecessarily involves z, meaning that among these parallel processes there is exactly one where x is z. \nIn the other parallel processes, although x is not z, z can still be involved. The projection of the \nsecond nested quanti.er .y : client \\ x works in the same way. This is why the .rst parallel part is \n.y : client \\ z.{!(y:client,Msg(string))}, which explicitly excludes the possible 2 !(z,Msg(string)). \nProcess Once the local types are known, the client processes have a similar structure, including the \nexplicit polling operator, written s.(y :client \\ z). Pclient(z)= a[z :client](s).\u00b5X.(s.(y:client \\ \nz).{s! (y,Msg(m))} | s.(x:client \\ z).{s?(x,Msg(w))});X (3) Auction We now illustrate the expressiveness \nof our universal types when combined with instantiation of participant identities and branching session. \nIn this session, we have three roles: the multiple buyers (here participants alice, alex, alan) and sellers \n(here bob, ben) which all connect to a single broker. This broker will then form matching pairs (x, y) \nof buyers and sellers who will then continue their interaction Price-Order separately. Notify alice \n Match(bob) Stop Quit(ben)  Stop  Quit(bob)  alex broker  Match(ben) Stop Quit(bob)   Notify \n Quit(ben) bob  Price alice Order bob  alan ben Price alex Order ben  Stop G = .x :buyer..y : seller. \nbroker.x{Match(y).x.y(Notify).y.x(Price).x.y(Order), Quit(y). x.y (Stop)};end The quanti.cations .x : \nbuyer..y : seller specify that every possible association between buyers and sellers is considered by \nthe broker when he makes his choices. For each pair (x,y) of buyer and seller, the broker selects to \nsend to x either a message Match(y) if he has found y to be a match for x, or a message Quit(y) otherwise. \nIf the message Match was sent, x noti.es y and the interaction Price-Order proceeds. In the other branch, \nx needs to warn y by the message Stop that the broker chose the second branch. For this example, we just \nwrite a process for a buyer: Pbuyer(z)=a[z :buyer](s).s.(y:seller).{s?(broker, {Match(y).s!(y, Notify).s?(y,Price).s!(y, \nOrder), Quit(y).s!(y, Stop)})};quit(s) From the above process, we can see the importance of the com\u00admunication \nof the participant identity y with the messages Match and Quit. The adjunction of y to the messages is \nnecessary for x to know to which y to send the Notify message. Note that the y in Match(y) is not a regular \npayload as all the sellers y are already known by x: at reception, x matches his known y against the \none coming along Match or Quit. This example presents a non-recursive session where all partici\u00adpants \nleave the session (through the expression quit(s)) at the end of their interaction. Since late joiners \nalways start at the beginning of the session, they cannot safely interact with the participants that \nhave already proceeded. To guarantee progress, we require that late 2 If we want our global type to include \nthose self-sent message, it can be done explicitly by writing a global type: \u00b5x.(.x :client.(x.x Msg(string)| \n.y :client.x.yMsg(string)); x.  joiners wait for the current participants to end before joining them\u00adselves \nand beginning their actions. To provide consistent synchro\u00adnisation, we introduce a multiparty locking \nmechanism to protect the global session executions. Main contributions (\u00a7 2) A new role-based multiparty \nsession type framework where participants can play several roles in a session. Its semantics allows participants \nto dynamically join and leave a running session, and create new parallel sessions. (\u00a7 3, \u00a7 4) Introduction \nof a universal type for polling participants, along with explicit parallel compositions, and a type system \nthat provides subject reduction (Theorem 4.2) and type safety (Corollary 4.3: no type error for values \nand labels). The end\u00adpoint projection and the well-formedness conditions of global types deal with the \nsubtle interplay between universal quanti\u00ad.ers, parallel compositions, branching and instantiations of \npar\u00adticipant identities. (\u00a7 5) A semantics and type system with a simple locking mecha\u00adnism by which \ncommunication safety (Theorem 5.4: every re\u00adceiver has a corresponding sender with the right type), progress \n(Theorem 5.6: processes in a single multiparty session always progress) and join progress (Theorem 5.8: \nlate joiners can al\u00adways join to an existing session and progress) are established. (\u00a7 5.5) Practical \nimplementation techniques used in our prototype extension of ML. The proofs, detailed de.nitions, additional \nexamples and the proto\u00adtype implementation are available from [3]. 2. Multirole session calculus We describe \nhere an extension of the multiparty session calculus presented in [4]. Our new system handles roles and \nallows pro\u00adgrams to participate in protocols that include multiple parallel in\u00adteractions and dynamic \nrole instantiation. u ::= x | a | b | ... Shared channel p ::= p :r | x : r Participant with role p ::= \np ::p | x ::p | e Participant list c ::= s[p] | y Session channel e ::= v | x | e . e | ... Expression \nv ::= a | s[p :r] | true | ... Values P ::= Processes | u(G) Session initialisation | u[p](y).P | quit(c) \nJoin, Quit | c!(p,l(p )(e)) Send | c?(p,{li(p i)(xi).Pi}i.I ) Receive | c.(x :r \\p ).{P} Poll | P | P \n| P;P Parallel, Sequential | if e then P else P Conditional | \u00b5X.P | X Recursion, Variable | 0 | (. a:G)P \nNull, Restriction | (. s)P | s:h Session restriction, Buffer | a(s)[R] Registry R ::= r1:P1,...,rn :Pn \nRole set h ::= e | h \u00b7 (p0:r0,p1:r1,l(pp)(v)) Buffer Figure 1. Multirole session calculus Syntax We give \nin Figure 1 the syntax of the processes of our session variant of the p-calculus. A session is always \ninitialised by a process of the form u(G)where G is a global type (formally de.ned in \u00a7 3). Session initiali\u00adsation \nattributes a particular global interaction pattern G to a shared channel u. Once the session has been \ninitialised on channel u, par\u00adticipants can join with u[p](y).P where p designates a participant identity \np or x associated with a particular role name r. Joining binds the variable y with the session channel \nthat this particular participant can use when he plays the role r. Leaving the session is done by quit(c), \nwhere c is the session channel corresponding to the participant and role. The asynchronous emission c! \n(p, l(p )(e)) allows to send to p a value e labelled by a constant l and participant names p . The reception \nc?(p, {li(p i)(xi).Pi}i.I ) expects from p a message with a label among the {li}i.I with participants \np i. The message payload is then received in variable xi, which binds in Pi. Messages are always labelled. \nThe list of participants p i enriches the label li in order for the receiver to be able to disambiguate \nmessages that have the same sender and label, but different continuations. The polling operation c.(x \n:r \\p ).{P} is the main way to inter\u00adact with the participants that instantiate a given role: P is replicated \nfor each participant x playing role r, with the exception of the par\u00adticipants mentioned in p . Parallel \nand sequential composition are standard, as are the conditional and recursion. The creation of a shared \nrendez-vous name is done by (. a : G)P. This fresh name can then be used as a reference for future instances \nof a session speci.ed by G. Once a session is running, our semantics uses some artifacts that are not \ndirectly accessible to the programmer. First, session instances are represented by session restriction \n(. s)P. Second, the message buffer s : h stores the messages in transit for the session s. Last, the \nsession registry a(s)[R] records the current association between participants and roles in the running \nsession s. For simplicity, we write c?(p,l(p )(xi)).P if there is a unique branch. Similarly, we omit \nthe empty list of participant ((e)) and unit payloads (e.g. c! (p, l)). We also do not write 0, and roles \nr (e.g. in x :r) if they are clear from the context. We use syntactic sugar for the special roles that \ncannot be multiply instantiated. Polling is done implicitly for these roles. Their participants names \n(p or x) do not have to be explicitly mentioned: the mention of the role r is suf.cient and unambiguous. \nIn the Map/Reduce example from \u00a7 1, server is such a role. We call a process which does not contain free \nvariables and runtime syntax initial. Semantics Figure 2 lists the reduction rules. The lINITJ rule pro\u00adceeds \nto a session initialisation by reducing a(G). It creates a fresh session channel s and two processes. \nFirst, the session registry a(s)[R] is an entity that centralises the association between partic\u00adipants \nand roles in the particular instance s of a session. Initially, R does not record any participant for \nany of the roles of G. The second process is the session s message buffer s : e, which is also initially \nempty. The rule lJOINJ governs the registration of a participant to a running session. The participant \nasks with a[p : r](y).P to join the session advertised on channel a and speci.es his identity p and which \nrole r he wants to play. This information is added to the session registry a(s)[R \u00b7 r : P {p}] and the \nsession channel s[p :r] is communicated. The rule lQUITJ manages the departure of a participant from \na session: quit(s[p :r]) forces the deletion of p : r from the registry. The rule lSENDJ describes asynchronous \nsending, which ap\u00adpends its labelled message to the buffer s : h. In rule lRECVJ, the ' reception takes \nfrom the session buffer the .rst message (p ' :r , p : r, lk(p k)(v)) that has a proper address, label \nand participant list and selects the matching continuation Pk. The rule lPOLLJ details the reduction \nof the polling process s[p : r '].(x : r \\pp).{P}. The set  a(G)-(.ri .G,R(ri)= \u00d8) lINITJ . (. s)(a(s)[R] \n| s : e) a[p : r](y).P | a(s)[R \u00b7 r : P] -r :P {p}] lJOINJ . P{s[p :r]/y}| a(s)[R \u00b7 quit(s[p :r])| a(s)[R \n\u00b7 r : P] -r :P \\ p] . a(s)[R \u00b7lQUITJ ''  s[p : r]!(p ' :r ,l(p )(v)) | a(s)[R] | s:h -\u00b7' :r , l(p )(v))(p \n.R(r) . p '.R(r ')) lSENDJ . a(s)[R] | s :h (p :r, p '' s[p : r]?(p ' :r ,{li(p i)(xi).Pi}i.I )| a(s)[R] \n| s : (p ' :r , p : r, lk(p k)(v)) \u00b7. Pk{v/xk}| a(s)[R] | s:h h -(p .R(r) . k .I) lRECVJ s[p :r '].(x \n:r \\p ).{P}| a(s)[R] -(R(r) \\p = {p1,..,pk}. p .R(r ')) lPOLLJ . P{p1/x}| ... | P{pk/x}| a(s)[R] if true \nthen P else Q -. P lIFTJ. Q if false then P else Q -lIFFJ P | Q -. E [P] | Q -lPARJ P -. E [P'] lCTXTJ \nP = P'-. P -lCONGJ . P'| Q' =. E [P'] | Q'. P' =. E [P] -. Q'= Q =. Q ' E ::= [] | E | P | E ; P | (. \na)E | (. s)E | s[p : r]!(p ' :r ,l(p )(E )) | if E then P else P | E . e | v . E | ... Figure 2. Reduction \nrules for the multirole session calculus of participants {p1,...,pk} that play role r (once the ones \nin p are removed) is received from the session registry and the process P is forked accordingly, with \nx appropriately substituted. In lPARJ, bound names in E and free names in Q are disjoint. The reduction \nis de.ned modulo the standard structural equiv\u00adalence =. We just mention here the session garbage collection \nrule (. a : G, s)(a(s)[R] | s : e) = 0 (when .ri . G, R(ri)= \u00d8) and '' the permutation rule s : (q, p,l(p \n1)(v)) \u00b7 (q , p , l'(p 2)(v ')) \u00b7 h = s : ''(q , p , l'(p 2)(v ')) \u00b7 (q, p,l(p 1)(v)) \u00b7 h which allows \nto put forward in the session buffers the messages that have different senders, re\u00adcipients, labels or \nparticipants lists. Others are standard. Reduction example We take the process Pclient(z) from the peer\u00adto-peer \nchat mentioned in the introduction (\u00a7 1(2)). Figure 3 gives reduction steps of a situation where we have \ntwo client processes Pclient(p1) and Pclient(p2) that want to interact on session chan\u00adnel a. We call \nQ(z) the process \u00b5X.(s[z].(y : client \\ z).{s[z]! (y, Msg(m))} | s[z].(x :client \\ z).{s[z]?(x,Msg(w))});X \nand abbrevi\u00adate the registry a(s)[client:{p1,p2}] by R. (. a)(a(G)| P(p1) | P(p2)) lINITJ. (. a)((. s)(a(s)[client: \n\u00d8] | s : e) | P(p1) | P(p2))) lJOINJ. (. a,s)(a(s)[client:{p1}] | s :e | Q(p1) | P(p2)) lJOINJ. (. a,s)(a(s)[client:{p1, \np2}] | s : e | Q(p1) | Q(p2)) lPOLLJ. (. a,s)(R | s:e | Q(p2) | (s[p1]! (p2, Msg(m)) | s[p1].(x:client \n\\ p1).{s[p1]?(x, Msg(w))});Q(p1)) lSENDJ. (. a,s)(R | s:(p1,p2,Msg(m)) | Q(p2) |(s[p1].(x :client \\ p1).{s[p1]?(x,Msg(w))}); \nQ(p1)) lPOLLJ. (. a,s)(R | s:(p1,p2,Msg(m))) | Q(p2) |s[p1]?(p2, Msg(w));Q(p1)) lPOLLJ. (. a,s)(R | s:(p1,p2,Msg(m)) \n| s[p1]?(p2, Msg(w));Q(p1) |(s[p2]! (p1, Msg(m)) |s[p2].(x :client \\ p2).{s[p2]?(x,Msg(w))});Q(p2)) lSENDJ. \n(. a,s)(R | s:(p1,p2,Msg(m)) \u00b7 (p2,p1,Msg(m)) |s[p1]?(p2,Msg(w));Q(p1) |s[p2].(x :client \\ p2).{s[p2]?(x,Msg(w))}; \nQ(p2)) lPOLLJ. (. a,s)(R | s:(p1,p2,Msg(m)) \u00b7 (p2,p1,Msg(m)) |s[p1]?(p2,Msg(w)); Q(p1) | s[p2]?(p1,Msg(w));Q(p2)) \nlRECVJ. (. a,s)(R | s:(p2,p1,Msg(m)) |s[p1]?(p2, Msg(w));Q(p1) | Q(p2)) lRECVJ. (. a,s)(R | s:e | Q(p1) \n| Q(p2)) Figure 3. Reduction for the peer-to-peer chat example 3. Multirole session types In this section, \nwe present the multirole session types which specify the communication patterns that are to be enforced. \nWe start with the de.nition of global and local types and follow with projection and well-formedness \nproperties. G ::= | p.p '{li(p i)(Ui).Gi}i.I |.x :r \\p .G | G | G'| G; G' | \u00b5x.G | x | e | end T ::= \n| !(p,{li(p i)(Ui).Ti}i.I )| ?(p,{li(p i)(Ui).Ti}i.I )|.x :r \\p .T '' | T | T | T ;T | \u00b5x.G | x | e | \nend U ::= S | T S ::= (G)| bool | unit | ... Figure 4. Global and local types 3.1 Global and local types \nGlobal types G describe role-based global scenarios between multi\u00adple participants as a type signature. \nWhen a participant agrees with a global type G, his behaviour is de.ned by a local protocol (called local \ntype Ti) that is generated by the projection of G to the role he wants to play. If each of the local \nprograms P1,...,Pn can be type\u00adchecked against the corresponding projected local types T1,..,Tn, then \nthey are automatically guaranteed to interact properly, follow\u00ading the intended scenario. The grammar \nof global types (G,G' ,...) ' and local types (T, T ,...) is given in .gure 4. There are four key extensions \nfrom the standard multiparty session types [4]: (1) asso\u00adciation of each participant to a role; (2) universal \nquanti.ers to bind participants identities; (3) parallel compositions for local types; and (4) labels \nthat can be extended by lists of participants. In the global types (G, G' ,...), a global interaction \ncan be a labelled message exchange (p.p '{li(p i)(Ui).Gi}i.I ), where p and ' p denote the sending and \nreceiving participants with roles (recall that p denotes either p :r or x:r), p i is a list of participants, \nUi is the payload type of the message and Gi the interaction that follows the choice of label li (I is \na .nite set of integers). Value types S include shared channel types (G) or base types (bool,unit ,...). \nMessage types U are either value types S or local types T (which correspond to the behaviour of one of \nthe session participants) for delegation. Parallel composition is written as G | G', and G;G' denotes \nse\u00adquential composition. \u00b5x.G is a recursive type where type variable x is guarded in the standard way \n(they only appear under some pre\u00ad.x). Inaction e marks the absence of communication, while end denotes \nthe end of the session for all roles. The universal quanti.\u00adcation is written .x : r \\ p .G where the \nparticipants of role r bind Global types Labelled messages Universal quanti.cation Parallel, Sequential \nRecursion, variable Inaction, End Local types Selection Branching Universal quanti.cation Parallel, Sequential \nRecursion, inaction, end Message types Sorts  free occurrences x in G. It corresponds to the operational \nseman\u00adtics of s[p : r '].(x : r \\p ).{P} (see \u00a7 2), i.e. a parallel composition G{p1/x}| ... | G{pk/x} \nfor some list of participants {p1,...,pk}playing the role r (which is decided at runtime), from which \nthe list of participants p has been excluded. In local types T , selection expresses the transmission \nto p of a label li taken from a set {li}i.I with a list of participants p i and a message type Ui, followed \nby Ti. Branching is its dual counterpart. The other local types are similar to their global versions. \nWe consider global and local types modulo the following equal\u00adities. For local types, we de.ne: (T | \ne)=(e | T )=(e;T )= T , (T | end)=(end | T )= T , (T | T ');end =(T ;end | T ' ;end) and !(p,{li(p i)(Ui).Ti}i.I \n);end = !(p,{li(p i)(Ui).Ti;end}i.I ). Similar equalities are applied to global types. We also use similar \nabbrevia\u00adtions for global and local types as the ones for processes (mentioned in \u00a7 2). In particular, \nwe write p.ql(p ')(U);G or !(p,l(pq)(U));T for a single branching, and p.q(l) if the list of participant \nis empty and the payload type is unit. end is also often eluded. EXAMPLE 3.1 (Global types). To give \nsome additional clarity to the semantics of global session types, we give here several varia\u00adtions on \nan additional example. We imagine a chat protocol (similar in spirit to the peer-to-peer chat session) \nwhere the clients must in\u00adteract through a single server. We have thus two roles: the unique server and \nthe multiple clients. Each client s behaviour is to send a message to the server who will then broadcast \nit to all the others. In the following picture, we only represent the Msg that one client sends to the \nserver and that is followed by the server broadcasting its content (in message Spread) to all the other \nclients. \u00a7 c ... \u00a7 c \u00a7 c \u00a7 c ... \u00a7 c Msg Spread Spread server The global type for this session relies \non the sequentiality that links each Msg to its following Spread. We write it as: G1 = \u00b5x..x:client.{x.server(Msg)..y:client\\x.{server.y(Spread)}};x \nIt starts with a quanti.cation over all clients x. Upon recep\u00adtion by the server of a message from x, \nthe global type spec\u00adi.es that Spread should be sent to all the other clients: .y : client \\ x.server.y(Spread). \nAn alternate chat server could be one where the server collects all incoming messages and then sends \na digest to all clients. In that case, the global type would be written: G2 = \u00b5x..x:client.{x.server(Msg)};.y \n:client.{server.y(Spread)};x The central synchronisation between the two quanti.ed types is important \nin our model. The semantics is radically different if this synchronisation is removed. G3 = \u00b5x..x:client.{x.server(Msg);server.x(Spread)};x \nThe global type G3 means that, independently for each client, the server .rst collects a message Msg \nand then immediately sends back to this same client a message Spread.  3.2 Projection from multirole \nglobal types to local types We now de.ne the projection operation, which, for any participant z playing \na role r in a session G, computes the local type it has to conform to. We say an end-point projection \nof G onto z : r, written G . z:r, is the local type that the participant z should respect to play the \nrole r in session G. As mentioned in \u00a7 1, the main dif.culty lies in the projection of the quanti.ers. \nLet us .rst consider informally the global type .x : r.G. This global type has the same semantics as \nG{p1/x}|... | G{pk/x} for some p1,..., pk playing the role r. If we write the projection of .x : r.G \nfor a participant pi playing role r (written as .x :r.G . pi : r), we can single out the instance corresponding \nto pi: (G{p1/x}. pi : r) | ... | (G{pk/x}. pi :r)= (G{pi/x}. pi : r) |.x :r \\ pi.(G . pi :r) Based on \nthis intuition behind the projection of quanti.ers, we give the projection de.nition in .gure 5. Projection \nis role-based, i.e. for each role r of a session G, a local type T = G . p is computed with p = z:r. \nThe case p = p : r is de.ned by replacing z by p. p.p '{li(p i)(Ui): Gi}i.I . p=!(p ' , {li(p i)(Ui).Gi \n. p}i.I ) p '.p{li(p i)(Ui): Gi}i.I . p=?(p ' , {li(p i)(Ui).Gi . p}i.I ) p.p{li(p i)(Ui): Gi}i.I . p=!(p,{li(p \ni)(Ui).?(p,li(p i)(Ui).Gi . p)}i.I ) . p '.p ''{li(p i)(Ui).Gi}i.I . p= i.I {Gi . p}(.x : r \\p .G) . \nz: r=G{z/x}. z : r |.x : r \\ z::p .(G . z:r)(z .p ) (.x : r \\p .G) . p=.x :r \\p .(G . p)(otherwise) (G \n| G) . p =(G . p | G . p)(G;G) . p =(G . p; G . p) \u00b5x.G . p = \u00b5x.(G . p) x . p = x e . p = e end . p \n= end Figure 5. Projection The projection of communication leads to a case analysis: if the participant \nprojected to (i.e. p) is the sender, then the projection is a selection sent to p '; if p is the receiver \nthen the projection is an input from p '; if participant p is both sender and receiver then the projection \nis an output followed by an input; otherwise, the communication is not observed locally and is skipped. \nThe operator U then merges the different remote branches (this operation was introduced in [35, \u00a7 4]). \nRoughly speaking, it makes sure that the locally observable behaviours are either independent of the \nremotely chosen branch or can be properly identi.ed through their labels. It is de.ned by T U T = T and \nthe following equality: '' ?(p, {li(p i)(Ui).Ti}i.I )U ?(p,{lj (p j ')(Uj).Tj }j.J ) ' = ?(p,{lk(p k)(Uk).Tk}k.I\\J \n.{lk(p k ')(Uk).Tk}k.J\\I '' .{lk(p k)(Uk).Tk U Tk }k.InJ ) when .k .I n J, p k = p k '.Uk = U k Note \nthat the merging operation may not return a result if the session uses labels ambiguously. An example \ncan be found in \u00a7 3.3. Finally, the most critical rules de.ne the projection of a quanti\u00ad.ed global type \n(.x : r \\p .G) . p. The .rst rule applies only when the quanti.cation acts on the same role r as the \nprojection, and when p is not in the exclusion list p . In that case, as explained above, the local type \nis the parallel composition of G where x : r is substituted by p, projected for p, and a quanti.cation \nexclud\u00ading p. The second rule sees the projection acting homomorphically through the quanti.cation on \na different role, or if p is in p . Other rules are homomorphic as well. We say that G is projectable \nif G can be projected (i.e. projection gives a result) for each of its roles. EXAMPLE 3.2 (Projection). \n(1) Peer-to-peer chat example. We give an example of projection for the peer-to-peer chat session from \n\u00a7 1, which features nested quanti.ers. The local type T (z:client) is calculated in the following way \n(p is z:client): (\u00b5x.(.x :client..y:client \\ x.x.yMsg(string)); x) . z :client = \u00b5x.((.x :client..y:client \n\\ x.x.yMsg(string)) . z :client);x = \u00b5x.((.y:client \\ z.z.y Msg(string)) . z:client | .x :client \\ z.(.y \n:client \\ x.x.y Msg(string)) . z:client);x = \u00b5x.(.y :client \\ z.(z.y Msg(string)) . z:client | .x :client \n\\ z.((x.zMsg(string)) . z :client | .y :client \\ z.(x.y Msg(string)) . z:client));x = \u00b5x.(.y :client \n\\ z.!(y,Msg(string)) | .x :client \\ z.(?(x, Msg(string)) |.y:client \\ z.e));x = \u00b5x.(.y :client \\ z.!(y,Msg(string)) \n| .x:client \\ z.?(x,Msg(string))); x (2) Chat-server from example 3.1. We give the projections for each \nof the three global types. The projection of G1 for the server and client roles gives: T1(z:server)=\u00b5x.(.x:client.{?(x \n:client,Msg); .y:client \\ x.! (y:client, Spread)}); x T1(z:client)=\u00b5x.(! (server, Msg)|.x:client \\ z.{?(server,Spread)});x \n Note that the sequentiality between Msg and Spread is rightly present in the server s local type. The \nprojection of G2 results in: T2(z :server)= \u00b5x. .x :client.{?(x :client,Msg)}; .y:client.{! (y:client, \nSpread)};x T2(z:client)= \u00b5x.(!(server,Msg)|.x:client \\ z.{?(server,Spread)});x We note that the server \ns local type represents a behaviour which .rst collects all incoming messages and then sends a digest \nto all clients. On the other hand, the client behaviour is the same as in session G1. The projection \nof G3 is given as: T3(z :server)=\u00b5x..x :client.{?(x:client, Msg);! (y:client,Spread)}; x T3(z:client)=\u00b5x.! \n(server,Msg);?(server,Spread);x In the above types, for each client, the server .rst collects a message \nMsg and then immediately sends back a message Spread to this client.  3.3 Well-formedness For type-checking \nto work, global types need to follow a set of rules that will ensure a reliable and unambiguous session \nbehaviour. Syntax correctness We apply kinding rules [3] to construct syn\u00adtactically correct types. A \n.rst point that is veri.ed is that every par\u00adticipant variable x is bound by a quanti.er and that it \nis consistently used with the same role. Then, we check that recursion variables do not appear under \nquanti.cation or explicit parallel composition. Formally, if a global type is of the form .x : r \\ p \n.G or G | G' , then G and G' are required not to contain any free recursion vari\u00adables. This condition \nprevents any race condition between different iterations of the same loop. We give a few examples of \ncorrect and incorrect global session types. \u00d7 G1 = \u00b5x.(server.client(Msg);x | server.broker(Notify); \nx) v G2 = \u00b5x.(server.client(Msg)| server.broker(Notify)); x v G3 = \u00b5x.server.client(Msg); x | \u00b5y.server.broker(Notify);y \nOther checks include the veri.cation that the position of end is indeed correct. For example, (G;end); \n(G' ;end) is not well-formed. Projectability As seen in \u00a7 3.2, projection does not always re\u00adturn a local \ntype, due to the veri.cation made when branches are merged. The merging operation veri.es that each branch \nis prop\u00aderly labelled and that no local process can be confused about which branch to follow. We thus \nrequire that any global session type G should be projectable. \u00d7 G4 = broker.buyer{Notify.buyer.seller(Msg);seller.buyer(Pay), \nQuit.buyer.seller(Msg)} v G5 = broker.buyer{Notify.buyer.seller(Price);seller.buyer(Pay), Quit.buyer.seller(Stop)} \nThe seller in G4 cannot distinguish the two Msg sent by the buyer. In G5, the seller knows which branch \nhas been taken by the broker since the upper one is labelled by Price and the lower one by Stop. Linearity \nThe concept of linearity is introduced in [19] but, in our case, we use a relaxed version to allow .exible \nparallel compo\u00adsitions (explicit or through quanti.cation) and branching. It makes sure that messages \nare always labelled in a way that prevents com\u00admunication mix-ups. To verify the linearity of a global \ntype G, we .rst need to transform the quanti.ers into explicit parallel compositions. To this effect, \nwe associate to each role r of G a (big enough) list of participant names p0, p1,.... Then, we compute \nfor each role r the local type Tr = G . p0: r and homomorphically replace every subterm of Tr of the \nform3 .x:r \\p .T0 by T0{pi/x}| T0{p j/x} with pi, p j the .rst two participant names for role r that \ndo not appear in p . This transformation is called dequanti.cation. 3 We leave the implicit quanti.ers \nof the singly instantiated roles untouched. DEFINITION 3.3 (Linearity). We say that a well-labelled global \ntype G is linear if, for all roles r of G, the dequanti.cation ' T of Tr = G . p0: r satis.es: If ?(p,{li(p \ni)(Ui).Ti}i.I ) and r '' ' ?(p,{l' j(p j ')(Uj).Tj }j.J ) are both subterms of T , then, .i, j.I \u00d7J, \nr '' li = l' j . ({li}i.I = {l' j}j.J .Ui = Uj . (p i = p j '. Ti = Tj )). This de.nition checks that \nif two receptions exist in the local type of a role r, then either they share no label (and thus cannot \nbe con\u00adfused), or they share exactly the same set of message labels, with identical payload types, in \nwhich case they should only differ by the distinguishing lists of participants: these lists allow to \nreliably target different continuation types even when concurrent threads expect messages with the same \nlabels. \u00d7 G6 = .x :buyer..y:seller.{broker.x(Msg).x.y(Notify)} v G7 = .x :buyer..y:seller.{broker.x(Msg(y)).x.y(Notify)} \nThe dequanti.cation of G6 . p0:seller is (buyers are p0,p1, sellers are q0,q1): ?(broker,(Msg).! (q0, \n(Notify))) | ?(broker, (Msg).!(q1,(Notify))) These two concurrent threads have identical guards but different \ncontinuations. The dequanti.cation of G7 . p0:seller is: ?(broker,(Msg(q0)).!(q0,(Notify)))| ?(broker,(Msg(q1)).!(q1,(Notify))) \nIn that case, the participant identity (y) is added to the label Msg and is able to disambiguate the \nconcurrent receptions. Well-formedness We now give the formal version of the well\u00adformedness condition. \nNote that it is decidable. DEFINITION 3.4 (Well-formed global types). We say that a global type G is \nwell-formed if the following conditions hold: 1. (Syntactically correct) G is syntactically correct [3]. \n 2. (Projectability) G . z : r is de.ned for each role r of G. 3. (Linearity) G is linear (De.nition \n3.3).  EXAMPLE 3.5 (Well-formedness). We test the well-formedness of the auction example from \u00a7 1 (the \nnumbers below correspond to the well-formedness conditions). Recall the global type G: G = .x:buyer..y:seller.broker.x{Match(y).x.y(Notify).y.x(Price).x.y(Order), \nQuit(y). x.y (Stop)};end The syntax correctness (1) is checked easily: there is no recursion, participant \nvariables are bound and used for a unique role, and end is well-positioned. G is projectable (2) since \nthe two branches (Match, Quit) do not forget to use different labels (Notify, Stop) to propagate to the \nseller y the choice that the broker makes. Con\u00adcerning linearity (3), the potential problem is in the \n.rst message: when a buyer x receives a message Match or Quit from the broker, x should know which parallel \ninstance it concerns among the ones the quanti.cation .y :seller creates. We only give below the veri.\u00adcation \ndetails for the buyer. With buyers p0, p1 and sellers q0,q1, the result of the dequanti.cation of G . \np0:buyer is: ?(broker,{Match(q0).!(q0,(Notify).?(q0, (Price).! (q0, (Order)))), Quit(q0).!(q0,(Stop))})| \n?(broker,{Match(q1).!(q1,(Notify).?(q1, (Price).! (q1, (Order)))), Quit(q1).!(q1,(Stop))})For G . q0:seller, \nthe dequanti.cation result gives: ?(p0, {Notify.!(p0,(Price).?(p0,(Order))),Stop}) | ?(p1, {Notify.!(p1,(Price).?(p1,(Order))),Stop})We \ncheck linearity by looking at the different occurrences of the same label (for example Match in G . p0 \n: buyer) being received from the same participant (e.g. broker): we verify that the lists of participant \nidentities are different whenever the continuations are different. Linearity is thus only achieved here \nthanks to the communication of the disambiguating y in messages Match and Quit, as it can be seen in \nthe buyer s case. The seller s and broker s (here omitted) linearity veri.cations are trivial.  4. Multirole \nsession typing system This section introduces the typing system and proves subject reduc\u00adtion (Theorem \n4.2) and type safety (Corollary 4.3). There are three main differences with previous session systems. \nFirst, a participant x can appear free in environments, types and processes, and is nec\u00adessarily bound \nby universal quanti.ers. Second, previous systems did not allow any parallel composition of types which \nuse com\u00admon channels. Since the projection of a universal quanti.ed type generates parallel compositions, \nwe relax this restriction. Thanks to the well-formedness of the global types (De.nition 3.4), the typ\u00ading \nsystem for initial processes is kept simple. Third, our runtime typing system needs to track parallel \nbehaviours by forks and joins. 4.1 Typing systems Environments We start with the grammar of environments. \nG ::= \u00d8| G, u:S | G,y : r | G,X : .. ::= \u00d8| .,c :T G is the standard environment which associates variables \nto sort types or roles, shared names to global types, and process variables to session types. . is the \nsession environment which associates channels to session types. We write G,u : S only if u . dom(G). \nSimilarly for other variables. We de.ne the sequential ; and parallel . compositions for types as follows: \n. r.' = .\\dom(.') . .'\\dom(.) .{c : .(c)r.'(c) | c . dom(.) n dom(.')} where r . {.,;} and .(c)r.'(c) \nis syntactically well-formed. Typing systems for initial processes We detail the typing sys\u00adtem for expressions \nand processes in .gure 6. The judgement for expression typing is given as G f e : S. The judgement for \nprocess typing is given as G f P c . which can be read as: under the envi\u00adronment G, process P has session \ntype . . Rules [BOOL,OR,ID] are standard. G f Env means that G is well\u00adformed, and G f S c Type means \nS is well-formed under G. Since a participant variable with role can appear both in types and environ\u00adments, \nwe need to use kinding techniques to make sure that types with free variables do not appear before the \nvariables declarations and ensure well-formedness (see De.nition 3.4). Rules [RL,RLV] are introduction \nrules for participants associated with roles. Rule [INIT] types the initialisation of a session with \nglobal type G. The judgement G f . : end means that . only contains end or e [18, 19]. The rule ensures \nthe initialisation is not bound by the pre.x. Rule [JOIN] types a joining process that follows the projection \nto p. A leaving process is typed if the remaining session type is completed (i.e. end). Rule [SEL] is \nfor the selection of label li, participants p i and payload e. We .rst infer the destination p from G. \nIf e is an atomic type (e.g. bool) or a shared channel type, then it is typed as in stan\u00addard selection \nrules [4, 19] for the expression by recording partic\u00adipants p i in the resulting type. This way, we can \npreserve the de\u00adpendency between the participants during polling and session com\u00admunications. Rule [SELS] \nis a session delegation rule [4, 19]. Rule [BRA] is the dual of the selection rules. Note that the participants \np and p i in c?(p, {li(p i)(yi).Pi}i.I ) are free so that they are bound by the polling and dynamically \ninstantiated by reductions. Rules [PAR,SEQ] assume ...' and .;.' are de.ned. Rule [POLLING] is the introduction \nrule for the universal quanti.cation. It only concerns a single session (otherwise other sessions are \ncopied after forking). The other rules are standard [4, 19]. Since checking well-formedness is decidable, \nfollowing the standard method [19, \u00a7 4], we have: PROPOSITION 4.1. Assuming the bound names and variables \nin P are annotated (i.e. processes whose bound variables are annotated by types), type-checking of G \nf P c \u00d8terminates. Typing runtime processes While the session typing systems for initial processes are \nsimple, typing runtime (which keeps tracking intermediate invariants to prove the theorems) is not trivial \ndue to parallel processes and participant instantiations generated by polling. We .rst extend the syntax \nof types T to include message selection type ! (p : r, l(p )(U)), which is an intermediate type for labelled \nvalues stored in the message buffer. To type runtime processes, we need to extend judgements to G fS \nP c ., which means that P contains the message buffers whose session names are in S. We only show the \nmost interesting typing rule for the register: Gf a : (G){ri}i.I = dom(R) G . xi : ri = Ti [ RGST] G \nf\u00d8 a(s)[R] c {s[p ji : ri]:Ti{p ji/xi}}i . I,p ji. R(ri) G fSi Pi c .i (i = 1,2) [GPAR] G fS1 S2 P1 | \nP2 c .1 * .2 [RGST] assigns to the registry a type which holds a set of projected local types for all \nroles with participants which are not recorded in R. Session typing s[ri :p ji]:Ti{p ji/xi} is erased \nonce it interacts with the initialisation process a[p ji : ri](y).P (see rule lJOINJ in .gure 2), and \nthe resulting P{s[p ji :ri]/y} holds s[ri : p ji]:Ti{p ji/xi} (see the proof of Subject reduction theorem \nin [3]). When two runtime processes are put in parallel (rule [GPAR]) a queue associated to the same \nsession does not appear twice (S1 n S2 = /0). For composing the two session environments, either ' (1) \nwe sequence a message type T and a local type T for the same session channel as s[p : r] : T ;T ' or \n(2) we check whether s[p : r] : T ' and s[p : r] : T can be parallel composed as s[p : r] : (T | T ') \nby checking the linearity condition for T | T ' following De.nition 3.3; and otherwise (3) unde.ned. \nThen we de.ne . * .' replacing r by * in the de.nition of .r.' .  4.2 Subject reduction As session participants \njoin, interact and leave, runtime session types need to follow. This dynamism is formalised by a type \nre\u00adduction relation . on session environments as follows. 1. {s[q : r '] :!(p :r,{li(p i)(Ui).Ti}i.I \n)} . {s[q : r '] :!(p :r,lk(p i)(Uk).Tk)} 2. s[p :r] :!(q :r ' ,lk(p k)(Uk)),s[q : r '] :?(p :r,{li(p \nk)(Ui).Ti}i.I ) . s[p : r] : e,s[q : r '] : Tk if k .I 3. s[p :r] :!(p :r,lk(p k)(Uk));?(p :r,{li(p \ni)(Ui).Ti}i.I ). s[p : r] : Tk if k .I  4. s[p :r] :.x:ri \\p .T . s[p :r]:(T {p1/x}| .. | T {pk/x}) \nwith pi .p  5. s[p :r]:E [T ].. . s[p :r]:E [T ']..' if s[p:r]:T .. . s[p :r]:T '..' 6. . . .'' . .'. \n.'' . . .'  if In the above type reduction rules, message selection types are considered modulo the \ntype equivalence relation = and E is a type evaluation context (i.e. E ::=[ ] | E | T | T | E | E ;T \n). Rule (1) corresponds to the choice of label li. Rule (2) corre\u00adsponds to the exchange of a labelled \nvalue from participant p : r to participant q : r '. Rule (3) is about self-sending and receiving. Rule \n(4) governs universal quanti.ers and forks types with respect to the participants which are not in the \nexclusion list p . Rules (5,6) are congruent rules. Hereafter we assume all processes are derived from \nthe initial processes (\u00a7 2) (i.e. subterms of those who are reduced from ini\u00adtials). Using the above \nde.nitions, .* P'. Then, G fS P' c .' for some .' such that . .* .' . THEOREM 4.2 (Subject reduction). \nSuppose G fS P c . and P - We say P has a type error if expressions in P contain either a type error \nfor a value or constant in the standard sense (e.g. if 3 then P else Q) or a label error (e.g. the sender \nsends a value with label l0 while the receiver does not expect label l0). From the  G f Env G f ei :bool \n(i = 1,2) G f Env G f Env y : r .GG f S c Type u : S .G [BOOL] [OR] [RL] [RLV] [ID] G f true ,false :bool \nG f e1 . e2 :bool G f p :r G f y:r G f u:S G,a :(G)f P c .G f a:(G) G f . : End G f u:(G) G f P c .,y \n: G . p G f P c .,c :end [NEW] [INIT] [JOIN] [LEAVE] G f (.a : G)P c .G f a(G) c .G f u[p](y).P c .G \nf quit(c); P c ., c:end G f p G f p j G f e:Sj G f P c .,c : Tj j .I G f p G f p j G f P c .,c : Tj j \n.I [SEL] [SELS] G f c!(p,lj(p j)(e));P c .,c :!(p,{li(p j)(Si).Ti}i.I ) G f c! (p, lj(p j)(c ')); P \nc ., c:!(p,{li(p j)(T ).Ti}i.I ),c ' : T G f p .i .I G f p i G,yi :Si f Pi c .,c:Ti (Ui = Si) '' or \nG f Pi c .,c:Ti, yi : T (Ui = Ti ) G,x: r f P c c:T G f p G f .:End i [BRA] [POLLING] [NIL] G f c?(p,{li(p \ni)(yi).Pi}i.I ) c .,c?(p,{li(p i)(Ui).Ti}i.I ) G f c.(x:r \\p ).{P} c c : .x :r \\p .T G f 0 c . G f e:bool \nG f Pi c . (i = 1,2) G f P c .G f Q c .' G f P c .G f Q c .' G,X :. f P c .G,X :. f Env [IF] [PAR] [SEQ] \n[REC] [RVAR] G f if e then P1 else P2 c .G f P | Q c . . .' G f P; Q c .;.' G f \u00b5X.P c .G,X :. f X c \n. Figure 6. Multirole session typing for initial processes subject reduction theorem and the well-formedness \nof global types (De.nition 3.4), we can prove: COROLLARY 4.3 (Type safety). Suppose G f P c .. For any \nP' such that P -has no type error. .* P',P' 5. Communication safety and progress This section discusses \nthe dif.culties that a distributed session se\u00admantics creates when participants can dynamically join, \nleave and poll. We illustrate two limitations of the semantics and typing sys\u00adtem presented so far and \npropose a solution based on multiparty locking that allows more .exibility for leaving a session and \nguar\u00adantees communication safety. We give two progress properties, one of which goes beyond existing \nachievements. 5.1 Limitations Leaving a session While our operational semantics (lQUITJ in .gure 2) allows \na participant to leave a session at any time, the typing rule ([LEAVE] in .gure 6) only allows a participant \nto leave when its local type is end. Recall the peer-to-peer chat example from \u00a7 1 (2), G is of the form \n\u00b5x.G0;x;end with G0 = .x : client..y : client \\ x.{x.y Msg (string)}. The recursive type prevents any \nparticipant from ever leaving since a process will never reach type end. We however remark that a client \ncan play just one interaction round (i.e. G0) and leave safely before another session iteration occurs. \nIf the starting and ending points of global types are known, some participants are able to leave a session \nsafely while others stay. Communication safety and progress In traditional multiparty sessions, the subject \nreduction theorem immediately brings com\u00admunication safety and progress (in a single session) [19]. The \nrea\u00adson is that standard multiparty session initiation ensures that all par\u00adties are eventually present \n(it waits for the expected .xed number of participants to join), while the typing system guarantees the \nsafety of the communications when they start. This does not hold in our system due to the interplay between \njoining, leaving and polling. We illustrate this point with the peer-to-peer chat example from \u00a7 1. In \nthat global type, every client is broadcasting Msg to all the others. Recall the client process Pclient(z) \nfrom \u00a7 1. a[z:client](s).\u00b5X.(s.(y:client \\ z).{s! (y,Msg(m))}| s.(x :client \\ z).{s?(x,Msg(w))});X At \neach iteration, every client does exactly two polling operations. Now suppose that a client does the \n.rst polling operation (to send Msg) before another client joins. It means that this new client will \nnot receive the message it expects. More generally, the polls that correspond to the emissions need to \nalways give the exact same result as the reception polls. This suggests that some mechanism to synchronise \ndistributed polling processes is required to guarantee consistent polling results.  5.2 Multiparty locking \nfor polling synchronisation This subsection shows that a simple locking policy that can be au\u00adtomatically \ncomputed from the global type is able to ensure a safe synchronisation to allow .exible session departure \nand consistent polling results. The key point is to temporarily block late partici\u00adpants from joining \nin the middle of a session execution in order to prevent any interference with polling. This is simply \ndone by auto\u00admatically surrounding global types by locks: lock{G} means that the interactions speci.ed \nby G are protected from late joiners and is called a locked global type. This condition is easily implementable \nusing a standard two phase commitment protocol which minimises the necessary synchronisation between \nprocesses (.gure 7) and is easily implementable in ML (\u00a7 5.5). The peer-to-peer chat example from \u00a7 1 \nis now de.ned by \u00b5x.lock{.x : client..y : client.x.yMsg(string)};x. This type al\u00adlows participants to \njoin at each recursive iteration, preventing in\u00adterferences while the exchange of Msg is under way. Syntax \nWe .rst extend the syntax of processes (.gure 1) as: P ::= ... | c lock | c unlock | a.[R,.] | a [R,.] \n. ::= \u00d8 | . .{p : r} The process syntax is extended to locking and unlocking opera\u00adtions. The registry \nhas two new states: a.[R,.] represents a registry that is in the process of being locked (so far by participants \n.), while a [R, .] represents a registry that is locked (and where par\u00adticipants . are still involved). \nSemantics The operational semantics with multiparty locking is given in .gure 7. It de.nes the relations \nbetween the three states of the registry and is based on a standard two phase locking protocol commonly \nfound in distributed applications. The .rst phase is the registration state: if the registry is of the \nform a(s)[R], participants can join and leave the session through lJOINJ and lQUITJ. The only other reduction \nrule that can be applied is lLOCKJ, which puts the registry in its second state, the locking state a.[R,e \n: .]. Then, the session can only wait for all the current participants in R to activate their locks by \nthe rules lUP, TOPJ.A new process can asynchronously join by lJOIN2J, and a current process can .nally \ndecide to leave lQUIT2J from the active session. The difference between lUPJ and lTOPJ lies in the side \ncondition:  a(G) -. (. s)(a(s)[R] | s:e)(.ri .G,R(ri)= \u00d8) lINITJ a[p :r](y).P | a(s)[R \u00b7 r :P] -r : \nP {p}] lJOINJ . P{s[p :r]/y}| a(s)[R \u00b7 a[p :r](y).P | a.(s)[R \u00b7. P{s[p :r]/y}| ar :P (p :r ..) r :P,.] \n-.(s)[R \u00b7{p}, .] lJOIN2J quit(s[p :r])| a(s)[R \u00b7 r :P] -r :P \\{p}] . a(s)[R \u00b7lQUITJ quit(s[p :r])| a.(s)[R \n\u00b7 r :P,.] -.(s)[R \u00b7 r :P \\{p}, .](p :r ..) lQUIT2J . as[p : r]lock | a(s)[R] -.(s)[R, {p : r}] lLOCKJ \n. a { a.(s)[R,. {p :r}](R . {p : r}) lUPJ s[p :r]lock | a.(s)[R,.] - . { a (s)[R,. {p :r}](R . {p \n: r}) lTOPJ a (s)[R,.](. = \u00d8) lDOWNJ s[p :r]unlock | a (s)[R,. . {p :r}] - a(s)[R](. = \u00d8)lUNLOCKJ '' \ns[p :r]! (p ' :r ,l(p )(v)) | a (s)[R, .] | s :h - (s)[R,.] | s:h \u00b7 (p :r, p , l(p )(v))(p .R(r) . p \n'.R(r ')) lSENDJ . a' :r '' s[p :r]?(p ' :r ,{li(p i)(xi).Pi}i.I )| a' :r , p :r, lk(p k)(v)) \u00b7 h - \n(s)[R] | s:h (p .R(r) . k .I) lRECVJ (s)[R] | s:(p . Pk{v/xk}| as[p :r].(x :r \\p ).{P}| a (s)[R \u00b7. P{p1/x}| \n.. | P{pk/x}| ar : P,.](R(r) \\p = {p1,.., pk}. p .R(r ')) lPOLLJ r :P,.] - (s)[R \u00b7 Other rules are from \n2. Figure 7. Operational semantics with multiparty lock R . holds when .p : r.(. = .'{p : r}. R = R \n'\u00b7 r : P {p}). Consequently, lTOPJ is only triggered when the set . contains the exact same combinations \nof participants and role as the set R, meaning that all participants have activated their locks. The \napplication of rule lTOPJ marks the beginning of the inter\u00adaction state, with a registry of the form \na (s)[R,e : .]. Only in this state can the rules l SEND, RECV, POLLJ be safely applied. The reg\u00adistry \ngoes back to its registration state by the application of rule lUNLOCKJ which can occur only when everyone \nbesides one partic\u00adipant has activated the unlock operation by rule lDOWNJ. Types and typing The syntax \nof global and local types are ex\u00adtended from .gure 4 as follows: G ::= ... | lock{G} T ::= ... | lock \n| unlock We say that a global type G is terminable if there exists at least one .nite path (whose leaf \nis e) up to the unfolding of G.A terminable type can be easily de.ned by a kinding system: e is terminable; \np.p '{li(p i)(Ui).Gi}i.I is terminable if for some k .I, Gk is terminable; and others are de.ned homomorphically \n(see [3]). For example, \u00b5x.p.p '{l1(U1).e, l2(U2).x} is terminable, but \u00b5x.p.p '{l1(U1).x,l2(U2).x} is \nnot. We de.ne the condition for global types and environments. DEFINITION 5.1 (Well-locked and persistently \nwell-locked). We say that a global type G is well-locked if G is closed (i.e. no free participant and \nrecursive type variables) and of the form lock{G0};end, and G0 does not include any lock. We say that \na closed global type G is persistently well-locked if G is of the form \u00b5x.lock{G0};x;end, with lock{G0};end \nwell-locked and G0 is terminable. We call G well-locked if for all G(u)= (G), G is ei\u00adther well-locked \nor persistently well-locked. We call G persistently well-locked if for all G(u)= (G), G is persistently \nwell-locked. Type lock{G0} means that a single multiparty session is locked. Type \u00b5x.lock{G0};x states \na multiparty session is persistently (re\u00adpeatedly) locked. The persistent lock ensures if a new participant \np wants to join, it can join at the beginning of the interaction G0, and if one wishes to quit, it can \nquit at the end of the session. Con\u00adsequently, it requires the global type to be of the form \u00b5x.G0;x \nwith a well-locked G0 that does not contain any in.nite loop which would prevent from reaching a new \niteration (unlock). The persis\u00adtent condition is needed for the .nal strong join progress discussed later. \nLocal types lock and unlock come from the projection: lock{G}. z:r = lock;(G . z:r);unlock This way, \ncorrect locks are automatically inserted at the right points of the local types. Typing lock and unlock \nis straightforward. G f Env G f Env G f c lock c c : lock G f c unlock c c:unlock We add the following \nrule which types quit(c) as some projection of session (G) in the environment. G f P c ., c:end G f u:(G) \nG f quit(c);P c .,c : G . p The above rule is useful when G is persistently well-locked. Sup\u00adpose G = \n\u00b5x.lock;G0;x;end. By the above rule, we can type lock; Q; unlock;quit(c) if Q has type G0 . p since G \n. p G0 . ' p;G . p where T T means T is isomorphic to T '; once session is unlocked, one can leave \nthe active session at c instead of repeating the same session G . p. As a simple example, recall the \npeer-to-peer chat server from \u00a7 1. The following client leaves a session after one interaction, which \nis typable under G = \u00b5x.lock{G0}; x;end with G0 = .x : client..y:client \\ x.{x.y Msg(string)}. Pclient(p)=a[p \n:client](s).(s.(y :client \\ z).{s!(y,Msg(m))} |s.(x:client \\ z).{s?(x,Msg(w))});quit(s)  5.3 Communication \nsafety and progress We .rst state communication safety. It states that, in a session execution, no receiver \nwaits for a message that will never come; and that there is no messages sent but never received. DEFINITION \n5.2 (Communication-safety). We say P is communi\u00adcation safe if: ' P = E [Q] with Q = s[p :r]?(p ' :r \n,{li(p i)(x).Pi}i.I ) implies that ' .* E ' : r k .I; and ' there exists E [Q] -'[Q | s : (p , p : r, \nlk(p k)(v)) \u00b7 h] with P = E [Q] with Q = s : (p ' : r , p : r, lk(p k)(v)) \u00b7 h implies that ' .* ' : \nr with k .I. there exists E [Q] -E '[Q | s[p : r]?(p ,{li(p i)(x).Pi}i.I )] The .rst statement means \nthat branching processes can always .nd out a correct element in the message buffer; and the second one \nis its dual. Note that combining with Type safety, the receiver will input a value v of the expected \ntype.  DEFINITION 5.3 (Single-session join). We write G f* PI. if P is typable and with a type derivation \nwhere the session typing in the premise and the conclusion of each pre.x rule is restricted to be at \nmost a singleton (more precisely, . = \u00d8 in [JOIN,LEAVE,SEL,BAR] and . contains at most one element in \n.;.' in [SEQ], . . .' in [PAR,SEQ], . in [IF,NEW,REC,RVAR] in .gure 6, deleting [SELS]). We say Q = a[p](y).Q' \nis a single-session join if a:(G)f* Qc\u00d8and Q' does not contain shared name restriction and any join process. \nG f* P I . ensures that P contains (several) join processes each of which holds a single session, while \nsingle-session join a[p](y).Q' has only one active point a, and once the session initiated at a, Q' can \nonly perform session communication at that initiated session. We prove the communication safety in a \nsingle multiparty session. THEOREM 5.4 (Communication safety). Suppose a : (G)f* P c \u00d8 and P is initial. \nAssume a : (G) is well-locked4. and P does not contain any shared name restriction. For any P' such that \nP -, .* P' P' is communication safe. The proof starts by a de.nition of coherent environments (a certain \nkind of duality relation over multiple participants [4, \u00a7 3]). Then, we prove a stronger subject reduction \ntheorem that shows the re\u00adduction of well-locked processes preserves the coherency of the resulting environment. \nWe note that session .delity [19, Corollary 5.6] comes also as a corollary. Now we prove the progress \nproperty in a single multiparty session as in [19, Theorem 5.12], i.e. if a program P starts from one \nsession, the reductions at session channels do not get stuck. DEFINITION 5.5 (Progress property). We \nsay G f P c \u00d8can prog\u00adress, or satis.es the progress property, if, whenever P - .* P', then either P'= \n0, P'. R or for some single-session join a : (G)f Q -with a:(G).G such that P'| Q -. R and R can progress. \nThe above de.nition means that a process satis.es the progress property if it can never reach a deadlock \nstate, i.e., if it never reduces to a process which contains active sessions (this amounts to containing \nwaiting process at some session channel) and which is irreducible in any inactive context with single-session \njoin Q running in parallel. THEOREM 5.6 (Progress). Suppose G f* P c \u00d8 and P is initial. Assume G is \nwell-locked and P does not contain any shared name restriction. Then P can progress.  5.4 Join progress \nThe above standard progress property is not strong enough, since all late joiners cannot participate \nto existing sessions. This subsec\u00adtion states a new progress property, not found in the literature. Recall \nthe (1) map-reduce example from \u00a7 1, and change the position of the recursion in the global type to: \nG0 = .x:client.server.x(Map); \u00b5x.x.server(Reduce);x From G0, we have the following well-typed processes: \nP0(s,z :client)= s?(server, Map); \u00b5X.s!(server,Reduce);X P0(s, z:server)= s.(x :client).{s!(x,Map); \u00b5X.s?(x,Reduce);X} \nWhile the interaction between them is communication safe, the problem is that a late client will never \nbe listened to by the existing server because the server s polling operation is not repeated to include \nhim. In other words, the late client cannot join an existing, already running session. Persistent locking \nensures this situation does not happen. 4 The property can be generalised to G from {a : (G)} if we compose \na parallel composition of single-session processes to E [Q] in De.nition 5.2 as De.nition 5.5. A similar \ngeneralisation is possible for De.nition 5.7. s[p : r] Below we write P---.Q if P -. Q is derived . Q \nand P -using lQUITJ, lQUIT2J, lSENDJ, lRECVJ or lPOLLJ at s[p : r] with lPAR,CTX,CONGJ, i.e. P interacts \nwith a queue or registry through s[p :r]. DEFINITION 5.7 (Join progress property). We say that a : (G)f \nP c \u00d8satis.es the join progress property if: P can progress; and  if P -(. | a(s)[R]) then, for any \nsingle-session join  .* s)(P' a : (G)f a[p : r](y).Q c \u00d8 with p : r fresh, and for any R such that P'| \na(s)[R] | a[p : r](y).Q -a (s)[R '] | R = Q' , .* s[p : r] .* if s[p :r].R, then there exists Q' ----.R'; \nand (. s)Q' satis.es the join progress property. The above de.nition says that a fresh joiner (a[p : \nr](y).Q) can al\u00adways join the existing (unlocked) session s in P'. In addition, it can always progress \nat the created session channel s by interacting with P'. More intuitively, once some participants under \nany role start a session, the late joiner can still join that session and interact with earlier joiners, \nprogressing further. Note that we can consider any single-session join a[p : r](y).Q to make a process \nprogress, which contrasts with the de.nition of the progress property (De.nition 5.5) where P is only \ncomposed of single-session joining processes. THEOREM 5.8 (Join progress). Suppose a : (G)f* P c \u00d8 and \nP is initial. Assume a : (G) is persistently well-locked and P does not contain any shared name restriction. \nThen P satis.es the join progress property. We have for our examples: PROPOSITION 5.9 (Properties of \nthe examples). Assume that each global type G in the protocols (1 3) of \u00a7 1 is replaced by lock{G}. Then \nall examples are type/communication safe and can always progress. Moreover if each global type in the \nprotocols (1,2) of \u00a7 1 inside the recursive type, i.e. \u00b5x.G;x is replaced by \u00b5x.lock{G};x, then they \nadditionally satisfy the join progress property.  5.5 Implementation Prototype implementation The multirole \ncalculus has been im\u00adplemented as an extension of ML. Following the technique used in [5, 13], the global \ntypes that the programmer writes are com\u00adpiled into an end-point function for each role. This choice \nallows to replace the implementation of the typing system by an automated generation of well-typed processes \nthat can be used, through an API, by the programmer. The session semantics is thus entirely generated \nand implemented by communication libraries. A distributed implementation The main issue for our compiler \nis to distribute as much as possible the centralised aspects of the semantics of .gures 2 and 7. First \nconcerned, the message buffers are completely distributed and implemented on the sender side: a thread \nis spawned to asynchronously make sure that the message gets across the TCP channel. Second, the registries \ncan be par\u00adtially distributed with one registry per role that deals with the corre\u00adsponding joining, \nleaving and polling activities. These distributed registries however need to stay in contact to synchronise \nthe global locking events (rules l LOCK, TOP, UNLOCKJ). Registries are attributed to participants by \nage: the .rst joiner for a role plays the registry as well, until he quits, in which case the registry \nis transmitted to the second older. Extension Singly instantiated roles, like the server or broker from \nexamples in \u00a7 1, are modelled through an inef.cient implicit quan\u00adti.cation. Our implementation gives \na special status to these roles. We use the fact that they play their own registry. As a consequence, \nno separate polling is necessary to send them messages and the ex\u00ad  tra messages required by the quanti.cation \ncan be avoided. Ef.ciency To gain performances, we propose an implementation with optimised messaging \nand improved asynchrony. First, since the slowest operation is communication, our imple\u00admentation tries \nto minimise the number of messages that are ex\u00adchanged. The main illustration is that if two messages \nare speci.ed to be sent in a row between the same participants, they are automat\u00adically concatenated. \nA more radical change is to do the polling only once for every participant, at the beginning of each \nlocked part of the session execution. The advantages are to limit the number of sent messages and to \nremove in effect the global synchronisation point of rule lUNLOCKJ. As soon as all polling operations \nare done, the distributed session execution can safely proceed until the list of participants of the \nnext iteration is synchronised (rule lTOPJ). 6. Related work The .rst motivation for the present work \nis a strong need to extend session type theory with dynamic recon.guration of multiparty sessions and \nrole-based abstraction to support a wider range of communication protocols found in practice. The inspiration \nfor multiparty session types comes from the design of high-level global protocol signatures for Web Services \nChoreography Description Language [1]. In CDL, types of partic\u00adipants (participantType) are declared \nas instances of types of roles (roleType) which represent collections of interaction behaviours. Later, \nsome of the members of the W3C CDL working group have started developing a language called Scribble [17, \n28] based on the theory of multiparty session types [4, 19]. Scribble is currently be\u00ading experimented \nwith for several different application domains in distributed systems [2, 24, 27] including business \nand .nancial pro\u00adtocols [32]. Our auction example in \u00a7 1(3) was extracted from the Scribble speci.cation \ndocument. The need for roles in session programming is also substanti\u00adated by our experiences in implementing \nweb service usecases [1] and parallel algorithms for high-performance clusters [25] using Session Java \n(SJ) [20, 21]. In this work, we .rst describe com\u00admunications between processes in a global topology \n(e.g. a multi\u00addimensional mesh or a ring) in the form of parameterised multi\u00adparty session types [35]. \nThe compatibility between [35] and our present work is yet to be investigated as complex topologies with \ndynamic features need sophisticated distributed synchronisation al\u00adgorithms (see also \u00a7 7). The second \nmotivation for the present work is the incorpora\u00adtion of dynamic features most suited to and compatible \nwith exist\u00ading multiparty session types [4 6, 9, 14, 19, 22, 23, 29, 35, 36]. The Conversation Calculus \n[8, 33] models distributed behaviours among places using new primitives such as conversation contexts \n(i.e. shared interaction points) and up (.) communication (simi\u00adlar to [7, 12]). A conversation models \nthe interactions between a client and various services, with dynamic joining into a conver\u00adsation, for \na possibly unknown number of processes. While both their work and ours aim to support dynamic natures \nfor sessions, the two join mechanisms are quite different. Their join is encoded by base primitives for \nlate joining into a point of conversation, which more closely resembles the late asynchronous session \nini\u00adtiation in [20, 35]. On the other hand, our join mechanism is role\u00adbased, and articulated at the \nlevel of global types, by declaring a single type construct which binds participants to a role. In contrast \nto [8], the process which controls joining might be a sender or lis\u00adtener, depending on the result of \nthe projection (i.e. the position of polling). This .exibility enables direct modelling and clear articula\u00adtion \n(i.e. without encoding) of different patterns of dynamic parallel protocols including symmetric peer-to-peer \nchats (\u00a7 1 and Exam\u00adples 3.1 and 3.2) by types. In [8], they proposed a sophisticated typ\u00ading system \nthat builds a well-founded order on events (similar to the line of [34]), to guarantee progress for processes \nunder the assump\u00adtion that all communications are matched with suf.cient joiners. They do not, however, \nexplore type inference for progress (decid\u00adability of a generation of well-formed ordering) [33]. Our \nprogress can be, on the other hand, guaranteed by well-formedness of global types, with an automatic \ninsertion of locks (which means a typing system with progress is decidable with Proposition 4.1). This \nleads to a simple but practical prototype implementation as discussed in \u00a7 5.5. A strong joining property \nhas not been studied in [8]. Contracts [11] record abstract interaction behaviours of pro\u00adcesses, and \ntypable processes themselves may not always satisfy the properties of session types such as progress: \nit is proved later by checking whether a whole contract conforms to a certain form. Proving properties \nwith contracts requires an exploration of all pos\u00adsible interleaved or non-deterministic paths of a protocol, \nsee [35, \u00a7 5]. The .rst suggestion to use roles to model dynamic conversations in the context of session \ntypes was made in [16]. This idea is further developed in a master s thesis [26] which formalises a Java\u00adlike \ncore calculus for role-based session interactions. A session structure is described as a collection of \nbinary session types for broadcast channels (used to send messages to role participants). New participants \ncan only join a conversation before it starts. Type structures for global protocols and their induced \nproperties (in particular progress) are not studied in [26]. For further comparisons of session types \nwith other service\u00adoriented calculi and behaviour typing systems, see [15] for a wide ranging survey \nof the related literature. 7. Conclusion and future work This work introduced a multirole session type \ndiscipline for validat\u00ading dynamic behaviours among an unspeci.ed number of partici\u00adpants, answering \na well-known open problem of multiparty session types [4, 6, 9, 14, 19, 22, 29, 35]. Dynamism is formalised \nthrough a powerful universal type construct which can represent many collec\u00adtive communications protocols, \nranging over parallel computations, P2P networking, chat protocols and e-commerce auctions. Despite the \ngreater expressiveness, projection and type checking are decid\u00adable. Global types offer a practical guideline \nfor a correct multi\u00adparty synchronisation mechanism, by which the theorems (proper\u00adties) are articulated \nas: (1) .x.G (subject reduction and type safety with dynamic join and leave semantics), (2) well-locked \nlock{G}(communication safety and progress); and (3) persistently well\u00adlocked \u00b5x.lock{G};x (join progress). \nOur prototype implemen\u00adtation demonstrates the direct applicability of the present theory. To realise \nthe full potential of the multirole session type theory, several challenges need to be addressed. First, \nthe theory can be integrated with the multiparty session exceptions developed in [10] in order to handle \nsystem failure and fault-tolerance in a larger class of distributed protocols, preserving type safety. \nIt is especially useful to directly express more complex and dynamic topologies, in combination with \nthe parameterised type theory from [35]. One extension that comes immediately to mind is the addition \nof an explicit existential .x : r.G. It however raises many semantic issues. Consider G' = .x : client.{.y \n: server.x.y(Msg)}. In that example, every client contacts a server (the intuition is that each x chooses \nhis y). The question is: how can we ensure by local typ\u00ading that servers will be listening to the right \nnumber of requests? The dif.culty is that a server y can be potentially chosen by ev\u00adery client x or \nby none, and that this choice is distributed (and thus very hard to locally type check). Consequently, \nthe global existen\u00adtial quanti.cation rather abstracts complex distributed election al\u00adgorithms. A different \nsolution is an extension to subtyping between roles r1 <: r2 by which we can represent a protocol with \nmember\u00adships, e.g. a client sends a message to a subset of subscribers.  Second, type-based approaches \nfor correct locking has been widely studied, including [30] in a framework of linear program analysis \nand types. Our aim in \u00a7 5.2 is to propose a simple way to realise synchronisation, articulated by global \ntypes, suggesting another use of global descriptions for different purposes. One such instance is studied \nin [14], where multiparty session types lead to an ef.cient buffer analysis, along with automatically \nguaranteed communication and buffer safety. A bene.t of using global types (i.e. a choreography framework \n[1]) is that the analysis can be done solely based on global types, without directly analysing (possibly \ndistributed) end-point types or processes since we can assume all processes agree with that global speci.cation. \nAn integration with global and local locking [30] is, however, an interesting future topic from the viewpoint \nof local re.nements [22]. Third, we are currently collaborating with several industry part\u00adners working \non open standardisations for .nancial protocols [32] and messaging middleware [2], governance architectures \n[27] and cyberinfrastructures [24] to attest the practical use and expressive\u00adness of the session framework, \nfor which an integration with mul\u00adtiparty logic [6] and security [5, 9] for monitoring, is our next task. \nAcknowledgement We are grateful to Lu\u00b4is Caires, Marco Car\u00adbone, S\u00f8ren Debois, Kohei Honda, Raymond Hu, \nKohei Suenaga, Hugo Vieira and Vasco Vasconcelos for their helpful comments. We thank the anonymous reviewers \nfor their precise questions and suggestions. This work was supported by EPSRC EP/F003757/01 and G015635/01. \nReferences [1] Web Services Choreography Description Language. http://www. w3.org/2002/ws/chor/. [2] \nAdvanced Message Queueing Protocols. http://www.amqp. org/confluence/display/AMQP/Advanced+Message+ Queuing+Pr%otocol. \n[3] On-line Appendix of this paper. http://www.doc.ic.ac.uk/ pmalo/dynamic. [4] L. Bettini et al. Global \nProgress in Dynamically Interfered Multiparty Sessions. In CONCUR 08, volume 5201 of LNCS, pages 418 \n433. Springer, 2008. [5] K. Bhargavan, R. Corin, P.-M. Deni\u00b4elou, C. Fournet, and J. Leifer. Cryptographic \nprotocol synthesis and veri.cation for multiparty ses\u00adsions. In CSF, pages 124 140, 2009. [6] L. Bocchi, \nK. Honda, E. Tuosto, and N. Yoshida. A theory of design\u00adby-contract for distributed multiparty interactions. \nIn CONCUR 10, volume 6269 of LNCS, pages 162 176. Springer, 2010. [7] M. Bugliesi, G. Castagna, and S. \nCrafa. Access control for mobile agents: The calculus of boxed ambients. TOPLAS, 26(1):57 124, 2004. \n[8] L. Caires and H. T. Vieira. Conversation types. In ESOP, volume 5502 of LNCS, pages 285 300. Springer, \n2009. A full version will appear in TCS. [9] S. Capecchi, I. Castellani, M. Dezani-Ciancaglini, and T. \nRezk. Ses\u00adsion Types for Access and Information Flow Control. In CONCUR 10, volume 6269 of LNCS, pages \n237 252. Springer, 2010. [10] S. Capecchi, E. Giachino, and N. Yoshida. Global escape in multiparty session. \nIn 30th FSTTCS 10, LIPICS, 2010. To appear. [11] G. Castagna and L. Padovani. Contracts for mobile processes. \nIn CONCUR, number 5710 in LNCS, pages 211 228, 2009. [12] G. Castagna, J. Vitek, and F. Z. Nardelli. \nThe seal calculus. Inf. Comput., 201(1):1 54, 2005. [13] R. Corin and P. Deni\u00b4elou. A protocol compiler \nfor secure sessions in ML. In TGC, volume 4912 of LNCS, pages 276 293. Springer, 2008. [14] P.-M. Deni\u00b4elou \nand N. Yoshida. Buffered communication analysis in distributed multiparty sessions. In CONCUR 10, volume \n6269 of LNCS, pages 343 357. Springer, 2010. Full version, Prototype at http://www.doc.ic.ac.uk/ pmalo/multianalysis. \n[15] M. Dezani-Ciancaglini and U. de Liguoro. Sessions and Session Types: an Overview. In WS-FM 09, volume \n6194 of LNCS, pages 1 28. Springer, 2010. [16] E. Giachino, M. Sackman, S. Drossopoulou, and S. Eisenbach. \nSoftly safely spoken: role playing for session types. Preliminary on-line preproceeding, 64 69 pages, \nhttp://gloss.di.fc.ul. pt/places09/preproceedings.pdf. [17] K. Honda, A. Mukhamedov, G. Brown, T.-C. \nChen, and N. Yoshida. Scribbling interactions with a formal foundation. In ICDCIT, LNCS. Springer, 2011. \nTo appear. [18] K. Honda, V. T. Vasconcelos, and M. Kubo. Language primitives and type disciplines for \nstructured communication-based programming. In ESOP 98, volume 1381 of LNCS, pages 22 138. Springer, \n1998. [19] K. Honda, N. Yoshida, and M. Carbone. Multiparty Asynchronous Session Types. In POPL, pages \n273 284, 2008. [20] R. Hu, D. Kouzapas, O. Pernet, N. Yoshida, and K. Honda. Type-Safe Eventful Sessions \nin Java. In ECOOP 10, volume 6183 of LNCS, pages 329 353. Springer, 2010. [21] R. Hu, N. Yoshida, and \nK. Honda. Session-Based Distributed Pro\u00adgramming in Java. In ECOOP 08, volume 5142 of LNCS, pages 516 \n541, 2008. [22] D. Mostrous, N. Yoshida, and K. Honda. Global principal typing in partially commutative \nasynchronous sessions. In ESOP 09, volume 5502 of LNCS, pages 316 332, 2009. [23] L. Nielsen, N. Yoshida, \nand K. Honda. Multiparty symmetric sum\u00adtypes. Technical Report 8, Department of Computing, Imperial Col\u00adlege \nLondon, 2009. To appear in Express 10. Apims Project at: http://www.thelas.dk/index.php/apims. [24] Ocean \nObservatories Initiative (OOI). http://www. oceanleadership.org/programs-and-partnerships/ ocean-observin%g/ooi/. \n[25] O. Pernet, N. Ng, R. Hu, N. Yoshida, and Y. Kryftis. Safe Parallel Programming with Session Java. \nTechnical Report 14, Department of Computing, Imperial College London, 2010. [26] A. Raad. Smelling of \nRoses: ROles, Speci.cation, Speci.cation and Scrutiny. DoC master s thesis, Imperial College London, \n2010. [27] Savara JBoss Project. http://www.jboss.org/savara. [28] Scribble Project. http://www.jboss.org/scribble. \n[29] K. C. Sivaramakrishnan, K. Nagaraj, L. Ziarek, and P. Eugster. Ef.\u00adcient session type guided distributed \ninteraction. In Coordination 10, volume 6116 of LNCS, pages 152 167. Springer, 2010. [30] K. Suenaga. \nType-based deadlock-freedom veri.cation for non-block\u00adstructured lock primitives and mutable references. \nIn APLAS, volume 5356 of LNCS, pages 155 170, 2008. [31] K. Takeuchi, K. Honda, and M. Kubo. An interaction-based \nlanguage and its typing system. In PARLE 94, volume 817 of LNCS, pages 398 413. Springer, 1994. [32] \nUNIFI. International Organization for Standardization ISO 20022 UNIversal Financial Industry message \nscheme. http://www. iso20022.org. [33] H. Viera. A Calculus for Modeling and Analyzing Conversations \nin Service-Oriented Computing. PhD thesis, University Nova de Lisboa, 2010. [34] N. Yoshida. Graph types \nfor monadic mobile processes. In FSTTCS, volume 1180 of LNCS, pages 371 386, 1996. [35] N. Yoshida, P.-M. \nDeni\u00b4elou, A. Bejleri, and R. Hu. Parameterised multiparty session types. In FoSSaCs, volume 6014 of \nLNCS, pages 128 145, 2010. [36] N. Yoshida, V. T. Vasconcelos, H. Paulino, and K. Honda. Session\u00adbased \ncompilation framework for multicore programming. In FMCO 08, volume 5751 of LNCS, pages 226 246. Springer, \n2009.    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Multiparty session types enforce structured safe communications between several participants, as long as their number is fixed when the session starts. In order to handle common distributed interaction patterns such as peer-to-peer protocols or cloud algorithms, we propose a new role-based multiparty session type theory where roles are defined as classes of local behaviours that an arbitrary number of participants can dynamically join and leave. We offer programmers a polling operation that gives access to the current set of a role's participants in order to fork processes. Our type system with universal types for polling can handle this dynamism and retain type safety. A multiparty locking mechanism is introduced to provide communication safety, but also to ensure a stronger progress property for joining participants that has never been guaranteed in previous systems. Finally, we present some implementation mechanisms used in our prototype extension of ML.</p>", "authors": [{"name": "Pierre-Malo Deni&#233;lou", "author_profile_id": "81318488153", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P2509647", "email_address": "malo@doc.ic.ac.uk", "orcid_id": ""}, {"name": "Nobuko Yoshida", "author_profile_id": "81100632656", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P2509648", "email_address": "yoshida@doc.ic.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926435", "year": "2011", "article_id": "1926435", "conference": "POPL", "title": "Dynamic multirole session types", "url": "http://dl.acm.org/citation.cfm?id=1926435"}