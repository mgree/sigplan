{"article_publication_date": "01-26-2011", "fulltext": "\n Static Analysis of Multi-Staged Programs via Unstaging Translation * Wontae Choi Baris Aktemur Kwangkeun \nYi Seoul National University, Korea UIUC, USA &#38;Ozyegin University, Seoul National University, Korea \nwtchoi@ropas.snu.ac.kr Turkey kwang@ropas.snu.ac.kr Baris.Aktemur@ozyegin.edu.tr Makoto Tatsuta National \nInstitute of Informatics, Japan tatsuta@nii.ac.jp Abstract Static analysis of multi-staged programs \nis challenging because the basic assumption of conventional static analysis no longer holds: the programtext \nitselfisno longera.xed static entity,but rather a dynamically constructed value. This article presents \na semantic\u00adpreserving translation of multi-staged call-by-value programs into unstaged programs and a \nstatic analysis framework based on this translation. The translation is semantic-preserving in that every \nsmall-step reduction of a multi-staged program is simulated by the evaluation of its unstaged version. \nThanks to this translation we can analyze multi-staged programs with existing static analy\u00adsis techniques \nthat have been developed for conventional unstaged programs: we .rst apply the unstaging translation, \nthen we apply conventional static analysis to the unstaged version, and .nally we cast the analysis results \nback in terms of the original staged pro\u00adgram. Our translation handles staging constructs that have been \nevolved to be useful in practice (typi.ed in Lisp s quasi-quotation): open code as values, unrestricted \noperations on references and in\u00adtentional variable-capturing substitutions. This article omits refer\u00adences \nfor which we refer the reader to our companion technical report. Categories and Subject Descriptors \nD.3.1[Programming Lan\u00adguages]: Formal De.nitions and Theory; D.3.3 [Programming Languages]: Language \nConstructs and Features; F.3.2 [Logics and Meanings of Programs]:Semantics of Programming Languages Program \nanalysis General Terms Languages, Theory * This work was supported by the Engineering Research Center \nof Ex\u00adcellence Program of Korea Ministry of Education, Science and Technol\u00adogy(MEST)/National Research \nFoundation of Korea(NRF) (Grant 2010\u00ad0001717). Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PoPL 11, January 26 28, Austin,Texas, USA. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0490-0/11/01. . . $10.00. Keywords Multi-staged languages, Static analysis, Unstaging \ntranslation, Semantics preservation, Abstract interpretation, Pro\u00adjection 1. Introduction Staged programming, \nwhich explicitly divides a computation into separate stages, is a unifying principle for the existing \nprogram\u00adgeneration systems.Partialevaluation [21, 12], runtime code gen\u00aderation [16, 32, 26, 28], function \ninlining, and macro expansion [35, 18], are all instances of staged computation. There canbe arbitrarily \nmanystages, determinedby the nesting depth of program generations: stage 0 is for conventional non\u00adstaged \nprograms, anda programof stage0generatesa programof stage1that generatesa programof stage2,andso on.Aprogram \nofstage1 canbe broughttostage0forexecution. Thekeyaspect of multi-staged languages is to have code tem\u00adplates \n(program fragments) as .rst-classvalues. Code templates are freelypassed,stored, composedwithcodeofother \nstages,andexe\u00adcuted when appropriate.For this reason, multi-staged programming is also called meta-programming. \nMulti-staged programming is commonplace in mainstream pro\u00adgramming. Lisp(or Scheme) s quasi-quotation \nsystem [35, 18] is a fully .edged multi-staged system that has been evolved to com\u00adply with the demands \nfrom multi-staged programming practices. C s macros and C++ s templates are multi-staged features. C#, \nJavaScript, PHP, and Python support a form of multi-staged pro\u00adgramming, albeit a limited one. MetaOcaml \n[36] and Template Haskell [33] are extensions to ML and Haskell respectively to sup\u00adport multi-staged \nprogramming. However, static analysis of multi-staged programs (in order to, for example, .nd bugs or \noptimize) is mostly unexplored. Aside from static typing systems such as [25, 4, 13, 31, 3, 37], there \nare, as far as we know, no studies on more general and more power\u00adful semantic-based static analysis(\u00b4 \na la abstract interpretation) for multi-staged programs. The primary obstacle is the fact that the basic \nassumption of conventional static analysis no longer holds: the program text it\u00adselfis no longera .xed \nstatic entity,but rathera dynamically con\u00adstructedvalue. Conventional static analysis can .nitely estimate \nthe setof constructed code fragments,but we reacha stalemate after that. If the program executes the \ngenerated code, how can we stat\u00adically analyze the execution? The program text to analyze at this stageis \nnota usualtextbuta .nitely abstracted representationof the possibly in.nite set of generated code.  \nContribution As a solution to the problem, we present a semantic-preserving translation of multi-staged \ncall-by-value programs into un\u00adstaged programs and a static analysis framework based on this translation.We \nprove the translationis semantic-preserving in that every small-step reduction of a multi-staged program \nis simulated by the evaluation of its unstaged version. Thanks tothis translation we can analyze multi-staged \npro\u00adgramswithexistingstaticanalysis techniquesthathavebeende\u00adveloped for conventional unstaged programs: \nwe .rst apply the unstaging translation, then we apply conventional static anal\u00adysis to the unstaged \nversion, and .nally we cast the analysis results back in terms of the original staged program.  We present \na framework of safely projecting the static analy\u00adsis results of unstaged translated version back in \nterms of the original staged program. Once the projection s safety condition is satis.ed, we can use \nconventional static analysis for the un\u00adstaged language to achieve a static analysis for the multi-staged \nlanguage.  Our semantic-preserving translation handles staging constructs thathavebeenevolvedtobe usefulin \npractice (typi.edin Lisp s quasi-quotation): open code as values, unrestricted operations on references, \nand intentional variable-capturing substitutions. This article omits references, for which we refer the \nreader to our companion technical report.  We illustrate the problem and our solution using an example \nprogram.Intheexample,weuseLisp s quasi-quotesyntax[35]for staging constructs: backquote expression e \ndenotes program e as data (a program of the next stage), inside which, if any, comma ' expression ,e' \nreplaces itselfby the code result fromevaluating e. 1.1 Problem For example, consider the following two-staged \nprogram. x := 0; repeat x := (,x + 2) until cond; run x Variablex initially has code 0. The repeat statement \nrepeatedly assignsanewcodevalueto x. Theexpression (,x + 2) becomes a code value by plugging x s current \ncontents into the place of ,x . Thus after one iteration x contains (0+ 2), after two iterations (0 + \n2 + 2), and so on. Finally run x evaluates the x s code and returns a non-negative even integer. Now \nconsider statically estimating the above program. In order to estimate the value of the run x expression \nwe must estimate the set of possible code values that may be assigned to x. Suppose that the number of \niterations of the repeat statement is statically undecidable. Then .ow-insensitive static analysis, for \nexample, must somehow .nitely estimate the set of all possible, in.nitely manycode values { 0, (0+2), \n(0+2+2), \u00b7\u00b7\u00b7}. To .nitely approximate the in.nite set of code, suppose we use grammar-based abstraction \n[7, 29, 5]. Then the set of codefor x wouldbe approximatedbya grammar: S . 0 | S+2. However, in order \nto analyze the code run by the run x expres\u00adsion (at least by conventional analyses for unstaged programs), \nev\u00adery code implied by the grammar must be exposed .rst; that is, the grammar must be concretized. Since \nthe concrete image has in\u00ad.nitelymanycodevalues,such analysisis unrealizable.Adifferent static analysis \ntechnique that can evade such concretization trap is necessary.  1.2 Solution As a solution to the problem, \nwe present a three-step approach: translate, analyze, and project. To make this three-step approach correct, \nwe prove the translation semantic-preserving: the trans\u00adlated unstaged version simulates every evaluation \nstep of the orig\u00adinal staged program. And we show a sound condition for the pro\u00adjection to be correct, \ni.e., to be aligned with the correspondence induced by the translation. Here we will demonstrate these \nsteps with the motivating ex\u00adample just presented. Exact de.nitions, lemmas and theorems are presentedin \nSections2,3and4. Translation:The above example program is translated as x := ...0; repeat x := (.h.(...(h.)+2)) \nx until cond; (x {}) The translation works as follows. Code is translated into a function that explicitly \ntakes a record (for its environment) as an argument: 0 -. ...0 Hence, the runexpressionis translatedintoa \nfunction ap\u00adplication: run 0 -. (...0){} The function is applied to an empty record because only closed \ncode can be run. Free variables inside a code are translated to record access expressions.For example, \n x -. ....\u00b7x Code composition (,x + 2) is translatedtoafunction(for the resulting code)-generating application \nwhose actual pa\u00adrameter is the part for the code-to-be-plugged expression: (,x + 2) -. (.h.(...(h.)+2)) \nx The code value of x will be plugged into its corresponding hole (the place of h ). The ...(h.)+2 stands \nfor the resulting code. The application (h.) is for capturing the code s, if any, free variables by the \ncurrent environment. The evaluation of the unstaged version simulates that of the original staged program.Forexample, \nafter one iterationof the repeat statement, x has ...((...0).)+2. After two it\u00aderations, ...((...((...0).)+2).)+2, \nand so on. These functions correspondto codevalues (0+2) and (0+2+2) after the same numbers of iterations \nin the original staged program. Analysis: Because the translation removes all the staging fea\u00adtures, \nwe can apply conventional static analysis techniques to translated results. For example, suppose we estimate \nthe values of expressions by a simple .ow-insensitive value analysis with 0CFA. (We can apply any elaborate \nstatic analysis technique,but just for illustration this simple analysis is suf.cient.) We present the \nanalysis results in set-constraint style [19, 20].We write Vi or Vx for thevaluesofexpression i andvariable \nx respectively. Let us .rst label some expressions including lambdas:  x := ..1.0; repeat x := (.h.(..2.(h.2)1 \n+ 2)) x until cond; (x {})2 The analysis will deduce set constraints as follows.For brevity, we write \n..i omitting the body expression for lambdas (0CFA-closure values). From the .rst assignment statement, \nVx . ..1. From the assignment inside the repeat statement, Vx can also contain the value of the application \n(.h...) x , i.e., .h s body expression s value, which is ..2. Hence Vx . ..2. The parameter binding in \nthe application (.h....) x gives Vh . Vx, hence Vh . ..1 and Vh . ..2. Application expression (h .2)1 \n has values of called func\u00adtions body expressions. The called functions would be Vh, which has ..1 and \n..2. Thus, V1 . 0 (* Vh has ..1 and ..1 s body svalueis0*) V1 . V1+2. (* Vh has ..2 and ..2 s body s \nvalue is V1+2*) Similarly, from the application expression (x {})2 , V2 . 0 (* Vx has ..1 and ..1 s \nbody svalueis0*) V2 . V1+2. (* Vx has ..2 and ..2 s body s value is V1+2 *) The above constraints can \nbe understood as inductive rules for value sets. For example, the (in.nite) sets V1 and V2 are inductively \nde.ned as follows: V1 . 0 | V1+2 V2 . 0 | V1+2 Thus we can conclude that V1 and V2 consist of all non-negative \neven integers. Projection: Finally, the analysis results for the unstaged ver\u00adsion need to be cast back \nin terms of the original staged pro\u00adgram. Because code (backquote) expressions are translated into lambdas, \nsome lambdas in the above example analysis results correspond to the code expressions in the original \nstaged pro\u00adgram.Forexample, analysis result Vh for variable h has ..1 and ..2 which respectively correspond \nto code expressions 0 and (,x + 2). That is, code to be plugged into the place of ,x can be 0 and, recursively, \n(,x + 2). It is straightforward tokeep track of which lambdas in the unstaged version correspond to which \ncode expression in the staged original.We can, for instance, assign parameter names of such lambdas from \na unique namespace to identify the cor\u00adresponding code expression, such as, ..i for the lambda trans\u00adlated \nfrom code expression ei of index i. Regarding the projections, we cannot use arbitrary ones. Ar\u00adbitrary \nprojections of the static analysis results of the translated program can have images thatfail to qualify \nas static analysis results of the original staged program. Projection from abstract semantics of the \ntranslatedprogram to that of the subject pro\u00adgram must be a safe approximation of its concrete counterpart \n(projection from concrete semantics of the translated program to that of the subject program). Section4presents \nthe formal\u00adization of this condition and an analysis example. Comparisons Translation: Davies and Pfenning \ns unstaging translation [13] works only for closed code. Their translation does not sup\u00adport open code \nand intentional variable-capturing substitution at stages > 0 ( unhygienic macros). This feature, which \nmay be unacceptable in a purely functional language, has long been used in practice (for example by Lisp \ns quasi-quote program\u00admers) for ef.ciency programming convenience. Kameyama et.al [23] s translation \nsupports open codebut theydo not pro\u00advide an observational equivalence; hence it is not adequate for \nour purpose: a round-about static analysis approach for multi\u00adstaged programs. Our unstaging translationisa \nre.nementof [1].We prove only two kinds of administrative reductions suf.ce whose ex\u00adhaustive application \nreaches the admin-normal form. We also de.ne an inverse translation that converts expressions in the \nadmin-normal form back to the original staged expression.  Static analysis: Most static analyses for \nmulti-staged programs are string analyses for programs that generate code as strings, but theyare limited \nto estimate only the shape, notthe seman\u00adtics, of generated code by using a grammar [7, 29, 5] or the \nparsing stack [15]. Such string analyses do not analyze the se\u00admantics of the generated code string. \n Multi-staged static type systems [13, 37, 25, 40] and their inference algorithms can be considered \nsound static analyses, but extending them for analyzing other behavior than types (\u00b4 a la effect type \nsystems [27, 22, 39]) is also constrained by the aforementioned in.nite-concretization trap. Any extension \nto estimate other properties than types is limited to those that can proceed without analyzing the semantics \nof the generated code. Existing multi-staged static type systems can evade the in.nite concretization \ntrap because typing the execution of the generated code (for expression such as run e)does not have to \nanalyze the generated code itselfbut can just pick up the type from the generated code s type.  1.3 \nOrganization Section2 de.nes the subject call-by-value multi-staged language .S and the target unstaged \nrecord language .R. Section3de.nes and proves semantic-preservation of the unstaging translation from \n.S to .R. Section4presentsa condition for safe projection. Sec\u00adtion5discusses relatedworks. Section6concludes. \n2. Languages In this section we give the formal de.nitions of the subject staged language .S and the \ntarget record language .R. For each, we present the syntax, operational semantics and the type system. \n 2.1 Multi-Staged Language .S The language .S is a typed, call-by-value .-calculus with staging annotations. \nIt is based on .sim [25], simpli.ed by removing open hygienic code composition (i.e.. *), mutable reference, \nand the lift operation. Also, the unbox operator is restricted to1stage. In this work our focus is not \non polymorphism. Thus, we omit let-bindings from the syntax; we use them in the examples as a syntactic \nsugar for application.  De.nitions 1 Value0 v0 ::= i | .x.e | fix f x.e | box v nn Valuen (n> 0) vn \n::= i | x | .x.vn | vv| fix f x.vn n+1 n-1 | box v| unbox v(n> 1) n | run vOperational Semantics (n = \n0) nn '' e1 -. ee -. ev . Valuen 1 (APP) n n ' ' e1 e2 -. e1 e2 ve -. ve 00 (.x.e) v -. [x .v]e 00 0 \n(fix f x.e) v -. [x .v][f .fix f x.e]e n+1 ' e -. e (BOX) n ' box e -. box e n ' e -. ev . Value1 FV \n0(v)= \u00d8 (RUN) n ' 0 run e -. run e run (box v) -. v n ' e -. ev . Value1 (UNB) n+1 1 ' unbox e -. unbox \ne unbox (box v) -. v n+1 ' e -. e (ABS) n+1 .x.e -. .x.e ' n+1 ' e -. e (FIX) n+1 fix f x.e -. fix f \nx.e ' Figure 1. Operational Semantics of .S. Syntax Variable x, y, f . VarS ExprS e ::= i | x | .x.e \n| ee | fix f x.e | box e | unbox e | run e The syntax of .S is given above. The language contains constants, \nvariables,lambda abstraction, application, and the .xpoint operator fix. Finally, there are staging annotations: \nbox is used to de.ne code templates. unbox is the escape operator that de.nes a hole insideacode template \nwhichis .lledin with another code template. box and unbox operators can be arbitrarily nested. run executes \na code template. Operational Semantics .S has a small-step, call-by-value, operational semantics. Evalua\u00ad \nn tion rules of the language are in Figure 1. The evaluation e -. e ' has the meaning that theexpression \ne isevaluated to e ' at stage n. Values areexpressions that cannotbe reduced further.Values are de.nedforall \nstages.Atstage0,valuesare constants, functionsand code templates.Acode templateisafrozenexpression withina \nbox annotation. Inside code templates, holes denoted by the unbox are .lled in by evaluating the unboxed \nexpression to a code template. In other words, code templates are composed using the unbox operator. \nOnly stage-1 holes can be .lled in. Once all the holes are .lled,a code template becomesa box-value.Acode \ntemplate can be evaluated at stage 0 by run. Code to run must not have any free variable. FV 0(e) in \nthe (RUN) rule denotes the set of free variables in stage-0 expression e, to which none of e s sub\u00adexpression \nof stage > 0 contributes. .S extends lambda calculus conservatively.At stage0, (APP)is the same as thetraditional \nsubstitution-based call-by-value seman\u00adtics. Alpha conversion and beta reduction are available at stage-0. \n(CONt) G0 ... Gn fS i : . Gn(x)= T (VARt) G0 ... Gn fS x : T G0 ... Gn + {x : T1}fS e : T2 (ABSt) G0 \n... Gn fS .x.e : T1 . T2 G0 ... Gn + {x : T1} + {f : T1 . T2}fS e : T2 (FIXt) G0 ... Gn fS fix f x.e \n: T1 . T2 G0 ... Gn fS e1 : T1 . T2 G0 ... Gn fS e2 : T1 (APPt) G0 ... Gn fS e1 e2 : T2 G0 ... Gn, G \nfS e : T (BOXt) G0 ... Gn fS box e : D(G I T) G0 ... Gn fS e : D(Gn+1 I T) (UNBt) G0 ... Gn, Gn+1 fS \nunbox e : T G0 ... Gn fS e : D(\u00d8I T) (RUNt) G0 ... Gn fS run e : T Figure 2. Type System of.S . Type \nSystem Figure2showsamonomorphic type system for .S .Apolymorphic type systemis alsoavailable [25].Typesin \n.S are de.ned as below. TypeS T ::= . | T . T | O(G > T) .n Type EnvironmentS G . VarS . TypeS We useT \nto denote type terms, . for base types, T . T for function types, O(G > T) for code template types, G \nfor type environments. Acode template is given a box-typeO(G > T) with the meaning that the code template \nwill evaluate to a value of type T if putina context that provides the environment G. The type environment \nG in the box-type O(G > T) contains the types of the unbound variables in the code template. A type environment \nG is a mapping from variables to types. G+ {x : T} is a function update operation that de.nes a function \nas follows: (G + {x : T})(x)= T and (G + {y : T})(x) = G(x) if x fS e : T with = y.Atyping judgment has \nthe form G0 ... Gn the meaning that a stage-n expression e, under type environments G0 ... Gn, has type \nT. G0 ... Gn is a sequence of type environ\u00adments. Each type environment corresponds to a stage where \nGn is the current(i.e. most recent)typeenvironment.Foraproofofthe soundness of this type system and its \nlet-polymorphic extension, see [25].  2.2 The Record Calculus .R The language .R is a .-calculus with \nrecord operations. As the target language of our translation, it is suf.cient for the record ex\u00adpression \nto have only variables and values. As opposed to .S, we include let-bindings in .R. This is to be able \nto syntactically dis\u00adtinguish several .R expressions during inverse translation (Section 3.3). The language \nis still monomorphic. Syntax Variable . . VarP (record variables) h . VarH (hole variables) x, y, f \n. VarX = VarS (ordinary variables) w . VarR = VarX . VarP . VarH Label x . Label = {x|x . VarX } (ordinary \nvariables in typewriter font) Operational Semantics RR '' -. ee -. e 1 (APPR) e1 RR '' e1 e2 -. e1 e2 \nve -. ve R (.w.e) v -. [w .v]e R (fix f x.e) v -. [x.v][f .fix f x.e]e R ' e1 -. e1 (LETR) R ' let w \n= e1 in e2 -. let w = e1 in e2 R let w = v in e -. [w .v]e R (ACCR) vr \u00b7x -. vr(x) Record Lookup j ' \nv if vr = v +{x =v} r vr(x)= '' v (x) if vr = v +{y = } and x =.y rr Figure 3. Operational Semantics \nof .R. ExprR e ::= i | w | .w.e | ee | fix f x.e | r | r\u00b7x | let w = e in e ValueR v ::= i | .w.e | fix \nf x.e | vr Record ValueR vr ::= {} | vr +{x = v} RecordR r ::= {} | . | r+{x = x}| r+{x = v} The record \nlanguage .R has constants(i),variables(x),lambda ab\u00adstractions, applications,a.xpoint operator fix,and \nlet-expressions. As for the record operations there are empty records({}), record variables(.), and the \nrecord update operation r+{x = }.For .eld names (or labels) in records, we use variables written in teletype \nfont. We separate variables into three disjoint sets: ordinary variables VarX (which are the same as \nvariables of .S), record variables VarP , and hole variables VarH . This syntactic distinction makes \nour presentation of the inverse translation in Section 3.3 easier. The operational semantics does not \nneed to make a distinction; all variables are treated uniformly. Operational Semantics .R hasasmall-step, \ncall-by-value operational semantics. Theeval-R uation e -. e ' means that the expression e evaluates \nto expres\u00adsion e ' . The operational semantics of .R is mostly standard. Eval\u00aduation rules and the de.nition \nof values are given in Figure 3. Type System Amonomorphic type system for.R isgivenin Figure4.Types are \nde.ned as follows: TypeR Record Type T Tr ::= . | T . T | Tr . Label .n . TypeR Type EnvironmentR G . \nVarR .n . TypeR There are base type and function types as usual.Arecord typeisa mapping from .eld labels \nto types.Type environments are similar to those for .S. (CONtR) G fR i : . (VARtR) G(w) = T G fR w : \nT (ABStR) G + {w : T1} fR e : T2 G fR .w.e : T1 . T2 (FIXtR) G + {x : T1} + {f : T1 . T2} fR e : T2 G \nfR fix f x.e : T1 . T2 (APPtR) G fR e1 : T1 . T2 G fR e2 : T1 G fR e1 e2 : T2 (LETtR) G fR e1 : T1 G \n+ {w : T1} fR e2 : T2 G fR let w = e1 in e2 : T2 (EMPtR) G fR {} : \u00d8 (UPDtR) G fR r : Tr G fR e : T G \nfR r+{x =e} : Tr + {x : T} (ACCtR) G fR r : Tr Tr (x) = T G fR r\u00b7x : T Figure 4. Type System of.R. 3. \nTranslation In this section we present how staged expressions can be repre\u00adsented with record calculus \nexpressions. We begin with an observation: Boxed expressions are not exe\u00adcuted theyremain frozen until \ntheyare run. This notion is very similar to closures; closures are not executed until they are applied \ntoan operand.This observationhintsthatboxedexpressionscanbe represented as functions. The second observation \nis that when an unboxed expression is replaced with a code template (see rule UNB in the operational \nse\u00admantics),thefreevariablesinthecode templatemaybe capturedby the surrounding expression. In other words, \nthe surrounding boxed expression provides the code template with an environment that carries the meaning \nof the free variables in the code template. Combining the two observations, we can then represent a boxed \nexpression as a function whose parameter is an environment. Pro\u00adviding an environment to a boxed expression \n(as in the case of un\u00adboxing)is then nothingbuta function application where the opera\u00adtor is the boxed \nexpression and the operand is the environment. The next question is howto represent environments. The \nanswer is trivial: as records.A variable occurrence then becomesa lookup in the current environment (i.e. \nrecord), and a binding is an update to the current environment (i.e. record). Our translation at the \ntype level translates code expression of type O(G > T) into function expression of type G . T, where \nG is a record type for G and T is a translated type for T. To give a few examples, consider the expressionbox \nx. It can be represented as ....\u00b7x, where the value of x is being obtained from the environment .. The \nexpression box (let x = 42 in unbox (box x)) can be represented as .. ' .(....\u00b7x){x = 42}. Note how the \nunbox expression becomes a function application. As a special case, run becomes an application where \nthe argument  box (... unbox ( \u00b7 ) ... unbox ( \u00b7 ) ...) | {z } (.h1.(.h2.(... ... h1 . ... h2 . ...))( \n Figure 5. Illustration of the translation of a box expression with two unboxes. is the empty environment, \nbecause only closed expressions can be executed.For example, run (box 42) becomes (...42){}. To illustrate \nhow variable capturing is handled, let us now take the following example. let a = box x b = box (.x..y.(unbox \na)+y) in (run b)11 In theexample, thevalueof b will be box (.x..y.x+y). Note how thevariable x,whichwas \nfreeinbox x,is captured. Continuing the evaluation, run b will reduce to the function .x..y.x+y,resulting \nin a .nal value of 2. Based on the translation described, the example above is trans\u00adlated as below: \nlet a = ....\u00b7x b = ....x..y.(a (. + {x = x, y = y}))+y in (b {})11 Both box expressions are converted \nto a function that takes as parameter an environment, .. In the .rst line, the occurrence of x is free. \nSo it is translated to a lookup operation in .. The occurrence of y in the second line is not free, hence \nit is left as it is. The unbox expression becomesafunction application wherethe operandisthe environment \n. updated with the bindings of x and y. Finally, the run expression is translated to an application to \nthe empty record. When evaluated, the translation reduces to 2, too. Order of Evaluation In the staged \ncalculus, unbox expressions inside box are evaluated to code templates. When translated to record calculus \nas discussed above, however, the contents of a box become guarded under a lambda abstraction and hence \nare not evaluated. Consider the fol\u00adlowing example box (unbox ((.x.x) box 1)) 0 -. box (unbox (box 1)) \n0 -. box 1 The translation of box (unbox ((.x.x) box 1)) would be ...((.x.x) ...1)., whichis alreadyavalue \nand does notevaluate further. So, the order of evaluation (in the call-by-value semantics) is perturbed \nby the translation. This would incur a serious problem in the presence of expressions with side-effects. \nTo preserve the order of evaluation, the translation has to move the expression inside unbox to the outside \nof the enclosing box, as illustrated in Figure 5. To do this, every unbox expression is replaced with \na hole variable h and a context in the form of (.h.[\u00b7]) e, where e is the translation of the unboxed \nexpression, is created so that the inside of the context can be .lled in with the translation of the \nenclosing box. Because e is at the argument position of a function, the call-by-value semantics of the \nrecord calculus evaluates e .rst and then handles the rest. The correct translationof theexample aboveis(.h....h \n.) ((.x.x)...1). Our translation to preserve the order of evaluation is similar to Davies and Pfenning \ns [13]. They suggested the translation from the implicit modal language Mini-ML0, which is similar to \n.S , to the explicit modal language Mini-ML0e . Their target language is still staged whereas ours is \nthe record language with no staging. Kameyamaet.al[23]alsodevelopedasimilar translationthat trans\u00adlates \n2-staged programs to SystemFwith tuples. More details on the related work are given in Section 5. Admin \nReductions Let us examine the evaluation of the expression above in small steps. (.h....h .) ((.x.x)...1) \nR -. (.h....(h.))(...1) R -. ...((...1) .) The .nal value, ...((...1) .), is not directly the translation \nof box 1;thereis stillareducible term,(...1).,insidealambda. This residual term is seen because of the \nfollowingfact: In the staged calculus, when an unbox expression evaluates to a code template, the code \ntemplate immediately (i.e. in one step) replaces the unbox expression.Ontheotherhand,inthe record calculus,theunboxex\u00adpression \nbecomesanargumenttoafunction,in whichtheargument is applied to an environment.Passing the argument to \nthe function takes one step of evaluation (i.e. substitution). The application of the argument to the \nenvironment still remains, and is, infact, the residual term that needs to be reduced via further action. \nThis kind of a reduction is called an admin reduction . Admin reductions simplify the record calculus \nterms and bring them to a form that is the direct resultofatranslation.In general,beta-reductionofanap\u00adplication \nwherethe operatorisalambdaexpressionandthe operand is a record is an admin reduction; this reduction \nmay happen any\u00adwhere, including inside lambda abstractions. The example above is admin-reduced as follows, \nwhere the admin-reducible term is un\u00adderlined. Note that the resulting term, ...1, is directly the transla\u00adtion \nof box 1. A ...((...1) .) -. ...1 There are two kinds of admin reductions. The .rst is the one explained \nabove. The second is related to variable capture. Recall that when a code template replaces an unbox \nexpression, the free variables are captured.Afreevariable becomesalookupexpression in the current environment \nafter the translation. Such lookups need toberesolved(afterahole replacement).Thisisdonebythesecond kindof \nadmin reduction. Figure6showsa tracethatbelongstothe .rstexamplegiveninthis section. Both kindsof admin \nreductions are used. Admin-reducible terms are again underlined. Figure 7 shows the evaluation of the \noriginal staged expression. Note that anytermin Figure7translatestoa termin Figure6. The formal de.nitions \nof the translation and admin reductions are given in the next section. 3.1 Translation De.nition The \ntranslationis presentedin Figure8.Atranslation judgmenthas the form R f e . (e, K) with the meaning that \na .S expression e,underenvironment stack R,translates to the.R expressione and the context stack K. An \nenvironment isasubsetofarecordexpressionthatassociates .eldstovariables.Itkeepsthe informationof whichvariableshave \nbeen bound so far. Each stage has a corresponding environment, held in the environment stack. Hence, \nthe translation of a stage\u00adn expression involves a stack of length n +1. The rightmost (or topmost) environment \nin the stack corresponds to the current stage. An expression that binds a variable updates the environment \nwith the new binding. Lambda abstraction and fix are such ex\u00ad  let a = ....\u00b7x b =(.h.....x..y.(h (. \n+ {x = x, y = y}))+y)a in (b {})11 R -. let b =(.h.....x..y.(h (. + {x = x, y = y}))+y)(....\u00b7x) in (b \n{})11 R -. let b = ....x..y.((....\u00b7x)(. + {x = x, y = y}))+y in (b {})11 A -. let b = ....x..y.(((. + \n{x = x, y = y})\u00b7x))+y in (b {})11 A -. let b = ....x..y.x+y in (b {})11 R -. ((....x..y.x+y) {})11 R \n-. (.x..y.x+y)11 R -. (.y.1+y)1 R -. 1+1 R -. 2 Figure 6. Reduction trace of the example expression after \nthe unstaging translation. Admin-reducible terms are underlined. let a = box x b = box (.x..y.(unbox \na)+y) in (run b) 1 1 0 -. let b = box (.x..y.(unbox (box x))+y) in (run b)11 0 -. let b = box (.x..y.x+y) \nin (run b)11 0 -. (run (box (.x..y.x+y))) 1 1 0 -. (.x..y.x+y)11 0 -. (.y.1+y)1 0 -. 1+1 0 -. 2 Figure \n7. Reduction trace of the example staged expression. Any term in this trace translates to a term in Figure \n6. pressions (see rules TABS and TFIX). A box expression starts a newenvironmentbyputtinga freshenvironmentvariableontopof \nthe environment stack. Dually, unbox chops offthe topmost envi\u00adronment from the stack. The notionofa \ncontext was informally discussed in the previous section. A context ((.h.[\u00b7]) e) corresponds to unbox \ne where e is the translation of the unboxed expression e. Contexts are used for putting the unboxed expression \noutside their enclosing box expressions so that the evaluation order is preserved. The variable that \na context binds, that is h, is a fresh variable that replaces the original unbox in the translation. \nNote that there may be multiple unbox expressions at a particular stage, e.g. box (unbox (e1)+ unbox \n(e2)). Therefore, contexts are de.ned recursively, as in ((.h..) e). Thisway,a contextis abletokeep information \nabout multiple unbox expressions in a stage, while still preserving their relative order of evaluation. \nAlso note that unbox expressions can be nested, e.g. box (box (unbox (unbox e))). The translation, De.nitions \nEnvironment r ::= {} | . | r+{x =x} Environment Stack R ::= .| R, r Context . ::= ((.h.[\u00b7]) e) | ((.h..) \ne) Context Stack K ::= .| K, . Environment Lookup 8 ' < x if r = r +{x =x} ' r(x)= r ' (x) if r = r +{y \n= } and x .= y : .\u00b7x if r = . TermTranslation (TCON) R f i . (i, .) (TVAR) R, r f x . (r(x), .) R, r+{x \n=x}f e . (e, K) (TABS) R, r f .x.e . (.x.e, K) R, r+{x =x}+{f =f}f e . (e, K) (TFIX) R, r f fix f x.e \n. (fix f x.e, K) R f e1 . (e1,K1) R f e2 . (e2,K2) (TAPP) R f e1 e2 . (e1 e2,K1 M K2) R, . f e . (e, \n(K, .)) (TBOX) new . R f box e . (.[...e],K) R, . f e . (e, .) new . R f box e . (...e, .) R f e . (e, \nK) (TUNB) new h R, r f unbox e . (h r, (K, (.h.[\u00b7]) e)) R f e . (e, K) (TRUN) new h R f run e . (let \nh = e in (h{}),K) Context Stack Merge Operator . M K = K KM . = K (K1,.1) M (K2,.2) = (K1 M K2), (.1[.2]) \nFigure 8. Translation from.S to .R. therefore, produces context stacksinsteadofa single context. Each \ncontext in the stack corresponds to a stage. The contexts in a stack are positioned in the following \norder: The context of the stage that is immediately lower than the current stage is positioned at the \nrightmost side; stages go lower (i.e. get closer to 0) as we go left. Thestage closestto0is locatedatthe \nleftmostsideofthe stack. New contexts in the translation are populated by unbox ex\u00adpressions (see rule \nTUNB). A fresh hole variable is also gener\u00adated as a placeholder for the unboxed expression. The translation \nof a box expression pulls the topmost context from the stack and puts the translated expression inside \nthis context. The translation of expressions with no subexpressions (e.g. variables) results in empty \ncontext stacks, since there are no unbox contained within the expression. The translation of expressions \nwith single subex\u00adpressions (e.g. abstraction) simply threads the context stack that results from the \ntranslation of the subexpression. The translation of expressions with more than one subexpression (e.g. \napplication) merges the context stacks resulting from the translation of subex\u00adpressions. A context stack \nmerge operation respects the order of appearance, hence serves the preservation of the order of evalua\u00adtion. \nWhen discussing the translation informally, we converted run toa function application,butin the formal \nde.nition we translate to a let-expression. The difference is merely syntactic; we want to be able to \ndistinguish translations of run from unbox so that the inverse translation can properly translate expressions \nback.  3.2 Semantics Preservation In this section we formally makethe connection between semantics \nof .S and .R through the translation.For complete proofs for lem\u00admas and theorems, we refer the reader \nto the companion technical report [6]. Recall that a translation yields a pair of an expression and a \ncontext stack. This pair can be constructed into a single expression using a context closure operation: \nDe.nition 1. (Context Closure) Let e be a .R expression and K be a context stack. The context closure \nK(e) is de.ned as follows. j K ' (.[e]) if K =(K ' ,.)K(e) = e if K = . In Section3 we discussed the \nneed for admin reductions; here we give the formal de.nition: De.nition 2. (Admin Reduction) Administrative \nreduction of an expression is a congruence closure of the following two rules: A (APP) (...e) r -. [..r]e \nr = . (ACC) A r\u00b7x -. r(x) The de.nition of administrative reductions also extends to contexts and context \nstacks. Note that an administrative reduction may happen anywhere, even under lambdas. Also note that \nan admin reduction is safe to per\u00adform, in the sense that no side-effecting or non-terminating expres\u00adsion \nis eliminated by an admin reduction. It is also straightforward to check that admin reductions terminate. \nDe.nition 3. (Admin-normal form) An expression e is said to be in admin-normal form iff there does not \nexist any e ' such that A e -. e ' . An important observation is that a translated expression does not \ncontain anyadmin-reducible terms: Lemma 1. Let e be a .S expression suchthat R f e . (e, K) for some \nR. Then, K(e) is in admin-normal form. Proof. By structural induction on e [6]. Notation 1. The Kleene \nclosure of admin reductions is denoted as A * -.. R;A * Notation 2. We use-. to denote sequential application \nof one step of eager evaluation followed by exhaustive administrative re\u00adductions. Exhaustive admin reductions \nare those that bring an ex\u00adpression to the admin-normal form. Next, we showthe relation between the operational \nsemantics of .S and .R:Given a.S expression e, we can .rst translate e, then evaluateitin record language \nsemantics followedby applicationof admin reductions, and we will have obtained the translation of the \nexpression thate evaluates to in the staged semantics. Furthermore, the admin reductions that we apply \nare exhaustive; we do not need toworry aboutoversimpli.cation. This relationis formally stated in Theorem1and \nillustratedin Figure9. Two properties are critical to prove the semantic preservation. First, the translation \npreserves the substitution operation. n ee ee' R;A * =. ' e e 1 1 e ' e Figure 9. Relation between \n.S and .R operational semantics. TypeTerm T1 . T1 T2 . T2 G . Tr T . T . . . T1 . T2 . T1 . T2 D(G I \nT) . Tr . T RecordTypeTerm G . Tr T . T \u00d8 . \u00d8 G+ x : T . Tr + {x : T} Figure 10. TypeTranslation. Lemma \n2. (Substitution Preservation) Assume e1 is a stage-n .S expression, e2 is a stage-0 .S expression with \nno free variables. Let r0 ...rn f e1 . (e1,.p ....1) for p = n and {} f e2 . (e2, .) where r0 is suchthat \nr0(x)= x for some variable x. Then 0 If n =0 then r0 f [x.e2]e1 . ([x.e2]e1, .). n If n>p then r0 ...rn \nf [x .e2]e1 . (e1,.p ....1). n If n = p then r0 ...rn f [x.e2]e1 . (e1, (. ' p,.p-1 ....1)) where . ' \np =[x.e2].p. Proof. By structural induction on expression e1 [6]. Second, the translation preserves the \nvariable-capturing reduc\u00adtion which happens in .S because of open code. Lemma 3. (Variable-Capturing \nPreservation) Assumee isastage\u00adn .S expression and S is a substitution where S =[. . r]. Let r0 ...rn \nf e . (e, K) and S(r0 ...rn) f e . (e ' ,K ' ). Then, A * A * Se -. e ' and SK -. K ' . Proof. Bystructural \ninduction on e [6]. The substitution operations (S(r0 ...rn),Se,andSK)are the usual compositional, homomor\u00adphic \noperations. Finally we give the simulation theorem that shows our transla\u00adtionis semantics-preserving.An \nillustrationof this theoremisgiven in Figure 9. Theorem 1. (Simulation) Let e be a stage-n.S expression \nwith n no free variables such that e -. e '. Let R f e . (e, K) and R;A * ''' '' R f e . (e ,K ). Then \nK(e) -. K (e ). n Proof. By induction on the evaluation e -. e ' using Lemma 1, Lemma2and Lemma3.For \ncomplete proof, see[6]. Type Translation Arelation between the two languagesexists not only between their \noperational semantics but also between their type systems. The translation preserves the typability of \nan expression: If a .S ex\u00adpression is typable in the .S type system, its translation is typable in the \n.R type system. The type translation is a straightforward conversion that converts all the box-types \nin a .S type to arrow types. (Figure 10) Theorem 2. (Type Correctness) Let e be a stage-0 .S expression \nwith no free variables suchthat \u00d8 fS e : T. If R f e . (e, .) then \u00d8 fR e : T.  De.nitions Hole Environment \nH : VarH . ExprR TermTranslation (IVAR) H f x . x (IACC) H f e\u00b7x . x H f e . e (IABS) H f .x.e . .x.e \nH f e . e (IABS) H f fix f x.e . fix f x.e H f e1 . e1 H f e2 . e2 .e2 ./RecordR e1 = .h.e (IAPP) H \nf e1 e2 . e1 e2 ' H .{h : e }f e . e (ICTX) ' H f ((.h.e) e ) . e H f e . e (IBOX) H f ...e . box e H \nf H(h) . e (IUNB) H f hr . unbox e H f e . e (IRUN) H f let h = e in (h {}) . run e Figure 11. InverseTranslation \nfrom .R to .S . For a proof of this theorem, see [1, 38].  3.3 InverseTranslation We have so far seen \nhow a .S expression can be translated to a .R expression and how the two expressions relate. We can also \ntranslate a .R expression back to .S.With such an inverse trans\u00adlation, we can not only translate a .S \nexpression and evaluate the result using recordlanguage semantics as we saw in the previous section,but \nalso translatetheevaluation result backto .S without ever having to evaluate the original .S expression. \nThe de.nition of the inverse translation is in Figure 11. An inverse translation judgment is in the form \nH f e . e with the meaning that under the hole environment H, the .R expression e translates to the .S \nexpression e. Ahole environment is a function that associates hole variables with expressions. Recall \nthat a forward translation replaces an unbox expression with a hole variable h and moves the unboxed \nexpression outside the enclosing box. A hole environment maps the hole variable to the expression that \nwas moved out so that we can convert the hole variable back to an unbox expression. This is done in the \n(IUNB) rule. Note that in inverse translation we have a single environment as opposed to having a stack \nof environments (and stack of contexts) in the forward translation. There are two reasons for this: (1) \nThere is no notion of stages in .R. (2) All the hole variables are freshly generated by the forward translation \nand theyare used only once each in unique locations. Hence, it suf.ces touseasingle functiontokeepthe \ninformationaboutholevariables and associated expressions. Thekeypointsof theinverse translation are the \nfollowing: Record lookupexpressions are converted backtovariables (rule IACC).  Alambda abstraction \nthat has a record variable as its parameter is converted to a box expression (rule IBOX).  e e e ' e \nn e ' =. 1 e R;A * e e ' Figure12. Givena .S expressione,we canevaluate its translation in the .R semantics \nand then translate the result back to obtain the result that we get from evaluation of the original expression \ne. Afunction application where the operator is a hole variable is converted to an unbox expression (rule \nIUNB).  Anew mapping is added to the hole environment when trans\u00adlating a function application where \nthe operator is a lambda ab\u00adstraction whose parameter is a hole variable (rule ICTX).  Note that the \nrules of inverse translation are not ambiguous; each rule matchesa unique syntactic category.For instance,even \nthough (IABS) and (IBOX) are both de.ned for lambda abstrac\u00adtions, in the former, the bound variable \nis a regular variable and in the latteritisa recordvariable. Thesetwovariables come from dis\u00adjoint sets \nand are syntactically differentiable. Similarly, hole vari\u00adables are syntactically distinguishable. This \ndistinctionofvariables helps us have an unambiguous coverage of expressions. Tomakethe connection between \nforward translation and inverse translation, we .rst de.ne how to interpret context stacks as hole environments. \nDe.nition 4. (From Contexts to Hole Environments) Let K be a context stack. The operation K de.nes a \nhole environment in the following way: j \u00d8 if K = . j ' K = K. . if K = K ' ,. {h : e} if . =(.h.[\u00b7]) \ne . = . ' .{h : e} if . =(.h.. ' ) e The lemma below states that we can translate a .S expression to \n.R and then translate the result back to .S to obtain the same expression. Theorem 3. (Inversion) Let \ne be a .S expression and R be an environment stack. If R f e . (e, K), then H f e . e for any H suchthat \nK . H. Proof. By induction on the structure of e [6]. Combining Theorem1with Theorem3givesa stronger \nresult: not only that the evaluation of translated .R-program simulate every reduction step of the original \n.S -programbut also thatevery intermittent .R-expression occurring in the simulation steps can be projected \nback to its corresponding .S-expression of the .R \u00adevaluation (Figure 12). Theexistenceof suchinversionfacilitates \nour development of the projection step, which is the topic of the next section. 4. Projection Among our \nthree-step (translate, analysis, and project) approach to analyze multi-staged programs, the .rst two \nsteps have sound foundations. Since we have proven that the translation is semantic\u00adpreserving, statically \nanalyzing translated programs can replace an\u00adalyzing the original subject programs. The analysis for \nthe trans\u00adlatedunstaged programscanbeproven correctusingaconventional static analysis framework such \nas abstract interpretation [9, 10]. The last step, projecting the analysis results back in terms of the \noriginal staged program, needs a condition for its safety. Arbitrary projections can have images that \nfail to qualify as static analysis resultsofthe originalstaged program.Forexample,staged program run \n0 is translated into an application (...0){}, and the binding of the empty record to variable . has no \ncounterpart in the original staged program s semantics. Hence, a projection whose image is only such \nan extra binding effect is clearly not a static analysis result of the original program.  A noticeable \npoint about the safety of projections is that the safety is de.ned in reference to a static analysis \nof the original staged program. Checking whether the projection image quali.es tobeastaticanalysisresultoftheoriginalstaged \nprogramneedsthe static analysis de.nition. This requirement is not a dilemma; static analysis can always \nbe de.ned, though it may not be realizable. Asuf.cient condition for projection safety is easy to see \nonce wemodelstaticanalysisintheabstract interpretationframework[9, 10]. Let e be a multi-staged program \nand e be its translated un\u00adstaged version. Let [ e] . DS and [ e] . DR be their concrete semantics over \nconcrete domains DS and DR respectively. Static analyses of e and e are computationsof abstract (approximate)ver\u00ad \n sions of the concrete semantics. Let [ e] . DS and [ e] . DR be the abstract semantics. Each pair of \nconcrete and abstract domains is Galois-connectedby anadjoined pairof abstraction(a and a) and concretization \nfunctions(. and .).Aconcrete (resp. abstract) projection p (resp. p )is a monotonic function from DR \nto DS (resp. D R to D S ). The following diagram summarizes the setting: . e e [ e] . DS -..- a DS . \n[ e] p p 1 . e [ e] . DR .- [ e] -.DR . a Asafety condition for the abstract projectionp is as follows. \nTheorem 4. (Safe Projection) Let e and e be,respectively,astaged program and its translated unstaged \nversion. If [ e] . p[ e] and a . p . . . p then a[ e] . p [ e] . Proof. Bythe .rst condition and the \nabstraction functiona smono\u00adtonicity (because of the Galois connection), a[ e] . (a . p)[[e] , which, \nby the monotonicity of a and p, and by the correctness of [ e] , is . (a . p . .)[ e] , which, by the \nsecond condition, is . p [ e] . These conditions are not particularly constraining. Concrete projection \np that satis.es the .rst condition [ e] . p[ e] always exists. Suchp is the inverse translation function \nin Section 3.3 com\u00adposed with an eraser function that .rst .lters out from [ e] , if any, extra things \noutside [ e] . Such composition satis.es the condition because (1) [ e] always includes [ e] since the \ntranslated program e simulates every reduction step of e and(2)by Theorem3. The sec\u00adond condition is \nanalogous to the usual correctness condition for an abstract operation in the abstract interpretation \nframework. Once the above conditions are satis.ed, we can concentrate on de.ning an abstract analysis \nof .R programs without considering staged constructs. Analyzing the translated program and applying the \nabstract projection p to the analysis result achieves a safe analysis result of the original staged program. \n 4.1 Example Consider the following staged program e. As in Section1we use Lisp s quasi-quote syntax \n[35] for staging constructs. let x = 0 (* indexed as .1 *) y = (,x + 2) (* indexed as .2 *) in run y \nThe translated version e, is let x = ..1.0 y =(.h.(..2.(h.2)+2)) x in y{} First we consider the three \nconcrete components: concrete se\u00admantics [ e] and [ e] and concrete projection p. The concrete se\u00admantics \nof the two programs are collecting semantics: collections of values of expressions and variables. [ e] \n: Collecting semantics [ e] of the staged original has entries such as: x has 0 y has (,x + 2) where \n,x has 0 (run y) has 2 [ e] : Collecting semantics [ e] of the translatedversion has en\u00ad tries such \nas: x has (..1.0, \u00d8) (* closure value *) y has (..2.(h.2)+2, {h .(..1.0, \u00d8)}) h has (..1.0, \u00d8) .1 has \n{} (* empty record *) .2 has {}(y {}) has 2 p: Projection p that satis.es [ e] . p[ e] is straightforward: \nit forgets extra bindings (for h, .1, .2)and projects closure value (..i, s) to code expression i whose \nunbox (comma) expression s code are those projected from the environment s. Projecting the closure values \nof .R into code values of .S is essentially identical to the inverse translation in Section 3.3. That \nis, p projects closure values as follows: (..1.0, \u00d8) to 0 32 ( ..2.(h.2)+2, (,x + 2) {h .(..1.0, \u00d8)} \n5 to 4 where the ,x position has ) 0 Now we consider the abstract components: [ e] , [ e] , and p . Note \nthat the static analysis will compute [ e] and project its results by p back in terms of the abstract \nsemantic domain of [ e] . The abstract semantics [ e] ofthe original staged programisonlyamathematical \nde.nition that will be referenced in checking the safety of p . [ e] :For the abstract semantics [ e] \nof the original staged pro\u00adgram e, suppose we abstract a set of code values into a regular term grammar \n[17, 8]. Inaregularterm grammar,each production srhsis f(t, ..., t) wherethe functionsymbol f is a code \nexpression label .i and each argumentterm t is either a code expression label or a non\u00adterminal symbol \nof a grammar. The n-th argument term is for the code to be plugged into the n-th unbox expression inside \nthe code expression .i. For example, production rule S . .2(.1) means the set of code values from code \nexpression .2 whose only hole(unbox expression)is pluggedbythecodevaluefrom code expression .1. [ e] \n: Suppose our static analysis [ e] for the translated unstaged programs is de.ned in a .ow-insensitive \n0CFA manner. That is, because the analysis will be ignorant about the environment parts for closures, \nthe best such analysis result for e would be: x has ..1.0 .1 has {}y has ..2.(h.2)+2 .2 has {}h has ..1.0(y \n{}) has 2  p : Lastly, abstract projection p cast the above analysis results [ e] back in terms of regular \nterm grammars of [ e] . Additionally, it .lters out those for the translation-induced extra variables \nh, .1, and .2. Of the many ways to safely project 0CFA-closure values (those corresponding to code) into \nregular term grammars, a safe yet naive projection p projects 0CFA-closures as follows: ..1.0 to S1 . \n.1 ..2.(h.2)+2 to S2 . .2(S) where the nonterminal S represents all code(S . S1|S2). The argument term \nS in the production rule is for the values of the application expression (h.2) that encodes the unbox \n(comma) expression inside code expression (,x + 2). Another more precise projection projects ..2.(h.2)+2 \ndif\u00adferently: ..2.(h.2)+2 to S2 . .2(.1) where the argument term .1 in the production rule is from the \nanalysis result for the h variable, not blindly the universe (S) nonterminal. Both the two abstract projections \np satisfy the safety condi\u00adtion a . p . . p. Let us check the more precise projection case. Note that \nthe concretization image (by .)of a 0CFA-closure...body is the set of closure (...body,s) s for every \npossible environment s for the free variables in body. The free variables values are transitively the \nconcretized images of their abstract values computedby [ e] . Thus, the image of a .p .. for ..2.(h.2)+2 \nbecomes . ..2.(h.2)+2 -. {(..2.(h.2)+2, {h .(..1.0, \u00d8)})} p -. (,x + 2) where ,x has 0 a -. S . .2(.1), \nwhich is equivalent to the abstract projection p s image. 5. RelatedWork Atranslation that makes the \norder of evaluation explicit was previ\u00adouslygivenbyDavies and Pfenning [14]. The translationin Figure \n8follows the same principles. Their translation, however, is not an unstaging one. Recently, a program \nlogic for Mini-ML0 e was pre\u00adsented [2] which precisely captures the operational semantics, yet cannot \nbe realizable as an automatic static analysis. An unstaging translationwaspreviously discussedbyKameyama \net al. [23]but has several limitations for our purpose. Their trans\u00adlationisto SystemFwith tuples, needstypeandenvironment \nclas\u00adsi.er [37] annotations, supports only two stages. Finally, theydid not prove the translation s semantics \npreservation property. Another idea of translation of staged expressions is given by Chen and Xi [4]. \nTheyconvert boxed expressions to .rst-order ab\u00adstract syntax expressions in a second-order language with \nrecur\u00adsion. An advantage of this representation is that inverse translation becomes straightforward. \nChen and Xi use deBruijn indices to rep\u00adresent program variables inside code templates. This has the \nprob\u00adlem that a binding at a higher stage may disappear or occur unex\u00adpectedly [4]. (Such anexampleisgivenby \nKimet al.[25, \u00a76.4].) Our translation is in principle similar to Minamide et al. [30] s closure conversion \nwhere free variables inside lambdas become environment loop operations, though their translation is a \ntype\u00addirected one for conventional unstaged programs. Our translation is an improvement of [1]: we re.ned \nthe ad\u00admin reductions to only two kinds and showed that these two admin reductions suf.ce to reach an \nadmin-normal form that can be con\u00advertedbacktothe correspondingstagedexpressionusinganinverse translation. \nThe re.ned proof of semantic preservation and the ex\u00adistence of the inverse translation is new. Fromthe \nperspectiveof Cousotand Cousot sabstract interpreta\u00adtion-based program transformation framework [11], \nour unstaging translation canbe seen as being derivableby an abstract interpreta\u00adtion of the staged language \n.S . Most static analyses for multi-staged programs are string analy\u00adses for programs that generate code \nas strings (a.k.a. heterogeneous meta programs), but they are limited to estimate only the shape, not \nthe semantics, of generated code by using a grammar [7, 29, 5] or the parsing stack [15]. Such string \nanalyses can not analyze the semantics of the generated code string. Multi-staged static type systems \n[13, 37, 25, 40] and their infer\u00adence algorithms are limited formsof staged static analyses.Anyex\u00adtension \nto estimate other properties than types(\u00b4 a la effect type sys\u00adtems [27, 22, 39]) is limited to those \nthat can proceed without an\u00adalyzing the semantics of the generated code. Existing multi-staged static \ntype systems do not have to analyze the generated code be\u00adcause code-generationexpression stype comeswiththetypeofthe \ngenerated code. Kamin et al. [24] s data .ow analysis of multi-staged programs combines static and dynamic \ntechniques. Our approach is com\u00adpletely static. Smith et al. [34] presented a static analysis of code \ntemplates. Their language is two-staged and code templates are not .rst-class citizens.Variable bindingsdonotextendbeyondthecode \ntemplates theyare de.ned in. Our approach does not have this lim\u00aditation. 6. Conclusion Static analysis \nof multi-staged programs is challenging because the basic assumption of conventional static analysis \nno longer holds: the programtext itselfisno longera.xed static entity,but rathera dynamically constructed \nvalue. In this article we have presented a semantic-preserving trans\u00adlation of multi-staged programs \ninto unstaged ones and a static analysis framework based on this translation. Our static analysis approach \nhas three steps: (1) we .rst apply the unstaging trans\u00adlation; (2) we apply conventional static analysis \nto the unstaged version; (3) we project the analysis results back in terms of the original staged program. \nAs long as the unstaged static analysis is correctw.r.t.the unstaged semantics,andthe projectionissafew.r.t \nthe imaginary staged analysis, a sound static analysis for the origi\u00adnal staged programs is obtained. \nBecause directly de.ning a staged static analysis is dif.cult, our technique makes it possible to use \nthe knowledge and experience in static analyses of conventional unstaged programs withouthavingtodevelop \nstagedanalyses from scratch. Our semantics-preserving translation handlesstaging constructs that have \nbeen evolved to be useful in practice (typi.ed in Lisp s quasi-quotation): open code as values, unrestricted \noperations on references and intentionalvariable-capturing substitutions.We re\u00adfer the reader to our \ncompanion technical report [6] for the mutable reference cases and complete proofs. Acknowledgment We \nthank Sam Kamin, Elsa Gunter and Peter Sestoft for their very valuable feedback on an earlier version \nof this paper. We thank Iksoon Kim, Ben Lickly, Cristiano Calcagno, Xavier Rival, and all the membersoftheROPAS \ngroupin Seoul National University for criticism, discussion, correction, and encouragement.  References \n[1] Baris Aktemur. Improving Ef.ciency and Safety of Program Generation. PhD thesis, University of Illinois \nat Urbana-Champaign, 2009. [2] Martin Berger and LaurenceTratt. Program logics for homogeneous meta-programming. \nIn Proceedings of the 17th International Conference on Logic for Programming, Arti.cial Intelligence \nand Reasoning, to appear, 2010. [3] Cristiano Calcagno, Eugenio Moggi, andWalidTaha. Closed types as \na simple approach to safe imperative multi-stage programming. In ICALP 00: Proceedings of the 27th International \nColloquium on Automata, Languages and Programming, pages 25 36, London, UK, 2000. Springer-Verlag. [4] \nChiyan Chen and Hongwei Xi. Meta-programming through typeful code representation. In ACM International \nConference on Functional Programming, pages 275 286.ACM, August 2003. [5]Tae-Hyoung Choi, Oukseh Lee, \nHyunha Kim, andKyung-Goo Doh. Apractical string analyzerby the widening approach. InProceedings of the \nAsian Symposium on Programming Languages and Systems, volume 4729 of Lecture Notes in Computer Science, \npages 374 388, Sydney, Austrailia, November 2006. Springer-Verlag. [6] Wontae Choi, Baris Aktemur, and \nKwangkeun Yi. Semantics preservation proof of an unstaging translation of lisp-like multi\u00adstaged languages. \nTechnical ReportROSAEC-2010-009,ROSAEC Center, Seoul National University, 2010. http://rosaec.snu.ac. \nkr/publish/2010/techmemo/ROSAEC-2010-009.pdf. [7] AskeSimon Christensen, Anders Mller,and Michael I. \nSchwartzbach. Precise analysis of string expressions. In Proceedings of the Static Analysis Symposium, \npages 1 18. Springer-Verlag, 2003. [8] Hubert Comon, Max Dauchet, Remi Gilleron, Florent Jacquemard, \nDenis Lugiez, ChristofL\u00a8oding, SophieTison, and MarcTommasi. Tree automata techniques and applications, \nApril 1999. [9] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed lattice model for static analysis \nof programs by construction or approximation of .xpoints. In Proceedings of TheACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages,pages 238 252,Los Angeles, California, 1977.ACM Press,NewYork,NY. \n[10] P. Cousot and R. Cousot. Abstract interpretation frameworks. Journal of Logic and Computation, 2(4):511 \n547, 1992. [11] Patrick Cousot and Radhia Cousot. Systematic design of program transformation frameworksby \nabstract interpretation. In Proceedings of The ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages pp.178 190, January 2002. [12] Olivier Danvy. Type-directed partial evaluation. In Proceedings \nof The ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 242 257.ACM, Jan 1996. \n[13] Rowan Davies and Frank Pfenning. A modal analysis of staged computation. In Proceedings of The ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 258 270.ACM, 1996. [14] Rowan \nDavies and Frank Pfenning. A modal analysis of staged computation. Journalof theACM, 48(3):555 604, 2001. \n[15] Kyung-Goo Doh, Hyunha Kim, and David Schmidt. Abstract parsing: static analysis of dynamically generated \nstring output using LR\u00adparsing technology. In Proceeeding of the International Static Analysis Symposium, \n2009. [16] Dawson R. Engler. VCODE:A retargetable, extensible, very fast dynamic code generation system. \nIn Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, pages 160 \n170,NewYork, 1996.ACM. [17] FerencG\u00b4ecseg and Magnus Steinby. TreeAutomata. Akad\u00b4emiai Kiad\u00b4o, 1984. \n[18] Paul Graham. On Lisp: an advanced techniques for Common Lisp. Prentice Hall, 1994. [19] Nevin Heintze. \nSet Based Program Analysis. PhD thesis, Carnegie Mellon University, October 1992. [20] Nevin Heintze. \nSet based analysis of ML programs. In Proceedings of the SIGPLAN Conference on Lisp and Functional Programming, \npages 306 317, 1994. [21] Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. Partial evaluation and \nautomaticprogramgeneration. Prentice-Hall, 1993. [22] Pierre Jouvelot and David K. Gifford. Algebraic \nreconstruction of types and effects. In Proceedings of TheACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, pages 303 310, 1991. [23] Yukiyoshi Kameyama, Oleg Kiselyov, and Chung chieh \nShan. Closing the stage:from staged code to typed closure. In Proceedings of The ACM Symposium on Partial \nEvaluation and Program Manipulations, pages 147 157, 2008. [24] Sam Kamin, Baris Aktemur, and Michael \nKatelman. Staging static analyses for program generation. In GPCE 06: Proceedings of the 5th international \nconference on Generative programming and component engineering, pages 1 10, NewYork, NY, USA, 2006. ACM. \n[25] Ik-Soon Kim, Kwangkeun Yi, and Cristiano Calcagno. A poly\u00admorphic modal type system for lisp-like \nmulti-staged languages. In Proceedings of TheACM SIGPLAN-SIGACT Symposium on Princi\u00adples of Programming \nLanguages, pages 257 269, 2006. [26] M. Leone and Peter Lee. Optimizing ML with run-time code generation. \nIn Proceedings of theACM SIGPLAN 96 Conference on Programming Language Design and Implementation, pages \n137 148.ACM Press, June 1996. [27] John M. Lucassen and David K. Gifford. Polymorphic effect systems. \nIn Proceedings of The ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 47 57, \n1988. [28] H. Massalim. An Ef.cient Implementation of Functional Operating System Services. PhD thesis, \nColumbia University, 1992. [29] Yasuhiko Minamide. Static approximation of dynamically generated web \npages. In Proceedingsof the International Conference onWorld WideWeb, pages 432 441,NewYork,NY, USA, \n2005.ACM. [30] Yasuhiko Minamide, Greg Morrisett, and Robert Harper. Typed closure conversion. In Proceedings \nof TheACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 271 283.ACM, 1996. [31] \nAleksandar Nanevski and Frank Pfenning. Staged computation with names and necessity. Journal of Functional \nProgramming, 15(6):893 939, 2005. [32] Massimilian Poletto, Wilson C. Hsieh, Dawson R. Engler, and M. \nFrans Kasshoek. Cand tcc:a language and compiler for dynamic code generation. ACMTransactionsonProgramming \nLanguagesand Systems, 21:324 369, March 1999. [33] Tim Sheard and Simon Peyton Jones. Template meta-programming \nfor Haskell. In Proceedingsof The HaskellWorkshop, October 2002. http:/www.haskell.org/haskellwiki/Template \nHaskell [34] Frederick Smith, Dan Grossman, GregMorrisett, Luke Hornof, and Trevor Jim. Compiling for \ntemplate-based run-time code generation. Journal of Functional Programming, 13(3):677 708, 2003. [35] \nGuy L. Steele. Common Lisp the Language, 2nd edition. Digital Press, 1990. [36] Walid Taha, Cristiano \nCalcagno, Xavier Leroy, and Ed Pizzi. MetaOCaml. http:/www.metaocaml.org/ [37]WalidTahaandMichael Florentin \nNielsen.Environment classi.ers. In Proceedings of The ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages.ACM, 2003. [38] MakotoTatsuta. Translation of multi-staged language. Technical Report NII-2010-003E, \nNational Institute of Informatics, Tokyo, 2010. http://research.nii.ac.jp/TechReports. [39] MadsTofte \nand Jean-PierreTalpin. Implementationof the typed call\u00adby-value .-calculus using a stack of regions. \nIn Proceedings of The ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 188 \n201, January 1994. [40] EdwinWestbrook, Mathias Ricken, Jun Inoue,YilongYao,Tamer Abdelatif,andWalidTaha. \nMint:Javamulti-stage programmingusing weak separability. In Proceedings of TheACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, 2010.    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Static analysis of multi-staged programs is challenging because the basic assumption of conventional static analysis no longer holds: the program text itself is no longer a fixed static entity, but rather a dynamically constructed value. This article presents a semantic-preserving translation of multi-staged call-by-value programs into unstaged programs and a static analysis framework based on this translation. The translation is semantic-preserving in that every small-step reduction of a multi-staged program is simulated by the evaluation of its unstaged version. Thanks to this translation we can analyze multi-staged programs with existing static analysis techniques that have been developed for conventional unstaged programs: we first apply the unstaging translation, then we apply conventional static analysis to the unstaged version, and finally we cast the analysis results back in terms of the original staged program. Our translation handles staging constructs that have been evolved to be useful in practice (typified in Lisp's quasi-quotation): open code as values, unrestricted operations on references and intentional variable-capturing substitutions. This article omits references for which we refer the reader to our companion technical report.</p>", "authors": [{"name": "Wontae Choi", "author_profile_id": "81443595067", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P2509566", "email_address": "wtchoi@ropas.snu.ac.kr", "orcid_id": ""}, {"name": "Baris Aktemur", "author_profile_id": "81418592948", "affiliation": "Ozyegin University, Istanbul, Turkey", "person_id": "P2509567", "email_address": "Baris.Aktemur@ozyegin.edu.tr", "orcid_id": ""}, {"name": "Kwangkeun Yi", "author_profile_id": "81339538925", "affiliation": "Seoul National University, Seoul, South Korea", "person_id": "P2509568", "email_address": "kwang@ropas.snu.ac.kr", "orcid_id": ""}, {"name": "Makoto Tatsuta", "author_profile_id": "81100245773", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2509569", "email_address": "tatsuta@nil.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926397", "year": "2011", "article_id": "1926397", "conference": "POPL", "title": "Static analysis of multi-staged programs via unstaging translation", "url": "http://dl.acm.org/citation.cfm?id=1926397"}