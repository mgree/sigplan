{"article_publication_date": "01-26-2011", "fulltext": "\n Bisimulation for Quantum Processes * Yuan Feng Centre for Quantum Computation and Intelligent Systems, \nUniversity of Technology Sydney, Australia State Key Laboratory of Intelligent Technology and Systems, \nTNList, Department of Computer Science and Technology, Tsinghua University, Beijing, China yuan.feng@uts.edu.au \nRunyao Duan Mingsheng Ying Centre for Quantum Computation and Intelligent Systems, University of Technology \nSydney, Australia State Key Laboratory of Intelligent Technology and Systems, TNList, Department of \nComputer Science and Technology, Tsinghua University, Beijing, China runyao.duan@uts.edu.au mingsheng.ying@uts.edu.au \n Abstract Quantum cryptographic systems have been commercially available, with a striking advantage over \nclassical systems that their security and ability to detect the presence of eavesdropping are provable \nbased on the principles of quantum mechanics. On the other hand, quantum protocol designers may commit \nmuch more faults than classical protocol designers since human intuition is much better adapted to the \nclassical world than the quantum world. To offer formal techniques for modeling and veri.cation of quantum \nproto\u00adcols, several quantum extensions of process algebra have been pro\u00adposed. One of the most serious \nissues in quantum process algebra is to discover a quantum generalization of the notion of bisimula\u00adtion, \nwhich lies in a central position in process algebra, preserved by parallel composition in the presence \nof quantum entanglement, which has no counterpart in classical computation. Quite a few ver\u00adsions of \nbisimulation have been de.ned for quantum processes in the literature, but in the best case they are \nonly proved to be pre\u00adserved by parallel composition of purely quantum processes where no classical communications \nare involved. Many quantum cryptographic protocols, however, employ the LOCC (Local Operations and Classical \nCommunications) scheme, where classical communications must be explicitly speci.ed. So, a notion of bisimulation \npreserved by parallel composition in the cir\u00adcumstance of both classical and quantum communications is \ncru\u00adcial for process algebra approach to veri.cation of quantum cryp\u00adtographic protocols. In this paper \nwe introduce a novel notion of bisimulation for quantum processes and prove that it is congruent with \nrespect to various process algebra combinators including par\u00adallel composition even when both classical \nand quantum communi\u00adcations are present. We also establish some basic algebraic laws for this bisimulation. \nIn particular, we prove uniqueness of the solu\u00adtions to recursive equations of quantum processes, which \nprovides * Partially supported by Australian ARC grant DP110103473, National Natural Science Foundation \nof China (Grant Nos: 60736011) and FANEDD grant 200755). Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. PoPL 11, January 26 28, 2011, Austin, Texas, USA. \nCopyright c &#38;#169; 2010 ACM 978-1-4503-0490-0/11/01. . . $10.00 a powerful proof technique for verifying \ncomplex quantum proto\u00adcols. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal \nDe.nitions and Theory; F.3.1 [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning \nabout Programs General Terms Languages, Theory, Veri.cation Keywords Quantum communication, quantum computing, \nquan\u00adtum process algebra, bisimulation, congruence 1. Introduction Quantum computing offers the potential \nof considerable speedup over classical computing for some important problems such as prime factoring \n[16] and unsorted database search [7]. However, functional quantum computers which can harness this potential \nin dealing with practical applications are extremely dif.cult to implement. On the other hand, quantum \ncryptography, of which the security and ability to detect the presence of eavesdropping are provable \nbased on the principles of quantum mechanics, has been developed so rapidly that quantum cryptographic \nsystems are already commercially available by a number of companies such as Id Quantique, Cerberis, MagiQ \nTechnologies, SmartQuantum, and NEC. As is well known, it is very dif.cult to guarantee correctness of \nclassical communication protocols at the design stage, and some simple protocols were .nally found to \nhave fundamental .aws. Since human intuition is much worse adapted to the quantum world than the classical \nworld, quantum protocol designers may com\u00admit much more faults than classical protocol designers, especially \nwhen more and more complicated quantum protocols can be imple\u00admented by future physical technology. With \nthe purpose of cloning the success classical process algebras achieve in analyzing and veri\u00adfying classical \ncommunication protocols and even distributed com\u00adputing, various quantum process algebras have been proposed \nin\u00addependently by several research groups. Jorrand and Lalire [10] de.ned a language QPAlg (Quantum Process \nAlgebra) by extend\u00ading a classical CCS-like process algebra. A branching bisimulation which identi.es \nquantum processes associated with graphs having the same branching structure was also presented [12]. \nThe bisim\u00adulation is, however, not congruent: it is not preserved by paral\u00adlel composition. Gay and Nagarajan \n[6] de.ned a language CQP (Communicating Quantum Processes), which combines the com\u00admunication primitives \nof pi-calculus [13] with primitives for uni\u00adtary transformations and measurements. One distinctive feature \nof CQP is a type system which guarantees the physical realizability of quantum processes. However, no \nnotion of equivalence between processes was presented.  Authors of the current paper proposed a model \nnamed qCCS [5] for quantum communicating systems by adding quantum in\u00adput/output and quantum operation/measurement \nprimitives to clas\u00adsical value-passing CCS [8, 9]. The semantics of quantum input and output was carefully \ndesigned to describe the communication of quantum systems which have been entangled with other systems. \nA bisimulation was de.ned for .nite processes, and a simpli.ed version of congruence property was proved, \nin which parallel com\u00adposition is only permitted when the participating processes are free of quantum \ninput, or free of quantum operations and measurement. In [18] the same authors studied a purely quantum \nversion of qCCS where no classical data is explicitly involved, aiming at providing us a suitable framework \nto observe the interaction of computation and communication in quantum systems. A bisimulation was de\u00ad.ned \nfor this purely quantum qCCS and shown to be fully pre\u00adserved by parallel composition. It is worth noting \nthat, however, the bisimulation proposed in [18] cannot be directly extended to gen\u00aderal qCCS where classical \ndata as well as probabilistic behaviors are included. In this paper, we combine the two models proposed \nin [5] and [18] together to involve both classical data and quantum data. This general model, which we \nstill call qCCS for coherence, accommo\u00addates all classical process constructors (especially recursive \ndef\u00adinitions) as well as quantum primitives. As a consequence, both sequential and distributed quantum \ncomputing, quantum commu\u00adnication protocols, and quantum cryptographic systems can be for\u00admally modeled \nand rigorously analyzed in the framework of qCCS. tax and operational semantics of qCCS are presented \nin Section 3. To illustrate the expressiveness of qCCS, we describe with it the well-known quantum superdense \ncoding and teleportation proto\u00adcols. We also show how to encode quantum unitary gates and mea\u00adsurement \ngates, which are two basic elements of quantum circuits, by qCCS. Section 4 de.nes the notion of bisimulations \nfor con.g\u00adurations as well as quantum processes. Equivalence relation based on bisimularity is also de.ned \nand proved to be fully preserved by all process constructors of qCCS. The validity of examples in Sec\u00adtion \n3 is proved by using the notion of bisimilarity de.ned in this section. Various properties such as monoid \nlaws, static laws, the expansion law, as well as uniqueness of solutions of process equa\u00adtions are also \nexamined. We outline the main results in Section 5 and point out some problems for further study.  2. \nPreliminaries For convenience of the reader, we brie.y recall some basic notions from linear algebra \nand quantum theory which are needed in this paper. For more details, we refer to [14]. P 2.1 Basic linear \nalgebra A Hilbert space H is a complete vector space equipped with an inner product (\u00b7|\u00b7) : H\u00d7H. C such \nthat (1) (.|.)= 0 for any |.).H, with equality if and only if |.) =0; (2) (f|.) = (.|f) * ; P .i|.i) \n= .i(f|.i), ii where C is the set of complex numbers, and for each . . C, . * We also design a bisimulation \nfor processes in qCCS and an equiv-(3) (f|alence relation based on it, which turns out to be a congruence. \nThis bisimulation has several distinctive features compared with those proposed in the literature: Firstly, \nit takes local quantum op\u00ad p stands for the complex conjugate of .. For any vector |.).H, its length \n|||.)|| is de.ned to benormalized if |||.)|| =1. Two vectors |.) and |f) are orthogonal if (.|f) =0.An \northonormal basis of a Hilbert space H is a (.|.), and it is said to be erations into account in a weak \nmanner, but at the same time .ts well with recursive de.nitions. Lalire s bisimulation cannot distin\u00ad \nguish different operations on a quantum system which will never be output: quantum states are only compared \nwhen they are input or output. Bisimulation de.ned in [5] works well only for .nite pro\u00adcesses since \nquantum states are required to be compared after all the actions have been performed. Note that no state \ncomparison is needed in [18] since all local quantum operations are regarded as visible actions, and \nthe resulted bisimulation is a very strong one it distinguishes two different sequences of local operations \neven when they have the same effect as a whole. Secondly, entanglement between the input/output system \nand the remaining systems is fully considered in our de.nition. Bisimulation presented in [12] totally \nbasis {|i)} where each |i) is normalized and any pair of them are orthogonal. Let L(H) be the set of \nlinear operators on H.For any A . L(H), A is Hermitian if A = A where A is the adjoint opera\u00adtor of A \nsuch that (.|A |f) = (f|A|.)* for any |.), |f).H. The fundamental spectrum theorem states that the set \nof all nor\u00admalized eigenvectors of a Hermitian operator in L(H) contains an orthonormal basis for H. \nThat is, there exists a so-called spectral decomposition for each Hermitian A such that X X A = .i|i)(i| \n= .iEi ignores this correlation by only considering the reduced state of the input/output system. In \n[5] this consideration is implicitly made by i i.spec(A) the state comparison after the processes terminating. \nAgain, it does not work for in.nite processes. Finally, but most importantly, the bisimulation presented \nhere is preserved by parallel composition, and the equivalence derived by the bisimulation is a congruence, \nmaking them suitable for equational reasoning in verifying quan\u00adtum communication and cryptographic systems. \nLalire s bisimula\u00adtion is not preserved by parallel composition. The bisimulation in [5] is not preserved \nby restriction, and whether it is preserved by where the set {|i)} constitute an orthonormal basis of \nH, spec(A) denotes the set of eigenvalues of A,and Ei is the projector to the corresponding eigenspace \nof .i. A linear operator A .L(H) is unitary if A A = AA = IH where IH is the identity operator on H. \nIn this paper, we will use some well-known unitary operators listed as follows: the quantum control-not \noperator performed on two qubits with the matrix representation 0 B@ 1 CA 1000 0100 parallel composition \nstill remains open, although the positive an\u00ad swer is af.rmed in two special cases. The bisimulation \nproposed CN = in [18] is indeed a congruence. However, since no classical data is involved in that model, \nmany important quantum communication protocols such as superdense coding and teleportation cannot be \nunder the computational basis, and the 1-qubit Hadamard operator described. This restricts the scope \nof its application. H and Pauli operators s0,s1,s2,s3 de.ned respectively as The paper is organized as \nfollows: in Section 2, we review some \u00ab \u00ab 1 H = v 11 10 basic notions from linear algebra and quantum \nmechanics. The syn\u00ad 0 ,s = I 1 -1 2  \u00ab \u00ab \u00ab 1 01 2 10 3 0 -i s= ,s= ,s= . 10 0 -1 i 0 P The trace of \nA .L(H) is de.ned as tr(A)= (i|A|i) i for some given orthonormal basis {|i)} of H. It is worth noting \nthat trace function is actually independent of the orthonormal basis selected. It is also easy to check \nthat trace function is linear and tr(AB)=tr(BA) for any operators A, B .L(H). Let H1 and H2 be two Hilbert \nspaces. Their tensor product H1 .H2 is de.ned as a vector space consisting of linear com\u00adbinations of \nthe vectors |.1.2) = |.1)|.2) = |.1).|.2) with |.1).H1 and |.2).H2. Here the tensor product of two vectors \nis de.ned by a new vector such that !! X XX .i|.i). \u00b5j |fj ) = .i\u00b5j |.i).|fj ). i j i,j Then H1 .H2 is \nalso a Hilbert space where the inner product is de.ned as the following: for any |.1), |f1).H1 and |.2), \n|f2).H2, (.1 . .2|f1 . f2) = (.1|f1)H1 (.2|f2)H2 where (\u00b7|\u00b7)Hi is the inner product of Hi.For any A1 \n.L(H1) and A2 .L(H2), A1 . A2 is de.ned as a linear operator in L(H1 .H2) such that for each |.1).H1 \nand |.2).H2, (A1 . A2)|.1.2) = A1|.1). A2|.2). The partial trace of A .L(H1 .H2) with respected to H1 \nis P de.ned as trH1 (A)= (i|A|i) where {|i)} is an orthonormal i basis of H1. Similarly, we can de.ne \nthe partial trace of A with respected to H2. Partial trace functions are also independent of the orthonormal \nbasis selected. A linear operator E on L(H) is completely positive if it maps positive operators in L(H) \nto positive operators in L(H),and for any auxiliary Hilbert space H', the trivially extended operator \nIH1 .E also maps positive operators in L(H' .H) to positive operators in L(H' .H). Here IH1 is the identity \noperator on L(H'). The elegant and powerful Kraus representation theorem [11] of completely positive \noperators states that a linear operator E is completely positive if and only if there are some set of \noperators {Ei} with appropriate dimension such that X E(A)= EiAEi i for any A .L(H). The operators Ei \nare called Kraus opera\u00adtors of E.Alinearoperatorissaidtobea super-operator if it is completely positive \nand trace-nonincreasing. Here an operator E is trace-nonincreasing if tr(E(A)) = tr(A) for any positive \nA .L(H), and it is said to be trace-preserving if the equality al\u00adways holds. Then a super-operator (resp. \na trace-preserving super\u00adoperator) is a completely positive operator with its Kraus operators P E P E \nEi satisfying i Ei = I (resp. i = I). ii Ei  2.2 Basic quantum mechanics According to von Neumann s \nformalism of quantum mechanics [17], an isolated physical system is associated with a Hilbert space which \nis called the state space of the system. A pure state of a quantum system is a normalized vector in its \nstate space, and a mixed state is represented by a density operator on the state space. Here a density \noperator . on Hilbert space H is a positive linear operator such that tr(.)=1. Another equivalent representation \nof density operator is probabilistic ensemble of pure states. In particu- P lar, given an ensemble {(pi, \n|.i))} where pi = 0, pi =1,and P i |.i) are pure states, then . = pi[|.i)] is a density operator. i Here \n[|.i)] denotes the abbreviation of |.i)(.i|. Conversely, each density operator can be generated by an \nensemble of pure states in this way. It is mathematically convenient to allow the trace of a density \noperator to be less than 1, which makes it possible to represent both the actual state (by the normalized \ndensity operator) and the probability with which the state is reached (by its trace) in a single expression \n[15]. Then the set of (partial) density operators on H can be de.ned as D(H)= { . .L(H): . is positive \nand tr(.) = 1}. The state space of a composite system (for example, a quantum system consisting of many \nqubits) is the tensor product of the state spaces of its components. For a mixed state . on H1 .H2, partial \ntraces of . have explicit physical meanings: the density operators trH1 . and trH2 . are exactly the \nreduced quantum states of . on the second and the .rst component system, respectively. Note that in general, \nthe state of a composite system cannot be decomposed into tensor product of the reduced states on its \ncomponent systems. A well-known example is the 2-qubit state 1 |.) = v (|00) + |11)) 2 which appears \nrepeatedly in our examples of this paper. This kind of state is called entangled state. To see the strangeness \nof entangle\u00adment, suppose a measurement M = .0[|0)]+ .1[|1)] is applied on the .rst qubit of |.) (see \nthe following for the de.nition of quan\u00adtum measurements). Then after the measurement, the second qubit \nwill de.nitely collapse into state |0) or |1) depending on whether the outcome .0 or .1 is observed. \nIn other words, the measurement on the .rst qubit changes the state of the second qubit in some way. \nThis is an outstanding feature of quantum mechanics which has no counterpart in classical world, and \nis the key to many quantum in\u00adformation processing tasks such as teleportation [4] and superdense coding \n[3]. The evolution of a closed quantum system is described by a unitary operator on its state space: \nif the states of the system at times t1 and t2 are .1 and .2, respectively, then .2 = U.1U for some \nunitary operator U which depends only on t1 and t2. In contrast, the general dynamics which can occur \nin a physical system is described by a super-operator on its state space. Note that the unitary transformation \nU(.)= U.U is a trace-preserving super-operator. A quantum measurement is described by a collection {Mm} \nof measurement operators, where the indices m refer to the measure\u00adment outcomes. It is required that \nthe measurement operators sat- P M is in state ., then the probability that measurement result m occurs \nis given by isfy the completeness equation mmMm = IH. If the system p(m)=tr(MmMm.), and the state of \nthe post-measurement system is Mm.M /p(m). m A particular case of measurement is projective measurement \nwhich is usually represented by a Hermitian operator. Let M be a Hermitian operator and X M = mEm m.spec(M) \nits spectral decomposition. Obviously, the projectors {Em : m . spec(M)} form a quantum measurement. \nIf the state of a quan\u00adtum system is ., then the probability that result m occurs when measuring M on \nthe system is p(m)=tr(Em.), and the post\u00admeasurement state of the system is Em.Em/p(m). Note that for \neach outcome m, the map Em(.)= Em.Em  is again a super-operator by Kraus Theorem; it is not trace\u00adpreserving \nin general.  3. Basic de.nitions of qCCS In this section, we give the basic de.nitions of qCCS, which \nis a combination of those proposed in [5] and [18], involving classical data as well as quantum data, \nall classical process constructors (especially the recursive de.nition) as well as quantum primitives. \nThe reader is referred to [5] and [18] for further examples and explanations of the language. 3.1 Syntax \nFor simplicity, only two types of data are considered in qCCS: real numbers Real for classical data and \nqubits Qbt for quantum data. Let cV ar, ranged over by x,y, ... , be the set of classical variables and \nqV ar, ranged over by q, r,... , the set of quantum variables. It is assumed that cV ar and qV ar are \nboth countably in.nite. Let Exp, ranged over by e, be the set of expressions with the value domain Real.Let \ncChan be the set of classical channel names, ranged over by c,d,... ,and qChan the set of quantum channel \nnames, ranged over by c, d,... .Let Chan = cChan . qChan.A relabeling function f is a one to one function \nfrom Chan to Chan such that f(cChan) . cChan and f(qChan) . qChan. We often abbreviate the indexed set \n{q1,...,qn} to qewhen q1,...,qn are distinct quantum variables and the dimension n is understood. Sometimes \nwe also use qeto denote the string q1 ...qn. We assume a set of process constant schemes, ranged over \nby A, B, . . . . Assigned to each process constant scheme A there is a non-negative integer ar(A).If \nqeis a tuple of distinct quantum variables with |qe| = ar(A),then A(qe) is called a process constant. \nBased on these notations, we now propose the syntax of qCCS as follows. DEFINITION 3.1. (Quantum process) \nThe set of quantum pro\u00ad cesses qP roc and the free quantum variable function qv : qP roc . 2qV ar are \nde.ned inductively by the following formation rules: (1) nil . qP roc,and qv(nil)= \u00d8; (2) A(qe) . qP \nroc,and qv(A(qe)) = qe; (3) t.P . qP roc,and qv(t.P )= qv(P ); (4) c?x.P . qP roc,and qv(c?x.P )= qv(P \n); (5) c!e.P . qP roc,and qv(c!e.P )= qv(P ); (6) c?q.P . qP roc,and qv(c?q.P )= qv(P ) -{q}; (7) \nIf q . qv(P ) then c!q.P . qP roc,and qv(c!q.P )= qv(P ) . {q}; (8) E[qe].P . qP roc,and qv(E[qe].P \n)= qv(P ) . qe; (9) M[qe; x].P . qP roc,and qv(M[qe; x].P )= qv(P ) . qe;  (10) P + Q . qP roc,and \nqv(P + Q)= qv(P ) . qv(Q); (11) If qv(P ) n qv(Q)= \u00d8 then P IQ . qP roc,and qv(P IQ)= qv(P ) . qv(Q); \n (12) P [f] . qP roc,and qv(P [f]) = qv(P ); (13) P \\L . qP roc,and qv(P \\L)= qv(P ); (14) if b then \nP . qP roc,and qv(if b then P )= qv(P ),  where P, Q . qP roc, c . cChan, x . cV ar, c . qChan, q . \nqV ar, qe. qV ar, e . Exp, t is the silent action, A(qe) is a process constant, f is a relabeling function, \nL . Chan, b is a boolean-valued expression, E and M are respectively a trace\u00adpreserving super-operator \nand a Hermitian operator applying on the Hilbert space associated with the systems qe. Furthermore, for \neach process constant A(qe), there is a de.ning equation def A(qe)= P where P . qP roc with qv(P ) . \nqe.When qe= \u00d8, we simply denote A(qe) as A. The notion of free classical variables in quantum processes \ncan be de.ned in the usual way with a unique modi.cation that quantum measurement M[qe; x] has binding \npower on x. A quantum process P is closed if it contains no free classical variables, i.e., fv(P )= \u00d8. \n 3.2 Operational semantics To present the operational semantics of qCCS, some further no\u00adtations are \nnecessary. For each quantum variable q . qV ar,we assume a 2-dimensional Hilbert space Hq to be the state \nspace of the q-system. For any S . qV ar, we denote O HS = Hq. q.S In particular, H = HqV ar is the state \nspace of the whole envi\u00adronment consisting of all the quantum variables. Note that H is a countably in.nite-dimensional \nHilbert space. Suppose P is a closed quantum process. A pair of the form (P, .) is called a con.guration, \nwhere . .D(H) is a density operator on H. The set of con.gurations is denoted by Con.We sometimes let \nC, D,... range over Con to ease notations. Let D(Con) be the set of .nite-support probability distributions \nover Con;thatis, D(Con)= {\u00b5 : Con . [0, 1] | \u00b5(C) > 0 for .nitely X many C,and \u00b5(C)=1}. \u00b5(C)>0 For any \n\u00b5 . D(Con),wedenoteby supp(\u00b5) the support set of \u00b5, i.e., the set of con.gurations C such that \u00b5(C) > \n0.When \u00b5 is a simple distribution such that supp(\u00b5)= {C} for some C,we abuse the notation slightly to \ndenote \u00b5 by C. Sometimes we .nd it convenient to denote a distribution \u00b5 by an explicit form \u00b5 = Ei.I \npi Ci (or \u00b5 = Epi Ci when the index set I is understood) where Ci are distinct con.gurations, supp(\u00b5)= \n{Ci : i . I}, and \u00b5(Ci)= pi for each i . I. P Given \u00b51,...,\u00b5n . D(Con) and p1,...,pn . [0P, 1], i pi \n= 1, we de.ne the combined distribution, denoted by n pi\u00b5i,to S i=1 be a new distribution \u00b5 such that \nsupp(\u00b5)= supp(\u00b5i),and for P i any D. supp(\u00b5), \u00b5(D)= i pi\u00b5i(D). It is worth pointing out the difference \nbetween the two notations P Ei.I pi Ci and i.I piCi: the former is the explicit form of a distribution, \nso it is required that pi > 0 for each i . I,and Ci = Cj for i = j; while the latter is a combined distribution \nof the simple distributions Ci with the probability weights pi,so pi may be zero for some i . I,and Ci \nare not necessarily distinct. Let \u00b5 = Ei.I pi (Pi,.i). We denote by qv(\u00b5) the free S variables of \u00b5;thatis, \nqv(\u00b5)= i.I qv(Pi). We write tr(\u00b5)= P pitr(.i),and E(\u00b5)= Ei.I pi (Pi, E(.i)) when E is a i.I super-operator. \nLet Act = {t }.{c?v, c!v | c . cChan, v . Real}.{c?r, c!r | c . qChan, r . qV ar}. For each a . Act, \nwe de.ne the bound quantum variable bv(a) of a as bv(c?r)= {r} and bv(a)= \u00d8 if a is not a quantum input. \nThe channel name used in action a is denoted by cn(a);that is, cn(c?v)= cn(c!v)= {c}, cn(c?r)= cn(c!r)= \n{c},and cn(t )= \u00d8. The semantics of qCCS is given by the probabilistic labeled transition system (Con, \nAct, -.),where -. . Con \u00d7 Act \u00d7 D(Con) is the smallest relation satisfying the rules de.ned in a Figs. \n1 and 2 (For brevity, we write (P, .) -. \u00b5 instead of ((P, .),a,\u00b5) .-.. The symmetric forms for Rules \nInp-Int, Oth-Int,and Sum are omitted).  Tau : t (t.P, .) -. (P, .) C-Inp : ,v . Real c?v (c?x.P, .) \n-. (P {v/x},.) C-Outp : ,v = [[e]] c!v (c!e.P, .) -. (P, .) c?vc!v (P1,.) -. (P1' ,.), (P2,.) -. (P2' \n,.) C-Com : t (P1IP2,.) -. (P ' IP ' ,.) 12 Q-Inp : ,r . qv(c?q.P ) c?r (c?q.P, .) -. (P {r/q},.) Q-Outp \n: c!q(c!q.P, .) -. (P, .) c?rc!r (P1,.) -. (P1' ,.), (P2,.) -. (P2' ,.) Q-Com : t (P1IP2,.) -. (P ' \nIP ' ,.) 12 Oper : t (E[re].P, .) -. (P, Ere(.))  Meas : tP (M[re; x].P, .) -. pi(P {.i/x},Ei .Ei /pi) \ni.Irere where M has the spectrum decomposition M = P .iEi and pi =tr(Ei .)/tr(.) i.Ire Figure 1. Inference \nrules for qCCS (Part 1) The transition relation -. can be lifted to D(Con) \u00d7 Act \u00d7 aa D(Con) by writing \n\u00b5 -. . if for any C. supp(\u00b5), C -. .C P for some .C,and . = \u00b5(C).C. C.supp(\u00b5) For any S . qV ar we denote \nby S the complement set of S in qV ar. The following lemmas can be easily observed from the inference \nrules de.ned above. a LEMMA 3.1. If (P, .) -. \u00b5,then qv(\u00b5) . qv(P ) .{bv(a)}. a LEMMA 3.2. If (P, .) \n-. \u00b5,then (1) tr(.)=tr(\u00b5); (2) there exist a set of super-operators {Ei : i . I} acting on Hqv(P ) such \nthat for any s .D(H), as s (P, s) -. Ei.I qi (Pi, Ei(s)/qi ) where qis =tr(Ei(s))/tr(s); (3) for any \nsuper-operator E acting on H , qv(P ) a (P, E(.)) -. E(\u00b5). 3.3 Examples To illustrate the expressiveness \nof qCCS, we give some examples. EXAMPLE 3.1. Superdense coding [3] is a quantum protocol using which \ntwo bits of classical information can be faithfully transmitted by sending only one qubit, provided that \na maximally entangled state is shared apriori between the sender and the receiver. The v protocol goes \nas follows. Let |.) =(|00) + |11))/ 2 be the entangled state shared between the sender Alice and the \nreceiver Bob. Alice applies a Pauli operator on her qubit of |.) according to which information among \nthe four possibilities she wishes to c?r (P1,.) -. (P1' ,.),r . qv(P2)  Inp-Int : c?r (P1IP2,.) -. (P \n' IP2,.) 1 a (P1,.) -. Ei.I pi (Pi ' ,.i),a = c?r Oth-Int : a(P1IP2,.) -. Ei.I pi (P ' IP2,.i) i a (P, \n.) -. \u00b5 Sum : a (P + Q, .) -. \u00b5 a (P, .) -. Epi (Pi,.i) Rel : f(a) (P [f],.) -. Epi (Pi[f],.i) a (P, \n.) -. Epi (Pi,.i),cn(a) . L Res : a(P \\L, .) -. Epi (Pi\\L, .i) a (P, .) -. \u00b5, [[b]] = true  Cho : a \n(if b then P, .) -. \u00b5 adef (P {eq},.) q)= Pr/e-. \u00b5, A(e Def : a (A(re),.) -. \u00b5 Figure 2. Inference \nrules for qCCS (Part 2) transmit, and sends her qubit to Bob. With the two qubits in hand, Bob performs \na perfect discrimination among the possible states (they are actually the four Bell states {si . I|.) \n: i =0, 1, 2, 3}where si are de.ned in Section 2) and retrieves the information Alice has sent. We now \nshow how to describe the protocol of superdense cod\u00ading with qCCS. Let M be a 2-qubit measurement such \nthat M = P3 i| i)( i|,where i is the binary expansion of i.Let CN be the i=0 controlled-not operator \nand H Hadamard operator. Then the quan\u00adtum processes participated in superdense coding protocol can be \nde.ned as follows: X Alices = c?x. if x = i then si[q1].e!q1.nil , 0=i=3 Bobs = e?q1.CN [q1,q2].H[q1].M[q1,q2; \nx].d!x.nil, Sdc =(AlicesIBobs)\\{e}. For any . .D(H{q1,q2}) and v .{0, 1, 2, 3},wehavethe transitions \n(Sdc, [|.)]q1,q2 . .) 00 11 X c?vi -. (@@ (if v = i then s[q1].e!q1.nil)AIBobs A\\{e}, 0=i=3 [|.)]q1,q2 \n. .) t -. ((e!q1.nilIBobs)\\{e},sv ([|.)]) . .) q1 t -. ((nilICN[q1,q2].H[q1].M[q1,q2; x].d!x.nil)\\{e}, \nsv ([|.)]) . .) q1 t -. ((nilIH[q1].M[q1,q2; x].d!x.nil)\\{e}, CNq1,q2 (sv ([|.)])) . .) q1 t  -. ((nilIM[q1,q2; \nx].d!x.nil)\\{e}, [|ev)]q1,q2 . .) (1) t -. ((nilId!v.nil)\\{e}, [|ve)]q1,q2 . .) d!v -. ((nilInil)\\{e}, \n[|ve)]q1,q2 . .).  Here Eq.(1) is calculated as follows: and for 0 = j = 3, ((c!j.nilIBobt)\\{e}, [|ej)]r,q1 \n. sj q2 X (.)) t Hq1 (CNq1,q2 (sv ([|.)]))) = q1 -. ((nilI (if j = i then si[q2].d!q2.nil))\\{e}, 0=i=3 \n8 >>>>>>>>>< >>>>>>>>>: |00)+|11) Hq1 (CNq1,q2 ([ v 2 ])) = [|00)], if v =0 [|ej)]r,q1 . sj (.)) q2 \nt |10)+|01) -. ((nilId!q2.nil)\\{e}, [|ej)]r,q1 . .) Hq1 (CNq1,q2 ([ v ])) = [|01)], if v =1 2 d!q2 -. \n((nilInil)\\{e}, [|ej)]r,q1 . .). |00)-|11) Hq1 (CNq1,q2 ([ v ])) = [|10)], if v =2 2 Here Eq.(2) is \ncalculated as follows. Notice that any . .D(H P ) {q1,q2} can be decomposed as . = Hq1 (CNq1,q2 ([ |01)-|10) \nv 2 ])) = [|11)], if v =3. 0=i=3 v .i[|.i)]r . .i where |.0) = |0), |.1) = |1), |.2) = |+) =(|0) + |1))/ \n2, and |.3) = |-) = v (|0)-|1))/ 2. Then it is easy to derive that EXAMPLE 3.2. Quantum teleportation \n[4] is one of the most im\u00adportant protocols in quantum information theory which can make use of a maximally \nentangled state shared between the sender and the receiver to teleport an unknown quantum state by send\u00ading \nonly classical information. It serves as a key ingredient in many other communication protocols. The \nprotocol goes as follows. Let |.)q1,q2 be the entanglement state shared between the sender Al\u00adice and \nthe receiver Bob, with Alice holding q1 and Bob holding q2.Let q be the quantum system whose state Alice \nwant to trans\u00admit to Bob. Alice .rst applies a quantum control-not operations on q and q1, with q the \ncontrol qubit and q1 the target, followed by a Hadamard operator H on q. She then measures q and q1 according \nto the computational basis, and sends the measurement outcome to Bob. Upon receiving the classical bits \nfrom Alice, Bob applies a corresponding Pauli operator on his qubit q2 to recover the original state \nof q. Let M, CN, H,and si,i =0,..., 3 be as de.ned in Exam\u00adple 3.1. Then the quantum processes participated \nin teleportation protocol can be de.ned as follows: Hr(CNr,q1 ([|.)]q1,q2 . .)) .0 =[|000) + |011) + \n|100) + |111)]r,q1,q2 . .1 4 .1 +[|001) + |010)-|101)-|110)]r,q1,q2 . .2 4 .2 +[|00+) + |01+) + |10-) \n- |11-)]r,q1,q2 . .3 4 .3 +[|00-) - |01-) + |10+) + |11+)]r,q1,q2 . .4 4 11 =[|00)]r,q1 . . +[|01)]r,q1 \n. s1 (.) q2 44 11 +[|10)]r,q1 . sq2 2 (.)+ [|11)]r,q1 . sq3 2 (.). 44 EXAMPLE 3.3. (Encode quantum circuits \nwith qCCS) Quantum circuits consist of two different types of gates: unitary gates and quantum measurements. \nWe now show how to encode them using qCCS. To ease the notations, we allow quantum channels to input \nand output multiple qubits. We write the quantum channel c as c n if n qubits can be communicated through \nc simultaneously. In other words, the quantum capacity of c n is n qubits. nil?q.CN[].H[].M[]!;cq,qqq,qx.ex.11,X \nqubits. Then the unitary gate which implements U can be de\u00ad (if x = i then si[q2].d!q2.nil), Alicet = \nUnitary gate. Suppose U is a unitary operator acting on n Bobt = e?x. .ned as a process constant U(U), \nqv(U(U)) = \u00d8, with the 0=i=3 X Tel =(AlicetIBobt)\\{e}, For any . .D(H),wehave {q1,q2} (Tel, [|.)]q1,q2 \n. .) c?r -. ((CN[r, q1].H[r].M[r, q1; x].c!x.nilIBobt)\\{e}, [|.)]q1,q2 . .) t -. ((H[r].M[r, q1; x].c!x.nilIBobt)\\{e}, \nCNr,q1 ([|.)]q1,q2 . .)) t -. ((M[r, q1; x].c!x.nilIBobt)\\{e}, 1 j de.ning equation def U(U)= c n?eq].dnq.U(U). \nq.U[e!e We denote ar(U(U)) = n. Measurement gate. Suppose M is a quantum measurement act\u00ading on n qubits. \nThen the measurement gate which implements M can be de.ned as def M(M)= c n?eq; x].e!x.dnq.M(M). q.M \n[e!e We denote ar(M(M)) = n. For any . .D(H),wehave c n?re (U(U),.) -. r].dnr.U(U),.) (U[e!e t -. (2) \n(dn[|ej)]r,q1 . s (.)) !r.eU(U),Ure.U) re q2 4 0=j=3 dn!re -. (U(U),Ure.U ) t -. re 1/4 ((c!0.nilIBobt)\\{e}, \n[|00)]r,q1 . .)E1/4 ((c!1.nilIBobt)\\{e}, [|01)]r,q1 . s 1 and (.)) q2 n?re -. 2 q2 c E1/4 ((c!2.nilIBobt)\\{e}, \n[|10)]r,q1 . sE1/4 ((c!3.nilIBobt)\\{e}, [|11)]r,q1 . s (M[re; x].e!x.dnEi.I pi (e!.i.dn (.)) (M(M),.) \n!e r.M(M ),.) t -. 3 (.)), /pi) q2  where M = P .iEi and pi =tr(Ei .)/tr(.). Now for each i.I re i . \nI, (e!.i.dn!erei .Erei r.M(M),E/pi) e!.i(dnr.M(M),Eri /pi) -. !ee.Erei dn!reii -. (M(M),Ere.Ere/pi). \nSuppose G1 and G2 are two (unitary or measurement) gates with ar(G1)= ar(G2)= n. The sequential composition \nof G1 and G2 can be de.ned as def n n nn G1 .G2 =(LsIG1[e /c , fn/dn]IG2[fn/c , g /dn]IRs)\\ {c, e n , \nfn , g n} def def where Ls = c n?en!eand Rs = g nq.dnq.c!0.Rs. q.e q.c?x.Ls ?e!e If ar(G1)= m and ar(G2)= \nn, then the parallel composition of G1 and G2 is de.ned as def m m nn G1 .G2 =(LpIG1[e1 /c , f1 m/dm]IG2[e2 \n/c , f2 n/dn] IRp)\\{c, e m 1 , f1 m , e n 2 , f2 n} def m+nm n where Lp =?e1 !l(e2 !r(e c q.e q).e q).c?x.Lp, \ndef fm r1.fn r2.dm+n1 Rp =? e2 ? e!(re1re2).c!0.Rp, l(qe) denotes the pre.x of qewith length m while \nr(qe) the post.x of qewith length n,and re1re2 is the concatenation of re1 and re2.  4. (Weak) Bisimulation \nbetween quantum processes To present the notion of bisimulation which abstracts the internal actions \ncaused by local quantum operations and (classical or quan\u00adtum) communications, we .rst extend the transition \nrelation de.ned in Section 3. DEFINITION 4.1. We de.ne the relation =.. Con \u00d7 D(Con) as the smallest \nrelation satisfying the following conditions: (1) C =.C; t (2) if C -. Ei.I pi Ci and Ci =. \u00b5i for each \ni . I,then P C =. pi\u00b5i. Similar to -., we can also lift =. to D(Con) \u00d7 D(Con) by writing \u00b5 =. . if for \neach C. supp(\u00b5), C =. .C for some .C P such that . = \u00b5(C).C. C.supp(\u00b5) For any \u00b5, . . D(Con) and s = \na1 ...an . Act * ,we say that \u00b5 can evolve into . by a weak s-transition, denoted by s \u00b5 =. .,ifthereexist \n\u00b51,...,\u00b5n+1,.1,...,.n . D(Con),such ai that \u00b5 =. \u00b51, \u00b5n+1 = ., and for each i =1,...,n, \u00b5i -. .i and \n.i =. \u00b5i+1. LEMMA 4.1. Let \u00b5 = Ei.I pi Ci and s . Act *.Then \u00b5 =.s . if and only for each i . I, Ci =s. \n.i for some .i such that P i.I pi.i = .. a a Note that \u00b5 =.-. . and \u00b5 =. . are different since in the \nformer the last action of every execution branch from \u00b5 to . must be a while in the latter the action \na appeared in each branch is not necessarily the last one. With these notations, we can extend Lemma \n3.2 to the weak transition case. LEMMA 4.2. If (P, .) =.s \u00b5,then (1) tr(.)=tr(\u00b5); (2) there exist a set \nof super-operators {Ei : i . I} acting on Hqv(P ).bv(s) where bv(a1 ...an)= bv(a1) .\u00b7\u00b7\u00b7. bv(an), such \nthat for any s .D(H); ss s (P, s) =. Ei.I qi (Pi, Ei(s)/qi ) where qis =tr(Ei(s))/tr(s); (3) for any \nsuper-operator E acting on H qv(P ).bv(s), we have s (P, E(.)) =.E(\u00b5). 4.1 Bisimulation To present the \nnotion of bisimulation, we need a de.nition from [2]. DEFINITION 4.2. Let R. Con \u00d7 Con,and \u00b5, . . D(Con). \nA weight function for (\u00b5, .) w.r.t. R is a function d : supp(\u00b5) \u00d7 supp(.) . [0, 1] which satis.es (1) \nFor all C, D. Con, X X d(C, D)= \u00b5(C),d(C, D)= .(D); D.supp(.) C.supp(\u00b5) (2) If d(C, D) > 0, then (C, \nD) .R. We write \u00b5R. if there exists a weight function for (\u00b5, .) w.r.t. R. LEMMA 4.3. Let \u00b5, . . D(Con).Then \n\u00b5R. if and only if \u00b5 = PP piCi and . = piDi such that CiRDi for each i . I. i.Ii.I In particular, if \nCR\u00b5 then CRD for each D. supp(\u00b5). P Note that when we write \u00b5 = i.I piCi,then Ci denotes a simple distribution. \nAs a consequence, the Cis are not necessarily distinct. DEFINITION 4.3. A relation R. Con \u00d7 Con is called \na bisimu\u00adlation if for any (P, .), (Q, s). Con, (P, .)R(Q, s) implies that qv(P )= qv(Q), trqv(P )(.)=trqv(Q)(s),and \nc?q c?q (1) whenever (P, .) -. \u00b5,then (Q, s) =.-. . for some . such that for any super-operator E acting \non H , qv(\u00b5)-{q} E(\u00b5)RE(.); a (2) whenever (P, .) -. \u00b5 where a is not a quantum input, then there exists \n. such that (Q, s) =a.b. and \u00b5R.; c?q c?q (3) whenever (Q, s) -. .,then (P, .) =.-. \u00b5 for some \u00b5 such \nthat for any super-operator E acting on H , qv(.)-{q} E(\u00b5)RE(.); a (4) whenever (Q, s) -. . where a is \nnot a quantum input, then there exists \u00b5 such that (P, .) =a.b\u00b5 and \u00b5R.. Here for any s . Act * , sbis \nthe string obtained from s by deleting all the occurrences of t . DEFINITION 4.4.(1) Twoquantumcon.gurations \n(P, .) and (Q, s)are bisimilar, denoted by (P, .) (Q, s), if there exists a bisimulation R such that \n(P, .)R(Q, s); (2) Two quantum processes P and Q are bisimilar, denoted by P Q, if for any quantum state \n. .D(H) and any indexed v/ev/e set veof classical values, (P {ex},.) (Q{ex},.). Here xeis the set of \nfree classical variables contained in P and Q. Some design decisions made in De.nition 4.3 deserve justi.ca\u00adtion \nand explanation: Recall that in the de.nition of bisimulations proposed in [5], a clause If (P, .) -. \nand (Q, s) -.,then . = s (3) is presented to guarantee that the quantum operations applied by P and Q, \nwhich give rise only to invisible actions, are the same. That de.nition, however, does not .t well with \nrecursive de.nitions since recursively de.ned processes will generally  never reach a terminating process. \nIn De.nition 4.3, we solve this problem by requiring instead that trqv(P )(.)=trqv(Q)(s). (4) Obviously, \nwhen (P, .) -. and (Q, s) -.,and P and Q do not hold any quantum variables, Eqs. (3) and (4) are equivalent. \nHowever, Eq.(4) can deal with processes which have in.nite behaviors. For example, let def A = c?q.Set0[q].c!q.A \nand 1 X def B = c?q.M0,1[q; x]. (if x = .i then si[q].c!q.B), i=0 where Set0 is the super-operator which \nsets the target qubit to |0),and M0,1 is the measurement according to the computa\u00adtionalbasis;thatis, \nM0,1 = .0|0)(0| + .1|1)(1|. Intuitively, B can be regarded as an implementation of A specifying how to \nset the input qubit to |0). We now show A B indeed holds under our de.nition of bisimulation. Let Con0,. \n= {(A, .), (B, .)} Con1,q,. = {(A1q,.), (A2q,.0), (B1q,.), (B2qj ,.j ), (B3q,.0) : j =0, 1} where A1q \n= Set0[q].c!q.A, A2q = c!q.A, 1 X B1q = M0,1[q; x]. (if x = .i then si[q].c!q.B), i=0 1 X B2qj =(if .j \n= .i then si[q].c!q.B), i=0 B3q = c!q.B,and .j =[|j)]q . trq..Let R. Con \u00d7 Con such that (P, s)R(Q, .) \nif and only if there exist q . qV ar and . .D(H) such that (P, s) and (Q, .) are simultaneously included \nin Con0,. or Con1,q,.. Then it is not dif.cult to prove that R is a bisimulation. Thus A B. Furthermore, \nby replacing Eq.(3) with Eq.(4), the derived bisimilarity will be preserved by restriction. Take the \nexam\u00adple in [5]. Let U1, U2, V1, V2 be unitary operators such that U2U1 = V2V1 but U1 = V1.Let P = U1[q].c!0.U2[q].nil,Q \n= V1[q].c!0.V2[q].nil. Then P and Q are bisimilar but P \\{c} and Q\\{c} are not if Eq.(3) is required \nin the de.nition. However, in our de.nition presented here, P \\{c} and Q\\{c} are also bisimilar since \nin Eq.(4) we only need to consider the reduced states on the sys\u00adtems qv(P )= qv(Q). The un.nished quantum \noperations, which are blocked by the restriction, are not taken into account when comparing the accompanying \nquantum states. Another question one may ask is that why we require qv(P )= qv(Q) in the de.nition, which \nexcludes the pair P = I[q].nil and Q = nil to be bisimilar. The reason is, although P and Q have the \nsame effect (they both do nothing at all) on the environment, they are indeed different under parallel \ncomposition. For example, if q . qv(R), then the process QIR is valid while P IR is not. In Clause (1), \nwe require E(\u00b5)RE(.) for any super-operator E acting on H . The reason for this rather strange re\u00ad qv(\u00b5)-{q} \nquirement is as follows. To check whether two con.gurations are bisimilar, we have to feed them with \nall possible inputs. In classical process algebra, this is realized by requiring that the input value \nis arbitrarily chosen. In quantum process algebra, however, since the state of all environmental systems \nis .xed for a given con.guration, only requiring the arbitrariness of the input system is not suf.cient. \nNote that the state-preparation op\u00aderation and the swap operation are both special super-operators. Our \nde.nition actually includes the possibility of inputing an arbitrary system which lies in an arbitrary \nstate. Furthermore, this requirement is also essential in proving the congruence property of the derived \nbisimilarity (See Theo\u00adrem 4.3). EXAMPLE 4.1. (Superdense coding revisited) This example is de\u00advoted \nto proving rigorously that the protocol presented in Example 3.1 indeed sends two bits of classical information \nfrom Alice to Bob by transmitting a qubit, with the help of a maximally entan\u00adgled state. Let Sdcspec \n= c?x.Setx[q1,q2].d!x.nil be the speci.cation of superdense coding protocol, where 3 X Setx[q1,q2].d!x.nil \n=(if x = i then Seti[q1,q2].d!x.nil), i=0 and Seti, i =0,..., 3, is the 2-qubit super-operator which \nsets the target qubits to |ei);thatis, forany . .D(H), Seti,q,q1 (.)=[|ei)]q,q1 . trq,q1 (.). We have \nSetx[q1,q2] in the speci.cation simply for technical rea\u00adsons: to make qv(Sdcspec)= qv(Sdc) andtoset \nq1,q2 to the re\u00adquired .nal states. For any . .D(H{q1,q2}),and v .{0, 1, 2, 3}, (Sdcspec, [|.)]q1,q2 \n. .) c?v -. (Setv[q1,q2].d!v.nil, [|.)]q1,q2 . .) t -. (d!v.nil, [|ve)]q1,q2 . .) d!v -. (nil, [|ve)]q1,q2 \n. .). We can easily prove (Sdc, [|.)]q1,q2 . .) (Sdcspec, [|.)]q1,q2 . .) by checking that R = {((Sdc, \n..), (Sdcspec,..))} .{((P, .), (Setv[q1,q2].d!v.nil,..)): v =0,..., 3, c?v (Sdc, ..) =.(P, .), and qv(P \n)= \u00d8}.{(((nilId!v.nil)\\{e},.ve), (d!v.nil,.ve)): v =0,..., 3}.{(((nilInil)\\{e},.ve), (nil,.ve)): v =0,..., \n3} is a bisimulation, where .. =[|.)]q1,q2 . .. Note that Sdc Sdcspec does not hold in general since \nsuper\u00addense coding protocol needs the assistance of a maximally entan\u00adgled state to realize the intended \ntask. EXAMPLE 4.2. (Teleportation revisited) This example is devoted to proving rigorously that the protocol \npresented in Example 3.2 indeed teleports any unknown quantum state from Alice to Bob, again with the \nhelp of a maximally entangled state. To employ our notion of bisimulation, we need to modify the original \nde.nition of Alice s protocol in Example 3.2 as follows: Alice t ' = c?q.CN [q, q1].H[q].M[q, q1; x].Set.[q, \nq1].e!x.nil  and Tel ' =(Alice ' tIBobt)\\c where Set. is similar to Setx in the previous example. Let \nTelspec = c?q.SW AP1,3[q, q1,q2].d!q2.nil be the speci.cation of teleportation protocol, where SW AP1,3 \nis a 3-qubit unitary operator which exchanges the states of the .rst and the third qubits, keeping the \nsecond qubit untouched. Again, we involve qubit q1 here just for technique reason: to make qv(Telspec)= \nqv(Tel ' ). Then for any . .D(H) and {q1,q2} r = q1,q2, (Telspec, [|.)]q1,q2 . .) c?r -. (SW AP1,3[r, \nq1,q2].d!q2.nil, [|.)]q1,q2 . .) t -. (d!q2.nil, [|.)]q1,r . .) d!q2 -. (nil, [|.)]q1,r . .). We can \nnow prove (Tel ' , [|.)]q1,q2 . .) (Telspec, [|.)]q1,q2 . .) by checking that R = {((Tel ' ,.q1,q2 ), \n(Telspec,.q1,q2 ))} .. .{((P, .), (SW AP1,3[r, q1,q2].d!q2.nil,sq1,q2 ): . c?r (Tel ' ,sq1,q2 ) =.(P, \n.),s .D(H), . {q1,q2} qv(P )= {r, q1,q2}, and r = q1,q2} .{((P, .), (d!q2.nil,sq1,r): . ' c?r (Tel ,sq1,q2 \n) =. \u00b5 with (P, .). supp(\u00b5), . s .D(H{q1,q2}),qv(P )= {q2}, and r = q1,q2} .{(((nilInil)\\{c},sq1,r), \n(nil,sq1,r)): s .D(H)} .. {q1,r} is a bisimulation, where sq,q 1 =[|.)]q,q1 . s. . Again, Tel ' Telspec \ndoes not hold in general since Telepor\u00adtation protocol is valid only when a maximally entangled state \nis provided and consumed. The following example shows the bimilarity between quantum processes. EXAMPLE \n4.3. (Encode quantum circuits by qCCS, revisited) Us\u00ading the notion presented in Example 3.3, we can \nprove the follow\u00ading properties considering the sequential composition and parallel composition of quantum \ngates: (1) U(U) .U(V ) U(VU); (2) U(U) .G(M) G(U MU) .U(U); (3) U(U) .U(V ) U(V . V ).  The proof \nis straightforward, and we only take (1) as an example. Let R = {((U(U) .U(V ),.), (U(VU),.)): . .D(H)} \nc n?re .{((P, s), (Q, .)): (U(U) .U(V ),.) =.(P, s) and c n?re (U(VU),.) =.(Q, .) where re. qV ar and \n. .D(H)} n?e c r,dn!re .{((P, s), (Q, .)): (U(U) .U(V ),.) =.(P, s) and c n?e r r,dn!e (U(VU),.) =.(Q, \n.) where re. qV ar and . .D(H)}. It is easy to check that R is a bisimulation. So we have (U(U) . U(V \n),.) (U(VU),.) for all . .D(H) and then U(U) . U(V ) U(VU). To conclude this section, we prove some properties \nof bisimi\u00adlarity which are useful in the rest of this paper. LEMMA 4.4. If (P, .) (Q, s), then for any \nsuper-operator E acting on H , we have tr(E(.)) = tr(E(s)). In particular, qv(P ) tr(.)=tr(s). THEOREM \n4.1. is a bisimulation on Con, and it is an equiva\u00adlence relation. THEOREM 4.2. For any con.gurations \n(P, .) and (Q, s), (P, .) (Q, s) if and only if qv(P )= qv(Q), trqv(P )(.)=trqv(Q)(s), and c?q c?q (1) \nwhenever (P, .) -. \u00b5,then (Q, s) =.-. . for some . such that for any super-operator E acting on H qv(\u00b5)-{q}, \nE(\u00b5) E(.); a (2) whenever (P, .) -. \u00b5 where a is not a quantum input, then ab there exists . such that \n(Q, s) =. . and \u00b5 .; and the symmetric conditions of (1) and (2).  4.2 Bisimilarity congruence We now \nturn to prove the congruence properties of bisimulation. First, we show that the bisimulation for con.gurations \nis preserved by all static constructors. THEOREM 4.3. If (P, .) (Q, s) then (1) (P IR, .) (QIR, s); \n(2) (P [f],.) (Q[f],s); (3) (P \\L, .) (Q\\L, s);  (4) (if b then P, .) (if b then Q, s). Proof. Let \nus prove (1); other cases are simpler. Let R = {((P IR, E(.)), (QIR, E(s))): (P, .) (Q, s) and E is \na super-operator acting on H}. qv(P ) It suf.ces to show that R is a bisimulation. Suppose (C, D) . R \nwhere C = (P IR, E(.)) and D = (QIR, E(s)) for some (P, .) (Q, s),and E is a super-operator acting on \nH .Then qv(P ) qv(P )= qv(Q) and trqv(P )(.)=trqv(Q)(s) by Theorem 4.2. Thus qv(P IR)= qv(QIR) and trqv(P \nIR)(E(.)) = trqv(QIR)(E(s)). a Let (P IR, E(.)) -. \u00b5 for some a and \u00b5. There are three cases to consider. \nI: The transition is caused by P solely. We need to further con\u00adsider two subcases: i: a = c?q is a quantum \ninput. Then there exists a transition c?q (P, .) -. (P ' ,.) and \u00b5 = (P ' IR, E(.)). By the assump\u00adtion \nthat (P, .) (Q, s),wehave c?q (Q, s) =. Ei.I pi (Qi' ,si) -. Ei.I pi (Qi,si) such that for any super-operator \nF acting on H , qv(P 1)-{q} (P ' , F(.)) (Qi, F(si)) (5) holds for any i . I.Then (Q, E(s)) =. Ei.I pi \n (Q ' i, E(si)) by Lemma 4.2(3), from which we further de\u00adrive c?q (Q, E(s)) =.-. Ei.I pi (Qi, E(si)) \nand c?q (QIR, E(s)) =.-. . = Ei.I pi (QiIR, E(si)). For any super-operator F ' acting on H ,we qv(P 1IR)-{q}obtain \nfrom Lemma 3.1 that the composite map F ' .E is a super-operator acting on H . Now using Eq.(5)  qv(P \n1)-{q} we have '' ' (P, F (E(.))) (Qi, F (E(si))), '' ' and thus (P IR, F (E(.)))R(QiIR, F (E(si))). \nThat is, F ' (\u00b5)RF ' (.) as required. ii: a is not a quantum input. Then there exists a transition a \n(P, .) -. \u00b51 = Ei.I pi (Pi,.i) and \u00b5 = Ei.I pi (PiIR, E(.i)) by Lemma 3.2(3). From the assumption that \n(P, .) (Q, s),wehave (Q, s) =a.b.1 = Ej.J qj (Qj ,sj ) and \u00b51 .1 by Theorem 4.2. Noting that E is a \nsuper\u00adoperator on H ,wehave (Q, E(s)) =ab. Ej.J qj qv(Q) (Qj , E(sj )) by Lemma 4.2(3). So it holds that \n(QIR, E(s)) =a.b. = Ej.J qj (Qj IR, E(sj )). Now for each i . I and j . J, (Pi,.i) (Qj ,sj ) implies \n(PiIR, E(.i))R(Qj IR, E(sj )) since from Lemma 3.1, E is also a super-operator acting on H . Thus we \nhave qv(Pi) \u00b5R. by Lemma 4.3, by noting that \u00b51 .1. II: The transition is caused by R solely. We also \nneed to further consider two subcases: i: a = c?q is a quantum input where q . qv(P ).Then c?q we have \n(R, E(.)) -. (R ' , E(.)) for some R ' ,and c?q \u00b5 = (P IR ' , E(.)). Thus (R, E(s))-. (R ' , E(s)). c?q \nBy inference rule Inp-Int,wehave (QIR, E(s)) -. (QIR ' , E(s)) since q . qv(Q). Now for any super\u00adoperator \nF acting on H , the composite map qv(P IR1)-{q} F.E is a super-operator acting on H from the fact qv(P \n) that qv(P IR ' ) -{q}. qv(P ) -{q} = qv(P ). Thus (P IR ' , F(E(.)))R(QIR ' , F(E(s))) from the de.nition \nof R. ii: a is not a quantum input. Then by Lemma 3.2(2), there a exists a transition (R, E(.)) -. Epi \n(Ri, Ei(E(.))/pi)where Ei is a super-operator on Hqv(R), pi =tr(Ei(E(.)))/tr(E(.)), and \u00b5 = Epi (P IRi, \nEi(E(.))/pi).Thenwederive a (R, E(s)) -. Eqi (Ri, Ei(E(s))/qi) where qi =tr(Ei(E(s)))/tr(E(s)), again \nby Lemma 3.2(2). Thus a (QIR, E(s)) -. . = Eqi (QIRi, Ei(E(s))/qi). Notice that for any i,wehave pi = \nqi by Lemma 4.4, and ((P IRi, Ei(E(.))), (QIRi, Ei(E(s)))) .R since the composite map Ei .E is a super-operator \nacting on H (qv(R) n qv(P )= \u00d8 by the validity of P IR). qv(P ) Then it follows that \u00b5R. from Lemma \n4.3. III: The transition is caused by a communication between P and R. Without loss of generality, we \nassume that c?qc!q (P, .) -. (P ' ,.), (R, .) -. (R ' ,.), and \u00b5 = (P ' IR ' , E(.)). Other cases are \nsimpler. Then q . c!q qv(P ) by the validity of P IR,and (R, .) -. (R ' ,.) for any . .D(H). From the \nassumption that (P, .) (Q, s),wehave c?q (Q, s) =. Ei.I pi (Qi' ,si) -. Ei.I pi (Qi,si) such that for \nany i . I and any super-operator F acting on H qv(P 1)-{q}, it holds that (P ' , F(.)) (Qi, F(si)).In \nparticular, we have (P ' , E(.)) (Qi, E(si)) (6) since qv(P ) . qv(P ' ) -{q}. Noting that E is a super-operator \non H ,wehave (Q, E(s)) =. Ei.I pi (Qi' , E(si)) by qv(Q) Lemma 4.2(3), from which we derive further c?q \n(Q, E(s)) =.-. Ei.I pi (Qi, E(si)), and t (QIR, E(s)) =.-. . = Ei.I pi (QiIR ' , E(si)). Furthermore, \nfor any i . I,wehave ' ' ' ((P IR, E(.)), (QiIR, E(si))) .R by Eq.(6). That is, \u00b5R. as required. a The \nsymmetric form when (QIR, E(s)) -. . can be similarly proved. So R is a bisimulation on Con. The result \nfollows by noting that the identity transformation is also a super-operator on H . D qv(P ) From Theorem \n4.3, the superdense coding protocol and telepor\u00adtation protocol presented in Section 3 is still valid \nin any quantum process context which consists only of parallel composition, rela\u00adbeling, restriction, \nand conditional. The con.guration bisimulation is not preserved, however, by dynamic constructors such \nas pre.x and summation. A coun\u00adterexample is as follows. Let P = M0,1[q; x].nil where M0,1 = .0[|0)]+ \n.1[|1)] is the 1-qubit measurement according to the com\u00adputational basis, Q = I[q].nil,and . =[|0)]q \n. s where s . D(Hq).Then (P, .) (Q, .),but (H[q].P, .) (H[q].Q, .)where H is the Hadamard operator. Nevertheless, \nsimilar to standard classical CCS, the bisimula\u00adtion for quantum processes is preserved by all the combinators \nof qCCS except for summation. THEOREM 4.4. If P Q then (1) a.P a.Q, a .{t, c?x, c!e, c?q, c!q, E[qe],M \n[qe; x]}; (2) P IR QIR; (3) P [f] Q[f]; (4) P \\L Q\\L;  (5) if b then P if b then Q.  4.3 Congruent \nequivalence of quantum processes As in classical process algebra, the bisimilarity is not preserved \nby summation combinator + . To deal with this problem, we introduce the notion of equality between quantum \nprocesses based on . DEFINITION 4.5. Two con.gurations (P, .) and (Q, s) are said to be equal, denoted \nby (P, .).(Q, s),if qv(P )= qv(Q), trqv(P )(.)=trqv(Q)(s),and c?q c?q (1) whenever (P, .) -. \u00b5,then (Q, \ns) =.-. . for some . such that for any super-operator E acting on H , qv(\u00b5)-{q} E(\u00b5) E(.); a (2) whenever \n(P, .) -. \u00b5 where a is not a quantum input, then there exists . such that (Q, s) =a. . and \u00b5 .; and \nthe symmetric conditions of (1) and (2).  The only difference between the de.nitions of and is that \nin the latter the =ab. transition in Clause (2) is replaced by =a.;that is, the matching action for a \nt-move has to be at least one t-move. Furthermore, we lift the de.nition of equality to quantum pro\u00adcessesasfollows.For \nP, Q . qP roc, PQ if and only if for any quantum state . .D(H) and any indexed set veof classical values, \n(P {v/exe},.).(Q{ex},.) where e v/ex = fv(P ) . fv(Q). It is worth noting that all the bisimulation relations \nproved in the examples of previous subsections are also valid when is replaced by . Now we prove that \nthe equality relation is preserved by various process constructors of qCCS. THEOREM 4.5. If PQ then (1) \na.P a.Q, a .{t, c?x, c!e, c?q, c!q, E[qe],M[qe; x]}; (2) P + RQ + R; (3) P IRQIR; (4) P [f] Q[f]; \n(5) P \\LQ\\L;   (6) if b then P if b then Q. The monoid laws and the static laws in classical CCS can \nalso be generalized to qCCS. THEOREM 4.6. For any P, Q, R . qP roc, K, L . Chan, any relabeling functions \nf, f ' , and any action pre.x a, we have (1) P + nil P ; (2) P + PP ; (3) P + QQ + P ;  (4) P +(Q \n+ R)(P + Q)+ R;  (10) (P + Q)\\LP \\L + Q\\L; (11) (P + Q)[f] P [f]+ Q[f];  (5) P Inil P ; (6) P IQ QIP \n; (7) P I(QIR) (8) (a.P )\\L (9) (a.P )[f] (P IQ)IR;j nil, a.P \\L, f(a).P [f]; if cn(a) . L otherwise \n (12) P \\LP if cn(P ) n L = \u00d8,where cn(P ) is the set of free channel names used in P ; (13) (P \\K)\\LP \n\\(K . L); (14) (P IQ)\\LP \\LIQ\\L,if cn(P ) n cn(Q) n L = \u00d8; (15) P [f]\\LP \\f-1(L)[f ];  (16) P [Id] \nP where Id is the identity relabeling function; (17) P [f] P [f ' ] if the restrictions of f and f ' \non cn(P ) coincide;  (18) P [f][f ' ] P [f ' . f]; (19) (P IQ)[f] P [f]IQ[f] if the restriction of f \non cn(P ) . cn(Q) is one-to-one. a In the following theorem, we simply write P -. P ' if for any a . \n.D(H), (P, .) -. (P ' ,.). THEOREM 4.7. (Expansion Law) Let P =(P1[f1]I\u00b7\u00b7\u00b7IPn[fn])\\L. Then X. ' Pfi(a).(P1[f1]I\u00b7\u00b7\u00b7IPi \n[fi]I\u00b7\u00b7\u00b7IPn[fn])\\L : o a' Pi -. Pi and fi(cn(a)) . L X. ' + fi(c?x).(P1[f1]I\u00b7\u00b7\u00b7IPi [fi]I\u00b7\u00b7\u00b7IPn[fn])\\L \n: o c?v' Pi -. Pi {v/x} for any v, and fi(c) . L X. + E[qe].(P1[f1]I\u00b7\u00b7\u00b7IPi ' [fi]I\u00b7\u00b7\u00b7IPn[fn])\\L : o t' \n(Pi,.) -. (Pi , Eqe(.)) for any . X. + M[qe; x].(P1[f1]I\u00b7\u00b7\u00b7IPi ' [fi]I\u00b7\u00b7\u00b7IPn[fn])\\L : t' (Pi,.) -. Ej.J \npj (Pi {.j /x},Kj,qe.Kj,qe/pj ) )X for any ., and M = .j Kj j.J X. '' + t.(P1[f1]I\u00b7\u00b7\u00b7IPi [fi]I\u00b7\u00b7\u00b7IPj \n[fj ]I\u00b7\u00b7\u00b7IPn[fn])\\L : a\u00df Pi -. Pi ' ,Pj -. Pj ' ,i < j,fi(cn(a)) = fj (cn(\u00df)), and among a and \u00df there \nis exactly one input and one output}. We now turn to examine the properties of the congruence re\u00adlation \nunder recursive de.nitions. To this end, we assume a set of process variable schemes, ranged over by \nX,Y, ... . Assigned to each process variable scheme X there is a non-negative integer ar(X).If qeis an \nindexed set of distinct quantum variables with |qe| = ar(A),then X(qe) is called a process variable. \nProcess expressions may be de.ned by adding the following clause into De.nition 3.1 (and replacing the \nword process by the phrase process expression and qProc by qExp ): (15) X(qe) . qExp,and qv(X(qe)) = \nqe where X(qe) is a process variable. We use metavariables E,F, ... to range over process expressions. \nSuppose that E is a process expression, and {Xi(qei): i . I} is a family of process variables. If {Pi \n: i . I} is a family of processes such that qv(Pi) . qei for all i, then we write E{Pi/Xi(qei): i . I} \nfor the process obtained by replacing simultaneously Xi(qei) in E with Pi for all i . I. DEFINITION 4.6. \nLet E and F be process expressions containing at most process variables {Xi(qei): i . I}.Then E and F \nare equal, denoted by EF , if for all family {Pi : i . I} of quantum processes with qv(Pi) . qei,wehave \nE{Pi/Xi(qei): i . I}. F {Pi/Xi(qei): i . I}. The next theorem shows that is also preserved by recursive \nde.nitions. def THEOREM 4.8. (1) If A(qe)= P ,then A(qe) P ; (2) Let {Ei : i . I} and {Fi : i . I} be \ntwo families of process expressions containing at most process variables {Xi(qei): i . I}, and Ei Fi \nfor each i . I.If {Ai(qei): i . I} and {Bi(qei): i . I} be two families of process constants such that \ndef Ai(qei)= Ei{Aj (qej )/Xj (qej ): j . I} def Bi(qei)= Fi{Bj (qej )/Xj (qej ): j . I}, then Ai(qei) \nBi(qei) for all i . I. Finally, the uniqueness of solutions of equations can be proved for process expressions \nin qCCS. DEFINITION 4.7. Given a process variable X(qe) and a process expression E, we call  X(qe) is \nsequential in E if every subexpression of E which con- P tains X(qe), excluding X(qe) itself, is of the \nform a.F , i.I Fi,  or if b then F ; X(qe) is guarded in E if each occurrence of X(qe) is within some \nsubexpression a.F of E where a is a (classical or quantum) input or output. THEOREM 4.9. Let {Ei : i \n. I} be a family of process expres\u00adsions containing at most process variables {Xi(qei): i . I}, and each \nXj (qej ) is sequential and guarded in each Ei.Let {Pi : i . I}and {Qi : i . I} be two families of quantum \nprocesses such that qv(Pi) . qv(Qi) . qei for each i, and Pi Ei{Pj /Xj (qej): j . I} Qi Ei{Qj /Xj (qej \n): j . I}, then Pi Qi for all i . I. To illustrate the power of the theorems proved in this section, \nlet us reconsider Example 4.3. We will provide another proof for U(U) .U(V ) .U(VU) using the expansion \nlaw and the unique\u00adness of solutions of equations. For simplicity, we only consider the special case \nwhere U and V are both 1-qubit unitary operators. Re\u00adcall the de.nition of U(U) .U(V ) in Example 3.3: \ndef U(U) .U(V )=(LsIU(U)[e/c, f/d]IU(V )[f/c, g/d]IRs)\\L where L = {c, e, f, g}. Then from Theorem 4.8(1), \nand repeatedly using Theorems 4.7 and 4.5, we have U(U) .U(V ) c?q.t.U [q].t.V [q].t.d!q.t.U(U) .U(V \n) where the .rst t action is caused by interaction between Ls and U(U)[e/c, f/d], the second one between \nU(U)[e/c, f/d] and U(V )[f/c, g/d], the third one between U(V )[f/c, g/d] and Rs, while the last one \nbetween Rs and Ls. On the other hand, by Theorem 4.8(1) we have U(VU) c?q.V U [q].d!q.U(VU). Now let \nX be a quantum process variable with qv(X)= \u00d8,and E = c?q.t.U [q].t.V [q].t.d!q.t.X, F = c?q.V U [q].d!q.X \nbe two quantum process expressions. Then E and F are both sequential and guarded, and EF .Sowehave U(U) \n.U(V ) U(VU) from Theorem 4.9.  5. Conclusions and further work In this paper, we propose a formal model \nqCCS, which is a quantum extension of classical value-passing CCS, to model and rigorously analyze the \nbehaviors of quantum distributed computing and quan\u00adtum communication protocols. We de.ne a notion of \nequivalence, based on bisimulation, for quantum processes in qCCS, and prove that it is preserved by \nall process constructors, including parallel composition, restriction, and recursive de.nitions. This \nis the .rst congruence relation for process algebras proposed so far aiming at modeling quantum communicating \nsystems. Various examples are fully examined to show the expressiveness as well as the proof techniques \nof qCCS. We conclude this paper by pointing out some topics for fur\u00adther study. In the present paper, \nonly exact bisimulation is pre\u00adsented where two quantum processes are either bisimilar or non\u00adbisimilar. \nObviously, such a bisimulation cannot capture the idea that a quantum process approximately implements \nits speci.ca\u00adtion. Note that this approximation, or imprecision, is especially es\u00adsential for quantum \nprocess algebra since quantum operations con\u00adstitute a continuum and exact bisimulation is not always \npracti\u00adcally suitable for their physical implementation. To provide tech\u00adniques and tools for approximate \nreasoning, a quanti.ed version of bisimulation, which de.nes for each pair of quantum processes a bisimulation-based \ndistance characterizing the extent to which they are bisimilar, has already been proposed for purely \nquantum processes in [18]. We plan to extend it to qCCS de.ned in this pa\u00adper. Another interesting direction \nworthy of being researched is to expand the application scope of qCCS to model and analyze the security \nproperties of quantum cryptographic systems. By intro\u00adducing cryptographic primitives, such as constructors \nfor encryp\u00adtion and decryption, into pi-calculus, the Spi calculus [1] has been very successful in cryptographic \nprotocol analysis. We believe that a similar extension of our qCCS will provide tools for analyzing quantum \ncryptographic protocols such as BB84 quantum key dis\u00adtribution protocol.  References [1] M. Abadi and \nA. Gordon. A calculus for cryptographic protocols: the spi calculus, 1997. [2] C. Baier and M. Kwiatkowska. \nDomain equations for probabilistic processes. Mathematical Structure in Computer Science, 1999. [3] C. \nH. Bennett and S. J. Wiesner. Communication via one-and two\u00adparticle operators on einstein-podolsky-rosen \nstates. Physical Review Letters, 69(20):2881 2884, 1992. [4] C. H. Bennett, G. Brassard, C. Crepeau, \nR. Jozsa, A. Peres, and W. Wootters. Teleporting an unknown quantum state via dual classical and epr \nchannels. Physical Review Letters, 70:1895 1899, 1993.  [5] Y. Feng, R. Duan, Z. Ji, and M. Ying. Probabilistic \nbisimulations for quantum processes. Information and Computation, 205(11):1608 1639, 2007. [6] S. J. \nGay and R. Nagarajan. Communicating quantum processes. In J. Palsberg and M. Abadi, editors, Proceedings \nof the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages (POPL), pages 145 157, \n2005. [7] L. K. Grover. Quantum mechanics helps in searching for a needle in a haystack. Physical Review \nLetters, 78(2):325, 1997. [8] M. Hennessy. A proof system for communicating processes with value-passing. \nFormal Aspects of Computer Science, 3:346 366, 1991. [9] M. Hennessy and A. Ing\u00b4ottir. olfsd\u00b4A theory \nof communicating pro\u00adcesses value-passing. Information and Computation, 107(2):202 236, 1993. [10] P. \nJorrand and M. Lalire. Toward a quantum process algebra. In P. Selinger, editor, Proceedings of the 2nd \nInternational Workshop on Quantum Programming Languages, 2004, page 111, 2004. [11] K. Kraus. States, \nEffects and Operations: Fundamental Notions of Quantum Theory. Springer, Berlin, 1983. [12] M. Lalire. \nRelations among quantum processes: Bisimilarity and congruence. Mathematical Structures in Computer Science, \n16(3): 407 428, 2006. [13] R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes, parts \ni and ii. Information and Computation, 100:1 77, 1992. [14] M. Nielsen and I. Chuang. Quantum computation \nand quantum infor\u00admation. Cambridge university press, 2000. [15] P. Selinger. Towards a quantum programming \nlanguage. Mathematical Structures in Computer Science, 14(4):527 586, 2004. [16] P. W. Shor. Algorithms \nfor quantum computation: discrete log and factoring. In Proceedings of the 35th IEEE FOCS, pages 124 \n134, 1994. [17] J. von Neumann. Mathematical Foundations of Quantum Mechanics. Princeton University Press, \nPrinceton, NJ, 1955. [18] M. Ying, Y. Feng, R. Duan, and Z. Ji. An algebra of quantum processes. ACM \nTransactions on Computational Logic (TOCL),10 (3):1 36, 2009.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Quantum cryptographic systems have been commercially available, with a striking advantage over classical systems that their security and ability to detect the presence of eavesdropping are provable based on the principles of quantum mechanics. On the other hand, quantum protocol designers may commit much more faults than classical protocol designers since human intuition is much better adapted to the classical world than the quantum world. To offer formal techniques for modeling and verification of quantum protocols, several quantum extensions of process algebra have been proposed. One of the most serious issues in quantum process algebra is to discover a quantum generalization of the notion of bisimulation, which lies in a central position in process algebra, preserved by parallel composition in the presence of quantum entanglement, which has no counterpart in classical computation. Quite a few versions of bisimulation have been defined for quantum processes in the literature, but in the best case they are only proved to be preserved by parallel composition of purely quantum processes where no classical communications are involved.</p> <p>Many quantum cryptographic protocols, however, employ the LOCC (Local Operations and Classical Communications) scheme, where classical communications must be explicitly specified. So, a notion of bisimulation preserved by parallel composition in the circumstance of both classical and quantum communications is crucial for process algebra approach to verification of quantum cryptographic protocols. In this paper we introduce a novel notion of bisimulation for quantum processes and prove that it is congruent with respect to various process algebra combinators including parallel composition even when both classical and quantum communications are present. We also establish some basic algebraic laws for this bisimulation. In particular, we prove uniqueness of the solutions to recursive equations of quantum processes, which provides a powerful proof technique for verifying complex quantum protocols.</p>", "authors": [{"name": "Yuan Feng", "author_profile_id": "81100140725", "affiliation": "University of Technology Sydney, Australia, Sydney, Australia", "person_id": "P2509677", "email_address": "Yuan.Feng@uts.edu.au", "orcid_id": ""}, {"name": "Runyao Duan", "author_profile_id": "81455605799", "affiliation": "University of Technology Sydney, Australia, Sydney, Australia", "person_id": "P2509678", "email_address": "runyao.duan@uts.edu.au", "orcid_id": ""}, {"name": "Mingsheng Ying", "author_profile_id": "81100627838", "affiliation": "University of Technology Sydney, Australia, Sydney, Australia", "person_id": "P2509679", "email_address": "mingsheng.ying@uts.edu.au", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926446", "year": "2011", "article_id": "1926446", "conference": "POPL", "title": "Bisimulation for quantum processes", "url": "http://dl.acm.org/citation.cfm?id=1926446"}