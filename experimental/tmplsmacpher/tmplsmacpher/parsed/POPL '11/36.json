{"article_publication_date": "01-26-2011", "fulltext": "\n Practical Af.ne Types Jesse A. Tov Riccardo Pucella Northeastern University, Boston, Massachusetts, \nUSA {tov,riccardo}@ccs.neu.edu Abstract module type RW LOCK = sig type (a, \u00df) array array of a identi.ed \nby \u00df Alms is a general-purpose programming language that supports type excl exclusive access practical \naf.ne types. To offer the expressiveness of Girard s linear type shared shared access logic while keeping \nthe type system light and convenient, Alms type \u00df@. : A grants .-level access to array \u00df uses expressive \nkinds that minimize notation while maximizing polymorphism between af.ne and unlimited types. val new \n: int . a . E \u00df.(a, \u00df) array A key feature of Alms is the ability to introduce abstract af.ne types via \nML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than \nthe principal usage restrictions of its implementation. This form of sealing allows the type system to \nnaturally and directly express a variety of resource management protocols from special-purpose type systems. \nWe present two pieces of evidence to demonstrate the validity of our design goals. First, we introduce \na prototype implementation of Alms and discuss our experience programming in the language. Second, we \nestablish the soundness of the core language. We also use the core model to prove a principal kinding \ntheorem. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features \nGeneral Terms Languages Keywords Af.ne types, linear logic, type systems, polymor\u00adphism, modules 1. A \nPractical Af.ne Type System Alms is a practical, general-purpose programming language with af.ne types. \nAf.ne types enforce the discipline that some values are not used more than once, which in Alms makes \nit easy to de.ne new, resource-aware abstractions. General-purpose means that Alms offers a full complement \nof modern language features suitable for writing a wide range of programs. Practical means that Alms \nis neither vaporware nor a minimal calculus it is possible to download Alms today and try it out. Rationale. \nResource-aware type systems divide into two camps: foundational calculi hewing closely to linear logic, \nand implemen\u00adtations of special-purpose type systems designed to solve special problems. We argue that \na general, practical type system based on Girard s linear logic (1987) can naturally and directly express \nmany of the special cases, such as region-based memory management, aliasing control, session types, and \ntypestate. To this end, the lan\u00adguage must satisfy several desiderata: Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PoPL 11, January 26 28, 2011, Austin, Texas, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 val acquireW:(a, \u00df) array . \n\u00df@excl val acquireR :(a, \u00df) array . \u00df@shared val release :(a, \u00df) array . \u00df@. . unit val set:(a, \u00df) array \n. int . a . \u00df@excl . \u00df@excl val get:(a, \u00df) array . int . \u00df@. . a \u00d7 \u00df@. end Figure 1. An interface for \nreader-writer locks (\u00a72) Convenience. Unlimited values are the common case, so working with them is as \nsmooth as in a conventional language. Expressiveness. A wide variety of resource-aware type systems appear \nnaturally as idioms. Familiarity. It is easy to use and understand. Pragmatics. It provides the trappings \nof a modern, high-level pro\u00ad gramming language, such as algebraic datatypes, pattern match\u00ad ing, exceptions, \nconcurrency, and modules. Soundness. It has a clear theoretical foundation. We show that Alms meets these \ncriteria. Alms employs a dependent kind system to determine whether a particular type is af.ne or unlimited \nand to support polymorphism over af.ne and unlimited types. This approach may sound compli\u00adcated, but \nin practice it is no stranger or harder to understand than the type systems of other functional programming \nlanguages. Af.ne types, a weakening of linear types, forbid duplication of some values; unlike with linear \ntypes, all values may be dropped. This .exibility is appropriate to a high-level, garbage-collected lan\u00adguage, \nand it interacts better with other features such as exceptions. Our Contributions. This paper introduces \nthe programming lan\u00adguage Alms, its implementation, and its basic theory: We describe the design of \nAlms, whose novel features include precise kinds for af.ne type constructors, and demonstrate how it \nexpresses a variety of resource-aware idioms (\u00a72).  Our implementation is a usable, full-featured prototype \nin which we have written several thousand lines of code (\u00a73).  Alms rests on a .rm theoretical basis. \nWe provide a formal model (\u00a74) and establish essential theoretical properties (\u00a75).  Our implementation \nand full proofs are available at www.ccs.neu. edu/~tov/pubs/alms.  2. Learn Alms in 2.5 Pages Alms is \na typed, call-by-value, impure functional language with algebraic data types, pattern matching, reference \ncells, threads, exceptions, and modules with opaque signature ascription. Alms reads like Ocaml (Leroy \net al. 2008) but is explicitly typed. In most cases local type inference renders explicit type instantiation \nunnecessary. We introduce Alms through a series of examples. Consider a simple Alms function, deposit, \nthat updates one element of an array by adding an integer: let deposit (a: int Array.array)(acct: int)(amount: \nint)= Array.set a acct (Array.get a acct + amount) This function has a race condition between the read \nand the write, so we may want to use a lock to enforce mutual exclusion: let deposit (a: int Array.array)(acct: \nint) (amount: int)(lock: Lock.lock)= Lock.acquire lock; Array.set a acct (Array.get a acct + amount); \nLock.release lock Af.ne data. Locks can ensure mutual exclusion, but using them correctly is error-prone. \nA rather coarse alternative to ensure mu\u00adtual exclusion is to forbid aliasing of the array altogether. \nIf we have the only reference to an array then no other process can operate on it concurrently. In Alms, \nwe do this by declaring an interface that includes a new, abstract array type: module type AF ARRAY = \nsig type a array : A val new : int . a . a array A val set : a array . int -.Aa -. a array val get : \na array . int -A. a \u00d7 a array module AfArray : AF ARRAY = struct type a array = a Array.array let new \n= Array.new let set (a: a array)(ix: int)(v: a)= Array.set a ix v; a let get (a: a array)(ix: int)=(Array.get \na ix, a) end The original array type a Array.array has kind U, as in unlimited, because it places no \nlimits on duplication. We can use it to represent an abstract type of kind A, however, because U is a \nsubkind of A, and Alms s kind subsumption rule allows assigning an abstract type a greater kind than \nthat of its concrete representation. This is somewhat akin to Standard ML s treatment of equality types \n(Milner et al. 1997) and Ocaml s treatment of type constructor variance (Leroy et al. 2008). In SML, \neqtype is subsumed by type, in that signature matching can abstract an equality type to a non\u00adequality \ntype but not vice versa. We need not change new at all, and get and set are modi.ed slightly to return \nthe array as required by the interface. Af.ne capabilities. The af.ne array interface is quite restrictive. \nBecause it requires single-threading an array through the program, it cannot support operations that \ndo not actually require exclusive access to the array. However, Alms supports creating a variety of abstractions \nto suit our needs. One way to increase our .exibility is to separate the reference to the array from \nthe capability to read and write the array. Only the latter needs to be af.ne. For example, we may prefer \nan interface that supports dirty reads, which do not require exclusive access but are not guaranteed \nto observe a consistent state: module type CAP ARRAY = sig type (a, \u00df) array type \u00df cap : A end val \nnew: int . a . E \u00df.(a, \u00df) array \u00d7 \u00df cap module AfArray : AF ARRAY = struct ... end The notation : A speci.es \nthat type a AfArray.array has kind A, as in af.ne, which means that any attempt to duplicate a reference \nto such an array is a type error. Two points about the types of AfArray.get and AfArray.set are worth \nnoting: Each must return an array because the caller cannot reuse the reference to the array supplied \nas an argument. A Type t1 -. t2 has kind A, which means that it may be used at most once.1 This is necessary \nbecause reusing a function partially applied to an af.ne value would reuse that value. We now rewrite \ndeposit to use the AF ARRAY interface: let deposit (a: int AfArray.array)(acct: int)(amt: int)= let (balance, \na)= AfArray.get a acct in AfArray.set a acct (balance + amt) If we attempt to use an AfArray.array more \nthan once without single-threading it, a type error results: let deposit (a: int AfArray.array)(acct: \nint)(amt: int)= let (balance, )= AfArray.get a acct in AfArray.set a acct (balance + amt) Alms reports \nthat the af.ne variable a is duplicated. Implementing AfArrayis just a matter of wrapping the primitive \narray type and operations, and sealing the module with an opaque signature ascription: 1 It is tempting \nto call this an af.ne function, but standard terminology says that an af.ne function uses its argument \nat most once, whereas here we have the type of a function itself usable at most once. Whether an Alms \nfunction is af.ne is determined by the kind of the type of its formal parameter. val set :(a, \u00df) array \n. int . a . \u00df cap . \u00df cap val get :(a, \u00df) array . int . \u00df cap . a \u00d7 \u00df cap val dirtyGet :(a, \u00df) array \n. int . a end In this signature, (a, \u00df) array is now unlimited and \u00df cap is af.ne. Type array s second \nparameter, \u00df, is a stamp used to tie it to its capability, which must have type \u00df cap (where \u00df matches). \nIn particular, the type of new indicates that it returns an existential containing an array and a capability \nwith matching stamps. The existential guarantees that the stamp on an array can only match the stamp \non the capability created by the same call to new. Operations set and get allow access to an array only \nwhen presented with the matching capability. This ensures that set and get have exclusive access with \nrespect to other sets and gets. They no longer return the array, but they do need to return the capability. \nOn the other hand, dirtyGet does not require a capability and should not return one. For example, the \nCAP ARRAY interface allows us to shuf.e an array while simultaneously computing an approximate sum: let \nshu.eAndDirtySum (a:(a, \u00df) CapArray.array) (cap: \u00df CapArray.cap)= let th1 = Thread.fork (. . inPlaceShu.e \na cap) in let th2 = Thread.fork (. . dirtySumArray a) in (Thread.wait th1, Thread.wait th2) To implement \nCAP ARRAY, we need suitable representations for its two abstract types. We represent CAP ARRAY s arrays \nby the primitive array type, and capabilities by type unit, which is adequate because these capabilities \nhave no run-time signi.cance.  module A = Array module CapArray : CAP ARRAY = struct type (a, \u00df) array \n= a A.array type \u00df cap = unit let new (size: int)(init: a)=(A.new size init, ()) let set (a: a A.array)(ix: \nint)(v: a)= A.set a ix v let get (a: a A.array)(ix: int) =(A.get a ix, ()) let dirtyGet = A.get end where \nthe superscripts were all A. (When the kind is U, we often omit it.) We discuss the kinds of function \ntypes and their subtyping in more depth in \u00a74.3. More possibilities. The rules of Alms are .exible enough \nto ex\u00adpress a wide variety of designs. For example, the ability to store capabilities in data structures \nallows us to create a more dynamic interface than the static capabilities of CapArray: module type CAP \nLOCK ARRAY = sig include CAP ARRAY Type unit has kind U, but as in the previous example, we can ab\u00ad \nstract it to A to match the kind of \u00df CapArray.cap. The implemen\u00ad tation of the operations is in terms \nof the underlying array oper\u00ad ations, with some shuf.ing to ignore capability arguments (in set and get) \nand to construct tuples containing () to represent the ca\u00ad pability in the result (in new and get).2 \nCapabilities are values. Capabilities such as \u00df CapArray.cap of\u00adten represent the state of a resource, \nbut in Alms they are also or\u00addinary values. They may be stored in immutable or mutable data structures, \npacked into exceptions and thrown, or sent over com\u00admunication channels like any other value. For example, \nsuppose we would like a list of array capabilities. Lists are de.ned thus in the standard library: type \na list = Nil | Cons of a \u00d7 a list The type variables we have seen until now could only be instanti\u00adated \nwith unlimited types, but the diacritic on type variable a in\u00addicates that a may be instantiated to any \ntype, whether af.ne or unlimited. Whether a list should be treated as af.ne or unlimited depends on whether \nthe contents of the list is af.ne or unlimited. Alms represents this fact by giving the list type constructor \na dependent kind, where kind (a ) denotes the kind of a : a list : (a ) list has kind . a.(a ) That \nis, the kind of a list is the same as the kind of its element type: type int list has kind U, whereas \n\u00df CapArray.cap list has kind A. In general, the kind of a type is the least upper bound of the kinds \nof the types that occur directly in its representation. For example: type ( a, \u00df ) r = a \u00d7 \u00df (a )u( \n\u00df ) type ( a, \u00df ) s = int \u00d7 \u00df (\u00df ) type ( a, = of of ( a) t a)u( \u00df) t T1 a | T2 \u00df, ( \u00df) type ( a, \u00df \n) u = U1 | U2 of ( a) u U \u00df, type ( a, \u00df ) v = a \u00d7 (unit . \u00df ) (a ) -\u00df type ( a, = a \u00d7 (unit .. unit) \na)u( \u00df ) \u00df) w - ( Because both a and \u00df are part of the representation of ( a, \u00df ) r, it must be af.ne \nif either of its parameters is af.ne. On the other hand, the phantom parameter a is not part of the representation \nof ( a, \u00df ) s, so that has kind (\u00df ). The kinds of t and u are the least solutions to these inequalities: \n.(( a, \u00df ) t) ; .( a) .(( a, \u00df ) u) ; U .(( a, \u00df, .(( \u00df) u) ; .(( a) u) \u00df) t) ; .(( a) t) a, \u00df, The kind \nof each type must be at least as restrictive as the kinds of all of its alternatives. For ( a, \u00df ) v, \nthe kind of \u00df does not appear because the domain and codomain of a function type are not part of the \nfunction s rep\u00adresentation. Instead, function types have their kind in a superscript as in the de.nition \nof type w. We saw this in the AfArray example, 2 If you think this unit shuf.ing is unnecessary, we agree \n(\u00a77). val new : int . a . E \u00df.(a, \u00df) array val acquire:(a, \u00df) array . \u00df cap val release :(a, \u00df) array \n. \u00df cap . unit end This signature changes the type of new to return an array (with unique tag \u00df) but \nno capability. To operate on the array, one needs to request a capability using acquire. Subsequent attempts \nto ac\u00adquire a capability for the same array block until the capability is released. We implement CAP \nLOCK ARRAY in terms of CapArray without any privileged knowledge about the representation of its capabilities. \nThe implementation relies on mvars, synchronized variables based Id s M-structures (Barth et al. 1991). \nAn a mvar may hold a value of type a or it may be empty. While an mvar may contain an af.ne value, the \nmvar itself is always unlimited. This is safe because calling take on a non-empty mvar removes the value \nand returns it, while take on an empty mvar blocks until another thread puts a value in it. To implement \nCAP LOCK ARRAY we now represent an array as a pair of the underlying (a, \u00df) CapArray.array and an mvar \nto store its capability: module CapLockArray : CAP LOCK ARRAY = struct module A = CapArray type (a, \u00df) \narray =(a, \u00df) A.array \u00d7 \u00df cap MVar.mvar let new (size: int)(init: a)= let (\u00df, a, cap)= A.new size init \nin (a, MVar.new cap) let acquire (( , mvar): (a, \u00df) array)= MVar.take mvar let release (( , mvar): (a, \n\u00df) array)(cap: \u00df cap)= MVar.put mvar cap let set ((a, ): (a, \u00df) array) = A.set a let get ((a, ): (a, \n\u00df) array) = A.get a . . . end The new operation creates a new array-capability pair and stores the capability \nin an mvar. Operations acquire and release use the mvar component of the representation, while the old \noper\u00adations such as set must be lifted to project out the underlying CapArray.array. There are many more \npossibilities. Figures 1 and 2 show two in\u00ad terfaces for reader-writer locks, which at any one time allow \neither exclusive read-write access or shared read-only access. Signature RW LOCK (.gure 1 on the .rst \npage) describes dynamic reader\u00ad writer locks. The signature declares nullary types excl and shared and \nan af.ne, binary type constructor (\u00b7 @ \u00b7). Capabilities now have type \u00df@., where \u00df ties the capability \nto a particular array and . records whether the lock is exclusive or shared. Operation set re\u00adquires \nan exclusive lock (\u00df@excl), but get allows . to be shared or excl. Signature FRACTIONAL (.gure 2) describes \nstatic reader\u00ad writer locks based on fractional capabilities (Boyland 2003). As in the previous example, \nthe capability type (\u00df, .) cap has a sec\u00adond parameter, which in this case represents a fraction of the \nwhole  module type FRACTIONAL = sig Two session types (Gay et al. 2003) libraries demonstrate dif\u00adtype \n(a, \u00df) array ferent approaches to alternation: one uses anonymous sums and type 1 the other uses algebraic \ndatatypes for named branches. type 2 Our version of Sutherland and Hodgman (1974) re-entrant poly\u00ad type \n./d gon clipping uses session types to connect stream transducers. type (\u00df, .) cap : A The Alms standard \nlibrary implements higher-order coercions val new : int . a . E \u00df. (a, \u00df) array \u00d7 (\u00df, 1) cap for checked \ndowncasts which can, for example, turn a function of type (unit -U. thread into a function of type (unit \n. unit) -U val split:(\u00df, .) cap . (\u00df, ./2) cap \u00d7 (\u00df, ./2) cap val join :(\u00df, ./2) cap \u00d7 (\u00df, ./2) cap . \n(\u00df, .) cap val set :(a, \u00df) array . int . a . (\u00df, 1) cap . (\u00df, 1) cap val get :(a, \u00df) array . int . (\u00df, \n.) cap . a \u00d7 (\u00df, .) cap end Figure 2. Another interface for reader-writer locks capability. The fraction \nis represented using type constructors 1, 2, and (\u00b7 / \u00b7). A capability of type (\u00df, 1) cap grants exclusive \naccess to the array with tag \u00df, while a fraction less than 1 such as 1/2 or 1/2/2 indicates shared access. \nThere are operations split, which splits a capability whose fraction is . into two capabilities of frac\u00adtion \n./2, and join, which combines two ./2 capabilities back into one . capability. Again, set requires exclusive \naccess but get does not. Syntax matters. Given CapLockArray as de.ned above, we can rewrite deposit to \ntake advantage of it: open CapLockArray let deposit (a:(int,\u00df) array)(acct: int)(amt: int)= let cap = \nacquire a in let (balance, cap)= get a acct cap in let cap = set a acct (balance + amt) cap in release \na cap While this gets the job done, the explicit threading of the capability can be inconvenient and \nhard to read. To address this, Alms pro\u00advides preliminary support for an alternative syntax inspired \nby a proposal by Mazurak et al. (2010): let deposit (a:(int,\u00df) array)(acct: int)(amt: int)= let !cap \n= acquire a in set a acct (get a acct cap + amt) cap; release a cap The pattern !cap bound by let marks \ncap as an imperative vari\u00adable, which means that within its scope, functions applied to cap are expected \nto return a pair of their real result and the new ver\u00adsion of cap. Alms transforms this code into the \nexplicitly-threaded version above. Currently this transformation happens before type checking, which \nmeans that it cannot compromise soundness but also cannot exploit type information. 3. Implementation \nand Experience Our prototype, implemented in 16k lines of Haskell, is available at www.ccs.neu.edu/~tov/pubs/alms. \nBesides a usable interpreter, it includes all the example code from this paper and other Alms examples \nillustrating a variety of concepts: A capability-based interface to Berkeley Sockets ensures that the \nprotocol to set up a socket is followed correctly. This library also shows how exceptions may be used \nfor error recovery in the presence of af.ne capabilities.  An echo server is built on top of the socket \nlibrary.  AU -. unit) -. thread by adding a dynamic check. These examples are not the last word on what \ncan be done in a language like Alms. Haskell s type classes (Wadler and Blott 1989), a general mechanism \ninvented to solve speci.c problems, have since found myriad unanticipated uses. Similarly, a practical, \ngeneral form of substructural types as offered by Alms likely has many applications waiting to be uncovered. \nWe have now written several thousand lines of code in Alms, and this experience has led to improvements \nin both its design and our skill at using what it has to offer. For example, an earlier version of Alms \nhad only unlimited (-U.) arrows, but Alms s .) and af.ne (-Abehavioral contract library motivated the \nintroduction of arrows a whose kinds involve type variables (e.g., --.). In particular, we found ourselves \nwriting the same function multiple times with different quali.ers in the argument types, and the addition \nof usage quali.er expressions eliminates this redundancy. 4. The Calculus a.ms We model Alms with a calculus \nbased on System F<. :, the higher\u00adorder polymorphic . calculus with subtyping (Pierce 2002). Our calculus, \na, makes several important changes to F. : .ms <: Our type system s structural rules are limited. In \nparticular contraction, which duplicates variables in a typing context to make them accessible to multiple \nsubterms, applies only to variables whose type is of the unlimited kind. Variables of af.ne or polymorphic \nkind cannot be contracted.  Our kind system is enriched with dependent kinds.  Our kind system is also \nenriched with variance on type opera\u00adtors (Steffen 1997), which allows abstract type constructors to \nspecify how their results vary in relation to their parameters.  Type operators are limited to .rst-order \nkinds that is, type operators may not take type operators as parameters.  Universally-quanti.ed type \nvariables are bounded only by a kind, not by a type.  The subtyping relation is induced by the subtyping \nrule for functions, whereby an unlimited-use function may be supplied where a one-use function is expected. \n The calculus a.ms also includes more types and terms than a minimal presentation of F. . Because we \nare interested in practical <: issues, we think it is important that our model include products,3 sums, \nmutable references, and non-termination. We do not model modules directly in a.ms , but its higher-kinded \ntype abstraction makes a.ms a suitable target for the .rst-order fragment of Rossberg et al. s (2010) \nF-ing modules translation. 3 In linear logic terms, our calculus (like Alms) supplies multiplicative \nproducts (.) and additive sums (.) directly. Additive products (&#38;) are easily encoded by AA.1U.2 \nt1 &#38; t2 \u00a3 .a:A. (t1 -. a)+(t2 -. a) - ---. a [e1,e2] \u00a3 .a:A..k. case k of .1 x1 . x1 e1; .2 x2 . \nx2 e2, where .1 and .2 are the kinds of t1 and t2.  . ::= q |(a)| .1 u .2 | .1 n .2 (usage quali.ers) \n. ::= . | .av.. (kinds) . t ::= a | .a.t | t1 t2 |.a:..t | t1 -. t2 (types) | 1 | (+) | (\u00d7) | aref e \n::= x | .x:t.e | e1 e2 | .a:..v | e[t] (terms) |() | (e1,e2)| case e1 of (x1,x2). e2 | .1 e | .2 e | \ncase e of .1 x . e1; .2 y . e2 | .x e | new e | swap e1 e2 | delete e | ptr e v ::= .x:t.e | .a:..v | \n() | (v1,v2) (values) | .1 v | .2 v | ptr e G, S ::= \u00b7| a:. | x:t | e:t | G1, G2 (typing contexts) (q, \n., u, n) (v, ., u, n) v1 \u00b7 v2 = v \u00b7 \u00b1- + A \u00b1 c \u00b1 \u00b1\u00b1\u00b1 c + -- \u00b1 + - c + \u00b1- + U c cc c c cc (qual. constants) \n(variances) (variance composition) Figure 3. Syntax of a.ms 4.1 Syntax We begin with the syntax of a.ms \nin .gure 3. Terms (e) include the usual terms from System F (variables, abstractions, applica\u00adtions, \ntype abstractions, and type applications), several forms for data construction and elimination (nil, \npairs, pair elimination, sum injections, and sum elimination), recursion (.x e), and several op\u00aderations \non reference cells (allocation, linear swap, and dealloca\u00adtion). Location names (ptr e) appear at run \ntime but are not present in source terms. Values (v) are standard. Types (t ) include type variables, \ntype-level abstraction and ap\u00adplication, universal quanti.cation, function types, and type con\u00adstructor \nconstants for unit, sums, products, and references. As in Alms, the function arrow carries a usage quali.er \n(.), which spec\u00adi.es whether the function is unlimited or one-use. The two constant usage quali.ers (q), \nU for unlimited and A for af.ne, are the bottom and top of the two-element lattice in .gure 3. Now consider \nthe K combinator .a:(a). .\u00df:(\u00df)..x:a..y:\u00df.x partially applied to a value: K[t1][t2] v. Whether it is \nsafe to dupli\u00adcate this term depends on whether it is safe to duplicate v, and this is re.ected in the \ninstantiation of a. To express this relationship, we introduce usage quali.er expressions (.), which \nform a bounded, distributive lattice over type variables with U and A as bottom and Ua top. We can thus \ngive K type .a:(a)..\u00df:(\u00df).a -. \u00df --. a. Quali.er expressions are the base kinds of a.ms that is, the \nkinds that classify proper types that may in turn classify values. To classify type operators, kinds \n(.) also include dependent product kinds, written .av... This is the kind of a type operator that, when \napplied to a type with kind ., gives a type with kind [./a].. For example, the kind of the Alms list \ntype constructor in \u00a72 is .a+ .(a), which means that list t has the same kind as t.4 The superscript \n+ in kind .a+ .(a) means that list is a covari\u00adant (or monotone) type constructor: if t1 is a subtype \nof t2 then list t1 is a subtype of list t2. Variances (v) form a four-point lattice (.gure 3). A type \noperator may also be contravariant (-), where the result varies inversely with the argument; omnivariant \n(c), where argument may vary freely without affecting the result; or invariant (\u00b1) where the argument \nmay not vary at all without producing a 4 Whereas Alms uses ML s conventional post.x notation for type-level \napplication, a.ms uses pre.x application. ff s; e -. s; e (small-step reduction) s;(.x:t.e) v -. s;[v/x]e \ns; (.a:..v)[t] -. s;[t/a]v s; .x v -. s; v (.x v) s; new v -. s l{e . v}; ptr e s l{e . v1}; swap (ptr \ne) v2 -. s l{e . v2}; (ptr e, v1) s l{e . v}; delete (ptr e) -. s; () s; e -. sf; ef s; E[e] -. sf; \nE[ef] E ::= [] | E e | v E | E[t ] | (E, e) | (v, E) (evaluation | case E of (x1, x2) . e | .1 E | .2 \nE contexts) | case E of .1 x . e1; .2 y . e2 | .x E | new E | swap Ee | swap vE | delete E s ::= {} \n| {e . v}| s1 l s2 (stores) Figure 4. Operational semantics (selected rules) subtyping-unrelated result. \nWe de.ne a composition operation (\u00b7) on variances, where v1 \u00b7 v2 is the variance of the composition of \ntype operators having variances v1 and v2. The kinds of the type constructors for sums and references \nmay aid understanding. The sum type constructor (+) has kind .a+ ..\u00df+ . (a)u(\u00df). This means that the \nkind of a sum type is at least as restrictive as the kinds of its disjuncts. It is covariant in both \narguments, which means that t1 + t2 is a subtype of t1f+ t2fif t1 is a subtype of t1fand t2 is a subtype \nof t2f. The reference type constructor, on the other hand, has kind .a\u00b1 .A. This means that reference \ncells are always af.ne and that their types do not support subtyping in either direction. Typing contexts \n(G or S) associate type variables with their kinds, variables with their types, and locations with the \ntypes of their contents. By convention, we use G for typing contexts that in\u00adclude neither af.ne variables \nnor locations, and we use S for typing contexts that may include locations and af.ne (or indeterminate) \nvariables. We use dom(G) to refer to the type variables, variables, and locations mapped by a context. \nWe de.ne the free type variables in a variety of syntactic forms (ftv(e), ftv(t), ftv(.), etc.) in the \nstandard way. We use locs(e) to denote the set of location names present in term e. There are no binders \nfor locations.  4.2 Operational Semantics The operational semantics of a.ms is mostly a standard call-by\u00advalue \nreduction semantics. We give a selection of rules in .gure 4. The reduction relation ( -.) relates con.gurations \n(s; e) compris\u00ading a store and a term. A store maps locations (e) to values (v). Stores are taken to \nbe unordered and do not repeat location names. The rules for reference operations are worth noting. In \nstore s, new v chooses a fresh location e, adding v to the store at location e and reducing to the reference \nptr e. The operation swap (ptr e) v2 requires that the store have location e holding some value v1. It \nswaps v2 for v1 in the store, returning a pair of a reference to e and value v1. Finally, delete (ptr \ne) also requires that the store contain e, which it then removes from the store. This means that freeing \na location can result in a dangling pointer, which would cause subsequent attempts to access that location \nto get stuck. Our type system prevents this.  G f . kind . is well formed (.g. 6) G f .1 <: .2 kind \n.1 is subsumed by .2 (.g. 6) G f a . t t v type t varies v-ly when a increases (.g. 7) G f t : . type \nt has kind . (.g. 7) G f t1 <:v t2 type t1 is v-related to type t2 (.g. 7) G f S : . context S is bounded \nby quali.er . (.g. 8) f (G0;S0), Sf \" G; S extending G0;S0 with Sf gives G; S (.g. 8) G; S [ e : t term \ne has type t (.g. 9) S1 [ s :S2 store s has type S2 (.g. 10) [ s; e : t con.guration s; e has type t \n(.g. 10) Figure 5. Type system judgments G f . (kind well-formedness) OK-QUAL ftv(.) . dom(G f . G) OK-ARR \nG, a:(a) f . if a . ftv(.) then + G f .av.. v G f .1 <: .2 (subkinding) KSUB-QUAL G |= .1 .2 KSUv1 B-ARR \nv2 G, a:(a) f .1 <: .2 G f .1 <: .2 G f .av1..1 <:.av2..2 Figure 6. Statics (i): kinds  4.3 Static \nSemantics Our type system involves a large number of judgments, which we Thus, a valuation is consistent \nwith a context if it corresponds to a De.nition 2 (Quali.er subsumption). We say that .1 is subsumed \nby .2 in G, written G |= .1 .2, if for all valuations V consistent with G, V(.1) V(.2). In other words, \nin all possible instantiations of the type variables in G, quali.er .1 being A implies that .2 is A. \nKinding and variance. The .rst two judgments in .gure 7, for computing variances and giving kinds to \ntypes, are de.ned by mu\u00adtual induction. It should be clear on inspection that the de.nitions are well-founded. \nJudgment G f a . t t v means that type variable a appears in type t at variance v, or in other words, \nthat type operator .a.t has variance v. Rules V-VAR and V-BOT say that type variables appear positively \nwith respect to themselves and omnivariantly with respect to types in which they are not free. Rule V-ABS \nsays that a type variable appears in a type operator .\u00df.t at the same variance that it appears in the \nbody t . The re\u00admaining three rules are more involved: By rule V-APP, the variance of a type variable \nin a type ap\u00ad plication comes from both the operator and the operand. The variance of a in t1 t2 is at \nleast the variance of a in t1 and at least the variance of a in the t2 composed with the variance of \noperator t1. This makes sense: if t is a contravariant type oper\u00adator, then a appears negatively in ta \nbut positively in t (ta).  By rule V-ALL, the variance of a in .\u00df:..t is at least its variance in t. \nHowever, if a appears in . then it is invariant in .\u00df:..t. This re.ects the fact that universally-quanti.ed \ntypes are related only if their bounds (.) match exactly, so changing a type variable that appears in \n. produces an unrelated type. (This  is based on the kernel variant of F: potentialinstantiationofthetypevariables,giventhatcontext. \n.< means that a.ms (Pierce 2002).) summarize in .gure 5. In several cases, we omit premises concern\u00ad \nBy rule V-ARR, the variance of a in a function type t1 . - . t2 ising well-formedness of contexts, which \nclutter the presentation and do not add anything of interest. The omitted premises appear in the extended \nversion of this paper. Kind judgments. Judgments on kinds appear in .gure 6. The .rst judgment, G f . \n, determines whether a kind . is well formed in typing context G. A base kind (i.e., a usage quali.er \nexpression) is well formed provided that G speci.es a kind for all of its free variables. A dependent \nproduct kind .av.. is well formed if G maps all of its free variables, provided it satis.es a second \ncondition: whenever the bound type variable a is free in . that is, when the kind is truly dependent \nthen variance v must be + or \u00b1. This rules out incoherent kinds such as .a- .(a) that classify no useful \ntype operator but whose presence breaks the kinding relation s monotonicity property (see lemma 4). The \nsecond judgment is subkinding: G f .1 <: .2. As we will see, if a type has kind .1, then it may be used \nwhere .1 or any greater kind is expected. For dependent product kinds the subkind\u00ading order is merely \nthe product order on the variance and the result kind, but for base kinds the relation relies on an interpretation \nof quali.er expressions. We interpret quali.er expressions via a valuation V, which is a map from type \nvariables to quali.er constants. We extend V s domain to quali.er expressions: V(q)= q V(.1 u .2)= V(.1) \nuV(.2) V((a))= V(a) V(.1 n .2)= V(.1) nV(.2) We need to interpret quali.er expressions under a typing \ncontext: De.nition 1 (Consistent valuations). A valuation V is consistent with a typing context G if \nfor all a:. . G, V(a) V(.). at least its variance in the codomain t2 and at least the opposite (composition \nwith -) of its variance in the domain t1. This re.ects function argument contravariance. The variance \nof a is at least + if it appears in the quali.er expression .. The second judgment, G f t : ., assigns \nkinds to well formed types. Rule K-VAR merely looks up the kind of a type variable in the context. Rules \nK-ABS and K-APP are the usual rules for dependent abstraction and application, with two small changes \nin rule K-ABS. First, it associates a with itself in the context, as a:(a), which ensures that occurrences \nof a in t can be re.ected in .. Second, it appeals to the variance judgment to determine the variance \nof the type operator. Rule K-ALL assigns a universal type the same kind as its body, but with A replacing \na. This is necessary because the resulting kind is outside the scope of a. Quali.er A is a safe bound \nfor any instantiation of a, and no terms have types that lose precision by this choice. The kind of an \narrow type, in rule K-ARR, is just the quali.er expression attached to the arrow. The remaining rules \ngive kinds for type constructor constants. Type equivalence and dereliction subtyping. The last judgment \nin .gure 7 is subtyping. The subtyping relation is parametrized by a variance v, which gives the direction \nof the subtyping: G f t1 <:+ t2 is the usual direction, judging t1 a subtype of t2. In terms of subsumption, \nthis means that values of type t1 may be used where values of type t2 are expected. The other variances \nare useful in de.ning the relation in the presence of v-variant type operators: (<:-) gives the inverse \nof the subtyping relation, (<:\u00b1) relates only equivalent types, and (<:\u00a2) relates all types. We can see \nhow this works this in rule TSUB-APP. To determine whether t11 t12 is a  G f a . t t v (variance of \ntype variables with respect to types) V-VAR V-BOT V-ABS a . ftv(t )G,\u00df:(\u00df)f a . t t v G f a . a t +G \nf a . t t G f a . .\u00df.t t v c A -. we can use Thread.fork where a value of type V-APP V-ALL V-ARR G f \na . t1 t v1 G f a . t2 t v2 G,\u00df:. f a . t t v1 G f a . t1 t v1 G f a . t2 t v2 G f t1 :.\u00dfv3..3 v2 = if \na . ftv(.) then \u00b1 else v3 = if a . ftv(.) then + else c . c G f a . t1 t2 t v1 u (v2 \u00b7 v3)G f a ..\u00df:..t \nt v1 u v2 G f a . t1 -. t2 t-v1 u v2 u v3 G f t : . (kinding of types) K-ABS K-APP K-ARR K-VAR G,a:(a)f \nt : . G f t1 :.av.. K-ALL G f t1 : .1 K-UNIT a:. . GG,a:(a)f a . t t v G f t2 : . G,a:. f t : . G f \nt2 : .2 G f t1 -. t2 : . G f a:. G f .a.t :.av.. G f t1 t2 :[./a]. G f.a:..t :[A/a]. . G f 1: U K-SUM \nK-PROD K-REF G f (+) : .a+ ..\u00df+ .(a)u(\u00df) G f (\u00d7):.a+ ..\u00df+ .(a)u(\u00df) G f aref :.a\u00b1 . A G f t1 <:v t2 (subtyping) \n TSUB-EQ TSUB-TRANS TSUB-OMNI TSUB-CONTRA TSUB-ABS vv -vv t1 = t2 G f t1 <: t2 G f t2 <: t3 G f t2 <: \nt1 G,a:(a)f t1 <: t2 vv vv G f t1 <: t2 G f t1 <: t3 G f t1 <:\u00a2 t2 G f t1 <: t2 G f .a.t1 <: .a.t2 TSUB-APP \nTSUB-ALL TSUB-ARR G f t11 :.av1..1 G f t21 :.av2..2 -vv G f t11 <:t21 G f t12 <:t22 vv\u00b7(v1Uv2) vv G \nf t11 <: t21 G f t12 <: t22 G,a:. f t1 <: t2 G f .1 <: .2 .1v .2 G f t11 t12 <: v t21 t22 G f.a:..t1 \n<: v .a:..t2 G f t11 - . t12 <: t21 - . t22 Figure 7. Statics (ii): types subtype of t21 t22, we take \nv to be +, yielding G f t11 :.av1..1 G f t21 :.av2..2 + v1Uv2 G f t11 <: t21 G f t12 <: t22 . + G f t11 \nt12 <:t21 t22 This means that for the subtyping relation to hold: The operators must be related in the \nsame direction, so that t11 is a subtype of t21.  The operands must be related in the direction given \nby the variances of the operators. For example, if both operators are covariant, then the operands must \nvary in the same direction, so that t12 is a subtype of t22. If both operators are contravariant, then \nthe operands must vary in the opposite direction. If the  direction. This rule is the source of non-trivial \nsubtyping in a.ms , without which subtyping would relate only equivalent types. The rule has two important \nimplications. First, an unlimited-use function can always be used where a one-use function is expected. \nThis corresponds to linear logic s usual dereliction rule, which says that the ! ( of course! ) modality \nmay always be removed. ILL (Bierman 1993) has a rule: . f e :!A DERELICTION. . f derelict e : A Dereliction \nis syntax-directed in this rule, but for practical program\u00adming we consider that as too inconvenient. \nThus, our subtyping re\u00adlation supports dereliction as needed. U,hastypeThread.fork-- A For example, \nthe function for creating a new thread in Alms, operators are invariant then the operands cannot vary \nat all, but A (unit . a thread, which means a . . a ) if they are omnivariant then t11 tf 22 for 12 \nis a subtype of t21 tf that Thread.fork will not call its argument more than once. How\u00adany t f 22. 12 \nand t f ever, this should not stop us from passing an unlimited-use func- Rule TSUB-EQ says that subtyping \nincludes type equivalence U tion to Thread.fork, and indeed we can. Dereliction subtyping al\u00adlows us \nto use a value of type unit-. a where a value of type (t1 = t2), which is merely \u00df equivalence on types. \nRule TSUB- OMNI allows any pair of types to be related by -variant subtyping, unit a is expected. Alternatively, \nby domain contravariance, c and rule TSUB-CONTRA says that the opposite variance sign gives the inverse \nrelation. Rules TSUB-ABS and TSUB-ALL specify that type operators and universally-quanti.ed types are \nrelated if their bodies are. Rule TSUB-ARR is more than the usual arrow subtyping rule. Beyond the usual \ncontravariance for arguments and covariance for results, it requires that quali.ers .1 and .2 relate \nin the same U U --. a thread is expected. In this case subsumption allows us to forget Thread.fork s \npromise not to reuse its argument. The other important implication of dereliction subtyping will become \nclearer once we see how quali.er expressions are assigned to function types. Subsumption makes it reasonable \nto always as\u00adsign functions the most permissive safe usage quali.er, because A (unit a . . a )  G f \nS : . (bound of typing context) B-NIL B-CONSA G f S : .1 G f . G f\u00b7: U G f S,a:. : .1 B-CONSX B-CONSL \nG f S : .1 G f t : .2 G f S : .1 G f t : .2 G f S,x:t : .1 u .2 G f S,e:t : A f (G0;S0), Sf G1;S1 (typing \ncontext extension) X-NIL f (G; S), \u00b7 G; S X-CONSU X-CONSA G0 f t : U G0 f t : . f (G0,x:t ;S0), Sf G; \nS f (G0;S0,x:t), Sf G; S f (G0;S0),x:t, Sf G; S f (G0;S0),x:t, Sf G; S Figure 8. Statics (iii): typing \ncontexts subsumption then allows us to use them in a less permissive con\u00adtext. Dereliction subtyping \napplies only to function types because in both the a.ms calculus and Alms language only function types \ncarry quali.ers. For instance, Alms has no separate types intU for unlimited integers and intA for af.ne \nintegers. Integers are always reference in its .rst parameter match the type of the value in its second \nin other words, swap performs a strong update. To type the term case e of (x1,x2). e1, rule T-UNPAIR \n.rst splits the af.ne environment into S1 for typing subterm e and S2 for sub\u00adterm e1. It invokes the \ncontext extension relation (.gure 8) to ex\u00ad tend G and S2 with bindings for x1 and x2 in order to type \ne1. The context extension relation requires that variables not known to be unlimited be added to S2. \nThe rule for sum elimination, T-CHOOSE, is both multiplicative and additive: the af.ne context is split \nbetween the term being destructed and the branches of the case expression. However, the portion of the \ncontext given to the branches is shared between them, because only one or the other will be evaluated. \nRule T-CHOOSE also uses the context extension relation to bind the pattern variables for the branches. \nRules T-NEW and T-DELETE introduce and eliminate reference types in the usual way. Likewise, the sum \nintroduction rules T-INk and type abstraction rule T-TABS are standard. Rules T-VAR, T-PTR, and T-UNIT \nare standard for an af.ne calculus but not a linear one, as they implicitly support weakening by allowing \nS to contain unused bindings. Rule T-FIX is also standard, modulo the reasonable constraint that its \nparameter function be unlimited, since the reduction rule for .x makes a copy of the parameter. The type \napplication rule T-TAPP supports subkinding, because it requires only that the kind of the actual type \nparameter be a sub\u00adkind of that of the formal parameter. This is the rule that supports the sort of type \nabstraction that we used in our examples of \u00a72 to construct af.ne capabilities. For example, the rule \nlets us instantiate af.ne type variable a with unlimited unit type 1: unlimited. If a programmer wants \nan af.ne version of int, she can G; S [ (.a:A..x:a.e): .a:A.a create it in Alms using the module system. \n. -. t G f 1: U G f U <: A Context judgments. Figure 8 de.nes two judgments on contexts. G; S [ (.a:A..x:a.e)[1] \n: 1 Judgment G f S : ., which will be important in typing functions, T-TAPP . -. t computes an upper \nbound . on the quali.ers of all the types in context S. If a context contains any locations, it is bounded \nby A; otherwise, its bound is the least upper bound of the quali.ers of all the types of variables in \nthe context. The second judgment shows how environments are extended by variable bindings. The typing \njudgment for terms will use two typ\u00ading contexts: G holds environment information that may be safely \nduplicated, such as type variables and variables of unlimited type, whereas S holds information, such \nas location types and af.ne vari\u00adables, that disallows duplication. Given contexts G0 and S0, judg\u00adment \nf (G0;S0), Sf G; S extends them by the variables and types in Sf to get G and S. Any variables may be \nplaced in S, but only variables whose types are known to be unlimited may be placed in G, since G may \nbe duplicated. Term judgment. The typing judgment for terms appears in .g\u00adure 9. The judgment, G; S [ \ne : t , uses two typing contexts in the style of DILL (Barber 1996): the unlimited environment G and \nthe af.ne environment S. When typing multiplicative terms such as ap\u00adplication, we distribute G to both \nsubterms but partition S between the two: Within its scope, a is considered a priori af.ne, regardless \nof how it may eventually be instantiated. This term types only if x appears in af.ne fashion in e. This \nbrings us .nally to T-ABS, the rule for typing term-level . abstractions. To type a term .x:t1.e, rule \nT-ABS uses the context extension relation to add x:t1 to its contexts and types the body e in the extended \ncontexts. It also must determine the quali.er . that decorates the arrow. Because abstractions close \nover their free variables, duplicating a function also duplicates the values of its free variables. Therefore, \nthe quali.er of a function type should be at least as restrictive as the quali.ers of the abstraction \ns free variables. To do this, rule T-ABS appeals to the context bounding judgment (.gure 8) to .nd the \nleast upper bound of the usage quali.ers of variables in the af.ne environment, and it requires that \nthe function type s quali.er be equally restrictive. This re.nes linear logic s usual promotion rule, \nwhich says that the ! modality may be added to propositions that in turn depend only on !-ed resources. \nIn ILL, we have !. f e : A . G; S1 [ e1 : t1 -. t2 G; S2 [ e2 : t1 G; S1, S2 [ e1 e2 : t2 PROMOTION, \n!. f promote e :!A T-APP where !. is a context in which all assumptions are of the form Unlike DILL, \nnot all types in S are necessarily af.ne. Since types whose usage quali.er involves type variables are \nnot known to be unlimited, we place those in S, to ensure that we do not duplicate values that might \nturn out to be af.ne once universally-quanti.ed types are instantiated. The other multiplicative rules \nare T-PAIR for product introduc\u00adtion, T-UNPAIR for product elimination, and T-SWAP for reference updates. \nNote that T-SWAP does not require that the type of the x :!B. As with dereliction, in our system it only \nmakes sense to apply promotion to function types. Our treatment of promotion indicates why we need the \nexplicit weakening rule T-WEAK, which allows discarding unused portions of the af.ne environment. In \norder to give a function type the best quali.er possible, we need to remove from S any unused variables \nor locations that might otherwise raise the bound on S, and the algorithmic version of the type system \nas implemented in  G; S [ e : t (typing of terms) T-SUBSUME T-WEAK T-VAR T-PTR ff + G; S [ e : t G \nf t<: t G; S [ e : tx:t . G, S e:t . S G; S [ e : t G; S, Sf [ e : t G; S [ x : t G; S [ ptr e : aref \nt T-ABS f (G; S),x:t1 Gf;Sf T-APP T-TABS Gf. ;Sf [ e : t2 G f S : . G; S1 [ e1 : t1 -. t2 G; S2 [ e2 \n: t1 G,a:.;S [ v : t . G; S [ .x:t1.e : t1 -. t2 G; S1, S2 [ e1 e2 : t2 G; S [ .a:..v : .a:..t T-TAPP \nT-PAIR ff f T-UNIT G; S [ e : .a:..t G f t : .G f .<: . G; S1 [ e1 : t1 G; S2 [ e2 : t2 G; S [ e[t f]:[tf/a]t \nG; S [ () : 1 G;S1, S2 [ (e1,e2) : t1 \u00d7 t2 T-UNPAIR T-INk (k.{1,2}) G; S1 [ e : t1 \u00d7 t2 f (G; S2),x1:t1,x2:t2 \nGf;Sf Gf;Sf [ e1 : t G; S [ e : tk G; S1, S2 [ case e of (x1,x2). e1 : t G; S [ .k e : t1 + t2 T-CHOOSE \n G; S [ e : t1 + t2 f (G; Sf),x1:t1 G1;S1 G1;S1 [ e1 : t f (G; Sf),x2:t2 G2;S2 G2;S2 [ e2 : t G; S, Sf \n[ case e of .1 x1 . e1; .2 x2 . e2 : t T-FIX T-NEW T-SWAP T-DELETE U G; S [ e : t -. t G; S [ e : t \nG; S1 [ e1 : aref t1 G; S2 [ e2 : t2 G; S [ e : aref t G; S [ .x e : t G; S [ new e : aref t G; S1, S2 \n[ swap e1 e2 : aref t2 \u00d7 t1 G; S [ delete e :1 Figure 9. Statics (iv): terms S1 [ s : S2 (store typing) \nS-NIL S-CONS S11 [ s : S2 \u00b7; S12 [ v : t S1 [ {} : \u00b7 S11, S12 [ s l {e . v} : S2, e:t [ s; e : t (con.guration \ntyping) CONF S1 [ s :S1, S2 \u00b7;S2 [ e : t [ s; e : t Figure 10. Statics (v): stores and con.gurations \nAlms does just that. In \u00a75 we show that our implicit promotion mechanism selects the best usage quali.er \nfor function types. Store and con.guration judgments. In order to prove our type soundness theorem, we \nneed to lift our typing judgments to stores and run-time con.gurations. The type of a store is a typing \ncontext containing the names of the store s locations and the types of their contents. The store 5. Theoretical \nResults We now state our two main theorems principal quali.ers and type soundness and sketch their proofs. \nFull versions of our proofs may be found in an extended version of this paper available at www.ccs.neu.edu/~tov/pubs/alms. \nPrincipal quali.ers. Alms and a.ms go to a lot of trouble to .nd the best usage quali.er expressions \nfor function types. To make programming with af.ne types as convenient as possible, we want to maximize \npolymorphism between one-use and unlimited versions of functions. While writing the Alms standard library, \nwe found that usage quali.er constants A and U, even with dereliction subtyping, were insuf.cient to \ngive a principal type to some terms. For example, consider function default, an eliminator for option \ntypes, sans function argument types: let default (def: ...)(opt: ...)= match opt with | Some x . x | \nNone . def Without usage quali.er expressions, defaulthas at least two incom\u00adparable types: typing judgment \nS1 [ s :S2 gives store s type S2 in the context of S1, which is necessary because values in the store \nmay refer to U -. a option -A . default1 A A a .a a : U -. a option U default2 -. a. a.a : other values \nin the store. Rule S-CONS shows that the resources represented by context S1 (i.e., S11, S12) are split \nbetween the values in s. Our preservation lemma concerns typing judgments on con.gu\u00adrations, [ s; e : \nt , which means that e has type t in the context of store s. To type the con.guration by rule CONF, we \ntype the store, splitting its type into S1, which contains locations referenced from the store, and S2, \nwhich contains locations referenced from e. In the .rst case, because a might be af.ne, the partial application \nof default1 must be a one-use function, but in the second case we know that a is unlimited so partially \napplying default2 and reusing the result is safe. Formally, these types are incomparable because the \nuniversally-quantified type variable a in the former has a different kind than a in the latter, and Alms \nuses the kernel variant of rule TSUB-ALL. However, even were we to replace  rule TSUB-ALL with a rule \nanalogous to F<. : s full variant, This lemma is the reason for the premise in rule OK-ARR that v -v \nfor a kind .av.., variance v must be at least + if a . ftv(.). G,a:. f t1 <: t2 G,a:. f .1 <: .2 Otherwise, \nwe could construct a counterexample to lemma 4: v TSUB-ALLFULL , -. 1) <:-. 1), -. 1) : A, and -. 1) \n: U, U AAU G f.a:.1.t1 <: .a:.2.t2 \u00df:.a- + . (a)f \u00df (1 (1 the types would not be related by the subtyping \norder. More impor\u00ad tantly, neither type is preferable in an informal sense. The type of \u00df:.a- . (a)f \n\u00df (1 default1 allows a to be instantiated to an af.ne or unlimited type, but the result of partially \napplying it is a one-use function even if a \u00df:.a- . (a)f \u00df (1 but \u00df:.a- .(a)f A <: U is not the case.is \nknown to be unlimited: default1 (aref 5): int aref option-. int aref. int-. A A default1 5 : int option \nThe kind well-formedness judgment rules out kinds like .a- . (a). Proof for lemma 4. We de.ne an extension \nof the subkinding rela- If we choose default2, the result of partial application is unlimited, tion, \nG f .1 ; .2, which is insensitive to the variances decorating but attempting to instantiate a to an af.ne \ntype is a type error: . kinds. Observe that on quali.er expressions this new relation co\u00ad -. int U default2 \n5 : int option incides with subkinding. We generalize the induction hypothesis default2 (aref 5): Type \nerror! Alms avoids both problems and instead discovers that the best usage quali.er for the arrow is \nthe kind of the type variable: if G f t1 <:+ t2 where G f t1 : .1 and G f t2 : .2, then G f .1 ; .2 and \ncomplete the proof by induction on the struc\u00ad ture of the subtyping derivation. default 5 : int option \nU- . a option a --. a Corollary 5 (Kinding .nds locations). Suppose that G; S [ v : t and G f t : . \nwhere dom(S) contains only locations (e). If any default A a .a : default (aref 5): int aref option-. \nint aref. int-. A U locations appear in v then G f A <: .. Because this is an important property, we \nprove a theorem that every typeable a.ms function has a principal usage quali.er. . Theorem 3 (Principal \nquali.ers). If G; S [ .x:t.e : t1 -. t2, then it has a least quali.er expression .0; that is, . Proof \nsketch. By induction on the typing derivation. We use the previous lemma in the case for the subsumption \nrule T-SUBSUME: ff + G; S [ v : t G f t<: t G f t : . Case . G; S [ v : t By the induction hypothesis, \nG f tf A, and by lemma 4, G; S [ .x:t.e : t1 - . t2 and G f .0 <: .f for all .f such that G; S [ .x:t.e \n: t1 0 : .G f A <: .. . -. t2. Corollary 5 lets us prove our substitution lemma. Then progress, Proof \nsketch. We obtain the principal quali.er .0 as follows. Let preservation, and type soundness are standard: \nS0 be the restriction of S to exactly the free variables and locations Theorem 6 (Type soundness). If \n[ {}; e : t then either e diverges * or there exists some store s and value v such that {}; e -. s; v \nof .x:t.e. Let .0 be the unique bound of S0 given by G f S0 : .0. By strengthening, G; S0 [ .x:t.e rule \nT-WEAK we can get the same type in S. : t1 0 . - . t2, and by and [ s; v : t . 0 A derivation of G; \nS [ .x:t.e : t1 -.. t2 always involves rule T-ABS using some portion of S, followed by some number of \nsubsumptions and weakenings. Subsumption will never let .f be less than .0. However, weakening might \nallow us to type .x:t.e with a different portion of S than S0. We know that any superset of S0 has bound \nno less than .0, and while a non-superset of S0 may have a smaller bound, we chose S0 so that only S0 \nand its supersets are suitable to type the term and then weaken to S. Thus, for a function in any given \ncontext, there is a least usage quali.er, and our implementation can .nd the least quali.er by considering \nonly the portion of S that pertains to the free identi.ers of the . term, as suggested by the algorithmic \nrule (T-ABSALG ) ff ff [ e : t2 f (G; S),x:t1 G;SG;S f A if locs(e)= \u00d8 .0 = {. | x . fv(e), G f S(x): \n.} otherwise . . - . t2 G; S [ .x:t1.e : t1 6. Related Work In prior work, we showed how an Alms-like \naf.ne language may safely interoperate with a conventional (non-af.ne) language (Tov and Pucella 2010). \nIn particular, the languages may freely share val\u00adues, including functions. Attempts by the conventional \nlanguage to subvert the af.ne language s invariants are prevented by dynamic checks in the form of behavioral \nsoftware contracts. That paper fo\u00adcused speci.cally on multi-language interaction, using a predeces\u00adsor \nof Alms. System F. . Mazurak et al. (2010) describe a calculus of light\u00adweight linear types. Their primary \nmotivation is similar to ours: to remove needless overhead and provide a simple foundation for practical \nlinear programming. System F. and the prior iteration of Alms independently intro\u00adduced several new ideas: \nBoth use kinds to distinguish linear (in Alms, af.ne) types from unlimited types, where F. s kinds . \nand * correspond to our A and U, and their subkinding relation * =. corresponds to our Type soundness. \nThe key obstacle in our type soundness proof is UA. establishing a substitution lemma, which in turn \nrelies on showing that the kind of the type of any value accurately re.ects the re\u00adsources contained \nin that value, which itself comes as a corollary to the proposition that the kinds of subtypes are themselves \nsubkinds: Lemma 4 (Monotonicity of kinding). If G f t1 <:+ t2 where G f t1 : .1 and G f t2 : .2, then \nG f .1 <: .2. F. uses existentials and subkinding to abstract unlimited types into linear types. Alms \n(the language) uses modules and a.ms (the calculus) uses higher-kinded type abstraction to de.ne ab\u00adstract \naf.ne types, including type constructors with parameters. Mazurak et al. mention the possibility of extending \nF. with ab\u00adstraction over higher kinds but do not show the details.  They sketch out a convenient notation \nfor writing linear com\u00adputations. This inspired our different implicit threading syntax, which is implemented \nin Alms as mentioned at the end of \u00a72. There are also notable differences: F. has linear types, which \ndisallow weakening, whereas Alms has af.ne types, which support it. This is a trade-off. Linear types \nmake it possible to enforce liveness properties, which may be useful, for instance, to ensure that manual \nmemory manage\u00adment does not leak. On the other hand, we anticipate that safely combining linearity with \nexceptions requires a type-and-effect system to track when raising an exception would implicitly dis\u00adcard \nlinear values. Alms can support explicit deallocation so long as failure to do so is backed up by a garbage \ncollector.  Alms s unlimited-use function type is a subtype of its one-use function type. F. does not \nprovide subtyping, though they do show how . expansion can explicitly perform the coercion that our subtyping \ndoes implicitly. Experience with our implemen\u00adtation con.rms that dereliction subtyping is valuable, \nthough we admit it comes at the cost of complexity.  F. requires annotating abstractions (.. x:t.e) \nto specify the kind of the resulting arrow type, which may only be * or .. Alms re.nes this with quali.er \nexpressions and selects the least kind automatically.  Mazurak et al. give a resource-aware semantics \nand prove that they can encode regular protocols. We do neither but conjecture that our system enjoys \nsimilar properties, except that weakening makes it possible to bail out of a protocol at any point. \n Their sketch of rules for algebraic datatypes is similar to how ours work, though ours are strictly \nstronger. For example, an option type in F. would have two versions:  optionLin : ... optionUn : * . \n*. Our dependent kinds in Alms let us de.ne one type constructor whose kind subsumes both: a+ option \n: . . (a ). Clean. At .rst glance, Clean s uniqueness types appear to be dual to af.ne types. Uniqueness \ntypes are descriptive they indi\u00adcate that a particular reference is unique while af.ne (and linear) types \nare prescriptive, since they restrict what may be done to some reference in the future but do not necessarily \nknow where it s been. Similarly, Clean s subtyping relation, which allows forgetting that a value is \nunique, appears dual to Alms s, which allows pretending that an unlimited value is af.ne. However, the \nduality breaks down in the higher-order case. When a partially applied function cap\u00adtures some unique \nfree variable, Clean s type system must prohibit aliasing of the function in order to maintain descriptive \nuniqueness when the function is fully applied (Plasmeijer and Eekelen 2002). In Clean s terminology, \nfunction types with the unique attribute are essentially unique, but we might call them af.ne. There \nis a strong similarity between our kinding judgment and Clean s uniqueness propagation rules that relate \nthe uniqueness of data structures to that of their constituent parts. While Clean sup\u00adports subtyping, \nit does not have a subkinding relation analogous to Alms or F. s. In particular, Clean requires that \nthe uniqueness at\u00adtributes declared for an abstract type in a module s interface exactly match the uniqueness \nattributes in the module s implementation. Use types and quali.ers. Wadler (1991) discusses several vari\u00ad \nants of linear type systems. He proposes something akin to derelic\u00adtion subtyping (i.e., !A = A) and \npoints out that in such a system, terms such as .f..x.f x have several unrelated types. (We made a similar \nobservation in \u00a75.) In order to recover principal types, he introduces use types, which decorate the \nexponential modality with a use variable i: !i. The use variable ranges over 0 and 1, where !0A = A and \n!1A =!A. This provides principal types, but at the cost of adding use-variable inequality constraints \nto type schemes. A use-variable inequality of the form i = j is essentially an implication i . j, where \n1 is truth and 0 is falsity. De Vries et al. (2008) show, in the setting of uniqueness types, how such \ninequalities may be represented instead using Boolean logic. For example, if we have a type !i !j ... \n... ..., [i = j], we can discard the inequality constraint and represent it instead as ii.k ... !... \n!..., because i = (i . k). In general, any collection of use-variable inequalities (or uniqueness-attribute \nconstraints) may be eliminated by replacing some of the use variables with propositional formulae over \nuse variables. This insight is the source of Alms s usage quali.er expressions. If we follow use types \nto their logical conclusion, we reach .URAL (Ahmed et al. 2005), wherein each type is composed of a pretype \nthat describes its representation and a quali.er that gives its usage. Alms does not follow this approach \nbecause we insist that quali.ed types are too verbose for a user-visible type system. Their system s \nquali.er lattice includes two more than ours, R for relevant types that allow duplication but not discarding, \nand L for linear types. This results in a rich and elegant system, but we do not believe R and L would \nbe useful in a language like Alms. However, there is an interesting correspondence between our kinding \nrules and their type rules. For example, our product type constructor (\u00d7) has kind .a+ . .\u00df+ .(a)u(\u00df), \nwhich means that the kind of a product type is the least upper bound of the kinds of its components. \nThe product typing rule in .URAL enforces a similar constraint, that the quali.er of a product type, \n., must upper bound the quali.ers of its components t1 and t2. . f GG1 . G2 . f . : QUAL .; G1 f v1 : \nt1 . f t1 : . .; G2 f v2 : t2 . f t2 : . (MPAIR). .; G f(v1,v2) : .(t1 . t2) Vault. DeLine and F\u00e4hndrich \ns Vault (2001) is a safe, low-level language with support for typestate. It tracks keys, which associate \nstatic capabilities with the identity of run-time objects, in the same manner that Alms uses existentially-quanti.ed \ntype variables to tie values to capabilities. This allows static enforcement of a variety of protocols. \nAs an example, DeLine and F\u00e4hndrich give a tracked version of the Berkeley Sockets API. In previous work \non Alms we show how Alms expresses the same interface. Vault s treatment of capabilities may be more \nconvenient to use than Alms s, because while Alms requires explicit threading of ca\u00adpability values, \nVault s key sets are tracked automatically within function bodies. On the other hand, because capabilities \nin Alms appear as ordinary values, we may combine them using the na\u00adtive intuitionistic logic of Alms \ns type system. Instead, Vault must provide a simple predicate calculus for expressing pre-and post\u00adconditions. \nFor more complicated logic, Vault allows embedding capabilities in values, but since the values are untracked, \nextracting a capability from a value requires a dynamic check. Alms s type system eliminates the need \nfor such checks for af.ne values stored in algebraic datatypes, though it also allows dynamic management \nof af.ne values by storing them in reference cells. Notably, Alms can also express F\u00e4hndrich and DeLine \ns adop\u00adtion and focus (2002).  Sing#. Microsoft s experimental Singularity operating system is written \nin Sing#, a high-level systems programming language that extends Spec# (F\u00e4hndrich et al. 2006). Sing# \nhas built-in support for channel contracts, which are a form of session type providing static checking \nof communication protocols between device drivers and other services. Unlike more idealistic linear systems, \nthe design acknowledges the need to allow for failure: every protocol implic\u00aditly includes branches to \nclose the channel at any point. Sing# processes do not share memory but can allocate tracked objects \non a common exchange heap. Only one process has access to an exchange heap object at a given time, but \na process may give up access and transmit the object over a channel to another process, which then claims \nownership of it. Alms s library includes two different implementations of ses\u00adsion types supporting different \ninterfaces, and the exchange heap concept is easily expressible as well. 7. Future Work and Conclusion \nWe already enjoy programming in Alms, but we are not done yet. Unit subsumption. In \u00a72, we found that \nadding capabilities to an existing interface often involves wrapping the old version of a function to \nignore a new argument of type unit or construct a tuple containing unit for its result. This is unnecessary. \nWhile the client outside the abstraction barrier needs to see types that involve the af.ne capabilities, \nthe implementation has no use for them. To eliminate much of this noise, we can extend our subtyping \nrelation to take advantage of the fact that unit is, well, a unit: G f t2 singleton G f t2 singleton \nG f t1 <: v t1 \u00d7 t2 G f t1 <: v t2 \u00d7 t1 G f t2 singleton References A. Ahmed, M. Fluet, and G. Morrisett. \nA step-indexed model of substructural state. In ICFP 05, pages 78 91. ACM, 2005. A. Barber. Dual intuitionistic \nlinear logic. Technical Report ECS\u00adLFCS-960347, U. of Edinburgh, 1996. P. S. Barth, R. S. Nikhil, and \nArvind. M-structures: Extend\u00ading a parallel, non-strict, functional language with state. In Proc. FPCA \n91, volume 523 of LNCS. Springer, 1991. G. M. Bierman. On Intuitionistic Linear Logic. PhD thesis, U. \nof Cambridge, 1993. J. Boyland. Checking interference with fractional permissions. In SAS 03, volume \n2694 of LNCS. Springer, 2003. K. Crary, S. Weirich, and G. Morrisett. Intensional polymorphism in type-erasure \nsemantics. JFP, 12(06):567 600, 2002. L. Damas and R. Milner. Principal type-schemes for functional programs. \nIn POPL 82, pages 207 212. ACM, 1982. R. DeLine and M. F\u00e4hndrich. Enforcing high-level protocols in low-level \nsoftware. In PLDI 01. ACM, 2001. M. F\u00e4hndrich and R. DeLine. Adoption and focus: Practical linear types \nfor imperative programming. In PLDI 02. ACM, 2002. M. F\u00e4hndrich, M. Aiken, C. Hawblitzel, O. Hodson, \nG. Hunt, J. R. Larus, and S. Levi. Language support for fast and reli\u00adable message-based communication \nin Singularity OS. In Eu\u00adroSys 06, pages 177 190. ACM, 2006. S. J. Gay, V. T. Vasconcelos, and A. Ravara. \nSession types for inter\u00adprocess communication. Technical Report TR-2003-133, U. of Glasgow, 2003. J.-Y. \nGirard. Linear logic. Theoretical Computer Science, 50:1 . . G f t1 -. t2 -. t3 <: v . t1 -. t3 102, \n1987. This is implementable via a type erasure technique such as inten\u00ad sional polymorphism (Crary et \nal. 2002). Not representing compile\u00ad time capabilities at run time has performance bene.ts as well. \nD. Leijen. Flexible types: Robust type inference for .rst-class polymorphism. In POPL 09, pages 66 77. \nACM, 2009. X. Leroy, D. Doligez, J. Garrigue, D. R\u00e9my, and J. Vouillon. The Objective Caml system. INRIA, \n3.11 edition, 2008. Type inference. Alms s local type inference eliminates most ex\u00ad plicit type applications, \nbut needing to annotate all function argu-K. Mazurak, J. Zhao, and S. Zdancewic. Lightweight linear types \nments is irksome. To .x this, we are exploring possibilities for in System F.. In TLDI 10, pages 77 88. \nACM, 2010. type inference. While we suspect that our limited subtyping should not impede full Damas-Milner \nstyle inference (Damas and Milner 1982), Alms has several idioms that rely on existential types. We are \nexploring whether an extension for .rst-class polymorphism, such as HML (Leijen 2009), would be suitable \nfor Alms. Alms is not .nished, but our prototype is at this point usable for experimentation. It is based \non a calculus, a.ms , whose type sys\u00adtem we have proved sound. While some parts of the type system are \ncomplex, we have seen in practice that Alms types are tractable and Alms programs do not look very different \nfrom the functional programs to which we are accustomed. It currently implements al\u00adgebraic datatypes, \nexceptions, pattern matching, concurrency, and opaque signature ascription. The language is rich enough \nto express Vault-style typestate, a variety of static and dynamic locking pro\u00adtocols, checked downcasts \nof one-use functions to unlimited-use functions, session types, and more. Acknowledgments We wish to \nthank J. Daniel Brown, Bryan Chadwick, Matthias Felleisen, Sam Tobin-Hochstadt, Vincent St-Amour, and \nthe anony\u00admous referees for their helpful comments, discussion, and cor\u00adrections. This research was supported \nin part by AFOSR grant FA9550-09-1-0110. R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.nition \nof Standard ML. MIT, revised edition, 1997. B. C. Pierce. Types and Programming Languages. MIT, 2002. \nR. Plasmeijer and M. van Eekelen. Clean Language Report, Ver\u00adsion 2.1. Dept. of Software Technology, \nU. of Nijmegen, 2002. A. Rossberg, C. V. Russo, and D. Dreyer. F-ing modules. In TLDI 10, pages 89 102. \nACM, 2010. M. Steffen. Polarized Higher Order Subtyping. PhD thesis, Uni\u00adversit\u00e4t Erlangen-N\u00fcrnberg, \n1997. I. E. Sutherland and G. W. Hodgman. Reentrant polygon clipping. CACM, 17(1):32 42, 1974. J. A. \nTov and R. Pucella. Stateful contracts for af.ne types. In ESOP 10, volume 6012 of LNCS, pages 550 569. \nSpringer, 2010. E. de Vries, R. Plasmeijer, and D. M. Abrahamson. Uniqueness typing simpli.ed. In IFL \n07, pages 201 218. Springer, 2008. P. Wadler. Is there a use for linear logic? In PEPM 91, pages 255 \n 273. ACM, 1991. P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc. In POPL 89, pages \n60 76. ACM, 1989.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Alms is a general-purpose programming language that supports practical affine types. To offer the expressiveness of Girard's linear logic while keeping the type system light and convenient, Alms uses expressive kinds that minimize notation while maximizing polymorphism between affine and unlimited types.</p> <p>A key feature of Alms is the ability to introduce abstract affine types via ML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than the principal usage restrictions of its implementation. This form of sealing allows the type system to naturally and directly express a variety of resource management protocols from special-purpose type systems.</p> <p>We present two pieces of evidence to demonstrate the validity of our design goals. First, we introduce a prototype implementation of Alms and discuss our experience programming in the language. Second, we establish the soundness of the core language. We also use the core model to prove a principal kinding theorem.</p>", "authors": [{"name": "Jesse A. Tov", "author_profile_id": "81372593761", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2509649", "email_address": "tov@ccs.neu.edu", "orcid_id": ""}, {"name": "Riccardo Pucella", "author_profile_id": "81100260833", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2509650", "email_address": "riccardo@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926436", "year": "2011", "article_id": "1926436", "conference": "POPL", "title": "Practical affine types", "url": "http://dl.acm.org/citation.cfm?id=1926436"}