{"article_publication_date": "01-26-2011", "fulltext": "\n Symmetric Lenses Martin Hofmann Benjamin Pierce Daniel Wagner Ludwig-Maximilians-Universit\u00a8at University \nof Pennsylvania University of Pennsylvania M\u00a8unchen, Germany Pennsylvania, USA Pennsylvania, USA Abstract \nLenses bidirectional transformations between pairs of connected structures have been extensively studied \nand are beginning to .nd their way into industrial practice. However, some aspects of their foundations \nremain poorly understood. In particular, most previous work has focused on the special case of asymmetric \nlenses, where one of the structures is taken as primary and the other is thought of as a projection, \nor view. A few studies have considered symmetric variants, where each structure contains information \nnot present in the other, but these all lack the basic operation of composition. Moreover, while many \ndomain-speci.c languages based on lenses have been designed, lenses have not been thoroughly explored \nfrom an algebraic perspective. We offer two contributions to the theory of lenses. First, we present \na new symmetric formulation, based on complements, an old idea from the database literature. This formulation \ngeneralizes the familiar structure of asymmetric lenses, and it admits a good notion of composition. \nSecond, we explore the algebraic structure of the space of symmetric lenses. We present generalizations \nof a number of known constructions on asymmetric lenses and settle some longstanding questions about \ntheir properties in particular, we prove the existence of (symmetric monoidal) tensor products and sums \nand the non-existence of full categorical products or sums in the category of symmetric lenses. We then \nshow how the meth\u00adods of universal algebra can be applied to build iterator lenses for structured data \nsuch as lists and trees, yielding lenses for operations like mapping, .ltering, and concatenation from \n.rst principles. Fi\u00adnally, we investigate an even more general technique for construct\u00ading mapping combinators, \nbased on the theory of containers. Categories and Subject Descriptors D.3.2 [Programming Lan\u00adguages]: \nLanguage Classi.cations Specialized application lan\u00adguages General Terms Design, Languages, Theory Keywords \nlens, view-update, algebra, category theory 1. Introduction The electronic world is rife with partially \nsynchronized data replicated structures that are not identical but share some common parts, and where \nthe shared parts need to be kept up to date as the Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, USA. Copyright c \n&#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 structures change. Examples include databases \nand materialized views, in-memory and on-disk representations of heap structures, connected components \nof user interfaces, and models representing different aspects of the same software system. In current \npractice, the propagation of changes between con\u00adnected structures is mostly handled by ad hoc methods. \nGiven a pair of structures X and Y , we write one transformation that maps changes to X into changes \nto Y and a separate transformation that maps Y changes to X changes. However, when the structures in\u00advolved \nare complex, managing such pairs of transformations man\u00adually can be a maintenance nightmare. This has \nled to a burgeoning interest in bidirectional program\u00adming languages, in which every expression denotes \na related pair of transformations. A great variety of bidirectional languages have been proposed (see \n[8, 13] for recent surveys), and these ideas are beginning to see commercial application, e.g., in RedHat \ns system administration tool, Augeas [21]. One particularly well-studied class of bidirectional program\u00adming \nlanguages is the framework of lenses [11]. Prior work on lenses and lens-like structures has mostly been \ncarried out in spe\u00adci.c domains designing combinators for lenses that work over strings [5, 7, 12], trees \n[11, 17, 20, 25], relations [6], graphs [16], or software models [9, 10, 15, 26, 27, 31]. By contrast, \nour aim in this paper is to advance the foundations of lenses in two signi.cant respects. First, we show \nthat lenses can be generalized from their usual asymmetric presentation where one of the structures is \nalways a view of the other to a fully symmetric version where each of the two structures may contain \ninformation that is not present in the other (Section 2). This generalization is signi.cantly more ex\u00adpressive \nthan any previously known: although symmetric variants of lenses have been studied [10, 23, 28], they \nall lack a notion of sequential composition of lenses, a signi.cant technical and prac\u00adtical limitation \n(see Section 10). As we will see, the extra struc\u00adture that we need to support composition is nontrivial; \nin particular, constructions involving symmetric lenses need to be proved correct modulo a notion of \nbehavioral equivalence (Section 3). Second, we undertake a systematic investigation of the alge\u00adbraic \nstructure of the space of lenses, using the concepts of ele\u00admentary category theory as guiding and organizing \nprinciples. (Our presentation is self contained, but some prior familiarity with basic concepts of category \ntheory will be helpful. Most proofs are omit\u00adted for brevity; they can be found in a long version of \nthe paper, available from the second author s web page.) We begin this algebraic investigation with some \nsimple generic constructions on symmetric lenses: composition, dualization, ter\u00adminal lenses, simple \nbijections, etc. (Section 4). We then settle some basic questions about products and sums (Sections 5 \nand 6). In particular, it was previously known that asymmetric lenses ad\u00admit constructions intuitively \ncorresponding to pairing and projec\u00adtion [7] and another construction that is intuitively like a sum \n[11]. However, these constructions were not very well understood; in particular, it was not known whether \nthe pairing and projection operations formed a full categorical product, while the injection arrows from \nX to X + Y and from Y to X + Y were not de.n\u00adable at all in the asymmetric setting. We prove that the \ncategory of symmetric lenses does not have full categorical products or sums, but does have symmetric \nmonoidal structures with many of the useful properties of products and sums. Next, we consider how to \nbuild lenses over more complex data structures such as lists and trees (Section 7). We .rst ob\u00adserve \nthat the standard construction of algebraic datatypes can be lifted straightforwardly from the category \nof sets to the category of lenses. For example, from the de.nition of lists as the least so\u00adlution of \nthe equation L(X) . Unit + X \u00d7 L(X) we obtain a lens connecting the set L(X) with the set Unit + X \u00d7 \nL(X); the two directions of this lens correspond to the unfold and fold operations on lists. Moreover, \nthe familiar notion of initial algebra also generalizes to lenses, giving us powerful iterators that \nallow for a modular de.nition of many symmetric lenses on lists and trees e.g., mapping a symmetric lens \nover a list, .ltering, revers\u00ading, concatenating, and translating between lists and trees. Finally, we \nbrie.y investigate an even more general technique for constructing mapping lenses that apply the action \nof a given sublens to all the elements of some data structure (Section 8). This technique applies not \nonly to algebraic data structures but to an ar\u00adbitrary container in the sense of Abbot, Altenkirch, and \nGhani [2]. This extends the variety of list and tree mapping combinators that we can construct from .rst \nprinciples to include non-inductive datatypes such as labeled dags and graphs. We carry out these investigations \nin the richer space of symmet\u00adric lenses, but many of the results and techniques should also apply to \nthe special case of asymmetric lenses. Indeed, we can show (Sec\u00adtion 9) that asymmetric lenses form a \nsubcategory of symmetric ones in a natural way: every asymmetric lens can be embedded in a symmetric \nlens, and many of the algebraic operators on symmet\u00adric lenses specialize to known constructions on asymmetric \nlenses. Conversely, a symmetric lens can be factored into a back to back assembly of two asymmetric ones. \nSections 10 and 11 discuss related and future work. 2. Fundamental De.nitions Asymmetric Lenses To set \nthe stage, let s review the standard def\u00adinition of asymmetric lenses. (Other de.nitions can be given, \nfea\u00adturing weaker or stronger laws, but this version is widely accepted. We discuss variants in Section \n10.) Suppose X is some set of source structures (say, the possible states of a database) and Y a set \nof tar\u00adget structures (views of the database). An asymmetric lens from X to Y has two components: get \n. X . Y put . Y \u00d7 X . X The get component is the forward transformation, a total function from X to Y \n. The put component takes an old X and a modi.ed Y and yields a correspondingly modi.ed X. These components \nmust obey two round-tripping laws for every x . X and y . Y : put (get x) x = x (GETPUT) get (put yx)= \ny (PUTGET) It is also useful to be able to create an element of x given just an element of y, with no \noriginal x to put it into; in order to handle this in a uniform way, each lens is also equipped with \na function create . Y . X, and we assume one more axiom: get (create y)= y (CREATEGET) Complements The \nkey step toward symmetric lenses is the no\u00adtion of complements. The idea dates back to a famous paper \nin the database literature on the view update problem [4] and was adapted to lenses in [5] (and, for \na slightly different de.nition, [22]), and it is quite simple. If we think of the get component of a \nlens as a sort of projection function, then we can .nd another projection from X into some set C that \nkeeps all the information discarded by get. Equivalently, we can think of get as returning two results \nan element of Y and an element of C that together contain all the information needed to reconstitute \nthe original element of X. Now the put function doesn t need a whole x . X to recombine with some updated \ny . Y ; it can just take the complement c . C gen\u00aderated from x by the get, since this will contain all \nthe information that is missing from y. Moreover, instead of a separate create func\u00adtion, we can simply \npick a distinguished element missing . C and de.ne create(y) as put(y, missing). Formally, an asymmetric \nlens with complement mapping be\u00adtween X and Y consists of a set C, a distinguished element missing . \nC, and two functions get . X . Y \u00d7 C put . Y \u00d7 C . X obeying the following laws for every x . X, y . \nY , and c . C:1 get x =(y, c) (GETPUT) put (y, c)= x get (put (y, c)) = (b',c') (PUTGET) b' = y Note \nthat the type is just lens from X to Y : the set C is an internal component, not part of the externally \nvisible type. In symbols, Lens(X, Y )= .C. {missing : C, get : X . Y \u00d7 C, put : Y \u00d7 C . X}. Symmetric \nLenses Now we can symmetrize. First, instead of hav\u00ading only get return a complement, we make put return \na comple\u00adment too, and we take this complement as a second argument to get. So we have get . X \u00d7CY . \nY \u00d7CX and put . Y \u00d7CX . X \u00d7 CY . Intuitively, CX is the information from X that is dis\u00adcarded by get, \nand CY is the information from Y that is discarded by put. Next we observe that we can, without loss \nof generality, use the same set C as the complement in both directions. So now we have get . X \u00d7C . Y \n\u00d7C and put . Y \u00d7C . X \u00d7C. Intu\u00aditively, we can think of the combined complement C as CX \u00d7CY that is, \neach complement contains some private information from X and some private information from Y ; by convention, \nthe get function reads the CY part and writes the CX part, while the put reads the CX part and writes \nthe CY part. Lastly, now that every\u00adthing is symmetric, the get / put distinction is not helpful, so \nwe rename the functions to putr and putl. This brings us to our core de.nition. 2.1 De.nition [Symmetric \nlens]: A lens e from X to Y (written e . X . Y ) has three parts: a set of complements C, a distin\u00adguished \nelement missing . C, and two functions putr . X \u00d7 C . Y \u00d7 C putl . Y \u00d7 C . X \u00d7 C satisfying the following \nround-tripping laws: 1 We can convert back and forth between the two presentations; in particular, if \n(get, put, create) are the components of a traditional lens, then we de\u00ad.ne a canonical complement by \nC = {f . Y .X |.y. get(f(y)) = y}. We then de.ne the components missing', get', and put' of an asym\u00admetric \nlens with complement as missing' = create and get'(x)= (get(x), .y.put(y, x)) and put'(y, f)= f(y). \n Figure 1. Behavior of a symmetric lens putr(x, c) = (y, c ' ) putl(y, c ' ) = (x, c ' ) (PUTRL) putl(y, \nc) = (x, c ' ) putr(x, c ' ) = (y, c ' ) (PUTLR) When several lenses are under discussion, we use record \nnotation to identify their parts, writing e.C for the complement set of e, etc. The force of the PUTRL \nand PUTLR laws is to establish some consistent or steady-state triples (x, y, c), for which puts of x \nfrom the left or y from the right will have no effect that is, will not change the complement. The conclusion \nof each rule has the same variable c ' on both sides of the equation to re.ect this. We will use the \nequation putr(x, c)=(y, c) to characterize the steady states. In general, a put of a new x ' from the \nleft entails .nding a y ' and a c ' that restore consistency. Additionally, we often wish this process \nto involve the complement c from the previous steady state; as a result, it can be delicate to choose \na good value of missing. This value can often be chosen compositionally; each of our primitive lenses \nand lens combinators specify one good choice for missing. One can imagine other laws. In particular, \nthe long version of the paper considers symmetric forms of the asymmetric PUTPUT laws, which specify \nthat two put operations in a row should have the same effect as the second one alone. As with asymmetric \nlenses, these laws appear too strong to be desirable in practice. Examples Figure 1 illustrates the use \nof a symmetric lens. The structures in this example are lists of textual records describing composers. \nThe partially synchronized records (a) have a name and two dates on the left and a name and a country \non the right. The complement (b) contains all the information that is discarded by both puts all the \ndates from the left-hand structure and all the countries from the right-hand structure. (It can be viewed \nas a pair of lists of strings, or equivalently as a list of pairs of strings; the way we build list lenses \nlater actually corresponds to the latter.) If we add a new record to the left hand structure (c) and \nuse the putr operation to propagate it through the lens (d), we copy the shared information (the new \nname) directly from left to right, store the private information (the new dates) in the complement, and \nuse a default string to .ll in both the private information on the right and the corresponding right-hand \npart of the complement. If we now update the right-hand structure to .ll in the missing information and \ncorrect a typo in one of the other names (e), then a putl operation will propagate the edited country \nto the complement, propagate the edited name to the other structure, and use the complement to restore \nthe dates for all three composers. Viewed more abstractly, the connection between the informa\u00adtion about \na single composer in the two tables is a lens from X \u00d7Y to Y \u00d7 Z, with complement X \u00d7 Z let s call it \ne. Its putr com\u00adponent is given (x, y) as input and has (x ' ,z) in its complement; it constructs a new \ncomplement by replacing x ' by x to form (x, z), and it constructs its output by pairing the y from its \ninput and the z from its complement to form (y, z). The putl component does the opposite, replacing the \nz part of the complement and retrieving * the x part. Then the top-level lens in Figure 1 let s call \nit e abstractly has type (X \u00d7 Y )* . (Y \u00d7 Z)* and can be thought of as the lifting of e from elements \nto lists. There are several plausible implementations of e*, with slightly different behaviors when list \nelements are added and removed i.e., when the input and complement arguments to putr or putl are * lists \nof different lengths. One possibility is to take e.C =(e.C)* and maintain the invariant that the complement \nlist in the output is the same length as the input list. When the lists in the input have different lengths, \nwe can restore the invariant by either truncating the complement list or padding it with e.missing. For \nexample, taking X = {a, b, c, . . .}, Y = {1, 2, 3,...}, Z = {A, B, C, . . .}, and e.missing =(m, M ), \nand writing (a, b, c) for the sequence with the three elements a, b, and c, we could have: putr(((a, \n1)) , ((p, P ), (q, Q))) = putr(((a, 1)) , ((p, P ))) (truncating) =(((1,P )) , ((a, P ))) putr(((a, \n1), (b, 2)) , ((a, P ))) = putr(((a, 1), (b, 2)) , ((a, P ), (m, M))) (padding) =(((1,P ), (2,M)) , ((a, \nP ), (b, M))) Notice that, after the .rst putr, the information in the second element of the complement \nlist (q, Q) is lost. The second putr creates a brand new second element for the list, so the value Q \nis gone forever; what s left is the default value M. Another possibility arguably better behaved is to \nkeep an in.nite list of complements. Whenever we do a put, we use (and update) a pre.x of the complement \nlist of the same length as the current value being put, but we keep the in.nite tail so that, later, \nwe have values to use when the list being put is longer. putr(((a, 1)) , ((p, P ), (q, Q), (m, M), (m, \nM),...)) =(((1,P )) , ((a, P ), (q, Q), (m, M), (m, M),...))  putr(((a, 1), (b, 2)) , ((a, P ), (q, \nQ), (m, M), (m, M),...)) =(((1,P ), (2,Q)) , ((a, P ), (b, Q), (m, M),...)) We call the .rst form the \nforgetful list mapping lens and the second the retentive list mapping lens. We will see, later, that \nthe difference between these two precisely boils down to a difference in the behavior of the lens-summing \noperator . in the speci.cation e * idUnit . (e . e * ) of the list mapping lens. Figure 2 illustrates \nanother use of symmetric lenses. The struc\u00adtures in this example are lists of categorized data; each \nname on the left is either a composer (tagged inl) or an author (tagged inr), and each name on the right \nis either a composer or an actor. The lens under consideration will synchronize just the composers be\u00adtween \nthe two lists, leaving the authors untouched on the left and the actors untouched on the right. The synchronized \nstate (a) shows a complement with two lists, each with holes for the composers. If we re-order the right-hand \nstructure (b), the change in order will be re.ected on the left by swapping the two composers. Adding \nan\u00adother composer on the left (c) involves adding a new hole to each complement; on the left, the location \nof the hole is determined by the new list, and on the right it simply shows up at the end. Simi\u00adlarly, \nif we remove a composer (d), the .nal hole on the other side disappears. Abstractly, to achieve this \nbehavior we need to de.ne a lens comp between (X +Y ) * and (X +Z) *. To do this, it is convenient to \n.rst de.ne a lens that connects (X + Y ) * and X * \u00d7 Y *; call this lens partition. The complement of \nthe partition is a list of booleans telling whether the corresponding element of the left list is an \nX or a Y . The putr function is fairly simple: we separate the (X+Y ) list into X and Y lists by checking \nthe tag of each element, and set the complement to exactly match the tags. For example: putr((inl a, \ninl b, inr 1) ,c) = (((a, b) , (1)), (false, false, true)) putr((inl a, inr 1, inl b) ,c) = (((a, b) \n, (1)), (false, true, false)) These examples demonstrate that putr ignores the complement entirely, fabricating \na completely new one from its input. The putl function, on the other hand, relies entirely on the complement \nfor its ordering information. When there are extra entries (not accounted for by the complement), it \nadds them at the end. Consider taking the output of the second putr above and adding c to the X list \nand 2 to the Y list: putl(((a, b, c) , (1, 2)), (false, true, false))= ((inl a, inr 1, inl b, inl c, \ninr 2) , (false, true, false, false, true)) The putl .lls in as much of the beginning of the list as \nit can, using the complement to indicate whether to draw elements from X * or from Y *. (How the remaining \nX and Y elements are interleaved is a free choice, not speci.ed by the lens laws, since this case only \narises when we are not in a round-tripping situation. The strategy shown here, where all new X entries \nprecede all new Y entries, is just one possibility.) Given partition, we can obtain comp by composing \nthree lenses in sequence: from (X + Y ) * we get to X * \u00d7 Y * using partition, then to X * \u00d7 Z * using \na variant of the lens e discussed above, and .nally to (X + Z) * using a backwards partition. Alignment \nOne important non-goal of the present paper is deal\u00ading with the (important) issue of alignment [5, 7]. \nWe consider only the simple case of lenses that work positionally. For example, the lens e * in the example \nwill always use e to propagate changes be\u00adtween the .rst element of x and the .rst element of y, between \nthe second element of x and the second of y, and so on. This amounts to assuming that the lists are edited \neither by editing individual el\u00adements in place or by adding or deleting elements at the end of the list; \nif an actual edit inserts an element at the head of one of the lists, positional alignment will produce \nsurprising (and proba\u00adbly distressing) results. We see two avenues for incorporating richer notions of \nalignment: either we can generalize the mechanisms of matching lenses [5] to the setting of symmetric \nlenses, or we can re.ne the whole framework of symmetric lenses with a notion of delta propagation; see \nSection 11. 3. Equivalence Since each lens carries its own complement and since this need not be the \nsame as the complement of another lens with the same domain and codomain we now need to de.ne what it \nmeans for two lenses to be indistinguishable, in the sense that no user could ever tell the difference \nbetween them by observing just the X and Y parts of their outputs. We will use this relation pervasively \nin what follows: indeed, most of the laws we would like our constructions to validate even things as \nbasic as associativity of composition will not hold on the nose, but only up to equivalence. 3.1 De.nition: \nGiven X, Y, Cf ,Cg and a relation R . Cf \u00d7 Cg, we say that functions f . X \u00d7 Cf . Y \u00d7 Cf and g . X \u00d7 \nCg . Y \u00d7 Cg are R-similar, written f ~R g, if they take inputs with R\u00adrelated complements to equal outputs \nwith R-related complements: (cf ,cg) . R f(x, cf )=(yf ,c ' f ) g(x, cg)=(yg,c g' ) yf = yg . (c ' f \n,c ' g) . R 3.2 De.nition [Lens equivalence]: Two lenses k and e are equiv\u00adalent (written k = e) if \nthere is a relation R . k.C \u00d7 e.C with 1. (k.missing, e.missing) . R 2. k.putr ~R e.putr 3. k.putl \n~R e.putl.  We write X .. Y for the set of equivalence classes of lenses from X to Y . When e is a \nlens, we write [e] for the equivalence class of e (that is, e . X . Y iff [e] . X .. Y ). Where no confusion \nresults, we abuse notation and drop these brackets, using e for both a lens and its equivalence class. \nWe show in the long version that this de.nition of lens equiva\u00adlence coincides with a more observational \nde.nition where two lenses are equivalent iff they always give the same sequence of out\u00adputs when presented \nwith the same sequence of inputs, starting with a missing complement. 4. Basic Constructions With the \nbasic de.nitions in hand, we can start de.ning lenses. We begin in this section with several relatively \nsimple constructions. 4.1 De.nition [Identity lens]: Let Unit be a distinguished single\u00adton set and () \nits only element.   (a) Initial replicas (b) Alphabetizing the right (c) Inserting Chopin on the left \n(d) Deleting Beethoven from the left Figure 2. Synchronizing lists of sums To check that this de.nition \nis well formed, we must show that the components de.ned in the lower box satisfy the round-trip laws \nimplied by the upper box. This proof and analogous ones for later lens de.nitions are given in full in \nthe long version. 4.2 De.nition [Lens composition]: This de.nition speci.es what it means to compose \ntwo lenses. To show that this de.nition lifts to equivalence classes of lenses, we need to check the \nfollowing congruence property. We include the proof to give a taste of the technique; proofs of similar \nlemmas for the other operators on lenses de.ned below are deferred to the long version. 4.3 Lemma [Composition \npreserves equivalence]: If k = k ' and e = e ', then k; e = k ' ; e ' . 4.4 De.nition: The following \nfunction on relations is convenient here: ' '' ' R1 \u00d7 R2 = {((c1,c2), (c1,c 2)) | (c1,c 1) . R1 . (c2,c \n2) . R2} Proof of 4.3: If the simulation Rk witnesses k = k ' and R\u00a3 witnesses e = e ' then it is straightforward \nto verify that R = Rk \u00d7 R\u00a3 witnesses k; e = k ' ; e '. There are three things to show. 1. We wish to \nshow the .rst line: (k; e).missing R (k ' ; e ' ).missing .. (k.missing, e.missing) R (k ' .missing,e \n' .missing) .. k.missing Rk k ' .missing . e.missing R\u00a3 e ' .missing But the .nal line is certainly true, \nsince Rk and R\u00a3 are simula\u00adtion relations. 2. We must show that (k; e).putr ~R (k ' ; e ' ).putr. So \ntake ck,c\u00a3,ck! ,c\u00a3! such that (ck,c\u00a3) R (ck! ,c\u00a3! ) and choose an input x. De.ne the following: (y, c \nk' )= k.putr(x, ck) (z, c \u00a3')= e.putr(y, c\u00a3) ' ' ' (y ,c k! )= k.putr(x, ck! ) ''' ' (z ,c \u00a3! )= e.putr(y \n,c\u00a3! ) We can then compute: (k; e).putr(x, (ck,c\u00a3)) = (z, (ck' ,c \u00a3')) ' ' ''' (k ; e ! )) = (z, (ck! \n,c \u00a3! )) ).putr(x, (ck! ,c\u00a3 ' '''' We need to show that z = z and that (ck,c \u00a3) R (ck! ,c \u00a3! ). '' ' \nSince ck Rk ck! , we can conclude that y = y and ck Rk ck! ; similarly, since c\u00a3 R\u00a3 c\u00a3! and y = y ', \nwe know that z = z ' (discharging one of our two proof burdens) and c '\u00a3 R\u00a3 c\u00a3'! . '''' Combining the \nabove facts, we .nd that (ck,c \u00a3) R (ck! ,c \u00a3! ) by de.nition of R (discharging the other proof burden). \n 3. The proof that (k; e).putl ~R (k ' ; e ' ).putl is similar to the putr case. D  4.5 Lemma [Associativity \nof composition]: j;(k; e) = (j; k); e. (The equivalence is crucial here: j;(k; e) and (j; k); e are not \nthe same lens because their complements are structured differently.)  4.6 Lemma [Identity arrows]: The \nidentity lens is a left and right identity for composition: idX ; e = e; idY = e. Thus symmetric lenses \nform a category, LENS, with sets as objects and equivalence classes of lenses as arrows. The identity \narrow for a set X is [idX ]. Composition is [k]; [e]=[k; e]. 4.7 Proposition [Bijective lenses]:  (If \nwe were designing syntax for a bidirectional language, we might not want to include bij, since we would \nthen need to offer pro\u00adgrammers some notation for writing down bijections in such a way that we can verify \nthat they are bijections and derive their inverses. However, even if it doesn t appear in the surface \nsyntax, we will see several places where bij is useful in talking about the algebraic theory of symmetric \nlenses.) This transformation (and several others we will see) respects much of the structure available \nin our category. Formally, bij is a functor. Recall that a covariant (respectively, contravariant) func\u00adtor \nbetween categories C and D is a pair of maps one from objects of C to objects of D and the other from \narrows of C to arrows of D that preserve typing, identities, and composition: The image of any arrow \nf : X . Y in C has the type F (f): F (X) . F (Y ) (respectively, F (f): F (Y ) . F (X)) in D.  For every \nobject X in C, we have F (idX )= idF (X) in D.  If f; g = h in C, then F (f); F (g)= F (h) (respectively, \nF (g); F (f)= F (h)) in D.  Covariant functors are simply called functors. When it can be inferred from \nthe arrow mapping, the object mapping is often elided. 4.8 Lemma: The bij operator forms a functor from \nthe category ISO, whose objects are sets and whose arrows are isomorphic func\u00adtions, to LENS that is, \nbijidX = idX and bijf ; bijg = bijf;g. 4.9 De.nition [Dual of a lens]:  op)op It is easy to see that \n(-)op is involutive that is, that (e= e for every e and that bijf-1 = bijop f for any bijective f. Re\u00adcalling \nthat an endofunctor is a functor whose source and target categories are identical, we can easily show \nthe following lemma.  4.10 Lemma: The (-)op operation can be lifted to a contravariant op ]. endofunctor \non the category LENS, mapping each arrow [e] to [e 4.11 Corollary: The category LENS is self dual, i.e., \nequivalent to its own opposite. (Note that this does not mean that each arrow is its own inverse!) Proof: \nThe arrow part of (-)op is bijective. D The lenses we have discussed so far maintain all the information \nin the domain and codomain. It is sometimes useful to discard some information in one direction of the \nlens. The terminal lens does this, recording the discarded information in the complement so that the \nother direction of the lens can restore it. 4.12 De.nition [Terminal lens]:  4.13 Proposition [Uniqueness \nof terminal lens]: Lenses with the same type as a terminal lens are equivalent to a terminal lens. More \nprecisely, suppose k . X . Unit and k.putl((), k.missing)= (x, c). Then k = termx. Of course, there may \nbe many (pairwise non-equivalent) termi\u00adnal lenses of a particular type; for any two x, y . X with x \ny, = it s clear that termx = termy. Proposition 4.13 tells us that there are exactly as many arrows e \n: X .. Unit as there are elements of X. 4.14 De.nition [Disconnect lens]:  The disconnect lens does \nnot synchronize its two sides at all. The complement, disconnect.C, is X \u00d7 Y ; inputs are squirreled \naway into one side of the complement, and outputs are retrieved from the other side of the complement. \n5. Products A few additional notions from elementary category theory will be useful for giving us ideas \nabout what sorts of properties to look for and for structuring the discussion of which of these properties \nhold and which fail for lenses. The categorical product of two objects X and Y is an object X \u00d7 Y and \narrows p1 : X \u00d7 Y . X and p2 : X \u00d7 Y . Y such that for any two arrows f : Z . X and g : Z . Y there is \na unique arrow (f, g) : Z . X \u00d7 Y the pairing of f and g satisfying (f, g); p1 = f and (f, g); p2 = g. \nIt is well known that, if a categorical product exists at all, it is unique up to isomorphism. If a category \nC has a product for each pair of objects, we say that C has products. 5.1 Theorem: LENS does not have \nproducts. Proof idea: Suppose we have lenses k . Z .. X and e . Z .. Y . Informally, the lens k includes \na way to take any Z and choose a corresponding X and a way to take any X and .nd a corresponding Z. Many \ncommon categories with products include the former, but the latter is somewhat unique to lens categories, \nso we focus on the return trip here. The lenses k and e together mean we have a way to take any X and \nchoose a corresponding Z, and we have a (separate) way to take any Y and choose a corresponding Z. Assume \ntemporarily that the object part of the product of two objects is simply the Cartesian product. To complete \nthe product, we must construct (k, e). Z .. X \u00d7 Y , that is, we must .nd a way to take an X and a Y and \nchoose a Z that corresponds to both simultaneously. But there may not be any such Z the Z that k gives \nus from X may not be the same as the Z that e gives us from Y . To complete the proof, we simply choose \nX and Y carefully to rule out the possibility of a corresponding Z, regardless of whether we choose X \n\u00d7 Y to be the Cartesian product or to be some other construction. Proof: Uniqueness of pairing shows \nthat there is exactly one lens from Unit to Unit \u00d7 Unit (whatever this may be). Combined with Prop. 4.13 \nthis shows that Unit \u00d7 Unit is a one-element set. Again by Prop. 4.13 this then means that lenses between \nUnit \u00d7 Unit and any other set X are constant which leads to cardinality clashes once |X| > 1. (A more \ndetailed proof appears in the full paper.) D However, LENS does have a similar (but weaker) structure: \na tensor product i.e., an associative, two-argument functor. For any two objects X and Y , we have an \nobject X . Y , and for any two arrows f : A . X and g : B . Y , an arrow f . g : A . B . X . Y such that \n(f1; f2) . (g1; g2)=(f1 . g1); (f2 . g2) and idX . idY = idX.Y . Furthermore, for any three objects X, \nY, Z there is a natural isomorphism aX,Y,Z :(X . Y ) . Z . X.(Y .Z) satisfying certain coherence conditions \n(which specify that all ways of re-associating a quadruple are equal). A categorical product is always \na tensor product (by de.ning f . g = (p1; f, p2; g)), and conversely a tensor product is a categorical \nproduct if there are natural transformations p1,p2, diag p1,X,Y . X . Y . X p2,X,Y . X . Y . Y diagX \n. X . X . X such that (suppressing subscripts to reduce clutter) (f . g); p1 = p1; f (1) (f . g); p2 \n= p2; g (2) diag; (f . f) = f; diag (3) diag; p1 = id (4) diag; p2 = id (5) diag; (p1 . p2) = id (6) \n for all arrows f and g. Building a categorical product from a tensor product is not the most familiar \npresentation, but it can be shown to be equivalent (see Proposition 13 in [3], for example). In the category \nLENS, we can build a tensor product and can also build projection lenses with reasonable behaviors. However, \nthese projections are not quite natural transformations laws 1 and 2 above hold only with an additional \nindexing constraint for particular f and g. More seriously, while it seems we can de.ne some reasonable \nnatural transformations with the type of diag (that is, arrows satisfying law 3), none of them satisfy \nthe .nal three laws. 5.2 De.nition [Tensor product lens]: The veri.cation that this forms a lens is \nstraightforward. 5.3 Lemma [Product bijection]: For bijections f and g, bijf . bijg = bijf\u00d7g. In fact, \nthe particular tensor product de.ned above is very well behaved: it induces a symmetric monoidal category \ni.e., a cate\u00adgory with a unit object 1 and the following natural isomorphisms: aX,Y,Z : (X . Y ) . Z \n. X . (Y . Z) .X : 1 . X . X .X : X . 1 . X .X,Y : X . Y . Y . X These are known as the associator, \nleft-unitor, right-unitor, and symmetry, respectively. In addition to the equations implied by these \nbeing natural isomorphisms, they must also satisfy some coherence conditions (given in the full version). \n5.4 Proposition [LENS,. is a symmetric monoidal category]: In the category SET, the Cartesian product \nis a bifunctor with Unit as unit, and gives rise to a symmetric monoidal category. Let a\u00d7,.\u00d7,.\u00d7,.\u00d7 be \nassociator, left-unitor, right-unitor, and sym\u00admetry natural isomorphisms. Then the . bifunctor also \ngives rise to a symmetric monoidal category of lenses, with Unit as unit and a. = bij . a\u00d7 , .. = bij \n. .\u00d7 , .. = bij . .\u00d7, and .. = bij . .\u00d7 as associator, left-unitor, right-unitor, and symmetry, respectively. \nKnowing that LENS is a symmetric monoidal category is useful for several reasons. First, it tells us \nthat, even though it is not quite a full-blown product, the tensor construction is algebraically quite \nwell behaved. Second, it justi.es a convenient intuition where lenses built from multiple tensors are \npictured as graphical wiring diagrams, and suggests a possible syntax for lenses that shuf.e product \ncomponents (which we brie.y discuss in Section 11). 5.5 De.nition [Projection lenses]: In LENS, the projection \nis parametrized by an extra element to return when executing a putl with a missing complement.  The \nother projection is de.ned similarly. Returning to the example in the introduction, recall that we wish \nto create a lens e : X \u00d7Y . Y \u00d7Z with missing elements m . X and M . Z. We now have the machinery necessary \nto construct this lens: e = p2m ; pop 1M The extra parameter to the projection (e.g. m or M above) needs \nto be chosen with some care. Some sets may have clear neutral elements; for example, a projection from \nA \u00d7 B * . A will likely use the empty list () as its neutral element. Other projections may need additional \ndomain knowledge to choose a good neutral element for example, a projection A \u00d7 Country . A might use \nthe country with the most customers as its default. In some cases, the algebraic laws that one wants \nthe projection to satisfy may guide the choice as well. The extra parameter pre\u00advents full naturality \nfrom holding, and therefore prevents this from being a categorical product, but the following indexed \nversion of the naturality law does hold. 5.6 Lemma [Naturality of projections]: Suppose k . Xk . Yk and \ne . X\u00a3 . Y\u00a3 and choose some initial value yi . Y\u00a3. De.ne (xi,ci)= e.putl(yi, e.missing). Then (k . e); \np1yi = p1xi ; k. The most serious problem, though, is that there is no diagonal. There are, of course, \nlenses with the type we need for diag for example, disconnect. Or, more usefully, the lens that coalesces \nthe copies of X whenever possible, preferring the left one when it cannot coalesce (this is essentially \nthe merge lens from [11]) where here the eq function tests its arguments for equality ' '' eq(x, x ) \nyields inl () if x = x and yields x if not. However, neither of these proposals satisfy all the required \nlaws. 6. Sums and Lists The status of sums has been even more mysterious than that of products. In particular, \nthe injection arrows from A to A + B and B to A + B do not even make sense in the asymmetric setting; \nas functions, they are not surjective, so they cannot satisfy PUTGET. A categorical sum of two objects \nX and Y is an object X + Y and arrows inl : X . X + Y and inr : Y . X + Y such that for any two arrows \nf : X . Z and g : Y . Z there is a unique arrow [f, g]: X + Y . Z the choice of f or g satisfying inl;[f, \ng]= f and inr;[f, g]= g. As with products, if a sum exists, it is unique up to isomorphism. Since products \nand sums are dual, Corollary 4.11 and Theo\u00adrem 5.1 imply that LENS does not have sums. But we do have \na tensor whose object part is a set-theoretic sum in fact, there are at least two interestingly different \nones and we can de.ne useful as\u00adsociated structures, including a choice operation on lenses. As with \nproducts, a tensor can be extended to a sum by providing injec\u00adtion and co-diagonal natural transformations \nsatisfying a family of equations, but these constructions are even farther away from being categorical \nsums than what we saw with products. The two tensors, which we called retentive and forgetful in Section \n2, differ in how they handle the complement when the new value being put is from a different branch of \nthe sum than the old value that was put. The retentive sum keeps complements for both sublenses in its \nown complement and switches between them as needed. The forgetful sum keeps only one complement, corresponding \nto whichever branch was last put. If the next put switches sides, the complement is replaced with missing. \nWe give just the retentive sum here, since it seems more useful; the forgetful sum can be found in the \nlong version. 6.1 De.nition [Retentive tensor sum lens]:  C = k.C \u00d7 e.C missing = (k.missing, e.missing) \n' putr(inl x, (ck, c\u00a3)) = let (z, c k) = k.putr(x, ck) in ' (inl z, (ck, c\u00a3)) ' putr(inr y, (ck, c\u00a3)) \n= let (w, c \u00a3) = e.putr(y, c\u00a3) in ' (inr w, (ck, c \u00a3)) ' putl(inl z, (ck, c\u00a3)) = let (x, c k) = k.putl(z, \nck) in ' (inl x, (ck, c\u00a3)) ' putl(inr w, (ck,c\u00a3)) = let (y, c \u00a3)= e.putl(y, c\u00a3) in (inr y, (ck,c \u00a3' \n)) 6.2 Lemma [Sum bijection]: For bijections f and g, bijf . bijg = bijf+g 6.3 Proposition [LENS,. \nis a symmetric monoidal category]: In SET, the disjoint union gives rise to a symmetric monoidal cate\u00adgory \nwith \u00d8 as unit. Let a+,.+,.+,.+ be associator, left-unitor, right-unitor, and symmetry natural isomorphisms. \nThen the . bi\u00adfunctor gives rise to a symmetric monoidal category of lenses with \u00d8 as unit and a. = bij \n. a+ , .. = bij . .+ , .. = bij . .+, and .. = bij..+ as associator, left-unitor, right-unitor, and symmetry, \nrespectively. The types of these natural isomorphisms are: a. . (X + Y )+ Z . X +(Y + Z) X,Y,Z .. .\u00d8 \n+ X . X X . .X . X + \u00d8. X . .X,Y . X + Y . Y + X Unlike the product unit, there are no interesting lenses \nwhose domain is the sum s unit, so this cannot be used to de.ne the injection lenses; we have to do it \nby hand. 6.4 De.nition [Injection lenses]: C = X \u00d7 (Unit + Y ) missing =(x, inl ()) putr(x, (x ' , inl \n())) =(inl x, (x, inl ())) putr(x, (x ' , inr y)) =(inr y, (x, inr y)) putl(inl x, c) =(x, (x, inl ())) \nputl(inr y, (x, c)) =(x, (x, inr y)) We also de.ne inry = inly; .. Y,X .   6.5 Proposition: The injection \nlenses are not natural. As with products, where we have a useful lens of type X . X \u00d7 X that is nevertheless \nnot a diagonal lens, we can craft a useful conditional lens of type X +X . X that is nevertheless not \na codiagonal lens. In fact, we de.ne a more general lens union . X + Y . X . Y . Occasionally, a value \nthat is both an X and a Y may be put to the left across one of these union lenses. In this situation, \nthe lens may legitimately choose either an inr tag or an inl tag. The union lens uses the most recent \nunambiguous put to break the tie. (In the long version, we also de.ne a variant that looks back to the \nlast tagged value that was put to the right that was in both sets.) 6.6 De.nition [Union lens]: C = Bool \nmissing = false putr(inl x, c)=(x, false) putr(inr y, c)=(y, true) putl(xy, c) ( (inl xy, false) xy /. \nY . (xy . X .\u00acc) = (inr xy, true) xy /. X . (xy . Y . c) This de.nition is not symmetric in X and Y \n, because putl prefers to return an inl value if there have been no tie breakers yet. Because of this \npreference, union cannot be used to construct a true codiagonal. However, there are two useful related \nconstruc\u00adtions: 6.7 De.nition [Switch lens]: 6.8 De.nition [Retentive case lens]: A forgetful case \nlens appears in the long version. Lists We can also de.ne a variety of lenses operating on lists. We \nonly consider mapping here, because in the next section we show how to obtain this and a whole variety \nof other functions on lists as instances of a powerful generic theorem, but it is useful to see one concrete \ninstance .rst! Write X * for the set of lists with elements from the set X. Write () for the empty list \nand x:xs for the list with head x and tail xs. Write X. for the set of in.nite lists over X. When x . \nX and ss . X., write x:ss . X. for the in.nite list with head x and tail ss. Write x . . X. for the in.nite \nlist of x s. 6.9 De.nition [Retentive list mapping lens]: C =(e.C). missing =(e.missing). putr(x, c)= \nlet (x1,...,xm) = x in let (c1,...) = c in let (yi,c i' )= e.putr(xi,ci) in ((y1,...,ym) , (c1' ,...,c \n' ,cm+1,...)) m putl (similar) As we saw in Section 2, there is also a forgetful variant of the list \nmapping lens. Indeed, this is the one that corresponds to the known list mapping operator on asymmetric \nlenses [7, 11]. Additionally, the map lens gives us the machinery we need to complete the .rst example \nin the introduction: simply de.ne e * = map(e). 7. Iterators In functional programming, mapping functionals \nare usually seen as instances of more general fold patterns, or de.ned by general recursion. In this \nsection, we investigate to what extent this path can be followed in the world of symmetric lenses. Allowing \ngeneral recursive de.nitions for symmetric lenses may be possible, but in general, complements change \nwhen un\u00adfolding a recursive de.nition; this means that the structure of the complement of the recursively \nde.ned function would itself have to be given by some kind of .xpoint construction. Preliminary in\u00advestigation \nsuggests that this is possible, but it would considerably clutter the development on top of the general \ninconvenience of having to deal with partiality. Therefore, we choose a different path. We identify a \nfold combinator for lists, reminiscent of the view of lists as initial algebras. We show that several \nimportant lenses on lists including mapping can be de.ned with the help of a fold, and that, due to the \nself-duality of lenses, folds can be composed back-to-back to yield general recursive patterns in the \nstyle of hylomorphisms [24]. We also discuss iteration patterns on trees and argue that the methodology \ncarries over to other polynomial inductive datatypes. 7.1 Lists Let fold . Unit +(X\u00d7X * ) . X * be the \nbijection between unfolded lists and lists; fold takes inl () to () and inr (x, xs) to x:xs. Note that \nbijfold . Unit +(X\u00d7X * ) .. X * is then a bijective arrow in the category LENS. 7.1.1 De.nition: An X-list \nalgebra on a set Z is an arrow e . Unit +(X\u00d7Z) .. Z and a function w . Z . N such that '' ' e.putl(z, \nc)=(inr (x, z ),c ) implies w(z ) <w(z). We write * TX for the functor that sends any lens k to idUnit \n. (idX . k). The function w here plays the role of a termination measure. We will be iterating e.putl, \nproducing a stream of values of type Z, which we would like to guarantee eventually ends. 7.1.2 Theorem: \nFor X-list algebra e on Z, there is a unique arrow It(e) . X * .. Z such that the following diagram commutes: \nbijfold * X * TX (X * ) * TX (It(e)) It(e) * TX (Z) Z e Proof sketch: We choose the complement of \nIt(e) to be e.C., so that the complements of the two arms of the commuting square are isomorphic. We \nthen take commutativity of the diagram as a suggestion for a recursive de.nition of both putr and putl. \nThe length of the list in the case of putr and the weight function in the case of putl are used as ranking \nfunctions establishing totality of the recursive de.nitions. One must then prove, again by induction \non these ranking functions, that the square does indeed commute. To show uniqueness, we take another \nlens k which satis.es the above commutativity diagram. The diagram induces an unfold\u00ading of k s complement \ninto an in.nite sequence of complements that satisfy a pairwise correspondence property with the in.nite \nse\u00adquence in It(e) s complement. We can then show that putr and putl preserve this correspondence, which \nlets us construct a rela\u00adtion witnessing the equivalence of k and It(e). D In the terminology of universal \nalgebra, an algebra for a functor F from some category to itself is simply an object Z and an arrow F \n(Z) . Z. An arrow between F -algebras (Z, f) and (Z ' ,f ' ) is an arrow u . Z . Z ' such that f; u = \nF (u); f '. The F -algebras thus form a category themselves. An initial F -algebra is an initial object \nin that category (an initial object has exactly one arrow to each other object, and is unique up to isomorphism). \nF -algebras can be used to model a wide variety of inductive datatypes, includ\u00ading lists and various \nkinds of trees [29]. Using this terminology, Theorem 7.1.2 says that bijfold is an initial object in \nthe subcate\u00ad * gory consisting of those TX -algebras for which a weight function w is available. Let \nus consider some concrete instances of the theorem. First, if k . X .. Y is a lens, then we can form \nan X-list algebra e on Y * by composing idUnit . (k . idY * ) . Unit +(X\u00d7Y * ) .. Unit +(Y \u00d7Y * ) with \nbijfold . Unit +(Y \u00d7Y * ) .. Y * . A suitable weight function is given by w(ys)= length(ys). The induced \nlens It(e) . .. is the lens analog of X * Y * the familiar list mapping function. In fact, substituting \nthe lens e . X \u00d7 Y .. Y \u00d7 Z (from the introduction) for k in the above diagram, we .nd that It(e) is \nthe sneakier variant of the lens e *. (Again, we are ignoring the important question of alignment here. \nA hand-written map lens could perform a more sophisticated alignment analysis to associate similar items \nin a sequence of puts and recover more appropriate data from the complement; the process described above \nresults in a simple positional alignment scheme.) Second, suppose that X = X1 + X2 and let Z be X1 * \n\u00d7 X2 * . Writing Xi + for Xi \u00d7 Xi*, we can de.ne isomorphisms f . (X1 + X2) \u00d7 X1 * \u00d7 X2 * . (X+ + X2+)+(X+ \n\u00d7 X+ + X+ \u00d7 X2+) 1 121 g . Unit + ((X1+ + X2+)+ X1+ \u00d7 X2+) ** . X1 \u00d7 X2 by distributing the sum and unfolding \nthe list type for f and by factoring the polynomial and folding the list type for g. Then we can create \n  7.2 Other Datatypes Analogs of Theorem 7.1.2 and Corollary 7.1.3 are available for a number of other \nfunctors, in particular those that are built up from variables by + and \u00d7. All of these can also be construed \nas con\u00adtainers (see Section 8), but the iterator and hylomorphism patterns provide more powerful operations \nfor the construction of lenses than the mapping operation available for general containers. More\u00adover, \nthe universal property of the iterator provides a modular proof method, allowing one to deduce equational \nlaws which can be cum\u00adbersome to establish directly because of the de.nition of equality as behavioral \nequivalence. For instance, we can immediately deduce that list mapping is a functor. Containers, on the \nother hand, sub\u00adsume datatypes such as labeled graphs that are not initial algebras. Iterators with multiple \narguments The list iterator allows us to de.ne a lens between X * and some other set Z, but Theorem 7.1.2 \ncannot be directly used to de.ne a lens between X * \u00d7 Y and Z (think of Y as modeling parameters). In \nstandard functional programming, a map from X * \u00d7 Y to Z is tantamount to a map from X * to Y .Z, so \niteration with parameters is subsumed by the parameterless case. Unfortunately, LENS does not seem to \nhave the function spaces required to play this trick. * Therefore, we introduce the functor TX,Y (Z)= \nY + X \u00d7 Z * and notice that TX,Y (X * \u00d7 Y ) X * \u00d7 Y . Just as before, an A suitable weight function \nfor e is given by w((xs1, xs2)) = length(xs1)+ length(xs2). The lens It(e) . (X1 + X2) * .. X1 * \u00d7 X2 \n* that we obtain from iteration partitions the input list in one direction and uses a stream of booleans \nfrom the state to put them back in the right order in the other direction. Indeed, It(e) is exactly the \npartition lens described in the introductory examples. Composing it with a projection yields a .lter \nlens. (Alternatively, the .lter lens could be obtained directly by iterating a slightly trickier e.) \nConsequently, we now have the machinery we need to de.ne comp from the introduction: .lter = partition; \np1O comp = .lter; .lterop 7.1.3 Corollary: Suppose kop is an X-list algebra on W and e is an X-list algebra \non Z. Then there is a lens Hy(k, e) . W .. Z such that the following diagram commutes: * k TX (W ) W \n* TX (Hy(k, e)) Hy(k, e) * TX (Z) Z e )op Proof: De.ne Hy(k, e) as the composition It(kop; It(e). \nD One can think of Hy(k, e) as a recursive de.nition of a lens. The lens k tells whether a recursive \ncall should be made, and if so, produces the argument for the recursive call and some auxiliary data. \nThe lens e then describes how the result is to be built from the result of the recursive call and the \nauxiliary data. This gives us a lens version of the hylomorphism pattern from functional programming \n[24]. Unfortunately, we were unable to prove or disprove the uniqueness of Hy(k, e). We have not formally \nstudied the question of whether It(e) is actually an initial algebra, i.e., whether it can be de.ned \nand is unique even in the absence of a weight function. However, this seems unlikely, because then it \nwould apply to the case where Z is the set of .nite and in.nite X lists and e the obvious bijective lens. \nThe putl component of It(e) would then have to truncate an in.nite list, which would presumably break \nthe commuting square. * algebra for that functor is a lens e . TX,Y (Z) . Z together with a function \nw : Z . N such that e.putl(z, c)=(inr (x, z ' ),c ' ) implies w(z ' ) <w(z). As an example, let Y = Z \n= X * and de.ne X * Iteration yields a lens X * \u00d7 X * . that can be seen as a bidirectional version \nof list concatenation. The commuting square for the iterator corresponds to the familiar recursive de.nition \nof concatenation: concat(() , ys)= ys and concat(x:xs, ys)= x:concat(xs, ys). In the bidirectional case \nconsidered here the complement will automatically retain enough information to allow splitting in the \nputl-direction. We can use a version of Corollary 7.1.3 for this data structure to implement tail recursive \nconstructions. Consider, for instance, the * + X * . X * TUnit,X* -algebra k : X * \u00d7 X * \u00d7 X * where \nk.putl((acc, ()), true) =(inl acc, true) k.putl((acc,x:xs), true)=(inr (x:acc, xs), true) k.putl((acc, \nxs), false) =(inr (acc, xs), false). * : X * . X * Together with the TUnit,X* -algebra switchX* + X \n* , this furnishes a bidirectional version of the familiar tail recursive list reversal that sends (acc, \nxs) to xs rev acc. Trees For set X let Tree(X) be the set of binary X-labeled trees given inductively \nby leaf . Tree(X) and x . X, e . Tree(X),r . Tree(X) . node(x, e, r) . T ree(X). Con\u00adsider the endofunctor \nT T ree (Z) = Unit + X \u00d7 Z \u00d7 Z. Let c . X T Tree X (Tree(X)) . Tree(X) denote the obvious bijective \nlens. T Tree An X-tree algebra is a lens e . X (Z) . Z and a function w . Z . N with the property that \nif e.putl(z, c)= (inr (x, zl,zr),c ' ) then w(zl) <w(z) and w(zr) <w(z). The bijective lens c is then \nthe initial object in the category of X-tree algebras; that is, every X-tree algebra on Z de.nes a unique \nlens in Tree(X) . Z. Consider, for example, the concatenation lens concat : X * \u00d7 X * ' \u00d7 X * . X * \n. X *. Let concat : Unit + X \u00d7 X * be the lens obtained from concat by precomposing with the fold\u00adisomorphism \nand the terminal lens termO . Intuitively, this lens sends inl () to () and x, xs, xs ' to x:xs@xs ', \nusing the complement to undo this operation properly. This lens forms an example of a tree algebra (with \nnumber of nodes as weight functions) and thus iteration furnishes a lens Tree(X) . X * which does a pre-order \ntraversal, keeping enough information in the complement to rebuild a tree from a modi.ed traversal. The \nhylomorphism pattern can also be applied to trees, yielding the ability to de.ne symmetric lenses by \ndivide-and-conquer, i.e., by dispatching one call to two parallel recursive calls whose results are then \nappropriately merged. 8. Containers The previous section suggests a construction for a variety of oper\u00adations \non datatypes built from polynomial functors. Narrowing the focus to the very common map operation, we \ncan generalize still further, to any kind of container functor [1], i.e. a normal functor in the terminology \nof Hasegawa [14] or an analytic functor in the terminology of Joyal [19]. (These structures are also \nrelated to the shapely types of Jay and Cockett [18].) 8.1 De.nition [Container]: A container consists \nof a set I to\u00adgether with an I-indexed family of sets B . I . Set. Each container (I,B) gives rise to \nan endofunctor FI,B on SET h whose object part is de.ned by FI,B (X)= i.I B(i) . X. For example, if I \n= N and B(n)= {0, 1,...,n-1}, then FI,B (X) is X * (up to isomorphism). Or, if I = Tree(Unit) is the \nset of binary trees with trivial labels and B(i) is the set of nodes of i, then FI,B(X) is the set of \nbinary trees labeled with elements of X. In general, we can think of I as a set of shapes and, for each \nshape i . I, we can think of B(i) as the set of positions in shape i. So an element (i, f) . FI,B(X) \nconsists of a shape i and a function f assigning an element f (p) . X to each position p . B(i). The \narrow part of FI,B maps a function u . X . Y to a function FI,B (u) . FI,B(X) . FI,B (Y ) given by (i, \nf) . (i, f; u). Now, we would like to .nd a way to view a container as a functor on the category of lenses. \nIn order to do this, we need a little extra structure. 8.2 De.nition: A container with ordered shapes \nis a pair (I,B) satisfying these conditions: 1. I is a partial order with binary meets. We say i is a \nsubshape of j whenever i = j. 2. B is a functor from (I, =) viewed as a category (with one object for \neach element and an arrow from i to j iff i = j) into SET. When B and i are understood, we simply write \nb|i ' for B(i = i ' )(b) if b . B(i) and i = i ' . 3. If i and i ' are both subshapes of a common shape \nj and we have positions b . B(i) and b ' .B(i ' ) with b|j = |j, then  b ' there must be a unique b0.B(i.i \n' ) such that b = b0|i and b ' = b0|i '. Thus such b and b ' are really the same position. In other words, \nevery diagram of the following form is a pullback: B(i . i ' ) B(i . i ' = i) B(i) B(i . i ' = i ' ) \nB(i = j) B(i ' ) B(i ' = j) B(j) If i = j, we can apply the instance of the pullback diagram where i \n= i ' and hence i . i ' = i and deduce that B(i = j) . B(i) . B(j) is always injective. For example, \nin the case of trees, we can de.ne t = t ' if every path from the root in t is also a path from the root \nin t '. The arrow part of B then embeds positions of a smaller tree canonically into positions of a bigger \ntree. The meet of two trees is the greatest common subtree starting from the root. 8.3 De.nition [Container \nmapping lens]: C = {t .B(i) . e.(C) | i.I .i, i ' .i = i ' ..b.B(i).t(i ' )(b|i ' )= t(i)(b)}missing(i)(b)= \ne.missing putr((i, f),t)= let f ' (b)= fst(e.putr(f(b),t(i)(b))) in let t ' (j)(b)= if .b0 . B(i . j).b0|j \n= b then snd(e.putr(f(b0|i),t(j)(b))) in else t(j)(b) ((i, f ' ),t ' ) putl (similar) (Experts will \nnote that C is the limit of the contravariant functor i . (B(i) . e.(C)). Alternatively, we can construe \nC as the function space D . e.(C) where D is the colimit of the functor h B. Concretely, D is given \nby i.I B(i) modulo the equivalence relation ~ generated by (i, b) ~ (i ' ,b ' ) whenever i = i ' and \nb ' = B(i = i ' )(b).) For the case of lists, this mapping lens coincides with the reten\u00adtive map that \nwe obtained from the iterator in Section 7. In general, two pieces of data synchronized by one of these \nmapping lenses will have exactly the same shape; any shape change to one of the sides will be precisely \nmirrored in the other side. For example, the tree version of this lens will transport the deletion of \na node by deleting the node in the same position on the other side. We believe it should also be possible \nto de.ne a forgetful version where the complement is just FI,B (e.C). 9. Asymmetric Lenses as Symmetric \nLenses The .nal step in our investigation is to formalize the connection between symmetric lenses and \nthe more familiar asymmetric ones, and to show how known constructions on asymmetric lenses corre\u00adspond \nto the constructions we have considered. a Write X . Y for the set of asymmetric lenses from X to Y \n(using the .rst presentation of asymmetric lenses from Section 2, with get, put, and create components). \n9.1 De.nition: Every asymmetric lens can be embedded in a sym\u00admetric one.  C = {f . Y . X |.y . Y. e.get(f(y)) \n= y} missing = e.create putr(x, f)=(e.get(x),fx) putl(y, f)= let x = f(y) in (x, fx) (Here, fx(y) means \ne.put(y, x).) Viewing X as the source of an asymmetric lens (and therefore as having more information \nthan Y ), we can understand the de.nition of the complement here as being a value from X stored as a \nclosure over that value. The presentation is complicated slightly by the need to accommodate the situation \nwhere a complete X does not yet exist i.e. when de.ning missing in which case we can use create to fabricate \nan X value out of a Y value if necessary. 9.2 De.nition [Asymmetric lenses]: Here are several useful \nasym\u00admetric lenses, based on string lenses from [7]. (We give only their names and types here; full de.nitions \nappear in the long version.) a We use eX,Y to stand for any asymmetric lens e . X . Y . a copyX . X . \nX a eX,Y ; eY,Z . X . Z a aconstx . X . Unit whenever x . X a eX,Y \u00b7 eZ,W . X \u00d7 Z . Y \u00d7 W a eX,Y |eZ,W \n. X + Z . Y . W * ** a eX,Y . X . Y 9.3 Theorem: The symmetric embeddings of these lenses corre\u00adspond \nnicely to de.nitions from earlier in this paper: sym copyX = idX (1) (k; e)sym ksym sym = ; e(2) sym \naconstx = termx (3) (k \u00b7 e)sym ksym sym =. e(4) (k|e)sym (ksym .f sym = e); union (5) * )sym f sym (e \n= map (e) (6) The .rst two show that (-)sym is a functor. The .f operator is the forgetful variant of \n.; see the long version for the full de.nition. We suspect that there might be an asymmetric fold construction \nsimilar to our iteration lens above satisfying an equivalence like fold(e)sym = It(esym ), but have not \nexplored this carefully. The (-)sym functor is not full that is, there are some symmet\u00adric lenses which \nare not the image of any asymmetric lens. Injection lenses, for example, have no analog in the category \nof asymmetric lenses, nor do either of the example lenses presented in the intro\u00adduction. However, we \ncan characterize symmetric lenses in terms of asymmetric ones in a slightly more elaborate way.  9.4 \nTheorem: Given any arrow e of LENS, there are asymmetric )op ; ksym lenses k1,k2 such that (k1 sym 2 \n= e. To see this, we need to know how to asymmetrize a symmetric lens. We can view a symmetric lens as \na pair of asymmetric lenses joined tail to tail whose common domain is consistent triples. For any lens \ne . X . Y , de.ne S\u00a3 = {(x, y, c) . X \u00d7 Y \u00d7 e.C |e.putr(x, c)=(y, c)}. Now de.ne: get((x, y, c)) = x \n' ''' put(x, (x, y, c)) = let (y ,c )= e.putr(x ,c) ' '' in (x ,y ,c ) create(x)= let (y, c)= e.putr(x, \ne.missing) in (x, y, c) a The de.nition of easym l . S\u00a3 . Y is similar. asym asym Proof of 9.4: Given \n[e], choose k1 = er and k2 = el . D 10. Related Work There is a large literature on lenses and related \napproaches to propagating updates between connected structures. We discuss only the most closely related \nwork here; good general surveys of the area can be found in [8, 13]. Connections to the literature on \nview update in databases are surveyed in [11]. The .rst symmetric approach to update propagation was \npro\u00adposed by Meertens [23] and followed up by Stevens [26], Diskin [10], and Xiong, et al [30]. Meertens \nsuggests modeling synchronization between two sets X and Y by a consistency relation R . X\u00d7Y and two \nconsistency maintainers < : X \u00d7 Y . X and C : X \u00d7 Y . Y such that (x< y) Ry and xR (xC y) always hold, \nand such that xRy implies x< y = x and xC y = y. The main advantage of symmetric lenses over consistency \nmaintainers is their closure under composition. Indeed, all of the aforementioned authors note that, \nin general, consistency main\u00adtainers do not compose and view this as a drawback. Suppose that we have \nrelations R . X \u00d7 Y and R ' . Y \u00d7 Z maintained by C,< and C ' ,< ', resp. If we want to construct a maintainer \nfor the composition R; R ', we face the problem that, given x . X and z . Z, there is no canonical way \nof coming up with a y . Y that will allow us to use either of the existing maintainer functions. Concretely, \nMeertens gives the following counterexample. Let X be the set of nonempty context free grammars over \nsome alpha\u00adbet, and let Y be the set of words over that same alphabet. Let R . X \u00d7 Y be given by GRx \n.. x . L(G). It is easy to de.ne computable maintainer functions making this relation a constraint maintainer. \nComposing this relation with its opposite yields an undecidable relation (namely, whether the intersection \nof two context-free grammars is nonempty), so there cannot be computable maintainer functions. We can \ntransform any constraint maintainer into a symmetric lens as follows: take the relation R itself (viewed \nas a set of pairs) as the complement, and de.ne putl(x ' , (x, y)) = (x ' C y, (x ' ,x ' Cy)) and similarly \nfor putr. If we compose such a symmetric lens with its opposite we obtain R\u00d7Rop as the complement and, \nfor example, ' ' ''' putr(x, ((x1,y1), (y2,x2))) = (x2 <(xCy1), ((x,x Cy1), (xC y1,x2 <(x ' Cy1)))). \nFor Meertens counterexample, we would have complements of the form ((G1,w1), (w2,G2)), with w1 . L(G1) \nand w2 . L(G2); putr -ing a new grammar G ' 1 through the com\u00ad '' ' posed lens yields the complement \n((G ' 1,w 1), (w1,G 2' )), where w1 is w1 if w1 . L(G1) and some default otherwise, and where G ' 2 = \nG2 if w1 ' . L(G2) and S.w1 ' (where S is the start state) otherwise. We observe that there is a property \nof lenses analogous to Meertens requirement that xRy implies x< y = x. This prop\u00aderty is not necessarily \npreserved by composition, and in particular the lens described above for synchronizing languages does \nnot have it. Meertens recommends using a chain of consistency maintainers in such a situation to achieve \na similar effect; however, the proper\u00adties of such chains have not been explored. For asymmetric lenses, \na number of alternative laws have been explored. Some of these are weaker than ours; for example, a number \nof papers from a community of researchers based in Tokyo replace the PUTGET law with a somewhat looser \nPUTGETPUT law, permitting a broader range of useful behaviors for lenses that duplicate information. \nIt would be interesting to see what kind of categorical structures arise from these choices. The proposal \nby Matsuda et al.[22] is particularly interesting because it also employs the idea of complements. Conversely, \nstronger laws can be imagined, such as the PUTPUT law discussed by Foster et al. [11]. A different foundation \nfor de.ning lenses by recursion was explored by Foster et al. [11], using standard tools from domain \ntheory to de.ne monotonicity and continuity for lens combinators parametrized on other lenses. The main \ndrawback of this approach is that the required (manual) proofs that such recursive lenses are total tend \nto be somewhat intricate. By contrast, we expect that our initial-algebra approach can be equipped with \nautomatic proofs of totality (that is, choices of the weight function w) in many cases of interest. 11. \nConclusions and Future Work We have proposed the .rst notion of symmetric bidirectional trans\u00adformations \nthat supports composition. Composability opens up the study of symmetric bidirectional transformations \nfrom a category\u00adtheoretic perspective. We have explored the category of symmetric lenses, which is self-dual \nand has the category of bijections and that of asymmetric lenses each as full subcategories. We have \nsurveyed the structure of this category and found it to admit tensor product structures that are the \nCartesian product and disjoint union on ob\u00adjects. We have also investigated datatypes both inductively \nand as containers and found the category of symmetric lenses to support powerful mapping and folding \nconstructs. Syntax Although we have focused here on semantic and alge\u00adbraic foundations, many of our \nconstructions have a straightfor\u00adward syntactic realization. In particular, it is easy to give a string\u00adtransformation \ninterpretation to all the constructions in Sections 4 to 6 (including lenses over lists); these could \neasily be used to build a symmetric version of Boomerang [7]. More interesting would be to eliminate \nBoomerang s built-in lists and instead obtain lenses over lists and other structures (mapping, reversing, \n.attening of lists, transforming trees into lists) solely by using the combinators derived from the category-theoretic \nstructure we have exhibited. To accomplish this, two further .ne points need to be considered. First, \nwe would want an automatic way for discovering weight functions for iterators. We believe that a straightforward \ntermination analysis based on unfolding (similar to the one built into Coq) could help, but the details \nremain to be checked. And second, we must invent a formal syntax for programming with containers. Surprisingly, \nthe existing literature does not seem to contain such a proposal. More speculatively, it is a well-known \nfolklore result that sym\u00admetric monoidal categories are in 1-1 correspondence with wiring diagrams and \nwith .rst-order linear lambda calculus. We would like to exploit this correspondence to design a lambda-calculus\u00adlike \nsyntax for symmetric lenses and perhaps also a diagrammatic language. The linear lambda calculus has \njudgments of the form x1:A1,...,xn:An f t : A0, where A0,...,An are sets or possi\u00adbly syntactic type \nexpressions and where t is a linear term made up from basic lenses, lens combinators, and the variables \nx1,...,xn. This could be taken as denoting a symmetric lens A1 .\u00b7\u00b7\u00b7.An . A0. For example, here is such \na term for the lens concat ' from Sec\u00adtion 7.2: z:Unit . A . A * . A * f match z with | inl () . termop \nO | inr (a, al, ar) . concat(a:al, ar) The interpretation of such a term in the category of lenses then \ntakes care of the appropriate insertion of bijective lenses for regrouping and swapping tensor products. \nComplements as States One bene.t of treating complements ex\u00adplicitly is that it opens the way to a stateful \npresentation of lenses. The idea is that the complement of a lens can be thought of as its lo\u00adcal storage \nthe part of the heap that belongs to it. An obvious next step is that, instead of the lens components \ntaking the local storage as an argument and returning an updated version as a result, they can just hang \nonto it themselves, internally, in mutable variables. The types of the put operations then become just \ne.putr . A . B and e.putl . B . A, where the . is now a programming lan\u00adguage function type, with the \nusual implicit treatment of the heap. This avoids destructing the given C each time we propagate an up\u00addate \nand rebuilding a new C to yield as a result, improving the ef\u00ad.ciency of the implementation. An additional \nimprovement comes from the next potential extension. Alignment and Delta Lenses As we mentioned in Section \n2, dealing correctly with alignment of structured information is cru\u00adcial in practice. This issue has \nbeen extensively explored in the context of asymmetric lenses, and it seems it should be possible to \nadapt existing ideas such as dictionary lenses [7] and matching lenses [5] to symmetric lenses. An even \nbetter approach might be to change the fundamental nature of lenses so that, instead of working directly \nwith entire structures, they work with deltas descriptions of changes to the structures. These deltas \ncan arise from simple po\u00adsitional judgments, as in this paper, from diff-like heuristics, from cues within \nthe data itself, or perhaps even from user interaction the lens itself doesn t need to know anything \nabout this. Many of our basic constructions can be adapted to deltas by taking the domain and codomain \nof a lens to be monoids (of edit operations) instead of sets, and then, for each lens construction, de.ning \nan appropriate edit monoid from the monoids of its com\u00adponents. For example, an edit for a pair lens \nis a pair of edits for the left-and right-hand sides of the pair. However, more thought is re\u00adquired \nto make this scheme really work: applying this idea naively leads to insuf.ciently expressive edit languages \nfor structures like lists. In particular, we would like to see insertion and deletion as edit operations \non lists (and rotations and the like for trees, etc.). Currently, we believe that containers are a promising \nframework for this endeavour. Algebraic Structure We have shown that the category of symmet\u00adric lenses \ndoes not have products or sums. One reviewer suggests that it may be interesting to explore placing a \npartial order on the the homsets of our category (the sets of arrows between pairs of ob\u00adjects). Perhaps \nthis extra structure would allow us to de.ne variants of products and sums in which the required equations \ndo not hold as equalities, but as inequalities. Acknowledgments We are grateful to Nate Foster for productive \ndiscussions of many points, especially about the category of lenses, and to both Nate and Alexandre Pilkiewicz \nfor helpful comments on drafts of the paper. Our work is supported by the National Sci\u00adence Foundation \nunder grant IIS-0534592 Linguistic Foundations for XML View Update. References [1] M. Abbott, T. Altenkirch, \nand N. Ghani. Categories of containers. In Foundations of Software Science and Computation Structures, \npages 23 38. Springer, 2003. [2] Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Containers: constructing \nstrictly positive types. Theor. Comput. Sci., 342(1):3 27, 2005.  [3] Samson Abramsky and Nikos Tzevelekos. \nIntroduction to categories and categorical logic. In Bob Coecke, editor, New Structures for Physics. \nSpringer, 2010. [4] Franc\u00b8ois Bancilhon and Nicolas Spyratos. Update semantics of rela\u00adtional views. \nACM Transactions on Database Systems, 6(4):557 575, December 1981. [5] Davi M. J. Barbosa, Julien Cretin, \nNate Foster, Michael Greenberg, and Benjamin C. Pierce. Matching lenses: Alignment and view up\u00addate. \nIn ACM SIGPLAN International Conference on Functional Pro\u00adgramming (ICFP), Baltimore, Maryland, September \n2010. [6] Aaron Bohannon, Jeffrey A. Vaughan, and Benjamin C. Pierce. Re\u00adlational lenses: A language \nfor updateable views. In Principles of Database Systems (PODS), 2006. Extended version available as Uni\u00adversity \nof Pennsylvania technical report MS-CIS-05-27. [7] Aaron Bohannon, J. Nathan Foster, Benjamin C. Pierce, \nAlexandre Pilkiewicz, and Alan Schmitt. Boomerang: Resourceful lenses for string data. In ACM SIGPLAN \nSIGACT Symposium on Principles of Programming Languages (POPL), San Francisco, California, January 2008. \n[8] Krzysztof Czarnecki, J. Nathan Foster, Zhenjiang Hu, Ralf L\u00a8 ammel, Andy Sch\u00a8urr, and James F. Terwilliger. \nBidirectional transformations: A cross-discipline perspective. In Richard F. Paige, editor, ICMT, volume \n5563 of Lecture Notes in Computer Science, pages 260 283. Springer, 2009. ISBN 978-3-642-02407-8. [9] \nZ. Diskin, K. Czarnecki, and M. Antkiewicz. Model-versioning-in\u00adthe-large: algebraic foundations and \nthe tile notation. In Proceedings of the 2009 ICSE Workshop on Comparison and Versioning of Soft\u00adware \nModels, pages 7 12. IEEE Computer Society, 2009. [10] Zinovy Diskin. Algebraic models for bidirectional \nmodel synchroniza\u00adtion. In Krzysztof Czarnecki, Ileana Ober, Jean-Michel Bruel, Axel Uhl, and Markus \nV\u00a8olter, editors, MoDELS, volume 5301 of Lecture Notes in Computer Science, pages 21 36. Springer, 2008. \nISBN 978\u00ad3-540-87874-2. [11] J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Ben\u00adjamin C. \nPierce, and Alan Schmitt. Combinators for bi-directional tree transformations: A linguistic approach \nto the view update prob\u00adlem. ACM Transactions on Programming Languages and Systems, 29 (3):17, May 2007. \nExtended abstract in Principles of Programming Languages (POPL), 2005. [12] J. Nathan Foster, Alexandre \nPilkiewicz, and Benjamin C. Pierce. Quo\u00adtient lenses. In ACM SIGPLAN International Conference on Func\u00adtional \nProgramming (ICFP), Victoria, Canada, September 2008. [13] John Nathan Foster. Bidirectional Programming \nLanguages. PhD thesis, University of Pennsylvania, December 2009. [14] R. Hasegawa. Two applications \nof analytic functors. Theoretical Computer Science, 272(1-2):113 175, 2002. [15] S. Hidaka, Z. Hu, H. \nKato, and K. Nakano. A compositional approach to bidirectional model transformation. In New Ideas and \nEmerging Re\u00adsults Track of 31st International Conference on Software Engineering (ICSE 2009, NIER Track), \n2009. [16] S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, and K. Nakano. Bidirectionalizing graph transformations. \nIn ACM SIGPLAN Inter\u00adnational Conference on Functional Programming (ICFP), Baltimore, Maryland, September \n2010. [17] Zhenjiang Hu, Shin-Cheng Mu, and Masato Takeichi. A pro\u00adgrammable editor for developing structured \ndocuments based on bi\u00addirectional transformations. In Partial Evaluation and Program Ma\u00adnipulation (PEPM), \npages 178 189, 2004. Extended version to appear in Higher Order and Symbolic Computation, 2008. [18] \nC. Barry Jay and J. Robin B. Cockett. Shapely types and shape polymorphism. In Donald Sannella, editor, \nESOP, volume 788 of Lecture Notes in Computer Science, pages 302 316. Springer, 1994. ISBN 3-540-57880-3. \n[19] A. Joyal. Foncteurs analytiques et especes de structures. Combinatoire \u00b4erative, pages 126 159, \n1986. enum\u00b4 [20] Dongxi Liu, Zhenjiang Hu, and Masato Takeichi. Bidirectional inter\u00adpretation of xquery. \nIn ACM SIGPLAN Symposium on Partial Eval\u00aduation and Semantics-based Program Manipulation (PEPM), Nice, \nFrance, pages 21 30, New York, NY, USA, 2007. [21] David Lutterkort. Augeas: A Linux con.guration API, \nFebruary 2007. Available from http://augeas.net/. [22] K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and M. \nTakeichi. Bidi\u00adrectionalization transformation based on automatic derivation of view complement functions. \nIn ACM SIGPLAN International Conference on Functional Programming (ICFP), pages 47 58. ACM Press New \nYork, NY, USA, 2007. [23] Lambert Meertens. Designing constraint maintainers for user interac\u00adtion, 1998. \nManuscript. [24] E. Meijer, M. Fokkinga, and R. Paterson. Functional programming with bananas, lenses, \nenvelopes and barbed wire. In Functional Pro\u00adgramming Languages and Computer Architecture, pages 124 \n144. Springer, 1991. [25] Shin-Cheng Mu, Zhenjiang Hu, and Masato Takeichi. An algebraic approach to \nbi-directional updating. In ASIAN Symposium on Pro\u00adgramming Languages and Systems (APLAS), pages 2 20, \nNovember 2004. [26] Perdita Stevens. Bidirectional model transformations in QVT: Seman\u00adtic issues and \nopen questions. In International Conference on Model Driven Engineering Languages and Systems (MoDELS), \nNashville, TN, volume 4735 of Lecture Notes in Computer Science, pages 1 15. Springer-Verlag, 2007. ISBN \n978-3-540-75208-0. [27] Perdita Stevens. A landscape of bidirectional model transformations. Postproceedings \nof GTTSE, 7, 2008. [28] Perdita Stevens. Towards an algebraic theory of bidirectional transfor\u00admations. \nIn Graph Transformations: 4th International Conference, Icgt 2008, Leicester, United Kingdom, September \n7-13, 2008, Pro\u00adceedings, page 1. Springer, 2008. [29] Varmo Vene. Categorical Programming with Inductive \nand Coinduc\u00adtive Types. PhD thesis, Universitatis Tartuensis, 2000. [30] Y. Xiong, H. Song, Z. Hu, and \nM. Takeichi. Supporting parallel up\u00addates with bidirectional model transformations. Theory and Practice \nof Model Transformations, pages 213 228, 2009. [31] Yingfei Xiong, Dongxi Liu, Zhenjiang Hu, Haiyan Zhao, \nMasato Takeichi, and Hong Mei. Towards automatic model synchronization from model transformations. In \nIEEE/ACM International Conference on Automated Software Engineering (ASE), Atlanta, GA, pages 164 173, \n2007.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p><i>Lenses</i>--bidirectional transformations between pairs of connected structures--have been extensively studied and are beginning to find their way into industrial practice. However, some aspects of their foundations remain poorly understood. In particular, most previous work has focused on the special case of <i>asymmetric lenses</i>, where one of the structures is taken as primary and the other is thought of as a projection, or view. A few studies have considered symmetric variants, where each structure contains information not present in the other, but these all lack the basic operation of <i>composition</i>. Moreover, while many domain-specific languages based on lenses have been designed, lenses have not been thoroughly explored from an algebraic perspective.</p> <p>We offer two contributions to the theory of lenses. First, we present a new symmetric formulation, based on <i>complements</i>, an old idea from the database literature. This formulation generalizes the familiar structure of asymmetric lenses, and it admits a good notion of composition. Second, we explore the algebraic structure of the space of symmetric lenses. We present generalizations of a number of known constructions on asymmetric lenses and settle some longstanding questions about their properties---in particular, we prove the existence of (symmetric monoidal) tensor products and sums and the <i>non</i>-existence of full categorical products or sums in the category of symmetric lenses. We then show how the methods of universal algebra can be applied to build <i>iterator lenses</i> for structured data such as lists and trees, yielding lenses for operations like mapping, filtering, and concatenation from first principles. Finally, we investigate an even more general technique for constructing mapping combinators, based on the theory of <i>containers</i>.</p>", "authors": [{"name": "Martin Hofmann", "author_profile_id": "81452607849", "affiliation": "Ludwig-Maximilians-Universit&#228;t M&#252;nchen, M&#252;nchen, PA, Germany", "person_id": "P2509633", "email_address": "hofmann@ifi.lmu.de", "orcid_id": ""}, {"name": "Benjamin Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2509634", "email_address": "bcpierce@cis.upenn.edu", "orcid_id": ""}, {"name": "Daniel Wagner", "author_profile_id": "81458652419", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2509635", "email_address": "wagnerdm@cis.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926428", "year": "2011", "article_id": "1926428", "conference": "POPL", "title": "Symmetric lenses", "url": "http://dl.acm.org/citation.cfm?id=1926428"}