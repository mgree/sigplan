{"article_publication_date": "01-26-2011", "fulltext": "\n Fresh-Register Automata NikosTzevelekos OxfordUniversityComputingLaboratory nikt@comlab.ox.ac.uk Abstract \nWhat is a basic automata-theoretic model of computation with names and fresh-name generation? We introduce \nFresh-Register Automata (FRA), a new class of automata which operate on an in.nite alphabet of names \nand use a .nite number of registers to storefresh names, andto compareincoming names withpreviously stored \nones.These .nitemachinesextendKaminski andFrancez s Finite-MemoryAutomatabybeing ableto recognisegloballyfresh \ninputs, that is, names fresh in the whole current run. We exam\u00adine the expressivity of FRA s both from \nthe aspect of accepted languages and of bisimulation equivalence. We establish primary properties and \nconnections between automata of thiskind, and an\u00adswer key decidability questions. As a demonstrating \nexample, we express the theory of the pi-calculus in FRA s and characterise bisimulation equivalence \nby an appropriate, and decidable in the .nitary case, notionin these automata. Categories and Subject \nDescriptors F.1.1[Computation by Ab\u00adstract Devices]: Models of Computation; D.3.1 [Programming Languages]: \nFormalDe.nitions andTheory Semantics GeneralTerms Theory,Languages,Veri.cation 1. Introduction One of \nthe most common and useful abstractions in programming is the assumption that entities of speci.c kinds \ncan be created at will and, moreover,in such a manner that newly created entities are always fresh distinct \nfrom any other such created thus far. This is, for example, the case with mutable reference cells, exceptions \nuser-declared datatypes, etc. in languages like Standard ML[15]. Following along traditionin computer \nscience[20], wecall these entities names and specify them asfollows. Names canbe createdfreshdynamically \nandlocally, compared for equality and communicatedbetween agents or subroutines. Apart from the uses \nmentioned above, names form the basis of calculi of mobile processes (e.g. the p-calculus [14]); appear \nin network protocols and secure transactions; and are generally es\u00adsentialinprogrammingforidentifying \nvariables, channels, threads, objects, codes, and many other sorts of name in disguise. To our knowledge, \ntherehas notbeenintheliterature aproposal of abasic automata-theoretic model of names, providing abstract \nmachines underlying alltheseparadigms.Weproposejust such a modelhere. Permission to make digital or hard \ncopies of all or part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot \nmadeordistributed forpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe \n.rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission \nand/or afee. POPL 11, January26 28,2011,Austin,Texas,USA. Copyright c &#38;#169; 2011ACM978-1-4503-0490-0/11/01. \n. .$10.00 Our model is based on the successful paradigm of Finite-Memory Automata(FMA), introduced by \nKaminski and Francez in the early90 s[11].Motivatedby real-worldproblems(where codes, addresses, identi.ers, \netc. may have unbounded domains), those automata address a demand for a natural .nite-state ma\u00adchine \nmodel over in.nite alphabets. An FMA A is an automaton attached with a .nitenumber of name-storing registers.Its \nstructure looks identical to that of an ordinary .nite-state automaton over a .nite set oflabelsgeneratedbyindicesinthe \nrange 1,...,n, where n is the number of registers. However, A truly operates on the in\u00ad.nite set of inputs \nA (thesetofnames), withindices i referring to the names storedin the i-th register of A.This simpleidealifts \nthe automatonfrom .nitetoin.nitealphabet. There are two ways in which an FMA can access its registers: \neitherby comparing aninput name to a stored one, orby storing an inputnamein one ofits registersbut onlyin \ncaseitis locallyfresh, thatis,itdoes not already appear in any of them.Thus, FMA s are history-free: \ntheir computational steps rely solely on their current registers. Here we introduce Fresh-Register Automata \n(FRA),a .nite-register automaton model which extends FMA s by global freshness recognition: an automaton \ncan now accept(and store) an input namejustin case itisfreshin the whole run. For example, a transition \ni. q -. q ' meansthatif A is atstate qand the set of names thathave appeared inits registerssofarisH,then \nA can accept anyname a/. H,store itinitsi-th register andproceed to q ' .Thishistory-sensitivefeature \nprecisely captures fresh-name creation.1 Thus, e.g. the following language(notrecognisedbyFMA s[11])is \nrecognisedby a single\u00adstateFRA with one register. L1 = { a1 \u00b7\u00b7\u00b7 ak . A * |.i= j.ai aj } = An intuitive \nway to view L1 is as the trace of a fresh-name gen\u00aderator: one which returns reference cells in SML, \nobjects in Java, memory addresses inC, etc. Research in FMA s and their formal languages has been ex\u00adtensive \n[2, 6, 11, 21, 25, 27]. It has been shown [11, 21] that FMA-recognisable languages are closed under union, \nintersection, concatenation and Kleene star; they are not closed under comple\u00adment; emptiness of FMA \ns is decidable; and universality is unde\u00adcidable. Our .rst contribution is to answer this series of questions \nfor FRA s. We show that for emptiness and universality the situ\u00adation remains the same as in FMA s. On \nthe other hand, FRA\u00adrecognisable languages are still closed under union and intersec\u00adtion, but history-sensitiveness \nprohibits this for concatenation and Kleenestar.Moreover,they arenotclosed undercomplement and, infact, \nthereis anFMA-recognisablelanguage whose complement is not recognised byFRA s. 1Note that, although history-sensitive, \nthe automaton does not have full access to the history H.In automata-theoreticjargon,the situation canbe \ndescribed asconsulting anoraclewhocandecidethefreshnessof names. Our main vehicle for studying equivalence \nbetween FRA s is bisimulation equivalence (also called bisimilarity). The notion is very relevantfromthepointof \nviewofprogramming, andprocess calculi in particular, and in the case of FRA s it implies language equivalence.Moreimportantly,weshowthatby \nexamining FRA s at the symbolic level, i.e. as ordinary .nite-state automata on the set of index-generated \nlabels, it is possible to capture bisimilar\u00adity by an appropriate symbolic notion; we thus prove that \nFRA\u00adbisimilarity isdecidable. A symbolic bisimulation relates states of two automata in speci.c environments, \nthe latter specifying how are the names which appearin their registers related. As a demonstrating example, \nwe express the p-calculus in the context of fresh-register automata. We introduce the xp-calculus system: \na presentation of the p-calculus with early transition se\u00admantics[14,26],inwhichprocesses arestatesof \nanin.niteFRA. TransitionsaregivenbyFRA-transitionsand thesystemis .nitely branching.More speci.cally,bound \noutputs are modelledbyglob\u00adally fresh transitions, while each input is decomposed into .nitely many cases: \neither theincoming nameislocallyfresh orit already appears in the registers. This clean treatment of \nfresh and bound names is the main advantage of the xp-calculus and allows for the .niterepresentation,asordinaryFRA \ns,of .nitaryprocesses.2 Moreover, we characterise strong bisimilarity by an appropriate symbolic notion \nin xp. This gives an alternative proof of decid\u00adability ofbisimilarityfor .nitaryprocesses. Motivation \nand related work Programming languages The idea of studying names in higher\u00adorderlanguages andinisolation \nof othereffects was .rstpursuedby Pitts and Stark[24]. They introduced the .-calculus, an extension of \nthe simply-typed .-calculus with references of unit type. Inves\u00adtigations on the .-calculus were meticulously \ncarried on by Stark inhisPhDthesis[28],whichexposed aratherunexpected com\u00adplexityhidden behind names. \nItbecame evident thatbetter models forlanguages with names were needed.To address this, newdirec\u00adtionsindenotational[1,12,13,18] \nand operational[3,10] models were explored, signi.cantly advancing our understanding of com\u00adputation \nwith namesbut,atthesametime,leavingbasicquestions unanswered. In particular, those works examined computation \nat the higher level, that of programs and program equivalence, leav\u00ading open thequestion of abasic,lower-level \nmodel. Interestingly,intheirinitialpaper onFMA s[11],Kaminski and Francez motivatetheirconstruction(also)by \nbrie.ypresenting an idealised procedural language with names. There, names cannot be freshly created, \nbut they can be read from the environment as inputs and stored in a .nite memory. Moreover, stored names \ncan .ow inside the memory from one register to another and can alsobe compared for equality and thus \ntrigger goto s.The authors explainthatFMA soperatelike acceptorsforthatsimpleimperative language with \nnames.By analogy,FRA sdescribe the extension of thelanguage withfresh-namegeneration. Process calculi \nFor mobile systems like the p-calculus [14], where processes can create locally, receive or send names, \nthe use of ordinary labelled transition systems for its semantics is in many ways unsatisfactory: for \nexample, in.nite branching arises eveninthecase of very simpleprocessesthatreceive a(locally fresh) name, \nor output alocally created(globallyfresh) one.Such shortcomings naturally led to solutions involving \nrepresentations of processes by formalisms which incorporate name-reasoning of some sort[4,5,16].The \nmost notableparadigminthisdirection is that of History-Dependent Automata (HD-Automata) [16, 22], which \nare structuresde.nedin a universe of named sets and named functions.HD-automata can succinctly represent \nthe p-calculus, as 2Aprocessis .nitary ifitsitdoes notgrow unboundedly inparallelism. HD-transitions \nmatch on-the-.y names between the source, tar\u00adget, andlabelof p-calculus transitions, allowing thusforthe \nuse of representatives ofprocesses and transitions, ratherthan allpossible ones under e.g.permutation \noffresh names.The stream of research onHD-automatahasfocussedboth onfoundational issues[17,22] and onpragmatic \napplications[7].The workpresentedhere shares objectives with HD-automata, and to some extent can be viewed \nas a complementary attempt to the same question, albeit based on basicmachinesof .rstprinciples . Outline \nInthe nextsection wegivethebasicde.nitions onFRA s.Section3 provides some useful bisimilar constructions. \nIn Section 4 we re\u00adcall FMA s and establish their connection to FRA s. We examine WFRA s,aweakernotion \nofFRA sfocussing onglobalfreshness, in Section 5. In Section 6 we prove some technical results regard\u00ading \nclosure properties for FRA s, and in Section 7 we show that emptiness and bisimilarity are decidable \nusing symbolic methods. Section8 examines the p-calculusin the setting ofFRA s.  2. De.nitions Wedistinguishbetween \ntwo sets ofinput symbols: anin.nite set of names, A, and  a .nite set of constants, C.  Constantshave \nan auxiliary role and are non-storable.3 Welet a,b, etc. range over names. We write A * for the set of \n.nite strings of names, and A. for its restriction to those containing pairwise distinct names. Strings \na1 \u00b7\u00b7\u00b7 an will be typically represented by vectors ia,in which case img(ia)= {a1,...,an}. For each n \n. ., we write [n]for the set{1,...,n}, andlet Ln = C .{ i,i ,i. | i . [n]} . be the set oflabelsgeneratedby \n[n].Moreover, wede.ne Regn = { s :[n]. A.{.}|.i = j.s(i)= s(j)=. s(i)= .} tobe the set of register assignments \nof size n.We write img(s)for the name-range of s,i.e. img(s)= { a . A |.i.s(i)= a }, and letdom(s)= { \ni . [n]| s(i). A }.Whenever a/. img(s), s[i . a]= { (i,a)}.{ (j,s(j))| j. [n]\\{i}} is an update of s,for \nany i . [n]. De.nition1. A fresh-register automaton(FRA) of n registersis aquintuple A = (Q,q0,s0,d,F) \nwhere: Q is a .nite set of states,  q0 is theinitial state,  s0 . Regn is theinitialregister assignment, \n d . Q\u00d7 Ln \u00d7 Q is the transition relation,  F . Q is the set of .nal states.  A is called a register \nautomaton(RA) if there are no q,q ' ,i such that (q,i. ,q ' ). d. Transitions containing labels of the \nform i are called known transitions; those of the form i are locally fresh ones; and glob\u00adally fresh \ntransitions involve i. . Thus, an RA is an FRA with no globallyfreshtransitions.4 Here is an informal \nreading of d.Suppose A is at state q1 with current register assignment s.Ifinput l . C . A arrives then:5 \n3In other presentations [11, 21] there is no such distinction, but symbols that appearintheinitial register \nassignment canplay theroleof constants. 4Thisyieldsthesamenotionof register automaton asthat of[21]. \n5Note that the same symbol, l,islater used to range over elements of Ln.  Ifl . C and (q1,l,q2). d then \nA accepts land moves to q2.  If l . A and (q1,i,q2). d and s(i)= lthen A accepts land moves to q2. \n If l . A and (q1,i ,q2) . d and l is not stored in s then A accepts l,it sets s(i)= land moves to q2. \n If l . A and (q1,i. ,q2) . d and l/. img(s0)and l has not appeared in the current run then A accepts \nl, it sets s(i)= l and moves to q2.  The above is formally de.ned by means of con.gurations repre\u00adsenting \nthe intended current state of the automaton, which apart from states containsinformation on the current \nregister assignment and the set of nameshaving appeared thusfar(the history). The latter component is \nnecessary forgloballyfresh transitions. De.nition2. Acon.guration ofA is a triple(q,s,H). Q , with Q= \nQ\u00d7 Regn \u00d7Pfn(A) and Pfn (A)being the set of .nite subsets of A. From d de.ne a transition relation on \ncon.gurations -.d . Q \u00d7 (C . A)\u00d7 Q asfollows.For all(q,s,H). Q and (q,l,q ' ). d: l Ifl . C then (q,s,H)-.d \n(q ' ,s,H). a Ifl = iand s(i)= a then (q,s,H)-.d (q ' ,s,H .{a}). i '' a If l = and a ./img(s)then (q,s,H) \n-.d (q ,s ' ,H ) withs ' = s[i . a]and H ' = H .{a}. i. a'' Ifl = anda/. H.img(s0)then (q,s,H)-.d (q \n,s ' ,H ) withs ' = s[i . a]and H ' = H .{a}. We write - . d for the re.exive transitive closure of -.d. \nl We say that con.guration q is reachable if (q0,s0,\u00d8) - . d q for some il . (A . C) * . We call A a \nclosed FRA if, for all reachable con.gurations (q,s,H)and all (q,i,q ' ) . d, we have that s(i)= ..Finally, \nthe set of strings accepted byA is: l L(A)= { il . (A . C) * | (q0,s0,\u00d8)- . d (q,s,H). q . F } and is \ncalled the language recognised by A. Two automata are equivalent if theyrecognise the samelanguage. Remark3. \nThereis an equivalentde.nition ofFRA sin whichhis\u00adtories include img(s0)by default, and in which reachable \ncon.g\u00adurations are the ones reachedfrom (q0,s0,img(s0)).Hereinstead we have decided to separate the history \nof the run from its initial names, which appears togive a cleanerpresentationbutitisby no means a substantial \npoint of difference. Note also that reachable con.gurations contain namesthathave appearedbefore one \nwayor another:if(q,s,H)is reachable then img(s). img(s0). H. A. Example4. The reader can checkthatthelanguage \nL1 (= )of theIntroductionis recognisedbythefollowingFRA. A0 = ({q0},q0,{(1,.)},{(q0,1. ,q0)},{q0}) Note \nthat the FRA B = ({q0},q0,{(1,.)},{(q0,1 ,q0)},{q0}) recognises thelanguage: L2 = { a1 \u00b7\u00b7\u00b7 ak . A * | \nk . ...i.ai = ai+1 } andis therefore not equivalent to A. A more elaborate exampleis thefollowing.Let \nA be theFRA: 1/1 1 1 1. 11 with initial assignment {(1,.)}. The automaton works as follows. It receives \na name a and then keeps receiving a until some b = a arrives; then it keeps receiving b until a globally \nfresh c arrives; it then repeatsfrom start.Thus, members of L(A)are of theform j0 k0 j1 k1 j2 k2 jn kn \nabc0 abc1 abc2 ...an bn cn 00 11 22 where,for all i, wehave ji,ki > 0, ai = bi and ci differsfrom all \nsymbolsprecedingit.Formally, setting L ' n1 bn2 (H)= { ac | ni > 0. a = b. c/. H .{a,b}} S we have that \nL(A)= i.. Li , where we set L0 = L ' (\u00d8)and Li+1 = {iaib| ia .Li . ib .L ' (img(ia))} . Somebasic results \nThelanguages ofFMA s[11]are regular once constrained toa .nitenumberof symbols.Moreover,thelanguage accepted \nby an FMA is impervious to name-permutations that do not affect its initial register. These properties \ncarry over to FRA s, and areproved asin[11]. Proposition5. LetA = (Q,q0,s0,d,F) be anFRAofn registers \nand S . A be .nite.Then, L(A)n S * is a regular language. ~ = Proposition 6. For A as above, if ia .L(A)and \np : A . A is such that p(a)= a for all a . img(s0)then p(ia).L(A). Bisimulation Bisimulation equivalence \nturns out to be a great toolfor relatingautomata, evenfromdifferentparadigms.Itimplies language equivalence \nand, in all our cases of interest, it is not too strictin this aspect.We chooseithere as our main vehicle \nof study. De.nition 7. Let Ai = (Qi,q0i,s0i,di,Fi) be FRA s with ni  registers, for i =1,2. A relation \nR . Q1 \u00d7 Q2 is called a simulation on A1 and A2 if,for all( q1,q 2). R, ifp1( q1). F1 then p1( q2). F2, \nll ' ''' ifq 1 -.d1 q 1 then q 2 -.d2 q 2 for some ( q1,q 2). R. R is called a bisimulation if both \nR and R-1 are simulations. We say that A1 and A2 are bisimilar, written A1 ~A2, if there is a bisimulation \nRsuch that ((q01,s01,\u00d8),(q02,s02,\u00d8)). R. Lemma8. If A1 ~A2 then L(A1)= L(A2). The aboveisprovedusingstandardmethods.Bisimilarityisalso \ncalledbisimulation equivalence.Forinstance,the automaton A0 of example4isbisimilar to B = ({q0,q1},q0,{(1,.)},{(q0,1 \n,q1),(q1,1. ,q1)},{q0,q1}) , withabisimulation witnessingthisbeing thefollowing, {((q0,s0,\u00d8),(q0,s0,\u00d8))}.{((q0,s1,H1),(q1,s2,H2))| \nH1 = H2)} where s0 = {(1,.)}. 3. Bisimilar constructions In this section wedemonstrate somebisimilar \nconstructions which willbe useful in the sequel. Starting from a fresh-register automa\u00adton A = (Q,q0,s0,d,F) \nof n registers, we effectively construct thefollowingbisimilar automata. The closedFRAA, called the \nclosure of A.  For anyia . A. with img(s0)n img(ia)= \u00d8, theFRA A. ia. Thisis calledtheextension ofA \nbyia, anditsinitialassignment is s0 +ia = s0 .{ (i+n,ai)| 1 = i =|ia|}.   Ourpresentation willfocus \non constructing thebisimilar automata and explaining the candidate bisimulation relation R, omitting \nthe actualproofthatRis abisimulation,astheseproofs are notdif.cult (but tedious)andfollowdirectlyfrom \nthe constructions. Closures ForA as above with n registers wede.neits closure to (Q '' be the n-register \nFRA A = ,q 0,s 0' ,d ' ,F ' ) given as follows. We set Q ' = Q\u00d7P([n]), q0 ' =(q0,dom(s0)), s0 ' = s0 \nand F ' = { (q,S)| q . F }.Recall we want to construct an automaton which is closed, that is, whenever \na con.guration with state q and assignment s is reached and (q,i,q ' )is atransition, thens(i). A and \ntherefore the transitionis allowed.The extra component added in Qmonitorsthe registersthathavebeen assigned \na name(note that once a registerhasbeen assigned a nameit cannot returntothe .state).Consequently, d \n' willbedesignedin such a way sothatthis monitoring carries through and, moreover, the known transitions \nincludedin d ' are always allowed: ' '' d = { ((q,S),l,(q ,S))| (q,l,q ). d. l . C)} .{ ((q,S),i,(q ' \n,S))| (q,i,q ' ). d . i . S)} '' ' ' .{ ((q,S),i/i. ,(q ,S ))| (q,i/i. ,q ). d. S = S .{i}} Now, we can \ncheck that thefollowing relationis abisimulation R = { ((q,s,H),((q,S),s,H))| dom(s)= S} and therefore \nthat A~ A.Moreover, the reachable con.gurations of A are of the form ((q,S),s,H)with dom(s)= S, and there\u00adfore \nthe automatonis closed. Remark 9. If A = (Q,q0,s0,d,F) is a closed FRA then each l1l2lm path q0 -. q1 \n-. \u00b7\u00b7\u00b7 -. qm in A (where arrow notation represents d)yieldsis a con.gurationpath l ' l ' l ' 12m (q0,s0,\u00d8)-.d \n(q1,s1,H1)-.d \u00b7\u00b7\u00b7 -.d (qm,sm,Hm) according to thede.nition of -.d.For example, if lj+1 = i then l ' j+1 \n= sj(i), sj+1 = sj and Hj+1 = Hj.{sj(i)}.In this case, closedness of A guarantees thatsj(i)= .. Name \nextension For A as above with n registers and ia . A. a sequence oflength m such that img(s0)n img(ia)= \n\u00d8, wede.ne the extension A.ia astheFRA with n+m registers anddescription (Q ' ,q 0' ,s 0' ,d ' ,F ' ) \ngiven asfollows.We set Q ' = Q\u00d7 ([n]. [n + m])\u00d7P({n +1,...,n + m}) and q0 ' =(q0,.,{n+1,...,n+m}), with \n.theinclusionfunction, F ' = { (q,f,S). Q ' | q . F } and s0 ' = s0 +ia.Finally: '' ' d = { ((q,f,S),f(l),(q \n,f,S))| l . C . (q,l,q ). d} '' ' ' .{ ((q,f,S),j,(q ,f ,S ))| (q,i,q ). d . j/. img(f)} ''' ' .{ ((q,f,S),j,(q \n,f ,S ))| (q,i. ,q ). d . j. S} where f(i )= f(i) , f(i. )= f(i). , f(l)= l for l . C, f ' = f[i . j]and \nS ' = S \\{j}. The transition relation in A. ia proceeds as in A with the ex\u00adception oflocally/globallyfresh \ntransitions, where some extra care is needed. Since the registers of the new automaton contain more names \nthan those of the initial one, fresh transitions in A. ia can now capture fewer names. For example, if \na is one of the added namesthen an i transitionfromtheinitialcon.guration could cap\u00adture it before, but \nthis is no more the case as a appears in s0' ; in\u00adstead, we need an explicit jtransitionforthispurpose.Thisis \nwhat the second clause of thede.nition of d ' addresses.For this to work we need to introduce the component \nf to keep track of the corre\u00adspondencesbetween old and new registersthat arisein the wayjust described. \nFor globally fresh transitions a similar situation arises, only that this time we need only remember \nwhich of the names in theinitialia have notappearedinthehistory thusfar, whichis what the component S \nachieves.Thus, thefollowingis abisimulation '' ' R = { ((q,s,H),((q,f,S),s ,H))| s = s .f.img(ia). H.s(S)} \nand therefore A~A. ia.  4. Finite-memory automata We now present FMA s and examine their properties \nin relation to FRA s and RA s. In fact, RA s are equivalent to FMA s and in theliteraturetheyhavebeen \nused assynonyms(e.g.compare[11] with[21]).Theprecise correspondence is statedinproposition 11, whichis \nafolklore result. Let us recall the originalde.nitionfrom[11].A .nite-memory automaton(FMA) of n registersisa \nsextuple A = (Q,q0,s0,.,d,F) where: Qis a .nite setof states, with q0 . Qinitial, and F . Q.nal.  s0 \n. Regn is theinitialregister assignment.  . : Q.[n] is the reassignment (partial)function.  d . Q\u00d7 \n[n]\u00d7 Q is the transition relation.  Theintuitive reading of d is thefollowing.Suppose A is atstate \nq1 with register assignment s and let (q1,i,q2) . d. If input a . A arrives then:  Ifs(i)= a then A \naccepts a and moves to state q2.  Ifa/. img(s)and .(q1)= ithen A accepts a,it sets s(i)= a and moves \nto state q2.  Formally, a con.gurationis now apair (q,s). Q , where Q= Q\u00d7 Regn , andthetransition \nrelation -.d . Q \u00d7A \u00d7Q isde.nedasfollows. For all (q,s). Q and (q,i,q ' ). d: a Ifs(i)= a then (q,s)-.d \n(q ' ,s). a If.(q)= ithen,for alla/. img(s), (q,s)-.d (q ' ,s[i . a]). The notions of reachable con.gurations \nand accepted strings and languages arede.nedjustasin the case ofFRA s. Example10. Recallthelanguage \nL2 of example4: L2 = { a1 \u00b7\u00b7\u00b7 ak . A * |.i.ai = ai+1 } whichisRA-recognisable. L2 is recognisedby theFMA: \nB = (Q,q0,s0,{(q0,1),(q1,2)},{(q0,1,q1),(q1,2,q0)},Q) where Q = {q0,q1} and s0 = {(1,.),(2,.)}. Comparing \nthis to B of example4,thereader can observehowthedifferencesbetween RA sandFMA sinreassignmenthavebeen \naddressedhereby use of the extra register. The main properties of FMA s and FMA-recognisable lan\u00adguageshavebeen \nestablished asfollows. (a). EmptinessisdecidableforFMA s[11](i.e.is L(A)= \u00d8 ?),and inparticularitisNP-complete[25]. \n(b). The languages accepted by FMA s are closed under union, intersection, concatenation andKleene star;they \nare not closed under complement[11]. A * (c). Universality is undecidable[21](i.e.is L(A)= ?). Hence, \nthe equivalence and containmentproblems are undecidable too (i.e.isL(A)= /.L(B)?). We shall see that \nthe emptiness problem is also decidable for FRA s(proposition 24).Clearly,FRA sbeing extensions ofFMA \ns impliesthatuniversality oftheformeris undecidable, andhencethe same holds for equivalence and containment. \nIn section 6 we will examine closure properties of FRA s and show that closure under concatenation and \nKleene star are lost, closure under complement stillfails,but closure under union andintersectionprevail. \nWe now relate FMA s to the kind of automata we have intro\u00ad duced previously: in essence, FMA s are the \nsame as RA s. The notions of simulation and bisimulation straightforwardly extend to FMA s.Infact,de.nition7 \nappliesto all machines operating onthe in.nite alphabetC . A whichhave con.gurationgraphs containing \ninitial and .nal con.gurations. It therefore makes sense to extend these notions toRA-FMApairs(andFRA-WFRApairslater \non). Proposition 11. For any FMA A of n registers there is an effec\u00adtively constructibleRA B of n registers \nsuch that A~B. Conversely, for any RA B of n registers there is an effectively con\u00adstructibleFMA A of \nn +1 registers such that A~B. Proof. GoingfromFMA s toFRA sis simple: we use the same set of states; \nwe match each transition (q1,i,q2)with (q1,i,q2); and, additionally,for each transition (q1,i,q2)where \n.(q1)= iwe add (q1,i ,q2). The other direction is more elaborate but apparently the constructionis alreadyknown[21], \nso we omitit. Corollary 12. The universality, equivalence and containment problems are undecidable forRA \ns and FRA s.  5. Weakfresh-registerautomata In this section we examine a weaker version of FRA s by \nconcen\u00adtrating on the aspect ofglobalfreshness while relaxing that oflocal freshness.Even though this \nrestrictionleads us to machines thatdo not extend FMA s, we show that universality remains undecidable \n(proposition17). The machines weintroduce operate on sets oflabels Lw n = C .{ i,i?,i. | i . [n]} , where \ni?standsfor accept any name transitions.Moreover,their registers are now takenfrom the sets Regw =[n]. \nA .{.}. n De.nition 13. A weak fresh-register automaton (WFRA) of n registersis aquintuple A = (Q,q0,s0,d,F) \nwhere: Qis a .nite set of states, with q0 . Qinitial, and F . Q.nal.  s0 . Regw is theinitialregister \nassignment.  n d . Q\u00d7 Lw \u00d7 Q is the transition relation. n Thetransitionrelationhasthesameintuitivemeaning \nasinthe case of FRA s, with the exception that in transitions of the form (q1,i?,q2) . d the automaton \naccepts any name a, stores it at its i-th cell and moves to state q2. Formally, a con.guration is now \ngiven as a triple(q,s,H). Q , where Q= Q\u00d7 ([n]. (A . .))\u00d7Pfn (A), and the transition relation -.d. Q \n\u00d7 (C . A)\u00d7 Q on con.gura\u00adtionsisde.ned asfollows.For all (q,s,H). Q and (q,l,q ' ). d: l ifl . C then \n(q,s,H)-.d (q ' ,s,H); a ifl = iand s(i)= a then (q,s,H)-.d (q ' ,s,H ' ); a ifl = i? then (q,s,H)-.d \n(q ' ,s ' ,H ' ); a ifl = i. and a/. H.img(s0)then (q,s,H)-.d (q ' ,s ' ,H ' ); with s ' = s[i . a]and \nH ' = H.{a}.Reachable con.gurations and accepted strings/languages arede.ned exactly asinFRA s. Example14. \nConsider thefollowinglanguage, L3 = { a1 \u00b7\u00b7\u00b7 ak b1 \u00b7\u00b7\u00b7 bl . A * |.i = j.ai = aj . bi = bj } whichisinfactthe \nconcatenation of A. withitself,andtheWFRA: with2 registers,both oftheminitially empty.Callthe above A.We \nclaimthat L(A)= A * \\L3,thatis, s .L(A) .. s/.L3 for all s . A * .The forward implication is clear: if \ns .L(A)then either the same name a appears three times in s (via the pathq0q1q2q4), or names a1 and a2 \nappear eachtwicein s withoutinterleaving(via thepath q0q1q2q3q4).Inbothcases, s/.L ' . For the opposite \ndirection, let s ./L3 and feed it to A. Since s/. A. , we can write s = s1a1s2a1s ' with s1a1s2 . A. \n. In A,  ' . A. s1a1s2a1 leads controltoq2.Now, s/.L3 impliesthata1s/ ' ' ''' ' sothereis some a2 \nina1s suchthat a1s = a1s1a2s , a1s1 . A. and a2 appears in a1s1' . If a2 = a1 then s1' a2 leads A directly \nto q4.Otherwise,itleads to q4 via q3. The reader may want to verify that changing thelabels of theloops \nat q0 and q1 above to 1. , and the label from q0 to q1 to 2. , leads to aWFRA A ' that still satis.es \nL(A ' )= A * \\L3. We show that any WFRA has a bisimilar FRA of the same number of registers.Theideais \nto simulate the non-linear memory (i.e. a set ofregisters that may contain names in common) of the WFRAby \nalinear memoryplus a reordering function on theFRA part.For example,hereis sucha simulation: ( { (1,a),(2,b),(3,c)}{ \n(1,a),(2,b),(3,b)} -. plus(1. 1, 2 . 2, 3 . 2) The reordering functions willbe attached to the states \nof theFRA. Moreover, we shall simulate any-transitions(i.e. of theform i?)of theWFRAby means oflocally-fresh-transitions(i \n)and known\u00adtransitions (j, for all j). In the end, de.ning the new transition relationgetsabitinvolved \nasonehastobearreorderingsinmind, which need to be accounted for before making a transition and updated \nafterwards. Lemma15. For anyWFRA A of n registers thereis an effectively constructible FRA B of n registers \nsuch that A~B. Proof. LetA = (Q,q0,s0,d,F);constructB = (Q ' ,q 0' ,s 0' ,d ' ,F ' ) asfollows.We set \nQ ' = Q\u00d7 ([n]. [n])and write elements of Q ' as (q,f).Simulation of non-linear memory s bylinear memory \ns ' and reordering f is de.ned in the obvious manner: s = . f. s ' Moreover, for each i . [n], the multiplicity \nof s(i), i.e. the num\u00adber of times it appears in s,isgivenby the sizeof f-1(f(i)); we denote thisby \u00b5(i).Welet \n(s0' ,f0)be a simulation ofs0 such that s '' 0 contains no more names than s0, and set q0 =(q0,f0)and \nF ' = {(q,f)| q . F}.We nowde.ne d ' : ' '' d = { ((q,f),l,(q ,f))| (q,l,q ). d . l . C } .{ ((q,f),f(i),(q \n' ,f))| (q,i,q ' ). d} .{ ((q,f),f(i). ,(q ' ,f))| (q,i. ,q ' ). d . \u00b5(i)=1} '' ' .{ ((q,f),j. ,(q ,f \n))| (q,i. ,q ). d . \u00b5(i)>1. j/. img(f)} ' ' .{ ((q,f),f(i),(q ,f))| (q,i?,q ). d . \u00b5(i)=1} '' ' .{ ((q,f),j,(q \n,f ))| (q,i?,q ). d . \u00b5(i)> 1. j/. img(f)} '' ' .{ ((q,f),j,(q ,f ))| (q,i?,q ). d} where f ' = f[i \n. j]. The .rst line is straightforward. The secondline says that receiving the name of the i-th registerin \nA is simulated by receiving the f(i)-th name in B. The same rationale is repeatedin the thirdline, only \nthat now wehave todo a memory update and therefore we need to be careful with reorderings. In particular, \nstoring the new name, say a, in the f(i)-th register should notbe allowed when \u00b5(i)> 1:if thisis the \ncase and we set s ' (f(i))= a then a still appears in s but nolonger appears in s ' , breaking thus the \nsimulation. Nonetheless, if \u00b5(i) > 1 then there must be some j which is free in s ' (i.e.j/. img(f))and \nwe can safely storethe new nameinthere, updatingthe reorderingfunction accordingly. The last three lines \nof d ' implement the idea that receiving any name can be matched by receiving either a locally fresh \nname or one of the stored ones.Thus, R = { ((q,s,H),((q,f),s ' ,H))| s = s ' . f } is abisimulation \nand therefore A~B. We next show that the absence of locally fresh transitions in WFRA s renders themincapable \nof recognisingFMA-recognisable languages. Combining this with the previous result we obtain that WFRA \ns areindeed strictly weaker thanFRA s. Lemma 16. The language L2 = {a1 \u00b7\u00b7\u00b7 ak |.i.ai=ai+1} of ex\u00adamples4 \nand 10 is notWFRA-recognisable. Proof. Suppose L2 = L(A), for a WFRA A with n registers. Then, for any \ns . A. of length m> 1, we have ss .L(A). Let thefollowingbe the transitionpathin A acceptingit, ......' \na1' a2am' q0 -. \u00b7\u00b7\u00b7 -. q0 -. q1 -. \u00b7\u00b7\u00b7 -. qm '' with the subpath from q0 to qm accepting the second copy \nof s. Then, none of the a s can be of the form i. as their names have appeared before.Moreover, if ai \n= j? then ai can also accept the preceding symbol, contradicting the fact that L(A)= L2. Hence, all a \ns arein [n].Choosing m> n we arriveto a contradiction. EmptinessisdecidableforWFRA s,byinheritance.Moreinter\u00adestingly, \nthe universality problem remains undecidable, and hence the samehappens for equivalence and containment. \nProposition17. Universalityis undecidable forWFRA s. Proof. The proof is by reduction from the Post Correspondence \nProblem, andfollowsthetrack of the analogousproofin[21].In particular, we show that the locally fresh \ntransitions of the RA s constructed in that proof can be replaced by WFRA-transitions. Unlike[21],hereitis \nnecessary to use the set C.  6. Closureproperties In order to establish closureproperties ofFRA s, andfollowing \nthe approach onFMA sin[11],itis usefultointroduce a version of FRA s with multiple assignment, that is, \nautomata that can store aninput name at several of their registers at one step.Inparticular, assignments \nwillnowbetakenfromthe sets Regw .The set oflabels n we shall useis thefollowing. L ' = C . (P([n])\u00d7P([n])\u00d7 \n({.} . P([n]))) n Labels of the form (S,T,.)are written simply (S,T), and when we write (S,T,A)we assume \nA = ..If we want to allowfor ., we write (S,T,A.). De.nition 18. An MFRA of n registers is a quintuple \nA = (Q,q0,s0,d,F) where: Qis a .nite setof states, q0 . Qisinitialand F . Qare .nal.  s0 . Regw is \ntheinitialregister assignment.  n d . Q\u00d7 L ' \u00d7 Q is the transition relation. n The intuitive reading \nof d is the following. If A is at state q1 with register assignment s andinput l . C . A arrives then: \n ifl . C and (q1,l,q2). d then A accepts land moves to q2.  if l . A and (q1,(S,T),q2). d and (s[S . \nl])-1(l)= T,  i.e. l appears exactly in the registers in T after it is assigned to all registers in \nS, then A accepts l, it sets s(S)= {l} and moves to state q2. if l . A and (q1,(S,T,A),q2) . d, (s[S \n. l])-1(l)= T and lhas notappearedinthehistory nordoesit appearin s0(A) then A accepts l,it sets s(S)= \n{l} and moves to state q2.  Thus, labels of the form (S,T) work in the same way as in M-automata [11], \nand the main novelty here is the inclusion of (S,T,A):in order for the transition to be allowed, the \ninput name a must befreshin the history and in thepart of s0 speci.edby A. This addition allows us to \nmodelgloballyfreshtransitions and also to combine automata unifying theirinitial assignments. Formally, \nlet Q = Q \u00d7 Regw \u00d7Pfn (A) be the set of con\u00ad n  .gurations and de.ne -.d. Q \u00d7 (C . A) \u00d7 Q as follows. \nFor all (q,s,H). Q : l If(q,l,q ' ). d with l . C then (q,s,H)-.d (q ' ,s,H).  If (q,(S,T),q ' ). d, \ns ' = s[S . a]and s'-1(a)= T then  a (q,s,H)-.d (q ' ,s ' ,H .{a}). ' . d, s ' s[S . a], s'-1 If (q,(S,T,A),q \n) =(a)= T and a a/. H . s0(A)then (q,s,H)-.d (q ' ,s ' ,H .{a}). Reachabilityand acceptance arede.ned \nasbefore.Notethatplausi\u00adbletransitionlabels(S,T,A.)satisfy S . T.Moreover,if S = T and A. = . then the \ntransition can onlybeinstantiatedby a name a . s0([n]\\ A)thathas notyet appeared in thehistorybutis still \nin some register. Lemma 19. For any FRA A of n registers there is an effectively constructible MFRA B \nof n +1 registers such that A~B Theotherdirectionisabitmoreelaborate and weachieveitin two steps.Let \nus say that anMFRA A is pure if,for all transitions (q,(S,T,A),q ' )of A, S = T and A =[n]. Lemma20. \nFor anyMFRA A of n registers thereis an effectively constructiblepure MFRA B of 2n registers such that \nA~B. Lemma 21. For any pure MFRA A of n registers there is an effectively constructible FRA B of n registers \nsuch that A~B. We can now establish thefollowing closureproperties.Closure under union and intersection \nis answered positively, while closure under concatenation,Kleene star or complementfails. Proposition22. \nForFRA sA and B, thelanguages L(A).L(B) and L(A)nL(B)areFRA-recognisable. Proof. Assume MFRA s A ' = \n(Q1,q01,s01,d1,F1)~A and B ' = (Q2,q02,s02,d2,F2)~B of n,m registers respectively. For the union, construct \nanMFRA C = (Q,q0,s0,d,F) of n +m registers, where Q= {q0}.Q1.Q2 ,s0 = s01+s02 ,F = F1.F2.f(F1.F2) with \nf : Q1 . Q2 . Q mapping q01 and q02 to q0, and being elsewhere theidentity.Finally: '' ' ' d = { (q \n,l,q )| l . C . (q,l,q ). d1 . d2 } '' '' .{ (q,(S . [m]+n,T . [m]+n,A.),q )| (q,(S,T,A.),q ). d1} '' \n'' .{ (q,([n]. S+n ,[n]. T+n,A+n),q )| (q,(S,T,A.),q ). d2} . where q '' .{q,f(q)} and S+n = { i + n \n| i . S}, for each S . ., and .+n = ..Itfollows that L(C)= L(A).L(B). For the intersection, construct \nan MFRA C = (Q,q0,s0,d,F) of n + m registers where Q = Q1 \u00d7 Q2, q0 =(q01,q02), s0 = s01 +s02, F = F1 \n\u00d7 F2 and, assuming .. A. = A.: d = { (q,l,q ' )| l . C ..i . [2]. (pi(q),l,pi(q ' )). di } .{ (q,(S1 \n. S+n,T1 . T+n,A.1 . A+n),q ' )| 22 .2 .i . [2]. (pi(q),(Si,Ti,A.i),pi(q ' )). di }  Itfollows that \nL(C)= L(A)nL(B). Proposition23. There are FRA s A and B such that thelanguage L(A)*L(B)is not FRA-recognisable. \nMoreover, there is an FRA A such that thelanguage L(A) * is notFRA-recognisable.Finally, there is an \nRA B such that the language A * \\L(B)is not FRA\u00adrecognisable. Proof. Forthe .rstpartweshowthatthelanguage \nL ' = L1 *L1 is not FRA-recognisable, where L1 = A. . Suppose L ' were recognisedby anFRA C of n registers, \nso ss .L(C)with s beinga string of m distinct names.Let thefollowingbe the transitionpath in C acceptingit, \n......' a1' a2am' q0 -. \u00b7\u00b7\u00b7 -. q0 -. q1 -. \u00b7\u00b7\u00b7 -. qm '' with the subpath from q0 to qm, call it p, accepting \nthe second copy of s. As all the symbols of s have already appeared before, none of the a s is of the \nform i. . Moreover, as all the symbols in s are distinct, there cannot be i . [n] and j <j ' such that \naj .{i,i } and aj' = i, as aj' would then repeat a name already present in the subpath p.Moreover, there \ncannot be i,i ' . [n]and i ' j <j ' <j '' such that aj .{i,i }, aj' = i and aj'' = . For suppose this \nwere the case, and suppose that all a s between j and j ' are not in {i,i }, and that all a s between \nj ' and j '' are not in {i ' | i ' . [n]}. Then, s = s1a1s2a2s3a3s4 with a1,a2,a3 corresponding to aj,aj' \n,aj'' respectively. But i ' is also allowed to accept a1,hencethereis s4 ' suchthat ss1a1s2a2s3a1s4 ' \n.L(C), contradicting L(C)= .But now taking m>n +1 we obtain a L ' contradiction. The second part is shown \nin a similar manner, taking as A the automaton accepting thelanguage L2,a0 = { a0a1 ...ak . A * |.i = \nj.ai = aj } for some chosen a0. A similar argument to the above applies, that is, we assume L* 2,a0 = \nL(C) for some FRA C and select a0sa0s .L* 2,a0 of sizebig enough toyield a contradiction. Finally,itsuf.cestoshowL \n' = A * \\L(B)for anRAB.By example 14 we have that L ' = A * \\L(A)for a WFRA A with no fresh transitions.From \nthat, we obtain B by applyinglemma15.  7. Symbolic methods The automata we have introduced can be viewed \nin two different manners: either as ordinary .nite-state automata operating on con\u00adstant symbols and \nthe symbols 1,1 ,1. ,...,n . (for machines with n registers), or as machines which recognise languages \nfrom an alphabet comprising a .nite set of constants and an in.nite set of names. We use the term semantic \nlevel for the latter interpre\u00adtation, and symbolic level for the former one. The semantic is of course \nthe intended interpretation but, on the other hand, viewing our automata as operating on the .nite alphabet \nLn is much more convenient.In this section we examine methodsfrom the symbolic level which characterise \nsemantic notions. More speci.cally, we start by giving a simple proof of decidability of FRA-emptiness \nby reducing the problem to FSA-emptiness. We then proceed to our main point of focus, which is the de.nition \nof an appropriate notion of symbolic bisimilarity that is equivalent to the notion of bisimilarity we \nhave been using thus far. As a corollary we prove thatbisimilarityisdecidableforFRA s. Proposition24. \nThe emptinessproblemisdecidable forFRA s. Proof. Given anFRAA of n registers, constructits closure A, \nand take A ' to be the ordinary FSA with the same set of states, initial state, transition relation and \n.nal states as A, and operating on the set of labels Ln. We claim that L(A)= \u00d8 .. L(A ' )= \u00d8. Indeed, \nif A accepts a string s . C . A * then, the accepting path in A yields a string s ' . Ln* , and s ' .L(A \n' ). Conversely, if A ' accepts a string s ' then the acceptingpathin A ' is also apathin A endingin \nan accepting state.From remark9, wehave thatthelatter yields a strings .L(A). In order to de.ne a symbolic \nnotion of bisimulation equiva\u00adlence which captures its semantical analogue, we introduce aux\u00adiliary structures \nwhich record the way in which two register as\u00adsignments are related.Inparticular, they record thedomains \nof the assignments and thoseindices on which the two assignments coin\u00adcide.A symbolicbisimulationbetween \ntwo automata relates states of the automatain speci.c record environments.At eachbisimula\u00adtion step the \nrecords are updated according to the speci.c symbolic transitions takingplace. This symbolic description \nis shown to ac\u00adcurately capture whathappens at the semanticallevel. We adaptStark s notion of span [28].We \ncall (S1,.,S2).P([n1])\u00d7P([n1]\u00d7 [n2])\u00d7P([n2]) a typed span on (n1,n2)if: (i,j),(i ' ,j ' ). .implies \nthat i = i ' .. j= j ' ,  img(.). S2, where img(.)= { i . [n]|.j.(j,i). .},  dom(.). S1, where dom(.)= \n{ j. [n]|.i.(j,i). .}.  We write [n1] . [n2]for the set of typed spans on (n1,n2).A perhaps moreintuitive \nwayto view a typed span (S1,.,S2)is as a triple of relations: . S2. .).(img -. ).(dom .. S1 By abuse \nof notation, we write . for the whole of (S1,.,S2), in which case we also use the notation S1(.)= S1 \nand S2(.)= S2. If. :[n1]. [n2]and (i,j). [n1]\u00d7 [n2]then .[i . j]:[n1]. [n2]is the typed span: '' '' \n(S1(.).{i},. \\{(i ,j )| i = i .j= j}.{(i,j)},S2(.).{j}) A typed span (S1,.,S2) relates register assignments \ns1 and s2 just in case. is a bijection between the parts of [n1]and [n2]that have commonimages unders1 \nand s2, while Si keeps trackof(the indices of) all namesin si.Formally, . = s1 . s2 if: dom(s1)= S1(.).dom(s2)= \nS2(.).. = {(i,j)| s1(i)= s2(j)} In this case, I.I = |S1(.)| + |S2(.)|-|dom(.)| gives the total number \nof namesin s1 and s2. Suppose, for example, that we have related state q1 of automa\u00adton A1 to state q2 \nof A2 with respect to ..If (q1,i,q 1' )is a transi\u00adtionin A1 and i . dom(.)then the namein register iof \nA1 (inthe semantical scenario captured by the symbolic description) resides in register.(i)of A2.Consequently, \nA2 can only simulatethetran\u00adsition by some (q2,.(i),q 2' ).On the other hand, if (q1,i ,q 1' )is a transitionin \nA1 then there are severalfactors to consider: Anyprivate name ofA2 canbe capturedby i .Hence, A2 needs \na simulatingtransition (q2,j,q 2' )for everyj. S2(.)\\ img(.).  Moreover, A2 needs a transition for \nall names locally fresh to both A1 and A2. This can be some (q2,j ,q 2' )but, under circumstances,it \nmay alsobe some (q2,j. ,q 2' ).   In order for (q2,j. ,q 2' )to capture all names locally fresh to \nA1 and A2, it must be the case that all names in history are present in the registers of A1 and A2 (so \nthat global freshness coincide with mutual local freshness). If A1 has n1 registers and A2 has n2, and \nassuming that the initial register assignments for A1 and A2 contain the same names, thelatter can onlyhappen \nin caseless than n1 + n2 names appearin thehistory. We can therefore resolve thelatter caseby adding \na component which counts the names in the history, up to n1 + n2. In the followingwe write n forn1+n2, \nand set h++ = .h+1.n (= h+1 ifh<n, and n otherwise). De.nition 25. Let Ai = (Qi,q0i,s0i,di,Fi) be FRA \ns of ni registers, for i =1,2, such that img(.01)= img(.02)= H0. A symbolic simulation on A1 and A2 is \na relation R . Q1 \u00d7 ([n].{0})\u00d7 ([n1]. [n2])\u00d7 Q2 such that, whenever (q1,h,.,q2) . R, if q1 . F1 then \nq2 . F2 andif (q1,l,q 1' ). d1 then: 1. Ifl . C then (q2,l,q 2' ). d2 for some (q1' ,h,.,q 2' ). R. \n2. If l = i and i . dom(.)then (q2,.(i),q 2' ) . d2 for some (q1' ,h,.,q 2' ). R.  3. If l = i and i \n. S1(.)\\ dom(.)then (q2,j ,q 2' ) . d2 for some (q1' ,h,.[i . j],q 2' ). R.  4. Ifl = i then,for any \nj. S2(.)\\ img(.), (q2,j,q 2' ). d2 for some (q1' ,h,.[i . j],q 2' ). R.  5. If l = i and h = n or I.I \n<h then (q2,j ,q 2' ) . d2 for some (q1' ,h,.[i . j],q 2' ). R.  6. If l .{i ,i. } then (q2,j ,q 2' \n). d2, or (q2,j. ,q 2' ). d2,for some (q1' ,h++,.[i . j],q 2' ). R.  Setting(S1,.,S2)-1 =(S2,.-1,S1), \ntheinverse of Ris: R-1 = { (q2,h,.,q1)| (q1,h,.-1 ,q2). R} . We say that R is a symbolic bisimulation \nif both R and R-1 are symbolic simulations. We say that A1 and A2 are symbolic s bisimilar, written A1 \n~A2,if thereis a symbolic bisimulation R on A1 and A2 such that (q01,h0,.0,q02) . R with h0 = |H0| and \n.0 = s01 . s02. In the following propositions let us assume the hypotheses of De.nition25.Letus also \nwrite H forH . H0, and n forn1 +n2. Proposition26. If Ris a symbolic simulation on A1 and A2 then R ' \n= { ((q1,s1,H),(q2,s2,H))| (q1,h,.,q2). R . . = s1 . s2 . h = .| H |.n . img(si). H } is a simulation. \nMoreover, if R is a symbolic bisimulation then R ' is abisimulation. Proposition 27. If A1 and A2 are \nclosed FRA s and R is a simulation on A1 and A2 then R ' = { (q1,h,.,q2)| ((q1,s1,H),(q2,s2,H)). R . \n. = s1 . s2 . h = .| H |.n . (qi,si,H)reachable } is a symbolic simulation. Moreover, if R is a bisimulation \nthen R ' is a symbolicbisimulation. Corollary 28. Bisimilarityisdecidable forFRA s. Proof. LetAi = (Qi,q0i,s0i,di,Fi) \nbeFRA s of ni registers,for i =1,2. Choose ia1,ia2 . A. such that img(iai)= img(s0i)\\ img(s0\u00afi), and \nform A ' 1 = A1 . ia2 and A2 ' = A2 . ia1. Now close these and obtain closedFRA s A ' i.Wehave Ai ~A \n' i.More\u00ad s over,bythepreviouspropositions, A ' ~A ' .. A ' ~A2' , and 12 1 s hence A1 ~A2 .. A ' 1 ~A \n' 2 . As the symbolic bisimu\u00adlations between A ' 1 and A ' 2 live in a space bounded relatively to |Q1|,|Q2|,n1,n2, \nwe can searchit exhaustivelyfor such relations. Hence,FRA-bisimilarityisdecidable.  8. Automataforthe \np-calculus Webrie.yrecall thede.nition of the p-calculus with early seman\u00adtics and strong bisimulation \n[14, 26]. We use the .xed set A of names for channel names, and let p range over process constants. The \nset.of p-calculusprocessesisgiven asfollows, P,Q ::= 0 | \u00af= a) ab.P | a(b).P | [ab]P | .a.P | P+Q| P \n| Q| p(i where a,b . A and ia . A * . Name binding is de.ned as usual (b is bound in a(b).P and .b.P), \nand processes are equatedup to a-equivalence.We write fn(P)for the set of names appearingfree inP.Process \nconstants are accompaniedby de.nitions of theform p(ia)= P, where ia . A. and fn(P)= img(ia). Moreover, \neach occurrence of p must be guarded, i.e. it must come in one of the forms \u00afa)a). ab.p(ior a(b).p(iThe \nsemantics ofthe calculusisearly andisgiven via alabelled transition relation withlabels: a ::= \u00afa(b)| \nab | t ab | \u00af Labelshavefree andbound occurrences of names,but they are not equated up to a-equivalence. \nfn(\u00afab)= fn(ab)= {a,b} fn(\u00afa(b))= {a} fn(t)= \u00d8 bn(\u00afab)= bn(ab)= \u00d8 bn(\u00afa(b))= {b} bn(t)= \u00d8 We write n(a)for \nfn(a). bn(a).Thetransition relationisgiven by thefollowing rules(plus symmetric counterparts). a P -. \nP ' OUT MATCH aab \u00af-. P [a = a]P -. Pab.P \u00af' a P{ia/ib} -. P ' INP REC p(.b)=P aca a(b).P -. P{c/b} p(ia)-. \nP ' \u00afa ab P -. P ' P -. P ' OPEN a.a/ =b RES .n(a) a\u00af(b)a' ' .a.P -. .a.P .b.P -. P \u00afab ab aP -. P ' \nQ-. Q ' P -. P ' SUM COMM at '' | Q ' P+Q-. PP | Q-. P a P -. P ' PAR bn(a)nfn(Q)=\u00d8 a P | Q-. P ' | Q \na\u00af(b)ab P -. P ' Q-. Q ' CLOSE b/ .fn(Q) t P | Q-. .b.(P ' | Q ' ) Note how the side-conditions impose \nglobal freshness on names created using the . constructor. Bisimulation is the standard notion of equivalence \nin the p\u00adcalculus; here we shall consider strong bisimulation. A relation R . . \u00d7 . is called a simulation \nif, for all (P1,P2) . R and aa all a with bn(a)n fn(P1,P2)= \u00d8,if P1 -. P1 ' then P2 -. P2 ' for some \n(P1' ,P 2' ) . R. R is called a bisimulation if both R and R-1 are simulations.We say that P and Qare \np-bisimilar, written p P ~ Q,if thereis abisimulation Rcontaining (P,Q). We nowde.ne a version ofthep-calculus \nwith extended syntax thatisdirectly representable byFRA s.Since transitions are multi\u00adsymbol, and our \nautomata can recognise one symbol at a time, they willbe decomposed to atomic ones. We add sets of input \nand output processes which cater for the intermediate stages in these decompositions.For example, ab\u00afab \nab.P \u00af-. P decomposes to \u00af-. b.P ab.P -. P where b.P isan outputprocess.Output[resp.input]processes \nare in the middle of sending[receiving] a name on a chosen channel. De.nition29. Thexp-calculus syntaxisgivenby \nthe sets .,.out and .inp, with elements: P,Q ::= 0 | \u00af= a) ab.P | a(b).P | [ab]P | .a.P | P+Q| P | Q| \np(i Pout ::= b.P | .a.Pout | P | Pout | Pout | P Pinp ::= (b).P | .a.Pinp | P | Pinp | Pinp | P  where \na,b . A and ia . A * . We write . for . . .out . .inp, and let Q,range over its elements, which we equate \nup to P, ... a-equivalence. Namebinding isde.ned as expected: b isbound in .b. P,a(b).P and (b).P . It \nis handy to introduce here some very basic notions from the theory of nominal sets[8,23].We call nominal \nstructure any struc\u00adture which may contain names (i.e. elements of A), and we de\u00adnoteby Perm(A)theset \nof.nitepermutationson A (i.e.bijections p : A . A such that p(a)= a for .nitely many a . A). For example, \nid = {(a,a)| a . A}. Perm(A). We shall de.ne for each set X of nominal structures ofinterest afunction \n\u00b7 : Perm(A)\u00d7 X . X such that p\u00b7 (p ' \u00b7 x)=(p. p ' )\u00b7 x and id \u00b7 x = x,for all x . X and p,p ' . Perm(A). \nX willbe called a nominal set ifallits elements involve .nitely many names,thatis,forall x . X there \nis a .nite set S . A such that p \u00b7 x = x whenever .a . S.p(a)= a. For example, A is a nominal set with \naction p \u00b7 a = p(a), and so is Pfn (A) with action p \u00b7 S = {p(a) | a . S}. Also, any set of non-nominal \nstructures is a nominal set with trivial action p \u00b7 x = x. More interestingly, if X is a nominal set \nthen so is X * with action p \u00b7 x1 ...xn =(p \u00b7 x1)... (p \u00b7 xn). Also, if X S is a nominal set then so \nis the set n..([n] . X)with action p \u00b7 f = {(i,p\u00b7 x)| (i,x). f}. Thus,.,.out ,.inp,.are all nominal sets.For \nexample, ' c \u00af' p \u00b7 a(b).bc. \u00af0 = a ' (b ' ).b . 0 where a ' =p(a),b ' =p(b),c ' =p(c)(notethatpermutations \nequally affectbound andfree name occurrences).Similarlyto X * , wehave that X \u00d7 Y is a nominal set whenever \nX and Y are. Note that if X is a nominal set and X ' . X is such that p \u00b7 x . X ' , for all x . X ' and \np . Perm(A), then X ' is also a nominal set with the inherited action.Hence, thefollowing setis a nominal \nset. [ K = { (s, P )| s . Regn . P . . . fn(P ). img(s)} (1) n.. WewriteK forthe restrictionof K to elements(s, \nP )with P . .. Finally,from a nominal set X we canderiveits set of orbits: O(X)= {O(x)| x . X} where \nO(x)= {p\u00b7x | p . Perm(A)}. Note that each O(x)is a nominal subset of X. The technology of the previous \nparagraph is used for de.ning the transition system of the extended calculus. In contrast to the ordinary \np-calculus, the transition relation we de.ne is .nitely branching, andthisis achievedbyconsideringprocesses-in-context \nand specifying channels by their context indices instead of their names. More speci.cally, we let O(K \n)betheset ofprocesses-in\u00adcontext.Each such O(s, P )is writtens . P . Since s . P = p\u00b7s . p\u00b7P, for any \npermutation p, what matters in s . P is not the speci.c names occurring in s or P, but only theirindexin \ns.For example, ''' ' {(1,a),(2,c)}. a(b).bc. \u00af0 = {(1,a ),(2,c )}. a (b).b c \u00af . 0 andin essenceboth \nof these are speci.edby an expression e.g.like ({(1,.),(2,.)},1(b).b\u00af2. 0). Borrowing notation from FRA \ns, we build up on the indices idea and use transition labels of the form i /i. forfreshinputs/outputs. \nDe.nition 30. The semantics of the xp-calculus is given via a labelled transition system with set of \nstates O(K )andlabels: a ::= i| i | i. | t | \u00afij | \u00afij. | ij | ij where i,j . ..Thetransition relationisgivenby \nthe rulesinTable1. l Note that s . P -. s ' . P ' implies |s| = |s ' |.Somefurther remarks on reduction: \n Transitions restricted to . use only t and double labels, i.e. from {\u00afij,\u00afij. ,ij,ij | i,j . .}.  Inputs \nare decomposed as known inputs (INP2A) and locally fresh ones (INP2B), and are therefore .nitely branching. \nThe  i side-conditions impose that, whenever s . Pinp -. s ' . P, then s ' = s[i . a], a/. img(s)and \ni is the least index such that s(i)./fn(P).6 Similar .niteness and minimisation apply tobound outputs \n(OPEN). Note that the CLOSE rule involves bound outputs, hence glob\u00adally fresh transitions on the output \nside. On the input side, it is then necessary to have a matching locally fresh transition: globalfreshnessimplieslocalfreshness. \n Example31. For each a . A,let sa = {(1,a)} and Pa = .b.p(ab) withde.nition p(ab)= ab..c.p(bc) \u00af. In \nthe p-calculus, Pa induces an in.nitely-branching, in.nite-path transitiongraph: ... . . . . . . a(b \n' ) . \u00af' ) . c(d ' ) . \u00af b(c \u00af  \u00af a\u00af(b) b(c) c\u00af(d) Pa Pb Pc \u00b7\u00b7\u00b7 Inthe extendedcalculus, Pa inducesthefollowingtransitiongraph, \n11. 1 sa . Pa -. sa . .b.b..c.p(bc)-. sb . Pb -. \u00b7\u00b7\u00b7 which is economic by branching once at each step. \nIn fact, setting Pout = .b.b..c.p(bc), and since sa . Pa = sb . Pb and sa . Pout = sb . Pout for all \na,b . A,thegraph above contains just two nodes: 1 sa . Pa . sa . Pout 1. and usingdoublelabels weget \nsimply sa . PaP 11. . The wayin whichthetwotransition relations are relatedisgiven by thefollowinglemma, \nwhich veri.es theintuitions ofTable1. Lemma 32. Let s,s ' be registers, and a, a be labels of p and xp \nrespectively.For all P,P ' . .with fn(P). img(s): a a if s . P -. s ' . P ' then P -. P ' , aa if P -. \nP ' then s . P -. s ' . P ' ; s ' \u00af where either a = a = t and s = ; a = ij/ij, a =\u00af or ab/ab, s(i)= \na, s(j)= b and s ' = s; or a = ij. /ij , a = a\u00af(b)/ab, \u00af a, s '' s(i)= = s[j. b]and j= min{j| s(j)./fn(P \n)}. There is a straightforward passage from the xp-calculus to FRA s: states are taken from O(K ), states \nfrom O(K) are .nal, andthetransition relationisthe onegiveninTable1(omittingdou\u00adbletransitions).7However,the \nusual(symbolic) notion ofbisimu\u00adlation between FRA s is not appropriate because it is de.ned for single-step \ntransitions and, moreover, does not take into account thedistinctionbetweeninputs and outputs. We thereforede.ne \nthe following notion. De.nition33. A simulation is a relation [ R . O(K)\u00d7 ([n]. [m])\u00d7 O(K) n,m.. 6Althoughnot \nessential, minimisation saves usfrom unnecessarybranching. 7Notethatthistranslationtypicallyyieldsin.niteFRA \ns butweshall examineclassesofprocesseswheretheresultingFRA sare .niteintheend of this section. aa '' \n s . P -. s . Ps . P -. s . P INP1 s(i)=a MATCH SUM aa i '' s . a(b).P -. s . (b).P s . [a = a]P -. \ns . Ps . P+Q-. s . P i=min{i|s(i)./fn(P)} INP2A s(i)=a INP2B ii b/ .img(s) s . (b).P -. s . P{a/b} \ns . (b).P -. s[i . b]. P i s[i . a]. Pout -. s[i . a]. P i=min{i|s(i)./fn(P)} OUT1 s(i)=a OPEN ii. \na/ .img(s) s . \u00af-. s . b.P ab.P s . .a.Pout -. s[i . a]. P a ' a' s . P{ia/ib} -. s . Ps . P -. s . \nP OUT2 s(i)=b REC p(.b)=P PAR1 aa i' s . b.P -. s . Ps . p(ia)-. s . P ' s . P | Q-. s . P | Q ai /i. \n(s+ a). P -. (s ' + a). P ' s . P -. s[i . b]. P ' RES a.PAR2 j=min{j|s(j)/' ,Q)} =(|s|+1) .fn(P a s \n. .a.P -. s ' . .a.P ' j /j. ' s . P | Q-. s[j. b]. P | Q \u00af\u00afi1. i1 ijij ' s . P -. s . Ps . Q-. s . \nQ ' (.+ s). P -. (b+s). P ' (.+ s). Q-. (b+ s). Q ' COMM CLOSE tt s . P | Q-. s . P ' | Q ' s . P | \nQ-. s . .b.(P ' | Q ' ) ij/j. ij/j ' ' s . P -. s . Pout -. s ' . Ps . P -. s . Pinp -. s ' . P DBLOUT \nDBLINP \u00afij/\u00afij. ij/ij ' . s ' s . P ----. s ' . P ' s . P - --. P Table1. The transition relationfor \nthe xp-calculus (symmetric counterparts of SUM, PAR, COMM, CLOSE omitted8). such that if (s1 . P1,.,s2 \n. P2) . R then . :[|s1|] . [|s2|] a ' a and s1 . P1 -. s1 ' . P1 ' implies that s2 . P2 -. s2 ' . P2 \n' for some (s1 ' . P1' ,. ' ,s2 ' . P2' ). Rsuchthat one ofthefollowingis the case, withi . dom(.): \na = a ' = t and . ' = .;  a = ij, j. dom(.), a ' = .(i).(j)and . ' = .;  a = ij, j/. dom(.), a ' = \n.(i)k and . ' = .[j. k];  a = ij , a ' = .(i)k , . ' = .[j. k]and,  .(i)k ' for all k ' . S2(.)\\ img(.), \ns2 . P2 -. s2 . P2 ' for some (s1 ' . P1' ,.[j. k ' ],s2 . P2' ). R; \u00af a = ij, j. dom(.), a ' = .(i).(j)and \n. ' = .; \u00af a = ij. , a ' = .(i)k. and . ' = .[j. k]. R is called a bisimulation ifboth R and R-1 are \nsimulations. We for excluding such in.nite behaviours. We say that a process has .nite control if no \nparallel compositions appear in its recursive de.nitions. Aprocess is .-strict if all its subprocesses \nof the form .a.P satisfya . fn(P).Also, Qis a descendant of P if thereis a series of p-transitionsfrom \nP to Q. Proposition 35. If P0 . . has .nite control and all its descen\u00addants are .-strict, then there \nis some s0 and a .nite S . O(K) a such that, for all (s . P) . S, if s . P -. s ' . P ' then (s '' . \nP ). S, and (s0 . P0). S. Proof. Suppose(WLOG)that P0 invokes de.nitions pi(iai)= Pi, i . [N]for some \nN, and take M = |P0|\u00d7 max{|Pi|| i . [N]} forthe sizefunction whichcounts aprocess occurrences of0 s, \np s and names,free orbound(but notbinding): e.g. |\u00af2+|P|, ab.P| = |a(b).P| =1+|P|, |.a.P| = |P|, |p(ia)| \n=1+|ia| and |0| =1. pp p ~ P2,if thereis a bisimulation R containing (s01 . P1,s01 . s02,s02 . P2),for \nonly increase its size by recursion and, as P0 has .nite control, some s01,s02 with img(s01)= fn(P1),img(s02)= \nfn(P2). recursions cannot obtain size greater than max{|Pi|| i . [N]}. ~ Qiff P ~ Q. x If Q is a descendant \nof P then |Q|= M as a process maysay that P1 and P2 are xp-bisimilar, written P1 But then, because all \ndescendants of P0 are .-strict, their number x Proposition34. For all P,Q. ., P of .-abstractionsisbounded \nby M, andhence they allhavelength (number of symbols or constructors) bounded relatively to M.Proof. \nTheproofproceedsby showing thatifR is a simulationfor the p-calculus then They are still unboundedly \nmany, due to different choices of free R ' = { (s1 . P1,.,s2 . P2)| (P1,P2). R. . = s1 . s2 } is a simulation \nfor xp and, conversely, if R is a simulation for the xp-calculus then R ' = { (P1,P2)|.s1,s2. (s1 . \nP1,s1 . s2,s2 . P2). R} is a simulationforp. Note that the set of reducts of a given process-in-context \nis in generalin.nite.Thefollowingresultprovides suf.cient conditions variables.But since eachdescendant \ncanbe matchedwitha context from RegM, the number of the resulting processes-in-context is bounded relativelyto \nM.We collect all thesein S. Corollary 36. Bisimilarity is decidable in . when restricted to processes \nwith .nite control. Proof. For any suchprocesses P1,P2 . .,bythepreviouspropo\u00adsition and after equating \nprocesses up to non-strict .-abstractions, we obtain xp-transitiongraphswith sizesbounded relativelyto \nP1 p and P2. Clearly, P1 ~ P2 iffthereis abisimulation(in xp) be\u00ad8note: s+v = s.{(|s|+1,v)}, v+s = {(1,v)}.{(i+1,v \n' ) |(i,v ' ) . s}. tweenthosegraphs.Asthosebisimulationsliveinaspacebounded x  relatively to the sizes \nof P1 and P2, we can search it exhaustively for such relations. Equatingprocesses up to structural congruence \n[14], the above results can be further strengthened to processes with .nite degree ofparallelism,in a \nsimilar manner to[4].   9. Furtherdirections Wehaveintroducedan abstract computationalparadigm and \nestab\u00adlisheditskeyproperties,layingthegroundforfurther research.The next logical step is to examine concrete \napplications of FRA s to the description of computation with names, either in the direction of mobile \ncalculi or that of programming languages, relating this approach to existing higher-level approaches. \nA .rst such advance hasbeen recently accomplishedin[19] by constructing a model of alow-order restrictionofReducedML(afragmentofML \nwith ground-typeinteger references)representablein a variant ofFRA s where labels contain store information. \nThis was achieved by rep\u00adresenting thefully abstractgame semantics of thelanguage[18]. On the foundational \nside, the study of the p-calculus in FRA s revealed that there is a notion of polarity inherent in computation \nwith names. In particular, the examined FRA s do not mix locally with globally fresh transitions, and \nthis is clearly depicted in the partition . =.inp . .out . .. A similar observation applies to FRA s \ndescribing Reduced ML [19]. There, the states are parti\u00adtionedinP-states(forProponent/Program) andO-states(forOppo\u00adnent/Environment); \nonly P-states are allowed to perform globally fresh transitions, and only O-states can do locally fresh \nones. In\u00adtuitively, the only notion of freshness that can be observed on the program s side is local \nfreshness, whereas the environment should be assumed tohave the memory needed in order to observe global \nfreshness. These observations suggest that a notion of polarised FRA, where states are partitioned as \nabove, is relevant and should be further pursued. In the polarised setting, symbolic bisimula\u00adtions are \nsimpli.ed as there is no longer need for an h component (cf.De.nitions25and33). Apotential criticism \ntowards FRA s concerns the fact that they failto satisfy closure under concatenation andKleene star(cf.Sec\u00adtion6).We \n.nd thesenon-closureresultsratherexpected asFRA s are history-sensitive machines. On the other hand, \nFRA s seem to be closed under the nominal versions of concatenation and Kleene star, as recentlyintroducedbyGabbay \nandCiancia[9].Thepre\u00adcise connectionsbetweenFRA s and regularlanguages with name\u00adrestriction[9] are the \nsubject of ongoing research. Finally, someimportantquestionshave stillnotbeen answered. For example, \nwe have not considered deterministic versions of FRA s, nor examined whether FRA s canbe determinised.Assum\u00ading \nthat in a deterministic FRA to each input string corresponds a uniquepath, we can see that e.g. theFRA \naccepting thelanguage L = { a1 \u00b7\u00b7\u00b7 aka | a .{a1,...,ak}..i = j.ai = aj } has no deterministic equivalent. \nOther directions for further re\u00adsearch concern minimisation of FRA s (recently examined for FMA s [2]) \nand the evident connections to HD-automata. More\u00adover, severalpossible extensions ofFRA s are ofinterest, \ne.g. vari\u00adants withlabels(data words), stores, orpushdown variants. 10. Acknowledgements ThankstoAndrzejMurawski,SamsonAbramsky,VassilisKoutavas \nandUlrichSch\u00a8oppfordiscussions and suggestions.Thanks also to the anonymous reviewersfor their comments.Section7inparticu\u00adlaris \nnow much simplerdue to a reviewer s suggestion.  A. Proofsfromsection6 Proof ofLemma19. Let A = (Q,q0,s0,d,F). \nThe construction of B = (Q ' ,q 0' ,s 0' ,d ' ,F ' ) follows closely [11]. In particular, each transition \nof A involving a name induces an assignment of that name in the extra register of B. If the transition \nwere a fresh assignment then this would result in the name occurring in B just once afterassignment, \notherwiseitwould occurtwice.Asthe actual extra register of B changes during this process we add an extra \ncomponent in states to rememberit. ~ = We set Q ' = Q\u00d7 ([n + 1] -. [n + 1]) and write elements of Q \n'' as (q,p). Moreover, q0 =(q0,id), s0 ' = s0[n+1 . .]and F ' = {(q,p)| q . F}.Finally: d ' = { ((q1,p),l,(q2,p))| \nl . C . (q1,l,q2). d} .{ (q1' ,({p(n+1)},{p(i),p(n+1)}),(q2,p))| (q1,i,q2). d} ' ' .{ (q1,({p(n+1)},{p(n+1)}),(q2,p \n))| (q1,i,q2). d} .{ (q1' ,({p(n+1)},{p(n+1)},[n]),(q2,p ' ))| (q1,i. ,q2). d} where q1 ' =(q1,p)and \np ' =(p(i) . p(n+1)) . p (we write (k . j)forthepermutation thatswaps kand j).We can show that thefollowing \nrelationis abisimulation and therefore that A~B. R = { ((q,s,H),((q,p),s ' ,H))|.i . [n].s(i)= s ' (p(i))} \n Proof ofLemma20. Let A = (Q,q0,s0,d,F) and construct B = (Q ' ,q 0' ,s 0' ,d ' ,F ' ) as follows. The \nidea is to keep in the extra memory registers of B a copy of theinitial con.guration s0 which is never \ntouchedbyassignments.Thus, whenever A wants to make a transition with label (S,T,A), B will simulate \nit by a transition (S,S,[n]) and transitions of the form (S,T . Ta) where Ta . {n+1,..., 2n}, a . s0([n]\\ \nA) and a is not in the history. In order to accomplish this we need to enrich states withinformation \nregarding whether the names in img(s0) appear in the history. Therefore, we set Q ' = Q\u00d7P(img(s0)), q0 \n' =(q0,\u00d8), s0 ' = s0 + s0, F ' = {(q,I)| q . F} and: '' ' d = { ((q,I),l,(q ,I))| l . C . (q,l,q ). \nd} .{ ((q,I),(S,T),(q ' ,I))| (q,(S,T),q ' ). d} .{ ((q,I),(S,T . Ta),(q ' ,I .{a}))| (q,(S,T),q ' ). \nd} .{ ((q,I),(S,S,[n]),(q ' ,I))| (q,(S,S,A),q ' ). d} '' ' .{ ((q,I),(S,T . Ta ' ),(q ,I .{a }))| (q,(S,T,A),q \n). d} where a . img(s0), Ta = { (n + i) . [2n] | s0(i)= a}, a ' . s0([n]\\ A)\\ I, and Ta ' as Ta.We can \ncheck that R = { ((q,s,H),((q,I),s ' ,H))| I = Hnimg(s0).s ' = s+s0 } is abisimulation and therefore \nthat A~B. Proof ofLemma21. Let A = (Q,q0,s0,d,F) and construct B = (Q ' ,q 0' ,s 0' ,d ' ,F ' ) by setting \nQ ' = Q\u00d7 ([n]. [n])and selecting f0,s 0 ' such that img(s0)= img(s0' )and s0 = s0 ' . f0.Moreover, set \nq0 ' =(q0,f0), F ' = {(q,f)| q . F} and: d ' = { ((q,f),l,(q ' ,f))| l . C . (q,l,q ' ). d} '' ' .{ ((q,f),i,(q \n,f ))| f(T \\ S)= {i}. (q,(S,T),q ). d} ' '-1' .{ ((q,f),i,(q ,f ))| f(i). S . (q,(S,S),q ). d} ''-1' \n.{ ((q,f),i,(q ,f ))| f(i). S . (q,(S,S),q ). d} ' '-1' .{ ((q,f),i. ,(q ,f ))| f(i). S . (q,(S,S,[n]),q \n). d} with f ' = f[S . i].Now, thefollowingis abisimulation R = { ((q,s,H),((q,f),s ' ,H))| s = s ' \n. f } andhence A~B.  B. Proofsfromsection7 Proof ofProposition 26. It will suf.ce to check only non-constant \ntransitions. So let ((q1,s1,H),(q2,s2,H)) . due to some R ' a (q1,h,.,q2). Rand supposethat (q1,s1,H)-.d1 \n(q1' ,s 1' ,H ' ) with H ' = H .{a}.Wedo case analysis on a.Below we write . ' for .[i . j]. a . img(s1)n \nimg(s2), say a = s1(i)= s2(j). Then, it is necessary that (q1,i,q 1' ) . d1 and s1 ' = s1. Also, . = \ns1 . s2 implies (i,j). ., so (q2,j,q 2' ). d2 for some (q1' ,h,.,q 2' ). R. a Thus, (q2,s2,H)-.d2 (q2' \n,s2,H ' )and, noting that H ' = H so ' '' ' h = .| H ' |.n, we can see that ((q1,s1,H ),(q2,s2,H )). \nR ' . a . img(s1)\\img(s2), say a = s1(i).Then, again (q1,i,q 1' ). d1 and s1 ' = s1,but i . S1(.)\\ dom(.).Thus, \n(q2,j ,q 2' ). d2 a '' ' forsome(q1,h,. ' ,q 2). R.Thus, (q2,s2,H)-.d2 (q2,s 2' ,H ' ), s '' 2 = s2[j. \na].Notingthat . ' = s1 . s2 ' and H = H, wehave ' '' ' that ((q1,s1,H ),(q2,s 2' ,H )). R ' . a . img(s2)\\img(s1), \nsay a = s2(j).Since a . H\\img(s1), we have some (q1,i ,q 1' ) . d1, and s1 ' = s1[i . a]. More\u00adover, \nj . S2(.)\\ img(.)and therefore (q2,j,q 2 ' . d2 for some a '' '' (q1,h,. ' ,q 2). R. Thus, (q2,s2,H)-.d2 \n(q2,s2,H )and we ' '' ' can see that ((q1,s 1' ,H ),(q2,s2,H )). R ' . a . H \\ (img(s2). img(s1)), so \n(q1,i ,q 1' ). d1, and s1 ' = s1[i . a].If h<n then I.I = |img(s1). img(s2)| < |H | = h. Thus, (q2,j \n,q2) . d2 for some (q1' ,h,. ' ,q 2' ) . R, and so a (q2,s2,H)-.d2 (q2' ,s 2' ,H ' ), s2 ' = s2[j . a]. \nWe have . ' = s1 ' . s2 ' and h = .| H ' |.n,thus ((q1' ,s 1' ,H ' ),(q2' ,s 2' ,H ' )). R ' . a/. H \nand say transitionisdue to (q1,i /i. ,q 1' ). d1, so s1 ' = ' '' s1[i . a].Then, (q2,j /j. ,q 2). d2 \nfor some(q1,h++,. ' ,q 2). a R, so (q2,s2,H)-.d2 (q2' ,s 2' ,H ' ), s2 ' = s2[j . a]. We have ' '' ' \nthat h++ = .| H ' |.n , so ((q1,s 1' ,H ),(q2,s 2' ,H )). R ' . Thus, R ' is a simulation. If R is a \nsymbolic bisimulation then, by symmetry, R ' is a bisimulation. Finally, if (q01,|H0|,s01 . s02,q02). \nRthen ((q01,s01,\u00d8),(q02,s02,\u00d8)). R ' . Proof ofProposition 27. We check non-constant transitions. Let \n(q1,h,.,q2) . R ' , due to some ((q1,s1,H),(q2,s2,H)) . R and suppose that (q1,l,q 1' ). d1.Wedo case \nanalysis on l.Below we write H ' forH .{a}, and . ' for .[i . j]. a If l = i then, by closure, (q1,s1,H) \n-.d1 (q1' ,s1,H ' )with a a = s1(i), and hence (q2,s2,H) -.d2 (q2' ,s 2' ,H ' )for some ' '' ' ((q1,s1,H \n),(q2,s 2' ,H )) . R. If i . dom(.), say (i,j) . ., then a . img(s2) and it must be (q2,j,q 2' ) . d2, \ns2 ' = s2. We can see that (q1' ,h,.,q 2' ) . R ' . If i . S1(.) \\ dom(.) then a ./img(s2) and there \nis some (q2,j ,q 2' ) . d2, and s2 ' = s2[j. a].Wehave that (q1' ,h,. ' ,q 2' ). R ' . a If l = i then, \nfor each a ./img(s1), (q1,s1,H) -.d1 a (q1' ,s 1' ,H ' ), s1 ' = s1[i . a], and therefore (q2,s2,H) -.d2 \n' '' (q2,s 2' ,H ' )for some ((q1,s 1' ,H ' ),(q2,s 2' ,H ' )). R. For any j . S2(.)\\ img(.), s2(j) ./img(s1), \nso we can take a = s2(j).Then, we musthave (q2,j,q 2' ). d2, s2 ' = s2, and we can check that (q1' ,h,. \n' ,q 2' ). R ' . If h = n or I.I <h then we can choose a . H \\ (img(s1). img(s2)).Thus, wehave some \n(q2,j ,q 2' ). d2, s2 ' = s2[j. a]. ' s ' '' Notingthat H = H and . ' = 1.s2' ,weget (q1,h,. ' ,q 2). \nR ' . Finally,if we choose a/. H then there is some (q2,j /j. ,q 2' ). d2, and s2 ' = s2[j . a]. We have \nthat . ' = s1 ' . s2 ' and ' '' H = H .{a},thus h++ = .| H ' |.n.Hence, (q1,h++,. ' ,q 2). R ' . i. Thus, \nR ' is a symbolic simulation. If R is a bisimulation then, by symmetry, R ' is a symbolicbisimulation.Finally,if \n((q01,s01,\u00d8), (q02,s02,\u00d8)). R then (q01,|H0|,s01 . s02,q02). R ' . Ifl = then we work asin thelast case \nabove.  References [1] S.Abramsky,D.R.Ghica,A.S.Murawski,C.-H.L.Ong,andI.D.B. Stark. Nominal games and \nfull abstraction for the nu-calculus. In Proc.ofLICS 04,pages150 159.IEEEComp.Soc.Press,2004. [2] M. \nBenedikt, C. Ley, and G. Puppis. Minimal memory automata. AlbertoMendelzonWorkshop onFoundations ofDatabases,2010. \n[3] N. Benton and V. Koutavas. A mechanized bisimulation for the nu\u00adcalculus. Tech.Rep.MSR-TR-2008-129,Microsoft \nResearch, 2008. [4] R. Bruni, F. Honsell, M. Lenisa, and M. Miculan. Modeling fresh names in the pi-calculus \nusing abstractions. In Proc. of CMCS 04, volume106,pages25 41.Elsevier,2004. [5] S. Delaune, S. Kremer, \nand M. Ryan. Symbolic bisimulation for the Applied PiCalculus. In Proc.ofFSTTCS 07, volume4855 of LNCS, \npages133 145,2007. [6] S. Demri and R. Lazic. LTL with the freeze quanti.er and register automata. ACMTrans.Comput.Log.,10(3),2009. \n[7] G. L. Ferrari, U. Montanari, and E. Tuosto. Model checking for nominal calculi. In Proc. of FOSSACS \n05, volume 3441 of LNCS, pages1 24,2005. [8] M. Gabbay and A. M. Pitts. A new approach to abstract syntax \nwith variable binding. FormalAsp.Comput.,13(3-5):341 363, 2002. [9] M. J. Gabbay and V. Ciancia. Freshness \nand name-restriction in sets of traces with names.Submittedforpublication,2010. [10] A. Jeffrey and \nJ. Rathke. Towards a theory of bisimulation for local names. In LICS,pages56 66,1999. [11] M. Kaminski \nand N. Francez. Finite-memory automata. Theor. Comput. Sci.,134(2):329 363, 1994. [12] J. Laird. A game \nsemantics of local names and good variables. In Proc.ofFOSSACS 04, volume2987 of LNCS,pages289 303,2004. \n[13] J. Laird. A fully abstract trace semantics for general references. In Proc.ofICALP 07, volume4596 \nof LNCS,pages667 679,2007. [14] R.Milner,J.Parrow, andD.Walker. Acalculus of mobileprocesses, I andII. \nInf.Comput.,100(1):1 77,1992. [15] R. Milner, M. Tofte, and D. Macqueen. The De.nition of Standard ML. \nMITPress,1997. [16] U. Montanari and M. Pistore. An introduction to History Dependent Automata. Electr.Notes \nTheor.Comput.Sci.,10,1997. [17] U.Montanari andM.Pistore.Structured coalgebrasand minimalHD\u00adautomata \nfor the pi-calculus. Theor. Comput. Sci., 340(3):539 576, 2005. [18] A.S.Murawski andN.Tzevelekos.Full \nabstractionforReducedML. In Proc.ofFOSSACS 09, volume5504 of LNCS,pages32 47,2009. [19] A. S. Murawski \nand N. Tzevelekos. Algorithmic nominal game se\u00admantics. Submittedforpublication, 2010. [20] R.M.Needham.Names.InS.Mullender,editor, \nDistributed systems, pages315 327.ACMPress/Addison-Wesley, 1993. 2ndedition. [21] F. Neven, T. Schwentick, \nand V. Vianu. Finite state machines for stringsoverin.nite alphabets. ACMTrans.Comput. Logic,5(3):403 \n435,2004. [22] M. Pistore. History Dependent Automata. PhD thesis, University of Pisa,1999. [23] A.M.Pitts. \nNominallogic, a .rst ordertheory of namesandbinding. Inf.Comput.,186(2):165 193, 2003. [24] A. M. Pitts \nand I. Stark. Observable properties of higher order func\u00adtionsthatdynamically createlocal names,or:What \ns new? InProc. of MFCS 93, number711inLNCS,pages122 141,1993. [25] H. Sakamoto and D. Ikeda. Intractability \nof decision problems for .nite-memory automata. Theor.Comput.Sci.,231(2):297 308, 2000. [26] D. Sangiorgi \nand D. Walker. The pi-calculus: A Theory of Mobile Processes. CambridgeUniversity Press,2001. [27] L.Segou.n. \nAutomataandlogicsforwordsand trees overanin.nite alphabet. In Proc.ofCSL 06, vol.4207 of LNCS,pages41 \n57,2006. [28] I.Stark. Names and Higher-Order Functions. PhD thesis, University ofCambridge, 1994.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p><i>What is a basic automata-theoretic model of computation with names and fresh-name generation?</i> We introduce Fresh-Register Automata (FRA), a new class of automata which operate on an infinite alphabet of names and use a finite number of registers to store fresh names, and to compare incoming names with previously stored ones. These finite machines extend Kaminski and Francez's Finite-Memory Automata by being able to recognise globally fresh inputs, that is, names fresh in the whole current run. We examine the expressivity of FRA's both from the aspect of accepted languages and of bisimulation equivalence. We establish primary properties and connections between automata of this kind, and answer key decidability questions. As a demonstrating example, we express the theory of the pi-calculus in FRA's and characterise bisimulation equivalence by an appropriate, and decidable in the finitary case, notion in these automata.</p>", "authors": [{"name": "Nikos Tzevelekos", "author_profile_id": "81319502901", "affiliation": "Oxford University Computing Laboratory, Oxford, United Kingdom", "person_id": "P2509620", "email_address": "nikt@comlab.ox.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926420", "year": "2011", "article_id": "1926420", "conference": "POPL", "title": "Fresh-register automata", "url": "http://dl.acm.org/citation.cfm?id=1926420"}