{"article_publication_date": "01-26-2011", "fulltext": "\n Step-Indexed Kripke Models over Recursive Worlds Lars Birkedal IT University of Copenhagen, Denmark \n birkedal@itu.dk Kristian St\u00f8vring * University of Copenhagen, Denmark stovring@diku.dk Bernhard Reus \nUniversity of Sussex, UK bernhard@sussex.ac.uk Jacob Thamsborg IT University of Copenhagen, Denmark \n thamsborg@itu.dk Abstract Over the last decade, there has been extensive research on mod\u00adelling challenging \nfeatures in programming languages and program logics, such as higher-order store and storable resource \ninvariants. A recent line of work has identi.ed a common solution to some of these challenges: Kripke \nmodels over worlds that are recursively de.ned in a category of metric spaces. In this paper, we broaden \nthe scope of this technique from the original domain-theoretic set\u00adting to an elementary, operational \none based on step indexing. The resulting method is widely applicable and leads to simple, succinct models \nof complicated language features, as we demonstrate in our semantics of Chargu\u00b4eraud and Pottier s type-and-capability \nsys\u00adtem for an ML-like higher-order language. Moreover, the method provides a high-level understanding \nof the essence of recent ap\u00adproaches based on step indexing. Categories and Subject Descriptors D.3.1 \n[PROGRAMMING LANGUAGES]: Formal De.nitions and Theory; F.3.1 [LOGICS AND MEANINGS OF PROGRAMS]: Specifying \nand Verifying and Reasoning about Programs General Terms Languages, Theory, Veri.cation Keywords Kripke \nmodels, ultrametric spaces, step-indexed mod\u00adels, capability calculus, frame rules, indirection theory \n1. Introduction Over the last decade, there has been extensive research on mod\u00adelling challenging features \nin programming languages, type sys\u00adtems and program logics, such as higher-order store and storable resource \ninvariants, where modelling involves constructing recur\u00adsively de.ned structures [15, 22, 29, 32, 41, \n42]. One of the main aims of this research has been to develop a method for building semantic models \nsuch that (1) the method is simple enough to be understood by the designers of a type system or a program \nlogic * Work carried out while employed at the IT University of Copenhagen. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, \nUSA. Copyright c . 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 Jan Schwinghammer Saarland University, \nGermany jan@ps.uni-saarland.de Hongseok Yang Queen Mary University London, UK hyang@dcs.qmul.ac.uk \n(who might have only limited knowledge of domain theory) but (2) the method is powerful enough to resolve \nthe issue of constructing recursive structures. Unfortunately, existing methods do not fully achieve \nthis aim. Methods based on classical domain theory provide techniques for constructing recursive structures, \nbut they require non-trivial math\u00adematical knowledge from users. Methods based on step index\u00ading [2, \n4, 6, 11, 12], on the other hand, do not require sophisticated mathematics from the users; usually, the \nprerequisite is just famil\u00adiarity with standard operational semantics of programs. However, the step-indexed \nmethods only partially address the issue of con\u00adstructing recursive structures. They change the original \nrecursive equations that solutions have to satisfy to easier approximate ones, and construct structures \nthat satisfy the approximate equations. We point out that solving the original recursive equations seems \ncrucial in some applications, such as the semantics of various higher-order frame and anti-frame rules \n[44, 46]. Hence, in those applications, only domain-theoretic models, not step-indexed ones, have been \ndeveloped. In this paper, we propose a new method that brings together the bene.ts of both domain-theoretic \nand step-indexing methods. Our approach is based on a recent line of work where challenging features \nof programming languages and logics are modelled using a common solution: Kripke models over worlds that \nare recursively de.ned in a category of metric spaces [21, 44, 46]. This method transfers those worlds \nfrom the original domain-theoretic setup to an elementary, operational one based on step indexing. Although \nour method does involve a modicum of metric space theory, it retains the .avour and simplicity of traditional \nstep\u00adindexed methods [2, 4, 6, 11, 12]. Unlike these step-indexed mod\u00adels, which only provide solutions \nto approximated versions of re\u00adcursive equations, our approach provides solutions to the equations proper, \ni.e., we solve the equation up to isomorphism. In the pa\u00adper, we demonstrate the bene.ts of our method \nby presenting the .rst semantic model of Chargu\u00b4eraud and Pottier s capability calcu\u00adlus [24]. This calculus \nis a substructural type system for a higher\u00adorder ML-like language with state. Our semantics justi.es \nthe typ\u00ading rules of the calculus, and it also suggests a sound extension of the type system with a higher-order \n(deep) frame rule. The latter imposes a nontrivial soundness issue, because we need a recur\u00adsively de.ned \noperation on a recursively-de.ned set of worlds to model the invariant-extension operator of higher-order \nframing. 1 1 We have also used the new method to give an elementary operational model for a program logic \nfor reasoning about higher-order store; this yields an alternative soundness proof to the earlier non-trivial \ndomain-theoretic  Our method also provides a high-level understanding of the essence of step-indexed \nmodels. In particular, we show that the method can be specialized to Hobor et al. s recent abstract descrip\u00adtion \nof step-indexed models [30], and explain the bene.ts of taking the metric viewpoint we suggest. The remainder \nof the paper is organized as follows. In Section 2, we give an extensive introduction of our method, \nby developing a step-indexed Kripke model for ML references. In Section 3, we address the challenging \nproblem of modelling Chargu\u00b4 eraud and Pottier s capability type system, and show how our method gives \nrise to a step-indexed Kripke model of the calculus. Next, in Section 4, we consider the connection with \nthe indirection theory of Hobor et al. [30], and point out what new insights our method brings to the \nwork on step indexing. Finally, in Sections 5 and 6, we discuss related work and conclude the paper. \nFor space reasons, some proofs and details have been omitted. These can be found in the appendices of \nthe long version of the paper, which is available at: http://www.itu.dk/people/birkedal/longessence.pdf \n2. Introductory Example: ML References In this section, we give an extensive introduction of our method, \nusing a programming language with impredicative polymorphism and general ML-like references, i.e., an \nextension of the call-by\u00advalue polymorphic lambda calculus with higher-order store. We do not give the \nsyntax of this language as it is standard [36] but point out that we use v for values, e for expressions \nand T for types, in particular e[T] is application of a polymorphic term to a type. First, we describe \nthe general idea of interpreting the program\u00adming language with a Kripke-style possible-worlds model, \nwhere the set of worlds is recursively de.ned. Then, we review an existing model that realizes the idea \nin a domain-theoretic setting (based on an adequate denotational semantics of the language). Finally, \nwe present a new step-indexed model (based purely on the operational semantics), and compare it with \nthe domain-theoretic one. A simple approach for modelling the polymorphic lambda cal\u00adculus, without general \nreferences, is to interpret types as predicates (subsets) on some .xed set of values. To model the programming \nlanguage of interest now, however, we need to extend this approach, because the language includes dynamic \nallocation of general refer\u00adences. Following earlier work on the semantics of dynamic allo\u00adcation of \nsimple integer cells [14, 32, 40, 48], we use an exten\u00adsion with Kripke-style possible worlds. In this \nextension, a type is interpreted as a predicate on values parameterized over worlds, and a world describes \nthe type for each allocated location a world w . W is a .nite map from locations (modelled as natural \nnum\u00adbers) to semantic types in T. The extension is described by the following recursive equations on \nthe set W of worlds and the set T of semantic types: V = set of values, including locations (1) W = N \n..n TT = W .mon Pred(V) Note that in the equation for T, we impose a monotonicity require\u00adment (with \nrespect to an extension ordering of worlds). Intuitively, this requirement means that validity of semantic \ntypes is preserved in presence of a growing heap. The formal meaning of the mono\u00adtonicity will be explained \nlater in Section 2.2. Once we are given the semantic domains W and T satisfying the above equations, \nwe can interpret types as elements in T. In particular, the meaning of a reference type ref T can be \nde.ned one [44]. Please see the appendix of the long version of the paper for this model. roughly as \n(ref T)w = {I | w(I)= T}, i.e., for a world w, it is the set of locations I such that the semantic type \nrecorded in the world at I is the same as T.2 Observe that the natural model of types here is a Kripke \nmodel over a recursively-de.ned set of worlds. It is a Kripke model be\u00adcause the semantic types are parameterized \nover W. The problem is, of course, that for cardinality reasons there are no solutions to the above equations \nin the category of sets; unfolding the above equations we get W = N ..n (W .mon Pred(V)) with W in a \nnegative position, see also Ahmed [2]. To address this cardinality issue, existing methods based on step \nindexing, including the recent work by Hobor et al. [30], propose that we should give up solving the \noriginal recursive equations and instead solve approximate versions. As Hobor et al. show, solutions \nof the approximate equations are often suf.cient for the applications of interest. In this paper, we \nfollow a different approach, which involves .nding an appropriate simple category of metric spaces and \nsolving the original recursive equations in the category. This approach has been developed in the setting \nof denotational semantics and domain theory. We show that the same approach can also be applied to operational \nsemantics and step indexing. In the next subsections, we explain this point by giving a Kripke model \nof ML references, .rst using domain-theoretic methods, and then step indexing. 2.1 Review of Metric \nSpaces Before describing our Kripke models, we review basic facts on the metric spaces, which will be \nused in the models; see, e.g., [47] for a thorough exposition. A 1-bounded ultrametric space (X, d) is \na metric space where the distance function d : X \u00d7 X . R takes values in the closed interval [0, 1] and \nsatis.es the strong triangle inequality d(x, y) = max{d(x, z),d(z, y)}. An (ultra)metric space is complete \nif every Cauchy sequence has a limit. A function ( : X1 . X2 between metric spaces (X1,d1) and (X2,d2) \nis non-expansive if d2(((x),((y)) = d1(x, y) for all x, y . X1. It is contractive if there exists some \n<< 1 such that d2(((x),((y)) = < \u00b7 d1(x, y) for all x, y . X1. The complete, 1-bounded, non-empty, ultrametric \nspaces and non-expansive functions between them form a Cartesian closed category CBUltne. Products are \ngiven by the set-theoretic prod\u00aduct where the distance is the maximum of the componentwise dis\u00adtances. \nThe exponential (X1,d1) . (X2,d2) has the set of non\u00adexpansive functions from (X1,d1) to (X2,d2) as underlying \nset, and distance function: dx1.x2 ((,g) = sup{d2(((x),g(x)) |x . X1}. For any set S and space (X, d) \n. CBUltne, the set of .nite partial functions S..n X from S to X is again a com\u00adplete, 1-bounded ultrametric \nspace with distance function given by d((,g)=1, if the domains of ( and g are not equal, and d((,g) = \nmax{d(((s),g(s)) | s . dom(()}, if the domains of ( and g are equal. A functor F : CBUltop \u00d7CBUltne -. \nCBUltne is locally non\u00ad ne expansive if d(F((, g),F((' ,g ' )) = max{d((,(' ),d(g, g ' )} for all non-expansive \n(, (' ,g, g '. It is locally contractive if there exists << 1 such that d(F((,g),F((' ,g ' )) = <\u00b7max{d((,(' \n),d(g, g ' )}for all non-expansive (, (' ,g, g '. By multiplication of the distances of (X, d) with a \nnon-negative shrinking factor << 1, one obtains a new ultrametric space, < \u00b7 (X, d)=(X, d ' ) where d \n' (x, y)= 2 In both of the concrete models to be presented next, the interpretation of reference types \nis actually more complicated and involves certain ap\u00adproximate equality relations on semantic types. \nThis is fairly standard for step-indexed models; that it is also required in the domain-theoretic setup \nis discussed by Birkedal et al. [21].  < \u00b7 d(x, y). By shrinking, a locally non-expansive functor F \nyields a locally contractive functor (< \u00b7 F )(X1,X2)= < \u00b7 (F (X1,X2)). It is well-known that one can \nsolve recursive domain equations in CBUltne by an adaptation of the inverse-limit method from classical \ndomain theory: Theorem 2.1 (America-Rutten [9]). Let F : CBUltop . ne \u00d7CBUltne CBUltne be a locally contractive \nfunctor. Then there exists a unique (up to isomorphism) (X, d) . CBUltne such that (X, d) ~ = F ((X, \nd), (X, d)). All the metric spaces we consider satisfy the following property: De.nition 2.2. A metric \nspace is bisected if all non-zero distances are of the form 2-n for some natural number n = 0. The following \nnotation is convenient when working with bi\u00ad n sected metric spaces: in such a space, x = y means that \nd(x, y) = 2-n. We use two facts on n= =. First, each relation nis an equiva\u00adlence relation because of \nthe ultrametric inequality. We are there\u00adfore justi.ed in referring to the relation n = as n-equality. \nSecond, the distance of a bisected metric space is bounded by 1. In other 0 words, the relation x = y \nalways holds. Proposition 2.3. Let (X1,d1) and (X2,d2) be bisected metric spaces. A function ( : X1 . \nX2 is non-expansive if and only nn '' ' if x1 = x1 . ((x1)= ((x1) holds for all x1,x 1 . X1 and all natural \nnumbers n = 0.  2.2 General Recipe and Domain-Theoretic Model We now follow the idea outlined earlier \nand reformulate the recur\u00adsive equations (1) in CBUltne to .nd solutions within this category. Concretely, \nthe proposal suggests to use the recipe below: 1. De.ne a set V with a structure. The structure can be \na pre\u00adorder, or a uniform complete partial order, but does not have to be. Intuitively, V is a domain \nfor semantic values. 2. De.ne an object Pred(V ) in CBUltne. Elements in this object represent predicates \non values. 3. Solve the recursive domain equation below in CBUltne:  ~1 T = 2 \u00b7 ((N ..n T ) .mon Pred(V \n)) . (2) 4. De.ne T and W using T : W = N..n T, T = W .mon Pred(V ). (3) The function space in the equivalence \nin the third step consists of non-expansive and monotone functions, where monotonicity is imposed with \nrespect to the following extension order on N ..n T : For w, w ' . N ..n T , we have w . w ' iff the \ndomain of w is included in the domain of w ', and w and w ' agree on the former. The 12 is an example \nof a shrinking factor and, technically, ensures that the functor is locally contractive; it is a standard \ntechnique [9]. The equivalence is well-formed in CBUltne, and it has a unique solution up to isomorphism \nby Theorem 2.1. The recipe has been used by Birkedal, St\u00f8vring and Thams\u00adborg [21], when they gave a \nrelationally-parametric domain\u00adtheoretic model of a call-by-value language with impredicative polymorphism, \ngeneral references and recursive types. They con\u00adstructed the parameters V and Pred(V ) of the recipe \nusing domain theory, choosing for V the cpo of values that is used in the standard untyped domain-theoretic \ninterpretation of the language. This domain V comes with a family of projections 7n : V . V. satis\u00adfying \ncertain properties (so it becomes a uniform cpo). For the next parameter Pred(V ), Birkedal et al. used \nthese projections to de.ne Pred(V ) as the collection of complete uniform subsets of V . Com\u00adpleteness \nsays that a subset P is closed under least upper bounds of chains, and uniformity that P is closed under \nall the projections (i.e., .v . P. .n> 0.7n(v) . P.). The set Pred(V ) can be viewed as a metric space \nin CBUltne, by giving it an appropriate distance function along the lines of earlier work on interpreting \nrecursive types and impredicative polymorphism [1, 7, 8, 23, 33]. Now, by simply following the recipe \nfrom the given ingredients (i.e. parameters V and Pred(V )) one obtains metric spaces T for semantic \ntypes and W for possible worlds, respectively. With this indexed semantic model of types, Birkedal et \nal. gave an interpre\u00adtation of all the types of the programming language, and de.ned the typed meaning \nof expressions by proving the fundamental the\u00adorem of logical relations wrt. the untyped semantics of \nexpressions. See [21] for a detailed treatment.3  2.3 Step-Indexed Model Our new insight is that the \nrecipe presented in Section 2.2 is not tied to domain theory and denotational semantics, but it can also \nbe used with operational semantics. In this case, the .rst parameter of the recipe is the set Val of \nclosed syntactic values from the operational semantics. The second parameter is the set of predicates \non step\u00adapproximated values. Precisely, it is the collection UPred(Val) of subsets of N\u00d7 Val that are \ndownwards closed in the .rst step (N) component: UPred(Val)= {p . N\u00d7Val |.(k, v) . p. .j = k. (j, v) \n. p}. We call p . UPred(Val) a uniform predicate on Val. Note that we give a unary interpretation; in \nparticular the model does not prove any program equivalences. This is just for simplicity of presentation, \na relational, i.e., binary, model can be built along the same lines using UPred(Val \u00d7 Val). The idea \nof considering predicates on step-approximated val\u00adues is from step-indexed models [2, 4, 11, 12]. Here \nwe go a step further and show that the collection UPred(Val) of such predi\u00adcates can always be made into \nan object in CBUltne. To do this, for p . UPred(Val) and k . N, we use the notation p[k] = {(m, v) . \np | m<k}, representing the k-th approximation of p. With this notation, we de.ne a distance function \nd on UPred(Val), which measures up-to-what-level two predicates agree: { 2- max{k | P[k] =Q[k]} if p \n/ = q d(p, q)= 0 otherwise. Lemma 2.4. (UPred(Val),d) is a well-de.ned object in CBUltne. In fact, the \nconstruction in UPred(Val) does not depend on our choice of Val, and can be applied to any set X, giving \na metric space UPred(X) in CBUltne. Note that because of this lemma, we can consider uniform predicates \np . UPred(X) on any set X. Hence, the recipe in Section 2.2 is applicable for Val and UPred(Val), and \ngives rise to semantic domains T , W and T that satisfy the recursive equations in (2) and (3). Note \nthat by work\u00ading in CBUltne, we have solved the desired equations, even for a setting based on operational \nsemantics. In the rest of this section, we use these domains and model the programming language with \nimpredicative polymorphism and ML references. For concreteness, we consider a language as in Dreyer et \nal. [27], except that we do not consider recursive types and we split the context for type variables \nand term variables in two. Term 3 Notice that we use a small trick to construct the space of worlds W \nusing Theorem 2.1. By solving the equation (2) we .rst obtain the space of semantic types, and we then \nde.ne worlds in terms of semantic types. It is also possible to obtain W directly, as a solution of a \nrecursive equation in a category of pre-ordered ultrametric spaces [20]. The latter technique is more \ngeneral, but for this paper we do not need such pre-ordered spaces.  [. . T]1 : W .mon UPred(Val) [. \n. 1]1w = {(k, ()) | k . N} k [. . ref T]1w = {(k, l) | l . dom(w) . w(l)= [. . T]1} [. . a]1w = '(a)(w) \n[. ..a.T]1w = {(k, v) |.T ' . SyntacticType. .r . T. .w ' . w. w ' .i = k. (i, v[T ' ]) .E[ .,a . T] \n1[c .r]} [. . T . T '] w = {(k, v) |.v ' . Val. .w ' . w. .i = k. 1 w ' (i, v ' ) . [. . T]1. (i,v v \n' ) .E[[. . T ' ] 1w ' } E[ . . T] 1w = {(k, t) |.i = k. .h, h ' . .e ' . (h :k w . (t | h) -.i (e ' \n| h ' ) . (e ' ,h ' ) irreducible) . (.w ' . w. h ' :k-i w ' . (k - i, e ' ) . [. . T]1w ')} h :k w \n.. dom(h) = dom(w) . .i< k. .l . dom(w). (i, h(l)) . w(l)(w) (where () is the unique element in the empty \nproduct, SyntacticType is the set of syntactic types, Exp is the set of closed syntactic expressions, \nand (t | h) is a con.guration of an expression t and a heap h. A heap h is a .nite function from locations \nto closed syntactic values.) Figure 1. Interpretation of types judgments take the form .; G; S . M : \nT where . is a context of type variables a1,...,an; G is a context of typed term variables x1 : T1,...,xm \n: Tm; and S is a context of typed locations I1 : T1,...,Ik : Tk. Detailed typing judgments and operational \nsemantics can be found in the online appendix to Dreyer et al. Types in this language are interpreted \nsimilar to those used in existing step-indexed models [2], but one can exploit the fact that W and T \nare solutions to the recursive equations above. The semantics of types in context is de.ned as a non-expansive \nfunction T |.| : . T [. . T] in CBUltne. The de.nition is shown in Figure 1. In the .gure, we use T for \nenvironments for ., i.e., elements in the product space T |.| in CBUltne. Notice that in the case for \n[. . ref T], we use k-equality in the space T and that E[[. . T] generalizes [. . T ]from values to expressions. \nLemma 2.5. [. . T] is well-de.ned. In particular, \u00b7 for all T . T |.|, [. . T]1 is non-expansive and \nmonotone; and \u00b7 [. . T ] is a non-expansive map on T s.  In Figure 2 we de.ne interpretations of contexts \nand the log\u00adical relation interpretation of well-typed expressions. Using those de.nitions, we are ready \nto prove the main soundness result: Theorem 2.6 (Fundamental Theorem of Logical Relations). If .; G; \nS . t : T , then .; G; S . t :log T. One oddity is worth explaining: there is no coherence between the \nsyntactic types that we substitute for type variables and the corresponding semantic types in the environment; \nthis is the case both for the interpretation of universal types and in the de.nition of the logical relation. \nThe explanation is simply that the syntactic types in values and expressions do not in.uence the computation; \nindeed, we could equally well have worked with a language without type-decorations as, e.g., Ahmed [3] \ndoes. [. . G]1 : W . UPred(Val|G|) [. .\u00d8]1w = {(k, ()) | k . N} [. . G,x : T]1w = {(k, p[x . v]) | (k, \np) . [. . G]1w . (k, v) . [. . T]1w} [S] : UPred(W ) [S] = {(k, w) |.(l : T) . S. (k, l) . [\u00d8. ref T]()w} \nlog T .; G; S . t :.. .a1,...,an. .= a1,...,an . .T1,...,Tn . SyntacticType. .k = 0. .'. .p. .w. ( ) \n' . T|.| . (k, p) . [. . G]1w . (k, w) . [S] ( ) . (k, (p(t))[a1:=T1,...,an:=Tn]) .E[[. . T] 1w (where \n() is the unique environment for the empty context, and both (-)[a1:=T1,...,an:=Tn] and p(-) represent \nthe applications of sub\u00adstitutions.) Figure 2. Interpretation of contexts and well-typed expressions \nWe .nally remark that it is not surprising that there is a con\u00adnection between metric spaces and step-indexed \nmodels; this was already pointed out in [11]. The point is that it is useful not to for\u00adget this connection \nbecause it, e.g., allows us to de.ne solutions to recursive world equations such as the ones in this \nsection. (See also the discussion in Section 4.2.) We do not present a formal relationship to existing \nmodels for this particular example, but rather show, in Section 4, how all the step-indexed models described \nvia the indirection theory of Hobor et al. [30] can be obtained by a specialization of our general approach. \nIn Section 4.2, we will also highlight the advantages of using metric spaces. Next, however, we consider \nanother more substantial application to illustrate our method. 3. Application: A Step-indexed Model of \nCapabilities Reasoning about higher-order stateful programs is notoriously dif\u00ad.cult, and often involves \nthe need to track aliasing information. A particular line of work that has been proposed to this end \nare substructural type systems with regions, capabilities and singleton types [5, 24, 26]. In this section, \nwe give a step-indexed model for a substantial fragment4 of Chargu\u00b4eraud and Pottier s capability cal\u00adculus \n[24]. Our model provides an alternative soundness proof to the translation and progress and preservation \nresults in [24, 38], and allows for the analysis of soundness of extensions. We illustrate this latter \npoint by proving sound an extension of the language with higher-order frame rules [19, 44], and establish \nan explicit connec\u00adtion with models of separation logic qua our model, which shows that capabilities \ncan be understood semantically as separation logic predicates, i.e., as predicates on heaps. We believe \nthat this step-indexed model provides an interesting application of the metric point of view that has \nbeen emphasized in the previous section. The model construction takes advantage of the fact that the \nrecursive world equation can be solved (up to isomorphism), rather than merely approximated: the higher-order \nframe rules are modelled with the help of a recursive operation on worlds, and this operation is de.ned \nusing the metric structure. 4 We do not consider group regions.  v ::= x | () | inji v | (v1,v2) | J(.Ax.t \n| I t ::= v | (vt) | case(v1,v2,v) | proji v | ref v | get v | set v Figure 3. Syntax of values and expressions \n(J(.Ax.t) v | h -. t[( := J(.Ax.t, x := v] | h proji(v1,v2) | h -. vi | h for i =1, 2 case(v1,v2, inji \nv) | h -. vi v | h for i =1, 2 ref v | h -. I | h\u00b7[I . v] if I/. dom h get I | h -. h(I) | h if I . dom \nh set (I, v) | h -. () | h[I := v] if I . dom h '' '' vt | h -. vt | h if t | h -. t | h Figure 4. Operational \nsemantics While we do not model the anti-frame rule [38] here, the ap\u00adproach does scale to do that; this \nis demonstrated in recent work by Schwinghammer, Birkedal and St\u00f8vring [45]. 3.1 A Calculus of Capabilities \nIn the following presentation, we keep close to the notation of Chargu\u00b4 eraud and Pottier [24, 38]. Figures \n3 and 4 give the syntax and operational semantics of the programming language that we consider. It is \na standard call-by-value, higher-order language with general references, and polymorphic and recursive \ntypes. The only noteworthy point about the syntax is that expressions are restricted so that all sequencing \nis made explicit; this simpli.es the presenta\u00adtion of the typing rules and semantics but is no real restriction. \nThe term J(.Ax.t stands for the recursive procedure ( with body t and argument x. If ( does not appear \nin t, we may simply write Ax.t. The operational semantics is de.ned between con.gurations (t | h) that \nconsist of a (closed) expression t and a heap h. As in the previous section, a heap h is a .nite map \nfrom locations to closed values. Also, we remind the reader of our notation t[x:=v] that means the substitution \nof v for x in t. We use the notation h#h ' to indicate that two heaps h and h ' have disjoint domains, \nand we write h \u00b7 h ' for the union of two such heaps. The types used in the system are given by the grammar \nin Figure 5. Capabilities C describe heap properties (much like the assertions of a Hoare-style program \nlogic), value types T classify values, and memory types e (and the subset of computation types) describe \nproperties of expressions and how their evaluation affects the heap. Because of the heap dependency, \ncapabilities and memory types are linear, and correspondingly there is a distinction between value type \nenvironments and the more general linear environments. A region e is a static name that represents a \nvalue, and [e] is a singleton type that contains only this particular value. Capabil\u00adities are formed \nfrom singleton capabilities {e : e} by separat\u00ading conjunction and existential quanti.cation over regions. \nWe also include capability variables I and permit recursively de.ned ca\u00adpabilities. A singleton capability \n{e : e} asserts that the value denoted by e has type e, and moreover it represents the owner\u00adship of \nboth this value and the fragment of the heap described by e. Thus, it is similar to the points-to predicate \nof separation logic: for example, the capability {e : ref T} means that e denotes the address of a reference \ncell, and that the owned part of the heap stores a value of type T at this address. Apart from singleton \ntypes, the value types include base types (here an empty type 0, the unit type 1, and int) and are closed \nunder products, sums, and universal quanti.cation over singletons, types and capabilities. The memory \ntypes extend value types by a type of references, and by the pos\u00adsibility to *-conjoin a capability. \nLike the pre-and postconditions used in Hoare logic, the arrow types make explicit which part of the \nheap is accessed when a procedure is called. For instance, the type .e,e ' . [e] *{e : ref [e ' ]}. [e \n' ] *{e : ref [e ' ]} can be given to a procedure that dereferences its argument. Recursive capabilities \nand types are subject to a syntactic re\u00adstriction: C must be formally contractive in I for JI.C to be \nwell\u00adformed. By this we mean that the recursion must go through one of the type constructors +, \u00d7, . \nor ref, or through the right-hand side of .. This restriction ensures that the capability JI.C is the \nunique solution of the capability equation I = C. Corresponding restric\u00adtions apply to recursively de.ned \ntypes Ja.T and Jf.e. We omit the straightforward inductive de.nition of formal contractiveness. One interesting \naspect of the type system is that each of the syntactic categories is equipped with an invariant extension \noper\u00adation, \u00b7. C. Intuitively, this operation conjoins C to the domain and codomain of every arrow type \nthat occurs within its left hand argument, which means that the capability C is preserved by all functions \nof this type. This intuition is made precise by regarding capabilities and types modulo the structural \nequivalence given in Figure 6. This equivalence subsumes the distribution axioms for . that are used \nto express generic higher-order frame rules [19]. The .rst two groups of equations, equivalences (4) \n(11), state that both * and the derived operation \u00b0 on capabilities satisfy the ax\u00adioms of a monoid, \nand that * and . are actions of these monoids. Equivalences (15) (30) describe the action by . on types. \nIn par\u00adticular, (25) shows the key case of the invariant extension described informally above.5 Finally, \nthe equivalences (34) (38) for focusing let us build and deconstruct the capabilities over complex types \nin terms of capabilities over more primitive types. The system also uses a subtyping relation, and Figure \n7 gives some of the subtyping axioms. The typing rules are shown in Figure 8. Due to the use of linear \nenvironments and computation types (which in general contain embedded capabilities), the typing judgement \nG . t : X is similar to a Hoare triple where G serves as a precondition and X as a postcondition. This \nview explains the rules SHALLOW-FRAME and DEEP-FRAME; as in separation logic, these rules can be used \nto add an invariant C to a speci.cation. The difference between SHALLOW-FRAME and DEEP-FRAME is that \nthe former adds C only on the top-level, whereas the latter also extends all arrow types nested inside \nG and X, via \u00b7. C. As with the higher-order frame rules in separation logic, this is useful for reasoning \nabout information hiding [19].  3.2 Upwards Closed Uniform Predicates and Worlds The main idea of the \nmodel that we present next is that types (as well as type contexts and capabilities) are parameterized \nby invariants. Thus, in this case the worlds will be predicates that, like the syntactic capabilities \nof the calculus, describe properties of the heap that all computations must preserve. Recall that the \nset UPred(X) of uniform predicates on a set X is de.ned by UPred(X)= {p . N\u00d7 X |.(k, v) . p. .j = k. \n(j, v) . p}. The interpretation of types and capabilities is based on a variation on these uniform predicates. \nLet (A, .) be a partially ordered set. An upwards closed uniform predicate p on A is a predicate in UPred(A) \nthat is also upward closed in the second argument, i.e. if (k, a) . p and a . b then (k, b) . p. We write \nUPred.(A) for 5 Note that (13) and (14) let us move capabilities between assumptions a form of ownership \ntransfer.  Variables U ::= a | f | I | e Capabilities C ::= C . C |\u00d8| C * C |{e : e}|.e.C | I | JI.C \n|.U.C Value types T ::= T . C | 0 | 1 | int | T + T | T \u00d7 T | X . X | [e] | a | Ja.T |.U.T Memory types \ne ::= e . C | T | e + e | e \u00d7 e | ref e | e * C |.e.e | f | Jf.e |.U.e Computation types X ::= X . C \n| T | X * C |.e.X Value environments . ::= . . C | \u00d8 | .,x:T Linear environments G ::= G . C | \u00d8 | G,x:X \n| G * C Figure 5. Capabilities and types VAR UNIT INJ PAIR RECFUN (x : T ) . . . . v : Ti . . v1 : T1 \n. . v2 : T2 ., ( : X1 . X2, x : X1 . t : X2 . . x : T . . () : 1 . . (inji v) : (T1+T2) . . (v1, v2) \n: (T1 \u00d7 T2) . . J(.Ax.t : X1 . X2 VAL APP PROJ-1 PROJ-2 . . v : T . . v : T . . v : X1 . X2 ., G . t \n: X1 ., G . (v t) : X2 G . v : [e] * {e : T1 \u00d7 e2} G . proj1 v : T1 * {e : T1 \u00d7 e2} G . v : [e] * {e \n: e1 \u00d7 T2} G . proj2 v : T2 * {e : e1 \u00d7 T2} CASE . . v1 : (.e1.[e1] * {e : [e1] + 0} * {e1 : e1} * C) \n. X . . v2 : (.e2.[e2] * {e : 0 + [e2]} * {e2 : e2} * C) . X ., G . v : [e] * {e : e1 + e2} * C ., G \n. case(v1, v2, v) : X .-INTRO . . v : T . . v : .U.T U/. . .-ELIM-1 . . v : .a.T . . v : T [a := T ' \n] REF GET SET G . v : T G . v :[e] *{e : ref T } G . v : ([e] \u00d7 T2) *{e : ref T1}G . ref v : .e.[e] \n*{e : ref T} G . get v : T *{e : ref T } G . set v :1 *{e : ref T2} SHALLOW-FRAME DEEP-FRAME SUB G . \nt : X G . t : X G . t : X1 X1 = X2 G * C . t : X * C (G . C) * C . t :(X . C) * C G . t : X2 Figure 8. \nTyping of values and expressions the set of all upwards closed uniform predicates on A, and de.ne p[k] \n= {(j, a) . p | j<k}. As in Section 2.3 on UPred(V ), this restricts p to pairs with .rst component less \nthan k. Note that p[k] is again upwards closed and uniform, so it belongs to UPred.(A) as well. We equip \nUPred.(A) with the same distance function d as UPred(A) in Section 2.3. This makes (UPred.(A),d) an object \nof CBUltne. In our model, we use UPred.(A) with the following concrete instances for the partial order \n(A, .): \u00b7 (Heap, .) where h . h ' iff h ' = h \u00b7 h0 for some h0#h, \u00b7 (Val, .) where u . v iff u = v, \n \u00b7 (Val \u00d7 Heap, .) where (u, h) . (v, h ' ) iff u = v and h . h ' .  separating conjunction and separating \nimplication are given by '' ' (k, h) . p . q ..j = k. .h . h. (j, h ) . p . (j, h ) . q (k, h) . p1 * \np2 ..h1,h2.h = h1\u00b7h2 . (k, hi) . pi '' ' (k, h) . p -* q ..j = k. .h #h. (j, h ) . p . (j, h\u00b7h ) . q \nThe unit for * is given by I = N\u00d7 Heap = .. Up to the natural number indexing, this is just the standard \nintuitionistic (in the sense that it is not tight ) model of separation logic [43]. Since the worlds \nare to represent invariants (for instance, de\u00adscribing the shape of data structures laid out in the heap) \nand since the language of Section 3.1 has general references (so these in\u00advariants talk about stored \nprocedures and are themselves world\u00addependent), it is natural that worlds w . W must also double\u00adact \nas functions W . UPred.(Heap). Consequently, we solve in CBUltne the following recursive world equation: \n~1 W = 2 \u00b7 W . UPred.(Heap) . (46) Here, the function space is that of CBUltne and the 1/2 denotes As \nin Section 2.3, Val is the set of closed values of the language, see Figure 3. We also use variants of \nthe latter two instances where the set Val is replaced by the set of value substitutions, Env, and by \nthe set of expressions, Exp. On UPred.(Heap), ordered by subset inclusion, we have a com\u00adplete Heyting \nBI algebra structure [17]. Meets and joins are given by set-theoretic intersections and unions, resp., \nand implication, the scaling of the distance function on W . That W exists (and is uniquely determined \nup to isomorphism) follows from Theo\u00adrem 2.1, applied to the locally contractive functor F (X, Y)= 1 \n\u00b7 X . UPred.(Heap) on CBUltne. Worlds are thus essentially 2 contractive functions from worlds to UPred.(Heap), \ni.e. world de\u00adpendent heap predicates. We de.ne Cap = 21 \u00b7 W . UPred.(Heap),  monoids monoid actions \n01 \u00b0 02 def = (01 . 02) * 02 (4) (01 \u00b0 02) \u00b0 03 = 01 \u00b0 (02 \u00b0 03) (5) 0 \u00b0 \u00d8 = 0 (6) (01 * 02) * 03 = 01 \n* (02 * 03) (7) 0 * \u00d8 = 0 (8) 01 * 02 = 02 * 01 (9) (\u00b7. 01) . 02 = \u00b7. (01 \u00b0 02) \u00b7.\u00d8 = \u00b7 (10) (\u00b7* 01) \n* 02 = \u00b7* (01 * 02) \u00b7*\u00d8 = \u00b7 (11) action by * on singleton {a : B}* 0 = {a : B * 0} (12) action by * on \nlinear environments (G,x:X) * 0 =G,x:(X * 0) (13) = (G * 0),x:X (14) action by . on capabilities, types, \nand environments (\u00b7*\u00b7) . 0 =(\u00b7. 0) * (\u00b7. 0) (15) (.a.\u00b7) . 0 = .a.(\u00b7. 0) if a/. RegNames(0) (16) \u00d8. 0 \n= \u00d8 (17) {a : B}. 0 = {a : B . 0} (18) 0 . 0 =0 (19) 1 . 0 =1 (20) int . 0 = int (21) (B1 + B2) . 0 =(B1 \n. 0)+(B2 . 0) (22) (B1 \u00d7 B2) . 0 =(B1 . 0) \u00d7 (B2 . 0) (23) (.e.B) . 0 = .e.(B . 0) if e/. fv 0 (24) (X1 \n. X2) . 0 =(X1 \u00b0 0) . (X2 \u00b0 0) (25) [a] . 0 =[a] (26) (ref B) . 0 = ref (B . 0) (27) \u00d8. 0 = \u00d8 (28) (G,x:X) \n. 0 = (G . 0),x:(X . 0) (29) (G * 01) . 02 = (G . 02) * (01 . 02) (30) region abstraction focusing recursion \n.a1..a2.\u00b7 = .a2..a1.\u00b7 (31) \u00b7* (.a.0)= .a.(\u00b7* 0) (32) {a1 : .a2.B} = .a2.{a1 : B} where a1 /= a2 (33) \n{a1 : ref B} = .a2.{a1 : ref [a2]}*{a2 : B} (34) {a : B1 \u00d7 B2} = .a1.{a :[a1] \u00d7 B2}*{a1 : B1} (35) {a \n: B1 \u00d7 B2} = .a2.{a : B1 \u00d7 [a2]}*{a2 : B2} (36)  {a : B1 +0} = .a1.{a :[a1]+0}*{a1 : B1} (37) {a :0+ \nB2} = .a2.{a :0+[a2]}*{a2 : B2} (38)  ji.0 = 0[i:=ji.0] (39) ja.T = T[a:=ja.T] (40) j!.B = B[!:=j!.B] \n(41) Figure 6. Structural equivalence (.rst-order) frame axiom X1 . X2 = (X1 * C) . (X2 * C) (42) free \nC1 * C2 = C1 (43) singletons T = .e.[e] * {e : T } [e] * {e : T} = T * {e : T} (44) (45)  Figure 7. \nSome subtyping axioms and write [ : Cap . W for the isomorphism in (46), and [-1 for its inverse. By \nordering the elements of Cap pointwise, p = q ..w. p(w) . q(w), we can lift the algebra structure on \nUPred.(Heap). Lemma 3.1. With the above ordering and the pointwise lifting of the algebra operations \non UPred.(Heap), the set Cap is a complete Heyting BI algebra. The fact that Cap is a complete BI algebra \nimmediately gives us a sound interpretation of * on capabilities. (Moreover, it suggests that the syntax \nof capabilities could be extended with all the logical connectives of separation logic.) However, to \ninterpret recursive capabilities we also need to know that the operations are non\u00adexpansive: Lemma 3.2. \nThe BI algebra operations on Cap are non-expansive functions, i.e., they are morphisms in CBUltne: ., \n., ., *, -* : Cap \u00d7 Cap . Cap .. I, I :(I . Cap) . Cap (For the last two operations, the indexing set \nI is given the discrete metric, i.e., the distance of any two different elements is 1.) Proof sketch. \nOne can .rst show the corresponding property for the operations on UPred.(Heap) which is straightforward; \nthe re\u00adsult then follows from the pointwise de.nition and the use of the sup-metric on Cap. To illustrate \nthe non-expansiveness on UPred.(Heap), we consider the case of separating conjunction: It nn n '' '' \nsuf.ces to show that p = p and q = q implies p * q = p * q . n By de.nition of the n-equality, p * q \n= p ' * q ' is equivalent to (j, h) . p * q . (j, h) . p ' * q ' for all j<n, which follows nn easily \nfrom the assumptions that p = p ' and q = q ' . Next, we de.ne a composition operation on the worlds \nW . This operation plays a role similar to the ordering by extension in the case where worlds are .nite \nmaps from locations to semantic types (cf. Section 2). However, it is more involved than a simple extension \nof worlds; rather, it corresponds to the syntactic abbrevi\u00adation C1 \u00b0 C2 = C1 . C2 * C2 from Figure 6, \nof conjoining C1 and C2 and additionally applying an invariant extension \u00b7. C2 to C1. Formally, \u00b0 : W \n\u00d7 W . W is a non-expansive operation that for all p, r,w . W satis.es -1-1-1 [(p \u00b0 r)(w)= [(p)(r \u00b0 w) \n* [(r)(w) . Using the metric-space setup, we can de.ne this operation by an easy application of Banach \ns .xed point theorem, as in [44]. Observe that it is here where we exploit that we have obtained a proper \nsolution to the world equation (46) in CBUltne. We write emp for the image [(Aw.I) of the BI unit under \n[. Then it turns out that \u00b0 is associative and p \u00b0 emp = emp \u00b0 p = p holds for all p, so (W, \u00b0, emp) \nis a monoid in CBUltne. Now let (X, d) be an arbitrary ultrametric space. Using the composition operator \non worlds, we consider a semantic analogue of the invariant extension on the right-hand side refers \nto the value type interpretation. Note \u00b7W) \u00d7 W . X( 1 2 \u00b7W) de.ned by that the computation types X form \na subset of the memory types, operation, . : X( and thus obtain their interpretation in MT. (( . w0)(w)= \n((w0 \u00b0 w) . Let Env denote the .nite maps from variables to closed val\u00adues. Duplicable (heap-independent) \nenvironments are interpreted as contractive maps from W to UPred.(Env). Linear environments The following \nproposition is a slight generalization of [44, Lemma 5], and summarizes the key properties of \u00b0 and .. \nIn the following, these properties are used to justify some of the equivalences given are modelled as \ncontractive maps from W to UPred.(Env\u00d7Heap). in Figure 6. Conceptually, each of the entries in a linear \nenvironment owns a part of the heap, disjoint from that of the other entries. Proposition 3.3 (Monoid \nand monoid action). Let (X, d) be an With the exception of arrow types, the semantics of value types \nultrametric space. Then (W, \u00b0, emp) is a monoid in CBUltne, and deserves little explanation; in all cases, \nthe world is simply passed the operation . : X( 1 2 \u00b7W) \u00d7 W . X( 1 2 \u00b7W) is a (non-expansive) on, and \nthe index is decreased (whenever justi.ed by the opera\u00adaction of the monoid W on the ultrametric space \nof non-expansive tional semantics) to ensure that type constructors become contrac\u00adfunctions from 12 \n\u00b7 W to X, i.e., ( .emp = ( and (( .w1).w2 = tive. The de.nition of arrow types is more intricate, and \nuses the ( . (w1 \u00b0 w2).  3.3 Semantic Domains and Interpretation In this section we give the interpretation \nof the capabilities, types and environments of the type system. The semantic domain corre\u00adsponding to \neach syntactic category is a set of (contractively world\u00addependent) upwards closed and uniform predicates: \nVT = 12 \u00b7 W . UPred.(Val) MT = 12 \u00b7 W . UPred.(Val \u00d7 Heap) . In particular, in each case there is an \naction of W by the operation ., as described in Proposition 3.3. Note that Cap = 12 \u00b7 W . UPred.(Heap) \nacts on itself, via the isomorphism [ between W and Cap. This operation plays a key role in explaining \nthe higher\u00adorder frame (and also anti-frame) inference rules and the associated distribution axioms [44, \n46]. Moreover, due to the shrinking factor < = 12 , this action is contractive in its right-hand side: \nfor all p, r . Cap, the assignment r . p.[(r) is a contractive endomap on Cap. This observation explains \nwhy the (syntactic) invariant extension can be assumed formally contractive in its second argument. We \nalso consider a further overloading of the separating con\u00adjunction. It is the below generalization S \n* q to sets of the form S . UPred.(A \u00d7 Heap) and q . UPred.(Heap): S * q = {(k, (a, h \u00b7 h ' )) | (k, \n(a, h)) . S . (k, h ' ) . q . h#h ' }. As for the separating conjunction on UPred.(Heap), this operation \ncan be lifted pointwise to give a non-expansive operation on S . 1 2 \u00b7 W . UPred.(A \u00d7 Heap) and r . Cap, \n(S * r)(w)= S(w) * r(w) . (47) This provides a second monoid action, with respect to the monoid structure \ngiven by the separating conjunction on Cap. Proposition 3.4 (Monoid and monoid action). (Cap, *,I) is \na commutative monoid, and for any (pre-ordered) set A the operation in (47) is an action of this monoid \non the space of non-expansive functions from 21 \u00b7 W to UPred.(A \u00d7 Heap), i.e., S * I = S and (S * p) \n* q = S * (p * q). The interpretation of capabilities and types is given in Figure 9. This interpretation \ndepends on an environment T, which maps re\u00adgion names e . RegName to closed values T(e) . Val, capability \nvariables I to semantic capabilities T(I) . Cap, and type vari\u00adables a and f to semantic types T(a) . \nVT and T(f) . MT. As indicated above, the semantics of capabilities is de.ned in terms of the BI structure \non Cap. The semantics of memory types uses the action of Cap on MT described in (47). It also makes explicit \nthe aliasing information contained in memory types: for instance, the two components of a pair of type \ne1 \u00d7 e2 cannot overlap in the heap (a similar exclusion of sharing holds for referenced cells). In the \ninterpretation of a value type T considered as memory type, [T ] following extension of memory types \nfrom values to expressions. De.nition 3.5. Let S . MT. Then the function E(S): W . UPred.(Exp \u00d7 Heap) \nis de.ned by (k, (t, h)) .E(S)(w) iff '' '''' .j = k,t ,h . (t | h) -.j (t | h ) . (t | h ) irreducible \n'' -1 . (k - j, (t ,h )) . S(w) * [(w)(emp) . Note that there is no scaling by 12 , i.e., E(S) is a non-expansive, \nbut not a contractive, function of worlds. However, we do have a form of contractiveness on non-values: \nLemma 3.6. For all S1,S2 . MT, expressions t and h . Heap, if nn w1 = w2 in W , S1 = S2 and t/. Val, \nthen for all k = n, (k, (t, h)) .E(S1)(w1) . (k, (t, h)) .E(S2)(w2) . n n Proof. Let w1 = w2, and observe \nthat this implies S1(w1)= n [-1 S2(w2) and [-1(w1)(emp)= (w2)(emp). Now assume that (k, (t, h)) .E(S1)(w1) \nfor some k = n. We must show that (k, (t, h)) .E(S2)(w2). For this, suppose that (t | h) -.j (t ' | h \n' ) for some j = k where (t ' | h ' ) is irreducible. The as\u00adsumption (k, (t, h)) .E(S1)(w1) yields (k \n- j, (t ' ,h ' )) . S1(w1) * [-1(w1)(emp). In particular, t ' . Val and therefore t /t ' . Val. Thus \nwe must have j> 0, = by the assumption that t/and therefore k - j<k = n which by the above observations \nmeans that (k - j, (t ' ,h ' )) . S2(w2) * [-1(w2)(emp). The direction from right to left is symmetric. \nWe now explain the ideas behind the de.nition of arrow types in Figure 9 in more detail. First, the basic \nidea of our Kripke style semantics is that invariants added by the context are collected in the worlds. \nThus, for a procedure application we realize this idea by interpreting the current world as a predicate \n[-1(w)(emp) on heaps, which is conjoined to the actual argument (computa\u00adtion) type [X1]1 (w), as well \nas to the result (computation) type (w) through the de.nition of E. Second, by additionally con\u00ad [X2]1 \njoining r as an invariant we bake in the .rst-order frame prop\u00aderty. Finally, the quanti.cation over \nindices j less than k achieves that [X1 . X2]1 w is in UPred.(Val). There are two explanations why we \nrequire that j be strictly less than k in the de.nition of [X1 . X2]. Technically, since [-1(w)(emp) \nis non-expansive but not contractive in w, we need the strict inequality to ensure the non\u00adexpansiveness \nof [X1 . X2] as a function 1 \u00b7 W . UPred.(Val). 2 Moreover, the smaller index allows us to prove the \ntyping rule for recursive functions, by induction on k. Intuitively, the use of j<k for the arguments \nsuf.ces since each procedure application con\u00adsumes a step. The .nal j +1 index on expressions in the \ninterpre\u00adtation of arrow types is justi.ed by the above Lemma. Proposition 3.7. The interpretation in \nFigure 9 is well-de.ned: all the [\u00b7] s map into the declared sets, and the recursive de.nitions of capabilities \nand types have unique solutions.  1 Capabilities, [0]1 : \u00b7 W . UPred.(Heap) 2 [01 . 02]1 w =([01]1 . \nL([02]1))w [\u00d8]1 w = N\u00d7 Heap [01 * 02]1 w =([01]1 * [02]1)w [{a : B}]1 w = {(k, h) | (k, ('(a),h)) . [B]1 \nw} . [.a.0]1 w = V.Val [0]1[<:=V] w [i]1 w = '(i)(w) [ji.0]1 w = .x(>r. [0]1[b:=r])w 1 Value types, [T]1 \n: \u00b7 W . UPred.(Val) 2 [T . 0]1 w =([T]1 . L([0]1))w [0]1 w = \u00d8 [1]1 w = N\u00d7{()} [int]1 w = N\u00d7{n | n . \nZ} [T1 + T2]1 w = {(k, inji v) | k> 0 . (k-1,v) . [Ti]1 w} [T1 \u00d7 T2]1 w = {(k, (v1,v2)) | k> 0 . (k-1,vi) \n. [Ti]1 w} [X1 . X2]1 w = {(k, v) |.j <k. .r . Cap. .(j, (v ' ,h)) . ([X1]1 * r)(w) *L-1(w)(emp). (j+1, \n(vv ' ,h)) .E([X2]1 * r)(w)} [[a]]1 w = N\u00d7{'(a)} [a]1 w = '(a)(w) [ja.T]1 w = .x(>S. [T]1[c:=S])w n [.a.T]1 \nw = a.VT [T]1[c:=a] w 1 Memory types, [B]1 : \u00b7 W . UPred.(Val \u00d7 Heap) 2 [B . 0]1 w =([B]1 . L([0]1)) \nw [T]1 w = {(k, (v, h)) | h . Heap, (k, v) . [T]1 w}  [B1 + B2]1 w = {(k, (injiv, h)) | k>0 . (k-1, \n(v, h)) . [Bi]1 w} [B1 \u00d7 B2]1 w = {(k, (v1,v2),h1\u00b7h2) | k>0 . (k-1, (vi,hi)). [Bi]1w} [ref B]1 w = {(k, \n(l, h\u00b7[l . v])) | k>0 . (k-1, (v, h)). [B]1w} [B * 0]1 w =([B]1 w) * ([0]1 w) . [.a.B]1 w = V.Val [B]1[<:=V] \nw [!]1 w = '(!)(w) [j!.B]1 w = .x(>S. [B]1[;:=S])w 1 Duplicable environments, [.]1 : \u00b7 W . UPred.(Env) \n2 [. . 0]1 w =([.]1 . L([0]1))w [\u00d8]1 w = N\u00d7{[]} [.,x:T]1 w = {(k, p[x . v]) | (k, p) . [.]1 w . (k, v) \n. [T]1 w} 1 Linear environments, [G]1 : \u00b7 W . UPred.(Env \u00d7 Heap) 2 [G . 0]1 w =([G]1 . L([0]1))w [\u00d8]1 \nw = N\u00d7 ({[]}\u00d7 Heap) [G,x:X]1 w = {(k, (p[x . v],h \u00b7 h ' )) |(k, (p, h)) . [G]1 w . (k, (v, h ' )) . [X]1 \nw} [G * 0]1 w =([G]1 w) * ([0]1 w) Figure 9. Interpretation Proof sketch. We equip the set of values \nwith the discrete metric, and then obtain a complete 1-bounded ultrametric on environments: d(T, T ' \n) = sup. d(T(U),T ' (U)) . (48) We then show by simultaneous induction on C, T , and e, the following \nproperties: 1. [C]1 w, [T]1 w, and [e]1 w are upwards closed and uniform predicates; 2. [C]1 w, [T ]1 \nw, and [e]1 w are non-expansive functions of T (with respect to the distance in (48)) and w (with respect \nto the metric on 12 \u00b7 W ); 3. if C is formally contractive in U then is contractive;  C]1[.:=(\u00b7)] 4. \nif e is formally contractive in U then [ e]1[.:=(\u00b7)] is contractive. These properties can be veri.ed \nby a straightforward (but tedious) simultaneous induction, for instance using Lemma 3.6 and the non-expansiveness \nof separating conjunction to show the non\u00adexpansiveness of arrow types. The interpretation of recursive \ntypes and capabilities relies on our restriction to formally contractive equations, so that they are \nuniquely de.ned from Banach s .xed point theorem by the above properties 3 and 4. This interpretation \nrespects the structural equivalence, i.e., whenever (and similarly for value and memory types). The proofs \nof these C1 and C2 are equivalent capabilities then [C1] = [C2]facts are easy consequences of the de.nition \nof [C] and Proposi\u00adtions 3.3 and 3.4. Moreover, the interpretation validates the subtyp\u00ading axioms, i.e., \nwhenever e1 = e2 then [e1]1 w . [e2]1 w holds for all T and w. These proofs can be found in the appendix \nof the long version of the paper. Recall that we have two kinds of judgments, one for typing of values \nand the other for the typing of expressions: . . v : T G . t : X The semantics of a value judgement simply \nestablishes truth with respect to all worlds w, all environments T and all k . N: def |= (. . v : T ) \n.. .T. .w . W. .k . N. .(k, p) . [.]1 w. (k, p(v)) . [T]1 w. Here p(v) means the application of the substitution \np to v. The judgement for expressions mirrors the interpretation of the arrow case for value types, in \nthat there is also a quanti.cation over heap predicates r . Cap: def |= (G . t : X) .. .T. .w . W. .k \n. N. .r . Cap. .(k, (p, h)) . ([G]1 * r)w * [-1(w)(emp). (k, (p(t),h)) .E([X]1 * r)(w). The universal \nquanti.cations allow us to have frame rules: the universal quanti.cation over worlds w ensures the soundness \nof the deep frame rule, and the universal quanti.cation over capabilities r validates the shallow frame \nrule. We can now give the main result of this section, which expresses that the extension of the capability \nsystem with higher-order frame rules is sound. In particular, the below theorem implies type safety. \nTheorem 3.8 (Soundness). If . . v : T then |= (. . v : T ), and if G . t : X then |= (G . t : X). To \nprove the theorem, we show that each typing rule preserves the truth of judgements. These proofs are \ngiven in the appendix of the long version of the paper.  3.4 Observations We conclude this section \nwith some remarks on the model. Structural equivalence. In previous work, where Pottier .rst in\u00adtroduced \nthe anti-frame rule [38], the syntactic types are considered modulo the structural equivalence. This \nmeans that they are not in\u00adductively de.ned, and consequently Pottier avoids inductive proofs on their \nsyntax. In contrast, our interpretation is given by induc\u00adtion on the structure of types and capabilities, \nand only after having established the interpretation do we consider the structural equiva\u00adlence (and \nprove that our interpretation respects it). Unique solutions proof principle. In practice, one may have \nto show type equivalences that do not easily follow from the structural equivalence. The metric structure \nof our model suggests a proof principle for this, by the uniqueness of solutions of contractive type \nequations: if two types are solutions of a common contractive .xed point equation, then we can conclude \nthat they are equal. Additional subtyping axioms. Our model satis.es some addi\u00adtional subtyping axioms \nthat have not been mentioned in the litera\u00adture before. These refer, e.g. to the duplication of value \ncapabilities. In particular, our model implies the soundness of the axiom [e] *{e : T}= [e] *{e : T}*{e \n: T }. A possible explanation why these axioms have not been noted before may be that previous soundness \nproofs for capability type systems (e.g. by translation [24] or progress and preservation [38]) rest \non invariants that are stronger than necessary. Classical interpretation. The capability calculus of \nCrary et al. [26] has a memory deallocation construct, and satis.es a complete collection property. Essentially, \nif a program of type T *\u00d8 termi\u00adnates, then it does so in an empty heap. After dropping the sub\u00adtyping \naxiom C1 * C2 = C1 and adding a deallocation construct to our calculus, it would also satisfy this property. \nOur approach is .exible enough so that this can be shown by modifying the se\u00admantics and using the classical \ninterpretation of separation logic. That is, the de.nition of worlds and capabilities would be based \non UPred(Heap) instead of UPred.(Heap), where the BI structure is given by * and -* as above but with \nunit I = w \u00d7{[]}. However, this complete collection property is not only destroyed by the ax\u00adiom C1 * \nC2 = C1 but also by the inclusion of an anti-frame rule (which we do not consider in this paper, though). \nAliasing. Even though our model is based on the operational semantics, it gives a semantic understanding \nof capabilities. Let e be any memory type, and consider the recursively de.ned memory type mlist = Jf.ref \n1+ e \u00d7 f of mutable lists from [24]. In loc. cit. it is mentioned (without proof) that this is the type \nof mutable non-aliased lists, and our semantics shows very directly that this is indeed the case: From \nthe semantics of memory types in Figure 9, we see (for k large enough) that (k, (I1,h)) . [mlist] just \nin case that for some n<k, heap h can be split up into 2n disjoint parts: h =[I1 . (v1,I2)] \u00b7 h1 \u00b7 [I2 \n. (v2,I3)] \u00b7 h2 \u00b7\u00b7\u00b7\u00b7 [In . ()] \u00b7 hn, with (k-i, (vi,hi)) . [e], for all 1 = i<n. Thus, all list entries \nlive in disjoint parts of the heap and all locations Ii must be distinct; in particular, mlist cannot \ncontain cyclic lists. A domain-theoretic model? Finally, it may be worthwhile to re\u00admark that we have \ntried to give a domain-theoretic ultrametric model of the calculus as well, but found this very dif.cult. \nIn fact, this dif.culty was one motivation for constructing the present step\u00adindexed model. Very roughly, \nthe projections that come with so\u00adlutions to recursive domain equations disagree with, e.g., memory types. \nThe step-indexed setting appears a bit more .exible in this respect. 4. Specialization to Indirection \nTheory Hobor, Dockins and Appel [30] present a general theory of indi\u00adrection for giving set-theoretic \nmodels of recursively de.ned struc\u00adtures. Faced with a recursive equation, Hobor et al. provide an ap\u00adproximate \nsolution: this is a set together with a pair of functions characterized by the two axioms of indirection \ntheory that elegantly capture the approximative nature of the solution. Our approach to recursive equations \nis different. We provide an exact solution, but in a category of metric spaces instead of the category \nof sets and functions. In this section we argue that our approach is more general in the sense that, \nfor the same recursive equation, one may build the approximative solution of Hobor et al. from our solution. \nBefore starting, we point out that this specialization to indirec\u00adtion theory is not unconditional. The \nconstruction presented by Ho\u00adbor et al. is parameterized over a set-theoretic functor F : Set . Set, \nand this functor must in a suitable sense have an extension to CBUltne in order for our approach to apply. \nFortunately, this con\u00addition holds for functors on Set built with standard constructors. We now sketch \nhow the specialization to indirection theory proceeds. The full story, including proofs, can be found \nin the appendix of the long version of the paper. 4.1 Indirection Theory Assume that we are given a functor \nF : Set . Set and a non-empty set 0. Let 2= {0, 1} be the set of truth values. Indirection theory begins \nfrom the desire to solve the equation K ~ = F (K \u00d7 0 . 2) (49) in Set, which is often impossible for \ncardinality reasons.6 Instead, one obtains an approximate solution unsquash  K N\u00d7 F (K \u00d7 0 . 2) squash \nconsisting of a set K and functions squash and unsquash satisfy\u00ading: 1. squash(unsquash k)= k. 2. unsquash(squash(m, \nv)) = (m, F (approxm)(v)) .  Here level = fst \u00b0 unsquash : K . N, and the map approxm : (K \u00d7 0 . 2) \n. (K \u00d7 0 . 2) is de.ned, for each m . N, by approxm(\\)(k, o)=(\\(k, o) . level(k) <m). The idea is that \nelements of K have levels, and that the func\u00adtion approxm transforms a predicate on K to one that only \nholds for elements of level less than m. Notice that squash is a left inverse of unsquash, but in general \nnot a right inverse: unsquash(squash(m, v)) is in some sense an approximation of (m, v).  4.2 From Metric \nSpaces to Indirection Theory Every set can be considered as a metric space by giving it the dis\u00adcrete \nmetric d (i.e., d(x, y)=1 if x / = y). In this way, the category of non-empty sets can be viewed as a \nsubcategory of CBUltne. We now assume that the functor F : Set . Set considered above has a so-called \nplain lift F : CBUltne . CBUltne. This means that F is a locally non-expansive functor which agrees with \nF on non-empty sets (and functions between them), and also that F satis.es some technical conditions \ngiven in the appendix of the long version of 6 Unlike Hobor et al. we do not parameterize over the set \nof truth values. The generalization, while probably technically feasible, does not appear necessary for \napplications.  the paper. As noted above, plain lifts exist for all the standard con\u00adstructors (see \nagain the long version of the paper). In particular we have plain lifts of the functors of all the examples \nof Hobor et al.7 From Theorem 2.1 and Lemma 2.4, we easily obtain: Theorem 4.1. Let F : Set . Set be \na functor with a plain lift F : CBUltne . CBUltne. There is a non-empty, complete, 1\u00adbounded ultrametric \nspace X and an isomorphism () ~ 1 F: X = F 2 (X . UPred(0)), where the function space consists of non-expansive \nmaps. We now show that one can use such an isomorphism to construct an approximate solution in the sense \nof indirection theory. We deviate from Hobor et al. by building a solution that features only so-called \nhereditary maps from K \u00d7 0 to 2. This is a direct consequence of the downwards closedness required of \nmembers of UPred(0), since hereditary predicates are, intuitively, closed un\u00adder approximation in the \nK component. We regard this difference as an improvement since, in all applications to date, hereditariness \nis considered desirable and often necessary. This point is discussed further below. Theorem 4.2. Let \nF : Set . Set be a functor with a plain lift F : CBUltne . CBUltne. We can, from the isomorphism of Theorem \n4.1, build a set K, a subset of hereditary maps K \u00d7 0 .her 2 of the full function space K \u00d7 0 . 2 and \ntwo maps unsquash K N\u00d7 F (K \u00d7 0 .her 2) squash satisfying Hobor et al. s requirements for an approximate \nsolution (items 1 and 2 above). Advantages of metric solution approach. Having proved that our metric-space \napproach specializes to the indirection theory, we now proceed to argue some advantages of our approach \nin general. Firstly, although we do not think that the step-indexed version of our metric-space approach \nis more expressive than standard step\u00adindexed models, we believe that our version provides a good frame\u00adwork \nfor doing step-indexing with useful conceptual guidelines. This holds even if we disregard recursively \nde.ned worlds. Con\u00adsider, e.g., the interpretation of recursive types in Figure 9 of Sec\u00adtion 3. Under \nthe aforementioned assumptions of formal contrac\u00adtiveness, we are free to interpret recursive types as \nactual .xed points a conceptually pleasing thing to do. Another example is the . operator in the same \nsection, which is also constructed using Banach s .xed-point theorem. A similar construction could possi\u00adbly \nbe pushed through either with hand-built approximate worlds as employed by Ahmed et al. [6], with the \nindirection theory of Hobor et al. [30] or the higher order J described in Hobor s thesis [28]. But the \nprecise course of action is much less immediate. Secondly, in comparison with the indirection theory \n[30], our approach of solving recursive metric equations allows one to use a body of supporting theory \non metric spaces and to construct a wider variety of possible worlds to be used in Kripke models. To \nillustrate this point, let us focus on the step-indexed model of ML references discussed in Section 2.3 \nand in Sections 2.1, 4.1 and 5 of [30]. In the model provided by indirection theory, types are arbitrary \nmaps from worlds to values, modulo currying and nomenclature. But, as argued in [30, Section 5.1], we \nreally want types that are both hereditary and monotone. In [30, Section 5.1], such types are elegantly \nidenti.ed using modal operators, but this does not change the problem that the types in a world may fail \nto 7 With the possible exception of Example 2.7. The functor in that example is complex, and the presentation \nis a bit dense, so we are not sure whether the functor has a plain lift. meet these criteria. This is \naddressed in the last paragraph of [30, Section 10] where an alternative, and less straightforward, model \nwith only hereditary types in the worlds is sketched. Alas, this means that one has to start the model \nconstruction all over again from scratch and it does not buy us monotonicity8. On the other hand, to \nobtain hereditary types with the metric approach we just use the downwards-closure condition on UPred(V \n), verify Lemma 2.4 and apply Theorem 2.1. And to work with monotone types, we can apply a slightly stronger \nexistence result [20, Proposition 5.4] for pre-ordered metric spaces. By a similar argument one can extend \nthe approach to mixed variance functors discussed in [30, Section 10]: Indeed, in unpublished work we \nhave used mixed\u00advariance functors to verify that the metric-space approach scales to the elaborate worlds \nof [6]. Finally, we think that it is advantageous that the metric approach applies both to models based \non domain theory and to models based on operational semantics. 5. Related and Future Work Relational \nreasoning. We have focused on unary reasoning in this paper, but the techniques developed here also apply \nto rela\u00adtional reasoning. Relational reasoning principles about programs with higher-order store, such \nas logical relations for reasoning about contextual equivalence of programs, have been developed both \nbased on domain theory (e.g., [15, 21]), and on step-indexed models (e.g., [6]). For such relational \nreasoning, the worlds are typ\u00adically more sophisticated than the worlds we have discussed so far. This \nis because for relational reasoning worlds need to describe sit\u00aduations in which programs are contextually \nequivalent even though they use local states in different ways. One of us (Thamsborg) has recently phrased \nthe state-of-the-art world model from [6] as a re\u00adcursive world equation over a domain-theoretic model. \nHe did this to obtain more abstract proof principles for program equivalences, which does not involve \nreasoning about step indices. Alternatively, Dreyer et al. [27] have shown how to extend the relational \nstep\u00adindexed model [6] to a model of a modal logic for more abstract reasoning about program equivalences. \nThe latter modal logic has been derived from the step-indexed model. Even with this devel\u00adopment, it \nis still a challenge to develop relational step-indexed models of Hoare Type Theory [35] and its new \ndevelopments. It would be interesting to see whether the step-indexed metric space approach can be used \nto address this challenge. Formalization. An often mentioned advantage of the traditional step-indexed \napproach is that it lends itself well to formalization in theorem provers. Indeed, impressive formalization \nwork has been carried out in, e.g., Coq [10]. Thus, one may wonder whether our proposed metric approach \nhinders formalizations. It does not. Following the treatment in [20], Varming et al. have given a constructive \nformalization of the solu\u00adtions of recursive metric-space equations in Coq [16], including the step-indexed \nmodel of ML references from Section 2.3. Capabilities. In [5], Ahmed et al. presented a step-indexed \nmodel of a substructural type system, which is similar to the capability calculus considered in this \npaper. However, their model did not provide a satisfactory semantic analysis of capabilities. Ahmed et \nal. instrumented the operational semantics with abstract run-time entities corresponding to capabilities, \nand their model included those abstract entities, instead of giving a semantic analysis of what they \nreally should denote. Moreover, they did not consider non\u00adtrivial combinations of capabilities such as \nC1 * C2 and did not 8 It is worth noticing that since the publication of [30], Hobor et al. have given \nan even more expressive notion of indirection theory that guarantee monotone types too and works with \nmixed variance functors, see [10].  include frame rules, etc. The step-indexed model in this paper does \nnot alter the operational semantics, interprets capabilities including C1 * C2, and justi.es (shallow \nand deep) frame rules. We point out that an alternative semantic model of the basic capability system \ncould be obtained by combining the functional translation of Chargu\u00b4 eraud and Pottier [24] with a semantic \nmodel of their purely functional target calculus. The functional translation in [24] does not, however, \ninclude higher-order frame rules and it is not immediate how to include those rules. To extend our semantics \nto group regions is future work. Note that group regions are non-trivial, since they might grow over \ntime but types need to be invariant (monotone) with respect to this growth. Further extensions will address, \nfor instance, frame rules for more general (parameterized) invariants on local state [39]. Other operational \ntechniques. We brie.y mention two tech\u00adniques other than step indexing that can be used to de.ne logical \nrelations based on operational semantics. First, syntactic minimal invariance [18, 25] is based on operational \ncounterparts of the pro\u00adjection functions one obtains from solutions to recursive domain equations. As \nfar as we know, this technique has not been devel\u00adoped for languages with store. Second, biorthogonality \n[13, 31, 37] is based on syntactically de.ned closure operators on relations. Biorthogonality has been \ndeveloped for a language with integer store [37], but not (without also using step indexing) for languages \nwith general recursive types or higher-order store. Voullion and Melli`es [50] give an axiomatic setup \nthat incorporates both tech\u00adniques for a language without store. See also [34] by the same authors. As \nan alternative to logical relations, techniques based on bisim\u00adulation can be used to show contextual \nequivalences for languages with store [49]. However, such techniques do not seem helpful for modelling \nexpressive type systems such as the one considered in Section 3. 6. Conclusion In this paper, we have \nargued that recursive features of program\u00adming languages, type systems and program logics, such as higher\u00adorder \nstore, can be naturally interpreted via Kripke models over worlds that are recursively de.ned in a category \nof metric spaces. Interestingly, this can be carried out not only denotationally but also using operational \nsemantics. Our method combines the simplic\u00adity of existing step-indexed models with the accuracy of domain\u00adtheoretic \napproaches for recursive domain equations. Unlike other step-indexed models, our method uses solutions \nof the original re\u00adcursive equations, not their approximated versions. The bene.ts of this technique \nhave been demonstrated in our new semantics of Chargu\u00b4 eraud and Pottier s type-and-capability system \n[24], where solving an original recursive equation over worlds played a seem\u00adingly crucial role in modelling \na recursively de.ned operator on worlds. Additionally, we have shown that our metric approach can be \nspecialized to Hobor et al. s recent proposal [30] and argued that the metric approach has some advantages. \nAcknowledgments We would like to thank Franc\u00b8ois Pottier, Aquinas Hobor, Robert Dockins, Andrew W. Appel \nand Carsten Varming for helpful dis\u00adcussions and insightful comments. Yang and Reus acknowledge support \nfrom the EPSRC. References [1] M. Abadi and G. D. Plotkin. A per model of polymorphism and recursive \ntypes. In Proceedings of LICS, pages 355 365, 1990. [2] A. Ahmed. Semantics of Types for Mutable State. \nPhD thesis, Princeton University, 2004. [3] A. Ahmed. Step-indexed syntactic logical relations for recursive \nand quanti.ed types. In Proceedings of ESOP, pages 69 83, 2006. [4] A. Ahmed, A. Appel, and R. Virga. \nA strati.ed semantics of general references. In Proceedings of LICS, pages 75 84, 2002. [5] A. Ahmed, \nM. Fluet, and G. Morrisett. L3: A linear language with locations. Fundam. Inf., 77(4):397 449, 2007. \n[6] A. Ahmed, D. Dreyer, and A. Rossberg. State-dependent representation inde\u00adpendence. In Proceedings \nof POPL, pages 340 353, 2009. [7] R. M. Amadio. Recursion over realizability structures. Information \nand Com\u00adputation, 91(1):55 85, 1991. [8] R. M. Amadio and P.-L. Curien. Domains and Lambda-Calculi. Cambridge \nUniversity Press, 1998. [9] P. America and J. J. M. M. Rutten. Solving re.exive domain equations in a \ncategory of complete metric spaces. J. Comput. Syst. Sci., 39(3):343 375, 1989. [10] A. Appel, R. Dockins, \nand A. Hobor. Mechanized semantic library. http://msl.cs.princeton.edu/, 2009. [11] A. W. Appel and D. \nA. McAllester. An indexed model of recursive types for foundational proof-carrying code. ACM Trans. Program. \nLang. Syst., 23(5): 657 683, 2001. [12] A. W. Appel, P. Melli`es, C. D. Richards, and J. Vouillon. A \nvery modal model of a modern, major, general type system. In Proceedings of POPL, pages 109 122, 2007. \n[13] N. Benton and C.-K. Hur. Biorthogonality, step-indexing and compiler correct\u00adness. In Proceedings \nof ICFP, pages 97 108, 2009. [14] N. Benton and B. Leperchey. Relational reasoning in a nominal semantics \nfor storage. In Proceedings of TLCA, pages 86 101, 2005. [15] N. Benton, L. Beringer, M. Hofmann, and \nA. Kennedy. Relational semantics for effect-based program transformations: Higher-order store. In Proceedings \nof PPDP, pages 301 312, 2009. [16] N. Benton, A. Kennedy, C. Varming, and L. Birkedal. Formalizing domains, \nul\u00adtrametric spaces and semantics of programming languages. Manuscript. Avail\u00adable at http://www.itu.dk/people \n/birkedal/papers/formalizing-semantics.pdf, 2010. [17] B. Biering, L. Birkedal, and N. Torp-Smith. Bi-hyperdoctrines, \nhigher-order separation logic, and abstraction. ACM Trans. Program. Lang. Syst., 29(5), 2007. [18] L. \nBirkedal and R. W. Harper. Constructing interpretations of recursive types in an operational setting. \nInformation and Computation, 155:3 63, 1999. [19] L. Birkedal, N. Torp-Smith, and H. Yang. Semantics \nof separation-logic typing and higher-order frame rules for Algol-like languages. LMCS, 2(5:1), 2006. \n[20] L. Birkedal, K. St\u00f8vring, and J. Thamsborg. The category-theoretic solution of recursive metric-space \nquations. Technical Report ITU-2009-119, IT University of Copenhagen, 2009. [21] L. Birkedal, K. St\u00f8vring, \nand J. Thamsborg. Realizability semantics of paramet\u00adric polymorphism, general references, and recursive \ntypes. In Proceedings of FOSSACS, pages 456 470, 2009. [22] N. Bohr and L. Birkedal. Relational reasoning \nfor recursive types and references. In Proceedings of APLAS, pages 79 96, 2006. [23] F. Cardone. Relational \nsemantics for recursive types and bounded quanti.cation. In Proceedings of ICALP, pages 164 178, 1989. \n[24] A. Chargu\u00b4eraud and F. Pottier. Functional translation of a calculus of capabili\u00adties. In Proceedings \nof ICFP, pages 213 224, 2008. [25] K. Crary and R. Harper. Syntactic logical relations for polymorphic \nand recur\u00adsive types. Electronic Notes in Theoretical Computer Science, 172:259 299, 2007. [26] K. Crary, \nD. Walker, and G. Morrisett. Typed memory management in a calculus of capabilities. In Proceedings of \nPOPL, pages 262 275, 1999. [27] D. Dreyer, G. Neis, A. Rossberg, and L. Birkedal. A relational modal \nlogic for higher-order stateful ADTs. In Proceedings of POPL, pages 185 198, 2010. [28] A. Hobor. Oracle \nSemantics. PhD thesis, Princeton University, 2008. [29] A. Hobor, A. Appel, and F. Nardelli. Oracle semantics \nfor concurrent separation logic. In Proceedings of ESOP, pages 353 367, 2008. [30] A. Hobor, R. Dockins, \nand A. Appel. A theory of indirection via approximation. In Proceedings of POPL, pages 171 184, 2010. \n[31] P. Johann and J. Voigtl\u00a8ander. A family of syntactic logical relations for the semantics of Haskell-like \nlanguages. Information and Computation, 207(2): 341 368, 2009.  [32] P. B. Levy. Possible world semantics \nfor general storage in call-by-value. In Proceedings of CSL, pages 232 246, 2002. [33] D. B. MacQueen, \nG. D. Plotkin, and R. Sethi. An ideal model for recursive polymorphic types. Information and Control, \n71(1/2):95 130, 1986. [34] P.-A. Melli`es and J. Vouillon. Recursive polymorphic types and parametricity \nin an operational framework. In Proceedings of LICS, pages 82 91, 2005. [35] A. Nanevski, G. Morrisett, \nand L. Birkedal. Polymorphism and separation in hoare type theory. In Proceedings of ICFP, pages 62 73, \n2006. [36] B. C. Pierce. Types and Programming Languages. The MIT Press, 2002. [37] A. M. Pitts and I. \nD. B. Stark. Operational reasoning for functions with local state. In A. D. Gordon and A. M. Pitts, editors, \nHigher-Order Operational Techniques in Semantics, Publications of the Newton Institute, pages 227 273. \nCambridge University Press, 1998. [38] F. Pottier. Hiding local state in direct style: a higher-order \nanti-frame rule. In Proceedings of LICS, pages 331 340, 2008. [39] F. Pottier. Generalizing the higher-order \nframe and anti-frame rules. Unpub\u00adlished, July 2009. [40] U. S. Reddy and H. Yang. Correctness of data \nrepresentations involving heap data structures. Science of Computer Programming, 50(1 3):129 160, March \n2004. [41] B. Reus and J. Schwinghammer. Separation logic for higher-order store. In Proceedings of CSL, \npages 575 590, 2006. [42] B. Reus and T. Streicher. Semantics and logic of object calculi. In Proceedings \nof LICS, pages 113 124, 2002. [43] J. C. Reynolds. Separation logic: A logic for shared mutable data \nstructures. In Proceedings of LICS, pages 55 74, 2002. [44] J. Schwinghammer, L. Birkedal, B. Reus, and \nH. Yang. Nested Hoare triples and frame rules for higher-order store. In Proceedings of CSL, pages 440 \n454, 2009. [45] J. Schwinghammer, L. Birkedal, and K. St\u00f8vring. A step-indexed Kripke model of hidden \nstate via recursive properties on recursively de.ned metric spaces. Manuscript. Available at http://www.itu.dk/people \n/birkedal/papers/relpoms-antiframe-conf.pdf, 2010. [46] J. Schwinghammer, H. Yang, L. Birkedal, F. Pottier, \nand B. Reus. A semantic foundation for hidden state. In Proceedings of FOSSACS, pages 2 17, 2010. [47] \nM. B. Smyth. Topology. In S. Abramsky, D. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in \nComputer Science. Oxford University Press, 1992. [48] I. Stark. Categorical models for local names. LISP \nand Symbolic Computation, 9(1):77 107, Feb. 1996. [49] E. Sumii. A complete characterization of observational \nequivalence in polymor\u00adphic lambda-calculus with general references. In Proceedings of CSL, pages 455 \n469, 2009. [50] J. Vouillon and P.-A. Melli`es. Semantic types: a fresh look at the ideal model for types. \nIn Proceedings of POPL, pages 52 63, 2004.   \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Over the last decade, there has been extensive research on modelling challenging features in programming languages and program logics, such as higher-order store and storable resource invariants. A recent line of work has identified a common solution to some of these challenges: Kripke models over worlds that are recursively defined in a category of metric spaces. In this paper, we broaden the scope of this technique from the original domain-theoretic setting to an elementary, operational one based on step indexing. The resulting method is widely applicable and leads to simple, succinct models of complicated language features, as we demonstrate in our semantics of Chargu&#233;raud and Pottier's type-and-capability system for an ML-like higher-order language. Moreover, the method provides a high-level understanding of the essence of recent approaches based on step indexing.</p>", "authors": [{"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P2509579", "email_address": "birkedal@itu.dk", "orcid_id": ""}, {"name": "Bernhard Reus", "author_profile_id": "81100359548", "affiliation": "University of Sussex, Brighton, United Kingdom", "person_id": "P2509580", "email_address": "bernhard@sussex.ac.uk", "orcid_id": ""}, {"name": "Jan Schwinghammer", "author_profile_id": "81314485716", "affiliation": "Saarland University, Saarbr&#252;cken, Germany", "person_id": "P2509581", "email_address": "jan@ps.uni-saarland.de", "orcid_id": ""}, {"name": "Kristian St&#248;vring", "author_profile_id": "81318496592", "affiliation": "University of Copenhagen, Copenhagen, Denmark", "person_id": "P2509582", "email_address": "stovring@diku.dk", "orcid_id": ""}, {"name": "Jacob Thamsborg", "author_profile_id": "81418598508", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P2509583", "email_address": "thamsborg@itu.dk", "orcid_id": ""}, {"name": "Hongseok Yang", "author_profile_id": "81100355747", "affiliation": "Queen Mary University London, London, United Kingdom", "person_id": "P2509584", "email_address": "hyang@dcs.qmul.ac.uk", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926401", "year": "2011", "article_id": "1926401", "conference": "POPL", "title": "Step-indexed kripke models over recursive worlds", "url": "http://dl.acm.org/citation.cfm?id=1926401"}