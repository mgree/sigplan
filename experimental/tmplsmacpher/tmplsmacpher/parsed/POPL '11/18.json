{"article_publication_date": "01-26-2011", "fulltext": "\n Generative Type Abstraction and Type-level Computation Stephanie Weirich Dimitrios Vytiniotis Steve \nZdancewic University of Pennsylvania Simon Peyton Jones University of Pennsylvania Philadelphia, PA, \nUSA Microsoft Research Philadelphia, PA, USA sweirich@cis.upenn.edu Cambridge, UK stevez@cis.upenn.edu \n{dimitris,simonpj}@microsoft.com Abstract Modular languages support generative type abstraction, ensuring \nthatan abstracttypeis distinctfromitsrepresentation,except inside the implementation wherethe two are \nsynonymous.We show that this well-established feature is in tension with the non-parametric features \nof newer type systems, such as indexed typefamilies and GADTs. In this paper we solve the problem by \nusing kinds to distinguish between parametric and non-parametric contexts. The result is directly applicable \nto Haskell, which is rapidly developing support for type-level computation,but the same issues should \narise whenever generativity and non-parametric features are combined. Categories and Subject Descriptors \nD.3.3[LanguageConstructs and Features]: Abstract data types; F.3.3[Studies of Program Constructs]:Type \nstructure General Terms Design,Languages Keywords Haskell,Newtype deriving,Type functions 1. Introduction \nGenerative type abstraction allows programmers to introduce new type constants in their programs that \nare isomorphic to existing types; examples include ML s module system [Milner et al. 1997; Pierce 2005, \nCh. 8], and Haskell s newtype construct [Peyton Jones et al. 2003].Type generativity is important because \nit sup\u00adports modularity by enforcing abstraction: the implementor of a module can move freely between \nthe abstract and representation types, whereas to the client of the module the two types are com\u00adpletely \ndistinct. There is growing interest in languages that support some form of type-level computation including \nHaskell s type classes [Hall et al. 1996] and indexed typefamilies [Kiselyov et al. 2010]. However, there \nis a fundamental tension between type-level computation and generative type abstraction, at least in \nthe latter s more .exible forms.To summarizevery brie.y, the con.ictis this: To maximize re-use and convenience, \nit is very desirable for the implementor to be able to treat the abstract type A and its concrete representation \ntype C as synonymous we call this .exible typegenerativity. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin,Texas, \nUSA. Copyright c &#38;#169; 2011ACM 978-1-4503-0490-0/11/01... $10.00 However, given type-level function \nF the result of (FA) and (FC) may differ, so A and C cannot be synonymous. Resolving this con.ict is \nthe subject of this paper. Speci.cally our contributions are: Weshowin Section2thatthenaivecombinationoftype \ngenera\u00adtivity and non-parametric type-level features can violate sound\u00adness; a problem that already manifests \nin the Glasgow Haskell Compiler, and affects not only type-level non-parametric func\u00adtions,butalsootherformsof \nnon-parametric constructs,suchas generalized algebraic datatypes(GADTs) [Cheneyand Hinze 2003; Hinze \net al. 2002; Peyton Jones et al. 2006; Xi et al. 2003].  We formalize a solution to this problem that \nreconciles .exi\u00adble type generativity and non-parametric type functions in Sec\u00adtion 3. Our language, \nFC2, builds on GHC s existing core language, System FC [Sulzmann et al. 2007], which supports erasabletype-level \ncoercions.Thekeyingredientinour solution is to employkinds decorated with roles to mark the distinctions \nthat type contexts may make.  We prove thatFC2 programs are type safe, provided that user axioms and \nde.nitions give rise to consistent axiom sets (Sec\u00adtion 4).  We give suf.cient conditions for showing \nthe consistency of an axiom set. For our proofs, we introduce a rewrite sys\u00adtem for types that is novel \nin two dimensions: rewriting (i) is role-sensitive, and (ii) need not be strongly normalizing (Sec\u00adtion \n4.2).  We present a Haskell-speci.c result: we show how Haskell source programs that may involvenon-parametric \ntype contexts and .exible type generativity can be translated to yield provably consistent FC2 axiom \nsets. (Section 5)  Our core language is an improvement of System FC since it permits safe .exible type \ngenerativity,but also unsaturated type functions. Perhaps surprisingly, our language is additionally \na signi.cant simpli.cation of the original System FC, which removesseveral of the original coercion constructs \nthat we have identi.edtobe encodable(eveninthe originalSystemFC).We discuss these differences in Section \n6.2.  For the sake of concretenesswebuild our presentation around Haskell and System FC, since this \nsetting allows us to demon\u00adstrate our points with real code, instead of using a hypothetical .-calculus. \nHowever, we stress that our work is applicable when\u00adever .exible type generativity and non-parametric \ntype-level fea\u00adtures are combined.Forexample, thevery same issues could arise inextensionsof theML module \nsystem.We discuss relatedwork in Section 7.  Some of the technical material has been elided from this \nver\u00adsion of the paper for space. Although this paper is self contained, more details are available at \nhttp://www.cis.upenn.edu/ ~sweirich/newtypes.pdf. 2. The problems with generative type abstraction Generative \ntype abstraction is an extremely useful mechanism for enforcing abstraction barriers and for re.ning \ninterfaces.Tosee this bene.t, let us consider the Haskell incarnation of type generativity, namely newtype \nde.nitions. In Haskell, the programmer may declare a newtype Age, with concrete representation type Int, \nthus: newtype Age = MkAge Int The implementor uses the data constructor MkAge to coerce an Int to an \nAge,and pattern matching to effect the inverse coercion. For example: addAge :: Age . Int . Age addAge \n(MkAge a) n = MkAge (a+n) The client, in contrast, can be prevented from making such conver\u00adsions, by \nusing the module system to hide the MkAge constructor: module AgeModule( Age, addAge, ... ) where --Age \ndefinition and implementation 2.1 Coercion lifting In describing MkAge, we wrote data constructor in \nquotes be\u00adcause although it behaves in many ways like a data constructor, its cost modelisdifferent. \nSpeci.cally,a newtype de.nition guaran\u00adteesthatthe abstracttypereallyis representedbythe concretetype, \nso the runtime conversion cost is zero. That would not be true if Age were instead declared with data \ninstead of newtype. So Age can be coerced to an Int, and vice versa, for free i.e. without runtime cost \nbecause it is an Int. Notationally, we say that Int ~ Age, where we use ~ for type equality1. But what \nabout, say, Maybe Age? data Maybe a = Nothing | Just a Obviously, Maybe Age should be freely coercible \nto Maybe Int, because the two are represented identically. Alas, in Haskell 98 one would have to write \ncvtAge :: Maybe Age . Maybe Int cvtAge t = mapMaybe (.(MkAge a) . a) t --mapMaybe :: (a . b) . Maybe \na . Maybe b This is unsavory for several reasons: (a) it is tedious for the pro\u00adgrammer; (b) it may be \ndif.cult to implement the necessary map function; (c) it is hard for the compiler to eliminate a runtime \ncall to the map function (let alone to guarantee to do so) especially if the map function is recursive. \nAs an example of (b) consider the mapping function for the type T shown below, with co-and contra\u00advariance, \nand higher kinds: data T a f =T1a | T2 (a . Int) | T3(f(T a f) (T a f)) These dif.culties are frustrating, \nbecause we know that, say, T Age Maybe is represented identically to T Int Maybe. So, let us imagine \na hypothetical extension of Haskell that provides lifted coercions; that is, it implements the following \nrule: 1There are too manysorts of = ! Coercion lifting: if for two types . and . we have . ~ . (for example, \nif they are the abstract and concrete types of a newtype declaration), then T . ~ T . for any type constructor \nT . Infactthisextensionisnotsohypothetical, becausesucharuleis the basis of the so-called newtype deriving \nfeature implemented by GHC. It is not dif.cult to use newtype deriving to de.ne an identity function \nwhose type is cvt :: .{c}. c Int . c Age ML supports coercion liftingeven more directly: withina struc\u00adture \nthe abstract and the representation types are consideredentirely interchangeable.Forexamplein StandardML \none might say signature AGE = sig type age val addAge : age . int . age ... end structure AgeModule :> \nAGE = struct type age = int fun addAge a n = a+n ... end Inside AgeModule the twotypes are synonymous, \nand so addAge need not convert in either direction. However, the point of this paper is that the innocuous \nand obvious-seeming lifting of type identities becomes unsound when combined with type-level computation, \nas we show in the next section. 2.2 Type-level computation One very popular extension to Haskell is \nthat of Generalized Alge\u00adbraic DataTypes (GADTs) [Peyton Jones et al. 2006], with which we assume the \nreaderis somewhatfamiliar.In GHC one could de\u00adclare a GADT with two nullary constructors like this: data \nKa where KAge :: K Age KInt :: K Int Now, consider these de.nitions (using cvt from Section 2.1): kint::KAge \nget::KAge . String kint = cvt KInt get KAge = \"Age\" Since get s type signature declares that its argument \nis of type K Age, the patterns in get are exhaustive. But consider the call (get kint). It is patently \nwell typed, yet the pattern match in get willfail (recall that cvt is operationally the identity function), \nandifthe compilerassumed otherwisearuntime crash could result. In the last few years we have gone beyond \nGADTs, by extend\u00ading GHC with type-level functions [Chakravarty et al. 2005a,b; Kiselyov et al. 2010]. \nThe reader is urged to consult these papers for motivatedexamplesof type functions,but for the purposesof \nthis paper we content ourselves withasmallbut contrivedexample: type family F a :: * type instance F \nAge = Char  type instance F Int = Bool Here the type function F maps the type Age to the type Char,but \nit maps Int to Bool. However, the existence of such a type-level function threatens not just patternexhaustivenessbut \ntype soundness itself. Consider the type Bool. This type is equivalent to F Int by the equation for F;and \nby coercion lifting that should be equivalent toF Age; and that is equivalent to Char by the other equation \nfor F. Alto\u00adgether we can coerce Bool to Char, which is obvious nonsense.  Whatwentwrong?Maybeitshouldbeillegalforatype \nfunction to behavedifferently on twocoercible types, such as Age and Int? Butinfact Haskell programmers \noften use newtypes precisely so that they can give a different type-class instance (for comparison, say) \nfor Age than for the underlying Int.Type functions are no different; indeed, they are often introduced \nas an associated type of a type class [Kiselyov et al. 2010], and hence, just as the type class distinguishes \nbetween the abstract and concrete type, so must the type function. Howelse might we .x the problem? Perhaps, \nin the de.nition of coercion lifting we should not allow T to range over type functions such as F or \nGADTs such as K?Indeed we should not,but that is not enough. Consider data TF a =MkTF(F a) Now, should \ncoercion lifting allow us to coerce TF Age to TF Int?Obviously not! Otherwise we could write to :: Bool \n. TF Int from :: TF Age . Char tob =MkTFb from(MkTFc) =c and now the composition from . cvt . to is well-typed \n(via coercion lifting) but obviously unsound. So in the the de.nition of coercion lifting, as well as \ntype functions and GADTs we must exclude data types like TF that use their type arguments non\u00adparametrically. \n 2.3 Summary At this point it should be clear that a naive combination of: type-level dispatch, whether \nby GADTs or by type functions  unrestricted coercion lifting  simplydoesnotwork.This interactionwasfarfromobvioustous \ninitially, andindeed GHC hasa well-documented type-soundness bug2 that arises directly from this unforeseen \ninteraction.Yet both type-level dispatch and coercion lifting (suitably restricted) are valuable. The \npurpose of this paper is to show how they may be soundly combined. This problem is important not only \nbecause it arises in GHC (whichisourmain sourceofmotivation),butalso becausethe same issues will arise \nin any type system that combines type-level dis\u00adpatch and coercion lifting. Haskell is the .rst programming \nlan\u00adguage that has pushed the type systemfar enough for these prob\u00adlems to arise in practice,but others \nmay do so in the future. How\u00adever, these different languages may expose the coercions between abstractand \nconcretetypesindifferentways, possiblyexplicitly(as inHaskell)or implicitly(asinML),inawaythatis intimately \ncon\u00adnected with type inference.Toavoid the complications associated with type inference, in this paper, \nwe focus on an intermediate lan\u00adguage, in which (runtime-erasable) coercions are explicit. Whether they \ncome directly from the source program, or from elaboration by the type checker, is secondary. 3. The \nFC2 language: codes versus types Our goal is to resolve the tension between generative types, which allow \nprogrammers to express the intent that two types have iden\u00adtical representations, and type functions, \nwhich can distinguish two types even if theyhave the same underlying representation. The inspiration \nfor our solution comes from encodings of generic programming in dependently typed languages [Benke et \nal. 2http://hackage.haskell.org/trac/ghc/ticket/1496 2003; Dybjer 2000]. These encodings use codes to \nrepresent types as a form of data. For example, the code IntCode may be the code for the type Int. Nonparametric \nfunctions branch on codes and thus have a different type from parametric functions. In this context, \nwe can view Age and IntCode as two different codes that both map to the type Int. However, this encoding \nre\u00adquires signi.cant syntactic overhead as we must have a code for every type and must explicitly map \ncodes to types when they are used to classify expressions. However, the important distinction between \ncodes and types is that they have different de.nitions of equality. In the encoding above, the codes \nAge and IntCode are different codes,but their interpretations are equal types. Therefore, we use this \nidea in FC2 to de.ne roles, which support different notions of equality for the same data. In this language, \nAge and Int are distinct when viewed at role code but equal when viewed at role type. Code equality is \nused to reason about the meaning of type-indexed functions and is .ner-grained than type equality, which \nis used to determine which type coercions are safe. Importantly, FC2 distinguishes type functionsby what \nequivalences theyrespect.Parametric functions respect the role type, whereas functions that distinguish \nbetween Age and Int do not. 3.1 FC2: an overview These ideas are best explained in terms of an intermediate \nlan\u00adguage that exposes the differences between the code and type roles and makes explicit the uses of \nthe two kinds of equality men\u00adtioned above. Thus, the remainder of this section describes FC2, our new \nvariant of System FC [Sulzmann et al. 2007] a model of the intermediate language used in GHC. As such, \nit is ex\u00adpressive enough to capture indexed type functions, newtype and newtype deriving, GADTs, existential \nand nested datatypes, and much more. Figure 1 summarizes the syntax of FC2, which, at the term level(e), \nis just the polymorphic lambda calculus with two exten\u00adsions. First, FC2 provides polymorphic datatypes, \nintroduced by data constructors K . These datatypes are eliminated using a case construct that should \nbefamiliar from Haskell or ML-style func\u00adtional programming we describe how datatypes and case are typechecked \nin Section 3.5. Second, FC2 includes .rst-class proofs of type equality that witness safe coercions introduced \nduring compilation. Programs in FC2 can abstract over coercions re.ecting a particular type equal\u00adity \n(written .c : .1 ~ .2.e), pass a coercion as an argument to such a function (written e .), and use a \ncoercion to cast a term from one type to another (written e c.). These explicit coercions, written .,maketypecheckingFC2 \nprograms syntax-directed that is, the syntax of an FC2 term encodes its typing derivation. Why is this \nimportant? The idea is that the compiler s front end per\u00adforms perhaps-complex type inference on the \nsource program, and records the proofs generated by inference directly in the syntax of the FC2 intermediate \nlanguage. The optimiser transforms FC2 terms, perhaps radically. At any point one can check the consis\u00adtency \nof the resulting FC2 program using a simple, fast, syntax\u00addirected typechecker; this consistency check \nhas proven to be an extremely powerful aid to getting the compiler right. It is just as easy to .nd the \ntype of an arbitrary FC2 term, an ability that is used extensively inside GHC. Figure2shows the typing \nrules for the terms of FC2. The .rst .ve rules, EEVAR through ETAPP, are completely standard. We deferexplanationofthe \nremaining rules untilwebuildup technical machinery having to do with FC2 s kind-level distinction between \ncodes and types and the rules by which explicit coercions can themselvesbe combined.We describe these \naspectsof FC2 next.  . ::= * | . . . R ::= C | T . ::= ./R H ::= | T | F | (.) | (~.) ., s, . ::= | \na | H | .1 .2 |.a : ... . ::= | c . | . | sym . | .1 ; .2 | .1 .2 | nth k . |.a : ...2 | .@. e ::= | \nx | .x:s.e | e1 e2 | .a:..e | e . | K | cases e of brs | .c : .1 ~.2.e | e . | e c. i.1..n brs ::= Ki \n. ei bnd ::= | a:. | H :. | c :...1 ~ .2/R | x:s | K :s G ::= \u00b7| G, bnd . ::= \u00b7| a:., . . ::= e | . | \n. T ::= |\u00b7 | s, T | a:., T | .1 ~ .2, T v ::= .x:s.e | .a:..e | .c : .1 ~.2.e | K .. t ::= T | (.) | \n(~.) |.a : ... | t. Figure 1. Syntax kind role kind and role type constants datatypes functions/newtypes \narrow equality codes and types variables constants application polymorphism coercion proof assumption \nre.exivity symmetry transitivity application injectivity polymorphism instantiation expressions variable \nabstraction application type abstraction type application data constructor case analysis proof abstraction \nproof application coercion branches binding type variable type constant coercion term variable data constructor \ncontext type context datacon argument telescopes empty expression type type variable equality values \nvalue types G f e : s x:s . G f G EEVAR G f x : s G, x:s1 f e : s2 EEABS G f .x:s1.e : s1 . s2 G f e1 \n: s1 . s2 G f e2 : s1 EEAPP G f e1 e2 : s2 G, a:. f e : s ETABS G f .a:..e : .a : ..s G f e : .a : ..s \nG f . : . ETAPP G f e . : s[a . .] T :. . * . G K :. a:... T.T a . G f G EDATACON G f K : . a:... T.T \na G f e : T . G f s : */T for each Ki . ConstrG(T ) Ki :. a: ...i . G .i [a . .]= . Ti .T . G f ei : \n. Ti .s ECASE G f cases e of Ki . eii : s G, c:.1 ~ .2/C f e : s ECABS G f .c :.1 ~.2.e :(.1 ~.2) . \ns G f e :(.1 ~.2) . s G f . : .1 ~ .2 . ./C ECAPP G f e . : s G f e : s1 G f . : s1 ~ s2 . */T ECOERCE \nG f e c. : s2 Figure 2. Typing rules G f a : ./R2 R1dR2 CdT RSUB RdR RREFL G f . : . a:./R1 . G R1dR2 \nf G PVAR H :. . G f G PCONST G f H : ./R G f .1 :(.1/R2 . .2)/R1 G f .2 : .1/min(R1,R2) PAPP G f .1 \n.2 : .2/R1 G, a:. f . : */R PALL G f.a : ... : */R G f . : . G f \u00b7 : \u00b7 PNIL G f . : . G f . : . G f ., \n. : ., . PCONS Figure 3. Kinding  3.2 FC2 types and kinds Types inFC2 are classi.ed by pairs . of \nthe form ./R, where the kind . ensures(as usual) that types are well-formed structurally, and the role \nR that determines the precision at which they can be analyzed. Codes (which distinguish Age and Int)have \nrole C, whereas types (which identify them) have role T. This syntax is summarized at the top of Figure \n1, while the kinding rules are in Figure 3. The distinction betweencodesandtypesallowsustogiveinfor\u00admative \nkinds to type constructors: The Maybe type (Section 2.1) has kind */T . *, indicating that Maybe treats \nits argument parametrically.  The types K, F, and TF (Section 2.2) all use type indexing and therefore \nhave kind */C . *.  These kinds in turn support thekeyinsight of this paper: it is only safe to lift \ncoercions through functions with parametric kinds. So Maybe Age ~ Maybe Int holdsbut TF Age ~ TF Int. \nThe rules for constructing coercions are given in Section 3.3, but .rst we must deal with the kinding \nrules for types. The critical rule is PAPP in Figure 3, which deals with type application. It is quite \nconventionalexceptforthe treatmentof roles. Consider these type declarations: data TF1 a = MkTF1 (F (Maybe \na) data TF2 a = MkTF2 (Maybe (F a)) data TF3 a = MkTF3 (Maybe (Maybe a)) In the .rst two cases, type \nvariable a is used non-parametrically (intuitively, under a type function), so TF1 : */C . *, and similarly \nfor TF2. In contrast, TF3 treats a parametrically, so TF1 : */T . *. The unusual min in rule PAPP achieves \nthese kindingsbycombiningtheroleofthe contextandtheargumentrole of the function to get the role of the \nargument. Infact, min is just the least upper bound induced by an inclu\u00adsion relation CdT on roles (see \nthe top of Figure 3). This inclusion makesexplicit thefact that code equality implies type equalitybut \nnot vice-versa.Forexample, consider data TF4a =MkTF4(F a) a Here a is used both non-parametrically (as \nan argument of F)and parametrically(asa plain argumentof MkTF4). So a has role */C, which makes sense; \njust because a type can be analyzeddoes not mean that it must be. Despite these non-standard kinds, the \ntypes of FC2 are mostly standard. Codes . and types s are drawn from the same syntax (see Figure1), althoughwe \nusetwodifferent metavariablesasa re\u00adminder of the intended role. The type language includes type vari\u00adables \na, type constants H , applications .1 .2, and polymorphic types .a : ..s. Type constants, H , include \ndatatypes T, and type functions F . For the most part, datatypes and type functions are treated uniformly,but \nthere are two important distinctions: Datatypes must be injective, while type functions need not be. \nInjectivity is important because equalities between applications of injectivefunctions imply equalities \nbetween their arguments; see ruleCNTHTin Section 3.3.  Datatypes are inhabitedbyvalues,but type functions \nare not there are no values v with types that are headed by F. (There are coerced values with such types, \nbut no raw values.) This distinctioniskeyto the de.nitionof consistencyinSection 4.1.  Newtypes are \nnot inhabited by raw values, so we treat them like type functions, ranged over by F . Unlike type functions, \nhowever, newtypes are injectiveat role C after all, the essence of generativ\u00adityisthatnewtypes createafresh \nconstant butfornowwewillnot take advantageof thatfact, leavingit for discussionin Section 6.1. The set \nof type constants also includes thefamiliar arrow type constructor (.),anda kind-indexedfamilyof constructors \n(~.), which construct functions that abstract over coercions. The kinds of these constants are: (.): \n*/T . */T . * (~.): ./C . ./C . */T . * (We discuss in Sections 3.3 and 3.6 why the kind of (~.) must \nrequire role C for its .rst two arguments.) Type constants are generally applied pre.x,butfor thesetwo \nconstantswe de.ne in.x syntactic sugar: s . s = (.) ss (.1 ~.2) . s = (~.) .1 .2 s In the latter case, \nbecause the syntactic sugar lacks the . annotation, we only use this notation in contexts where the kind \nof .1 and .2 is irrelevant. Rule ECABS follows this convention it shows that thisfamilyof type constructorsis \nusedtogivea typeto termsof the form .c : .1 ~ .2.e, which abstracts over an equality proof in the body \ne. Note that this rule applies only to code equalities; abstraction over type equalities is not needed \nfor compilation of Haskell and permitting it, while straightforward, would require extra syntactic complexity. \nFigure3de.nes the kinding rules for FC2 using judgments of the form G f . : .. Here, the context G mapstypevariablesto \ntheir kind/role pairs and type constants and type functions to their kinds. This judgment relies on a \njudgment f G (shown in the extended version) that checks that contexts are well formed. These checks \nensure that constants (.) and (~.) have the right kinds, that data constructors and term variables have \nwell-formed types and that coercion axioms introduce equalities between well-formed codes and types. \nRule PCONST allows a type constant to play either role. Al\u00adthough a type constant may be given role C, \nits kind may well in\u00advolve arguments with role T; for example, see the signature for (.) above. It follows \nthat closed types can play both roles, inde\u00adpendentlyof whether theycontain newtypes or type functions.For \nexample (Int,Age) : */C and (Int,Age) : */T both hold. Together these kinding rules implement a subsumption \nrelation that includes codes into the language of types: LEMMA 1. If G f . : ./C then G f . : ./T. On \nthe other hand, types haveonly one kind regardless of their role: LEMMA 2. If G f . : .1/R1 and G f . \n: .2/R2 then .1 = .2. Note that the kinding judgment, like term typing, is syntax\u00addirected (see the remarks \nin Section 3.1). In particular, the role component R of the . in thisjudgment is treated as input to \nthe algorithm, and the . is an output the context in which . is used determines what the role should \nbe. The only interesting case from this perspective is PAPP, in which .1 must be checked .rst to obtain \nR2 so that the minimum of R1 and R2 can be passed as an input when checking .2.  3.3 Coercions and equality \nIn FC2 a coercion is a proof term that witnesses the equality of two types. Coercions are used to change \nthe type of a term, thus (Figure 2): G f e : s1 G f . : s1 ~ s2 . */T ECOERCE G f e c. : s2 Here, . is \na coercion witnessing the equality s1 ~ s2 in role T; given thate has type s1,we can use. to let us treat \nthe term as hav\u00ad  G f . : .1 ~ .2 . . (c : a : .. .1 ~ .2/R1) . G G f .1 : ./R1 G f . : .R1dR2 CASSM \nG f c . : .1[a . .] ~ .2[a . .] . ./R2 G f . : . CREFL G f . : . ~ . . . G f . : .1 ~ .2 . . CSYM G \nf sym . : .2 ~ .1 . . G f .1 : .1 ~ .2 . . G f .2 : .2 ~ .3 . . CTRANS G f .1 ; .2 : .1 ~ .3 . . G f \n.1 : .1 ~ .2 . (.1/R2 . .2)/R1 G f .2 : .1 ~ .2 . .1/min(R1,R2) CAPP G f .1 .2 : .1 .1 ~ .2 .2 . .2/R1 \nG f . : T . ~ T . . ./T T :. . * . G . /R1 = nth k .R1dR2 CNTHT G f nth k . : nth k . ~ nth k . . . \n/R2 G, a:. f .2 : .1 ~ .2 . */R CALL G f.a : ...2 : .a : ...1 ~.a : ...2 . */R G f . : .a :...1 ~.a \n:...2 . */R G f . : . CINST G f .@. :(.1[a . .]) ~ (.2[a . .]) . */R G f . : .1 ~ .2 . . f G CNIL G \nf\u00b7 : \u00b7~\u00b7.\u00b7 G f . : .1 ~ .2 . . G f . : .1 ~ .2 . . CCONS G f ., . : .1,.1 ~ .2,.2 . ., . Figure 4. Coercions \ning type s2. At compile time, these explicit coercions ensure that typechecking FC2 programs is completely \nsyntax directed. Such coercions have no run-time effect: theywill be erased by the com\u00adpiler before the \nprogram is run. Nevertheless, FC2 s operational semantics includes coercions, thereby allowing usto establish \ntype safety using standard techniques (Section 3.6). The translation of a source program into FC2 may \nextend the type environment G with new equality axioms. For example, the Age newtype de.nition generates \nthe axiom (where mkAge is a coercion constant c): mkAge : Age ~ Int/T Note that ECOERCE requires s1 and \ns2 to be equal when considered in role T, which is consistent with the idea that type equality determines \nwhen it is safe to coerce. On the other hand, source programs can also introduce code equalities.Forexample \nthe type function F (Section 2.2) generates the two axioms: axF1 : F Int ~ Bool/C axF2 : F Age ~ Char/C \nHowever, all code axioms can be used to prove type equalities, as code equality is a re.nement of type \nequality. More generally we permit axiom schemes. For example, the source language declaration type instance \nF(Maybe a) = (a,a) would create the axiom scheme axF3 :(a:*/C). F(Maybe a) ~ (a,a)/C In general,asshownin \nFigure1,the context G includes bindings of the form c :...1 ~ .2/R for coercion axioms. The metavariable \n. stands for a type variable context: a list of quanti.ed type variable bindings of the form a:.. The \nsame binding form is used both for axioms introduced at top level, and (with empty .)for local assumptions \nintroducedinECABS (Figure2). Of course it is important to know that the top-level axioms are consistent \nit would be unsound to assert that Bool ~ Char/T, forexample. Section4givesasuf.cientsetof conditionsfor \nensur\u00ading that source programs generate consistent axioms. Next,weneedawayto compose coercionstogetherto \nconstruct other coercions. Our goal is to have rules that allow the creation of composite coercions such \nas: List mkAge : List Age ~ List Int/T List axF2 : List(F Int) ~ List Bool/T On the other hand, the coercion \nformation rules should disallow the formation of a coercion of the form .3 : F Age ~ F Int/T, which creates \nthe unsoundness described in Section 2.2. Figure 1 gives the syntax of coercion terms, ., and Figure \n4 gives their typing rules. Coercions are typechecked using the judg\u00adment: G f . : .1 ~ .2 . ./R, which \nasserts that the type of a coercion . is an equality proposition .1 ~ .2 . ./R. This propo\u00adsition in \nturn implies that .1 and .2 both havekind . and are equal in role R. It is technically convenient to \ninclude . in the syntax of the judgement to enforce that both types have the same kind. How\u00adever, this \ncomponent is not always relevant, so we sometimes omit the . . part, as we have done in the examples \nabove. RuleCASSM instantiates an axiom scheme with types ., using an auxiliary judgment G f . : . de.ned \nat the bottom of Fig\u00adure3to ensurethateachvariableis instantiatedwithatypeofthe matching kind and role. \nThe notation a : . zips together a list of type variables and a list of kinds to create a type variable \ncontext .. These two lists must have the same length for the notation to be well-de.ned. The notation \n.[a . .] applies a multi-substitution of the types . for each of the corresponding variables in the list \na. Rule CREFL shows that anytype . can be lifted to a re.exive coercion ., while CSYM and CTRANS add \nsymmetry and transi\u00adtivity, ensuring that equality is an equivalence relation. The rules CAPPandCALLextend \nequality compatiblyover applicationsand polymorphic types; their structure is analogous to the correspond\u00ading \nkinding rulesin Figure3. RuleCAPP is particularlyimportant, because it implements thekey coercion lifting \nidea we discussed in Section 2.1, using kinds to prevent the formation of the bogus coercion FmkAge : \nF Age ~ F Int/T To see why, recall thatF has kind */C . *,but the mkAge axiom holds only at role T type \nequalities cannot be lifted through code functions. Another example of a coercion that is correctly rejected \nby the application rule (because of the kind of (~.))is (~*) mkAge Int s This coercion proves (Age ~ \nInt) . s ~ (Int ~ Int) . s, an equalitythat couldbe usedto introducea bogus assumption that Age ~ Int/C \nand satisfy it with re.exivity for Int. As well as composing coercions to witness the equality of big\u00adger \ntypes, it is also essential to do the reverse: to decompose equalities over complex types to give equalities \nof simpler types.  Decomposition is required by FC2 s operational semantics (Sec\u00adtion 3.6), and it also \nmakes the language usefully more expres\u00adsive. Rule CINST allows equalities between polymorphic types \nto be instantiated. The other, more important decomposition rule is CNTHT, which decomposes the application \nof a datatype constant to arguments. For example, given a coercion . : List Int ~ List a/T we can use \nnth 0 . to conclude that Int ~ a/T. The soundness of this rule depends on thefact that datatypes are \ninjective. In general, type functions are not, and hence CNTHT is restricted to datatypes T . In ruleCNTHT,the \nnotationT . abbreviates the multi-application ((T .1) ....n ) for .1 ....n in .. In the conclusion of \nthe rule, the notation nth k ., accesses the kth element of the sequence of types, and nth k ., accesses \nthe kind of the kth variable binding. Both of these notations are unde.ned if k is not less than the \nlength of the sequence. The sequence of types . is determinedby the kind of the datatype, using the following \nnotation. DEFINITION 3. We de.ne. . . by induction on . as follows: \u00b7. . = . ., . . . = . . (. . .) \nThe coercion judgment satis.es a number of sanity checking properties. First, coercions are between well-formed \ntypes. LEMMA 4 (Coercion regularity). If G f . : .1 ~ .2 . . then G f .1 : . and G f .2 : .. Next, each \ncoercion proof is for one pair of codes/types. LEMMA 5 (Unique types). If G f . : .1 ~ .2 . ./R and G \nf . : .1 ~ .2 . . /R then .1 = .1 and .2 = .2 and . = . . Finally, equality for Cs is a re.nement of \nthat for Ts; that is, code equality implies type equality,but not viceversa. LEMMA 6. If G f . : .1 ~ \n.2 . ./C then G f . : .1 ~ .2 . ./T.  3.4 Coercion lifting The applicationruleCAPPdescribedintheprevious \nsectionallows us to lift equalities through arbitrary type constructors; that is, for all datatypes T \nof kind */T . *, we have a coercion that shows T Age ~ T Int . */T. In fact, this notion of coercion \nlifting is not restricted to datatypes (like List),butisavailable for more general contexts. More precisely, \ngiven an arbitrary type s with free variable a of kind */T, we can also create a coercion s[a . Age] \n~ s[a . Int] . */T. We create such coercions with thelifting operation. This opera\u00adtion replaces type \nvariables by coercions in types to produce a new coercion, relyingonthefact thatthe syntaxof typesisa \nsubsetof the syntax of coercions: DEFINITION 7 (Lifting Operation). De.ne the lifting operation, written \n.[a . .], by induction on .. a[a . .]= . b[a . .]= b when a = b H [a . .]= H (..)[a . .] =(.[a . .]) \n(.[a . .]) (.b :..s)[a . .]= .b :..(s[a . .]) The lifting operation produces a valid result as long as \nthe role of the lifted coercion matches the role of the type variable in the type. LEMMA 8 (Lifting). \nIf G, a:./R f s : . and G f . : . ~ . . ./R, then G f s[a . .]: s[a . .] ~ s[a . . ] . .. In other words, \nif a were used in some indexed context in s, that is, if its role were C, then we would not be able to \nlift the coercion Age ~ Int . */T in s.We generalize lifting to replace multiple type variables simultaneously \nin the obvious way, with notation s[a . .].  3.5 Pattern matching and datatypes FC2 includesaformalizationof \nrecursivedatatypes. These datatypes includeallGHCextensionsto standard datatypes:empty datatypes, nested \ndatatypes, existential types, .rst-class polymorphism and GADTS. Both datatypes T and data constructors \nK must be de\u00adclared in a context G beforethey canbe used.Forexample,using the syntax for G in Figure \n1, the declarations for the data construc\u00adtors of List are: List : */T . * Nil :(a: */T). List a Cons \n:(a: */T). a . List a . List a What about GADTs? Here s an example in Haskell: data Rep a where Rint \n:: Rep Int Rlist :: Rep a . Rep (List a) Although a Haskell programmer writes the data constructors \nof a GADT with non-parametric result types, in the internal type system it is simpler in the formalization \nfor the result type of a data constructor to take the form (Ta1 ... an ), where the a are the type parameters,using \nequality constraintstoexpresstheindexing, thus: Rep : */C . * Rint :(a: */C).(a ~Int) . Rep a Rlist :(a: \n*/C).. (b : */C).(a ~List b) . Repb . Rep a Notice here that Rep s kind expresses that its argument is \nan index (role C)rather than a parameter (role T). In fact, the C role for variable a falls out naturally \nbecausea appears as argument to the (~*) constructor (in the type of Rint and Rlist), which in turn requires \nit to have role C. More generally, we use the notation of telescopes [de Bruijn 1991] to conveniently \nexpress the types of data constructors. Fig\u00adure1de.nesa telescope T like this: T ::= \u00b7| a:., T | .1 ~ \n.2, T | s, T Atelescope is like a mini-context: a list of type variable bindings, equality propositions \n(between codes only) and types that classify each argument of the data constructor. (Note that a type \nvariable context . isalsoa telescope.)We de.nethe syntacticsugar . T.s as follows: DEFINITION 9 (Telescope \nsyntactic sugar). .\u00b7 .s = s . (a:., T).s = .a :..(. T.s) . (.1 ~ .2, T).s =(.1 ~.2) . (. T.s) . (s, T).s \n= s . (. T.s) At each useofa data constructor (ruleEDATACON), we check that the declaration of a data \nconstructor is of the form K :. a : ..(. T.T a) where a : . lists the type parameters of the datatype, \nT describes the types of the arguments to the data constructor, and T a is syntactic sugar for the application \nof T to those parameters (i.e. ((Ta1) ... an )).Forexample, the List type hasa single parame\u00adter a: */T, \nthe constructor Cons has telescope (a, List a, \u00b7), and constructs type List a. Likewise, the Rep type \nhas the parameter a: */C, the telescope for Rlist is (b: */C, a ~ List b, (Rep b), \u00b7), and the result \ntype is Rep a.  G f . :T .0 = sym (nth 0 .) .1 = nth 1 . SSPUSH ((.x:s1.e1) c.) e2 (.x:s1.(e1 c.1)) \n(e2 c.0) f G TNIL G f\u00b7 : \u00b7 S f . : .a :..s1 ~.a : ..s2 . */T SSTPUSH ((.a:..e) c.) . (.a:..(e c.@a)) \n. G f e : s G f . :T TCONSE G f e,. :(s, T) S f . :(~.) .1 .2 s ~ (~.) .1 .2 s . */T .0 = nth 0 ..1 \n= sym (nth 1 .) .2 = nth 2 . G f . : . G f . : T[a . .] SSCPUSH TCONST ((.c :.1 ~.2.e) c.) . (.c : .1 \n~.2.(e c.2)) (.0 ; . ; .1) S f . : T . ~ T . . */T K :. a : ..s . S SSKPUSH cases (K ..) c. of brs \ncases K . (.cs[a . nth .]) of brs Figure 5. Operational Semantics (Push rules) Telescope notation is \nalso used for case expressions in rule ECASE (Figure 2). The type of the scrutinee of the case must be \nheaded by a datatype constant T . Furthermore, for each data constructor that could create a T , there \nmust be a corresponding branch. The (elided) function ConstrG(T ) looks up the construc\u00adtors of T from \nthe context. After substituting for the parameters, the branch for data constructor Ki must abstract \nthe same argu\u00adments as Ki and return the same result type as the entire case.To make sure that typechecking \nis syntax directed even when there are no branches (for empty datatypes), the case expression is an\u00adnotated \nwith its result type s, and we must check that this type is well-formed in the current context.  3.6 \nOperational semantics: pushing coercions The operational semantics of FC2 is based on a small-step call\u00adby-name \noperational semantics for a polymorphic lambda calcu\u00adlus. Although this language includes explicit type \nabstraction and application (as well as explicit coercion proof abstraction and ap\u00adplication), types \nand coercions are not relevant at run time. All such abstractions and applications, as well as uses of \ncoercions e c. may be erased prior to execution and so impose no run-time costs. As alluded to above, \nthis operational semantics preserves coer\u00adcion proofs, which allows us to establish type safety using \nstandard syntactic proofs of progress and preservation (described in the next section). The most important \nrules of the operational semantics are those that push coercions when theyappear in active positions \nso that theydo not interfere with reduction. Figure5shows the rele\u00advant pushing rules. (The complete \nrules of the operational seman\u00adtics are listed in the extended version.) In some of the push rules, the \ncoercion must be checked to constrain the types that it proves equal. This checking happens in a global \ncontext S that contains only the de.nitions of data constructors, data types, and coercion axioms. Note \nthat these checks are not actually necessary at run\u00adtime, in a consistent context these checks will always \nsucceed. The .rst three rules show how in an application of a coerced abstraction, the term steps to \na new application, where the coer\u00adcion has been decomposed into a coercion for the body of the ab\u00adstraction, \nand a coercion of the argument. For example, consider SSPUSH. Here, the . is a coercion between some \nfunction types s1 . s1 and s2 . s2. The rule uses nth and sym to decompose . into two coercions, one \nfrom s2 ~ s1 (the order is reversed to account for contra-variance) and one from s1 ~ s2. These new coercions \ncan be pushed to the body of the lambda and the function argument,exposing the reduction. RulesSSTPUSHandSSCPUSH \nwork analogously. G f ., . :(a:., T) G f . : .1 ~ .2 . ./C G f . :T TCONSC G f ., . :(.1 ~ .2, T) Figure \n6. Telescope rules Note that SSCPUSH justi.es the kind of (~.), which requires that the .rst two arguments \nbe codes. If we had assigned (~.) the parametric kind ./T . ./T . */T . *, then the coercions .0 and \n.1 in the rule would both be type coercions. However, type coercions cannot be composed with . to form \na code coercion, which is the role required for the right hand side of the rule to typecheck. The last \nrule, SSKPUSH, pushes the coercion of a data con\u00adstructorinthe scrutinee positionofacaseexpressioninto \ncoercions of the arguments of the data constructor. The arguments of a data constructor, notated ., can \neither be an expression, a type, or a co\u00adercion. . ::= e | . | . If the declared type of the data constructor \nK is . a : ... T.T a, and the type parameters are ., then we know that the arguments can be typed using \nG f . : T[a . .] (see Figure 6). However, pushing the coercion changes the type parameters to be . , \nso the new arguments must have type T[a . . ]. These new arguments are producedby coercing the listof \nargu\u00adments . with the coercion generated by lifting as described above. (The notation s[a . nth .] means \nthat variable ai is lifted to co\u00adercion nth i..) Once this coercion has been de.nedby lifting, we use \nit to coerce the list of arguments of the data constructor with the following operation. DEFINITION 10. \nDe.ne argument coercion .c. by induction on .: \u00b7 c . (e, .) c .1 . .2 (., .) c .a : ...2 (., .) c (.1 \n~.2)..3 = = = = \u00b7 (e c .1), . c .2 ., . c .2 (sym .1 ; . ; .2), . c .3 Argument coercion coerces a list \nof arguments as described by the following lemma. LEMMA 11. If G f . :T and G f . : . T.s ~. T .s . */T \nthen G f (.c.):T 4. Type safety and consistency The FC2 language supports a straightforward proof of \ntype safety based on the usual preservation and progress theorems. Impor\u00adtantly, the progress theorem \nholds only for consistent contexts those that cannot equate Int and Char, for example. Below, we state \nthe progress and preservation theorems andgiveaprecise def\u00adinition of consistency. In the next subsection, \nwe formulate suf.\u00adcient conditions for proving that a context is consistent.  4.1 Preservation and progress \nThe preservation proof for FC2 is standard, relying on the usual regularity and substitution lemmas for \nthe various judgement forms. For space reasons, we omit those de.nitions here and in\u00adstead refer the \nreader to the extended version. THEOREM 12 (Preservation). If G f e1 : s and e1 e2 then G f e2 : s. The \nprogress theorem holds only for closed,consistent contexts. Acontext isclosed ifitdoesnot containanytermvariable \nbindings. We use the metavariableS for closed contexts. The de.nition of consistency and the canonical \nforms lemma (necessary to showthe progress theorem) are both stated using the notions of uncoerced values \nand their types, value types. Value types include all types except those that are headed by a variable \na or type function/newtype F .Formally, we de.ne values v and value types t, with the following grammars: \nt ::= T | (.) | (~.) |.a : ... | t. v ::= .x:s.e | .a:..e | .c :.1 ~.2.e | K .. The canonical forms lemma \ntells us that the shape of a value is determined by its type:3 LEMMA 13 (CanonicalForms). Say S f v : \ns. Then s is a value type. Furthermore, 1. If s = s1 . s2 then v is .x:s1.e or K ... 2. If s = .a :..s \nthen v is .a:..e or K ... 3. If s =(.1 ~.2) . s then v is .c :.1 ~.2.e or K ... 4. If s = T .1 then \nv is K ...  In FC2,notall irreducibleformsarevalues.Evaluationcanalso produce a coerced value of the \nform v c., which erases to a value when coercions are dropped. To prove the progress theorem, we must \nreason about what sort of coercion . could be so that we can appropriately apply the push rules in Figure \n5. In the statement of the progress theorem, because . coerces the value v, we know (by ECOERCE and canonical \nforms) that . : t ~ s the left type is a value type t . Consistency of the axiom set assures us that \nif s is also a value type, it must have the same head form. DEFINITION 14 (Consistency). AcontextG is \nconsistent if when\u00adever G f . : t1 ~ t2 . ./T it is the case that 1. If t1 is T .1 then t2 is T .2. \n2. If t1 is (.) .1 then t2 is (.) .2. 3. If t1 is (~.) .1 then t2 is (~.) .2. 4. If t1 is .a : ..s1 \nthen t2 is .a : ..s2.  Putting these observations together, we obtain: THEOREM 15 (Progress). If S is \nconsistent and S f e1 : s and e1 is not a value v or a coerced value v c., then there exists an e2 suchthat \ne1 e2.  4.2 Determining consistency Although the previous subsection gives a de.nition of when con\u00adtexts \nare consistent, it does not provide anymechanism for deter\u00admining whether a set of axioms leads to a \nconsistent context. This subsection de.nes suf.cient conditions (written Good G) for establishing context \nconsistency these conditions are not the only way to show consistency(theyare not necessary)but theyare \npermissive enough to cover the axioms generated by compilation of typefamily declarations and newtype \nde.nitions. 3Note that all forms of value type must include partial applications of data constructors. \nG f .. . . G f a : . . ./R G f . . . ./R RVAR G f a . a . . ./R H :. . . . G G f .. . ./R RCONST G f \nH . H . . ./R G, a:. f ss . */R RALL G f.a :..s .a : ..s . */R H :.1 . (.2 . .) . G G f .1 .1 . .1/R \nG f .2 .2 . .2/R G f c . : H .1 ~ s . .2 . ./R RRED G f H .1 .2 s.2 . ./R G f .. . ./R RNIL G f\u00b7 \u00b7.\u00b7/R \nG f .. . ./min(R1,R2) G f .. . ./R1 RCONS G f .,. ., . . ./R2, ./R1 Figure 7. Type rewriting As in the \nprevious version of FC, we show consistency by (i) de.ning a rewrite system for types and (ii) proving \nthat two types are joinable (share a common reduct) if and only if there is some coercion proof between \nthose types. The rewrite system guarantees that value types preserve their head form throughout rewriting \nand therefore value types with different head forms can never be equated. 4.2.1 Rewriting and joinability \nFigure7gives our rewrite relation, whichisavariantof parallel reduction it looks throughout the type, \ntrying to .re reductions. The reduction of a type headed by a constant H is implemented in rule RRED. \nIf, after the arguments to H have been reduced to . , there is some instantiation of an axiom such that \nH applied to some pre.x of the . matches the left-hand side of the coercion, then the type may reduce \nto the right-hand-side type(RRED). Importantly, rewriting (very much like coercibility) takes roles into \naccount: rewriting occurs at some role R, which speci.es what axioms are available.Forexample,at role \nT we can rewrite a newtype Age to its de.nition Int,but at role C, we cannot. Notice that rules RCONST \nand RRED overlap. The term H . may reduce usingamatching axiom for H (via ruleRRED),but not necessarily \n(viaRC ONST).With ruleRCONST,the rewrite relation is re.exive. LEMMA 16. If G f . : . then G f .. . .. \nThe joinability relation, below, is simply reduction to a common reduct after zero or more steps. DEFINITION \n17 (Joinable). Two types arejoinable if theyshare a common reduct. De.ne G f .1 . .2 . . if G f .1 * \n. . . and G f .2 * . . ..  Re.exivity of the rewrite relation is crucial for joinability of type applications \nwith multiple arguments. Consider the axiom c : F Int ~ (F Int, F Int)/C and the following two types: \n.1 = T (F Int) (F Int, F Int) .2 = T (F Int, F Int) (F Int) We dcertainlylike.1 and .2 to be reducible \nto a common reduct (after all, thereexistsa coercion term between them),but the .rst argument of T in \n.1 lags behind compared to the .rst argument of T in .2, whereas the second argument in .1 advances ahead \ncompared to the second argument in .2. Re.exivity allows us to freeze the reduction of the second argument \nin .1 while reducing the .rst, and similarly for .2 which allows us to join the two types.  4.2.2 Soundness \nand completeness of the rewrite relation Wenowgivesuf.cient conditions on contexts which ensure that \nthe rewrite relation of Figure7is sound and complete with respect to coercibility. Hence, these are suf.cient \nconditions for consistency. DEFINITION 18 (Good contexts). We haveGood G when the fol\u00adlowing conditions \nhold: 1. All axioms in G are of the form c :.. F . ~ ./R. Let a = dom(.) and . be the corresponding kinds.Foreverywell \nkinded . and result types . , such that G f (.[a . .]) . . . /R it must be . = .[a . . ] for some . \nwith G f .. . ./R. 2. Thereisnooverlap between axioms.For each F . there exists at most one pre.x .1 \nof . suchthat thereexist c,. and . where G f c . : F .1 ~ . . .. This c is unique for every matching \nF .1.  The .rst condition above restricts the declared arguments of type functions to behave like patterns. \nIt merely states that all the reductions that can possibly happen when we substitute types for . do not \ninvolve reductions from . but only reductionsinside those substitutedtypes.This conditionisageneralized(andmorelenient) \nform of the current GHC restrictions on typefamily declarations, which only allow value types or variables \nas .. The second condi\u00adtion is simply a strong non-overlapping condition. Interestingly, the .rst condition \non the arguments to type func\u00adtions restricts the kind thata type function mayhave.Forexample, recall \nthe axioms for F from Section 2.2: axF1 : F Int ~ Bool/C axF2 : F Age ~ Char/C For this to be aGood axiom \nset, the kind of F must be */C . * because the newtype Age is irreducible only in role C. In the rest \nof this section, we sketch the proof that our conditions aresuf.cientfor consistency. Soundnessisastraightforward \nproof. THEOREM 19 (Soundness). If if Good G and G f .1 .2 . . then there is some . suchthat G f . : \n.1 ~ .2 . .. Thethreekeylemmasofthe completenessproofarethat joinability is preserved under application \nand substitution andalocal diamond property of rewriting. LEMMA 20 (Application). If Good G and G f .1 \n. .1 . (.1/R1 . .2)/R2 and G f .2 . .2 . .1/min(R1,R2) then G f .1 .2 . .1 .2 . .2/R2. THEOREM 21 (Local \ndiamond property). If Good G and G f ..1 . . and G f ..2 . . then there exists a .3 suchthat G f .1 .3 \n. . and G f .2 .3 . .. LEMMA 22 (Substitution). If Good G and G, a:., . f s * s . . and G f . * . . ., \nthen there is some G, . f s[a . .] . s [a . . ] . . . From these lemmas we see that joinability is complete. \nTHEOREM 23 (Completeness). If Good G and G f . : .1 ~ .2 . . then G f .1 . .2 . .. THEOREM 24 (Consistency). \nIf Good G then G is consistent. Proof Suppose G f . : t1 ~ t2 . */R, where t1 and t2 are two value types. \nBy completeness, we have that those two types are joinable, i.e. that there is some . such that G f t1 \n* . . */R and G f t2 * . . */R.However,byinversion on the rewriting relation, we see that it preserves \nthe head forms of value types (since there exist no axioms for those by the .rst condition of Good G). \nThus, t1 and t2 (and .)have the same head form. A different novelty of our approach compared to previous \nwork [Sulzmann et al. 2007] is that establishing the complete\u00adness theorem, and therefore type soundness, \ndoes not depend on strong normalization. Our de.nition of Good G that (i) forces the declaredtypefamilyargumentstobehavelike \npatterns,and(ii)im\u00adposes strong (stronger than the previous work) non-overlapping conditions, is suf.cient \nto show completeness. With this new approach, a programmer can be con.dent that, even in the presence \nof possibly non-terminating type functions, if the compiler can show that the programis well-typed then \nthe program will not crash. Although type checking is undecidable in general without strong normalization, \nthere may be manyprograms that the compiler can actually type check, and this approach shows that those \nprograms are type sound. 5. Compilation from source Haskell In the previous sections we have informally \npresented the transla\u00adtions of Haskell source features such as datatype, typefamily, and newtype declarations \ninto FC2.We summarize them here:   data T . where Ki : s . T : ...*, Ki :..s type family F : ./C . \n. . F : ./C . . type instance ..F . = . .  cF :..F . ~ . . ./C newtype ..M a = MkM . . M :..*, MkM \n:..M a ~ . . */T In addition, uses of the data constructor of a newtype, both in termsand patterns,aretranslatedtoauseofthe \ncorresponding coer\u00adcionintheobviousway.The importantpartsofthese de.nitionsare that(i)typefamilies acceptcodearguments,(ii)type \ninstancesgive risetocode equalities,and(iii)newtype de.nitionsgiverisetotype equality axioms. The bindings \ngenerated in this way can be easily checked for well-formedness. If, in addition, the resulting context \nis Good (see Section 4.2) the only possible problemis the poten\u00adtialto generateoverlapping type instance \ndeclarations then the context is consistent, which in turn guarantees type safety. Notice that the sourcelanguage \nfeaturesin this translationhave been already annotated with their kinds. This is a reasonable as\u00adsumption. \nPrior to type inference, which translates a source dec\u00adlaration to an FC2 binding, we must have determined \nthe kinds involvedinthe declarations.Forthe purposesofthispaper,weas\u00adsumethatthekindsaregiven in practicetheywouldbetheoutput \nof a kind inference process, potentially guided by the user to dis\u00adambiguate role information and higher-order \nkinds.  Newtype deriving Generative type abstraction is achieved in Haskell using the newtype deriving \nmechanism, which al\u00adlows type classes to be automatically lifted to new types.For in\u00adstance, we may write \n newtype Age = MkAge Int deriving Eq The type class Eq a is a standard class in Haskell (signature, \nin ML terminology) that de.nes one method, eq :: a . a . Bool. For the type checker, a type class is \nnothing but a record type containing the method eq. The deriving line automatically generates an implementation \nof Eq Age from a pre-existing in\u00adstance Eq Int. This can be done by simply applying a coercion Eq Int \n~ Eq Age to the old record. It is straightforward to con\u00adstruct this coercion: lift the Age ~ Int axiom \nfrom the newtype de.nition over the Eq constructor and apply symmetry. Impor\u00adtantly, this lifting is \nsafe because Eq has a parametric kind of the form */T . *. However, if a type class has a indexed kind \nof the form */C . *, newtype deriving is no longer sound.For example  class Cx where op::F x . x instance \nC Int where ... newtype Age = MkAge Int deriving C It is unsound to lift the C Int implementation to \na C Age, pre\u00adcisely because x has role C. The documented GHCbug mentioned earlier arises precisely as \nthe result of such an unsound lifting over a non-parametric type class. 6. Discussion 6.1 Relaxing decomposition \nRecall the coercion decomposition rule, CNTHT, from Figure 4. This rule allows us to deconstruct an equality \nof the form G f . : T . ~ T . . ./T. In effect, it assertsthat data constructors are injective. The rule \nis important because it is used in the operational semantics to ensure subject reduction. However, the \ndecomposi\u00adtion rule may be somewhat restrictive for some Haskell source pro\u00adgrams. Consider the following: \nnewtype M a = MkM (Maybe [a]) data Eq a b where EQ::Eqa a f::Eq(M a) (M b) . a . b fEQx = x Pattern matching \nagainst theEQ constructor introduces a coercion between Ma and Mb, which cannot be decomposed using the \nCNTHT rule to obtain a ~ b, so this program cannot be typed. Nevertheless, we know that M is injective, \nbecause Ma is de.ned to be equal to Maybe [a], which is clearly injective. On the other hand, the following \nnewtype is not injective. type instance G a = Char newtype N a =MkN(G a) Here, it is possible to derive \nG f . : N Int ~ N Char . */T, using the axiom for G, even though Int is not coercible to Char. It turns \nout that newtype de.nitions are always injective with respect to code equality, but they might not be \ninjective with re\u00adspect to type equality (as illustrated by the two examples above). Thus it would be \nsound and potentially useful (but not necessary for type soundness) to introduce yet another decomposition \nrule for newtype de.nitions that takes advantage of injectivity with respect to codes (we use metavariable \nN newtypes): G f . : N . ~ N . . ./C N :. . . . G . /R = nth k . CNTHN G f nth k . : nth k . ~ nth k \n. . . /R The only subtle part of this rule is that R is not related to R , since the equality G f . : \nN . ~ N . . ./C is a C-equality (and min(C,R )= C). Arguably, decomposition for injective type functions \nis also de\u00adsirable, were we able to effectively specify and check that property.  6.2 Other technical \ndifferences of FC2 from System FC The intermediate language FC2 described in this paper is a sig\u00adni.cant \nmodi.cation of System FC [Sulzmann et al. 2007] due to the introduction of codes. However, FC2 also makes \na number of technical simpli.cations: The original System FC presentation includes coercion kinds, s1 \n~ s2. The original coercion language includes three ad\u00additional constructs, one to coerce coercions, \nand two more to decompose coercion kinds. By treating (.1 ~ .2) . .3 as the application of a constructor \n(~.) we no longer need any of these constructs in the operational semantics, nor have we identi.ed any \nuses of these constructs that are not encodable.  The operational semantics rules of FC2 in Figure 5 \nnot only use simpler coercion constructs,but are alsoexpressed without need for substitutions, contrary \nto their original FC versions.  FC2 replaces the FC coercions left and right, which decom\u00adposed arbitrary \ntype applications, by nth, which decomposes only the application of a datatype constructor. This allows \nus to lift a tiresome restriction in in System FC, namely that type functions were requiredtobe saturated.Typefamily \nsaturation was necessary in FC, in order to prevent the decomposition of equalities as F a ~ Maybe [a] \nvia left or right. Allowing unsat\u00adurated functions increases the expressiveness of FC2, because we can \nnow abstract over type functoins, and also opens new directions for future research on typeinference \nin the presence of unsaturated type functions.  However, using nth instead of left and right does carry \na small price. Generalizing the example from Section 6.1, should this program be well typed?  data Eq \na b where EQ :: Eq a a f::Eq(p q) (r s) . q . s fEQ x = x To type it we must decompose a proof thatpq \n~ rs to geta proof that q ~ s, which right could do,but nth cannot. Some other differences are presentational: \n System FC used a common syntax for types and coercions, whichisaconvenientpun,buthas turnedouttobe more \ncon\u00adfusing than helpful. In FC2 we use a distinct syntax for types and coercions (Figure 1).  In FC2 \nwe de.ne top-level axiom schemes c :...1 ~ .2/R directly, and fully instantiate them at every occurrence \nwith the form c. (Figure 1). System FC instead de.ned a top\u00adlevel axiom scheme as an equality between \npolytypes, thus  c : ....1 ~....2. Here again FC is confusing (but not wrong) so in FC2 we opt for telling \nthe story more directly, albeit with slightly more syntax. Moreover the kinding rules for . (PALL and \nCALL)can insist that the body of the forall has kind * as is conventional.  Using telescopes in the \ntreatment of datatypes simpli.es the operational semantics rules but is also (only slightly) more expressive: \nThe types of data constructors do not have to have their quanti.ed variables preceding their coercion \nand term arguments. Instead, telescopes allow arbitrary interleavings. 7. Related work Previous work \non System FC [Sulzmann et al. 2007] discusses a signi.cant amount of related work, in typed languages \nwith ex\u00adplicit proof witnesses [Licata and Harper 2005; Shao et al. 2005], or in calculi that support \ncoercions [Breazu-Tannen et al. 1991]. Be\u00adlow, we present related work in generativity and abstraction, \ntype\u00adindexed constructs and the separation between codes and types. Generativity, abstraction, and module \nsystems Generativity and abstractionhasbeen studiedextensivelyinthe contextofMLmod\u00adule systems [Milner \net al. 1997]. Russo shows how generativity in module systemsis connectedtoexistential quanti.cation [Russo \n1999] and Dreyer [2005] has studied this connection in the presence of recursive modules. Montagu andR\u00b4 \nemy [2009] re.ne this con\u00adnection by introducing open existential types. Rossberg [2008] uses .exible \ngenerativity to explain ML-style module sealing. Type abstraction can be understood in terms of dynamic \nname generation [Rossberg2003; Vytiniotis et al. 2005], which can re\u00adestablish abstraction properties \nin languages with dynamic type analysis. Neis et al. [2009] prove a parametricity theorem in this setting. \nIn addition, they use a translation from polymorphism to generative types to establish the parametric \nbehavior of certain functions although theywork in a non-parametric language. Although many of these \nlanguages support type generativity and non-parametric features, they do not exhibit the soundness problems \ndescribed in the paper,mainly due to the absence of type\u00adlevel type dispatching. Nevertheless, the techniques \ndeveloped in the aforementioned related work wouldbe valuable in the formal study of the parametricity \nproperties of FC2. Type-indexed types Although many systems for generic pro\u00adgramming support dynamic \ncomputation based on types, very few systems allow the structure of types to be destructed to produce \nother types. However, suchfacility is often necessary to describe the type of generic programs.Forexample, \nHarper and Morrisett include a Typerec operator to their typed intermediate language .ML i [Harper and \nMorrisett 1995], to describe type-directed opti\u00admizations. (Theycredit NuPRL s mechanism of Universe \nElimi\u00adnation in NuPRL as the inspiration for this operation [Constable 1982; Constable and Zlatin 1984].) \nTo support generic programming in source languages, Hinze, Jeuring andL\u00a8oh added Type-Indexed Datatypes \n[Hinze et al. 2002] to the Generic Haskell front end. In later work, Chakravarty et al. [2005b] introduced \nassociated datafamilies in GHC, which are type-indexed datatypes associated with type class instances. \nExtending this work, they later introduced associated type syn\u00adonyms [Chakravarty et al. 2005a], which \nare proper type-level func\u00adtions with instances associated with type class instances. Currently, the \nsource language of GHC also supports standalone type-level type functions, often referred to as indexed \ntype families [Kise\u00adlyov et al. 2010; Schrijvers et al. 2008], a feature that we have extensively used \nin our presentation. Codes, types, and interpretations Our distinction between codes and types and our \nterminology is inspired by similar notions in intuitionistic type theory [Benke et al. 2003; Dybjer 2000; \nMartin-Lof 1975]. There, types (sets) \u00a8are constructed as the recursive interpretation of codes, which \ninhabit inductively constructed code universes.A newtype de.nition can be viewed as giving rise to a \nnew code, inhabiting an open universe of codes, and whose interpretation coincides with the interpretation \nof its de.nition. Languages based on dependent type theory,such as Agda [Bove etal.2009]orCoq[TheCoqTeam], \nnaturallyoffertype-level com\u00adputation to construct types, but they allow elimination of codes only, not \ntypes. Therefore, theydo not exhibit the same soundness problem, as the expressiveness of these languages \ncan readily en\u00adforce the distinction between types and codes. The disadvantage is the extra programming \nverbosity of explicit de.nitions and in\u00adterpretationsof codes.To better support generic programming, \nthe dependently-typed language Epigram [Chapman et al. 2010] iden\u00adti.es types with their code universes. \nThe LX language [Crary andWeirich 1999] also uses universe constructions to solve problems with type-directed \ncompilation. When the type translation in a compiler pass is not the identity then type dispatch must \nbe compiled to code dispatch (so the gen\u00aderated code can dispatch on source types instead of target types). \nThe interpretation of codes is then the type translation. To sup\u00adport universes, LX includes datakinds \n(for codes) and primitive re\u00adcursive functions over datakinds (for their interpretation at types). In \nLX, source types Age and Int would be mapped to de.nable codes AgeCode and IntCode, and would be accompanied \nby an interpretation function such that interp(AgeCode) equals Int and interp(IntCode) equals Int. Therefore, \nthe prob\u00adlem with generativity would not show up in that context. If one wanted to solve the problem \nin this paper along the LX lines, one wouldhaveto translate source Haskell typestovoid types that stand \nin as codes and handle the interp() function as anyother type function. This function, as well as interpreting \nthe codes as types, would have to be accompanied with suitable congruence axioms, like interp(T t) ~ \nT (interp(t)). Explicitly introduc\u00ading these axioms means that coercions would be signi.cantly more verbose. \nOur system dispenses with an explicit interp() func\u00adtionbyconvenientlyusingtherolesinthe judgementsto \ndetermine whether we wish to derive an equality between codes or between their interpretations. 8. Conclusions \nand future work Inthispaperwehaveidenti.edaproblemforthesafe interactionof .exibletype generativityandtype-level \ncomputation.Wehavepro\u00adposedasolution that distinguishes between indexed and parametric type contexts, \nby extending the language of kinds, and formalized the solution in the FC2 language.Wehave severalavenues \nfor fu\u00adture research in mind, which we outline below. Source language technology We would like to work \non ways to expose the FC2 expressive features to programmers. Speci.c directions are: enriching the kind \ndeclarations with the ability to declare parametric or indexed type-level constructs, introducing typefamily \ninjectivity annotations,extending kind inference with roles,andextendingtype inferenceto support unsaturated \nfunctions using the more sophisticated kinds. Enriching the universes of codes with terms We are currently \nworking on enriching the universe of codes with constants or func\u00adtions drawn from the term syntax, such \nas data constructors, in or\u00adder to enable direct dependently-typed programming in Haskell. More roles \nLemma6asserts that the equivalence classes induced by T-equality are re.ned by C-equality. However, our \napproach readily extends to arbitrary lattices of roles with gradually more re.ned equivalence classes \nas we move down the d relation. Consider, for example, a lattice with new roles C1 and C2, each lying \nbetween C and T, but incomparable with each other. These two roles model partial knowledge of newtype \nequalities. For example, perhapsC1 identi.es Age and Int but distinguishes a different newtype Moo from \nits de.nition Bool. Conversely, C2 can identify Moo and Bool and distinguish Age and Int. These more \nprecise roles could be used to give more precise types to nonparametric functions by identifying exactly \nwhich newtype equivalences theydo and do not respect. However, we have not yet explored the practical \nimplications of this precision.  Furthermore, one could explore adding a role above T. Type functions \nwith kind */T . *, are not necessarily parametric in FC2. For example, because G below does not match \nnewtypes it may be assigned either kind */T . * or */C . *. axG1 : G Int ~ Bool/C axG2 : G Bool ~ Char/C \nTo distinguish truly parametric functions from those like G, we could add a role P, induced by the relation \nthat equates all types of the same kind. As this equivalence is coarser than T, it could not (and should \nnot) participate in coercions. However, this new role would provide a yet more descriptive kind for type \nfunctions. Acknowledgements We thank Brent Yorgey and the attendees of the Type System Wrestling sessions \nat MSR Cambridge for manyuseful discussions. We wrote this paper using the Ott tool. This work was partially \nsupportedby grants fromDARPA(CSSG) and NSF (0910786) and a SloanFoundation fellowship. References M. \nBenke,P. Dybjer, andP. Jansson. Universes for generic programs and proofs in dependent type theory. NordicJ. \nof Computing, 10(4):265 289, 2003. ISSN 1236-6064. A.Bove,P. Dybjer,andU. Norell.Abriefoverviewofagda \na functional language with dependent types. In TPHOLs 09: Proceedings of the 22nd International Conference \non Theorem Proving in Higher Order Logics, pages 73 78, Berlin, Heidelberg, 2009. Springer-Verlag. V. \nBreazu-Tannen,T. Coquand, C. A. Gunter, and A. Scedrov. Inheritance as implicit coercion. Information \nand Computation, 93:172 221, 1991. M. M. T. Chakravarty, G. Keller, and S. Peyton Jones. Associated \ntype synonyms. In ICFP 05: Proceedings of the Tenth ACM SIGPLAN International Conference on Functional \nProgramming, pages 241 253, NewYork,NY, USA, 2005a.ACM. M. M. T. Chakravarty, G. Keller, S. Peyton Jones, \nand S. Marlow. As\u00adsociated types with class. SIGPLAN Not., 40(1):1 13, 2005b. ISSN 0362-1340. J. Chapman,P. \n\u00b4  EvaristeDagand,C. McBride,andP. Morris. The gentleart of levitation. In Proceedings of theFifteenthACM \nSIGPLAN Interna\u00adtional Conference on Functional Programming (ICFP 10), Baltimore, MD, USA, September \n2010. To appear. J. Cheneyand R. Hinze. First-class phantom types. CUCIS TR2003-1901, Cornell University, \n2003. R. L. Constable. Intensional analysis of functions and types. Technical Report CSR-118-82, Department \nof Computer Science, University of Edinburgh, June 1982. R. L. Constable and D. R. Zlatin. The type theory \nof PL/CV3. ACM Transactions on Programming Languages and Systems, 6(1):94 117, Jan. 1984. K. Crary and \nS. Weirich. Flexible type analysis. In Proceedings of the Fourth ACM SIGPLAN International Conference \non Functional Pro\u00adgramming, pages 233 248,Paris, France, Sept. 1999. N. G. de Bruijn. Telescopic mappings \nin typed lambda calculus. Inf. Comput., 91(2):189 204, 1991. ISSN 0890-5401. D. Dreyer. Recursive type \ngenerativity. In ICFP 05: Proceedings of the TenthACM SIGPLAN International Conferenceon FunctionalProgram\u00adming, \npages 41 53,NewYork,NY, USA, 2005.ACM. P. Dybjer. Ageneral formulation of simultaneous inductive-recursive \nde.\u00adnitions in type theory. Journal of Symbolic Logic, 65(2):525 549, 2000. C.V.Hall,K. Hammond,S.L.Peyton \nJones,andP.L.Wadler.Type classes in Haskell. ACMTransactionsonProgrammingLanguagesand Systems, 18(2):109 \n138, Mar. 1996. R. Harper and G. Morrisett. Compiling polymorphism using intensional type analysis. \nIn POPL 95: Proceedings of the 22ndACM SIGPLAN-SIGACT symposium on Principles of programming languages, \npages 130 141,NewYork,NY, USA, 1995.ACM. ISBN 0-89791-692-1.  R. Hinze, J. Jeuring, and A.L\u00a8Type-indexed \ndata types. In B. M. oh. Eerke Boiten, editor, Proceedings of the Sixth International Conference on Mathematics \nof Program Construction (MPC 2002), pages 148 174, Dagstuhl, Germany, July 2002. O. Kiselyov, S. Peyton \nJones, and C. Shan. Fun with type functions. Springer, 2010. D. R. Licata and R. Harper. Aformulation \nof dependent ML with explicit equality proofs. Technical Report CMU-CS-05-178, Carnegie Mellon University \nDepartment of Computer Science, 2005. P. Martin-L\u00a8of. An intuitionistic theory of types: Predicative \npart. In Pro\u00adceedings of the Logic Colloquium, 1973, volume 80 of Studies in Logic and the Foundations \nof Mathematics, pages 73 118. North-Holland, 1975. R. Milner, M. Tofte, and D. Macqueen. The De.nition \nof Standard ML. MIT Press, Cambridge, MA, USA, 1997. ISBN 0262631814. B. Montagu and D.R\u00b4emy. Modeling \nabstract types in modules with open existential types. In POPL 09: Proceedings of the 36th an\u00adnual ACM \nSIGPLAN-SIGACT Symposium on Principles of Program\u00adming Languages, pages 354 365,NewYork,NY, USA, 2009.ACM. \nG. Neis, D. Dreyer, and A. Rossberg. Non-parametric parametricity. In ICFP 09: Proceedings of the 14thACM \nSIGPLAN International Con\u00adference on Functional Programming, pages 135 148, New York, NY, USA, 2009.ACM. \nISBN 978-1-60558-332-7. S. Peyton Jones et al. The Haskell 98 language and libraries: The revised report. \nJournal of Functional Programming, 13(1):0 255, Jan 2003. http://www.haskell.org/definition/. S. L. Peyton \nJones, D. Vytiniotis, S.Weirich, and G.Washburn. Simple uni.cation-based type inference for GADTs. In \nInternational Confer\u00adence on Functional Programming (ICFP), Portland, OR, USA, Sept. 2006. B. C. Pierce, \neditor. Advanced Topics in Types and Programming Lan\u00adguages. MIT Press, 2005. A. Rossberg. Dynamic translucencywith \nabstraction kinds and higher-order coercions. Electr. Notes Theor. Comput. Sci., 218:313 336, 2008. A. \nRossberg. Generativity and dynamic opacityfor abstract types. In PPDP 03:Proceedingsofthe5thACM SIGPLAN \nInternational Conferenceon Principles and Practice of Declaritive Programming, pages 241 252, NewYork,NY, \nUSA, 2003.ACM. ISBN 1-58113-705-2. C.V. Russo. Non-dependenttypesfor StandardML modules.In PPDP 99: Proceedings \nof the International Conference PPDP 99 on Principles and Practice of Declarative Programming, pages \n80 97, London, UK, 1999. Springer-Verlag. ISBN 3-540-66540-4. T. Schrijvers, S. Peyton Jones, M. Chakravarty, \nand M. Sulzmann. Type checking with open type functions. In ICFP 08: Proceeding of the 13th ACM SIGPLAN \ninternational conference on Functional programming, pages 51 62,NewYork,NY, USA, 2008.ACM. Z. Shao, \nV. Trifonov, B. Saha, and N. Papaspyrou. A type system for certi.ed binaries. ACMTrans.Program. Lang. \nSyst., 27(1):1 45, 2005. M. Sulzmann, M. M. T. Chakravarty, S. Peyton Jones, and K. Donnelly. SystemFwith \ntype equality coercions. In TLDI 07:Proceedingsofthe 2007 ACM SIGPLAN International Workshop on Types \nin Languages Design and Implementation, pages 53 66, NewYork, NY, USA, 2007. ACM.  The CoqTeam. Coq. \nURL http://coq.inria.fr. D. Vytiniotis,G.Washburn,andS.Weirich.Anopenandshut typecase.In ACM SIGPLANWorkshopinTypesin \nLanguage Design and Implemen\u00adtation, Long Beach, CA, USA, Jan. 2005. H. Xi, C. Chen, and G. Chen. Guarded \nrecursive datatype constructors. In POPL, pages 224 235, 2003.   \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Modular languages support generative type abstraction, ensuring that an abstract type is distinct from its representation, except inside the implementation where the two are synonymous. We show that this well-established feature is in tension with the non-parametric features of newer type systems, such as indexed type families and GADTs. In this paper we solve the problem by using kinds to distinguish between parametric and non-parametric contexts. The result is directly applicable to Haskell, which is rapidly developing support for type-level computation, but the same issues should arise whenever generativity and non-parametric features are combined.</p>", "authors": [{"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2509695", "email_address": "sweirich@cis.upenn.edu", "orcid_id": ""}, {"name": "Dimitrios Vytiniotis", "author_profile_id": "81100156369", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2509696", "email_address": "dimitris@microsoft.com", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2509697", "email_address": "simonpj@microsoft.com", "orcid_id": ""}, {"name": "Steve Zdancewic", "author_profile_id": "81384616728", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2509698", "email_address": "stevez@cis.upenn.edu", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926411", "year": "2011", "article_id": "1926411", "conference": "POPL", "title": "Generative type abstraction and type-level computation", "url": "http://dl.acm.org/citation.cfm?id=1926411"}