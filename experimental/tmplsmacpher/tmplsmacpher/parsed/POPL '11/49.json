{"article_publication_date": "01-26-2011", "fulltext": "\n Streaming Transducers for Algorithmic Veri.cation of Single-pass List-processing Programs * Rajeev \nAlur Pavol .y Cern\u00b4University of Pennsylvania IST Austria alur@cis.upenn.edu pavol.cerny@ist.ac.at Abstract \nWe introduce streaming data string transducers that map input data strings to output data strings in \na single left-to-right pass in linear time. Data strings are (unbounded) sequences of data values, tagged \nwith symbols from a .nite set, over a potentially in.nite data do\u00admain that supports only the operations \nof equality and ordering. The transducer uses a .nite set of states, a .nite set of variables ranging \nover the data domain, and a .nite set of variables ranging over data strings. At every step, it can make \ndecisions based on the next in\u00adput symbol, updating its state, remembering the input data value in its \ndata variables, and updating data-string variables by concatenat\u00ading data-string variables and new symbols \nformed from data vari\u00adables, while avoiding duplication. We establish that the problems of checking functional \nequivalence of two streaming transducers, and of checking whether a streaming transducer satis.es pre/post \nveri.cation conditions speci.ed by streaming acceptors over in\u00adput/output data-strings, are in PSPACE. \nWe identify a class of imperative and a class of functional pro\u00adgrams, manipulating lists of data items, \nwhich can be effectively translated to streaming data-string transducers. The imperative pro\u00adgrams dynamically \nmodify a singly-linked heap by changing next\u00adpointers of heap-nodes and by adding new nodes. The main \nre\u00adstriction speci.es how the next-pointers can be used for traversal. We also identify an expressively \nequivalent fragment of functional programs that traverse a list using syntactically restricted recursive \ncalls. Our results lead to algorithms for assertion checking and for checking functional equivalence \nof two programs, written possibly in different programming styles, for commonly used routines such as \ninsert, delete, and reverse. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program \nVeri.cation Formal Methods, Model Checking; F.3.1 [Logics and Meanings of Programs]: Specify\u00ading and \nVerifying and Reasoning about Programs Mechanical veri.cation General Terms Veri.cation, Theory, Algorithms \nKeywords transducers, algorithmic software veri.cation, lists * This research was partially supported \nby NSF grants CCF 0915777 and CCF 0905464. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, USA. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 1. Introduction We propose streaming transducers as an \nabstract and analyzable model for programs that access and modify sequences of data items in a single \npass. The idea of using transducers for modeling such programs is a natural one. However, the class of \nregular transductions, which has appealing theoretical properties such as MSO characterization, is de.ned \nby two-way transducers. As an example, consider the reverse transduction that reverses the input string. \nIt is not de.nable using classical one-way transducers (such as Mealy machines), we need a second (backward) \npass during which the output is produced. On the other hand, this transduction can easily be computed \nby a single-pass program that traverses a list both in the settings of imperative programs manipulating \nheap-allocated lists and functional programs using tail recursion. Our streaming transducer model can \ncapture such computations naturally. Furthermore, we show that veri.cation problems such as checking \nfunctional equivalence, assertion checking, and checking correctness with respect to pre/post conditions, \nare decidable for this transducer model, even in the presence of values from an unbounded data domain. \nIn the proposed model, a (deterministic) streaming data-string transducers map input data strings to \noutput data strings in a sin\u00adgle left-to-right pass in linear time. A data string is a sequence of items \nof type data \u00d7 tag,where data is a potentially in.nite set of data values, and tag is a .nite set of \nlabels. The only operations allowed on the type data are tests for equality and ordering, and this restriction \nis essential for decidability. The transducer uses a .nite set of states, a .nite set of variables ranging \nover data,and a .nite set of variables ranging over data strings. At every step, it can make decisions \nbased on the current state, the tag of the next input symbol, and the ordering relationship of the data \nof the next input symbol with the data values stored in data variables. It can update the state, modify \ndata variables using the input data value, and up\u00addate the data-string variables using assignments whose \nright-hand\u00adsides are concatenations of data-string variables and new symbols formed using data variables. \nA key restriction is that a data-string variable can be used at most once in a right-hand-side expression \nat each step. Multiple data-string variables are necessary for the transducer to compute different possible \nchunks of the output, and the restriction on how they can be used ensures that at every step there is \nmerely a rearrangement of outputs computed so far without duplication. We consider the following two \ndecision problems for streaming transducers: (1) Equivalence: given two streaming transducers, do they \nde.ne the same (partial) functions? (2) Pre-post condition checking: given a streaming transducer, a \npre-condition and a post\u00adcondition, both expressed by similarly de.ned streaming acceptors over data \nstrings, is it the case that for every input satisfying the pre\u00adcondition, the corresponding transducer \noutput satis.es the post\u00adcondition? We show both problems to be in PSPACE. We also show that extending \nthe model along several possible directions leads quickly to undecidability of basic problems such as \nreachability.  We then identify a class of programs that precisely correspond to the streaming data-string \ntransducers. The input to a program is a single list with elements of type data \u00d7 tag, possibly with \nadditional arguments of types data, tag,and bool, and the output is a single list, possibly with additional \nreturned values of types data, tag,and bool. The key restriction, needed for decidability of veri.cation \nproblems, is that the program computes the output in a single pass processing the next item of the list \nat each step. A number of commonly used routines such as insertion, deletion, membership, reversal, sorting \nwith respect to tags (but not data values), naturally satisfy this restriction. For heap-manipulating \nimperative programs, the input list is stored in a heap of nodes each of which can store a tag, a data \nvalue, and a next-node pointer. During the computation of the program, the next-pointers induce an unranked \nforest structure over the nodes. The program accesses the heap using a .nite number of pointer variables \nand uses a .nite number of data variables. The program can add new nodes to the heap, change values stored \nat nodes referenced by pointer variables, and also modify next\u00adpointers of such nodes. A key restriction \non the traversal of the heap using next-pointers is that the only legal use of the next-.eld on the right-hand-side \nis in the assignment curr := curr.next,where curr is the unique pointer initially pointing to the head \nof the input list. We also show that for this class of programs, a variety of assertion checking problems \n(such as is a program location reachable, and does the heap stay acyclic ) are solvable in PSPACE. Finally, \nwe present a class of list-processing functional pro\u00adgrams which traverse an input list from left to \nright using recursive calls. The key restriction is that a call to the function f with input list l can \nrecursively call f with input tail l, and returns value obtained by composing its input arguments and \nthe values returned by the recursive call without examining them. We show that this class precisely corresponds \nto the streaming data string transducers. Thus, the results of this paper show how to automatically compile \ntwo list-processing programs, one written in imperative style, and one written in functional style, into \nan intermediate low-level trans\u00adducer model, and algorithmically check if the two are semantically equivalent. \n 2. Streaming transducers 2.1 Data strings and transductions A data domain is a totally ordered, possibly \nin.nite, set D of data values. We will use < to denote the strict total order over D. Throughout this \npaper, assume D to be .xed. A data symbol over S,where S is a .nite set of symbols or tags,isapair (s, \nd) with s . S and d . D.A data string w over S is a .nite sequence (s1,d1), (s2,d2),... (sk,dk) of data \nsymbols over S.A data language over S is a set L of data strings over S.A (deterministic) data transduction \nfrom an input alphabet S to an output alphabet G is a partial function F from data strings over S to \ndata strings over G. For a data transduction F from an input alphabet S to an output alphabet G,the domain \nof F is the data language over S consisting of data strings w such that F (w) is de.ned. As an example, \nlet D be the set of strings over ASCII charac\u00adters ordered by the standard lexicographic ordering. Let \nS contain two tags private and public. A data symbol denotes an entry in an address-book consisting of \na name tagged either as private or pub\u00adlic. A data string represents an address-book. Here are a few \nexam\u00adples of data languages: language L1 consists of all data strings in which names appear in the alphabetic \norder (that is, data symbols are sorted in an increasing order according to < over data values); and \nlanguage L2 consists of all data strings that do not contain du\u00adplicate entries. A few examples of useful \ndata transductions are: transduction F1 maps a data string to its reverse; transduction F2 maps a data \nstring w to w1.w2,where w1 is the subsequence of w containing private entries, and w2 is the subsequence \nof w contain\u00ading public entries; and transduction F3 deletes an entry (private,d) from the input data \nstring if the string also contains (public,d).To model operations such as insertion and deletion that \ntake data val\u00adues/symbols as inputs in addition to a data string, we can encode all inputs in a single \ndata string. For example, the transduction F4, given an input data string (s, d).w checks if names appear \nin the alphabetic order in the tail w, and if so, it returns w with (s, d) inserted in the correct position \nto maintain the output string sorted (F4 is unde.ned if the input string is empty, or if the tail of \nthe input string is not sorted).  2.2 Transducer de.nition We now describe our model of deterministic \ntransducers. The trans\u00adducer reads an input data string left-to-right in a single pass, and computes \nan output data string. The transducer uses a .nite set of states, a .nite set of data variables that \nrange over data values, and a .nite set of data string variables that range over data strings over the \noutput alphabet. At each step, the transducer reads the next data symbol of the input string, and chooses \na transition depending on the current state, the tag of the input symbol, and the ordering re\u00adlationship \nof the data value of the input symbol with values of all its data variables. The transition updates the \nstate, updates the data variables possibly using the input data value, and updates the data string variables \nin parallel using assignments whose right-hand\u00adsides are concatenations of data string variables and \nnew data sym\u00adbols formed using data variables. When the transducer consumes the entire input string, \nthe .nal output string is produced by simi\u00adlarly concatenating data string and data variables. A key \nrestriction is that a data string variable can be used at most once in a right\u00adhand-side expression in \na transition, and thus, at every step, there is merely a rearrangement of output chunks computed so far, \nwithout duplication. We now de.ne the model formally. A (deterministic) streaming data-string transducer \n(SDST) S from an input alphabet S to an output alphabet G consists of a .nite set of states Q, an initial \nstate q0 . Q, a .nite set of data variables V , a data variable curr . V used to refer to the data value \nof the current input symbol, a .nite set of data string variables X, a partial output function O from \nQ to ((G \u00d7 V ) . X) *, a .nite set E of transitions of the form (q, s, ., q',a),where q . Q is a source \nstate, s . S is an input tag, . is a Boolean formula over atomic constraints of the form v< curr and \ncurr <v with v . V , q . . Q is a target state, and a is an assignment mapping data variables V to V \nand data string variables X to ((G \u00d7 V ) . X) *. It is required that (1) for each q . Q and x . X, there \nis at most one occurrence of x in O(q), and (2) for each transition (q, s, ., q',a), for each x . X, \nx appears at most once in the set of strings {a(y) | y . X},and (3) for each pair of transitions (q, \ns, ., q',a) and (q, s, .. ,q '',a') with the same source state and input tag, the tests . and .. are \nmutually exclusive (that is, . . .. is unsatis.able). A valuation \u00df for such a transducer S is a partial \nfunction over data and data string variables such that for each data variable v . V , either \u00df(v) is \nunde.ned or is a data value in D,and for each data string variable x . X,either \u00df(x) is unde.ned or is \na data string over the output alphabet G. Such a valuation naturally extends to a partial Boolean function \nto evaluate tests. Each test . is a Boolean formula over atomic constraints of the form v< curr and curr \n<v with v . V . The value \u00df(.) is de.ned if \u00df(v) is de.ned for all data variables v occurring in ., and \nif so, . is evaluated using the values \u00df assigns to these data variables. A valuation \u00df also extends \nto strings in ((G \u00d7 V ) . X) *:given a string u in ((G\u00d7V ).X) *, the valuation \u00df(u) is de.ned when \u00df \nis de.ned for all the data and data string variables occurring in u,and if so, \u00df(u) is the data string \nover the output alphabet G obtained by replacing each data string variable x in u with the data string \n\u00df(x) and each data variable v in u with the data value \u00df(v).  Given an SDST S,a con.guration of S is \na pair (q, \u00df),where q is a state in Q,and \u00df is a valuation for S. The initial con.guration is (q0,\u00df0) \nwhere q0 is the initial state of S, \u00df0(v) is unde.ned for each data variable v,and \u00df0(x) is the empty \nstring for each data string variable x. The one-step transition relation over the set of con.gurations \nis de.ned as follows. Consider a con.guration (q, \u00df) and an input data symbol (s, d). The transducer \n.rst updates the valuation \u00df to \u00df' by setting curr to the input data value d.Next, let (q, s, ., q',a) \nbe a transition such that \u00df' satis.es the test .. If there is such a transition, then the updated state \nis q', and the updated value of each data and data string variable x is obtained by evaluating the right-hand-side \na(x) according to the valuation \u00df'. That is, if there exists a transition (q, s, ., q',a) such that \u00df'(.)= \ns,d' 1,for \u00df' = \u00df[currn. d],then (q, \u00df) -. (q,\u00df' \u00b7 a). Determinism ensures that each con.guration has \nat most one successor for a given input data symbol. The transition relation extends to a multi\u00adstep \nrelation over input data strings in the natural way. Given an w input data string w over S, (q0,\u00df0) -. \n(q, \u00df) means that the con.guration of the transducer after reading the input data string w is (q, \u00df) \n(if no such con.guration exists that means no transition is enabled at some step). The semantics of S \nis then de.ned to be the transduction [[S]] de.ned as: for an input data string w over S,if w (q0,\u00df0) \n-. (q, \u00df) and O(q) is de.ned then [[S]](w) is de.ned to be \u00df(O(q)), otherwise [[S]](w) is unde.ned. We \ncall a data transduction F from an input alphabet S to an output alphabet G to be streaming-regular if \nthere exists an SDST S such that [[S]] = F .  2.3 Examples To illustrate our de.nition of transducers, \nlet us consider the trans\u00adductions mentioned in Section 2.1. The transduction F1 to reverse the input \ndata string can be implemented by a streaming data-string transducer S1 with a single state, a single \ndata variable curr,and a single data string variable x. The input tag s is processed by the self-loop \ntransition with update x := (s, curr).x (by default, a variable that is not explicitly updated, remains \nunchanged; we omit such assignments for readability). The output function outputs x. No tests on input \ndata values are needed. Notice that classical de.\u00adnitions of transducers allow adding output symbols \nonly at the end of the output computed so far. Adding a symbol to the front of the string variable x \nat each step is crucial to implement reverse in a single left-to-right pass. Now let us consider the \ntransduction F2 that maps a data string w to w1.w2,where w1 and w2 are the subsequences of w con\u00adtaining \nprivate and public entries, respectively. This can be imple\u00admented by an SDST S2 that maintains two data \nstring variables x1 and x2, and a single data variable curr. At each step, if the tag of current input \nsymbol is private, the symbol is added to x1 (the pre\u00adcise assignment is [x1,x2]:=[x1.(private, curr),x2]), \notherwise the symbol is added to x2 in a symmetric manner. The output func\u00adtion outputs the concatenation \nx1.x2. Note that it is not possible to implement this transduction by an SDST using just one variable. \nThe transduction F3 deletes a private entry from the input data string if the string also contains a \npublic entry with a matching data value. When reading an input symbol with data value d,the streaming \nalgorithm needs to .gure out if a private entry with the same data value has been encountered before. \nAn SDST with k variables can effectively use only k data values for tests at any step, [x, u]:= u = \ncurr . [(curr,s), curr] [v, y]:=[curr ,x(curr,s)]  (v = curr) . [v, y]:= [curr,y(curr,s)] u> curr . \n(u = curr) [v, y]:= &#38;(v = curr) . [curr, (curr,s)] [v, y]:= [curr,yx(curr,s)] (u> curr)&#38;(v = \ncurr) . [v, y]:=[curr,y(curr,s)] Figure 1. Transduction F4 and since the number of possible data values \nin an input string is unbounded, F3 is not streaming-regular. Consider the transduction F4 that inserts \nthe head symbol of the input string in its tail, provided that the tail is sorted. The transducer S4 \nuses three data variables: u to remember the head data value, v to remember the previous data value, \nand curr to refer to the current data value. It uses a data string variable x to remember the .rst data \nsymbol, and y to compute the output. The transducer is shown in Figure 1. The transducer is in state \nq0 initially, in state q1 after reading one symbol, in state q2 after reading 2 or more symbols provided \nthe tail so far is sorted and all its data values are smaller than the head data value (stored in u), \nand in state q3 after reading 2 or more symbols provided the tail so far is sorted and the head symbol \nhas already been inserted in the output. In states q2 and q3,the variable v stores the previous data \nvalue, and the test v = curr checks for sortedness of the input (v gets updated to curr at each step). \nIf this test does not hold, no transition is enabled, and the output will be unde.ned. The transition \nto q3 inserts the data symbol stored in x in the output y. The output function is unde.ned in state q0,and \nis x in state q1, y.x in state q2,and y in state q3.  2.4 Streaming acceptors A streaming data-string \nacceptor (SDSA) is a streaming data\u00adstring transducer S with an empty set of data string variables. Such \nan acceptor S has a .nite set of data variables that can remember the data values from the input string, \nand can make decisions based on their relative ordering. The output alphabet plays no role in the behavior \nof an acceptor. Given an input data string w, either the output [[S]](w) is de.ned or unde.ned, and the \ndomain of the transducer is the data language associated with the acceptor S.This is the same as saying \nthat the output function O marks states of S as accepting or rejecting based on whether the output function \nO is de.ned or unde.ned at a state. We call a data language L over an alphabet S to be streaming-regular \nif L is accepted by a streaming data-string acceptor. The data language L1 consisting of sorted data \nstrings can be de.ned by such an acceptor using one data variable that remembers the previous data value, \nalong with the data variable curr needed to refer to the data value of the currently read symbol. Thus \nL1 is a streaming-regular data language. The data language L2 consisting of data strings without duplicate \nentries is not streaming-regular by an argument similar to the one for the transduction F3. Among different \ntypes of automata over data strings that have been studied, data automata [3] have emerged as a good \ncandidate for the notion of regularity for languages of data strings. However, data automata are too \nexpressive for our purpose as they have an undecidable emptiness problem in the presence of ordering \non data values [3].  2.5 Properties In this section, we note some properties of streaming transducers \naimed at understanding their expressiveness. First, observe that a streaming data-string transducer S \ncannot output new data val\u00adues. That is, for every input data string w, any data value appearing in the \noutput data string [[S]](w) must appear in some symbol in w. Second, streaming transducers are bounded \nin the sense that the length of the output string is within at most a constant factor of the length of \nthe input string. Proposition 1. If F is a streaming-regular transduction from S to G, then for all input \ndata strings w over S, |F (w)| = O(|w|). The boundedness depends on the fact that the parallel assign\u00adment \nat each step is copyless: each variable can appear in a right\u00adhand-side expression at most once. Not \nonly this is crucially needed for decidability of the equivalence problem, it also allows an ef.\u00adcient \nimplementation: if the data strings corresponding to variables are stored in linked lists, then the assignment \ncan be executed by only changing a constant number of pointers (proportional to the description of the \ntransducer, but independent of the lengths of the data strings they store, and thus, independent of the \nlength of the input string). Proposition 2. If F is a streaming-regular data-string transduc\u00adtion, then \ngiven an input string w, the output F (w) can be com\u00adputed in time O(|w|). This also means that the sorting \ntransduction that maps an input data string to its sorted version is not streaming-regular due to well\u00adknown \nlower bounds for sorting. Obviously streaming transducers cannot capture all linear-time streaming algorithms. \nAs a speci.c example, let us revisit the transduction F2 that maps a data string w to w1.w2,where w1 \nand w2 are the projections of w containing private and public entries, respectively. Consider the variation \nF2 ' that maps w to a merge of the two projections w1 and w2 taking elements from the two lists in an \nalternate manner. This can be easily implemented in linear-time if we maintain two read-heads over the \ninput string, one corresponding to private entries and one corresponding to public entries. Note that \nthe emptiness problem of .nite automata with multiple read-heads is undecidable, and the traversal allowed \nfor streaming transducers is restricted by design to ensure decidability of key analysis problems. In \nparticular, F2 ' is not streaming-regular. Let us now consider some closure properties for the class \nof streaming-regular transducers. Given two data transductions F1 and F2,and atest L as a data language, \nsuppose we want to compute F1(w) when w . L and F2(w) otherwise. If all of F1, F2,and L are speci.ed \nusing SDSTs then we can construct an SDST for the desired transduction by a suitably modi.ed product \nconstruction. Proposition 3. If F1 and F2 are streaming-regular data transduc\u00adtions from S to G, and \nL is a streaming-regular data language over S, then the following data transduction F is streaming-regular: \nfor an input data string w over S,if w . L then F (w)= F1(w) else F (w)= F2(w). It turns out that streaming-regular \ndata transductions are not closed under functional composition. That is, given two SDSTs S1 and S2, we \ncannot always construct an SDST S such that S(w)= S2(S1(w)). Proposition 4. There exist streaming-regular \ndata transductions F1 and F2 from S to S such that the following data transduction F is not streaming-regular: \nfor an input data string w over S, F (w)= F2(F1(w)). Proof. We choose S to be a singleton set, and thus, \nit plays no role. Consider the transduction F1 that maps a data string d1d2 \u00b7\u00b7\u00b7 dk to its reverse dkdk-1 \n\u00b7\u00b7\u00b7 d1. F1 is streaming-regular. Consider the transduction F2 that maps a data string d1d2 \u00b7\u00b7\u00b7 dk to \n(d1)k.That is, F2 just repeats the .rst data value for each input symbol read. It is easy to implement \nF2 by an SDST. Now consider the compo\u00adsition F = F1 \u00b7 F2. The transduction F maps an input data string \nd1d2 \u00b7\u00b7\u00b7 dk to (dk)k. We can prove that F is not streaming-regular. Note that the above proof crucially \nuses the fact that the data domain D is unbounded, and we can always .nd a fresh data value that has \nnot appeared in the input string before. If we make D .nite, then the streaming-regular transducers are \nclosed under composition.  3. Imperative Programs Updating Linked Lists We consider a class of imperative \nprograms that manipulate heap\u00adallocated singly-linked list data structures. Each node of the heap stores \na tag, a data value, and a pointer to another node. For clarity, in this section, we will assume that \nthe output alphabet is the same as the input alphabet, so we need to consider tags of only one type. \nThe input data string is stored in such a heap using one node for each position (null pointer indicates \nthe end of the list). A list-processing program is invoked with the reference to the head-node of the \nlist as input. The program traverses the list using next-pointers, and computes using variables that \nrange over tags, over data values, over booleans, and over pointers into the heap. It can create new \nnodes and add them to the heap, and can also manipulate the shape of the heap by updating the next-pointers \nof the nodes referenced by its pointer variables. The output data string is returned using a pointer-variable \nthat points to the head of the list storing that output. During the computation of the program, next-pointers \nof two heap-nodes may point to the same node, and thus, the heap in general has a structure of an unordered \nforest. Since the output is computed by possibly reusing the nodes that store the input, we need careful \nsyntactic restrictions to allow a single-pass traversal of the input list, while disallowing repeated \nor nested traversals. We require that a typical traversal assignment x := y.next for pointer variables \nx and y is disallowed. The only legal use of the next-.eld on the right-hand-side is in the assignment \ncurr := curr.next,where curr is the unique input pointer. Assignments of the form x.next := y to update \nthe heap structure are allowed, provided x and curr are not referencing the same heap-node. An attempt \nto execute x.next := y in a state where x and curr reference the same heap-node, causes a runtime error \n(alternatively we can require each such assignment to be syntactically guarded by the boolean condition \nx = curr). A program can have additional input and output parameters, and each such input/output parameter \ncan be a data value, a boolean value, or a tag. Before we describe the syntax and the semantics in detail, \nlet us .rst consider a couple of examples. The following function reverses a list in-place, and corresponds \nto the data trans\u00adduction F1: function Reverse input ref curr; output ref result := curr; local ref prev \n:= curr; if curr nil then { = curr := curr.next; while curr nil { = result := curr; curr := curr.next; \nresult.next := prev; prev := result; }}.  Suppose given an input data string w and an input data symbol \nd, we want to delete each symbol in w whose data value equals d, and return the resulting data string \nalong with a boolean .ag that indicates whether or not some symbol was actually deleted. The following \nfunction implements this: function Delete input ref curr; input data v; output ref result; output bool \nb:=0; local ref prev; while (curr nil) &#38; (curr.data = v) { = curr := curr.next; b := 1; } result \n:= curr; prev :=curr; if curr nil then { = curr := curr.next; prev.next := nil; while curr nil { = if \ncurr.data = v then { curr := curr.next; b := 1; } else { prev.next := curr; prev := curr; curr := curr.next; \nprev.next := nil; }; }; }. 3.1 Syntax Types: Variables are typed. The possible types are: bool for Boolean-valued \nvariables, tag for variables ranging over the al\u00adphabet S, data for variables ranging over the data domain \nD along with an unde.ned value denoted .,and ref for reference vari\u00adables that index into the data heap \nalong with the null reference nil. Variable declarations: A program variable is declared along with its \ntype (bool, tag, data,or ref) and an annotation which can be either local, input,or output.The input \nannotation means that the variable is an input to the function. A function has exactly one input variable \nof type ref, and can have multiple input variables of other types. We will use curr to name this unique \ninput reference variable. The output annotation means that the variable is an out\u00adput of the function, \nand local annotation means that the variable is neither an input nor an output. There is exactly one \noutput variable of type ref which is used to return a single data string. The dec\u00adlaration of each output \nand local variable has an associated value. The initial value of a variable of type bool or tag can be \neither a constant or an input variable of matching type. The initial value of a data variable can be \neither . or an input data variable. The initial value of a pointer variable can be either curr or nil. \nData expressions and assignments: A data expression is of the form (1) a variable of type data,or(2) \nr.data,where r is a variable of type ref, denoting the data value stored in the heap\u00adnode indexed by \nr. A data assignment statement assigns a data expression to a data variable. Tag expressions and assignments: \nA tag expression is of the form (1) a variable of type tag, (2) a constant s from the alphabet S,or(3) \nr.tag,where r is a variable of type ref, denoting the tag value stored in the heap-node indexed by r. \nA tag assignment statement assigns a tag expression to a tag variable. Reference expressions and assignments: \nA reference expression re is either a variable of type ref or the constant nil. A reference assignment \nstatement is either (1) r := re,where r is a local or a output variable of type ref and re is a reference \nexpression, (2) r.next := re,where r is of type ref and re is a reference expression, (3) r := new(te, \nde, re),where r is a local or a output variable of type ref and te is a tag expression, de is a data \nexpression, re is a reference expression, or (4) curr := curr.next. The .rst assignment allows reassignment \nof reference variables, except for the input variable curr. The second assignment updates the heap by \nchanging the next-pointer of the heap-node indexed by r, provided r and curr do not point to the same \nheap-node. The third assignment creates a new heap-node with tag value given by te, data value given \nby de, and next-pointer given by re.Thelast assignment allows traversal, and is syntactically restricted \nto ensure that only the unique input reference variable is used to traverse the input list. Boolean expressions \nand assignments: An atomic boolean ex\u00adpression is either a boolean constant (0/1), or tests equality \nbetween two tag expressions, or tests equality or ordering between two data expressions, or tests equality \nbetween two reference expressions. A boolean expression is formed from atomic boolean expressions using \nstandard logical connectives for negation, conjunction, and disjunction. A boolean assignment statement \nassigns a boolean ex\u00adpression to a boolean variable. Statements: An assignment statement is either a \ndata assign\u00adment statement, a tag assignment statement, a reference assignment statement, or a boolean \nassignment statement. A statement s is ei\u00adther (1) an assignment statement, (2) a conditional statement \nof the form if be then s or if be then s1 else s2,where be is a boolean expression, (3) a while statement \nof the form while be { s},where be is a boolean expression, or (4) a .nite sequence of statements. Program: \nA single-pass list processing program P consists of a sequence of variable declarations followed by a \nstatement.  3.2 Semantics Recall that a program has a single input variable of type ref and a single \noutput variable of type ref. The semantics of a program is de.ned as a partial function from an input \ndata string together with values for input data/tag/boolean variables to an output data string together \nwith values for output data/tag/boolean variables. For example, the semantics of Delete is a partial \nfunction from (S \u00d7 D) * \u00d7 D to (S \u00d7 D) * \u00d7{0, 1}. Con.gurations: Given a program P , its con.guration \nis com\u00adpletely described by (1) the values of its data, tag, boolean, and reference variables, (2) the \nprogram counter indicating the next statement to be executed, and (3) the data-heap. Let Loc be the set \nof locations in P (this can be the set of vertices in the control\u00ad.ow graph of the program). A data-heap \nh consists of a .nite set N of heap-nodes, a data function fd : N n. D that gives the data element stored \nat each node, a tag function ft : N n. S that gives the tag element stored at each node, and a next-pointer \nfunction fn : N n. N. that gives the next-pointer of each node, where N. is the set N together with the \nconstant nil. A program\u00adcon.guration c of P then consists of a location e . Loc, a data heap h =(N, fd,ft,fn), \nand a partial function \u00df over all the program variables that maps each data variable to D, each reference \nvariable to N, each boolean variable to {0, 1}, and each tag variable to S. Initialization: Given an \ninput data string (s1,d1) \u00b7\u00b7\u00b7 (sk,dk), the initial heap h0 consists of the set N = {n1,...nk} of nodes, \none per each data symbol of the input string. The data function is given by fd(ni)= di, the tag function \nis given by ft(ni)= si, and the next-pointer function is given by fn(ni)= ni+1 for i<k and fn(nk)= nil. \nThe initial location e0 is the unique entry location of the control-.ow graph. For the initial valuation \n\u00df0, \u00df0(curr)= n1. For all other input variables x, \u00df0(x) is set to the corresponding input value. For \nall local and output variables x, \u00df0(x) is de.ned according to the initialization in the declaration \nfor x. The initial con.guration c0 of the program is (e0,h0,\u00df0).  Transition relation over con.gurations: \nThe operational seman\u00adtics of programs is de.ned by a transition relation over the con\u00ad.gurations. First, \ngiven a con.guration c =(e, (N, fd,ft,fn),\u00df), there is a natural way to evaluate a data expression de \nto obtain a data value c(de) . D, a tag expression te to obtain a tag value c(te) . S, a reference expression \nre to obtain a value c(re) . N., and a boolean expression be to obtain a boolean value c(be).Every program \ncon.guration c =(e, (N, fd,ft,fn),\u00df) can have at most one successor con.guration, determined by the statement \ns at loca\u00adtion e. The details are standard, and we illustrate them using a few cases. Suppose the statement \nis a conditional statement e : if b then e1 : s1 else e2 : s2. Then, if c(b)=1 then the successor con.guration \nof c is (e1,h,\u00df),and if c(b)=0 then the successor con.guration of c is (e2,h,\u00df). Suppose the statement \ns is a reference assignment statement e : r := new(te, de, re). The effect of executing the statement \ns updates the control location from e to the unique successor location e ' of the statement s. For the \nupdated data heap h ' , the set of nodes is N .{n},where n . N is a new heap-node, the data function \nis fd[n n. c(de)], the tag function is ft[n n. c(re)], and the next\u00adpointer function is fn[n n. c(re)]. \nThe updated valuation \u00df ' is \u00df[r n. n]. Suppose the statement s is a reference assignment statement \n e : r.next := re.If c(r)= c(curr) then this is an error and the con.guration c has no successor. Otherwise, \nthe successor con.gu\u00adration is c ' such that the location e ' is the unique successor location of e in \nthe control-.ow graph, the valuation \u00df stays unchanged, and the updated heap is (N, fd,ft,fn[c(r) n. \nc(re)]) (that is, the next-pointer of the node c(r) in the heap changes to c(re) which may be nil or \na heap-node).  Termination and output: An execution of the program is ob\u00adtained by starting in the initial \ncon.guration c0 and continuing with the successor con.guration as long as possible. If this execution \nis in.nite, then the program is non-terminating, and the output is un\u00adde.ned. Suppose the execution is \n.nite and ends in the con.gura\u00adtion cf =(ef ,hf ,\u00dff ). If the location ef is not the unique exit lo\u00adcation \nof the control-.ow graph, then again the output is unde.ned. Otherwise, the returned value of each output \ndata/tag/boolean vari\u00adable is given by the .nal valuation \u00dff of program variables. For the unique output \nreference variable r,let (s1,d1)(s2,d2) \u00b7\u00b7\u00b7 be the unique sequence of tag/data values stored in the heap \nhf starting at the node \u00dff (r) following the next-pointers until the nil value is encountered. If this \nsequence is in.nite, this indicates that the program created a cycle in the heap during its computation, \nand the output is again unde.ned. If this sequence is .nite, it is the returned output data string. \n 3.3 Streaming transducers with E-transitions We extend the model of streaming data-string transducers \nby al\u00adlowing the transducer to update its state, data variables, and data string variables using an E-transition \nthat does not consume an in\u00adput symbol. We will .rst show that it is possible to eliminate such E-transitions, \nand then we will translate list-processing programs to transducers with E-transitions. The de.nition \nof a (deterministic) streaming data-string trans\u00adducer S with E-transitions extends the de.nition of \nSDSTs as fol\u00adlows: in a transition (q, s, ., q ' ,a), s can now also be E, provided there is no transition \nof the form (q, s ' ,. ' ,q '' ,a ' ) with s ' . S. The restriction is needed for ensuring determinism: \nin a state q, either all outgoing transitions are E-transitions, or all outgoing tran\u00adsitions have non-E \ntags (and thus consume the next input symbol). Note that the original determinism requirement still applies: \nif there are multiple transitions with same source state and same input tag (which now may be E), their \ntests must be mutually exclusive. r3 n4 n0 n1 n2 n3 n5 n6 n7 n8 n9 n10  w1 w2 r1 r2 r4 curr Figure 2. \nStoring heap in data strings As in case of SDSTs, a con.guration consists of a state q and a valuation \n\u00df for the data and data string variables. The de.nition of s,d the transition relation (q, \u00df) -. (q ' \n,\u00df ' ),for s . S and d . D,is unchanged. The E-transitions are de.ned by: if there exists a transi\u00ad tion \n(q, E,.,q ' ,a) such that \u00df(.)=1 then (q, \u00df) -. (q ' ,\u00df \u00b7 a). A run over the input data string w is obtained \nby starting in the ini\u00adtial con.guration (q0,\u00df0), and applying either an E-transition or a transition \ncorresponding to the next input data symbol until all the input data symbols are consumed and no more \nE-transitions are pos\u00adsible. This ensures determinism: for a given input string w,there is w at most \none con.guration (q, \u00df) such that (1) (q0,\u00df0) -. (q, \u00df) and (2) (q, \u00df) has no E-successor. The semantics \n[[S]](w) is de.ned to be \u00df(O(w)) in such a case, provided O(q) is de.ned, and is unde.ned otherwise. \nNote that it is possible that such a transducer keeps on executing E-transitions without terminating, \nand in such a case, the corresponding output is unde.ned. It turns out this extension does not add to \nthe expressiveness: Proposition 5. Given a streaming data-string transducer S with E-transitions, one \ncan effectively construct a streaming data-string transducer (without E-transitions) S ' such that [[S]] \n= [[S ' ]] with the same number of states, same number of data variables, and the same number of data \nstring variables.  3.4 From single-pass programs to streaming transducers In this section, we describe \nhow to translate single-pass list process\u00ading programs to streaming data-string transducers. The .rst \nstep is to view the semantics of a single-pass list processing program as a partial function from data \nstrings to data strings. To associate such a data string transduction [[P ]] with a program P , we encode \ninput parameters in the same manner as described in Sec. 2.1. If P has ki input boolean/data/tag variables \nand ko output boolean/data/tag variables, then we pre.x the input data string with ki symbols each encoding \none input argument, and pre.x the output data string with ko symbols each encoding one output value. \nThe main challenge in the construction is to store the informa\u00adtion in the data heap used by the program \nP using a bounded num\u00adber of data and data string variables in the corresponding trans\u00adducer S. Figure \n2 shows a possible con.guration of the data heap that the program accesses using the reference variables \ncurr and r1,r2,r3,r4. The .rst observation is that the heap-nodes that are not accessible from any of \nthe reference variables are not relevant to the execution of the program, and can be ignored. Second, \nnodes such as n9 and n10 that are accessible from curr.next can contain only input symbols that the program \nhas not processed so far. These nodes have not in.uenced the execution of the program so far, and information \nin these nodes does not need to be stored. When the program executes the statement curr := curr.next, \nthe node n9 becomes relevant. This step is analogous to the transducer S pro\u00adcessing the next input symbol. \nCompressing the heap using a bounded number of strings is achieved using an encoding similar to [13]. \nA node is called a referenced node if a reference variable points to it. In the example, n0, n4, n7 and \nn8 are referenced nodes. Information in such nodes needs to be stored explicitly by S. For each reference \nvariable r of P , S maintains a data variable dr and a tag variable tr storing the information in the \nnode that r points to. A node such as n3 is called an interruption node as two nodes point to it (and \nboth these nodes are accessible from the program s reference variables). If P has k reference variables, \nthen there can be at most 2k - 1 interruption nodes. The stretches n1,n2 and n3,n5,n6 are uninterrupted \nheap segments. In each such segment (1) the .rst node is either an interruption node, or is the next-successor \nof a referenced node,  (2) the next-pointer of each node in the sequence points to the next node in \nthe sequence, (3) no node other than the .rst is an interruption or a referenced node, and (4) the next-pointer \nof the last node is either nil or points to an interruption or a referenced node. If P has k reference \nvariables, then there can be at most 2k -1 uninterrupted heap segments. The sequence of data symbols \nstored in an uninterrupted heap segment is stored in a data string variable by S. In our example, the \ndata string w1 stores the data symbols in n1,n2 and the data string w2 stores the data symbols in n3,n4,n5. \nThe .nite-state control of S remembers the shape of the heap: r1 and r2 point to the same node, the next-pointer \nof the r1-referenced node points to the data string stored in w1,the next-pointers of the node referenced \nby r3 and of the last node of w1 point to w2, w2 is followed by the r4-referenced node, which is followed \nby the curr-referenced node. Such a shape can be captured by a function fn : Y n. Y.,where Y contains \nall the reference variables of P and all the data string variables of S that store the data strings in \nuninterrupted heap segments. If P executes the assignment r3.next := curr,then n3 is no longer an interruption \nnode, and in this case, the two uninterrupted heap segments collapse into one. This is achieved by S \nby the assignment [w1,w2]:=[w1.w2,e] to the data string variables, updating the tag/data variable corresponding \nto r3, and changing the shape by updating fn(w1) to r4 and fn(r3) to curr. Proposition 6. Given a single-pass \nlist-processing program P one can effectively construct a streaming data-string transducer S with E-transitions \nsuch that [[P ]] =[[S]].If P has m locations, kr reference variables, kb boolean variables, kt tag variables, \nand kd data variables, then S has kd + kr data variables, 2kr data string variables, and O(m \u00b7 2kb r \n\u00b7|S|kt+kr ) states. \u00b7 kkr Proof. The transducer S has a data variable for each data variable for P , \nand also for each reference variable of P (to store the data values in referenced nodes in the heap). \nIt has 2kr data string variables to store uninterrupted heap segments. The state of S stores (1) the \nlocation of control of P , (2) the boolean value of each boolean variable of P , (3) the tag value of \neach tag variable of P , (4) a partition of the reference variables of P (two reference variables are \nin the same partition if they point to the same heap\u00adnode), (5) for each equivalence class in the partition, \neither a tag value stored at the node referenced, or nil, and (6) for each data string variable and each \nequivalence class of the partition, a next value that gives either a data string variable or an equivalence \nclass of the partition. The last component stores the shape of the heap. The bound on the possible number \nof states follows by a simple counting argument. If P has data, boolean, or tag input variables, the \ntransducer S .rst scans the initial pre.x of data symbols setting up the initial values using E-transitions. \nThen the transducer processes the .rst input symbol, assigning the tag-component corresponding to curr \nin its state to tag of the input symbol, and assigning the data variable corresponding to curr to data \nof the input symbol. After this phase, the control location is set to the unique entry location, all \noutput strings are empty (there are no uninterrupted heap segments in the initial heap), and the partition \nhas only two classes (some reference variables are nil and some are in the class that contains curr). \nWe now describe transitions of S corresponding to statements of P . The only statement that causes a \nnon-E transition is the statement curr := curr.next. The transition that corresponds to this statement \nin S: (1) changes the stored control location of P , (2) changes the partition of reference variables \ninto equivalence classes: curr is split from its current equivalent class, (3) a new tag value is stored \nfor the new equivalence class of curr, (4) for each reference variable p from the previous equivalence \nclass of curr the new next value of p (i.e. fn(p)) will be curr, (5) if for any data string variable \nx (that stores an uninterrupted heap segment) of S we have (fn(x)= curr) then we append the current data \nsymbol (from before the transition is executed) to x. All other statements are captured by an E-transition, \nas they do not correspond to the move of the head of the automaton. Boolean, tag, and data assignments \ncan be simulated directly. We have already described using an example how a statement r.next = curr can \naffect the shape of the heap, and how this is captured by assignments that S can perform in its transitions. \nIn Section 2.5, we have mentioned that the assignments that a streaming transducer performs on its data \nstring variables can be executed by only changing a constant number of pointers. A list\u00adprocessing program \nequivalent to a transducer stores data strings in list segments on the heap, and keeps pointers to the \n.rst and last nodes of the segment. To perform an assignment of the form x := xy, the program performs \ncommands xl.next := yf; xl := yl, where xf (xl) is a reference to the .rst (last) node representing x \n(and similarly for y). We obtain the following proposition: Proposition 7. Given a streaming data string \ntransducer S, one can effectively construct a single-pass list-processing program P such that [[S]] = \n[[P ]].  4. Functional programs on lists We consider a simply typed functional language with types \nbool, tag, data, list, and function types, with letrec recursion and pair and list constructors. As in \nthe previous section, we assume that S=G for ease of presentation. The terms are de.ned by: t:= true \n| false | isTrue t | isFalse t |S|isS (for all S . tag) | x|funx:T.t|t t| iftthentelse t |x=x|x<x| {t,t} \n| t.1 | t.2 |nil|constt| appendt t | isnil t|headt |tailt | let x=t in t | letrec x:T=t in t The operators \n= and < apply to terms of type data.Thelistsare of type (list (tag \u00d7 data)),or list for short. The list \nand pair terms are standard. We de.ned a class of functional programs that intuitively cap\u00adtures single-pass \nfunctions that process a list by recursing through it from left to right. The recursion restriction we \nde.ne is a mi\u00adnor generalization of tail recursive functions, where we allow the caller to perform operations \non, but not test, the values that the callee returns. This allows capturing common routines such as in\u00adsert, \ndelete, and reverse (both tail-recursive and non-tail recursive). We allow wrapper functions in order \nto enable the standard pro\u00adgramming style for tail recursive functions. A function is a single-pass list \nprocessing function iff it is de.ned by the following term: fun a:list \u00d7 T1. letrec f:((list \u00d7 T1 \u00d7 T2) \n. (list \u00d7 T))=t in (f a initValues)  This term encodes a wrapper function that can pass some additional \narguments to a recursive function f. The following conditions are required to hold: one list: Let us \ndenote the .rst argument to f (by de.nition of type list)by l. The list l is the only list accessed by \nisnil, head and tail. The contents of the other list variables are thus not examined. However, it is \npossible to use cons or append with these variables. type restrictions: The types T1 and T are products \nof types bool, tag, data, with possibly more than one component of each type. These are input and output \narguments of the list processing function. The type T2 is a product of types bool, tag, data,and list, \nwith possibly more than one component of each type. Intuitively, these are buffers where the recursive \nfunction can store results.  recursion restriction: The .rst argument to any recursive call is the term \n(tail l),where l is the .rst argument to f.Every recursive call to f is enclosed in an expression e de.ned \nby let r=(f(taill)a)in t. Furthermore, e is the last expression the caller evaluates, i.e. t is the caller \ns result. Using thetyperestrictionabove,wehavethat r = l1 , r1 ,..., rn ,and a = a1 ... an ,and t = l2 \n, t1 ,... tn ,where l1 is a list and l2 is a list expression, each of r1 ,... rn and t1 ,... tn is of \ntype bool, tag or data, and each of a1 ,... an is of type bool, tag, data,or list. We have the following \nrestrictions on these subexpressions: (i) a list variable of f can appear in at most one expression ai \nor tj (this is similar to the restriction that requires the assignments of SDSTs to be copyless ), (ii) \nif ti is of type bool, then the only variable from r it can use is ri , (iii) if ti is of type tag or \ndata,thenwehave ti = ri , (iv) the only variable from r that l2 can use is l1 .  term t:Theterm t is \nof the form fun x: (list \u00d7 T1 \u00d7 T2). t ,where t ' does not contain the function de.nition term fun or \nthe recursive de.nition term letrec.  initValues: The expression initValues is of type T2.If T2 contains \nlist types, the corresponding values in initValues are nil.  Note that all the above conditions can \nbe checked syntactically. 4.1 Examples The data transduction F1 that reverses a list can be encoded as \na single-pass list processing function as follows: fun l:list. letrec reverse: (list \u00d7 list . list) = \nfun l:list. fun result:list. if (isnil l) then result else (reverse (tail l) (cons (head l) result)) \nin (reverse l nil) A function that given a list l and a data value d deletes all occurrences of d in \nl is encoded as follows: fun l:list. d:data. letrec FuncDelete: (list \u00d7 data . list) = fun l:list. fun \nd:data. if (isnil l) then nil else if (head l).data = d then (FuncDelete (tail l) d) else (cons (head \nl) (FuncDelete (tail l) d)) in (FuncDelete l d) One of the recursive calls in FuncDelete is enclosed \nin an ex\u00adpression that adds a cell to the front of the list: (cons (head l) (FuncDelete (tail l) d)). \nThis recursive call is not tail recur\u00adsive, as the caller function applies an operation to the result \nreturned by the callee. However, the recursive call satis.es the recursion re\u00adstriction from our de.nition \nof single-pass list processing functions (and it satis.es the other restrictions as well). The constructions \nin this paper lead to an algorithm to check if the imperative function Delete of Section 3 and the above \nfunction FuncDelete are semantically equivalent (i.e., specify the same transduction). Such a check can \nbe used for full functional veri.cation of one using the other as the speci.cation.  4.2 From list processing \nfunctions to streaming transducers Semantics The simply-typed functional language we de.ned contains \nstandard terms. The values of the language, as well as the typing rules, and the evaluation relation \nt1 . t2 for all the terms are omitted here, as they can be found in a standard textbook [16]. The operational \nsemantics is given by a transition system, whose states are subterms of f, whose transitions are given \nby the evalua\u00adtion relation t1 . t2 , and whose initial state is the term f. As for imperative programs, \nthe semantics of a single-pass list processing function can be viewed as a data string transduction, \nthat is, a partial function from data strings to data strings. To associate a transduction [[f]] with \na single-pass list processing function f : (list \u00d7 T1 ) . T, we encode input parameters in the same way \nas in Section 3. Given a data string w, its .rst ki symbols can represent ki input boolean/data/tag variables, \nand the rest represents the input list (converting a data string to a list term of type list is straight\u00adforward). \nGiven a data string, the function decode param(w, ki) returns the parameter values, and the function \ndecode list(w, ki) returns the tail of the input string represented as a list term. Sim\u00adilar encoding \nto data strings can be used for output values and output lists. Given a tuple {l1 , r1 ,..., rn } of \ntype list \u00d7 T, enc res({l1 , r1 ,..., rn }) returns the corresponding data string. Given a single-pass \nlist processing function f,wehavethat [[f]](w)= w ' iff (f decode list(w) decode param(w)) . * {l1,r1,...,rn} \nand enc res(l1,r1,...,rn)= w. Proposition 8. Given a single-pass list processing function f : (list \u00d7 \nT1 ) . T, one can effectively construct a streaming data string transducer S, such that [[f]] =[[S]].Let \ng be the recursive function used by f.If g has kb boolean variables, kt tag variables, kd data variables, \nand kl list variables, then S has O(2kb \u00b7|S|kt ) states, kd data variables, and kl +1 data string variables. \nWe note that the construction used in the proof of Proposition 8 is more direct than the one used in \nthe proof of Proposition 6. The list variables (apart from the list that is traversed) and data variables \nare modeled directly by data string variables and data variables of the transducer, and the control state \nof the transducer encodes the value of boolean and tag variables. GivenanSDST S, we can construct an \nequivalent list-processing program f. We .rst describe the arguments of the recursive func\u00adtion g the \nfunction f uses: its boolean arguments encode state of S, its data arguments correspond to data variables \nof S, and its list arguments correspond to the data string variables of S. A transition (q, s, ., q ' \n,a) is translated by making the function g test whether the current boolean arguments correspond to q, \nwhether the current tag is s, and whether . holds for the current data arguments. If so, the function \nmakes a recursive call with parameters encoding q ' and the assignments from a. The function we obtain \nin this way is tail recursive. The next proposition follows: Proposition 9. Given a single-pass data \nstring transducer S, one can effectively construct a single-pass list processing function f, such that \n[[S]] = [[f]].   5. Decision Problems In this section, we prove that the equivalence problem and the \npre/post condition checking problem are decidable for streaming data string transducers. We also show \nthat, for a number of exten\u00adsions of the streaming transducer model, already the basic analysis problem \nof reachability is undecidable. 5.1 Sound and complete abstraction for order and equality In proofs of \ndecidability of equivalence and pre/post condition checking of SDSTs that operate on an in.nite data \ndomain D, we will construct .nite state systems that do not store values of the data variables of the \nSDSTs, but only keep track of order and equality predicates. In order to prove that such an abstraction \nis both sound and complete for analysis problems, we will need the lemma presented in this subsection. \nLet V be a set of variables that range over D.We.x V and an in.nite D for this subsection. We will consider \npairs of the form (V d,.),wheretheset V d . V represents the set of variables with a de.ned value, and \nwhere . is an ec-order on V d (short for order on equivalence classes). An ec-order . =(=.,<.) is a pair \nwhere the .rst component is an equivalence relation on V d, and the second component is a strict total \norder on equivalence classes of =.. For data variables v1,v2,wewrite v1 <. v2,if v1 belongs to an equivalence \nclass c1, v2 belongs to an equivalence class c2,and c1 <. c2. For example, if V = {v1,v2,v3}, all variables \nhave a de.ned value, then a possible ec-order on V d can be represented as v1 =. v3 <. v2.Let \u00df be a \nvaluation of data variables as in the de.nition of SDSTs. A pair (V d,.) represents a set of valuations. \nWe write \u00df |=(V d,.) iff \u00df is de.ned precisely for the variables in V d,and forall v1,v2 . V d we have \nthat \u00df(v1) <\u00df(v2) iff v1 <. v2,and \u00df(v1)= \u00df(v2) iff v1 =. v2.Let . be a Boolean combination of constraints \nof the form v1 <v2 and v1 = v2 for variables v1,v2 . V .Let a beamapfrom V to V modeling assignments, \nas in the de.nition of transitions of SDSTs. We write (.,a) \u00df1 ---. \u00df2,if \u00df1 satis.es . and \u00df2 = \u00df1 \u00b7 \na, similarly to the de.nition of SDSTs. For pairs (V d,.), we de.ne a transition (.,a) relation (V d,.) \n---. (V 'd,. ' ) iff (a) V 'd contains the variables which were assigned to by a from variables in V \nd,(b) . implies ., a and (c) . ' is the ec-order obtained from . by executing a.Let u be a sequence of \npairs (V1 d,.1)(V2 d,.2) ... (Vnd,.n).Let u be a sequence of valuations \u00df1\u00df2 ...\u00dfn.Let upd be a sequence \nof pairs (.1,a1)(.2,a2) ... (.n-1,an-1). The sequence u a conforms to (.i,ai) the sequence upd if for \nall i if 1 = i<n,then (Vid,.i) -----. (Vid +1,.i+1). Similarly, the sequence u conforms to the sequence \n(.i,ai) upd if for all i if 1 = i<n,then \u00dfi -----. \u00dfi+1. The proof of the following lemma crucially uses \nthe fact that the in.nite totally-ordered data domain D contains chains, that is, sequences of elements \nin an increasing order, of unbounded length. The proof is omitted here in the interest of space. A similar \nproof is a part of the proof of Theorem 1 of [2]. Lemma 10. Let upd be a sequence of pairs (.1,a1)(.2,a2) \n... (.n-1,an-1).Let u a be a sequence of pairs (V1 d,.1)(V1 d,.1) ... a (Vnd,.n), such that u conforms \nto upd. Then there exists a se\u00adquence of valuations u = \u00df1\u00df2 ...\u00dfn such that u conforms to upd and for \nall i,if 1 = i = n,then ui |= uia .  5.2 Equivalence checking Given two streaming data-string transducers \nS1 and S2 from S to G,the streaming transducer equivalence problem is to determine whether [[S1]] = [[S2]]. \nIn order to show that the problem can be solved in PSPACE we reduce the problem to a reachability problem \nin 1-counter machines. A 1-counter machine M is a tuple (QM ,dM ,q0 M ,FM ), where QM is a set of states, \nq0 M is the initial state, and FM . QM is a set of .nal states. The transition relation dM is a relation \nin QM \u00d7 QM \u00d7{-1, 0, 1}. Note that 1-counter machines do not test the content of the counter. A con.guration \nof the 1-counter machine is a pair in Q \u00d7 Z, that is, it consists of a state and the value of a counter. \nA transition relation . on con.gurations is de.ned as ''' ' follows: (q, z) . (q ,z ) iff (q,q ,c) . \ndM and z = z + c.The 1-counter 0-reachability problem is to decide whether there exists a state q . FM \nsuch that (q0 M , 0) . * (q, 0). This is a special case of the empty-stack reachability problem for pushdown \nautomata. While the latter is PTIME-complete, the following lemma shows that the former is in NLOGSPACE. \nLemma 11. The 1-counter 0-reachability problem is in NLOGSPACE. Proof. Consider a 1-counter machine M \n=(QM ,dM ,q0 M ,FM ). We observe that for all q, q ' . QM , if there is a path (q, 0) . * (q ' , 0), \nthen there is such a path with stack depth bounded by n 2. This is a consequence of a summarization-based \nreachability algorithm (easily adapted from summarization-based reachability algorithm for pushdown automata), \nwhich computes summaries for pairs (q, q ' ). The iteration in which a pair (q, q ' ) gets added is the \nminimum absolute value of counter needed to reach from (q, 0) to (q ' , 0). The number of iterations \nis at most the number of summaries, that is, n 2. Note that this observation holds for all pushdown automata. \nWe can thus assume that the counter ranges over (-n 2 ,n 2). State of a 1-counter machine is (q, z),where \nz is the value of a counter. Therefore we need to consider only O(n 3) possible con.gurations. (This \nstatement does not hold for general pushdown automata). Thus our reachability problem is a reachability \nproblem in a graph with O(n 3) states. The problem can be therefore solved in space O(log n 3). Theorem \n12. The streaming data-string transducer equivalence problem is in PSPACE. Proof. Let us consider two \nstreaming data-string transducers S1 and S2 from S to G. They are not equivalent if there exists an input \ndata string w over S such that one of the following three conditions hold: (i) [[S1]](w) is de.ned, but \n[[S2]](w) is not (or vice-versa), (ii) [[S1]](w) and [[S2]](w) are de.ned, but have different lengths, \n(iii) [[S1]](w) and [[S2]](w) are de.ned and have the same lengths, but there exists a position p such \nthat the data strings [[S1]](w) and [[S2]](w) differ at the position p. We construct a 1-counter automaton \nand designate a state q such that q is 0-reachable in M if and only if S1 and S2 are not equivalent. \nThe automaton M nondeterministically chooses which type of difference (of the three described above) \nit will .nd. We only describe here how M can determine that there is an input string such that the p-th \noutput symbol of S1 is different from the p-th output symbol of S2. The construction for the other two \ncases uses similar ideas and is simpler. The automaton M nondeterministically simulates S1 and S2 running \nin parallel. It keeps track of states of S1 and S2 precisely, but only keeps some information on the \ndata and data string vari\u00adables. Intuitively, M guesses during the course of simulation of S1 (resp. \nS2) where the position p in the output is, and uses its counter to check that the guess is the same for \nS1 and S2. For each data string variable, M guesses (at each step) where the contents of the variable \nwill appear in the output with respect to the position p. More concretely, for each data string variable \nx of both S1 and S2, M guesses which of the following categories the variable is in: (i) left of p (Class \nL), (ii) center, i.e. position p is in this string (Class C), (iii) right of p (Class R), (iv) x does \nnot contribute to the output (Class N).  Maintaining consistency of assignment of data string vari\u00adables \ninto these four classes is straightforward. First, consider the case when at a particular step, S1 performs \nan assignment y := (a, v1)z(b, v2) and M guesses that the contents y will ap\u00adpear to the left of the \nposition p in the output of M1.Toverifythat this guess is consistent with previous guesses, M checks \nthat in the previous step, z was in Class L. The assignment caused two output symbols (a, v1) and (b, \nv2) to appear to the left of the po\u00adsition p, therefore M increases its counter by 2 (outputs of S2 are \ntaken into account by decreasing the counter rather than increas\u00ading). Second, if at a particular step, \nS1 performs an assignment x := (a, v1)y(b, v2)z,and M guesses that the symbol (b, v2) in this assignment \nwill be at the position p, then: (i) M veri.es that at the previous step, y was in Class L, and z was \nin Class R, (ii) M increases its counter by two in order to simulate the fact that S1 outputs (a, v1) \nand (b, v2) (as before, when simulating S2, M decreases the counter), and (iii) M assigns x to Class \nC. Note that initially, no variable is assigned to Class C, and at each step, at most one variable is \nin Class C, because of the copyless assignment re\u00adstriction. The cases when M guesses that a variable \nto which S1 (resp. S2) assigns is in Class R or Class N are similar. In the remainder of the proof, we \nassume that the data domain D is in.nite. If it is .nite, the automaton can directly store values from \nD in its .nite-state control, and the construction is simpler. For data variables, M keeps track of which \nvariable is de.ned, and for the de.ned variables, it keeps track of the ordering and equality information. \nMore precisely, let us consider the follow\u00ading set of variables V =(V1 \\{curr1}) . (V2 \\{curr2}) . {vp1, \nvp2, curr},where V1 and V2 are the sets of data variables of S1 and S2,and vp1 and vp2 are used by M \nto store information about the data value S1 and S2 output at position p. The automaton M stores a pair \n(V d,.),where V d . V that contains all of the variables whose values are de.ned in computation of S1 \nand S2, and . is an ec-order on V d. The pair (V d,.) is updated as steps of S1 and S2 are simulated \nand their transitions are executed. Note that M maintains only one variable curr common to M1 and M2 \nbecause the two automata are running on the same input. The .\u00adnal part of the construction is the maintenance \nof vp1,thevariable used to store the output of S1 at position p.When M guesses that the output symbol \nof S1 at position p will be one in the right-hand side of the assignment (such as x := (a, v1)y(b, v2)z) \nit is simulat\u00ading currently, it assigns x to Class C as above, and if it guesses that at position p is \nthe symbol (b, v2), then : (i) the value b from S is stored in the .nite state control of M, and (ii) \nvp1 is added to V d , the set of de.ned variables, and vp1 is added to the equivalence class of v2 in \n.. The construction for vp2 is analogous. To summarize, a state of M consists of (1) a state of S1,(2)a \nstate of S2,(3)aset V d . V representing the de.ned variables, (4) an ec-order ., (5) a partition of \nthe data string variables of S1 and S2 to classes (as described above) and a symbol from G at position \np for S1 and S2 (if M guessed that the output to position p was already performed). The set of states \nof M is thus a product: Q1 \u00d7 Q2 \u00d7 2V \u00d7 . \u00d7 QB , with the components corresponding to items (1) to (5). \nThe initial state of M is the tuple containing initial states of S1 and S2, with the set V d empty all \nthe variables are unde.ned, and the component (5) has a special value i.From this state there are nondeterministic \ntransitions which choose the initial assignments of data string variables to classes. The other transitions \nare as described above. The set of .nal states consists of states where either the variables vp1 and \nvp2 are de.ned, but . does not imply vp1 = vp2 or the G symbols stored in the .nite\u00adstate control of \nM for position p in output strings of S1 and S2 differ. We now prove that a .nal state of M is 0-reachable \niff there exists an input data string w and a position p, such that [[S1]](w) and [[S2]](w) differ at \nposition p. We will need the following notion that relates con.gurations of M to con.gurations of S1 \nand S2. Let c1 =(q1,\u00df1) be a con.guration of S1,let c2 =(q2,\u00df2) be a con.guration of S2 and let cM =((q1 \nM ,q2 M ,V d,.,qB ),e) be a con.guration of M (e is the value of the counter). The con.gu\u00adration cM is \nan abstraction of con.gurations (c1,c2) (denoted by a((c1,c2)) = cM ) iff the following conditions hold: \n States: the states of S1 and S2 are the same in c1 and c2 as they are in cM .  Data variables: \u00df1 or \n\u00df2 are de.ned for each of the variables in V d, and the values \u00df1 and \u00df2 assign to variables in V d are \nconsistent with .  Data string variables: Let eL 1 be the number of symbols in the data string variables \nof S1 that are assigned to Class L in QB . Class C in QB contains by construction at most one data string \nvariable of S1. If Class C contains a data string variable x1 of S1, then we can designate a position \np1 in the data string in x1.Let eC 1 be the number of characters to the left of p1 in x1. The values \neL 2 and eC 2 are de.ned analogously for S2 and a position p2 in a data string variable x2. The following \nequality  11 22 is required to hold: eL + eC - (eL + eC )= e,where e is the counter value in cM . Furthermore, \nlet d1 be the data value at position p1. We have that the equality and order relations that . contains \non vp1 and the other data variables hold for d1 and the values of these data variables given by \u00df1 and \n\u00df2. An analogous condition holds for the data value at position p2. Claim 1 The automaton M can reach \nthe con.guration cM = ((q1,q2,V d,.,QB ),e) in k steps iff there exists an input string w of length k, \nsuch that S1 (S2), after traversing this input, reaches a con.guration c1 (c2), and a((c1,c2)) = cM . \nThe claim is proven by induction on k. The more dif.cult part of the proof of the claim is the left-to-right \nimplication, where we are required to .nd an input string w that satis.es the condition. We need to .nd \na sequence of valuations \u00df that is the same as the sequence of pairs (V d,.) given by the sequence of \ncon.gurations of M. It is here that Lemma 10 is used. Using Claim 1, we now prove that a .nal state of \nM is 0\u00adreachable implies that there exists an input data string w and a position p, such that [[S1]](w) \nand [[S2]](w) differ at position p. A .nal state of M isastatewherewedonothave vp1 = vp2 or where the \nG symbols stored for positions p1 and p2 differ. By Claim 1, this means that there is a position p1 in \nthe output of S1 and a position p2 in the output of S2 where the data values or the G symbols differ. \nIf such a state is 0-reachable, (using Claim 1) we 11 22 get that eL + eC - (eL + eC )=0, which implies \np1 - p2 =0, which implies that p1 = p2. The other implication can be also easily shown using Claim 1. \nComplexity Checking whether a particular .nal state of M is 0\u00adreachable can be done in NLOGSPACE (Lemma \n11). A nondeter\u00administic algorithm .rst guesses which .nal state is reachable, and then checks its reachability \nin NLOGSPACE. The number of states of the 1-counter automaton M we constructed is linear in the num\u00adber \nof states of S1 and S2 and exponential in the number of data string and data variables of S1 and S2. \nFurthermore, given two states of M, one can decide (in polynomial time in the number of variables), whether \nthere is a transition between the two states. We thus have that the streaming transducer equivalence \nproblem is in PSPACE. Theorem 12 implies that checking equivalence is in PSPACE for list-processing programs \nfrom Section 3 and list-processing functions de.ned in Section 4. The reason is that the number of data \nand output variables of the resulting transducer is linear in the size of the program (more precisely, \nin the number of data and reference variables of the program).  5.3 Checking pre/post conditions and \nassertions Let S be a streaming data string transducer S from S to G.Let A1 be a streaming data string \nacceptor on S, and let A2 be a streaming data string acceptor on G. The triple {A1}S{A2} holds iff for \nall input data strings w over S we have that if A1 accepts w and [[S]](w)= w ' ,then A2 accepts w ' .The \npre/post condition problem for SDSTs is to determine, given A1, S,and A2,whether {A1}S{A2} holds. Pre-post \ncondition checking is useful in the context of veri.cation, because we can, for example, ask whether \na transducer that takes a sorted list (with respect to an ordering on S) as an input returns a sorted \nlist (with respect to an ordering on G) as an output. The upper bound in the following theorem is obtained \nby reduction to the emptiness problem in nondeterministic .nite automata (NFAs). Theorem 13. The pre/post \ncondition problem for SDSTs is in PSPACE. The above de.nition of pre/post condition checking corre\u00adsponds \nto partial correctness. We can also check total correctness: there is a PSPACE algorithm to check, given \nS, A1,and A2,isitthe case that for all input strings w accepted by A1, [[S]](w) is de.ned and A2 accepts \n[[S]](w). The constructions discussed so far can also be used to solve a number of assertion checking \nproblems for single-pass list\u00adprocessing programs. Reachability Given a single-pass list processing program \nP ,a location e of P , and a streaming data string acceptor A,is there a data string w accepted by A \nsuch that starting from the initial heap that stores w, there is an execution of P leadingtoa con.guration \nwith location e? For this, we need to construct the SDST corresponding to P as discussed in Section 3.4, \nand simulate it on an input together with A. The complexity is PSPACE. The same construction can be used \nif additional constraints are speci.ed on boolean and tag variables of P at the end of the execution. \nPointer analysis Given a single-pass list processing program P , two pointer variables x and y, and a \nstreaming data string acceptor A, is there a data string w accepted by A such that starting from the \ninitial heap that stores w, there is an execution of P leading to a con.guration in which both x and \ny point to the same heap-node? Recall that the compilation of programs into SDSTs keeps track of such \naliasing relationships, and has the necessary information to answer such a query. We can also check if \na pointer variable r is guaranteed to be non-null whenever it is dereferenced (using expressions such \nas r.next and r.data). Heap-cycles detection Given a single-pass list processing pro\u00adgram P and a streaming \ndata string acceptor A,istherea data string w accepted by A such that starting from the ini\u00adtial (acyclic) \nheap that stores w, there is an execution of P leading to a con.guration in which the heap contains a \ncycle (formed by next-pointers of heap-nodes)? Again, the compila\u00adtion of programs into SDSTs keeps track \nof the heap shape, and can be used to solve this problem in PSPACE. 5.4 Undecidable extensions Two-way \ndata string transducers A two-way (deterministic) data string transducer (2DST) is an extension of the \nstreaming data string transducer model, where at each step, the transducer can decide whether to move \nleft or to move right or to stay put. More precisely, a transition of a 2DST is de.ned by a a tuple (q, \ns, ., q ' ,a,.),where q, s, ., q ' and a are as for SDSTs, and . is in {., ., .}. For 2DSTs, we assume \nthat the input data string is enclosed by two special symbols f, -. The machine stops when it reaches \na .nal state. If the machine never reaches a .nal state, or if it tries to move left while the tag is \nf or it tries to move right when the tag is -, then the output unde.ned. Given a 2DST S and a state q \nof S,the 2DST reachability problem is to determine whether there exists a data string w such that S enters \nthe state q while processing w. Theorem 14. The 2DST reachability problem is undecidable. The theorem \nis proven by reduction from the undecidable prob\u00adlem of emptiness for two-counter automata. The main \nstep of the proof is to show that a 2DST can recognize whether the input data string encodes a computation \nof a two-counter machine. The proof uses the fact that the data domain is ordered. Programs with multiple \ntraversing pointers The class of imper\u00adative list processing programs considered in Section 3 restricts \nhow next pointers of heap nodes can be traversed: there is one special pointer variable curr, and it \nis the only pointer variable that can traverse the next pointer. Now consider the class of programs, \nde\u00adnoted by PMTP (short for programs with multiple traversal point\u00aders), obtained by lifting this restriction, \nand allowing assignments x := y.next for any two pointer variables x and y. Given a program P from the \nclass PMTP and a location e,the PMTP reachability problem is to determine whether there exists a data \nstring w such that starting from the initial heap that stores w, there is an execution of P leading to \na con.guration with location e. Theorem 15. The PMTP reachability problem is undecidable. The proof of \nthe undecidability is again by a reduction from the reachability problem for two-counter automata. The \nbasic observa\u00adtion is that if multiple pointers can traverse the heap simultaneously, the program can \ncheck whether two successive parts of the heap en\u00adcode two successive con.gurations of the two-counter \nmachine. Data string variable equality While a number of analysis prob\u00adlems for SDSTs, and assertion \nchecking problems for single-pass list-processing programs, are decidable, checking whether the transducer/program \ncan reach a con.guration where the contents of two string variables are the same, is undecidable. Given \nan SDST S,astate q of S, and two data string variables x and y of S,the data string variable equality \nproblem is to determine whether there exists a data string w such that S reaches a con.guration where \nx = y and the state is q. The following theorem is proven using a reduction from Post s correspondence \nproblem. Theorem 16. The data string variable equality problem is unde\u00adcidable.  6. Related Work We \nare not aware of any prior decidability results for checking semantic equivalence of list processing \nprograms, even for the restricted case of bounded data domains. The decidability of safety properties \nfor programs with lists was investigated in [7]. The negative result in [7] holds for a very re\u00adstricted \nclass of programs: programs with only non-nested loops which do not modify the list data structure. Compared \nto the model of [7], we do not allow general traversal assignments of the form x := y.next, but allow \nonly one pointer variable curr to traverse the next pointers of the heap nodes. We also assume that the \nini\u00adtial heap is acyclic (but analysis algorithms can detect if cycles get introduced during program \nexecution). In previous work [8], we have presented decidability results for a class of concurrent list \nac\u00adcessing programs. The two models are different: the model in [8] allows concurrency and nondeterminism, \nbut is not able to capture for example the list reversal transduction. The restrictions in [8] are rather \nintricate, and that is what triggered this study in search of a robust automata-theoretic model. Extending \nthe streaming trans\u00adducer model to capture concurrency is an interesting research di\u00adrection. There is \nan emerging literature on automata and logics over data strings [3, 15] and algorithmic analysis of programs \naccessing data strings [2]. While existing literature studies acceptors and lan\u00adguages of data strings, \nwe want to handle destructive methods that  e.g. delete elements, and thus, a model of transducers is \nneeded. A number of automata-based techniques have been proposed for shape analysis [4, 5] (see also \n[9] for a survey). In particular, the regular model checking approach [4] employs transducers to reason \nabout heap-manipulating programs in the following manner. The set of heaps feasible at a program point \nis represented by either a string automaton or a tree automaton, and the transformation on the heap due \nto a single statement is captured by a corresponding transducer model. The transformation of the entire \nprogram, then, corresponds to iterated composition of such transducers. Given a regular initial set of \nheaps, the set of heaps reachable after one tran\u00adsition will be regular. However, regular languages are \nnot closed under unbounded union, so the set of all reachable heaps need not be regular. Consider a program \nthat given an input list w outputs the list ww (note that data values do not play an important role in \nthis transduction). For such a program, the iterative .xpoint pro\u00adcedure to compute the set of all reachable \ncon.gurations does not terminate (in fact, the set of reachable con.gurations is not regular, and cannot \nbe represented by a .nite-state automaton). However, a streaming transducer that computes such a transduction \ncan be easily de.ned. It is important to note that our decision procedures do not attempt to compute \nthe set of reachable con.gurations (or heap contents). The literature on regular model checking provides \nseveral techniques for over-approximations of the set of reachable heaps to ensure termination, such \nas widening [20] and specialized abstractions using counters [6]. Analyzing programs that manipulate \ndynamic linked data struc\u00adtures is a widely studied problem commonly described as shape analysis [19]. \nProving assertions of such programs is undecid\u00adable [12, 18], and the bulk of the literature consists \nof abstraction\u00adbased techniques for veri.cation (see e.g. [10, 14, 17]). The core problem these techniques \nfocus on is computation of invariants that often need to quantify over the nodes in the heap. Let us \nconsider function Delete from Section 3. If the function was called with the parameter d, a natural postcondition \nis that all nodes reach\u00adable from result have values different from d. A quanti.ed in\u00advariant needed \nto prove the postcondition could be automatically computed using for example the approach described in \n[17]. How\u00adever, we emphasize that in contrast to the sound-but-not-complete abstraction-based methods \nfor checking safety properties, our ap\u00adproach is sound and complete for a well-de.ned class of programs \nand, in addition to checking of assertions and pre/post conditions, we presented an algorithm for checking \nequivalence of programs.  7. Conclusions We have introduced a streaming transducer model, and showed \nthat it can serve as a foundational model of single-pass list processing programs. Our results lead to \nalgorithms for checking functional equivalence of two programs, written possibly in different pro\u00adgramming \nstyles, for commonly used routines for processing lists of data items. We are not aware of any prior \ndecidability results for checking semantic equivalence of list processing programs, even for the restricted \ncase of bounded data domains. We also believe that the streaming transducer model introduced in this \npaper is of independent theoretical interest. We have started the investigation of expressiveness and \nrelated theoretical proper\u00adties of the transducer model when the data domain is bounded. Classical string-to-string \n.nite-state transducers need to be two\u00adway to implement an operation such as reverse. In a subsequent \npaper, we showed that the streaming string transducer model is expressively equivalent to two-way transducers \n[1], and thus, to MSO-de.nable string transductions [11]. Learning streaming string transducers from \ninput/output examples, and de.ning a similar streaming transducer model for tree-structured data are \npotential fruitful directions for future research.  References [1] R. Alur and P. .y. Expressivness \nof streaming string transducers. Cern\u00b4 Invited paper. In FSTTCS, 2010. [2] R. Alur, P. .y, and S. Weinstein. \nAlgorithmic analysis of array- Cern\u00b4 accessing programs. In CSL, pages 86 101, 2009. [3] M. Boja\u00b4nczyk, \nA. Muscholl, T. Schwentick, L. Segou.n, and C. David. Two-variable logic on words with data. In LICS, \npages 7 16, 2006. [4] A. Bouajjani, B. Jonsson, M. Nilsson, and T. Touili. Regular model checking. In \nCAV, pages 403 418, 2000. [5] A. Bouajjani, P. Habermehl, P. Moro, and T. Vojnar. Verifying pro\u00adgrams \nwith dynamic 1-selector-linked structures in regular model checking. In TACAS, pages 13 29, 2005. [6] \nA. Bouajjani, M. Bozga, P. Habermehl, R. Iosif, P. Moro, and T. Voj\u00adnar. Programs with lists are counter \nautomata. In CAV, pages 517 531, 2006. [7] M. Bozga and R. Iosif. On .at programs with lists. In VMCAI, \npages 122 136, 2007. [8] P. .y, A. Radhakrishna, D. Zufferey, S. Chaudhuri, and R. Alur. Cern\u00b4Model checking \nof linearizability of concurrent list implementations. In CAV, pages 465 479, 2010. [9] S. Chakraborty. \nReasoning about heap manipulating programs using automata techniques. To appear in IISc-World Scienti.c \nReview Vol\u00adume on Modern Applications of Automata Theory. [10] D. Distefano, P. O Hearn, and H. Yang. \nA local shape analysis based on separation logic. In TACAS, pages 287 302, 2006. [11] J. Engelfriet and \nH. Hoogeboom. MSO de.nable string transductions and two-way .nite-state transducers. ACM Trans. Comput. \nLog., 2(2): 216 254, 2001. [12] W. Landi. Undecidability of static analysis. LOPLAS, 1(4):323 337, 1992. \n[13] R. Manevich, E. Yahav, G. Ramalingam, and S. Sagiv. Predicate ab\u00adstraction and canonical abstraction \nfor singly-linked lists. In VMCAI, pages 181 198, 2005. [14] R. Manevich, J. Berdine, B. Cook, G. Ramalingam, \nand M. Sagiv. Shape analysis by graph decomposition. In TACAS, pages 3 18, 2007. [15] F. Neven, T. Schwentick, \nand V. Vianu. Finite state machines for strings over in.nite alphabets. ACM Trans. Comput. Logic, 5(3):403 \n435, 2004. [16] B. Pierce. Types and programming languages. MIT Press, 2002. [17] A. Podelski and T. \nWies. Counterexample-guided focus. In POPL, pages 249 260, 2010. [18] G. Ramalingam. The undecidability \nof aliasing. ACM Trans. Program. Lang. Syst., 16(5):1467 1471, 1994. [19] S. Sagiv, T. Reps, and R. Wilhelm. \nParametric shape analysis via 3\u00advalued logic. ACM Trans. Program. Lang. Syst., 24(3):217 298, 2002. [20] \nT. Touili. Regular model checking using widening techniques. Electr. Notes Theor. Comput. Sci., 50(4), \n2001.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p>We introduce <i>streaming data string transducers</i> that map input data strings to output data strings in a single left-to-right pass in linear time. Data strings are (unbounded) sequences of data values, tagged with symbols from a finite set, over a potentially infinite data domain that supports only the operations of equality and ordering. The transducer uses a finite set of states, a finite set of variables ranging over the data domain, and a finite set of variables ranging over data strings. At every step, it can make decisions based on the next input symbol, updating its state, remembering the input data value in its data variables, and updating data-string variables by concatenating data-string variables and new symbols formed from data variables, while avoiding duplication. We establish PSPACE bounds for the problems of checking functional equivalence of two streaming transducers, and of checking whether a streaming transducer satisfies pre/post verification conditions specified by streaming acceptors over input/output data-strings.</p> <p>We identify a class of imperative and a class of functional programs, manipulating lists of data items, which can be effectively translated to streaming data-string transducers. The imperative programs dynamically modify a singly-linked heap by changing next-pointers of heap-nodes and by adding new nodes. The main restriction specifies how the next-pointers can be used for traversal. We also identify an expressively equivalent fragment of functional programs that traverse a list using syntactically restricted recursive calls. Our results lead to algorithms for assertion checking and for checking functional equivalence of two programs, written possibly in different programming styles, for commonly used routines such as insert, delete, and reverse.</p>", "authors": [{"name": "Rajeev Alur", "author_profile_id": "81100359539", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2509706", "email_address": "alur@cis.upenn.edu", "orcid_id": ""}, {"name": "Pavol &#268;ern&#253;", "author_profile_id": "81100462652", "affiliation": "IST Austria, Klosterneuburg, Austria", "person_id": "P2509707", "email_address": "pavol.cerny@ist.ac.at", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926454", "year": "2011", "article_id": "1926454", "conference": "POPL", "title": "Streaming transducers for algorithmic verification of single-pass list-processing programs", "url": "http://dl.acm.org/citation.cfm?id=1926454"}