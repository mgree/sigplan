{"article_publication_date": "01-26-2011", "fulltext": "\n Decidable Logics Combining Heap Structures and Data P. Madhusudan Gennaro Parlato Xiaokang Qiu University \nof Illinois at LIAFA, CNRS and University of Paris University of Illinois at Urbana-Champaign, USA Diderot, \nFrance Urbana-Champaign, USA madhu@illinois.edu gennaro@liafa.jussieu.fr qiu2@illinois.edu Abstract \nWe de.ne a new logic, STRAND, that allows reasoning with heap\u00admanipulating programs using deductive veri.cation \nand SMT solvers. STRAND logic ( STRucture ANd Data logic) formulas express constraints involving heap \nstructures and the data they contain; they are de.ned over a class of pointer-structures R de\u00ad.ned using \nMSO-de.ned relations over trees, and are of the form .yx.yx,y ),where . is a monadic second-order logic \n(MSO) for\u00ad y.(ymula with additional quanti.cation that combines structural con\u00adstraints as well as data-constraints, \nbut where the data-constraints are only allowed to refer to yx and yy. The salient aspects of the logic \nare: (a) the logic is powerful, allowing existential and universal quanti.cation over the nodes, and \ncomplex combinations of data and structural constraints; (b) checking Hoare-triples for linear blocks \nof statements with pre\u00adconditions and post-conditions expressed as Boolean combinations of existential \nand universal STRAND formulas reduces to satis\u00ad.ability of a STRAND formula; (c) there are powerful decidable \nfragments of STRAND, one semantically de.ned and one syntac\u00adtically de.ned, where the decision procedure \nworks by combining the theory of MSO over trees and the quanti.er-free theory of the underlying data-logic. \nWe demonstrate the effectiveness and practi\u00adcality of the logic by checking veri.cation conditions generated \nin proving properties of several heap-manipulating programs, using a tool that combines an MSO decision \nprocedure over trees (MONA) with an SMT solver for integer constraints (Z3). Categories and Subject Descriptors \nF.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams: Mechanical \nVeri.cation; D.2.4 [Software Engineering]: Software/Program Veri.cation: Assertion checkers; F.1.1 [Theory \nof Computation]: Models of Computation: Automata General Terms Algorithms, Reliability, Theory, Veri.cation \nKeywords heap analysis, SMT solvers, monadic second-order logic, combining decision procedures, automata, \ndecidability 1. Introduction A fundamental component of analysis techniques for complex pro\u00adgrams is \nlogical reasoning. The advent of ef.cient SMT solvers (satis.ability modulo theory solvers) have signi.cantly \nadvanced Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed the techniques for the analysis \nof programs. SMT solvers check satis.ability in particular theories (e.g. integers, arrays, theory of \nuninterpreted functions, etc.), and are often restricted to quanti.er\u00adfree fragments of .rst-order logic, \nbut support completely auto\u00admated and ef.cient decision procedures for satis.ability. Moreover, by using \ntechniques that combine theories, larger decidable theories can be obtained. The Nelson-Oppen framework \n[22] allows generic combinations of quanti.er-free theories, and has been used in ef\u00ad.cient implementations \nof combinations of theories using a SAT solver that queries decision procedures of component theories. \nSatis.ability solvers for theories are tools that advance several analysis techniques. They are useful \nin test-input generation, where the solver is asked whether there exists an input to a program that will \ndrive it along a particular path; see for example [12]. SMT solvers are also useful in static-analysis \nbased on abstract inter\u00adpretation, where the solver is asked to compute precise abstract transitions \n(for example see SLAM [2] for predicate abstraction and TVLA [17, 27] for shape-analysis). Solvers are \nalso useful in classical deductive veri.cation, where Hoare-triples that state pre\u00adconditions and post-conditions \ncan be transformed into veri.cation conditions whose validity is checked by the solver; for example BOOGIE \n[3] and ESC/Java [11] use SMT solvers to prove veri.ca\u00adtion conditions. One of the least understood classes \nof theories, however, are the\u00adories that combine heap-structures and the data they contain. Anal\u00adysis \nof programs that manipulate dynamically allocated memory and perform destructive pointer-updates while \nmaintaining data\u00adstructure invariants (like a binary search tree), requires reasoning with heaps with \nan unbounded number of nodes with data stored in them. Reasoning with heap structures and data poses \nfundamental challenges due to the unboundedness of the data-structures. First, for a logic to be useful, \nit must be able to place constraints on all parts of the structure (e.g. to say a list is sorted), and \nhence some form of universal quanti.cation over the heap is absolutely neces\u00adsary. This immediately rules \nout classical combinations of theories, like the Nelson-Oppen scheme [22], which caters only to quanti.er\u00adfree \ntheories. Intuitively, given a constraint on heap structures and data, there may be an in.nite number \nof heaps that satisfy the struc\u00adtural constraints, and checking whether any of these heaps can be extended \nwith data to satisfy the constraint cannot be stated over the data-logic (even if it has quanti.cation). \nThere have been a few breakthroughs in combining heap struc\u00adtures and data recently. For instance, HAVOC \n[16] supports a logic that ensures decidability using a highly restrictive syntax, and CSL [7] extends \nthe HAVOC logic mechanism to handle constraints on sizes of structures. However, both these logics have \nvery awk\u00adward syntax that involve the domain being partially ordered with for pro.t or commercial advantage \nand that copies bear this notice and the full citation respect to sorts, and the logics are heavily curtailed \nso that the deci\u00adon the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nsion procedure can move down the sorted structures hierarchically to lists, requires prior speci.c permission \nand/or a fee. and hence terminate. Moreover, these logics cannot express even POPL 11, January 26 28, \n2011, Austin, Texas, USA. simple properties on trees of unbounded depth, like the property cCopyright \n&#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00  that a tree is a binary search tree. More importantly, \nthe technique for deciding the logic is encoded in the syntax, which in turn nar\u00adrowly aims for a fast \nreduction to the underlying data-logic, making it hard to extend or generalize. In this paper, we propose \na new fundamental technique for de\u00adciding theories that combine heap structures and data, for fragments \nof a logic called STRAND. The logic STRAND: We de.ne a new logic called STRAND (for STRucture ANd Data \n), that combines a powerful heap-logic with an arbitrary data-logic. STRAND formulas are interpreted \nover a class of data-structures R, and are of the form .yx.yx,y ),where y.(y. is a formula that combines \na complete monadic second-order logic over the heap-structure (and can have additional quanti.ca\u00adtion), \nand a data-logic that can constrain the data-.elds of the nodes referred to by yx and y . The heap-logic \nin STRAND is derived from the rich logic tra\u00addition of designing decidable monadic second-order logics \nover graphs, and is extremely expressive in de.ning structural shapes and invariants. STRAND formulas \nare interpreted over a recursively de.ned class of data-structures R, which is de.ned using a regu\u00adlar \nset of skeleton trees with MSO-de.ned edge-relations (pointer\u00adrelations) between them. This way of recursively \nde.ning data\u00adstructures is not new, and was pioneered by the PALE system [20], which reasons with purely \nstructural properties of heaps de.ned in a similar manner. In fact, the notion of graph types [14] is \na conve\u00adnient and simple way to de.ne data-structure types and invariants, and is easily expressible \nin our scheme. Data-structures de.ned over skeleton trees have enough expressive power to state most \ndata-structure invariants of recursively de.ned data-structures, in\u00adcluding nested lists, threaded trees, \ncyclic and doubly-linked lists, and separate or loosely connected combinations of these structures. Moreover, \nthey present a class of graphs that have a decidable MSO theory, as MSO on these graphs can be interpreted \nusing MSO over trees, which is decidable. In fact, graphs de.ned this way are one of the largest classes \nof graphs that have a decidable MSO theory. As we show in this paper, the STRAND logic is well-suited \nto reasoning with programs. In particular, assume we are given a (straight-line) program P , a pre-condition \non the data-structure ex\u00adpressed as a set of recursive structures R, and a pre-condition and a post-condition \nexpressed in a sub-fragment of STRAND that allows Boolean combinations of the existential and universal \nfragments. We show that checking the invalidity of the associated Hoare-triple reduces to the satis.ability \nproblem of STRAND over a new class of recursive structures RP . Note that despite its relative expressiveness \nin allowing quanti.\u00adcation over nodes, STRAND formulas cannot express certain con\u00adstraints such as those \nthat constrain the length of a list of nodes (e.g., to express that the number of black nodes on all \npaths in a red-black tree are the same), nor express the multi-set of data\u00advalues stored in a data-structure \n(e.g., to express that one list s data contents are the same as that of another list). We hope that future \nwork will extend the results in this paper to handle such constraints. Decidable fragments of STRAND: \nThe primary contribution of this paper is in identifying decidable fragments of STRAND.We de.ne two such \nfragments, one which is a semantic fragment STRANDsem that de.nes the largest class that can exploit \nour com\u00ad dec bination mechanism for decidability, and the other a smaller but syntactic fragment STRANDdec. \nThe decision procedures work through a notion called satis.\u00adability-preserving embeddings. Intuitively, \nfor two heap structures (without data) S and S', S satis.ability-preservingly embeds in S' with respect \nto a STRAND formula . if there is an embedding of the nodes of S in S' such that no matter how the data-logic \nconstraints are interpreted,if S' satis.es ., then so will the submodel S satisfy ., by inheriting the \ndata-values. We de.ne the notion of satis.ability-preserving embeddings so that it is entirely structural \nin nature, and is de.nable using MSO on an underlying graph that simultaneously represents S, S', and \nthe embedding of S in S'. If S satis.ability-preservingly embeds in S',then clearly,when checking for \nsatis.ability, we can ignore S' if we check satis.\u00adability for S. More generally, the satis.ability check \ncan be done only for the minimal structures with respect to the partial-order (and well-order) de.ned \nby satis.ability-preserving embeddings. The semantic decidable fragment STRANDsem is de.ned to be dec \nthe class of all formulas for which the set of minimal structures with respect to satis.ability-preserving \nembeddings is .nite,and where the quanti.er-free theory of the underlying data-logic is decidable. Though \nthis fragment of STRAND is semantically de.ned, we show that it is syntactically checkable. Given a STRAND \nformula .,we show that we can build a regular .nite representation of all the min\u00adimal models with respect \nto satis.ability-preserving embeddings, even if it is an in.nite set, using automata-theory. Then, checking \nwhether the number of minimal models is .nite is decidable. If the set of minimal models is .nite, we \nshow how to enumerate the models, and reduce the problem of checking whether they admit a data-extension \nthat satis.es . to a formula in the quanti.er-free fragment of the underlying data-logic, which can then \nbe decided. We also de.ne a syntactic decidable fragment of STRAND, STRANDdec,whichisasubfragmentofthesemanticclass \nSTRANDsem dec . In this fragment, we distinguish two kinds of binary relations in the heap, elastic and \nnon-elastic relations. Intuitively, a relation is elas\u00adtic if for every model M and submodel M', the \nrelation holds on a pair of nodes of M' iff the relation holds for the corresponding pair of nodes in \nM. Given a relation R,we show itis alsode\u00adcidable whether R is an elastic relation. STRANDdec formulas \nare then of the form .yx.yx,y ), where (a) . has no additional quan\u00ad y.(yti.cation, and (b) the atomic \nnon-elastic structural relations in . compare only variables in yx. We show that STRANDdec formulas always \nhave a .nite number of minimal models with respect to satis.ability-preserving embeddings, and are hence \ndecidable us\u00ading the decision procedure for the semantic fragment STRANDsem dec . We report also on an \nimplementation of the above decision pro\u00adcedures. For the structural phase, we use MONA [13], a power\u00adful \ntool for deciding MSO over trees which, despite its theoreti\u00adcal non-elementary worst-case complexity, \nworks very ef.ciently on realistic examples, by combining a variety of techniques includ\u00ading tree-automata \nminimization, BDDs, and guided tree automata. The quanti.er-free data-logic we use is the quanti.er-free \nlogic of linear arithmetic, and we use the SMT solver Z3 to handle these constraints. We have proved \nseveral heap-manipulating programs correct including programs that search and insert into sorted lists, \nreverse sorted lists, and perform search, insertion, and rotation on binary-search trees. In each of \nthese cases, the veri.cation conditions were always expressible in the syntactic fragment STRANDdec, \nand hence in the semantic decidable fragment STRANDsem dec , supporting our thesis that the decidable \nfragment is natural and useful. In summary, we present a general decidability technique for combining \nheap structures and data, identify semantically a de\u00adcidable fragment STRANDsem dec , demonstrate a syntactically-de.ned \nsubfragment STRANDdec, and present experimental evaluation to show that the decidable combination is \nexpressive and ef.ciently solvable. We believe that this work breaks new ground in combin\u00ading heap structures \nand data, and the technique may also pave the way for de.ning decidable fragments of other logics, such \nas sepa\u00adration logic, that combine structures and data.  2. Motivating examples and logic design The \ngoal of this section is to present an overview of the issues involved in .nding decidable logics that \ncombine heap structure and data, which sets the stage for de.ning the decidable fragments of the logic \nSTRAND, and motivates the choices in our logic design using simple examples on lists.  Let us consider \nlists in this section, where each node u has a data-.eld d(u) that can hold a value (say an integer), \nand with two variables head and tail pointing to the .rst and last nodes of the list, respectively. Consider \n.rst-order logic, where we are allowed to quantify over the nodes of the list, and further, for any node \nx, allowed to refer to the data-.eld of x using the term d(x). Let x . y denote that y is the successor \nof x in the list, and let x . * y denote that x is the same as y or precedes y in the list. EXAMPLE 2.1. \nConsider the formula: .1 : d(head)=c1 . d(tail)=c2 . .y1.y2((y1 . * y2) . d(y1) = d(y2)) The above says \nthat the list must be sorted and that the head of the list must have value c1 and the tail must have \nvalue c2.Note that the formula is satis.able iff c1 = c2, and in which case it is actually satis.ed by \na list containing just two elements, pointed to by head and tail, with values c1 and c2, respectively. \nIn fact, the property that the formula is satis.able by a two\u00adelement list has nothing really to do with \nthe data-constraints in\u00advolved in the above formula. Assume that we have no idea as to what the data-constraints \nmean, and hence look upon the above formula by replacing all the data-constraints using uninterpreted \npredicates p1,p2,... to get the formula: .b1 : p1(d(head)) . p2(d(tail)) . .y1.y2((y1 . * y2) . p3(d(y1),d(y2))) \n Now, we do not know whether the formula is satis.able (for exam\u00adple, p1 may be unsatis.able). But we \nstill do know that two-element lists are always suf.cient. In other words, if there is a list that satis\u00ad.es \nthe above formula, then there is a two-element list that satis.es it. The argument is simple: take any \nlist l that satis.es the formula, and form a new list l ' that has only the head and tail of the list \nl, with an edge from head to tail, and with data values inherited from l (see .gure below). It is easy \nto see that l ' satis.es the formula as well, since whenever two nodes are related by . * in the list \nl ' ,the corresponding elements in l are similarly related. This property, tail ...\u00a3 head tail \u00a3' of \ncourse, does not hold on all formulas, as we see in the example below. EXAMPLE 2.2. Consider the formula: \n.2 : d(head)=c1 . d(tail)=c2 . .y1.y2((y1 . y2) . d(y2)= d(y1)+1) The above says that the values in \nthe list increase by one as we go one element down the list, and that the head and tail of the list have \nvalues c1 and c2, respectively. This formula is satis.able iff c1 <c2. However, there is no bound on \nthe size of the minimal model that is independent of the data-constraints. For example, if c1 =1 and \nc2 =106, then the smallest list that satis.es the formula has a million nodes. In other words, the data-constraints \nplace arbitrary lower bounds on the size of the minimal structure that satis.es the formula. Intuitively, \nthe formula .2 refers to successive elements in the list, and hence a large model that satis.es the formula \nis not neces\u00adsarily contractible to a smaller model. The formula .1 in the sort\u00adedness example (Example \n2.1) refers to pairs of elements that were reachable, leading to contraction of large models to small \nones. Recall that the design principle of the decidable fragment of STRAND is to examine the structural \nconstraints in a formula ., and enumerate a .nite set of structures such that the formula is sat\u00adis.able \niff it one of these structures can be populated with values to satisfy the formula. This strategy necessarily \nfails for the above for\u00admula .2, as there is no class of .nite structures that adequately cap\u00adtures all \nmodels of the formula, independent of the data-constraints. The sortedness formula .1 in the .rst example \nis part of the decid\u00adable fragment of STRAND, while .2 is outside of it. EXAMPLE 2.3. Consider the formula: \n.3 : d(head)=c1 . d(tail)=c2 . .y1((y1 = tail) ..y2(d(y2)= d(y1)+1)) This formula says that for any \nnode n except the tail, there is some node n ' that has the value d(n)+1. Notice that the formula is \nsatis.able if c1 <c2, but still there is no a priori bound on the minimal model that is independent of \nthe data-constraints. In particular, if c1 =0 and c2 =106, then the smallest model is a list with 106 \nnodes. Moreover, the reason why the bounded struc\u00adture property fails is not because of the data-constraints \nreferring to successive elements as in Example 2.2, but rather because the above formula has a .. pre.x \nquanti.cation of data-variables. Formulas where an existential quanti.cation follows a universal quanti.ca\u00adtion \nin the pre.x seldom have bounded models, and STRAND hence only allows formulas with . * . * quanti.cation \npre.xes. Note that quanti.cation of structure variables (variables that quantify over nodes but whose \ndata-.eld is not referenced in the formula) can be arbitrary, and in fact we allow STRAND formulas to \neven have set quanti.cations over nodes. The Bernays-Sch\u00a8on.nkel-Ramsey class: Having motivated for\u00admulas \nwith the . * . * quanti.cation, it is worthwhile to examine this fragment in classical .rst-order logic \n(over arbitrary in.nite uni\u00adverses), which is known as the Bernays-Sch\u00a8on.nkel-Ramsey class, and is a \nclassical decidable fragment of .rst-order logic [6]. Consider .rst a purely relational vocabulary (assume \nthere are no functions and even no constants). Then, given a formula .yx.yx,y ),let M be a model that \nsatis.es this formula. Let v y.(ybe an interpretation for yx such that M under v satis.es .yx,y ). y.(yThen \nit is not hard to argue that the submodel obtained by pick\u00ading only the elements used in the interpretation \nof yx (i.e. v(yx)), and projecting each relation to this smaller set, satis.es the for\u00admula .yx.yx,y \n) as well [6]. Hence a model of size at most k y.(yalways exists that satis.es ., if the formula is satis.able, \nwhere k is the size of the vector of existentially quanti.ed variables yx.This bounded model property \nextends to when constants are present as well (the submodel should include all the constants) but fails \nwhen more than two functions are present. Satis.ability hence reduces to propositional satis.ability, \nand this class is also called the effec\u00adtively propositional class, and SMT solving for this class exists \n[8]. The decidable fragment of STRAND is fashioned after a similar but more complex argument. Given a \nsubset of nodes of a model, the subset itself may not form a valid graph/data-structure. We de\u00ad.ne a \nnotion of submodels that allows us to extract proper sub\u00adgraphs that contain certain nodes of the model. \nHowever, the rela\u00adtions (edges) in the submodel will not be the projection of edges in the larger model. \nConsequently, the submodel may not satisfy a formula, even though the larger model does. We de.ne a notion \ncalled satis.ability-preserving embeddings that allows us to identify when a submodel S of T is such \nthat, whenever T satis.es . under some interpretation of the data-logic, S can inherit values from T \nto satisfy . as well. This is consider\u00adably more complex and is the main technical contribution of the \npa\u00adper. We then build decision procedures to check the minimal mod\u00adels according to this embedding relation. \n  3. Recursive data-structures We now de.ne recursive data-structures using a formalism that de.nes \nthe nodes and edges using MSO formulas over a regular set of trees. Intuitively, a set of data-structures \nis de.ned by taking a regular class of trees that acts as a skeleton over which the data\u00adstructure will \nbe de.ned. The precise set of nodes of the tree that corresponds to the nodes of the data-structure, \nand the edges between these nodes (which model pointer .elds) will be captured using MSO formulas over \nthese trees. We call such classes of data\u00adstructures recursively de.ned data-structures. Recursively \nde.ned data-structures are very powerful mecha\u00adnisms for de.ning invariants of data-structures. The notion \nof graph types [14] is a very similar notion, where again data-structure in\u00advariants are de.ned using \na tree-backbone but where edges are de\u00ad.ned using regular path expressions. Graph types can be modeled \ndirectly in our framework; in fact, our formalism is more powerful. The framework of recursively de.ned \ndata-structures is also in\u00adteresting because they de.ne classes of graphs that have a decid\u00adable monadic \nsecond-order theory. In other words, given a class C of recursively de.ned data-structures, the satis.ability \nproblem for MSO formulas over C (i.e. the problem of checking, given ., whether there is some structure \nR .C that satis.es .) is decidable. The decision procedure works by interpreting the MSO formula on the \ntree-backbone of the structures. In fact, our framework can cap\u00adture all graphs de.nable using edge-replacement \ngrammars,which are one of the most powerful classes of graphs known that have a decidable MSO theory \n[10]. 3.1 Graphs and monadic second-order logics A labeled (directed) graph G over a .nite set of vertex-labels \nLv and a .nite set of edge labels Le is a 6-tuple, G =(V, E, \u00b5, ., Lv, Le),where V is a non-empty .nite \nset of nodes, E . V \u00d7 V is a set of edges, \u00b5 : V . 2Lv assigns a subset of labels to each vertex, and \n. : E . 2Le assigns a subset of labels to each edge. Monadic second-order logic (MSO) on graphs over \nthe la\u00adbels (Lv,Le) is the standard MSO on structures of the form (U, E, {Qa}a.Lv , {Eb}b.Le ) where \nU represents the universe, E is a binary relation capturing the edge relation, Qa is a monadic predicate \nthat captures all nodes whose labels contain a,and Eb is a binary relation that captures all edges whose \nlabel contain b (note that Eb . E,for every b . Le). However, we also allow Boolean variables and quanti.cation \nover them1. Let us .x a countable set of .rst-order variables FV (.rst-order variables will be denoted \nby s, t, etc.) and a countable set of set\u00advariables SV (set-variables will be denoted by S, T ,etc.).Let \nus also .x a countable set of Boolean variables BV (denoted by p, q, etc.) The syntax of the logic is: \n. ::= p | Qa(s) | E(s, t) | Eb(s, t) | s = t | s . S | . . . |\u00ac. |.s.. |.p.. |.S.. where a . Lv, b . \nLe, s, t . FV , S . SV ,and p . BV . 3.2 Recursively de.ned data-structures Let S be a .nite alphabet. \nFor any k . N,let [k] denote the set {1,...k}. 1 Classical de.nitions of MSO do not allow such Boolean \nquanti.cation, but we will .nd it useful in our setting. These variables can be easily removed; e.g. \ninstead of quantifying over a Boolean variable p, we can quantify over aset X and convert every occurrence \nof p to a formula that expresses that X is empty. A k-ary S-labeled tree is a pair (V, .),where V . [k] \n*,and V is non-empty and pre.x-closed, and . : V . S. The edges of the tree are implicitly de.ned: that \nis u.i is the i th child of u,for every u, u.i . V ,where u . [k] * and i . [k]. Trees are seen as graphs \nwith S-labeled vertices and edge relations Ei(x, y) that de.ne the i th-child edges. Monadic second-order \nlogic over trees is the MSO logic over these graphs. Formally, we de.ne classes of recursively de.ned \ndata-structures as follows. DEFINITION 3.1. Aclass C of recursively de.ned data-structures is speci.ed \nby a tuple R =(.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ), where .Tr is an MSO sentence, .U is a unary predicate \nde.ned in MSO, and each aa and \u00dfb are monadic and binary predicates de.ned using MSO, where all MSO formulas \nare over k-ary trees, for some k . N,. Let R =(.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ) and T be a k-ary S-labeled \ntree. Then T =(V, {Ei}i.[k]) de.nes (according to R) agraph Graph(T )=(N, E, \u00b5, ., Lv,Le) de.ned as follows: \n N = {s . V | .U (s) holds in T }  E = {(s, s ' ) | \u00dfb(s, s ' ) holds in T for some b . Le}  \u00b5(s)= \n{a . Lv | aa(s) holds in T }  .((s, s ' )) = {b . Le | \u00dfb(s, s ' ) holds in T }.  The class of graphs \nde.ned by R is the set Graph(R)= {Graph(T ) | T |= .Tr }. EXAMPLE 3.2. Let us de.ne a class of recursive \ndata-structures that consists of trees where the leaves of the tree are connected by a linked list. The \nclass of trees will be the class of binary trees (with edges E1 and E2 representing left-and right-child \nrelations), and we de.ne the next-edge relation for the list using an MSO predi\u00adcate: Enext(s, t) = leaf(s) \n. leaf(t) ..z1,z2,z3(E1(z3,z1) . E2(z3,z2) . RightMostPath(z1,s) . LeftMostPath(z2,t)) where leaf(x) \nis a subformula that checks if x is a leaf, and RightMostPath(x, y) (and LeftMostPath(x, y)) is a formula \nthat checks if y is in the right-most (left-most, respectively) path from x.  4. STRAND: A logic over \nheap structures and data 4.1 De.nition of STRAND We now introduce our logic STRAND ( STRucture ANd Data \n). STRAND is a two-sorted logic interpreted on program heaps with both locations and their carried data. \nGiven a .rst-order theory D of sort Data, and given L, a monadic second-order (MSO) theory over (Lv,Le)-labeled \ngraphs, of sort Loc, the syntax of STRAND is presented in Figure 1. STRAND is de.ned over the two-sorted \nsignature G(D, L)= Sig(D) . Sig(L) .{data},where data is a function of sort Loc . Data.STRAND formulas \nare of the form .yx.yx,y ),where y y.(yx and y are .DVar and .DVar, respec\u00adtively, of sort Loc (we also \nrefer to both as DVar), . is an MSO formula with atomic formulas of the form either .(e1,...,en) or a(v1,...,vn). \n.(e1,...,en) is an atomic D-formula in which the data carried by Loc-variables can be referred as data(x) \nor data(y). a(v1,...,vn) is just an atomic formula from L.Note that additional variables are allowed \nin .(yx, y ), both .rst-order and second-order, but .(e1,...,en) is only allowed to refer to yx and y \n. A model for STRAND is a structure M = (MLoc, MData, Mmap). MLoc is an L-model (i.e. a labeled graph) \nwith MLoc as the underlying set of nodes, and MData is a D-model with MData as the underlying set. Mmap \nis an interpretation for the function data of sort MLoc . MData. The semantics of STRAND formulas is \nthe natural extension of the logics L and D.  .DVar x . Loc .DVar y . Loc GVar z . Loc Variable v ::= \nx | y | z 2Loc Set - Variable S . Constant c . Sig(D) Function g . Sig(D) D-Relation . . Sig(D) L-Relation \na . Sig(L) Expression e ::= data(x) | data(y) | c | g(e1,...,en) AFormula . ::= .(e1,...,en) | a(v1,...,vn) \n|\u00ac. | .1 . .2 | .1 . .2 |.z.. |.z.. |.S.. |.S.. .Formula . ::= . |.y.. Formula . ::= . |.x.. Figure 1. \nSyntax of STRAND We will refer to an L-model as a graph-model.A data-extension of a graph model MLoc \nis a STRAND model (MLoc, MData,Mmap). Undecidability. STRAND is an expressive logic, as we will show \nbelow, but it is undecidable in general, even if both its underlying theories D and L are decidable. \nLet D be linear integer arithmetic and L be the standard MSO logic over lists. It is easy to model an \nexecution of a 2-counter machine using a list with integers. Each con.guration is represented by two \nadjacent nodes, which are labeled by the current instruction. The data .elds of the two nodes hold the \nvalue of the two registers, respectively. Then a halting computation can be expressed by a STRAND formula. \nHence the satis.ability of the STRAND logic is undecidable, even though the underlying logics L and D \nare decidable.  4.2 Examples We now show various examples to illustrate the expressiveness of STRAND. \nWe sometimes use d() instead of data(), for brevity. EXAMPLE 4.1 (Binary search tree). In STRAND,a binary \nsearch tree (BST) is interpreted as a binary tree data structure with an additional key .eld for each \nnode. The keys in a BST are always stored in such a way as to satisfy the binary-search-tree property, \nexpressed in STRAND as follows: leftsubtree(y1,y2) =.z(left(y1,z) . z . * y2) rightsubtree(y1,y2) =.z(right(y1,z) \n. z . * y2) .bst =.y1.y2((leftsubtree(y1,y2) . d(y2) <d(y1)) . ((rightsubtree(y1,y2) . d(y1) = d(y2)) \n) Note that .bst has an existentially quanti.ed variable z in GVar after the universal quanti.cation \nof y1,y2.However, as z is a structural quanti.cation (whose data-.eld cannot be referred to), this formula \nis in STRAND. EXAMPLE 4.2 (Two disjoint lists). In separation logic[26], a novel binary operator *,or \nseparating conjunction, is de.ned to as\u00adsert that the heap can be split into two disjoint parts where \nits two arguments hold, respectively. Such an operator is use\u00adful in reasoning with frame conditions \nin program veri.cation. Thanks to the powerful expressiveness of MSO logic, the sepa\u00adrating conjunction \nis also expressible in STRAND. For example, (head1 . * tail1) * (head2 . * tail2) states, in separation \nlogic, that there are two disjoint lists such that one list is from head1 to tail1, and the other is \nfrom head2 to tail2. This for\u00admula can be written in STRAND as: .S1.S2(disjoint(S1,S2) . head1.S1 . tail1.S1 \n. head2.S2 .tail2.S2 .head1 . * tail1 .head2 . * tail2). (.z(head1 . * z . z . * tail1) . z . S1). (.z(head2 \n. * z . z . * tail2) . z . S2) where disjoint(S1,S2) =\u00ac.z(z . S1 . z . S2).  5. Deciding STRAND fragments \n5.1 Removing existential quanti.cation: Given a STRAND formula .yx.yx,y ) over a class of recursively \ny.(yde.ned data-structures R =(.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ), we can transform this to an equisatis.able \nformula .yx.y(y y. ' x, y ) over a different class of recursive data-structures R ' , where data\u00adstructures \nin R ' are data-structures in R with new unary predi\u00adcates that give a valuation for the variables in \nyx. We won t de.ne this formally, but this is an easy transformation: we modify .Tr to accept trees with \nextra labelings ai that give (an arbitrary) sin\u00adgleton valuation of each xi . yx that satis.es .U , and \nintroduce new unary predicates Vali(x)= Qai (x), and de.ne . ' (yx, y ) to be (.iVali(xi)) . .(yx, y \n). It is easy to see there is a graph in Graph(R) that satis.es .yx.yx,y ) iff there is a graph in y.(yGraph(R \n' ) that satis.es .yx.yy. ' (yx, y ). The latter is a STRAND formula with no existential quanti.cation \nof variables whose data is referred to by the formula. Let us refer to these formulas with no leading \nexistential quanti.cation on data-variables as universal STRAND formulas; we will now outline techniques \nto solve the sat\u00adis.abilityproblem of acertainclass of universal STRAND formulas.  5.2 Submodels Let \nus .x a class of recursively de.ned data-structures R = (.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ) for the rest \nof this section. We .rst need to de.ne the notion of submodels of a model. The de.nition of a submodel \nwill depend on the particular class of recursively de.ned data-structures we are working with, since \nwe want to exploit the tree-representation of the models, which in turnwillplayacrucialroleindeciding \nfragmentsof STRAND,asit will allow us to check satis.ability-preserving embeddings. In fact, we will \nde.ne the submodel relation between trees that satisfy .Tr . DEFINITION 5.1. Let T =(V, .) be a tree \nthat satis.es .Tr , and let S . V . Then we say that S is a valid subset of V if the following hold: \n S is non-empty, and least-ancestor closed (i.e. for any s, s ' . S, the least common ancestor of s and \ns ' in T also belongs to S).  The subtree de.ned by S, denoted Subtree(T,S),is the tree with nodes S, \nand where the i th child of a node u . S is the (unique) node u ' . S closest to u that is in the subtree \nrooted at the i th child of u. (This is uniquely de.ned since S is least-ancestor closed.) Then we require \nthat Subtree(T,S) also satis.es .Tr .  We also require that for every s . S,if .U (s) holds in Subtree(T,S),then \n.U (s) holds in T as well.  Atree T ' =(V ' ,. ' ) issaidtobe a submodel of T =(V, .) if there is a \nvalid subset S of V such that T ' is isomorphic to Subtree(T,S). Note that a submodel is necessarily \na valid data-structure. Intuitively, T ' =(V ' ,. ' ) is a submodel of T =(V, .) if the vertices of T \n' can be embedded in T , preserving the tree\u00adstructure. The nodes of the Graph(T ' ), are a subset of \nthe nodes of Graph(T ) (because of the last condition in the de.nition of a submodel), and, given a valid \nsubset S, there is in fact an injective mapping from the nodes of Graph(T ' ) to Graph(T ). For technical \nconvenience, we will work with valid subsets mostly, as .xing the precise embedding helps in the decision \nprocedures.  5.3 Structural abstractions of STRAND formulas Let . = .yy.(y ) be a universal STRAND \nformula. We now de.ne the structural abstraction of . as follows. Let .1,.2,...,.r be the atomic relational \nformulas of the data-logic in .. Note that each of these relational formulas will be over the data .elds \nof variables in y only (since the data-logic is restricted to working over the terms data(y),where y \n. y ). Consider evaluating . over a particular model. After .xing a particular valuation of y , notice \nthat the data-relations .i get all .xed, and evaluate to true or false. Moreover, once the values of \n.i are .xed, the rest of the formula is purely structural in nature. Now, if . is to hold in the model, \nthen no matter how we choose to evaluate y over the nodes of the model, the .i relations must evaluate \nto true or false in such a way that . holds. Since we want, in the .rst phase, to ignore the data-constraints \nentirely, we will abstract . using a purely structural formula by using Boolean variables b1,...br instead \nof the data-relations .1,.2,...,.r. However, since these Boolean variables get deter\u00admined only after \nthe valuation of y gets determined, and since we are solving for satis.ability, we existentially quantify \nover these Boolean variables and quantify them after the quanti.cation of y . Formally2, DEFINITION 5.2. \nLet . = .y.y(y ) be a universal STRAND for\u00admula, and let the atomic relational formulas of the data-logic \nthat occur in . be .1,.2,...,.r. Then its structural abstraction .bis de.ned as the pure MSO formula \non graphs: .y .b1 ...br . ' (yy,yb) where . ' is . with every occurrence of .i replaced with bi. For \nexample, consider the sortedness formula .sorted from Exam\u00adple 2.1. Then b .sorted : .y1.y2 .b1 (d(head)=c1 \n. d(tail)=c2 . ((y1 . * y2) . b1) Note that each Boolean variable bi replaces an atomic relational formula \n.i,where .i places some data-constraint on the data-.elds of some of the universally quanti.ed variables. \nThe following proposition is obvious; it says that if a universal STRAND formula . is satis.able, then \nso is its structural abstrac\u00adtion .b. The proposition is true because the values for the Boolean variables \ncan be set in the structural abstraction precisely according to how the relational formulas .i evaluate \nin .: PROPOSITION 5.3. Let . = .y.y(y ) be a universal STRAND formula, and . be its structural abstraction. \nIf . is satis.able b over a set of recursive data-structures R, then the MSO formula on graphs (with \nno constraints on data) .bis also satis.able over R. 2 The de.nition of structural abstractions can be \nstrengthened in two ways. First, if .i and .j are of the same arity and over z and z', respectively, \nand ' further uniformly replacing zi with z in .i yields . ', then we can express i ' the constraint \n((zi = zi ) . (bi . bj)), in the inner formula . '. Sec\u00adond, if a constraint .i involves only existentially \nquanti.ed variables in x, then we can move the quanti.cation of bi outside the universal quanti.ca\u00adtion. \nDoing these steps gives a more accurate structural abstraction, and in practice, restricts the number \nof models created. We use these more precise abstractions in the experiments, but use the less precise \nabstractions in the theoretical narrative. The proofs in this section, however, smoothly extend to the \nmore precise abstractions.  5.4 Satis.ability-preserving embeddings We are now ready to de.ne satis.ability-preserving \nembeddings using structural abstractions. Given a model de.ned by a tree T = (V, .) satisfying .Tr , \nand a valid subset S . V , and a universal STRAND formula ., we would like to de.ne the notion of when \nthe submodel de.ned by S satis.ability-preservingly embeds in the model. The most crucial requirement \nfor the de.nition is that if S satis.ability-preservingly embeds in T , then we require that if there \nis a data-extension of Graph(T ) that satis.es ., then the nodes of the submodel de.ned by S, Graph(Subtree(T,S)), \ncan inherit the data-values and also satisfy .. The notion of structural abstractions de.ned above allows \nus to de.ne such a notion. Intuitively, if a model satis.es ., then it would satisfy .btoo, as for every \nvaluation of y , there is some way it would satisfy the atomic data-relations, and using this we can \npull out a valuation for the Boolean variables to satisfy .b(as in the proof of Proposition 5.3 above). \nNow, since the data-values in the submodel are inherited from the larger model, the atomic data-relations \nwould hold in the same way as they do in the larger model. However, the submodel may not satisfy . if \nthe conditions on the truth-and false-hood of these atomic relations demanded by . are not the same. \nFor example, consider a list and a sublist of it. Consider a formula that demands that for any two successor \nelements y1,y2 in the list, the data-value of y2 is the data-value of y1 incremented by 1 (as in the \nsuccessor example in Section 2): . =.y1.y2((y1 . y2) . (d(y2)= d(y1)+1) ) Now consider two nodes y1 and \ny2 that are successors in the sublist but not successors in the list. The list hence could satisfy the \nformula by setting the data-relation . : d(y2)= d(y1)+1 to false. Since the sublist inherits the data \nvalues, . would be false in the sublist as well, but the sublist will not satisfy the formula .. We hence \nwant to ensure that no matter how the larger model satis.es the formula using some valuation of the atomic \ndata\u00adrelations, the submodel will be able to satisfy the formula using the same valuation of the atomic \ndata-relations. Thisleads usto the following de.nition: DEFINITION 5.4. Let . = .y.y(y ) be a universal \nSTRAND for\u00admula, and let its structural abstraction be .b= .y .yb. ' (y,yyb).Let T =(V, .) be a tree \nthat satis.es .Tr , and let a submodel be de\u00ad.ned by S . V .Then S is said to satis.ability-preservingly \nembed into T wrt . if for every possible valuation of y over the elements of S, and for every possible \nBoolean valuation of yb,if . ' (yb) holds y,yin the graph de.ned by T under this valuation, then the \nsubmodel de.ned by S, Graph(Subtree(T,S)), also satis.es . ' (yb) under y,y the same valuation. The \nsatis.ability-preserving embedding relation can be seen as a partial order over trees (a tree T ' satis.ability-preservingly \nembeds into T if there is a subset S of T such that S satis.ability\u00adpreservingly embeds into T and Subtree(T,S) \nis isomorphic to T ' ); it is easy to see that this relation is re.exive, anti-symmetric and transitive. \nIt is now not hard to see that if S satis.ability-preservingly em\u00adbeds into T wrt .,and Graph(T ) satis.es \n.,then Graph(Subtree( T,S)) also necessarily satis.es ., which is the main theorem we seek. THEOREM 5.5. \nLet . = .y.y(y ) be universal STRAND formula. Let T =(V, .) be a tree that satis.es .Tr , and S be a \nvalid subset of T that satis.ability-preservingly embeds into T wrt .. Then, if there is a data-extension \nof Graph(T ) that satis.es ., then there is a data-extension of Graph(Subtree(T,S)) that satis.es .. \n Notice that the above theorem crucially depends on the formula being universal over data-variables. \nFor example, if the formula was of the form .y1.y2.(y1,y2), then we would have no way of knowing which \nnodes are used for y2 in the data-extension of Graph(T ) to satisfy the formula. Without knowing the \nprecise meaning of the data-predicates, we would not be able to declare that whenever a data-extension \nof Graph(T ) is satis.able, a data\u00adextension of a strict submodel S is satis.able (even over lists). \nThe above notion of satis.ability preserving embeddings is the property that will be used to decide if \na formula falls into our decidable fragment.  dec : A semantic decidable fragment of STRAND 5.5 STRANDsem \nWe are now ready to de.ne STRANDsem dec , the most general decid\u00adable fragment of STRAND in this paper. \nThis fragment is semanti\u00adcally de.ned (but syntactically checkable, as we show below), and intuitively \ncontains all STRAND formulas that have a .nite num\u00adber of minimal models with respect to the partial-order \nde.ned by satis.ability-preserving embeddings. Formally, let . = .y y.(y ) be a universal STRAND formula, \nand let T =(V, .) beatreethat satis.es .Tr . Then we say that T is a minimal model with respect to . \nif there is no strict valid subset S of V that satis.ability-preservingly embeds in T . DEFINITION 5.6. \nLet R be a recursively de.ned set of data\u00adstructures. A universal formula . = .yy.(y ) is in STRANDsem \niff the dec number of minimal models with respect to R and . is .nite. A STRAND formula of the form . \n= x .yx,y ) is in .yy.(y STRANDsem dec iff the corresponding equi-satis.able universal formula . ' over \nset of data-structure R ' (as de.nedin Section5.1) is in STRANDsem dec . We now show that we can effectively \ncheck if a STRAND for\u00admula belongs to the decidable fragment STRANDsem dec . The idea, in\u00adtuitively, \nis to express that a model is a minimal model with respect to satis.ability-preserving embeddings, and \nthen check, using au\u00adtomata theory, that the number of minimal models is .nite. Let . = .y.y(y ) be universal \nSTRAND formula, and let its structural abstraction be .b= .y .y(yb). b. ' y,y We now show that we can \nde.ne an MSO formula MinModel., such that it holds on a tree T =(V, .) iff T de.nes a minimal model with \nrespect to satis.ability-preserving embeddings. Before we do that, we need some technical results and \nnotation. Let R =(.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ). We .rst show that any (pure) MSO formula d on (Lv,Le)\u00adlabeled \ngraphs can be interpreted on trees. Formally, we show that any (pure) MSO formula d on (Lv,Le)-labeled \ngraphs can be transformed syntactically to a (pure) MSO formula d ' on trees such that for any tree T \n=(V, .), Graph(T )) satis.es d iff T satis.es d ' . This is not hard to do, since the graph is de.ned \nusing MSO formulas on the trees, and we can adapt these de.nitions to work over the tree instead. The \ntransformation is given by the following function interpret; the predicates for edges, and the predicates \nthat check vertex labels and edges labels are transformed according to their de.nition, and all quanti.ed \nvariables are restricted to quantify over nodes that satisfy .U . interpret(p)= p  interpret(Qa(s)) \n= aa(s),for every a . Lv  W interpret(E(s, t)) = b.Le \u00dfb(s, t)  interpret(Eb(s, t)) = \u00dfb(s, t),for \nevery b . Le  interpret(s = t)=(s = t)  interpret(s . W )= s . W  interpret(.1 . .2)= interpret(.1) \n. interpret(.2)  interpret(\u00ac.)= \u00ac(interpret(.))  interpret(.s..)= .s.(.U (s) . interpret(.))  interpret(.W..)= \n.W.((.s.(s . W . .U (s))).interpret(.))  It is not hard to show that for any formula d on (Lv,Le)-labeled \ngraphs Graph(T ) satis.es d iff T satis.es interpret(d). Now, we give another transformation, that transforms \nan MSO formula d on trees to a formula d ' (X) on trees, over a free set\u00advariable X, such that for any \ntree T =(V, .) and any valid subset S . V , Subtree(T,S) satis.es d iff T satis.es d ' (X) when X is \ninterpreted to be S. In other words, we can transform a formula that expresses a property of a subtree \nto a formula that expresses the same property on the subtree de.ned by the free variable X.The transformation \nis given by the following function tailor; the crucial transformation are the edge-formulas, which has \nto be interpreted as the edges of the subtree de.ned by X. tailorX (p)= p  tailorX (Qa(s)) = Qa(s),for \nevery a . Lv  tailorX (Ei(s, t)) = .s ' [Ei (s, s ' ) . s ' =t .  '''' ' .t. ((t . X . s = t ) . t \n= t )], for every i . [k]. tailorX (s = t)=(s = t)  tailorX (s . W )= s . W  tailorX (.1 . .2)= tailor(.1) \n. tailor(.2)  tailorX (\u00ac.)= \u00ac(tailor(.))  tailorX (.s..)= .s.(s . X . tailor(.))  tailorX (.W..)= \n.W.(W . X . tailor(.))  The above transformation satis.es the following property. For any MSO sentence \nd on k-ary trees, for any tree T =(V, .) and for any valid subset S . V , Subtree(T,S) satis.es d iff \nT satis.es tailorX (d) when X is interpreted to be S. Note that the above transformations can be combined. \nFor any MSO formula d on (Lv,Le) labeled graphs, consider the formula tailorX (interpret(d)). Then for \nany tree T =(V, .) and for any valid subset S . V , Graph(Subtree(T,S)) satis.es d iff T satis.es tailorX \n(interpret(d)),where X is interpreted as S. Expressing minimal models in MSO. First, we can also express, \nwith an MSO formula ValidSubModel(X), with a free set variable X, that holds in a tree T =(V, .) iff \nX is interpreted as a valid submodel of T : ValidSubModel(X) = .s, t, u ((s . X . t . X . lca(s, t, u)) \n. u . X).tailorX (.Tr) . (.s(s . X . tailorX (.U (s))) . .U (s)) where lca(s, t, u) is an MSO formula \nthat checks whether u is the least-common ancestor of s and t in the tree; this expresses the requirements \nin De.nition 5.1. We are now ready to de.ne the MSO formula on k-ary trees MinModel. that captures minimal \nmodels. Let the structural ab\u00adstraction of . be .b= .y .yb. ' (yy,yb),then MinModel. =\u00ac.X.( ValidSubModel(X) \n. .s.(s . X) ..s.(s . X) . ( .y .yb ((.y.Y(y . X . .U (y)) . interpret(. ' (yb))) yy,y . tailorX (interpret(. \n' (yb))))) y,y The above formula when interpreted on a tree T says that there does not exists a set X \nthat de.nes a non-empty valid strict subset of the nodes of T , which de.nes a model Graph(Subtree(T,X)) \nthat further satis.es the following: for every valuation of y over the nodes of Graph(Subtree(T,S)) and \nfor every valuation of the Boolean variablesyb such that the structural abstraction of . holds in Graph(T \n), the same valuation also makes the structural abstraction of . hold in Graph(Subtree(T,S)).  Note \nthat the above is a pure MSO formula on trees, and en\u00adcodes the properties required of a minimal model \nwith respect to satis.ability-preserving embeddings. Using the classical logic\u00adautomaton connection [6], \nwe can transform the MSO formula MinModel. . .Tr . .bto a tree automaton that accepts precisely those \ntrees that de.ne data-structures that satisfy the structural ab\u00adstraction and are minimal models. Since \nthe .niteness of the lan\u00adguage accepted by a tree automaton is decidable, we can check whether there \nare only a .nite number of minimal models wrt satis.ability-preserving embeddings, and hence decide member\u00adship \nin the decidable fragment STRANDsem dec . THEOREM 5.7. Given a sentence .yx.yx,y ), the problem of y.(y \nchecking whether the sentence belongs to the fragment STRANDsem dec is decidable. In fact, we develop, \nusing the tool MONA, the decision proce\u00addure above (see Section 7). Deciding formulas in STRANDsem We \nnow give the decision dec . procedure for satis.ability of sentences in STRANDsem over a re\u00ad dec cursively \nde.ned class of data-structures. First, we transform the satis.ability problem to that of satis.ability \nof universal formulas of the form . = .y y.(y ). Then, using the formula MinModel. de\u00adscribed above, \nand by transforming it to tree automata, we extract the set of all trees accepted by the tree-automaton \nin order to get the tree-representation of all the minimal models. Note that this set of minimal models \nis .nite, and the sentence is satis.able iff it is satis.able in some data-extension of one of these \nmodels. We can now write a quanti.er-free formula over the data-logic that asserts that one of the minimal \nmodels has a data-extension that satis.es .. This formula will be a disjunction of m sub-formulas .1,...,.m,where \nm is the number of minimal models. Each for\u00admula .i will express that there is a data-extension of the \ni th min\u00adimal model that satis.es .. First, since a minimal model has only a .nite number of nodes, we \ncreate one data-variable for each of these nodes, and associate them with the nodes of the model. It \nis now not hard to transform the formula . to this model using no quanti.cation. The universal quanti.cation \nover y translates to a conjunction of formulas over all possible valuations of y over the nodes of the \n.xed model. Existential (universal) quanti.ed vari\u00adables are then expanded using disjunction (conjunction, \nrespec\u00adtively) of formulas for all possible valuations over the .xed model. The edge-relations between \nnodes in the model are interpreted on the tree using MSO formulas in R, which are then expanded to conditions \nover the .xed set of nodes in the model. Finally, the data-constraints in the STRAND formula are directlywrittenas \ncon\u00adstraints in the data-logic. The resulting formula is a pure data-logic formula without quan\u00adti.cation \nthat is satis.able if and only if . is satis.able over R.This is then decided using the decision procedure \nfor the data-logic. THEOREM 5.8. Given a sentence .yx.yy.(yx, y ) over R in STRANDsem dec , the problem \nof checking whether . is satis.able re\u00adduces to the satis.ability of a quanti.er-free formula in the \ndata\u00adlogic. Since the quanti.er-free data-logic is decidable, the satis.a\u00adbility of STRANDsem dec formulas \nis decidable.  5.6 STRANDdec: A syntactic decidable fragment of STRAND We utilize the semantically \nde.ned decidable class in the previous section to de.ne a logic that has a simple syntactic restriction \nand is entirely decidable. The decidable fragment allows only formulas of the kind .yx.y y. where . has \nno further quanti.cation. Moreover, some of the structural edge relations R on the data-structure are \nclassi.ed as elastic relations. In ., elastic relations are allowed to relate any pair of variables, \nwhile non-elastic relations are allowed only to relate existentially quanti.ed variables in yx. A relation \nR is elastic if, intuitively, for any model M and a submodel M ' of M, R holds on a pair of nodes of \nM ' iff R holds for the corresponding pair of nodes in M. More formally, let us .x a class of recursively \nde.ned data\u00adstructures R =(.Tr ,.U , {aa}a.Lv , {\u00dfb}b.Le ).Let Eb denote the edge-relation de.ned by \n\u00dfb.Thenwe say Eb is elastic if the following holds: for every tree T =(V, {Ei}i.[k]) satisfying .Tr , \nfor every valid subset S of V , and for every pair of nodes u, v in the model M ' = Graph(Subtree(T,S)), \nEb(u, v) holds in M ' iff Eb(u, v) holds in Graph(T ). Forexample,overtrees, the = relation relating \na node with any of its descendants is an elastic relation; however, the relation that relates a node \nto its parent is not elastic, as we can take two nodes u and v in a subtree Subtree(S, T ) where u is \nthe parent of v,but u is not the parent of v in T . We can express the property that Rb is elastic in \nMSO over a particular tree T using the following formula: .S.u.v((ValidSubModel(S) . u.S . v.S . tailorS \n(.U (u)) . tailorS(.U (v))) . (\u00dfb(u, v) . tailorS(\u00dfb(u, v)))) Hence, we can decide whether a relation \nis elastic or not, by check\u00ading the validity of the above formula over all trees satisfying .Tr . The \nsyntactic decidable fragment STRANDdec is de.ned as the class of all STRAND formulas of the form .yx.y \ny. such that (a) . has no quanti.cation, (b) every occurrence of an atomic relation in . is of the form \nR(z1,z2) where either R is an elastic relation or z1 and z2 are in yx, or are constants. We can now show: \nTHEOREM 5.9. Over any class of recursively de.ned structures R, STRANDdec is decidable. We omit the proof \nfor lack of space; it s gist is as follows. When all relations are elastic, for any valid subset S, tailorS(.) \nholds on any valuation of variables over S iff . holds on the same valuation over T (since the atomic \nrelations are elastic). Hence the submodel can always inherit the data-values from the model to satisfy \nthe formula. The minimal models with respect to satis.ability-preserving embeddings are hence a subset \nof the minimal models with respect to the submodel-relation, which we can show is .nite. When all relations \nare not elastic, the proof is much more complex, and relies on the fact that the non-elastic relations \nde.ne only a .nite number of equivalence classes of relationships over yx. All of veri.cation conditions \nin our experiments turn out to be in the syntactic decidable class STRANDdec.  6. Program Veri.cation \nUsing STRAND In this section we show how STRAND can be used to reason about the correctness of programs, \nin terms of verifying Hoare-triples where the pre-and post-conditions express both the structure of the \nheap as well as the data contained in them. The pre-and post-conditions that we allow are STRAND formulas \nthat consist of Boolean combinations of the formulas with pure existential or pure universal quanti.cation \nover the data-variables (i.e. Boolean combinations of formulas of the form .yx. and .y y.); let us call \nthis fragment STRAND.,.. Given a straight-line program P that does destructive pointer\u00adupdates and data \nupdates, we model a Hoare-triple as a tuple (R, Pre,P, Post), where the pre-condition is given by the \ndata\u00adstructure constraint R with the STRAND.,. formula Pre,and the post-condition is given by the STRAND.,. \nformula Post (note that structural constraints on the data-structure for the post-condition are also \nexpressed in Post, using MSO logic).  In this section, we show that given such a Hoare-triple, we can \nreduce checking whether the Hoare-triple is not valid can be reduced to a satis.ability problem of a \nSTRAND formula over a class of recursively de.ned data-structures RP . This then allows us to use STRAND.,. \nto verify programs (where, of course, loop\u00adinvariants are given by the programmer, which breaks down \nver\u00adi.cation of a program to veri.cation of straight-line code). Intu\u00aditively, this reduction augments \nthe structures in R with extra nodes that could be created during the execution of P , and models the \ntrail the program takes by logically de.ning the con.guration of the program at each time instant. Over \nthis trail, we then express that the pre-condition holds and the post-condition fails to hold. We also \nconstruct formulas that check if there is any memory ac\u00adcess violation during the run of P (e.g. free-ing \nlocations twice, dereferencing a null pointer, etc.). Syntax of programs. Let us de.ne the syntax of \na basic pro\u00adgramming language manipulating heaps and data; more complex constructs can be de.ned by combining \nthese statements appro\u00adpriately. Let Var be a countable set of pointer variables, F be a countable set \nof structural pointer .elds,and data be a data .eld. A condition is de.ned as follows: (for technical \nreasons, negations are pushed all the way in): 1 k 1 k . . Cond ::= .(q.data,..., q.data) |\u00ac.(q.data,..., \nq.data) | p == q | p = q | p == nil | p = nil| .1 . .2 | .1 . .2 where p, q, q1 ,..., qk . Var,and . \nis a predicate over data values. The set of statements Stmt de.ned over Var, F ,and data is de\u00ad.ned as \nfollows: s . Stmt ::= p := new | free(p) | assume(.) | p := nil |p := q | p.f := q | p := q.f | p.data \n:= h(q1 .data,..., qk .data) where p, q, q1 ,..., qk . Var, f . F , h is a function over data, and . \nis a condition. A program P over Var, F ,and data is a non empty .nite sequence of statements s1; s2; \n... ; sm, with si . Stmt. The semantics of a program is the natural one and we skip its de.nition. Let \nR be a recursive data-structure, Pre, Post betwo STRAND.,. formulas, and P ::= s1; s2; ... ; sm be a \nprogram. The con.gura\u00adtion of the program at any point is given by a heap modeled as a graph, where nodes \nof the graph are assigned data values. For a program with m statements, let us .x the con.gurations to \nbe G0,...,Gm. The trail. The idea is to capture the entire computation starting from a particular data-structure \nusing a single data-structure. The main intuition is that if we run P over a graph G0 . Graph(R) then \na new class of recursive data-structures RP will de.ne a graph Gtrail which encodes in it G0, aswellasall \nthe graphs Gi,for every i . [m]. Gtrail has the nodes of G0 plus m other fresh nodes (these nodes will \nbe used to model newly created nodes P creates as well as to hold new data-values of variables that are \nassigned to in P ). Each of these new nodes are pointed by a distinguished pointer variable newi. Initially, \nthese additional nodes are all inactive in G0. We build an MSO-de.ned unary predicate activei that captures \nat each step i the precise set of active nodes in the heap. To capture the pointer variables at each \nstep of the execution, we de.ne a new unary predicate pi, for each p . Var and i . [0,m]. Similarly, \nwe create MSO-de.ned binary predicates fi for each f . F and i . [0,m], to capture structural pointer \n.elds at step i. The heap Gi at step i is hence the graph consisting of all the nodes x of Gtrail such \nthat activei(x) holds true, and the pointers and edges of Gi are de.ned by pi and fi predicates, respectively. \nFormally, .x a recursively de.ned data-structure R = (.Tr ,.U , {ap}p.Var , {\u00dff }f.F ), with a monadic \npredicate axnil, which evaluates to a unique NIL node in the data-structure. Then its trail with respect \nto the program P is de.ned as RP = (. ' U , {a ' Tr ,. ' p}p.Var. , {\u00dff ' }f.F . ) where: . ' Tr is designed \nto hold on all trees in which the .rst subtree of the root satis.es .Tr and the second child of the root \nhas a chain of m - 1 nodes where each of them is the second child of the parent. . ' U holds true on \nthe root, on all the second child descendent of the root, and on all .rst child descendent on which .U \nholds true. Var ' = {newi|i . [m]}.{pi|p . Var,i . [0,m]},and -(1) a ' holds only on the root, and a \n' holds true only on new1 newi the i +1 th descendent of the second child of the root, for every i . \n[m - 1]. -(2) for every p . Var and i . [m], a ' = ap and a ' is de.ned as in Figure 2. p0 pi F ' = {fi|f \n. F, i . [0,m]}, and for every f . F and i . [m], \u00df ' = \u00dff and \u00df ' is de.ned as in Figure 2. f0 fi In \nFigure 2, the MSO formulas a ' and \u00df ' are derived in the pi fi natural way from the semantics of the \nstatements, except for the statement p.data := h(q1 .data,..., qk .data). Although the se\u00admantics for \nthis statement does not involve any structural modi.\u00adcation of the graph (it changes only the data value \nassociated p), we represent this operation by making a new version of the node pointed by p in order \nto represent explicitly the change for the data value corresponding to that node. We deactivate the node \npointed by pi-1 and activate the dormant node pointed by newi. All the edges in the graph and the pointers \nare rearranged to re.ect this exchange of nodes. In Figure 2, we also de.ne two more MSO formulas, activei \nand errori, which are not part of the trail, where the .rst models the active nodes at step i, and the \nsecond expresses when an error occurs due to the dereferencing of a variable pointing to xnil, respectively. \nHandling data constraints. The trail RP captures all the struc\u00adtural modi.cations made to the graph during \nthe execution P . However, data constrains entailed by assume statements and data\u00adassignments cannot \nbe expressed in the trail as they are not express\u00adible in MSO. We impose them in the STRAND formula. \nWe de.ne aformula .i for each statement index i . [m],where if si is not an assume or a data-assignment \nstatement, then .i = true.Other\u00adwise, there are two cases: Handling assume assignments. If si is the \nstatement assume(.), then .i is the STRAND formula obtained by adapting the constraint . to the i th \nstage of the trail. This is not hard, but is tedious, and we skip its de.nition. Constraints on data-variables \nasserted in the formula using data-logic constraints. Handling data-assignments. The STRAND formula .i \nfor a data\u00ad assignment statement p.data := h(q1 .data,..., qk .data) is: .i := .ex, ex1,..., exk. pi(ex). \n^ ( qij -1(exj )) . data(ex)= h(data(ex1),..., data(exk)) i.[k] which translates si into STRAND making \nsure that it refers to the heap at step i-1. Adapting pre-and post-conditions to the trail. The last \ningredi\u00adent that we need is to express the STRAND.,. formulas Pre and the negation of the Post on the \ntrail RP . More speci.cally, we need to  [p := new ]: a. a. (x)= a. (x), (x)= a. (x), .q . Var \\{p}, \n\u00df. (x, y)=\u00df. (x, y), activei(x)= activei-1(x) . a. (x) pi newi qi qi-1 fi fi-1 newi errori = false [free(p) \n]: zi zi-1 xnili-1 pi-1 a(x)=(a(x) . (a(x) .\u00aca(x))) . (axnili-1 (x) .\u00acazi-1 (x)) \u00df(x, y)=(\u00df(x, y) .\u00aca(x)) \nfi fi-1 pi-1 xnili-1 fi-1 pi-1 . (a(y) ..ex. (\u00df(x, ex) . a(ex))) activei(x)= activei-1(x) .\u00acapi-1 (x) \nerrori = .x.(a(x) . a(x)) pi-1 xnili-1 [p := nil ]: a= a(x),a(x)= a(x), .z . Var \\{p} pi(x) xnili-1 \nzi zi-1 \u00df(x, y)= \u00df(x, y), activei(x)=activei-1(x), errori=false fi fi-1 [p := q ]: a(x)= a(x),a(x)= a(x), \n.z . (Var \\{p}) pi qi-1 zi zi-1 \u00df(x, y)= \u00df(x, y), activei(x)=activei-1(x), errori=false fi fi-1 [p.f \n:= q ]: a(x)= a(x), .z . Var zi zi-1 \u00df(x, y)=(\u00aca(x) . \u00df(x, y)) . (api-1(x) . a(y)) fi pi-1 fi-1 qi-1 \na(x, y)= a(x, y), .g . (F \\{f}) gi gi-1 activei(x)=activei-1(x), errori=.x.(a(x) . a(x)) pi-1 xnili-1 \n[p := q.f ]: a= .ex. (a(ex) . \u00df(ex, x)) pi(x) qi-1 fi-1 a(x)= a(x), .q . (Var \\{p}) qi qi-1 \u00df. (x, y)= \n\u00df. (x, y) fi fi-1 a(x, y)= a(x, y), .g . (F \\{f}) gi gi-1 qi-1 xnili-1 activei(x)= activei-1(x), errori=.x. \n(a(x) . a(x)) [assume(.) ]: a(x)= a(x), .q . Var,\u00df(x, y)= \u00df(x, y), .f . F qi qi-1 fi fi-1 activei(x)= \nactivei-1(x), errori=.x. _(a(x) . a(x)) pi-1 xnili-1 p.Var. where Var. is the set of all variables occurring \nin .. [p.data := h(q1 .data,..., qk .data) ]: a(x)= a(x),a(x)= a(x), .q . Var \\{p} pi newi qi qi-1 \u00df(x, \ny)=(\u00df(x, y) .\u00aca(x)) fi fi-1 pi-1 .(anewi (y) ..ex. (\u00df(x, ex) . a(ex))) fi-1 pi-1 activei(x)=(activei-1(x) \n.\u00acpi-1(x)) . anewi (x) errori = .x.( _ (a(x) . a(x)) ) zi-1 xnili-1 z .{p,q,...,qk} 1 Figure 2. Predicates \nde.ning the new data-structure. adapt Pre to the trail for index 0, which corresponds to the original \ngraph, i.e. the predicates p are replaced with p0,for every p . Var, and the edge predicates f with f0,for \nevery f . F . Moreover, when\u00adever we refer to a node in the graph we need to be sure that node is active \nwhich can be done by using the predicate active0(x) which holds true if x is in the .rst subtree of the \nroot and . ' U (x) holds. A similar transformation is done for the formula \u00acPost, where now we consider \npointers, edge labels, and active nodes at the last step m.Let PreRP (resp., PostRP )be the STRAND formula \ncorre\u00adsponding to the adaptation of Pre (resp., Post) Reduction to satis.ability problem on the trail. \nIt is easy to see that an error occurs during the execution of P on a graph de.ned through R that satis.es \nPre if the following STRAND formula is satis.able on the trail RP : WV Error =(PreRP . .j . errori) i.[m]j.[i-1] \nSimilarly, the Hoare-triple is not valid iff the following STRAND formula is satis.able on the trail: \nV ViolatePost = PreRP . ( .j ) .\u00acPostRP j.[m] THEOREM 6.1. Let P be a program, R be a recursive data\u00adstructure, \nand Pre, Post be two STRAND.,. formulas over Var, F , and data. Then, there is a graph G . Graph(R) that \nsat\u00adis.es Pre and where either P terminates with an error or the obtained graph G ' does not satisfy \nPost iff the STRAND formula Error . ViolatePost is satis.able on the trail RP .  7. Evaluation 7.1 \nImplementation In this section, we demonstrate the effectiveness and practical\u00adity of the decision procedures \nfor STRAND by checking veri.ca\u00adtion conditions generated in proving properties of several heap\u00admanipulating \nprograms. Given pre-conditions, post-conditions and loop-invariants, each linear block of statements \nof a program yields a Hoare-triple, which is manually translated into a STRAND for\u00admula . over trees \nand integer arithmetic, as a veri.cation condi\u00adtion. The decision procedure for STRAND implements the \ndeci\u00adsion procedure for the semantically de.ned fragment STRANDsem dec . Given a STRAND formula, our \nprocedure will .rst determine if it is in the semantic decidable fragment, and if not, will halt and \nreport that satis.ability of the formula is not checkable. When given a formula in the syntactic fragment \nSTRANDdec, this procedure will always succeed, and the decision procedure will determine satis.\u00adability \nof the formula. The decision procedure consists of a structural phase, where we determine whether the \nnumber of minimal models is .nite, and if so, determine a bound on the size of the minimal models. This \nphase is effected by using MONA [13], a monadic second-order logic solver over (strings and) trees. In \nthe second data-constraint solving phase, the .nite set of minimal models, if any, are examined by the \ndata-solver Z3 [9] to check if they can be extended with data-values to satisfy the formula. Instead \nof building an automaton representing the minimal models and then checking it for .niteness, we check \nthe .nite\u00adness formula MinModel. using WS2S, supported by MONA, which is a monadic second-order logic \nover in.nite trees with set\u00adquanti.cation restricted to .nite sets. By quantifying over a .nite universe \nU, and transforming all quanti.cations to be interpreted over U, we can interpret MinModel. over all \n.nite trees. Let us denote this emulation as MinModel ' . The .niteness condition U,. can now be checked \nby asking if there exists a .nite set B such that any minimal model for . is contained within the nodes \nof B: U,. . (U . Bound)) . Bound .U .Qa(a.S) (MinModel ' This formula has no free-variables, and hence \neither holds on the in.nite tree or not, and can be checked by MONA. This formula evaluates to true iff \nthe formula is in STRANDsem dec . We also follow a slightly different procedure to synthesize the data-logic \nformula. Instead of extracting each minimal model, and  Structural solving (MONA) Data-constraint Solving \n(Z3 with QF-LIA) Veri.cation in STRANDsem ? Final Graph Formula Program dec Bound condition (.nitely-many \n#States BDD Time(s) model size Satis.able? Time(s) (#Nodes) minimal models) size exists? (KB) sorted\u00adlist-search \nbefore-loop in-loop after-loop Yes Yes Yes 67 131 67 264 585 264 0.34 0.59 0.18 No No No --- --- --- \n--- before-head Yes 73 298 1.66 Yes 5 6.2 No 0.02 sorted\u00ad before-loop Yes 259 1290 0.38 No - - - - list-insert \nin-loop Yes 1027 6156 4.46 No - - - - after-loop Yes 146 680 13.93 Yes 7 14.5 No 0.02 sorted-list\u00adinsert-error \nbefore-loop Yes 298 1519 0.34 Yes 7 9.5 Yes 0.02 sorted\u00adlist-reverse before-loop in-loop after-loop Yes \nYes Yes 35 513 129 119 2816 576 0.24 2.79 0.35 No No No --- --- --- --- bubblesort loop-if-if loop-if-else \nloop-else Yes Yes Yes 2049 1025 1033 13312 6144 6204 7.70 6.83 2.73 No No Yes --8 --22.2 --No --0.02 \nbst-search before-loop in-loop after-loop Yes Yes Yes 52 160 52 276 1132 276 5.03 32.80 3.27 No Yes No \n-9 - -7.7 - -No - -0.02 - bst-insert before-loop in-loop after-loop Yes Yes Yes 36 68 20 196 452 84 1.34 \n9.84 1.76 No No No --- --- --- --- left/right-rotate bst-preserving Yes 29 117 1.59 Yes 19 70.3 No 0.05 \n Figure 3. Results of program veri.cation checking if there is a data-extension for it, we obtain a bound \non the size of minimal models, and ask the data-solver to check for any model within that bound. This \nis often a much simpler formula to feed to the data-solver. In our current implementation, the MONA constraints \nare en\u00adcoded manually, and once the bound is obtained, we write a pro\u00adgram that outputs the Z3 constraints \nfor the veri.cation condition and the bound. The translation from STRAND to MONA formulas and the translation \nfrom STRAND formulas to Z3 formulas for any bound can be automated, and is a plan for the future.  7.2 \nExperiments Figure 3 presents the evaluation of our tools on checking a set of programs that manipulate \nsorted singly-linked lists and binary search trees. Note that the binary search trees presented here \nare out of the scope of the logics HAVOC [16] and CSL [7]. The programs sorted-list-search and sorted-list\u00adinsert \nsearch and insert a node in a sorted singly-linked list, respectively, while sorted-list-insert-error \nis the inser\u00adtion program with an intended error. The program sorted-list -reverse is a routine for in-place \nreversal of a sorted singly\u00adlinked list, which results in a reverse-sorted list, and bubblesort is the \ncode for Bubble-sort of a list. The routines bst-search and bst-insert search and insert a node in a \nbinary search tree, re\u00adspectively, while the programs left-rotate and right-rotate perform rotations \n(for balancing) in a binary search tree. For all these examples, a set of partial correctness properties \nincluding both structural and data requirements is checked. For example, assuming a node with value k \nexists, we check if both sorted-list-search and bst-search return a node with value k.For sorted-list-insert, \nwe assume that the inserted value does not exist, and check if the resulting list contains the inserted \nnode, and the sortedness property continues to hold. In the pro\u00adgram bst-insert, assuming the tree does \nnot contain the inserted node in the beginning, we check whether the .nal tree contains the inserted \nnode, and the binary-search-tree property continues to hold. In sorted-list-reverse, we check if the \noutput list is a valid list that is reverse-sorted. The code for bubblesort is checked to see if it results \nin a sorted list. And the left-rotate and right-rotate codes are checked to see whether they main\u00adtain \nthe property that maintain the binary search-tree property. Note that each program requires checking \nseveral veri.cation conditions (typically for the linear block from the beginning of the program to a \nloop, for the loop invariant linear block, and for the block from the loop invariant to the end of the \nprogram). The experiments were conducted on a 2.2GHz, 4GB machine running Windows 7, and the formulas \nand results are available at http://www.cs.uiuc.edu/~qiu2/strand. For the structural solving phase, we \nreport .rst whether the ver\u00adi.cation condition falls within our semantic decidable fragment STRANDsem \ndec . In fact, it turns out that all of our veri.cation con\u00additions can be written entirely in the syntactic \ndecidable fragment STRANDdec! We also report the number of states, the BDD sizes to represent automata, \nand the time taken by MONA to compute the minimal models. We report whether there were any models found; \nnote that if the formula is unsatis.able and there are no models, the Z3 phase isskipped (these are denoted \nby - annotations in the table for Z3). For the data-constraint solving phase, we .rst report the number \nof nodes of the tree (or string) that is an upper bound for all minimal models. The Z3 formulas are typically \nlarge (but simple) as one can see from the size of the formulas in the table. We report whether Z3 found \nthe formula tobe satis.able or not (all cases were unsatis.able, except sorted-list-insert-error, as \nthe Hoare\u00adtriples veri.ed were correct), and the time it took to determine this. The experimental results \nshow that natural veri.cation condi\u00adtions tend to be expressible in the syntactic decidable fragment \nSTRANDdec. Moreover, the expressiveness of our logic allows us to write complex conditions involving \nstructure and data, and yet are handled well by MONA and Z3. We believe that a full-.edged engineering \nof an SMT solver for STRANDsem dec that answers queries involving heap structures and data is a promising \nfuture direction. Towards this end, an ef.cient non-automata theoretic decision pro\u00adcedure (unlike MONA) \nthat uses search techniques (like SAT) in\u00adstead of representing the class of all models (like BDDs and \nau\u00adtomata) may yield more ef.cient decision procedures.   8. Related Work We .rst discuss related work \nthat can reason with combinations of heaps and data. In handling heaps, .rst-order theories that can \nrea\u00adson with restricted forms of the reachability relation for ensuring decidability are the most common. \nThe work most closely related to our work is the logic in HAVOC, called LISBQ [16], that offers a reasoning \nwith generic heaps combined with an arbitrary data\u00adlogic. The logic has restricted reachability predicates \nand universal quanti.cation, but is syntactically severely curtailed, to obtain de\u00adcidability. We .nd \nthe restrictions on the syntax quite awkward, with sort-based restrictions in the logic. Furthermore, \nthe logic cannot handle even simple constraints over trees with unbounded depth where the nodes are of \nthe same sort (like a tree being a bi\u00adnary search tree). However, the logic is extremely ef.cient, as \nit uses no structural solver, but translates the structure-solving also to (the Boolean aspect of) the \nSMT solver. We gained a lot of insight into decidability by studying the expressive power of HAVOC,and \nwe believe that STRAND generalizes some of the underlying ideas present in HAVOC to a much more powerful \ntechnique for decid\u00adability.Thelogic CSL[7]hasasimilar.avoras HAVOC,withsim\u00adilar sort-restrictions on \nthe syntax, but generalizes to handle doubly linked lists, and allows size constraints on structures. \nThe work re\u00adported in [5] gives a logic that extends an LTL-like syntax to de.ne certain decidable logic \nfragments on heaps. Rakamari\u00b4c et al [23] propose an inference rule system for rea\u00adsoning with restricted \nreachability (but this logic does not have uni\u00adversal quanti.cation and cannot express disjointness constraints), \nand an SMT solver based implementation has been reported [24]. Restricted forms of reachability were \n.rst axiomatized in early work by Nelson [21]. Several mechanisms without quanti.cation exist, including \nthe work reported in [1, 25]. Automatic decision procedures that approximate higher-order logic using \n.rst-order logic, using approximate logics over sets and their cardinalities, have been proposed [15]. \nThere is a rich literature on heap analysis without data. Since .rst-order logic over graphs is undecidable, \ndecidable logics must either restrict the logic or the class of graphs. The closest work to ours in this \nrealm is PALE [20], which restricts structures to be de\u00ad.nable over tree-skeletons, similar to STRAND, \nand reduces prob\u00adlems to the MONA system [13]. Several approximations of .rst\u00adorder axiomatizations of \nreachability have been proposed: axioms capturing local properties [19], a logic on regular patterns \nthat is decidable [28], among others. Finally, separation logic [26] has emerged as a convenient logic \nto express heap properties of programs, and a decidable fragment (without data) on lists is known [4]. \nHowever, not many extensions of separation logics handle data constraints (see [18] which com\u00adbines this \nlogic for linked lists with arithmetic). Acknowledgments We thank Christof L\u00a8oding for the fruitful discussions \nwe had when we started this project a few years back. This work is partially funded by NSF CAREER award \n#0747041 and French ANR-09-SEGI project Veridyc.  References [1] I. Balaban, A. Pnueli, and L. D. Zuck. \nShape analysis by predicate abstraction. In VMCAI 05, volume 3385 of LNCS, pages 164 180. Springer, 2005. \n[2] T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani. Automatic predicate abstraction of C programs. \nIn PLDI 01, pages 203 213. ACM, 2001. [3] M. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs, and K. R. \nM. Leino. Boogie: A modular reusable veri.er for object-oriented programs. In FMCO 05, volume 4111 of \nLNCS, pages 364 387. Springer, 2005. [4] J. Berdine, C. Calcagno, and P. W. O Hearn. A decidable fragment \nof separation logic. In FSTTCS 04, volume 3328 of LNCS, pages 97 109. Springer, 2004. [5] N. Bj\u00f8rner \nand J. Hendrix. Linear functional .xed-points. In CAV 09, volume 5643 of LNCS, pages 124 139. Springer, \n2009. [6] E. B\u00a8orger, E. Gr\u00a8adel, and Y. Gurevich. The Classical Decision Prob\u00adlem. Springer, 2001. [7] \nA. Bouajjani, C. Dragoi, C. Enea, and M. Sighireanu. A logic\u00adbased framework for reasoning about composite \ndata structures. In CONCUR 09, volume 5710 of LNCS, pages 178 195. Springer, 2009. [8] L. M. de Moura \nand N. Bj\u00f8rner. Deciding effectively propositional logic using DPLL and substitution sets. In IJCAR 08, \nvolume 5195 of LNCS, pages 410 425. Springer, 2008. [9] L. M. de Moura and N. Bj\u00f8rner. Z3: An ef.cient \nSMT solver. In TACAS 08, volume 4963 of LNCS, pages 337 340. Springer, 2008. [10] J. Engelfriet. Context-free \ngraph grammars. In Handbook of Formal Languages, volume 3, pages 125 214. Springer, 1997. [11] C. Flanagan, \nK. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. \nIn PLDI 02, pages 234 245. ACM, 2002. [12] P. Godefroid, N. Klarlund, and K. Sen. DART: directed automated \nrandom testing. In PLDI 05, pages 213 223. ACM, 2005. [13] N. Klarlund and A. M\u00f8ller. MONA. BRICS, Department \nof Com\u00adputer Science, Aarhus University, January 2001. Available from http://www.brics.dk/mona/. [14] \nN. Klarlund and M. I. Schwartzbach. Graph types. In POPL 93, pages 196 205. ACM, 1993. [15] V. Kuncak. \nModular Data Structure Veri.cation. PhD thesis, Mas\u00adsachusetts Institute of Technology, 2007. [16] S. \nLahiri and S. Qadeer. Back to the future: revisiting precise program veri.cation using SMT solvers. In \nPOPL 08, pages 171 182. ACM, 2008. [17] T. Lev-Ami and S. Sagiv. Tvla: A system for implementing static \nanalyses. In SAS 00, volume 1824 of LNCS, pages 280 301. Springer, 2000. [18] S. Magill, M.-H. Tsai, \nP. Lee, and Y.-K. Tsay. THOR: A tool for reasoning about shape and arithmetic. In CAV 08, volume 5123 \nof LNCS, pages 428 432. Springer, 2008. [19] S. McPeak and G. C. Necula. Data structure speci.cations \nvia local equality axioms. In CAV 05, volume 3576 of LNCS, pages 476 490. Springer, 2005. [20] A. M\u00f8ller \nand M. I. Schwartzbach. The pointer assertion logic engine. In PLDI 01, pages 221 231. ACM, 2001. [21] \nG. Nelson. Verifying reachability invariants of linked structures. In POPL 83, pages 38 47. ACM, 1983. \n[22] G. Nelson and D. C. Oppen. Simpli.cation by cooperating decision procedures. ACM Trans. Program. \nLang. Syst., 1:245 257, 1979. [23] Z. Rakamari\u00b4c, J. D. Bingham, and A. J. Hu. An inference-rule-based \ndecision procedure for veri.cation of heap-manipulating programs with mutable data and cyclic data structures. \nIn VMCAI 07, volume 4349 of LNCS, pages 106 121. Springer, 2007. [24] Z. Rakamari\u00b4c, R. Bruttomesso, \nA. J. Hu, and A. Cimatti. Verifying heap-manipulating programs in an SMT framework. In ATVA 07, volume \n4762 of LNCS, pages 237 252. Springer, 2007. [25] S. Ranise and C. Zarba. A theory of singly-linked lists \nand its ex\u00adtensible decision procedure. In SEFM 06, pages 206 215. IEEE-CS, 2006. [26] J. Reynolds. Separation \nlogic: a logic for shared mutable data struc\u00adtures. In LICS 02, pages 55 74. IEEE-CS, 2002. [27] G. Yorsh, \nT. W. Reps, and S. Sagiv. Symbolically computing most\u00adprecise abstract operations for shape analysis. \nIn TACAS 04, volume 2988 of LNCS, pages 530 545. Springer, 2004. [28] G. Yorsh, A. M. Rabinovich, M. \nSagiv, A. Meyer, and A. Bouajjani. A logic of reachable patterns in linked data-structures. In FoSSaCS \n06, volume 3921 of LNCS, pages 94 110. Springer, 2006.  \n\t\t\t", "proc_id": "1926385", "abstract": "<p>We define a new logic, STRAND, that allows reasoning with heap-manipulating programs using deductive verification and SMT solvers. STRAND logic (\"STRucture ANd Data\" logic) formulas express constraints involving heap structures and the data they contain; they are defined over a class of pointer-structures <i>R</i> defined using MSO-defined relations over trees, and are of the form &#8707;&#8594;<i>x</i>&#8704;&#8594;<i>y</i> (&#8594;<i>x</i>,&#8594;) <i>x</i>\" , where \"&#966;\" is a monadic second-order logic (MSO) formulawith additional quantification that combines structural constraints as well as data-constraints, but where the data-constraints are only allowed to refer to \"&#8594;<i>x</i>\" and \"&#8594;<i>y</i>\"</p> <p>The salient aspects of the logic are: (a) the logic is powerful, allowing existential and universal quantification over the nodes, and complex combinations of data and structural constraints; (b) checking Hoare-triples for linear blocks of statements with pre-conditions and post-conditions expressed as Boolean combinations of existential and universal STRAND formulas reduces to satisfiability of a STRAND formula; (c) there are powerful decidable fragments of STRAND, one semantically defined and one syntactically defined, where the decision procedure works by combining the theory of MSO over trees and the quantifier-free theory of the underlying data-logic. We demonstrate the effectiveness and practicality of the logic by checking verification conditions generated in proving properties of several heap-manipulating programs, using a tool that combines an MSO decision procedure over trees (MONA) with an SMT solver for integer constraints (Z3).</p>", "authors": [{"name": "P. Madhusudan", "author_profile_id": "81100489757", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P2509708", "email_address": "madhu@illinois.edu", "orcid_id": ""}, {"name": "Gennaro Parlato", "author_profile_id": "81332520215", "affiliation": "LIAFA, CNRS and University of Paris Diderot, Paris, IL, USA", "person_id": "P2509709", "email_address": "gennaro@liafa.jussieu.fr", "orcid_id": ""}, {"name": "Xiaokang Qiu", "author_profile_id": "81421595944", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL, USA", "person_id": "P2509710", "email_address": "qiu2@illinois.edu", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926455", "year": "2011", "article_id": "1926455", "conference": "POPL", "title": "Decidable logics combining heap structures and data", "url": "http://dl.acm.org/citation.cfm?id=1926455"}