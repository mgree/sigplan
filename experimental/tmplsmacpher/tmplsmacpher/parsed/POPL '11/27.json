{"article_publication_date": "01-26-2011", "fulltext": "\n Predicate Abstraction and Re.nement for Verifying Multi-Threaded Programs Ashutosh Gupta Corneliu Popeea \nAndrey Rybalchenko Institut f\u00a8at M\u00a8 ur Informatik, Technische Universit\u00a8unchen Germany {guptaa,popeea,rybal}@in.tum.de \nAbstract Automated veri.cation of multi-threaded programs requires ex\u00adplicit identi.cation of the interplay \nbetween interacting threads, so\u00adcalled environment transitions, to enable scalable, compositional reasoning. \nOnce the environment transitions are identi.ed, we can prove program properties by considering each program \nthread in isolation, as the environment transitions keep track of the interleav\u00ading with other threads. \nFinding adequate environment transitions that are suf.ciently precise to yield conclusive results and \nyet do not overwhelm the veri.er with unnecessary details about the in\u00adterleaving with other threads \nis a major challenge. In this paper we propose a method for safety veri.cation of multi-threaded pro\u00adgrams \nthat applies (transition) predicate abstraction-based discov\u00adery of environment transitions, exposing \na minimal amount of in\u00adformation about the thread interleaving. The crux of our method is an abstraction \nre.nement procedure that uses recursion-free Horn clauses to declaratively state abstraction re.nement \nqueries. Then, the queries are resolved by a corresponding constraint solving al\u00adgorithm. We present \npreliminary experimental results for mutual exclusion protocols and multi-threaded device drivers. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and \nMeanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General Terms Algorithms, \nLanguages, Reliability, Veri.cation. Keywords Multi-threaded programs, safety, proof rule, modular reasoning, \nenvironment transitions, (transition) predicate abstrac\u00adtion, abstraction re.nement, Horn clauses. 1. \nIntroduction The ubiquitous availability of parallel computing infrastructures fa\u00adcilitated by the advent \nof multicore architectures requires a shift towards multi-threaded programming to take full advantage \nof the available computing resources. Writing correct multi-threaded soft\u00adware is a dif.cult task, as \nthe programmer needs to keep track of a very large number of possible interactions between the pro\u00adgram \nthreads. Automated program analysis and veri.cation tools Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, USA. \nCopyright c &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 can support programmer in dealing \nwith this challenge by system\u00adatically and exhaustively exploring program behaviours and check\u00ading their \ncorrectness. Direct treatment of all possible thread interleavings by reason\u00ading about the program globally \nis a prohibitively expensive task, even for small programs. By applying rely-guarantee techniques, see \ne.g. [17, 26], such global reasoning can be avoided by consid\u00adering each program thread in isolation, \nusing environment transi\u00adtions to summarize the effect of executing other threads, and ap\u00adplying them \non the thread at hand. The success of such an ap\u00adproach depends on the ability to automatically discover \nenviron\u00adment transitions that are precise enough to deliver a conclusive analysis/veri.cation outcome, \nand yet do not keep track of unnec\u00adessary details in order to avoid sub-optimal ef.ciency. In this paper \nwe present a method that automates rely-guarantee reasoning for verifying safety of multi-threaded programs. \nOur method relies on an automated discovery of environment transi\u00adtions using (transition) predicate \nabstraction [12, 28]. It performs a predicate abstraction-based reachability computation for each thread \nand interleaves it with the construction of environment tran\u00adsitions that over-approximate the effect \nof executing thread transi\u00adtions using transition predicates. The success of our method cru\u00adcially depends \non an abstraction re.nement procedure that discov\u00aders (transition) predicates. The re.nement procedure \nattempts to minimize the amount of details that are exposed by the environ\u00adment transitions, in order \nto avoid unnecessary details about thread interaction. The crux of our re.nement approach is in using \na declarative formulation of the abstraction re.nement algorithm that can deal with the thread reachability, \nenvironment transitions, and their mu\u00adtual dependencies. We use Horn clauses to describe constraints \non the desired (transition) predicates, and solve these constraints us\u00ading a general algorithm for recursion-free \nHorn clauses. Our for\u00admalization can accommodate additional requirements that express the preference \nfor modular predicates that do not refer to the local variables of environment threads, together with \nthe preference for modular transition predicates that only deal with global variables and their primed \nversions. We implemented the proposed method in a veri.cation tool for multi-threaded programs and applied \nit on a range of bench\u00admarks, which includes fragments of open source software, ticket\u00adbased mutual exclusion \nprotocols, and multi-threaded Linux device drivers. The results of the experimental evaluation indicate \nthat our declarative abstraction re.nement approach can be effective in .nd\u00ading adequate environment \ntransitions for the veri.cation of multi\u00adthreaded programs. This paper makes the following contributions: \n 1. the automatic, rely-guarantee based method for verifying multi\u00adthreaded programs using (transition) \npredicate abstraction; 2. the novel formulation of abstraction re.nement schemes using Horn clauses, \nand its application for the (transition) abstraction discovery for multi-threaded programs; 3. the algorithm \nfor solving recursion-free Horn clauses over lin\u00adear arithmetic constraints; 4. the prototype implementation \nand its evaluation.  The rest of the paper is organized as follows. First, we illustrate our method \nin Section 2. In Section 3 we present necessary def\u00adinitions. Section 4 presents a proof rule that provides \na basis for our method, and shows how the proof rule can be automated using the connection to .xpoints \nand abstraction techniques. We present the main algorithm in Section 5. Section 6 focuses on the abstrac\u00adtion \nre.nement using Horn clauses, while Section 7 presents a con\u00adstraint solving algorithm for Horn clauses \nover linear inequalities. We discuss the experimental evaluation in Section 8. Related work is presented \nin Section 9. 2. Illustration In this section we illustrate our algorithm using two multi-threaded examples. \nThe .rst example does not have a modular proof, hence our algorithm reasons about relationship between \nthe local vari\u00adables of different threads. For the second example, our algorithm succeeds in .nding a \nmodular proof by applying an abstraction re\u00ad.nement procedure that guarantees the discovery of a modular \nab\u00adstraction whenever it exists. 2.1 Example LockBit See Figure 1 for the program LockBit that consists \nof two threads. The threads attempt to access a critical section, and synchronize their accesses using \na global variable lock . We assume that ini\u00adtially the lock is not taken, i.e., lock =0 , and that the \nlocking statement take_lock waits until the lock is released and then as\u00adsigns the value of its second \nparameter to lock , thus taking the lock. We write V =(lock, pc1 , pc2 ) for the program variables, where \npc1 and pc2 are local program counter variables of the .rst and second thread, respectively. We start \nby representing the program using assertions .init and .err over program variables that describe the \ninitial and error states of the program, together with assertions over unprimed and primed program variables \n.1 and .2 that describe the transition relations for program statements. .init =(pc1 = a . pc2 = p . \nlock = 0) , .err =(pc1 = b . pc2 = q) , ' .1 =(lock =0 . lock' =1 . pc1 = a . pc1 = b . .2= ) , . =1 \n=(pc1 = pc1 ') , ' .2 =(lock =0 . lock' =1 . pc2 = p . pc2= q . . =1 ) , . = ' 2 =(pc2 = pc2) . The auxiliary \nassertions . =1 and . =2 state that the local variable of the .rst and second thread, respectively, is \npreserved during the transition. To verify LockBit, our algorithm computes a sequence of ARETs (Abstract \nReachability and Environment Trees). Each tree computation amounts to a combination of i) a standard \nabstract reachability computation that is performed for each thread and is called thread reachability, \nand ii) a construction and application of environment transitions. Abstract states represent sets of \n(concrete) program states, while environment transitions are binary relations of program states. // Thread \n1 // Thread 2 a: take_lock(lock, 1); p: take_lock(lock, 1); b: // critical q: // critical Figure 1. \nExample program LockBit. Each thread waits until the lock is released, and then assigns the integer 1 \nto lock . .1 .2  .1 .2 e2 e1  (a) (b)   . 1 e1 e2 .2 (c)  Figure 2. Reachability trees constructed \nusing different abstrac\u00adtion functions. Edges are labeled with a transition. Nodes with gray background \nrepresent (spurious) error tuples: (m2,n2) from (a) and (m3,n3) from (b). No pair of states from (c) \nintersects .err . First ARET computation The thread reachability computation for the .rst thread starts \nby computing an abstraction of the initial program states .init . Here, we use an abstraction function \na.1 , where the dot indicates that this function over-approximates sets of program states (and not sets \nof pairs of states, as will take place later) and the index 1 indicates that this abstraction function \nis used for the .rst thread. In this example, we assume that the abstraction function only tracks the \nvalue of the program counter of the .rst thread, i.e., P.1 = pc1 = a, pc1 = b} , and is computed as { \n . follows: a.1(S)= {p..P1 |.V : S . p.} . We obtain the initial abstract state m1 as follows: m1 = a.1(.init \n)=(pc1 = a) . Next, we compute an abstract successor of m1 with respect to the transition .1 using the \nstrongest postcondition operator post that is combined with a.1: m2 = a.1(post(.1,m1)) = (pc1 = b) . \nSimilarly, we compute the thread reachability for the second thread. Using predicates over the program \ncounter of the second . thread, i.e., P2 = {pc2 = p, pc2 = q} , we compute the following two abstract \nstates: n1 = a.2(.init ) =(pc2 = p) , n2 = a.2(post(.2,n1)) = (pc2 = q) . For each thread, we organize \nthe computed abstract states in a tree, see Figure 2(a). We stop the ARET computation since we discover \nthat the error states overlap with the intersection of the abstract state m2 from the thread reachability \nof the .rst thread and n2 from the second thread, i.e., m2 . n2 . .err is satis.able.  First abstraction \nre.nement We treat the pair m2 and n2 as a possible evidence that the error states of the program can \nbe reached. Yet, we cannot assert that the program is incorrect, since abstraction was involved when \ncomputing m2 and n2 . We check if the discovered evidence is spurious by formulat\u00ading a constraint that \nis satis.able if and only if the abstraction can be re.ned to exclude the spuriousness. For each abstract \nstate in\u00advolved in the reachability of and including m2 and n2 we create an unknown predicate that denotes \na set of program states. We obtain m1 (V ), n1 (V ), m2 (V ), and n2 (V ) , which correspond to m1, n1, \nm2, and n2, respectively. Then, we record the relation between the unknown predicates using constraints \nin the form of Horn clauses. For example, since m1 was an abstraction of the ini\u00adtial program states, \nwe require that m1 (V ) over-approximates .init as well, and represent this requirement by a Horn clause \n.init . m1 (V ) . As a result, we obtain the following set of clauses. HC1 = {.init . m1 (V ), m1 (V \n) . .1 . m2 (V ' ), .init . n1 (V ), n1 (V ) . .2 . n2 (V ' ), m2 (V ) . n2 (V ) . .err . false} The \nlast clause in HC1 requires that the intersection of the re.ned versions of the abstract states m2 and \nn2 is disjoint from the error states of the program. We check if the conjunction of the clauses in HC1 \nis satis.able using a SAT-based algorithm presented in [13]. (Section 7 presents an algorithm for solving \nHorn clauses over linear inequalities.) We obtain the following satisfying assignment SOL that maps each \nunknown predicate to an assertion of the program variables. SOL( m1 (V )) = (pc2 = p) SOL( n1 (V )) = \n(pc1 = a) SOL( m2 (V )) = (pc2 = p) SOL( n2 (V )) = (pc1 = a) The existence of SOL indicates that the \ndiscovered evidence is spurious. We use SOL to re.ne the abstraction functions and hence eliminate the \nsource of spuriousness. We collect the predicates that appear in the solution for abstract states from \nthe .rst thread, add them to the sets of predicates P.1, and perform a similar step for the second thread. \nThe resulting sets of predicates are shown below. . P1 = {pc1 = a, pc1 = b, pc2 = p}. P2 = {pc2 = p, \npc2 = q, pc1 = a} They guarantee that the same spuriousness will not appear during subsequent ARET computations. \nSecond ARET computation We re-start the ARET computation using the previously discovered predicates. \nFigure 2(b) shows the two trees computed with the re.ned abstraction functions where m1 =(pc1 = a . pc2 \n= p) ,n1 =(pc1 = a . pc2 = p) , m2 =(pc1 = b . pc2 = p) ,n2 =(pc1 = a . pc2 = q) . Due to the .rst abstraction \nre.nement step, m2 . n2 . .err is unsatis.able. The thread reachability computation for each thread does \nnot discover any further abstract states. The ARET computation proceeds by considering interleaving of \nthe transitions from one thread with the transitions from the other thread. We account for thread interleaving \nby constructing and ap\u00adplying environment transitions. First, we construct an environment transition \ne1 that records the effect of applying .1 on m1 in the .rst thread on the thread reachability in the \nsecond thread. This ef\u00adfect is over-approximated by using an abstraction function a\u00a81.2. In this function, \nthe double dot indicates that the function abstracts binary relations over states (and not sets of states). \nThe index 1 c 2 indicates that this function is applied to abstract effect of the .rst thread on the \nsecond thread. Initially, we use the empty set of tran\u00ad \u00a8 sition predicates (over pairs of states) P1.2 \n= \u00d8 to de.ne a\u00a81.2. The environment transition e1 is de.ned as e1 = a\u00a81.2(m1 . .1)= true , and it non-deterministically \nupdates the program variables (since true does not impose any restrictions on the successor states of \nthe transition). Next, we add e1 to the transitions of the second thread. Then, its thread reachability \ncomputation uses e1 during the abstract successor computation, and creates an abstract state n3 by applying \ne1 on n2 as follows: n3 = a.2(post(e1 . .2= ,n2)) = (pc2 = q) . The conjunct . =2 ensures that the local \nvariable of the second thread is not changed by the environment transition. Symmetrically, we use a function \na\u00a82.1 to abstract the effect of applying transitions in the second thread on the thread reachability \nof the .rst thread. The application of .2 on n1 results in the environment transition e2 such that e2 \n= a\u00a82.1(n1 . .2)= true . We apply e2 to contribute an abstract successor m3 of the abstract state m2 \nto the thread reachability of the .rst thread: m3 = a.1(post(e2 . .1= ,m2)) = (pc1 = b) . We observe \nthat the intersection of the abstract states m3 and n3 contains a non-empty set of error states, i.e., \nm3 . n3 . .err is satis.able, thus delivering a possible evidence for incorrectness. Second abstraction \nre.nement Similarly to the .rst abstrac\u00adtion re.nement step, we construct a set of Horn clauses HC2 to \ncheck if the discovered evidence is spurious. We consider pred\u00adicates m1 (V ), n1 (V ), m2 (V ), n2 (V \n), m3 (V ), and n3 (V ) that represent unknown sets of program states, together with e1 (V,V ' ) and \ne2 (V, V ' ) that represent unknown binary relations over program states. HC2 = {.init . m1 (V ), m1 \n(V ) . .1 . m2 (V ' ), .init . n1 (V ), n1 (V ) . .2 . n2 (V ' ), m1 (V ) . .1 . e1 (V,V ' ), ) . . = \nn2 (V ) . e1 (V,V ' 2 . n3 (V ' ), n1 (V ) . .2 . e2 (V, V ' ), m2 (V ) . e2 (V, V ' ) . . =1 . m3 (V \n' ), m3 (V ) . n3 (V ) . .err . false} The conjunction of clauses in HC2 is satis.able. We obtain the \nfollowing satisfying assignment SOL. SOL( m1 (V )) = true SOL( m2 (V )) =(lock = 1) SOL( n1 (V )) = true \nSOL( n2 (V )) =(lock = 1) SOL( m3 (V )) = false SOL( e1 (V, V ' )) = (lock = 0) SOL( n3 (V )) = false \nSOL( e2 (V, V ' )) = (lock = 0) This solution constrains m2 (V ) and n2 (V ) to states where the lock \nis held (lock = 1) , while the environment transitions e1 (V, V ' ) and e2 (V, V ' ) are applicable only \nin states for which the lock is not held by the respective thread (lock = 0) . We add the (transition) \npredicates that appear in the environ\u00adment transition e2 of the .rst thread to the set P2.1 , and, symmet\u00ad \n\u00a8 \u00a8 rically, we add the predicates from e1 to P1.2. For the next ARET  // Thread 1 // Thread 2 a: take_lock(lock, \n1); p: take_lock(lock, 2); b: // critical q: // critical Figure 3. Example program LockId . computation \nwe have the following set of predicates: . P1 = {pc1 = a, pc1 = b, pc2 = p, lock =1} , . P2 = {pc2 = \np, pc2 = q, pc1 = a, lock =1} , \u00a8 P12 = {lock =0} , \u00a8 P21 = {lock =0} . Last ARET computation Weperformanother \nARET computation and a subsequent abstraction re.nement step. We add the predicate \u00a8\u00a8 lock ' =1 to both \nP12 and P21, and proceed with the .nal ARET computation. Figure 2(c) shows the resulting trees. The application \nof thread transitions produces the following abstract states and environment transitions: m1 = a.1(.init \n) =(pc1 = a . pc2 = p) , n1 = a.2(.init ) =(pc1 = a . pc2 = p) , m2 = a.1(post(.1,m1)) = (pc1 = b . pc2 \n= p . lock = 1) , n2 = a.2(post(.2,n1)) =(pc1 = a . pc2 = q . lock = 1) , e1 = a\u00a812(m1 . .1) =(lock =0 \n. lock ' = 1) , e2 = a\u00a821(n1 . .2) =(lock =0 . lock ' = 1) . The environment transitions e1 and e2 produce \nthe abstract states m3 and n3 whose intersection does not contain any error states. m3 = a.1(post(e2 \n. .1= ,m2)) = (pc1 = a . lock = 1) n3 = a.2(post(e1 . .2= ,n2)) =(pc2 = p . lock = 1) Neither thread \nnor environment transitions can be applied from the abstract states m3 and n3, while no further abstract \nstates are found. Since each pair of abstract states from different threads yields an intersection that \nis disjoint from the error states, we conclude that LockBit is safe. The labeling of the computed trees \ncan be directly used to construct a safety proof for LockBit, as Sections 4 and 5 will show.  2.2 Example \nLockId Our second example LockId, shown in Figure 3, is a variation of LockBit. LockId uses an integer \nvariable lock (instead of a single bit) to record which thread holds the lock. Due to this additional \ninformation recorded in the global variable, the example LockId has a modular proof, which does not refer \nto any local variables. We show how our algorithm discovers such a proof by only admitting modular predicates \nin the abstraction re.nement step. LockId differs from LockBit in its transition relation .2: = q . . \n= .2 =(lock =0 . lock ' =2 . pc2 = p . pc2 ' 1 ) . First ARET computation Similarly to LockBit, we discover \nthat m2 .n2 ..err is satis.able, and compute the following set of Horn clauses: HC3 = {.init . m1 (V \n), m1 (V ) . .1 . m2 (V ' ), .init . n1 (V ), n1 (V ) . .2 . n2 (V ' ), m2 (V ) . n2 (V ) . .err . false} \n. One possible satisfying assignment SOL is: SOL( m1 (V )) = (pc2 = p) , SOL( n1 (V )) = (pc1 = a) , \nSOL( m2 (V )) = (pc2 = p) , SOL( n2 (V )) = (pc1 = a) . .1 .2  Figure 4. Tree that shows all the reachable \nabstract states found during the last ARET computation for LockId. This assignment uses a predicate pc2 \n= p over the local variable of the second thread as a solution for the abstract state m1 (V ) in the \nthread reachability of the .rst thread. By collecting and using the corresponding predicates, we will \ndiscover a non-modular proof. To avoid the drawbacks of non-modular proofs, our algo\u00adrithm does not use \nHC3 and attempts to .nd modular predicates for abstraction re.nement instead. We express the preference \nfor modular predicates declaratively, using a set of Horn clauses in which the unknown predicates are \nrestricted to the desired vari\u00adables, as described in Sections 6. For the abstract states in the .rst \nthread, we require that the corresponding solutions are over the global variable lock and the local variable \npc1 of the .rst thread, i.e., we have the unknown predicates m1 (lock, pc1 ) and m2 (lock, pc1 ). Similarly, \nfor the second thread we obtain n1 (lock, pc2 ) and n2 (lock, pc2 ). Instead of HC3, we use a set of \nHorn clauses HC4 shown below: HC4 = {.init . m1 (lock, pc1 ), m1 (lock, pc1 ) . .1 . m2 (lock ' , pc1 \n' ), .init . n1 (lock, pc2 ), n1 (lock, pc2 ) . .2 . n2 (lock ' , pc2 ' ), m2 (lock, pc1 ) . n2 (lock, \npc2 ) . .err . false} . The conjunction of clauses from HC4 can be satis.ed by an assign\u00adment SOL such \nthat SOL( m1 (lock, pc1 )) = true , SOL( m2 (lock, pc1 )) = (lock = 1) , SOL( n1 (lock, pc2 )) = true \n, SOL( n2 (lock, pc2 )) = (lock = 2) , which contains only modular predicates. Last ARET computation \nWe present the last ARET computation for LockBit, which uses on the following (transition) predicates \ncollected so far: . P1 = {pc1 = a, pc1 = b, lock =1} , . P2 = {pc2 = p, pc2 = q, lock =2} , \u00a8 P21 = {lock \n=0} , \u00a8 P12 = {lock =0} . Figure 4 shows the resulting abstract reachability and environment trees constructed \nas follows: m1 = a.1(.init ) =(pc1 = a) n1 = a.2(.init ) =(pc2 = p) m2 = a.1(post(.1,m1)) = (pc1 = b \n. lock = 1) n2 = a.2(post(.2,n1)) =(pc2 = q . lock = 2) e1 = a\u00a812(m1 . .1) =(lock = 0) e2 = a\u00a821(n1 . \n.2) =(lock = 0)  The ARET construction is completed, since a.1(post(e2 . .1= ,m1)) . m1 ,a.1(post(e2,m2)) \n= false , a.2(post(e1 . .2= ,n1)) . n1 ,a.2(post(e1,n2)) = false . By inspecting pairs of abstract states \nfrom different trees we con\u00adclude that LockId is safe. Furthermore no predicate in P.1 refers to the \nlocal variable of the second thread, the symmetric condition holds for P.2, and \u00a8\u00a8 the predicates in \nP12 as well as P21 do not refer to any local variables. Thus, from the trees in Figure 4 we can construct \na modular safety proof. 3. Preliminaries In this section we brie.y describe multi-threaded programs, \ntheir computations and correctness. We also introduce auxiliary de.ni\u00adtions that we apply for reasoning \nabout programs. Programs We consider a multi-threaded program P that consists of N = 1 concurrent threads. \nLet 1..N be the set {1,..., N} . We assume that the program variables V =(VG,V1,...,VN) are partitioned \ninto global variables VG that are shared by all threads, and local variables V1,...,VN that are only \naccessible by the threads 1,..., N , respectively. The set of global states G consists of the valuations \nof global variables, and the sets of local states L1,...,LN consist of the valuations of the local variables \nof respective threads. By taking the product of the global and local state spaces, we obtain the set \nof program states S= G \u00d7 L1 \u00d7 \u00b7 \u00b7\u00b7 \u00d7 LN . We represent sets of program states using assertions over program \nvariables. Binary relations between sets of program states are represented using assertions over unprimed \nand primed variables. Let |= denote the satisfaction relation between (pairs) of states and assertions. \nThe set of initial program states is denoted by .init , and the set of error states is denoted by .err \n. For each thread i . 1..N we have a .nite set of transition relations Ti , which are abbreviated as \ntransitions. Each transition . .Ti can change the values of the global variables and the local variables \nof the thread i . Let . = i be a constraint requiring that the local variables of the thread i do not \nchange, i.e., . = i =(Vi = Vi ' ) . Then, . .Ti has the form update'' .(VG,Vi,V G,V i ) ..j = , j.1..N\\{i} \nwhere the .rst conjunct represents the update of the variables in the scope of the thread i and the remaining \nconjuncts ensure that the local variables of other threads do not change. We write .i for w the union \nof the transitions of the thread i , i.e., .i = Ti . The transition relation of the program is .T = .1 \n.\u00b7 \u00b7\u00b7. .N . Computations A computation of P is a sequence of program states s1,s2,... such that s1 is \nan initial state, i.e., s1 |= .init , and each pair of consecutive states si and si+1 in the sequence \nis connected by some transition . from a program thread, i.e., (si,si+1) |= . .A path is a sequence of \ntransitions. We write E for the empty sequence. Let [z/w] be a substitution function such that .[z/w] \nreplaces w by z in . . Let . be the relational composition function for binary relations given by assertions \nover unprimed and primed variables such that for assertions . and . we have . . . = .V '' : .[V '' ] \n. .[V '' /V ' /V ] . Then, a path relation is a relational composition of transition relations along \nthe path, i.e., for p = .1 \u00b7\u00b7\u00b7 .n we have .p = .1 . ... . .n . A path p is feasible if its path relation \nis not empty, i.e., .V, V ' : .p . A program state is reachable if it appears in some computation. Let \n.reach denote the set of reachable states. The program is safe if none of its error states is reachable, \ni.e., .reach . .err . false . For assertions R1,...,RN over V , and E1,...,EN over V and V ' CS1: .init \n. Ri for i . 1..N CS2: Ri . .i . Ri ' for i . 1..N CS3: Ri . Ei . . = i . Ri ' for i . 1..N w CS4:( Ri \n. .i) . Ej for j . 1..N i.1..N\\{j} CS5: R1 .\u00b7 \u00b7\u00b7. RN . .err . false program P is safe Figure 5. Proof \nrule REACHENV for compositional safety proofs of multi-threaded programs. Ri ' stands for Ri[V ' /V ] \n. REACHENV yields a pre-.xpoint characterization through Equations (1). Auxiliary de.nitions We de.ne \na successor function post such that for a binary relation over states . and a set of states . we have \n'''' '' ' post(., .)= .V : .[V /V ] . .[V /V ][V/V ] . We also extend the logical implication to tuples \nof equal length, i.e., (.1,...,.n) . (.1,...,.n)= .1 . f1 .\u00b7 \u00b7\u00b7. .n . fn , where each implication is \nimplicitly universally quanti.ed over the free variables occurring in it. From now on, we assume that \ntuples of assertions are partially ordered by the above extension of . . A Horn clause b1(w1) . \u00b7 \u00b7\u00b7 \n. bn(wn) . b(w) consists of relation symbols b1,. . . , bn, b, and vectors of variables w1,. . . , wn, \nw. For the algorithm SOLVELINEARHC in Section 7 we only consider Horn clauses over linear arithmetic. \nWe say that b depends on the relation symbols {bi | i . 1..n . bi (=)} . A set = of Horn clauses is recursion-free \nif the transitive closure of the corresponding dependency relation is well founded. 4. Proof rule, .xpoints, \nand abstraction In this section we develop the foundations for our veri.cation algorithm. We present \na compositional proof rule and then derive a corresponding characterization in terms of least .xpoints \nand their approximations. We present the ability of our proof rule to facilitate modular reasoning, when \nadmitted by the program, without losing the ability for global reasoning otherwise. Proof rule Figure \n5 presents a proof rule REACHENV for com\u00adpositional veri.cation of program safety. The proof rule is \ninspired by the existing proof rules for compositional safety reasoning, see e.g. [5, 15, 16, 26]. Our \nformulation of REACHENV directly leads to a pre-.xpoint characterization, thus, providing a basis for \nthe proof rule automation using abstraction and re.nement techniques. REACHENV relies on thread reachability \nassertions R1,...,RN that keep track of program states reached by threads 1,..., N together with their \nrespective environment transitions E1,...,EN . The environment transition of each thread keeps track \nof modi.cations of program states by other threads. The auxiliary assertions used in our proof rule can \nrefer to all program variables, that is, they are not restricted to a combination of global variables \nand local variables of a particular thread. If the provided auxiliary assertions satisfy all premises \nof the proof rule, i.e., CS1, . . . , CS5, then the program is safe. The premise CS1 requires that each \nthread reachability over\u00adapproximates the initial program states. CS2 ensures that the thread reachability \nof each thread is invariant under the application of the thread transitions. In addition, CS3 requires \ninvariance under the environment transitions of the thread. The conjunct . = i in CS3 se\u00adlects the subset \nof the environment transition that does not modify the local variables of the thread. Given a thread \nj , the premise CS4 collects transitions that start from states in the thread reachability of other threads \nand combines them into the environment transition for j . Finally, CS5 checks that there is no error \nstate that appears in each thread reachability set.  The proof rule REACHENV can be directly used to \nprove pro\u00adgram safety following a two-step procedure. First, we need to iden\u00adtify candidate assertions \nfor the thread reachability and environ\u00adment transitions. Second, we need to check that these candidate \nassertions satisfy the premises of proof rule. The correctness of the conclusion is formalized by the \nfollowing theorems. THEOREM 1 (Soundness). The proof rule REACHENV is sound. Proof. Let R1,...,RN and \nE1,...,EN satisfy the premises CS1, . . . , CS5. We show that the program is safe. To prove safety, for \neach reachable state s |= .reach we prove that s |= R1 .\u00b7 \u00b7\u00b7. RN by induction over the length k of a \nshortest computation segment s1,...,sk such that s1 |= .init and sk = s . For the base case k =1, the \ninclusion holds due to the premise CS1. For the induction step, we assume that the above statement holds \nfor states reachable in k = 1 steps and prove the statement for their immediate successors. That is, \nlet sk |= .reach and hence sk |= R1 . \u00b7 \u00b7\u00b7 . RN . If sk does not have any successor, i.e., \u00ac(.sk+1 :(sk,sk+1) \n|= .T ) , then there are no more states to consider. Otherwise, we choose a successor state sk+1 of sk \nthat is reached by taking a transition in a thread i , i.e., (sk,sk+1) |= .i . From CS2 follows that \nsk+1 |= Ri . To show that sk+1 |= Rj for each j . 1..N \\{i} we rely on the premises CS4 and CS3. By induction \nhypothesis sk |= Ri and due to CS4 we have (sk,sk+1) |= Ej . Now sk+1 . Rj follows from CS3. D THEOREM \n2 (Relative completeness). The proof rule REACHENV is complete relative to .rst-order reasoning. Proof. \nLet P be safe. We de.ne R1 = \u00b7\u00b7\u00b7 = RN = .reach and E1 = \u00b7\u00b7\u00b7 = EN = .reach . .T . Then, the premises CS1, \n. . . , CS5 are immediately satis.ed. D Modular and global proofs Reasoning about multi-threaded pro\u00adgram \nis more complex than reasoning about sequential programs since thread interaction needs to be taken into \naccount. Some pro\u00adgrams admit modular reasoning that deals with each thread in iso\u00adlation, i.e., assertions \nused in the proof only refer to the global vari\u00adables and the local variables of one thread at a time. \nThe proof rule REACHENV facilitates modular reasoning about multi-threaded programs. If a program has \na modular safety proof, then the following modular assertions satisfy the proof rule premises: Ri = .V \n\\ (VG . Vi): .reach , for i . 1..N Ei = .(V . V ' ) \\ (VG . VG' ): .reach . .T . for i . 1..N REACHENV \nis not restricted to modular proofs. Since the as\u00adsertions used in REACHENV can refer to each of the \nprogram vari\u00adables, non-modular proofs can be directly used. In fact, the proof of Theorem 2 relies on \nnon-modular assertions, since .reach may refer to local variables of different threads. In Section 5 \nwe will present our algorithm that can discover modular assertions for REACHENV if the program admits \nmodular proofs, and delivers non-modular assertions otherwise. Fixpoints The proof rule REACHENV in Figure \n5 directly leads to a .xpoint-based characterization, which de.nes our algorithm in Section 5. From the \npremises CS2, CS3, and CS4 we obtain a function F on N-tuples of assertions over the program variables \nand N-tuples of assertions over the unprimed and primed program variables such that F (S1,...,SN,T1,...,TN)= \n(post(.1 . T1 . . =1 ,S1), ..., post(.N . TN . . = (1) N ,SN), ww Si . .i, ..., Si . .i) . i.1..N\\{1} \ni.1..N\\{N} We formalize the relation between F and REACHENV as follows. LEMMA 1. Each pre-.xpoint of \nF satis.es the premises CS2, CS3, and CS4 of REACHENV. That is, if F (R1,...,RN,E1,...,EN) . (R1,...,RN,E1,...,EN) \nthen R1,...,RN,E1,...,EN satis.es CS2, CS3, and CS4 . We de.ne a distinguished tuple .F : .F =(.init \n,...,.init , false,..., false) . (2) N times Then, each pre-.xpoint of F that is greater than .F satis.es \nthe premise CS1. By choosing a pre\u00ad.xpoint (R1,...,RN,E1,...,EN) above .F such that R1 . ...,RN . .err \n. false we will satisfy all premises of the proof rule REACHENV, and hence prove the program safety. \nFixpoint abstraction Computing pre-.xpoints of F that satisfy CS1 and CS5 is a dif.cult task. We automate \nthis computation using the framework of abstract interpretation [7], which uses over\u00adapproximation to \nstrike a balance between reasoning precision and ef.ciency. To implement required over-approximation \nfunctions, we will use a collection of abstraction functions a.i and a\u00a8ij , where i = j . 1..N, that \nover-approximate sets and binary relations over programs states, respectively. We de.ne a function F \n# that over-approximates F using given abstraction functions: F #(S1,...,SN,T1,...,TN)= (.a1(post(.1,S1)) \n. .1 ,S1)) , a1(post(T1 . . = \u00b7\u00b7\u00b7 a.N(post(.N,SN) . .N ,SN)) , aN(post(TN . . = (3) w a\u00a8i 1(Si . .i) \n, i.1..N\\{1} \u00b7\u00b7\u00b7 w a\u00a8i N(Si . .i)) . i.1..N\\{N} Let .F # be an over-approximation of F such that .F # \n= (.a1(.init ),..., a.N(.init ), false,..., false) . (4) N times The least pre-.xpoint of F # above \n.F # can be used to prove program safety by applying the following theorem, and is the key outcome of \nour algorithm in Section 5. THEOREM 3 (Abstract .xpoint checking). If the least pre-.xpoint of F # above \n.F # , say (R1,...,RN,E1,...,EN), satis.es the premise CS5 then the program is safe. Proof. The theorem \nfollows directly from the soundness of the proof rule REACHENV, Lemma 1, and over-approximations introduced \nby the applied abstraction functions. D  function MAIN input P -program with N threads vars P.i,a.i \n-predicates for thread i and corresponding state abstraction function \u00a8 Pij ,a\u00a8ij -transition predicates \nfor pair of threads i, j and corresponding transition abstraction function Ri -abstract states of thread \ni Ei -abstract environment transitions of thread i Parent -parent function for abstract states and environment \ntransitions ParentTId -parent thread function for abstract states and environment transitions begin 1 \nfor each i = j . 1..N do 2 P.i := P\u00a8 ij := \u00d8 3 repeat 4 for each i = j . 1..N do { . 5 a.i := .S. {p..Pi \n|.V : S . p.}\u00a8 6 a\u00a8ij := .T. {{p\u00a8.Pij |.V, V ' : T . p\u00a8} 7 ABSTREACHENV() 8 if exists S1 .R1,...,SN .RN \nsuch that 9 .V : S1 .\u00b7 \u00b7\u00b7. SN . .err 10 then 11 try 12 REFINE(S1,...,SN) 13 with UNSATISFIABLE 14 D \n:= some Si from {S1,...,SN} 15 return counterexample MKPATH(D) 16 else 17 return program P is safe with \nthe proof w www 18 R1,..., RN, E1,..., EN 19 until true end. Figure 6. Function MAIN for verifying \nsafety of the multi\u00adthreaded program P . The choice of the abstract domains, i.e., the range sets of \nthe abstraction functions, determines if the least .xpoint of F # yields a modular proof. Our abstraction \ndiscovery algorithm in Section 6 automatically chooses the abstraction such that modular proofs are preferred. \n5. Thread reachability and environment transitions In this section, we present our rely-guarantee based \nveri.cation algorithm for proving safety properties of multi-threaded programs. The algorithm is based \non Theorem 3 and consists of three main steps. The .rst step computes for each thread a tree that is \ndecorated by abstract states and environment transitions, so-called ARET, and analyses the discovered \nabstract states. If an intersection with the error states of the program is found, then the second step \ngenerates a set of corresponding Horn clauses, see Section 6. At the third step, we solve the constraint \nde.ned by the conjunction of the generated Horn clauses and use the solutions to the re.ne the abstraction \nfunctions used for the ARET computation, see Section 7. procedure ABSTREACHENV begin 1 Parent := ParentTId \n:= . (* the empty function *) 2 for each i . 1..N do 3 4 Ri := { .ai(.init )}Ei := \u00d8 5 repeat 6 .nished \n:= true 7 for each i . 1..N and S .Ri do 8 (* states *) 9 for each . .Ti .Ei do 10 S ' := if . .Ti then \na.i(post(., S)) 11 else .i ,S)) ai(post(. . . = . S '' 12 if \u00ac(.S '' .Ri .V : S ' ) then 13 Ri := {S \n' }.Ri 14 Parent(S ' ) := (S, .) 15 ParentTId(S ' ) := i 16 .nished := false 17 done 18 (* environment \ntransitions *) 19 for each . .Ti and j . 1..N \\{i} do 20 . ' := a\u00a8ij (S . .) if \u00ac(.. '' : . ' . . '' \n21 .Tj .Ej .V, V ' ) then 22 Ej := {. ' }.Ej 23 Parent(. ' ) := (S, .) 24 ParentTId(. ' ) := i 25 .nished \n:= false 26 done 27 done 28 until .nished end Figure 7. Procedure ABSTREACHENV implements ARET compu\u00adtation. \nWe assume that the iterator statements in lines 7 and 9 make an immutable snapshot of their domains Ri \nand Ei, respectively. For example, this implies that each addition of S ' in line 12 is un\u00adnoticed in \nline 7 until the next iteration of the repeat loop. Function MAIN The main function of our algorithm \nMAIN is shown in Figure 6. MAIN takes as input the multi-threaded pro\u00adgram P . The repeat loop iterates \nthrough the three main steps of the algorithm. First, we construct the abstraction functions a.i and \na\u00a8ij at lines 4 6 from a given set of (transition) predicates, which is empty initially. Next, the ARET \ncomputation is performed in line 7 using these abstraction functions. In lines 8 9, the abstract states \nin the computed ARET s are analyzed wrt. the safety property. In case of a positive outcome of this check, \nMAIN constructs and returns a safety proof in lines 17 18. If the safety check fails, then REFINE is \nexecuted on the violating abstract states. If REFINE terminates nor\u00admally, and hence succeeds in eliminating \nthe violation by re.ning the abstraction functions, then MAIN continues with the next iter\u00adation of the \nrepeat loop. In case an UNSATISFIABLE exception is thrown, MKPATH from Figure 8 constructs a counterexample \npath that we report to the user. Procedure ABSTREACHENV See Figure 7 for the procedure ABSTREACHENV that \nimplements ARET computation using the abstraction functions a.i and a\u00a8ij . We use Parent and ParentTId \nto maintain information about the constructed trees, and initialize  function MKPATH input D -abstract \nstate begin 1 match Parent(D) with 2 | (S, .) -> 3 p := MKPATH(S) 4 match Parent(.) with 5 | (O, .O) \n-> return p \u00b7 .O 6 | . -> return p \u00b7 . 7 | . -> return E (* the empty sequence *) end Figure 8. Function \nMKPATH takes as input an abstract state D and returns a sequence of transitions that lead to D. them \nwith the empty function . in line 1. Ri and Ei keep track of abstract states and environment transitions \nfor a thread i . 1..N . Ei is initialized to an empty set in line 4, while Ri contains the abstraction \nof the initial program states computed for the thread i . The ARET computation is performed iteratively \nin the repeat loop, see lines 5 27. The .rst part of the loop (see lines 7 17) implements a standard, \nleast .xpoint computation over reachable states. At line 7, the algorithm picks an already reachable \nstates S .Ri in order to compute its abstract successors. After computing at lines 10 11 one successor \nof S , line 12 implements a .xpoint check, which succeeds if S ' contains program states that have not \nbeen reached yet. The new states reachable in thread i are stored in Ri . At line 14, the function Parent \nis updated to keep track of the child\u00adparent relation between abstract states, while ParentTId maps the \nnew reachable state to its parent thread. The second part of the loop (see lines 19 26) performs a least \n.xpoint computation over environment transitions. Each time a transition from a thread i is picked at \nline 7, the abstraction of its effect computed in line 20 is propagated to each other thread j . Note \nhowever, that the propagation only happens for environment transitions that are not subsumed by the existing \nones, which is checked in line 21. Additional environment transitions are recorded in line 22. Environment \ntransitions are taken into consideration when computing abstract state reachability, see line 9. Upon \ntermination, which is guaranteed by the .niteness of our abstract domains, the function ABSTREACHENV \ncomputes sets of abstract states R1,..., RN and sets of environment transitions E1,..., EN . 6. Abstraction \nre.nement Procedure REFINE In Figure 9, we present the procedure REFINE that takes as argument an error \ntuple and, if possible, re\u00ad.nes the abstraction functions to include predicates that witness the fact \nthat the error state is unreachable. The procedure REFINE generates a set of Horn clauses corresponding \nto the error tuple (lines 1 4). Next, the REFINE algorithm invokes a solving proce\u00addure for Horn clauses \n(lines 5 7). Lastly, the procedure REFINE up\u00addates the abstraction functions using the solution of Horn \nclauses at lines 8 12. We consider the solution SOL and add the atomic pred\u00adicates that appear in Sol( \nS (V) to the set of predicates P.i . The index i is chosen to be that of the thread where S originated \nfrom. Similarly, the procedure updates the transition abstraction functions at line 12. Here, we only \nassume that SOLVEHC returns a cor\u00adrect solution to the set of Horn clauses received as argument. In procedure \nREFINE input S1,...,SN -abstract error tuple begin 1 2 HC := { S1 (V ) . \u00b7 \u00b7 \u00b7 . SN (V ) . .err . false}. \nMKHORNCLAUSES(S1) 3 . . . 4 . MKHORNCLAUSES(SN) 5 SOL := SOLVEHC(HC, 6 7 8 { S (V ) | i . 1..N . S . \nRi} . { . (V, V ' ) | i . 1..N . . . Ei}) for each i . 1..N and S . Ri do 9 .Pi := PredsOf (SOL( S (V \n))) . .Pi 10 for each j . 1..N and . . Ej do 11 i := ParentTId(.) 12 \u00a8 Pij := PredsOf (SOL( . (V, V ' \n))) . \u00a8 Pij end Figure 9. Procedure REFINE. The quotation function \u00b7 creates a relation symbol from \na given abstract state/abstract transition. The function PredsOf extracts atomic predicates from the \nsolutions to the set of Horn clauses HC. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function MKHORNCLAUSES input \nD -abstract state begin i := ParentTId(D) return match Parent(D) with | (S, .) -> MKHORNCLAUSES(S) . \n begin match Parent(.) with | (O, .O) -> { O (V ) . .O . . (V, V ' ) , S (V ) . . (V, V ' ) . . = . D \n(V ' )} i . MKHORNCLAUSES(O) | . -> { S (V ) . . . D (V ' )} end | . -> {.init . D (V )} end Figure \n10. Function MKHORNCLAUSES. Section 7, we present a solving algorithm for recursion-free Horn clauses \nover the linear arithmetic domain. Function MKHORNCLAUSES The generation of the Horn clauses is started \nfrom lines 1 4 of Figure 9. One clause re\u00adquires that the solutions corresponding to the abstract states \nfrom the error tuple do not intersect .err : { S1 (V ) . \u00b7\u00b7\u00b7 . SN (V ) . .err . false} . The other clauses \nare generated by invoking MKHORNCLAUSES(Si) for i . 1..N . The function MKHORNCLAUSES generates Horn \nclauses for transitions consid\u00adered during ARET computation as follows. If the abstract state D was produced \nby following a local transition, i.e., Parent(D)=  9 10 { O (VG, Vi) . .O . . (VG, V ' G) , S (VG, Vi) \n. . (VG, V ' G) . 11 12 . = i . D (V ' G, V ' i )}. MKHORNCLAUSES(O) 13 14 | . -> { S (VG, Vi) . . . \nD (V ' G, V ' i )}end 15 | . -> {.init . D (VG, Vi)} Figure 11. Modi.cations to MKHORNCLAUSES to admit \nonly modular solutions.  // Thread 1 // Thread 2 x: cnt++; p: take_lock(lock,1); assume(cnt >= 1); q: \n// critical a: take_lock(lock,1); b: // critical .init =(pc1 = x . pc2 = p . lock =0 . cnt = 0) . = ' \n1 =(pc1 = pc1 ' . cnt = cnt ) . = ' 2 =(pc2 = pc2 ) .0 =(pc1 = x . pc1 ' = a . lock = lock ' . cnt +1= \ncnt ' . 1 = cnt 2 ) ' . . = .1 =(pc1 = a . pc1 ' = b . lock =0 . lock ' =1 . cnt = cnt 2 ) ' . . = .2 \n=(pc2 = p . pc2 ' = q . lock =0 . lock ' =1 . . =1 ) .err =(pc1 = b . pc2 = q) Figure 12. LockBitCnt \nis an expanded version of the program LockBit . (S, .) and Parent(.)= . , then one Horn clause corresponds \nto the application of the local transition at line 12: { S (V ) . . . D (V ' )} . Additional Horn clauses \nare generated recursively for the parent state S at line 5. If the abstract state D was produced by following \nan environment transition, i.e., Parent(D)=(S, .) and Parent(.)=(O, .O) , then two Horn clauses correspond \nto the generation of the environment transition (line 9) and to the application of the environment transition \n(line 10). Finally, if Parent(D)= . , then one Horn clause constrains the solution of D (V ) at line \n14: {.init . D (V )} . Note that solutions for unknown states are expressed in terms of all program variables \nV , while solutions for unknown transitions are expressed in terms of V and V ' . Consequently, these \nsolutions may lead to non-modular proofs even for a set of Horn clauses that has modular solutions. Discovery \nof Modular Predicates We present modi.cations to our abstraction re.nement algorithm that guarantee the \ndiscovery of modular solutions whenever they exist. With these modi.ca\u00adtions, solutions for unknown states \noriginating in thread i can only be expressed in terms of VG,Vi rather than the whole set of pro\u00adgram \nvariables V . Solutions for unknown transitions are restricted to the set of global variables VG,V G \n' . To implement these changes, we change line 1 from the REFINE procedure as follows:  1 HC := { S1 \n(VG,V1) .\u00b7 \u00b7\u00b7. SN (VG,VN) . .err } We also replace lines 9 14 from MKHORNCLAUSES with the frag\u00adment shown \nin Figure 11. The rest of the function MKHORN-CLAUSES is unchanged. If the resulting Horn clauses have \nno so\u00adlution, i.e., SOLVEHC throws an UNSATISFIABLE exception, then it may still be possible that a non-modular \nsolution exists. In this case, we invoke the abstraction re.nement once again, this time generating Horn \nclauses using the unmodi.ed function MKHORN-CLAUSES from Figure 10. Example We illustrate the generation \nof Horn clauses using an expanded version of LockBit shown in Figure 12. This example contains an additional \nvariable cnt local to the .rst thread. The initial symbolic state of the program .init constrains both \ncnt and lock to the value 0 . The transition relation of the .rst thread is extended with .0, which increments \ncnt by 1 and assumes that the incremented value is greater than or equal to 1 . Similar to the example \nfrom Section 2, .err encodes the violation of the mutual exclusion property. We show in Figure 13(a) \nthe reachability trees as computed by the ARET computation. The error tuple consists of m4 and n3 , i.e., \nm4 . n3 . .err is satis.able. From this error tuple, MKHORNCLAUSES generates Horn clauses following the \nprocedure from Figure 10. These Horn clauses are shown in Figure 13(b). The Horn clauses have un\u00adknown \nstates m1 (V ), m2 (V ), m3 (V ), m4 (V ), n1 (V ), n2 (V ) , and n3 (V ) . The unknown transitions are \ne1 (V, V ' ) and e2 (V, V ' ) . Comparatively, we show in Figure 13(c) the Horn clauses gen\u00aderated with \npreference for modular solutions. The solutions for the unknown states of thread 1 can refer only to \n(VG,V1) , while the unknown states of thread 2 are restricted to (VG,V1) . The un\u00adknown transitions are \ne1 (VG,V G' ) and e2 (VG,V G' ) . THEOREM 4 (Progress of abstraction re.nement). The procedure REFINE \nguarantees progress of abstraction re.nement, i.e., the same set of Horn clauses is never discovered \ntwice. 7. Solving Horn clauses over linear inequalities As presented in the previous section, REFINE \ncalls the func\u00adtion SOLVEHC. In this section we present a function SOLVE-LINEARHC that can be used as \nan implementation of SOLVEHC takes as input a set of clauses HC over linear inequalities that is recursion-free. \nTo simplify the presentation of the algorithm, we make two additional assumptions on HC. First, we assume \nthat for each pair of clauses (...) . b(w) and (...) . b ' (w ' ) from HC we have b = b ' and b =(=)= \nb '. Second, we assume that HC contains a clause (...) . false . The additional assumptions are satis.ed \nby the clauses gener\u00adated in Section 6. In case SOLVELINEARHC is applied on a set of recursion-free Horn \nclauses over linear arithmetic that violates the two assumptions above, we can apply a certain renaming \nof re\u00adlation symbols and introduction of additional clauses to meet the assumptions. Function MKTREE \nThe function MKTREE generates a tree rep\u00adresentation for a set of Horn clauses and is shown in Figure \n15. For every relation appearing in the Horn clauses, the algorithm gener\u00adates a corresponding tree node. \nThe children of a node are main\u00adtained in a function Children as follows. Nodes that correspond to linear \narithmetic relations have no children, see lines 11 12. A node that corresponds to an unknown relation \nwith a relation sym\u00adbol b has as children those nodes that represent relation symbols that depend on \nb . The Label attribute of the tree nodes is initial\u00adized to a linear arithmetic constraint for leaves \nof the tree in line 11, and to an unknown relation for internal tree nodes in line 13. Function SOLVELINEARHC \nSee Figure 14 for the pseudocode of the procedure SOLVELINEARHC . This procedure creates a tree representation \nfor HC at line 2. At line 3, we build a set containing  .init . m1 (V ) .init . m1 (VG,V1) m1 (V ) . \n.0 . m2 (V ' ) m1 (VG,V1) . .0 . m2 (V ' ,V ' ) G1 m2 (V ) . .1 . m3 (V ' ) m2 (VG,V1) . .1 . m3 (V \n' ,V ' ) G1 m2 (V ) . .1 . e1 (V, V ' ) m2 (VG,V1) . .1 . e1 (VG,V ' ) G m3 (V ) . e2 (V, V ' ) . .= \n. m4 (V ' ) m3 (VG,V1) . e2 (VG,V ' ) . .= . m4 (V ' ,V ' ) 1 G1 G1 .init . n1 (V ) .init . n1 (VG,V2) \nn1 (V ) . .2 . n2 (V ' ) n1 (VG,V2) . .2 . n2 (V ' ,V ' ) G2 n1 (V ) . .2 . e2 (V, V ' ) n1 (VG,V2) \n. .2 . e2 (VG,V ' ) G n2 (V ) . e1 (V, V ' ) . .= . n3 (V ' ) n2 (VG,V2) . e1 (VG,V ' ) . .= . n3 (V \n' ,V ' ) 2 G2 G2 m4 (V ) . n3 (V ) . .err . false m4 (VG,V1) . n3 (VG,V2) . .err . false (a) (b) (c) \n  6: .init (VG4,V 14,V 2 I)   8: .1(V 3,V 3,V IV ,V 2,V 2,V V) G12 G12  (c) Horn clauses generated \nwith preference for modular solutions. (d) A tree representation of the clauses from (b) as generated \nby MKTREE. Each node shows its Label attribute. The superscript of the node name identi.es the set of \nvariables appearing in the attribute of the node. (e) The Pred map generated by SOLVELINEARHC from the \nclauses in (b). (f) The Label map generated by MKHORNCLAUSES from the clauses in (c).  7: .0(V 4,V 4,V \nII ,V 3,V 3,V III ) G12 G12 ,V VIII ,V 2) 11 : .init (VG21 2 all the Label attributes of leaf nodes \nand store this set in Atoms . { The input set of Horn clauses is satis.able if and only if Atoms { is \nunsatis.able. If Atoms is unsatis.able, the test at lines 4 5 succeeds and returns a proof of unsatis.ability \nin the form of weights for each linear inequality. This test can be implemented using some linear arithmetic \nconstraint solver. If the constraint solver fails to .nd a proof, an exception UNSATISFIABLE is thrown \nat line 12. At line 7, SOLVELINEARHC calls the procedure ANNOTPRED , which is presented in Figure 16. \nThis procedure recursively tra\u00adverses the input tree in postorder. If this procedure is invoked for a \nleaf node n , it directly computes the value of Pred(n) as a linear combination of atomic formulas with \nweights given by the Proof function (see line 2). If this procedure is invoked for an internal node n \n, the attribute Pred of n s children is computed using a re\u00adcursive call at line 5. After completing \nthe recursive call, Pred(n) is calculated by adding the values of the Pred attributes of n s chil\u00addren. \nSince there may be multiple nodes in the tree corresponding to the same unknown relation, the algorithm \nhas to account for the Pred attributes of all these nodes. Therefore, at lines 8 9 we compute solutions \nfor each b(w) in UnkRel by taking conjunction of Pred of each node of the tree that is labeled with b(u) \nfor some u . THEOREM 5. SOLVELINEARHC computes a solution for a set of Horn clauses HC if and only if \nthe conjunction of the clauses in HC is satis.able. Example We illustrate the solving procedure using \nthe same ex\u00adample from the previous section. Given the Horn clauses from Fig\u00adure 13(b), MKTREE constructs \na tree that is shown in Figure 13(d). This tree contains nodes which we label for convenience with iden\u00adti.ers \nfrom 1 to 26 . In Figure 13(d) we show the Label map of the { tree. A witness of the unsatis.ability \nof Atoms is given by the following atomic formulas: (cnt3 = 1) . (cnt3 = cnt2) . (cnt2 = 0) function \nSOLVELINEARHC input HC -recursion-free Horn clauses over linear inequalities UnkRel -unknown relations \nvars Label -map from node to attribute Children -map from node to a set of nodes Pred -map from node \nto an atomic predicate Proof -weight function for inequalities begin 1 Label := Children := . (* the \nempty function *) 2 root := MKTREE(false) 3 Atoms := {Label(n) | Children(n)= \u00d8}4 if exists Proof : \nAtoms . Q=0 such that 5 {Proof (b(u)) \u00b7 b(u) | b(u) . Atoms} = (1 = 0) 6 then 7 ANNOTPRED(root) 8 for \neach b(w) . UnkRel do { 9 SOL(b(w)) := {Pred(n)[w/u]|Label(n)= b(u)} 10 return SOL 11 else 12 throw UNSATISFIABLE \nend Figure 14. Function SOLVELINEARHC returns a solution for a set of recursion-free Horn clauses over \nlinear arithmetic. node as cntVIII . The proof of unsatis.ability shown above does no longer hold, since \nthe following formula is satis.able: 332VIII (1 = cnt ) . (cnt = cnt ) . (cnt = 0) However, the conjunction \nof the elements from the Atoms set is . . . still unsatis.able, indicating that a modular solution exists. \nWe .nd Label(7) Label(8) Label(11) that the following atoms contribute to a proof of unsatis.ability: \nOur solver treats each linear equality as a conjunction of two linear lock2 =1 . lock2 =0 inequalities. \nThe equality cnt2 =0 is split in two inequalities cnt2 = 0 .-cnt2 = 0 . The proof of unsatis.ability \nis: . . Label(8) Label(12) (1 = cnt3)+(cnt3 = cnt2)+(cnt2 = 0) = (1 = 0). This is encoded in the Proof \nmap with values of 1 at locations corresponding to the three atomic formulas above and values of 0 for \nall the other atomic formula. Next, we show in Figure 13(e) the values for the Pred map as computed by \nANNOTPRED . The .nal solution of the Horn clauses is built by a conjunction of the Pred attributes for \nnodes with the same unknown label. The resulting solution SOL is shown below. SOL( m1 (V )) = SOL( n2 \n(V )) =(0 = 0) SOL( e1 (V, V ' ))= =(0 = 0) SOL( m2 (V )) = SOL( m3 (V )) =(1 = cnt) SOL( n1 (V )) = \nSOL( e2 (V, V ' )) = (cnt = 0) Solving the clauses shown in Figure 13(c) Given the Horn clauses shown \nin this .gure, MKTREE returns a tree representa\u00adtion with a similar Children map structure but with different \nLabel attributes. The part of the tree that contributes to the proof of unsat\u00adis.ability is shown in \nFigure 13(f). The variable cnt2 does not ap\u00adpear in the subtree of the node 9 since Label(9) = e2 (VG2,V \nG1) . Part of this subtree is the node 11. Let us name the variable at this After splitting the equalities \nin equivalent inequalities, our algo\u00adrithm computes the following solution: Pred(8) = (1 = lock2) Pred(12) \n= (lock2 = 0) Pred(3) = (1 = lock2) Pred(9) = (lock2 = 0) Pred(2) = (1 = 0) From this Pred map, our algorithm \nderives a solution SOL in lines 8 9 and succeeds in computing modular predicates. 8. Experimental results \nIn this section, we describe a proof-of-concept implementation of our proposed algorithm as an extension \nof the model checker ARMC [29]. Tool description The veri.er we built takes as input a number of functions \n(written in the C language) representing threads that should execute concurrently. The input .le also \ncontains the de\u00adscription of an initial state and a number of assertions to be proven correct. Our tool \nuses a frontend based on the CIL infrastructure [25] to translate a C program to its corresponding multi-threaded \ntransition system that is formalized in Section 3. The main compo\u00ad  function MKTREE input g -relation, \neither b(u) or false begin 1 p, q := new nodes 2 match g with 3 | false -> 4 {b1(w1) .\u00b7 \u00b7\u00b7. bn(wn) . \nfalse, ... } := HC 5 z1,...,zn := fresh copies of w1,...,wn 6 s := [z1/w1] \u00b7\u00b7\u00b7 [zn/wn] 7 | b(u) -> 8 \n{b1(w1) .\u00b7 \u00b7\u00b7. bn(wn) . b(w), ... } := HC 9 z1,...,zn,z := fresh copies of w1,...,wn,w 10 s := [z1/w1] \n\u00b7\u00b7\u00b7 [zn/wn][u/z] 11 Label(p) := {bi(wi)s | i . 1..n . bi =(=)}12 Children(p) := \u00d8 13 Label(q) := g 14 \nChildren(q) := 15 {p}. {MKTREE(bi(wi)s) | i . 1..n . bi =(=)}16 return q end Figure 15. Function MKTREE. \nFresh copies are created con\u00adsistent, e.g., fresh copies of {v1,v2}, {v3,v1} returns {f1,f2}, {f3f1}, \nwhere f1, f2, f3 are fresh variables that do not appear anywhere else. procedure ANNOTPRED input n -node \nof Horn tree begin 1 if Children(n)= \u00d8 then 2 Pred(n) := {Proof (b(u))\u00b7b(u) | b(u) . Label(n)} 3 else \n4 for each n ' . Children(n) do ' 5 ANNOTPRED(n ) 6 Pred(n) := {Pred(n ' )|n ' . Children(n)} end Figure \n16. Procedure ANNOTPRED. nent of our tool is an implementation of our algorithm done using SICStus Prolog \n[33]. An important design decision in our implementation concerns the treatment of control-location and \ndata variables. Even if both control-location variables and data variables can be handled uni\u00adformly \nby our algorithm, we found that different abstraction do\u00admains and re.nement for the two domains can \nlead to signi.cant improvement. In our implementation, the REFINE procedure .rst splits the constraints \ninto data variable constraints and control\u00adlocation constraints. The splitting procedure preserves satis.abil\u00adity/unsatis.ability \nof the original constraint since there is no atomic formula in the program transitions that relates both \ncontrol vari\u00adables and data variables. If the data constraints are satis.able, the algorithm proceeds \nas in Figure 9. If the data constraints are un\u00adsatis.able, our implementation relies on a specialized \nre.nement procedure (described in [13]) that takes advantage of the simpler form of control counterexamples. \nFor these counterexamples, con\u00adtrol variables range over a .nite domain and no atomic formula from the \nprogram transitions involves different control variables. Benchmark programs We tested our prototype \nimplementation using a collection of programs that have intricate correctness proofs for their safety \nassertions. The .rst four programs shown in Ta\u00adble 1 are derived from two buggy examples highlighted \nas .gures in [20], together with their .xes from the MOZILLA CVS reposi\u00adtory. The property to verify \nis that two operations performed by dif\u00adferent threads are executed in the correct order. The next three \nex\u00adamples model the stopping procedure of a Windows NT Bluetooth driver [30]. BLUETOOTH2 contains two \nthreads, one worker thread and another thread to model the stopping procedure of the driver. BLUETOOTH2-FIXED \nand BLUETOOTH3-FIXED are the .xed ver\u00adsions of the model with two and respectively three threads. SCULL \n[6] is a Linux character device driver that implements access to a global memory area. The property to \nverify is that read and write operations are performed in critical section. We also include some examples \nwhich are not particularly fa\u00advorable to a modular reasoning approach. These examples are al\u00adgorithms \nthat establish mutual exclusion and mainly deal with global variables (no local computation is included \nin the critical region). The mutual exclusion property of the na\u00a8ive version of the Bakery algorithm \n[22] holds only when assuming assignments are performed atomically. (Our veri.er was able to con.rm the \nbug present in the code without such atomicity assumption.) BAKERY [18] is the complete version of the \nBakery algorithm, while LAM-PORT [19] is an algorithm with an optimized path in the absence of memory \ncontention. QRCU [23] is an algorithm implementing the Read-copy-update synchronization algorithm. It \nis an alternative to a readers-writer lock having wait-free read operations. Performance of our tool \nTo explain our experimental results, we .rst articulate a working hypothesis. This hypothesis suggests \nthat, when verifying a program that does not have a modular proof, the algorithm with preference for \nmodular solutions (denoted as ver\u00adi.cation with bias) is expected to pay a penalty by insisting to search \nfor modular solutions that do not exist. On the other hand, for cases where a modular proof does exist, \nthe non-biased veri.\u00adcation could fail to .nd a modular proof and instead return a more detailed non-modular \nproof. Therefore, the hypothesis suggests that in these cases the biased veri.cation is expected to succeed \nfaster compared to the non-biased veri.cation. We report statistical data for each of the programs in \nTable 1. We show the number of lines of code (LOC) and whether a modu\u00adlar proof exists for a program \n(see Column 3). Our implementation has two modes. Column 4 shows the veri.cation results, when us\u00ading \nour algorithm with a preference for modular solutions. The last column of the table shows the veri.cation \nresults for the non-biased implementation of our algorithm. The results demonstrate that our approach \nto veri.cation of multi-threaded programs is feasible and that the constraint solving procedure with \nbias is able to produce modular proofs more often than the non-biased veri.cation. Fur\u00adthermore, without \nthe bias, the veri.cation procedure times-out for Scull and QRCU examples showing the bene.ts of modular \nproofs. As another experiment, we tested some of our smaller exam\u00adples using two state-of-the-art model \ncheckers for sequential C pro\u00adgrams, Blast [14] and ARMC[31]. For each of the tested programs (Fig2-.xed, \nFig4-.xed, Dekker, Peterson, and Lamport), we instru\u00admented the program counter as explicit program variables \n(pc1 and pc2 ) and obtained a sequential model of the multi-threaded exam\u00adples. Both Blast and ARMC eagerly \nconsider all interleavings and obtained timeouts after 30 minutes for both Fig4-.xed and Lam\u00adport. Comparatively, \nour tool exploits the thread structure of these programs and obtains conclusive veri.cation results fast. \n Benchmark programs Our algorithm Name LOC Has a modular proof? With bias No bias Fig2-cex[20] 33 No \n\u00d7 0.2s \u00d7 0.2s Fig2-.xed[20] 38 Yes .-Modular 0.8s .-Modular 0.7s Fig4-cex[20] 175 No \u00d7 4.5s \u00d7 3.7s Fig4-.xed[20] \n168 Yes .-Modular 1.5s . 11.1s Bluetooth2[30] 90 No . 29.1s . 11.2s Bluetooth2-.xed 90 No . 3.7s . 0.4s \nBluetooth3-.xed 90 No . 135s . 9.7s Scull[6] 451 Yes .-Modular 128.5s T/O Dekker[1] 39 No . 11.1s . 6s \nPeterson[1] 26 No . 4.7s . 3.9s Readers-writer-lock[10] 22 Yes .-Modular 0.2s . 0.4s Time varying mutex[10] \n29 No . 11.8s . 3.1s Szymanski[32] 43 No . 32s . 8.8s Na\u00a8iveBakery[22] 22 Yes .-Modular 2.5s . 3s Bakery[18] \n37 No . 105.4s . 101s Lamport[19] 62 No . 120.8s . 97s QRCU[23] 120 Yes .-Modular 34.5s T/O Table 1. \nHas a modular proof? indicates whether the program has a modular proof of correctness. . and \u00d7 indicate \nwhether the program is proven safe or a counterexample is returned, while T/O stands for time out after \n15 minutes. .-Modular indicates that a modular proof is found by our tool. 9. Related work The main inspiration \nfor our work draws from the rely-guarantee reasoning method [16, 17] and automatic abstraction re.nement \napproach to veri.cation [4]. The seminal work on rely-guarantee reasoning [16, 17] initially offered \nan approach to reason about multi-threaded programs by making explicit the interference between threads. \nSubsequently, rely-guarantee reasoning was used to tackle the problem of state ex\u00adplosion in veri.cation \nof multi-threaded programs. Rely-guarantee reasoning was mechanized and .rstly implemented in the Calvin \nmodel checker [10] for Java shared-memory programs. Calvin re\u00adduces the veri.cation of the multi-threaded \nprogram to the veri.ca\u00adtion of several sequential programs with the help of a programmer speci.ed environment \nassumption. In [9], thread-modular model checking was proposed to infer automatically environment assump\u00adtions \nthat propagate only global variable changes to other threads. The algorithm has low complexity, polynomial \nin the number of threads, but is incomplete and fails to discover environment as\u00adsumptions that refer \nto the local states of a thread. Thread-modular veri.cation is formalized by [21] in the framework of \nabstract in\u00adterpretation as Cartesian product of sets of states. The method of [15] uses a richer abstraction \nscheme that com\u00adputes contextual thread reachability, where the context in which a thread executes includes \ninformation on both global and local states of threads. The context (or environment) is computed using \nbisim\u00adilarity quotients in steps that are interleaved with abstract reacha\u00adbility computations. The veri.cation \nstarts with the strongest pos\u00adsible environment assumption and, by re.nement, the environment is weakened \nuntil it over-approximates the transitions of the other threads. In contrast, our approach re.nes iteratively \nthe environ\u00adment based on over-approximation, starting with the weakest en\u00advironment and strengthening \nit at every iteration. For abstraction re.nement, a counterexample from [15] is reduced to a concrete \nsequential path by replacing environment transitions with their cor\u00adresponding local transitions. The \napproach of [5] presents another solution to overcome the incompleteness of local reasoning. Guided by \ncounterexamples, it re.nes the abstraction by exposing a local variable of a thread as a global variable. \nThis re.nement recovers the completeness of reasoning, but is applicable to .nite-state systems and may \ncompute an unnecessarily precise abstraction. In contrast, our re.nement procedure relies on interpolation \nand includes predicates on local variables as needed during veri.cation. Another approach to overcome \nthe state explosion problem of monolithic reasoning over multi-threaded programs is to translate the \nmulti-threaded program to a sequential program assuming a bound on the number of context switches. This \nscheme was initially proposed and implemented in KISS [30], a multi-threaded checker for C programs, \nand later evolved to handle and reproduce even dif\u00ad.cult to .nd Heisenbugs [24]. Monolithic reasoning \ncan be greatly facilitated by using techniques evolved from partial-order reduction [11], like dynamic \npartial-order reduction [8] or peephole partial order reduction [34]. Yet another technique to .ght state \nexplosion is to factor out redundancy due to thread replication as proposed in counter abstraction [27] \nand implemented in the model checker Boom [2, 3]. We view these techniques as paramount in obtaining \npractical multi-threaded veri.ers, but orthogonal to our proposal for automatic environment inference. \nAcknowledgments The .rst author was supported by the DFG Graduiertenkolleg 1480 (PUMA). We thank Byron \nCook, Rusl\u00b4an Ledesma Garza, and Peter O Hearn for comments and suggestions. References [1] Y. Bar-David \nand G. Taubenfeld. Automatic discovery of mutual  exclusion algorithms. In DISC, pages 136 150, 2003. \n[2] G. Basler, M. Mazzucchi, T. Wahl, and D. Kroening. Symbolic counter abstraction for concurrent software. \nIn CAV, pages 64 78, 2009. [3] G. Basler, M. Hague, D. Kroening, C.-H. L. Ong, T. Wahl, and H. Zhao. \nBoom: Taking boolean program model checking one step further. In TACAS, pages 145 149, 2010. [4] E. M. \nClarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. Counterexample-guided abstraction re.nement. In CAV, \npages 154 169, 2000. [5] A. Cohen and K. S. Namjoshi. Local proofs for global safety proper\u00adties. FMSD, \n34(2):104 125, 2009. [6] J. Corbet, A. Rubini, and G. Kroah-Hartman. Linux Device Drivers, 3rd Edition. \nO Reilly Media, Inc., 2005. [7] P. Cousot and R. Cousot. Abstract interpretation: A uni.ed lattice model \nfor static analysis of programs by construction or approxima\u00adtion of .xpoints. In POPL, pages 238 252, \n1977. [8] C. Flanagan and P. Godefroid. Dynamic partial-order reduction for model checking software. \nIn POPL, pages 110 121, 2005. [9] C. Flanagan and S. Qadeer. Thread-modular model checking. In SPIN, \npages 213 224, 2003. [10] C. Flanagan, S. N. Freund, and S. Qadeer. Thread-modular veri.cation for shared-memory \nprograms. In ESOP, pages 262 277, 2002. [11] P. Godefroid. Partial-Order Methods for the Veri.cation \nof Concur\u00adrent Systems -An Approach to the State-Explosion Problem. PhD the\u00adsis, University of Liege, \nComputer Science Department, 1994. [12] S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs \nwith PVS. In CAV, pages 72 83, 1997. [13] A. Gupta, C. Popeea, and A. Rybalchenko. Non-monotonic re.nement \nof control abstraction for concurrent programs. In ATVA, pages 188 202, 2010. [14] T. A. Henzinger, R. \nJhala, R. Majumdar, and G. Sutre. Lazy abstrac\u00adtion. In POPL, pages 58 70, 2002. [15] T. A. Henzinger, \nR. Jhala, and R. Majumdar. Race checking by context inference. In PLDI, pages 1 13, 2004. [16] C. B. \nJones. Tentative steps toward a development method for inter\u00adfering programs. ACM Trans. Program. Lang. \nSyst., 5(4):596 619, 1983. [17] C. B. Jones. Speci.cation and design of (parallel) programs. In IFIP \nCongress, pages 321 332, 1983. [18] L. Lamport. A new solution of Dijkstra s concurrent programming problem. \nCommun. ACM, 17(8):453 455, 1974. [19] L. Lamport. A fast mutual exclusion algorithm. ACM Trans. Comput. \nSyst., 5(1):1 11, 1987. [20] S. Lu, S. Park, E. Seo, and Y. Zhou. Learning from mistakes: a comprehensive \nstudy on real world concurrency bug characteristics. In ASPLOS, pages 329 339, 2008. [21] A. Malkis, \nA. Podelski, and A. Rybalchenko. Thread-modular veri.\u00adcation is cartesian abstract interpretation. In \nICTAC, pages 183 197, 2006. [22] Z. Manna and A. Pnueli. Temporal veri.cation of reactive systems: safety. \nSpringer-Verlag, 1995. [23] P. McKenney. Using Promela and Spin to verify parallel algorithms. LWN.net \nweekly edition, 2007. [24] M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P. A. Nainar, and I. Neamtiu. \nFinding and reproducing Heisenbugs in concurrent pro\u00adgrams. In OSDI, pages 267 280, 2008. [25] G. C. \nNecula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermedi\u00adate language and tools for analysis and \ntransformation of C programs. In CC, pages 213 228, 2002. [26] S. S. Owicki and D. Gries. An axiomatic \nproof technique for parallel programs I. Acta Inf., 6:319 340, 1976. [27] A. Pnueli, J. Xu, and L. D. \nZuck. Liveness with (0, 1, infty)-counter abstraction. In CAV, pages 107 122, 2002. [28] A. Podelski \nand A. Rybalchenko. Transition predicate abstraction and fair termination. In POPL, pages 132 144, 2005. \n[29] A. Podelski and A. Rybalchenko. ARMC: The logical choice for software model checking with abstraction \nre.nement. In PADL, pages 245 259, 2007. [30] S. Qadeer and D. Wu. KISS: keep it simple and sequential. \nIn PLDI, pages 14 24, 2004. [31] A. Rybalchenko. The ARMC tool. Available from http://www7.in.tum.de/ \nrybal/armc/. [32] B. K. Szymanski. A simple solution to Lamport s concurrent program\u00adming problem with \nlinear wait. In ICS, pages 621 626, 1988. [33] The Intelligent Systems Laboratory. SICStus Prolog User \ns Manual. Swedish Institute of Computer Science, 2001. Release 3.8.7. [34] C. Wang, Z. Yang, V. Kahlon, \nand A. Gupta. Peephole partial order reduction. In TACAS, pages 382 396, 2008.   \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Automated verification of multi-threaded programs requires explicit identification of the interplay between interacting threads, so-called environment transitions, to enable scalable, compositional reasoning. Once the environment transitions are identified, we can prove program properties by considering each program thread in isolation, as the environment transitions keep track of the interleaving with other threads. Finding adequate environment transitions that are sufficiently precise to yield conclusive results and yet do not overwhelm the verifier with unnecessary details about the interleaving with other threads is a major challenge. In this paper we propose a method for safety verification of multi-threaded programs that applies (transition) predicate abstraction-based discovery of environment transitions, exposing a minimal amount of information about the thread interleaving. The crux of our method is an abstraction refinement procedure that uses recursion-free Horn clauses to declaratively state abstraction refinement queries. Then, the queries are resolved by a corresponding constraint solving algorithm. We present preliminary experimental results for mutual exclusion protocols and multi-threaded device drivers.</p>", "authors": [{"name": "Ashutosh Gupta", "author_profile_id": "81418597229", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P2509624", "email_address": "guptaa@in.tum.de", "orcid_id": ""}, {"name": "Corneliu Popeea", "author_profile_id": "81100461244", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P2509625", "email_address": "popeea@in.tum.de", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Technische Universit&#228;t M&#252;nchen, Munich, Germany", "person_id": "P2509626", "email_address": "rybal@in.tum.de", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926424", "year": "2011", "article_id": "1926424", "conference": "POPL", "title": "Predicate abstraction and refinement for verifying multi-threaded programs", "url": "http://dl.acm.org/citation.cfm?id=1926424"}