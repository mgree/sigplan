{"article_publication_date": "01-26-2011", "fulltext": "\n Pick Your Contexts Well: Understanding Object-Sensitivity TheMaking of aPrecise andScalablePointerAnalysis \nYannisSmaragdakis Department ofComputerScience, University ofMassachusetts, Amherst,MA01003,USA andDepartment \nofInformatics, University ofAthens,15784,Greece yannis@cs.umass.edu smaragd@di.uoa.gr Abstract Object-sensitivity \nhas emerged as an excellent context abstraction forpoints-to analysisin object-orientedlanguages.Despiteitsprac\u00adtical \nsuccess, however, object-sensitivity ispoorly understood. For instance, for a context depth of 2 or higher, \npast scalable imple\u00admentations deviate signi.cantly from the original de.nition of an object-sensitive \nanalysis. The reason is that the analysis has many degrees of freedom, relating to which context elements \nare picked at every method call and object creation. We o.er a clean model forthe analysisdesign space, \nanddiscuss aformalandinformal un\u00adderstanding of object-sensitivity and ofhow to creategood object\u00adsensitive \nanalyses. The results are surprising in their extent. We .nd that past implementations have made a sub-optimal \nchoice of contexts, to the severedetriment ofprecision andperformance.We de.nea full-object-sensitive \nanalysisthat resultsinsigni.cantly higher precision, and often performance, for the exact same con\u00adtext \ndepth. We also introduce type-sensitivity as an explicit ap\u00adproximation of object-sensitivity that preserves \nhigh context qual\u00adityat substantially reduced cost.Atype-sensitivepoints-to analysis makes an unconventional \nuse of types as context: the context types are not dynamic types of objects involved in the analysis, \nbut in\u00adstead upperbounds on thedynamic types of their allocator objects. Our results expose the in.uence \nof context choice on the quality ofpoints-to analysis anddemonstrate type-sensitivity tobe anidea with \nmajor impact: It decisively advances the state-of-the-art with a spectrum of analyses that simultaneously \nenjoy speed (several times faster than an analogous object-sensitive analysis), scalabil\u00adity(comparabletoanalyses \nwithmuchlesscontext-sensitivity), and precision(comparable to thebestobject-sensitive analysis with the \nsame contextdepth). Categories and Subject Descriptors F.3.2[Logics and Meanings of Programs]: Semantics \nof Programming Languages Program Analysis ; D.3.1 [Programming Languages]: Formal De.nitions and Theory \nSemantics General Terms Algorithms,Languages,Performance Permission to make digital or hard copies of \nall or part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. POPL 11, January26 28,2011,Austin,Texas,USA. Copyright &#38;#169;c2011ACM978-1-4503-0490-0/11/01. \n. .$10.00 MartinBravenboer LogicBloxInc. TwoMidtownPlaza Atlanta,GA30309,USA martin.bravenboer@acm.org \nOnd.rejLhot\u00b4ak DavidR.CheritonSchool of ComputerScience University ofWaterloo Waterloo,ONN2L3G1,Canada \n olhotak@uwaterloo.ca 1. Introduction Points-to analysis(or pointer analysis in our context)is one of \nthe mostfundamental staticprogram analyses.Points-toanalysis con\u00adsists of computing a static abstraction \nof all the data that a pointer expression(orjust a variable, without loss ofgenerality) canpoint toduringprogram \nrun-time.The analysisformsthebasisforpracti\u00adcally every otherprogram analysis andis closelyinter-related \nwith mechanisms such as call-graph construction, since the values of a pointer determine the target of \ndynamically resolved calls, such as object-oriented dynamically dispatched method calls or functional \nlambda applications. By nature, the entire challenge of points-to analysisistopickjudicious approximations.Intractabilitylurksbe\u00adhind \nany attempt to track program control-or data-.ow precisely. Furthermore, the global character and complicated \nnature of the analysis makeithard todeterminehowdi.erent analysisdecisions interact with various language \nfeatures. For object-oriented and functional languages, context-sensitivity isageneral approach that \nachieves tractable and usefully high precision. Context-sensitivity consists ofqualifyinglocalprogram \nvariables, andpossibly(heap) object abstractions, with contextinformation:the analysis collapses information \n(e.g., what objects this method argument can point to ) over all possible executions that result in the \nsame context, while separating all information for di.erent contexts. Two main kinds ofcontext-sensitivityhavebeen \nexplored: call-site sensitivity [18,19]and object-sensitivity [13]. Ever since theintroduction of object-sensitivityby \nMilanova et al.[13], therehasbeen accumulating evidence[3,7,8,10,14] that it is a superior context abstraction \nfor object-oriented programs, yielding high precision relative to cost. The success of object\u00adsensitivity \nhas been such that, in current practice, object-sensitive analyses have almost completely supplanted \ntraditional call-site sensitive/kCFA analysesforobject-orientedlanguages.Thispaper is concerned with \nunderstanding object-sensitivity in depth, for\u00admalizingit conveniently, and exploringdesign choicesthatproduce \neven more scalable andprecise analyses than currentpractice. What is object-sensitivity at a high level? \nPerhaps the easi\u00adest way to describe the concept is by analogy and contrast to the better-known call-site \nsensitivity.A call-site sensitive/kCFA analy\u00adsis uses method call-sites(i.e.,labels ofinstructionsthat \nmay call the method) as context elements.Thatis,inOOterms, the analysis separatesinformation onlocal \nvariables(e.g., method arguments) percall-stack(i.e.,sequence of k call-sites) of method invocations \nthatled to the current method call.Similarly,the analysis separates information on heap objects per call-stack \nof method invocations thatledtothe object s allocation.Forinstance,inthe code example below, a1-call-site \nsensitive analysis(unlike a context-insensitive analysis) willdistinguishthetwo call-sites of method \nfoo onlines7 and9.This means thatthe analysis willtreat foo separatelyfortwo cases: that of its argument, \no, pointing to anything someobj1 may point to, andthat of o pointing to anything someobj2 maypoint to. \n 1 class A { 2 void foo(Object o) { ... } 3 } 4 5 class Client { 6 void bar(A a1, A a2) { ... 7 a1.foo(someobj1); \n8 ... 9 a2.foo(someobj2); 10 } 11 } In contrast, object-sensitivity uses object allocation sites(i.e., \nlabels of instructions containing a new statement) as context ele\u00adments.(Hence,abetternamefor object-sensitivity \nmighthave been allocation-sitesensitivity .)Thatis,whenamethodiscalled on an object, the analysis separates \ntheinferredfactsdepending on the allocation site ofthe receiver object(i.e.,the object on which the method \nis called), as well as other allocation sites used as con\u00adtext.Thus,intheaboveexample,a1-object-sensitive \nanalysiswill analyze foo separatelydepending ontheallocationsitesof theob\u00adjects thata1 and a2 maypoint \nto.Itis not apparent from the above fragment neither whether a1 and a2 maypoint todi.erent objects, nor \nto how many objects: the allocation site of the receiver object maybe remote and unrelated to the method \ncallitself.Similarly,it is not possible to compare the precision of an object-sensitive and a call-site \nsensitive analysis in principle. In this example, it is not even clear whether the object sensitive analysis \nwill examine all calls to foo as one case, as two, or as many more, since this de\u00adpends on the allocation \nsites of all objects that the analysis itself computesto .owinto a1 and a2. Note that our above description \nhas been vague: the analysis separates ... facts depending on the allocation site of the receiver object \n... as well as other allocation sites . What are these other allocationsites ?The .rst contributionof \nourpaperconsistsof rec\u00adognizingthatthereis confusionintheliterature regardingthistopic. Theoriginalde.nition \nof object-sensitivity(see[13],Fig.6,p.12.) de.nes the context of a method call to be the allocation site \nof the receiver object obj, the allocation site of the allocator object(obj ' ) of obj,(i.e.,the receiver \nobject of the method that made the alloca\u00adtion of obj), the allocation site ofthe allocator object of \nobj ' , and soon.Nevertheless,subsequent object-sensitive analyses(e.g., [5, 8, 10, 20], amongmany) maintain \nthe fundamental premise of using allocationsitesascontextelements,yetdi.erinwhich allo\u00adcation sites are \nused.Forinstance,the2-object-sensitive analysisin the Paddle framework[7,9] uses asmethod contexttheallocation \nsite ofthe receiver object and the allocation site ofthe caller object (i.e., an objectof class Client, \nand not A,in our example). In thispaper, we o.er a uni.edformalframework that captures the object-sensitive \nanalyses de.ned in the literature and allows a deeper understanding of their di.erences. Additionally, \nwe imple\u00admentanarray of object-sensitiveanalyses anddrawinsightsabout how the choice of context relates \nto scalability and precision. We discover that the seemingly simple di.erence of how an analy\u00adsis context \nis chosen results in large di.erences in precision and performance. We use the name full-object sensitivity \nto referto(a slightgeneralization of) the original statement of object-sensitivity byMilanova et al.We \nargue thatfull-object sensitivityis an excel\u00adlentchoiceinthedesign space, whilethe choice of context \nmadein past actual implementations is sub-optimal and results in substan\u00adtial loss of precision. Concretely, \na practical outcome of our work isto establisha2-full-object-sensitive analysis with a1-object sen\u00adsitiveheap(shortenedto \n2full+1H ) as an analysis that is often (thoughnot always) feasible with current technology and impres\u00adsivelyprecise. \nPerhaps even moreimportantly, our understandingoftheimpact of context onthe e.ectiveness of an analysisleadstode.ning \na new variantthatcombines scalability withgoodprecision.Namely,we introduce the idea of a type-sensitive \nanalysis, which is de.ned to be directly analogous to an object-sensitive analysis, yet approxi\u00admates(some) \ncontext elements usingtypesinstead offull allocation sites.In contrast topast uses of typesinpoints-to \nanalysis(e.g., [1,15,21] and seeRyder[17] for several examples) wedemon\u00adstrate that the types used as \ncontexts should not be the types of the corresponding objects. Instead, the precision of our type-sensitive \nanalysisisdue to replacing the allocation site of an object o (which would be used as context in an object-sensitive \nanalysis) with an upper-bound of thedynamic type of o s allocator object.The result isasubstantialimprovementthatestablishes \nanew sweet spotinthe practicaltradeo. ofpoints-to analysisprecision andperformance. In summary, our work \nmakes thefollowing contributions: We o.er a better understanding of the concept and variations of object-sensitive \npoints-to analyses. Our understanding relies on apreciseformalism that captures thedi.erent object-sensitive \nanalyses, as well as oninformalinsights.  We identify the di.erencesinpastobject-sensitive analyses \nand analyze the in.uence of these di.erences on precision and per\u00adformance. We argue that full-object-sensitivity \nis a substantially better choicethan others usedin actualpractice.Wevalidatethe impact offull-object-sensitivityfor \nthe case of a contextdepth of  2.Thedi.erenceis signi.cantin terms ofprecision and scalabil-ity.Our \nresultshelp establish a2full+1H analysis as the state-of\u00adthe-artforprecisionin object-orientedprograms, \namong analyses that are oftenpracticallyfeasible. We introduce type-sensitivity, as a purposeful collapsing \nof the context information of an object-sensitive analysis, in order to improve scalability. We discuss \nwhat is a good type-sensitive context and show that the straightforward option(of replacing an object \nby its type) is catastrophically bad. Instead, we identify an excellent choice of type context anddemonstrate \nthatityields a surprisingly ideal combination of precision and scalability. A type-sensitive analysisfor \na contextdepth of2is severaltimes(2x to unboundedlyhigh)fasterthan a corresponding object-sensitive analysis, \nwhile keeping almost the same precision. In fact, the run-timeperformance and scalability of atype-sensitive \nanalysis often exceed those of a cheap object-sensitive analysis of alower contextdepth, whileyielding \nvastly moreprecision. 2. FormalizingObject-Sensitivity andVariations We formalize analyses using an abstract \ninterpretation over a sim\u00adpli.ed base language that closely captures the key operations that practical \npoints-to analyses perform. For this, we use Feather\u00adweight Java [6] in A-Normal form. A-Normal Featherweight \nJava is identical to ordinary Featherweight Java, except that argu\u00admentsto afunction call mustbe atomically \nevaluable.For example, the body return f.foo(b.bar()); becomes b1 = b.bar(); f1 = f.foo(b1); return f1;.This \nshiftdoes not change the expressive power ofthelanguage or the nature ofthe analysis,butitsimpli.es the \nsemantics and brings the language closer to the intermediate languages thatpracticalpoints-to analysisimplementations \noperate on.Ourformalismis animperative variant(with a call stackin\u00adstead of continuations) of the corresponding \nformalism of Might, Smaragdakis andVanHorn[12],whichattemptsauni.edtreat\u00adment of control-.ow analysis(infunctionallanguages) \nandpoints\u00adto analysis(inimperative/OOlanguages).  The grammar below describes A-Normal Featherweight \nJava. Some of the Featherweight Java conventions merit a reminder: A classdeclarationalwaysnamesasuperclass,andlists \n.elds(dis\u00adtinctfrom thosein the superclass)followedby a single constructor andalist ofmethods.Constructors \nare stylized, always takingin as many parameters as total .elds in the class and superclasses, and consisting \nof a callto the superclass constructor and assignment of therest ofthe .elds,allinorder. ------ .. C \n'' Class ::= class C extends C '{ f ; KM} -- ------------- - -.. . ' '' ''' K . Konst ::= C (Cf ){super( \nf ) ; this. f = f ;} - -. - --. M . Method ::= Cm (Cv ) {Cv ; 1s } s . Stmt ::= v = e ;l |return v ;l \n.-- . e . Exp ::= v |v. f |v.m(v ) |new C (v ) |(C)v v . Var is a setof variable names f . FieldName \nis a setof .eld names C . ClassName is a setof class names m . MethodCall is a setof methodinvocation \nsites l . Lab is a setoflabels Every statementhas alabel,toprovide a convenient way of refer\u00adencingprogrampoints.Thefunction \nsucc : Lab . Stmt yields the subsequent statementfor a statement slabel. 2.1 ConcreteSemantics Weexpressthe \nsemantics usingasmall-stepstatemachine.Figure1 containsthe state space.Astate consists ofa statement, \nadata stack (forlocalvariables), a store, a call-stack(recording,for eachactive method invocation, the \nstatement to return to, the context to re\u00adstore, andthelocationthat willholdthe return value), anda current \ncontext.Followingearlier work[12], our concrete semantics antici\u00adpatesabstractioninthatvariablesand .eldsaremappedtocontext\u00adsensitive \naddresses, and the store maps such addresses to objects. The purpose served by the concept of a context-sensitive \naddress istointroduce an extralevel ofindirection(throughthe store).In the usual concrete semantics, \nevery dynamic instance of a variable or .eld will have a di.erent context, making context-sensitive ad\u00addresses \nextraneous.Nevertheless,the existence ofthe store makesit easy to collapse information from di.erentprogram \npaths, as long asvariablesor .eldsmaptothesamecontext-sensitiveaddress.1In addition to being a map from \n.elds to context-sensitive addresses, an object also stores its creation context. There are two di.erent \nkindsofcontextinthisstatespace: acontextforlocal(method) variables, and a heap context, for object .elds. \nAt a .rst approxi\u00admation, one can think of the two contexts as being the same sets. Any in.nite sets \ncan play the role of context. By picking speci.c context sets we can simplifythe mappingfrom concreteto \nabstract, as wellas capture the essence of object-sensitivity. The semantics are encoded as a small-step \ntransition relation (.) . S \u00d7 S, shown in Figure 2. There is one transition rule for each expression \ntype, plus an additional transition rule to account for return. Evaluation consists of .nding all states \nreachable from an initial state (typically a single call statement with an empty store and binding environment). \nWe use standard functions cons, car, cdr, and .rst n to construct and deconstruct lists/stacks. For 1Toprevent \nmisunderstandings, we notethatthe extralevelofindirectionis theonlypurposeof thestoreinoursemantics.Speci.cally, \nourstoreisnot intended for modeling theJavaheap and our stackis not modeling theJava local variable stack(althoughithassimilarstructure, \nasitisamap over local variables). For instance, the store is used to also map local variables toactual \nvalues, whichisthepurposeof aJavastack. . . S= Stmt \u00d7 Stack \u00d7 Store \u00d7 CallStack \u00d7 Context st . Stack \n= (Var . ContSensAddr) * s . Store = ContSensAddr . Obj o . Obj= HContext \u00d7 (FieldName . ContSensAddr) \ncst . CallStack = (Stmt \u00d7 Context \u00d7 ContSensAddr) * a . ContSensAddr = (Var \u00d7 Context)+ (FieldName \u00d7 \nHContext) c . Context is anin.nite set of contexts hc . HContext is anin.nite set ofheapcontexts. Figure1. \nState-spaceforA-NormalFeatherweightJava. Variable reference ([[v = v ' ;l]],st,s,cst,c). (succ(l),st,s \n' ,cst,c), where s ' = s+ [st(v) . s(st(v ' ))]. Return ([[return v ;l]],st,s,cst,c). (s,cdr(st),s ' \n,cdr(cst),c ' ), where (s,c ' ,aret)= car(cst) s ' = s+ [aret . s(st(v))]. Field reference ([[v = v ' \n. f ;l]],st,s,cst,c). (succ(l),st,s ' ,cst,c), where ( ,[f . af ])= s(st(v ' )) s ' = s+ [st(v) . s(af \n)]. Method invocation . ' '' ([[v = v0.m( -v );l]],st,s,cst, c). (s0,st ' ,s ' ,cst ,c ), where - --. \n- ----. '' ''' M = [[Cm (Cv ) {C ' v ; 1s}]]= M(o0,m) o0 = s(st(v0)) oi = s(st(v ' i)) (hc0, )= o0 c \n' = merge(l,hc0,c) ' '' '' ''' a = (v ' ) a = (v ' ) ii ,c jj ,c s '' ' = s+ [ai . oi] cst = cons((succ(l),c, \nst(v)),cst) ' '' '''' '' st = cons([vi . ai,vj . aj ],st). Object allocation . ([[v = new C ( -v ' );l]],st,s,cst,c). \n(succ(l),st,s ' ,cst,c), where oi = s(st(v ' i)) hc = record(l,c) 1f = F(C) ai = (fi,hc) ' s '' o = (hc,[fi \n. ai]) = s+ [st(v) . o ]+ [ai . oi]. Casting (C '' ([[v = ) v ]],st,s,cst, c). (succ(l),st,s ' , cst,c), \nwhere s ' = s+ [st(v) . s(st(v ' ))]. Figure2. Concrete semanticsforA-NormalFeatherweightJava. convenience, \nwe de.ne a lookup of a variable in a stack to mean a lookup in the top component of the stack, e.g., \nst(v) means (car(st))(v).We also usehelperfunctions M : Obj\u00d7 MethodCall . Method F : ClassName . FieldName \n* .   The former takes a method invocation point and an object and returns the object s method that \nis called at that point (which is not known without knowing the receiver object, due to dynamic dispatch). \nThe latter returns a list of all .elds in a class de.nition, including superclass .elds. Our semantics \nis parameterized by two functions that manipu\u00adlate contexts: record : Lab \u00d7 Context . HContext merge \n: Lab \u00d7 HContext \u00d7 Context . Context The record function is used every time an object is created, in \nor\u00adder to store a creation context with the object. The merge function isusedoneverymethodinvocation.Its \n.rst argumentisthecurrent call statement label, while the second and third arguments are the context \nofallocation ofthe method s receiver object andthe current (caller s)context, respectively.Thekeyfordi.erent \n.avors ofcon\u00adtext sensitivity is to specify di.erent record and merge functions for contexts. For a simple \nunderstandingofthe concrete semanticsthatyields the natural behavior one expects, we can de.ne contexts \nas just natural numbers: Context = HContext = N. In that case, we need to ensure that the record and \nmerge func\u00adtions never return a duplicate context. For instance, if we con\u00adsider labels to also map to \nnaturals we can capture the entire his\u00adtory of past context creation by de.ning record(l,c) = 2l \u00b7 3c \nand 7hc merge(l,hc,c) = 5l \u00b7\u00b7 11c. A di.erent choice of context that is closer to idealized (in.nite \ncontext) object-sensitive semantics consists ofde.ning a context as alist oflabels: Context = HContext \n= Lab * , yielding a straightforward record function, while the merge func\u00adtion canignoreits second argument: \nrecord(l,c)= cons(l,c) merge(l,hc,c)= cons(l,c). These de.nitions enable every variable to have a di.erent \naddress for di.erent invocations, and every object .eld to have a di.erent addressfor eachobject allocated, \nas expected.2  2.2 AbstractSemantics Itis now straightforward to express object-sensitivepoints-to anal\u00adyses \nby abstract interpretation [4] of the above semantics for an abstractdomainthat maintainsonly.nitecontext. \nThe abstract state space is shown in Figure 3. The main dis\u00adtinctions from the concrete state-space are \nthat the set of contexts is .nite and that the store can return a set of objects, instead of a single \nobject. Generally, the abstract semantics closely mirror the concrete. The abstract semantics are encoded \nas a small-step transition relation(.) . S \u00d7 S , shown in Figure 4. There is one abstract transition \nruleforeachexpressiontype,plusan additionaltransition rule to account for return.We assume the usualproperties \nfor . of a mapto sets(i.e., merging of the setsfor the same value). We similarly de.ne abstract versions \nof the context\u00admanipulatingfunctions: &#38; record&#38;: Lab \u00d7 Context&#38;. HContext &#38;&#38;&#38; \nmerge&#38;: Lab \u00d7 HContext \u00d7 Context . Context 2Technically, this is true only because the FJ calculus \nhas no iteration, so object allocations from the same statement can only occur after a recursive call. \nThus, the string of labels for method calls is enough to ensure that objects have a unique context. \u00d7 \n&#38;&#38;&#38; S Stmt \u00d7 &#38; . . = Stack Store \u00d7 CallStack \u00d7 Context &#38;* Sst . &#38;= (Var . ContSensAddr) \nStack s . &#38;&#38;O Store = ContSensAddr .PObj o . O&#38;&#38; Obj= HContext \u00d7 (FieldName . ContSensAddr) \ncstC. CallStack = (Stmt \u00d7 Context \u00d7 ContSensAddr) * &#38;&#38;&#38; &#38;&#38;&#38; a . ContSensAddr \n= (Var \u00d7 Context)+ (FieldName \u00d7 HContext) &#38; S&#38; c . Context is a .nite setof contexts hc . HContext \nisa .nitesetofheap contexts. Figure 3. Object-sensitive analysis state-space for A-Normal FeatherweightJava. \nVariable reference ' lSC ([[v = v ;]],st, cst, \" (succ(l),stS,s ' ,cst,c ), where s,Cc)s ' = s .[Sst(v). \ns (Sst(v ' ))]. Return ([[return v ;l]],st, cst, \" (s,cdr(Ss ' , cdr(Cc ' Ss,Cc)st), cst), ), where (s,c \n' ,a ret)= cst) = s.[ aret . st(v))]. car(Cs ' s(S Field reference ' lSC ([[v = v . f ;]],st, cst, \" \n(succ(l),Sst,s ' ,cst, c ), where s,Cc)( ,[f . a f ])= s (Sst(v ' )) s ' = s .[Sst(v). s ( af )]. Method \ninvocation .-'' SSs ' C ([[v = v0.m(v ' );l]],st,s, cstC,c )\" (s0,st , ,cst ,c ' ), where - --. - ----. \n'' ''' C ' M = [[Cm (Cv ) { v ; 1s}]]= M( o0,m) ' o 0 . s (Sst(v0)) o i = s (Sst(vi)) (hcS0, )= o0 c \n= merge(l,Sc) ' &#38;hc0, ' '' ' '' ''' ' a i = (vi ,c ) a j = (vj ,c ) ' = s.[ i . C' = c,st(v)),cst) \ns ' a oi] cst cons((succ(l), SC '' '''' '' Sst ' = cons([vi . a i,vj . a j ],Sst). Object allocation \n' ([[v = new C ( -v );l]],Ss,Cc)\" (succ(l),Ss ' , cst,c ), . st, cst, st, C where o i = st(v ' hc record(l, \n s(Si)) S= &#38;c) f1= F(C) a i = (fi,hc) S '' o = (Sai]) s ' = s.[So ai . hc,[fi . st(v). ].[ oi]. \nCasting ' s ' ([[v = ) v ]],Ss,Cc)\" (succ(l),S,cst, (C ' st, cst, st, Cc), where s '' = s .[Sst(v). s \n(Sst(v ))]. Figure 4. Object-sensitivity abstract semantics for A-Normal FeatherweightJava.  The abstract \nrecord &#38;and &#38; merge functions capture the essence of object-sensitivity: an object-sensitive \nanalysis is distinguished by its storing a context together with every allocated object (via &#38; record), \nand byits retrieving that context and using it as the basis for the analysis context of every method \ndispatched on the object (via &#38; merge).  2.3 AnalysisVariationsandObservations With the above framework, \nwe can concisely characterize all past object-sensitive analyses, as well as discuss otherpossibilities.All \nvariations consist of only modifying the de.nitions of Context, &#38;&#38;&#38; HContext, record, and \n&#38; merge. Original Object Sensitivity. Milanova etal.[13]gavethe original de.nition of object-sensitivity \nbut did not implement the analysis for context depths greater than 1. Taken literally, the original de.\u00adnitionprescribes \nthat,for an n-object-sensitive analysis, the regular and theheap context consist of n labels: &#38;&#38; \nContext = HContext = Labn , &#38;in our concrete semantics, and &#38;while record just keeps the .rstn \nelements of the context de.ned merge discards everything but the receiver object context: &#38; record(l,c \n)= cons(l,.rst n-1( c)) S merge&#38;(l, hcS, c )= hc. Inpracticalterms, thisde.nitionhas several consequences: \n The only labels used as context are labels from an object allo\u00adcation site, via the &#38; record function. \n On a methodinvocation, only the(heap) context of the receiver object matters.  Theheapcontext of a \nnewly allocated objectisderivedfromthe context of the method doing the allocation, i.e., from the heap \ncontext of the object thatisdoing the allocation.  In other words, the context used to analyze a method \nconsists of the allocation site of the method s receiver object, the allocation site of the object that \nallocated the method s receiver object, the allocation site of the object that allocated the object that \nallocated the method s receiver object, and so on. In the next section we discuss whether thisis agood \nchoice of context for scalability and precision. Past Implementations of Object Sensitivity. For an object\u00adsensitive \nanalysis with context depth 1, the context choice is ob\u00advious. The &#38; merge function has to use some \nof the receiver object context, orthe analysis would notbe object-sensitive(just call-site\u00adsensitive), \nandthe receiver object context consists ofjustthe ob\u00adject s allocation site. For analyses with contextdepth \nn > 1,however, thede.nitions of &#38;record can vary signi.cantly.Actualimplementations merge and &#38;of \nsuch analyses deviated from the Milanova et al. de.nition. No\u00adtably, the Paddle framework[7,9](whichprovidesthe \nmost-used such implementation available) merges the allocation site of the receiver object with multiple \ncontext elements from the caller ob\u00adjectcontext when analyzing a method.This resultsin thefollowing functions: \n&#38; record(l,c )= cons(l,.rst n-1( c)) &#38;hc, = hc),.rstc)). merge(l, Sc)cons(car(Sn-1( Thepracticallyinterestingcaseis \nof n = 2.(Higher values are well outside current technologyifthe analysisis applied asde.ned,i.e., the \ncontextdepth applies to allprogram variables.)The abovede.\u00adnitionthen means that every methodis analyzed \nusing as context a) the allocation site of the receiver object; and b) the allocation site of the caller \nobject. Heap Context, Naming, and Full-Object Sensitivity. The above analyses de.ned the heap context \n( HContext) and the regu\u00ad &#38;lar/method context ( &#38;. Context) to be the same set, namely Labn There \nare other interesting possibilities, however. Since the &#38; merge function has access to aheap context \nand to a regular context(and needs tobuild a new regular context) theheap context canbe shal\u00adlower.Forinstance,Lhot\u00b4ak \ns exploration of object-sensitive analy\u00adses[7] studiesindepth analyses wheretheheap contextisalways justa \nsingle allocation site: &#38; HContext = Lab &#38; Context = Labn &#38; record(l,c )= l &#38;hc, = hc,.rst \nn-1c)). merge(l, Sc)cons(S( In fact, the above de.nition is what is most commonly called an object-sensitive \nanalysis in the literature! The analyses we saw earlier are colloquially called object-sensitive analyses \nwith a context-sensitive (or object-sensitive) heap . That is, the points\u00adto analysis literature by convention \nuses context to apply only to methods, whileheap objects are representedbyjusttheir allocation site.Adding \nmorecontexttoobject .eldsthanjusttheobjectal\u00adlocation site is designated with su.xes such as context-sensitive \nheap or heap cloning inananalysisdescription.Thus, oneneeds tobe very careful with naming conventions.We \nsummarize ours at the end of this section. Another interesting possibility is that of keeping a deeper \ncon\u00adtext for heap objects than for methods. The most meaningful case inpracticeisthe one wheretheheapobjectkeeps \none extra context element: &#38; HContext = Labn+1 &#38; Context = Labn &#38; record(l,c )= cons(l,c \n). (The &#38; merge function can vary orthogonally, as per our earlier dis\u00adcussion.) For n = 1,thisisLhot\u00b4ak \ns 1obj+H analysis, which is currently considered thebest trade-o. between scalability andpre\u00adcision[8], \nand to which we refer repeatedlyin our experimental evaluation ofSection5 Thislatestvariation complicates \nnaming even more.InLhot\u00b4ak s detailednaming scheme,theaboveanalysiswouldbean n-object\u00adsensitive analysis \nwith an (n-)object-sensitive heap , while our &#38;&#38; standard n-object-sensitive analysis(with Context \n= HContext = Labn)is calledan n-object-sensitive analysis with an n-1-object\u00adsensitive heap . The reason \nfor the o.-by-one convention is his\u00adtorical: it is considered self-evident in the points-to analysis \ncom\u00admunity that the static abstraction for a heap object will consist of atleastits allocation sitelabel. \nTherefore, theheap context is con\u00adsidered to be n - 1 labels, when the static abstraction of an object \nconsists of n labelsin total. In the rest of this paper, we adopt the standard terminology of the points-to \nanalysis literature. That is, we talk of an n-object\u00adsensitive analysis with an n -1-object-sensitiveheap \nto mean that &#38;&#38; Context = HContext = Labn. Furthermore, to distinguish between thetwodominantde.nitions \nof a &#38; merge function(Milanova etal. s, as opposed to that of the Paddle framework) we refer to a \nfull\u00adobject-sensitive analysis vs. a plain-object-sensitive analysis.A full-object-sensitive analysisis \ncharacterizedbya &#38; merge function: S merge&#38;(l, hcS,c )= hc.  Thatis,the full object abstractionofthereceiverobjectisused \nas contextforthemethodinvoked onthat object.Incontrast,aplain\u00adobject-sensitive analysis mergesinformationfrom \nthe receiver and the caller objects: &#38; record(l,c )= cons(l,.rst n-1( c)) &#38;hc, = hc),.rst n-1c)). \nmerge(l, Sc)cons(car(S( Thus, the original object-sensitivityde.nitionbyMilanova et al.is afull-object-sensitiveanalysis, \nwhilethepractical object-sensitive analysis of the Paddle framework isplain-object-sensitive. We ab\u00adbreviate \nplain-object-sensitive analyses for di.erent context and heapcontextdepthsto nplain+mH andfull-object-sensitive \nanal\u00adyses to nfull+mH . When the two analyses coincide, we use the abbreviation nobj+mH . Discussion. \nFinally, note that our theoretical framework is not limited to traditional object-sensitivity, but also \nencompasses call\u00adsite sensitivity. Namely, the &#38; merge function takes the current call\u00adsitelabel \nas an argument.None ofthe actual object-sensitive analy\u00adses we saw above usethis argument.Thus, ourframework \nsuggests ageneralized interpretation of what constitutes an object-sensitive analysis.Webelievethatthe \nessence of object-sensitivity is not in only using allocation-sitelabelsascontext butin storing anob\u00adject \ns creation context andusing it at the site of a method invoca\u00adtion (i.e., thefunctionalityof the &#38; \nmerge function).We expect that future analyses willexplorethisdirectionfurther,possibly combin\u00ading call-site \nand allocation-siteinformationininteresting ways. Our framework also allows the same high-level structure \nof an analysisbut withdi.erent contextinformationpreserved.Section4 pursues a speci.c direction in this \ndesign space, but generally we can produce analyses by using as context any abstractions com\u00adputablefromthe \narguments tofunctions &#38;merge (withap\u00ad record and &#38;propriate changes to the Context and HContext \nsets).Forinstance, &#38;&#38; we can use as context coarse-grained program location informa\u00adtion(moduleidenti.ers,packages, \nuser annotations) sincethese are uniquelyidenti.edby the currentprogram statementlabel, l.Simi\u00adlarly, \nwe can makedi.erent context choicesfordi.erent allocation sites or call sites,by de.ning the &#38;merge \nfunctions con\u00ad record and &#38;ditionally on the supplied label. In fact, there are few examples of context-sensitivepoints-to \nanalyses that cannot be captured by our framework, and simple extensions would su.cefor most of those. \nForinstance, a context-sensitivepoints-to analysis that employs as context astaticabstraction of thearguments \nof a method call(and notjustof the receiver object)iscurrently notdirectly expressible in ourformalism.(This \napproachhasbeenfruitfulindi.erent static analyses, e.g.,for typeinference[1,15].)Nevertheless, itis a \nsim\u00adple matterto adjusttheform ofthe &#38; merge functionandthe method invocation rulein order to allowthe \nmethodcall context to alsobe afunction of theheap contexts of argument objects. 3. InsightsonContextChoice \nWith the bene.t of our theoretical map of context choices for object-sensitivity, we next discuss what \nmakes a scalable and pre\u00adcise analysisinpractice. 3.1 Full-Object-Sensitivityvs.Plain-Object-Sensitivity \nThe .rst question in our work is how to select which context ele\u00adments to keep i.e., what is the best \nde.nition of the &#38; merge func\u00adtion for practical purposes. We already saw the two main distinc\u00adtions, \nin the form of full-object-sensitive vs. plain-object-sensitive analyses. Consider the standard case \nof a 2-object-sensitive anal\u00adysis with a 1-object-sensitive heap, i.e., per the standard naming convention, \nContext = HContext = Lab2. The 2full+1H analysis &#38;&#38; will examine every method using as context \nthe allocation site of the method s receiver object, and the allocation site of the alloca\u00adtor of this \nreceiver object.(Recall that allinformationfor method invocations under the same context willbe merged, \nwhileinforma\u00adtion under di.erentcontexts willbekept separate.) Incontrastthe 2plain+1H analysis examines \nevery method using as context the allocation site of the receiver object, and the allocation site of \nthe caller object. The 2full+1H analysis has not been implemented or evaluated inpracticebefore.Yetwith \nan understanding ofhow contextis em\u00adployed, there are strong conceptual reasons why one may expect 2full+1H \nto be superior to 2plain+1H. The insight is that context serves the purpose of yielding extra information \nto classify dy\u00adnamic paths, at high extra cost for added context depth. Thus, for contextto serveitspurpose,it \nneedstobe agood classi.er,splitting the space ofpossibilitiesin roughly uniformpartitions.When mix\u00ading \ncontext elements(allocation sitelabels) fromthe receiver and the caller object(asin the2plain+1H analysis), \nthe two context el\u00adements are likely to be correlated. High correlation means that a 2-object-sensitive \nanalysis is e.ectively reduced to a high-cost 1\u00adobject-sensitive one.In a simple case of context correlation, \nan ob\u00adjectcalls another method onitself:the receiver object andthe caller object arethe same.3There are \nmanymorepatterns of common ob\u00adjectcorrelation knowing that we are executing a method of object p almost \nalways yields signi.cant information about which object q is the receiver of a method call. Wrapper patterns, \nproxy pat\u00adterns, the Bridge design pattern, etc., all have pairs of objects that are allocated and used \ntogether. For such cases of related objects, one can see the e.ectinintuitive terms:The traditional mixed \ncon\u00adtext of a 2plain+1H analysis classi.es method calls by asking ob\u00adjects where were you born and where \nwas your sibling born? A 2full+1H analysisasks wherewereyoubornand wherewasyour parent born? The latter \nis a better di.erentiator, since birth loca\u00adtions of siblings are more correlated.  3.2 ContextDepth \nandAnalysisComplexity Thetheme ofcontext element correlation andits e.ect onprecision is generally important \nfor analysis design. The rule of thumb is that context elements should be as little-correlated as possible \nfor an analysis with high precision. To see this consider how context depth a.ects the scalability of \nan analysis.There are two opposing forces when contextdepthisincreased.On the onehand,increased precision \nmayhelp the analysis avoid combinatorial explosion.On the other hand, when imprecision will occur anyway, \na deeper context analysis willbe signi.cantlyless scalable. Forthe.rstpoint,considerthequestion whencanananalysis \nwith a deeper context outperform one with a shallower context? Concretely, are there cases when a 2-object-sensitive \nanalysis will be faster or more scalable than a 1-object-sensitive analysis (for otherwisethesame analysislogic,i.e.,bothplain-obj \norfull-obj)? Much of the cost of evaluating an analysis is due to propagating matching facts. Consider, \nfor instance, the Variable reference rule from our abstract semantics in Figure 4, which results in an \nevaluation of the form: s ' = s . [Sst(v) . s (Sst(v ' ))]. For this evaluation to be faster under a \ndeeper context, the lookup s (Sst(v ' )) should return substantially fewer facts, i.e., the analysis \ncontext should result in much higher precision. Speci.cally two conditions need to be satis.ed. First, \nthe more detailed context should partition the facts well: the redundancy should be minimal between partitions \nin context-depth-2 that would project to the same partition with context depth 1. Intuitively, adding \nan extra levelof context should not cause all(or many)factstobe replicated 3Thiscasecanbedetected staticallyby \ntheanalysis,and context repetition can be avoided. This simple .x alone is not su.cient for reliably \nreducing theimprecision of a2plain+1H analysis,however.  for all(or many)extra context elements.Second,fewerfacts \nshould be produced by the rule evaluation at context depth 2 relative to depth 1, when compared afterprojection \ndown to depth-1 facts.In other words, going to context depth 2 should be often enough to tell usthat \nsomeobjectdoesnotinfact .owtoacertain1-context\u00adsensitive variable,because the assignmentisinvalidgiven \nthe more precise contextknowledge. In case of imprecision, on the other hand, the deeper context will \nalmost always result in a combinatorial explosion of the pos\u00adsible facts and highly ine.cient computation. \nWhen going from a 1obj+H analysis to a2full+H or2plain+H, wehave every fact an\u00adalyzedin up to N times \nmore contexts(where N isthetotalnumber of context elements, i.e., allocation sites). As a rule of thumb, \nev\u00adery extra level of context can multiply the space consumption and runtime of an analysis by a factor \nof N, and possibly more, since the N-times-larger collections of facts need to be used to index in other \nN-times-largercollections,withindexing mechanisms(and possibly results) that may notbelinear. It is, \ntherefore, expected that an analysis with deeper context willperformquitewellwhenitmanagestokeepprecisefacts, \nwhile exploding in runtime complexity when the context is not su.cient to maintain precision. Unfortunately, \nthere are inevitable sources of imprecision in any real programming language these include re.ection(whichisimpossibletohandlesoundly \nandprecisely), static .elds(whichdefeatcontext-sensitivity),arrays,exceptions, etc. When this imprecision \nis not well-isolated and a.ects large parts of arealisticprogram,thepoints-to analysis will almost cer\u00adtainlyfail(within \nany reasonable time and spacebound). Thispro\u00adduces a scalability wall e.ect: a given analysis on a program \nwill eitherterminatequickly orwillfail toterminate ever (inpracti\u00adcal terms).Input characteristics of \ntheprogram(e.g.,size metrics) are almost never good predictors of whether the program will be easy to \nanalyze, as this property depends directly on the induced analysisimprecision. The challenge then becomes \nwhether we can maintain high precision while reducingthepossibilityfor a combinatorialblowup of analysis \nfacts due to deeper context. We next introduce a new approach in thisdirection. 4. Type-Sensitivity Ifan \nanalysis with adeeper contextby nature resultsin a combina\u00adtorial explosion in complexity, then a natural \nstep is to reduce the base of the exponential function. Context elements in an object\u00adsensitive analysis \nare object allocation sites, and typical programs have too many allocation sites, making the product \nof the number of allocation sites toohigh.Therefore, a simpleideafor scalability is to use coarser approximations \nof objects as context, instead of complete allocation sites.This would collapse thepossible combi\u00adnationsdown \nto a more manageable space,yieldingimproved scal\u00adability.The most straightforward static abstractionthat \ncan approx\u00adimate an objectis a type, whichleads to ouridea ofa type-sensitive analysis. 4.1 De.nitionofType-SensitiveAnalysis \nA type-sensitive analysis is almost identical to an object-sensitive analysis, but whereas an object-sensitive \nanalysis would keep an allocation site as a context element, a type-sensitive analysiskeeps a type instead.4 \nConsider, for instance, a 2-type-sensitive analysis with a1-type-sensitiveheap(henceforth 2type+1H ).The \nmethod context for this analysis consists of two types.(For now wedo not care whichtypes.Wediscusslater \nwhattypesyieldhighprecision.) 4Despite the name similarity, our type-sensitive points-to analysis has \nno relationshiptoReppy s type-sensitivecontrol-.owanalysis [16],which usestypesto.ltercontrol .owfactsinacontext-insensitiveanalysis. \nExpressedin ourframework, the2type+1H analysishas: &#38; HContext = Lab \u00d7 ClassName &#38; Context = ClassName2. \nNoteagainthecontrastof thestandard convention of thepoints-to analysis community andthestructure of abstractions:the2type+1H \nanalysis also includes an allocation site label in the static abstrac\u00adtion of an object this aspect is \nconsidered so essential that it is not re.ected on the analysis name. Approximating the allocation site \nof the objectitselfby a type wouldbepossible,butdetrimental forprecision. Generally, type-contexts and \nobject-contexts can be merged at any level, as long as the &#38; merge function can be de.ned. An in\u00adteresting \nchoice is an analysis that merely replaces one of the two allocation sites of2full+1Hwith atype, whileleaving \nallthe rest of the context elementsintact.We call this a1-type-1-object-sensitive analysis with a 1-object-sensitive \nheap, and shorten the name to 1type1obj+1H .Thatis, a1type1obj+1H analysishas: &#38; HContext = Lab2 \n&#38; Context = Lab \u00d7 ClassName. The 2type+1H and the 1type1obj+1H analyses are the most practically \npromising type-sensitive analyses with a context depth of 2. Their context-manipulation functions can \nbe described with thehelp of an auxiliaryfunction T : Lab . ClassName, which retrieves a typefrom an \nallocation sitelabel.For2type+1H, the contextfunctionsbecome:5 &#38; record(l,c = [C1,C2])= [l,C1] merge&#38;(l, \nhc S= [l ' ,C],c )= [T(l ' ),C], whilefor1type1obj+1H, the twofunctions are: &#38; record(l,c = [l ' \n,C])= [l,l ' ] merge&#38;(l, hc S= [l1,l2],c )= [l1,T(l2)], In other words,thetwo analyses are variations \nof2full+1H(and not of 2plain+1H), with some of the context information down\u00adgraded tobe typesinstead \nof allocation sitelabels.Thefunction T makes opaque the method we use to produce a type from an allo\u00adcation \nsite, which wediscuss next.  4.2 ChoiceofTypeContexts Just having a type as a context element does not \ntell us how good the context willbefor ensuringprecision the choice of typeis of paramount importance. \nThe essence of understanding what consti\u00adtutes a good type context is the question what does an allocation \nsite tell us about types? After all, we want to use types as a coarse approximation of allocation sites, \nso we want to maintain most of theinformation that allocation sitesimply regarding types. Theidentity \nof anallocationsite,i.e.,aninstruction new A() inside class C,gives us: thedynamic type A of the allocated \nobject  an upper bound C on the dynamic type of the allocator object. (Since the allocation site occurs \nin a method of class C, the allocator object must be of type C or a subclass of C that does not override \nthe method containing the allocation site.)  5We use common list and pattern-matching notation to avoid \nlong expres\u00ad &#38; sions.E.g., record(l,c = [C1,C2]) means when the second argument, c, of &#38; record \nis alist of two elements, C1 and C2... .  A straightforward option would be to de.ne the T function \nto returnjustthetype of the allocation site,i.e.,type A above. This isanawfuldesigndecision,however.Toseewhy,consider \n.rstthe case of a 2type+1H analysis. When we analyze a method context\u00adsensitively and the .rst element \nof the context is the type of the receiver object, we are e.ectively wasting mostof thepotential of the \ncontext. The reason is that the method under analysis already gives us enoughinformation aboutthetype \nofthe receiver object i.e., the identity of the method and the type of the receiver are closely correlated. \nIf, for instance, the method being analyzed is B::foo (i.e., method foo de.nedin classB)then we alreadyhave \na tight upper bound on the dynamic type of the receiver object: the receiver object s type has to be \neither B or a subclass of B that does not override method foo. Since we want to pick a context thatisless \ncorrelated with otherinformation andyields meaningful distinctions, a2type+1Hanalysis shouldhaveits T \nfunction return the typein which the allocation takesplace,i.e., class C above. A similar argument applies \nto a1type1obj+1H analysis.Inthis analysis the method context consists of the receiver object, as well \nas a type. We want 1type1obj+1H to be a good approximation of 2full+1H,whichwouldkeeptwo allocation sitesinstead(that \nofthe receiver object and that of the receiver object s allocator object). Thus the two allocation sites \nof 2full+1H give us the following information about types: thedynamic type of the receiver object  \nan upper bound on the dynamic type of the receiver object s allocator object  thedynamic type of the \nreceiver object s allocator object  an upper bound on the dynamic type of the receiver object s allocator \ns allocator object.  The .rsttwopiecesofinformation,above,comefromtheiden\u00adtity of the receiver object \ns allocation site, and, thus, arekeptintact in a 1type1obj+1H analysis. The question is which of the \nlast two types we wouldliketokeep.Thehigh correlation ofthe second and thirdbulletpointabove(upperbound \nof atypeand thetypeitself) makes it clear that we want tokeep the type of thelastbullet.That is,in all \nscenarios, the function T(l), whenl represents aninstruc\u00adtion new A() inside class C, should return type \nC and not type A. We validate this understanding experimentally aspart ofthe results of the next section. \n5. ImplementationandEvaluation We implemented and evaluated several object-sensitive analyses for a context \ndepth up to 2, which meets the limit of practicality for real-worldprograms.Thequestions we want to answer \nrelateto the main newideaspresented sofar: Is full-object-sensitivity advantageous compared to plain\u00adobject-sensitivity \nin terms ofprecision and performance, as ar\u00adguedinSection3.1?(Recall thatfull-object-sensitive analyses \nhad notbeen implemented in thepast for context depthgreater than1.)  Does the de.nition of function \nT matter, as predicted in Sec\u00adtion4.2?  Does type-sensitivity achieve higher scalability than regular \nobject-sensitive analyses while maintaining most of the preci\u00adsion?  5.1 Setting Ourimplementationisinthe \ncontextoftheDoop framework[2,3]. Doop uses the Datalog language to specify analyses declaratively. Additionally,Doop \nemploys an explicit representation of relations, listing all the elements of tuples of related elements \nexplicitly, as opposedto employingBinaryDecisionDiagrams(BDDs), which have often been used in points-to \nanalysis [7, 8, 22, 23]. As we showedin earlier work[3]BDDs are only useful whenthe selected context \nabstractionsintroducehigh redundancy, while analysesthat take care to avoid unnecessary imprecision are \nsigni.cantly faster and scalablein an explicit representation.Doop is ahighly scalable framework and \nimplements very e.ciently the most complex and precise context-sensitive analysesin currentuse[3].Doop \nachieves functional equivalence(identical results) withLhot\u00b4ak andHen\u00addren sPaddle system[8], which is \nanother feature-richframework forprecise analyses, butbased on an entirelydi.erent architecture (usingsemi-declarative \nanalysis speci.cations andBDDs to repre\u00adsent relations).This equivalence of resultsis usefulfor establishing \nthat an analysis is correct and meaningful, which is a property far fromgrantedfor complexpoints-to analysis \nalgorithms. We use a64-bitmachine with aquad-coreXeonE55302.4GHz CPU(onlyonethread was active at atime).The \nmachinehas24GB of RAM, but we have found no analysis that terminates (within twohours,but also occasionally \nallowing upto12) after occupying more than12GB of memory.Most analyses requireless than2GB, with only \nthe longest running analyses (over 1000 seconds run time) occasionally needing morememory.Thisisindicativeof \nthe scalability walldescribed earlier:the explosion of contexts without a correspondingincreaseinprecision \nmakes an analysisintractable quite abruptly. We analyzed the DaCapo benchmark programs, v.2006-10-MR2, \nwith JDK 1.4 (j2re1.4.2 18). These benchmarks are the largestin theliterature on context-sensitivepoints-to \nanalysis. We analyzed allbenchmarks except hsqldb andjython with the full Doop functionality and support \nfor language features, includ\u00adingnative methods, re.ection(a re.nement ofLivshits et al. s algo\u00adrithm[11] \nwith supportfor re.ectively invoked methods and con\u00adstructors), andprecise exceptionhandling[2].Generally \nour set\u00adtings are a superset(i.e., more completefeature support) thanprior published benchmarks on Doop \n[2, 3].(The Doop language fea\u00adture support is among the most complete in the literature, as doc\u00adumentedindetailinthepast[3].) \nHsqldb andjython could notbe analyzed with re.ection analysis enabled hsqldb cannot even be analyzed \ncontext-insensitively andjython cannot even be analyzed with the 1obj analysis. This is due to vast imprecision \nintroduced when re.ection methods are not .ltered in any way by constant strings (for classes, .elds, \nor methods) and the analysis infers a largenumberofre.ectionobjectsto .owtoseveral variables.(E.g., in \nthe theoreticallyworst case244 sitesinjython canbeinferred to allocate over 1.1 million abstract objects.) \nFor these two applica\u00adtions, our analysis has re.ection reasoning disabled. Since hsqldb intheDaCapobenchmarkcodehasits \nmainfunctionality called via re.ection, wehad to con.gureits entrypoint manually.  5.2 Full-object-sensitivityvs.Plain-object-sensitivity \nFigure 5 shows the precision comparison of a 2plain+1H and a 2full+1H analysis for a subset of the DaCapo \nbenchmarks. For reference, we also include a context-insensitive, 1-object-sensitive and1obj+1Hanalysis, \nandindicatehowthe metricschangefrom an analysis to the next moreprecise one.The metrics are a mixture \nof corepoints-to statistics and client analysis metrics, resembling the methodology ofLhot\u00b4ak andHendren[8].For \nease of reference, we highlight(inbold)some of the mostimportant metrics: the number of methods inferred \nto be reachable (including both application methods and methodsinthe standardJavalibrary),the average \nvar\u00adpoints-toset(i.e.,howmany allocationsitesavariablecanrefer to),thetotal number of call sitesthatarefound \ntobepolymorphic (i.e.,for whichthe analysis cannotpinpoint a single method as the target of the dynamic \ndispatch), and the total number of casts that  insensitive 1obj 1obj+H 2plain+1H 2full+1H     call-graph \nedges 43055 -559 -1216 -1129 -368 reachable methods 5758 -29 -37 -62 -21 total reachable virtual call \nsites 27823 -128 -96 -272 -139 1326 -38 -22 -38 -68 16393 0 0 0 -9 851 0 0 0 0 total reachable casts \n 1038 -14 -15 -33 -6 total casts that may fail 844 -136 -94 -144 -64 application reachable casts 308 \n0 0 0 -1 application casts that may fail 262 -8 -38 -66 -23 pmd luindex eclipse chart antlr average \nvar-points-to 216.71 24.7 15.1 8.5 8.2 average application var-points-to 327.27 20.8 15.3 8.8 8.5  \n  call-graph edges 44930 -1239 -2063 -2287 -765 reachable methods 8502 -76 -87 -115 -53 total reachable \nvirtual call sites 23944 -233 -327 -368 -172 total polymorphic call sites 1218 -90 -24 -83 -119 application \nreachable virtual call sites 3649 0 -8 -47 -12 application polymorphic call sites 110 -4 -13 -10 -4 \ntotal reachable casts 1728 -22 -38 -58 -7 total casts that may fail 1457 -182 -252 -164 -120 application \nreachable casts 232 0 -4 -21 -1 application casts that may fail 196 -17 -64 -32 -38 average var-points-to \n98.35 36.0 20.1 9.4 6.7 average application var-points-to 55.35 27.2 14.4 5.0 2.8   call-graph edges \n 36057 -1342 -2499 -1900 -803 reachable methods 6541 -67 -153 -83 -49 total reachable virtual call sites \n 18447 -291 -315 -356 -226 total polymorphic call sites 873 -96 -25 -38 -89 application reachable virtual \ncall sites 5959 -101 -53 -31 -44 application polymorphic call sites 292 -40 -9 -3 -3 total reachable \ncasts 1270 -21 -21 -27 -24 total casts that may fail 1001 -213 -103 -133 -51 application reachable \ncasts 476 -3 -2 -8 0 application casts that may fail 362 -61 -55 -58 1 average var-points-to 102.7 \n21.8 16.1 9.8 9.1 average application var-points-to 104.1 22.9 15.8 9.6 9.4   call-graph edges 24069 \n-663 -1155 -1119 -354 reachable methods 4742 -31 -34 -64 -20 total reachable virtual call sites 12675 \n-193 -117 -276 -130 total polymorphic call sites 507 -50 -22 -38 -66 application reachable virtual call \nsites 1267 -65 -29 -4 0 application polymorphic call sites 39 -10 0 0 0 total reachable casts 790 \n-14 -15 -33 -5 total casts that may fail 627 -129 -69 -96 -43 application reachable casts 63 0 -1 0 \n0 application casts that may fail 46 -3 -18 -13 -2 average var-points-to 69.66 14.7 10.8 6.5 6.3 average \napplication var-points-to 90.05 9.2 5.9 3.0 2.9   call-graph edges 30990 -527 -1329 -809 -1043 reachable \nmethods 6158 -34 -44 -37 -62 total reachable virtual call sites 16029 -144 -163 -208 -280 total polymorphic \ncall sites 576 -42 -26 -21 -107 application reachable virtual call sites 4545 -22 -87 -5 -83 application \npolymorphic call sites 93 -2 -10 -4 -24 total reachable casts 1260 -15 -15 -13 -27 total casts that \nmay fail 1066 -137 -97 -94 -78 application reachable casts 531 -2 -2 0 -2 application casts that may \nfail 485 -11 -43 -32 -21 average var-points-to 88.08 22.3 15.8 8.2 7.3 average application var-points-to \n 102.3 29.7 26.1 8.5 8.0    Figure5. Precision metricsfor2plain+1H and2full+1Hforasubset of theDaCapobenchmarks.Thelasttwometrics( \naverage ... ) arein absolute numbers, the rest aregiven relative to the immediatelypreceding column(not \nrelative to the numbers in the insensitive column). All metrics are end-user(i.e., context-insensitive) \nmetrics.Var-points-tois the main relation of apoints-to analysis,linking a variable to the allocationsitesit \nmay bereferring to.(Theaverageisovervariables.) Reachablemethods isthesameascall-graph nodes,hencethe.rst \ntwometricsshowhowpreciseistheon-the-.yinferred call-graph. Polymorphiccall-sites arethoseforwhichtheanalysiscannot \nstatically determineauniquereceivermethod. Caststhat mayfail arethoseforwhich theanalysiscannot staticallydeterminethatthey \naresafe. mayfail at run-time(i.e.,for whichthe analysis cannot statically determine that the castis \nalways safe).These metricspaint afairly complete picture of relative analysis precision, although the \nrest of the metrics are usefulforframing(e.g.,for examininghowthe statistics varybetween application \nclasses and systemlibraries,for comparing to the total number of reachable call sites, etc.). As can \nbe seen in Figure 5, 2full+1H is almost always signif\u00adicantly more precise than 2plain+1H, even though \nboth analyses have the same context depth. The di.erence in precision is quite substantial:For several \nmetrics andprograms(e.g., multiple met\u00adricsforpmd, or reductionin totalpolymorphic virtual call sitesfor \nmanyprograms), thedi.erencebetweenfull-object-sensitivity and plain-object-sensitivity is as large as \nany other single-step incre\u00admentinprecision(e.g.,from1-obj to1obj+H). Perhaps most impressively, this \nprecision is accompanied by substantially improved performance. Figure 6 shows the running time of the \nanalyses, together with two key internal complexity metrics: the number of edges in the context-sensitive \ncallgraph (i.e.,howmanycontext-quali.ed methods areinferred tocallhow many other context-quali.ed methods) \nand the size of the context\u00adsensitive var-points-to set, i.e., the total number of facts inferred that \nrelate a context-quali.ed variable with a context-quali.ed al\u00adlocation site. The running time of 2full+1H \nis almost always much lower than that of 2plain+1H. The case of chart is most striking, with 2full+1H \n.nishing in well under a third of the time of 2plain+1H, while achieving the much higher precision shown \nin Figure 5. The internal metrics show that 2full+1H makes excellent use of its context and has substantially \nlower internal complexity than 2plain+1H.Note that the statisticsfor context-sensitive var-points\u00adto \nare quite low, explaining why the analysis is faster, since each variable needstobe examined onlyin a \nsmaller number of contexts. A second reason why such internal metrics are important is that theperformance \nof ananalysisdepends very much onalgorithmic and data structure implementation choices, such as whether \nBDDs are used to represent large relations. Internal metrics, on the other hand, are invariant and indicate \na complexity of the analysis that often transcends representation choices. It is easy to see from the \nabove .gures that full-object\u00adsensitivity makes a muchbetter choice of contextthanplain-object\u00adsensitivity, \nresulting in both increased precision and better perfor\u00admance. Infact, wehave found the 2full+1H analysis \ntobe a sweet spot in the current set of near-feasible analyses in terms of preci\u00adsion. Adding an extra \nlevel of context sensitivity for object .elds, yielding a2full+2H analysis, adds extremely littleprecision \nto the analysis results whilegreatlyincreasing the analysis cost. In fact, for the benchmarks shown, \n2full+1H is even signi.\u00adcantly faster than the much lessprecise 1obj+H. Nevertheless, the same is not \ntrue universally. Of the 10 DaCapo benchmarks in our evaluation set, 2full+1H handles 6 with ease (the \n5 shown plus lusearch which has very similar behavior to luindex ) but its running time explodes for \nthe other4. The2plain+1H analysis ex\u00adplodes at least as badly for the 4 benchmarks, but a 1obj+H anal\u00adysis \nhandles 9 out of 10, and a 1-obj analysis handles all of them. In short, the performance (and internal \ncomplexity) of a highly\u00adprecise but deep-context analysis is bimodal: when precision is maintained,theanalysisperforms \nadmirably.When,however,sig\u00adni.cant imprecision creeps in, the analysis does badly, since the number of \ncontextsincreasesin combinatorialfashion. Therefore, 2full+1H achieves excellent precision but is not \na goodpointinthedesign spaceintermsof scalability.(Inthepast, the only fully scalable uses of object-sensitivity \nwith depth > 1 have applied deep context to a small, carefully selected subset of allocation sites; we \nare interested in scalability when the whole programis analyzedwiththeprecision ofdeep context.)Thisisthe \nshortcomingthat we expectto address withtype-sensitive analyses.  5.3 ImportanceofTypeContextChoice \nInSection4.2 we arguedthat,forjudicious use ofthe extra con\u00adtext element, function T has to be de.ned \nso that it returns the enclosing type of an allocation site and not the type that is be\u00ading allocated. \nExperimentally, this is very clearly the case. Fig\u00adure7demonstrates thisfortwo of ourbenchmarkprograms(the \nalphabetically .rst and last, which are representative of the rest). 1obj+H is shown as a baseline, to \nappreciate the di.erence. With the wrong typecontext,a1type1obj+1H analysisisfar more ex\u00adpensive andbarely \nmoreprecise than1obj+H, while with the right type context the analysisisimpressively scalable andprecise(very \nclose to2full+1H, as we showlater). As can be seen, the impact of a good context is highly signif\u00adicant,bothfor \nscalability(in terms of time andinternal metrics) andforprecision.Inoursubsequentdiscussion weassumethatall \ntype-sensitive analyses use the superior context, asde.ned above.  5.4 Type-SensitivityPrecisionandPerformance \nWe found that type-sensitivity fully meets its stated goal: it yields analyses that are almost as precise \nas full-object-sensitive ones, while being highly scalable. In fact, type-sensitive analyses seem to \nclearly supplant other current state-of-the-art analyses e.g., both 2type+1H and 1type1obj+1H seem overwhelmingly \nbetter than 1obj+H in both precision and performance for most of our benchmarks and metrics. Our experiment \nspace consists of the four precise analyses that appear feasible or mostly-feasible with current capabilities: \n1obj+H,2type+1H,1type1obj+1H, and2full+1H.Figure8 shows the results of our evaluation for 8 of the 10 \nbenchmark programs. (Thereis some replication ofnumbers compared totheprevious ta\u00adbles,but thisislimitedto \ncolumnsincluded asbaselines.)We omit lusearch for layout reasons, since it behaves almost identically \nto luindex.Wediscussthe .nalbenchmark,hsqldb,intext,butdonot listitonthetablebecause2type+1Histhe onlyofthefour \nanalyses that terminates onit. Notethatthe .rsttwoanalyses(1obj+H,2type+1H)are seman\u00adtically incomparable \nin precision but every other pair has a prov\u00adably more precise analysis, so the issue concerns the amount \nof extra precision obtained and the running time cost. Speci.cally, 2full+1Hisguaranteedtobe moreprecisethanthe \notherthree anal\u00adyses, and 1type1obj+1H is guaranteed to be more precise than ei\u00adther1obj+H or2type+1H. \nThe trendsfrom our experiments arequite clear: Althoughthereis noguarantee,2type+1His almostalways more \nprecise than 1obj+H, hence the 2type+1Hprecision metrics(re\u00adportedin the table relative to theprecedingcolumn,i.e.,1obj+H) \nare overwhelmingly showing negative numbers(i.e., animprove\u00adment). Additionally, 2type+1H is almost always \n(for 9 out of 10 programs) the fastest analysis in our set. In all but one case, 2type+1H is several \ntimes faster than 1obj+H e.g., 5x faster or more for 4 of the benchmarks. The clear improvement of 2type+1H \nover 1obj+H isperhaps the most important of our ex\u00adperimental .ndings. Recall that 1obj+H is currently \nconsidered the sweetspot ofprecisionand scalabilityinpractice: ahighly precise analysis, that is still \nfeasible for large programs without exploding badlyin complexity.  2type+1H achievesgreat scalability \nforfairlygoodprecision.It is the only analysis that terminates for all our benchmark pro\u00adgrams. It typically \nproduces quite tight points-to sets, with antlr being a signi.cant exception that requires more examination. \nIn terms of client analyses and end-user metrics,theincreaseinpre\u00ad   insensitive 1obj 1obj+H 2plain+1H \n2full+1H time (sec) lr 86.5 134.0 427.4 236.9 161.1 context-sensitive callgraph edges (thousands) ant \n1,484 966 1,428 2,458 context-sensitive var-points-to (thousands) 13,143 8,147 49,237 24,980 9,279 time \n(sec) rt 72.2 380.2 1199.2 2496.0 688.2 chacontext-sensitive callgraph edges (thousands) 1,463 1,087 \n9,564 7,469 context-sensitive var-points-to (thousands) 7,054 19,942 83,354 107,221 22,854 time (sec) \nse 67.2 228.0 826.0 502.0 480.4 eclipcontext-sensitive callgraph edges (thousands) 1,921 1,278 2,103 \n5,341 context-sensitive var-points-to (thousands) 5,754 9,962 64,586 65,435 22,574 time (sec) ex 37.9 \n63.2 179.3 123.9 124.3 luindcontext-sensitive callgraph edges (thousands) 384 324 779 1,227 context-sensitive \nvar-points-to (thousands) 2,737 2,781 16,968 9,576 5,072 time (sec) d 57.7 120.0 293.7 392.6 160.0 pmcontext-sensitive \ncallgraph edges (thousands) 553 418 3,610 1,614 context-sensitive var-points-to (thousands) 4,392 5,314 \n24,902 35,628 6,770 Figure6. Performance andcomplexity metricsfor object-sensitive analyses.2full+1His \nalmostalwaysfasterthan2plain+1H(some striking cases arehighlighted).Additionally,2full+1Hmakesgood use \nof context andhas often substantiallylowerinternal metrics than2plain+1H, and typically even than1obj+H. \n1obj+H 1type1obj+1H  1obj+H 1type1obj+1H bad context good context bad context good context call-graph \nedges 41280 -329 -1124 call-graph edges 35908 -408 -1290 reachable meths 5692 -3 -78 reachable meths \n7237 -2 -86 reachable v-calls 27599 -2 -404 reachable v-calls 19828 -2 -389 poly v-calls 1266 -51 -27 \npoly v-calls 1175 -52 -51 reach. v-calls in app 16393 0 -9 reach. v-calls in app 7709 0 0 poly v-calls \nin app 851 0 0 poly v-calls in app 726 -2 -6      reachable casts 1009 -1 -38 reachable casts \n1264 -1 xalan antlr casts that may fail 614 -4 -157 casts that may fail 668 -5 reach. casts in app \n308 0 -1 reach. casts in app 501 0 casts in app may fail 216 0 -61 casts in app may fail 250 -4 -23 \navg var-points-to  15.14 10.62 8.19 avg var-points-to 14.94 14.03 9.57 avg app var-points-to 15.25 \n9.02 8.51 avg app var-points-to 15.73 15.14 11.58 time (sec) 427.4 376.7 114.2 time (sec) 979.9 4398.9 \n831.0 c-s callgraph edge (K) 965 816 960 c-s callgraph edge (K) 936 4915 2580 c-s var-points-to (K) \n49237 43030 7459 c-s var-points-to (K) 96021 163916 38205        Figure 7. Precision, performance, \nand internal complexity metrics for a type-object-sensitive analysis with a good and a bad choice of \ncontext.TheentriesarethesameasinFigures5 and6,with metricnames condensed.AsinFigure5,allbutthelasttwoprecisionmetrics \nare reported as di.erences relative to the immediately preceding column(i.e.,we are showinghow much moreprecisionthegood \ncontext yields over the alreadyhigherprecision ofthebad context, not over thebaseline). cisiongoing from1obj+H \nto2type+1H is oftengreater than that of going from 2type+1H to 2full+1H. Overall, 2type+1His an excellent \napproximation of2full+1Hgivenitslow cost. Although not shown on the table, 2type+1H is not just faster \nthan the three shown analyses but also faster than 1obj, for 7 out of 10 benchmark programs. The di.erence \nin precision between the two analyses is enormous, however. A good example is the hsqldb benchmark, omitted \nfrom Figure 8 since 2type+1H is the only analysis with a context-sensitive heap that terminates for it. \n2type+1Hprocesseshsqldb slightlyfasterthan1obj(404secin\u00adstead of464sec).At the same time, allprecision \nmetrics aredras\u00adtically better.Thepoints-to sets are almost half the size(11.3 to\u00adtal vs.22.1, and13.2for \napplication vars only vs.18.2).On other precision metrics the di.erence between 2type+1H and 1obj is \nmuch greater than that between 1obj and a context-insensitive analysis. For application casts that may \nfail alone, 2type+1obj eliminates117instances relative to1obj.  1type1obj+1Hishighlyprecise anditsdi.erencefrom2full+1H \nisrarely signi.cant.(Itisilluminatingtoaddthetwocolumns and compare the cumulative di.erence of 1type1obj+1H \nfrom 1obj+1H, relative to thedi.erence of theformerfrom2full+1H.)  At the same time, 1type1obj+1H avoids \nmany of the scalability problems of 2full+1H:itterminates on8 of10benchmarks(in\u00adstead of6 out of10) andis \nalwaysfasterthan2full+1H,occasion\u00adally(e.g., chart)by a signi.cantfactor. 6. Conclusions In this paper \nwe strove for a better understanding of the concept of object-sensitivity in points-to analysis. Our \nexploration led to a precise formal modeling, to a complete mapping of past object\u00adsensitive analyses \nin the literature, as well as to insights on how context a.ectstheprecision and scalability of an analysis.One \ncon\u00adcrete outcome ofour workisto establishfull-object-sensitivity(and especially a2full+1Hanalysis)as \na superior choice ofcontext com\u00adpared to others inpastliterature.Additionally, wehave introduced the \nconcept of type-sensitivity and applied our insights to pick an appropriate typeto use as context of \napoints-to analysis.The result isa range ofanalyses, especially2type+1Hand1type1obj+1H,that have very \ngood to excellent scalability, while maintaining most of theprecision of a much more expensive analysis.The \nnew analyses weintroduced arecurrentsweet spotsinthedesignspaceand rep\u00adresent asigni.cant advancement \nof thestate-of-the-artinpoints-to analysis.  1obj+H 2type 1type 2full 1obj+H 2type 1type 2full +1H \n1obj+1H +1H +1H 1obj+1H +1H time (sec) 427.4 78.8 114.2 161.1 time (sec) 1215.7 2107.6 c-s callgraph \nedge (K) 966 512 960 2,458 c-s callgraph edge (K) 923 4,399 c-s var-points-to (K) 49,237 4,029 7,459 \n9,279 c-s var-points-to (K) 110,113 53,552 call-graph edges 47792 -1797 -489 call-graph edges 22251 -1368 \n-63 -42 reachable meths 6945 -85 -12 reachable meths 4677 -78 -4 -2 reachable v-calls 25220 -404 -18 \nreachable v-calls 12365 -400 -1 -5 poly v-calls 1406 -82 -85 poly v-calls 435 -66 -12 -26 reach.v-calls \nin app 13879 -20 0 reach. v-calls in app 1173 -4 0 0 poly v-calls in app 953 -28 -58 poly v-calls in \napp 29 4 -4 0 reachable casts 2062 -43 -2 reachable casts ex 761 -38 0 0 casts that may fail 1546 -45 \n-120 luindcasts that may fail 429 -54 -66 -19 reach. casts in app 1346 -2 0 reach. casts in app 62 0 \n0 0 casts in app may fail 1134 13 -70 casts in app may fail 25 3 -18 0 avg var-points-to 32.5 21.8 18.6 \navg var-points-to 10.8 7.8 6.4 6.3 avg app var-points-to 42.6 31.9 29.1 avg app var-points-to 5.9 4.2 \n2.9 2.9 time (sec) 2307.2 432.7 2431.0 time (sec) 179.3 67.7 80.8 124.3 c-s callgraph edge (K) 1,791 \n1,036 3,196 c-s callgraph edge (K) 324 473 656 1,227 c-s var-points-to (K) 73,527 10,375 43,073 c-s var-points-to \n(K) 16,968 2,848 3,892 5,072 call-graph edges 41628 -2776 -191 -85 call-graph edges 29134 -1720 -52 -80 \nreachable meths 8339 -133 -27 -8 reachable meths 6080 -86 -5 -8 reachable v-calls 23384 -491 -39 -10 \nreachable v-calls 15722 -475 -1 -12 poly v-calls 1104 -155 -20 -27 poly v-calls 508 -83 -8 -37 reach. \nv-calls in app 3641 -30 -29 0 reach. v-calls in app 4436 -84 0 -4 poly v-calls in app 93 -8 -6 0 poly \nv-calls in app 81 -17 0 -11 reachable casts 1668 -55 -10 0 pmd reachable casts 1230 -40 0 0 casts that \nmay fail 1023 -39 -199 -46 casts that may fail 832 -63 -75 -34 reach. casts in app 228 -15 -7 0 reach. \ncasts in app 527 -2 0 0 casts in app may fail 115 3 -66 -7 casts in app may fail 431 -12 -26 -15 avg \nvar-points-to 20.1 8.5 6.8 6.7 avg var-points-to 15.8 8.8 7.3 7.3 avg app var-points-to 14.4 4.0 2.8 \n2.8 avg app var-points-to 26.1 8.9 8.0 8.0 time (sec) 1199.2 143.2 199.0 688.2 time (sec) 293.7 78.2 \n128.1 160.0 c-s callgraph edge (K) 1,087 974 1,252 7,469 c-s callgraph edge (K) 418 527 1,043 1,614 c-s \nvar-points-to (K) 83,354 6,572 9,093 22,854 c-s var-points-to (K) 24,902 3,370 5,901 6,770 call-graph \nedges 32216 -2575 -86 -42 call-graph edges 35908 -1553 -145 reachable meths 6321 -127 -4 -1 reachable \nmeths 7237 -65 -23 reachable v-calls 17841 -577 -1 -4 reachable v-calls 19828 -355 -36 poly v-calls 752 \n-77 -24 -26 poly v-calls 1175 -88 -15 reach. v-calls in app 5805 -74 -1 0 reach. v-calls in app 7709 \n35 -35 poly v-calls in app 243 3 -7 -2 poly v-calls in app 726 -1 -7 reachable casts 1228 -51 0 0 reachable \ncasts n 1264 -34 -4 casts that may fail 685 -58 -98 -28 xalacasts that may fail 668 21 -149 reach. casts \nin app 471 -8 0 0 reach. casts in app 501 4 -4 casts in app may fail 246 -5 -44 -8 casts in app may \nfail 250 52 -79 avg var-points-to 16.1 11.8 9.1 9.1   avg var-points-to 14.9 12.1   9.6 Figure8. \nPrecision,performance, andinternal complexity metricsforprecise analyses.The entries are the same asinFigures5 \nand6, with metric names condensed.AsinFigure5, allbutthelasttwoprecision metrics are reported asdi.erences \nrelativetothe immediatelypreceding column.Empty entries aredue to non-termination after2hours of running \ntime.Some of the mostinteresting metrics arehighlighted.       call-graph edges 41280 -1401 -52 \n -44 call-graph edges 30370 -2091 reachable meths 5692 -77 -4 -2 reachable meths 5754 -118 reachable \nv-calls 27599 -405 -1 -5 reachable v-calls 16057 -830 poly v-calls 1266 -70 -8 -28 poly v-calls 768 \n-71 reach.v-calls in app 16393 -9 0 0 reach. v-calls in app 7146 -492 poly v-calls in app 851 0 0 0 \npoly v-calls in app 422 0 reachable casts 1009 -39 0 0 jython reachable casts 1272 -18 eclipse chart \nbloat antlr casts that may fail 614 -104 -57 -47 casts that may fail 741 -11 reach. casts in app 308 \n-1 0 0 reach. casts in app 677 0 app casts may fail 216 -53 -8 -28 casts in app may fail 445 17 avg \nvar-points-to  15.1 23.0 8.2 8.2 avg var-points-to 21.2 19.1 avg app v-points-to  15.3 41.7 8.5 8.5 \navg app var-points-to 30.7 31.4    Acknowledgments Wethank theanonymous reviewersfortheirhelpful \ncomments,as well asMattMight andDavidVanHornforinterestingdiscussions. This work was funded by the National \nScience Foundation under grantsCCF-0917774 andCCF-0934631, aswell asby theNatural Sciences andEngineeringResearchCouncil \nofCanada. References [1] Ole Agesen. The cartesian product algorithm: Simple and precise type inference \nof parametric polymorphism. In Proceedings of the 9th European Conference on Object-Oriented Programming, \npages 2 26, London, UK, 1995. Springer-Verlag. [2] MartinBravenboer andYannisSmaragdakis. Exception anal\u00adysis \nand points-to analysis: Better together. In Laura Dillon, editor, ISSTA 09: Proceedings of the 2009 International \nSymposium onSoftwareTesting andAnalysis,NewYork,NY, USA,July2009. [3] Martin Bravenboer and Yannis Smaragdakis. \nStrictly declarative speci.cation of sophisticated points-to analyses. In OOPSLA 09: 24th annual ACM \nSIGPLAN conference on Object Oriented Programming, Systems, Languages, and Applications,NewYork,NY,USA,2009.ACM. \n[4] Patrick Cousot and Radhia Cousot. Abstract interpretation: a uni.ed lattice model for static analysis \nof programs by construction or approximation of .xpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN \nsymposium on Principles ofprogramming languages,POPL 77,pages238 252,New York,NY,USA,1977.ACM. [5] Stephen \nFink, Eran Yahav, Nurit Dor, G. Ramalingam, and Emmanuel Geay. E.ective typestate veri.cation in the \npresence of aliasing. In ISSTA 06: Proceedings of the 2006 international symposium on Software testing \nand analysis, pages133 144, NewYork,NY,USA,2006.ACM. [6] Atsushi Igarashi, Benjamin C. Pierce, and Philip \nWadler. FeatherweightJava: a minimal core calculusforJava and GJ. ACMTrans.Program.Lang.Syst.,23(3):396 \n450, 2001. [7] Ond.rej Lhot\u00b4ak. Program Analysis using Binary Decision Diagrams. PhD thesis,McGillUniversity,January2006. \n[8] Ond.rej Lhot\u00b4ak andLaurieHendren. Evaluating thebene.ts of context-sensitive points-to analysis using \na BDD-based implementation. ACMTrans.Softw.Eng.Methodol.,18(1):1 53,2008. [9] Ond.rejLhot\u00b4akandLaurieHendren. \nRelationsasan abstraction for BDD-based program analysis. ACM Trans. Program.Lang.Syst.,30(4):1 63,2008. \n[10] Donglin Liang, Maikel Pennings, and Mary Jean Harrold. Evaluating the impact of context-sensitivity \non Andersen s algorithm for Java programs. In Michael D. Ernst and ThomasP.Jensen, editors, PASTE,pages6 \n12.ACM,2005. [11] Benjamin Livshits, John Whaley, and Monica S. Lam. Re.ection analysis for Java. In \nKwangkeun Yi, editor, Proceedings of the 3rd Asian Symposium on Programming Languages and Systems, volume \n3780. Springer-Verlag, November2005. [12] Matthew Might, Yannis Smaragdakis, and David Van Horn. Resolving \nand exploiting the k-CFA paradox: Illuminating functional vs. object-oriented program analysis. In Conf. \non Programming Language Design and Implementation(PLDI). ACM,June2010. [13] Ana Milanova, Atanas Rountev, \nand Barbara G. Ryder. Parameterized object sensitivity for points-to analysis for Java. ACMTrans.Softw.Eng.Methodol.,14(1):1 \n41,2005. [14] Mayur Naik, Alex Aiken, and John Whaley. E.ective static race detection for Java. In Proceedings \nof the 2006 ACM SIGPLAN Conference on Programming Language Design and Implementation(PLDI 06),pages308 \n319, 2006. [15] John Plevyak and Andrew A. Chien. Precise concrete type inference for object-oriented \nlanguages. In Proceedings of the ninth annual conference onObject-orientedprogramming systems, language, \nand applications, OOPSLA 94, pages 324 340, NewYork,NY,USA,1994.ACM. [16] John Reppy. Type-sensitive \ncontrol-.ow analysis. In Proceedings of the 2006 ACM SIGPLAN Workshop on ML, pages74 83,September2006. \n[17] Barbara G. Ryder. Dimensions of precision in reference analysis of object-orientedprogramming languages. \nInG\u00a8orel Hedin, editor, Compiler Construction, 12th International Conference, CC 2003, volume 2622 of \nLecture Notes in Computer Science,pages126 137. Springer,2003. [18] MichaSharir andAmirPnueli. Two approaches \ntointerproce\u00adduraldata .owanalysis. InStevenS.Muchnick andNeilD. Jones, editors, Program Flow Analysis, \npages 189 233, En\u00adglewood Cli.s,NJ,1981.Prentice-Hall,Inc. [19] Olin Shivers. Control-Flow Analysis of \nHigher-Order Languages. PhD thesis, Carnegie Mellon University, May 1991. [20] Manu Sridharan and Rastislav \nBod\u00b4ik. Re.nement-based context-sensitive points-to analysis for Java. In PLDI 06: Proc. of the 2006 \nACM SIGPLAN conf. on Programming language design and implementation, pages 387 400, New York,NY,USA,2006.ACM. \n[21] Vijay Sundaresan, Laurie Hendren, Chrislain Raza.mahefa, RajaVall\u00b4ee-Rai,PatrickLam,EtienneGagnon, \nandCharles Godin. Practical virtual method call resolution for Java. In Proceedings of the Conference \non Object-Oriented Program\u00adming Systems, Languages, and Applications,pages 264 280. ACMPress,2000. [22] \nJohnWhaley,DzintarsAvots,MichaelCarbin, andMonicaS. Lam. Using Datalog with binary decision diagrams \nfor program analysis. In Kwangkeun Yi, editor, APLAS, volume 3780 of Lecture Notes in Computer Science, \npages 97 118. Springer,2005. [23] John Whaley and Monica S. Lam. Cloning-based context\u00adsensitive pointer \nalias analysis using binary decision dia\u00adgrams. In PLDI 04:Proc.of theACMSIGPLAN2004 conf. on Programming \nlanguage design andimplementation,pages 131 144, NewYork,NY,USA,2004.ACM.    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Object-sensitivity has emerged as an excellent context abstraction for points-to analysis in object-oriented languages. Despite its practical success, however, object-sensitivity is poorly understood. For instance, for a context depth of 2 or higher, past scalable implementations deviate significantly from the original definition of an object-sensitive analysis. The reason is that the analysis has many degrees of freedom, relating to which context elements are picked at every method call and object creation. We offer a clean model for the analysis design space, and discuss a formal and informal understanding of object-sensitivity and of how to create good object-sensitive analyses. The results are surprising in their extent. We find that past implementations have made a sub-optimal choice of contexts, to the severe detriment of precision and performance. We define a \"full-object-sensitive\" analysis that results in significantly higher precision, and often performance, for the exact same context depth. We also introduce \"type-sensitivity\" as an explicit approximation of object-sensitivity that preserves high context quality at substantially reduced cost. A type-sensitive points-to analysis makes an unconventional use of types as context: the context types are not dynamic types of objects involved in the analysis, but instead upper bounds on the dynamic types of their allocator objects. Our results expose the influence of context choice on the quality of points-to analysis and demonstrate type-sensitivity to be an idea with major impact: It decisively advances the state-of-the-art with a spectrum of analyses that simultaneously enjoy speed (several times faster than an analogous object-sensitive analysis), scalability (comparable to analyses with much less context-sensitivity), and precision (comparable to the best object-sensitive analysis with the same context depth).</p>", "authors": [{"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "University of Massachusetts, Amherst, MA, USA", "person_id": "P2509545", "email_address": "yannis@cs.umass.edu", "orcid_id": ""}, {"name": "Martin Bravenboer", "author_profile_id": "81100378172", "affiliation": "LogicBlox Inc., Atlanta, GA, USA", "person_id": "P2509546", "email_address": "martin.bravenboer@acm.org", "orcid_id": ""}, {"name": "Ondrej Lhot&#225;k", "author_profile_id": "81100503314", "affiliation": "University of Waterloo, Waterloo, ON, Canada", "person_id": "P2509547", "email_address": "olhotak@uwaterloo.ca", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926390", "year": "2011", "article_id": "1926390", "conference": "POPL", "title": "Pick your contexts well: understanding object-sensitivity", "url": "http://dl.acm.org/citation.cfm?id=1926390"}