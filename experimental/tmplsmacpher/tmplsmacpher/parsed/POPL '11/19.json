{"article_publication_date": "01-26-2011", "fulltext": "\n The Design of Kodu: A Tiny Visual Programming Language for Children on the Xbox 360 Matthew MacLaurin \nMicrosoft FUSE Labs / Microsoft Research mmaclaurin@hotmail.com Abstract Kodu is a relatively new programming \nlanguage (1) designed specifically for young children to learn through independent exploration. Kodu \nseeks to lower the barrier to entry for new programmers by presenting a radically simplified programming \nmodel which nevertheless has significant expressive power (2). Kodu is integrated in a real-time 3D gaming \nenvironment and is designed to compete with modern console games in terms of intuitive user interface \nand graphical production values. In this paper we will review key tradeoffs made in the design of the \nprogramming language and illustrate how it is one of very few languages designed using user interface \ndesign principles and methodologies, to the extent that the blend of subjective and objective factors \nconsidered in the language design1 have succeeded in presenting a model of programming which is uniquely \napproachable and creatively empowering for non-technical users. Categories and Subject Descriptors D.1.7 \n[Programming Techniques]: Visual Programming D.2.2 [Software Engineering]: Design Tools and Techniques \n User interfaces; Computer-aided software engineering (CASE); Evolutionary prototyping, D.2.6 [Software \nEngineering]: Programming Environments Graphical environments; Integrated environments; Interactive \nenvironments, D.3.2 [Programming Languages]: Language Classifications Specialized application languages; \nVery high-level languages; Concurrent, distributed, and parallel languages General Terms Design, Human \nFactors, Languages Keywords games; game programming; 3d user interface; end\u00aduser authoring; K12 programming; \nprogramming early education; Kodu, Boku 1. Goals of Kodu Kodu was initially inspired by the relatively \neasy access to programming through a ROM-based BASIC interpreter provided in early 1980s personal computers \nlike the Commodore PET, Apple II, and the Radio Shack TRS-80. For programmers coming of age in that time, \nthere was little to do with a computer Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. POPL 11 January 26 28, 2011, Austin, Texas, USA. Copyright &#38;#169; \n2011 ACM 978-1-4503-0490-0/11/01 $10.00. but program or play simple games copied from magazine listings. \nSignificantly, many programmers wrote their first lines of code in order to modify these pre-fab games \nto be more to their liking. We felt that this blend of play and learning had largely been lost, to the \ndetriment of the programming community. Modern video games do not typically come with source code, cannot \nbe reprogrammed on the fly and particularly in the area of console games - require such advanced engineering \nthat they present an intimidating barrier to entry. It was our expectation that providing a more easily \naccessible, creatively powerful programming experience to young children would benefit the children in \ntheir cognitive development (3) and eventually increase the overall size and quality of the programming \ncommunity. Ideally, more children would be drawn to programming as a creative tool for expressing their \nown ideas rather than an externally motivated career choice with limited personal relevance. With Kodu, \nwe set out to provide a new first programming experience that mirrored the early PC era: play games, \nfix them up, and eventually create your own from scratch. We realized very early that the kids of today \nhave a very different context than we ourselves had in the 80s, particularly in regard to user interface \nand the games themselves, which often have art budgets comparable to those of the largest Hollywood films. \nWe didn t want a 21st century language for building 1980s games; instead, we felt our new language should \nbe able to achieve the same quality of work product that kids experience in commercial console games \ntoday. This indicated to us that we should pursue a higher level of abstraction than BASIC in order to \nmeet kid s sophisticated expectations of game behavior while keeping the learning curve manageable. By \ncoupling the language semantics with a real-time 3D game engine we sought to allow kids to leverage common \ngaming assumptions such as physics to focus on what was new about their own game designs.  2. Kodu \nEnvironment Although our focus for Kodu was to create a new programming language, our chosen domain \n3d gaming required that we also supply tools necessary for arranging and populating the game world. \nKodu includes a full 3D gaming development environment, include a terrain editor, layout tools, character \nmenus, and other mechanisms which allow end-users to create the world data against which their code will \noperate. Similarly, the Kodu runtime includes a full complement of fundamental game technology: camera \ncontrols, collision detection, physics, etc. Although implementing such basic game technology as a physics \nengine is a deep and fascinating endeavor for an advanced programmer, our interviews with children showed \na clear focus on new forms of gameplay which typically assume that physics already works. We decided \nto provide enough functionality out of the box that the problems the kids were trying to solve through \nprogramming were problems they already found interesting their own game design ideas.  3. Design chronology \n3.1 Inspirations Once we had chosen our north star to achieve the level of interactivity, ease of entry, \nand relative expressive power of 80s BASIC environments, we looked for modern inspirations of high\u00adlevel \nsystems with expressive power, even if they were not programming environments per se. One such inspiration \nwas the children s musical toy Music Blocks created by the toy company Neurosmith. This toy allows very \nsmall children to create a variety of different songs by changing the orientation and order of a set \nof electronic cubes on a rack. The attractive element of this toy was how the user interface ruled out \nthe possibility of a syntax error: as long as the cubes are placed into the rack spaces, a song will \nresult. There are no illegal combinations possible. We distilled this inspiration into a key creative \nimage: a robot onto which the user places cards containing high level concepts such as move, see, green, \nor left, which then self-assemble into coherent behavioral statements. This crystalized a motivation \nto protect the user from having to memorize abstract grammatical structure or sequencing rules. Another \ninspiration was the HyperCard environment created by Bill Atkinson at Apple Computer in the 1990s (4). \nIn HyperCard, there was no distinction between the programming environment and the finished project. \nA user created a new program by interactively modifying an already running albeit simplistic program. \nWe noticed that, in this model, a user is faced with a single level of abstraction a program that can \nbe modified - rather than the more daunting and complex concept of a program which creates programs which \nis presented in modern Interactive Development Environments (IDEs) such as Microsoft s Visual Studio \nor the Eclipse Foundation s eponymous product. From more recent software history, we studied the logical \npuzzle blocks model presented by MIT s Scratch project and the menu-driven game programming environment \nin CMU s Alice (5). In seeking to contribute something beyond what these modern kid s programming tools \nhad already achieved, we noticed that these environments closely modeled the syntax and level of abstraction \nof professional programming languages such as Java. We asked ourselves if we could use either higher-level \nlanguage constructs or more deeply integrate common game engine concepts to allow our users to achieve \nmore complex games in fewer lines of code than these other (excellent) environments. This became a key \nturning point in the language design as we realized that visually modeling the semantics of mainstream \nlanguages was not a goal because it had already been done quite effectively. Rather, we implicitly gave \nourselves permission to invent a completely new language if we could convince ourselves that that language \nwould more concisely express the ideas of a kid trying to design a new video game. A full accounting \nof our inspirations is barely possible; some of the others included Smalltalk (6); Lisp and in particular \nthe object\u00adoriented dialect Dylan (7); interactive physics environments such as Crayon Physics; the event-driven \nmodel of programming popularized by the Apple Macintosh (8) and dataflow programming environments such \nas HookUp and Lego Mindstorms. 3.2 Vehicles Our use of the gaming domain was implicit in our goal of \nspeaking to kids existing motivations making and playing games. The modern gaming world is overwhelmingly \nreal-time and 3D, which led us to examine robotics literature, which deals extensively with controlling \nbehavior in a real-time 3D environment. One particularly compelling example of this was Valentino Breitenberg \ns 1984 book Vehicles, which examines how surprisingly intelligent behavior can be achieve by simple combinations \nof motors, wheels, lights, and light sensors, wired in different combinations. In our first design exploration, \nwe attempted to re-create the popular early video game Pac Man using a Breitenberg-style library of sensor \nand motor blocks within a wiring tool. We quickly discovered that even simple behaviors would quickly \nbecome very large, complex diagrams. Motors and sensors were too low-level to achieve the expressive \npower we were after. After a round of early paper prototyping work, we discarded this approach and went \nback to the drawing board. 3.3 Cards paradigm Stephen Coy, one of the original Kodu team members, had \nrecently completed a research prototype for a new graphical user interface for issuing commands to a \ncomputer. This prototype consisted of a virtual deck of cards representing OS concepts such as printer \nand document. A user would construct a hand like a poker hand of these cards in a 3D environment and \nthen play the hand and the system would infer a command. For example, selecting a card labeled printer \nand a card for a document would cause the document to be printed. The positive usability results from \nthis internal Microsoft prototype motivated us to find a way to incorporate this hand of cards paradigm \nin our language design and user interface.  3.4 Behavior-based Robotics As we continued to explore scenarios \nand design goals using paper prototyping, we found increasing relevance in the robotics literature of \nRodney Brooks at MIT. Just as Brooks subsumption architecture (9) reduced processing requirements for \nreal-world robots, we realized these concepts could also be used to achieve greater expressive power \nfor game designers. Based on these publications and more popular descriptions of robotic behavior programming \nKodu co-founder Michael Miller designed a basic model for the language which is still in use today: A \nsensor detects objects in the world. Sensors used in Kodu include physical analogs such as see, hear \nand bump (touch,) and also slightly more abstract sensors such as timer, which detects the passage of \ntime, and scored, which detects changes to game scores. Sensors create sets of sensed objects which are \navailable for further processing. A filter reduces the set of objects detected by a sensor. A sensor \nproduces a set, and the filter reduces that set. Filtering can be done on object types (apple, tree;) \non object attributes such as color, or on situational characteristics such as distance (near, far) or \nquantity (many, few.) A selector operates on the set emitted by the filter to select a single object \nfor operation. In actual use the nearest selector is most commonly used; other selectors include furthest \nand random.  An actuator causes the executing robot (the subject) to take some action towards itself \nor the object provided by the selector (the object.) Finally, a modifier further parameterizes the actuator, \noptionally incorporating information derived from the subject, object or global state. A set of these \nprimitives combine (2) to form a rule. Within that rule, the sensor, filters, and selectors form a sensor \nclause while the actuator and one or more modifiers form and actuator clause. At runtime, any sensor \nclause which detects at least one matching object in the environment causes the rules actuator clause \nto take effect, or fire. The core set of sensors, filters etc is based on primitive functionality oriented \ntowards game design: sensors such as see and hear, filters that can reference object type (like tree) \nor color, and actuators like move with filters such as towards or away. See apple nearest : move towards \nis a common hello world equivalent in Kodu. Note that this approach does not mandate a particular order \nfor the primitives in a rule. At this point in the design, we chose an order that provided the most direct \nmapping to English speech.  3.5 First User Interface In designing Kodu, we gave equal weight to the \ndesign of the language itself and of the user interface used to create and edit Kodu programs. Our design \nprocess incorporated user interface design principles, such as progressive disclosure (xxx) (revealing \nelements after the user has made use of preceding elements) and methodologies such as usability testing \n(xxx) using both paper and interactive prototypes. The first version of the Kodu user interface had the \nsimple goal of allowing end users to create rules by combining the language primitives listed in the \nprevious section. For this we chose a straightforward implementation of a grid where each row corresponds \nto a single rule and each column to a primitive type in the order sensor filter selector actuator \n modifier. In Figure 1 we see a single rule consisting of nodes on a horizontal bar. Each node can be \nclicked (using an Xbox 360 controller) to open a menu allowing the user to select a primitive to be placed \nat that node. In this image the user has clicked on the Sensor node and is viewing a circular menu of \nsensors including See, Hear, and Touch as well as the now-defunct Remember and Stalled sensors. Usability \ntests for the first user interface revealed a few problems. The first stemmed from our approach of having \npre-allocated empty cells for each primitive type. Note that a user can add several filters to a rule: \nSee red apple nearest sensor filter filter selector Since we couldn t know how many filters a user \nwould need for a given rule, we simply left 3 filter spaces. This was usually enough; however, users \nnew to the system tended to see it as a minimum requirement and felt compelled to add 3 filters to every \nrule. This often led to rules that were overly specific (see red apple big) and could not select matching \nobjects in the environment. We needed a way to guide the user to create rules with the minimum effective \nnumber of primitives (such as filters) while allowing more advanced users to express more specific rules \nwhen necessary. 3.6 Rule Prioritization and Arbitration In our previous example we considered the user \ninterface for a single rule. Rules can be grouped together to form a page; in the user interface, this \nis depicted as a vertical stack of rules numbered in ascending order from top to bottom, with the topmost \nrule having the number 1. These numbers indicate the priority of the rules, with the highest priority \nrule appearing at the top of the screen. For many simple programs, prioritization has no effect; rules \nare executed concurrently, with all sensors tested against the same world state. However, more subtle \nor complex behaviors are possible by programming conflicting rules and allowing prioritization to mask \nthe results of some rules. For example, one might create the Kodu program: 1. See purple move away \n 2. See apple move -towards  In this example, the robot will move towards any apple and away from \nanything purple. In the case of a purple apple, the rule to move away from purple objects will take priority. \nA common use for this effect is to have a robot that patrols unless it sees an enemy, in which case it \nwill give chase. This ability to have multiple simple programs arbitrated by suppressing each other s \noutputs can be seen as a simplified version of Rodney Brook s subsumption architecture (10), with the \ndifference that in Kodu suppression is based on a simple linear priority ordering rather than a hierarchical \narrangement of behaviors.  3.7 Program Editor Revision The next major revision of the program responded \nto two key issues. The first was the tendency of users to fill in every slot and create overly specific \nrules, as we mentioned earlier. The second issue was a problem of repetitiveness: in real-world design \nchallenges, users tended to use the same selector almost exclusively: the nearest selector, which simply \npicks the closest object detected in the sensor clause. (ex see apple nearest : move towards vs. see \n apple furthest move towards)  This new design also recognized a natural hierarchy in the primitives: \nfilters have a many-to-one mapping to sensors (the filters red, blue, etc apply to the see sensor) and \nmodifiers have a similar relationship to actuators: the modifiers toward and away can similarly be seen \nas children of the move actuator. Given this hierarchy, the team designed a new presentation which presented \nonly two affordances: a sensor menu and an actuator menu. This streamlined presentation of an empty rule \nis shown below. Figure 2. Revised Kodu rule editor focuses on the key sensor and actuator primitives. \nIn this simplified presentation, a more intuitive interpretation of the syntax emerged: the sensor and \nactuator are equivalent to a stimulus and a response, or to the classic if then clause in most procedural \nlanguages. Based on polling of our usability test subjects, we settled on labels for each of these clauses \nof when (for the filter clause) and do (for the actuator clause.) These labels can be seen in Figure \n2. In this new presentation we also emphasize the hierarchical relationship between sensors and filters \nand between actuators and modifiers. In Figure 3, below, we see a filter clause (see red apple) with \ntwo filters and an actuator clause with a single modifier (move toward.) Another significant change \nwith this revision is that the selectors are no longer presented to the user. Since users almost universally \nchose the nearest selector, we made this the default. While the underlying architecture still allows \nfor different types of selectors, the user interface no longer exposes this capability. As of this writing \nwe are considering re-introducing the selector concept in the user interface as part of a deeper design \ninvestigation around set semantics, iteration, and concurrency, details of which are beyond the scope \nof this paper.  3.8 Consideration of State and Variables At this point in the evolution of the language \nit was become clear that we needed a model for management of state. We considered adding classical variable \ntypes such as string and integers, but struggled to do it in a way which maintained the intuitiveness \nof the programming user interface. Two insights guided this part of the design: the first was the general \nvalue in Rodney Brook s work (xxx) that reaction that state should be read from the environment and models \nwere to be avoided. The second relied on personal correspondence with earlier implementers of prototype \nchildren s languages at Microsoft who had found that children seemed uninterested in abstractions (like \nvariables) and more interested in real-world concepts (like seeing and moving.) In the end, we decided \nto avoid typical presentation of variables in favor of reliance on world state. Although this was already \na useful paradigm in robotics (11), Kodu has two advantages over the robotics field that made it even \nmore useful. The first is that we could invent new actuators capable of writing state reliably into the \nsimulation environment. Additionally our sensors, being virtual, are perfect and can be counted on to \nread state back from the environment instantly and without error. A classic example of Kodu style state \nis object color. Characters can react to each other s color and also use the color actuator to change \ntheir own or each other s color. We ve seen programs where characters signal their program state to each \nother by changing their own color, providing a lightweight synchronization mechanism that has the wonderful \nside effect of being visible to the user and therefore easier to understand and debug. In the initial \nrelease of Kodu we also include a representation that has proven endlessly useful and, as all our language \nconstructs, has an intuitive analog: the score. Kodu has primitives for setting, incrementing, decrementing, \nand testing scores. Although we present this in the curricula for the obvious reason keeping track of \nwho s winning we were delighted to see our users use scores exactly as general-purpose integer variables, \nkeeping track of iterations, resource counts, and even semaphores between characters.  3.9 State Machines \nand Structured Programming Another classic do we or don t we moment arrived as sample programs started \nto use more complex real-world game designs. While prioritization and arbitration can achieve surprisingly \nsubtle behavior, pages of rules can become unwieldy with more than 8 or so lines and our users wanted \na way to encapsulate different modes of behavior. Clearly this was an opportunity to introduce subroutines \nand structured programming. At the same time, jumping directly to those well-understood concepts would \nput severe pressure on our design goals of intuitive, discoverable user interface and minimal abstraction. \nGiven the wonderfully English-like rules Kodu was currently composed of, the notion of shoe-horning in \nparameter passing and return address stacks threatened to take our user experience off the deep end and \nwell beyond what a seven year old might willingly explore on their own. In the end, we went with a minimal \nblock structure with a real\u00adworld (i.e. non-abstract) metaphor: the page. Each Kodu program automatically \npresents one page of initially empty rules. Most new Kodu programmers will spend several hours without \nrealizing that a robot can have more than one page. As they explore the set of actuators more deeply, \nthey discover (or are shown) a switch page actuator that allows a robot to change from one page of rules \nto a completely different page of rules. No state is passed; again we rely on the environment to hold \nour model . The icon for this actuator (a page icon with an arrow) is echoed elsewhere on the screen \nin a UI hint that shows the user how to move between pages in the editor.   4. Lessons: Kodu in the \nReal World Kodu was first released on the Xbox 360 in June of 2009 and then for the PC (as a free download) \nin January of 2010. It is currently in use in 120 countries around the world and has been translated \nto several languages by enthusiastic users. Deployment environments range from single players on the \nXbox at home (around 50,000 paid downloads by individuals) to a multi-school K12 collaborative Kodu system \nin Victoria Australia (12). 4.1 What worked We attempted to provide a programming language so seamlessly \nembedded in a modern console gaming experience that children would voluntarily spend their leisure time \nlearning to program their own games. Based on the downloads we ve seen on the Xbox 360 and positive reviews \nin mainstream gaming press, we believe we have achieved that. One result that pleasantly surprised us \nwas that Kodu users in several school environments seem to be evenly divided between boys and girls. \nAs our first pilot deployment was in an all-girls after-school program, our early user feedback may have \nguided us to an experience that appeals regardless of gender. This is an effect we are just beginning \nto investigate and would like to build on. 4.2 Missed opportunities Although the team wanted to build \na game-sharing server for Kodu, resource limitations prevented us from deploying it to end users. We \nfeel that this limited the ability of kids to be motivated by each other s work, ultimately holding back \nthe growth of the Kodu user base. Feedback from some academic institutions has indicated a desire for \na ladder from Kodu to mainstream professional programming languages. While we remain focused on the earliest \npossible programming experience rather than pure vocational preparation, we recognize the appeal of an \nintegrated profession from Kodu to, say, C# or JavaScript. 4.3 Next steps As of this writing we have \na major Kodu upgrade scheduled to launch in fall of 2010. In early 2011 we plan to begin work on a global \nKodu sharing server which will allow children to share their Kodu creations with classmates and students \nin other schools and countries. We are also actively seeking partners in university to help us extend \nKodu with specialized scenarios and more advanced language constructs. We have shared the Kodu source \ncode with several university efforts, notably in support of Teale Fristoe s fuzzy logic extension for \nKodu, in development at UC Santa Cruz. It is our hope that broadening the community of Kodu contributors \nwill help it to reach its full potential as an easy-to-learn new language for young children.  5. References \n1. Microsoft FUSE Labs. Kodu Web Site. [Online] [Cited: November 12, 2010.] http://fuse.microsoft.com/project/kodu.aspx. \n 2. Stolee, K. T. Kodu language and grammar specification. Redmond, WA, USA : Microsoft Research, 2010. \n 3. \"Let the players play!\" &#38; other earnest remarks about videogame authorship. Teske, Paul and Fristoe, \nTeale. s.l. : International Society of the Learning Sciences, 2010. ICLS '10 Proceedings of the 9th International \nConference of the Learning Sciences - Volume 1. 4. Apple Computer, Inc. HyperCard Script Language Guide: \nThe HyperTalk Language. Reading, MA : Addison-Wesley Publishing Company, 1988. 5. Matthew Conway, et \nal. Alice: lessons learned from building a 3D system for novices. CHI '00 Proceedings of the SIGCHI conference \non Human factors in computing systems. The Hague, The Netherlands : s.n., 2000. 6. Goldberg, A. Smalltalk-80: \nthe language and its implementation. Boston, MA, USA : Addison-Wesley Longman Publishing Co., Inc., 1983. \nISBN: 0-201-11371-6. 7. Shalit, A. The Dylan reference manual. Redwood City, CA, USA : Addison Wesley \nLongman Publishing Co., Inc., 1996. ISBN:0-201-44211-6. 8. A declarative approach to event-handling \nin visual programming languages. Burnett, MM and al, et. Seattle, WA, USA : s.n., 1992. Proceedings, \n1992 IEEE Workshop on Visual Languages. pp. 34-40. 9. New Approaches to Robotics. Brooks, RA. 13, s.l. \n: Science, 1991, Vol. 253. 10. Brooks, Rodney A. Intelligence Without Reason. Cambridge, MA, USA : MIT, \n1991. 11. Brooks, Roney A. Intelligence without representation. [book auth.] George F. Luger. Computation \n&#38; Intelligence. Menlo Park, CA, USA : American Association for Artificial Intelligence, 1995. 12. \nThe impact of web 2.0 technologies in the clsassroom. Department of Education and Early Childhood Development, \nState of Victoria. 2009. 13. Kodu: end-user programmin gand design for games. MacLaurin, Matt. s.l. \n: ACM, 2009. FDG '09: Proceedings for the 4th International Conference on Foundations of Digital Games. \n 14. The early history of Smalltalk. Kay, Alan C. s.l. : ACM, 1993. HOPL-II: The second ACM SIGPLAN conference \non History of programming languages . 15. Elephants don't play chess. Brooks, Rodney A. 1-2, 1990, Robotics \nand Autonomous Systems, Vol. 6.    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>Kodu is a relatively new programming language designed specifically for young children to learn through independent exploration. Kodu seeks to lower the barrier to entry for new programmers by presenting a radically simplified programming model which nevertheless has significant expressive power. Kodu is integrated in a real-time 3D gaming environment and is designed to compete with modern console games in terms of intuitive user interface and graphical production values. In this paper we will review key tradeoffs made in the design of the programming language and illustrate how it is one of very few languages designed using user interface design principles and methodologies, to the extent that the blend of subjective and objective factors considered in the language design have succeeded in presenting a model of programming which is uniquely approachable and creatively empowering for non-technical users.</p>", "authors": [{"name": "Matthew B. MacLaurin", "author_profile_id": "81421594524", "affiliation": "Microsoft FUSE Labs, Redmond, WA, USA", "person_id": "P2509608", "email_address": "mmaclaurin@hotmail.com", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926413", "year": "2011", "article_id": "1926413", "conference": "POPL", "title": "The design of kodu: a tiny visual programming language for children on the Xbox 360", "url": "http://dl.acm.org/citation.cfm?id=1926413"}