{"article_publication_date": "01-26-2011", "fulltext": "\n The Tree Width of Auxiliary Storage P. Madhusudan Gennaro Parlato University of Illinois at Urbana-Champaign, \nUSA LIAFA, CNRS and University of Paris Diderot, France. madhu@illinois.edu gennaro@liafa.jussieu.fr \nAbstract We propose a generalization of results on the decidability of empti\u00adness for several restricted \nclasses of sequential and distributed au\u00adtomata with auxiliary storage (stacks, queues) that have recently \nbeen proved. Our generalization relies on reducing emptiness of these automata to .nite-state graph automata \n(without storage) restricted to monadic second-order (MSO) de.nable graphs of bounded tree-width, where \nthe graph structure encodes the mech\u00adanism provided by the auxiliary storage. Our results outline a uni\u00adform \nmechanism to derive emptiness algorithms for automata, ex\u00adplaining and simplifying several existing results, \nas well as proving new decidability results. Categories and Subject Descriptors F.1.1 [Theory of Computa\u00adtion]: \nModels of Computation: Automata; D.2.4 [Software Engi\u00adneering]: Software/Program Veri.cation: Model checking; \nF.4.3 [Theory of Computation]: Formal Languages: Decision problems General Terms Algorithms, Reliability, \nTheory, Veri.cation Keywords model checking, automata, decision procedures, bounded tree-width 1. Introduction \nSeveral classes of automata with auxiliary storage have been de\u00ad.ned over the years that have a decidable \nemptiness problem. Clas\u00adsic models like pushdown automata utilizing a stack have a decid\u00adable emptiness \nproblem [14], and several new models like restricted classes of multi-stack pushdown automata, automata \nwith queues, and automata with both stacks and queues, have been proved de\u00adcidable recently [8, 15, 17, \n22]. The decidability of emptiness of these automata has often been motivated for model-checking systems. \nSoftware models can be captured using automata with auxiliary storage, as stacks can model the control \nrecursion in programs while queues model FIFO communication between processes. In abstraction-based model\u00adchecking, \ndata domains get abstracted from programs, resulting in automata models (e.g., the SLAM tool builds pushdown \nautomata models using predicate abstraction [7], and the GETAFIX tool model-checks both single-stack \nand multi-stack automata mod\u00adels [18, 19]). The emptiness problem for these automata is the most relevant \nproblem as it directly corresponds to checking reachability of an error state. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 11, January 26 28, 2011, Austin, Texas, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0490-0/11/01. . . $10.00 However, the various identi.ed \ndecidable restrictions on these automata are, for the most part, awkward in their de.nitions e.g. emptiness \nof multi-stack pushdown automata where pushes to any stack is allowed at any time, but popping is restricted \nto the .rst non-empty stack is decidable! [8]. Yet, relaxing these de.nitions to more natural ones seems \nto either destroy decidability or their power. It is hence natural to ask: why do these automata have \ndecidable emptiness problems? Is there a common underlying principle that explains their decidability? \nWe propose, in this paper, a general criterion that uniformly explains many such results several restricted \nuses of auxiliary storage are decidable because they can be simulated by graph automata working on graphs \nthat capture the storage as well as their sequential or distributed nature, and are also of bounded tree\u00adwidth. \nMore precisely, we can show, using generalizations of known results on the decidability of satis.ability \nof monadic second-order logic (MSO) on bounded tree-width graphs [9, 23], that graph au\u00adtomata on MSO-de.nable \ngraphs of bounded tree-width are decid\u00adable. Graph automata [24] are .nite-state automata (without auxil\u00adiary \nstorage) that accept or reject graphs using tilings of the graph using states, where the restrictions \non tiling determine the graphs that get accepted. The general decidability of emptiness of graph automata \non MSO-de.nable graphs follows since the existence of acceptable tilings is MSO-de.nable. We proceed \nto show that several sequential/distributed automata with an auxiliary storage (we consider stacks and \nqueues only in this paper), can be realized as graph automata workingonsingle or multiple directed paths \naugmented with special edges to capture the mechanism of the storage. Intuitively, a symbol that gets \nstored in a stack/queue and later gets retrieved can be simulated by a graph automaton working on a graph \nwhere there is a special edge between the point where the symbol gets stored to the point where it gets \nretrieved. A graph automaton can retrieve the symbol at the retrieval point by using an appropriate tiling \nof this special edge. The idea of converting automata with storage to graph automata without storage \nbut working on specialized graphs is that it allows us to examine the complexity of storage using the \nstructure of the graph that simulates it. We show that many automata with a tractable emptiness problem \ncan be converted to graph automata working on MSO de.nable graphs of bounded tree-width, from which decidability \nof their emptiness follows. We prove the simulation of the following classes of automata with auxiliary \nstorage by graph automata working on MSO\u00adde.nable bounded tree-width graphs: -Multi-stack pushdown automata \nwith bounded context-switching: This is the class of multi-stack automata where each computa\u00adtion of \nthe automaton can be divided into k stages, where in each stage the automaton touches only one stack \n(proved decidable .rst in [22]). We show that they can be simulated by graph automata on graphs of tree-width \nO(k).  -Multi-stack pushdown automata with bounded phases: These are automata that generalize the bounded-context-switching \nones: the computations must be dividable into k phases, for a .xed k, where in each phase the automaton \ncan push onto any stack, but can pop only from one stack (proved decidable recently in [15]). We show \nthat graph automata on graphs of tree-width O(2k) (not O(k) as in the above case) can simulate them. \n-Ordered multi-stack pushdown automata: The restriction here is that there is a .nite number of stacks \nthat are ordered, and at any time, the automaton can push onto any stack, but pop only from the .rst \nnon-empty stack. Note that the computation is not divided into phases, as in the above two restrictions. \nWe show that automata on graphs of tree-width O(n \u00b7 2n) (where n is the number of stacks) can simulate \nthem. -Distributed queue automata on polyforest architectures: Dis\u00adtributed queue automata is a model \nwhere .nite-state processes at n sites work by communicating to each other using FIFO channels, modeled \nas queues. It was shown recently that when the architec\u00adture is a polyforest (i.e. the underlying undirected \nnetwork graph of the architecture is a forest), the emptiness problem is decidable (and for other architectures, \nit is undecidable) [17]. We prove that graph automata working on graphs of tree-width (in fact, path-width) \nn, where n is the number of processes, can simulate distributed queue automata on polyforest architectures. \n -Distributed queue automata with stacks on forest architectures: When we endow each process in a distributed \nqueue automaton with a local stack, it turns out that if the automaton is well-queuing and the architecture \nis a forest, the emptiness problem is decid\u00adable [17]. The well-queuing condition demands that a process \nmay dequeue from a queue only when its local stack is empty. Further\u00admore, it is known that simply dropping \nthe well-queuing condition or dropping the condition that the architecture be a forest, makes emptiness \nundecidable [17]. We prove that graph automata that work on graphs that simulate both the local stacks \nand the queues can capture these automata, and for well-queuing automata over forest architectures, the \ngraphs are of tree-width O(n),where n is the number of processes. The graphs on which the graph automata \nneed to work to realize the above automata are also, surprisingly, uniform. For the .rst three classes \nof multi-stack automata, the graphs are simply a single word endowed with a set of nesting edges relations, \none relation for each stack. For distributed queue automata, the graphs are composed of n distinct linear \nstructures, one for each process, with queue edges connecting enqueing vertices to dequeuing vertices, \nand, if the processes have stacks, have nesting edges at each process to capture the local stack. The \ntree-decompositions for these graphs as well as the proofs that the decompositions give bounded tree-width \nfor the restrictions are involved, and are tailored to exploit the restriction placed on the automata. \nThe idea of interpreting stacks as nesting edges was motivated by the work relating visibly pushdown \nautomata with nested word automata [1 3], where nesting edges capture a visible stack. Our work is also \nmotivated by the work on bounded-phase multi\u00adstack automata [15], in which we were involved, where tree\u00adinterpretations \nwere used to show decidability of emptiness. Sur\u00adveying the other known decidable automata restrictions \nled us to this uniform framework for proving decidability. The automata variants we study were often \n.rst proved to be decidable by dif\u00adferent means bounded context-switching multi-stack automata were shown \nto be decidable using regularity of tuples of reach\u00adable con.gurations [22], ordered multi-stack automata \nwere shown decidable using manipulations of associated grammars, followed by a Parikh theorem [8], and \ndistributed queue automata with stacks were shown decidable by reductions to bounded-phase au\u00adtomata \n[17]. Our theorems also lead to new consequences. First, automata with multi-stacks are decidable when \ntheir graphs are restricted to graphs of bounded tree-width, and in fact even bounded clique\u00adwidth graphs \n[10, 11]; this result generalizes all the above multi\u00adstack sequential automata. Second, several of our \nresults extend to automata over in.nite behaviors for example, it follows easily that ordered multi-stack \nB\u00a8uchi or parity automata on in.nite words have a decidable emptiness problem. Third, several variants \nof the restrictions can be proved immediately decidable for example, suppose we restrict multi-stack \nautomata to k phases, where in each phase, there is only one stack that is pushed into (but arbitrary \npops of stacks are allowed), then it easily follows that emptiness is decidable, as the graphs corresponding \nto these automata are precisely the same as those of bounded phase automata, save for the orientation \nof the linear and nesting edges, and hence has the same tree-width. Section 5 gives a summary of consequences \nof our general result. Due to the variety of automata models we consider we do not give all de.nitions \nand proofs in the main text. The proofs for the boundedness of tree-width for various restrictions of \nmulti-stack pushdown automata are given in the Appendix, while the proofs regarding distributed queue \nautomata can be found in the technical report [20].  2. Logics, graphs, graph automata, tree-width, \nand emptiness We start by de.ning, in this section, graph automata that work on edge-labeled .nite directed \ngraphs, and show that the emptiness problem for these automata is decidable over any MSO-de.nable class \nof graphs of bounded tree-width. This result is derived from classical results on interpretations of \ngraphs on trees, and we sketch the derivations here. Monadic second-order logic on graphs: Fix a .nite \nalphabet (set) S.A S-labeled graph is a structure (V, {Ea}a.S),where V is a .nite non-empty set of vertices, \nand each Ea . V \u00d7 V is a set of a-labeled directed edges. We will assume, throughout this paper, that \nfor any vertex v, there is at most one incoming a-labeled edge and at most one outgoing a-labeled edge. \nWe view graphs as logical structures, with V as the universe, and each set of edges Ea as a binary relation \non vertices. Monadic second-order logic (MSO) is now the standard logic on these struc\u00adtures. We .x a \ncountable set of .rst-order variables (we will denote these as x, y, etc.) and another countable set \nof set variables (de\u00adnoted as X, Y, etc.). MSO is given by the following syntax: . ::= x = y | Ea(x, \ny) | x . X | . . . |\u00ac. |.x.. |.X.. where a . S. The semantics is the standard one, with .rst-order and \nset variables interpreted as vertices and sets of vertices.1 We say a class of S-labeled graphs C is \nMSO-de.nable, if there is an MSO formula . such that C is the precise class of S-labeled graphs that \nsatisfy .. Graph automata: Fix a class of S-labeled graphs C.Agraph automaton (GA) on C is a tuple (Q, \n{Ta}a.S, type),where Q is a .nite set of states, each Ta . Q \u00d7 Q is a tiling relation,and type : Q . \n2S \u00d7 2S is the type-relation. 1 Note: In the literature, a variant of MSO (called MSO2) has been con\u00adsidered \nwhere both vertices and edges are in a two-sorted universe and are related by an incidence relation; \nthat version is stronger than ours, but we shall not need it for our exposition.  Intuitively, a graph \nautomaton will accept a graph if there is a way to tile (label) the vertices by states so that the tiling \nrelation is satis.ed by vertices adjacent to each other, and further satis.es the type-relation. The \ntype-relation associates each state to a pair (In, Out) of sets of labels, and in order for a state to \ndecorate a vertex, we require its type to match the edges incident on it the labels of incoming (and \noutgoing) edges must be precisely In (and Out). Formally, we say that a graph automaton (Q, {Ta}a.S, \ntype) accepts agraph (V, {Ea}a.S) if there is a map . : V . Q that satis.es the following conditions: \n For every (u, v) . Ea, with a . S, (.(u),.(v)) . Ta.  For every u, type(.(u)) = (In, Out),where In \n= {a |.v, (v, u) . Ea} and Out = {a |.v, (u, v) . Ea}.  The language of a graph automaton GA over a \nclass of graphs C, denoted L(GA), is the set of graphs in C that it accepts. Note that the notion of \nan automaton running over the graph has been replaced by tiling constraints. Also, we have done away \nwith initial or .nal states; we will capture these when needed using specially labeled edges in the sequel. \nOur notion of graph automata is motivated by de.nitions of au\u00adtomata on graphs through tilings in the \nliterature [24]. Graph au\u00adtomata can in fact be de.ned more powerfully (see [24]); however, for our purposes, \nthe above de.nition will suf.ce. Most of our re\u00adsults will carry over to generalizations of the above \nde.nition. Tree-width: We recall the de.nition of tree-width for graphs (see [12]). The tree-width of \na graph intuitively captures how close a graph is to a tree. Formally, a tree-decomposition of a graph \n(V, E) is a pair (T, bag),where T =(N, .) is a tree, and bag : N . 2V is a function that satis.es: For \nevery v . V , there is a node n . N such that v . bag(n),  For every edge (u, v) . E, there is a node \nn . N such that u, v . bag(n),and  ' If u . bag(n) and u . bag(n), for nodes n, n' . N,then ' for every \nn'' that lies on the unique path connecting n and n, '' u . bag(n). The width of a tree decomposition \nis the size of the largest bag in it, minus one; i.e. maxn.N {|bag(n)|} - 1. The tree-width of a graph \nis the smallest of the widths of all of its tree decompositions. It is easy to see that the tree-width \nof a tree is 1 while the tree\u00adwidth of a k-clique is k - 1. Emptiness of graph automata on graphs of \nbounded tree-width: We now show that emptiness of graph automata is decidable, when evaluated over graphs \nthat are de.nable in MSO and are also of bounded tree-width. First, we recall a classical result that \nthe satis.ability problem for MSO is decidable on the class of all graphs of tree-width k (for a.xed \nk) [23]. Courcelle s classic theorem shows that checking if a particular graph G of tree-width k (for \na .xed k) satis.es a .xed MSO formula is decidable in linear time. This result works by de.ning the graph \nin a labelled tree by MSO formulas, and by translating the MSO formula about graphs into one about trees, \nand using a tree-automaton for the MSO formula to check if the corre\u00adsponding tree is accepted. It turns \nout the same proof can be used to prove the satis.ability theorem that we refer to above as well. Intuitively, \nwe can interpret all graphs of tree-width k by using a uniform set of labeled binary trees whose labels \nonly depend on k, translate the MSO formula on graphs to these labeled trees, and use the fact that satis.ability \nof MSO on trees is decidable. THEOREM 2.1 (Seese [23]). The problem of checking, given k . N and . . \nMSO over S-labeled graphs, whether there is a S-labeled graph G of tree-width at most k that satis.es \n.,is decidable. Note that the above certainly does not imply that satis.ability of MSO is decidable on \nany class of graphs of bounded tree-width (take a non-recursive class of linear-orders/words for a counter\u00adexample). \nHowever, an immediate corollary is that satis.ability of MSO is also decidable on any MSO-de.nable class \nof graphs C of bounded tree-width (if .C de.nes the class of graphs, and . is the MSO formula, we can \ninstantiate the above theorem for .C . .). COROLLARY 2.2. Let C be a class of MSO de.nable S-labeled \ngraphs. The problem of checking, given k . N and an MSO\u00adformula ., whether there is a graph G .C of tree-width \nat most k that satis.es ., is decidable. We can now prove that the emptiness problem for graph au\u00adtomata \nis decidable when restricted to bounded tree-width graphs over an MSO-de.nable class of graphs. Intuitively, \nwe can write an MSO formula . that checks whether there is a proper tiling of a graph by the graph automaton \nthat respects the tiling and typing relations. This formula will essentially use an existential quanti.\u00adcation \nof a set of sets Xa (for each a . S) to guess a tiling, and check whether the tiling and typing is proper, \nusing universal .rst\u00adorder quanti.cation on vertices. We can then instantiate the above corollary with \nthis formula to show decidability of graph automata emptiness. In fact, using a direct automaton construction \non trees, we can show the complexity of graph-automata emptiness as well (see [20] for a gist of proof): \nto obtain our result: THEOREM 2.3. Let C be a class of MSO de.nable S-labeled graphs. The problem of \nchecking, given k . N and a graph au\u00adtomaton GA, whether there is some G .C of tree-width at most k that \nis accepted by GA, is decidable, and decidable in time |GA|O(k). The above theorem will be the key result \nwe will use to uni\u00adformly prove decidability results in this paper. For various restric\u00adtions of sequential \nand distributed automata with auxiliary stor\u00adage, we will translate them to graph automata over MSO-de.nable \ngraphs, show that the relevant graphs are of bounded tree-width, and use the above theorem to prove decidability \nof emptiness.  3. Multi-stack Pushdown Automata In this section, we will show the decidability of emptiness \nof var\u00adious restricted multi-stack pushdown automata (bounded context\u00adswitches, bounded phase, and ordered), \nby showing that they can be simulated by graph automata working over multiply-nested word graphs that \nare of bounded tree-width. For any n . N,let [n] denote the set {1,...n}. A multi-stack pushdown automaton \nis an automaton with .nite control and equipped with a .nite number of stacks. A transition of this automaton \nconsists in pushing or popping a symbol from a speci.ed stack and changing its control or simply an internal \nmove that affects only the control state without alteration of the stacks contents. DEFINITION 3.1 (MULTI-STACK \nPUSHDOWN AUTOMATA). For a .xed n . N,an n-stack pushdown automaton (n-PDA) is a tuple M =(Q, q0, G,d,QF \n),where Q is a .nite set of states, q0 . Q is the initial state, G is a .nite stack alphabet, QF . Q \nis the set of .nal states, and d = (dpush,dpop,dint) where dpush . (Q \u00d7 Q \u00d7 G \u00d7 [n]) is the set of push \nmoves,  dpop . (Q \u00d7 G \u00d7 Q \u00d7 [n]) is the set of pop moves, and   dint . (Q \u00d7 Q) is the set of internal \nmoves. A multi-stack pushdown automaton (mPDA) is an n-stack push\u00addown automaton, for some n . N. A con.guration \nof an n-PDA M =(Q, q0, G,d,QF ) is a tuple (q, s1,...,sn) with q . Q and sj . G * is the content of stack \nj,for every j . [n].Let C = (q, s1,...,sn) be a con.guration of M. Then, C is the initial con.guration \nif q = q0 and sj = E, for every j . [n]. Moreover, C is a .nal con.guration if q . QF and sj = E,for \nevery j . [n]. Given two con.gurations C = ' '' ' (q, s1,...,sn) and C = (q ,s1,...,sn), there is a transition \nfrom C to C ' on the action act from the behavior set Bn = act {int, push1,... push, pop1,..., pop}, \ndenoted C - . C ' ,if nn one of the following holds: [Push . onto stack j] act = pushj , and there exists \n. such that ' '' (q,q ,.,j) . dpush, sj = ..sj,and sh = sh for every h . [n] - j. [Pop . from stack j] \nact = popj , and there exists . such that (q, ., q ' ,j) . dpop, sj = ..s ' j ,and sh ' = sh for every \nh . [n] - j. [Internal] act = int,and (q, q ' ) . dint,and sh ' = sh for each h . [n]. act1 A run of \nM is a sequence of transitions of M, . = C1 --. actm-1 C2 ... -----. Cm,where C1 is initial and Cm is \n.nal. For each such run . of M, we associate the behavior word beh(.)= act1.act2 ... actm, and de.ne \nthe set of behaviors of M as the language Beh(M)= { beh(.) | . is arun of M }. Note that the behaviors \ncapture the way the automaton handles the stacks, noting the push and pop operations and the stack on \nwhich they are performed. The emptiness problem for an mPDA M is the problem of checking if Beh(M) is \nempty (or equivalently, whether there is a run of the mPDA). Multiply-nested words: In the following \nwe show that mPDAs can be naturally encoded as graph automata on a class of (edge\u00adlabelled) graphs that \nwe call multiply nested words, and the empti\u00adness problem on the former reduces to the emptiness problem \non the latter. We start by de.ning multiply nested word graphs. DEFINITION 3.2 (MULTIPLY NESTED WORDS). \nFor a given in\u00adteger n,an n-nested word (n-NW) is a tuple N =(V, Init, F inal, L, {Ej }j.[n]),where \nV is a .nite set of vertices;  L . V \u00d7 V is a non-re.exive (successor) edge relation such that L * is \na linear ordering <L on the vertices of V ;  If x is the minimum element w.r.t. L,then Init = {(x, x)};if \nx is the maximal element w.r.t. L,then Final = {(x, x)};  Ej . V \u00d7 V is a nesting relation, for every \nj . [n]. A nesting relation Ej is a relation that satis.es the following properties: for all u, u ' ,v, \nv ' . V and j, j ' . [n],  if Ej(u, v) then u<L v holds;  if Ej(u, v) and Ej(u, v ' ) then v = v \n' ; and if Ej(u, v) and Ej(u ' ,v) then u = u ' ;   '' ' if Ej(u, v) and Ej(u ,v ) and u<L u ' then \neither v<L u or v ' <L v holds. ' '' = j ' if j , Ej(u, v), and Ej' (u ,v ' ),then u,v,u ,v are all \ndifferent. A multiply nested word (mNW )is an n-nested word, for some n . N. E1 Init Final 6 12345 78910 \n1314  E2 Figure 1. A 2 nested word graph. Figure 1 illustrates a 2-nested word. Intuitively, mNWs are \nmeant to capture the behaviors of runs of mPDAs, where the stacks are compiled down to edges in the graph: \nthe relation L relates consecutive actions in the run, while the nesting edge relation Ej captures the \nmatching push-pop relation of stack j, for every stack index j . [n]. The self-looping edges Init and \nFinal capture the initial and .nal vertex with respect to L. The properties of multiply nested words \n(De.nition 3) can be easily stated in MSO: PROPOSITION 3.3. For any integer n, the class of n-NWs is \nMSO de.nable. We can de.ne a 1-to-1 function nw from the set of behav\u00adiors of the n-PDA M to the class \nof n-NWs. Given an M run . with beh(.)= a1a2 ...am, the corresponding nested word graph n-NW N is as \nfollows. The set of vertices of N is V = {v1,v2,...,vm,vm+1}, the relation L is such that L(vi,vj ) holds \niff j = i +1. The edge relation Ej is de.ned as follows. On the word beh(.) there are intrinsic relations \nthat match corresponding pushes and pops of the same stack, and since we assumed that all the stacks \nat the end of a run are empty, we have that in beh(.) ev\u00adery symbol pushj is matched with a future symbol \npopj and vice\u00adversa. Thus the edge relation Ej is de.ned as: Ej(vi,vh) holds if and only if ai = pushj \n, ah = popj and the pair (i, h) is a match\u00ading pair of push and pop actions in beh(.). It is easy to \nsee that this is a 1-to-1 correspondence. Given any n-PDA M, we can easily translate it to a graph automaton \nthat accepts the mNWs corresponding to the behaviors of M. Intuitively, whenever the n-PDA pushes onto \nthe i th stack, the graph automaton decorates the corresponding node in the nested word graph with the \nsymbol pushed, and when this symbol gets popped later, the graph automaton, using tiling conditions on \nthe nested edge, will recover the symbol. Hence, by using tilings on the nested edges, the graph automaton \ncan work without a stack, and capture the semantics of the n-PDA precisely. We hence have: LEMMA 3.4. \nFor every n-PDA M, there is a (constructible) graph automaton GA on n-nested words such that nw(Beh(M)) \n= L(GA). Hence Beh(M) = \u00d8 iff L(GA)= \u00d8. Note that 1-PDAs are basic pushdown automata, whose empti\u00adness \nproblem is decidable. The emptiness problem for n-PDA is well-known to be undecidable when n> 1 [14]. \nThus, Lemma 3.4 can be used to show that the class of n-NWs, with n> 1,have unbounded tree-width. LEMMA \n3.5. The class of 1-NWs has tree-width 2. For any integer n> 1, the class of n-NWs has unbounded tree\u00adwidth. \n Tree-decompositions of multiply nested words. In order to show restricted versions of mPDAs have a decidable \nemptiness problem, we will .rst de.ne canonical tree-decompositions for multiply nested words, which \nwe will use to prove bounds on tree-width and  {1, 2, 13} {2, 13, 14} {3, 4, 6, 7, 8, 11, 12}{3, 8, \n9, 11, 12, 13} {4, 5, 6, 7, 8, 11 , 12} {9, 10, 11, 12, 13}  {5, 6, 7, 8} {10, 11, 12, 13} {5, 11, \n12} {6, 7, 8} {11, 12, 13} Figure 2. Tree decomposition of the graph illustrated in Figure 1. hence prove \nemptiness for both bounded-phase automata as well as ordered automata (it turns out that bounded context-switching \nautomata have a simpler tree decomposition). DEFINITION 3.6 (CANONICAL TREE DECOMP. OF n-NWS). For any \nn-NW N =(V, Init, Final, L, {Ej}j.[n]), the canonical tree-decomposition of N,can-td(N)=(T, bag) is decomposition \nT =(V, bag) de.ned as: The set of nodes of the tree T are the vertices V of the N.  If Ej(u, v) holds \nfor any j . [n],then v is the right-child of u in T .  if L(u, v) holds and for all j . [n] and z . \nV , Ej(z, v) does not hold, then v is the left-child of u.  The function bag associates the minimum \nset of vertices to each node of T that satis.es the following: v . bag(v), for all v . V .  if u is \nthe parent of v in T ,then u . bag(v), for every u, v . V .  for u, v . V ,if L(u, v) holds then u . \nbag(z), for all vertices z such that z is on the unique path from u to v in T .  Figure 2 illustrates \na tree-decomposition for the 2-nested graph in Figure 1. In the above de.nition of the tree-decomposition \nof an n-NW N, the vertices of T are the same as the vertices of N. The root of T is the minimum vertex \nin N according to the linear ordering induced by L. The nesting-edge-successor of any node, if any, is \nalways its right-child. Otherwise, a vertex v is the left-child of its linear predecessor. Notice that, \nsince for each node v there exists at most one pair (u, j) such that Ej(u, v) holds, and at most one \nvertex u such that L(u, v) holds, the tree T is uniquely determined by N. Note that the tree T captures \nall the nesting edges in: in fact if Ej(u, v) holds then v must be the right-child of u, and hence u, \nv . bag(v). The successor relation L is not always local as the nesting-edge relation is: for example, \nif L(u, v) and Ej(z, v) hold for some j and z,then v is the right-child of z and not the left-child of \nu. However, the third property in the de.nition guaranties that all linear edges are captured by at least \none bag, and also validates the requirement that nodes whose bags contain the same vertex in a tree decomposition \nbe connected. Hence, it is clear that can-td(N) de.nes a unique tree decomposition for every n-NWs (though \nits width may not be bounded). LEMMA 3.7. For any multiply nested word graph N,can-td(N) is a tree-decomposition \nof N. 3.1 Bounded context-switch emptiness We show now that the multiply-nested words that correspond \nto bounded context-switching runs of a multi-stack automaton are of bounded tree-width, and hence admit \na decidable emptiness problem. For any k . N, we say that a behavior word w . Bn * is a k-context word, \nif it belongs to ( {int, pushj,popj} * )k . j.[n] In other words, w can be factorized as at most k sub-words \nw1w2 ...wh (with h = k) such that each wi includes only actions of a single stack and internal actions. \nLet us de.ne k-CS-Beh(M) to be the set of all k-context behavior words in Beh(M). The emptiness problem \nfor mPDAs restricted to k contexts is the problem of checking, given an mPDA M, whether the language \nk\u00adCS-Beh(M) is empty. As in the general case, the emptiness problem for mPDSs restricted to k contexts \ncan be reduced to the emptiness prob\u00adlem for graph automata, where now the class of graphs to con\u00adsider \nis that of mNWs restricted to k-context behaviors. For any k, n . N,a k-context-switch n-nested word \nis a tuple N =(V, Init, Final, L, {Ej }j.[n]) where N is a n-NW and nw -1(N) is a k-context behavior \nword. The k-context restriction on multiply nested word graphs is easily expressible as an MSO formula \nf; this formula will express that the graph can be factored into k segments and only nesting edges of \none stack are incident on vertices of a single segment. Along with the MSO formula . de.ning the class \nof mNWs, . . f de.nes the class of all k-context mNWs. Moreover, a tree\u00addecomposition where each stack \nis encoded as a subtree under the root (in the usual way, as in the canonical tree decomposition of 1-nested \nwords), has width at most k +1 (see Appendix A). LEMMA 3.8. For any k, n . N, the class of k-context \nn-NW graphs is MSO de.nable. Furthermore, for any k-context n-NW, there exists a tree-decomposition of \nwidth at most k +1. From the fact that the emptiness problem for mPDAs restricted to k-contexts is effectively \nreducible to the emptiness problem for graph automata over k-context mNWs, and using Lemma 3.8, we can \ninstantiate Theorem 2.3 to show the following: THEOREM 3.9. For any k . N, the emptiness problem for \nmP-DAs restricted to k contexts is decidable, and decidable in time O(|M|O(k)). For a .xed k, the emptiness \nproblem is in PTIME. The original proof of decidability of reachability of multi-stack automata under \na bounded number of context-switches was proved using tuples of automata to store the con.gurations of \nstacks [22]. The above proof is very different it shows that the graph that captures the storage, i.e. \nmultiple stacks with bounded context\u00adswitches, has bounded tree-width, and hence admits a decidable emptiness \nproblem.  3.2 Bounded phase emptiness Now we show that the multiply-nested words that correspond to \nbounded phase runs of a multi-stack automaton are of bounded tree-width (in fact, the canonical tree-decomposition \ngives bounded tree-width), and hence entails decidable emptiness. Aword w . Bn * is a phase if it belongs \nto one of the sets phasej =({int, popj }. {pushi}) *,for some j . [n]. i.[n] A phase j describes any \nsequence of actions in which only internal actions, pushes to all stacks, and pops from stack j are permitted. \nA word w . Bn * is a k-phase behavior word if it is the concatenation of at most k phases: that is, \nw . ((phasej ))k.We de.ne the j.[n]  set k-Phase-Beh(M),for a mPDA M, as the set of all the k-phase \nwords in Beh(M). The emptiness problem for mPDAs restricted to k phase be\u00adhaviors asks whether k-Phase-Beh(M) \nis an empty set. mPDAs restricted to bounded phases can be simulated by graph automata on a the class \nof bounded phase mNWs. For any k, n . N,a k\u00adphase n-nested word N is an n-NW where nw -1(N) is a k-phase \nbehavior word. LEMMA 3.10. For any k, n . N, the class of k-phase n-NW graphs is MSO de.nable. Moreover, \nthe tree-decomposition nw\u00adtd(N),where N is any k-phase n-NW, has tree-width at most 2k +2k-1 +1. From \nLemma 3.10 and Theorem 2.3 to obtain the following theorem, which also matches the 2ETIME lower bound \nfor this problem [16]. THEOREM 3.11. For any k . N, the emptiness problem for mP- DAs restricted to k \nphases is decidable, and decidable in time |M|O(2k). When the number of phases is .xed, the emptiness \nprob\u00adlem is in PTIME. Proofs can be found in Appendix B.  3.3 Emptiness of ordered multi-stack automata \nTurning to the orderedness restriction on multi-stack automata, we show that the multiply-nested words \nthat correspond to or\u00addered runs are of bounded tree-width (using the canonical tree\u00addecomposition), \nand hence admits a decidable emptiness problem. Arun . of an nPDA is ordered if whenever a pop action \nhappens on the stack j . [n], then all stacks of index less than j are empty: act1actm-1 if . = C1 --. \nC2 ... - ---. Cm, then for every i . [m - 1], if acti = popj and Ci = (q, s1,...,sn) then sh = E, for \neach h<j. The set ordered-Beh(M),for a mPDA M, is the set of all the ordered words of Beh(M). The emptiness \nproblem for mPDAs restricted to ordered behav\u00adiors is the problem of checking the emptiness of ordered-Beh(M). \nFor any n . N,an ordered n-nested word N is an n-NW in which nw -1(N) is a ordered word. LEMMA 3.12. \nLet n . N. The class of ordered n-NW graphs is MSO de.nable. Furthermore, the tree-decomposition nw-td(N), \nwhere N is any ordered n-NW, has width at most (n+1)\u00b72n-1 +1. From Lemma 3.12 and Theorem 2.3 we obtain \nthe following theorem, which also matches the 2ETIME lower bound for this problem [6]. THEOREM 3.13. \nThe emptiness problem for mPDAs restricted to ordered runs is decidable, and decidable in time |M|O(n.2n).When \nthe number of stacks is .xed, the problem is decidable in PTIME. Proofs can be found in Appendix B. \n 4. Distributed Automata with Queues and Stacks Distributed queue automata with stacks (DQSA) is an automaton \nmodel composed of a .nite number of processes and a .nite num\u00adber of .rst-in-.rst-out (FIFO) channels \nusing which they communi\u00adcate, and where the local processes are endowed with a single local stack each. \nEach FIFO queue has a unique sender process that can enqueue onto it, and a unique receiver process that \ndequeues from it. DEFINITION 4.1 (DISTRIBUTED QUEUE AUT. WITH STACKS). A distributed queue automaton \nwith stacks (DQSA) is a tuple M =(P, Q, ., G, Sender, Receiver, {Ap}p.P ) where P is a .\u00adnite set of \nprocess names, Q is a .nite set of queues, . is a .nite message alphabet, G is a .nite stack alphabet, \nand Sender: Q . P and Receiver: Q . P are two maps that assign a unique sender process and receiver process \nfor each queue, respectively. For ev\u00adery process p . P , Ap =(Sp,s0p,Fp,dp) is the machine at site p, \nwhere Sp is a .nite set of states, s0 p . Sp is the initial state, Fp . Sp is the set of .nal states, \nand dp = (dipnt,dspend,drpecv,dppush,dppop)where dp . (Sp \u00d7 Qp \u00d7 . \u00d7 Sp) is the set of send moves, where \nsend send Qp = { q . Q | Sender(q)= p }; send drpecv . (Sp \u00d7 Qp recv \u00d7 . \u00d7 Sp) is the set of receive \nmoves, where Qp recv = { q . Q | Receiver(q)= p };  dpush . (Sp \u00d7 Sp \u00d7 G) is the set of push moves; \n dpop . (Sp \u00d7 G \u00d7 Sp) is the set of pop moves;  dipnt . (Sp \u00d7 Sp) is the set of internal moves.  For \nthe rest of the section we .x M =(P, Q, ., G, Sender, Receiver, {Ap}p.P ) to be a DQSA, where Ap =(Sp,sp,Fp,dp) \n0 for every p . P . The semantics of DQSAs is as follows. A con.guration of a DQSA M is a tuple ({sp}p.P \n, {.p}p.P , {\u00b5q }q.Q) where for each p . P , sp . Sp and .p . G * are the state and the stack content \nof process p respectively, and for each queue q . Q, \u00b5q . . * is the content of q. The con.guration C \n= ({sp}p.P , {.p}p.P , {\u00b5q }q.Q) of M is the initial con.guration if sp = sp 0 and .p = E for each p \n. P ,and \u00b5q = E, for each queue q . Q. C is a .nal con.guration if sp . Fp,for every process p . P , \nand further all queues are empty, i.e. \u00b5q = E, for each q . Q, and all stacks are also empty, i.e. .p \n= E, for each p . P . Let the actions of process p be Bp = {intp, pushp, popp}. ( {send(p,q)}) . ( {recv(p,q)}),and \nB = Bp q.Qq.Qp.P be the alphabet of all actions. For any two con.gurations C = '' ({sp}p.P , {.p}p.P \n, {\u00b5q }q.Q) and C = ({sp}p.P , {.p' }p.P , {\u00b5 ' act q }q.Q), C - . C ' ,if act . B and one of the following \nholds: [Send] act = send(p,q), and there is a move (sp,q, m, s ' p) . dspend such that for each pE= \np, sp ' = spE,  \u00b5 ' q = m.\u00b5q, and for each qE= q, \u00b5 ' qE= \u00b5qE.  for each pE, .p ' E= .pE.  [Receive] \nact = recv(p,q), and there is a move (sp,q,m,sp' ) . drpecv such that for each pE= p, sp ' = spE,  \n\u00b5q = \u00b5q' .m, and for each qE= q, \u00b5q ' E= \u00b5qE.  for each pE, .p ' E= .pE.  [Push] act = push, and there \nis a move (sp,s ' ,a) . dp such pppush that for each pE= p, sp ' = spE,  for each qE, \u00b5 ' qE= \u00b5qE. \n . ' = a..p, and for each pE= p, . ' = .pE.  ppE [Pop] act = popp, and there is a move (sp,a,sp' ) \n. dppop such that for each pE= p, sp ' E= spE,  for each qE, \u00b5q ' E= \u00b5qE.  a..p ' = .p, and for each \npE= p, .p ' E= .pE. ' ) . dp  [Internal] act = intp, and there is a move (sp,spint such that  Init \nP1  Final P1 id l P1 :  ab c efgh jk mn Init P2 Final P2 567 P2 :  1234 9 1011121314 InitP3 FinalP3 \n\u00df.dEe .... P3 : a  \u00b5. Figure 3. A stack-queue graph. for each pE= p, s ' pE= spE,  for each qE, \n\u00b5 ' qE= \u00b5qE.  for each pE, .p ' E= .pE.  Let w = act1act2 ...actm-1 . B *.A run of M on w is a actm-1act1 \nsequence . = C1 --. C2 ... -----. Cm,where C1 is initial and Cm is .nal. The set of behaviors of M, Beh(M) \nis the set of words w . B * such that there is a run of M on w. A stack-queue graph (SQG) captures the \nbehaviors of DQSA as a graph. This graph captures the distributed behavior by modeling local behaviors \nof the process as disjoint linearly ordered sets of vertices with two additional kinds of edges: edges \nthat capture the nesting relation matching pushes and pops of the local processes (like in a nested word), \nand edges that match send-events of one process with receive-events in others. Formally, DEFINITION 4.2 \n(STACK-QUEUE GRAPHS). A stack-queue graph (SQG) over (P, Q, Sender, Receiver) (where P , Q are .nite \nsets, Sender : Q . P and Receiver : Q . P ) is a tuple SQG =( {(Vp, I nitp, F inalp,Lp,Ep )}p.P , {Eq \n}q.Q ), where (Vp, I nitp, F inalp,Lp,Ep ) is a 1-NW, for every p . P ;  Vp n Vp ' = \u00d8, for all p, \np ' . P with p = p ' ;  Eq . Vp \u00d7 Vp ' ,for some p, p ' . P with p = p ' .Further,for all u, x . Vp \nand v, y . Vp ' ,if (u, v) . Eq and (x, y) . Eq and u<Lp x holds, then v<L p y.  ' Any vertex v . Vp \nhas at most one edge of ((Eq). p.Pq.Qp.P (Ep)) incident on it. Figure 3 illustrates a stack-queue graph \nfor three processes. The properties de.ning stack-queue graphs (the de.nition above) can be easily expressed \nin MSO: LEMMA 4.3. For any tuple (P, Q, Sender, Receiver), the class of stack-queue graphs over it is \nMSO de.nable. The class of stack-queue graphs represent all potential behaviors of any DQSA. The precise \nqueue graphs corresponding to behav\u00adiors of a DQSA can be accepted by a graph automaton over queue graphs \nthat decorates each of these graphs with the DQSA states and checks whether there is a run of the DQSA \ncorresponding to the graph. Let us associate a function sqg that associates (as a 1-1 correspondence), \nthe stack-queue graph corresponding to any be\u00adhavior w. Then, LEMMA 4.4. For any DQSA M over (P, Q, Sender, \nReceiver), there is an effectively constructible graph automaton on stack\u00adqueue graphs over (P, Q, Sender, \nReceiver) such that sqg(Beh(M)) = L(GA). Stack-queue graphs are complex graphs, and several restrictions \nare required to make them tractable. In fact, they are of unbounded tree width: LEMMA 4.5. For any (P, \nQ, Sender, Receiver),where |P | > 2 and Q = \u00d8, the class of stack-queue graphs over (P, Q, Sender, Receiver) \nhas an unbounded tree-width. The architecture of a DQSA M is the directed graph that describes the way \nits processes communicate trough queues: Arch(M)=( P, { (Sender(q), Receiver(q)) | q . Q } ). In [17], \nit is proved that if the underlying architecture is a directed tree (where each process hence has only \none incoming queue) and if the processes are well-queuing, then the emptiness problem is decidable for \nDQSAs. The well-queuing assumption demands that each process may dequeue from an incoming queue only \nwhen its local stack is empty. The stack-queue graph in Fig\u00adure 3 corresponds to such a well-queuing \nbehavior. These proper\u00adties (well-queuing and tree architectures) can be expressed in MSO. Furthermore, \nwe can prove that these restrictions cause the graphs to be of bounded tree-width. This proof is quite \ninvolved, and is given in the technical report [20]. The idea is to .rst de.ne the notions of graph decompositions \nand their widths that extends the notion of tree-decompositions. If H is a class of graphs, then a H-decomposition \nof a graph G is a graph H .H where each node in H has an associated bag of vertices, where every edge \nin G is in the union of two adjacent bags in H, and where the nodes that contain a vertex of G are connected \nin H. We then show that stack-queue graphs over an architecture that is a directed tree can be decomposed \nwith a small width onto a nested word.This process relies on the observation that the global run can \nbe always be executed in a particular order where messages in queues never go beyond length 1. Then, \nby using the small tree-width of nested words, we obtain the following result. LEMMA 4.6. The set of \nall stack-queue graphs over a pair (P, Q, Sender, Receiver) whose underlying architecture is a di\u00adrected \ntree and are well-queuing, is MSO-de.nable, and further\u00admore, have tree-width bounded by 3n - 1 where \nn is the number of processes. From Lemma 4.6, we have: THEOREM 4.7. The emptiness problem for a well-queuing \nDQSA M with tree-architectures is decidable. The problem is decidable in time |M|O(n),where n is the \nnumber of processes of M. In fact, the precise analysis of the tree-width that leads to the above theorem \nimproves the complexity by one exponential over the one proved in [17], which gives an algorithm doubly \nexponen\u00adtial in n. 4.1 Distributed Queue Automata without stacks Distributed Queue Automata without \nstacks (DQAs) are the same model as that of DQASs except that the local stacks at each process are not \npresent. Even in this restricted setting, the emptiness prob\u00adlem is undecidable. We can capture behaviors \nusing queue graphs that are composed of n linear orders, one for each process, with edges connecting \nmatching sends and receives. Figure 4 illustrates a queue graph. In general, queue graphs of distributed \nqueue au\u00adtomata without stacks are also of unbounded tree width. Formally, we de.ne queue graph as a \nstack queue graph with an empty set of stack edges: DEFINITION 4.8 (QUEUE GRAPHS). A queue graph (QG) \nover (P, Q, Sender, Receiver), is a tuple QG =( {(Vp, Initp, Finalp,Lp)}p.P , {Eq}q.Q ),  I nitP1 \nF inalP1 P1 : I nitP2 F inalP2 P2 : I nitP3 P3 : F inalP3 Figure 4. A queue graph. where ( {(Vp, Initp, \nFinalp,Lp)}p.P , {Ep}p.P , {Eq}q.Q ) is a stack queue graph, where every Ep = \u00d8,for each p . P . The \nproperties de.ning queue graphs can be easily expressed in MSO: LEMMA 4.9. For any (P, Q, Sender, Receiver), \nthe class of queue graphs over it is MSO de.nable. Also, let qg be a function that associates to every \nbehavior of a distributed queue automaton the corresponding queue graph. LEMMA 4.10. For every DQA M, \nthere is a (constructible) graph automaton GA on queue graphs such that qg(Beh(M)) = L(GA). In [17], \nit was proved that when the architecture of a DGA is a polyforest the emptiness problem is decidable. \nAn architecture Arch(M) of a DQA M is a polyforest if the underlying undirected graph is acyclic. To \nbound the tree-width of queue graphs of polyforest architec\u00adtures, we note that we can reverse any edge \nof the graph, without changing its tree-width. Hence, we can direct queuing edges in a way to make the \nunderlying architecture a directed forest (note that since there are no stacks, the well-queuing assumption \nis satis.ed vacuously, see [20]). This resulting graph hence can be interpreted on a linear word (using \nthe same proof as for DQAS, except that now the nesting relation is not needed). Hence we obtain the \nfol\u00adlowing: LEMMA 4.11. Let (P, Q, Sender, Receiver) be a tuple where P and Q are .nite sets and Sender \n: Q . P and Receiver : Q . P . Then the class of polyforest queue graphs over (P, Q, Sender, Receiver) \nhas tree-width (even path-width) bounded by |P |. Furthermore, from Lemma 4.10, Lemma 4.9 , and Theorem \n2.3, we can conclude: THEOREM 4.12. The emptiness problem for polyforest DQAs is decidable, and decidable \nin time |M|O(n),where n is the number of processes of M.  5. Conclusions and further results The main \ncontribution of this paper is to provide a uniform frame\u00adwork using which we can prove decidability of \nemptiness of a vari\u00adety of automata with auxiliary storage. In this sense, our framework is the mother \nof several automata decidability results proved re\u00adcently in the literature, where complex but awkward \nrestrictions have been imposed to obtain decidability of emptiness. We also believe that our results \ncan help in the search of new automaton models that have a tractable emptiness problem using the princi\u00adples \noutlined by our framework. There are several other results that follow immediately from our work, that \nwe discuss below. Under-approximation of abstracted programs using tree-width: The analysis of abstracted \nconcurrent programs communicating through shared-variables is in general undecidable. These programs \ncan be modeled as multi-stack pushdown automata. In the last few years, syntactic restrictions on the \nbehaviors of those automata have been considered with the aim of making the analysis of such programs \ndecidable, e.g. bounded context-switches [22], bounded\u00adphases [15]), etc. Since all the known syntactic \nrestrictions correspond to graphs of bounded tree-width, we can consider the tree-width as a natural \nsemantic restriction to consider for under-approximations. Given a multi-stack automaton and k . N, the \nproblem of deciding whether there is a multiply nested word of tree-width k that is accepted by it is \ndecidable, as shown in our framework, and hence can be used as an under-approximation technique to explore \nthe state-space reached by a concurrent program. Note that this would cover all behaviors that explore \nk context-switches, and more, and yet has the same complexity. Improvement in complexity for DQSAs: As \nmentioned earlier, Theorem 4.7 improves the complexity of the emptiness problem for a well-queuing DQSA \nM with tree-architectures to one exponential in the number of processes; the algorithm given in [17] \nis doubly exponential. This upper bound complexity matches the EXPTIME lower-bound for the emptiness \nproblem on DQSAs [13]. Decidable emptiness problem for multi-stack pushdown automata with bounded reverse-phase: \nOur framework shows immedi\u00adately the decidability of other restrictions placed on automata with auxiliary \nstorage. For example, .x k . N and consider multi\u00adstack automata behaviors restricted to k reverse-phases,where \nin each reverse-phase, there is only one stack that is pushed into (but arbitrary pops of stacks are \nallowed). Then it easily follows that emptiness is decidable for this class, since the graphs correspond\u00ading \nto the runs of these automata are precisely the same as those of bounded-phase automata, save for the \norientation of the linear and nesting edges, and hence has the same tree-width. A general Parikh theorem: \nWe can prove a general Parikh theo\u00adrem [21] for all classes of automata that can be compiled to graph \nautomata of bounded tree-width. The idea is to encode the graph into a tree using the tree-decomposition, \nwith a unique vertex of the tree for every graph node. Since a depth-.rst traversal of the tree can be \ncaptured by a pushdown automata, we can build a context\u00adfree grammar that generates the graph nodes in \nsome order. Using the classic Parikh theorem for context-free grammars, we can show that the labels of \nthe graph nodes de.ne a semi-linear set. This is a generalization of the technique using in [15], where \na similar ar\u00adgument was used for proving a Parikh theorem for bounded-phase multi-stack automata. Extension \nto in.nite behaviors: Several of our results extend to automata over in.nite behaviors. For example, \nconsider ordered multi-stack B\u00a8uchi or parity automata on in.nite words. We can show that there are graph \nautomata on multiply-nested in.nite graphs (with appropriate B\u00a8uchi and parity conditions) that can sim\u00adulate \nthese automata, and further that these graphs have bounded tree-width. This proves that the emptiness \nproblem for this class of automata is decidable. (See [5] for recent results in this direc\u00adtion.) Similar \nresults can be obtained by extending the tractable distributed automata presented in this paper to in.nite \nwords.  There are interesting temporal logics suitable for expressing properties of single-stack pushdown \nsystems, like the logic CARET [4]). Natural extensions of temporal logics like CARET that allow to reason \nwith multi-stack pushdown automata are also possible, and can be proved decidable for all multi-stack \nautomata whose runs can be modeled by graphs of bounded tree-width.   Acknowledgments This work was \npartially supported by the NSF CAREER grant #0747041 and the French ANR-09-SEGI project Veridyc. References \n[1] R. Alur and P. Madhusudan. Visibly pushdown languages. In L. Babai, editor, STOC, pages 202 211. \nACM, 2004. [2] R. Alur and P. Madhusudan. Adding nesting structure to words. In O. H. Ibarra and Z. Dang, \neditors, Developments in Language Theory, volume 4036 of Lecture Notes in Computer Science, pages 1 13. \nSpringer, 2006. [3] R. Alur and P. Madhusudan. Adding nesting structure to words. J. ACM, 56(3), 2009. \n[4] R. Alur, K. Etessami, and P. Madhusudan. A temporal logic of nested calls and returns. In K. Jensen \nand A. Podelski, editors, TACAS, volume 2988 of Lecture Notes in Computer Science, pages 467 481. Springer, \n2004. [5] M. F. Atig. Global model checking of ordered multi-pushdown sys\u00adtems. In K. Lodaya and M. Mahajan, \neditors, Proceedings of the 30th Conference on FSTTCS, Leibniz International Proceedings in Infor\u00admatics, \nChennai, India, Dec. 2010. To appear. [6] M. F. Atig, B. Bollig, and P. Habermehl. Emptiness of multi-pushdown \nautomata is 2etime-complete. In M. Ito and M. Toyama, editors, Developments in Language Theory, volume \n5257 of Lecture Notes in Computer Science, pages 121 133. Springer, 2008. [7] T. Ball, R. Majumdar, T. \nD. Millstein, and S. K. Rajamani. Automatic predicate abstraction of C programs. In PLDI, pages 203 213, \n2001. [8] L. Breveglieri, A. Cherubini, C. Citrini, and S. Crespi-Reghizzi. Multi\u00adpush-down languages \nand grammars. Int. J. Found. Comput. Sci., 7(3): 253 292, 1996. [9] B. Courcelle. The expression of graph \nproperties and graph trans\u00adformations in monadic second-order logic. In G. Rozenberg, edi\u00adtor, Handbook \nof Graph Grammars, pages 313 400. World Scienti.c, 1997. [10] B. Courcelle and S. Olariu. Upper bounds \nto the clique width of graphs. Discrete Applied Mathematics, 101(1-3):77 114, 2000. [11] B. Courcelle, \nJ. A. Makowsky, and U. Rotics. Linear time solvable optimization problems on graphs of bounded clique-width. \nTheory Comput. Syst., 33(2):125 150, 2000. [12] J. Flum and M. Grohe. Parameterized Complexity Theory \n(Texts in Theoretical Computer Science. An EATCS Series). Springer-Verlag New York, Inc., Secaucus, NJ, \nUSA, 2006. [13] A. Heu\u00dfner, J. Leroux, A. Muscholl, and G. Sutre. Reachability analysis of communicating \npushdown systems. In C.-H. L. Ong, editor, FOSSACS, volume 6014 of Lecture Notes in Computer Science, \npages 267 281. Springer, 2010. [14] J. E. Hopcroft and J. D. Ullman. Introduction to Automata Theory, \nLanguages, and Computation. Addison-Wesley, 1979. [15] S. La Torre, P. Madhusudan, and G. Parlato. A \nrobust class of context\u00adsensitive languages. In LICS, pages 161 170. IEEE Computer Society, 2007. [16] \nS. La Torre, P. Madhusudan, and G. Parlato. An in.nite automaton characterization of double exponential \ntime. In M. Kaminski and S. Martini, editors, CSL, volume 5213 of Lecture Notes in Computer Science, \npages 33 48. Springer, 2008. [17] S. La Torre, P. Madhusudan, and G. Parlato. Context-bounded analysis \nof concurrent queue systems. In C. R. Ramakrishnan and J. Rehof, editors, TACAS, volume 4963 of Lecture \nNotes in Computer Science, pages 299 314. Springer, 2008. [18] S. La Torre, P. Madhusudan, and G. Parlato. \nAnalyzing recursive programs using a .xed-point calculus. In M. Hind and A. Diwan, editors, PLDI, pages \n211 222. ACM, 2009. [19] S. La Torre, P. Madhusudan, and G. Parlato. Model-checking pa\u00adrameterized concurrent \nprograms using linear interfaces. In T. Touili, B. Cook, and P. Jackson, editors, CAV, volume 6174 of \nLecture Notes in Computer Science, pages 629 644. Springer, 2010. [20] P. Madhusudan and G. Parlato. \nThe tree width of au\u00adtomata with auxiliary storage. In IDEALS Technical Report http://hdl.handle.net/2142/15433, \nApril 2010. [21] R. Parikh. On context-free languages. J. ACM, 13(4):570 581, 1966. [22] S. Qadeer and \nJ. Rehof. Context-bounded model checking of con\u00adcurrent software. In N. Halbwachs and L. D. Zuck, editors, \nTACAS, volume 3440 of Lecture Notes in Computer Science, pages 93 107. Springer, 2005. [23] D. Seese. \nThe structure of models of decidable monadic theories of graphs. Ann. Pure Appl. Logic, 53(2):169 195, \n1991. [24] W. Thomas. On logics, tilings, and automata. In J. L. Albert, B. Monien, and M. Rodr\u00b4iguez-Artalejo, \neditors, ICALP, volume 510 of Lecture Notes in Computer Science, pages 441 454. Springer, 1991.  Appendix \nA. Tree-width of bounded-context multiply nested words In this section we show that any k-context multiply \nnested word graph has a tree-width upper-bounded by k +1. LEMMA A.1. For any k . N, the tree-width of \nany k-context mNW N is at most k +1. The proof is simple, and we sketch the main idea. Let us create \na tree-decomposition by creating a tree where the root has k subtrees, each subtree corresponding to \na stack. For each stack s, wetakethe contexts that involve the stack s, remove the rest of the events, \nand build the tree (and the bags) as in the canonical tree-decomposition of a singly nested word (of \nwidth at most 2). These trees along with the root, and the bags associated with the nodes, capture all \nnesting edges and all linear edges, except the linear edges that cross contexts (which are at most k \n- 1 in number). Now, for every pair of nodes u and v,where v is the linear successor of u,and where u \nand v are in different contexts, let us add u to all nodes in the path from u to v. Clearly, the bag-sizes \nincrease by at most k - 1,and the resulting tree-decomposition captures all edges and is of width at \nmost k +1.  B. On the tree-width of bounded-phase and ordered multiply nested words In this section \nwe give an upper-bound of the tree-width of both bounded-phase and ordered multiply nested word graphs. \nFor a given k and n, the tree-width of any k-phase n-NW is O(2k), instead the tree-width of any ordered \nn-NW is O(n \u00b7 2n). We show such bounds by giving a general technique to upper\u00adbound the width of the \ncanonical tree decomposition can-td(N), for any n-NW which is k-phase (Section B.1) or ordered (Sec\u00adtion \nB.2). Proof strategy: Our proof strategy is the following. First, notice that in any multiply nested \nword, the canonical tree decomposition we de.ned has all edges except the pop-edges, i.e. edges (u, v) \nwhere v is a pop-node for some stack (other linear edges as well as all nesting edges are local in the \ntree decomposition). We de.ne, .rst, a notion of an extension of a multiply nested word, which is the \nsame as the multiply nested word except that every edge (u, v) where v is a pop-node is replaced by a \npath of nodes which, intuitively, connects u to v by taking a backward path along the linear order, all \nthe way up to the push-node v ' corresponding to v and then goes on to v. The crucial property of this \nexpansion is that all edges between u and v become local in the tree. This backward path is constructed \nso that it utilizes nesting edges (of the same kind as the stack v is popping from) in order to reach \nv ' .  This extension of a multiply nested word will be used in both the proofs of bounded phase words \nas well as ordered multi-stack words. We show that this extension preserves the bounded phase property \nas well as the ordered-ness property. The extension of a multiply nested word N then helps us build a \nnew tree-decomposition over the same tree as we need in the the\u00adorems; i.e. using a different setofbags \nbut overthe same tree T deriving from can-td(N). We show that this tree-decomposition certainly has width \nat least as the width of can-td(N), and hence establishing that the width of this tree decomposition \nis bounded by the appropriate bounds for bounded-phase multiply nested words and ordered multiply nested \nwords is suf.cient to prove our theo\u00adrems. We then de.ne a notion of generator trees corresponding to \nev\u00adery node of a multiply nested structure N. Intuitively, the generator tree of a node v consists of \nthe copies of the node v in the exten\u00adsion of N, and a copy (v, h ' ) of v is the child of a copy (v, \nh ' ), if (v, h ' ) was created as a relabeling of (v, h) in a backward path that replaced a pop-edge. \nThe generator tree is a technical structure that has certain structural properties (Lemma B.5 and Lemma \nB.6) that allows us to count the widths of the decompositions of both bounded phase words and ordered \nmultiply nested words. Proof outline: Throughout the section, every time we refer to N we mean the n-NW \nN =(V, Init, Final, L, {Ej}j.[n]).More\u00adover, whenever we refer to the ordering among N nodes, we always \nintend the linear ordering <L. We also consider an ordering on L edges: if e1 =(a, b) and e2 =(c, d) \nwith e1,e2 . L,then e1 <e2 if b<L c.Furthermore, T is the tree obtained as (T, bag)= can-td(N).If (u, \nv) . Ej with j . [n], we say that u is a push-j node, v is a pop-j node, and that u and v are matched. \nMoreover, an L edge (u, v) is called a pop-j edge, if v is a pop-j node. For any N, we de.ne an n-NW \nN ' =(V ' ,Init ' ,F inal ' ,L ' , {Ej' }j.[n]), called the extension of N, as follows. Intuitively, \nN ' is obtained from N by replacing all the pop edges with a sequence of nodes. More precisely, consider \na pop-j edge (u, v) and suppose that all the pop edges before (u, v) have already been replaced with \npaths to create a nested word N ' . Then, the pop edge (u, v) is replaced with the back-path of N ' starting \nfrom u and ending with the push node u ' that matches v. The back-path is built in the following manner. \nSuppose we have reached a node b.Now, if b is a pop-j node notice that v is also a pop-j node then \nthe next node in the back-path is a where a is the push-j node matched to b ((a, b) . Ej' ). (In this \nway we get closer to u ' ,which must occur before a, and hence skipping all nodes between b and a.) Otherwise, \nthe next node in the path will be the L ' predecessor of b. In other words, the back-path from u to u \n' is formed by taking linear predecessors at each state, except taking nesting edges for the stack j. \nObviously all the nodes in back-paths will be renamed so that they will be unique in N ' . Now we formally \nde.ne the extension of a multiply nested word N, Ext(N). We do this by de.ning a function expand that \ntakes the .rst pop-edge in a nested word, and replaces it by a back-path. We will .rst start with the \nnested word N, with renamed vertices. Then, we will apply expand to it repeatedly till all pop-edges \nare replaced (and we reach a .xed-point). This .xed-point will be the extension of N. First, let us de.ne \nback-paths formally. Back-paths and extensions: Let EV, lInit, pL, {E j }j.[n]) be a n-NW and let (u, \nv) N =(EFinal, Ebe a pop-edge (i.e. v is a pop-node and u is the linear predecessor of v). Let (v ' ,v) \n. E j (j . [n]). Then BackP athE(v) is the unique N node sequence v1 ...vt such that v1 = u and vt = \nv ' ,and  For every i . [t - 1],if vi is a pop-j node, then vi+1 is the  corresponding push-node, i.e. \nthe node such that (vi+1,vi) . E j. Otherwise vi+1 is the linear predecessor of v (i.e. the node such \nthat (vi+1,vi) . LE). We now de.ne the extension of a multiple nested word, using a systematic replacement \nof every pop-edge (u, v) by a linearly ordered sequence of nodes formed by a back-path from u to the \npush-node v ' corresponding to v. Moreover, in the linearly ordered sequence that replaces the pop-edge, \nno node will have nesting edges incident on it. We will perform this surgery on all pop-edges, going \nfrom the left-most one to the right-most; this is important as back-paths for a pop-edge may utilize \nthe extensions of pop-edges that occur to the left of it. Let us .x a n-NW N =(V, Init, Final, L, {Ej \n}j.[n]).The extension of N will have vertices of the form (v, i) where v . V and i . N. Let N0 be thesameasnestedword \nN, except that each vertex v . V gets renamed to (v, 1).Inother words, N0 =(V \u00d7 {1}, Init0, Final0,L0, \n{Ej 0}j.[n]), where the various edges in N0 are appropriately de.ned. We now construct Ni+1 from Ni using \nthe following algorithm. Let Ni =(Vi, Initi, Finali,Li, {Eji}j.[n]),where Vi . V \u00d7 N. Let ((u, 1), (v, \n1)) be the .rst pop-edge of its kind (i.e. with indices 1)in Ni according to the linear ordering Li (if \nno such pop\u00adedge exists, then we set Ni+1 = Ni, and reach a .xed-point). Then Ni+1 =(Vi+1, Initi, Finali,Li+1, \n{Eji}j.[n]) is de.ned as follows (note that the initial, .nal, and nesting edges do not change). Let \nthe back-path from (u, 1) be BackP athNi ((u, 1))= (z1,h1) ... (zt,ht). Note that any node occurs at \nmost once in the back-path. Let us now relabel this path so that the nodes (zj ,hj)get renamed to some \n(zj,h ' j ) so that they are not in Vi and do not get repeated in the back-path: relabelVi (E)= E  \nrelabelVi (w, (x, m))= relabelVi (w), (x, m ' ) where m ' is the least positive integer such that (x, \nm ' ) . Vi and does not occur in relabelVi (w).  Let relabelX (BackP athN ' ((u, 1))) = (z1,h1' ) ... \n(zt,ht' ). Then, Vi+1 =(Vi .{(zi,h ' i)| i . [t]}) and the set Li+1 is: Li+1 =(Li\\{((u, 1), (v, 1))}).{((zi,h \n' i), (zi+1,h ' i+1)) | i . [t]} .{((u, 1), (z1,h1' )), ((zt,h ' ), (v, 1))} t Intuitively, we remove \nthe linear edge from (u, 1) to (v, 1)) and replace it with the backward path from (u, 1), appropriately \nrenamed. We apply the above algorithm to systematically replace pop\u00adedges by a linearly ordered set of \nnodes, left to right, till we reach a .xed-point, where there are no pop-edges of the form ((u, 1), (v, \n1)). The .nal multiply nested word will be the exten\u00adsion of N.  Notice that, N ' is the same as N except \nthat pop edges of N are replaced by nodes that are neither the target nor the source of any nesting edges. \nTherefore, if N is a k-phase MNW then also N ' is, and if N is an ordered n-NWthensois N ' : LEMMA B.1. \nLet N ' be the extension of an n-NW N. Then, (1) N ' is k-phase iff N is k-phase, (2) N ' is ordered \niff N is ordered. It is easy to prove that if ((a, i), (b, j)) is an edge in N ' ,that is ((a, i), (b, \nj)) . (L ' . Eh' )),then a and b are connected h.[n] by an edge in T , which means that either a is the \nparent of b or vice-versa. By using N ' we de.ne a new tree decomposition of N whose underlying tree \nis T . ' 2V ' We de.ne a map bag : V . as follows. Map bag associates the minimum set of vertices to \neach node of T according to the following rules: 1. v . bag ' (v),for all v . V . 2. if u is the parent \nof v in T ,then u . bag ' (v),for every v . V . 3. if (u, v) is a pop edge of N,and BackP athN ' ((u, \n1))= (u1,h1) ... (ut,ht),then u . bag ' (ui),for every i . [t].  Notice that the .rst and second condition \nde.ning the map bag (see De.nition 3.6) and the .rst and second condition in the de.nition of bag ' are \nthe same. They only differ in the third one: if u ' is such that (u ' ,v) . Ej, then condition three \nof De.nition 3.6 says that u is added to bag(z) for all nodes z lying along the unique shortest path \nin T between u and u ' . Similarly the third condition of the de.nition above adds u to the bag ' of \nall the T nodes along a path in T from u to u ' which may not be the shortest. However, that path has \nto pass trough all the nodes of the shortest path between u ' and u. Thus, (T, bag ' ) is a tree decomposition \nof N, and more importantly for us bag(z) . bag ' (z),for every node z of T . Therefore, we can upper-bound \nthe size of bag(u) by considering the size of bag ' (u) for every u . V , as stated in the next lemma. \nLEMMA B.2. Let N be an n-nested word, and T =(T, bag)= can-td(N). Then, T ' =(T, bag ' ) is a tree decompositions \nof N where width(T ) = width(T ' ). Furthermore, for every v . V , |bag ' (v)|= dv +1,where dv = |{ (v, \nh). V ' | h . N}|. Generator Trees: A convenient way to calculate dv (in the above lemma) is to represent \nthe set of N ' nodes {(v, h). V ' | h . N}as a tree, for each v . V .Let (v, h), with h> 1, be a node \nof N ' , and let (u, 1) be the greatest push node of N ' that occurs before (v, h). Intuitively, (v, \nh) is one of the node of the path between that have replaced the pop edge (u, v) of N. By de.nition of \nN ' , (v, h)is generated because there is another node (v, h ' ) with h ' <h in BackP ath((u, 1)). We \ncall (v, h ' ) the generator of (v, h).Note that for every node (v, h) with h> 1 there is a unique generator \nof it (though the vice-versa does not hold). ' DEFINITION B.3 (GENERATOR TREES). Let N be the extension \nof an n-nested word N, and let V be the set of nodes of N.For every v . V , we de.ne a tree Tv as follows: \n (v, 1) is the root of Tv.  if (v, h ' ) is the generator of (v, h) then (v, h) is a child of (v, h \n' ).  For every v . V ,the tree Tv is called the generator tree of v. Observe that, for a given N node \nv, all the nodes (v, h) in N ' are also nodes of Tv, thus the value dv corresponds to the number of nodes \nof Tv, We can also associate a stack to every node of generator tree, except the root. If a node (v, \n1) is the .rst pop node after (v, h) (where h> 1), and if v is a pop node of stack j, then we say that \nj is the stack of (v, h). Intuitively, the stack associated with (v, h) is the stack whose popping led \nto a back-path that created (v, h). In the following we give some properties of generator trees that \nwill be instantiate later for the case in which N is bounded-phase and ordered. Intuitively, .x a stack \nj; then, any node in a multiply nested word can be touched only once on a backward path that is caused \nby a pop of stack j, except that when the node is a push onto stack j, in which case it may be touched \ntwice. This is true because the backward path caused by a pop to stack j takes nesting edges of stack \nj as much as possible, hence skipping the nodes between the nesting edges it takes. The .rst lemma states \nthat if v is a push onto stack j, the root of the generator tree of v, namely (v, 1), has at most n +1 \nchildren at most two of these children may be of stack j, and all the other children must be of distinct \nstacks. LEMMA B.4. If v . V is a push-j node then the root (v, 1) of Tv has at most two children of stack \nj. Moreover, for every j ' = j, (v, 1) has at most one child of stack j ' . Proof By contradiction suppose \nthat (v, 1) has at least three chil\u00addren of stack j. Since a back-path goes always backward it contains \ndistinct nodes. Therefore there must exist three pop-j edges in N, say e1 =(u1,v1),e2 =(u2,v2),e3 =(u3,v3), \nsuch that (v, 1)is contained in BackP athN ' ((ui, 1)) for all i . [3]. Suppose that e1,e2 and e3, in \nthe order, are the .rst three pop edges of N having the above property. It is easy to see that (v1, 1) \nis the matching pop of (v, 1).Now, BackP athN ' ((u2, 1)) to reaches (v, 1) must pass through (v1, 1) \n(a back-path always goes backward and since the Ej ' relation is nested a back-path can never jump in \nbetween (v, 1) and (v1, 1)). Thus, when BackP athN ' ((u2, 1)) reaches (v1, 1), it goes directly to (v, \n1). This entails that the matching push of (v2, 1) occurs before (v, 1).Now, BackP athN ' ((u3, 1)) must \npass through (v2, 1) to reach (v, 1).But, (v2, 1) is a pop-j node and thus the back-path jumps directly \nto the matching push of (v2, 1), which comes before (v, 1). Since a back-path goes always backward, (v, \n1) can never be reached by BackP athN ' ((u3, 1)). This is a contradiction. In similar way we prove that, \nif j ' = j then (v, 1) has at most one child of stack j ' . By contradiction, let e1 =(u1,v1) and e2 \n=(u2,v2) be the .rst two pop-j ' edges of N such that BackP athN ' ((u1, 1)) and BackP athN ' ((u2, 1)) \ncontain (v, 1). If BackP athN ' ((u1, 1)) passes through (v, 1) means that the push-j node matched by \nthe (v1, 1) must occur before (v, 1).Now BackP athN ' ((u2, 1)) must pass through (v1, 1) and hence jumps \ndirectly to the matched push-j node matched with (v1, 1).Since such a node comes before (v, 1) and back-paths \nnever go forward we have that (v, 1) cannot be reached by BackP athN ' ((u2, 1)). The second property \nwe need is that for any node v, any non\u00adroot node in the generator tree of v has children whose stacks \nare distinct from each other. Moreover, if v is not a push, then the root also has children whose stacks \nare all distinct from each other. LEMMA B.5. Let (z, h). N ' . Then, if h> 1 or z is not a push node \nof N, then for every j . [n], the node (z, h) has at most one child of stack j in Tz. Proof If h> 1 then \n(z, h) must be a node of a path that has replaced a pop edge, say (u, v) of N. Suppose that e1 =(u1,v1) \nand e2 =(u2,v2) are the .rst two pop-j edges (in the order) of N such that BackP athN ' ((u1, 1)) and \nBackP athN ' ((u2, 1)) contain (z, h). Thus, (z, h) <L ' (u1, 1) <L ' (v1, 1) <L ' (u2, 1). Since BackP \nathN ' ((u1, 1)) passes through (z, h) implies that the push-j node matched by the (v1, 1) occurs before \n(z, h).Now  BackP athN ' ((u2, 1)) has to pass through (v1, 1), which is a pop\u00adj node, and hence jumps \ndirectly to the push-j node matched to (v1, 1). Such a node appears before (z, h) and since back\u00adpaths \nonly go backward we have that (v, 1) is never reached by BackP athN ' ((u2, 1)) which contradicts the \nhypotheses. The other case in which (z, 1) is not a push node is similar to the case above and we do \nnot give it here. 0 B.1 Tree-width of bounded-phase multiply nested word graphs In this section we show \nthat the tree-width of any k-phase mNW N is O(2k). From Lemma B.1, the extension N ' of N is also a k-phase \nn-NW. Thus, we de.ne phaseN ' to be the map that associates to every node (v, h) of N ' its phase number. \nThe next lemma, which is a re.nement of Lemma B.4, says that for any push-node v, the phase numbers of \nthe children of the root of the generator tree of v are not less than that of the root, and further, \nall phase numbers of the children of the root are distinct from each other, save for one child. This \nbounds the number of children of the root to k - j +2, if the root has phase j. LEMMA B.6. For every \npush node v . V , the phase of the children of the root (v, 1) of Tv is greater or equal to the phase \nof (v, 1). Moreover, except for one child of (v, 1), all the other children have different phase number. \nProof If (v, h) is a child of (v, 1),then (v, 1) <L ' (v, h),and hence phaseN ' ((v, 1)) = phaseN ' ((v, \nh)). Now, if the stack number of (v, h) is different from the stack number of (v, 1)then phaseN ' ((v, \n1)) < phaseN ' ((v, h)). Moreover, if (v, h) and (v, h ' ) are two children of (v, 1) with different \nstack number then phaseN ' ((v, h))= phaseN ' ((v, h ' )). Thus, from Lemma B.4 we can conclude the proof. \n0 By using a similar argument of the previous proof, and Lemma B.5, we can show the following lemma, \nwhich says that for any v,the children of a non-root node (v, h) in the generator tree for v have distinct \nphases and have phases greater than the phase of (v, h). Moreover, this is also true for the root (v, \n1) provided v is not a push-node. LEMMA B.7. Let (v, h). N ' . Then, if h> 1 or v isnot a push node of \nN, then for every child (v, h ' ) of (v, h) in Tv, phaseN ' ((v, h)) < phaseN ' ((v, h ' )). Moreover, \nfor every phase number p> phaseN ' ((v, h)), there is at most one child (v, h ' ) of (v, h) such that \nphaseN ' ((v, h ' ))= p. By using the previous lemma we can upper-bound the number of nodes of the sub-tree \nof Tv rooted in any internal node of Tv, for every node v of N.Let f :[k] . N de.ned as: f(i)= k 1+f(j) \nfor every i . [k - 1],and f(k)=1.Bya j=i+1 simple calculation it is easy to prove that f(i)=2k-i.Thus,we \ncan upper-bound the number of nodes of any subtree of Tv rooted in an internal node (v, h) with f(phaseN \n' ((v, h))). Now by instantiating Lemma B.6, we have that k k dv = 1+ f(1) + f(i)=2k +2k-1 , i=1 and \nby Lemma B.2 follows that the width of the tree decomposition can-td(N) of N is at most 2k +2k-1 +1. \nTHEOREM B.8. The tree-width of any k-phase mNW is at most 2k +2k-1 +1.  B.2 Tree-width of ordered multiply \nnested word graph In this section we show that the tree-width of any ordered n-nested 2n-1 words N is \nO(n \u00b7 ). As in the previous section, we prove such a result by upper-bounding the number of nodes of \neach tree Tv, for every node v of N. In the following we instantiate Lemma B.5 for ordered multiply nested \nwords. We show that for any internal node (v, h) of the generator tree of a node v, the stacks of the \nchildren of v are strictly greater than that of v. The reason why the stack of a child of (v, h) cannot \nbe lower than that of v is because of the ordered-ness of the stack accesses if the back-path of a pop \nof stack j ' leads through a pop of stack j, then we must have that j = j ' (the reason why it cannot \nj = j ' is also argued below). Hence, the depth of the tree gets bounded by the number of stacks, n, \nand each non-root node has at most n - 1 children. LEMMA B.9. If (v, h). N ' is a stack j node with h> \n0, then (1) the stack j ' for any child of the node (v, h) is such that j ' >j, and (2) the stacks for \nthe children of the node (v, h) are all distinct. Proof Case (2) follows from Lemma B.4. Case (1) is \nproved by contradiction and we distinguish two cases, one when j ' <j and the other one for j ' = j.Let \n(v, h ' ) be a child of (v, h),and suppose that (v, h ' ) is a stack j ' node. Since h, h ' > 1, (v, \nh)and (v, h ' ) are both lying on a two different paths that replace two different pop edges of N,say \ne1 =(u1,v1) and e2 =(u2,v2). Thus, we have that (v, h) <L ' (v1, 1) <L ' (u2, 1) <L ' (v, h ' ). The \nfact that BackP athN ' ((u2, 1)) has to visit (v, h) to reach the matching push-j ' node of (v2, 1) means \nthat it occurs before the pop-j (v1, 1). Now if j ' <j, it means that there is pop-j node that comes \nafter a push-j ' node that has not matched yet. Since j ' <j,this contradicts the ordered-ness property \nof N ' and hence N. Instead, if j ' = j then BackP athN ' ((u2, 1)) will never visit (v, h) because between \n(v, h) and (u2, 1) there is a pop-j node whose matching pop occurs before (v, h). 0 For every i . [n], \nlet us de.ne the map f :[n] . N as k f(i)= 1+f(j) if i . [n - 1] and f(n)=1. Notice j=i+1 that f(i)=2n-i. \nFrom Lemma B.9, It is easy see that f(i) upper\u00adbounds the number of nodes of any Tv subtree rooted in \none of its internal node which is a stack i node. Thus, from Lemma B.4 we can conclude that the following \nupper-bounds the number of nodes of any tree Tv. 1+(n +1)f(1) = 1+(n +1) \u00b7 2n-1 . Now from Lemma B.2 \nwe can conclude with the main theorem of the section. THEOREM B.10. The tree-width of any ordered n-NW \nis at most n \u00b7 2n-1 .    \n\t\t\t", "proc_id": "1926385", "abstract": "<p>We propose a generalization of results on the decidability of emptiness for several restricted classes of sequential and distributed automata with auxiliary storage (stacks, queues) that have recently been proved. Our generalization relies on reducing emptiness of these automata to finite-state <i>graph automata</i> (without storage) restricted to monadic second-order (MSO) definable graphs of bounded tree-width, where the graph structure encodes the mechanism provided by the auxiliary storage. Our results outline a uniform mechanism to derive emptiness algorithms for automata, explaining and simplifying several existing results, as well as proving new decidability results.</p>", "authors": [{"name": "P. Madhusudan", "author_profile_id": "81100489757", "affiliation": "University of Illinois at Urbana-Champaign, URBANA, IL, USA", "person_id": "P2509618", "email_address": "madhu@illinois.edu", "orcid_id": ""}, {"name": "Gennaro Parlato", "author_profile_id": "81332520215", "affiliation": "LIAFA, CNRS and University of Paris Diderot, France., URBANA, IL, France", "person_id": "P2509619", "email_address": "gennaro@liafa.jussieu.fr", "orcid_id": ""}], "doi_number": "10.1145/1926385.1926419", "year": "2011", "article_id": "1926419", "conference": "POPL", "title": "The tree width of auxiliary storage", "url": "http://dl.acm.org/citation.cfm?id=1926419"}