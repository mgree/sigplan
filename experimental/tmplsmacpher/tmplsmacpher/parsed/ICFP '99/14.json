{"article_publication_date": "09-01-1999", "fulltext": "\n Calling hell from heaven and heaven from hell Sigbjorn Finne Daan Leijen Erik Meijer University of Glasgow \nUniversity of Utrecht University of Utrecht sofOdcs, gla. ac .uk daanOcs.uu.nl erikOcs, uu. nl Simon \nPeyton Jones Microsoft Research Cambridge simonpj @microsoft. com Abstract The increasing popularity \nof component-based programming tools offer a big opportunity to designers of advanced pro- gramming languages, \nsuch as Haskell. If we can package our programs as software components, then it is easy to inte- grate \nthem into applications written in other languages. In earlier work we described a preliminary integration \nof Haskell with Microsoft's Component Object Model (COM), focusing on how Haskell can create and invoke \nCOM ob-jects. This paper develops that work, concentrating on the mechanisms that support externally-callable \nHaskell func- tions, and the encapsulation of Haskell programs as COM objects. Introduction \"Component-based \nprogramming\" is all the rage. It has come to mean an approach to software construction in which a program \nis an assembly of software components, per-haps written in different languages, glued together by some \ncommon substrate [16]. The most widely used substrates are Microsoft's Component Object Model (COM), \nand the Common Object Request Broker Architecture (CORBA). The language-neutral nature of these architectures \noffers a tremendous new opportunity to those interested in exotic languages such as Haskell (our own \ninterest): if we can present our programs in COM or CORBA clothing, then the client programs will neither \nknow nor care that the program is written in Haskell. Our Haskell programs can thereby inter-operate \nwith a huge variety of other software, and a would-be user of Haskell is not faced with an all-or-nothing \nchoice. In an earlier paper we described how to instantiate and in- voke COM objects from a Haskell program \n[11]. In that paper we implied that it would be but a short step to be able to seal up a Haskell program \ninside a COM object, thus completing the picture. In practice, this ability proved more subtle than we \nhad supposed. This paper tells the story. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advan- tage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. ICFP '99 9 99 Paris, France &#38;#169; 1999 ACM 1-58113-111-919910009_. \n$ 5.00  The main contribution is the overall design of our Haskell COM server. More specifically: Our \ndesign is carefully factored, so that it can easily work with a variety of Haskell implementations, in-cluding \ninterpreters (the latter is trickier than it may at first appear). Most of the required functionality \nis encapsulated in Our separate H/Direct tool, or in li- brary modules written in Haskell. This \"arms-length\" \ndesign does not come at the price of convenience; it is still extremely easy to create COM components, \nand to implement a COM component in Haskell. Many other COM interfaces have a tighter, and hence less \nportable, integration with the compiler (Visual Java, for exam- pie). The only facility required from \nthe Haskell implemen- tation is a foreign language interface that (a) supports the import and export \nof Haskell functions, and (b) provides hooks for managing pointers from Haskell to the external world, \nand back again. Our earlier paper described :foreign import and :foreign export, exten- sions to Haskell \nthat allow it to call, and be called by, an external program. It turned out that to support callbacks \nand COM objects we need a more dynamic form of these primitives, :foreign import dynamic and :foreign \nexport dynamic. We motivate ~md describe these primitives (Section 3). Even though COM does not support \nparametric poly- morphism, we show how polymorphism can be used to: encode the (interface) inheritance \nstructure of in- terface pointers; connect interface pointers with their globally-unique identifiers \n(GUIDs); and ensure that object vector tables are only paired with appropriate object states (Section \n5). COM is very general, but it requires quite a bit of C++ code to build a COM object, usually supported \nby \"wizards\" of some sort. We are instead able to pro- vide a library of higher-order functions that \nmake it easy to construct COM objects without wizardly sup- port (Section 6). Overall, we give an elegant \nand easy-to-use design for using building and using COM objects in Haskell. In some ways there is nothing \nreally difficult about it, but it has neverthe- less taken us over a year to evolve, so it is certainly \na more subtle task than we initially appreciated. number of files and tools that the programmer hasto \ndeal with. Figure 1: A COM component in Haskell Overview We begin by giving an overview of our architecture \n(Fig- ure 1). A Haskell program (grey box) that implements a COM component consists of three parts: \nThe application code, written in Haskell by the pro- grammer (labelled \"user\" in Figure 1).  A collection \nof automatically-generated Haskell \"boil- erplate modules\", one per COM class. Each of these modules \nis generated by our H/Direct tool from an In- terface Definition Language (IDL) specification of the \nclassJ These modules deal with the \"impedance mis- match\" between Haskell and COM.  A Haskell library \nmodule, Com, which exports all the functions needed to support COM objects in Haskell (labelled \"library\"); \nand a C library module that pro- vides some run-time support.  Our earlier paper discusses the pros \nand cons of using a sep- arate interface definition language, IDL, to define the inter- face between \nCOM components, and we do not repeat that discussion here [2]. Notice, however, that we use IDL and H/Direct \nboth when invoking a COM object from a Haskell program, and when implementing a COM object in Haskell. \nIn each case data flows across the border in both directions, so there are clear similarities. Notice \nthat H/Direct generates only Haskell modules; it does not also generate C code. This design choice minimise \nthe 1Optionally, the boilerplate code can be put inside one module.  3 The foreign function interface \nH/Direct generates Haskell code that marshalls values be- tween Haskell and the foreign language. But \nin the end, it must generate a real call to the foreign procedure, passing parameters. This foreign call \ncan only be expressed using some extension to the Haskell language. The same is true if we want a foreign \nprocedure to call a Haskell function. In this section we describe a set of language extensions that address \nthis need. We have carefully minimised what is required from the lan- guage implementation, while maximising \nthe work done by H/Direct. In this way, any Haskell that implements our ex- tensions can interface with \nCOM, using the implementation- independent H/Direct to do most of the work. 3.1 Foreign static import \nand export Earlier versions of GHC (the Glasgow Haskell Compiler) provided ccall (or even casm) to invoke \na C procedure [12]. However, while this facility is (fairly) easy to support in a compiler that uses \nC as an intermediate language, it is a bit more difficult when using a native code generator, and well-nigh \nimpossible when using an interpreter such as Hugs. Furthermore, it says nothing about how to allow C \nto call Haskell, or how to inter-operate with procedures with non-C calling conventions. Our new foreign \nfunction interface is much simpler. Here is an example of how to import a foreign procedure: foreign \nimport \"hash32\" hash :: Int -> IO Int This foreign declaration is modeled directly on the primitive \ndeclaration that Hugs has supported for some time. The declaration defines the Haskell If} action hash \nwhich, when invoked, will call the external procedure hash32. The implementation of hash also takes care \nof con- verting between the Haskell representation of an Int and the corresponding external representation. \nThe result of hash has type I0 Int rather than simply Int, to signal that hash might perform some input/output \nor have some other side effect. We give a short summary of the If} monad in the Appendix. The range of \ntypes that can be passed to and from a foreign- imported procedure is deliberately restricted to the \n(small) set of primitive types. By a \"primitive type\" we mean one that cannot be defined in Haskell, \nsuch as Int, Float, Char. Only the language implementation knows the representation of primitive types, \nand so only the language implementation can marshall them. For all other types, such as lists or Boo1, \nH/Direct is used to generate marshalling code. The same restriction applies to the other variants of \nforeign that we discuss later, for the same reasons. 3.2 Variations on the theme We support several \nvariants of the basic foreign declara-tion: The name of the external procedure can be omitted, in which \ncase it defaults to the same as the Haskell procedure. foreign import hash :: Int -> I0 Int  If the \nprogrammer is sure that the foreign procedure is really a function -- that is, it has no side effects \n-- he can write the type as a non-I0 type: foreign unsafe import \"sin\" sin :: Double-> Double  The \"unsafe\" \nkeyword highlights the fact that the pro- grammer undertakes a proof obligation, namely that the function \nreally is a function. We use this conven- tion uniformly (also e.g. in unsafePerformIO), so that a programmer \ncan find all his proof obligations by say- ing grep unsafe. By default, foreign import uses the C calling \ncon- vention, but the convention can instead be specified explicitly: foreign unsafe import ccall \"sin\" \nsin :: Double-> Double  We also support the standard calling convention (stdcall) used in Win32 environments. \n* In many systems it is necessary to specify the library or DLL\" in which the external procedure can \nbe found. foreign unsafe import \"MathLib\" \"sin\" sin :: Double-> Double  similar declaration allows the \nprogrammer to expose a Haskell function to the outside world: foreign export \"put_char\" putChar :: Char \n-> IO () This exports a C-callable procedure put_char that in turn invokes the Haskell function putChar, \nmarshalling the pa- rameter appropriately. The calling convention can be spec- ified, just as with foreign \nimport, and a pure (non-I/O) Haskell function can be exported just as easily (no need for \"unsafe\" here): \nforeign export fibonacci :: Int -> Int Similar to the foreign import case, when the external name of \nthe exposed function is ommited, it defaults to the same name as the Haskell function. Stable pointers \nand foreign objects is often necessary to pass a Haskell value (pointer) to an external procedure. This \nraises two difficulties: first, the Haskell garbage collector cannot tell when the Haskell value no longer \nrequired; and second, the value may be moved by the (copying) garbage collector. We solve both these \nproblems by registering the Haskell value as a stable pointer. This registration (a) returns a stable \nvalue (a small integer) that names the value, and will not change during garbage collection, and (b) \ntells the garbage collector to retain the 2Dynamically Linked Library value until told otherwise. Subsequently, \nthe stable pointer can be dereferenced to recover the original Haskell value. An exactly dual problem \narises when we want to pass to a Haskell program a pointer to an external object (e.g. a file handle, \nmalloc'd block, or COM interface pointer). Often, we would like to be able to call fclose, or free, on \nthe external reference when the Haskell garbage collector finds that it is no longer required. Such \"run \nthis when the object dies\" behaviour is called finalization. We have defined extensions to Haskell to \nsupport both stable pointers and finalisation. They are described in detail in a companion paper [10], \nso we do not discuss them further here. 3.4 Dynamic import The foreign import primitive is fine if we \nknow the name of the C function we want to invoke. But sometimes we don't. Notably, when invoking a COM \nobject, we start from an interface pointer, which points to a location that points to a vector table \nof methods (we discuss this more in Section 4). To invoke the method, we must fetch the address of the \nmethod from the vector table, and call it. foreign import simply doesn't do the job; it works fine for \nlink-time or load- time binding, but not at all for run-time binding. To address this deficiency, we \nfirst need a new primitive Haskell data type, Addr, that represents a machine address. (We could have \nused Int, but that seems unsavory.) Next, we extend foreign import with a dynamic attribute: foreign \nimport dynamic hashMethod :: Addr-> (Int -> IO Int) This defines a Haskell function hashMethod, whose \ntype is as specified. Function hashMethod takes the address of the foreign procedure, which must be of \ntype Addr, and returns a fully-fledged Haskell function that, when applied, will invoke the foreign procedure. \nConsider the following example: do{ h <-...get addr of hash procedure... --h has type Addr  ; let hash \n= hashMethod h ; rl <- hash 34  ; r2 <- hash 39 ) h is the address of a suitable C procedure; hashMethod \nturns h into a Haskell function of type Int -> I0 Int, which is then invoked twice. Of course, if h is \nbound to a bogus address then terrible things will happen. It is rather simple to implement foreign import \ndynamic. The only difference from the static version is that the call takes place to a supplied argument, \nrather than to a static label. This contrasts sharply with its dual, dynamic export, which we study next. \n 3.5 Dynamic export Just as foreign import is inadequate in general, so is foreign export, for two reasons. \nFirst, foreign export only makes sense in a compiled setting, since its effect is to generate a code \nlabel that is externally visible; an interpreter cannot reasonably implement foreign export. Second, \nforeign export works on top-level functions. But we might want to export arbitrary functions. For example, \nexternal library procedures quite often take a callback pa-rameter; that is, a pointer to ~ procedure \nthat the external procedure will itself call. For example, the Win32 API pro- vides a function that allows \nyou to iterate over the current list of open windows: typedef BOOL (*WNDENUMPROC) (HWND, LPARAM) ; BOOL \nEnumWindows( WNDENUMPROC enumFunc , LPARAM iParam );  The system call takes a pointer to a callback \nprocedure to invoke for each open window, together with a value iparam that we'll ignore for now. The \ncallback procedure returns a boolean value to indicate whether we should stop iterating over the windows \nor not. The system call itself can easily enough he imported into Haskell 3 type BOOL = Int type LPARAM \n= Int type WNDENUMPROC = Addr foreign import \"EnumWindows\" enumWindows :: WNDENUMPKOC -> LPARAM -> \nIO BOOL  But what to do with the callback? We want to implement it in Haskell, so the callback will \nhave to be dressed up to appear like a C function pointer. One way would be to use foreign export to \nexport a Haskell procedure as a C procedure, and add some mechanism to give Haskell access to the address \nof that C procedure, to pass to enumWindous. But there is a much more elegant solution. We provide a \ndynamic form of foreign export, thus: type HWND = Addr foreign export dynamic mkWndEnumProc :: (HWND \n-> LPARAM -> I0 B00L) -> IO WNDENUMPROC  This declaration defines a Haskell function mkWndEnumProc, \nwith the type specified. Function rakWndEnumProc takes an arbitrary Haskell function value of the given \ntype as its single argument, and returns a C function pointer. This C function expects to find two arguments \non the C stack; it marshalls them into the Haskell world, and passes them to the Haskell function that \nwas passed to mkWndEnumProc. Here is an ex- ample of its use4: windowTitles :: IO [String] windowTit \nles = do{ ref <- newIORef [] ; let getTitle :: HWND -> LPAKAM -> I0 BOOL getTitle hwnd ip = do{ t \n<- getWindowTitle hwnd ; ts <- readIORef ref ; writeIORef ref (t:ts) ; return (boolToInt True) } \n; cback <- mkWndEnumProc getTitle ; enumWindows cback (0: :Int) ; readIORef ref  SWe declare types BOOL, \nLPARAM, etc as Haskell type synonyms that mimic the C header file definitions of these types. Such type \ndeclara- tions are usually generated automatically by H/Direct. 4The Appendix introduces IOB.efs. } \nHere, getTitle is the callback procedure; it is called for each window, passing the window handle and \nthe LPAPAM value. It in turn calls getWindowTitle (another foreign-imported procedure) to get the window \ntitle, and puts it onto the front of a list of window titles, kept in a Haskell mutable variable ref. \n The Haskell function getTitle is turned into a C-callable procedure cback (of type Addr) by mkWndEnumProc, \nthe func- tion defined by the foreign export dynamic declaration. Finally cback is passed to enumWindows. \nPhew! We do not want to claim that this is beautiful pro- gramming style. For example, it is rather gruesome \nto use a mutable variable in getTitle. But the style is dictated by the architecture of Windows system \ncalls; we are stuck with it. However, we are now ready to understand quite a bit about foreign export \ndynamic: The callback function getTitle is a first class Haskell value. It is not a top-level function, \nas must be the case for a static foreign export. In this case, getTitle has a free variable, ref, the \nmutable cell that it updates. This capability is modeled in C by the LPARAM parame- ter. The system call \naccepts LPAPAM as well as the call- back procedure, and passes LPARAM each time it calls the procedure. \nIn effect, the (callback, LPARAM) pair constitutes a closure, of code plus environment. In this particular \ncase, a C programmer would use LPAB.AM to point to a location in which the list is ac- cumulated, just \nlike ref. If there were many free variables, matters would be less simple. The Haskell programmer does \nnot need to bother with LPARAM --indeed, 1p is unused in the definition of getTitle. mkWndEnumProc captures \na first-class Haskell value, free variables and all. Higher-order programming in C! m.kWndEnuroProc encapsulates \na Haskell value as a C function pointer. To do this, it first registers the Haskell value as a stable \npointer (Section 3.3), and then embeds the stable pointer in the C function. The pro- grammer can explicitly \nfree the retained Haskell value using: freeHaskellFunctionPtr :: Addr -> IO () This operation cannot \nbe done automatically, since it depends on knowing that the exported function pointer is no longer needed \nexternally. As with the other foreign declaration variants, a foreign export dynamic also allows you \nto specify which calling convention the returned function pointer should expect.  3.6 Implementing dynamic \nexport Dynamic export is considerably harder to implement than dynamic import, because we have to generate \na C function pointer that cannot be static, because it must somehow refer to the Haskell function it \nencapsulates. This forces us to perform a little bit of dynamic code generation. Our implementation for \nthe Glasgow Haskell Compiler works by taking advantage of the static version of foreign export. Here, \nfor example, is how we implement Most functional programming systems provide a FFI, allow- mkWndEnumProc. \nWe repeat its declaration here: ing calls to external functions to embedded within functional foreign \nexport dynamic mkWndEnumProc :: (HWND -> LPARAM -> I0 BOOL) -> I0 WNDENUMPROC GHC first generates code \nexactly as if the programmer had written: foreign export wndEnumProc : : HWND -> LPARAM -> StablePtr \n(HWND->LPAPAM->I0 B00L) -> If] Bf]f]L  wndEnumProc h i sp = do{ f <- deRefStablePtr sp ; f h 1 } wndEnumProc \ntakes an extra argument, a stable pointer to the function value (Section 3.3); it simply dereferences \nthe stable pointer, and calls the function it gets back. Now, GHC generates code for mkWndEnumProc, which \ndoes three things: registers the Haskell function as a stable pointer;  dynamically generates a code \nfragment;  returns the address of this dynamically generated code.  The dynamically-generated code \nconsists of two or three in- structions: add-param <function pointer> jump .ndEnumProc The add-param \n\"instruction\" must be whatever machine code is necessary to pass one extra parameter --often this is \njust a matter of pushing it on the stack (perhaps also moving the return address). Once this is done, \nthe statically-exported vndEnumProc will do the rest. Clearly, the dynamic-code-generation part is highly \narchitecture de- pendent, but it is also very short, and is not hard in practice. Unfortunately, this \nsolution won't work at all for the Hugs interpreter, because an interpreter can't support static :foreign \nexport. Instead, the Hugs implementation of mkWndEnumProc dynamically generates the following segment \nof machine code: push <:function pointer> push <type descriptor> jump GenericCaller Here <type descriptor> \nis a (pointer to a C-format) string that encodes the type signature of the function. The <:function \npointer> is a stable pointer to the Haskell func- tion value, as before. Finally, GenericCaller is a \nfixed piece of code that (a) uses the type descriptor to marshall data from C to Haskell, (b) calls the \nspecified Haskell function, (c) marshalls the Haskell result back, and (d) returns to the C caller. GenericCaller \nis highly machine dependent, since it must know all about the caller's calling conventions; but at least \nit need only be written once. 3.7 Related work Foreign function interfaces (FFIs) are clearly of great \nuse, but papers describing them are relatively thin on the ground. code. However, few provide equally \ngood support for the outside to call in. The esh Scheme implementation [14] is a notable exception; it \nwas designed with the explicit goal of making hybrid Scheme and C/C++ applications easier to write. Another, \nmore recent system is the Bigloo Scheme compiler [15]. For ML-based languages, the Standard ML of New \nJersey compiler's foreign function interface does also provide sup- port for call-ins [5]. Function closures \ncan be dressed up behind a C function pointer, which can then be passed out to the outside world, making \nit similar in power to foreign export dynamic. A similar approach is provided by the Objective Caml FFI \n[8], which requires exported functions to be registered by giving them a name (an arbitrary string) from \nwithin OCaml code. The run-time system provides a C callable entry point for looking up the OCaml function \nclosure that hides be- hind a name, and invoke through a class of invocation func- tions. This scheme \nrequires that the user makes up the difference using C, writing a little bit of stub code that does the \nlookup and invokes the function by marshalling and un- marshalling the arguments and results. Contrast \nthis with foreign export dynamic which makes the Haskell-nature of the function pointers it returns transparent \nto the user. To our knowledge, the only other Haskell system that pro- vides support for externally-callable \nHaskell functions is the NHC 1.3 compiler [17], which provides a basic export mech- anism similar to \nthat of Objective Caml's. 4 How COM works Before we can describe how to encapsulate a Haskell pro- gram \nas a COM component, we have to digress briefly to explain how COM works. We concentrate exclusively on \nhow COM works, rather on why it works that way; the COM lit- erature deals with the latter topic in detail \n[13]. This section is closely based on our description in [11]. Here is how a client, written in C, might \ncreate and invoke a COM object: /* Create the object */ err_code = CoCreateInstance ( cls_id , iface_id \n, &#38;iptr ); if (not SUCCEEDED(err_code)) { . .error recovery... } /* Invoke a method */ (*iptr)[3]( \niptr, x, y, z ); The procedure CoCreateInstance is best thought of as an operating system procedure. \n(In real life, it takes more pa- rameters than those given above, but they are unimportant here.) Calling \nCoCreateInstance creates an instance of an object whose class identifier, or CLSID, is held in cls_id. \nThe class identifier is a 128-bit globally unique identifier, or GUID. Here \"globally unique\" means that \nthe GUID is a name for the class that will not (ever) be re-used for any other purpose anywhere on the \nplanet. A standard utility (*iptr)[3]( iptr, x, y, z ); \"Vtbl pointer\" \"Virtual function table\" (not \nshared) (shared by all instances) Interface Querylnterface pointer / '. :! = AddRef : = Release \" Object \n\" I    state other I : ~ methods Figure 2: Interface pointers allows an unlimited supply of fresh \nGUIDs to be generated locally, based on the machine's IP address and the date and time. The code for \nthe class is found indirectly via the system registry, which is held in a fixed place in the file system. \nThis double indirection of CLSIDs and registry makes the client code independent of the specific location \nof the code for the class. Next, CoCreateInstance loads the class code into the current process (unless \nit has already been loaded). Alternatively, one can ask COM to create a new process (either local or \nremote) to run the instance. 4.1 Interfaces and method invocation A COM object supports one or more interfaces, \neach of which has its own globally-unique interface identifier or IID. That is why CoCreateInstaace takes \na second parameter, iface_id, the IID of the desired interface; CoCreateInstance returns the interface \npointer of this inter- face in iptr. There is no such thing as an \"object pointer\", or \"object identifier\"; \nthere are only interface pointers. The IID of an interface uniquely identifies the complete sig-nature \nof that interface; that is, what methods the interface has (including what order they appear in), their \ncalling con- vention, what arguments they take, and what results they return. If we want to change the \nsignature of an interface, we must give the new interface a different IID from the old one. That way, \nwhen a client asks for an interface with a particular IID, it knows exactly what that interface provides. \nA COM interface pointer is (deep breath) a pointer to a pointer to a table of method addresses (Figure \n2). Notice the double indirection, which allows the table of method ad- dresses to be shared among all \ninstances of the class. Data specific to a particular instance of the class, notably the object's state, \ncan be stored at some fixed offset from the \"vtbl pointer\" (Figure 2). The format of this information \nis entirely up to the object's implementation; the client knows nothing about it. Lastly, when a method \nis invoked, the in- terface pointer must be passed as the first argument, so that the method code can \naccess the instance-specific state. Tak-ing all these points together, we can now see why a method invocation \nlooks like this: None of this is language specific. That is, COM is a binary interface standard. Provided \nthe code that creates an ob- ject instance returns an interface pointer that points to the structures \njust described, the client will be happy. In theory, the parameter passing conventions for each method \ncan be different (but fixed in advance). In practice, they match the __stdcall convention used by C and \nC++. Interface pointers provide the sole way in which one can in- teract with a COM object. This restriction \nmakes it possible to implement location transparency (a major COM war-cry), whereby an object's client \ninteracts with the object in the same way regardless of whether or not the object is in the same address \nspace, or even in the same machine, as the client. All that is necessary is to build a proxy interface \npointer, that does point into the client's address space, but whose methods are stub procedures that \nmarshal the data to and from across the border to the remote object. 4.2 Getting other interfaces A single \nCOM object can support more than one interface. But as we have seen before CoCreateInstaace returns only \none interface pointer. So how do we get the others? Answer: every interface supports the QueryInterface \nmethod, which maps an IID to an interface pointer for the requested IID or fails if the object does not \nsupport the requested interface. So, from any interface pointer, iptr, on an object we can get to any \nother interface pointer, iptr2, which that object implements. For example: err_code = (*iptr)[0]( iptr, \nlid2, &#38;iptr2 ); Why \"[0]\"? Because QueryInterface is at offset 0 in every interface. The COM specification \nrequires that QueryInterface be- haves consistently. The IUnknown interface on an object is the identity \nof that object; queries for IUnknown from any interface on an object should all return exactly the same \ninterface pointer. Queries for interfaces on the same ob-ject should always fail or always succeed. Thus, \nthe call (*iptr) [0] (iptr, iid2,&#38;iptr2) should not succeed at one point, but fail at another. Finally, \nwhen viewed as a binary relation over interfaces on a component, QueryInterface should be an equivalence \nrelation. 4.3 Reference counting Each object keeps a reference count of all the interface point- ers \nit has handed out. When a client discards an interface pointer it should call the Release method via \nthat inter-face pointer; every interface supports the Release method. Similarly, when it duplicates an \ninterface pointer it holds, the client should call the AddReg method via the interface pointer; every \ninterface also supports the AddRef method. When an object's reference count drops to zero it can com- \nmit suicide --but. it is up to the object, not the client, to cause this to happen. All the client does \nis make correct calls to AddRef and Release. Every interface supports the three methods QueryInterface, \nAddKef, and Release. The three together constitute the IUnknown interface, which every other inter- face \nextends. rity right at the heart of our implementation. Here are the types of the Haskell equivalents \nof CoCreateInstance and pointer_default(unique) QueryInterface: ] interface IUnknown { HRESULT QueryInterface( \n[in] REFID iid, [out] void **ppv ); ULONG AddrRef( void ); ULONG Release( void ); }  [ object, uuid(...) \n] interface ILookup : IUnknown { HRESULT LookupByName ( [in,string]char* name, [out,string]char** number \n); HRESULT LookupByNumber( [in,string]char* number, [out,string]char** name );} [ object, uuid(...) ] \ninterface IInsert : IUnknown { HKESULT Insert( [in,string]char* name, [in,string]char* number ); }  \n [ uuid(...) ] coclass PBX { [default] interface ILookup; interface interface IInsert; }   4.4 Describing \ninterfaces Since every IID uniquely identifies the signature of the in- terface, it is useful to have \na common language in which to describe that signature. COM has such a language, called IDL (Interface \nDefinition Language), but IDL is not part of the core COM standard. You do not have to describe an interface \nusing IDL, you can describe it in classical Greek prose if you like. All COM says is that one IID must \nidentify one signature. Describing an interface in IDL is useful, though, because it is a language that \nall COM programmers understand. Fur- thermore, there are tools that read IDL descriptions and produce \nlanguage-specific declarations and glue code. For example, the Microsoft MIDL compiler can read IDL and \nproduce C++ class declarations that make COM objects look exactly like C++ objects (or Java, or Visual \nBasic). As a short example, Figure 4.4 gives the IDL description Of the IUnknown interface, the interface \nthat every other extends. The 128 bit long constant is the GUID for the IUnknown interface. Also presented \nare the class and inter- face declarations for a simple telephone directory compo- nent, PBX. The PBX \nclass supports two interfaces, ILookup and IInsert. The former has two methods, in addition to the standard \nIUnknown methods, while the latter has one. (The class and interface GUIDs are elided to \"...\" for brevity.) \n5 Polymorphism expresses single inheritance Our earlier paper showed how to create and invoke COM components \nfrom Haskell. We found that we were able to make compelling use of polymorphism to offer type secu- coCreateInstance \n:: CLSID -> IID iid -> I0 (IUnk lid) queryInterface :: IID lid -> IUnk a -> I0 (IUnk iid)  CLSID is \nthe type of class GUIDs.  IID iid is the type of interface GUIDs, but parame- terised by, iid, the \"interface \ntype\".  $ IOnk lid 5 is the type of interface pointers, again pa- rameterised by its interface type. \nThe polymorphism in coCreateInstance and query-Interface elegantly ensures that the interface pointer \nre- turned is statically checked to support the same methods as the IID that was passed. Whenever coCreateInstance \nor queryInterface obtains a new interface pointer of type IUnk lid from COM, it at- taches a finaliser \nto it (Section 3.3), so that when the Haskell program lets go of the interface pointer, the finaliser \nwill automatically call Release. In this way, managing COM object reference counts is invisible to the \nprogrammer. 5.1 Interface types What are these \"interface types\"? For every interface (GUID) defined \nin the IDL for a component, H/Direct sim- ply define a fresh Haskell type --the interface type. There \nis a one-to-one correspondence between interface IDs and in- terface types, which is why we use \"iid\" \nfor a type variable that ranges over interface types. Strangely, such an interface type is an abstract \ndata type with no operations, nor do we ever create a value of the type. For example, consider the ILookup \ninterface in Figure 4.4. When fed this IDL, H/Direct will produce a Haskell module containing the following \ndeclarations (among others): data ILookupT a = ILookupT --The interface type type ILookup a = IUnknown \n(ILookupT a) iidlLookup :: lID (ILookupT O) iidlLookup = newlld \"...GUID for ILookup...\" The interface \ntype for ILookup is called ILookupT. It is de- clared as an algebraic data type with a single constructor \n6 We will return shortly to the type parameter for ILookupT; just ignore it for now. Next, there is a \ntype synonym, that defines ILookup a to be the type of interface pointers for in- terfaces of type ILookup. \nFinally, a suitably-typed interface ID for ILookup is defined. H/Direct also generates client stub definitions \nfor the meth- ods of the interface: lookupByName :: String -> ILookup a -> IO String 1ookupByNumber :: \nString -> ILookup a -> I0 String Sin the real implementation it is called \"IIlnknown\", but \"IUnk\" made \nour typesetting easier! 6It would be better to declare it as a type with no constructors, since we never \nuse the constructor, but Haskell does not allow that. Notice that these each take a typed interface \npointer as their argument. It is impossible for the Haskell application to ac- cidentally call lookupByName \npassing it an interface pointer to an IInsert interface, say. And the only way the applica- tion can \nconstruct an interface pointer of type ILookup a is by calling coCreateInstance or queryInterface! 5.2 \nInheritance Why is ILookupT parameterised? Because it is possible to define another interface that extends \nILookup. The IDL might look like this: interface ISearch : ILookup { ... } Given this, H/Direct will \ngenerate the following: data ISearchT a = ISearchT type ISearch a = ILookup (ISearchT a) iidISearch :: \nIID (ISearchT ()) iidISearch = ... Now, the beautifulthingisthis:ifI have an interface pointer oftype \nISearch t, then Ican use lookupByName on it. Why? Because ISearch t = ILookup (ISearchT t)  (just by \nexpanding the type synonym for ISearch). That is, every interface pointer for ISearch is automatically \nan interface pointer for ILookup, and indeed also an interface pointer for IOnknown. Now we can understand \nthe type of iidISearch as well: iidISearch :: IID (ISearchT ())  iidISearch is the interface ID for \nISearch exactly, ex-pressed by instantiating the type parameter to (). In short, we have been able to \nuse simple polymorphic in- stantiation to model (single, interface) inheritance, which luckily is precisely \nwhat COM requires. In retrospect the idea is quite obvious, and perhaps has been invented many times \nbefore, but we have been unable to find a published account. 6 Encapsulating Haskell as a COM component \n Next, we turn to our third main theme, the task of im- plementing a specified COM component in Haskell. \nThe starting point is an IDL specification for the interface(s) the component must offer; as a running \nexample we use the tele- phone directory given in Figure 4.4. This is closely based on the example used \nin [4] to introduce Component Pascal's support for interacting with COM. We tackle the encapsulation \nin three clearly-separated \"lay- ers\" (Figure 1): Code written by the application programmer writes \n(Section 6.1). There are two things to do here: pro-vide an implementation of the component, and register \nit with COM so that other components can invoke it.  Code generated by H/Direct from the PBX IDL (Sec- \ntion 6.2). This boilerplate code deals with marshalling  arguments between Haskell and the client; it \nalso deals with creating the component's vector tables and inter- face pointers in exactly the form expected \nby COM clients. Fixed code that lives in the Corn library (Section 7). 6.1 The programmer's eye view \n What does the Haskell programmer have to do to implement PBX in Haskell? First he feeds the IDL to H/Direct, \nwhich generates a Haskell module PBXProxy.hs (Figure 1). This module imports a Haskell module PBX. lhs, \nwhich provides the programmer's implementation of the PBX functionality. H/Direct optionally outputs \na skeleton for this module, but the programmer must complete it by providing: A type declaration for \nthe state of the PBX object. This type is given the same name as the class. For example: type Name = \nString type Number = String type PBX = IORef [(Name,Number)] Here the state PBX is held in a mutable \nIORef cell. The advantage of using mutable references over a more \"functional\" state-transformer style \nis that under the former scheme, the Haskell signatures for using com-ponents and for implementing components \nin Haskell are uniform. An initialiser, initPBX, for the PBX state. For example: initPBX :: I0 PBX initPBX \n= newIORef [] An implementation for each method. The Haskell type of each method is derived from the \ncorresponding IDL type; this type translation is given in detail in [2]. For example: lookupByName :: \nString -> PBX -> I0 String lookupByName want pbx = do{ pairs <- readIORef phx ; maybe (lookup want pairs) \n(coError E_Fail) (return) } The last parameter of each method is the state of the object. The function \ncoError raises an excep-tion in the I0 monad, passing the E_Fail return code, which is marshalled into \nCOM's E_FAIL return code by H/Direct. Finally, the programmer must make the new component known to COM \nby supplying a main module, Main. lhs, as follows: module Main where import Com(coRegister) import PBXProxy(pbx) \n main :: I0 () main = coKegister [pbx]  When the Haskell program is run, the call to coRegister registers \nthe component(s) defined in its argument list. This step registers Haskell functions through which a \nclient can create instances of the component(s). If a single Haskell program implements more than one \nCOM component, main would import several Proxy modules, and would have several items in the list passed \nto coRegister. And that is all the programmer has to do! Next, we look behind the scenes, and study the \nPBXProxy and Com modules. 6.2 Creating a component instance H/Direct generates the module PBXProxy from \nthe IDL for PBX, which exports the single value pbx. This value pbx en- capsulates the complete implementation \nof the component ~ pbx :: CoComponent data CoComponent = CoComponent { componentCLSID : : CLSID , componentProgID \n:: String , newInstance :: IID lid -> I0 (IUnk iid) }  A CoComponent is a triple of: a class ID, the \nunique 128- bit \"name\" of the class; a prog ID, a human friendly string through which the class ID can \nbe looked up in the registry; and a function to create a new instance of the component. The first two \nfields are easy to generate from the IDL. ~Ve will focus on the last, newInstance. To create an instance \nof a COM component we need to con- struct an interface pointer that looks precisely as depicted in Figure \n2. We represent an interface pointer as a pointer to a malloc'd pair of (a) a method vector table pointer \nand (b) a (stable pointer to) the object's state s. All the interfaces for a particular object share \na common state. So there are two things we must be able to do: 1. Create a method vector table. In the \ncompiled imple- mentation we could do this statically, but that is not possible in Hugs, so we provide \na function that dynam- ically builds a vector table. type CoVTable iid st = ... newCoVTable :: [Addr] \n-> CoVTable iid st  Function newCoVTable uses malloc to allocate a fixed, never-freed, vector table, \nreturning its address as a Haskell closure via unsafePerformI0. By reflecting Haskell's underlying laziness \nand sharing in this way, we get sharing and laziness of vector tables for free! The CoVTable type is \nparameterised by the interface type (lid) of the interface it implements, and object state (st) understood \nby the methods. 7The actual data type contains a few extra fields --for example a string giving a short \ndescription of the component. Sin principle, we could instead create a fresh method table for each instance \nof the object; the methods could then have the object state as a free variable, just like getTitle did \nin Section 3.5. But that would mean much method-table duplication, so instead we follow COM's hint, and \nuse a fixed method table, shared among all instances. The method addresses passed to newCoVTable point \nto procedures that can be called directly by other COM objects. They can be generated using foreign export. \nFunction newCoVTable prefixes this list with three fur- ther addresses, for the standard IUnkno~ra interface \nmethods QueryInter:face, hddRef, and Release. (A variant of newCoVTable is provided for those who want \nto write their own implementations of these methods -see Section 7.2.) 2. Create an instance of the object. \nA COM object may support several interfaces, so we must pass a list of (IID,VTable) pairs for every interface \nthe object im- plements, each of type IfaceSpec: data IfaceSpec st = forall lid. IfaceSpec (IID lid) \n(CoVTable iid st) newCoInstance :: st -> [IfaceSpec st] -> IID lid -> IO (IUnk lid) Function newCoInstance \ntakes an initial state, a list of interfaces (each specified as a (IID,VTable) pair), and an IID, and \nreturns a suitable interface pointer to the object. The data type declaration for I:faceSpec uses an \nex- perimental extension of Haskell that provides existen- tial data types 9. The data type has one constructor, \nIfaceSpec, with type: IfaceSpec :: IID lid -> CoVTable lid st -> IfaceSpec st The IID and CoVTable must \nhave compatible lid types, but that type does not show up in the type of the con- structed value. Hence, \na list of IfaceSpecs may differ in their iids, but will all share the same state st. We are finally ready \nto give the code for the PBXProxy mod- ule. Remember that its sole export is the component pbx. module \nPBXProxy( pbx ) where import PBX( PBX, initPBX, lookupByName, 1ookupByNumber, insert ) import Com(CoComponent(..), \nIfaceSpec(..), newCoInstance, newCoVTable, CoIPRep, getCoState )   pbx :: CoComponent pbx = CoComponent \n{ \u00a2omponentCLSID = \"...\", componentName = \"PBX\", newInstance = newPBX } newPBX :: IID iid -> I0 (IUnk \niid) newPBX = do{ init <-initPBX ; newCoInstance init pbxISpecs } pbxISpecs :: [IfaceSpec PBX] pbxISpecs \n= [IfaceSpec iidIInsert vtInsert, 9This extension, first suggested byLau~r [7],is implemented by several \nHaskell compilers, lnclude GHC, hbc, and Hugs. IfaceSpec iidlLookup vtLookup] 7.1 Activation vtInsert \n:: VTable IInsertT PBX vtInsert = newCoVTable [wrapInsert] vtLookup :: VTable ILookupT PBX vtLookup \n= newCoVTable [wrapLookupByName, wrapLookupByNumber]  --Definitions of IInsertT, iidIInsert etc as before \n foreign export \"LookupByName\" wrapLookupByName :: CoIPRep PBX -> Addr -> Addr -> I0 ()  wrapLookupByName \nip p_name p_number = do{ st <- getCoState ip ; name <- unmarshallString p_name ; number <- lookupByName \nname st ; writeString p_number number } -- Similar wrappers for lookupByNumber, and insert All of \nthis code is generated from the PBX IDL by H/Direct, which is a good thing, because it is quite tiresome \nto write. The definitions of pbx, newPBX and pbxISpecs axe straight- forward. The vector tables, vtInsert \nand vtLookup, are allocated on demand, by newCoVTable. The addresses in the vector table are obtained \nusing foreign export. The function thus exported is a wrapper function (wrapInsert is an example) that \ntakes the raw \"self\" interface pointer as an argument. The purpose of this interface pointer is to get \nthe object state, so we give it the type CoIPRep PBX, and provide the operation: getCoState :: ColPRep \nst -> I0 st which extracts the state component from an interface pointer. Now we can pass that state \non to the user-written method insert, imported from module PBX. It may seem strange that in Section 5 \nwe gave interface pointers a type (IUnk) parameterised by an interface type, while here we parameterise \na different type (CoIPRep) by the object state. How peculiar! However, even though both ave represented \nby a single address, they play quite different roles. A value of type IUnk lid is a client-side interface \npointer for an object held elsewhere; its state is invisible, and when it is finalised (Section 3.3) \nwe must call its Release method. In contrast, a value of type CoIPRep st is a server- side interface \npointer; its state is visible (because the 'this' pointer is passed to the method implementation), and \nwhen there are no further references we need only call free to return the store to malloc. When H/Direct \nis generating code for Hugs, it can only use foreign export dynamic, so the code for vtlnsert and vtLookup \nis a little more indirect, but still straightforward. 7 The Corn library The bottom layer of the encapsulation \nis the fixed, generic Haskell library Com. lhs to support COM objects. We do not have space to present \ndetailed code; instead we summarise what the implementation (completely written in Haskell) 'does. When \na client calls CoCreatelnstance (see Section 4) to cre- ate a COM object, COM looks in the registry to \nfind which DLL to activate. If the DLL has not already been loaded, COM will load it and invoke its initialisation \nprocedure. If the DLL holds a Haskell program, this initialisation proce- dure runs the Haskell programs \nfunction main. As indicated in Section 6.1, main in turns calls coRegister, passing it a list of all \nthe components that this DLL serves: coRegister :: [CoComponent] -> 10 O Once CoCreateInstance has ensured \nthat the DLL is loaded, it calls a standard entry point DllGetClass0bject, passing the CLSID of the \nobject to be instantiated. We ar- range that this call is forwarded to a Haskell procedure cre- ated \n(at initialisation time) by coRegister using foreign export dynamic. This Haskell procedure simply searches \nthe list of components passed to coRegister, looking for one with a matching CLSID, and creates an instance \nof that component. (In reality, it creates a so-called class factory object for the object, which in \nturn can be called to create instances of the object, but the idea is the same.) '7.2 The IUaknown interface \nIn Section 6.2 we said that newCoVTable and newCoInstance worked together to provide implementation of \nthe IUnknown methods, Querylnterface, AddRef, and Release. In this section we outline how this is done. \n The basic idea is simple enough. Recall that we represent an interface pointer by a malloc'd pair of \na pointer to the method vector table, and (a stable pointer to) the Haskelt state for the object. For \nCOM objects that use the Cam library support, the object state is a (Haskell) pair of two values: the \n\"user\" state (PBX in the above example), and the \"system\" state. The system state in turn is a pair of \n(a) a reference count for the whole object, and (b) a mapping from an IID to an interface pointer: type \nCoState st = (IORef Int , FiniteMap (IID ()) (CoIPRep st) ) type Irate st =(IID (), CoIPRep st) \nWith this object state in mind, we can provide standard AddRef and Release methods. They simply adjust \nthe ref- erence count held in the CoState. When the reference count drops to zero, Release simply frees \nthe stable pointer that keeps the object's state alive. That, in turn, may cause a number of finalizers \nto get called, see Section 3.3. The standard QueryInterface method uses the IID-to- interface-pointer \nmapping to do its work. The typing of the mapping looks strange, for two reasons. First, the Haskell \ntype system cannot express the idea of a mapping in which the argument value determines the result type. \nOne needs dependent types for that. Second, the result of QueryInterface is in any case returned immediately \nto the external client, so little is gained by a sophisticated typing. With this in mind, newCoVTable \nuses the even-more-primitive newVTable to do its work:  [6] D. Jeffery, T. Dowd, and Z. Somogyi. MCORBA: \na CORBA binding for Mercury. In Gupta; editor, Prac-tical Applications of Declarative Languages, pages \n211- 227. Springer Verlag LNCS 1551, 1999. [7] K L~iufer and M Odersky. An extension of ML with first-class \nabstract types. In Workshop on ML and its Applications. 1992. [8] X. Leroy. Interfacing C with Objective \nCarol. INRIA, Rocquencourt, France. http://canal, inria, fr/ocaml/ htmlman/. [9] Microsoft Corporation. \nVisual J++. http://www. microsoft, com/j ava/.  [10] S. Peyton Jones, S. Marlow, and C. Elliott. Stretching \nthe storage manager: weak pointers and stable names in Haskell. Technical report, Microsoft Research, \n1999. [11] S. Peyton Jones, E. Meijer, and D. Leijen. Scripting COM components in Haskell. In Proc Fifth \nInterna- tional Conference on Software Reuse, Victoria. IEEE, 1998. [12] S. Peyton Jones and P. Wadler. \nImperative functional programming. In 20th A CM Symposium on Principles of Programming Languages (POPL'93), \nCharleston, pages 71-84. ACM, 1993. [13] D. Rogerson. Inside COM: Microsoft's Component Ob- ject Model. \nMicrosoft Press, 1997. [14] J. R. Rose and H. Muller. Integrating the Scheme and C Languages. In Proc \nACM 1992 Conference on Lisp and Functional Programming, pages 247-259, 1992. [15] M. Serrano. Bigloo \nUser's Manual, 1999. http:// kaolin, unice, fr/~serrano/bigloo/bigloo, html. [16] C. Szyperski. Component \nSoftware. Addison Wesley, 1998. [17] M. Wallace. Calling Haskell from C using GreenCard. http://www, \ncs. york. ac. uk/fp/nhc/ CcallingHaskell. html.  Appendix: Input/output in Haskell In Haskell, a function \nthat has type Int -> Int, say, is a function from integers to integers, no more and no less. In particular \nit cannot perform any input/output. Any func- tion that can perform I/O has a result type of the form \nI0 r. This so-called monadic I/O has become the standard way to do input/output in purely functional \nlanguages [12]. An I/O performing function can be used in a do expression, which serves to sequence such \ncomputations. For example: main :: I0 () main = do{ 1 <- getLine ; putStr (reverse 1) } This program \nuses two standard functions: getLine :: I0 String putStr :: String -> I0 () When main is performed, the \ndo arranges first to perform getLine, binding the result, of type String to 1. The it performs putStr \n(reverse 1), which displays the reverse of 1. Many of the programs in this paper use mutable cells, \nsimilar to ML's ref type. newIORef :: a-> I0 (IORef a) readIORef :: IORef a -> I0 a writeIORef :: IORef \na -> a -> I0 () A value of type IORef t is a reference to a mutable cell holding a value of type t. \nThe primitives to allocate, read, and write the cell are all in the I0 monad. Here is a short example, \nusing Haskell's do notation: swap :: IORef a-> IORef a -> I0 () --Swap the contents of the two cells \nswap aref bref = do{ a <- readIORef aref ; b <- readIORef bref ; writeIORef aref b ; writeIORef bref \na }  A primitive IO action is also provided for tying knots, fixIO :: (a -> IO a) -> IO a which is \nthe fixpoint combinator at the level of IO actions.   \n\t\t\t", "proc_id": "317636", "abstract": "The increasing popularity of component-based programming tools offer a big opportunity to designers of advanced programming languages, such as Haskell. If we can package our programs as software components, then it is easy to integrate them into applications written in other languages.In earlier work we described a preliminary integration of Haskell with Microsoft's Component Object Model (COM), focusing on how Haskell can create and invoke COM objects. This paper develops that work, concentrating on the mechanisms that support externally-callable Haskell functions, and the encapsulation of Haskell programs as COM objects.", "authors": [{"name": "Sigbjorn Finne", "author_profile_id": "81100410497", "affiliation": "University of Glasgow", "person_id": "P265156", "email_address": "", "orcid_id": ""}, {"name": "Daan Leijen", "author_profile_id": "81100572466", "affiliation": "University of Utrecht", "person_id": "PP39049120", "email_address": "", "orcid_id": ""}, {"name": "Erik Meijer", "author_profile_id": "81100295095", "affiliation": "University of Utrecht", "person_id": "P78826", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research Cambridge", "person_id": "PP40033275", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/317636.317790", "year": "1999", "article_id": "317790", "conference": "ICFP", "title": "Calling hell from heaven and heaven from hell", "url": "http://dl.acm.org/citation.cfm?id=317790"}