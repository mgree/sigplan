{"article_publication_date": "03-01-1993", "fulltext": "\n A Sort Inference Algorithm for the Polyadic ~-Calculus Simon J. Gay* Department of Computing, Imperial \nCollege of Science, Technology and Medicine, 180 Queen s Gate, London, UK SW7 2BZ (sjg3@doc.ic.ac.uk) \nAbstract phic type of an expression. This relieves the program\u00admer of the task of supplying type annotations \nfor all variables and functions, and helps to ensure that func- In Milner s polyadic ~-calculus there \nis a notion of sorts tion definitions reflect any genericity present in the al\u00adwhich is analogous to \nthe notion of types in functional gorithms which they are encoding. From a theoreti\u00adprogramming. As a \nwell-typed program applies func\u00adcal point of view, the analogy between types in func\u00adtions to arguments \nin a consistent way, a well-sorted pro\u00adtional programming and propositions in intuitionisticcess uses \ncommunication channels in a consistent way. logic (the Curry-Howard isomorphism, also known asAn open \nproblem is whether there is an algorithm to in\u00adthe propositions-as-types paradigm) forms the basis offer \nsorts in the z-calculus in the same way that types can the elegant connections between functional programs,be \ninferred in functional programming. Here we solve intuitionistic proofs and cartesian closed categories. \nOnthe problem by presenting an algorithm which infers the practical side, type checking is recognised \nas one ofthe most general sorting for a process in the first-order the most successful applications to \ndate of formal meth\u00adcalculus, and proving its correctness. The algorithm is ods in computer science. \nsimilar in style to those used for Hindley-Milner type inference in functional languages. The success \nof type systems in sequential programming makes it natural to ask whether there is a similar notion of \ntypes in some given formalism for describing concur\u00ad 1 Introduction rent processes, and whether the same \nkind oft ype check\u00ading and type inference can be used to good effect. In this paper we study this question \nin the case of one such The benefits of programming with a typed language are formalism, namely Milner \ns r-calculus [MPW89, Mi191]. widely accepted. The type of a function or procedure Milner answers the \nfirst part of the question by defining is the simplest possible form of specification, but nev\u00adthe notions \nof sort and sorting: a sorting is analogous toertheless a very useful one. The type system aids mod\u00adan \nenvironment of typed terms in functional program\u00adular program construction by providing a means of ex\u00adming \ntype inference, and the sort of an agent (process) ispressing procedure interface specifications, and \ncompile\u00adanalogous to the type of a function. The second part oftime type checking, which is a standard \nfeature of both the question is an open problem. We solve this problemimperative and functional languages, \nis able to detect by presenting an algorithm which constructs the mostmany programming errors. In the \nrealm of functional general (in a sense to be made precise; this is analo\u00ad programming with polymorphism, \ntype checking is ex\u00adgous to polymorphism) sorting in which a given agent tended by the provision of type \ninference: the compiler can be assigned a sort, and also the sort itself. The is able to (attempt to) \ninfer the most general polymor\u00adalgorithm is in the style of those in widespread use for Researcb supported \nby an SERC studentship. Hindley-Milner type inference [Mi178, Hin69] in func-Permission to oopy without \nfee all or pert of this material is tional language systems. granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the In order to make \nthe paper as self-contained as possi\u00adtitle of the publication and its date appear, and notice is given \nble, we begin with an introduction to (or review of) the that copying is by permission of the Association \nfor Computing r-calculus in Section 2 and describe Milner s notion of Machinery. To copy otherwise, or \nto republish, requires a fee sorting. Then in Section 3 we give the (slightly differ\u00ad and/or specific \npermission. ACM-20th PoPL-1 /93-S. C., USA 01993 ACM 0-89791 -561 -5/93 /0001 /0429 . ..$1 .50 ent) definition \nof sorting to be used in the rest of the paper, and develop some theory of these sortings. In Section \n4 the sort inference algorithm is presented as a collection of rules allowing agents to be constructed \nalong with a suitable sorting, in the same way that type inference algorithms for functional programming \nlanguages are usually presented. Some examples of the algorithm in action also appear in this section. \nSec\u00adtion 5 contains the proof that the algorithm constructs the correct sorting. Finally in Section 6 \nthe algorithm needed to combine two existing sortings into a sorting for a compound agent is given in \na more concrete form, which should make it clear that the sort inference algo\u00adrithm is amenable to implementation. \n2 The m-Calculus The r-calculus is a notation for communicating pro\u00adcesses. As the name suggests, it \nhas a flavour of the A-calculus in the way terms are constructed. It is sim\u00adilar to CCS [Mi189] in that \nprocesses can be built up by adding prefixes, or communication points, to exist\u00ading processes, but generalises \nCCS by allowing the com\u00admunications resulting from prefixes to send and receive arbitrary names. For \nexample, adding the prefix x(y) to a process P forms the process z(y) .P which can receive a name (referred \nto as y within P) along a communica\u00adtion channel called x, and then become P. The notation for prefixes \nwhich output names is similar: ZU.Q out\u00adputs u along z and becomes Q. The names which can be transmitted \nalong channels in this way are of the same nature as the names of the channels themselves, so that x(y) \ny(z) .P is a valid construction. This ability to use names to refer to both channels and data is one \nof the key features of the ~-calculus, and is what gives it much of its power. It allows the effect of \ntransmit\u00adting processes along channels to be obtained: instead of sending a process, it is sufficient \nto send a name which can be used to access the process. Processes can be combined in parallel, which \nintroduces the possibility of communication just as in CCS: x(y) .P@.Q reduces to P{u/y} IQ. There is \nalso a + operator which again be\u00adhaves in the manner familiar from CCS: x.P + y.Q can communicate with \nan z or a v prefix and become P or Q accordingly. The above examples live in the monadic n-calculus; \nin moving to the polyadic ~-calculus, which we deal with in this paper, two further generalisations are \nmade. Any number of names can appear in the argument of a prefix, for example X( UVW), and also the addition \nof a prefix to a process is broken down into two steps. To form what we have previously written as z(y) \n.F , the first step is to form the abstraction (Ay)P from the process P, and the second step is to locate \nthis abstraction at x by form\u00ading x.( Ay)P; we can then abbreviate this expression by a(y) .P to recover \nthe previous notation. Similarly for outputs: EU.Q is an abbreviation for Z. [u]Q, where the concretion \n[u]Q has been co-located at the co-name T. Abstraction and concretion behave slightly differently with \nrespect to the binding of names: x is bound in (Ax)P but free in [z]P. The other way of binding names \nis with the restriction operator v. In (vx)P, uses of x within P are distinct from any external uses; \nthe com\u00adbination (vx)[z]P gives the effect of a concretion which binds its arguments. The last construction \nto mention is the replication op\u00aderator. The process !P is equivalent to P\\ !P; this allows processes \nto be constructed which behave as if defined by recursive equations. The preceding discussion describes \nthe standard (first\u00adorder) n-calculus. We will extend the calculus by the addition of a new atomic process \nERROR, which will be used to represent the kind of run-time error which sortings are intended to avoid. \nThe constructions described above are formalised by the following grammar for agents, in which A4, N \nare normal processes, P, Q are processes, F is an abstraction, C a concretion and A an agent. Also x \nis an arbitrary name, and a is an arbitrary name or co-name. N ::= a. Alolitf+N\\ ERRoR P ::= N I PIQ \n[!P I (vx)P F ::= P I (Aa)F I (vx)F c ::= P I [*]C I (Vz)c A ::= FIC In order to describe the benefits \nof introducing sortings, we need to discuss the operational semantics of the r\u00adcalculus. First of all, \nthe reduction relation between processes can be defined most simply if we work not with raw process terms, \nbut modulo a certain structural congruence relation. Writing P for the collection of pro\u00adcesses and MP \nfor the collection of normal processes, we define s to be the smallest congruence relation over T which \nsatisfies the properties listed below, The free and bound names of a process, fn(P) and bn(P), are defined \nin the natural way. This is the standard definition of z for the ~-calculus, extended to cover ERROR. \n1. Processes are identified if they differ only by a change of bound names ( ie a-conversion). 2. (NP/ \n-,+, O) is a commutative monoid. 3. (7/ =,1, O) is a commutative monoid. 4. !P E P[!P. 5. If z @fn(P) \nthen (vz)(PIQ) = PI(vz)Q.  6. [f z # y then (vy)(kc)F s (kE)(vy)F. is, an element of S*. A sorting \nover S is a non-empty 7. [f x # y then (vy)[z]Cs [z](vy)C. 8. (ME)(vY)A a (vy)(vz)A, (vz)(vz)A s (vz)A. \n 9. ~ + ERROR s ERROR.  10. PIERROR z ERROR. !ERROR ~ ERROR. 11. 12. (kC)ERROR E ERROR, [Z] ERROR \nE ERROR, (VZ)ERROR EZ ERROR.  Now we define the reduction relation + over processes to be the smallest \nrelation satisfying the following rules. Comm (.. -+ F) I(I+3.. +3. C)+FOC P+P P*.P Par Res PIQ ~ P \n\\Q (?m)P + (VZ)P Q=P P4P P EQ Struct Q-+Q The term F*C is the pseudo-application of the ab\u00adstraction \nF to the concretion C. To define it, note that structural congruence can be used to write abstrac\u00adtions \nand concretions in standard forms F = (M)P, C = (v~)[~Q. If F and C are in this form with ~f@ = 0, we \ndefine F C to be (vJ)(P{Z/Z}lQ) if I;l = I;I, and ERROR otherwise. Thus the ERROR process is used to \nrepresent the result of an attempted communication in which the sending and receiving processes disagree \nabout the number of names to be transmitted. The other possibility would be not to have a reduction in \nthe case of such a disagreement, so that the result would be a deadlock. But by introducing ERROR we \ncan iden\u00adtify precisely the kind of bad behaviour which can be eliminated by using well-sorted processes, \nalthough even well-sorted processes can deadlock for other reasons. The aim of introducing sortings is \nto ensure that names are used consistently. If two processes x. F and z.C have been constructed within \nthe discipline of some ambient sorting then forming the composition x .F IE.C is guar\u00adanteed to make \nsense (ie will not reduce to ERROR), because F and C will have the same number of names abstracted or \nconcreted out. Furthermore, both pro\u00adcesses agree about how each name transmitted can be used, and so \nERROR will not appear in any subsequent reductions. This will be made precise later in the paper. Milner \ns definition of sorting is as follows. We assume a collection S of subject sorts and for each S E S an \ninfinite collection of names with subject sort S, written z : S. An object sort is a sequence of subject \nsorts; that partial function ob : S -S* which describes, for any name x : S, the sort of name-vector \nit can carry when used to locate or co-locate an abstraction or concretion. Given a sorting ob, an agent \nA respects ob, or is well\u00ad sorted for ob, if it can be assigned an object sort s by the use of certain \nrules which ensure that the use of names in A is compatible with ob. So the condition is that A : s can \nbe inferred for some object sort s from the rules z:S F:ob(S) z:S C:ob(S) x.F : () Z.c :()  &#38;f:() \nIV:() 0:() M+ fv:() P:() Q:() P:() A:s PIQ :() !P :() (vx)A :S x;S F:s X:s C:s (h)F : (S)AS [X]c : (s) \ns and then s is the (possibly empty) sequence of sorts of the names over which A is abstracted or concreted. \nEach rule is to be read as a deduction of the conclusion below the line from the hypotheses above the \nline, in the manner of sequent calculus. In the rest of the paper we will describe how these rules form \nthe basis of a sort inference algorithm. 3 Sortings From now on we assume that there is a fixed collection \nhf of names, which includes all the names used in all the agents being considered. In the following theory, \neverything could be explicitly parameterised over N, but this seems excessively general. We also assume \nthat all bound names are distinct from each other and from all free names; this can be done as a-conversion \nis part of the definition of structural congruence. For sortings, we use Definition 1 A sorting Z is \na pair (1?, ob) consisting of an equivalence relation R on N and a partial function ob : N/R -(N/R)*. \nAn object sort in the sorting Z is an element of (N/R)*. The idea behind this definition is that the \nequivalence classes of R represent the assignment of subject sorts to names, so that names x and y have \nthe same sub\u00adject sort if and only if xRy. Thus we have abandoned the names of the subject sorts, and \nretained only the essential information about which names have the same subject sort. The definition \nof what it means for an agent to respect a sorting is essentially the same as in the previous section, \nexcept that we use judgments of the form Z K Abs A : s to show the sorting being used, the sort assigned \nto the agent A, and also the class of agent into which A falls. Definition 2 An agent A respects a sorting \nZ = (R, 06), or is well-sorted for X, if for some object sort s the judgement X 1-AgentA : s can be derived \nfrom the rules in Figure 1. To show the benefit of working with well-sorted pro\u00adcesses, we state (but \ndo not prove) Proposition 1 If X t-Proc P : () and P ~ Q then Zt-Proc Q : (). from which, noting that \nthe agent ERROR does not re\u00adspect any sorting, avoidance of run-time error follows. Corollary 2 If Z \nt-Proc P : () then P ~ ERROR. Before considering the question of how to infer a sorting for a given agent, \nwe will develop an algebraic theory of sortings a little; this can be convenient y expressed in the language \nof partial orders. The idea is that sort\u00adings form a poset in which moving up the order relation represents \ninstantiating a sorting by combining certain subject sorts and extending the domain of definition of \nob. Definition 3 Let Sort be the set of sortings Z = (.??, oh), with a partial order defined by Z ~ X \nif and only if R ~ R and whenever ob([z]R) = ([ZI]R . . . [LE&#38;), ob ([~]~,) = ([Z1]RI .,. [z&#38;). \nIt is easy to check that this does define a partial or\u00adder. Note that R induces an equivalence relation \non each equivalence class of R , so the classes of R are themselves partitioned into R-classes; these \nare also the classes into which R partitions N. Viewing this the other way round, the picture is of R \nbeing constructed by amalgamating some of the R-classes of ~, as long as this results in ob being well-defined \nwhen it is induced by ob in the obvious way. Note that Sort has a least element, the sorting (=, @), \nwhich we will denote by L as usual. When inferring sortings, we will need to be able to combine sortings \nwhich have been inferred for two sub\u00adprocesses in order to find a sorting for a compound pro\u00adcess. The \nnew sorting should be an instance of both previous sortings, and in fact it is clear that we would like \nit to be the most general such sorting. So we will be interested in least upper bounds in Sort. A con\u00adcrete \nalgorithm to construct Xl V Zz will be described later; in order to make it easier to prove the correctness \nof the algorithm, we will now give a characterisation of the least upper bound of two sortings in terms \nof a least fixed point construction. Let xl = (Rl, obl ) and X2 = (Rz, ob2) be sortings for which 21 \nV 22 exists. Consider the function F on the poset (EqRel(N ), ~), defined in Figure 2, where the function \nSTC is the sym\u00admetric transitive closure and EqRel(iX) is the set of equivalence relations on a set X. \nThis definition relies on the existence of xl V Z2 to ensure that when obl [Z]R1 and 0b2 [~]R2 are defined \nwith (z, y) E R, their values are sequences of the same length. Since F is continuous and the poset (EqRel(~), \n~) has a least element (equality), we can define a sorting E = (R, ob) by taking R to be the least fixed \npoint of F, and ob to be induced by its values on the equivalence classes of RI and R2 (which are bound \nto be compatible). We now have Proof We have xi ~ Z since Ri ~ R and because of the way in which ob is \ninduced by obi. If E = (R , oh ) is such that Z1, Z2 ~ I?, then R is a fixed point of F. Hence R ~ R \n. Also El, Z2 ~ E means that ob is defined on at least those classes for which its definition can be \ninduced from the obi, and its values there are those which would be induced. So Z ~ Y. 1  4 The Sort \nInference Algorithm We can now describe the algorithm which constructs the most general sorting for a \ngiven agent, if it exists, assuming the existence of an algorithm which computes V or reports that it \nis undefined. Following the usual practice in presenting type inference algorithms in func\u00adtional programming, \nwe give a collection of inference rules for sorting judgments, similar to those in the def\u00adinition of \nwell-sortedness, but which build up a sort\u00ading as well as constructing an agent. If the judgement ~A \nh AgentA : s can be deduced from the rules given below, then the agent A k well-sorted for ~A and EA \nis the most general sorting for A. If at any point a com\u00adputation of V is required which is not defined, \nthen A does not respect any sorting. The rules are shown in Figure 3. An important feature of these rules \nis that there is exactly one for each construction in the gram\u00admar which generates agents. Thus given \nan agent A, the construction of ~A is deterministic. Before proving that this algorithm constructs the \nde\u00adsired sorting, we will illustrate it with a couple of exam\u00ad Zero II 1-NormProc O : () 2 t-NormProc \nM : () Z E NormProc IV : () plus 2 t-NormProc Al+ iV : () X h Abs F : ob[cx]~ X } Cone C : ob[a]~ Loc \nCOLOC Z F NormProc CX,F : () X h NormProc a.C : () X F NormProc N : () Proml EFProclV:() Xt-Proc P:() \nX1-Proc Q:() Comp Xl-Proc PIQ : () Et-X h Proc Proc P:() !P : () Rep Z XFProc 1-Proc (vz)P P:() : () \nResl XFProc ZFAbs P:() P:() Promz ZhProc ZFConc.P:() P:() P roms E1-Abs F:s XbConc C:s Resz Ress ~ F \nAbs (vz)F : S X 1-Cone (vz)C : s XFAbs F:() Z1-Conc C:() Promq Proms Z FAgent F :() 2 +Agent C :() Figure \n1: Rules for sort derivation. F(R) = STC(R U RI U R2 U {(zi, vi) : 3%, Y.($> y) E R&#38;Oh[z]~, = ([d~,)?=lkob[d~, \n= ([Y~]&#38;)~sl}) Figure 2: The definition of F : (EqRel(N), ~) a (EqRel(M), ~). ,/ 433 Zero 11- NormProc \nO : () X t-NormProc M : () 2 t-NormProc fV : () plus Z V Z t-NormProc M + IV :() (R, Oh)t-Abs F : ob[a]~ \n~ocl if [a]R ~ dom(ob) (R, ob) t-NormProc CY.F : () (R, ob)t Abs F :S LOC2 if [~]R @ dom( ob) (R, ob \nU {[Q]R H s}) t-NormProc a.F : () (R, ob) I_ Cone C : ob[a]R ~oLocl if [a]~ E dom(ob) (R, ob) 1-NormProc \n&#38;.C : () (R, ob) 1-Cone C :s COLOC2 if [a]R @ dom( ob) (R, ob U {[a]R I--+ s}) 1-NormProc ti.C : \n() E k NormProc IV : () Proml XFProc IV:() Et-Proc P:() Z 1-Proc Q:() Comp EvE 1-Proc P[Q : () Z1-Proc \nZ 1-Proc P:() !F : () Rep 2 ZFProc h Proc (vz)P P:() : () Resl N!v Proc Z1-Abs F :() P:() Promz xHProc \nZ1-Conc P:() Proms P:() ~ \\ E1-Abs Abs (kc)~ F:s : ([Z]R)A Abs S E h E1l-Conc C:s Cone Cone [z]F : ([Z]R)-S \nEt-Abs F:s Z i-Abs (LM)F : Res2 S E E1-Conc F Cone C:s (vx)C Ress : s Zt-Abs Z h Agent F:() F : () Promq \nXFConc IS b Agent C:() C : () Proms Figure 3 Rules for sort inference. pies, one of success and one \nof failure. Our first example comes from Milner s translation of the lazy A-calculus into the r-calculus. \nThis translation, written as [ ~, is given by [z] = (kb)z.[u]o [ptiiw; : (A?J)U.(AZ)[M] ;U)(VV)([M]VI(VZ) \n(W.[ZU]OI!Z.[N])). This translation respects the sorting which in Milner s notation is written aa {vAR \nR (ARGS), ARIm ~ (VAR, ARGS)} and which, in our notation, means that there are two equivalence classes \nof names, called VAR and ARGS. We will not dwell on the details of this translation, but just have a \nlook at the r-calculus term arising from a simple case -the identity function. According to the above \ndef\u00adinitions, [Jz.zj = (Jv)v.(Az)(~u)Z. [u]O. The ~-calculus term contains the names z, u, v; we can \ndescribe a sort\u00ading by indicating the partitions of x, u, v and the action of ob, so for example the \nsorting J_ will be written {z} +1, {u} ~ 1,{v} ~ J\u00ad where by {z} w J_ we mean that ob is undefined on \n{z}. We will omit the undefined instances of ob where this does not cause confusion. The derivation of \nthe sorting {x} + ({u}), {u} H -1-, {v} ~ ({z}, {u}) and the assignment of the sort ({v}) to the agent \n(~v)v.(kc)(Au)E. [u]O is shown in Figure 4 (uses of the promotion rules Promn are omitted). This is the \nmost general sorting respected by this agent; the sorting given by Milner, when expressed in our notation, \nis {z} + ({u, v}), {u, v} + ({z}, {u, v}) (so VAR = {z}, ARGS = {u, v}). We can see that Mil\u00adner s sorting \nis an instantiation of the one found by our algorithm. This is not to say that his sorting is not the \nmost general one appropriate for the translation of the lazy ~-calculus, but merely demonstrates the \nfact that a particular process arising from the translation may not constrain the use of its names sufficiently \nto define that sorting fully. For an example of the algorithm detecting a badly\u00adsorted process, consider \na.(Xr)7i3.O and d.[u]u.(~z)O. The first of these receives a name z on a, then sends a signal on x. The \nsecond sends a name u on a, then receives a name z on u. Thus the two processes do not use the channel \na in compatible ways, because they make different use of the name transmitted on a. Fig\u00adure 5 shows the \nattempt to infer a sorting respected by (a.(Az)E.O)[(il. [u]u.(Jz)O). The problem arises when it is necessary \nto form the join of the sortings {z} w (),{u} ~ 1, {z} M 1, {a} I+ ({z}) and {z} ~ L, {u} * ({z}), {z}* \nJ-, {a} w ({u}). Comparing ob{a} in the two sortings shows that the combined sorting must have an equivalence \nclass con\u00adtaining {z, u}, but looking at ob{z} in the first sorting and ob{u} in the second shows that \nthe combined sort\u00ading must have ob{z, u} = () and ob{z, u} = ([z]), which is contradictory. Hence the \ntwo sortings have no join, and the process respects no sorting. 5 Correctness of the Algorithm We now \nhave to demonstrate that ~A is the most gen\u00aderal sorting respected by A, in a suitable sense. First we \nneed to know that Sort.4, the set of sortings respected by A, is closed under instantiation. Lemma 4 \nIf X E SortA and E ~ ~ then E E SortA. Proof As usual, let 2 = (R, ob) and Z = (R , oh ). Given an object \nsort s = ([zl]R. . . [zn]R), define s = ([zl]~l . . . [z&#38;/). From a proof of X 1-A : s we con\u00adstruct \na proof of Z t A : s , by induction on the length of the proof. Consider the possible cases for the last \nstep of the proof. The base case: if it is Zero Z F NormProc O : () then since () = (), Zero Z i-NormProc \nO : () is the desired proof. Ifit is E 1-Abs F : ob([@]R) . Loc X h NormProc LY.F : () then by induction \nthere is a proof of X 1-Abs F : {ob([cY]H)} ; but {ob([a]R)} = Ob ([CY]RI), so this is a proof of 2 1-Abs \nF : ob ([a]~l) and hence the Loc rule can be used to prove Z 1-NormProc CY.F : () . The case for the \nrule COLOC is similar. Zero {x}, {u}, {v} H 11-NormProc 0: () ~onc {z}, {u}, {0} H J-+ Corlc [U]o : \n({u}) ~oLoc, {z} ~ ({u}) 1-NormProc Z.[U]O : () ~b~ {x} w ({u}) F Abs (Au)E.[u]O : ({u}) Abs {x} = ({u}) \n~ Abs (~a)(~u)z.[u]O : ({~}, {u}) . Figure 4: An example of sort inference. Zero {z}, {a}, {u}, {z}H \nJ-E 0: () *bs Zero {z}, {a}, {u}, {z} ~ 11-o: () ~oLoc2 {z}, {a}, {u}, {.z} k+ J_ t-(Az)O : ({z}) {z} \nH () b E.o : () {u} * {z}!-U.(lz )o : () ~on:oc Abs {z} H () + (Az)z.o : ({x}) {u} * {z} 1-[U]u.(k)o \n: ({u}) COLOC2 {z} H (), {a} -({*}) F a.(h)Z.O : () L0c2 {u} H {2}, {a} H ({u}) 1-E.[U]U.(AZ)O : () \nfhmn ._/u...~ The sortings in the premises have no join. Figure 5: Detecting a badly-sorted process. \ne If it is Proof We check that the rules in the algorithm pre\u00adserve validity of judgments. There are \nthr~e essentially different cases. , e The rule Zero is sound because then by induction there is a proof \nof 21-NormProc O : () E FAbs F:s for any sorting E. which can be extended to a proof of For the rule \nPlus, observe that since E, Z ~ Z V E , 2 1-Abs (h)F : ([x]~l)-s M and N respect E V 2 , so we have \nby the Abs rule, and this is the required proof since Z V Z F NormProc M : () ([z] B)*s = ([2] R,)-S \n. The case for the rule Cone is similar. and X V Z F NormProc IV : () All the other cases are trivial \nsince they do not from which we can deduce change the sorting of the agent involved. ~V~ F NormProc \n&#38;f+N : (). 1 Thus instantiation preserves respectability. The most o The rule Locz is sound because \n(R, ob) G (R, oh ) general sorting respected by A should be the least in-and by the same argument as \nfor the previous case. stantiated sorting in SortA, which means the least ele\u00adment of the poset. Before \nproving this, we should check = that A does respect the sorting ~A, if 2A exists. Corollary 6 If EA \nis defined then ~A e So?%A. Lemma 5 All the sorting judgments appearing in the algorithm which constructs \n~A are valid. Finally, we can prove the desired property of EA. Proposition 7 For any agent A, if ~A \nis defined then it is the ieast element of SortA. Proof We show by induction that if A respects 2 and \n~ appears during the construction of 2A, E ~ ~; hence if Z ~ SortA and 2A is defined, ZA ~ Z. There \nare essentially three cases to consider. A respects the sorting 1 which starts the construc\u00ad tion off. \nAlgorithm 1 To compute the least upper bound of two For the rule Plus we have by induction that sortings, \nif possible. Xl, 212 ~ Z, and so xl V Xz ~ 2 since it is the least upper bound. procedure lub(l?l, obl, \nR2, obz,R, ob) R:= TC(RI U R2) For the rule Locz we have by induction that repeat (Rl, Obl) Q Z. In the \nproof that A respects Z, 1:=0 the rule Locz must be used with sorting Z, which foreach (x, y) c N2 do \nmeans that ob : [cr]~ H s. If if (c, y) G R (obl U {[cYIR,= s})([z]R,) = ([~I]R, . . . [%] R,) and and \notq [Z]R1 obz [V]R2 = = ([zi]R1 )i &#38;l ([vj]R2)7sI then then either if m # n then fail obl([z]~l) \n= ([~I]R1 . . . [%] RI) else foreachi=l... ndo or [$]R1 = [~]Rl. In the first case, if (q, Vi) @ R then \nobl([z]R) = ([Z1]R . . . [Zn]R) 1 := endif /u {(zi, yi)} since (Rl, obl ) ~ 2, and in the second case \nendfor endif .S = ([ZI]R1 . . . [zn]R,) = ob([dd. endif endfor Hence foreach (z, y) c 1 do (Rl, obl U \n{[a]Rl + S}) ~ ~. R:= STC(R U {(z, y)}) endfor = until 1 = 0 foreach z c N do if obl[z]~l = ([~i]RI)?el \nComputing Least Upper and obz [Z]R2= ([Yj]RJ~el then Bounds of Sortings endif ob([z]R) := ([Zi]R):=l \nendfor now need to describe the algorithm which given end procedure = (Rl, obl) and Ez = (Rz, obz), calculates \nZ = .Z1 V E2 = (R, ob) or reports that it does not exist. The algorithm is shown in Figure 6. It uses \nthe functions TC and STC which compute the transitive closure and Figure 6: Computing least upper bounds. \nsymmetric transitive closure of their arguments, respec\u00ad tively. We now prove the correctness of this \nalgorithm in an informal way. Of course, as we are now at the stage of considering real computation, \nwe assume that Af is finite; the actual set A.f of names used in a given agent can be determined syntactically. \n Lemma 8 Algorithm 1 always terminates. Proof The set 1 is used during each pass through N2 to accumulate \nthe extra pairs which need to be added to R. Each such pair which is found represents a pair of equivalence \nclasses of R which need to be joined to\u00adgether. Since there are only finitely many equivalence classes \nin TC(R1 U R2) to start with, it must be the case that after some finite number of passes through N2, \nno more pairs will be found on the next pass. When this happens, 1 = 0 at the end of a pass, and this \nis the case in which the algorithm terminates. = Proposition 9 When Algorithm 1 terminates, (R, Ob) = \nXI V~z. Proof The algorithm is directly computing the least fixed point of the function F by iteration. \nThe only difference is that the algorithm makes explicit the fact that the existing relations RI and \nRI only need to be incorporated at the first iteration. 1 A few words about the complexity of the sort \ninference algorithm are in order. When computing the most gen\u00aderal sorting respected by a given agent \nA, the function V is calculated s + c times where s and c are the numbers of occurrences of+ and I in \nA. As for the complexity of computing V, if INI = n then computing TC(R1 U Rz) takes time 0(n3), Combine \nis called O(n) times, joining two equivalence classes takes time O(n) and finding the length of an object \nsort should take time O(n) with the result that computing V is 0(n3). The problem with this analysis \nis that the length of an object sort cannot be bounded by n because of the fact that introducing a name \ninto a concretion does not bind it and so the sort of a concretion can be arbitrarily long. If the maximum \nsize of a concretion is m then the time taken to compute V is 0(n3 +n2m). We can bound S+C, n and m by \nthe size p of the textual representation of the process; this gives a bound of 0(p4) on the time taken \nto calculate the most general sorting. 7 Conclusions The idea of sorts in the m-calculus extends the \nbenefits of typing from a sequential to a concurrent setting, pro\u00ad viding a useful tool in program design. \nThe algorithm presented in this paper demonstrates that sort check\u00ad ing and sort inference could also \nbe incorporated into an implementation of the ~-calculus offering the same support to the programmer \nas type checking and type inference do in functional language implementations. 8 Acknowledgements It \nshould be noted that work in the general area of sort\u00adings, including sort inference, has been carried \nout in\u00addependently by David N. Turner (personal communica\u00adtion); his work is as yet unpublished and, \nI believe, uses a rather different approach. I would like to thank Samson Abramsky, Roy Crole, Radha \nJagadeesan, Hiu Fai Chau and Sebastian Hunt for their helpful comments and suggestions during the preparation \nof this paper; also the anonymous referees who made some valuable comments.   References [Hin69] J \n.R. Hindley. The principal type-scheme of an object in combinatory logic. Transac\u00adtions of the American \nMathematical Society, 146:29-60, 1969. [Mi178] R. Milner. A theory of type polymorphism in programming. \nJournal of Computer and System Sciences, 17, 1978. [Mi189] R. Milner. Communication and Concur\u00adrency. \nPrentice Hall, 1989. [Mi191] R. Milner. The polyadic ~-calculus: A tuto\u00adrial. Technical report, Laboratory \nfor Foun\u00addations of Computer Science, Department of Computer Science, University of Edinburgh, 1991. \n[MPW89] R. Milner, J. Parrow, and D. Walker. A cal\u00adculus of mobile processes. Technical report, Laboratory \nfor Foundations of Computer Sci\u00adence, Department of Computer Science, Uni\u00adversity of Edinburgh, 1989. \n  \n\t\t\t", "proc_id": "158511", "abstract": "<p>In Milner's polyadic &#960;-calculus there is a notion of <italic>sorts</italic> which is analogous to the notion of types in functional programming. As a well-typed program applies functions to arguments in a consistent way, a well-sorted process uses communication channels in a consistent way. An open problem is whether there is an algorithm to infer sorts in the &#960;-calculus in the same way that types can be inferred in functional programming. Here we solve the problem by presenting an algorithm which infers the most general sorting for a process in the first-order calculus, and proving its correctness. The algorithm is similar in style to those used for Hindley-Milner type inference in functional languages.</p>", "authors": [{"name": "Simon J. Gay", "author_profile_id": "81554820256", "affiliation": "", "person_id": "PP1700024900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158701", "year": "1993", "article_id": "158701", "conference": "POPL", "title": "A sort inference algorithm for the polyadic &#960;-calculus", "url": "http://dl.acm.org/citation.cfm?id=158701"}