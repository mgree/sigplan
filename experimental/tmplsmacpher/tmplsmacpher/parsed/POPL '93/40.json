{"article_publication_date": "03-01-1993", "fulltext": "\n Quasi-Static Scoping: Sharing Variable Bindings Across Multiple Lexical Scopes* Shinn-Der Lee and Daniel \nP. Friedman Computer Science Department Indiana University Bloomington, Indiana 47405 sdleeacs.indiana. \nedu Abstract Static scoping embodies a strong encapsulation mechanism for hiding the details of program \nunits. Yet, it does not allow the sharing of variable bindings (locations) across indepen\u00addent program \nunits. Facilities such as module and object systems that require cross references of variables therefore \nmust be added as special features. In this paper we present an alternative: quaai-st atic scoping. Quasi-at \natic scoping is more flexible than at atic scoping, but has the same encapsu\u00adlation mechanism. The user \ncan control when and in what scope to resolve a quasi-at atic variable, i.e., to associate it with a \nvariable binding. To demonstrate its versatility, we add quasi-static scoping to Scheme and show how \nto build the aforementioned facilities at the user-level. We also show that quasi-at atic scoping can \nbe implemented efficiently. Introduction Static (Lexical) scoping is ideal for hiding the internal de\u00adtails \nof program units. In addkion, a static variable s refer\u00adence occurrences can all be identified syntactically \nat com\u00adpile time. Thus, there is little, if any, computation needed at run time to resolve a variable \nreference, i.e., to determine the variable binding (location) denoted by the reference. Con\u00adsequently, \nat atic scoping facilitates eilicient implementation. Yet, static scoping does not allow variables to \nbe shared across independent scopes [14]. Facilities such as module and object systems that support cross \nreferences of variables among lexical scopes thus must be added as special features. They provide the \nnecessary scoping information to assist the evaluator (compiler or interpreter) in resolving variable \nreferences. \" Thk research was partially supported by the National Science Foundation under grants CCR \nS9-01919 and CCR 90-00597. Permission to copy without fee all or part of this material is grented provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. ACM-20th PoPL-1 /93-S. C., USA Q 1993 ACM 0-89791 -561 -5/93 /0001 /0479 . ..$1 \n.50 dfried@cs.+adiana. edu In this paper we present an alternative: guasi-datic scop\u00ading. With quasi-at \natic scoping, a free variable in an ex\u00adpression can be designated as quasi-static. A quasi-static variable \nis initially unresolved, i.e., not associated with any variable binding. To avoid int roduang dynamic \nbehavior, it has no default binding in the expression s evaluation-time environment. Rather, the user \nmust resolve it prior to deref\u00aderencing; otherwise, it is a dangling reference and raises an error. We \ntherefore provide a resolution operation to aasociate a quasi-at atic variable in an expression with \na variable binding in any scope. This resolution is performed independently of the given expression s \nevaluation, and it need not resolve all the quani-static variables of the expression at once. Thus when \nand in what scope a quasi-static variable is resolved is entirely at the user s discretion. Moreover, \nonce a quaai-static variable is resolved, it re\u00admains iixed as if it had been a static variable, hence \nthe term quasi-static. It thus provides the same encapsulation mechanism as at atic scoping and therefore \nthe same degree of program modularity and security. In addition, since a resolved quasi-at atic variable \nis a at atic variable, run-time dereferencing requires no extra work. Any renaming (a-conversion) of \na static variable is done consistently throughout the variable s syntactically evident finite scope. \nHence, a static variable s resolution can safely depend on its name. The name-based resolution of a quaei\u00adstatic \nvariable, however, does not survive under a-conversion, since the scope of a shared quasi-static variable \ncannot be determined lexically. We avert this problem by recognizing that every variable has two names: \nan internal name and an extemol name. The former is a-convertible and is used in the finite scope of \nevery at atic and quasi-at atic variable. The latter is not subject to renaming and is used by the quasi\u00adstatic \nvariable resolution operation to associate a reference in one scope with a binding in another scope. \nIn the next section we extend Scheme with quasi-static scoping. In Section 3 we demonstrate the expressive \npower of quasi-static scoping by using it as a basic building block for constructing module and object \nsystems. In the follow\u00ading two sections we present a denotational semantics and an efficient implementation \nof quasi-static scoping. In the last section we make comparisons to other work and discuss future research \ndirections. 2 Extending Scheme with Quasi-Static Scoping Scheme is an elegant statically-scoped functional \nlanguage with imperative features that has a simple and clean se\u00admantics [4]. In this section we add \nquasi-static scoping to Scheme, showing that quasi-static scoping and static scoping can co-exist and \ncomplement each other. 2.1 Quasi-Static Procedures A quasi-static variable is not as static as a static \none; it should only be used in circumstances where a static vari\u00adable is inadequate. Thus, a variable \nis static unless stated otherwise. In an applicative-order language like Scheme, a procedure is the only \nvalue with possible references to free variables. Hence, we add a new type of procedure, called a quasi-static \nprocedure, that haa some of its free variables quasi-statically bound. A quasi-static variable is unresolved, \ni.e., not associated wit h a variable binding, when the proce\u00addure is defined. It is later resolved to \nsome existing variable binding at the user s discretion. A quasi-static procedure is the result of evaluating \na qs\u00adlambdaO expression of the following form: (qs-lambdao ((ql Qi ) . . . (qk Qk)) formals bodY) The \nnames ql, .... qk, where k 2 0, and QI, .... Qh are the internal and external names of the procedure \ns quaai\u00adstatic formal parameters, respectively. They are identfied by their positions in a qs-lambdaO \nform. To further dis\u00ad tinguish them visually, however, we use upper-case for the external ones and lower-cue \nfor the internal ones. Like the static formals, the quasi-static formals ql, . . .. qk are also the procedure \ns bound variables with a finite scope consisting of only the body expression. Consequently, like the \nstatic formals, they are subject to a-conversion. Their external names, however, a~e not. In order to \navoid ambiguities, the formal parameters, static and quasi-static, must have dif\u00adferent internal names, \nand the external names of the quasi\u00adstatic formals must be different as well. When a qs-lambdaO expression \nis evaluated, the envi\u00ad ronment in effect defines the free static variables referenced in the body; the \nquasi-static formals are unresolmd and are known outside through their corresponding external names. \nCalling a quasi-static procedure binds its static formals but not its quasi-static formals. The latter \nare associated with variable bindings using resolvel described below. For example, the two expressions \nin Figure 1 define two independent quasi-static procedures odd? and even?. The procedure odd? has an \nunresolved quasi-static formal pa\u00adrameter whose internal and external names are even? and (define odd? \n(qs-lambdaO ((even? F)) (z) (if (zero? z) #f (even? (-s l))))) (define even? (qs-lambdaO ((odd? G)) \n(z) (if (zero? z) #t (odd? (-z l))))) Figure 1: Two independent quasi-static procedures. 1 , respectively. \nWe can rename the internal name just as we might rename a bound variable. Thus, the expression (define \nodd? (qa-lambdaO ((foo ~)) (z) (if (.vem? z) #f (/00 (-z l))))) defines the same odd? procedure. On the \nother hand, the resolution operation relies on the external name F to SSSG ciate even? with a variable \nblndmg. Hence, it is not subject to a-conversion. The two procedures odd? and even? have no access to \neach other; they are not mutually recursive. Applying the procedure odd? in Figure 1 binds x, but the \nquasi-static formal parameter even? remains unresolved. Hence, the ap plication (even? ( z 1)) raises \nan unbound variable error. One of our design criteria is to make quasi-static scop\u00ading as orthogonal \nto Scheme as possible. Quasi-static pro\u00adcedures are therefore disjoint from ordinary Scheme proce\u00addures. \nThus, we need a new predicate (qs-procedure ? ezp) that returns true only if the expression ezp evaluates \nto a quasi-static procedure. Hence, (qs-procedure ? (lambda (z) z)) iS f~e M iS (procedure? (qs-lambdaO \n() (z) z)), even though the latter has no quasi-static formals and behaves exactly like (lambda (z) z). \n 2.2 Quasi-Static Variable Resolution The only operation that can resolve a procedure s quasi\u00adstatic \nformal parameters is the resolvel special form. It maps a quasi-static procedure into another distinct \nquasi\u00adstatic procedure with possibly fewer unresolved quasi-static formal parameters. A resolvel expression \nhas the form (resolvel z Q qs-proc) (The 1 of resolvel indicates that it involves only a single variable.) \nThe variable z must be associated with a vari\u00adable binding and the expression qs-proc must evaluate to \na quasi-static procedure, say, ~. The resolvel expression then returns a new quasi-static procedure g. \nFor each un\u00adresolved quasi-static formal parameter q of ~, if its external name is Q, the q in g becomes \nan alias of z. That is, the q in g is associated with the variable binding of z. Furthermore, such a \nresolved q becomes a static variable of g and there\u00adfore does not participate in future resolution operations \non g. Otherwise, q remains unresolved in g. (letrec ((nay-odd? (resolvel rny-wen? F odd?)) (rn~euen? \n(resolvel m~odd? G even?))) (rn~ochf? 6)) Figure 2: Mutual recursion with resolution. We can use resolvel \nto construct programs from exist\u00ading compiled programs, rather than their source code, by linking their \nquasi-static variables. For inst ante, Figure 2 shows how to build a mutually recursive version of the \ntwo procedures odd? and even? of Figure 1 with resolvel. The first resolvel expression returns a quasi-static \nprocedure, called m~ odd?, that is similar to odd? except that its quasi\u00adstatic variable even?, having \nexternal name F, is alissed to the variable my-even?. Similarly, the qussi-st atic variable odd? of the \nprocedure my-even? is an alias of the variable my-odd?. Hence, my-odd ? and my even? are mutually recur\u00adsive \nand the expression in Figure 2 is equivalent to (letrec ((m~odd? (qa-lambdaO () (z) (if (zero? z) #f \n(myeuen? (-z l))))) (my-even? (qs-lambdaO () (z) (if (zero? z) #t (m~odd? (-z 1)))))) (my-odd? 6))  \n2.3 Currying Quasi-Static Procedures The addition of qs-lambdaO takes away an important pro\u00adgram transformation \ntechnique: currying. For instance, con\u00adsider currying the static formal parameters of the following quasi-static \nprocedure (q:~)dao ((z X)) (a b) Because x is not used until the inner procedure of the curried result \nis applied, we would like to allow X to be resolved at either of the two nested quasi-static procedures \n(qs-lambdaO ~ (a) (qs-lambdaO ~ (b) (Z a b))) Putting ((s X)) in either ~ or ~ and placing () in the \nother is incorrect, because X can then only be resolved at one of the two qussi-static procedures. Putting \n((z X)) in both ~ and ?Z is equivalent to placing it only in ~, since the inner a shadows the outer one. \nSo, that also does not work. What we need is something that can provide two (in general more than one) \noccasions to resolve X. In addition, they should be connected in such a way that if X is resolved at \nthe outer procedure then the X of the inner procedure is also resolved and has the same variable binding. \nOtherwise, the inner procedure provides another chauce to resolve X. Hence we define the following qa-lambda \nspecial form (qa-lambda ((iql oql) . . . (iqm 09=)) ((N:,)---J Qh)) A qs-lambda expression generalises \na qa-lambdaO expres\u00adsion with the extra list ((igl Ogl ) . . . (iqm oqm)), where m ~ O. (The O of qa-lambdaO \nmeans its m is O.) The list indicates that the inner qussi-st atic formals iqi, . . .. iqm lezically \ninherit the status of the outer quasi-static variables oq~, .... oq~, respectively. That k in the res~ting \nqussi\u00adstatic procedure, iqj is an alias (having the same variable binding) of oqj, provided oqj is resolved. \nOtherwise, iqj is an unresolved quasi-static formal parameter with the same external name as oqj and \nis therefore resolvable. Further\u00admore, because lexical-inheritance is unidirectional, resolving iqj does \nnot resolve oqj as well. So, it is possible for iqj to be resolved but not oqj. Again, the inheriting \nquasi-static for\u00admals iql, . . .. iqm must be dHerent horn the other formals. They are the procedure \ns bound variables and are therefore subject to a-conversion. The outer ones, however, are free within \nthe expression. Now, the curried version of the above two-argument quasi\u00adstatic procedure is (qa-lambdaO \n((z X)) (a) (qs-lambda ((z z)) () (b) (c a b))) We can resolve X at either quasi-static procedure. If \nX is resolved before the outer procedure is called, the inner x lexically inherits the identity of the \nouter z. Thus, it is a static variable of the inner procedure. On the other hand, if X is unresolved \nat the outer procedure, the inner z lexically inherits the external name X. It is therefore still a resolvable \nquasi-static formal. The ability to lexically inherit quasi-static variables has applications beyond \nexpressing currying. We can use it to implement Common Lisp s optional keyword parameters [18]. Consider \nthe quasi-static procedure ~ defined in Figure 3. It has a quasi-static parameter a named externally \nas A that is lexically inherited by the inner quasi-static procedure (q-lambda ((a a)) () () (set! a \n(+ n a)) a). When ~ is called with 3, A is unresolved. Consequently, the inner quasi-static procedure \nbecomes (qa-lambda ((a A)) () () (set! a (+ n a)) a). But before the inner quaai\u00adstatic procedure is \ncalled, its A is resolved with private-val. Therefore, a is aliaeed to private-val, which acts as the \ndefault binding of a. Hence, the result of (j 3) is (+ 3 1). Also, each call to f generates a distinct \nprivate-val so that the assignments (set! private-val (+ n private-val)) do not affect one snother. If \nwe intend to share default-val among sll calls to f, however, we should remove the inner let and replace \n(resolvel private-val . ..) with (resolvel defauk\u00adval ... ), On the other hand, invoking g on 3 yields \n(+ 3 10). The quasi-static parameter a is an alias of y. Because A has been resolved, the second resolvel \noperation has no effect (define f (let ((de~ault-ual l)) (qa-larnbdaO ((a A)) (n) (let ((private-rnd \nck~atdt-val)) ((resolvel priuate-ual A (qa-lambda ((u a)) () () (set! a (+ n a)) a))))))) (define g \n(let ((y 10)) (resolvel y A ~))) Figure 3: Optional keyword parameter. on the inner quasi-static procedure. \nThe formal parameter a therefore behaves just like an optional keyword parameter of ~. Its external name \nA is the keyword and its default value is default-val. Whereas static formals can be curried, quasi-static \nfor\u00admals are not. For example, (qs-lambdaO ((a X) (y Y)) (a ~) (z (y ab))) is different from (qs-lambdaO \n((z X)) (a) (qs-lambda ((z z)) ((Y Y)) (~) (z (y a b)))) because in the latter we cannot resolve Y at \nthe outer pro\u00adcedure. Beaides, since there is no ordering between X and Y, it is unclear which one should \ncome first. 2.4 Derived Forms In addition to the two new special forms qs-lambda and resolvel, we define \ntwo syntactic extensions resolve and ink-resolver. The resolvel operation involves only a single variable. \nTo express the same operation for multiple variables, we use the resolve syntactic extension defined \nin Figure 4. Alter\u00adnatively, we could take resolve aa a core form and define resolvel se a degenerate \ncsae of resolve. Indeed, the alter\u00adnative view is beneficial from the perspective of implement w tion \nefficiency. It will not only avoid allocating space for the quasi-static procedures generated by the \nintermediate steps, but also eliminate the time taken to generate and garbage collect them. A quasi-static \nprocedure imports variable bindings and a resolution operation exports them. They complement each other. \nBut, whereas a quasi-static procedure is a first-CISSS value, a resolution operation is not. Fortunately, \nwe can abstract over the operand of a resolution operation to make it into a first-class value. This \nia captured by the ink-resolver syntactic extension defined in Figure 5, where all the external names \nare dMerent. Such a one-argument (resolve ((ZI Qi) (a Qz) . ..) qs-proc) a (resolvel ZI Qi (resolve ((za \nQ2) . ..) qs-pruc)) (resolve () qs-proc) * qs-proc Figure 4: Syntactic extension resolve. (ink-resolver \n(z, Q,) . . . (zn Qn)) * (lambda (qs-proc) (resolve ((ZI QI) . . . (G Q~)) qs-proc)) Figure 5: Syntactic \nextension ink-resolver. procedure is a quasi-static procedure transformer we call a resolver. It is essentially \na first-class environment of the variables Z1, . . .. Zn known externally through the names QI, . . .. \nQ-. For instance, the expression (define pt (let ((z 3) (y 4)) (ink-resolver (. X-COJ?) (y Y-COR)))) \nreturns a resolver pt with external names X-COR and Y-COR. Besides constructing it from scratch, there \nare two other ways to build a resolver. First, we can construct a sub\u00adresolver of a resolver by extracting \nvariable bindings from the latter. For instance, consider the expressions (define z-of-pt ((pt (c@arnlxiaO \n((z X)) () (ink-resolver (z X)))))) (define y-qf-pt ((pt (qa-hunlxho ((z y)) () (ink-resolver (z Y)))))) \nBy matching the external name X, the quaai-st atic formal z is aliased to the variable z of pt. Then \nthe resulting zero\u00adargument procedure is called to return a resolver of z under the external name X. \nTherefore, z-of-pt is a sub-resolver of pt. Similarly, y-o~-pt is a sub-resolver of pt. Second, we can \nconstruct a new resolver by superimposi\u00adng one resolver on another. For example, the expression (define \nptO (superimpose z-of-pt y-of-p~)) where supen mpose is (define superimpose (lmbda (j g) (9 (f ~)))) \ndefines a resolver pt(l that is the same as pt in behavior. The way z-of-pt is constructed above relies \non the fact that we know the resolver pt has a binding with the external name X. If we have no access \nto that knowledge, we can use the following defined? syntactic extension to determine whether the external \nname X is defined in the resolver pt (defined? Q resolver) + ((resolver (qe-larnbdaO ((q Q)) () (let \n((unique unique )) ((resolvel unique Q (qe-l~bda ((9 q)) ()() (not (e*? q unique))))))))) Briefly, Q \nis an optional keyword parameter with a unique default value unique. If resolver has a binding for Q, \nthe variable q is aliased to that binding and therefore the test (not (eq? q unique)) is true. Otherwise, \nq assumes the default binding unique and so the test fails. The same problem, however, is undecidable \nfor a quasi\u00adstatic procedure. We cannot tell if a quasi-at atic procedure has an unresolved quasi-static \nformal parameter with a par\u00adticular external name. Interestingly, the problem becomes deadable if we \nallow a quasi-static procedure with no unre\u00adsolved quaei-st atic formals to be coercible into an ordinary \nScheme procedure (cf. Section 2.1). Briefly, by resolving the given procedure with external names defined \nin some pre\u00addefine order and testing whether each result is a Scheme procedure, we can determine the \nlargest external name aesociat ed with the procedure. Repeating the process until there are no more unresolved \nquasi-static formal parame\u00adters and we have the external names of all the unresolved quasi-static formals \nin descending order. From the perspective of information hiding, we consider thk asymmetry desirable. \nWhat is exported should be made public whereas what is imported should be kept private. 3 Module and \nObject Systems To further demonstrate the versatility of quasi-static scop\u00ading, we use it to build a \nmodule system and an object sys\u00adtem. The former illustrates variable binding sharing among modules, the \nlatter depicts code sharing among objects. 3.1 Modules A module is a protection mechanism that realiaes \nthe prin\u00adciple of information hiding. Its operational detail is hidden from other modules. A module communicates \nwith other modules only by importing and exporting variables. Hence, its extensional behavior is totally \nspecified by its import and export variables. In our module system, there are two kinds of first-class \nentities: interfaces and clients. An interface is a resolver that exports a collection of sharable variable \nbindings, which serve as communication channels between the clients that import them. A client is a quasi-static \nprocedure with its quasi-static formals being the client s impart variables. It gains access to sharable \nvariables by linking with interfaces and interacts with other clients by writing to and reading from \nshared variables. Besides implementing information hiding, our module system also supports increment \nal development and testing (error squsre root function undefined )))) (mk-resolver (sqrt SQUARE-ROOT)))) \n ~ Figure 6: User interface. (define tester-intj (let ((tester (lambda (inq.d) ((inapl (qa-lambdaO ((qrt \nSQE7 ) (epsilon EPSILON)) () . ..)))))) (ink-resolver (tester TEST)))) (define installer-intf (let ((installer \n((user-intf (qs-lambdaO ((sqrt SQUARE-ROOT)) ) (lambda (irnpl) ((itnpl (qa-lambdaO ((~ SQRT)) () (set! \nqrtf)))))))))) (ink-resolver (installer INSTALL)))) [define impl-intf (superimpose tester-intf installer-in~)) \nFigure 7: Implementor interface. of modules. As presented in the previous section, there are various \nways of building interfaces (resolvers). Two inter\u00adfaces can be combined into a single one and a sub-interface \ncan be constructed out of an existing one. In addition, the definition, and therefore the compilation, \nof a client is inde\u00adpendent of its linking with its interfaces. Thus, a client can be created without \nthe existence of its interfaces. Later, it can be linked to its interfaces when they become available. \nMoreover, changing the definition of a client requires only the recompilation and relinking of the client, \nno other clients are affected. Our module syetem M thus highly attractive to the development and testing \nof programs in an interactive environment. To illustrate, we show how to apply the module concept to \nmanage the development of a square root function. In Figure 6 we define an interface user-intf that is \nintended for the function s users. It exports a single variable sqrt, whose implement ation is yet to \nbe defined, under the external name SQUARE-ROOT. Next we define in Figure 7 an interface impl-int~ for \nthe function s implementor. The interface is a combination of two independent interfaces: tester-intf \nand installer-int~. The interface tester-intf exports the vari\u00adable tester with the external name TEST. \nThe procedure tester serves as the specification that the implementation must meet. It takes an implementation \nimpl and returns define test.Mnstall (impl-intj (q:~-:bdao ((test TEST) (install INSTALL)) (impl ((test \nimpl) (install impl) installed) (else rejected))))) define newton-sqrt (let () (define tolerance O) (define \nitemte (lambda (z n) (if (< (ahs ( (* x z) n)) tolemnce) ~iterate (/ (+ z (\\ n z)) 2.0) n)))) (define \nsqrt (lambda (n) (itemte 1.0 n))) (ink-resolver (toiemnce EPSILON) (qrtSQR Z )))) :test&#38;install newton-sqrt) \nFigure 8: A square root function implementation. #t only if the implementation satisfies the unspecified \ntests. An implementation impl of the square root function is in the form of an interface. It must provide \nat least two export vari\u00adables under the external names SQR2 and EPSILON. The former ia sasociated with \nthe implementation of the square root function. The latter denotes the tolerance of the func\u00adtion s solutions. \nThe tests are expected to tune the tolerance factor of the implementation to meet the needs of the users. \nThe other interface installer-intj exports another variable installer whose external name is INSTALL. \nThe procedure installer provides the implementor a means to deposit the final result in the sqrt variable \nthat ia visible to the users. It gains access to sqrt by importing SQUARE-ROOT from the user interface \nuser-intf. There are various ways of realizing the square root func\u00adtion. Figure 8 illustrates one possibtity. \nFirst, testing and installation are merged into a single procedure called test .!lfinstall. It takes \nan implementation and applies the imported testing procedure to it. It then uses the imported installation \nprocedure to deposit the implementation into the variable visible to the users, provided the testing \npro\u00adcedure approves the implementation. Otherwise, it issues a negative response. After the definition \nof testWinstall, the implementor need only come up with a solution in the form of an interface. For instance, \nFigure 8 shows a square root function implementation newton-sqrt, in the form of a two\u00advariable interface, \nthat is baaed on Newton s method. To test and install th~ implementation, the implementor need only invoke \nthe test tYinstall procedure on it. The square root function implementation can be altered with minimal \nrecompilation and relinking. The only changes are to the implementation itse~ no other clients or interfaces \nneed be recompiled or relinked. Our module system uses by-reference export and import, aa well aa run-time \nlinking. Felleiaen and Friedman s Scheme module system [7] also employs run-time linking. But it uses \nby-value import and export. There are thus serious restric\u00adtions on the ordering of linking, since import \ncan occur only when the export value is readily available. To ease the re\u00adstrictions, they switch to \nby-name import that essentially. delays import until the value ia needed. Unfortunately, by\u00adname import \nonly works for import values that are proce\u00addures. Curtis and Rauen s Scheme module system [5] uses by\u00adreference \nimport and export. But its goal ia to perform compile-time (static) linking since macros are expected \nto be sharable as well. Therefore their interfaces are compile\u00adtirne objects, since they must be computable \nstatically. ML s module system [13] uses by-value import and ex\u00adport. But since ML haa first-class references \n(variable bind\u00adings), by-reference import and export are easily expressible aa well. ML s funct ors, \nwhich are functions mapping mod\u00adules to modules, are not first-class values; instead, they are first-order \nobjects. With such a restriction, every functor ap plication can be inlined and hence ML s import and \nexport variables can be statically linked as in Curtis and Rauen s system. Without first-class functors, \nhowever, procedures like tester and installer of Figure 7 are not expressible in the two module systems. \nIn summary, we believe that by-reference import and ex\u00adport and run-time linking are essential to a Scheme \nmodule system. But we would alao like to have static linking be\u00adcause of macro sharing and efficiency. \nThus, a combination of the above systems ia preferred.  3.2 Objects In Scheme object systems [2, 15] \nwhere instance variables are lexical variables, inheritance of instance variables ia not feasible. One \nway of getting around this restriction is to define for each instance variable a pair of methods called \nreader and writer, and simulate instance variable inheri\u00adtance with method inheritance, aa in CLOS [18]. \nAnother constraint posed by lexical instance variables ia that an ob\u00adject s method, which is a procedure, \nmust be defined within the lexical scope of the object s instance variables in order for it to gain access \nto the instance variables. Oaklisp [11] removes the constraint by resorting to the add-method special \nform (add-method (op (type . inst-vars) . args) . body) where inst-uars ia the list of instance variables \nof the chss type that are accessible to the method s body. The addition of quasi-static scoping, however, \nprovides a simple alternative. By treating a method aa a procedure (define rnk-obj vector) (define obfidispatcher \n(lambda (z) (vector-re.f x O))) (define obj4uars (lambda (z) (uector-ref x l))) (define ob~pamnt (lambda \n(z) (vector-ref z 2))) (define obj-mncell (lambda (z) (vector-re~ z 3))) (define obfiternplate (lambda \n(z) (vector-mj z 4))) (define d-cell vector) (define celbe~ (lambda (z) (vector-ref x O))) (define ce.li-set! \n(lambda (S v) (vector-set! z O v))) Figure 9: Object representation. with its quasi-static formal parameters \nas the inst ante vari\u00adables referenced in the method, the definition of an object s method can be separated \nfrom the object s instance vsri\u00adables. Consequently, it facilitates incremental method addi\u00adtion to an \no~ject a la Oakliap. For example, the following quasi-static procedure (define distance (qs-lambdaO ((z \nX) (y Y)) (self) (+ z y))) is a method that references instance variables whose external names are X \nand Y. Such a method is called an open metkod. It can be added to the classes the user deems appropriate. \nFurthermore, by packaging an object s instance variables into a resolver and making it available to the \nobject s chil\u00addren, we have inst ante variable inheritance as well. To illus\u00adtrate, let cp be an object \nwith at least two instance variables named X and Y, and let their resolver be defined as (define cp-iuars \n(let ((z 3) (y 4) ...) (ink-resolver (z X) (y Y) . . . ))) Moreover, let mp be an object that inherits \ncp-iuars from cp. Then, to invoke distance on mp, the open method s quasi-static formals are resolved \nby cp-iuars to produce an eflectiue method as follows: (define resolved-distance (cp-iuars distance)) \n It is then invoked on mp, which is bound to the static formal parameter self, (resolved-distance mp) \n In the rest of this section we describe a simple object sye\u00adtem that is based on quasi-static scoping. \nThe object system employs message passing, has only single inherit ante, and achieves self-reference \nthrough an explicit parameter self. It is based on delegation. There are no specific objects des\u00adignated \nas class objects; every object is its own class object. An instance object is created from a class object \nby cloning the latter. In Figure 9 we define our system s object represent\u00adation. An object is a vector \nof five elements: a dispatcher, an inst ante variable resolver, a parent object, a cell of open methods, \nand an instance variable template. The dispatcher defines how the object responds to messages. The instance \nvariable resolver defines the instance variables to which the object has access, including the ones that \nthe object inherits horn its parent. The fourth element is a cell that contains an incrementally growing \nasaoaation list of operation and open method pairs. For ease of presentation, operations are just symbols. \nThe last component of an object is a template from which the instance variable resolver is generated. \nEs\u00ad sentially, clones of an object share the same open method cell. Code sharing, a single method operating \non multiple sets of inst ante variables, is accomplished through the shar\u00ad ing of open methods among \nobjects. An object is created by invoking the new procedure of Figure 10-with an instance variable template, \na parent ob\u00adject, and the initial values of the object s inst ante variables. Each new object has two \nbuilt-in methods add-method and clone. The former is responsible for the incremental addi\u00adtion of methods \nto the object. It takes an operation and open method pair, and adds it to the object s open method cell. \nThe latter built-in method clones the object itself. It is similar to new except that it needs only the \ninitial values of the clone s instance variables, since the dwpatcher, the par\u00adent object, and the inst \nante variable template are known to be those of the cloned object. Instance variable inheritance is defined \nby the mk-ivars procedure of Figure 10. It uses the object s instance variable template with initial \nvalues to generate the object s own inst ante variable resolver. This resolver is then composed with \nthat of the parent object. Hence, when the composition is applied to a given open method, the method \ngains access to both the object s own instance variables and the ones of the parent objects. In case \ninst ante variable inherit ante is undesirable, we can replace the procedure mk-ivars of Figure 10 by \n(define mk-ivars (lambda (template ivals parent) (apply template iwds))) This time the parent object \ns instance variable resolver is ignored and only the object s resolver is used to resolve an open method. \nHence, the parent s instance variables are not visible to the method. The procedure obj-maker of Figure \n10 is used by both new and clone to create an object. Its most noticeable task is to create the object \ns dispatcher. Upon receiving a message OP, which is an operation, an object s dispatcher searches the \nopen methods in its cell. If one ia found, it is passed along with the object itself to the success continuation \nsk, which handles the rest of a method call. Once an open method is located for a message, we apply the \ninst ante variable re\u00ad solver of the handler object, the object in which the open method is found, to \nyield the final effective method. The effective method is then called with the actual arguments. The \nprocedure send of Figure 10 is an abstraction of such a process. define new (lambda (tenqdate parent \n. ivak) (let ((7nceU (mk-ceU built-in-methods)) (ivars (mk-ivars template iuals parent))) (obj-maker \nivars parent nwell template)))) define add-method (qa-lambdaO (self op method) (let ((rnceU (obfimcell \nse~))) (cell-set! mcell (cons (cons op method) (cell-ref mceil)))))) define clone (qs-lambdaO (self . \nivals) (let ((parent (ob~parent se2f)) (template (obfitemplate m#)) (mcell (obj-wncell se2j))) (let \n((iuars (mk-iuars template iuah parent))) (obj-rnaker ivars parent mcell template))))) define built-in-methods \n(list (cons add-method add-method) (con3 clone clone))) define mk-ivars (lambda (template ivah parent) \n(let ((ivars (apply template ivals))) (lambda (method) ((ob>ivars parent) (ivars method)))))) :define \nobj-maker (lambda (ivars parent mce12 template) (let ((parent-dispatcher (obfidispatcher parent))) (letrec \n((obj (mk-obj (lambda (op sk jk) (cond ((assg op (cehej mceil)) => (lambda (P) (sk (cdr p) obj))) (else \n(parent-dispatcher op sk jk)))) ivars parent mcell template))) obj)))) ldefine send (lambda (receiver \nop . args) ((obfidispatcher receiver) op (lambda (method handier) (apply (resolve-method receiver handler \nmethod) receiver args)) (lambda () (method-call-error op))))) :define resolve-method (lambda (receiver \nhandler method) ((obj+ivars handler) method))) Figure 10: A simple object system. (define base-object \n(mk-obj (lambda (OP sk j%) (jk)) (lambda (z) z) no-parent (ink-cell ()) (lambda args (ink-resolver)))) \nFigure 11: The base object. (define cartesian-distance (qa-larnbdaO ((z X) (Y Y)) (~eu) (Sgrt (+ (* z \nz) (* y y))))) (define manhattan-distance (qa-lambdaO ((z X) (y Y)) (seZf) (+x Y))) (define cpl (new \n(lambda (z y) (ink-resolver (.X) (y Y))) base-object 3 4)) (define cp2 (send cpl clone 1 2)) (send cp2 \nadd-method distance cartesian-distance) (define mp (new (lambda args (ink-resolver)) cpl )) (send mp \nadd-method distance manhattan-distance) Figure 12: Cartesian and Manhattan points. On the other hand, \nif an object cannot handle a given message, it is delegated to the object s parent. Eventually, if no \nobject in the inheritance chain is able to respond to the message, the dispatcher of the ultimate parent \nobject, base-object of Figure 11, is used to activate the failure con\u00adtinuation E. The procedure resolve-method \nused in send implements early binding for the inst ante variables. That is, the effec\u00adtive method assumes \nits instance variables from the handler object. The following alternative implements late binding in \nwhich the effective method gets its inetance variables from the receiver object, the object initially \nreceiving the message of a method call. (define resolve-method (lambda (wceiver handler method) ((obj+ivars \nreceiver) method))) Finally, we uee the example in Figure 12 to demonstrate incremental method addition \nand inst ante variable inher\u00aditance at work. Firet we define two open methods cartesian\u00addistance and \nmanhattan-distance that both reference in\u00adstance variables X and Y. The former computes the Carte\u00adsian \ndistance of a two-dimensional point tlom the origin, whereas the Iat t er comput ee the Manhattan dist \nante. Next, we use new to define a two-dimensional point object cpl whose coordinates are (3, 4). The \nobject has no parent ob\u00adject. It has two instance variables called X and Y exter\u00ad nally, as defined \nby the instance variable template (lambda (z y) (ink-resolver (z X) (y Y))). When this object is created \nit has no other methods beeides the two built-ins add-method and clone. We invoke the latter to create \na clone cp~ of cpl. Next, we add the cartesian-distance open method to cp,??. Since both cpl and cp2 \nshare the same open method cell, cartesian-distance is available to cpl as well. Then, we decide to view \ncpl as a Manhattan point object. Hence, we define an object mp that inherits from cpl. This new object \ninherits all the methods and instance variables of cpl. But the carteaian-distance method is inappropriate \nfor mp. Thus, we add a new method manhattan-didance to mp, shadowing the version associated with cpI. \nSO, invok\u00ading the distance method on mp uses manhattan-distance to operate on the instance variables \nof cpl, showing the effect of instance variable inheritance. 4 Formal Semantics We present in Figure \n13 a denotationrd description of a simplified Scheme wit h quasi-static scoping. Besides qs-Iambda and \nresolvel, we also include variable reference, variable assignment, and procedure invocation. In order \nto simplify the present ation, we only describe single-argument procedures. Furthermore, we treat an \nordinary Scheme pro\u00adcedure se a quasi-static procedure with no quasi-static for\u00admal parameters. That \nis, in this section (lambda (z) e) is considered equivalent to (qa-lambdaO () (z) e), which in turn is \nequivalent to (qs-lambda () () (z) e). 4.1 Finite Functions We summarize the finite function definitions \nemployed in the semantics. Let f : A * B denote a finite function from A to B. We write b/a G f if f(a) \n= b and represent f by the finite set {b/a I b/a c f }. The arid finite function is denoted by 0. Let \n~:A * B, then c Dom(f) = {aEAl 3bE B, b/a~f} is the domain of f, \" Rng(f)= {b EB13a EA, b/a Ef} is the \nrange of ~. Let .f, f , f : A a B, Dorn(f) n Dona(f ) = 0, A q A, B ~B, aeA, bEB, andg:B-s+C, then \" \nf@ f = {b/a Ib/a Ef or b/a ~j } is the sum of f and f , \" f \\A = {b/a E f I a $1A } is the domain omission \nof f over A , \" f\\\\B = {b/a E f [ b @B ) is the mnge omission of f over B , b f[b/al = (f\\{a}) @ {b/a} \nis the ezterwion of f with a mapped to b, \" f[f l = (f\\Dom U )) @ / is the e~ten~ion of ~ with $ , \" \ngo f = {c/a I b/a c f, cjb c g} is the composition of f and 9. The operation e is commutative and associative; \nthe operation o is associative; the operations [], \\, and \\\\ are left associative. The descending precedence \norder is [], \\, \\\\, o, and@. 4.2 Evaluation Function In addition to an expression e, the evaluation \nfunction [] takes three more arguments w, p, and u, each of which is a finite function. The link u maps \nvariables (internal names) to external names. It records the quasi-static variables de\u00adclared in the \nenclosing context of e. The environment p maps variables to locations. It defines the resolved vsri\u00adables, \nboth static and quaai-st atic, that are accessible to e. Not shown in the semantic clauses for variable \nreference, assignment, and quasi-static variable resolution M that the variable in question must be defined \nin the environment: z E Dom (p). The domains of w and p are not necessar\u00ad ily diejoint. A variable that \nis defined in both w and p is a quasi-static variable that has been resolved prior to the evaluation \nof e. The store a maps locations to values. It is included here to model variable assignments. A quasi-static \nprocedure is denoted by a triple (c, u~, pr) of a piece of code, a link, and an environment. The link \nw= specifies the procedure s unresolved quasi-static formals. The environment p, defines the procedure \ns ~esolved quasi\u00adstatic formals. The domains of p, and UU are always disjoint, since a quasi-static formal \nparameter M either resolved or unresolved. The code c is the denotation of the procedure s body parameteriaed \nover the resolved quasi-static formals, as well as the value of the procedure s static formal param\u00adeter. \nWhen a procedure (c, w-, P*) is invoked, the p, com\u00adponent, which defines the resolved quasi-static formals, \nis passed to c. The link w., however, is discarded, since any unresolved quaei-st atic formals are no \nlonger resolvable in the body. See the procedure invocation clause in Figure 13. 4.2.1 Resolving an External \nName Let the expression e in the evaluation of a resolvel expres\u00adsion [(reaolvel z Q e)] u p a denote \nthe quaai-st atic procedure (c, w-, p,). Then, in the resulting quaai-st atic procedure, the quaei-st \natic formals in w= that are aesoeiated with the external name Q are resolved to the location (p z). The \nlink w. is compmaed with the func\u00adtion {(p z)/Q}, yielding {(p z)/Q}owti = {(p z)/y I Q/g wit}. The result \nis a finite function from variables to 10CW tions, i.e., an environment. This environment defines the \nquasi-static formals in WU that are resolved by {(p z)/Q}. It is combined with the environment pr to \nform the new pro\u00adcedure s environment component, {(p z )/Q} ow~ @ p,. Siice the resolved quasi-static \nformals are now associated with lo\u00adcations, they should be removed from the link. Hence, the Lbstract \nSyntax: Z,g, z : Var (Internal Names or Variables) Nam (External Names) Q: e: Exp (Expressions) e ::= \nz I(set! z e) I(e e) I(resolvel z Q e) I (qa-larnbda ((~, z1) (vm z~)) ((z~ Q,) ~(~k QJ) (z) e) lemantic \nDomains: 1 : Loc (Locations) : Env = Var w Loc (Environments) %: Inh = Var -Var (Inheritors) P w: Lnk \n= Var -e-i Nam (Links) u: Sto = Loc * Val (Stores) c: Cod = Vrd -Env ~ Sto ---i (Vsl x Sto) (Codes) Proc \n= Cod x Lnk x Env (Procedures) v: Val=Proc +... (Values) Evaluation Function [ ] : Exp ~ Lnk ~ Env ~ \nSto ~ (Val x Sto) [Z]w pa = ((a(pZ )), o-) [(set! z e)] wpa = let (v, a ) = [e]w pa in (v, (a [v/(pZ)])) \n [(eP e=)] w p a = let ((c, WU,P,), u ) = [eP] w PO in let (v, u ) = [e=] wpu in II cvpFu [(resolvel \nz Q e)] wpa = let((c, wu, p.), u ) = [enwpu in [(lambda (z) e)] w p a = let w~ = w\\{z}, p~ = p\\{z} in \n ((( AvP;u . [ellwd((P; @ Pj)[~/z])(a [v/q)), %,0), u) where 1 @ Dona(u ) [(q-larnbdao ((zi Q,)... (zk \nQ,)) (z) e)] w p ~ = let w. = {Q,/zl,... , Qk/Zk} in let wd = fJ\\{z}[41 Pf = p\\ Dorn(wU)\\{z} in (((~wd.u \n. [e]wd ((p; @ P~)[i/Z]) (u [v/q)), ww 0), a) where t # Dom(u ) [(q-lambda ((y, z,)... (V= zm)) ((zl \nQ~) - (zk Qk)) (z) e)]upu = let W.= {Q,/zl, ..-,Qk/zk}, 7r = {ZI/yl, ..., z_/vm} in let wx = Wor% p,= \npoz in let w . = wT\\Dom(pr) @we, wd = w\\{z}[wir @ w.], = p\\Dom (x)\\Dom (wo)\\{z} in ((fiup;~ o[e] d ((P;@ \nPj)[~/z]) (u [vM)))WU,p,),u) where 1 ~ Dom (o ) Figure 13: Denot ationsl semantics of Scheme with quasi-static \nscoping. new procedure s link component is ua\\\\{Q} = {Q /z E WV I as follows: Q % Q}. Thus, ~ the resulting \ntriple, the domains of the link and the environment remain disjoint. The code c, how\u00adever> is carried \nover to the new procedure unchanged. Hence, the two procedures share the same piece of code but oper\u00adate \non different sets of bindings for the quasi-static formal parameters. 4.2.2 Deriving Qs-lambda We develop \nthe meaning of a qa-lambda expression in three stages. First we describe lambda, which is qa-larnbda \nwit bout quasi-static formal parameters. In the second stage we generalize lambda to qa-lambdaO, which \nhas quasi\u00adstatic formal parameters but no lexical inheritance of quasi\u00adstatic variables. Finally we include \nquaai-st atic variable in\u00adheritance to get qs-lambda. See Figure 13 in which, for ex\u00adplication purposes, \nwe also include the clauses for lambda and qs-lambdaO. The meaning of a lambda expression ~(lambda (z) \ne)] w p u is defined as follows: kt (#d = w\\{z}, = p\\{z} in ((8V;u c[e] d((p; ~Pt)[~/z])(@ [v/~] )), \n% 0), u) where 1 @ Dorn(a ) Since there are no quasi-static formals, the resulting triple s link and \nenvironment components are both arid. The quasi\u00adstatic variables ~eclared in the enclosing context of \nthe body expression e are Ud = w\\{z}. They are the ones declared in the enclosing context of the lambda \nexpression that are not shadowed by the static formal parameter z. The resolved @ variables, both static \nand quaai-static, visible to the body expression e prior to the evaluation of the lambda expression are \ndefined by the environment pf = p\\{z}. It is the procedure s evaluation time environment p but with the \nstatic formal parameter z omitted. The resolved free variables visible to e during its evaluation are \nthe variables defined in p,, the resolved quasi-static formal parameters of p:, and a fresh binding of \nthe static formal parameter z: (P: e P,)[W But when the code is invoked, the parameter p: is certain \nto be associated with 9, since a lambda expres~on has no quasi-static formals. Also, by the definition \nof finite function extension, (p\\{z})[l/z]) is equivalent to p[z/z]. Therefore, the triple s code is \nequivalent to (Avp~c . [e](w\\{z}) (p[l/z]) (a [v/2])) which, except for the extra link w\\{z} and the \nignored pa\u00adrameter p:, is what we have for a procedure in Scheme. Next we define the meaning of a qa-lambdaO \nexpression [(w-1-bdao ((zi Q,) o. (zh Q,)) (z) e)] w PU let w= = {Q1/ZI,... ,Qk/Zk} in k?t Wd= (J\\{z}[wu], \nPj = p\\Dom (w=)\\ {z} in (((AuP;u -[e] d((P; @ Pt)[l/z]) (du/~])), w-, 0), u) where 1 @ Dom (u .) The \nresulting triple s link component WU specifies the unre\u00adsolved quasi-static formals Z1, ..., Zk. Since \nthere M no lex\u00adical inheritance, the triple s environment component is and. The code component is the \nsame as that of a lambda ex\u00adpression, except that Wd and P, take on different meanings. The link w~ = \nw\\{z}[w=] captures the quasi-static variables declared with respe&#38; to-the body expression e. It consists \nof the most recently specified ones and the ones declared in the enclosing context of the qa-lambdaO \nexpression that are not shadowed by the static formal parameter. The re\u00adsolved free variables available \nto the body expression when the qa-lambdaO expression is evaluated are defined by the environment p, \n= p\\Dom (wti)\\{z}. They are the ones re\u00adsolved before the evaluation of the qa-lambdaO expression that \nare not shadowed by the newly specified quasi-static variables or the static formal parameter. In order \nto verify that lambda is a degenerate case of qa-lambdaO, we need only replace W= by $. Then, let + be \n((g, z,).,. (ym z-)) and # be ((z, Q,)... (zk Qk)), we define the meaning of a qa-lambda expression [(w-l~bda \n# d (z) e)] w p u as follows: let w 0 = {Q1/ZI, . . . ,Qk/zk), K = {ZI/W,..., Zm/Ym} in let WT = We%, \n= por in let WV = wx\\Dom(pr) @ wO, P, wd = w\\{z}[wx @wOJ, = p\\Dom (r)\\Dom (wa)\\{z} in ((fivPY $[d QJ~((P; \n@ Pjwl) (d~/~l))!WV,P,)) 4 where 1 @ Dom(u ) This yields a quaei-st atic procedure (c, WU, p,) whose \ncom\u00adponents are defined in detail below. The syntax @ denotes the inheritor finite function m = , Zm/vm} \nand the syntax ~ denotes the ~k WO = {21/2/,,... {Qi/zl, . . . . Qk/zk}. Not shown in the semantic clause \nis that the inherited quasi-static variables Z1, ..., z~ must be declared in the enclosing context. That \nis, it is a synt u error unless Rng (r) ~ Dom (w). The inheriting quasi-static for\u00admale yl, ..., Vm have \nthe same external names as zi, ..., z~, respectively. Hence, their link is wm = w oz = {Q/~ I z/y G ~; \nQ/z G w}-The inherited quasi-static variables that have been resolved prior to the qa-lambda expression \ns evaluw tion are defined in p. So, the environment of the resolved inheriting quaei-st atic formals \nis P. = POr = {l/g I z/v G z, l/z c p}, which is the third component of the result\u00ading triple. Consequently, \nthe link of the unresolved inher\u00aditing quasi-static formals is wx\\Dom (pr). The link com\u00adponent Ww of \nthe procedure s unresolved quasi-static formal parameters is therefore w. (B w% \\Dom (P. ), the sum of \nw. and w~\\Dom (pK). The procedure s code component is the same as that of qs-lambdaO, except for the \ndifFerent interpretations of w~ and p,. The link w,f of the declared quasi-static variables that are \nvisible to e is w\\{z}[wr @ wO]. They are the vsri\u00adables specified by the procedure and the variables \ndeclared in the enclosing context that are not shadowed by the static formal parameter. The parameter \np: is the procedure s re\u00adsolved quasi-static formals p. when the code is invoked. The environment p, \nof the resolved free variables known to the body expression prior to the qs-lambda expression s eval\u00aduation \nis p\\Dom (x)\\Dom (wo)\\{z}. It is the variables de\u00adfined in p that are not shadowed by the inheriting \nqussi\u00adstatic formals VI, . . . . ym, the quasi-static formals Z1, . . . . z~, or the static formal parameter \nz. Again, by substituting 0 for r, it is straightforward to verify that qs-lambdaO is a degenerate case \nof qs-lambda. 5 Implementation We describe an implementation of quasi-static scoping. It includes the \nrepresentation of quasi-static procedures, the run-time support for procedure invocations and quasi-static \nvariable references, and the quasi-static variable resolution operation. Since we have designed quasi-static \nscoping to be as orthogonal to Scheme se possible, we have also made its implementation as independent \nof Scheme implementations as possible. We represent a quasi-static closure (procedure) (qs-lambda ((iql \nOgl) . . . (Xg_ o%)) ((91 QI) . . . (!lk Qk)) (1) formals body) by a fime of I+rn+k+h consecutive memory \nslots arranged as follows: (c)s,,..., %n,am+l,. ... am+k>f l,.. ., fh) (2) The first slot c is the location \nof a static C20SWWrepresent\u00ading the ordinary Scheme procedure (lambda formals body), Each of the next \nm + k slots contains either a location or an external name. The first m slots are for the inheriting \nquasi-static formals iql, . . .. iqm. The next k slots are for the local quasi-static forma.k ql , . \n. .. qk. The last h slots fl,... ! ~h are locations of the enclosing frames. They are the display [6] \nof the procedure s free quasi-static variable references. We discuss how the slots are filled later. \nThe values of m and k are readily available horn the syntax of the qs-lambda expression itself. The value \nof h depends on the syntactic context of the qs-lambda exprew aion. It is the number of enclosing qs-lambda \nexpressions. Hence, each frame s shape can be determined statically. Every static closure contains a \npointer to a frame through which the procedure s body gains access to the quasi-static variables visible \nto it. For a static closure created by a lambda expression, this frame is the most recently acti\u00advated \none when the closure ia built. For a static closure constructed by a qs-lambda expression, it is the \nnewly cre\u00adated frame. That is, a frame s static closure points back circularly to the frame itself. This \ncircularity is justifiable since, when a frame is invoked, the accessible quasi-static variables are \ndefined in the tiame. The additional run-time support then consists of a single register called the Frame \nPointer register (FP) that points to the most recently activated frame. Context switching is simple. \nThe activation record of each procedure invocation maintains the caller s FP value. Returning from a \nprocedure invocation simply reinstalls FP to that value. Invoking a procedure, static or quasi-static, \nrequires only saving the current value of FP in the newly created activation record before adjusting \nit to point to the callee s frame. In case the call is in tail position, however, the callee s activation \nrecord assumes the same FP value as that of the caller s. We next explain how a quasi-static variable \nreference is achieved. We assign to each quasi-static variable ref\u00aderence occurrence a pair of statically \ndetermined numbers (d, i) called the lezicul address. The number d ~ O is the depth between a reference \noccurrence and its binding occur\u00adrence, i.e., the number of qs-lambda expressions between the two occurrences. \nThe other number i is the binding oc\u00adcurrence s slot index in its frame. Using the notation [~ to denote \nthe contents of the location 1, the value of a sero\u00addepth reference occurrence, (O, i), is denoted by \n[[[FP] + ii]. The current frame s location is denoted by [FP]. Adding the index i to it, ~P] + i, gives \nus the location of the quasi\u00adstatic variable s dot. Dereferencing it, [~P] + i], yields the cent ents \noft he quaai-st atic variable s slot. If it cent sins a lo\u00adcation, dereferencing it, [[[FP] + i]], returns \nthe quaai-st atic variable s value. Otherwise, since an external name is not a location, an attempt to \ndereference it raises an unbound variable error. The value of a reference occurrence with a lexical address \nof (d, i), where d ~ 1, requires one more level of indirection. It is denoted by [[[[FP] + t] + fl] where \nthe statically deter\u00admined number t is d+ m+ k, with m+ k being the number of quasi-static formals in \nthe current frame. Hence [~P] + t] denotes the frame in which the binding occurrence s slot re\u00adsides. \nBesides this extra indirection, the rest is the same as a zero-depth reference. The two kinds of quasi-static \nvariable references described above both refer to the variable s r-value. The l-values, which are needed \nlater, can be obtained as in the r-value cases except for the last dereferencing. That is, [~P] + i] \nif the reference occurrence s depth is sero and [[~P] + t] + il otherwise. There are two ways to create \na new quasi-static frame. First is the evaluation of a qs-lambda expression of (1) that yields a frame \nof (2). The location c of the static closure iille the first slot. The next m slots are filled with the \nl-values of the inherited quasi-at atic variables Ogl, . . .. Oqm, because iqi inherits the location \nor external name (not value) of Ogi. Since qi, . . .. q~ are unresolved, their slots are filled with \nthe external names Q1, . . .. Q&#38;, respectively. That is, s~+~ = Q; fori=l ,..., k. The display s \nframe pointers fl,..., ~h get their values from the current frame pointed to by FP. The frame pointer \nfl points to the closest frame when the new frame is invoked (i. e., ~P]). The other frame pointers f2,..., \nfh are the display of the current frame. Siice the current frame s shape is known at compilation, its \nslot in\u00addices are known. Therefore it is straightforward to generate the code needed to copy the display. \nWe can apply two compile-time optimisations at this stage. First, the frame need not allocate a slot \nfor any of the quasi-static formals iql, . . .. iqm or ql, . . .. qh that is not referenced in the body. \nSecond, the display need only in\u00adclude the frames that are actually needed in the body. That is, if none \nof the quasi-static variables of an outer frame is referenced in the body, it can be excluded from the \ndisplay. The other way to create a new frame is by evaluating a resolve expression (resolve ((zi Q,) \n. . . (z= Q=)) qs-proc) First we check that the variables z1, . . .. z~ are resolved, i.e., associated \nwith locations. For each zi that is a quasi-static variable, we must make sure that its l-value is a \nlocation, not an external name. Furthermore, the expression qs-proc must evaluate to a frame (C, s,,... \nsam+k,fl,. --tfh) Let 1~ be the location associated with the variable zi. Then the resolve expression \nreturns a new frame (c, s;,..., s~+k, fi, fh), fh) where for i = 1,.. .,m+k, lj ifsi~Qj forsomen>j>l \na; = 8; otherwise. { That is, each slot Si is compared against the external names Q1 , . . .. Q=. If \nthere is a match with Qj, the corresponding slot s: is the location lj. Otherwise, s~ is either a location \nor a different external name. Hence, s; is the same as si. We should point out that without sufficient \ndataflow in\u00adformation, each lexical variable z; must be assumed to be assignable. As a result, optirnisations \nperformed by many Scheme compilers on a lexical variable that is free of side\u00adeffects are not applicable \nto zi. Finally we sketch a simple variation of the implemen\u00adtation presented above. The purpoee of a \nframe s display is to gain access to the slots of the procedure s free quaei\u00adstatic variables. Hence, \ninstead of copying a sequence of frame pointers, we could copy down the slots of the free quasi-static \nvariables. The result is reminiscent of the way Cardelli s Functional Abstract Machine [3] handles a \npro\u00adcedure s free lexical variable references. It would require potentially more time and space to build \na frame. On the other hand, it reduces every quasi-static variable reference s lexical address to a depth \nof zero. Hence, it speeds up free quasi-static variable referencing. 6 Comparisons and Future Work We \naccomplish variable sharing across lexical scopes with re\u00adsolvers that selectively export variable bindings \nand quasi\u00adstatic procedures that selectively %nport variable bin\u00addings. Resolvers are run-time linking \noperators and quasi\u00adstatic procedures are compiled but only partially linked pro\u00adgrams. MIT Scheme s \nfirst-class environments [1, 12] resemble our resolvers. They dWer from our quasi-static scoping in four \naspects. Fust, there is no mechanism like resolve that can export variables selectively. Consequently, \nin the presence of first-class environments, optimisation techniques such se constant folding that involve \neliminating variables are no longer meaning preserving transformations. Second, first-class environments \nrely on the internal names of vari\u00adables. Hence, a-conversion is invalid on some variables. This imposes \na serious problem on macro systems since generated variable names could cause inadvertent capturing. \nThird, eual, the user-accessible interpreter, compiles source code at run time and the same piece of \nsource code is compiled as many times as it is used. Thus, the performance is inferior to our approach \nin which each piece of source is compiled only once. Fourth, environment is a notion that is not employed \nby every computational model. Thus, adding first-class en\u00advironments to a language means that the language \ncannot be implemented easily on some environment-less archkcctures such se the G-machine [16]. Jagannathan \ns environment\u00adbaeed reflection language Rascal [9] is another language with first-class environments. \nRascal provides a way to identify reifiable (export able) variables; however, it still suffers from the \nfirst two disadvantages mentioned above, because some non-reifiable variables are dynamically bound. \nLamping s uniiied system of parameterisation [10] em\u00adphasises the other part of our approach. It uses \na special form data to identify non-lexical variables. But instead of providing an explicit resolution \noperation like resolve, it always uses the run-time dynamic environment to resolve the non-lexical variables. \nThey are therefore truly dynamic variables. Consequently, programs are harder to analyze and the language \nis diflicult to implement efficiently. Quasi-static scoping can be characterised as a mechw nism for \nrun-time linking as opposed to the compile-time linking provided by other systems. It is just one point \nin the spectrum of linking disciplines ranging fkom static (compile\u00adtime) to dynamic (run-time). We are \nconvinced that in a programming environment various linking disciplines are necessary for diferent purposes. \nOur goal is therefore to investigate if there exists a small set of linking disciplines that will suffice \nfor all needs. If not, we would like to es\u00adtablish a metric for measuring the degree of statieity, or \nequivalently dynarnicit y, in order to classify all the possi\u00adble disciplines. We are currently exploring \nvarious ways of speeding up the resolution process. For instance, we can assign types to both resolvers \nand quaai-static procedures and initiate the resolution process only if their types match. Then, run-time \nexternal name matching would be eliminated. Finally, for reasoning about quasi-static scoping, we have \ndeveloped a calculus that is consistent and has a standard\u00adization procedure. The calculus is an extension \nof Felleiaen and Hieb s calculus of sequential state [8], which in turn is an extension of Plotkin s \ncall-by-value .X-calculus [1 7]. Wc will continue its development into a more complete logical system \nand report it elsewhere. Acknowledgements. We are grateful for the insightful comments by Kent Dybvig, \nChris Haynes, and the late Bob Hieb during the early stages of this research. We would also like to thank \nMike Ashley, Matthias Felleisen, Julia Lawali, Jon Rossie, and John Simmons for their comments on earlier \ndrafts of this paper. References [1] H. Abelson and G. J. Sussman with J. Sussman. Struc\u00adture and Interpretation \nof Computer Programs. MIT Press, 1985. [2] N. Adams and J. Rees. Object-oriented programming in Scheme. \nIn Proceedings of the A CM Conference on Lisp and Fictional Progmmming, pages 277-288, 1988. [3] L. Cardelli. \nCompiling a functional language. In Pro\u00adceedings of the ACM Conference on Lisp and Functional Progmmming, \npages 208-217, 1984. [4] W. Clinger and J. Rees (editors). Reviaed4 report on the algorithmic language \nScheme. Lisp Pointers, 4(3):1-55, 1991. [5] P. Curtis and J. Rauen. A module system for Scheme. In Proceedings \nof the ACM Conference,, on Lisp and Fictional Programming, pages 13-19, 1990. [6] E. W. Dijkstra. Algol \n60 translation. Supplement AL-GOL Bulletin 10, 1960. [7] M. Felleisen and D. P. Friedman. A closer look \nat ex\u00adport and import statements. .loumal of Computer Lan\u00adguages, 11(1):29-37, 1986. [8] M. Felkisen \nand R. Hieb. The revised report on the synt aetic theories of sequential control and state. Z%e\u00adoretical \nComputer Science, 102:235-271, 1992. [9] S. Jagannathan. Reflective building blocks for modu\u00adlar systems. \nTo appear in the IMSA 92 International Workshop on Reflection and Mets-Level Architecture. [10] J. O. \nLamping. A unitied system of parameters+ tion for programming languages. In Proceedings of the ACM Conference \non Lisp and Functional Pmgrumming, pages 316-326, 1988. [11] K. J. Lang and B. A. Pearhnutter. Oaldisp: \nAn object\u00adoriented dkdect of Scheme. Lisp and Symbolic Compu\u00adtation, 1(1):39-51, 1988. [12] J. S. Miller \nand G. J. Rosas. Free variables and first\u00adclaas environments. Lisp and Symbolic Computation, 4(2):107 \n141, 1991. [13] R. Milner, M. Tofte, and R. Harper. The Definition of Standard ML. MIT Press, 1990. [14] \nJ. H. Morris Jr. Protection in programming languages. CACM, 16(8):15-21, 1973. [15] K. N@rmark. Simulation \nof object-oriented concepts and mechanisms in Scheme. Technical Report R 90\u00ad01, Institute of Electronic \nSystems, Aalborg University, January 1990. [16] S. L. Peyton Jones. The Implementation of Fictional Programming \nLanguages. Prentice Hall, 1987. [17] G. D. Plotkin. Call-by-name, call-by-value and the ~-czdculus. Theoretical \nComputer Science, 1:125 159, 1975. [18] G. L. Steele Jr. Common Lisp: The Language. Digital Press, second \nedition, 1990.   \n\t\t\t", "proc_id": "158511", "abstract": "<p>Static scoping embodies a strong encapsulation mechanism for hiding the details of program units. Yet, it does not allow the sharing of variable bindings (locations) across independent program units. Facilities such as module and object systems that require cross references of variables therefore must be added as special features. In this paper we present an alternative: quasi-static scoping. Quasi-static scoping is more flexible than static scoping, but has the same encapsulation mechanism. The user can control when and in what scope to resolve a quasi-static variable, i.e., to associate it with a variable binding. To demonstrate its versatility, we add quasi-static scoping to Scheme and show how to build the aforementioned facilities at the user-level. We also show that quasi-static scoping can be implemented efficiently.</p>", "authors": [{"name": "Shinn-Der Lee", "author_profile_id": "81545145456", "affiliation": "", "person_id": "PP311214300", "email_address": "", "orcid_id": ""}, {"name": "Daniel P. Friedman", "author_profile_id": "81100636522", "affiliation": "", "person_id": "PP39051860", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158706", "year": "1993", "article_id": "158706", "conference": "POPL", "title": "Quasi-static scoping: sharing variable bindings across multiple lexical scopes", "url": "http://dl.acm.org/citation.cfm?id=158706"}