{"article_publication_date": "03-01-1993", "fulltext": "\n ON THE ORTHOGONALITY OF ASSIGNMENTS AND PROCEDURES IN ALGOL Stephen Weeks* Matthias Felleisen~ Department \nof Computer Science Rice University Houston, TX 77251-1892 Abstract According to folklore, Algol is an \northogonal ex\u00adtension of a simple imperative programming lan\u00adguage with a call-by-name functional language. \nThe former cent ains assignments, branching con\u00adstructs, and compound statements; the latter is based \non the typed ,X-calculus. In an attempt to formalize the claim of orthogonality , we define a simple \nversion of Algol and an extended A-calculus. The calculus includes the full /!I-rule and rules for the \nreduction of assignment statements and com\u00admands. It has the usual properties, e.g., it satisfies a Church-Rosser \nand Strong Normalization The\u00adorem. In support of the claim that the impera\u00adtive and functional components \nare orthogonal to each other, we show that the proofs of these the\u00adorems are combinations of separate \nChurch-Rosser and Strong Normalization theorems for each sub\u00adlanguage. An acclaimed consequence of Algol \ns orthogonal design is the idea that the evaluation of a program has two distinct phases. The first phase \ncorre\u00adsponds to an unrolling of the program according to the usual /3 and fixpoint reductions, which \npro\u00advide the formal counterpart to Algol s famous copy rule. The result of this phase is essentially \nan im\u00adperative program. The second phase executes the output of the first phase in the imperative fashion \n*New address: Carnegie Mellon University, School of Computer Science, Pittsburgh, PA 15213-3891 f Both \nauthors were supported in part by NSF grants CCR 89-17022 and CCR 91-22518. Permission to copy without \nfee all or part of this material is granted provided that the copies are not made or distributed for \ndirect commercial advantage, the ACM copyright notice and the title of the publication and its dete appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. ACM-20th PoPL-1 /93-S. C., USA \nQ 1993 ACM 0-89791 -561 -5/93 /000110057 . ..+1 .50 of a stack machine. Given our calculus, we can prove \na Postponement Theorem and can thus for\u00admalize this phase separation. 1 The Origins of Algol According \nto folklore, Algol 60 orthogonally ex\u00adtends a simple imperative programming language with a typed A-calculus. \nThe underlying impera\u00adtive language usually consists of assignment state\u00adments, branching statements, \nloops, and state\u00adment sequences for computing basic arithmetic al\u00adgorithms. The typed A-calculus adds \nrecursive, higher-order procedures, which provide the power to abstract over algorithms in the command \nlan\u00adguage. In his most recent description of Forsythe, a successor to Algol, Reynolds expounds this view, \nwhich he says is implicit in Algol 60, underlies Forsythe and distinguishes it from such languages as \nAlgol 68, Scheme, and ML: The pro\u00adgramming language is a typed lambda cal\u00adculus with a primitive type \ncomm, such that terms of this type, when reduced to normal form, are programs in the simple imperative \nlanguage. [17:3] Moreover, he reiterates the common belief that as a result of this design, a Forsythe \nprogram is executed in two phases. First the pro\u00adgram is reduced to normal form. (In Al\u00adgol jargon, the \ncopy rule is repeatedly ap\u00adplied to eliminate procedure calls.) Then the resulting simple imperative \nprogram is executed. [17:3] Given the recent interest in integrating varia\u00adtions of assignment statements \ninto functional pro\u00adgramming languages in a controlled manner and in the design of simple logics for \nsuch mixed lan\u00adguages [2, 9, 10, 12, 13, 16, 21], these folklore claims about Algol s design clearly \ndeserve a rigorous anal\u00adysis. On one hand, such an analysis will enhance our understanding of the role \nof orthogonality in Algol in the same manner in which S@ndergard s and Sestoft s paper [20] clarified \nthe often misused terminology of referential transparency , and in which Felleisen s work [6] defined \nthe idea of ex\u00adpressiveness of programming languages. On the other hand, the results are a contribution \nto the construction of simple logics for mixed functional\u00adimperative programming languages and to their \nab\u00adst ract implement ation. The first step for such an analysis clearly requires the formulation of \na small Algol-like language and its A-calculus. The calculus we develop includes the jull @-rule, despite \nthe presence of assignments, and has the usual properties, i.e., Church-Rosser, Standardization, and \nStrong Normalization for the recursion-free subset. In support of the claim that the two sub-languages \nare orthogonal to each other, we show that the proofs of Church-Rosser and Strong Normalization, the \nmost interesting prop\u00aderties of the calculus, consist of two separate sub\u00adproofs, one for each sub-language, \nand a proof that the two systems mix smoothly. Most importantly, we confirm Reynolds s second conjecture \nwith a Postponement Theorem, which shows how the eval\u00aduation of a program can indeed be separated into \na functional phase followed by an imperative phase. We begin by defining the syntax, calculus, and semantics \nof a simple Algol-like language. Sec\u00adtion 2.3 addresses the basic consistency results for the calculus \nand the derived semantics. Section 3 contains the Postponement Theorem. In Section 4, we prove that Postponement \ncombined with Strong Normalization for each sub-calculus entails Strong Normalization for the complete \ncalculus. We ad\u00address the shortcomings of our dialect in the last section; we also include a brief discussion \nof related work. Note: Except for the strong-normalization theo\u00adrem, the paper does not include full \nproofs. We refer the interested reader to our technical report 92-193 (anonymous ftp: titan. cs.rice.edu \nin pub\u00adlic/languages) which contains the full proofs of the remaining theorems. 2 Idealized Algol Our \nversion of Idealized Algol (IA) is a simpli\u00adfication of Forsythe, a generalized version of Al\u00adgol 60 \n[17, 18, 19]. Specifically, the imperative sub\u00adlanguage of IA only contains an arithmetic expres\u00adsion \nlanguage for numerals and a small set of total primitive functions. The language is simply typed, and, \nfor simplicity, excludes intersection types and coercions, complex data, and non-local control op\u00aderators. \nThus, it is simple enough to permit an eas\u00adily comprehensible semantics, yet complete enough to permit \na generalization of our results to other Algol-like languages. Based on the syntactic definition in the \nfirst sub\u00adsection; we specify the semantics of the language in the second subsection via a combination \nof two reduction systems. One system describes the com\u00admand component, the other one is a simply-typed \nA-calculus. The union of the two basic reduction relations generates the calculus for the entire lan\u00adguage. \nWe then show in the final subsection that this calculus provides an adequate reasoning sys\u00adtem for the \nlanguage, i.e., it is consistent and strong enough to define a well-behaved evaluator. 2.1 Syntax and \nInformal Semantics The definition of the syntactic part of the language proceeds in two stages: the general \nsyntax of com\u00admands and expressions, and a type system for fil\u00adtering out legal commands and expressions. \nSyntax. Figure 1 specifies the set of syntactically feasible commands and expressions. The first part \nof the set of terms (above the line) constitutes the raw syntax of the imperative sub-language; the sec\u00adond \npart (below the line) is the A-calculus exten\u00adsion, including a ret-construct for declaring recur\u00adsive \nobjects (procedures and the diverging inte\u00adger ). Both Az.kf and new(x,N).J4 bind z in M; no other construct \nbinds a variable in a term. A variable occurs free in a term if it is not bound by a surrounding binding \nconstruct. A contezt is a term with a single hole , [ ], in the place of a sub\u00adterm; C[ ] denotes a context. \nThe notation L [&#38;f] refers to the result of filling the hole of the con\u00ad text C[ ] with term .34, \npossibly capturing some free variables of M. Convention 1. We adopt a number of Baren\u00adSyntax: .._ M \n.. n lop/z /(MM) arithmetic expressions where n Ez. Op G {+, ,*} C Vars [ skip I (ifO M M M) I (begin \nMM) nop, bra~ching, sequencing I new(x,M).M block I (deref M) I (setref! MM) dereferencing, assignment \nI Az.M I (ret M) (recursive) procedures Type System: Constants References r D M : int, ~[z/int refl \nB N :< n P n : int T D new(z,M).N :< rDM:intref T b op : int+int+int r D (deref M) : int ?rDJf:int ref, \nrDN:int  Variables ir D (setref! M N) : comm  z E dom(n) Simple Commands &#38; Expressions7rbz:7r(z) \n Functions r D skip : comm ~D~:int, rDM:o, ~D N:o m[z/r] D M :r mp(ifOLNN):o rDkf:comm, mDN:o T D (begin \nM N) :0 TD(MN):T FIGURE 1: Syntax and Type Inference System for IA dregt s [1] A-calculus conventions \nfor IA. Specifi-terms into a sub-language of commands (of comm) cally, we identify terms that are equivalent \nmod-and expressions. It is an adaptation of the type U1O change of bound variables and use ill s N system \nfor Forsythe [19], to denote this equivalence. The sets of free and bound variables in distinct terms \ndo not interfere with each other in definitions and theorems. Con-An expression in the imperative sub-language \ntexts are not subject to this convention. D may either be of ground type (o) or of a first-order arithmetic \nfunction type (o ~ o) and o ~ (o ~ o). For example, n is of type o and (+ l ) is of Types, Legal Syntax. \nThe type system filters type o ~ o. A command in the imperative sub\u00adlegal from illegal terms and separates \nthe set of language is a term of type comm whose (maximal) sub-expressions are of ground type, e.g., \n(begin skip ((+ l ) 3 )) is a command in the imperative sub-language while (begin skip (+ 1 )) is not. \nLike Algol and Fors yt he, IA restricts ref\u00aderences to cent tin only basic data values (int s). Thus, \nnew(x,rO ).(setref! z ((+ (deref z)) (deref z))) is a block of type command. The extension of the imperative \nsub-language to IA is accomplished by relaxing the constraint on expression types. The full language \nadmits ex\u00adpressions of type ~-m for arbitrary types ~, e.g., int~int~comm is a permissible type now. \nThe sys\u00adtem does not lift the restriction that the result of new-blocks are of ground type. For the formal \nspecification of type system, we begin with a definition of the ful.llanguage of types: T .. .. 0 [ \nT+2\u00ad 0 .. .. comm \\ int I int ref c .. .. comm I int The type inference system is defined by a set \nof in\u00adference rules, whose basic components are typings. A typing, T D Ikf : r consists of a type assign\u00adment, \nm, an expression, Al, and a type, ~. A type assignment, r, is a finite function from variables to types. \nWe use the notation r[z/~] to indicate the type assignment such that r[z/T](z) = r and m[z/r](y) = m(y), \nif y ~ z. The typing ~ b M : ~ asserts that expression ill has type ~ when the free variables in Al are \nassigned types by z. Figure 1 cent ains the inference rules for IA. While the type inference system is \na straightfor\u00adward extension of that for the simply typed A-cal\u00adculus, two apparent restrictions deserve \nsome com\u00adments. Both ifO-expressions and begin-expressions are commands as well as expressions, depending \non which ground type they are assigned. In ad\u00addition, the requirement that ifO-expressions and begin-expressions \nbe of type o is only to simplify the theory, and may be removed in practice with the following abbreviations: \n(ifOL M N) ~ A2.(ifO L (M i) (N E)) (begin MN) ~ M.(begin M (N 2)); in each case, i is a vector of variables \nof the length required to assign an appropriate ground type to the expressions (J4 F) and (N Z). Informal \nSemantics, Pragmatic. The be\u00adhavior of IA s imperative sub-language is that of an assembly language for \na stack-machine. Numerak are basic values; arithmetic expressions are evalu\u00adated as usual. Blocks allocate \na new location (ref\u00aderence) with some initial value, execute their body, and finally deallocate the location. \nThe compound and branching terms are also executed in the usual manner: the former sequences the execution \nof two terms, the latter compares the result of its first sub-expression to O and branches to the second \nif the answer is affirmative and to the third term otherwise. The informal semantics of the procedural \nlan\u00adguage is easily explained via Algol s copy rule [14]. A procedure replaces its parameters by its \nargu\u00adments (aft er renaming internal bound variables, which we implicitly assume according to Conven\u00adtion \n1). A recursive definition is unrolled as far as necessary. The sub-language of IA does not provide a \nloop\u00ad ing construct but again, this omission only simpli\u00ad fies the analysis of the theory and is no real \nobstacle to programming in IA. For example, a while loop is a simple abbreviation, based on recursive \nfunc\u00ad tions: (while MN) ~ (ret Aw.Ax.Ay. (ifO z skip (begin y ((w z) g)))) Other loops are similar abbreviations. \nThe following phrase is a simple procedure, mix\u00ading functional and imperative facilities: Aj.new(S,rO \n).new( i,j). (begin (while (deref i) do (begin (setref! S ((+ (deref S)) (deref i))) (setref! i ((-(deref \ni)) l )))) (deref S)) The procedure passes the type inference system as an expression of type int-+int, \nthat is, as a pro\u00adcedure from integers to integers. It implements a simple imperative algorithm for computing \nthe sum from zero to its parameter i. We refer to the above procedure as X!. An equivalent functional \nimplementation of Z! is the following (pure) IA phrase: (ret Asu7rt.Ai.(ifO i O ((+ i) (sum ((-i) 11))))) \n We use XA in the following sections to refer to this procedure. 2.2 Semantics and Calculus To formalize \nIA s semantics, we define an equa\u00adtional calculus.1 The definition of the basic notion of reduction for \nIA relies heavily on our experience with extended J-calculi for untyped languages with assignment stat \nements, specifically, the definition of the An-R-calculus for a call-by-name language and that of the \n&#38;B-calculus for a language with first class reference cells [2, 9]. Convention 2. We adopt Barendregt \ns [1] con\u00adventions about reduction relations and calculi. A notion of reduction, r, denotes a binary \nrelation on the set of phrases. The relation ~r, the compat\u00adible closure of r, is defined by: (Al, iV) \nC r * C[M] -r C [N] for all contexts C. The relation +: is the reflexive transitive closure of -r. The \nrelation =r is the equivalence relation generated by xr. Given two notions of reduction rl and r2, rl \nr2 denotes rl U r2. c In order to describe the rules for assignment, we must first define a set of special \ncent exts, evalu\u00adation contezts, and their associated bound refer\u00adences. The following grammar simultaneously \nde\u00adfines evaluation contexts and the corresponding set 1In contrast, Lent [1 I] defines an operational \nsemantics of an IA-like language baaed on structural operational se\u00admantics. His major concern is an \nadequacy theorem for his language with respect to a semantic model. of trapped references, TR(E): E ::= \nTR(E) 0 TR(E) 1[1 I ((WE) w I ((OP ~ ) ~) TR(E) [ new(z,E).J4 TR(E) I new(z,rnl).E {z} u TR(E) I (deref \nE) TR(E) I (setref! EM) TR(E) / (setref! z E) TR(E) I (ifO E J4 A4) TR(E) I (begin E &#38;f) TR(E) The \nhole in an evaluation context indicates the sub-expression whose assignment commands and dereferencing \nexpression maybe executed next. It is an easy induction to show that a term has a unique partitioning \ninto an evaluation context and an assignment command or dereferencing expres\u00adsion, unless it is a numeral \nor a skip. This fact guarantees the well-behavedness of the imperative part of the calculus; we call \nthis the unique parti\u00adtion property. Figure 2 defines the basic notions of reduction for IA. The first \npart (above the line) characterizes the behavior of the imperative sub-language and the second part (below \nthe line) is the usual set of reductions for the simply-typed, call-by-name A calculus with a recursion \nconstruct. The rules capture the informal semantics in an intuitive manner. Sequencing of the begin\u00adexpression \nis enforced by the structure of evalua\u00adtion contexts and the B rule. Together, these only allow non-local \nassignments in the second subex\u00adpression of a begin-expression to take place after the first subexpression \nhas been completely evalu\u00adated to a skip and removed by the B rule. Despite the presence of assignments, \nfunction applications satisfy the ful/ /3-axiom. Potential conflicts be\u00adtween assignments to and dereferences \nof the same references are eliminated by the use of ewduation cent exts due to the above-mentioned unique \npar\u00ad tition property for phrases. Thus, assignments to distinct references may proceed in parallel. For \nan example, consider the following phrase: ((+ (~! lo )) (x! 5 )) (6) (POP) (D) (a) (T) (F) (B) ((op \nn ) n-t ) new(z,rn ).v new(x,rn ).E[(deref z)] new(z,rn ).ll[( setref! z m )] (ifO 01 M N) (ifOrn+l MfV) \n(begin skip M) --+ --+ -+ n Op m v, new(z,rrt ).l?~rt l, new(z,rm ).l?[skip], M N M v E n or z @TR(E) \nz @TR(E) skip (P) (fix) ((AZ.M) (ret N) M) -4 MIIA-V] (M (ret M)) FIGURE 2: Basic Notions of Reduction \n Here all side-effects in the two distinct procedure If M is a program, then eval(ill) = n if and only \ncalls of Z! can proceed independently. The current if ia R M = n . We write evalP(M) = n when calculus \ndoes not support the permuted reduction pt-M=rn7. n of all independent assignments or dereference ex\u00ad \n pressions. 2.3 Characteristics of eval Based on the primitive notions of reduction, we To show that \nthe language IA is a deterministic,define three compound term relations. The first, well-behaved language \nlike Algol, we need to proveia, is intended to describe evaluation in the full that the evaluator is \nindeed a function, and that language IA. The second, /?fix, corresponds to the this function is only \nundefined if all reductions axioms describing the functional part of the lan\u00adstarting from the program \nare infinite. The easiest guage. The third, p, corresponds to the axioms de\u00adway to prove these results \nis via a Church-Rosser scribing the command component of the language: theorem and a subject reduction \ntheorem for types. Both results hold for the two sub-languages and ia ~ @fixup carry over to IA in a \nuniform manner. pfix ~ /3ufix We begin by proving that eval is a well-defined function. ~ 8upopu Duau \nTuFu B P Theorem 2.2 Let M be a program, let n, m ~ Z. To emphasize that the above is a calculus, we \nsome\u00ad times write rEM = N when M =r N where ris 1. If eval(M) = n and eval(M) = m then either ia, /?fix, \nor p. m=n. Given the calculus, we can define the behavior of a program in a precise manner. A program, \nwhich 2. eval(M) = n if and only if M <~~ n . must be a closed integer expression, produces a re- Proof. \nBoth parts are immediate consequences of sult if and only if it is provably equal to a numeral Theorem \n2.3. ~ The latter is the result of the program. Theorem 2.3 (Church-Rosser) If L +~~ M Definition 2.1. \n(Programs, Evaluation) A pro\u00adand L +~e N, then there exists K such that gram M is a closed expression \nof type int, i.e., M +~a K andNb~~ K. M G Z%ogrums if and only if@ D M : int. Proof. The proof consists \nof three lemmas. The first two establish the Church-Rosser property for The evaluator is a partial function \nfrom programs each subsystem, i.e. p and /3fix, separately. The to numerals: third lemma shows that the \nsubsystems merge eval : Programs ++ Numerals. smoothly. 1. The notion of reduction @fix is Church-Rosser. \nThis fact immediately follows from the Church-Rosser Theorem for simply-typed A-calculus (with ret). \nThe new syntax does not interfere with the proof. 2. The reflexive-compatible closure of p satisfies \nthe diamond property directly. Hence, by a diagram chase, the reflexive, transitive closure of ~p satisfies \nthe diamond property, and p is Church-Rosser. 3. The two reductions generated by .i3fix and p commute. \nThis is shown by defining a paral\u00adlel reduction relation ~ ~, and showing that  and ~ --pfix 1 p comm~te \n The Church-Rosser Theorem for ia follows di\u00adrectly from the three lemmas by the Hindley-Rosen Lemma \n[1:64]. I The second important property of the evaluator for IA is that it never gets stuck . That is, \nwe can show that every program either goes into an infinite loop or terminates giving a numeral. This \nresult is the subject of the following theorem.2 Theorem 2.4 (Uniform Evaluation) For all programs M, \neither M +~a n , for some n c Z, or for all N such that M -+~~ N, there exists N such that N -+-i. N \n. Proof. The result follows from two lemmas. The first (Lemma 2.5) shows that reductions preserve types, \nand hence that a program always reduces to a program. The proof of the second (Lemma 2.6) provides a \ncharacterization of cert ain normal forms, and in particular shows that a program in normal form must \nbe a numeral. ~ The first of the two auxiliary lemmas states that reductions preserve the type of programs \nand more generally of arbitrary expressions. Lemma 2.5 IfM-+i. NandTbM:T, then TDN:T. Proof. By induction \non the structure of M: The base cases are vacuously true. The inductive cases 2If IA contained integer \ndivision (or other partial prim\u00aditive functions), then the calculus ia would have to include error values \nand reductions for error values. The Uniform Evaluation Theorem would have to state that a program either \nreduces to a numeral or an error value. require an easy application of the inductive hypoth\u00adesis or a \ncareful inspection of the type of the con\u00adtractum of a redex. D The second lemma shows that a program \nin nor\u00admal form is a numeral. Lemma 2.6 If P is a program in normal form, i.e., there is no P such that \nP -+i. P , then P = n for some n CZ. Proof. We prove t he following more general lemma by induction on \nthe structure of an arbitrary ex\u00adpression N: if {(z~, int ref), . . . . (zn, int ref)} b N : r, and \nN is a normal form, then N < tl, the language described by the following grammar: t~ ::= n Iop I(op n \n) I(op tz) ]xi I Ay.M I skip I t2 tz ::= E[(deref z;)] I E[(setref! z; n )] where z; # TR(E) The specific \nresult follow by noting that a program M must satisfy @ b M : int. B Theorems 2.2 and 2.4, together with \nTheo\u00adrem 2.3, show that the calculus defines a well\u00adbehaved interpreter and that it is sound with re\u00adspect \nto program equivalences [2]. Also, the proofs of the preceding theorems and lemmas show that the functional \nand imperative sub-languages are in\u00addependent and that meta-properties follow from modularized proofs. \nIn the next section we will prove that the evaluation itself can proceed in a highly modular fashion. \n 3 Postponement As discussed in the introduction, one of Algol s de\u00adsign goals is a phase separation \nof the evaluation of programs. For IA, the first phase eliminates pro\u00adcedures and their uses by reducing \nprograms with @fix sufficiently far. The result is a mixed program whose functional components are irrelevant \nfor the rest of the evaluation. The second phase executes the imperative program according to the p-rules \nor on a regular stack machine. The following theorem makes this idea precise. Theorem 3.1 Let M be a \nprogram, let n < Z. Then, eval(ill) = n iff for some program N, --..$ rn  M-+x N Proof. The direction \nfrom right to left is trivial, the other direction is difficult. We proceed as fol\u00adlows. The first step \nis to define a parallel reduc\u00adtion relation, ~ ~, which contains -p but is cent ained in -~. This fcNows \nthe method of Tait\\L@f for the Church-Rosser Theorem. The sec\u00adond step is to replace all +-p steps with \n~ ~ steps in the reduction M x~~ n , which must ex\u00adist since eval(fll) = n . The final step is to prove \nthat we can slide all XOfiix to the left and all ~ ~ to the right. The proof method is inspired by Plotkin \ns proof of standardization for the un\u00ad typed A-calculus [15:140]. ~ Conceptually, this theorem says that \nwe may view compilation as reduction in the functional fragment and execution as reduction in the imper\u00adative \nfragment. However, as Reynolds also points out, recursion presents a major obstacle since the reduction \nphase may go on for\u00ad ever, producing an infinite head-normal term. Nevertheless, such an infinite term \ncan still be viewed as a simple imperative program; operationally, one simply imple\u00ad ments the two phases \nas coroutines. [17:3] Put differently, a compiler CZLnnOt know in advance how far to unroll a recursive \nprogram. Hence, the compiler must unroll it all the way, which means that the result is an infinite term. \nThe important point is that although this infinite term is in (an ex\u00adtended version of) the impel~ative \nlanguage, it can still be executed in the usual imperative reduction system. In order to formalize these \nnotions, we extend the language of IA with an additional constant, Q, denoting observable nontermination. \nWe define the function [ c];, which maps i>n expression in IA to an expression in extended 1A by unrolling \nall re\u00ad cursive functions i times. We then define a purely imperative sublanguage of (extended IA that \npre\u00ad cisely characterizes the @ normal forms of unrolled programs. This imperative sublanguage may be \nviewed as the target Iangualge of the compiler. Extended 1A is naturally ordered by, ~, the prefix-ordering \nwith respect to Q. Unrolling and ,f3\u00ad normalization respect this cmdering, i.e., unrolling an expression \nfurther and ~ normalizing the re\u00adsult yields a (potentially) larger member of the im\u00adperative sublanguage. \nSimilarly, execution in the imperative sublanguage respects the ordering. Fi\u00adnally, we prove a version \nof the postponement the\u00adorem for unrolled programs. Definition 3.2. ( Unrolling) The ith unrolling of \nan IA expression M, notation: [M]i, is defined by induction on the structure of M. The only interest\u00ading \nclause is the following: For all other constructs, the unrolling expansion is a homomorphic map. We refer \nto i as the un\u00adrolling index. The constant Q is of ground type; for higher types, it is an abbreviation \nfor Ad.fl for an appropriate vector &#38; of variables. ~ Unrolling a program i times roughly corresponds \nto using the axiom (fix) i-times on each rec\u00adexpression. More precisely, (ret M) ~fix~ {M(. ~.(Mjrec \nM)) . ..) i times but [(ret M)]i = (~lf],(. ;.([M$,Q))). i times To formalize the precise relationship \nbetween the two operations, we introduce an ordering, L, on W terms. It is the usual prefix-ordering \nfor terms with respect to Q. Definition 3.3. (G) 1.QLM 2.MEM 3. if M z M and C ~ C then C [M] EC [M ] \n For contexts, C L C if C[Q] ~ C [Q]. Q The target language of the compiler is the purely imperative \nsub-language, W, which is essentially extended IA without recursion, A-Abstraction, or arbitrary function \napplication. Definition 3.4. (W) The imperative sub\u00adlanguage Wofextended IAis defined by the fol\u00adlowing \ngrammar: ..  t .. Q1 n [z[((opt)t) I new(z,t).t I (deref t) I (setref! tt) Iskip I(ifO t t t) I(begin \nt t) Legal phrases of W are those that satisfy the type inference rules of Figure 1 with the additional \ncon\u00adstraint that Q is of one of the groundtypes (o). ~ In order to show that W is the proper target language, \nwe prove that the result of ~-reducing an unrolled program to ~ normal form is always a member of W. \nLemma 3.5For alli c Pi,L < M, the @ normal form of [L]i is in W. Proof. The proof reduces to showing \nthat both the function and argument position of an appli\u00adcation in a normal form expression cannot be \na A-expression. c Since it is impossible to know a priori how far recursive procedures must be unrolled, \nthe compi\u00adlation of an IA program into a W program must produce the set of/3 normal form s of all unrolling \nof the original program. Hence, to understand the evaluation of an IA program as the execution of a W \nprogram, we need to extend evalP (see Defini\u00adtion 2.1 ) to sets of W programs. Definition 3.6. (Eztended \nevalp) Let W be a set of W programs, i.e., a set of closed phrases of ground type. Then, evalP applied \nto this set is the point-wise extension of the originaJ evaluator: evalp(lv) = {evalp(w) I w G W}  { \nn [ w --+; ?2 , w c w}. (For completeness, we define that Q -+P Q.) ~ To prove that evalP is equivalent \nto the original evaluator, we must show that both the functional and imperative reduction system respect \nthe prefix ordering, G. If this holds, the ~ normal forms of all finitely unrolled versions of a program \nclearly form a totally ordered, infinite set of W programs, which may be perceived as the infinite @ \nnormal form of an IA program. 3 If the imperative executions of all elements of the infinite term preserve \nthe ordering, and if one of the elements reduces to the correct final answer, then the two evaluators \nindeed agree. We begin by proving that the functional reductions preserve the approximation ordering. \nLemma 3.7 For all programs M and i < N, if Lj is the ~ normal form of [M]j, then for all i E N, Li g \nLi+l Proof. The result follows from two lemmas. The first shows that [M]i Q [M]i+l. The second shows \nthat ~ normalization respects L. = Second, we prove that imperative reductions pre\u00ad serve approximations. \nIn particular, if a W pro\u00ad gram terminates, then so do all the programs that dominate it. Lemma 3.8 \nFor all M,N cW, ifM ~N and M +; n , then N -+? n . Proof. By induction on the length of the reduction \nM -+} n : For a single step M -+P Ml, since M ~ N, either M a Ml if it is an Q reduction or the same \nredex exists in N. The first case is triv\u00adial. For the second case, it is simple to check that reducing \nthe corresponding redex in N produces a phrase N1 such that Ml ~ N1, hence the induction hypothesis may \nbe applied. I Finally, we state and prove a more general ver\u00adsion of the postponement theorem that character\u00adizes \ncompilation as ~-normalization to an infinite tree and machine execution as an evaluation of the infinite \ntree in the imperative fragment. Theorem 3.9 For all IA programs L, let W = {MI M is ~ normal form of \n[L]i for i G R-J}. Then, {eval(L)} = evalP(W). Proof. By Lemma 3.7, W is a chain, i.e., a totally ordered \nset. Thus, the theorem reduces to the fol\u00adlowing claim: coal(L) = n 3This situation is analogous to \ndomain theory [1]: infinite terms are really sets of all their finite approximations. if and only if \nthere exists some unrolling index i and O normal form M such that If this claim is true, then, by Lemma \n3.8, W con\u00adt ains at most one result, which must be the result of the original program. The right to \nleft direction of the auxiliary claim is obvious. For the left to right direction, by the Postponement \nTheorem 3. , coal(L) = n implies that there is a reduction: L >fix N -; n Clearly, no ret-expression \nor ~-expression in N is relevant to the reduction from N to n . Hence we m,py replace all ret-expressions \nand A-expressions in N by Q to produce a term N such that N ~ N and N ---+; n . Next, let i be the number \nof fix steps in the reduction from L to N. Directly correspond\u00ading to the sequence of @ reductions in \nL -* pfix N is a sequence of ~ reductions that takes [L]i to a term N , which looks like N with some \nsubterms of the form (ret Nl) replaced by (NI (. . (NI Q))). Hence N Q N . Let M be the /? normal form \nof N , which exists because ~ is strongly normaliz\u00ad ing. Because /3 normalization respects C, we know \nthat N Q M. Hence, by Lemma 3.8, we have M ~~ n . Combining the above, we have the following sit\u00ad uation: \nP r where double lines indicate a partial order and vec\u00adtors denotes reductions. We have thus found \na nor\u00admal form M such that [L]i reduces to M, and M imperatively reduces to the final answer. This com\u00adpletes \nthe proof of the auxiliary claim. E A straightforward implementation of this compi\u00adlation/execution schema \nrelies on lazy evaluation. The compiler suspends after producing sufficient output and pipes its output \ninto an abstract ma\u00adchine for imperative programs. When the machine runs out of executable code, it resumes \nthe com\u00adpiler. The abstract machine is a modification of the CEK machine [7]. The control portion of \nthe machine is a member of W. The environment acts as a stack of references. The continuation corre\u00ad \nsponds to an evaluation cent ext. Figure 3 cent sins a formal specification of the machine and its in\u00ad \nstructions. 4 Strong Normalization The simply-typed A-calculus has the important property that terms \nwithout the recursion con\u00adstruct always reduce to normal form. As a result, the equational theory is \ndecidable, which is clearly import ant for the implement ation of a broad class of compile time optimizations. \nSince the impera\u00adtive sub-language of IA is also clearly strongly nor\u00admalizing, the natural question \nis whether the com\u00adbined language (without fix) satisfies the strong normalization theorem. The key to \nthe Strong Normalization Theorem for IA is (a stronger version of) the Postpone\u00adment Theorem of Section \n3 and a proof technique for combinations of two strongly-normalizing sys\u00adtems that satisfy the postponement \nproperty.4 Ap\u00adpendix A contains the proof of the meta-theorem on combining strong normalization results \nfor two different systems. Theorem 4.1 ~p is strongly-normalizing. Proof. Since the combination of two \nstrongly\u00ad normalizing systems that satisfy the postponement property is not necessarily strongly-normalizing, \nwe need to prove a technical lemma that strength\u00ad ens these properties. For our case, the relevant properties \nare: finite branching A one-step reduction relation is finitely branching if for every term, the set \nof terms reachable in one step is finite. strong postponement If rl and r2 satisfy post\u00adponement, they \nsatisfy strong postponement if M ~&#38; r2 M t implies there exists M! such that M ~~ M ~~z M , and m+n>1.5 \n4Van Daalen [3:80] apparently proves the same result, but he ignores the additional conditions we impose. \nTheir absence breaks the meta-theorem. , 5Postponement refers to Theorem 3.1 not to Theorem 3.9. Before \nAfter cEK cEK .. .... -. ((op tl) t~) M-tl E ((op *) t2)::K rnl E ((op *):2):: K + tz E ((op n )*):: \nK m E ((op n )*):: K + n opm E K new(z,tl).tz E K -tl new(z,*).t2 :: K rnl E new(z,*).t2 :: K + tz (x, \nn:) :: E new(ic,rn ).* :: K val p::E new(z,rn ).* :: K + val E K (setref! tl t2) E K -tl E (setref! \n* tz)::K z E (setref! * tz) :: K + tz E (setref! z*) :: K rnl E (setref! z *):: K + skip E!(x, n ) K \n (cieref tl) E K -tl E (deref *) :: K x E (deref*)::K + E.z E K (ifOtl tzts) E K. -tl E (ifO * t2 t3)::K \nrlo E (ifO* t2t3)::K+ tz EK n+1 E (ifO* tzt,)::K -ts EK (begintltz) E K -tl E (begin * t2)::K skip E \n(begin * t2)::K+t2E K where the operations ! and . on environments are defined as follows: (((x, m ) \n:: E)!(z, rm ) = (c, rm ) :: E ((y, n ) :: E)!(x, m ) = (Y, n ):: (E!(z) m )), where z # Y ((z, n ) :: \nE).c = n ((y, n ) :: E).z = E.z, where z # y FIGURE 3: CEK Machine Our main technical theorem (Theorem \nA.4) is the The following lemma (Lemma 4.2) shows that p is following: strongly normalizing. u If rl \nand rz are strongly-normalizing and satisfy the finite branching property, and if r1r2 satisfies the \nstrong postponement  Lemma 4.2 p is strongly-normalizing. property with respect to r2, then rl r2 is \nstrongly normalizing. Given this theorem, to prove that ~p is strongly-Proof. We note that every p reduction \nremoves at normalizing, all that remains to be shown is that least one keyword, with the exception of \no, which ~p satisfies the strrmg postponement property with replaces a set ref ! with a skip. Hence, \nany reduc\u00adrespect to p and that p is strongly-normalizing. It tion starting with a term t could not possibly \nhave is obvious that both /3 and p satisfy finite branch-more that 2s + k steps, wheres is the number \nof se\u00ading. The proof of the postponement theorem (3.1) tref ! s in t and k is the number of other keywords \nis easily modified to show strong postponement. in t.m 5 Extensions and Alternatives The preceding analysis \nof a small, but prototypi\u00adcal version of Algol formalizes a number of folklore claims. First, it proves \nthat the language s calculus is indeed the extension of a term rewriting systems for a simple imperative \nlanguage with a typed A\u00adcalculus. Second, the combination is orthogonal in the sense that major properties \nfor the two sub\u00adcalculi are compatible and hold for the entire sys\u00adtem. Finally, the analysis confirms \nthe idea that the evaluation of Algol programs can be neatly sep\u00adarated into a functional and an imperative \nphase. An extension of our results to more expressive languages than IA is possible. The analysis ob\u00adviously \ncarries over to extensions of IA that in\u00adclude different primitive data types (boolean, float, characters), \ncomplex data types of ground types (strings, arrays, records), and intersection types of ground types \nwith coercions. Moreover, all the re\u00adsults can be re-established for a call-by-value vari\u00adant of IA; \nbut, for the Postponement Theorem to hold, the functional system becomes more complex and must include \nbubbling reductions for imper\u00adative operations [5:ch. 5]. It is not clear whether the results will hold \nfor full Forsythe, which in\u00adcludes less restrictive intersection types. The Strong Normalization and \nPostponement re\u00adsults cannot carry over to languages with higher\u00adtyped or untyped references. As a consequence, \nthese results do not hold for the calculi of sev\u00aderal programming languages that mix functional and imperative \nfeatures, i.e., Russel [4], Scheme (Lisp) [2, 8,9,12, 13], and ML [22]. A recently dis\u00adcovered alternative \nto mixing functional and fully imperative languages is the addition of a weakened form of assignment \nto functional languages [10, 16]. None of these languages or calculi is comparable to IA with respect \nto (imperative) expressive power. We suspect that most of these languages satisfy postponement and strong \nnormalization theorems, but it is not clear whether this is relevant given the weakness of their assignment \nstatements. In conclusion, we believe that our work correctly captures the principles of Algol and that \nit contin\u00adues the tradition of formalizing and exposing met a\u00adproperties of programming languages. Conversely, \nin order to determine whether a language is an ex\u00adtension of Algol or whether it belongs to a different \nclass of programming languages, it suffices to check whether its calculus satisfies the above-mentioned \nproperties or not. We conjecture that it is also possible to characterize other classes of languages \n(e.g., Scheme or ML) through the meta-properties of their calculi. Acknowledgements. We appreciate comments \nby Robert Cartwright, Ian Mason, Amr Sabry, and John Gateley on an early draft. References 1. BARENDREGT, \nH.P. The Lambda Calculus: Its Syntax and Semantics. Revised Edition. Studies in Logic and the Foundations \nof Mathe\u00admatics 103. North-Holland, Amsterdam, 1984. 2. CRANK, E. AND M. FELLEISEN. Parameter\u00adpassing \nand the lambda-calculus. In Proc. 18th ACM Symposium on Principles oj Program\u00adming Languages, 1991, 233 \n245. 3. DAALEN VAN, D. The Language Theory of A UTOMATH. Ph.D. Dissertation, Eindhoven University, 1980. \n 4. DEMERS, A. AND J. DONAHUE. Making vari\u00adables abstract: an equational theory for Rus\u00adsell. In Proc. \n10th A GM Symposium on Prin\u00adciples of Programming Languages, 1983, 59 72. 5. FE LLEISEN, M. The Calculi \nof Lambda-v-CS-Conversion: A Syntactic Theory of Control and State in Imperative Higher-Order Programming \nLanguages. Ph.D. dissertation, Indiana Univer\u00adsity, 1987. 6. FELLEISEN, M. On the expressive power of \nprogramming languages. Science of Computer Programming 17, 1991, 35-75. Preliminary version in; Proc. \n3rd European Symposium on Programming. Neil Jones, Ed. Lecture Notes in Computer Science, 432. Springer \nVerlag, Berlin, 1990, 134-151. 7. FELLEISEN, M. AND D.P. FRIEDMAN. Con\u00adtrol operators, the SECD-machine, \nand the A\u00adcalculus. In Formal Description of Program\u00adming Concepts III, edit ed by M. Wirsing. Else\u00advier \nScience Publishers B .V. (North-Holland), Amsterdam, 1986, 193-217.  8 FELLEISEN, M. AND D.P. FRIEDMAN. \nA syn\u00adtactic theory of sequential state. Theor. Com\u00adput. Sci. 69(3), 1989, 243 287. Preliminary version \nin: Proc. Idth ACM Symposium on Principles of Programming Languages, 1987, van Vliet. North-Holland, \nAmsterdam, 1981, 314-325. 345-372. 9. FELLEISEN, M. AND R. HIEB. The revised 190 REYNOLDS, J. C. Preliminary \nDesign of the report on the syntactic theories of sequential Programming Language Forsythe. Technical \ncontrol and state. Technical Report 100, Rice Report CMU-CS-88-159, Carnegie Mellon Uni- University, \nJune 1989. Theor. Comput. Sci. versit y, Computer Science Department, 1988. 102, 1992. 20. S@ NDERGARD, \nH. AND P. SESTOFT. Referen\u00ad 10. GUZMLN, J.C. AND P. HUDAK. Single-tial transparency, definiteness and \nenfoldabil\u00adthreaded polymorphic lambda-calculus. In ity. Acts Informatica 27, 1990, 505 5 17. Proc. Symposium \non Logic in Computer Sci-21. WADLER, P. Comprehending monads. In ence, 1990, 333 345. Proc. 1990 ACM \nConference on Lisp and Functional Programming, 1990,61-78. 11. LENT, A. F. The Category of Functors \nfrom State Shapes to Bottomless CPOS is Adequate 22. WRIGHT, A. AND M. FELLEISEN. A syntactic for Block \nStructure. Master s thesis, MIT, approach to type soundness. Technical Report 1992. 160. Rice University, \n1991. Information and 12. MASON, I.A. AND C. TALCOTT. Equivalence Computation, 1992, to appear. in functional \nprogramming languages with ef\u00adfects. Journal of Functional Programming 1(3), A Strong Normalization July \n1991, 287 327. Preliminary version in: Proc. International C onjerence on Automata, In order to show \nthat the orthogonal combination Languages and Programming. Springer Lecture of two strongly-normalizing \nsystems is strongly-Notes in Computer Science, Vol. 372, Berlin, normalizing, we would like a theorem \nsimilar to 1989,574-588. the following, found in van Daalen [3:80]: 13, MASON, I.A. AND C. TALCOTT. Inferring \nthe Theorem A.1 equivalence of functional programs that mutate If rl and r2 are strongly-normalizing \nand if rlrzdata. Theor. Comput. Sci. 105(2), 1992, 167\u00adsatisfies the postponement property with respect \nto215. Preliminary version in: F roc. Symposium r2 then rl r2 is strongly-normalizing. on Logic in Computer \nScience. Computer So\u00ad ciety Press, Washington, D. C., 1989, 284 293. Unfortunately the above theorem \nis not true. 14. NAUR, P. (Ed.). Revised report on the al- There are several problems. First, the postpone\u00ad \ngorithmic language ALGOL 60. Comm. ACM ment property does not imply that there is any 6(l), 1963, 1 \n17. relationship between the length of the reduction 15. PLOTKIN, G.D. Call-by-name, call-by-value, \nL-~lr2 N and the length of the reduction L-~l and the ~-calculus. Theor. Comput. Sci. 1, M +:, N. In \norder to solve this problem, we in\u00ad 1975, 125-159. troduce a stronger notion of postponement, which places \na lower bound on the length of the generated 16. REDDY, U. S., V. SWARUP, AND E. IRELAND. Assignments \nfor applicative languages. In Proc. reduction. Conference on Functional Programming and Definition A.2. \n(Strong Postponement) rlrzComputer Architecture. Lecture Notes in Com\u00adsatisfies the strong postponement \nproperty with re\u00adputer Science, Vol. 523. Springer Verlag, spect to r2, if e +~.rz M 1 implies there \nexists M{Berlin, 1991, 192-214. such that e*Z Mt +~z M , and m+n>1. B 17. REYNOLDS, J.C. Replacing complexity \nwith generality: The programming language Problems can also arise when rl or r2 allows ar- Forsythe. \nUnpublished manuscript, Carnegie bitrary length (not infinite) reductions for a given Mellon University, \nComputer Science Depart\u00ad term. Oflland, arbitrarily long reductions starting ment, 1991. from a single \nterm might appear to directly con\u00ad 18. REYNOLDS, J.C. The essence of Algol. In AL tradict strong-normalization; \nhowever, in general, gorithmic Languages, edited by de Bakker and this is not the case. As an example, \nconsider the following notion of reduction over the language X*, with alphabet X = {O, 1, 2}. r = {( \nO,lm) I n > l}U {(1,2)} Notice that r is strongly-normalizing, but for any term containing a O, there \nare reductions of arbi\u00adtrary length. Intuitively, for more standard reduction sys\u00adtems such as /?, p, \nand ia, strong normalization coincides with bounded reduction length. In com\u00adparing these systems with \nr, we notice that they share a property that r does not have, namely, only a finite number of reductions \nare applicable to any given term. The notion r does not satisfy this finite branching property, because \nfor a term tcontaining a 0, there are an infinite number of terms t such that t -r t . After introducing \nsome terminology, we will provide a simple criterion which character\u00adizes strongly-normalizing systems \nwhich prohibit arbitrary length reductions starting with a given term. Definition A.3. (Reachability) \nLet r be a notion of reduction. e The set of terms reachable in i steps from ex\u00adpression A4 using notion \nof reduction r is de\u00adfined by: R;(M) ~ {M I M +,; M } o The set of terms reachable from M is defined \nby: R,(M) ~ u i>o B;(M)  r satisfies the finite reachability y property if for all expressions M, Rr(M) \nis finite. e r satisfies the finite branching property if for all expressions M, R;(M) is finite.  \nr satisfies the bounded reduction length prop\u00ad  erty if for all expressions M, there exists a j, such \nthat U;>j R;(M) = 0., For an expression M, we denote the smallest such j by P,(M). B With some technical \nlemmas, we can show that in the presence of finite branching, strong\u00adnormalization exactly corresponds \nto bounded re\u00adduction length. Then we can prove the following theorem. Theorem A.4 If rl and rz are strongly-normalizing \nand satisfy the jinite branching property, and if r1r2 satisfies the strong postponement property with \nrespect to r2, then rl r2 is strongly-normalizing. We begin by making some observations about reachability. \nWe then prove the necessary lemmas for Theorem A.4, and finally the theorem itself. Observation A.5 R,(M) \n= M u ( u R,(M )) M @(14) Observation A.6 Bounded reduction length im\u00adplies strong normalization. Proposition \nA.7 Strong normalization plus jinite branching implies finite reachability. Proof. We use infinite reachability \nand finite branching to generate an infinite reduction se\u00adquence. Let M be a term that violates finite \nreach\u00adability. By Observation A.5 and finite branching we may conclude that there exists an M < B:(M) \nthat violates finite reachability. Apply a similar argument to M . Continue. I Proposition A.8 Strong \nnormalization plus jinite reachability implies bounded reduction length. Proof. In fact, pr(M) < l&#38;(M)l. \nAny longer reduction would necessarily repeat a term, contra\u00ad dicting strong-normalization. n We are \nnow ready to prove our main theorem. Proof. (Theorem A.4) We show that r1r2 sat\u00adisfies bounded reduction \nlength, thus by Obser\u00advation A.6 is strongly-normalizing. By Proposi\u00adtions A.7 and A.8 we know that rl \nand r2 sat\u00adisfy bounded reduction length. We show that prlr2(M) < m + n , where m = prl (M), n = max{prz \n(M ) / M ~ Ii&#38; (M)}. We note that n is well-defined because rl satisfies finite reachability (by \nProposition A.7) and r2 satisfies bounded re\u00adduction length. Consider a reduction Al ~~lr2 M . Because \nr1r2 satisfies the strong postpone\u00adment property with respect to r2, there exists a reduction M PE M \n--+;, M with m + n >1. We know that m-< ml. Since M c R,, (M) we also know that n < Pr, (M ) < n . Hence \n1< m+n<m +n . m \n\t\t\t", "proc_id": "158511", "abstract": "<p>According to folklore, Algol is an &#8220;orthogonal&#8221; extension of a simple imperative programming language with a call-by-name functional language. The former contains assignments, branching constructs, and compound statements; the latter is based on the typed &#955;-calculus. In an attempt to formalize the claim of &#8220;orthogonality&#8221;, we define a simple version of Algol and an extended &#955;-calculus. The calculus includes the <italic>full</italic> &#946;-rule and rules for the reduction of assignment statements and commands. It has the usual properties, e.g., it satisfies a Church-Rosser and Strong Normalization Theorem. In support of the claim that the imperative and functional components are orthogonal to each other, we show that the proofs of these theorems are  combinations of separate Church-Rosser and Strong Normalization theorems for each sublanguage.</p><p>An acclaimed consequence of Algol's orthogonal design is the idea that the evaluation of a program has two distinct phases. The first phase corresponds to an unrolling of the program according to the usual &#946; and fixpoint reductions, which provide the formal counterpart to Algol's famous copy rule. The result of this phase is essentially an imperative program. The second phase executes the output of the first phase in the imperative fashion of a stack machine. Given our calculus, we can prove a Postponement Theorem and can thus formalize this phase separation.</p>", "authors": [{"name": "Stephen Weeks", "author_profile_id": "81100226831", "affiliation": "", "person_id": "PP31098951", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158523", "year": "1993", "article_id": "158523", "conference": "POPL", "title": "On the orthogonality of assignments and procedures in Algol", "url": "http://dl.acm.org/citation.cfm?id=158523"}