{"article_publication_date": "03-01-1993", "fulltext": "\n Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging Ali-Reza \nAdl-Tabatabai and Thomas Gross School of Computer Science Carnegie Mellon University Pittsburgh, Pennsylvania \n15213 Abstract A symbolic debugger allows a user to display the values of program variables at a breakpoint. \nHowever, problems arise if the program is translated by an optimizing com\u00adpiler. This paper addresses \nttie effects of global register allocation and assignment a register assigned to a variable V may not \nbe holding V s value at a breakpoint since the register can also be assigned to other variables. We define \nthe problem of determining whether a variable is in its assigned register as the residence problem. Prior \nwork on debugging of optimized code has focused on the currency problem; detecting whether a variable \ns run-time value is the expected value. Determining residence is a more se\u00adrious problem than currency \ndetection. We present a data flow algorithm that accurately computes a variable s res\u00adidency, by determining \nwhen a variable becomes evicted from its register. We measure the effectiveness of differ\u00ad ent approaches \nto determine variable residence for three C programs tlom the SPEC suite. Supportedin part by the Defense \nAdvanced Research Projects Agency, Information Science and Technology Office, under the title Research \non Parallel Computing: ARPA Order No. 7330. Work furnished in connection with this mearch is provided \nunder prime contract MDA972-90-C-0035 issued by DARPA/CMO to Carnegie Mellon University. The views and \nconclusions contained in this document are those of the authors and should not be interpreted as representing \nthe official policies, either expressed or implied, of the U.S. Govern\u00adment. Permission to copy without \nfee all or part of this material is granted provided that the copies are not made or distributed for \ndirect commercial advantege, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. ACM-20th PoPL-1 /93-S. C., USA \na 1993 ACM 0-89791-561-5/93/0001/0371 . ..$l .50 1 Introduction Optimization commonly employed by current \ncompilers duplicate, eliminate or reorder operations and values so that it is difficult for a symbolic \ndebugger to discover the correspondence between source and object code. Such optimization may make it \ndifficult to set breakpoints or to inspect variables; some values may either be inconsistent with what \na user expects based on the source code, or may be inaccessible in the run-time state. A symbolic debugger \nfor optimized code must detect these values and respond appropriately to a user query. The problems encountered \nby a symbolic debugger of optimized code have received considerable attention in the past. Starting with \nHennessy [12], a number of studies [14,10,8,3,1 1] have investigated the detection and recov\u00adery of noncurrent \nvariables, variables whose values are inconsistent with what the user expects from inspecting the source. \nThis paper discusses a more fundamental problem that a symbolic debugger has to handle detection of nonresident \nvariables. Global register allocation and assignment effec\u00adtively exploit modem architectures that have \nlarge register files and high memory access latencies, and these opti\u00admization are incorporated in almost \nall modem optimiz\u00ading compilers. These optirnizations, however, affect de\u00adbugging by making variables \ninaccessible at a breakpoint. By attempting to pack as many variables as possible into a limited number \nof registers, global register allocation re\u00adassigns registers to different variables at different points \nin the program. Therefore, a source level variable V maybe inaccessible at a breakpoint if the register \nassigned to V holds the value of some other variable at that poin4 and there is no other location that \nholds V s value. From the viewpoint of the user, noncurrent and non\u00adresident variables are similar in \nthat the debugger cannot display the expected value. However, a noncurrent vari\u00adable has a vatue that \nis inconsistent with what the user ex\u00adpects, whereas a nonresident variable has no value. That is, the \nvalue in a noncurrent variable s run-time location is a source level value, but it is not the value expeeted \nby the user. Therefore, since the value has some meaning in the source, it may be helpful to the user \nif the debugger can convey what source value a noncurrent variable s value corresponds to [11,8]. On \nthe other hand, no source vatue can be displayed for a nonresident variable. This paper investigates \nthe problem of detecting non\u00adresident variables in the presence of global register allo\u00adcation. Our solution \nis based on using data flow analy\u00adsis techniques for the debugger to detect all points where source level \nvalues are in their assigned run-time locations. The problem of detecting resident variables is concerned \nonly with whether a variable V s register contains any source value of V, and not whether V is current. \nOther mechanisms must exist that detect noncurrent variables. These m~hanisms are orthogonal to our method \nof de\u00adtecting nonresidence. Other compiler optimizations do not affect our method as long as the compiler \ncan provide the necessary bookkeeping of source assignments. To measure the effects of our approach (and \nthe serious\u00adness of the problem), we have implemented the techniques in a production C compiler that \nperforms code compaction and register allocation for an LIW machine with a large register file. We have \ncompared the effects of nonresi\u00addency with the effeets of noncurrency on the debugger s ability to recover \nsource values at a breakpoint. Our results indicate that nonresident variables are a serious problem, \nthe assumption (made if noncurrency is the only issue of concern to the debugger) that a variable is \nalways accessi\u00adble in its assigned run-time location presents a picture that is too optimistic. Furthermore, \na separate data flow analy\u00adsis phase in the debugger for tracking a variable s run-time location significantly \nimproves the number of variables ac\u00adcessible by the debugger; an overly conservative approach to tracking \na variable s run-time location (as presented in [11]) misses many opportunities. The following section \ndiscusses the problem of debug\u00adging optimized code. Section 3 describes our global reg\u00adister allocation \nmodel. Section 4 discusses approaches to detecting nonresident variables and describes our solution. \nSection 5 discusses the effects of optimization employed by the code generator to eliminate register \ncopy opera\u00adtions. Section 6 compares our work with prior work in debugging optimized code. Section 7 \nreports the results of using our approach on some sample programs, and Sec\u00ad tion 8 presents our conclusions. \n2 Debugging optimized code Our debugger model is the same as that used by a number of other researchers \n(see e.g. [8]). The debugger sup\u00adports the base operations of setting control breakpoints, inspecting \ndata and resuming execution after a breakpoint. Control breakpoints are either synchronous, such as source \nlevel breakpoints, or asynchronous, such as program faults or user interrupts. Data inspection is limited \nto source vari\u00adables, and the debugger does not change the state of a pro\u00adgram except for setting breakpoints; \ndata modification by the user is not supported. The debugger is non-invasive; no modification of the \nprogram s code or data is allowed, i.e., the code executed when debugging is identical to the code executed \notherwise, and the storage layout of the program is not perturbed. Our model does not allow the compiler \nto insert extra code to make debugging easier. For example, the compiler does not insert puth &#38;tertniners \n[15] into the object to determine the execution path leading to a break\u00adpoint, even though such knowledge \nallows the debugger to perform better analysis while retrieving source values. Furthermore, registers \nare only saved when necesszuy for the execution of the program, the compiler does not save old values \nsolely to assist the debugger. The compiler will, however, leave sufficient information describing cor\u00adrespondences \nbetween the object and source codes, such as a mapping of variables to storage locations. When the debugger \nis invoked as a result of a control breakpoint, the point in the object at which execution has halted \nis called the object breakpoint location, and the source statement where the breakpoint is reported is \ncalled the source breakpoiti location. Debugger functions can be classified into two groups: related \nto program flow (setting breakpoints: mapping a source-level location into a location in the object code \nreporting exceptions: mapping a faulting machine opera\u00adtion into source code), and related to data (reporting \nthe values of user variables). Problems related to the former are known as code locution problems, while \nthose related to the latter are known as data value problems [16]. In this paper, we only address the \ndata value problem of re\u00adtrieving source level values from the run-time state of a halted program. Our \nwork assumes that breakpoints can occur anywhere in the object code and hence applies to both synchronous \nand asynchronous breakpoints. See [8] or [15] for a discussion of flow related issues. 372 2.1 Retrieving \nsource values In response to a query of a variable V s value at a source breakpoint location S, the user \nexpects the value from the latest source assignment to V, relative to S. This value is the expected value \nof V [8]. l%e debugger either presents V s expected value or detects and reporta that V s expected value \ncannot be presented. If a value cannot be presented, the debugger may provide additional guidance to \nthe user by conveying how optimization have affected source val\u00adues. Thus we assume the debugger exhibits \ntruthful [16]. A variable s expected value is not always retrievable from the run-time state of an optimized \nprogram. IWO conditions must be satisfied to retrieve a variable V s ex\u00adpected value at a breakpoint \n1. V must be accessible in a storage location (memory, register, condition codes, . . . ) of the machine. \nIf the debugger determines that V is accessible in a storage location, V is called re,ridmt, otherwise \nV is called nonresident. The storage location where V is accessible is called V s residence, and the \nvalue in V S r~idence is called V s add value [8]. 2. V s actual value must be the same as V s expected \nvalue. If V s residence holds V s expected value, V is called current, otherwise V is called noncurrent \n[12]. A nonresident variable does not have an ac\u00adtual value, hence currency can not apply to such a variable. \n In unoptimized code, a variable has a home location whose value always matches the variable s expected \nvalue at a breakpoint. Thus the debugger can retrieve a vari\u00adable s expected vatue from the variable \ns home location. Optimizing transformations complicate the retrieval of val\u00adues by violating the conditions \nabove either a variable is inaccessible because the debugger determines the vwiable has no residence, \nor a variable is resident, but its value is noncurrent because the variable s actual value is not the \nsame (or muy not be the same [1]) as its expected value. This paper focuses on the problem of detecting \nnonresident variables. 2.2 Example Consider the source and object codes shown in Figure l(a) -(b). In \nthis example, variable c has been assigned reg\u00adister r3, while d and f have both been assigned register \nr4. Register r3 is also used as an expression temporary at instruction 13. No code has been generated \nto perform a store to a for S1, since S1 s assignment is redundant. The value computed by this statement \nis kept in register r3 for use by statement Ss. Figure 1(c) shows the ranges of instructions during which \nregister assigned variablea are resident. c is resident upon entry to this block until in\u00adstruction 13, \nat which point c becomes dead and r3 is reassigned to a temporary. c becomes resident again at 1s. r4 \ncontains a value of f upon entry, hence d is non\u00adresident. At 16, r4 is reassigned to d, and as a result \nf becomes nonresident. Table 1 lists the nonresident and noncurrent variables at all possible object \nbreakpoint locations in the code of Figure 1. We report an asynchronous breakpoint at an instruction \n1 as a breakpoint at the source statement for which 1 was generated. The tirst two columns of Ta\u00adble \n1 show the mapping from object locations to source statements. The third column presents the source expres\u00adsion \nthat is computed by each instruction, and the last two columns list the nonresident and noncurrent variables \nif a breakpoint happens at a given instruction. Considerabreakpoint atinstruction 15,reportedatstate\u00adment \nS3 in the source. At this breakpoint the expected value of a is the value assigned at statement S1, and \nthe expected value of d is the value assigned at statement SZ. The actual value of a is the value in \na s memory location before entry into this block, since the store to a has been eliminated. Therefore, \na is noncurrent. d is nonresident at this breakpoint, because the register assigned to d (r4) is holding \nf s value. c is also nonresident because ita reg\u00adister (r3) is holdlng the temporary value computed at \n13. Therefore no actual values exist for c and d. The expected and actual values of b, e and f are the \nvalues assigned by the last assignments to these variables before this block. Therefore, these wwiables \nare current at this breakpoint. 2.3 Nonresident and noncurrent variables Observe that noncurrent and \nnonresident variables are dif\u00adferent with regard the possible behavior of the debugger. In the case of \na noncurrent variable V, the debugger may provide additional information to the user by displaying V \ns actual value and attempting to explain what value is being displayed. E.g., consider a breakpoint occurring \nat 16 and reported at statement Sz in Figure 1. At this break\u00adpoint, the assignment to c of statement \nS3 has executed too early at 15. In response to a user query of c, the debugger may display the value \nin register r3 (c s actual value) and explain to the user that the displayed value is the value of c \nassigned at S3 because optirnizations have caused state\u00adment S3 to execute too early. This approach was \nadopted in the DOC debugger [11]. Copperman [8] gives sugges\u00ad r3 r4 s~: a = b+c; II:rl+ load b c S2: \nd=e*f; 12:r2+ load g 1 S3: c . a-g; 13: r3v fpadd rl , r3 s~: a=c; Id: rl + load e Is: r3 ~ fpsub r3, \nr2 1 I(j: r4 + fpmul rl, r4 IT: a&#38; store r3 d  CTfT Source code Object code Residence ranges \n(a) (b) (c) Figure 1: Example of noncurrent and nonresident variables Breakpoint Location Source Expression \nNonresident Noncurrent Object Source Evaluated by Instruction Variables Variables IISIb d 12S39 d a 13S1 \nb+C d 14Sz e c,da 15 S3 c.a-g c,d a &#38; S2 d=e*f d a,c 17S4a=c fa Table 1: Nonresident and noncurrent \nvariables at breakpoints in code of Figure 1 tions about what information should be presented to the \nuser. In the case of a nonresident variable, however, no actual value exists that can be presented to \nthe user. For example, at a breakpoint at 1s, c is nonresident because its assigned register r3 is holding \nthe temporary vatue computed at in\u00adstruction 13. This value has no relation to c (in fac~ it is the value \nof a computed by statement S1) and therefore will not be helpful to the user. The debugger can only inform \nthe user that the requested variable has been opti\u00admized away (i.e., the variable is unavailable), as \nis done in DOC [11] and CXdb [4]. An approach to dealing with noncurrent and nonresident variables is \nto recover a variable s expected value from the actual values of other variables and temporaries [12]. \n~,, E.g., at a breakpoint at 15, the debugger may infer that - a s expected value is in r3. Recovering \nvalues in globally optimized code is difficult (see [12] for a discussion of the scenarios when recovery \ncan be attempted), and the effectiveness of recovery in practice is unknown. 2.4 Uninitialized variables \nWhen the user inspects a variable, the variable s expected vatue maybe immaterial because the variable \nhas not been initialized during the execution of the program. Thus the question of whether an uninitialized \nvariable V is resident or current is irrelevant, since V has no expected value. The debugger may either \ndetect and warn the user of uninitial\u00adized variables, or it may let the user beware. Detecting and reporting \nuninitialized variables can reduce the number of variables that are reported as nonresident or noncurrent \nand provides additional information to the user. In the absence of support provided by the run-time sys\u00adtem \n(e.g., path determiners [15]) or the architecture (e.g., memory tags), detecting uninitialized variables \nrequires that the debugger obtains program flow analysis informa\u00adtion from the compiler. If no definition \nof a user variable V reaches a point S in the source, then V is uninitialized whenever the program breaks \nat S. This dataftow problem is known as reaching definitions [2]. Note that the debug\u00adger cannot help \nin the case that definitions reach on some but not all paths to S. Referring back to the example of Figure \n1, if no source assignment of d reaches the block of code, d can be re\u00ad 374 ported as uninitialized \nrather than nonresident at any break\u00adpoint reported at S1 or S2. In this example, these are breakpoints \nthat occur at 11, 13,14and ~fj. 3 Global register allocation Register allocation and assignment attempt \nto speed up program execution by keeping frequently accessed values in high speed registers. Such values \ninclude variables, temporaries, and constants, but since we are concerned with source-level debugging, \nwe do not mention tempo\u00adraries or constants any Mher. Our model of register allocation is similar in \nstyle to Chaitin s [5] and is based on the optimizing compiler that we have used in our empirical studies. \nIn our model, a variable is either promoted to a register (selected to reside in a register) or given \na home location in memory. Reg\u00adister assignment binds physical registers to register pro\u00admoted variables, \nand in our compiler, register assignment happens after instruction scheduling. A register is assigned \nfor exclusive use by a variable during the variable s live mnge [6], which consists of instruction ranges \nbetween definitions and last uses of the variable. If spilling is required during register assignment \nthe whole live range of a variable is spilled to memory. Loads and stores are added to the schedule to \naccess spilled vari\u00adables. Disjoint segments of a live range are not renamed, nor are live ranges sptit \nduring register assignment. Thus, each register promoted variable V is either spilled to mem\u00adory (if \nthere are not enough registers), or it is assigned a single physical register denoted R(V) for the duration \nof its live range. A register promoted variable that is assigned a physical register is referred to as \na register assigned variuble. Variables that have home locations in memory (including those that are \nspilled to memory) are always residen~ since their storage locations are not shared with other variables. \nRegister assigned variables, however, may be nonresident since a register is usually assigned to many \nvariables. Coalescing, also known as subsumption [5], eliminates copy operations. This optimization coalesces \ntwo variables whose live ranges do not interfere and are connected by a copy operation. As a resutt, \nboth variables are assigned the same physical register. 4 Detecting nonresident variables There are severat \napproaches that a debugger may take to determine if a variable is resident at a given object loca\u00adtion. \nSince a variable is resident during its live range, one way to detect resident variables is to consider \na variable as resident at an object breakpoint within the variable s live range. The advantage of this \napproach is that live range in\u00adformation is computed at compile time by the compiler s register assignment \nphase. E.g., in the DOC debugger [11], the address ranges of instructions in a variable s live range \nare recorded in the runge record data structure at the same time as the interference graph is built by \nthe regis\u00adter assigner. The range records are passed to the debugger, which uses them to detect whether \na breakpoint lies within a variable s live range. Using a variable s live range for determining residency \nis simplistic and conservat.ky the debugger uses a simple rule that is always right but misses opportunities. \nA vari\u00adable s assigned register may still be hoidlng the variable s value after the variable s live range \n(e.g., after the last use of the variable). This is illustrated in Figure 2(a). This figure shows a sequence \nof definitions and uses of a regis\u00adter r in a straight line piece of object code. Register r has been \nassigned to source variables x and y. The definition at 11 writes a value of x into r, and this definition \nmarks the beginning of x s live range, whereas the use of r at 13 is the last use of x and establishes \nthe end of x s live range. x is definitely resident at a breakpoint occurring at either 12 or 13, since \nthese instructions lie within x s live range. x remains resident until 15 writes y s value in r, thus \nevicting x from r (eviction is discussed in Section 4.2). But the range of instructions after 13 are \nnot part of x s live range. Hence, at a breakpoint at 14, a debugger that bases x s residency on x s \nlive range will report x as being nonresident, even though T still contains x s value. 4.1 Terminology \nBefore discussing the details of our approach, we intro\u00adduce some terminology. A control flow graph is \na directed graph (B, S, E) where B is the set of basic blocks; S c B is the entry bloc% E is the set \nof edges between blocks such that if (Bi, I?j ) E E then control may immediately reach Bj from Bi. Each \nbasic block Bi contains a se\u00adquence of instructions generated by the compiler, as well as a speciat preamble \ninstruction that appears before the other instruction in Bi, thus dominating them. A preamble instruction \nis an abstraction that is used by our algorithms, it is not generated by the compiler nor does it appear \nin the object code. Given an instruction 1, we define the set of predecessor instructions of 1, denoted \npred(l), as the set of instructions from which control can immediately reach 1. A point is defined as \nbeing either between two adjacent z~:... (1) m II: def r def x Residencedetermined (I) I by live range \n 12: ... Z3: user last we x I (II) Residencedetermined 14:... by fk3W S@&#38; 15:def r def y z~:... \nObject code Ranges in which x is resident (a) (b) Figure 2: Example illustrating the approaches to detecting \nnonresident variables instructions, before the first instruction in a basic block, or after the last \ninstruction in a basic block. The point irmne\u00addiately before an instruction 1 is denoted pre(l), and \nthe point immediately after 1 is denoted post(l). The entry point of the control flow graph is the point \nat the beginning of the source basic block S. The entry point dominates all other points in the control \nflow graph. A path is defined to be a sequence of points PI ...p. such that for each adjacent pair Pi, \nPi+l, either Pi = pre(~) ~d Pi+l ==post(l) for some instruction 1, or pi is a point at the end of a block \nBj and pi+l is a point at the beginning of a block Bk and (Bj, Bk)e E. We catl an instruction that targets \na register r a definition of r. An instruction 1 reaches a point p if there exists a path from post(l) \nto p along which the register defined by 1 is not redefined. The set of definitions of a register r that \nreach a point o is denoted by Z?eachirtgDef(fi o). 4.2 Evicted variables An approach to detecting nonresident \nvafiables that is more accurate than using live ranges is to precisely detect all points where V becomes \nnonresident. This implies detect\u00ading that x is still resident at 14 in Figtue 2(a) and allows the debugger \nto display the value of x outside of x s live range, as depicted by Figure 2(b). In the rest of this \nsec\u00adtion, we describe a method based on data flow analysis that realizes such an approach by detecting \nevicted vari\u00adabks. At a breakpoint, an evicted variable is a register assigned variable V whose assigned \nregister R(V) may contain a value that is not from a source assignment to V. Since only register assigned \nvariables can be nonresi\u00addent, all tither references to variables in this section are to register assigned \nvariables. To track whether a variable V s value is contained in R(V), definitions that write a source \nvalue of V into R(V) must be distinguished: Definition 1 LetE be a source assignment expression that \nassigns to a variable V. Of the instructions generated for E, the instruction that assigns V s value \nto R(V) is referred 10 as a source definition of V and is denoted by IV(E). At the point immediately \nfollowing a source definition of V, V is resident since R(V) holds a value from a source assignment to \nV. Referring back to Figure 1, instructions 15 and 16 are generated for statements S3 and SZ respectively. \nThese in\u00adstructions target the registers assigned to variables c and d with the source values of these \nvariables computed at StateIWWSs3 and S2. Hence Is and ~Gare source defini\u00adtiOIIS Of c and d : 1=(s3) \n= 15 and ~d(sz) = 16. To detect whether a variable V is evicted, the debugger must analyze paths leading \nto a breakpoint to discover which value is being held by R(V): Definition 2 A variable V is evicted along \na path p in the object l~execution of the path p results in R(V) containing a value that is not a value \nfrom a source definition of V. If R(V) is uninitialized along p, then R(V) is considered as having no \nvalue and V is not evicted along p. Definition 3 A variable V is evicted at a point o in the object, \nif V is evicted along al least one path leading from the entry point to o. Z%epredicate IsEvicted(V, \no) is true if a variable V is evicted at point o in the object. Note that the definition of an evicted \nvariable does not depend on where the breakpoint is reported in the source. We are concerned only with \nwhether R(V) holds a value of V, not whether it holds the expected value of V. Consider the control flow \ngraph of Figure 3. In this fig\u00ad ure, variables x, y and z have all been assigned the same register r. \nEach basic block contains at most one instruc\u00ad tion that is a source definition of one of the variables. \nAt 376 Basic Block Evicted Variables Evicted Variables at Start of Block 1 at End of Block B1 y,z B2 \ny,z X,z B3 x,z X,y B4 XIYJ z yrz F35 y,z y,z Table 2: Evicted variables at the start and end of each \nblock in Figure 3 the beginning of block B3, x and z are evicttxl since all execution paths leading to \nthis point result in r containing a value of y. Similarly, at the beginning of block B5, y and z are \nevicted since all execution paths leading to this point result in r containing a value of x. Table 2 \nlists the evicted variables at the start and end of each basic block in Figure 3.  !Iy(s,):r= . . . \n... I I To detect whether a variable V is evicted at a point o, I we must consider all values that \nmay possibly be contained B1 in R(V) if execution is halted at o. This can be accom\u00adplished by examining \nthe setReachingDef@(VJoJ If there exists any definition d c ReachingDef(R(V), o), such that IY(S2): r \n= ... d is not a source definition of V, then there exists a path leading to o which results in R(V) \ncontaining a value that B2 is not a value from a source definition of V, and hence by Definition 3 IsEvicted(V, \no) is true. Conversely, if IsEvicted(V, o) is true, some definition of R(V) that is not a source definition \nof V must reach o. Thus, the evic\u00adIZ(S3):r= . . . tion problem may be cast in terms of reaching definitions: \nLemma 1 A variable V is evicted at a point o in the object ifl there exists a definition d G ReachingDef(R(V),o} \nsuch 1 that d is not a source definition of V. 1x(S4):r = . . . 4.3 Computing evicted variables By Lemma \n1, IsEvicted(V, o) can be solved for by com\u00ad puting the set ReachingDef(R(V),o), and checking whether \nthere is a definition in ReachingDef(R(V),o) that is not a source definition of V. A simpler approach \nto comput\u00ad ing IsEvicted(V, o) is to track whether any definition of R(x) =R(y)=R( z)= r B5 R(V) that \nis not a source definition of V reaches o, using data flow analysis. Whereas a source definition writes \nthe Figure 3: Object control flow graph vatue of a variable V into R(V), an evicting definition of V \nwrites the value of a variable other than V into R(V): Definition 4 An evicting definition of a variable \nV is a akjinition of R(V) thaJ is not a source de$nition of V. Given am evicting definition 1 of a variable \nV, we say V is evicted by 1 (or I evicts V). Table 3 lists the 377 ~ Instruction I Variables Evicted \nI by Instruction Ix(sl) Y,z Iy(s2) x, z Iz(s~) X*Y IX(S4) y,z Table 3: Variables evicted by instructions \nof program in Figure 3 variables evicted by the instructions in Figure 3. For each register promoted \nvariable V, we define the predi\u00adcate Evictlikach(V, o) as follows: Definition 5 The predicate EvictReach(V, \no) is true at a point o in the object if any evicting &#38;~ition of variable V reaches o. Note that \nby Lemma 1, EvictReach(V, o) is equivalent to IsEvicted(V, o). Hence, solving for EvictReach(V, o) is \nequivalent to solving for IsEvicted(V, o). Since no evicting definitions reach the entry point s of the \nflow graph, no variable is evicted at s. Given an instruction 1, let .EvictReachln(I) be the set of variables \n{V : EviciReach(V, pre(l))] and let EvictReachOut(l) be the set of variables {V : EvictReach(V, post(~))}. \nEvicting definitions of a vari\u00adable V reach the point immediately before an instruction 1 if evicting \ndefinitions of V reach the points after any of 1 s predecessor instructions. l%us the EvictReachIn set \nof an instruction 1 is related to the EvictReachOut sets of 1 s predecessor instructions by the following \ndata flow equation: EvictReachIn(l ) = U EvictReachOut(J) J@+ed(I) An instruction 1 that is an evicting \ndefinition of a vari\u00adable V causes EvictReach(V, post(~)) to be true, and thus generates a reaching evicting \ndefinition of V. The set of variables that are evicted by an instruction 1 is denoted by EvictReachGen(I) \n. Similarly, an instruc\u00adtion J that is a source definition of V, re-establishes V s residence by killing \nall reaching evicting definitions of V, and causes EvictReach(V, post(J)) to be false. EvictReachKi//(J) \ndenotes the set of variables for which J is a source definition. The sets EvictReachGen and EvictReachKill \nare defined for an instruction 1 that de\u00adfines register R(V): o If 1 is a source definition of V, then \nV c EvictReachKill(I). Otherwise, V @ EvictReachKi/1(1). If 1 is an evicting definition of V, then V \nG EvictReachGen(I). Otherwise, V @ EvictReachGen(I). The EvictReachIn and EvictReachOut sets of an in\u00adstruction \nare related by the following data flow equation: EvictReachOut(I) = (EvictIn(I) U EvictReachGen(I)) \\ \nEvictReachKill(I) Function calls kill the contents of caller saved registers and therefore evict all \nvariables that are assigned caller saved registers. 5 The effects of coalescing Coalescing or subsumption \n[5] is an optimization that elim\u00adinates copy operations by assigning the same physical reg\u00adister to the \nsource and destination operands of a copy oper\u00adation. Coalescing affects debugging when the eliminated \ncopy operation is a source definition Iv(S) of a variable V. E.g., consider the source and object codes \ndepicted in Figure 4. Part (a) of this figure shows the source code, while parts (b) and (c) show the \nobject code before and after register assignment respectively. In this example, ly(S1) = 11 and 1=(S2) \n= Iz before register assignment. Assume that the live ranges of x and y do not interfere. The register \nassigner coalesces x and y, eliminating the copy operation 12 and assigning the same register r to both \nx and y (r= R(x) = R(y)). Sl: y=... Il:y= . . . 11: r=... ... ... ... S2: x = y; 12:x=y (a) (b) (c) \nFigure 4: Effects of register subsumption To capture the effects of coalescing, we consider the source \ndefinition corresponding to S2 as being executed by 11, at the same time as S~, so that 1=(S.2) = ly(S~) \n= 11 and {x, y} ~ EvictReachKi//(ll ). If execution stops somewhere between S1 and S2 in the source, \nbut after 11 in the objec~ x and y are both resident in r. The actual value of y is the value assigned \nby S1, while the actual value of x is the value assigned by S2, Hence, y is current and x is noncurrent. \nIf execution stops after S2 in the source, but atter 11 in the object, both x and y are current. x= \n... P Y=.. . Y=.. . IS:x=y; )I (a) Figure 5: Global A less precise model is to consider S2 as an eliminated \nassignment. Thus at a breakpoint after S2 in the source and after 11in the object, x will be detected \nasnonresident since 11 is a reaching evicting definition of x. However, this is conservative since r \ncontains the value that would have been assigned to x by S2, which is x s expected value. In general, \nwhen coalescing eliminates an instruction I = IV(S), the source definition instruction Iv(S) is changed \nto an earlier definition of R(V) that reaches pre(.1). Figure 4 illustrates the simple case where the \near\u00adlier definition of R(V) is within the same basic block as the eliminated copy operation. However, \nno earlier def\u00adinition of R(V) may exist within the same basic block as the eliminated instruction. Figure \n5 illustrates other cases that can oeeur. In this figure, coalescing eliminates the copy z = y. In Figure \n5 (a) S post-dominates all reaching definitions of R(V). Thus we may consider both reaching definitions \nas source definitions of S, adjusting IX(S) accordingly. Note that this moves the definition of x into \ndifferent basic blocks and results in multiple source definitions. This has ramifications on the noncurrency \nde\u00adtection algorithms which now have to address global code reordering [1]. If there exists a reaehing \ndefinition D that is not post-dominated by S, as shown in Figure 5(b), D cannot be considered a source \ndefinition of x. To avoid these two problems all together, we model the source definition of S in both \ncases to be the pre-atnble instruction of S s basic block. In other words, if there does not exist a \nprior definition of R(V) in the basic block, the preamble instruction is used. (b) register coalescing \n6 Comparison with other work Prior work on debugging optimized code has mostly as\u00adsumed that variables \nare aiways accessible in a run-time storage location. With the exception of the DOC [11] and CXdb [4] \ndebuggers, previous research has overlooked the problem of nonresident variables. Hennessy s work [12] \nand later refinements of Wall et. al [14] deal with detection and recovery of noncurrent variables in \nthe presence of local optimizations and code generation using DAGs. The model of [12] assumes that all \nvariables have home locations in memory and does not consider values held in registers. The code genera\u00adtor \nis cast at the intermediate representation level (before variables are bound to machine resources) and \noperates witbout reference to any specific features of the target ma\u00adchine (like load delays or a horizontal \ninstruction format). However, code generators in modern compilers typically are tightly tuned to the \ninstruction-level parallelism and storage hierarchy of the target architecture, as modern ar\u00adchitectures \nrely on instruction scheduling and register al\u00adheation for performance. Copperman ([81, [7]), proposes \na method of detecting noncurrent variables using global data flow analysis but does not consider nonresident \nvariables. A similar ap\u00adproach has been proposed by Bemmerl [3]. In another work, Copperman and McDowell \npoint out that Hennessy s model does not consider values held in registers [10]. However, they still \nconsider the problem at the intermediate representation level without reference to registers. They suggest \nthat ailowing multiple assignments to a variable within a basic block addresses this problem. However, \nthis does not handle the case of nonresidence caused by register re-use. DOC [11] is the first system \nthat we are aware off that deals with muttiple storage locations for variables. DOC tackles this problem \nby computing the location and cur\u00adrency of a variable in the compileu this information is then passed \nto the debugger in range records. A range record provides the debugger with the storage location assigned \nto a variable or, in the case that a variable has been elim\u00adinated and replaced with a constant, the \nvariable s value. The range of object code addresses during which a range record is valid is also specified \nin the record. The description in [11] states that range records of a register promoted variable span \nonly the variable s live range but the paper does not indicate how the debugger responds to a user query \nof a register promoted variable at breakpoints outside of the variable s live range, e.g., at a breakpoint \nbefore the variable has been defined or after its last use. According to Copperman and McDowell [10], \nDOC reports a variable as inaccessible after its last use. CXdb [4] is another system that detects nonresidency \nusing the live range approach[13]. Results To compare the problems caused by nonresidency with those \ncaused by noncurrency, and to evaluate the effective\u00adness of using data flow analysis, we have implemented \nour approach using the iWarp C compiler (pre-release version 2.7). This compiler is based on the PCC2 \ncompiler from AT&#38;T that has been enhanced with global optimizations. The target machine is the iWarp \nprocessor, an LIW ma\u00adchine, with 128 registers, of which 94 are available to the compiler. The compiler \nperforms globat register allocation and assignment, branch optimization, unreachable code elim\u00adination, \ncommon subexpression elimination, value propa\u00adgation, constant folding, and instruction scheduling. Com\u00admon \nsubexpression elimination, value propagation, and in\u00adstruction scheduling are performed at the basic \nblock level. The register allocation model is the one described in Sec\u00adtion 3. Due to the large number \nof registers in our machine, none of the benchmarks requires live ranges to be spilled to memory. The \ncompiler annotates each operation in the interme\u00addiate representation (IR) of the program with the list \nof machine instructions generated for the operation. The IR of assignments that have been eliminated \ndue to coalescing we annotated as described in Section 5. Register assign\u00ad ment are recorded in a table \nthat maps register assigned variables to physical registers. This information is used by our algorithms \nto detect nonresident and noncurrent vari\u00adables (details of our algorithm for detecting noncurrent variables \nare described in [1]). These algorithms can be performed either in the compiler for the debugger, or \nin the debugger. For our ex~riments, these algorithms were implemented in a separate program that gathers \nstatistics. Our experiments compare the effects of data flow anal\u00adysis techniques for finding evicted \nvariables to a simple approach, which tracks a variable s location only during the variable s live range. \nWe also investigate the effects of using reaching analysis to find uninitialized variables at breakpoints. \nWe look at the following four approaches to detecting nonresident variables: 1. A variable is resident \nduring its Iive range only. 2. A variable is resident during its live range only, and reaching analysis \ndetects uninitialized variables. 3. A variable is resident wherever it is not evicted. 4. A variables \nis resident wherever it is not evicted, and reaching analysis detects uninitialized vwiables.  In the \nfirst approach, the debugger is successful in re\u00adcovering a variable V s value if a breakpoint occurs \ninside V s live range. The second approach augments the first approach by using reaching analysis to \ndetect uninitialized variables. In this approach, the debugger is successful in recovering a variable \nV s value if the breakpoint occurs in\u00adside V s live range. At a source breakpoint where V is not reaching, \nthe debugger reports V as uninitialized. This re\u00adduces the number of variables reported nonresident since \nuninitialized variables are not reported as nonresident. Ihe third approach uses the data flow analysis \ntechnique described in Section 4.3 to find all points where a variable V s assigned register R(V) contains \nV s value. However, at a breakpoint, an uninitialized variable V is reported as nonresident if an evicting \ndefinition of V reaches the object breakpoint location. Recall that such an evicting definition is not \na source definition of V. The fourth ap\u00adproach adds reaching analysis to the third approach to de\u00adtect \nuninitialized variables and therefore only reports vari\u00adables as evicted if there is a source definition \nthat reaches the breakpoint. This approach is the most aggressive and least conservative of the four. \nWe present the results for three C benchmarks from the SPEC suite in Figure 6. This figure compares the \nper\u00adcentage of breakpoints that contain noncurrent variables (a) 1 Figure 6: Percentage of breakpoints \nwith noncurrent SPEC suite: (a) li , (b) eqntott, and (c) espresso. with the percentage of breakpoints \nthat contain nonresi\u00addent variables using each of the above four approaches. The first column shows the \npercentage of instructions for which there are noncurrent variables, i.e., we map each in\u00adstruction to \nits source statement and determine if there are any assignments or function calls that have been sched\u00aduled \nout of source order. The other four columns show the percentage of breakpoints with nonresident variables. \nFor each approach listed above, we compute the number of instructions for which there is at least one \nnonresident variable. The raw instruction counts are normalized by the total number of instructions in \nthe program. These metrics do not reflect the number of noncurrent or nonres\u00adident variables at a breakpoint \nnor do they consider the dynamic behavior of programs. Note that these metrics Bkpts with noncurrent \nvariables Bkpts with nonresident variables, residence determined by live range Bkpts with nonresident \nvariables, residence determined by live range and reaching dataflow for uninitialized variables Bkpts \nwith nonresident variables, residence determined by dataflow for eviction (Sec. 3) Bkpts with nonresident \nvariables, residence detenninad by dataflow for eviction and reaching dataflow for uninitialized variablee \n(c) or evicted variables for three C benchmarks from the also assume queries to all variables to be \nequaUy likely. The breakpoint model used is one that considers all instructions aspotential breakpoints \nand corresponds to the situation where the user can interrupt program execution at an arbitrary point \nin the object. We also considered a breakpoint model where only instruction that can generate a fault \nare considered as breakpoints. The results for both models are close; more details can be found in [1]. \nNote that these models capture the state of the user program for each machine instruction in the object \ncode and not for each source-level statement in the user program. The results in Figure 6 for these benchmarks \nshow that there are significantly more breakpoints containing non\u00adresident variables than there are breakpoints \nwith noncur\u00adrent variables. llms nonresident variables are potentially a more serious problem than noncurrent \nvariables when debugging optimized code. A comparison of the results of using the first approach with \nthe results of using the third approach, as well as a comparison of the second approach with the fourth \nap\u00adproach show that using data flow analysis to detect evicted viwiables significant y increases the \nchances of recovering a register assigned variable s value. The effects of using reaching analysis can \nbe measured by comparing the results of using the first and second ap\u00adproach rmd by comparing the results \nof using the third and fourth approach. Our results show that using reaching analysis decreases the number \nof breakpoints with nonres\u00adident variables for both the live range approach and the evicted data flow \nanalysis approach. Another way to evaluate the effectiveness of the various techniques for detecting \nnonresident variables is to look at the number of variables that are nonresident at a given breakpoint. \nFigure 7 presents this information using the same breakpoint model as discussed above. The leftmost column \nof each graph in this figure shows the average number of register assigned variables; this number presents \na baseline for comparison. A naive debugger that does not handle register assigned variables at all has \nto report all of these variables as inaccessible, so this number is the upper bound on nonresident variables \nfor each program. The rightmost columns of these graphs depict the average number of variables that the \ndifferent strategies discussed above report as inaccessible. The results from this figure again illustrate \nthe effectiveness of using data flow analysis to detect nonresident and uninitialized variables. 8 Conclusions \n Prior work in debugging of optimized code has concen\u00adtrated mainly on the problem of detecting and recovering \nnoncurrent variables and has either ignored the problem of evicted variables by assuming that a variable \nis always resident in a storage location, or used a simplistic approach to tracking variable locations. \nHowever, evicted variables are a serious problem for a symbolic debugger if the com\u00adpiler optimization \ninclude global register allocation and assignment (as is commonly done in modern compilers today). Our \nresults indicate that evicted variables are far more serious problem than noncurrent variables. In our \nsample programs from the SPEC suite, a large number of breakpoints have evicted variables. To detect \nevicted variables, it is necessary to consider the data flow at the level of machine instructions since \nit is at this level that register re-use occurs. Thus a detailed model of the machine resources is required. \nDebugger models proposed in previous studies are at a higher level than the machine level [12,9,8,7] \nand are not sufficient for detecting evicted variables. Detecting evicted variables requires analysis \nfor the de\u00adbugger. Our results show that at an approach that uses compiler collected data flow information \n(e.g., live range information for register allocation) to track a variable s location is conservative. \nThe impact of data flow anaty\u00adsis on the numkr of resident variables is significant, and our results \nclearly show that performing data flow analy\u00adsis to detect evicted and uninitialized variables increases \nthe number of variables that are correctly reported by the debugger. References [1] A. Adl-Tabatabai. \nSymbolic debugging of optimized C code. Unpublished draft from School of Computer Science, Carnegie Mellon \nUniversity, 1992. [2] A. V. Aho, R. Sethi, and Unman J. D. Compilers. Addison-Wesley, 1986. [3] T. Bemrnerl \nand R. Wismueller. Quellcode debugging von global optimierten programmed. Presented at 1992 Dagstuhl \nSeminar, Feb. 1992. (in German). [4] G. Brooks, G. Hansen, and S. Simmons. A new ap\u00adproach to debugging \noptimized code. In Proc. SIG-PLAN 92 Co@. on PLDZ, pages 1-11. ACM SIG-PLAN, June 1992. [5] G. J. Chaitin. \nRegister allocation and spilling via graph coloring. In Proc. of the SIGPLAN 1982 Sym\u00adposium on Compiler \nConstruction, pages 98-105, June 1982. In SIGPLAN Notices, v. 17, n. 6. [6] F. C. Chow and J. L. Hennessy. \nA priority-based coloring approach to register allocation. ACM Trans. on Programming Lunguages and Systems, \n12:501 535, Oct.1990. [7] M. Copperrnan. Debugging optimized code Current\u00adness determination with data \nflow. In Proc. Super\u00adcomputer Debugging Wortihop 92, Dallas, October 1992. Los Alamos National Laboratory. \n[8] M. Copperman. Debugging optimized code with\u00adout being misled. Twhnicrd Report 92-01, UC Santa Cruz, \nMay 1992. Register assignad variables Nonresident variables, residence determined by live range Nonresident \nvariables, residenee determined by . live range and reaching dataflow for uninitialized variables Nonresident \nvariables, residence determined Ea by dataflow for eviction Nonresident variables, residence determined \nby . dataflow for eviction and reaching dateflow for uninitialized variables (a) (b) (c) Figure 7: Number \nof evicted register allocated variables for three C benchmarks from the SPEC suite: (a) li , (b) WntotL \nand (c) espresso, [9] M. Copperman and C. McDowell. Detecting unex-[14] D. Wall, A. Srivastava, and \nF. Templin. A note pected data values in optimized code. Technical Re-on Hennessy s Symbolic debugging \nof optimized port 90-56, UC Santa Cruz, October 1990. code , ACM TOPLAS, 7(l): 176-181, January 1985. \n[15] P. ZMlweger. An interactive high-level debugger [10] M. Copperman and C, McDowell. A further note \nfor control-flow optimized programs. In Proc. of on Hennessy s Symbolic debugging of optimized the ACM \nSIGSOFi?/SIGPLAN So@ware Engineering code . Technical Report 92-24, UC Santa Cruz, April Symposium on \nHigh-Level Debugging, pages 159\u00ad 1992. 171. ACM, 1983. [11] D. S. Coutant, S. Meloy, and M. Ruscetta. \nDot: [16] P. Zellweger. Interactive Soure-tivel Debugging of A practical approach to source-level debugging \nof Optimized Programs. PhD thesis, University of Cal\u00adglobally optimized code. In Proc. SZGPZAN 1988 ifornia, \nBerkeley, May 1984. Published as Xerox ConJ on PLDI, pages 125-134. ACM, June 1988. PARC Technical Report \nCSL-84-5. [12] J. L. Hennessy. Symbolic debugging of optimized code. ACM TOPLAS, 4(3):323 344, July \n1982. [13] S. Simmons. Personal communication. 1992.  \n\t\t\t", "proc_id": "158511", "abstract": "<p>A symbolic debugger allows a user to display the values of program variables at a breakpoint. However, problems arise if the program is translated by an optimizing compiler. This paper addresses the effects of global register allocation and assignment: a register assigned to a variable V may not be holding V's value at a breakpoint since the register can also be assigned to other variables. We define the problem of determining whether a variable is in its assigned register as the <italic>residence</italic> problem. Prior work on debugging of optimized code has focused on the currency problem; detecting whether a variable's run-time value is the expected value. Determining residence is a more serious problem than currency detection. We present a data flow algorithm that accurately computes a variable's residency, by determining when a variable becomes <italic>evicted</italic> from its register. We measure the effectiveness of different approaches to determine variable residence for three C programs from the SPEC suite.</p>", "authors": [{"name": "Ali-Reza Adl-Tabatabai", "author_profile_id": "81100032153", "affiliation": "", "person_id": "PP14023844", "email_address": "", "orcid_id": ""}, {"name": "Thomas Gross", "author_profile_id": "81332502168", "affiliation": "", "person_id": "PP39077255", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158692", "year": "1993", "article_id": "158692", "conference": "POPL", "title": "Evicted variables and the interaction of global register allocation and symbolic debugging", "url": "http://dl.acm.org/citation.cfm?id=158692"}