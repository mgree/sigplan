{"article_publication_date": "03-01-1993", "fulltext": "\n functional programs and computational complexity Daniel Leivant Computer Science Department Indiana \nBloomington, leivant@cs. Synopsis. We develop two notions of stratified recur\u00adrence. The first is predicative \nrecurrence, and is similar to the use of levels in predicative (ramified) analysis. Our def\u00adinition is \nrelated to notions introduced in [Lei90,BC92], but it is conceptually unified and generic to all free \nalgebras, and it can use finite and transfinite levels. We show that the functions generated by finite \nlevel predicative recurrence over a free algebra A are obtained already using two levels, and are exactly \nthe functions computable by a register ma\u00adchine over A in time polynomial in the syntactic height of \nthe input. For the algebra W of words over a finite alpha\u00adbet, these are exactly the poly-time functions. \nWhen the medium of computation is the algebra N of unary numer\u00adals, then the functions generated by predicative \nrecurrence are exactly the numeric functions computable in polynomial space. These characterizations \nare purely functional, and use no speciaJ initial functions or bounding conditions. Moreover, in the \nresults for both W and N the polynomial degree cor\u00adresponds to the number of nestings of recurrence, \nif only two levela are used, and, more generally, to a certain count that combines recurrence and composition, \nif alJ finite levels are used. We further examine the result of introducing an impred\u00adicative ingredient \nin predicative recurrence, in the guise of level-coercion functions. We show that the nesting count of \nimpredicative recurrence provides a stratification of primi\u00adtive recursion (over the free algebra in \nhand). Combhing this with our predicative stratification, we obtain a purely functional classification \nof the primitive recursive functions, which for numeric functions is identical to Grzegorczyk s hi\u00aderarchy \nfrom level 3 and up, and which separates between polynomial and exponential growth of functions (a separa\u00adtion \nthat is lacking in the related functional hierarchy of Axt-Heinermann [Axt65,Hei61]). A related classification \nof the primitive recursive functions (over a free algebra A) is obtained by extending our pred\u00adicative \nhierarchy into transfinit e levela. Permission to copy without fee all or part of this materiel is grsnted \nprovided that the copies are not made or distributed for direct commercial advantsge, the ACM copyright \nnotice and the title of the publication and its date that copying is by permission of the Machinery. \nTo copy otherwise, or and/or specific permission. ACM-20th PoPL-1 /93-S. C., USA e 1993 ACM 0-~979j-56J \n.~/93/000j appear, and notice is given Association for Computing to republish, requires a fee j032~...+J \n.50  University IN 474o5 indiana. edu 1 introduction Applicative computational calculi are virtually \nas old aa the Theory of Computing: Church ahowed that the com\u00adputational power of the untyped Xcalculua \nis equivalent to that of Turing machines, and Gi5del and Herbrand showed that the same holds true of \nequational programs. Sepa\u00adrately, natural classes of total computable functions were defined or characterized \nin terms of recurrence over the natu\u00adral numbers, such as the primitive recursive functions (PR), multiply-recursive \nfunctions [Pet 66], and the provably re\u00adcursive functions of first-order arithmetic (G6del s system T \n[God58]). The applicative characterization of yet smaller computa\u00adtional complexity classea, ones that \nare relevant to Computer Science, has turned out to be more challenging. Such charac\u00adterizations are \neasy in the context of global queries over the class of all finite enumerated structures: e.g. unrestricted \nequational programs define exactly the poly-time queries [Saz80,Gur83], as do Datalog programa [Pap85], \nand equa\u00adtional programs in all finite types define exactly the functions computable in (Kalrnar-) Here \nwe are interested between computational computing over a single the natural numbers or elementary resources \n[Lei87,HS91]. in exploring the more subtle relation complexity and functional programs infinite canonical \nstructure, such as the words over {O, 1}. Cobham gave the first functional characterization of a complexity \nclaas, exhibiting an equational schema that gen\u00aderates precisely the poly-time functions over the natural \nnumbers [Cob65]. However, in Cobham a schema recurrence is replaced by recurrence on notations, the initial \nfunc\u00adtions include ad hoc functions, such as z#y =df 2 I=IIYI, and function growth rate ia bounded explicitly. \nAll these fea\u00adtures degrade the purely functioned nature of the definition of primitive recursive functions: \nthe schema of recurrence cor\u00adresponds to the inductive definition of the natural numbers, the initial \nPR functions are intrinsically related to the alge\u00adbra in hand and to explicit definition, and function \ngrowth rate is inherent in the definition of PR, and ia not super\u00adimposed. A new twist on applicative \ndefinitiona was introduced in [Lei90]. The underlying idea is that data objects are used comput ationally \nin different ways, correapondhig to different levels of data abstraction. Notably, words over {O, 1} \ncan be used as bit-wise memory, accessed locally , or u templates for recurrence. By explicitly sorting \nout the various uses of data, and requiring that each use of recurrence respect the resulting stratification, \none obtains definitions that cor\u00adrespond closely to major computational complexity classes, in particular \nPTime. Following [Lei91], and independently of [Lei90], Bellantoni and Cook have used the concept of \nstratification to obtain a functional characterization of PTime [B C92], t hat does away with the bounding \ncondition of [Cob65]. This work was continued in [B1092], who combined the use of 2 levels with the tree \n( divide-and-conquer ) recurrence of [C109O, CL90], to obtain subrecursive characterization of uniform \npoly-log depth. Data stratification underlies also the characteriza\u00adtions of PTime by set-existence principles \n[Lei91 ,Lei93], and by typed A-calculi [LM93]. A direct relation between proof theoretic stratification \nand computational complexity classes is developed in [Lei9?]. The main purpose of the present work is \nto transpose the stratification construction of [Lei90] to free algebras in a generic way, applying it \nsystematically to all levels and all free algebras, in particular to the algebra W of words over the \nalphabet {O, 1}. This leads to a purely functional characterization of PTime as the functions definable \nusing predicative recurrence over the algebra W of words. The use of only two levels in [BC92] is explained \nby the fact that additional finite levels do not increase the definitional power, though they do allow \nreplacing certain nested uses of recurrence by function composition. When recurrence over the algebra \nN of numerals is used, the functions definable by predicative recurrence are precisely the ones computable \nin polynomial space (where input size is taken for the binary represent ation). We further examine the \nresult of introducing an impred\u00adicative ingredient in predicative recurrence, in the guise of level-coercion \nfunctions. We show that the nesting count of impredicative recurrence provides a classification of all \nprimitive recursive functions (over the free algebra in hand). Combining this with our predicative stratification, \nwe ob\u00adtain a purely functional hierarchy of the primitive recursive functions, which for numeric functions \nis identical to Grze\u00adgorczyk s hierarchy from level 3 and up, and which separates between polynomial \nand exponential growth of functions. Such separation is lacking in the related functional hierarchy of \nAxt-Heinermann [Axt 65,Hei6 1], which counts nestings of (unrestricted) recurrence, because one recurrence \nleads from addition to exponentiation (2 +1 = 2X + 2 ). We also show that an analogous classification \nof the prim\u00aditive recursive functions (over a few algebra A) results from extending the predicative hierarchy \ninto transfinite levels. The use of transfinite levels is not as extraneous to compu\u00adtational complexity \nas it may first seem, since these levels are merely used as a bookkeeping method which, moreover, has \na finite representation (Cantor normal forms). As might be expected from other results relating ordinals \nto computabil\u00adity, full primitive recursion is recovered using predicative re\u00adcursion at levels up to \nLOW. 2 Predicative recurrence 2.1 Recurrence over free algebras The schema of recurrence (= primitive \nrecursion) over the natural numbers is one of the oldest and better known com\u00adputational schemas. A function \nf is defined bg recurrence from functions go and gs if f(o, q = go(q, f(s(n), F) = g.(f(n, 3), n, z) \n(where s is the successor function, aritg(f ) = aritg(go) + 1 = arity (Z)+ 1 = aritg(g. ) 1). The values \nf (n, Z) for n=o, l,... are computed successively, in tandem with the stepwise generation of n as a natural \nnumber, so the schema is a direct and natural reflection of the inductive definition of the set of natural \nnumbers, i.e. of the free algebra N gen\u00aderated using as constructors the constant O and the unary function \ns. Recurrence can be stated, more generally, for any free algebra A, generated from constructors c1 . \n. . ck (k > O), with aritg (c,) = r, ~ O. For example, the algebra W is generated from the O-ary c and \nthe unary functions O and 1; we identify each term with the corresponding word over {O, 1}; for example \n011 is identified with Ollc = O(l(l(c)))). Recurrence over an algebra A as above has k clauses, one for \neach constructor: f(ct(al . ..ar. ),Z) = gC, (f(al, F)... f(ar,, ~), d~~) We call the functions g=, the \nrecurrence-functions, the first r, arguments of get (as in the template above) the criticai arguments, \nand the first argument of ~ (in the template) the recurrence argument. In particular, recurre nce for \nW takes the form: f(c, i) = g,(z) f(ow, 2) = 90(f(% ~), w, ~) f(lw, z) = 91( f(w, J), %~) For example, \nif w is absent as a direct argument of the func\u00adtions go and gl, then where g$ and g?(z) abbreviate ge(Z) \nand g~(z, i), respec\u00adtively. Note that the recurrence argument of f is used here as a template for function \ncomposition. The PR functions over A are the functions defined from the constructors by recurrence and \nexplicit definition (i.e. using composition and projections).  2.2 Examples of recurrence The destructor \nfunction p and case function case for the algebra W are defined by: r(f) =f p(clv) = w C=o, l caae(e, \nw., wo, wl) = we case(cn, w., WO, wl) = w. C=o, l Addition and multiplication over the algebra N: +(0,z) \n= z -/-(WI,z) = S(-t(n, z)) X(o,$) = o X(sn, x) = +(z, X(n, z)) Concatenation and string 63(6, m) = @(cw, \n$) = 8(6, ~o,~l, G) = C3(o%$o, zl, q = C3(lw, xo, m, Z.) = multiplication over W: x c @ (w, z) C=o, l \n z. @l(zo, C3(w, zo, Zl, z.)) fB(m, C3(w, ~o,~l, G)) The function @ brings forth the use of the recurrence \nargument (the first) as a template . For example, @(One, ZO, Zl, z,) = ZOZICIZ, (concatenated). The exponentiation \nfunction T n = 2 over N is defined from addition by a single recurrence: f(o) =1 t(sn) = +(trl, Tn) \n 2.3 Predicative recurrence The well-established classification of infinite mathematical constructions \ninto finitistic, predicative, and impredicative, can also be applied to the terms of a free rdgebra. \nRecall that under the jinitistic approach infinite sets are considered as creations in progress, unbounded \nbut never completed. The predicative approach admits infinite sets as completed total\u00adities, which can \nserve as starting points for further construc\u00adtions of infinite sets; for example, once first-order definable \nsets of integers are admitted, one proceeds to admit sets definable using quantification over first-order \ndefinable sets. Centrrd to the predicative approach is the ramification of the construction of infinite \nsets into stages. Impredicative set definitions arise when the stages in the predicative con\u00adstruction \nare eliminated, i.e. coerced into a single entity, per\u00admitting set definitions that refer (e.g. via quantification \nor &#38;abstraction) to the very sets being defined. For example, the untyped A-calculus is obtained \nfrom the typed A-calculus by a coercion of all types into a single type, naive set theory is obtained \nby coercing the cumulative hierarchy of sets into initions, is familiar for sets of natural numbers. \nHowever, as pointed out by Nelson [Ne186], there is an impredicative trait already in the way that natural \nnumbers are used in induction and recurrence. The recurrence clause a single universe,l and impredicative \nanalysis is obtained by coercing the stages of set definitions in predicative analysis into a single \nstage. This contrast, between predicative and impredicative def\u00ad f(s(?z), i) = gs(f(n, F), n, q, is \nbased on the assumption that the function gs is well de\u00adfined for all natural numbers as critical arguments, \nand that ~(n, E) computationally reduces to a natural number. Thus the definition of $ proceeds through \nsteps, each of which refers to the totality of naturrd numbers. Clearly, such use of natural numbers \nss clocks selves to the set of all natural A predicative justification stratify the elements of a free \nplete analogy to the stratification for processes that refer them\u00adnumbers, is irnpredicative. of recurrence \nmust, therefore, aJgebra A into levels (in com\u00adof sets in predicative anal\u00ad ysis). At the bs.se level \nelements of A are considered as discrete, local , objects rather than as templates. E.g., a long w c \nW is used bitwise, as a store of binary values. The next level is the finitistic level, in which algebra \nelements are used as clocks or templates for recurrence that does not refer to the algebra as a whole. \nFor example, in the definition by recurrence of the concatenation function, @(c,x) = x @(cw, z!) = c \n@(w, z) C=o, l the recurrence functions go, gl are the constructors of the algebra, so the critical \narguments of these functions may be taken at the base level. Proceeding to generalize the latter step \nto a predicative progression, algebra elements of level w+l are used as recur\u00adrence arguments (i.e. templates \n) for recurrence-functions whose critical arguments are of level ~ n. This concept of distinct computational \nroles for terms a of a free algebra A can be captured algebraically as follows. One forms copies AO, \nAI . . . of the algebra A, where An con\u00adsists of the elements of A viewed as being of the n th abstrac\u00adtion \nlevel. One then forms the k-sorted structure sk (A), with AO, AI . . . Ak-1 as universes, where each \nuniverse has its own version of the constructors. Stratified (k-level) ap\u00adplicative computing over A \nconsists then simply of defining by recurrence, explicit definitions, and sorted composition, an expansion \nof sk (A). The formulation of predicative recurrence now follows from the underlying rationale of stratification \ninto levels. It requires that in a recurrence f (c,(al . ..ar. ), i?) = g.i(f(al, i). .. f(ari, ;), d,i) \n 1The ensuing paradoxes are repaired in ZF by modifying the schema of comprehension to separation. the \nlevel of the recurrence argument of ~ is higher than the level of the critical arguments of each gc, \n(when these argu\u00adments are present!). Note that the latter level is necessarily the same as as the level \nof the output of each gc,, for else the range of ~ is not well-defined. For example, a function f is \ndefined by predicative recur\u00adrence over the algebra W as follows. Let ~ =df W,l X.. . x W, V,g. :W~Wn, \nandgo, gl : w~xVV~XW--+w~, where m > n. Then wemay define f :W~ xW+ w. by f(c, z) = g.(z) f(ow, z) = \n90(f(w,~),~)~) f(lw, z) = gl(f(w, i), w, z). Note that if the critical argument of each of go, g] is \nabsent in their definition, then the stratification condition is vacuously satisfied. This is, for example, \nthe case for the definition of the predecessor function, p(sz) = x, in which the expression p(z) does \nnot appear in the definiendum (the r.h.s.). Examples of predicative recurrence Flat recurrence: The stratification \ncondition is vacuous, i.e. the critical arguments of the recurrence are absent. The functions p and case \nover W are defined by flat recurrence. Additive and multiplicative functions over the algebras N and \nW, as defined above. Note that + : NI x NO -+ No, whereas x : N] x N] a No. Similarly, @ : WI x WO*WO, \nwhereas@: WI XWIXWIXWO * WO. Consider again T n = 2 , defined by 2 +1 = 2 + 2 . Since the first input \nof addition must be at a level higher than the output, this recurrence is not predicative un\u00adder any \nassignment of levels to the arguments and re\u00adsults, A similar argument shows that the definition of exponentiation \nvia multiplication is not predicative. Consider the cubic function n3 = x(n, x(n, n)) We can stratify \nthis definition by $aking the inner mul\u00adtiplication to be a function of type Nz x Nz ~ N1, and the outer \none of type Nz x N1 -+ No. However, the cubic function can be defined using only levels N] and NO, though \nat the cost of iterated recurrence, as we demonstrate momentarily. For a term a, let [al denote the height \nof the parse-tree of a. LEMMA 2.1 Let A be a free algebra, and let f : A! X A? + A, be defined using \nk predicative recurrences over AO, Al. Then there -ar~ c, d > 0 such that, for every al ...ak, bl ...b~. \nIf(a, b)l < c .~~ +~0 + d, where fl df max(lall . . . [akl), and 10 =df max(]b,l . . . lb~[). Proof. \nBy induction on the definition off. a TIIEOREM 2.2 nk is defined using k predicative recurrences over \nA., Al, but not by using only k 1 such recurrences. Proof. For k > 0, the functions tp~(yl . . . ~k, \nz) =di W?U, + z, with tp~ : (NI) x NO ~ No, are defined J2 by successive instances of two-level predicative \nrecurrence, as follows. (We take the empty product to be 1, as usual.) tpo(z) = Sz; tpk+l((),~z ...g~,~) \n= X, tP~+l(SV,y2...V~,z) = tph(?/2... k,tpk+l(l (,?121?4k, ~4k,~ )) Conversely, Lemma 2.1 implies that \nnk cannot be defined by less than k instances of two-level predicative recurrence. o  2.5 Simultaneous \nrecurrence There are several variants of recurrence, such as recur\u00adrence with parameter substitution \nand simultaneous recur\u00adrence, which are reducible within PR to plain recurrence (see e.g. [Ros84]; the \nreductions are, in fact, Kalmar\u00adelement ary). Such reductions are far more problematic with\u00adout the sequence \ncoding power of (Kalmar-) elementary func\u00adtions. In particular, we shall make explicit use of the schema \nof simultaneous recurrence. For the algebra W this variant of recurrence defines simultaneously a pair \n(f 0, f 1) of func\u00adtions by f (e, i) = g;(i) f (ow, F) = 9:( f (wj ~), fl(w, ~),w, ~) ft(lw, i?) = 9:( \nf (w! ~)! fl(w! ~)1 w! ~) The predicative form of this schema requires that the each recurrence argument \nbe of higher level than the level of each critical argument. 3 Predicative recurrence and computational \ncomplexity 3.1 Register machines over free algebras In comparing functional definition to computational \ncom\u00adplexity classes we shall use, as machine model, register ma\u00adchines over free algebras. This choice \nhas two motivations. First, this model is generic for all free algebras, thereby per\u00admitting generic \nconnections between functional computing and machine models. A second motivation is that some of our \nresults refer to the degree of polynomials, which are sen\u00adsitive to the choice of machine models, and \nwhere register machines yield the best correspondence with functional com\u00adputing. Let A be the free algebra \ngenerated from constructors c1 . . . ck, with arity(c, ) = r,. A register machine over A is a computational \ndevice M with: 1. a finite set S = {s1 . . . sn} of states, of which S1 is the initial state and Sn is \nthe accepting state; 2. Afinite list 11=~1 . . . r~ of registers (i.e. distinct iden\u00adtifiers);   3. \nA (finite) collection of commands, where a command is of one of three forms: (a) (b) (c)  (Each latter \nbranching command, of the form s,r,s,, . . . s,,, constructor command, of the form s$r~l . . . 7rJr, \nC,7reSrj p-destructor command, of the form s,rlrts~, where p ~ max(r~),=l..,~. command is labeled with \nits type, which in the case includes the integer p.) The register machine is deterministic if for every \ns c S there is at m-ost one command that starts with s. The operational semantics of commands as above \nis: 1. for branching commands: when in state Si, switch to state sil or . . . or si~, according to whether \nthe main constructor of the algebra term in register rj is c1 or ...orc~;  2. for constructor commands: \nwhen in state s,, store in register re the term resulting from applying the con\u00ad st ruct or c, to  \n3. for destructor register ~1 the ~j, if it exists,  A conjigw-ation of the values stored in registers \nTj ~ . . . n~,, . commands: when in state s,, store in p-th immediate subterm of the term in otherwise \nstore the term in ir~. M is a pair (s,F) where s E S and F: II~A. Wewrite[uO . . . u~] for the F : II \n+ A defined by F(~,) = w. M induces a transition relation l-~ on con\u00adfigurations, where ~ KM / holds \nif there is a command of M whose operational execution sa above converts configuration K to K . Fix some \nconstant constructor value (e.g. O for N, c for W). A (al ...a,) (r < m) is a sequence with (SO, Fo), \nwhere Fo(T, ) =df where each configuration except d of A as canonical default computation of M on input \nof configurations, starting if z < r then a, else d; the last is related to its successor by I-M, and \nstat e. For each r < the multivalue-function maps ii c A to those M on input ii, whose where the last \nconfiguration has s~ as m the register machine M determines (i.e. relation) [M]r : A -+ A, which b s \nfor which there is a computation of end configuration (s., G) is such that G(~n ) = b. Of course, one \nis interested mainly in the cases where [M]r is a partial function.2 As an aside, note that for algebras \nwhere all constructors have arities < I (such as the algebra W), the definition of a register machine \ncan be simplified: the constructor and de\u00adstructor commands can be stated so that they use the same register \nfor both input and output. Using this restrict ed form of those transitions, plus branching commands, \none can re\u00adbuild the inverse of the contents of a register m in a register #; by applying this inverse-copying \noperation again to # we get a copy of K in m ; finally, applying a constructor c within m yields the \neffect of storing in ~ the result of applying c to the contents of m. zThese register madnes are similar \nto the first order pointer machines of [Lei87J, operating over A expanded with a discrimi\u00adnator function \nand destructor functions. 3.2 Functional characterization of PTime THEOREM 3.3 Let A be a free algebra, \nf a function over A. The following are equivalent: 1. f is computable by a register machine in time polyno\u00admial \nin the maximal height of the inputs. 2. f is definable by predicative recurrence over AO and Al. 3. \nf is definable by predicative recurrence over arbitrary A, s, i >0.  In fact, we shall prove a refinement \nof the theorem above. DEFINITION 3.4 The recurrence-nesting degree of a predict\u00adively defined function \nf : Ail x.. . x A,. + A,O is a natural number 6(f) defined by (met amathematical) the length of the definition \noff, as follows. If f is a constructor or a projection, then * Suppose f is defined by composition, g(hl(i!),..., \nhq(;), E), where hi,.. ., hP whose output is of level put of g; then 6(~) = 6(hp), 6(hp+l), . . . . qhq)). \n Suppose f is defined by where (say) g.,,..., g., and gCP+l, ..., gc~ don t; $(9CI),.. ., 1 + 6(9cp),9cp+1 \n> the level recurrence on 6(f) =0. f(i) = are those hJ s of the out\u00ad max( 6(g) + 6(hl) + ... + recurrence \nfrom g., . . . gc~, use critical arguments, then ~(f) = max( 1 + j.. .j9ck). Using this definition we \ncan state a refinement of Theorem 3.3: THEOREM 3.5 Let A be a free algebra, f a function over A. The \nfollowing are equivalent: 1. f is computable by a register machine over A in time O(nk ), where n is \nthe ma~ ma.1 height of the inputs. 2. f is definable by predicative recurrence over with < k instances \nof non-flat predicative appfied to functions over A..  3. f is definable by predicative recurrence over \nwith < k instances of non-fiat predicative (and sorted explicit definitions).  AO and AI, recurrence, \nAO and Al, recurrence 4. f is definable by predicative recurrence over any Ai s, ~ ~ O, with c$(f) ~ \nk. (and sorted explicit definitions,). For the case A = W these results imply that a function f over \n{O, 1}* is computable in deterministic polynomial time M it is definable by predicative recurrence over \nWO and W1, iff it is definable by predicative recurrence over arbitrary W, s (2 > o). Theorem 3.3 improves \non the main theorem of [BC92] in eliminating the need for initial functions extraneous to the algebra \nW, in providing a calibration of polynomial degrees (in the polynomial time bounds) for a natural machine \nmodel in terms of nesting of recurrence, and in being generic to all free algebras. Also, our result \nthat the use of levels beyond the first two does not increase the class of functions shows directly why \nthe functions definable predicative recurrence over two levels are closed under composition. Cobham s \nrecursion on notation falls out in our charac\u00adterization simply as the natural form of recurrence for \nW. Although technically trivial, our shift from recurrence over natural numbers to recurrence over W \nis fruitful from a CS viewpoint, as it allows a more natural relation between ap\u00adplicative and imperative \ndefinitions of computational com\u00adplexit y. We prove Theorem 3.5, from which 3.3 ensues, as follows. In \nLemma 3.7 we show that (1) implies (2). (2) implies (3) trivially. A function j, with the kind of definition \ndescribed in (2), clearly has J(j) < k, so (2) also implies (4). In Lemma 3.8 we prove that (4) implies \n(l). The proof of 3.8 also shows that (3) implies (l).  3.3 Functional simulation of PTime It is straightforward \nto define, using only flat recurrence, functions that simulate register machine transitions. Con\u00adsider, \nfor the sake of specificity and simplicity, the algebra A = W. For a register machine M over W as above, \nlet #s, =d~ 0 6 (i.e. a code for s,). LEMMA 3.6 Given a deterministic register machine M as above, there \nare m+l (m+l)-ary functions ro, rI, . . . , Tmj defined using only flat recurrence, and such that, if \nM has a transition rule for state s, then (s, [u1, . . . . u~]) l-~ (s , [u;,... ,u~])&#38;r,(#s, wl,..., \nu~)=u~fori=n2,. n2, and ~o(#s, ul, ..., un) = #s ; and if M has no such transi\u00adtion, then T,(MO . . . \num) = u,. Proof. Note that each u; (j = 1... m) is either U$, ~, O(u~), l(uQ), or p(ug), for some p = \n1 . . . m. Also, the appropriate case for the u; s and for the state-code argument #s can all be determined \nfrom the input using the function case. Since the functions c, O, 1, and p and case are all definable \nby flat recurrence, it follows that the functions TO . . . ~m are also defined using only flat recurrence. \nu LEMMA 3.7 If a function f over a free algebra A is com\u00adputable on a register machine M in time < c \n. nk + d, then it is definable by k instances of predicative recurrence over AO and AI, applied to functions \nover AO. Proof. We prove the lemma for A = W. The general case is similar. Suppose M has registers xl \n. . . zrm and states S1 . . . sC. We define functions Ujq of q+rn+l arguments (j= o . . . m,q=l . ..k), \nsuch that a~~(yl . ..y~. #s, ul,... u~) is the value of ir~ after Iyl I x. . . x ]y~l execution steps \nof M starting with configuration (s, [al . . . u~]) (j = 1 . . . m), and ~oq (?/1 . ..~q. #s, u],... \nU~ ) is the code of the resulting state. The definitions are by simultaneous predicative recurrence, \nusing the functions TJ of Lemma 3.6, and emulating the definition of the functions tpi in Theorem 2.2. \nLet ii = (uO,... ,u~), and J= (yz,..., vq). C7jl(c, 27) = UJ ajl(cw, il) = 73(71 (w, q) where &#38;l(w, \nif) = (Uol(w, il) , . . . . Uml(w, zl) ) U3M+I (~1z O = UJ ~~,q+l (Cw! !z ~) = Uwl(?l ~q+l (W ?) J)) \nwhere ~q+l(w>lz ~) = ( Uo,q+l(w, !7, q, . . . ,C7m,q+l(w, ~, i) ) If M runs in time s nk, then f(u) \n= . . . ,One,#sl, u, t, ,.. 6). C7mk(onc, If. M runs in time < c.nk+d, say c = d = 2, then we modify \nthe construction above by setting ajl(%z) = 7J(70(Z), . . . . rm(ii)) and ajl(cw, ti) = Tj (To(d(w, Z)), \n. . . Tm(a(w, i))) 1 Note that we cannot simply compose the single-step tran\u00adsition functions with a \npolynomial clock, because the output of a polynomial function is two levels lower than its input! 3.4 \nRegister machine simulation of predicative recurrence LEMMA 3.8 Ifafunction f :A,l x... xA,, -+A, isdefin\u00adable \nby predicative recurrence, with 6(f) < k, then f is com\u00adputable on some register machine M over A such \nthat, for certain constants c, d, f (ii) is computable in time s c. nk + d, where n = max {Iujl I level(uj) \n> i}. Proof. Again, consider the case A = W; the general case is similar. The proof is by induction on \nthe definition of f. The cases where j is a constructor are trivial. Suppose f is defined by composition, \nsay ~(z) = g(ho(i?), hi(i), i?), where E = (ZO, xl, X2, Z3). Let 1, be the level of x,, and m., ml, m \nthe respective levels of the out\u00adputs of hI, IU and g. For the sake of generality, assume i. s m. < 11~ \nm < 12s ml < 13. Then, by induction assumption, there is a register machine Mg that computes 6(9)+ d, \nwhere m = g(uo, ul, i?) in time c . m max(lul{,lszl,lzsl); there is a register machine MO that computes \nhO (Z) in time co . m. 6(h0) +do, where mo = max(lml, Iz21, lz31)~ and ho (Z) is therefore of height \n< n + co . m.6(h0) + do; there is a register machine Ml that computes hl (3) in time c1 . m$hl) + dI, \nwhere ml = Iz,l, and hi(;) is d(~l) + &#38;. therefore of height < n + c1 . ml It is easy to combine \nthe three machines into a single machine M for ~, that computes ~(;) by first computing the values of \nho and hl, and then computin g for the results. This %@+ &#38; +., .m:@l) +computation runs in time < \nco . m. dl + c.16fgJ+d where.! = max(n+cl. rnl6@ )+dl, Ixzl, 1$31). Thus, the computation is in time \n~ c . nstf) + d , with c df co + c1 + c , 6(g)! . C:(9J. (dl+l)b(g) and d =df do+ dl +d. Suppose that \nf is defined by predicative recurrence, with the recurrence argument of level j: f(e, ;) = g.(z) f(ow, \nii) = go(f(w, Z), w, i) f(lw, ii) = g,(f(w, ti), W, J). By induction assumption there are register machines \nMC, M. and Ml, with corresponding constants cC,de, co, ddo, CI, I and the required properties. Note that \nthe output levels of f, g~, go and gl are all i. Let c =df max(co, c1) and d =df max(do, dl ). It is \neasy to combine the three ma\u00adchines into a single machine for f, that after initializing us\u00ading M,, runs \na loop on the first input that simulates M. or Ml according to the successive characters of the recur\u00adrence \nargument. M runs some kO initial steps, and some k] set-up steps for each loop. So M computes ~(w, i, \nd) in time </c.+ cc.nk+dc+ Iwl.(lq +c .nk-l +d ), where n = max(lull . . . la,, 1,Iwl). Taking c =df \nc, + klc + d and d =df k. + de, we have that M computes ~(w, d, F) in time <c. nk+d. o 3.5 Predicative \nrecurrence over the algebra of unary numerals The following is essentially proved in [Gur83]. LEMMA \n3.9 Let f be a function over N. If f is computable by a register machine in time T(n) (where n is the \nsize of the uraarg input) then it is computable in space log(T(n)) on a multi-tape TM. If f is computable \nin space S(n) on a multi-tape TM (where n is the size of the binarg input) then it is computable in time \n2s( )2 on a re~ ster machine over N. Combining this with Theorem 3.5, we have: THEOREM 3.10 A numeric \nfunction is definable by predica\u00ad tive recurrence over the algebra N of unary numerals if it is poly-space, \nProof. If a numeric function f is definable by predica\u00adtive recurrence, then it is computable by a register \nmachine in time polynomial in the value of the input (i.e. it size in unarg), by Theorem 3.5. That is, \nf is computable in time 0(2 ) for some k, where n is the size of the input in binary. By Le~ma 3.9, \nthis implies that f is computable in space log(2n ) = nk. Conversely, if f is computed on a multi-tape \nTM in space O(nk ), where n is the size of input in binary, then it com\u00ad putable in time 0(2 2k ), by \nLemma 3.9. That is, f is com\u00ad putable in time 0(n2k ) where n is the size of the input in unary. Thus, \nby Theorem 3.5, f is definable by predicative recurrence. a 4 Extensions of predicative recurrence The \npredicative nature of recurrence can be mitigated in at least two distinct (though related) ways: using \nlevel\u00adcoercion functions, and extending the hierarchy of levels into the transfinite. We describe both \nmethods, and state the main results. 4.1 Coerced stratified recurrence The schema of (simultaneous) predicative \nrecurrence, say f(c, Z) = g,(z) f (Cw, i) = gc(f(w, ?q, w, t) c = 0,1 requires that the level of the \ncritical input of each g= be identical to the level of the output. If the critical inputs of each g~ \nare in W,+l, and the outputs in W:, then, for each specific w c W,+lwl, ~(w, Z) can be obtained (by Iwl \ncompositions), but no fixed level can be assigned to the re\u00adcurrence input. Suppose now that we had coercion \n~unctioras, ~j :W~ ~ W,+l, where ~: maps w c Wi to w GW,+l. Then we obtain a correctly stratified definition \nby recur\u00adrence: f(c, Z) = g,(i) f(cw, d) = K,gc(f(w, d), w, ?7) c =0,1. We call this form of recurrence \ncoerced recurrence. Clearly, we have PROPOSITION 4.11 Let A be a free tdgebra. A function over A is definable \nusing coerced recurrence and explicit defini\u00ad tions if it is PR over A. Thus, we can calibrate the complexity \nof all PR func\u00adtions over A by counting the nestings of instances of co\u00aderced recurrence. The seminal \nclassification is Grzegor\u00adczyk s Hierarchy [Grz53]: P7? = Un ~n, where &#38;n is gener\u00adated by composition \nand bounded recursion from the func\u00adtions constant-zero, successor, projections, and Gn, where G1 is \naddition, G2 multiplication, G3 exponentiation, and G~+I (z) = G~)(2) (z iterations) for n z 3. (See \ne.g. [ROS84] for exposition.) However, Grzegorczyk s definition is somewhat ad hoc, in the boundhg condition \nand in the choice of initial func\u00adtions. Consequently, alternative subrecursive hierarchies are of interest. \nA natural hierarchy, proposed in [Hei61 ,Axt 65], classifies PR by iterated recursions: P9Z = u= Rn, \nwhere R consists of functions generated by composition horn the initial functions, and R + 1 consists \nof the functions gener\u00adated by composition and at most one recursion from func\u00adtions in 7?n. Schwichtenberg \nshowed that 7? = &#38; +l for n ~ 3 [Schw69], and Miiller showed that this holds also for n = 2, provided \nsimultaneous recurrence is used [Mu173]. In addition to being a natural classification of IV? for nu\u00admeric \nfunction, nesting of recurrence is a natural calibration of computing over azbitrary free term algebras. \nUnfortu\u00adnately, this classification does not separate polynomial from exponential functions, since both \nlie in 7?-2.This is a signifi\u00adcant drawback, because the demarcation between polynomi\u00adals and exponential \nfunctions is computationally crucial. DEFINITION 4.12 The sets C:[A], of PR junctions ouer A Of predicativity \nleuel i, are defined as follows. Cl [A] consists of the functions defined using no nesting of non-flat \nrecurrences; C.z[A] consists of the functions defined using only pred\u00adicative recurrence; If f is defined \nby coerced recurrence from functions 9CI, ....gck, of which gcl ...gcp say are those that use their critical \nargument, and g., c Cj, [A], then f c C/[A], where 1= max(l+jl, . . . . l+jP, jP+l . . . . j~). Each \nC~[A] is closed under composition, and for i >2 aJso under predicative recurrence. THEOREM 4.13 For k \nz 3, Ck[N] = 15k. In particular, a nu\u00ad meric function is Kalmar-elemen tary (i.e. compu t able within \n,* resources 22 , with a fixed nesting of exponentiation) iff it is defined using coerced predicative \nrecurrence, but without nestings. Note that simultaneous recurrence is no longer needed, be\u00adcause pairing \nand projection functions are available at that level (cf. [Ros84]). Theorem 4.13 provides a purely functional \ncharacteriza\u00adtion of a Grzegorczyk-like hierarchy, which: (1) is free of extraneous initiaJ functions \nand bounding conditions; (2) is generic for all free algebras; (3) yields computationally sig\u00adnificant \nclasses for lower levels; (4) has no jump from the linear to the exponential level, w in the Axt-Heinermann \nHierarchy.  4.2 Transfinite predicative recurrence Another extension of predicative recurrence is obtained \nby extending the stratification of a free algebras into transfinite levels. The levels A, of a free algebra \nA are intuitively a decreasing chain, since a c A,+ I can be used anywhere for a E A,. Suppose we had \nAu = fit A,. Then a G Au can be used wherever a c Ai is. Moreover, if f c Pi?(A) has a predicative definition \nas f : A,+ I -+ A,, then f has a predicative definition with domain A;+l+j and range Ai+j, for all j \n(since all levels in the predicative definition off can be lifted by j). Thus, f may be regarded as f \n: Aw + AU. This intuition can be captured formally as follows. Recall that the canonical fundamental \nsequence (cr,),21 of an ordinal cv+ w is obtained from the Cantor normal form for a: ifa is a limit, \nthen that form is w d.+.. .+w o .o?o, where d$6NandrO>0, anda,=dfwF .d$+... +Wro. (do -1)+ J - .2. Let \na + W . A stratification of A up to cr is a transfinite sequence AO . . . AP . . . (/3 + CY). Consider \na definition of a function f by recurrence, f(C:(Ul . . . a,t), i?)= g., (f(al, i?) . . . f(a,,, 7), \nZ,F). We define, by ordinal recurrence on -y, what it means for this definition to be a predicative \nrecw-rence of type A@ x A + A7 (where A = A@, x... x A@r ). This is the case if either @> Y, and each \ngc, has a definition by a predicative recurrence of type A? x d + A7, or if /3 = y is a limit ordinal, \nand for every j ~ O, each g., has a definition which is a predicative recurrence of type A@ x A * A@,. \nLet Ta [A] be the set of functions (in PR(A)) that are definable from the constructors of A using predicative \nre\u00adcurrence up to a, and (correctly sorted) explicit definitions. THEOREM 4.14 TW. [A] = Cn+I, for n \n> 1. Hence 7U. [N] = E +l, for nz 2. Comments. 1. Note that the definitions by recurrence considered \nhere are usual, finite, PR definitions. Only the conditions on their predicativity use transfinite ordinals. \nThe definition of predicative recurrence for arbitrary free algebrzw is similar. 2. The concept of finite \ndefinitions with predicativity con\u00additions expressed in terms of transfinite ordinals has been used for \nfunction represent ation in typed A-calculi [Lei90a]. 3. The stratifications of recurrence studied above \ncan be ex\u00adtended to higher type functional [Lei9?a], in which case all ordinals < co are used for transfinite \npredicative recurrence, and the functions over A obtained are all the provably re\u00adcursive functions of \na Peano theory for A (the analog for A of Peano Arithmetic).  5 References Axt65 P. Axt, Iteration of \nprimitive recursion, Zeit. fiir mathematische Logik u. Grundlagen d. Math 11 (1965) 253-255. 13C92 Stephen \nBellantoni and Stephen Cook, A new recursion-theoretic characterization of the poly-time jrmctiom, to \nappear in Computational Complexity 1992. B1092 Stephen Bloch, Functional characterizations of uni\u00adform \nlog-depth and polylog-depth circuit families, to ap\u00adpear in the Proceedings of the 1992 IEEE Conference \non Structure in Complexity. CKS81 Ashok Chandra, Dexter Kozen and Larry Stock\u00admeyer, Alternation, Journal \nof the ACM 28 (1981), 114-133. CL90 Kevin Compton and Claude LaFlamme, An algebra and a iogic for N~, \nInformation and Computation 87 (1990) 241-263. C109O Peter Clote, Sequential machine-independent char\u00adacterizations \nof the pamllel complexity classes A LOG-TIME, A&#38;, N@ and NC, in Samuel M. Buss&#38; Philip J. Scott \n(eds.), Feasible Mathematics, Perspectives in Computer Science, Birkhauser-Boston, New York (1990). \nCob65 A. Cobham, The intrinsic computational dijjiculty Of ttmctions, in Y. Bar-Hillel (cd.), Proceedings \nof the International Conference on Logic, Method\u00adology, and Philosophy of Science, North-Holland, Amsterdam \n(1962) 24-30. Gi$d58 Kurt G6del, Uber eine bisher noch nicht benute Erweiterung des finiten Standpunktes, \nDialectic 12 (1958), 280 287. Republished with English transla\u00adtion and explanatory notes by A. S. Troelstra \nin Kurt Gi5del: Collected Works (Oxford University Press, 1990), vol. II, ed. S. Feferman. Grz53 A, Grzegorczyk, \nSome classes of recursive functions, Rozprawy Mate. IV, Warsaw, 1953. Gur83 Yuri Gurevich, Algebms of \nfeasible functions, Twenty Fourth Symposium on Foundations of Computer Science, IEEE Computer Society \nPress, 1983, 210-214, Gur87 Yuri Gurevich, Logic and the challenge of Computer Science, in Current Trends \nin Theoretical Com\u00adputer Science, (Egon B6rger, editor], Computer Sci\u00adence Press, 1987. Hei61 W. Heinermann, \nUntersuchungen tiber die Rekur\u00adsionszahlen rekursiuer Funktionen, Dissertation, Uni\u00adversit at Munster, \n1961. Lei87 Daniel Leivant, Descriptive characterizations of com\u00adputational complexity, Journal of Computer \nand System Sciences 39 (1989) 51 83. Revised and ex\u00adpanded from Second Annual Conference on Struc\u00adture \nin Complexity Theory, IEEE Computer Soci\u00adet y, Washington, 1987, 203-217. Lei90 Daniel Leivant, Subrecursion \nand lambda represen\u00adtation over free algebms (Prelirnhary Summary), in Samuel M. Buss &#38; Philip J. \nScott (eds.), Feaai\u00adble Mathematics, Perspectives in Computer Science, Birkhauser-Boston, New York (1990) \n281-291. Lei90a Daniel Leivant, Discrete Polymorphism, Proceed\u00adings of the Sixth ACM Conference on LISP \nand Functional Programming, 1990, 288-297. Lei91 Daniel Leivant, A foundational delineation of com\u00adputational \nfeasibilit~, in Proceedings of the Sixth IEEE Conference on Logic in Computer Science (Amsterdam), IEEE \nComputer Society Press, Wash\u00adington, D. C., 1991. Lei93 Daniel Leivant, A foundational delineation of \npoly\u00adtime, to appear in the LICS 91 issue of Information and Computation. Lei9? Daniel Leivant, Predicative \nPeano theories, to ap pear. Lei9?a Daniel Leivant, Predicative recurrence in finite types, to appear. \nLM93 Daniel Leivant and Jean-Yves Marion, Lambda\u00adcalculus characterizations of pol~-time, Fundamental \nInformaticae (1993). Mu173 H. Miiller, Characterization of the elementar~ func\u00adtions in terms of depth \nof nesting of primitive recur\u00adsions, Recursive Function Theory Newsletters (1973) 14-15. Initially reported \nin Dissertation, Uni\u00adversitat Miinster, 1973(?). Pap85 Christos Papadimitriou, A note on the expressive \npower of PROLOG, Bull. EATCS 26 (June 1985) 21 23. Pet66 R6sza P6ter, Rekursive Funktionen, Akad&#38;niai \nKiad6, Budapest, 1966. English translation: Recur\u00adsive Functions, Academic Press, New York, 1967. Ros84 \nH.E. Rose, Subrecursion, Clarendon Press (Ox\u00adford University Press), Oxford, 1984. Saz80 Vladimir Sazonov, \nPolynomial computability and re\u00adcursivitg in finite domains, Electronische Informa\u00adtionsverarbeitung \nund Kybernetik 7 (1980) 319\u00ad 323. Schw69 Helmut Schwichtenberg, Rekursionszahlen und die Grzegorczyk-Hierarchic, \nArcWlv fir mathematische Logik 12 (1969) 85-97.  \n\t\t\t", "proc_id": "158511", "abstract": "", "authors": [{"name": "Daniel Leivant", "author_profile_id": "81100590610", "affiliation": "", "person_id": "PP39074955", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158659", "year": "1993", "article_id": "158659", "conference": "POPL", "title": "Stratified functional programs and computational complexity", "url": "http://dl.acm.org/citation.cfm?id=158659"}