{"article_publication_date": "03-01-1993", "fulltext": "\n Extending Record typing to type parametric modules with sharing Maria Virginia Aponte Conservatoire \nNational des Arts et M~tiers and INRIA * Abstract We extend term unification techniques used to type \nex\u00adtensible records in order to solve the two main typing problems for modules in Standard ML: matching \nand sharing. We obtain a type system for modules baaed only on well known unification problems, modulo \nsome equational theories we define. Our formalization is sim\u00adple and has the elegance of polymorphic \ntype disciplines based on unification. It can be seen as a synthesis of previous work on module and record \ntyping. Introduction Building programs from modules can be safely done only if modules can be connected \ncoherently. The dif\u00adficulty of module coherence checking depends on the complexity and power of the module \nsystem consid\u00adered. The SML module system [5, 7] is, among the modular programming languages with decidable \ncheck\u00ading, the most expressive existing one. SML modules allow multiple but consistent views of the same \nmodule (sharing), and parametrization of a module (functors) by a module specification (signatures), \nand they can be typed statically. Moreover, the module language it\u00adself is largely independent of the \nSML core language, and therefore provides a starting point to build module systems for many different \nprogramming languages. Previous work on the static semantics of SML mod\u00adules had been based on special-purpose \nterm algebras to represent modules and on specific and complex static semantic notions [3, 7, 6], or \ndoes not address sharing nor multiple views of modules [4]. We show here that, this static description \ncan be completely expressed by classical typing techniques such as polymorphic typ\u00ading and the techniques \ndeveloped to type extensible *Author s address: INRIA Roquencourt, Projet Formel, B.P. 105, 78153 Le \nChesnay, France. E-mail: Maria .Aponte\u00adGarcia@inria.fr Permission to copy without fee all or part of \nthis material is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the title of the publication and its date appear, and notice is given that \ncopying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, \nrequires a fee and/or specific permission. ACM-20th PoPL-I /93-S. C., USA @ 1993 ACM o-89791 -561 -5/9310001 \n/0465 . ..$l .50 records. Moreover, our type discipline leads to efficient typechecking algorithms, thanks \nto a local formaliza\u00ad tion of module consistency verification. Finally, in our discipline the exclusion \nof defective signatures comes for free. This stands in contrast with previous type systems, where static \nsemantic constraints are globally imposed on inferred types in order to reject defective signatures. \nIn our system, these conditions are ensured directly by the unification process. We adapt the algebra \nof extensible record types pro\u00adposed by R6my [8, 10] to encode the types of modu\u00adlar objects, and extend \nits equational theory to per\u00adform unification on the terms obtained. The two main problems in module \nchecking matching a structure against a signature; finding types for signatures contain\u00ading sharing \nconstraints are then expressed as uni\u00adfication problems modulo certain equational theories. We show \nthat both problems have a principal solution whenever they have a solution. We then reformulate the module \nchecking problem as a type system using these results. For this type system, we easily obtain a result \non principal signatures, the equivalent of the prin\u00adcipal type result for the ML core language. Finally, \nwe show that principal signatures are no more than prin\u00adcipal solutions for the problem of typing a signature \nby unification. We start by presenting an overview of the typing problems related to SML modules. In \nsection 3 we present the module language. In section 4 we discuss the analogies between record types \nand modules and present R&#38;my s extensible records and our language of module types. In the next two \nsections we give our solutions for the mat thing and the sharing problems. In section 7 we present a \ntype system for modules and results on principality, consistency and defective signa\u00adtures. 2 Overview \nof SML modules typing problems Many modular languages have some form of encapsula\u00adtion of types and values. \nThis kind of basic module is called a structure in SML. Some languages also have pa\u00adrametrized modules, \nwhich are called functors in SML. A functor takes structures as arguments and produces structure S = \nstruct datatype t = C of int funts(cx) = C(x+l) structure A = struct . end end; signature Z = s ig type \nt valts:t+t end structure S = S : Z; Figure 1: Example ofa signature constraint structures as results. \nWhen parametrizing a functor by a structure variable, a specification of the structure components must \nbe provided; in SML, the specifica\u00adtion for a structure is called a szgnature. 2.1 Signature Matching \nA structure and a signature can be matched when the former satisfies the type specifications of the latter. \nFol\u00adlowing the requirements of independence in modular de\u00advelopment, it must be possible to have structures \nricher than their specifications, and also several views of the same structure. Then, a signature can \nbe matched against a richer structure, resulting in a constrained view of that structure. Another way \nof constraining a structure is by matching it against the signature of a functor argument. Figure 1 shows \nan example of a structure S and a signature Z that can be matched successfully. The resulting structure \nS k a view of S where the sub-structure A is absent. 2.2 Polymorphism and generative typ\u00ading ML is a \nlanguage with generative typing: two differ\u00adent type declarations produce two incompatible types. Each \ntype constructor in ML is associated with a unique mark, or stamp, which is fixed through the program \nlife. Type equality is determined by comparing type stamps. The notion of type stamps is naturally extended \nto stamps in structures. Each structure declaration has a new stamp assigned (for instance, the structure \nS in fig\u00adure 1). Nevertheless, constrained structures keep their original stamp: different views of the \nsame structure share the same stamp. Thus, the type of a structure can be represented by its stamp together \nwith the representations of its com\u00adponents. Figure 2 shows a picture of a possible repre\u00adsentation of \nstructures S and S . Stamps m, n, and p are drawn inside circles, while components appear on arcs. In \nthis paper, since we do not consider the typing of objects from the core language, we omit their type \nrepresent ation, and draw them as filled circles. This represent ation is both intuitive, and very near \nfrom the encoding of structures proposed by Harper, Milner and Tofte. As we shall see later, our encoding, \nwhich car\u00adries information, can be more advantageous checking module coherence. Signatures can be represented \nin a similar fashion. The only difference is that stamps are no more fixed, but can take many stamp values \nwhen matching dif\u00adferent structures. Intuitively, a signature can be seen as a structure where stamps \nare universally quantified variables. Roughly speaking, one can consider struc\u00adture and signature types \nin modules, respectively as the equivalent of simple types and type schemes in the core language. This \nelegant analogy was first proposed by Harper, Milner and Tofte [3] when describing the semantics of SML \nmodules. Figure 2 shows a represen\u00adtation of the signature Z. The dashed circles stand for universally \nquantified stamps: z and y in this example. Harper, Milner and Tofte [3, 7] and Tofte [11] devel\u00adoped \nseveral static semantic descriptions of SML mod\u00adules using this analogy. In particular, they described \nmatching as a process combining instantiation of uni\u00adversally quantified stamps with enrichment of signa\u00adtures \nwhen they have less information than the matched structure. In this paper, we give a new description \nof the matching process, using techniques from subtyping wit h extensible records. 2.3 Typing sharing \nconstraints Two different structures can share the same type com\u00adponent. For instance, S .tand S.t are \nthe same type. In contrast, different specifications in different signatures are assumed not to share \ntypes, since each specification can be implemented by different actual types. Some\u00adtimes, however, one \nmay need to consider two separate specifications as standing for the same type. The way to require this \nbehavior is by adding sharing constraints in signatures. Consider the functor F in figure 3 using the \nsignature Z of figure 1. F would be ill-typed without the sharing constraint in the functor heading. \nSharing can also be specified on structure and type identifiers, which can be either internal or external \nto signatures. The signature P is an example of sharing between in\u00adternal and external structures.  \n2.4 Consistency As SML allows having different views of the same struc\u00adture, solving sharing constraints \ncannot be done by classical unification ~ but instead by a process i dent i\u00adfying stamps in components. \nIndeed, some kind of con\u00ad Figure 2: Representation of S, S and X functor F (X : Z, Y : Z sharing X.t \n= y.t) = struct . . . fun t.two = (X.ts) o (Y.ts) . . . en~ signature P = sig structure M : sig structure \nA : sig end; end; sharing N = S end Figure 3: Sharing constraints sistency between the structures sharing \na given stamp must be also verified. From now on, we omit value and type components from module representations \nand con\u00adcentrate only on sub-structure components and stamps. We justify this choice in the next section. \nThe weakest condition we can request on module consistency is that all the structures sharing the same \nstamp have the same stamp on their common compo\u00adnents. Consistency can be easily preserved by the prun\u00ading \nprocess of signature constraint, as there is no need to create nor to destroy sharing when constraining \na structure. In contrast, solving sharing does need to verify that consistency is preserved while performing \nstamp iden\u00adtification. This is not straightforward. Consider the signature P of figure 3. It has a sharing \nconstraint be\u00adtween a structure M and the structure S1 described in figure 1. There, S is a constrained \nview (without the sub-structure A) of S . On the other hand, M has an A component. In spite of the fact \nthat S does not appear in the sharing constraint, one must look at it while solv\u00ading the sharing, and, \nin general, we must look at any structure sharing a stamp with M or S. Otherwise, a naive solution will \nlead to an inconsistent assembly of structures, and then to an incorrect signature, as in figure 4. The \nstructure M* is obtained from M by solving the sharing between M and S in a local way, only looking at \nthese two structures. The result is in\u00ad correct since, without considering the sub-structure A of S, \nthe y variable is not identified with p. The struc\u00adtures S and M* are inconsistent, because they share \nthe stamp m and have a common component A with two different stamps. Thus, the unification process must \nverify on the whole sssembly of structures to preserve consistency and obtain correct signatures. As \nwe will see in the next section, M* is not only inconsistent with the current typing environment, but \nit is also a defective signature.  2.5 Defective signatures Not every signature one can build from stamps \nand sub\u00adstructure components can be considered legal. For in\u00adst ante, we can find signatures that are \nimpossible to match with any possible structure for a given module typing context. In this section, we \npresent the notion of defective signature used by Milner and Tofte [6] (they also call them monsters) \nto describe signature types that do not make sense with respect to a given typing context, but which \ncould be inferred under their type rules if no care were taken. In the study of new type disciplines \nfor SML modules, the problem is to deter\u00admine whether defective signatures can be inferred, and if so, \nhow to exclude them. In SML modules, signatures belong to the language constructions and they are ac\u00adtually \npart of the code; they are used in particular to build functors. Defective signatures are then bad code, \nand it is nice to have a typing discipline clever enough to reject them. Our aim in this section is to \ncharacterize defective signatures and give some examples. In section 7.4 we show how within our type \ndiscipline it is impossible to obtain defective signatures for the same examples: our type system fails \nin typing them. Milner and Tofte introduced some global conditions on inferred types in order to exclude \ndefective signa\u00adtures. We use these conditions to characterize defective them. The first one is well-jormedness. \nRecall that signa\u00adtures have universally quantified variable stamps. If a free stamp occurs in a signature, \nthis means that it is shared with at least one real structure in the type con\u00adtext. A signature is well-formed \nif all the components attached to that free stamp have also free stamps. Con\u00ad sharing s= m f?= m Z M=I \n; l =$ M*. m o N/ A AA I7 1 y 1 1 y 1 P %_/ \\_/ I Figure 4: An inconsistent assembly of structures \n~-=(; , e= (;;1\\/ RR I 1 y 1 sharing P \\/ o R E=p AA I 1 1 .% 1 1 z 1 \\_~ \\-J Figure 6: An ill-formed \nsignature structure E = struct end; structure Cl = struct end; signature El = structure C2 = struct end; \nsig signature Q = structure R : sig sig structure A : structure A : sig end sig structure B : si.g end \nend; end; sharing A = Cl; sharing A.B = C2 sharing R = E end end Figure 7: Uncovering within a signature \nFigure5: Creation of an ill-formed signature for every Q component of S, there is in r a structure S \n sider the declarations of figure 5 and their correspond-sharing m, and which has a Q component. In figure \n8, ing types in figure 6. We call @-the type of@ before the sub-structure A of Q is uncovered as the \nonly struc\u00adsolving the sharing constraint, and El its type after solv-ture sharing m with A is Cl and \nit does not contain ing it. This latter is ill-formed since the bound stamp any B component. z is under \nthe free stamp p. Since there is no other Harper, Milner and Tofte impose well-formedness as structure \nthan E having a stamp p and also an A com-a global constraint on any inferred object and covering ponent, \nit is impossible to match the result signature @ on any inferred signature, thus rejecting defective \nsig\u00adwit h any existing structure, and even to create a new natures. In section 7.4 we show how, with \nour encoding, structure able to match it. In section 7.4 we show how matching, and sharing resolution, \nwe do not need any our type rules fail in assigning a type to @. of these side conditions to guarantee \nthat only legal sig\u00ad natures are obtained: our type discipline directly fails The second global condition \nis covering. We intro\u00ad to assign types for the two examples above. duced it using the examples in figures \n7 and 8. The signature fl in figure 8 is well-formed but will never match any real structure. The reason \nis that no struc\u00adture having the stamp m can have a sub-structure B on 3 The language ModL it: the structure \nCl where m comes from was originally created empty. Roughly speaking, a structure S having The matching \nand sharing problems can be studied in a a fixed stamp m is covered by the typing context f , if, simplified \nlanguage where modules contain only stamps  Q-=:; ,  I Cl=(;) \\/ Q= A A 1 y 1 sharing \\/%om m B B \n1 z 1 sharing <-/wn n I (72= i o  Figure 8: Creation of an uncovered signature Strexp : := Strid split \nin two syntactic constructions to make typing rules I S trexp . Strid shorter. ModL is a simplification \nof SML modules with I Strexp : Sigid no values, type declarations, or exceptions, but only I Fmid ( Strexp \n) structures, signatures, and functors. We assume three I struct Dec end disjoint identifier classes: \nStrid for structures, Sigid for Dec ::= signatures and Funid for functors. The ModL syntax is I Dec ; \nstructure Strid = Strexp presented in figure 9. Sigexp : := Sigid I sig Spec end 4 Extensible records \nand mod- Spec : := I Spec ; structure Strid : Sigexp ules I Spec : sharing Longid = Longid Modules and \nrecords are both built from labeled com- Funexp Longid : := : := I func ( Strid Longid Strid : . Strid \nSigid ) Strexp ponents. Moreover, module matching to be matched with richer structures, records can be \naccepted in place of allows much records signatures as greater with less Program : := structure Strid \n= Strexp information. For records, this problem is strongly con- I I I signature functor Program Sigid \n= Sigexp Funid = Funexp in Program nected Our record to subtyping. proposal exploits and module type \nthe similarity representations between the and between their typing problems. Figure 9: The language \nModL 4.1 Extensible record terms and information about their sub-structure components. The basic idea \nbehind R6my s discipline is to have This is justified as the matching between value types, record types \ndefining different sets of labels and then exception types, and type declarations can be easily de\u00ad allow \nunification on types of different sizes. R6my s fined using the classical subsumption ordering between \nrecords are defined by a term algebra together with an polymorphic types. Also, following the SML Definition \nequational theory controlling their unification. They [7], we do not consider sharing between value types. \nuse row variables, which where first introduced by Finally, most of the problems of sharing between type \nWand [13], to allow the extension of a record by new declarations can be solved in the same fashion as \nshar-fields in a polymorphic way. They also use flags on fields ing between sub-structures. What is left \nto study, then, indicating their presence or absence. For instance, the is the matching and sharing problems \nwith respect to record type t asking for the presence of the field a (if identification of stamps, and \nconsistency and enrich\u00ad for instance, a function extracts it from its argument), ment with respect to \nsub-structures. with an arbitrary type a is shown in figure 10. ModL was first introduced by Harper, \nMilner and Extension is performed by substitution on row vari-Tofte [7] and Tofte [11] to study SML module \ntyp-ables during unification against a larger record. In fig\u00ading. The language we present is a slight \nmodification of ure 10 the type t haa a row variable p , so it can be their calculus, where the functor \nconstruction has been extended. But a is the ord y component that t must r= a:cl.c b:&#38;2.r abs.p t= \na : pre. a abs.p r* = a : pre. u b : abs. r abs.pt I Figure 10: Record extension by unification ask for. \nTherefore, p is tagged by abs, and thus any subsequent extension will lead to absent fields. Variable \nflags are used when a field can be taken either as present or absent, giving the possibility to render \nsome type information invisible. Subtyping is achieved by allowing unification on types with differ\u00adent \nsizes: variable flags get instantiated to present or absent, row variables are instantiated to make types \nricher. Consider theexample of figure 10. The record type r has fields a and b with types u and r. Both \nfields are tagged by variable flags, so they can be taken as present or invisible. In a similar way, \nr can be extended only by absent fields. The unification of r and tresults in a term r* where the flag \nvariable of a in r is instantiated to present, the row variable of tis extended by an absent b field, \nand the b flag is instantiated to absent.  4.2 The module terms In figure 10, if we take r as the type \nof a structure, and t as the type of a signature specifying an a component, then, the result from the \nunification above is exactly the signature constraint of r by t;that is, in the resulting term, the b \ncomponent is no longer visible. We exploit this similarity and present the grammar corresponding to module \nterms. Unfortunately, R&#38;my s theory is not powerful enough to express all match\u00ading cases one wants \nto type in modules. The prob\u00adlem comes from the encoding of subtipying using vari\u00adable flags. Once a \nflag variable has been instantiated, say, to present, it can no longer be compared with the same field \ncomponent having an incompatible absent flag, even if this flag naturally represents less informa\u00adtion. \nThus, some cases of signature matching cannot be typed. Consequently, we do not use flag variables in \nour encoding of terms, but only absent and present flags. The problem with this is how to achieve subtyp\u00ading \nduring matching. We shall do it by introducing in the next section an order between terms tagged by abs \nand pre. Record terms are very general and admit many con\u00adcret e signature of symbols. In our version \nabove, we simply add stamps and write some symbols differently to be closer to the module terminology. \nThe structure constructor Str takes pairs of stamps and structure en\u00advironments. Rows are either variables, \nsequences of fields, or the empty row made of a non-labeled field. R6my s records are sorted to restrict \nthe terms that can meet by unification, and also to forbid label rep\u00ad etition. To simplify the notation, \nwe do not give the details of sorts, but keep these restrictions in mind when considering the type rules \nand the record equa\u00adtions. The symbol @ is the empty structure, which will be used to prevent extension \non structure types. We write T the for term language obtained, The asser\u00adtion list al : al :: ... :: \nan : an :: fl is also written [a~:a~; . . ..an. an]. The symbols a, ,6 are structure variables, x is \na row variable, 6 is a field variable, and z is a stamp. .._ u .. a I Str(z, p) I @ structures < ::= \nBl(a:u)::< assertion lists functors p ::= X/a:c; p rows I s17ra:u;c7 E ::= o17r.c7 fields T ::= abs I \npre flags # = Pl~-+a The equational theory of record terms allows com\u00admut at ivit y of fields and the \nextension of row variables. We present the laws below and write E for this theory and ~ for its equality. \na:e; b:et; p~b:c ; a:e; p The first axiom states E-equality modulo the reorder\u00ading of fields. The second, \nstates the distributivity of flags over the a : -;. row construct or. This axiom al\u00adlows the extension \nof a row by new components. For inst ante, in our encoding, a row variable in a signature has always \nthe form abs(cr). We can extend it by an a component plus a non-extensible row by substituting a : a; \n@ for a. Using the second axiom we obtain the term (in the right hand side): abs. (a:u; @) Za:abs. u;abs \n.@ Notice that in our grammar we admit terms like abs ~u and abs . (a : U; p), but we do not admit terms \nlike abs. (a : abs. u ; abs. p). Notice also that, assertion lists are different from rows. Assertion \nlists are built with the :: constructor and rows with the a : _;. constructor. In particular, the flag \ndistributivity axiom works only on rows and never on assertion lists.  5 Solving the matching problem \nWe extend the theory E above to compare structure and assertion lists of T having incompatible abs and \n Figure 11: Matching pre flags (under E). The relation D of enrichment is defined as the smallest transitive \nand E-reflexive rela\u00adtion (i.e., containing z) satisfying the rules below. We write C for any constructor \nof the module terms except +. Notice that this relation does not consider functors and that it is co-variant. \nThe b relation is a structural subtyping relation simpler than the subtyping problems studied in [2] \nwhere contravariance is considered. ulbrl...anb~n pre b abs C(ul,... ,u~) bc(r,,..., rn) In [1] we prove \nthat D is stable under substitutions so we can perform unification modulo it. We write inequa\u00adtion of \nenrichment for the unification problem given by the expressions u t+ T between the module terms u and \nr, and we say that p is a solution to this problem if pu b pr holds. If u is the encoding of a structure \nand Z is the encoding of a signature, the matching problem between u and Z is given by the inequation \nu P Z and solved by unification 2. When it has a minimal solution p, the structure resulting from the \nconstraint of u by X is given by the term pa. Consider the example in figure 11. The structures S and \nthe signature 22 of figure 1 are now represented without using variable flags. Absent components are \ndrawn in grey boxes, while present ones are drawn in white boxes. To solve the mat thing problem S &#38; \nX, the variable p must be extended by the A component of S. Since p is grey, the extension in the resulting \nterm S is also grey. The term obtained is a restricted vision of S where A is absent. The inequation \nabove has a principal solution under E. This is not always the case. Consider the inequation Str(rn, \nA : pre . a; p) b Str(rn, x). It has two minimal E-solutions: p = {x w A : pre .m;p} and p = {x M A : \nabs . u; p}. We choose the second one, which is minimal under the order D. This choice corresponds to \nan interpretation of D as a constraining relation: in the right hand of an inequation, we choose the \nsolution revealing the least of information. Lemma 1 Any matching problem having a solution has also \na principal solution under b. 1~ [I] we ~t~djed a contravariant version of b. zActUallY, ~ficatj~n is \na more general technique th~ what we need to solve this problem, but this is jucit a more general framework. \nmodules This lemma is proved by showing the existence of an algorithm which finds D-principal solutions \nfor in\u00ad equations. In appendix A, we present an algorithm Si simplifying an inequation into a system \nof elementary equations and inequations. An inequation is elemen\u00ad tary, if it contains a variable on \none side and either a variable, or a constant on the other side. An equation is elementary if it has \nthe form a ~ u. A simplified system is equivalent to the initial inequation when they both have the same \nprincipal solutions. Lemma 2 The algorithm Si samplijies an inequation into a system of elementary equations \nand inequations, when it admits a solution and fails otherwise. The sim\u00adplified system is equivalent \nto the initial inequation. In the output of Si there are not two equations or inequations on the same \nvariable, and moreover, the inequations are only of the forms: a b abs, pre D CY, and a D /?, which admit \nseveral solutions. The com\u00adplete algorithm of inequation resolution involves three steps. First, decomposing \nan inequation into a simpli\u00adfied system; second, checking for the existence of cycles (occur check); \nthird, choosing a ~-minimal solution for the simplified inequations having several solutions. Oc\u00adcur \ncheck is well known and D-minimzd solutions for the above inequations are trivial. The proof of the b\u00adprincipality \nthe algorithm solutions can be found in [1]. 6 Solving sharing constraints Putting absent flags hides \nsome fields without destroy\u00ading their type information. Consider the restricted view S of S in figure \n11. Both structures have exactly the same stamps and type information, the only difference being in the \nflags carried (box color) by the components. This has an important effect on the consistency verifi\u00adcation \nfor modules. The unification process of shar\u00ading resolution becomes purely local: it does not need to \nexamine structures other than those in the sharing constraint to verify that consistency is preserved. \nIn this section we develop a second extension of Re!my s equations, this time solving the sharing prob\u00adlem. \nIt states the equivalence of terms modulo some differences in the flags of components. We call the new \nM=(i A ~~ : = S =m ,, .~  @,,,,, * M = m ;j4 ,j@,?, ,, .,, ,,_J Y E Yr ....,,,, (g;jxz!: .p ,:,O.\u00ad \n-b,.,.,.,.: Figure 12: Solving theory E . It adds the axiom abs ~ pre to the previous theory E. A sharing \nequation has the form u C T for the mod\u00adule terms u and r. Now, if u and r are two struc\u00adtures appearing \nin a sharing constraint, solving this constraint is equivalent to solving the sharing equation c ~ T. \nBut the E theory identifies abs and pre flags in order to compare different views of structures. To identify \nthe solutions in the same way would be incor\u00adrect, so we must consider them modulo the equations E. As \nfor inequations, sharing equations can have sev\u00aderal E-minimal solutions, but when they have one, they \nalso have a b-minimal solution. Again, this is the so\u00adlution we are interested in, as it expresses exactly \nthe amount of visible type information necessary to satisfy sharing constraints within a module semantics \nallowing different views of structures. The unification algorithm for sharing resolution is an easy extension \nof R6my s algorithm that can be found in [9]. The proof of the lemma below can be found in [1]. Lemma \n3 Any sharing equation having a solutzon has also a principal solution under P. There exists an al\u00adgorithm \nthat jinds this solution when it exists and fails otherwtse. Now, given a D-principal solution p for \nthe equation c ~ T, the structures satisfying a sharing constraint between u and T are given by the terms \npa and pr. As we saw above, the advantage of this encoding is that the inconsistency we considered in \nsection 2.4 can\u00adnot arise any more when solving sharing constraints by local unification, that is, when \nunifying only the struc\u00adtures specified in the sharing constraint. Fig 12 shows our encoding and solution \nto the sharing problem in figure 4 of section 2.4. Now, S has all the stamps and components of S, so \nwhen unifying S and Lf the only structures in the constraint S haa all the nec\u00adessary information to \nguarantee that consistency is pre\u00adserved in the result XI*. If we call p the b-principal solution of \nS ~ M, the structure AI* resulting from M is given by pM. The structure S remains unchanged as it has \nonly fixed stamps (in solid circles). sharing constraints 7 Typing ModL In appendix B, we present a \ntype system for checking modules using our module terms, and the sharing and matching results described \nabove. We extend module types to module type schemes in order to capture poly\u00admorphism of stamps in signatures, \nand to allow row extensions during unification. A module type scheme is a module type with some variables \nuniversally quanti\u00adfied. We write VW ~ u. the module type u when the variables in the set W are universally \nquantified. A module contezt r is a triple (I ,, rt, I f) of partial functions of finite domain, mapping \nrespectively struc\u00adture, signature, and functor identifiers into structure types, structure schemes, \nand functor schemes. We de\u00adfine V(a) as the set of variables appearing in a. We extend V to module contexts \nr and note it V(I ), Sub\u00adstitutions are defined in the classical way: on free vari\u00adables of terms. We \nextend them to module contexts in such a way that the assertion x : u in 17 becomes ~ : pu in ~r. 7 \n.1 Functor schemes and generativity We have seen that structure stamps are fixed while sig\u00adnature stamps \nare bound variables. What happens with functor stamps? A functor scheme is constructed with +. By the \nSML module semantics, each new structure obtained by functor application haa new stamps asso\u00adciated; \nthat is, structure creation is generative under functor application. The new stamps are those appear\u00ading \nonly on the right hand side of the arrow, i.e., those that are not instantiated by the actual functor \nargu\u00adment. We call them generative variables. They will be transformed into new fixed stamps by the functor \nap\u00adplication, that is, they will never take the value of a stamp appearing already in V(I ). Suppose \nnow we have instantiation substitutions on functor schemes, that is, for a type VW. T, a substitution \np : W -+ V. We must forbid them from substituting stamps appearing in the typing context for generative \nvariables. In the rules (see appendix B) we use a predi\u00adcate Gen(p, r, VW . q5) over instantiation substitutions, \ntype contexts, and functor schemes. It holds exactly when the image of the substitution p applied to \nthe gen\u00aderative variables of the functor scheme is disjoint from free stamps in the typing context. The \nexact definition of this predicate in given in the appendix B. 7.2 Principal Signatures Building functors \nand constraining structures in SML\u00adrequires the specification of signatures. In both cases, one must \nensure that the inferred signature corresponds exactly in components and sharing to the user s specification. \nThis property is known as principality of signatures. Checking for principality is crucial in order to \ngive a correct semantics to module typing: building functors or constraining structures with non principal \nsignatures would lead to objects different from those explicitly specified by the programmer. We adapt \nthe principality definition of Harper, Mil\u00adner and Tofte [7] to our formalism. Let a be a signature type \nsuch that I 1-sigexp + cr. We say that u is princi\u00adpal for sigexp in the context f , if for any other \nsignature type u such that 171-sigexp + u , there exists an in\u00adstantiation substitution p : V(u) \\ V(I \n) + T such that u D pu. That is, if any other signature type inferred for sigexp is richer under D than \nan instance of u. Our type rules for signature declaration and functor abstraction have side conditions \non principality of sig\u00adnatures. This situation is to contrast with the ML core typing: since no type \nconstraints can be possibly stated by the user, no special side conditions are necessary to ensure that \nthe user s specifications are not violated. This is one of the major points where the analogy be\u00adtween \nthe core language and the module typing breaks. Nevertheless, by our method to type signatures we still \nobtain a nice analogy between principal types in the core and in the module languages. We type a signature \nsigexp by solving a unification problem: the principal solution to this problem give us the prirzcipai \nsigna\u00adture (in the sense introduced above) for the signature expression sigexp. Thus, we express signature \nprinci\u00adpality typing as the principal solution of an equational unification problem; much as principal \ntyping in ML is expressed using principal solutions for a classical unifi\u00adcation problem. We now introduce \nthe unification problem we use to type signatures, noted r i-sigexp =$ CY, between a context r, a signature \nspecification sigexp, and a vari\u00adable cr. We say that this problem has a solution p if r t-sigexp + pa \nholds3. This problem is solved es\u00adsentially using unification for sharing resolution. Then, from our \nprevious result (lemma 3) on the existence of D-minimal solutions for sharing equations, we can easily \nshow the following lemma. The algorithm W is actually the signature typing algorithm for our type discipline. \nWe present it in appendix C. 3This unification problem can be set this way because the type rules have \nbeen proved stable under substitutions in [1]. Lemma 4 If the unification problem r 1-sigexp &#38; a \nhas a solution, then d has a b-principal solution p such that r 1-sigexp + pcr holds. There exists an \nalgorithm W jinding this solution when it exists and failing otherwise. With this result, it is easy \nto show the following the\u00adorem. It states that principal signatures are precisely the principal solutions \nfor the unification problem of typing signatures. That solution is found by the signa\u00adture typing algorithm \nW given in appendix C. Theorem 1 If r 1-sigexp + u holds, then the t yp\u00ading signature algorithm W finds \na signature u which is principal for sigexp in r or fads otherwise. Proof If I 1-sigexp + a holds, then, \nthere exists a solution v for the unification problem I F sigexp &#38; a, such that u = va and there \nexists also a D-principal solution p, for the same problem, such that pa = a. But p is D-principal, and \nthen there exists a substitu\u00adtion q such that u Dqu. We conclude that u is principal for sigexp. An immediate \ncorollary of this theorem is the exis\u00adtence of principal signatures in our type system. 7.3 Consistency \npreservation We saw that two structures are consistent if, when they share a stamp, their common components \nalso share their stamps. This condition can be formalized in our type discipline as follows. Two structure \nterms u et T sharing the same stamp are consistent if the sharing E equation c = r holds. This notion \nis naturally ex\u00adtended to sets of module terms and to the set of module terms in a context I . By abuse \nof notation, we will talk about the consistency of the set of terms in I together with the term a, as \nthe consistency of the set {I , u}. We say that consistency is preserved by a module type judgment I \n1-e + u, if whenever I is consistent, the set {I , u} is also consistent. Inconsistency can arise when \nintroducing sharing be\u00adtween a set of terms which are not E -equal. The only rule that introduces sharing \nis (IVsig) which creates new signatures, In this rule, there is no restriction on the stamp chosen to \nbe on top of the new signature. In par\u00adticular, it can be a stamp already appearing in the type context \non top of a term E -different from the new sig\u00adnature. It is easy to show that consistency is preserved \nunder all the module type judgments except for those in the Sigexp and Spec syntactic classes of signatures. \nIn\u00addeed, these rules either introduce new stamps (they are generative), or they inherit whole terms (without \nintro\u00adducing any sharing) appearing in the type context. The proof of the following lemma can be found \nin [1]. =L E m Figure 13: Unification failing on an ill-formed signature Lemma 5 For any h40dL expression \ne not in Sigexp, nor in Spec, the judgment I 1-e + u preserves consis\u00ad tency. On the other hand, our \nunification notions have a good behaviour with respect to consistency. The proof of the following lemma \nis trivial. Lemma 6 Let {I , a} be a consistent set. If u = r or u ~ r hold, then the set {I , u, T} \nis also consistent. The signature type algorithm in appendix C uses uni\u00adfication which is well behaved \nby this lemma. The algorithm takes several precautions with respect to stamp variables. First, it forbids \nunification on fixed stamps (appearing in real structures) of the type con\u00adtext. Second, it always chooses \nnew stamp variables to build types for new signature specifications. Also, already existing signatures \nare instantiated by com\u00adpletely new stamp variables. In both cases, sharing is finally achieved by E \n-unification. The following theo\u00adrem states the existence of a signature type algorithm preserving consistency. \nThe proof can be found in [1]. Theorem 2 Let I be a consistent module context and p the solution found \nby the algorithm W for the r 1\u00adsigexp ~ CY typing problem; then the set {I , pa} is also consistent. \n 7.4 Rejection of defective signatures In this section we consider the examples of defective signatures \ninferred under the Harper, Milner and Tofte type system that we presented in section 2.5. Our type rules \nfail in assigning a type to these two examples thanks to our encoding of terms, and to our definitions \nof mat thing and sharing resolution. Figure 13 presents our solution for the ill-formedness example of \nfigure 6. In contrast with the unification definition of Harper, Milner and Tofte [7, 6], with our encoding \nand definition of unification, it is impossible to unify the structure E with the term attached to R. \nTo unify them, one would need to extend E by an A component, which is impossible by the encoding of E. \nLet us now consider the covering example of figures 7 and 8. In our type system, the typing of Q fails \nbecause it is impossible to unify the type of the structure Cl empty and non extensible with the type \nof the sub\u00adstructure A cent aining a B component. Figure 14 shows our type discipline failing on the \ntyping of Q because of this sharing resolution failure. Under our type rules, the two signature specifica\u00adtions \nabove are rejected. Unfortunately, it is actually possible to build badly formed and uncovered signa\u00adtures \nusing our types rules. More precisely, we cannot state a general result on preservation of well-formedness \nand covering for our type rules. As for consistency, the rule creating problems is (iVsig): using it \nwe can build arbitrary pathological signatures, either inconsis\u00adtent, baddl y-formed, or uncovered. But \nactually, things are not too bad. In the real world of typing, one does not try to guess arbitrary types \nbut just to build very general types (directed by the syntax), which are finally specialized by unification. \nWe saw above that unification behaves correctly: there will not be any inconsistency, bad formation, \nor uncov\u00adering introduced via unification on a set of consistent, well-formed, and covered objects. The \nfollowing lemma, which is easy to show, formalizes this good behaviour. It extends lemma 6 of the previous \nsection. Covering and well-formedness are extended to module type con\u00adtexts, Lemma 7 Let the set {I , \nu} be consistent, well\u00ad formed, and covered. If u ~ r or u ~ ~ hold, then the set {I , u, T} is consistent, \nwell-formed, and covered. Our notion of unification and particular encoding of terms intervene in the \ntype rules. This is why the two defective examples above are rejected. On the other hand, we actually \nfind types for signatures by solving a unification problem. We just have to put together the consistency \nresults of the previous section with the lemma below to extend the good behaviour of unifica\u00ad(-2-+ A \n;. $$; ;,..X,,::,.,,,,:,,:, _~ . ., E = F E = Figure 14: Unification failing onan uncovered signature \ntionto the process ofsignature typing. In other words, if we know how to obtain consistent signatures, \nwe can be sure they will be covered and well-formed. Lemma 8 lj the judgement I 1-e ~ u preserves con\u00adsistency, \nthen it also preserves well-formedness and cov\u00adering. Proof We sketch the proof. Let us suppose that \nI is consistent, well-formed and covered. Let us suposse also that I k e + u preserves consistency but \nthat u is badly-formed and uncovered. Then, there exist a struc\u00adture r in r, having on top a fixed stamp \nm, which is shared with a sub-structure r of u, As II is well-formed and covered, it must be that r # \nr , but this contra\u00ad dicts the hypothesis on the consistency of {I , a}. From the previous sections there \nexists a signature typing algorithm finding principal signatures and pre\u00adserving consistency. By the \nlemma above, this al\u00adgorithm also preserves well-formedness and covering. Moreover, we achieve this result \nfor free: without the introduction of any special condition checking for defec\u00adtive signatures. The following \ntheorem arises trivially. It synthesizes the typing results presented in this paper. Theorem 3 There \nexists a signature typing algorithm finding principal signatures and preserving consistency, well-formedness, \nand covering. 8 Related work In his Ph.D. thesis [11], Tofte studied a different se\u00admantics for consistency, \nmatching, and sharing for SML modules. According to this semantics, consistency (which he called coherence) \nis stronger: two struc\u00adtures sharing the same stamp must be completely equal. Sharing constraints become \nequality constraints and matching is not coercive: components in a structure cannot be hidden as this \nwould destroy consistency of multiple occurrences of the same structure. As in the language studied in \nthis paper, sharing constraints can be specified within differently shaped structures. In the same way, \nmatching is allowed between structures richer than signatures. The matching definition and the unification \nalgorithm in [11] are reminiscent of R&#38;my s algorithm in that both methods extend sequences of components \nby new components. More recently, Milner and Tofte studied [6] the se\u00admant ics we consider in this paper, \nand which happens to be the current semantics of SML modules. According to them, sharing is solved by \na process called admis\u00adsification that identifies stamps while checking consis\u00adtency, cycle-freeness, \nand well-formedness on the whole context of current structures. Our work uses several ideas already present \nin Tofte s thesis and in Milner and Tofte semantics: fixed stamps in the types of structures, bound \nstamps in the signa\u00adture types, and structure extension during unification, but our presentation is strongly \nbased on the R6my s unification framework. To this approach we incorporate the encoding and the equational \ntheories of unification necessary to deal with the current semantics of SML. All of that result in several \nimportant advantages: nice no\u00ad tions and proofs on principality, local consistency check\u00ad ing, consistency \npreservation and well-formedness and covering preservation coming directly from our signa\u00ad ture typing \ntechniques. 9 Conclusions We have shown a simple and elegant formalization of the static semantics of \nSML modules. We obtain a type system relying only on well-known unification tech\u00adniques and which does \nnot need new concepts nor ex\u00adternal constraints to guarantee that only legal types are inferred. The \nunification necessary to ensure con\u00adsistency remains local to specified structures in sharing constraints, \nand this is naturally efficient. Last but not least, the proof on principality, relying on the princi\u00adpality \nresult of sharing unification, is extremely simple. Our type system is an interesting application of \nrecord type disciplines. Its extension to higher-order functors (see [12]) is still under study. There \nare two main problems with this extension. The first one concerns the extension of the D relation to \nbe contravariant in order to compare functor types in structures during matching. The principal problem \nwith contravariance is ensuring the existence of princi\u00adpal solutions. The second problem concerns the \nsemantics of func\u00adtor sharing. In the type discipline of Tofte [12], two functor signatures can be shared \nif they are identical. In our framework, two functors can be shared if they differ only in some flags \nof components in the argument or in the result. It is not clear yet for us which one of these two solutions \ncorresponds to the more natural functor sharing semantics. 10 Acknowledgements Many thanks to Xavier \nLeroy, Mads Tofte, Didier R&#38;my, Michel Mauny, Benjamin Pierce and Ian Jacobs for their comments. \nReferences [1]Maria Virginia Aponte. Typage d un systime de modules paramttriques avec partage: une appli\u00adcation \nde [ unification clans les th~ories 6quation\u00adnelles. Th&#38;se de doctorat, Universit6 de Paris 7, 1992. \n[2] You-Chin Fuh and Prateek Mishra. Polymorphic subtype inference: Closing the theory-practice gap. \nIn TAPSOFT 89, 1989. [3] Robert Harper, Robin Milner, and Mads Tofte. A type discipline for program modules. \nIn The\u00adory and Practice of Programming Languages, vol\u00adume 250 of Lecture Notes in Computer Science. Springer \nVerlag, 1987. [4] Robert Harper and John C. Mitchell. The essence of ML. In Fifteenth ACM Symposium on \nPrinci\u00adples of Programming Languages, 1988. [5] David MacQueen. Modules for standard ML. Polymorphism \nNewsletter, II, 1985. [6] Robin Milner and Mads Tofte. Commentary on Standard ML. The MIT Press, 1991. \n[7] Robin Milner, Mads Tofte, and Robert Harper. The Definition of Standard ML. The MIT Press, 1990. \n[8] Didier R6my. Records and variants as a natural extension of ML. In Sixteenth Annual Symposium on \nPrinciples Of Programming Languages, 1989. [9] Didier R6my. Algibres Touffues. Application au Typage \nPolymorphe des Objects Enregistrements clans les Langages Fonctionnels. Th&#38;e de doc\u00adtorat, University \nde Paris 7, 1990. [10] Didier R6my. Type inference for records in a natu\u00adral extension of ML. Technical \nReport 1431, Inria, Rocquencourt, May 1991. Also in [Rem90], chap\u00adter 4. [11] Mads Tofte. Operational \nSemantics and Polymor\u00adphic Type Inference. PhD thesis, University of Ed\u00adinburgh, 1987. [12] Mads Tofte. \nPrincipal signatures for higher-order program modules. In 19th ACM Symposium on Principles of Programming \nLanguages, 1992. [13] Mitchell Wand. Complete type inference for simple objects. In Second Symposium \non Logic In Com\u00ad puter Science, 1987. A Appendix: The inequat ion decomposition algorithm The inequation \ndecomposition algorithm Si in figure 15 outputs a set of elementary equations and inequa\u00adtions. The Remy \ns equation decomposition algorithm Se, simplifies an equation into a set of elementary equa\u00adtions. This \nalgorithm can be found in [9]. Inequations in the output of the Si algorithm are only of the forms: a \nD abs, pre D a and a D 13, and there are not two equations or inequations on the same variable. The al\u00adgorithm \nelem, given an elementary inequation where the variable a appears, checks for the occurrence of an inequation \nor an equation on a in the already simplified system M. This algorithm tries to simplify all the in\u00adequations \nand equations on a or to find a contradiction between them. For more details on this kind of simpli\u00adfication \nand on the whole inequation resolution process, the reader can consult [1]. In order to find the solutions \nof an inequation after the obtention of a simplified system, two more steps must be performed. First, \none must check that there are no cycles in the syst em. Second, one must choose a solution for the elementary \ninequations having several solutions. In our type system we always choose D\u00adminimal solutions. Thus, \nthe D-minimal solution of aDabsandofpre Da isa ~ abs. B Appendix: Inference rules The typing relation \nis of the form (r i-e + T), where r is a module context, e is a ModL expression, and ~ is let rec Si(M, \ne) = match e with abs b pre A 1 I pre b abs + M I (x ba+M I C(al) b C(~l) + Si(M, ~i P rl) I u b C(ai) \n+ let ~i = neuvarso in let M = Se(M, u ~ C(ai)) in Si(M , ai b Ci) I (* symmetric *) cl bcz+ if c1 \n# C2 then fail else M Ii + elem(M, i) where rec elern(jbf,i) = match i with ab/3+MU{ab~} Iabc+ E ifa=c \ne M andc ~ c then fail elseMU{a Ec} Iabsba+ E ifs= pre EM ora b pre c M then fail else (M\\{ababs, prebcz})U{a \n~ abs} Iabpre+ E ifs= abscM orabs b a c M then fail else (M\\{cr Babs, preba})u{a ~ pre} Iababs+ E ifff= \nabs c M ora~ preEMthenM else M U{a b abs} Ipreba+ E ifs= abs EM oraE pre EMthenM else M U{pre b rr} ;; \n Figure 15: The inequation decomposition algorithm either a module type or a module context. It is defined \nas the smallest relation satisfying the rules below. When A is a context component, we write A[z : t] \nfor the function that is equal to A everywhere except on x, and assigns tto x. When the synt attic class \nof z is clear, we write I [z : t]instead of recomposing the whole context (... A[z : t]...) from the \ncomponents of I . Let A and B be two context components of the same kind. We write A+ B the context component \ndefined by A(z) if B(z) is not defined and B(z) otherwise. Two module contexts can be added by adding \ntheir components. We assume for any type VW. r and any context I , that W is disjoint from the variables \nin 17. We also assume that W is contained in V(r). Let #bea+ u and call Rthe set W\\V(a). The predicate \nGen(p, r, VW.q5) holds if and only if I(P ) R)fl V(r) = 0 where l(v) is the image of the substitution \nand r the restriction of substitutions. Given an assertion list c equal to [al : al; . . .; an : an], \nand a row term p, the notation c; p refers to the term al:pre. al; . . ..an. prcrfl;l; p. r(strid) = \nu (Vstr) I 1-strid ~ u I (sigid) = VW. u /b:w+T (Vsig) r 1-sigid + w I 1-funid + p# r 1-strexp + u I \n1-sigid + u uba (Res) 171-strexp : sigid + G r 1-strexp ~ Str(z, strid : pre . u; p) (Extr) r 1-strexp. \nstrid ~ u I 1-dec+< x @v(r) (Nstr) 1?1-str dec end+ Str(s, <; abs . @) rl-spec+a (Nsig) I 1-sig spec \nend + Str(z, s; abs . cr) r 1-strexp * u ubu I 1-fuiid+d--+r(App) r 1-funid(strexp) + T I t-sigid +. \nu a is principal for sigid in r 17[strid : a] t-strexp + ~ wnv(r)=O (Abs) r 1-func (stricl : sigid)strexp \n~ VW . u -+ r I 1-spec+c r[q] 1-sigexp + u strid @ dom(<) (Spec) I 1-spec; structure strid : sigexp * \n(strid : u) :: s (Edec, Espec) r~{}ao rl-dec+c r[<] 1-strexp * u strid @ dom(q) (Dee) 171-dec; structure \nstrid = strexp * (strid : a) :: c r 1-strexp * u (DecStr) I 1-structure strid = strexp a ([strid : u], \nn, n) r 1-sigexp + u Wnv(r)=O a is principal for sigexp in r (DecSig) r 1-signature sigid = sigexp * \n(0, [sigid : VW. u], o) r 1-funexp + # (DecFun) 1?1-functor funid = funexp +-(0, o, [funid : #]) r t-programl \n+-r] r + rl F program2 * rz (SeqProg) r 1-programl in program2 +-rl + rz C Appendix: The signature typing \nalgorithm The following algorithm uses a set ill of fixed stamps which cannot be modified (i,e,, they \ncannot be in the domain of any substitution). It also uses R&#38;my s uni\u00adfication algorithm modulo the \nequations E. We call ~(ill, u ~ r) the algorithm finding the principal solu\u00ad tion of the unification \nproblem u Z I-without changing the stamps in Al. The algorithm G* (Al, u ~ ~) finds the principal solution \nmodulo D of the sharing equation u ~ r without changing the stamps in M. let W(M, r F sigexp 4-a*) = \nmat ch sigexp vith sig spec end + let x = nevvarstampo and a, /3 = nevvarso andp= W(M, r 1-spec 4 a) \nin ~(M, a* ~ Str(x, p a; ahs c /3)) I {} -Wf-v ~ 0) sigid ~ let Vkl. r = r(sigid) in let p:U + T such \nthat I(P) n v(r) =0 I in ~(M, W* Spr) spec; structure a : sigexp - I let a, ~ = newvarso in let p = w(r \n* SPCX4-a) andv= W(M, P r[p a] ~ sigexp A B) inlet q=vop in G(M,cv* ~ (a: v~) :: qa) spec; sharing longid \n1 = Jongid 2 * I let a, ~, y = newvarso in let p = W(H,r 1-spec A 7) andv= W(M, p I [p y] E Iongid 1 \n~ a) and v = W(M, p r[p y] 1-longid2 &#38; p) and p = @(M, va ~ v ~) in G(M,CV* ~ (p o p) ~) ;; Figure \n16: The signature typing algorithm   \n\t\t\t", "proc_id": "158511", "abstract": "<p>We extend term unification techniques used to type extensible records in order to solve the two main typing problems for modules in Standard ML: matching and sharing. We obtain a type system for modules based only on well known unification problems, modulo some equational theories we define. Our formalization is simple and has the elegance of polymorphic type disciplines based on unification. It can be seen as a synthesis of previous work on module and record typing.</p>", "authors": [{"name": "Maria Virginia Aponte", "author_profile_id": "81100151158", "affiliation": "", "person_id": "P188642", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158704", "year": "1993", "article_id": "158704", "conference": "POPL", "title": "Extending record typing to type parametric modules with sharing", "url": "http://dl.acm.org/citation.cfm?id=158704"}