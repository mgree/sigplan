{"article_publication_date": "03-01-1993", "fulltext": "\n Efficient Flow-Sensitive Interprocedural Computation of Pointer-Induced Aliases and Side Effects Jong-Deok \nChoi Michael Burke* Paul Carini* IBM Research Division T. J. Watson Research Center Yorktown Heights, \nNY 10598 Abstract We present practical approximation methods for computing interprocedural aliases \nand side effects for a program written in a language that includes pointers, reference parameters and \nrecursion. We present the following results: 1) An algorithm for flow-senwtzve interprocedural alias \nanalysis which is more precise and efficient than the best inter\u00adprocedural method known. 2) An extension \nof traditional flow-insensztzve alias analysis which ac\u00adcommodates pointers and provides a framework \nfor a family of algorithms which trade off preci\u00adsion for efficiency. 3) An algorithm which correctly \ncomputes side effects in the presence of pointers. Pointers cannot be correctly handled by conven\u00adtional \nmethods for side effect analysis. 4) An alias naming technique which handles dynamically al\u00adlocated objects \nand guarantees the correctness of data-flow analysis. 5) A compact representation based on transitive \nreduction which does not re\u00adsult in a loss of precision and improves precision in some cases. 6) A method \nfor intraprocedural alias analysis which is based on a sparse represen\u00adt ation. Introduction .4 Ziasing \noccurs when two or more l-value [2] expres\u00adsions reference the same storage location at the same program \npoint p. Aliasing complicates data-flow anal\u00adysis, which is a basis for program transformations such \nas optimization and parallelization. The problem of ex\u00adactly computing interprocedural aliases in the \npresence of general pointers is known to be NP-hard [16]. In this paper, we describe approximation methods \nfor comput\u00ading interprocedural aliases and side effects for a program written in a language that includes \npointers, reference parameters and recursion. We present the following new results: *E-mail addresses: \n{jdchoi,burkem, carini}@watson. ibm.com Permission to copy without fee ell or part of this material is \ngranted provided that the copies are not made or distributed for direct commercial advantage, the ACM \ncopyright notice and the title of the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires \na fee and/or specific permission. ACM-20th PoPL-1/93-S.C., USA @ 1993 ACM o-89791 -561 -5/9310001 /0232 \n. ..$505O * An algorithm for jlotu-sensitive interprocedural alias analysis which is more precise and \nefficient than the best interprocedural method known [16, 17]. The jlow-sensitive interprocedural alias \nanal\u00adysis method interleavea intraprocedural and inter\u00adprocedural analyses. An extension of traditional \nflow-insensitive alias analysis [4, 10] to accommodate pointers. Our flow\u00adinsensitive alias analysis \nmethod provides a frame\u00adwork for a family of algorithms with varying degrees of precision.  An algorithm \nwhich correctly computes side effects in the presence of pointers. Conventional methods for side-effect \nanalysis [4, 9, 5] decompose the com\u00adputation into separate direct side-effect and alias analyses. Pointers \ncannot be correctly handled by algorithms based on this decomposition. Apart from the cost of the alias \nanalyais, this side-effect analysis does not incur any cost beyond the con\u00adventional algorithms.  o \nA naming technique for dynamically allocated ob\u00adjects. This technique improves the precision of ex\u00adisting \nmethods for alias analysis [7, 12, 13, 18]. * An aliaa naming technique which, when aliases are factored \ninto data-flow analysis, guarantees the cor\u00adrectness and enhances the precision of data-flow analysis. \nThis technique also allows a compact rep\u00adresentation which, based on transitive reduction, doea not result \nin a loss of precision. For some cases, this technique results in improved precision. A method for intraprocedural \nalias analysis which is based on a sparse representation. The algorithms we develop in this paper compute \naliases of access paths [18] l-value expressions which are constructed from variables, pointer indirection \nop\u00aderators, and structure field select operators. (In C these expressions would include the * indirection \noperator and the > and . field select operators.) Two acceaa paths are must-aliases at p if they refer \nto the same storage location in all execution instances of p. Two access paths are may-aliases at p if \nthey refer to the same storage location in some execution instances of p. This paper concerns computing \nmay-aliases, of which must-aliases are a subset. We will refer to may-aliases as aliases, whenever the \nmeaning is clear from context. int p, q, r, *s, X, Y; SUB1O { p = &#38;s; r.&#38;X SUB30; *r= lo;Y.x \n}; 1 SUB1 1 :~:: SUB20 ( .,. );/ SUB2 SUB30 { p=~ *1 .*PT <*r,X> 6 SUB3 p=fi F };/ SUB3 / Figure 1: \nExample Program Segment and Its PCG. Dynamic int? ap? ocedural atiases occur due to point\u00aders in languages \nlike LISP, C, C++ or Fortran 90, and static intraprocedural aliases occur due to con\u00adstructs such as \nthe union construct in C and Fortran EQUIVALENCE. Interprocedural aliases occur due to the passing of \nreference parameters and pointers at call sites, which propagates intraprocedural aliases across procedures \nand introduces new aliases. Thus, aliases are propagated through the procedure call graph (PCG), whose \nnodes represent procedures and edges represent call sites. Static alias information is typically computed \nduring the semantic analysis phase of compilation, and we assume that this information is readily available. \nWhere the meaning is clear, we will refer to dynamic in\u00adtraprocedural aliases as simply intraprocedural \naliases. A flow-sensitive interprocedural analysis makes use of the intraprocedural control flow information \nassociated with individual procedures. A jlow-insensitive interpro\u00adcedural analysis does not make use \nof intraprocedural control flow information. Through pointer assignment, a called procedure can affect \nthe aliasing of the calling procedure at the point just after the call site. Computing aliases requires \nbidirectional iteration over the PCG, with aliases prop\u00adagated forward from the call site to the entry \npoint of the called routine, and backward from the return point of a called procedure to the point just \nafter the call site. Section 2 contains examples which illustrate some of our improvements in precision \nover other interpro\u00adcedural methods. Section 3 presents an algorithm for computing intraprocedural alias \ninformation which is based on a sparse representation. Section 4 presents our interprocedural alias analysis \nmethods. Section 5 presents the method for computing call site side effects in the presence of pointers. \nSection 6 describes a tech\u00adnique for naming memory locations which guarantees the correctness of data \nflow analysis. It also presents a representation of alias information which enhances the precision and \nefficiency of alias analysis methods. The complexity of the alias analysis algorithms is presented in \nSection 7. Comparison of our method with relevant work is given in Section 8. Finally, we draw conclusions \nin Section 9. 2 Examples In this section, ,.we present two examples. The first ex\u00adample demonstrates \nthe improved pr~cision of our flow\u00adsensitive interprocedural method over the Landi-Ryder approach [16, \n17]. The second example demonstrates the improved precision of our method for naming dy\u00adnamically allocated \nobjects over previous approaches, including those described in [7, 18]. We use < x, y > to denote that \naccess paths z and y are may-aliases at a program point. Note that the trivial alias < z, m > always \nholds for all access paths z at all program points. Also note that, if z and y are non-null pointer-valued \naccess paths, < x, y > implies < *z, *y >. We refer to these implied aliases and trivial aliases as implicit \naliases. Figure 1 shows three procedures and the corre\u00adsponding PCG. Alias relations holding at the entry \nnode of SUB3 consist of < *p, s >, < *T, X >, and < *P, *q >.l Of these three alias relations, < *P, \ns > and < *T, X > are propagated along the PCG edge from SUBI to SUB3, and < *p, *q > is propagated along \nthe PCG edge from SUB2 to SUB3. The alias relations holding at the exit of SUB3 are different from those \nat the entry node, due to the assignment to *p in SUB3, and are propagated to the points in SUB1 and \nSUB2 immediately following the invocations of SUB3. Our interprocedural flow-sensitive analysis will \ncorrectly compute the following: < *P, s >,< *T,X >,< ** f7, *T >,< **p,x >, <* S,* T>, <*S, X> as the \nalias relations holding immediately after the call to SUB3 in SUB1, and the following: < *P, *q >, < \n**p)*r >, < **q, *r > as the alias relations holding immediately after the call to SUB3 in SUB2. In \ncontrast, the Landi-Ryder method [16, 17] will imprecisely compute, in addition to the above valid alias \nrelations, that the (invalid) alias relation < **q, X > holds immediately after the call site invoking \nSUB3 from either StJBl or SUB2 (but not both). This in\u00ad valid alias relation results from the spurious \ncoupling of LWe assume that no alias relations hold before any of the pro\u00adcedures are called. 233 int \n*p, *q, *r, *s, *t; maino { P = SUB1O; q = SUB20; );/ main / int SUB1 () { r = SUB30; SUB4 (); return(r); \n );~ SUB1 / Figure 2: int * SUB20 { S= SUB30; SUB4 (); return(s); ];/ SUB2 / el int * SUB30 { t = malloc( \n...); SUB4 (); e3 ); I* SUB3 *I Example Program Segment and Its PCG. < *r, X > and < *p, *q > in SUB3, \nalthough these alias relations cannot hold at the same time. Their method uses assumed aliases at the \nentry node and, in general, can compute 0(2n 1) invalid alias relations in the presence of n alias relations \nholding at the entry node, although the total number of aliases they com\u00adpute is no more than 0(m3) in \nthe presence of O(m) valid aliases [17]. The generation of invalid alias rela\u00adtions by their method is \ndiscussed in Section 8. Figure 2 shows an example program, where all five pointer variables p, q, ~,s, \nt point to objects dynam\u00adically allocated by the malloc statement in SUB3. For the method described \nin [7], all the pointer variables are assumed to point to the same location. Our method de\u00adtermines that \n*p is not aliased to *q or *s; and that *q is not aliased to *p or *T. Our method thereby improves the \nprecision of alias information for dynamically allo\u00ad cated objects. A more detailed description is provided \nin Section 6.  3 Intraprocedural Alias Compu\u00adtation The intraprocedural alias computation can be formu\u00adlated \nas a data flow framework [20, 22], in which the solution at a given program point is related to the so\u00adlution \nat other points. A control flow gvaph is a di\u00adrected graph CFG =< NCFG, ECFG, Entry, Exit >. The nodes \nNCFG are the statements of a procedure and two additional nodes, Entry and Exit. The edges ECFG represent \ntransfers of control between the statements. We assume that each node is on a path from Entry to Exit. \nThe data flow framework for computing aliases in\u00adcludes tvansfev functions, which describe the effect \nof nodes on aliasing. INY denotes the set of aliases as\u00adsumed to hold on entrance to Y; OUTY denotes \nthe set of aliases assumed to hold on exit from Y. The effect of node Y on aliasing is captured by its \ntransfer function: OVTY = fy (INY ) After a framework has been globally evaluated, each node Y has a \nsolution OUTY that is consistent with INY and the transfer function at every node. We use a sparse representation, \nthe Sparse Evalu\u00adation Graph (SEG) [8], for intraprocedural alias anal\u00adysis. The set of nodes in a Sparse \nEvaluation Graph SEG =< NS~G, ES~G, Entry, Exit > for computing aliases is a subset of NCFG and is the \nunion of the fol\u00adlowing two sets: GenNodes, which is the set of nodes where pointer variables are potentially \nmodified; and Meet Nodes, which is the set of nodes where alias infor\u00admation is combined at join points \nin the SEG. Intraprocedural aliasing can be computed by ap\u00adplying well-known iterative or interval-based \ntechniques to the SEG. This computation requires three compo\u00adnents: the aliases holding at the Entry \nnode of the SEG (A-LIAS~~~rg), the aliases holding at (i.e. immediately after) the call-site nodes in \nthe SEG, and the trans\u00adfer function for each node that contains a (potential) pointer assignment. The \naliases holding at the Entry node and the call-site nodes are interprocedurally com\u00adputed, as described \nin Section 4. If interprocedural alias analysis is not performed, interprocedural aliases hold\u00ading at \nthe Entry node and the call-site nodes would rep\u00adresent the pessimistic assumption that all possible \n(in\u00adterprocedurally induced) aliases hold. In this section, we describe the transfer function for a general \nassign\u00adment to an access path of a pointer type. 3.1 Transfer Function for Pointer As\u00adsignment Let A~~ \nand AyOUT be the setof alias relations hold\u00ad ing at the entry and exit of node Y, respectively. A~~ \nand A&#38;T correspond to INY and OUTY aa defined before. We use AIN and AOUT when the node Y in question \nis clear from context. As described before, a MeetNode in the SEG has multiple predecessor nodes. For \na MeetNode Y, A~N is the union of the AOUT sets of its predecessor nodes in the SEG: A~~ = &#38;JT u \nXCPreds(Y) For an access path z, let AIN (z) be the set of alias relations in AIN that contain access \npaths which include z. As an example, for AIN = {<z, y>, <ez, z>, <w, z>, v v SI : struct cell {. . .} \n r r celll, cel12, cel13, *p, *q;El-= o S2: p = &#38;celll; q = &#38;cel12; P P S3: if() { S4: p >left \n= &#38;cel13 % S5: p >right = q;  t Nt ... 9 sfj: } else if () { o o S7: p >left = q; Et- El\u00ad s s \ns13: p >right = q; ... S9: } else SKI: p=q; (A) (B) Sn: p >val = .... S12: p >left >val = ,.. ; Figure \n3: Graphical View of Aliasing. <*x, *y>, <x, x>, <y, y>, Figure 4: Example C Program Segment. <W, w>, \n<z, z>] AfN(c) is {< x,y >,< *X, Z >,< *z, *y >,< z,a >}. The first three alias relations of AIN are \nezplicit aliases, while the remaining are implicit aliases. For efficiency, our representation includes \nonly ezphcit aliases. For clarity, we sometimes include implicit aliases in our ex\u00adposition. The above \nalias sets become AIN={<x, y>, <*z, z>, <w, z>) and AIN(z) = {< z,v>, < *Z, Z >} respectively. For an \nalias relation AR 6 A1~(z), we use AR(Y/z) to denote the new alias relation obtained by replacing each \noccurrence of access path z in AR with access path y. We also use AIN (y/z) to denote the new set of \nalias relations obtained by replacing each occurrence of access path x in AIN with access path y. For \nAIN in the above example, AIN(q/z) = {< q,y >,< *q, z >}. For the following assignment statement to \nan 1\u00advalue with a pointer type Si:p+q, (1) the transfer function is as follows: -40uT = (AIN -AIN(*P)) \nu (2) u {AR(*u/*q)}. (3) <P,u>G-&#38;N, AlZ6ArN(*ST) The kdling rule (Rule 2) says that the value of \np may change after the assignment. The generation rule (Rule 3) says that any alias of p, including impiicit \nones, may point to what q may point to: if u is an alias of p, *u becomes aliased to what *q is aliased \nto. For examp\u00adle, assume AIN at statement Si in (1) is: { <p, T>, <*p,v>, <*T, v>, <q,8>, <*q, t>, <* \nS,t>} (4) which is shown in Figure 3-(A) (along with the follow\u00ading implicit aliases: < *p, *r >, < \n*q, *s >, < p, p >, < *p, *p>l<T, T>,... ). Now, AOUT at that statement, ignoring its implicit aliases, \nbecomes: { <p, ? >, <*T, V>, <q, S>, <*q, t>, <*s, t>, (5) <*p, t>, <* T,t>, <*p, *q>, <* T,*q>, <*p, \n*S>, <* T,* S>} (6) which is shown in Figure 3-(B). Elements of (5) came from applying the killing rule \n(2) to ArN. Elements of (6) came from applying the generation rule (3) to the following subset of AIN: \n{<p, p>, <p, T>, <*q, t>, <*q, *q>, <*q, *S>}, among which < p,p >, < *q,*q > and < *q,*S > are implicit \nalias relations. Recall that, in the above example, < p, r > in AIN at Si is a may-alias: p and ~ may \nrefer to the same memory location. After the assignment to p in 1, r might still point to v. If< p, T \n> is a must-alias, we can apply the killing rule to r as well as p. This will delete < *TI v > from AOUT, \nresulting in better precision. This corresponds to the case when there is no edge from T to v in Figure \n3\u00ad(B). As another example, consider the program segment in Figure 4. Assuming no aliasing holds before \nSz in the figure, the alias relations after S2 are as follows: {< *p, celll >,< *q, cel12 >}. There \nare 8 alias relations after S5: { < *p, celll >,< *q, cel12 >, < *(ceZ1l.left), cel13 >,< *(celll.right), \n*q >, < *(celil.right), ceU2 >, < *((*p) .ieft), ceU3 >, < *((*p), ~ight), *q >, < *((*p) .right), cel12 \n>}, (7) SI: if(){ S2: p= &#38;y; S3: q= nul~ S4: } else{ Ss: p= &#38;x; S6: q= &#38;z; S7: J; ss : *P \n= ~; Figure 5: Example C Program Segment. and 14 alias relations after SIO: { < *p, celil >,< *q, ceU2 \n>, < *(celil.left), celi3 >,< *(celll.right), cel12 >, < *(celll.right), *q >, < *((*p) .le~t), cel13 \n>,< *((*p) .right), cel12 >, < *((*p) .Tight), *q >, < *(celll.Jeft), cei12 >,< *(celll.left), *q >, \n< *((*p) .left), cei12 >,< *((*p) .left), *q >, < *p, *q >,< *p, cel12 >}0 (8) Later in Section 6, we \nshow how to represent alias rela\u00adtions more compactly. In Figure 5, the alias information at S7 generated \nalong the CFG path S1 --t S2 ~ S7 is Al ={< *p,y>} and the alias information generated along the CFG \npath Sl~S53STis A2 = {< *p, Z>,< *q, Z>}. Among the aliases generated by applying the transfer function \nof 5 S to the alias information Al U A2 resulting from the merge at S7, we have < *y, z >, which results \nfrom the coupling of< *p, y >E Al and < *q, z >e A2. However, < *p, y > and < *q, z > never hold for \nthe same execution instance, and thus < *y, z > never holds immediately after 5 S. Unioning alias information \nat join points of control flow such as S7 can generally result in a loss in preci\u00adsion, unless path-specific \ninformation is kept for alias information [19]. A similar case occurs during interpro\u00adcedural analysis \nin Section 4. A similar technique to the one developed in Section 4.4 can be used for lim\u00adited distinction \nbetween aliases generated along differ\u00adent CFG paths. With this technique, we can identify that < *p, \ny>E Al and < *q, z>C A2 do not hold for the same execution instance and, thereby, do not create < *y, \nz > at S8, resulting in improved preci8ion. 3.2 Cyclic Data Structures Consider the C program segment \ngiven in Figure 6 and the cyclic data structure given in Figure 7, which shows the data structures, in \nterms of r and celll, of the user program resulting from the execution of statements S1 and S2, respectively, \nin Figure 6. For simplicity, we ig\u00adnore the (anonymous) object pointed to by ce~ll. Also, we assume no \nnon-trivial aliasing holds before S1. The alias relationship holding after S1 is, thus, < *r, ceill >. \nAt S2, *celll and &#38;celll play the role of p and q, re\u00adspectively, in Rule 2. Thus, the set {< p, \nu > c AIN} of Rule 3 becomes {< *celll, *celll >, < *ceill, **T >}, and the set AIN (*q) of Rule 3 becomes \n{< ceiil, *T > >< ceill, ceill >}. Rules 2 and 3 yield the following Sl: r = &#38;celll; S2: *celll = \n&#38;celll; Figure 6: Example C Program Segment.  { < *r, eel/1 >,< *r, ***r >,< *r, **celtl >, < ***r, \ncelll >,< ceill, **ceUl >}. (9) Note that the above alias set does not represent the complete (infinite) \nset of alias relations for the cyclic data structure S2 in Figure 7. However, combined with the approach \ndescribed in Section 6.3, the alias relations in the above set are sufficient for deducing the complete \nset of aliases implied by the cyclic structure. 4 Interprocedural Alias Compu\u00adtation In this section, \nwe describe two methods for computing interprocedural aliases. The interprocedural alias so\u00adlution supplies \nALIASEntvv and ALIASEzit for each procedure. In the first method, we compute flow\u00adinsensitive interprocedural \naliasing over the PCG. In the second method, we compute flow-sensitive interpro\u00adcedural aliasing over \nthe PCG, where each node of the PCG is associated with the SEG for that procedure. For a given interprocedural \nproblem, flow-insensitive al\u00adgorithms are efficient but imprecise in comparison to flow-sensitive algorithms. \nWe first illustrate the differ\u00adence between our flow-sensitive and flow-insensitive ap\u00adproaches with \nan example. We then describe our ilow\u00adinsensitive and flow-sensitive anal ysis methods, and fi\u00adnally \ndescribe the technique for identifying realizable execution paths, which applies to both methods. 4.1 \nInterprocedural Alias Example In Figure 8, a flow-insensitive analysis would determine that at some point \nin P, a pointer assignment (S3) in\u00adduces the alias < *U} a >. This alias is presumed to hold everywhere \nin P, including its call site, It is passed for\u00adward along the PCG edge to Q, and is presumed to hold \neverywhere in Q. A flow-insensitive analysis of Q SI S2 Figure 7: Cyclic Data Structure. SO char *u, \na, b, c, .... z; recursion and also due to pointer-induced aliasing.2 It\u00ad eration due to cycles in the \nPCG is accommodated by Sl: P()  S2{ P S3 U=&#38;% {< u,a>} *(J= *R; S4 S5: Q(); 1 -S6: *U= B ; oQ \nS7: }; u = &#38;l?; S8: Q() S9: { S1O: U= &#38;b; Sll: }; Figure 8: Example Program Segment and Its PCG. \n would determine that, at some point in Q, a pointer as\u00adsignment induces the alias < *u, b >. This alias \nis also presumed to hold everywhere in Q, including its exit. The two aliases are passed backward along \nthe PCG edge to P, and presumed to hold everywhere in P. No further changes are introduced, and the iteration \nover the call graph stops. The flow-insensitive alias analysis has determined that the alias set {< *u, \na >,< *u, b >} holds everywhere in P and Q. A flow-sensitive analysis of P would associate alias relation \n< *u, a > with statements S3, S4 and S5. Since Q has not been analyzed yet, no assumptions are made about \nthe call to Q. ALIAS~z~~(P) is also associated with < *u, a >. The alias associated with the call site \nis then propagated forward along the PCG edge to A.LIAS~ntrY (Q). A flow-sensitive analysis of Q would \nassociate < *u, b > with ALIASEZit (Q), because the pointer assignment at SIO has both killed the alias \n< *u, a > and generated < *u, b >. The alias < *u, b > is then passed backward along the call graph to \nthe point just following S5 (the call to Q). since informa\u00adtion has changed in P, another analysis of \nP takes place, and propagates < *u, b > to Sfj and ALIAS@Zit (P). No further changes take place. At the \nconclusion of the flow-sensitive analysis, < *u, a > holds at S3, S~, and SS) and < *u, b > holds at \nS5, se, and S1O. 4.2 Flow-Insensitive Interprocedural Alias Computation Flow-insensitive interprocedural \nalgorithms are based on the PCG, associating summary information with its nodes and propagating this \ninformation through the PCG. As a class they are highly efficient because they do not require a representation \nor analysis of individual routines during the interprocedural component of the analysis. The basic model \nof computing flow-insensitive in\u00adterprocedural aliasing is similar to that of the PTRAN system [31, which \ncomputes this information for FOR-TRAN 77 programs in a single topological-order traver\u00adsal over the \nPCG. The major difference is that iteration over the PCG is required due to cycles resulting from topological-order \ntraversals. However, as described in Section 1, iteration due to pointer-induced aliasing is bidirectional \n-such aliasing is propagated from a callee to its callers as well as from a caller to its callees. To \nac\u00adcommodate pointer-induced aliasing, iterations over the PCG must alternate between topological and \nreverse\u00adtopological order. In flow-insensitive analysis, each node of the PCG is associated with a transfer \nfunction which is a conser\u00advative summary of all the intraprocedural transfer func\u00adtions of the procedure. \nWe assume that static alias in\u00adformation is available; the static alias information for a procedure is \nused to initialize its ALIAS~ntry set. Iter\u00adating through the PCG in alternate directions continues until \nthe ALIASEntTy and ALIASs=it sets converge for all nodes. If the transfer function for a procedure is \ncomputed in a flow-insensitive manner, then it does not kill aliases, but simply generates new ones. \nHowever, where a flow\u00adsensitive analysis of each procedure precedes the f30w\u00adinsensitive interprocedural \nanalysis, transfer functions which generate kill information can be computed and used to yield a more \nprecise solution. Summary kill information is associated with the call sites of a node. Fo~wardKill(Ci) \nrepresents aliases killed between the entry node of a procedure and call site C i in the procedure. BackwardKill(C~) \nrepre\u00adsents aliases killed along paths from call site Cl to the exit node of the procedure. Summary generation \ninfor\u00admation is associated with a PCG node. For node n, AliasGen(n) denotes the set of aliases generated \nby n. The following equations formulate the flow-insensitive alias computation as a data flow problem \nover the PCG which can utilize kill information if it is available: ALIA$E.t,g (nodej ) = u ( (ALIAS~~t.y(nodei) \n-l orwardKill(eij)) e.1 U AliasGen(nodei) ) (lo) ALIASEm~~ (nodej) = u ( (ALIASE.it(nodek) -l?ackwardlfili( \nej~))) e,k U AliasGen(nodej ), (11)  where node i denotes the ith node in topological order and eij \ndenotes an edge (call site) from node i to node j, This problem is solved in a straightforward manner \nby iteration over the call graph (alternating topological and reverse-topological iterations to accommodate \nthe bidirectional character of the problem). For efficiency, the iterative algorithm could be implemented \nwith a worklist representing the nodes yet to be processed. Using dominator trees and postdominator trees \n[8], we compute safe kill information, in time linear with respect to the number of nodes in the control \nflow graph, 2In the presence of cycles, topological order is defined by the removsl of back edges from \nthe PCG [15]. SI: foreach procedure, set ALIASB~t7Y = STATIC.ALIASES; S2: set ALIASE=~t = f}; S3: repeat; \nS4: foreach procedure P visited in a topological traversal over the PCG; S5: compute ALIASH~t~Y of P \nusing A; ateach call site C which invokes F ; S(j: compute flow-sensitive intraprocedural aliasing of \nP, including ALIAS&#38; of P, for each SEG node S;; if S a is a call site G compute A~u~ using A~~ and \nAL~ASEC~t of the called procedure; else compute Aotr~ using AIN and its transfer function; L98: until \naliasing converges; Figure 9: Algorithm to Compute Flow-Sensitive Interprocedural Aliasing as !Ollows: \nForwardKill(C i) UnO&#38;,~DO~(CJ iiaTKiiZ(nOde~ ) BackwardKill(Ci) UnO&#38;,cPDOikr(cJ li=sKii@Odej \n) where A?iasKill(nodei ) is the set of aliases killed at CFG node nodej ~n ac~ordance with Rule 2 in \nSection 3, DOM(C, ) is the set of CFG nodes that dominate Cz, and PDO.M(Ci) is the set of CFG nodes that \npost\u00addominate Ci. Flow-Sensitive Interprocedural Alias Computation Figure 9 describes our algorithm for \ncomputing flow\u00adsensitive interprocedural aliasing. As above, the static aliasing for a procedure is used \nto initialize its ALIASEnt.Y set (see Statement S1 in Figure 9). Inter\u00adleaving the inter-and intraprocedural \nanalyses results in more precise alias information than with the flow\u00adinsensitive method. As described \nin Figure 9, traversals over the PCG in topological order are repeated .3 At step S5 of Fig\u00adure 9, the \nalias information at the entry node of P, ALIASB~t,Y, is computed by first unioning the in\u00adtraprocedural \naliases at the call sites which invoke pro\u00adcedure P and then propagating the resulting set into the entry \nnode of P. At step 5 6, ALIASHZit of the called procedure is propagated back to the call site C for each \ncall in P. ALIASEmit sets computed during the previ\u00adous iteration are used. Once again, for efficiency, \nthe iterative algorithm could be implemented with a work\u00adlist representing the nodes yet to be processed. \nAlthough a called procedure can affect the aliases holding on return from the call sites which invoke \nit, ALIASJM~~ of a procedure does not uniformly affect all the procedures which call it. Rather, the \naliases holding on return from a call site Ca are affected only by a sub\u00ad set of ALIASEZ~t of the called \nprocedure, This subset includes only those aliases induced by aliases holding at C. or generated in the \ncalled procedure independently of the aliases holding at the invoking call sites. Identify\u00ading call sites \nwhose aliases have induced an alias relation in AL.lASEZ;t is related to identifying realizable ezecu\u00adtion \npaths [16].  4.4 Realizable Execution Paths In this section, we describe a method which correctly identifies, \nfor each alias relation of AL~Af$Em;t, the call sites whose aliases have induced the alias relation. \nWe also show how we extend the transfer functions de\u00adscribed in Section 3 to accomplish this. This method \nis applicable to both our flow-insensitive and flow-sensitive frameworks. Assume there are n subroutines \nQI . . . Qn each of which invokes P. Also assume alias relation A~ (1 <= i <= n), which is propagated \nfrom Qi to P as part of ALIAS.z~t?y of P, reaches the exit node of P and becomes part of ALIASEZzt of \nP. When ALIASEZit of P is propagated to the callers of P, Q1 . . . Qn, all of Al ...An might be propagated \nto all of QI ...Qn; not remembering the path(s) in the PCG along which particular data-flow information \nhas been propagated can substantially reduce the precision of the data-flow solution. To distinguish \nthe call sites to which alias relations need be propagated, we define an alias instance (AI) as a triple: \n[alias relation AR, source alias set SASC, call site C], where each member SA of SASC induces the alias \nre\u00adlation AR via C. At the entry node of P, we compute the set of alias instances ALIASE~t.Y of P which \nhold with respect to each call site C that invokes P. For ex\u00adample, if SASC = {< u, v >}, and u and v \nare global to P, an alias instance AI = [< u, v >,{< u, v >}, C] will be in ALIASEntrY (C). By convention, \nwe will use nuli for a trivial source alias < u, u >. Once we com\u00adpute ALIAS~~i,Y (C) for each call site \nC which invokes P, we compute ALIASEntrY of P as follows: sDue to pointers, alias information is propagated \nbidirection- ALIASEnt,Y = /U/IAsEntrg(c), slly. However, in this algorithm, t orological-order iterations \nover u the PCG sre sficient. CCCS(P) where CS(P) is the set of call sites which invoke P. We will use \nALIASEntvY as a shorthand for ALIASE~trY (C) when call site C in question is clear from the context. \nNote that alias instances generated independently of any other (non-trivial) alias have nuil (no) source \naliases and null call sites. We extend the notations defined in terms of alias relations in Section 3 \nto aliaa instances. For example, AIN (z), which is defined to be the set of alias relations in AIN which \ncontain access path x, becomes the set of alias instances in AIN whose alias relations contain x in them. \nNow, we extend the (aliasing) transfer function (Rule 2 and Rule 3) in Section 3 that is based upon alias \nrelations to the following that is based upon alias inst antes. For the following assignment to an l-value \nwith a pointer type: Si:p+q, (12) the new transfer function is as follows: AOu~ = (AI~ Ar~(*p)) U (13) \n{ [AR2(*u/ * q), SAg, C,] I  [< P,U >, SA, CI] 6 AIN, [Al?z, SA2, C2] c AIN(*q), SAg = SA1 U SAZ, (14) \n(Cg=Cl=C,) V((C, =Cl) A(C2 =wj~)) V ((Cl = null) A (C, = C2))}. (15) Note that some alias instances \ndo not have source aliases (nuZi), while some alias instances have more than one source alias. An example \nof the former is when an alias relation is generated independently of any other alias relations. An alias \ninstance of this case has null for its source alias and call site. An example of the latter is when an \nalias relation is induced by more than one alias relations. Informally, Expression 15 states that the \ngeneration rule be applied only when the two alias instances have conforming call sites: either the two \ncall sites are the same or at least one of them is null. In Section 3.1 we observed that unioning alias \nin\u00ad formation at join points of control flow results in a loss of precision. A similar technique to \nthe one developed here can be used for limited distinction between aliases generated along different \nCFG paths. 4.5 Reference Parameters In this and the following sections, we describe how to compute ALIASEat7Y \nfrom A~N sets and how to com\u00ad pute A&#38;~ from A~N and ALIASE~;t of the called procedure. We assume \nthat static aliasing informa\u00ad tion is available; alias instances due to static aliasing are without source \naliases and are used to initialize ALIASEn$TY . We describe the accommodation of ref\u00ad erence parameters \nin this section, and call-by-value pa\u00ad rameters in the following section. We will use AIN for A~N and \nAOUT for A~u~ when the call site C in ques\u00ad tion is clear from the context. Let a$ and jt be the ith \nactual and formal parame\u00ad ters of a subroutine call at call site C in Q which invokes P. Let yi o AR \ndenote the new alias relation obtained by replacing each occurrence of ai (if any) in AR with fi, and \nyt~l o AR denote the new alias relation obtained by replacing each occurrence of fi (if any) in AR with \nai. Formally, ~i o AR = AR(fi/ai), (16) ~Z~l o AR = AR(ai/f; ). (17) We extend the ~ operation to alias \ninstances as follows: -yi o [AR, SAS, C] = [Yi o AR, SAS, C] Also, define 170 AR as the set of alias \nrelations ob\u00adtained by applying every combination of 71... TN to AR, where N is the number of parameters \nat C, and define I ; 10 AR similarly (i.e., y; 1 . . . y~l).4 In the following, when the particular source \nalias sets or call site are not relevant, they will be shown simply as . . ALIASs~t,Y of P is generated \nat the call site C in rou\u00ad tine Q as follows: For each [< u, v >, ., ] c AIN, add the following to ALIAS.gnt7Y \n:  {[ARj, {< %V >}, C] I -4Rj e I o < U,V >}.5 We use the following examples to illustrate the above \nrule. In the examples, we do not show trivial alias in\u00adstances such as [< u, u >, null, null] in the \ngenerated alias instances. 1. For [< u, v >,., .] E AIN, where u and v are global to the callee:6 alias \ninstance: Alk = [< u, v >, < u, v >, C]; 2. From trivial alias [< ai, a~ >] c AIN: alias instance: AI~ \n= [< ai, fi >, null, C]. 3. Assume AIN = {[< *~, z >,., .], [< y,*w >,., .]}, where z,v, w, and z are \nall global variables. Also, .-. assume x and y are passed a; the first and the sec~ ond actual parameters \nto P: al is z, and a2 is y. aylas instances: (a) [<z, f,>, null, C]; (b) [< *fI, Z >,{< *Z, Z >}, C]; \n (c) [<y, f2 >, null, C]; (d) [< f2, *w >,{< Y,*w >},12  Note that in computing ALIASE~t,Y, we do \nnot explic\u00ad itly screen out non-Teachabie aliases of P aliases that contain access paths not reachable \nin P, because such non-reachable aliases of P may become reachable aliases of routines (transitively) \ncalled by P [6]. AOUT at a call site C of P in Q consists of two components: AoUT(nuii) which is the \nset of aliases in ALIASE=~t that are generated independently of 4Since an rdias relation consists of \na pair of access paths, it is sufficient to apply every ~ combination with length up to and including \ntwo. 5Non-reachable aliases, which are harrrdess to keep, can be screened out after interprocedural alias \nanalysis is done. 6The zero length ~ combination is the identit y operator, which is applied in this \ncase. any aliases propagated from the call sit es of P, and A OUT (induced) which is the set of aliases \nin ALIAS~Oit that are induced by one or more aliases propagated from the call site C that invokes P. \nA OUT (null) can be com\u00adputed as follows: AOuT(ntJll) = {[< U,V >,nldl,null] e r- o AI I AI 6 ALIAS~Zat, \nCallSite(Al) = nuli}. (18) To compute AouT(i?zduced), we first compute ALIASEz~t (C), the subset of \nALIASE=~t which need be propagated to call site C, as follows: ALIASjJ.~, (C) = {[<U, V >, SAS, C] E \nr-lo AI I AI G A.LIASE=it}. (19) Now, each alias instance AIP = [A%, SASP, C] c ALIAS~Zi, (C) potentially \ngenerates a set of new alias instances, each of which has the same alias relation (A%), to be prop\u00adagated \nto call site C that invokes P as follows: {AIn = [ARP, S-W., Cm]}, where SASn and Cn are the new source \nalias sets and call sites. Note that some instances in ALIASE3zt (C) may fail to generate any new instances \nto be propagated to C. Also note that SASP is a subset of AIN, since ALIAS~ait (C), from which AIP is \ncomputed, is a set of alias instances induced by alias relations propagated at call site C in Q which \ninvokes P. We now describe how to compute SASn and C., and also describe when alias instances in ALIASBZ;t \n(C) fails to generate instances to be propagated back to C. Informally, SASn is the union of the source \nalias sets of the alias instances in AIN with the same call sites whose alias relation matches one or \nmore of the alias relations in SASP. Formally, SASn and Cn are as follows: SASm = U SASt such that VA&#38; \nE SA;P, 3(AIi = [AR, SAS; , C.]) E AIN. (20) Then, AOUT (induced) is as follows: Aou~(induced) = U {AI.}, \n(21) n and AOUT is as follows: AOUT = Ao~T(nuii) U AO~T(i7z~uce~). (22) Some A&#38; may fail to be propagated \nback to call site C. For example, assume there are two call sites Cl and C2 that invoke Q, and that two \nalias instances AI1 and A12 have been propagated to Q from Cl and C2: AI1 and A12 cannot hold during \nthe same execution in\u00adstance. Also, assume AI1 and A12 both are propagated to P at C in Q which invokes \nP. Now in P, AI1 and A12 both have C as their call sites and can generated AIP as follows: [Al&#38;, \n{AR(AI1), AR(AIz)}, C]. When ARP is propagated back to the caller, Q, we find out that All and Alz have \ndifferent call sites, Cl and Cz, and that AIP is an invalid alias instance. However, we do not attempt \nto invalidate all the alias relations in P (and subroutines transitively called by P) that are induced \nby Ali$. 4.6 Call-by-Value Parameters Let ~i o AIN denote the new aliasing information ob\u00ad tained by \nreplacing each occurrence of *aZ in AIN with x~;. Formally, ~, o AIN = AIN(*fZ/ * ai). (23) Note that, \nin this section, *ai and *fi imply that a% and ~~ are access paths of a pointer type. We also define \nr o AR similar to I o AR for reference parameters, but in terms of ~ s. Then we compute ALIASE~t~Y of \nP for call site C in Q as follows: . For each [< U,V >, ., .] c AIN, add the following to ALIASEnt.Y \n: {[ARj, {< u, v >}, c]IARj E iO < U, v >}.7 An example of this rule is the trivial alias relation < \nu, u > of a pointer-type global variable u passed as ith parameter, which results in the following alias \ninstance at the entry node: [< *u, *.fi >, null, C]. Although correct for computing alias information, \nthe rule is not enough for correct side-eflect analyses, such as MOD and USE [4], of a subroutine call. \nWe describe later whv this rule is not enough for correct side-effect analys~s and how to augment the \nrule for correct side-effect analyses. As before with reference parameters, AOUT at a call site C of \nP in Q consists of two components: AOUT (null) and AOUT (induced). AOUT (nuil) can be computed as follows: \n.40~T(nu~~) = {AI= [<u, v >, nu~l, null] I AI 6 ALIASEZit, CallSite(AI) = null}. (24) Notice that unlike \nin Equation 18, there is no 1 1 oper\u00ad ation involved in Equation 24. ALIAS~mZt (C) is com\u00ad puted as \nfollows: ALIAS~Zit(C) = {AI= [<u, V >, SAS, C] AI ~ ALIASECit}. (25) Also, notice the lack of r-1 operation \nin Equation 25. Then, we compute AOUT (induced) and finally AOUT the same way we compute for reference \nparameters de\u00adscribed in the previous section. 7AS with the reference pars,ITIet er case, non-reachable \nfiases can be screened out. SI: SUB1 { S2: int A, B; S3: _ SUB2 (&#38;A,&#38; B); S4: }; S5: SUB2 (int \n*fl, *f2) { S6: int *tmp = fl; S7: fl =f2; S8: f2 = tmp; *f1 = $fp; S9: Slf) : }; Figure 10: Example \nProgram Segments with Value Pa\u00adrameters  5 Side-Effect Analysis with Pointer Parameters The conventional \nmethods for side-effect analysis [4, 5, 9] decompose the computation into separate direct side-effect \nand alias analyses. Aliasing is factored into direct side effects after they have been computed. In the \npresence of pointers, side-effect analysis cannot be per\u00adformed separately from alias analysis, and this \ndecom\u00adposition produces an incorrect solution. In this section, we illustrate that the conventional method \ndoes not cor\u00adrectly handle pointers, and describe our solution. Figure 10 shows procedure SU.BI passing \ntwo point er parameters to procedure SUB2. With conven\u00adtional side-effect analysis, the USE and MOD sets \nof procedures SUB2 are as follows [4]: USE(SUB2) = {*f2}, MOD(SUB2) = {*f I}, which shows that the access \npath involving the first pa\u00adrameter is in MOD and the access path involving the second parameter is in \nUSE. With the side-effect information of SUB2 com\u00adputed as above, by the conventional method, the first \nactual parameter (A) is regarded as modified, and the second actual parameter (B) k regarded as used \nat S3, which is incomec~ B is the one that is modified, and A is the one that is used at S3. Our solution \nis to compute side-effects of a proce\u00addure as a part of alias analysis by introducing a Tep-Tesent ative \npaTameieT T~ for each ith actual parameter local to the caller. Thus, with SUB2, we introduce T1 and \nT2 along with fl and f2. With that, we create [< T1, *?1 >, null, C] and [< r2, *j2 >, null, C] as part \nof ALIASB~tTY of SUB2, where C denotes the particular call site that invokes SUB2. Now, A.LIAS~z~t (SUB2) \nwill have the following alias relations: < *tmp, *f2 >,< T2, *fl >,and < T1, *f2 >, and the USE and \nMOD sets of SUB2 will be aa follows: t7f7E(St7B2) = {T1}, M0D(St7B2) = {T2}, which do not include access \npaths local to SUB2: *f 1 and *~2. In mapping the USE and MOD sets of SUB2 to its call sites, we map \nT1 to the first parameter and ~2 to the second parameter. With this, we correctly compute that B is modified \nand A is used at S3. SI : int ceill, cel12, *p; S2: celll =...; S3: ce112 =...; S4: p = &#38;celll; tij: \n*p =...; S6: p = &#38;cel12; S7: . ..= *P; Figure 11: Example C Program Segment, Apart from the cost \nof alias analysis, this side-effect analysis does not incur any cost beyond conventional side-effect \nalgorithms. The precision of the side effect analysis algorithm depends on the underlying alias anal\u00adysis \nmethod. 6 Naming for Correctness, Pre\u00adcision and Efficiency The naming of memory locations is required \nfor the cor\u00adrectness of data-flow analvsis. We address this issue in the beginning of this sec~ion. Further, \nnaming tech\u00adniques described in the remainder of this section im\u00adprove the precision and efficiency of \nour alias analysis methods. 6.1 Data-Flow Analysis and Aliasing In classical data-flow analysis without \npointers, uses and clefs at each statement are first computed in terms of (variable) names associated \nwith the accessed memory locations. Then, alias information for each variable is used to identify additional \nvariables potentially used or defined at each statement. While the association be\u00adtween a name and its \nmemory location does not change within a name scope, the association between a pointer expression and \nits memory location can (repeatedly) change within a name scope. For example, during an execution instance \nof the code segment in Figure 11, the memory location associated with access path *p changes from cezil \nto cel12, while the memory locations associ\u00adated with names celil and cel12 do not change. The result \nis that while there should be a clef-use data-flow chain [2] from S3 to S7, there should be no clef-use \nchain from S5 to S7. We propose the use of memory locations (variable names) aliased to a pointer expression \nrather than the pointer expression per se for data-flow analysis. With this scheme, S5 performs a write-access \nof ceiil, which is aliased to *pat that statement, and S7 performs a read\u00adaccess of cel12, which is aliased \nto *p at that statement; correctly identifying the clef-use chain from Ss to Sr becomes straightforward \nwith this method. We refer to memory locations associated with names, such as celll and cel12 in the \nexample, as named objects. Since we use the named obiect. rather than the access path through pointers \nalia~ed to the named ob\u00adject, we do not Jose any data-flow information by not keeping alias pairs such \nas < *p, *q > that do not con\u00adtain a named obiect. However. with such alias ~airs discarded, a tran~tive \nclosure operation is requireh for correctness. With the compact representation described Using aliased \nmemory locations is possible only when pointers point to named objects. For anonymous ob\u00adjects in a heap \nstorage (memory) returned by a storage allocator such as m allot in C, we use a naming scheme in Section \n6.3, the transitive closure does not result in a call graph edges in it. With this scheme, the number \nand loss of precision. Therefore, we do not keep alias pairs length of name strings are bounded by the \nprogram size, without named objects.s while the capability of distinguishing different instances of the \nobjects created at the same place is compromised. 6.2 Naming Anonymous Objects based on the place (statement) \nin the program where an anonymous object is created as in [7], combined with the k-limited approach: \nwe allow up to k instances of the object to have distinct names for each statement, where k is a pre-determined \nconstant (as in [14, 21, 18, 13]). We thus ensure that a pointer expression is always associated with \nat least one named object to which it is aliased. The named obiect, instead of the access ~ath of the \nexpression itself, is used for data-flow analy~is. A Dotential drawback of this naming scheme is that \ndiffere~t instances of anonymous object; created at the same m allot statement, but along different paths \nin the PCG, become indistinguishable, as shown in Figure 2. Our namine method aualifies these named . \nanonvmous objects with an addit~onal name string that captures call Dath information. With this scheme. \nwe identifv t wo qua fified names as identical if and only if one qu~lified name is a vrefix substrimz \nof the other. For e~ample in Figu~e 2, we first name the object allocated in SUB3 as, say, iVsl based \non the malloc statement. At the call site of SUB3 in SUB1, the name becomes e~~sl, and *T becomes aliased \nto e3iVS1; and at the call site of SUB1 in main, the name becomes e1e31Vs1, and *p becomes aliased to \ne1e3iVs1. At the call site of SUB3 in SUB2, the name becomes eAIVsl, and *s becomes aliased to e~~~l:-., \nand at the call site of SUB2 in main, the name becomes e2e4NS1, and *q becomes aliased to e2e41Js1. Note \nthat names are pre\u00adfixed with PCG edges when they are propagated from the callee to the caller, but not \nwhen and after they are propagated from the caller to the callee. Therefore, ob\u00adject names, propagated \nfrom a caller to a callee, do not change when they are propagated back from the callee to the caller.g \nIn main, we identify *r and *p as accessing the same named object since *T is aliased to e1e3Ns1, which \nis a prefix substring of (in fact identical to) the named object to which *p is aliased. Note that *r \nis aliased to e1e3Ns1 in main, while it is aliased to e3iVs1 in SUB1. We also identify *s and *q as aliases \nfor the same rea\u00ad son. However. *D and *a are not aliases since the obiect name to which ~p is ali~sed \nis not a prefix substrin~ of the object name to which *q is aliased, and vice versa. In SUB4, we identify \n*tand *r as accessing the same named object since *t is aliased to IVs 1, which is a sub\u00ad string of e3Nsl, \nto which *r is aliased. We handle call chains with cycles (due to recursive calls) by not allowing a \nname string to have duplicate 8Alias information such as < *p, *q > can be useful for data\u00adflow analysis \nwithin a set of contiguous statements during which no alias information changes with respect to *P or \n*Q. If so, we can easily maintain such alias pairs. 9Note that alias information propagated from a caller \nto a callee can be propagated from the callee only to that caller, not to other callers.  6.3 Compact \nRepresentation of Alias Information Alias information such as given in (7) and (8) can be re\u00adgarded as \nexhaustive information: it contains all explicit alias relations holding at each statement. However, \nex\u00adhaustive alias information holding at each statement is rarely needed. In most cases for a statement, \nalias rela\u00adtions of only those access paths referenced at that state\u00adment are needed, and having exhaustive \ninformation for all the access paths at each statement incurs unneces\u00adsary time and space cost. Pointer-induced \nalias relations determine a directed graph as shown in Figure 3: < *p, a > implies that there is a (de-referencing) \nedge from object p to object a. Likewise, < **q, b > implies that there exists an object c such that \nthere is an edge from q to c and one from c to b. Since every object pointed to by a pointer has a unique \nname in our analysis, < **q, b > implies the existence of < *q, c > and < *c, b > for some (named) object \nc, from which we can deduce < **q, b >. Each named object corresponds to a unique node in the directed \ngraph. We improve the time and space efficiency during alias analysis by keeping only alias relations \nwith no more than one level of de-referencing. Full alias informa\u00adtion is expanded later as needed when \nalias information is factored into general data-flow analysis. For a given access path, the corresponding \npath(s) in the directed graph is (are) traversed to determine the named ob\u00adject(s) to which it is aliased. \nDuring this traversal, the number of de-references encountered must be counted. Note that this is equivalent \nto performing -transitive re\u00ad duction [1] over the directed graph of alias relations dur\u00ad ing alias analysis, \nand later computing full alias infor\u00ad mation on demand. With this compact representation, alias informa\u00adtion \nof (7) in Section 3 will become: { < *p, celll >,< *q, cel12 >, < *(ceil l.iejt), cei13 >, < *(ceill.right), \ncel12 >}, (26) and alias information of (8) will become: { < *p, ceill >,< *q, cel12 >, < *(celil.le~t), \ncel13 >, < *(ceill.right), ceH2 >, < *(celll.ie~t), cel12 >, < *p, cel12 >}. (27) Later at S1l in Figure \n4, we readily obtain alias relations of *p as {< *p, celll >, < *p, cel12 >}. At S12, we can compute \nalias relations of *(*p). le f t as follows: {< *(*p. Jeft), eel/3 >,< *(*p. ieft), cel12 >} by combining \nthe following alias relation in 27: { < *p, ceiil >,< *(celll.left), celi3 >, < *(celll.left), cel12 \n>}. (28) S1: p = &#38;x; S1: x = &#38;y; S2: q=p; S2: p=q =&#38;x; S3: *p = &#38;y; S3: x = &#38;z; \n Figure 12: Example C Program Segment. An advantage of the transitive reduction/closure method is demonstrated \nby the code fragment listed in Figure 12. In our compact representation the alias re\u00adlations at S2 are \n< *q, z > and < *p, z >. The alias relations atS3are<*q,x>,<*p,x>,and<*x,y>. We generate the alias relation \n< **q, g > by applying our transitive closure operation at S3. A full represen\u00adtation would require that \nthe additional alias relation < *p, *q > be added at Sz in order to determine that the alias relation \n< **q, y > exists at S3. 6.4 Compact Representation and Preci\u00adsion of Alias Information Performing the \ntransitive reduction of alias relations can improve the precision of alias information. Consider the \nprogram segment of Figure 13. Assuming no aliases hold before S1, < *x, y > is the only alias after S1. \nAfter S2, the exhaustive alias relations holding are as follows: { <*x, y>, <*p, x>, <*q, x>,< *p, *q>, \n< **p, y >, < **q, y >,< **pl*z >, < **q, *x >, < **p, **q >}, (29) all of which can be represented by \nthe following transi\u00ad tive reduction: {< *p, z >,< *q, z >,< *Z, y >}. (30) After S3, the transitive \nreduction information becomes: {< *p,8 >,< *q, z >,< *X, Z >}, (31) from which the exhaustive information \ncan be com\u00adputed: <*x, z>, <*p, z>, <*q, z>,< *p, *q>, { < **p, z >,< **q, z >,< **p, *z >, < **qt*x \n>, < **p, **q >]. (32) The difference between (29) and (32) is that every access path y in (29) has \nbeen replaced by z in (32). However, the exhaustive alias information com\u00adputed by applying S3 directly \nto (29) is as follows: < **p, y>< **q, y>}u (33) { { <*x, z>, <*p, z>, <*q, z>,< *p, *q>, < **p, z >, \n< **q, z >,< **pj*z >,< **qt*x >, < **p, **q >}, (34) which contains additional alias relations (33), \nwhich are carried over from (29) ,10 These alias relations are orig\u00adinated from < *x, y > at S1 and {< \n*p$x >, < *q,z>} loNote that < **P, *Z > and < *X9, *Z > h 34 SK implicit aliases derived from < *P, \nz > and < *q, 0>, respectively. Figure 13: Example C! Program Segment. at S2. Once generated, however, \nthey have lost their sources and are carried over after S3, although S3 in\u00advalidates one of their sources: \n< *x, y >. Therefore, performing the transitive reduction not only improves the efficiency of the analysis, \nbut can improve the pre\u00adcision as well. Note that the same immoved rsrecision. can also be obtained by \nkeeping must-~lias information: If we keep the information that < *p, x > and < *q, x > are must\u00adaliases, \nwe can regard *p and *q as being modified at S3 in the figure, and can apply the killing rule to them \nas well as z.  7 Complexity Analysis There are three distinct phases of our flow-insensitive alias algorithm: \ninitial intraprocedural analysis for gen\u00aderation and optional killing information, interprocedu\u00adral iteration \nover the PCG, and final intraprocedural analysis. The space complexity of the analysis during the first \nand second phases is O(V * T * P), where V is the total number of distinct objects (i.e. variables and \nnamed anonymous objects), T is the maximum number of aliases for an object, and P is number of procedures \nin the program. The space complexity can also be ex\u00adpressed as O(A* P), where A is the maximum number \nof alias relations holding at a statement. This is expected to be smaller than V *T. The space complexity \nduring the final phase is O(A * S), where S is the number of statements in the program. The time complexity \nof the intraprocedural killing analysis is linear in the height of the dominator tree and in the height \nof the postdominator tree of each procedure and is, thus, O(P * S). The time com\u00adplexity during the second \nphase is 0(A2 * P2). The time complexity of the final intraprocedural phase is O(d*(A* (C+M) +T2 *N)), \nwhere C is the total num\u00ad ber of call sites, ill is the total number of MeetNodes in the SEGS, iV is \nthe total number of nodes of all the SEGS (minus call sites and MeetNodes of the pro\u00ad gram), and d is \nthe loop-connectedness parameter, the largest number of back edges on any cycle-free path of the program \ns control flow graphs [15]. it4 and IV can grow linearly with the size of the program, but are expected \nto be small in practice. The overall time complexity of the flow-insensitive algorithm is, thus, 0( P* \nS+ A2*P2+d*A* C+d*A*M+d*T2*N). There are three distinct phases of our flow-sensitive alias algorithm: \nthe SEG construction phase, during which the SEG for intraprocedural alias analysis is con\u00ad structed \nfor each procedure; the interprocedural phase during which, by iteration over the PCG, ALIAS,ga~t and \nALIASEtit?Y of each procedure are computed; the final intraprocedural phase, during which aliasing is \ncomputed for the access paths of each statement in each procedure. The final intraprocedural analysis \nis the same as with the flow-insensitive algorithm, and is ana\u00adlyzed above, In the construction of the \nSEG for a proce\u00addure, the time (and space) complexity is C.FE2+C$ IV2, where CFE (CFN) is the number \nof edges (nodes) in the control flow graph [8]. For this phase, then, the complexity is EE + iVN2, where \nEE (NiV) is the to\u00adtal number of nodes (edges) in the control flow graphs of the procedures in the program. \nIn practice, the com\u00adplexity of SEG construction is 0(C17E + CF Ar) for a procedure and so O(EE + NiV) \nfor a program [11]. The space complexity during the interprocedural phase is O(A * P). The interprocedural \nphase dominates the time complexity. The worst case requires O(A * P) iter\u00adations over the PCG. The time \ncomplexity to compute new AL1AS,gnt7Y of the procedures for each iteration over the PCG is O(d*(A* (P+ \nC+ M)+Z 2 *N)). The overall (inter-and intraprocedural) time complexity of the flow-sensitive algorithm \nis O(d * A2 * P2 + d * A2 * P* C+d*A2*P*M +d*A*P*T2*N), where the last term is dominant. In practice, \nwe expect the iteration over the PCG to converge rapidly, resulting in the over\u00adall time complexity of \nO(k(Aa*(P+ C+ M)+ Tj*N)), where k is a small constant, Aa is the average number of aliases holding at \na statement, and Ta is the average number of aliases for an object. 8 Related Work The most closely \nrelated work is that of Landi and Ryder [16, 17], which present algorithms for computing aliasing for \nthe same language constructs that we con\u00adsider here. Our method for computing intraprocedural aliases \ndiffers from theirs in that it employs a sparse representation, which provides a more efficient frame\u00adwork \nthan control flow graphs. Our transfer functions are simpler to use than their alias-generating rules \nbased on case analysis. Our method for computing interprocedural aliases, and for relating inter-procedural \nand intra-procedural alias relations, also differs from theirs. Their method computes may-aliasing based \non may-hold information. May-hold is a relation whose arguments are a set of aliases AA, a node in the \ncontrol flow graph n, and an alias pair < a, b >. It represents whether < a, b > holds at n, assuming \nthat there is a path from the program entry node to the entry node of the procedure containing n, for \nwhich every alias in AA holds. The algorithm of [17] finds the may-hold relations which are trivially \ntrue, and computes the set of all true may-holds using a worklist technique. May-aliasing can be computed \nfrom the may-hold solution in time linear with respect to the size of the solution. The worst case time \ncomplexity of their method is 0(S * V4 + P * V6), where V is the number of variables, S the number of \nstatements, and P the number of procedures in the program. The worst case complexity of our method, corresponding \nto setting T = V and A = V2 in Section 7, is 0( N* V4*P), where P is the number of procedures and N is \nthe total number of SEG nodes of the program, which is substantially smaller than S, the total number \nof statements in the program. To reduce the number of alias sets considered in the may-hold computation, \nwhich is potentially a pow\u00ad erset of 2n elements (with n alias relations (Al . . . An ) holding at the \nentry node), their method approximates by allowing for only singleton assumed-alias sets, each of which \nhas at most one alias relation. With this ap\u00adproximation, they keep only n + 1 assumed alias sets (AA(0) \n= {}, AA(1) = {Al},..., AA(n) = {An}) out of 2m possible sets, resulting in a loss of precision (which \nwe do not incur) in the presence of more than one level of pointer de-referencing. Another related area \nis the work done in conflict de\u00adtection between dynamically allocated recursive struc\u00adtures [7, 18], \nIn treating recursive structures, we use a naming scheme based on the statement in the pro\u00adgram where \nan anonymous object is created as in [7], combined with the k-limited approach (as in [14, 21, 18, 13] \n). A previous drawback of this naming scheme is that different instances of anonymous objects created \nat the same ma IIoc statement but along different paths in the PCG become indistinguishable. We have \nimproved this by qualifying named anonymous objects with a name string that captures call path information. \nWit h this scheme, we substantially improve alias information by distinguishing different instances of \ndynamically allo\u00adcated objects. Intraprocedurally, our method is similar to the work done in conflict \nanalysis [7, 12, 13, 18]. How\u00adever, our met hod is the first to accommodate e recursive data structures \nwithout explicitly building graphs. Our method, which uses Sparse Evaluation Graphs, is more efficient \nthan methods based on control flow graphs. Again, our method includes an efficient and accurate computation \nof int erprocedural alias information, while these graph-based methods in general either do not ad\u00address \nor poorly address the interprocedural aspects of computing aliases. Finally, we are the first to show \nthat the conven\u00adtional method for computing side effects of procedure calls (MOD and USE) based on [4] \ndoes not work in the presence of pointers. We develop an algorithm which handles pointers without loss \nof efficiency or precision. 9 Conclusions We have movided accurate and efficient methods for computing \nintra-and interprocedural aliases and side effects for languages like LISP, C, C++ and Fortran 90 which \ncontain reference parameters, pointers and recur\u00adsion. Without interprocedural alias analysis and pro\u00adcedure \nside effect information, compilers must make worst-case assumptions about formal parameters and variables \nglobal to a procedure. These assumptions im\u00adpede optimizations and can result in inefficient code, particularly \nfor a language like C for which pointer us\u00adage and procedure calls are generally frequent, We have demonstrated \nthat our flow-sensitive in\u00adterprocedural alias method is more efficient and precise than existing methods. \nWe have developed a new flow\u00adinsensitive interprocedural alias analysis method which accommodates pointers. \nThis method is highly efficient and also provides a framework for computing alias so\u00adlutions with varying \ndegrees of precision. The efficiency of our interprocedural analyses is im\u00adproved by identifying realizable \nexecution paths and by distinguishing different instances of dynamically allo-[10] cated objects created \nalong different call paths. We have presented a technique for naming memory Ioca\u00adtions which guarantees \nthe correctness of data flow anal\u00adysis. We have also developed techniques for compacting alias information. \n[11] We have developed an efficient technique for pre\u00adcisely computing procedure call side effects in \nthe pres\u00adence of pointers, including the passing of pointers as reference or value parameters. [12] \nAcknowledgements The authors are grateful to their colleagues in the PTRAN group for their contributions \nto this paper. [13]Special thanks to Ron Cytron, Jeanne Ferrante, Michael Hind and Edith Schonberg for \ntheir advice and sugges\u00ad tions. We would also like to acknowledge Fran Allen, for her advice and support. \n[14] References [1] A. V. Aho, M. R. Garey, and J. D. Unman. The transitive reduction of a directed \ngraph. SIAM Journal on Computing, 1(2):131-137, 1972.  [2] A.V. Aho, R. Sethi, and J.D. Unman. Compil-[15] \neTs: Principles, Techniques, and Tools. Addison-Wesley, 1986. [16] Ron Cytron, and Jeanne Ferrante. An \noverview of the ptran analysis system for multiprocessing. Proceedings of -the ACM 1987 Intemationai \nCon\u00adference on SupeTcomputingl 1987. Also published in The Journal of Parallel and Distributed Com-[17] \nputing, Oct., 1988, 5(5) pages 617-.640. [3] Frances Allen, Michael Burke, Philippe Charles, [4] John \nBanning. An efficient way to find the side effects of procedure calls and the aliases of vari\u00adables. \nConjeTence Record of the Sixth ACM Sym\u00adposium on Principles of PTogTamming Languages, [18] pages 29-41, \nJanuary 1979. [5] Michael Burke. An interval-based approach to ex\u00adhaustive and incremental interprocedural \ndata-flow analysis. ACM Transactions on PTogTamming Lan\u00adguages and Systems, 12(3):341-395, July 1990. \n[19] [6] Michael Burke and Ron Cytron. Interprocedural dependence analysis and parallelization. P? oceed\u00adings \nof the Sigplan 86 Symposium on CompileT Construction, 21(7):162-175, July 1986. [20] [7] David R. Chase, \nMark Wegman, and F. Kenneth Zadeck. Analysis of pointers and structures. Pro-[21] ceedings of the ACM \nSIGPLAN 90 Conference on Programming Language Design and Implementa\u00adtion, 25(6):296-310, June 1990. [8] \nJong-Deok Choi, Ron Cytron, and Jeanne Fer-[22] rante. Automatic construction of sparse data flow evaluation \ngraphs. Conference Record of the Eigh\u00adteenth Annual ACM Symposium on Principles of Programming Languages, \nJanuary 1991. [9] Keith D. Cooper and Ken Kennedy. Interproce\u00addural side-effect analysis in linear time. \nP? oceed\u00adings of the Sigpian 88 Conference on PTogTamming Language Design and Implementation, 23(7):57\u00ad66, \nJuly 1988. Atlanta, Georgia. Keith D. Cooper and Ken Kennedy. Fast interpro\u00adcedural alias analysis. \nSizteenth ACM Symposium on PTincipies of PTogTamming Languages, pages 49-59., January 11-131989. Austin, \nTexas, Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. Ef\u00adficiently \ncomputing static single assignment form and the control dependence graph. ACM Trans\u00ad actions on Programming \nLanguages and Systems, October 1991. Laurie J. Hendren and Alexandru Nicolau. Par\u00adallelizing programs \nwith recursive data structures. IEEE Transactions on PaTaUel and Distributed Sysi!em, 1(1):35-47, January \n1990. S. Horwitz, P. Pfeiffer, and T. Reps. Dependence analysis for pointer variables. %oceedings of \nthe ACM SIGPLAN 89 Conference on PTogTamming Language Design and Implementation, 1989. N. D. Jones and \nS. S. Muchnick. A flexible ap\u00adproach to interprocedural data flow analysis and programs with recursive \ndata structures. Confer\u00adence RecoTd of the Ninth Annual ACM Symposium on Principles of PTogTamming Languages, \nJanuary 1982. John B. Kam and Jeffrey D. Unman. Global data flow analysis and iterative algorithms. JA \nCM, 23,1:158-171, January 1976. William Landi and Barbara G. Ryder. Pointer\u00adinduced aliasing: a problem \nclassification. Confer\u00adence RecoTd of the Eighteenth Annual ACM Sym\u00adposium on Principles of PTogTamming \nLanguages, pages 93-103, January 1991. William Landi and Barbara G. Ryder. A safe approximate algorithm \nfor interprocedural pointer aliasing. ??oceedzngs of the ACM SIGPLAN 92 Conference on Programming Language \nDesign and Implementation, pages 235-248, June 1992, J. R. Larus and P. N. Hilfinger. Detecting con\u00adflicts \nbetween structure accesses. %oceedings of the ACM SIGPLAN 88 Conference on PTogTamming Language Design \nand Implementation, 23(7):21\u00ad34, July 1988. Eugene W. Myers. A precise inter-procedural data flow algorithm. \nConference RecoTd of Eighth ACM Symposium on Principles of PTogTamming Lan\u00ad guages, 1981. Barry K. Rosen. \nData flow analysis for procedural languages. JACM, 26(2):322-344, April 1979. C. Ruggieri and T. P. Murtagh. \nLifetime analy\u00adsis of dynamically allocated objects. Conference RecoTd of Fifteenth ACM Symposium on \nPrinciples of PTogTamming Languages, 1988. Robert Tarjan. Fast algorithms for solving path problems. \nJournal of the Association foT Comput\u00ading Machinery, 28(3):594-614, 1981.  \n\t\t\t", "proc_id": "158511", "abstract": "<p>We present practical <italic>approximation</italic> methods for computing interprocedural aliases and side effects for a program written in a language that includes pointers, reference parameters and recursion. We present the following results: 1) An algorithm for <italic>flow-sensitive</italic> interprocedural alias analysis which is more precise and efficient than the best interprocedural method known. 2) An extension of traditional <italic>flow-insensitive</italic> alias analysis which accommodates pointers and provides a framework for a family of algorithms which trade off precision for efficiency. 3) An algorithm which correctly computes side effects in the presence of pointers. Pointers cannot be correctly handled by conventional methods for side effect analysis. 4) An alias naming technique which handles dynamically allocated objects and guarantees the correctness of data-flow analysis. 5) A compact representation based on transitive reduction which does not result in a loss of precision and improves precision in some case. 6) A method for intraprocedural alias analysis which is based on a sparse representation.</p>", "authors": [{"name": "Jong-Deok Choi", "author_profile_id": "81423596242", "affiliation": "", "person_id": "PP80029956", "email_address": "", "orcid_id": ""}, {"name": "Michael Burke", "author_profile_id": "81406595896", "affiliation": "", "person_id": "PP39069893", "email_address": "", "orcid_id": ""}, {"name": "Paul Carini", "author_profile_id": "81100615742", "affiliation": "", "person_id": "P221033", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158639", "year": "1993", "article_id": "158639", "conference": "POPL", "title": "Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects", "url": "http://dl.acm.org/citation.cfm?id=158639"}