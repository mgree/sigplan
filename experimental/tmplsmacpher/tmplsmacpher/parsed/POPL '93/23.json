{"article_publication_date": "03-01-1993", "fulltext": "\n Constructing call multigraphs using dependence graphs Arun Lakhotia The Center for Advanced Computer \nStudies University of Southwestern Louisiana Lafayette, LA 70504 (318)231-6766, -5791 (Fax) ~a.mn@cacs.usl.edu \n 1 Introduction A call m.ultigraph of a program is a directed Multigraph encoding the possible calling \nrelations between procedures. These graphs are used in in\u00adterprocedurd program optimization [2, 3, 9, \n15] and for reverse engineering of softw~are systems [7, 8]. For programs that do not contain pro\u00adCedul \ne valued variables (referred to hencefollh as procedure variables) this graph can be constructed by a \nsingle pass over the program collecting the procedures called at each call site. When pro\u00adcedure v,ari.ables \nand indirect calls using values of such variables are allowed constructing such a graph is not so simple. \nIn the worst case, the value of a procedure v,ariable at a call site may be a reference to any procedure \nin the program. For interprocedural optimizations and for under\u00adstanding programs one would like to have \nmore precise solutions. The importance of precisely constructing an analogue of call graph (referred \nto as the Ot}l order control flow analysis or OCFA) in the context of higher order languages such as \nScheme and ML has been eloquently elaborated by Shivers [18]. A precise call graph enables data flow \noptimizations * In ths paper call multigmph is also refereed to as the call graph. Ths work was supported \nby the grant LEQSF (1991-92) ENH-98 from the Louisiana Bowl of Regents. Permission to copy without fee \nall or part of this material is granted provided that the copies are not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. ACM-20th PoPL-1 /93-S. C., USA \n@ 1993 ACM 0-89791 -561 -5/93 /0001 /0273 . ..$1 .50 that in tum enables efficient implementations of \nprograms in these languages. The precision of a program s call graph affects the precision of interprocedural \nanalysis in Foman compilers as well [5]. This paper describes a new polynomial time algolithm for constmcting \nsuch a call graph that is precise within the limitations ofj?ow insensitive interjxocedural analysis. \nThe key aspect of our solution is our model of the problem as a constant propagation problem over the \ndomain -powerset of all procedure constants with set union as the meet operator. We call this the problem \nof prop\u00adagating sets of procedure-values and show that this problem, unlike constant propagation prob\u00adlem, \nbelongs to the class of distributive flow anal\u00adysis problems [12]; it is therefore decidable. Our algolithm \nperforms interprocedural flow analysis [10] to constmct the graph. We de\u00advelop an interprocedurd procedure \nvahles prop\u00adagation algolithm by amfilgamating Wegman and Zadeck s constant propa@ion algorithm [20] \nand Horwitz, Reps, and Binkley s interprocedural for\u00adward slicing algolithm [11]. Interprocedural analyses \nthemselves depend on call muhigraph. Our algolithm resolves the conflict by iteratively propagating procedure-values \nover a system de\u00adpendence graph representation of a program [11] and constmcting the call graph, till \na fixed point is reached. We give a formal definition of the term precise call graph and prove that the \ncall graph constructed by our al.golithm is precise. Our al\u00adgolithm computes precise call graphs for \na larger procedure P(X, Y); procedure maino; proc var X, Y; proc var A, B; x := Y; proc ref P, Q, R, \nS; end; (-~. P(A, Q); *1: *A(); procedure Q(), C2 : P(B, R); procedure R(); . C3: S(B); procedure S(Z); \nC4 : P(A, P); proc var Z; 12: *A(A, S); 14: *20; 13: *A(Q); end; end; Figure 1 A program with procedure \nwriables and indirect calls. class of programs than the works in[4,5, 17, 18, 19, 21]. The rest of the \npaper is organized as follows. Section 2 establishes the terminology and formu-Iates the problem. Section3 \ndiscusses theprevi\u00adous works on this problem and elaborates upon oLlr Contribution. Section 4 Sumrn,wizes \nHorwitz et. al. s system dependence graph (SDG) and ou rextensions. For more details about SDGs the reacleris \nreferred to [11]. Section 5 gives our in\u00adterprocedural procedure-values propagation algo\u00adrithm. Section \n6 gives the algolithmto construct the call graph. Section 7 proves that our algo\u00adrithm computes precise \ncall graph and analyzes its complexity. It is followed by our conclusions and the list of references. \n2 Problem formulation We consider programs written in a procedural language that permits indirect calls \nthrough pro\u00adcedure valued variables. parameters across a pro\u00adcedure call are assumed to be passed by \ncall by value-result. Global variables are not permitted. Only variables are allowed in the actual parameter \nlist of procedure calls and repetition of variables in this list is not allowed. These restrictions pro\u00adhibit \naliasing in programs. The language, parame\u00adter transfer mechanism, and these restrictions are all inhelited \nfrom Horwitz et. al. [11] since we use their system dependence graph for represent\u00ading programs. These \nrestrictions can be removed using the methods suggested by them. if A in {p] ,pz} then { if A == pl then \npl(zl,12, ...). else if .4 == pz then p2(zl, z2, ...); } else { if A == p3 then p3(zl, z2, ...); else \nif A == p4 then p4(zl, z2, ...). else if A == p5 then p5(zl, z2, ... ); else terminate ubnormolly. ) \n Figure 2 Code segment used to reify an indirect call *A(z1, x2, ...) at site c, where fkf(ct) = {Pi, \nP2} The prog~am in Figure 1 will be used as a running example. , The statements starting with an * are \nindirect call statements. Further, it is assumed that a special procedure main exists that initiates \nthe execution. Definition: (Domain constraint). A procedure variable in a program can only be defined \nus\u00ading assignment statements that either have a pro\u00adcedure reference or a procedure variable on the right \nhand side. V This constraint prohibits one to assign nu\u00admeric expressions that evaluate to the physical \nmemory address of a function as one may do in programming languages such as C. Definition: (Completeness \nconstraint). Only pro\u00adcedures contained in a program may be called from a call site inside the program. \nV In the absence of this constraint a procedure may call another procedure external to the pro\u00adgram which \nmay then call some procedure within the program. Such a call will go undetected. Definition: Let P = \n{pl, pj, .... pn}, 72>0 be the set of procedures in a program (including main). We associate a unique \nidentifier to all statements of a program. Let C = {cl, c2, ....c~}. n2 > 0, be the set of (identifiers \nof the) indirect call vertices in the program. Let P be the power set of P. V Definition: The problem \nof constructing a call graph is essentially the same as creating a map\u00adping Lf : C + P, that maps each \nindirect call site to a set of procedure references constituting the procedures that may be called from \nthat site. For c, this set is denoted by lkf(cz). V Definition: A call graph is dynamically precise if \n for every call site Ci, AI(cZ ) contains only those procedures that can be called from Cz for some initial \nstate a. V This definition is not useful since it relies on dynamic characteristics of the program. \nWe would like a definition that depe~ds on a pro\u00adgram s static characteristics. The obvious defini\u00adtion \nbased on paths in the flowgraph also does not suffice since due to presence of indirect calls the paths \nare not known statically. We solve the problem by transforming the program P to PM to P~ such that PM \nis free of indirect procedure calls and Pfi has no procedure calls at all. The three programs are equivalent \nunder declarative semantics. Note that Pfi is introduced only to define the notion of statically precise \ncall graph. It is only manipulated mathematically to establish properties of our algolithm. Definition: \nLet PM denote the program due to expanding indirect call statements in program P with respect to a mapping \nfll as follows. If Cz contains *A(z1, x2, ...) and IVf(cz) = {pi, pz} then the call in c~ is replaced \nby the code segment in Figure 2. All other statements of P are copied asistoPM. V Definition: P~ is the \npotentially infinite single procedure due to exhaustive inlining of procedure calls inside procedure \nmain of program PJf. V The outer if introduced by expanding a c1 in PM does not contribute to its meaning \nbut serves to create different paths for procedures contained in kf(ci ) and those not contained in it. \nThe statements in the then side of an outer i~statement in PM (not P~ ) are said to lie on the true branch \nand those on the else side in the false branch. Definition: An ill-path in the flowgraph of PJ~ is a \npath in it that does not contain any statement that is an instance of some statement in the false branch \nof PM. (Refer to [1] for definitions of flowgraph and path). V Definition: A mapping J14 is conservative \niff it has the property: if 3 a statement s 1 in P~ such that &#38; S1 contains VI := pj, b. in the flow \ngraph of PJf there is an M\u00adpath from .sl to C: (an instance in P~ of the outer ij statement in PM that \ncorre\u00adsponds to cZ), c. a sequence of identity assignments copy  the value ofs 1 into the variable \nused in d. then c:, and there is an Jkf-path the flowgraph to S1 I]i E lf(cz). from start vertex of Q \nThe condition says that if the program exe\u00ad cution takes a path such that some statement SI propagates \nprocedure reference pj to C: then the call graph should state that j)j may be called from c~. But reification \nof indirect call sites may intro\u00adduce paths in the program that may not really happen. The condition \nthere is an M-path from the start vertex to s 1 removes such paths from consideration. When the definition \nis applied from procedure main onwards, we claim that it will require all procedures that are called \nfrom a call site to be included in the call graph. The mapping is conservative since Jf(cj ) may contain \nprocedures whose values can not be propagated to C3 through any path starting from main. Definition: \nA mapping Ad is optimistic iff it satisfies the property resulting from swapping the antecedent and the \nconsequent of the definition of conservative. V This is the inverse of the definition for con\u00adservative. \nIt says that 114(c~) should not contain a procedure reference if there is no path through which its value \ncan be propagated to CZ. Definition: A mapping is stdcally precise if it is both conservative and optimistic. \nWe show that the call graph computed by our algolithm is precise in the above sense. 3 Comparison with \nprevious works 4 System dependence graph The call multi.graph constmction problem has previously been \nstudied by Ryder [17], Burke [4]+, and Callahan et. al. [5], Spillman [19] and Weihl [21]. Our work may \nbe compared with these on a) constraints imposed on the usage of procedure variables and b) the precision \nof the resulting call Multigraph. The work of Burke, Ryder, and Callahan are specific to Fo~lran in which \na) procedure valued variables are only allowed as procedure parame\u00adters and b) assignments to formal \nprocedure pa\u00adrameters is not allowed, they can only receive pro\u00adcedure values from actual parameters. \nAmongst them, Burke s and Callahan et. al. s algorithms work for recursive Fortran programs where as \nRy\u00adder s algolithm does not. Further, Callahan et. al. s and Ryder s algorithms return more precise call \ngraphs than Burke s. The program in Figure 1 uses procedure vari\u00adables in a way not permissible in Fortran, \nhence Burke, Callahan et. al., and Ryder s [4, 5, 17] algorithms can not constmct its call graph. Our \nalgolithm is therefore applicable for a larger class of languages than these works. If, however, our \nalgolithm is applied to the same class of language as Callahan et. al. s and Ryder s work, respec\u00adtively, \nit is our con:jectuve that results returned will identical. Spillman [19] and Weihl [21] work with a \nprocedural language that permits label valued variables and aliasing. Due to the presence of label variables \nthey do not even have the flow graph of a program. As a result they can not as\u00adsume any ordering in a \nprogram s statements. The results of the analysis are vely imprecise. The call graph constmcted by our \nalgolithm and that due to Weihl s are given in Table 1 (towards the end of the paper). The reader may \nnotice the differ\u00adence in the results. * The chapter concerning constmchon of call Multigraph in [4] \nlms been omitted from its jounxd version published in ACM TOPLAS (July, 1990). Horwitz et. al. s SDG \nencodes the data, con\u00adtrol, and call dependence relations between state\u00adments~ of a program in a simple \nprocedural lan\u00adguage stated in Section 2 [11]. The next para\u00adgraph outlines the wuious types of vertices \nand edges in an SDG as defined by Horwitz et. al. For a more detailed description the reader is re\u00adfereed \nto [11]. The SDG consists of a collection of procedure dependence graph (PDG) (a variation of program \ndependence graph [14, 16]). There is one PDG per procedure in the program encoding the control and data \ndependence relations within the proce\u00addure. The various types of vertices in a PDG are: for statements \n assignment, ifi while, jinaluse, for procedure call call site, actual-in, actual\u00adout, and for procedure \nently -entry, .fo~mal-in, formal-out. The edges connecting vertices within a PDG are control and jlow \nedges. The edges be\u00ad tween vertices of different PDGs are: call edge from a call-site to an entry vertex; \nparameter\u00adin edge from an actual-in to an <formal-in ver\u00adtex; parameter-out edge from formal-out vertex \nto actual-out vertex; and summary edge from an actual-in to an actual-out vertex. Our extension.. We \nextend Horwitz et. al. s def\u00ad inition of SDG to contain indirect call vertices to represent an indirect \ncall. Each indirect call vertex has its pairs of actual-in and actual-out vertices that have flow edges \nconnecting them to the vertices within the PDG. Since the pro\u00ad cedures called from an indirect call statement \nare not known its vertices ,are not connected to ver\u00ad tices of any procedure ently and there are no sum\u00ad \nm,my edges between the actual-in and actual-out vertices. Our algolithm to construct call graph is iter\u00adative. \nAs procedures that may be called from an indirect call site ,are detected the SDG is modi\u00adfied to represent \nthis knowledge. For each pro\u00ad s It also has another dependence called the clef-order dependence which \nis not relevant for our work. This dependence is thel-efore ignol-ed in this paper. ,j&#38;. .. .~&#38;[ \n ,~.1-.o A-I _o A_i A_o P_o ,W :P-._:. ,B- :.~ ~ -------. ;? :, ,, , --4 / ~~ =----= .1 . ... // ~ , \n,, , H~,, , .,; ~ , ,, , ) [d)&#38; :, , Z_i Z:o j ,. {4*Z ; L / i...,. -----.... ,, ... Figure 3 \nSDG of program in Figure 1. Legend for vertices: rectangular boxes -entry ovals -direct and indirect \ncalls; dotted oval -other statements; @X -not a true vertex, shows usage of reference to procedure X; \nA_i or A_o -parameter vertex (actual or formal depending on geometric proximity with entry or call vertex), \n_i denotes _in and _o denotes _ouL dotted polygon -PDG of each procedure. Legend for edges: shaded arrows \n-parameter-in and parameter-out edges; solid arrows \u00addata dependence edges. To avoid clutter the control, \nindirect-control, and call edges are not shown. cedure that may be called from an indirect call to the \nentry vertices of the corresponding proce\u00ad site we introduce a virtual call-site and connect dures. This \nSDG can be created using Horwitz et. it by an indirect control edge emanating from the al. s algolithm. \nFigure 3 gives the initial SDG of comesponding indirect call site. The virtual call\u00ad the program in Figure \n1. sites too have actual-in and actual-out vellices and they may be connected by summ,wy edges. Flow \ndependence edges entering or exiting the 5 Propagating procedure actual parameter vertices of a virtual \ncall site ~a.re values using SDG copied from those of the indirect call site. These vertices are also \nconnected by parameter-in and The goal of constant propagation is to dis\u00ad parameter-out edges to the \nformal vertices of the cover values that are constant on all possible exe\u00ad comesponding procedure. cutions \nof a program and to propagate these con\u00ad stants as far as through the program as possible It may be reemphasized \nthat the virtual call [6]. The constant propagation algorithms of [6, site vertices ,are created by our \nalgolithm. In the 13, 20] use a jlat lattice and the following meet initial SDG only (direct) call sites \n,are connected sules: global G /* an SDG */; procedure PropagateProceciureValues; { I* Put root nodes \nin Worklist *I Wolkltst := d put nodes in G containing p:=c into WoTkltst, where p is a procedure variable \nand CE P; unmark all nodes I* Propugate constants to calling procedures *I propagateUsingSelectiveEdges(Worklist, \n[flow, summary, parameter-in)); let Worklist be the set of all nmrkeci nodes; I* Propagate constants \nto called procedures *I propagateUsingSelectiveEciges(IT orkl~ d, [flow, summary, parameter-out]); } \nprocedure propagateUsingSelectiveEdges(Worklist, EdgeTypes); { P p~opagate constants ji-otn vertices \nin Worklist by traversing only edges of type in Edge Types *I while WoTkl%st # d do { select and remove \nan element v from W or lclzst for every vertex Ml such that v -w is an edge whose type is one of EdgeType \nY do { if w. Value # w. Va17Le U u. VcJue w. Value := w. Value U v. Value; put w in Wo~klZst; } } \n} I* Initializations to be done before Pt-opugateProcedureValues is called *I procedure Initialize { \nfor every node sin G do { if s is an indirect call site: s. Value .= ~; if s assigns a procedure variable \nto a procedure variable: s. Value := @; if s assigns a procedure reference c to a procedure variable: \ns. Va/ue := c } } Figure 4 Algorithm for propagating procedure values using SDG. aAb=Tifa#b site in \nthe program may take. To differentiate with uAa=a the constant propagation problem we call this the problem \nof propagating procedure values. aAT=T The domain constraint of Section 2 stated in aAl=a Kam and Unman \ns [12] terminology implies that If the j?at lattice is replaced by the po]ver the function space for \nthis problem consists of set of all values in a given domain and the meet only the identity function. \nIt is therefore a dis\u00adoperator by set union these algorithms may not tributive flow ,analysis problem \nand, unlike tra\u00adterminate for infinite domains such as integers ditional constant propagation, can be \ncomputed or real numbers. However, if the domain is precisely. The reader may note that since the call \nfinite (as is the set of all procedures in a given Multigraph problem is formulated in terms of the program) \nthe algorithms will terminate [12] and flow graph of I$j its computability may be anal\u00adreturn the set \nof all values a variable at a given ysed using Kam and Unman s framework. Our procedure ConstructCrdlGraph; \n{ construct PDGs for all procedures Initialize; (See Figure 4) repeat Construct the SDG using Value \nof procedure variables at indirect call-sites PropagateProcedureConstants (see Figure 4) until Value \nof no indirect call-site changes I* create call graph M) is given *I VC, ~ C : A4(ct) = ct. Va/ue. 1} \nFigure 5 Algorithm for constructing call graph algolithm however does not use flow graph. cessed and \nthe condition when vertices may be added to it is retztined from Wegman and Zadeck s Figure 4 gives an \nalgolithm to propagate [20] algorithm. Due to the domain constraint, an sets of values of domain 7 for \nour extension assignment statement (of interest to us) can only of Horwitz et. al. s system dependence \ngraph have one vatiable on the right hand side. This re\u00ad [1 1]. The procedure Initialize should be called \nmoves the need to introduce join nodes, as done before PropagateProcedureValues is called. It has been \nkept outside because in the next sec\u00adby Wegman and Zadeck. tion PropagateProcedureValues is called in \na loop We have not used Callah,an et. al. s inter\u00adwhere the initializations need only be performed procedural \nconstant propagation algolithm [6] for once. Examples enumerating the working of the our problem because \nit gives results less precise algorithm are also presented in the next section. than our algorithm. This \nis because Callahan et. Horwitz et. al. have noted that indiscriminate al. s summaty information is computed \nby ignor\u00adtraversal of an SDG S edges can create a depen-ing the existence of other call sites. Our algo\u00addence \npath between vertices of two procedures lithm has access to the PDG of the procedure and even when none \nexists. This happens because a hence there is no approximation. Our algorithm procedure entry vellex \nmay be connected to mul-can however not be used to propagate constants tiple call sites. A traversal \nmay use pammeter-in when the domain constraint is removed. edge coming out of one call site and p,arameter\u00adout \nvertex returning to another call site to create the incomect linkage. Horwitz et. al. termed this 6 Constructing \ncall graph the calling context problem and developed a two pass traversal to solve it for their interprocedu- \nThe algorithm for finding the set of proce\u00adral forward slicing algolithm [11]. The first pass dures called \nfrom (an indirect call-site is given in of their algolithm uses only control, flow, sum- Figure 5. The \nalgorithm is iterative. The Value maty, and parameter-out edges for traversing the of an indirect call-site \nthe set of field gives pro\u00adgraph. Similarly, the second pass uses only con\u00ad cedures known to be called \nfrom that site. Before trol, flow, summiuy, call, and parameter-in edges. the first iteration this is \ninitialized to the empty Since we need only data dependence we drop the set. The SDG is updated at each \niteration to add control and call edges from the two passes; which virtual call sites con-esponding to \nthe Value of explains the choice of p~ammeters to propagate\u00ad the indirect call sites. The procedure values \nare UsingSelectiveEdges in Figure 4. then propagated over the SDG potentially chang-The Worklist to maintain \nvexlices to be pro-ing the Value of some indirect call site. The SDG ..... @R !.,, m / L--=-=+. J ./ \nJ.. \\,,,, ~~ \\, k Y_o  ;... ; ,,  ., 13 (J%_) < Q_i x:= Y,,; / / ~ . Figure 6 Parfial SIX after \nfirst iteration. Legend: shaded ovals -indirect call-sites; thicker solid at-rows this iteration. shaded \narrows -new parameter in/out edges; Not call-site. Adding nodes ancl edges from previous iteration will \nis updated a,gain and the process iterated until the Value of all the indirect call-sites stabilize. \nWe now apply the algorithm to the program in Figure 1 whose initial SDG is given in Figure 3. In this \nSDG the PDGs for procedures Q and R and all the control and clef-order edges have been ignored. The nodes \nof the indirect call sites have been labelled 11, 12, 13, and 14. The program requies four iterations \nof the repeat loop to propagate all the procedure constants. Figures 6 to 8 give the new SDG due to Value \nafter the end of each iteration. The virtual call-sites created as more Value of indirect call-sites \nget known care shown in shaded ovals. They are labelled Vl, V2, V3, V4, and V5. Table 1 gives the Value \nfor these nodes initially and after each iteration. For the sake of comparison, it also contains the \n-new flow edges added after shown: edge from indirect call-site to virtual make this SDG complete. values \ngenerated using Weihl s algolithm [21]. The other call graph construction algorithms do not process programs \nin our language and hence their results for this program can not be compared against ours. At the end \nof the first iteration, the proce\u00addure references Q, R, and P from call statements Cl, C2, and C4 are \npropagated to the indirect call-sites 11, 14, and 12, respectively (see Figure 6). Notice that 14 an \nindirect site in procedure S is connected to call site C2 of Main through an\u00adother call site C3 (also \nin Main.). Similar propa\u00adgation of constants across procedures through call sites in the same procedure \nis not permissible by Callahan et. al. s interpocedural constant prop\u00adagation algorithm [6]. Virtual \ncall sites VI, V2, and V3 are introduced in the SDG to reflect the ~g...  ;:EIl:~ , i-i Q-,~_. Bi ,.:xp:. \n~~~g~~ 1 0 o VI .7;;*..:J C!!!3 B_] -B.o A_i S_l A_o s ~ ....... . ..,,,. .,,,w-~-o -;Q .,,,/ -~ ....,,, \n., ~4 ~,~$> ! X_i ,~ i Y_o , .. . . //,-----\u00ad:%x:= Y ... ----\u00ad. . . . . ., . . . ~ ,-..., ,m, s ,; \n~ ~ ,i) ,,.,,... ;~s . , Q_i %0 ,,..... ...  -..,.,.::.,,.............. . ........ . .... .  ( ...... \n... .,, ,. .  ,,::.,,. ;.....: ..... ,, ..... ._ z_o  ; \\ .L : .. ! Figure 7 Partial SDG after second \niteration new knowledge. the value of a vellex can change is / P / (the maximum length in the lattice \n( P, ~)). The second iteration (see Figure 7) propagates procedure reference S from the virtual call-site \nV2 We now prove that the call graph created by (related to 12) to another indirect call-site 13. A our \nalgorithm is statically precise. The proof is new vil~ual call-site V4 is introduced. based on two conjectures \na) the SDG adequately The third iteration propagates a procedure represents a program s dependencies \nand b) the reference Q from the virtual call-site V4 (related SDG traversal algorithm only traverses \ndata de\u00adto 13) to indirect call-site 14. A new virtual call pendence paths. The interprocedm-al slicing \nalgo\u00adsite V5 is introduced. In the fourth iteration no rithm of Horwitz et. al. [11] is based on these \nmore values ,are propagated. Hence there is no conjectures. change in the SDG and the algolithm terminates. \nOur algorithm may be viewed as creating a sequence of call graphs A&#38;., Ml,. ... Mr where ~Ji(cj) \n= Cj. V (71U~, VC1 C ~ 7 Correctness and complexity before the ithiteration. analysis The gist of the \nproof is as follows. J40 is The algorithm of Figure 5 is guaranteed to optimistic because ~cj, &#38;f. \n(cj ) = ~. We prove terminate because a) the program is assumed to that if ikfi is optimistic then so \nis Ali+l. Finally, be complete, b) there are finite number of pl-o-M., the call graph on termination \nof the algolithm cedw-es, and c) the maximum number of times is conservative because there ,are no procedure \n@R @Q -.. / -. \\   ,,,  53=i7: hti ~~ ,, ,...i,g,!:,, ; v 1 ;;:*(N :.5y:~&#38;$ B_l +B_o ... \n,. .,. . .. ....... ... + \u00ad / .................  / \\/: / :, i , fi \\Yo. 1 &#38; :,,x:=y : ., . .. \n.......... . .. --- , .. .. ,/ . ..... ..{ Figure 8 Partial SDG after third iteration values that \nmay reach an indirect call site Cj and are not already in Jf(cj). Hence ~ is Precise. Since the precise \ncall graph is defined in terms of P&#38; and Al-paths, while our algolithm uses system dependence graph, \nwe first draw a relation between the two. This requires introducing some more notations. Definitiorx \nT (PM) removing from PM statements introduced call sites. Notice the relation is the program the else \npart after replacing between l fi created by of all the if the indirect and ~(~~)m. All the paths in \nT(PM )@ are A/f-paths and all the M-paths of Pfi are also contained in T(piw)m. Definition: Let GM denote \nthe SDG for P with virtual call sites for the call Multigraph defined by Jf. Definition: Lett G&#38; \nbe the potentially infinite graph created by replacing a call-site and the actual parameter vertices \nby the corresponding entry and formal-parameter vertices. Conjecture 1: Gfi is kornowhic to the PDG \nOf T(PJf)m. From this conjecture one may say that if in P~ the value of a variable defined at a statement \nz reaches a statement y then there will be a data dependence edge ing to ~ to that Conjecture 2: Horwitz \net. al. s in Gfi from vertex correspond\u00adcorresponding to y. When traversing an SDG using interprocedural \nforward slicing algolithm, if a vertex of a vertex w then in and w , instances of tively, such that \nthere v is found to be in the slice Gfi there exist Vertices V vertices v and w, respec\u00adis a path from \nv to w . Since we only use a subset of the type of edges used in each pass of Horwitz et. a .$s forward \nslicing algolithm it can be infemed that if there is a path in our system dependence graph Table 1 Values \nof indirect-call sites initiatly and at the that path is also traversed by Horwitz et. al. s end of each \niteration. The last column shows ~algorithm (with appropriate slicing criterion). the mapping due to \nWeihl s method. From the above conjectures we can infer the following. Every path (sequence of edges) \nof GJI traversed by our algolithrn comesponds to a set of paths in G~ which only represent flow of data \nalong some paths in r ( PfiI ) m and therefore along M-paths of Pflf. By definition, in the flow graph \ncomesponding to ~ (PJI )m there is a path from the start vertex to all the vel~ices. Hence, evely vertex \nof G~l used in our algorithm to create the initial ll~ork~ist is reachable from the start vertex over \nan M-path in the corresponding flowgraph. Lemma: If Mi is optimistic then M,,+ I is opti\u00ad mistic. Proofi \nFor all c~ ~ C if there exists a procedural value pj in &#38;li (c~) then it also exists in M,+l (c~ \n). If the four conditions for the optimality of M are tme in P8, then they <are also tme in Pti, +,. \n We therefore only need to concern about the condition when there exists pj in Jl~+l (c~ ) and not in \nlk~~(cJ. For a procedure value to be added to the Value field of any ve~lex in the i + lt~ iteration \nthere must exist an assignment statement that assigns the value to a variable and there must exist a \npath in CJflt along which the value reaches that vertex. These paths also exist in Gfit+l. Since all \npaths in a G~I are M-paths and since the domain con\u00adstraint allows only identity assignments to proce\u00addure \nvariables the four conditions in the definition of optimistic constraint are satisfied. Hence, if Jll \nis optimistic then so is Illt+l. V Theorem: The call graph M = M. created by algorithm of Figure 5 is \nstatically precise. Proofi Follow from above Lemma and that ter\u00admination implies Illm is conservative. \nV Complexity analysis. Let there be N vertices (including parameter vertices) that define proce\u00addure \nvariables. Since maximum times the value of a vertex can be changed is I P 1, the SDG may at worst be \ncreated N. I P / times. The computa\u00adtion of SDG can be done in polynomial time [11] Call-[teration Iteration \nIteration Weihl s site 1 2 3&#38;4 method 11 Q Q Q P,Q,R,S I 12 P P P P,Q,R,S I 13 s s P,Q,R,S 4 14 \nR R R,QR,Q 1h hence the construction of a call graph may also be done in polynomial time. Notice, that \nin each iteration new vertices and edges are added to the SDG, they are never re\u00admoved. Intermediate \ninformation extracted by the SDG construction algolithm can be saved so that successive iterations may \nonly perform incremen\u00adtal work to update the SDG. The complexity of the resulting algorithm then adds \n(not multiplies) a polynomial to the worst case complexity of Hor\u00adwitz et. al. s algolithm. More details \nare beyond the scope of this paper. 8 Conclusions We revisit the problem of constructing call Multigraph \nof a program that contains indirect calls to procedures using procedure variables. The problem has previously \nbeen looked at by Spillman [19], Ryder [17], Weihl [21], Burke [4], and Cidlahan et. al. [5]. Shivers \n[18] solves an equivalent problem in the domain of functional languages and terms it zeroth order control \nflow analysis (OCFA). We present a polynomial time algolithm that gives statically precise call rnuhigraph \nfor a larger class of procedural language than those dealt by Ryder, Burke, Callahan et. al., Spillman, \nand Weihl s. Our algolithm is significant because the precision of interprocedural data flow analyses \npelformed by optimizing compilers depend on the precision of the call graphs they compute. Call graphs \nare also used for reverse engineering of software systems and provide cross reference for program understanding. \nThe precision in comput\u00ad ing such a graph can also significantly help these activities. Acknowledgments: \nWe thak Rajiv Bagai ancl William Lancli, on their comments on an earlier version of this paper. The referees \ncomments were helpful in improving the presentation of this paper.  References [1] Aho, A. V., Sethi, \nR., and Unman, J. D. Compilers: Principles, Techniques, and Tools. Addison-Wesley, 1986. [2] Allen, F. \nE. Interprocedural data flow analysis. In Proceedings IFIP Congress, 1974 (1974), North-Holland, pp. \n398-402. [3] Banning, J. P. An efficient way to find the side effects of procedure calls and the aliases \nof vari\u00adables. In Proceedings of 6th Annual Symposium on Principles of Programming Languages (1979), \nACM, Pp. 29-41. [4] Burke, M. An interval-based approach to ex\u00adhaustive and incremental interprocedural \nanaly\u00adsis. Tech. Rep. RC 12702, IBM Research Center, Yorktown Heights, NY, Sept. 1987. [5] Callahan, \nD., Carle, A., Hall, M. W., and Kennedy, K. Constructing the procedure call Multigraph. IEEE ITans. Softw. \nEng. 16, 4 (Apr. 1990), 483487. [6] Callahan, D., Cooper, K. D., Kennedy, K., and Torczon, L. Interprocedural \nconstant propagation. In Proceedings of the SIGPLAN 86 Symposium on Compiler Construction (June 1986), \npp. 152-161. [7] Chikofsky, E. J., and Cross II, J. H. Reverse engineering and design recovery: A taxonomy. \nIEEE Soflware (Jan. 1990), 13 17. [8] Choi, S. C., and Scacchi, W. Extracting ancl restructuring the \ndesign of large systems. IEEE Soflware (Jan. 1990), 66-71. [9] Cooper, K. D., and Kennedy, K. Efficient \ncom\u00adputation of flow insensitive interproceclural sum\u00admary information. In Proceedings of the ACM SIGPLAN \n84 Symposium on Compiler Construc\u00adtion (.kne 1984), pp. 247 258. [10] Hecht, M. S. Flow Analysis of Computer \nPro\u00adgrams. North-Holland, New York, 1977. 11] Horwitz, S., Reps, T., and Binlcley, D. Interpro\u00adcedural \nslicing using dependence graphs. ACM Vans. Program. Lang. Sy.st. 12, 1 (1990), 26-60. 12] Karn, J. B., \nand Unman, J. D. Monotone data flow analysis frameworks. Acts Informatica 7 (1977), 305-317. r [13] Kildall, \nG. A unified approach to global program optimization. In Proceedings of the first ACM Symposium on Principle \nof Programming Lan\u00adguages (Oct. 1973), pp. 194-206. [14] Kuck, D. J., Muraoka, Y., and Chen, S. On the \nnumber of operations simultaneously executable in FORTRAN-like programs and their resulting speed-up. \nIEEE >ansactions on Computers C\u00ad12, 12 (Dec. 1972). [15] Myers, E. A precise interprocedural data flow \nalgorithm. In Proceedings of the 8th Annual Symposium on Principles of Programming Lan\u00adguages (Jan. 1981), \npp. 219-230. [16] Ottenstein, K. J., and Ottenstein, L. M. The pro\u00adgram dependence graph in a software \ndevelop\u00adment environment. ACM SIGPLAN Notices 19, 5 (May 1984). [17] Ryder, B. G. Constructing the call \ngraph of a program. IEEE Bans. Soflw. Eng. SE-5, 3 (May 1979), 216-226. [18] Shivers, O. Control-$ow \nAnalysis of Higher-Order Languuges. PhD thesis, School of Com\u00adputer Science, Carnegie Mellon University, \n1991. [19] Spillman, T. C. Exposing side-effets in a PL/I op\u00adtimizing compiler. In Proceedings IFIPS \n(Com\u00adputer Soflware) Conference (1971), pp. 5&#38;60. [20] Wegman, M., and Zadeck, F. Constant propaga\u00adtion \nwith conditional branches. ACM 2&#38;ans. Pro\u00adgram. Lang. Syst. 13, 2 (Apr. 1990), 181-210. [21] Weihl, \nW. E. InterProcedural data flow analysis in the presence of pointers, procedure variables, and label \nvariables. In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages \n(Jan. 1980), pp. 8? 94.  \n\t\t\t", "proc_id": "158511", "abstract": "", "authors": [{"name": "Arun Lakhotia", "author_profile_id": "81100057684", "affiliation": "", "person_id": "PP40035866", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158647", "year": "1993", "article_id": "158647", "conference": "POPL", "title": "Constructing call multigraphs using dependence graphs", "url": "http://dl.acm.org/citation.cfm?id=158647"}