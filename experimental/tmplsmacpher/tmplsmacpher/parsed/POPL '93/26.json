{"article_publication_date": "03-01-1993", "fulltext": "\n A Constructive Logic of Multiple Subtyping Harry G. Mairson Cambridge Research Laboratory Digital Equipment \nCorporation Cambridge, Massachusetts 02139 Abstract 1 Introduction We show how a higher order logic, \nthe calculus of con\u00adstructions, can be used to give a sirnpk, first principks treatment of record calculi, \npolymorphism, and subtyp\u00ading. The development follows the constructive idiom of extracting implementations \nof equationally specified pro\u00adgrams from proofs of their termination, with a logic for reasoning about \nprograms, and a semantics that comes as a gratuity. In this framework, records are finitely speci\u00adfied \nfunctions where equality is decidable over the domain, with types that are a particular kind of logical \nassertion. By proving that a record specification satisfies its type, we can extract its implement at \nion. W bile program ex\u00adtraction serves as a sort of compiler, proof normalization serves as m interpreter; \nthe latter serves to ensure in some sense the coherence of the translation embedded in the former. This \nsimple minded approach lets us show, for exam\u00adpie, that many inference rules found in record and object \ncalculi can be derived they are just provable lemmas in higher order logic. We see explicitly how from \nsubtyping proofs we can extract, using conventional methods, coer\u00adcion functions between underlying representations \nof data types. By further exploiting the computational metaphor of higher order logic, we can realize \nan interpreter for recursively defined objects, as well as subtype and inheri\u00adtance relations between \nthem. Recursive types for objects are explained by primitive recursion in higher types. The approach \nalso gives a computational understanding of F\u00adbounded polymorphism. *On leave from Brandeis University, \nWaltham, Mas\u00ad sachuset ts. Supported in part by NSF Grant CCR\u00ad 9017125, and grants from Texas Instruments \nand from the Tyson Foundation. Permission tc) copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the title of the publication and its date appsar, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee Type \ntheory has played an important role in the de\u00adsignand analY5isofprogramming languages, since types can \nbe used to prevent certain run-time er\u00ad rors resulting from type mismatch, to formally rea\u00adson about \nthe behavior of programs, and to spec\u00adify module interfaces. The latter point, in particu\u00adlar the checking \nof module interfaces through type compatibility, has been taken up by the proponents of object-oriented \nprogramming, where module inter\u00adfaces describe the functionality of methods invoked by differing vocabularies \nof messages, and the notions of subtyping and inheritance formally indicate where one kind of module \ncan be substituted for another. Records provide a simple and well defined func\u00adtional programming metaphor \nfor object oriented programming, since records associate labels (object oriented messages) with values \n(object oriented meth\u00adods) [Car88]. Adding and removing fields from a record then corresponds to adding \nand removing mes\u00adsages and met hods from an object; these values can of course be procedures in a functional \nprogramming setting. Adding and removing fields from a record type similarly corresponds to mutation \nof object ori\u00adented class declarations. Many proposals have been made for typed record calculi. Some \nof the original proposals stayed close to the ML type system, where both type checking and type inference \nare practically feasible, and type principality is achievable. More sophisticated type systems and logics \nhave led some researchers away from such feasibility in return for powerful mathemat\u00adical elegance. The \ncalculi are typically presented as a set of inference rules, with proofs that the inference system satisfies \ntypical properties such as Church-Rosser, strong normalization, etc., with added con\u00adstructions of semantic \nmodels of the calculi. Research in this area has also dealt with how to effect transla\u00ad t.Ions of programs \nfrom one such calculus to another, and to characterize the so-called coherence of these and/or specific \npermission. ACM-20th PoPL-l/93-S.C., USA g 1993 ACM 0-89791 -561 -5/93 /0001 /0313 . ..$1 .50 translations, \nThis general program of research raises an impor\u00adtant question: to what extent are these inference sys\u00adtems \nmere logic? By logic we do not mean well defined or rational in the colloquial sense, but Teal logic, \ni.e., predicate calculus and its higher order gen\u00aderalizations. Are these type systems for records an \nelegant syntactic sugar for proving assertions about programs? We want to show that many (but to be fair, \nnot all) of the desirable features of typed pro\u00adgramming languages for records and objects with sub\u00adtyping \nand inheritance can be achieved using simple, well known principles of higher-order logic. We provide \nsupporting evidence for this belief, for example, by providing an outline of a soundness proof for the \nCardelli-Mitchell record calculus. We do this by giving a Klgher-order logical specification of what \nrecords are, as well as showing how to code types as record specifications. Record types are repre\u00adsented \nexplicitly as dependent products in a logical sense. This formalization is carried out in the calculus \nof conwbwctions [CH88], a computational framework for formalizing intuitionistic arguments. As a conse\u00adquence, \nwe show that the Cardelli-Mitchell inference rules follow from principles of pure logic. Questions about \nconfluence, normalization, and soundness can then be deferred to their general treatment in the calculus \nof constructions. Also discussed is the issue of realizability in the con\u00adtext of logic. In recent work, \nfor example, Cardelli has proposed a justification of record calculi via a trans\u00adlation into a variant \nof the Girard/Reynolds type system Fa, augmented with subt yping rules [Car9 1]; Breazu-Tannen, Coquand, \nGunter, and Scedrov have also described how programs in a type discipline with subsumption can be translated \ninto one with explicit coercion instead [B CGS91, BGS90]. In a similar spirit, Church invent ed an informal \ntj ust ificat ion of arithmetic via a translation into lambda calculus, i.e., Church numerals. It was \nshown by Girard, and later by others in variants of hls basic insight, that Church s coding could be \nexplained by purely log\u00adical reasons: namely, by extracting programs (i.e., lambda terms) from proofs \nof termination of recumive programs, where these programs were defined over in\u00adductively specified data \n(i.e., integers). Can a transla\u00adtion of a record calculi into lambda terms be carried out automatically \n) (that is, logically) using simi\u00adlar methods? We show that this is indeed the case, though the programs \nextracted are hardly extraordi\u00adnary.-We discuss how the basic idea of coherence of translations gets \nreinterpreted in this context, as well as the computational necessity of coercion functions. It is not \ndifficult to extend the presented frame\u00adwork for records and record types to (recursively de\u00adfined) objects. \nIn the propositions-as-types analogy, recursive types translate naively into infinitely Iong logical \nformulas. It seems massive overkill to employ infinitary logic to describe points, stacks, and num\u00adbers; \nalso, strong normalization of proofs in higher or\u00adder logic appears untenable in the context of infinitely \nlong formulas. Instead, we introduce primitive recur\u00adsion at the level of higher order types to iterate \nob\u00adject type constructors. This construction allows us to simulate all the usual examples of objects, \nand to show the soundness of a standard rule for proving a subtyping relation between recursively defined \ntypes. We argue that inheritance is not subtyping [CHC90] because inheritance is not logical. We also \nshow how our general approach provides a computational inter\u00adpretation of F-bounded polymorphism [CCHOM89]. \nIn this watered-down Principia Maihematica of typed objects and records, we realize that many people \nare searching for an aestheic way to talk about these computational phenomena; as a conse\u00ad quence, differing \nperceptions of beauty provoke dif\u00ad fering opinions as to the appropriateness of various calculi. This \npresentation was motivated by the sim\u00ad ple idea that types are propositions about programs, so that an \nanalogy develops between type checking and proof checking on one hand, and type infer\u00ad ence and theorem \nproving on the other hand. How far can this simple analogy be pushed to solve new problems with old technology? \nGiven that power\u00ad ful calculi have been proposed for developing typed objects and records, where the \ncomputational feasi\u00ad bility of ML-inspired calculi (e.g., [R6m89, Wan89]) has been traded for abstract \nmathematical power (e.g., [CCHOM89, CHC90, CM91]) type inference for systems based on Girard s F2 is \na well known open problem, and in fact, type checking for a vari\u00ad ant of F2 with subtyping has been proven \nundecidable [Pie91] why not see what happens when the inspira\u00ad tion of the Curry-Howard correspondence \nis followed up with a very powerful logic? A final warning: terms in the calculus of construc\u00adtions are \nnot easy to read. Describing record and ob\u00adject calculi in CC amounts to writing an interpreter in the \nlogical equivalent of microcode. Even high level constructs as simple as records can look complicated \nwhen examined at such a microscopic level. 1.1 Guidelines Here are the goals of the proposed interpretation \nof records and objects. First, simplicity: -the theory should not be complicated, because neither records \nnor objects are comput ationally complex. The infer\u00adence rules should be kept to a bare minimum, of suf\u00adficient \ngenerality to derive others. Next, jidelity: the theory should address practical issues and situations \nconcerning reasoning about programs thh exercise is not merely an excuse to do mathematics; rather, \nto use standard logical methods giving a working understanding of programming language principles. This \nbrings us to the goal of mundaneness: the the\u00adory should be constructed out of familiar constructs: higher-order \nlogic (merely higher-order programming well known to functional programmers, where the data values are \nlogical formulas) and realizability via contraction) of proofs to programs. Finally, the theory should \nbe syntax directed: itshould be con\u00adstructive, oriented completely towards syntactic ma\u00adnipulation and \naway from semantic reasoning. Model theory and denotational semantics should be avoided. These general \ngoals have been further detailed in the following design decisions. Programs are equa\u00adtional theories, \nand types are propositions about pro\u00adgrams. Records are a special kind of function, defined over a finite \nsubset of a fixed set of labels, with types that are dependent products. When we prove a theo\u00adrem corresponding \nto typing a program, we should be able to computationally realize the proof by extract\u00ading from it a \n}-term which embodies the property asserted by the type. The logic used to prove the typing assertion \nshould have the strong normaliza\u00ad tion property, so that normalization of proofs can be used as an interpreter, \nand extraction of A-terms can be used as a compiler.  1.2 Calculus of constructions To carry out our \npresentation, we use the calculus of constructions (CC), a higher-order logic with depen\u00addent products. \nThe higher-order aspect will be essen\u00adtial to building complex types: for instance, taking our coding \nof a record type and augmenting it with a new field of some type. The dependent product aspect will be \nan essential substitution mechanism, since rather than programming directly in the calcu\u00adlus, we will \nuse it to prove theorems. In more detail, we will program in an equational theory, and the types of CC \nterms will be the logical assertions we want to make about our programs. The CC terms will then be proof \nobjects that show how to con\u00adstruct proofs of our assertions. This may all sound complicated, but it \nisn t: the calculus of constructions is just a functional notation for manipulating proof8. A number \nof summaries of the calculus of construc\u00adtions exist [Hue90, CH88]; we provide here the bare minimum \nto understand what follows, Abstraction is denoted by square brackets, and type quantifica\u00adtion denoted \nby curly brackets. For instance, the identity function for type T of kind Prop (for iogical proposition) \ncan be written [z : ~]z, which has type {z : T]~. 1 Application of a term (read, proof ) [z : ~]ill of \ntype (read, proposition ) {z : ~}P(c) (read, for all z, P(z) ) to a term N of type ~ yields a term ([z \n: ~]ilf)N of type P(N) = [iV/z]F . This substitution of the argument N into the type of the function \nis particularly disconcerting to those who have never seen dependent products. The rationale can be explained \nvery well by a canoni\u00adcal example: proving that the encoding of equality in second order logic satisfies \nassociativity. Suppose we define an equivalence relation Q over first order terms by the second order \nlogical formula Q(z, y) s V2P.P(S) --+ P(y) (the so-called Leibniz equality), where quantification is \nover all predicates P. We know Q(o, y) --t a = y (i.e., Q really does code equality) by instantiating \nP as P(z) -z = z; sub\u00adstituting this definition for P in Q(z, y), we derive z = z + a = y; the result \nfollows by the axiom z = x and modus ponens. We would hope that if Q(z, y) is really an equiv\u00adalence \nrelation, then VIZy. Q(Z, y) + Q(Y, Z) should be provable. In second order logic, take Q(z, y) and instantiate \nP as P(z) E Q(z, z), deriving Q(z, z) -i 6.?(Y, z). The premise Q(z, z) s V P.P(z) + P(z), asserting \nthat an equivalence relation is reflexive, can be easily proved, so by modus ponens, Q(y, z). Now let \ns code up this proof in CC. The predi\u00adcate Q we have defined is written in CC as Q = [z : Term][y : Term]{P \n: Term -+ Prop}(Pz) -+ (Py). In CC, a unary first order predicate (like P) is coded as a term of type \nTerm -+ Prop, since it is a function mapping input (first order terms) to output (logical proposition \nwith some truth value). The binary pred\u00adicate Q has type Term -+ Term -+ Prop, reflecting its two curried \ninputs. If Prf is a term (read, proof ) of type (read, theo\u00adrem ) Q*Y = {P : Term -+ Prop}(Px) -+ (Py), \nthen Prf can be applied to any term P of type Term --+ Prop, where Prf P then has type (Pz) + (Pv). Suppose \nR = [z : Term]Qzz; then Prf R has type 1In fact, the notation a + ,6 is a familiar variant of {z : a}~, \nwhere z does not appear in B. 2The notation v means ith-order quantification. (Qzz) -+ (Qyz). Similarly, \nPrf R can be applied to a term 1 of type Qxx, to derive Prf R I of type Qyx; since QZZ = {P : Term + \nProp}(Pz) -+ (Piz), we let 1 = [F : Term -+ Prop][w : Pz]w. Notice that from the assumption Prf : Qxy, \nwe constructed a proof Prf([z : Term]Qzz) ([P : Term --+ Prop] [w : Pz]w) having type Qyz. The proof \nuses a purely functional notation to describe all the steps in the second order logic proof. Second order \nlogic may seem easier to read than CC types, but lacks an equally formal notation for representing p~oofs. \nIn its entirety, we write the proof as [Term : Type] t\u00ad [Z: Terrn][y : Term] [Prf: Qzy] Prf ([z : Term] \nQzz) ([P : Term+ Prop][w : Pz]w) : {z : Term}{y : Term} (Qzy) -+ (Qyz) where Type is the mother of all \ntypes; the cent ext declares that Term is a type of type Type. 1.3 Terms, programs, types We assume \nprograms are first order equational the\u00adories, and types are assertions about programs. For instance, \nhere is a typical equational theory:3 Vlz.id x=x V1f.map f nil = nil V1fyt.map f (cons y t) = cons (f \ny) (map f t) The programming language assertion that id has type VP.P + P of id is interpreted as the \n(second order) logical assertion V2 P.VIZ.P(Z) + P(id z). Given the equation defining id above, the assertion \nis easy to prove in second order logic. How is the proof coded in CC? Write the first ax\u00adiom above as \n[M : {z : Term} Q(applyid z) z], where id : Term, and apply : Term -+ Term -+ Term builds terms from \nsmaller ones. The programming language typing id : VP.P --+ P is then the CC type {P : Term + Prop}{* \n: Term}(Pz) -+ (P(apply id z)). This type has proof II = [P : Term + Prop][z : Term] [Prf : Pz] Id ccP \nPrf By judiciously cross\u00ading out some subt erms in II, we realize ) id as [P : Prop] [Prf: P]Pr~ the \nusual coding of the poly\u00admorphic identity function as a A-term (with brackets denoting abstraction). \nBoldface denotes constants, italic face denotes variables. Not only does CC provide a framework for \nsuch realization of programs (A-terms) from equational specifications, it provides for free a model theory \n(a semantics), and a logic for reasoning about these specifications, and indirectly, the extracted programs. \nHere is a trivial example of the logic: Suppose we had some f : Term and a proof II of {P : Term -+ Prop}{z \n: Term](Pz) --+ (P(apply f z)). f has programming language type VP.P + P. We can then prove in CC {z \n: Term}Q (apply f z) (apply id z) namely, f must be the identity function, though Q f id need not be \nprovable. If this methodology works for programs as silly as the identity function, it ought to work \nfor records, objects, subt yping, etc. In general, we read the pro\u00adgramming language notation f : A + \nB in logic as VZ.A(a) -+ B(fz), or in CC as {z : Term}(Az) --+ (B{ f z)). Similarly, the programming \nlanguage no\u00adtation A <: B for subtyping is read logically as VZ.A(Z) + 13(z), in CC {x : Term}(Ao) + \n(13a). By analyzing typing proofs, we extract code; by ana-a lyzing subtyping proofs, we realize coercion \nfunctions between the underlying realizations of the datatypes (see section 1.5). 1.4 Inductive types \n The logical framework lets us code up all the usual in\u00ad ductive types; for instance the Peano axiom \nInt(n) ~ V2P.(Vlz,P(z) -+ P(succ z)) + P(0) + P(n) gets coded by putting constants succ and O (of type \nTerm) in the context, defining Int = [n: Term]{P : Term -+ Prop} ({z : Term}(Pz) + (P(succ z))) -+( \nPo)+(Pn) where Int is a term of type Term -t Prop (a predicate on terms, abbreviated as Pred), thus \nInt (SUCC(SUCC O)) has proof V2 = [P : Pred][s : {z : Term}(Pz) + (P(succ z))] [2: P 0]s (Succ o) (so \nz) By removing all the first-order information from the proof term, we get [P : Prop][s : P -+ P][z \n: P] s (s z), the familiar Church numeral. This contrac\u00ad tion procedure is the essence of extracting \nprograms from proofs [BB85, Gir72, GLT89, Lei90]. 4The bracket notation (e) abbreviates iterated use \nof appb : Term --+ Term --i Term to build term e. 1.5 Subtyping and coercion Successor = We can now define \nsubtyping, and an example type Even that is meant to be a subtype of Int: Subtype = [A: Term -+ Prop][B \n: Term + Prop] {z: Term}(A z) + (1? c) Even = [n: Term]{P : Term + Prop} ({z : Term}(Pz) + (P(succ(succ \nz)))) + (P o)+ (P n) Thus Subtype A B is the logi\u00adcal assertion VIZ.A(X) + B(z). We can show that Even(succ(succ \nO)) is provable, by the construction e2 = [P : Pred][s : {z : Term}(Pz) + (P(succ(succ z)))] [Z: PO] \nSOZ. (Notice this term contracts to ~ = [P : Prop][s : P + P] [z : P]s z, somewhat oddly, the Church \nnumeral for 1.) We prove Subtype Even Int by the construction [n: Term][E : Even n]ll Int ([z : Term][l \n: Int z] Successor (SUCC Z) (Successor z ~)) vo where Successor = [n: Term][l : Int n][P : Pred] [s: \n{z: Term}(Pz) + (P(SUCC z))][z : P 0] 1 ([z: Term](P (SUCC z))) ([z : Term] [Prf: P (SUCC z)] s (succ \nz) Pr~ (s O z) : {n: Term}(lnt n) + (Int(SUCC n)) Vo = [P: Pred][s : {z : Term}(Pa) --+ (P(succ z))] \n[Z: PO]Z : Int O Given this framework, we see explicitly, using entirely standard and well-known translation \nmethodology, how the computational interpretation of subtyping is related to coercion functions. By removing \nfirst-order information from the proofs of Subtype Even Int and {n : Term}(Int n) -+ (Int {SUCC n)), \nwe derive the programs and types &#38;=&#38;t= {P: Prop] (P-+ P)-+P +P [1 :lntJIP : Prop] [s: P + P][z \n: P] 1 P ([Prf: P] 9 Pr~ (s z) Subtype Even Jnt = [E:&#38;@ ~ ([1 : lnt]Successor (Successor 1)) ([P \n: Prop][s : P + P][z : P]z) Observe, then, that Subtype Even Int Ca ~-reduces to U2 namely, Subtype \nEven lnt is a function that coerces the even representation of 2 to its integer representation. It should \nbe clear that this extraction of coercions from subtyping, done along purely logical lines, will carry \nthrough for many kinds of data types,  1.6 Contravariance The function space constructor is contravariant \nbe\u00adcause logical implication satisfies principles of con\u00adtravariance. Here is a typical rule for subtyping \nin a programming language (see, e.g., [Car89, Bru92]): I k A <:A I F B<:B I I-A+B<:A --+B Why does this \nrule need to be mandated ex nihiio when it follows, in the right framework, from princi\u00adpies of logic?Itoughtto \nbe a derived rule. In CC, suppose we have terms a and@ where : Subtype A A = {z : Term} (A z) + (Az) \nSubtype B B = {z : Term}(Ba) -+ (B z);: Let fintype = [F : Term + Prop][G : Term + Prop][~ : Term]{* \n: Term} (l z) --i (G(~a)); we want to construct a term (proof) for the conclusion of the contravariance \nrule: : Subtype (Funtype A B) (Funtype A B ) -) s {f: Term} ((Funtype A B) f) + ((Funtype A B ) f) Namely, \n~ = [~: Term] {Prf: (Funtype A B) f} {z: Term}{.F : A f} @ (f~) (Prf o (CY z F)) In the body of ~, a \nz F has type Am, so that Prf z(a zF) :B (fz), and /3 (~z) (Prf z(CYz F)) : B (fz). We can then replace \na mandated inference rule by a construction Contravariance serving exactly the same purpose in type derivations. \nWhat is gained by all this? Instead of lots of inference rules, we only need a few, namely for CC term \nformation and type checking. Any specialized system (for records, ob\u00adjects, or whatever) can be built \nout of these generic parts. The terms (for instance, Contravariance) can then be interpreted as pieces \nof a soundness proof for the (record, object, etc.) calculus modulo the sound\u00ad ness of CC. Once again, \nthe computational content of contravariant subtyping (again, extracting programs from proofs) is a coercion \nfunction for the realization of the underlying datatypes.  1.7 Coherence Some brief, and not definitive, \nwords about coher\u00adence. Recent work discussing the relationship be\u00adtween subtyping and coercion has raised \nthe issue of coherence: though two structurally different as\u00adsertions about the same subtyping relation \nresult in two computationally different coercion functions, the functions should in some well-defined \nsense do the same thing. In our context, this means that the contractions ) of subtyping proofs to coercion \nfunc\u00adtions should be equivalent. For motivation, there are two proofs of {z : Term}(lnt z) -+ (Int (SUCC \nz)): one cent racts to Successor above, written as the un\u00adtyped Lterm ~n. h.k. ns(sz), and the other \ncon\u00adtracts to the equivalent of ~TZ.As.Az.s(nsz). Both of these A-terms realize successor on Church nu\u00admerals, \nthough they are not @q-equivalent (they are both in normal form). Yet it should be clear that on Church \nnumerals they do the same thing. An informal argument to establish the coherence of our translation exploits \nthe Curry-Howard iso\u00admorphism: namely, that normalizing proofs in our source logic corresponds to @reduction \nof our tar\u00adget terms. Normalizing a proof does not change its conclusion, this the logical interpretation \nof the ~-calculus subject reduction iemma. Hence the con\u00adclusion of a normalized proof, where the conclusion \nis an inductively defined type (roughly equivalent to the idea of obsemabie type in [BCGS91]), could \nbe alternately produced by pure equational reasoning. If using two different proofs of the same logical \nas\u00adsertion leads to two different answers, it would mean that our equational axioms were inconsistent. \n Records Records are functions. They map a finite domain (chosen from a set of labels) to a range of \nvalues. A record type is a dependent product. Equality of la\u00adbels should be decidable. We should be able \nto reason about field extension and removal. For example, we could define a record r by axioms r a = \nsucc O and r b = true, where a and b are labels. From a logical assertion R(r) asserting the equivalent \nof a depen\u00addent type, we should be able to prove, for example, 7?(r) + Int(r a). 2.1 Intuitionistic logic \nWe employ the usual intuitionistic cast of characters for logic: ABSURD = ~ = {P : Prop}p TRUE= {P : \nProp}p + P NOT [P :prop] = P+ ~ AND [P : Prop][Q : Prop] = {R: Prop}(P + Q + R)+R OR [P : Prop][Q : Prop] \n= {R: Prop}(P --+R) + (Q + R) + R COND [P : Prop][Q : Prop][R : Prop] = AND(P+ Q)((NOT P)+ R) IFF [P \n: Prop][Q : Prop] = AND (P--iQ)(Q+ P) We also use the infix i-+ for IFF. Do not con\u00adfuse the intuitionistic \nlogical connective with oper\u00adations on type Bool, defined Bool ~ [b : Term]{P : Pred}(P true) --+ (P \nfalse) + (P b) there is no CC term of type 1, but there is a constant false : Term.  2.2 Labels We axiomatize \nlabels by adding to the context [Label : Term -+ Prop][eq : Term] [Eql : {z : Term}{y : Term} (.?kbela) \n-+ (Lshely) + (Boo] (eq z y))] [Eq2 : {~ : Term}{y : Term} (Labelz) -t (Labely) -+ ((Q true(eq ZY)) +-+ \n(Q %Y))I [E&#38; : {z : Term}{y : Term} (.Labelz) -+ (Labelg) -+ ((Q false(eq ZY)) ++ (NOT (Q ZY)))] \n[@ q : NOT (Q true fake)] The first three axioms Eqi assert that eq is a function from a pair of labels \nto a Boolean function that is totally defined, and gives the expected answer. The last axiom asserts \nthat if we can prove Q true false, then we can prove anything.  2.3 Records, prototypes, record types \nThe canonical empty record is the term null, and the canonical empty record type (asserting nothing about \na record) is the term 3JuII = [ret : Term]{l : Term}TRUE. (This is ridiculous, but gets the ball rolling. \n) A prototype is a binary predicate (and a logical hack) on records and labels, of type Term + Term + \nProp; for example, IVull-prototype = [ret : Term] [/ : Term] TRUE. Prototypes can be augmented by adding \nan assertion about a field label and associated data type: Augment = [@: Term --+ Term -+ Prop][lab : \nTerm] [Z : Pred] [ret: Term][l : Term] COND (Q 1 lab) (T (ret ./)) (@ rec 1) Variant records [CW85] can \nof course be developed by augmenting Augment, replacing conjunction with disjunction. Record types are \nconstructed from pro\u00ad totypes by Recordtype = [@: Term --+ Term -+ Prop] [ret : Term]{ lab : Term} (Label \nlab) --+ (@ rec lab) Thus the record r defined by axioms r a = succ O and r b = true satisfies the predicate \n111 = Recordtype(Augment (Augment iVulLprototypea Boo]) b Int) Because prototypes describe functions \non a finite do\u00ad main, they can be given an inductive specification in higher order logic: Proto = [@: \nTerm --+ Term + Prop] {P: (Term + Term+ Prop) --+ Prop} ({W : Term -+ Term+ Prop} {1: Term}{T : Pred} \n(Label 1)+ (P W) -+ ( P (Augment WIZ ))) -i (7J Null-prototype) + ( P 0) (Translation: to prove a property \nP of a prototype 0, check it holds for the basis IVull-prototype, and inductively for any augmentation. \n) This definition provides an induction axiom for formally reasoning about records (gory details omitted). \nIn addition, given an equational theory defining records, when we prove for some r : Term that (Recordtype \nQ) r and Proto ~, from the proof of (Record type @) r we can extract a program (i.e., a A-term) realizing \nthe properties of r asserted by Recordtype +. Adding and removing fields from a record type is done using \nAugment to remove a field 4 from prototype @, we use Augment @i? [z : Term] TRUE. Because the im\u00adplementation \nis not effected with row variables, neg\u00adative information about fields is not necessary. We remark that \nexplicit use of prototypes can be elimi\u00adnated, at the cost of additional complications in our logical \ncoding. Rules for subtyping on record types follows from principles of pure logic. For instance, many \nrecord calculi have an inference rule saying that record type A is a subtype of record type B if B defines \na sub\u00adset of A s messages, and on that subset, pointwise subtyping is preserved. This becomes in CC a \nsim\u00adple lemma about conjunction. Program extraction from the proof just implements a coercion function \nthat removes fields. Of course, the functionality of records makes this coercion function unnecessary. \nObserve that this is not the case in our example of Subtype Even Int (section 1.5). 2.4 Soundness of \nrecord calculi Having set up a lot of logical machinery, we can use it. For example, we can show that \nthe type inference rules of a variant of Cardelli and Mitchell s record calculus [CM91] are sound, by \nshowing that they fol\u00adlow from principles of pure logic. This way, we ,. can bypass a lot of unnecessary \nmodel theory. We choose two examples from their paper. The first is rule ( TE7): it essentially states \nthat if R is a record type lacking a field with label 1 and type A, extend\u00ading R as such, and projecting \non .4, should yield type A. We rewrite this in our constructive logic, ignor\u00ading the condition that R \nlacks an 4 label (because we don t care): {@: Term -+ Term -i Prop}{T : Proto 0} {1: Term}{L : Label \nk?}{A : Pred}{z : Term} ((Project (Augment @.t A) 1) z) = (A z) where Project = [@ : Term --+ Term -+ \nProp][l : Term][y : Term] {rec: Term}(Q y (ret l?)) -+ (Q ~ec f?). Our second example is rule (TE9): \nit states that given a record type R having a field of type A with .,..-.... .,, ,, .. label -Z, It \nshould be equivalent to the record type derived by removing the field, and adding it back: {R: Term + \nTerm --i Prop} {rec: Term} { P : Proto R}((Recordtype R) ret) +-+ (( Recordtype (Augment R 1 (Project \nR /))) ret) The proof of these assertions, via induction on pro\u00adtotypes, is given in the appendix.  \n3 Objects Here is a canonical example of object-oriented pro\u00adgramming: the one-dimensional point, presented \nequaiionally: V1v.(makept w) value = w V1vd.(makept v) move d = makept (plus v d) two = makept (Succ \n(Succ o)) The constant makept serves as an object construc\u00adt or. The object two can now receive messages \nvalue and move: the former returns a value, the latter a method. Ultimately, we would like to asso\u00adciate \na type with such objects like Point = {value : lnt, move : Int + Point}. 3.1 Higher order primitive recursive \niterators The standard formal presentation of such recursive types has been through fixpoint operators \nat both the value and type level. In our logical framework, recursive types seem quite untenable: infinitely \nlong logical formulas mean a loss of strong normalization (our interpreter), and types as induction axioms \nseem equally hopeless we are led to consider what induc\u00adtion axioms will be admissible. Instead, we explain \nrecursive types using a form of higher-order primitive recursion. Recall Pred s Term -+ Prop; we also \ndefine Predo s Pred, Predk+l s Predk -+ Predk, in order to define higher order Church numerals, to be \nused as iterators: CN [T : Pred2] = {II : Pred2 --i Prop} ({X : Predz} II X + II (Succ X)) +IIZero-+H. \nT Succ [X : Pred2] = [S: Pred + Pred][Z : Pred] S(XSZ) Zero = [S : Pred -+ Pred][Z : Pred] Z We can \nconstruct a term of tiype {T: Pred2}(CN T) -+ (CN (Succ 2 )) (i.e., our numerals have successors): T \n= [2 : Pred2][Prf: CN T][II : Pred2 + Prop] [S: {X: Pred2}IIX + II (Succ X)] [Z: II Zero](S T) (Prf II \nS 2) We use these constructs to define the object type Point: we first define @[P : Pred][IV : Pred] \n= Record type (Augment (Augment iVuKprototypevalue lnt) move (Funtype Int P)) and then define Point \n= Object-type 0, where Unroll [IV : Pred2][t2 : Pred + Pred -+ Pred] = IV ([P : Pred] 0 P P) (L? True \nFalse) Object-type [!d : Pred + Pred --+ Pred] = [obj : Term]{T : Pred2}(CN 2 )+ Unroll T Cl obj The \nbindings P and N in @ mark the positive and negative occurrences of Point in {value : Int, move : Int \n+ Point} (here there is only one positive occur\u00adrence). The constructor Object-type uses a higher order \nChurch numeral to iterate @ on the basis @ True False. The recursive type of points then gets interpreted \nas: for any finite unwinding of the type declaration, everything is OK. 3.2 Folding and unfolding Many \nobject oriented type systems have an unfold\u00ad ing rule for types. Like our example of cent ravari\u00ad ance, \nit would be nice to derive such a rule from logic rather than adding it by fiat. In fact, we can prove \nthe unfolding {obj : Term} (Point obj) + {d: Term}(Int d) + (Point(obj moved)). The proof depends in \na straightforward manner on the higher order Church numerals having successor, since these numerals are \nused to unwind) the def\u00adinitions; we just unwind once, and use conjunction elimination. A curiosity of \nthis framework is that no generic construction seems obvious to do unfolding on all object types, while \nit seems clear how to un\u00adfold any particular such type. This is like a formal system that has proofs \nof some ~(n) for each integer n, but no proof of Vn.#(n). Thus a certain amount of reasoning goes on \noutside the system. 3.3 Subtyping recursive types We can use the higher-order iterators to derive a \nstan\u00addard inference rule about subtyping recursive types, written in a vanilla notation as: 17 u {P<: \nQ} t-O(P) <: W(Q) r t-pLqi) <: ~i.vqt) written in CC as {Q: Pred + Pred ---+ Pred} {W: Pred -+ Pred \n--+ Pred} ({P : Pred}{Q : Pred}(Subtype P Q) + (Subtype (Q P P) (W QQ))) + Subtype (Object-type @) (Object-type \nQ) The CC term with this type is a straightforward proof by induction on the higher order Church numerals. \nDetails of the proof appear in the appendix. 3.4 Inheritance is not subtyping, etc. Given Number = {value \n: Int, lesseq : Number --+ Boo]] and Order = {lesseq : Order + Bool}, ithas been pointed out that Number \nis not a subtype of Order. This has usually been demonstrated by ma\u00adnipulating the standard inference \nrule for recursive types and arguments about contravariance. When this putative subtyping relationship \nis viewed logi\u00adcally, another argument emerges to show that, quite simply, inheritance (i.e, of an Order \nobject that inher\u00adits a value field) does not logically imply subtyping. From our logical interpretation \nof the above types, we may easily prove the following three assertions: {obj : Term} (Number obj) + {y: \nTerm} (Number y) + (Boo] (obj lesseqy)) {obj : Term} (IVumber obj) + (lnt (obj value)) {obj : Term} (Order \nobj) + {y: Term} (Orcler y) --+ (Bool (obj lesseqy)) Were Number indeed a subtype of Order, then we would \nhave a proof of {obj : Term} (Number obj) + (Order obj). In contradiction, then, we will define an object \nf which is clearly a Number, but not an Order: consider the axioms f value = O, V1y.f lesseq y = lesseqlnt \n(f value) (y value), where lesseqInt de\u00adfines the property on Int. Certainly f is a Number. But it is \nnot an Orde~ define g by the single axiom V1z,g lesseq z = false. Again, clearly g is an Order, thus \nBoo] (f lesseq g) must be provable if f is truly an Order; an impossibility, since f lesseq g cannot \nbe reduced by the equational axioms to either true or false-the object g is not equipped with a value \nmessage.  3.5 F-bounded polymorphism The idea of F-bounded polymorphism proposed in [CCHOM89] is meant \nto get around such anomalies, in particular to type functions like @zy.min z y = if (z lesseq y) z y. \nThe discussion of the previous subsection shows that, even though we could prove {T: Pred}(Subtype T \nOrder) + {z: Term}{y : Term} (T*) + (Ty) + (T (rein z y)), the proof would be essentially useless. Instead, \ndefine F [P : Pred] = [T: Term]{s : Term} (Ps) + (Eiool(~ lesseq s)) (Observe that Order = Object-type \nF.) Clearly, Subtype Number (F Number) is provable, thus we type min as {T: Pred}(Subtype T (F 2 )) -i \n{m: Term}{y : Term} (Tic) + (Z y) ---+ (T (rein z y)), Here is another example: define V1z.translate \nz = z move (SUCC O). If we then define F [P : Pred] = [T: Term]{s : Term} (Int s) + (P(r move s)), we \ncan prove {T: Pred}(Subtype T (F T)) + {n: Term}(Tz) --+ (T (translate z)), so we know translate works \non objects oft ype Point, as well as any type T with a properly defined move message.  4 Conclusions \nVery standard constructs from higher-order logic can be used to explain computation with records and \nob\u00adjects. Just as A-calculus is recognized as an expressive formalism for representing computation, higher \norder logic (a mixture of lambda calculus and logic) is an expressive formalism for representing types. \nThe ex\u00adistence of strong normalization and realizability for this logic means that the formalism is ideal \nfor cal\u00adculation as well as representation: for example, we have off the shelf a compiler and interpreter \nfor F\u00adbounded polymorphism. The logical foundation pro\u00advides a mechanism for reasoning about the programs; \nthe semantics of the logic provides a semantics for the programs. The idea of multiple subtyping just \nmeans that you can prove more than one theorem about a first-order term. I have tried to answer what \nare types for records and objects? by appealing to logical syntax rather than denotational semantics. \nBut is this paper merely an exercise in denotational semantics with CC as a metalanguage? Whether or \nnot the logical ap\u00adproach is the right way remains to be seen, but it is worth thinking about. The perspective \ngiven in this paper, borrowing from categorical terminology, is that CC is a useful (and in some ways, \nsimple) (internal language to discuss the denotational se\u00admantics of record and object calculi. Constructive \nlogic is both a blessing and a curse: a blessing for the reasons we have given, but also a curse because \nthe formal syntax forces us to say what we mean in excruciating detail. In part, is this always the price \npaid for formal methods? The same problem of detail holds in principle for denotational seman\u00adtics, but \nthere, less attention to syntax may provide a way out ) via honest but suggestive hand waving. A research \nchallenge is to make the logical approach more palatable by writing better programs than the ones I have, \nincorporating good data abstraction at the level of proofs. Other failings of this approach are that \nthere is no clear delineation of what a type) actually is for a term is any logical construct admissible? \nand that reasoning about unbounded computation seems prob\u00adlematical. The latter, of course, is the price \nwe pay for strong normalization. Our introduction of higher\u00adorder iterators eliminates the need for unbounded \ncomputation for a host of well-known canonical (read toy ) examples, and appears sufficient for situations \nwhere the pieces of code satisfy a sort of master\u00adslave ) relationship: anomalous behavior evidenced \nby programs without this property have been inves\u00adtigated by Colson [C0191]. It would be interesting \nto see if the expressiveness of the primitive recursive iterators is sufficient to formalize more sophisticated \narguments about subt yping, for inst ante [AC9 I]. In reasoning about equational theories where the con\u00adtrol \nis distributed, the robustness of the approach is not clear. Even if unbounded type recursion is supe\u00adrior \nfor these programs with distributed control, one imagines that they will run aground for other reasons: \nnot only their complexity, but the tremendous diffi\u00adculty of proving termination of distributed programs. \nAcknowledgements. It was Jeff Sanders who sug\u00adgested that the approach of some earlier work [Mai91] on \nreasoning about programs based their on poly\u00admorphic data types be extended; I thank him for his encouragement \nand suggestions. Luca Cardelli has been particularly helpful with constructive comments and copious criticism. \nI also wish to thank Has\u00adsan Ait-Kaci, Andrew Black, Daniel Leivant, Patrick O Keefe, and Mitchell Wand \nfor their advice and their willingness to serve as listeners and critics. References [AC91] R. M. Amadlo \nand L. Cardelli. SuZ@p\u00ading recursive types. In Eighteenth An\u00adnual ACM Symposium on Principles of Programming \nLanguages, 1991, pp. 104-118. [BB85] C. Bohm and A. Berarducci. Automatic syn\u00adthesis of typed A-programs \non term algebras. Theoretical Computer Science 39, pp. 135 154, [BGS90] V. Breazu-Tannen, C, A. Gunter, \nA. Sce\u00addrov. Computing with coercions. 1990 ACM Conference on Lisp and Func\u00adtional Programming, pp. 44 \n60. [BCGS91] V. Breazu-Tannen, T. Coquand, C. A. Gunt er, A. Scedrov. Inheritance as implicit coercion. \nResearch Report MS-CIS-89-01, Department of Computer and Information Science, University of Pennsylvania. \n[B,u92] K. Bruce. A Paradigmatic Object-Oriented Programming Language: Design, Static Typ\u00ading and Semantics. \nTechnical Report CS-92\u00ad01, Williams College. [CCH0M89] P. Canning, W. Cook, W. Hill, W. Olthoff, and \nJ. C. Mitchell. F-bounded polymorphism for object-oriented programming. In Fourth ACM Conference on Functional \nPro\u00adgramming Languages and Computer Architecture, 1989, pp. 273-280. [Car88] [Car89] [Car91] [CM91] [CW85] \n[C0191] [CHC90] [CH88] [Gk72] [GLT89] [Hue90] [Lei90] [Mai91] [Pie91] L. Cardelli. A semcmtics of multiple \ninher\u00aditance. Information arnd Computation 76:2/3, 1988, pp. 138-164. L. Cardelli. Typeful programming. \nLecture Notes for the IFIP Advanced Seminar on Formal Methods in Programming Language Semantics, Rio \nde Janeiro, Brazil, 1989. See also SRC Report 45, Digital Equipment Cor\u00adporation. L. Cardelii. Extensible \nrecords in a pure cal\u00adculus of subtyping. Unpublished draft. L. Cardelli and J. C. Mitchell. Operations \non records. Mathematical Structures in Computer Science 1:1, 1991, pp. 3-48. L. Cardelli and P. Wegner. \nOn understand\u00ading types, data abstraction, and polymor\u00adphism. Computing Surveys 17(4):471\u00ad522, 1985. \nL. Colson. About primitive recursive algo\u00adrithms. Theoretical Computer Science 83 (1991), Pp. 57-69. \nW. R. Cook, W. L. Hill, and P. S. Canning. Inheritance is not subtyping. Seventeenth Annual ACM Symposium \non Princi\u00adples of Programming Languages, 1990, pp. 125-135. T. Coquand and G. Huet. The calculus of constructions. \nInformation and Compu\u00adtation 76:2/3, 1988, pp. 95-120. J.-Y. Girard, Interpretation Fonctionnelle et \nElimination des Coupures de i Arithmetique d Ordre Superieur. Th&#38;e de Doctorat d Etat, Universit6 \nde Paris VII, 1972. J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. Cambridge University Press, \n1989. G. Huet. A uniform approach to type theoTy. In Logical Foundations of Functional Programming, ed. \nG. Huet, pp. 337-398. Addison Wesleyl 1990. D. Leivant. contracting pToofs to programs. In Logic and \nComputer Science, ed. P. Odifreddi, pp. 279-328. Academic Press, 1990. H. G. Mairson. outline of a p? \noof theory of parametricity. In Fifth ACM Confer\u00ad ence on Functional Programming Lan\u00adguages and Computer \nArchitecture. LNCS 523, 1991, pp. 313-327. B. Pierce. Bounded quantification is unde\u00adcidable. Research \nReport CMU-CS-91-161, School of Computer Science, Carnegie Mel\u00adlon University, 1991. [R6m89] D. R6my. \nT~pechecking records and variants in a natural extension of ML. Sixteenth Annual ACM Symposium on Princi\u00adples \nof Programming Languages, 1989, pp. 60-76. [Wan89] M. Wand. Type inference for record concate\u00adnation \nand simple objects. Fourth IEEE Symposium on Logic in Computer Sci\u00adence, 1989, pp. 92-97. A Subtyping \nrecursive types We use the higher-order iterators to derive a standard inference rule about subtyping. \nRecall the definition Unroll [N : Pred2][G? : Pred + Pred + Pred] = IV ([P: Pred] fl P P) (!2 TrueFaJse). \n First we prove El= {~: Pred + Pred + Pred} {~: Pred + Pred -+ Pred} {T: (Pred 4 Pred) + (Pred + Pred)} \n(CN T)+ ({P : Pred}{Q : Pred}(Subtype P Q) --+ (Subtype (@P) (~Q))) + Subtype (Unroll T@) (Unroll T w) \n In context [@ : Predl][i# : Predl][T : Pred2][M : CN T] [Z : {P : Pred}{Q : Pred} (Subtype P Q) + (Subtype \n(@P) (IVQ))], observe that N [T : Pred2] Subtype( Unroll T @)( Unroll T W) has type @l --+ @2 + subtype \n(T @ True) (T V True), where @l is {X: PredZ}(Subtype (UnrolJ X @) (Unroll X W)) -+ (Subtype (Unroll \n(Succ X) @) (Unroll (Succ X) W) and (3z is Subtype (Unroll Zero 0) (Unroll Zero W) Assumption @l has \nproof [X: Pred2] Z (Unroll X@) (UnrolJ X W), and 02 has a trivial proof, recalling the iterative properties \nof Succ and Zero. Call C the proof of @. Defining Object-type as earlier, we can prove the standard subtyping \nrule {@: Pred ---+ Pred --+ Pred} {W: Pred -i Pred --+ Pred} ({P : Pred}{Q : Pred}(Subtype P Q) + (Subtype \n(0P P) (W Q Q))) + Subtype (Object-type @) (Object-type W) The construction with this type is [@: Pred \n+ Pred] [W: Pred --i Pred --+ Pred] [Prfl : {P : Pred}{Q : Pred}(Subtype PQ) + (Subtype (@P) (wQ))] [obj \n: Term] [Prfz : {2 : Pred2}(CN !? ) + Unroll T @ ob~~ [T: Pred2][Af : CN T] C @ It? T M Prfl (Prfz T \nAf)  B Proof of rule (TE7) To prove {@: Term -+ Term -+ Prop}{7J : Proto @] {1: Term}{L : Label 4}{A \n: Pred}{a : Term} ((Project (Augment @/A) 4) z) ++ (A z) where Project = [0: Term + Term ---+ Prop] \n[-4 : Term][y : Term] {~ec: Term}(Q y (~ec /)) + (Q rec -4) observe that Project (Augment @ ~A) 1 = [y: \nTerm] {rec: Term} (Q y (TW l)) + (AND ((Q /k ) + (A (ret l?))) (NOT (Q /1)+@ ret-t)). Suppose Prf : \n(Project (Augment @.4A) 4) y; we would like to construct a proof of A V. Assume the context contains \n[K : Term] and a familiar axiom, [Def-K : {z : Term}{y : Term} Q a (K z y)]. Then Prf (K y) (Def-K y \n1) : (AND ((Q 11) -+ (A (K y-?))) ((NOT (Q 41))+@ (K y) 1)) From this construction, it is easy to get \na proof of A (K y 1), and from the definition of Q and Def-K we can then derive a proof of A y. In the \nother direction, given a proof of A y, from hypothesis Q y (~ec 4) it is easy to prove A (ret 1), where \nrec and 1 are terms. To prove both halves of the conjunction, the first can be proved by introduc\u00ading \n(unused!) hypothesis Q 14, and the second can be proved by assuming NOT (Q 1.4) and using axiom Eq4: \nsince Q .4t is certainly provable, from a proof of true = false we can prove anything, including @ ~ec \nL Discharging hypotheses yields the result,  C Proof of rule (TE9) To prove {R: Term ---+ Term + Prop} \n{~ec : Term} { P : Proto R} ((l?ecordtype R) ret) + (( Recordtype (Augment R / (Project R /))) ~ec), \nobserve that this proposition converts (in the + di\u00adrection) to {R: Term + Term --+ Prop} {~ec : Term}{? \n: Proto R} ({z : Term} (Label z) + R ~ec z) + ({s : Term} (Label z) + (AND ((Q z -t)+ (Project RI) (~ec \nz)) ((NOT (Q zI) + R ~ec ~)))). Since (Project R 4) (ret z)= {~: Term}(Q (~ec z) (~ l)) + R rt, from \nprecondition Q x.4 we have (Project R 4) (ret 4)= {r: Term}(Q (ret 1) (~ 4)) + R ~-t. To prove the theorem, \nthen, we need to show (R rec 1) + (Project RI) (ret 4). This we do by induction on RI using the induction \naxiom Proto R, i.e., P [P : Term + Term --+ Prop] (R rec Z) -+ (Project lit) (ret t). The rest of the \nproof is routine. \n\t\t\t", "proc_id": "158511", "abstract": "<p>We show how a higher order logic, the calculus of constructions, can be used to give a simple, first principles treatment of record calculi, polymorphism, and subtyping. The development follows the constructive idiom of extracting implementations of equationally specified programs from proofs of their termination, with a logic for reasoning about programs, and a semantics that comes as a gratuity. In this framework, records are finitely specified functions where equality is decidable over the domain, with types that are a particular kind of logical assertion. By proving that a record specification satisfies its type, we can extract its implementation. While program extraction serves as a sort of compiler, proof normalization serves as an interpreter; the latter serves to ensure in some sense the coherence of the translation embedded in the former.</p><p>This simple minded approach lets us show, for example, that many inference rules found in record and object calculi can be derived&#8212;they are just provable lemmas in higher order logic. We see explicitly how from subtyping proofs we can extract, using conventional methods, coercion functions between underlying representations of data types. By further exploiting the computational metaphor of higher order logic, we can realize an interpreter for recursively defined objects, as well as subtype and inheritance relations between them. Recursive types for objects are explained by primitive recursion in higher types. The approach also gives a computational understanding of F-bounded polymorphism.</p>", "authors": [{"name": "Harry G. Mairson", "author_profile_id": "81100061196", "affiliation": "", "person_id": "P107959", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158657", "year": "1993", "article_id": "158657", "conference": "POPL", "title": "A constructive logic of multiple subtyping", "url": "http://dl.acm.org/citation.cfm?id=158657"}