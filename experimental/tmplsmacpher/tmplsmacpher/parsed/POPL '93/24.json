{"article_publication_date": "03-01-1993", "fulltext": "\n Safe Type Checking in a Statically-Typed Object-Oriented Programming Language Kim B. Bruce* Williams \nCollege kim@cs.williams .edu Abstract In this paper we introduce a statically-typed, functional, object-oriented \nprogramming language, TOOPL, which supports classes, objects, methods, in\u00ad stance variables, subtypes, \nand inheritance. It has proved to be surprisingly difficult to design statically-typed object-oriented \nlanguages which are nearly as expressive as Smalltalk and yet have no holes in their typing systems. \nA particular problem with statically type checking object-oriented languages is determining whether a \nmethod provided in a super\u00adclass will continue to type check when inherited in a subclass. ThLs problem \nis solved in our language by providing type checking rules which guarantee that a method which type checks \nas part of a class will type check correctly in all legal subclasses in which it is inherited. Thk feature \nenables library providers to provide only the interfaces of classes with executable and still allow users \nto safely create subclasses. The design of TOOPL has been guided by an anal\u00adysis of the semantics of \nthe language, which is given in terms of a sufficiently rich model of the F-bounded second-order lambda \ncalculus. This semantics sup\u00adported the language design by provided a means of proving that the type-checking \nrules for the language are sound, ensuring that well-typed terms produce ob\u00adjects of the appropriate \ntype. In particular, in a well\u00adtyped program it is impossible to send a message to an object which lacks \na corresponding method. *Part of this work was done while the author was on leave at the Computer Science \nDepartment, Stanford University, at the DEC Systems Research Center in Palo Alto, California, and at \nthe D6partement de h4ath6matiques et d Informatique, Ecole Normale Sup6rieure, in Paris. This rese=ch \nwas partially sup\u00adported by NSF grants CCR -9105316 and CCR9121778, and, at Stanford, the Powell Foundation. \nPermission to copy without fee all or psrt of this material is granted provided that the copies are not \nmade or distributed for direct commercial edvantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or specific permission. ACM-20th PoPL-1 \n/93-S. C., USA g 1993 ACM 0-89791 -561 -5193 /000110285 . ..$1 .50 1 Introduction Two very influential \npapers on the foundations of object-oriented programming languages were pre\u00adsented at the 1990 POPL conference. \nThe first, [CHC90], argued that subtyping and inheritance were distinct concepts, providing examples \nshowing that subclasses dld not always result in subtypes. It then demonstrated that many object-oriented \nfeatures could be modeled in the F-bounded second order lambda calculus, an extension of the bounded \nsecond\u00adorder lambda calculus. (See also [C CH+89] for more discussion and examples in this language.) \nThe second paper, [Mit90], showed how delegation, a variant of inheritance, could be modeled in a record \ncalculus which supported record extensions (but not full subtyping) and bounded quantification over func\u00adtions \nfrom types to types. In each case, a term could be determined to be type\u00adsafe if the translation of the \nterm into the higher-order language type-checked. Moreover this type checkhg of the translation ensured \nthat methods of the original language remained well-typed when inherited. While both papers represented \nimportant progress in the foundations of object-oriented programming languages, both simulated features \nof object-oriented languages in higher-order languages which included quantification over types or functions \nfrom types to types. This made each rather difficult to relate di\u00adrectly to languages that a programmer \nwould recog\u00adnize as object-oriented. This paper is an attempt to extend the work in these two papers \nby presenting a statically-typed object-oriented language, TOOPL (for Typed Object-Oriented Programming \nLanguage), which is based on a firm semantic foundation. Unlike the languages in the papers referred \nto earlier, TOOPL is a first\u00adorder (functional) object-oriented programming lan\u00adguage which directly \nsupports all of the common features of the object-oriented paradigm, including classes, objects, methods, \nupdatable instance vari\u00adables, subtypes, and inheritance. It supports the use of an identifier, usually \nwritten self, which refers to the current object, and its type, usually written My\u00adType. It also provides \na mechanism to refer to meth\u00adods of the superclass of a class being defined. We also provide static type-checking \nrules for the language. The rules for type-checking classes are based on those presented in [Mit90], \nextended to sup\u00adport subtyping rather than only simple type exten\u00adsions. Following [CHC90], we separate \nthe subtype and inheritance hierarchies. This results in a more flex\u00adible language while preserving type \nsafety. One ad\u00advantage of this separation of classes and types is that objects generated from distinct \nclasses can have the same type. For example, Point objects represented using Cartesian coordinates can \nbe defined so as to have the same type as point objects represented using polar coordhlates. In order \nto make possible a proof that the type\u00adchecking system is safe, we have provided a denota\u00adtionaI semantics \nof the language, which is presented in terms of a model of the F-bounded second-order lambda calculus \nwhich contains fixed points at both the type and element level. Using this semantics we are able to prove \nthat the type-checking rules are sound. Since TOOPL is functional, updating an instance variable results \nin a new object which differs from the original only in the value of the instance variable which was \nchanged. Instance variables are hidden outside of an object. The semantics of the hidden instance variables \nare given in terms of existential types, as presented in [MP88]. While the semantics is presented in \nterms of a model of the F-bounded second-order lambda calculus, the user has no need to understand this \nmore complex lan\u00adguage, since our type-checking rules are all presented in terms of first-order constructs. \nThe same is true of the operational semantics of the language, which is not, however, discussed in this \npaper. The major focus of this paper is the design of safe static type-checking rules for object-oriented \nlan\u00adguages, as illustrated in TOOPL. Type-checking prob\u00adlems arise when methods are redefined in subclasses. \nA key question we will answer is what changes to the types of methods are allowed in subclasses. However, \nequally severe problems can occur when methods are inherited (Le., without change) in subclasses. sup\u00adpose \nwe have type checked a method in the context of the class in which it is defined. If its body includes \nsending messages to self, and those messages may be modified in the subclass, how can we be assured that \nthis method will continue to type check when inher\u00adited? We would like to have type-checking rules which \nguarantee that, once a method is type checked, it will be type correct in all subclasses in which it \nis inher\u00adited. This is certainly necessary if vendors are going to provide libraries of classes in compiled \nform only. Our understanding is that in Trellis/Owl [SCB+86] and Typed Smalltalk [GJ90], for example, \nmethod bodies are type checked again when they are inherited in subclasses. This is unsatisfactory from \nour point of view, since the source code of the original class will generally not be available at the \ntime the subclass is compiled. In the language described in this paper, we will pro\u00advide type-checking \nrules which will allow us to inherit methods in subclasses with the assurance that they are type correct \nwithout the necessity of type check\u00ading them again in the context of the definition of the subclass. \nThus TOOPL satisfies the following conditions: 1. If we can prove that a term of TOOPL has a type, T, \nthen the result of evaluating that term will be an element of type r. In particular, no error messages \nof the form message not understood will arise during the evaluation of a well-typed term. 2. If a class \nhm a type, then we provide rules for de\u00adriving subclasses which guarantee that all inher\u00adited methods \ncontinue to have the types specified in the superclass. In particular, only the types of the instance \nvariables and methods of the super\u00adclass need be known in order to type check the subclass.  In the \nnext two sections we provide a very brief explanation of the fundamental concepts and termi\u00adnology commonly \nused in object-oriented languages and give an example of a program which causes prob\u00adlems with most object-oriented \nlanguages. We then describe the syntax and type-checking rules for our language. In section 5 we give \na brief sketch of a de\u00adnotational semantics for this language. This semantics provides the basis for \nour proof of a soundness theorem which shows that our type-checking rules are correct with respect to \nthe semantics. Because of space limitations, we concentrate on the language without instance variables. \nHowever in sec\u00adtion 6 we provide a brief sketch of the changes neces\u00adsary in order to include instance \nvariables. The addi\u00adtion of instance variables provides significant added complications in both type-checking \nand specifying the denotational semantics of object-oriented lan\u00adguages. (A more detailed presentation \nof the full lan\u00adguage can be found in [Bru92b].) Finally we compare our work with that of other researchers \nin the area and discuss other recent results on TOOPL. Fundamental concepts of object-oriented languages \n We presume the reader is familiar with object-oriented languages and simply provide a quick description \nof the terminology used in the rest of the paper. The language described in this paper offers full support \nfor object-oriented features including objects, classes, methods, instance variables, dynamic method \ndispatch, subclasses, and subtypes. We pr~vide mech\u00adanisms to allow the programmer to refer to the cur\u00adrent \nobject (self) and the record of methods of its superclass (super). Moreover the language provides a term \nwhich refers to the type of the current ob\u00adject (MyType), which can be used in type-checking terms. These \nconcepts are described briefly below. An object consists of a collection of instance vari\u00adables, representing \nthe state of the object, and a col\u00adlection of methods, which are routines for manipulat\u00ading the object. \nWhen a message is sent to an object, the corresponding method of the object is executed. Classes are \nextensible templates for creating objects. In particular, classes contain initial values for instance \nvariables and the bodies for methods. All objects gen\u00aderated from the same class share the same methods, \nbut may contain different values for their instance vari\u00adables. A subclass may be defined from a class \nby either adding to or modifying the methods and instance vari\u00adables of the original class. Restrictions \non the modifi\u00adcation of the types of methods and instance variables in subclasses are necessary in order \nto preserve type safety. A subclass inhem ts those methods of its super\u00adclass which are not redefined \nin the subclass. These methods can then be used aa though they were part of the subclass definition. \nAll terms of the language, including both classes and objects, have associated types. In the language \ndescribed in this paper, instance variables are not vis\u00adible outside of objects. Since types describe \nonly the public interfaces of objects, neither the instance vari\u00adable names nor their types are referred \nto in object types. We say type T is a subtype of U if a value of type T can be used in any context in \nwhich a value of type U is expected. Note that subtyping depends only on the type of wdues, while inheritance \ndepends upon their implementations. Virtually all object-oriented languages provide pro\u00adgrammers with \na mechanism for sending a message from an object to itself. We will use the keyword self in methods as \na name for the object which is currently executing the method. Since our language is statically typed, \nit will be necessary to assign a type to all oc\u00adcurrences of self. While one could simply give self the \nsame type as the object being defined, complications involving subclasses lead us to find a different \nsolution. The complications arise when a method whose body involves self is inherited in a subclass. \nIn the inher\u00adited method, self will now refer to objects generated from the subclass rather than from \nthe original class. Because the meaning of self will change in subclasses, its type will change as well. \nThus we will use the key\u00adword MyType as the type of self. (Technically, both self and MyType are bound \nvariables, rather than key words, in TOOPL. This allows for the possibility of nested class definitions. \nA language designed for se\u00adrious software production would probably make these reserved words of the \nlanguage.) Finally, when new definitions are given to methods in a subclass, it is useful to be able \nto refer to the meth\u00adods of the superclass. For instance, one often wishes to apply the method body from \nthe superclass and then perform a few more operations before returning from the redefined method. We \nprovide the keyword super to refer to the record of methods of the superclass. 3 Problems with type-checking \nobject-oriented languages Statically-typed object-oriented programming lan\u00adguages are notorious for the \nholes in their typing sy5 terns or their reliance on type casting in order to support a style of programming \nnearly as flexible as weakly typed languages like Smalltalk. Since one of the goals of this research \nis to produce a language whose type system is safe, we present an example here which gives most statically-typed \nobject-oriented languages problems, though it is easily expressed in Smalltalk. The example is presented \nin a variant of TOOPL without instance variables. In the following, p <= m denotes sending the mes\u00adsage \nm to the object p. PointClass = class (self My Type) {x =o, Y = o, eq = fun(p:MyType) ( (self<=x) = (p<=x) \n) &#38; ( (self<=y) = (p<=y) ) } Point Class has three methods named x, y, and eq. The method eq takes \na parameter, p, with the same type as self and compares the results of sending mes\u00adsages x and y to p \nand the results of sending the same messages to self. (In Section 6 we exhibit another version of this \nexample in which x and y are instance variables, rather than methods.) The operator new applied to a \nclass returns a new object of that class. PtObj = new PoimtClass The type of PtOb j is the type PointType: \nPointType = ObjectType(MyType) {x,y:Int; eq:MyType -> Bool} Next we modify Point class by adding a color \nfield, c, and updating method eq in ColorpointClass so that it calls the inherited eq from Point Class \n(using the keyword super) and then checks c components for equality. ColorPointClass = modify Pointclass \nby (self: MyType, super: {x, y: Int; eq: My Type-> Bool}) {c = Red, eq= fun(p: MyType) super. eq(p) &#38; \n((self <= C) = (p <= c))} (We have taken a few liberties with TOOPL here and combined update and extend \nOpera\u00adtions in forming colorPoint class. The formal lan\u00adguage would require us to define this in two \nsteps.) colorPointclass inherits the definitions of x and y from PointClass. As before we can create \nnew objects from thk class. ColorPtObj = new ColorPointClass ColorPtObj has type ColorPointType: ColorPointType \n= ObjectType(MyType) {c: ColorType; x,y:Int; eq:MyType -> Bool } The definition of the subclass colorpointclass \nfrom Pointclass is a very natural one and type\u00adchecks without problem in TOOPL. However prob\u00adlems may \narise if we make the incorrect assump\u00adtion that ColorPointType is a subtype of PointType. Consider the \nfollowing function: BreakIt = fun(p : PointType) p <= eq (new PointClass) Thkis a perfectly reasonable \nfunction which takes a point pas aparameter and checks to see ifit is equal to a new object formed from \nPoint class. In partic\u00adular, it checks to see if its x and y components are both O. This program type-checks \nwithout problem in TOOPL. Suppose for a moment that ColorPointType is a subtype of PointType. If so, \nthen a term of type ColorPointType may be used in any context which expects a term of type PointType. \nThus it would be legal to write BreakIt (ColorPtObj ). However, thk function call breaks the type sys\u00adtem \nsince ColorPtObj <= eq (new PointClass) is not well-typed. ColorPtObj <= eq expects a pa\u00adrameter of type \nColorPointType, not Poi.ntType. If the system attempted to evaluate the term BreakIt (ColorPtObj ) it \nwould crash since it would execute the code for eq which is associated with colorpoint class and collapse \nwhen it tried to call the (non-existent) color method of new point Class. Thus ColorPointType can not \nbe a subtype of PointType. (In fact this argument shows that PointType can have no proper subtypes in \nwhich eq has type MyType -> Bool!) This example creates serious problems for most well-known statically-typed \nobject-oriented languages, since they typically identify the notions of subtype and subclass. More precisely, \nthey presume that any legal subclass must be a subtype. The original ver\u00adsions of Elffel allowed the \ndefinition of the subclass ColorpointClass of PointClass, and then crashed if the function BreakIt were \napplied to an object gener\u00adated by Colorpointclass. Version 3.0 of Elffel works around this problem by \nadding an extra level of type checking at link time. This system-wide type checking essentially performs \na data flow analysis of all classes of the program in order to ensure that only type-safe message sends \nare performed (see [Mey92] for more details). Classes defined like colorPointclass and point class would \ntype check, but programs which included a class in which BreakIt were applied to an object generated \nby Colorpoint class would result in a type error during the link-time type check. We consider this solution \nunsatisfactory since individually correct classes may combhe to produce an incorrect system. Moreover, \nthis type-checking system requires access to the source code (or some cIose approxima\u00adtion) for all classes \nin the system. Since we would like our language to support the provision of libraries which could be \nprovided in compiled form only, this solution will not meet our needs. Other-languages avoid this problem \nby declaring the subclass ColorPointClass to be illegal. Trellis/Owl declares it to be illegal since \nit only allows subclasses which are also subtypes. C++ [Str86], Object Pascal [Tes85], and Modula-3 [CDG+88] \ndo not allow the user to redefine the types of parameters in subclasses, so the proposed redefinition \nof eq in colorpoint Class is illegal (though in C++ and Object Pascal it can be hacked together by by-passing \nthe type system and coercing the argument of eq to be an object of ColorPointType in the body of eq). \nSather [Omo91] (a variant of Eiffel) allows redefinition of types of pa\u00adrameters, but they must be redefined \nto be supertypes rather than subtypes. TOOPL allows us to define colorpointclass in a type-safe way by \nallowing it to be a subclass, with\u00adout insisting that ColorPointType be a subtype of Poi.ntType. TOOPL \nthus combines expressibility with type-safety.  4 TOOPL -a statically-typed object-oriented language \nIn this section we introduce TOOPL (Typed Object-Oriented Programming Language), a functional, statically-typed \nobject-oriented language. We provide an informal definition in this section, leaving the for\u00admal definition \nto Appendix A. Because of space lim\u00aditations, we describe only the subset of the full lan\u00adguage with \nmethods but no instance variables here. In section 6 we provide a sketch of some of the changes necessary \nto include updatable instance variables. 4.1 Types9 S, and %n.th We begin by defining the types of our \nlanguage. A type is either a type variable, a constant, or of the form a ~ T (for functions), {ml: 71;. \n. . ; mn: 7*} (for records), ObjectType(MyType)~ (for object types), or ClassType(MyType)~ (for claiwes). \nIn the last two expressions, MyType is considered to be a bound type variable, while T must be a record \ntype. The bound type variable MyType occurring in Ob\u00adjectType and ClassType types will be used as the \ntype of self in definitions of methods associated with these objects and classes. Because we are distinguishing \nbetween subtype and subclass, it will be convenient to define two different orders on type expressions. \nThe first, <, is the SUb\u00adtype ordering, which effectively determines when ele\u00adments of one type may be \nused in place of elements of another type. The second ordering, <m~th, will only be defined on object \ntypes, and will correspond to a pointwise ordering on the types of corresponding methods. We will see \nthat this ordering is very useful in type checking classes as it is related to the types of objects generated \nby subclasses. A type constraint sgstem is a finite sequence of state\u00adments ofthefOrm t ~rort~meth rwhere \ntisatype variable and ~ is a type expression. (See the formal definition in Appendix A.) The axioms and \nrules for ~ and ~~~~b are given in Appendix A and are the familiar ones for function and record types. \n(See [Car88a] for justifications.) Note that rule (S ~) for subtyping function types is con\u00adtravariant \nin the domain and covariant in the range. Rule SRec for record types is as usual, with subtypes possibly \ncontaining more fields than the supertypes, while the types of record components maybe replaced by subtypes \nof those found in the supertype. The subtyping rule for object types is the only new rule here. It is \nderived from the rule in [AC90] for recursive types. The complexity is due to the inher\u00ad ently recursive \nmeaning of MyType. The intuition behind the rule is that if Object TYPe(MiI yPe)r S Object Type(MyType \n)~ , then NIyType repre\u00adsents a type which is less than that represented by MyType . Thus if we can show \nthat T < r , as\u00adsuming only that MyType < My Type , then the conclusion follows. (We refer the reader \nto [AC90] for more details and a more rigorous justification of this rule.) On the other hand, the obvious \nsubtyping rule for objects is essentially the one given for <meth. However, our earlier example of ColorPointType \nand PointType in Section 3 shows that this rule fails. In particular, {c :ColorType;x,y: Int; eq:MyType->Bool} \n< {x, y: Int; eq: MyType->Bool} , but ColorPointType is not a subtype of PointType. Instead this more \nobvious rule is the basis for the ordering <~eth. It is an ordering of object types only. The following \nrule is derivable from rules MRefl and MTrans. CtT1<T 7 C F ObjectType(MyType)r ~~.th ObjectType(MyType)r \n While the conclusion fails for subtypes, it reflects exactly the way in which subclasses are formed. \nThat is, one object type will be <meth to another if it haa more methods or if types of some methods \nin the larger have been replaced by their subtypes in the smaller. We use the notation <meth in order \nto remind us that this ordering depends only on comparisons of the types of methods. If C S is a subclass \nof C such that C > gener\u00adates objects oft ype T , and C generates objects oft ype T, then T ~~et~ T. \nIn particular ColorPointType <me~h PointType. 4.2 Terms and type assignment The syntax of pre-terms \nis given in Figure 1. A pre\u00adterm of the form class ( self My Type) e represents a class with e as the \nrecord of method definitions. Inside those methods, self is used to refer to the object itself, while \nMyType designates its type. The extend and update pre-terms represent subclasses of c which are formed \nby either adding a new method (in the case of extend) or updating a method of c. In either of these cases, \nself and MyType are used as in class terms, while super is used to refer to the record, of methods of \nthe superclass. A pre-term of the form new c represents a new object whose methods axe those specified \nin c. Finally o <= m designates the result of sending the message m to object o. The terms of TOOPL are \ngiven with respect to a type-constraint system, C, and a syntactic type as\u00adsignment, E. The terms with \nrespect to C, E are those pre-terms which can be assigned a type by the type assignment axioms and rules \nin appendix A. C M -.=. . x ! if Bthen Melse N I fun(v:a)Ml MN I M= N I {ml =el,... , m~ =e~ } I e.mi \nI class (self: My Type) e I update c by (self: My Type; supe~ {ml: 71;. . . ;mn:rn}){m~ = e;} I extend \nc with (self: My Type; super {ml: ~l; . . . ;m.: ~n}) {mn+l = en+l} I new c I o <= m. Figure 1: Pre-terms \nof TOOPL without instance variables describes any assumptions that we may have on super\u00adtypes of type \nvariables, while E describes the intended type of term variables. In the rest of this section we explain \nthe intuition behind these rules and axioms. The type-assignment rules for variables, if-then-else, function \nabstractions and applications, and records are similar to those for ordinary programming lan\u00ad guages, \nand are omitted here. The last rule, Subsump, reflects exactly our intuition for subtypes. That is, an \nelement of a subtype can be treated as an element of its supertype. We focus on those rules which are \nspecific to object\u00adoriented languages. We urge the reader to examine briefly all type assignment rules \nin Appendix A before proceeding with the explanations in this section. As discussed earlier, we wish \nto type check meth\u00adods in classes so that they need not be type checked again when inherited in subclasses. \nBecause an in\u00adherited method may depend on yet another method which may be redefined in a subclsss, it \nis important to know how that redefined method might be changed. Suppose D is a class with method m = \n. . . self <= n . . . where n is a method of D with type r. If Dsub is a subclass of D in which m is \ninherited, but in which n is redefined to have type T , we have to ensure that m still type checks. We \nwill be able to assign m the same type as before if self <= n can be assigned the same type in Dsub as \nin D. Since self <= n has type r inside D and has type # inside Dsub, we can use subsumption to assign \nself <= n the type T in Dsub as long as 7- < T. Note that the type of a method rn may involve the type \nMyType. In this case the meaning of MyType in class D will likely be different from its meaning in a \nsubclass Dsub. However, if m is inherited in Dsub, all occurrences of self (and other expressions of \ntype MyType) will now have a type corresponding to ob\u00adjects generated from Dsub rather than D. If the \nonly assumption we make about M yType when we type check m in D is that MyType is a type of objects gen\u00aderated \nfrom a subclass of D (not necessarily exactly D), then the type-checking proof for rn could be carried \nout in exactly the same way for Dsub as for D. The prececlbg discussion can be summarized as fol\u00adlows: \n1. If we redefine a method m from a class D in a subclass, the type of the redefined m should be a subtype \nof that in D. 2. If we can successfully type check a method, while  only assuming that MyType is the \ntype of ob\u00ad jects generated by some unspecified subclass of D, then the body of m will type check properly \nif copied into any subclass of D. Of course, subclasses can also be formed by adding new methods to a \nclass. The two ways of forming subclasses correspond exactly to having the type of the record of methods \nof the subclass be a subtype of the record of methods of the superclass. As discussed at the end of the \nprevious section, this corresponds exactly to our ordering <meth on object types. At thk point we have \nsufficient information to explain the type assignment rule, Class. In order to show class (self: My Type) \ne has type ClassType(MyType)~, it is sufficient to show that e has type r under the assumption that self \nhas type My Type. In thk derivation one is only allowed to assume that MyTYPe <meth ObjectType(MyType)r. \nThat is, we may only as\u00adsume that M yType is the type of an object gener\u00adated by a subclass of class \n( self: M yType) e. The discussion above on assuring the type correctness of inherited methods provides \nthe intuition behind this rule. We next discuss the typing rules for subclasses. Rule Update determines \nwhen a term update c by (self: My Type; super: {ml: q; . . . , .mn:Tn}){ml = ej} has type ClassType(MyType) \n{ml:~~; mz:7-~; . . . . mn:rn}. It is sufficient to show that the new body e; of ml has a type, r;, \nwhich is a subtype of the type T1 of ml in c. As with classes, we type check the new body of ml under \nthe assumption that self has type My Type, which is a type of objects generated by an undeter\u00admined subclaes \nof the updated class. (This ensures that the new body of ml will remain type correct in all subclasses \nof the updated class.) The new body e; of method ml may also refer to the record super of the methods \nof the superclass. Thus the assumption that the type of super is that of the record of methods of c can \nbe used in type checking el. The rule, Extend, for subclasses formed by adding new methods is similar, \nand will not be discussed fur\u00adther here. The type-assignment rule for objects of the form new c is straightforward. \nThe new object has a type of the same shape as the class, c, except that it is an ObjectType rather than \na ClassType. Finally we come to the rule for type checking a mes\u00adsage sent to an object. It is possible \nthat when a message is sent to an object, we may not have exact information about the type of its methods. \nThe most common way this arises is in sending a message to self. In a method all we know is that the \ntype of self, MyType, is <~~t~ to the type of objects generated by the class being defined (see the type \nassignment rule for class terms). Thus the type assignment rule, Message, must take this into consideration. \nMessage determines that o <= m has type ~[-y/MyType] if o has type ~ and y is an object type correspond\u00ading \nto a subclass of a class with method m of type r (i.e., 7 <m.th ObjectType(MyType) {m: ~}). No\u00adtice that \nv is substituted in for MyType in the final type since MyType stands for the type of self, which is ~ \nat the time the message is sent. The careful reader might worry at this point that there may be several \nchoices for the r in the relation ? <m.t~ ob.jectType(MyType) {m: r} in the previ\u00adous paragraph. We hope \nit will be somewhat reassur\u00ading to point out that y <~~~h ObjectType(MyType) {m: r } <meth ObjectType(MyType) \n{m: r} only if r < T, and hence if #[-y/M yType] < ~[-y/M yType]. (Of course, the ultimate reassurance \nis the proof of Theorem 5.1).  5 The soundness of type as\u00adsignment in TOOPL In this section we discuss \nsome of the ideas behind the proof of the soundness theorem for our type ass\u00ad ignment rules. The soundness \ntheorem states that in a denotational model for TOOPL, for all terms M of TOOPL, all type-constraint \nsystems, C, and all syn\u00ad tactic type assignments, E, if the assignment of vari\u00ad ables to values in the \nmodel satisfies C and E, and if C, E k M: r, then the value of F! in the model is an element in the set \nof values corresponding to type r. Other soundness theorems of this sort can be pro\u00ad vided by analyzing \nthe operational semantics of a lan\u00ad guage and showing that types are preserved under computations. (Such \na subject reduction theorem is true in TOOPL and will be presented in a future paper). Another alternative \nis to provide a semantics in terms of an untyped model and then show that all terms with a particular \ntype lie in that part of the model corresponding to the set of elements of its type. In our case, the \nmeaning of a term is given by induc\u00adtion on its typing proof. Hence untyped terms are not given meanings \nat all. Since we do not have to provide meanings for un\u00adtyped terms, our semantics can be given in a \nsimpler form than might otherwise be possible, since we will not need to put in checks that values have \nthe appro\u00adpriate forms. Our soundness theorem essentially says that these checks can be omitted because \nan element which has type r can be shown to be in the set of ele\u00adments corresponding to the meaning of \nT. This makes life much easier for us since we know, for instance, that if M has type CT-+ T, we can \nbe guaranteed that its meaning is a function. Hence we will not need to check this in a semantic definition \nbefore applying it to the meaning of an element of type a. Of course if this theorem failed, then our \nsemantics of terms of TOOPL would not necessarily be well-defined. In order to present our soundness \ntheorem, we need to know something about the possible models of our language, and how to find the meaning \nof terms in this model. One class of models which will satisfy our needs is the collection. of models \nof F~ described in [BM92]. The types in these models are partial equivalence re\u00adlations over a model \nof the untyped lambda calculus. These models can be used to interpret terms of the bounded second-order \nlambda calculus [Gir71, Rey74], and thus support a subtype ordering which corre\u00adsponds to our <. These \nmodels also contain solutions to all relevant fixed-point type and value equations. A model having these \nfeatures is sufficient to inter\u00adpret TOOPL. For instance the solutions to fixed-point equations allow \nus to find meanings for self-referential terms of TOOPL like self and MyType. In [Bru92b] we give a detailed \ndescription of the se\u00admantics of TOOPL. In what follows we simply provide a sketch of these semantics \nin order to motivate the soundness theorem. Readers are referred to [Bru92b] for more details. Let p \nbe an environment assigning type and term variables to appropriate types and values of the model. We \nwrite [~]p for the meaning of type r in environ\u00ad ment p, and [N]p for the meaning of M in p. Functions \nand their types are interpreted as usual, while records are interpreted as functions from field names \nto ele\u00ad ments of the appropriate fields. The interpretations of objects and their types are more complex \nbecause of the inherently recursive meaning of self and My- Type. We begin by discussing object types. \nIf r is a record type, then [ObjectType(MyType) r]p = [dA[objectType(MyType)d~/MyTypel That is, the \nmeaning of the object type is simply the meaning of the type of the record of methods in an en\u00advironment \nin which MyType has been replaced ev\u00aderywhere by the meaning of the type itself. While this is a recursively \ndefined type, our model allows us to find recursive types by using fixed point operators. Objects themselves \nare defined recursively so that self is interpreted as the entire object, and M yType is in\u00adterpreted \nas its type. Sending a message then simply corresponds to extracting the corresponding field from the \nrecord of methods of the receiving object. (In the full language including hidden instance variables, \nthe semantics of message sending is more complex.) Classes and their types are more complex, because \nthe meaning of a class must specify the meaning of methods not only for objects generated from the class, \nbut also for objects generated from any subclass which inherits those methods. As a result, classes are \ninter\u00adpreted as functions which take as a parameter a type which is a possible meaning for My Type. Such \na type could arise as the type of an object generated by a subclass of the class being defined. Since \nwe also need to have an interpretation of self in order to ob\u00adtain the meaning for the methods, the meaning \nof the class will take a second parameter which is an element of the type passed in as the first parameter. \nA simple example should help illustrate this. Let c = class (self: My Type) {x=2, eqX = fun(newx: Int) \n(self <= x) = newx}. The type of c is ClassType (MyType) {x: Int; eqX: Int -> Bool}. Suppose o = [new \nc]p and T = [ObjectType(MyType) {x: Int; eqX: Int-> Bool}]p. Then [c]p = $, and f(Z )(o) is a record \nwith a component x with value 2, and a component eqx which is a function which takes an integer paxam\u00adeter \nand returns true iff that parameter has value 2. Let T be the meaning of a type u such that u <meth ObjectType(MyType) \n{x: Int; eqX: Int -> Bool} and let o be an object from T whose x component is 17. Then f(T ) (o ) is \na record with two components, in which the x component is 2 and the eqX component is a function which \nreturns true iff the parameter it is applied to is 17.1 Once the meaning of classes is understood, it \nis easy to see that the meaning of ClassType(MyType)~ is a collection of functions, each of which takes \na type T (constrained as above), and an element of that type, and returns a record with type [~]p[T/MyType]. \nFinally we note that it is possible to interpret the ordering <metk in this model. The relation 7 <~~th \nObjectType(MyType)~ will be true in the model 1Notice that o itself may have more than two fields, and \nthat the value of o only aflects the meaning of eqX (and not x) because only the body of eqX in c refers \nto self. iff [-y]p < [r]p[[-y]p/MyType].2 Having given an intuitive description of our model and its \nsemantics, we now state the soundness theorem for the type assignment rules of TOOPL. We say that an \nenvironment p is consistent with C, E iff when all variables are interpreted in the model according to \np, all inequalities in C are true, and variables are assigned values in the types specified in E. Theorem \n5.1 (Soundness of semantics with respect to the typing rules) Suppose there is a model as de\u00adscribed \nin this section. FOT all typing derivations, C, E 1-M: CT, if p is consistent with C, E, then [C, E i-M: \nu]p will be an element of type [cT]p. In particular, no term which is well-typed with respect to C, E \nwill ever fail to have a meaning because a mes\u00adsage is not understood by an object. The proof of thk \ntheorem can be given by induction on typing derivations.  6 Updateable instance vari\u00adables The key difference \nbetween methods and instance vari\u00adables is that methods are frozen when an object is created, whale instance \nvariables of an object may be updated. Values of instance variables are specified in class definitions, \nproviding initial values for these in\u00adstance variables when new objects are created from classes (using \nthe new operator). However it is possi\u00adble to make a new copy of an object with a different vaiue for \nan instance variable using the gets expres\u00adsion. In TOOPL we provide different notation for ac\u00adcessing \ninstance variables than for sendhg messages. We write q. x to access the instance variable x of q and \np <= getx to send the message getx top. We update an instance variable x of object p by writing p gets \n{x = e}. The value of this expression is a new object identical to p but with the value of e replacing \nthe old value of x. The addition of updatable instance variables to our language adds considerable complexity. \nOne problem is that when defining subclasses, we may not replace the type of an instance variable by \na subtype since that may break the typing system. Suppose class c has instance variable x with type T \nand has a method m whose body includes the ex\u00adpression self gets {x = e} where e is an expression of \ntype T. If we define a subclass of c which differs only by changing the type of x to be some T J which \nis a proper subtype of T (and of course providing a new initial value for x), then the inherited method \nm will break since we can no longer assign e to x. To be Zsee ~mgzb] for an explanation of why <m.th \nsho~d be interpreted in this way. legal, we would need T ~ T ~ when the reverse is true. Similarly a \nmethod which uses the value of x can be used to show that redefining instance variables in a subclass \nusing supertypes rather than subtypes also has problems. Thus no changes are allowed to types of instance \nvariables in subclasses. A second complicating factor is that we do not wish to have instance variables \nvisible outside of an object. Thus, we will have two different views of an object: the view from inside \nthe object in which all instance variables are visible, and that from without, in which all instance \nvariables are hidden. We will continue to refer to the type of an object from the outside using MyType, \nbut we will now refer to the type from the inside using Selfl ype. Inside a method, the type of self \nwill now be SelfI ype, Often we will need to close Upn an object to hide the instance variables from \nthe outside world. The function close with type SelfType -> MyType will perform this action. The following \nexample of a movable point in the full TOOPL should get across the basic idea. (We take the liberty of \nadding keywords var and methods to make the syntax more readable.) PointClass = class (self: SelfType, \nclose: SelfI ype->MyType) (var {x =o, Y = o}, methods {mv(dx ,dy: Int)= close(self gets {x = self. x \n+ dx, Y = ssilf. y + dy}), getx = self .x, gety = self. y, eq = fun(p:MyType) (self. x = (p <= getx) \n) &#38; (self. y = (p <= gety))}}) Notice that there is no way to directly access the instance variables \nof the parameter p of eq. The type of this class is PointClassType = ClassType(MyType) (var {x,y:Int}, \nmethods {mv: Int -> Int -> MT; getx, get y: Int; eq: MyType -> Bool} ) While the instance variables \nare visible in the type of Point Class, they are not visible in the correspond\u00ading object types. If MyPoint \n= new PointClass then the type of ~ypoint is: PointType = ObjectType(MyType) {rev: Int -> Int -> MyType; \ngetx ,get y: Int; eq: MyType -> Boo1} Thus only the types of methods are visible in ob\u00adject types. We \nalso restrict the types of methods to exclude any mention of SelfI ype, since that informa\u00adtion should \nnot be visible outside of the object. As well as adding some complexity to the subtyp\u00ading and type-checkhg \nrules, the addition of instance variables raises the complexity of the semantics of the language as well. \nFor the moment let us ignore the fact that instance variables are hidden outside object. Then objects \nare interpreted as pairs where the first component is a record containing the current values of its instance \nvariables, wlile the second component consists of a function which, when applied to a set of values of \nthe instance variables, returns the meaning of the record of methods. Recall that the meanings of methods \nare fixed at object creation time (via taking a fixed point so that each occurrence of self in its methods \nrefers to the object as a whole), while the instance variables can be changed at any time. While we could \ntake a new fixed point every time an object s instance variable is updated, we prefer to simply make \na change to the record of current values of instance variables. As a result we will have to go to a bit \nmore work when we send a message to an object. When we wish to extract the value of an instance variable \nof an object, we simply look it up in the first component of the object. However, when we send a message \nto an object we must now apply the second component of the object to the current value of the record \nof instance variables before looking up the ap\u00adpropriate method. Going back to our example, if MyPoint \n= new PointClass, then [!fyPoint]p = ({x = O, y = O}, f), where for v a record value of the form {x = \na, y = b}, f(v) = {mu = g,geih = a,gety = b,eq = h} in which, for actual parameters c and d, g(c, d) \nis ({x = a +c, y = b+ d}, f), while h takes another object value, p, from type Poi.ntType as a parameter, \nand returns true iff the results of sending getx and gety top return the values a and b, respectively. \nTo evaluate [MyPoint <= mv(2, 3)]p, we calculate .f({z = 0, Y = 0}) (since {z = O,y = O} is the cur\u00adrent \nvalue of MyPoint s instance variables), extract the meaning of mv and apply it to the parameters 2 and \n3, getting as an answer an object with value ({z = 2,y = 3}, ~), where ~ is as above. If a mv message \nwere sent to this new object, ~ would now be applied to {x = 2, y = 3} before extracting the meaning \nof IUV and applying it to the actual parame\u00adters. The fact that we wish to hide the instance variables \nfrom outside the object brings in one more complicat\u00ading factor. Fortunately, existential types (see \n[MP88]) provide exactly what we need. Selfl ype will be of the form (a, a ~ r). The function close hides \nthe record of instance variables of an object by converting a pair with type (a, c 4 r) to an element \nwith the ex\u00adistential type, 3v. (v, v a r). Thus MyType and all object types are existential types of \nthis form. Since a method only has access to its own instance variables and self has type SelfType, there \nis no difficulty ac\u00adcessing the needed instance variables. As in the example with IIIV above, before \na new ob\u00adject is returned as the value of a method, it must be closed so that the outside world haa no \naccess to the instance variables. This is enforced by a type\u00adchecking requirement that the types of methods \nnot involve SelfI ype. When a method is sent to an ob\u00adject, one can open the existential type to apply \nthe function in the second component to the current v?lue of the instance variables. Since this does \nnot require knowledge of the exact value of v, this is a type-safe operation which provides the appropriate \nabstraction. A more complete discussion of the full TOOPL language with instance variables may be found \nin [Bru92b].  7 Comparison with previous work As we indicated in the introduction, the language pre\u00ad \nsented in this paper builds on the important papers [CHC90, Mit90]. In a previous paper, [Bru92a], we \ncompared the definitions of inheritance given in the those papers and showed that they were essentially \nequivalent. While we have chosen to give the se\u00ad mantics of TOOPL using the F-bounded second-order lambda \ncalculus, which is closer to the approach taken in [CHC90], the rules for type-checking are based on \nthose given in [Mit90], modified to handle classes and inheritance rather than delegation, and extended \nto handle their interactions with subtypes. While these earlier papers handled only methods, this paper \nalso includes a treatment of instant vari\u00ad ables. Instance variables differ primarily from meth\u00ad ods \nin that they can be updated in objects, whereas once an object is created, the methods are frozen.3 We \nalso include specific mechanisms for referring to the object receiving a message, self, its type, My- \nType, and the methods of the superclass, super. We 3In the case of Mitchell s language, which is based \non dele\u00adgation, there seems to be no advantage to separating instance variables from methods. also have \nprovided a proof that type-checked terms of the language will not encounter type-errors, in partic\u00adular, \nthose related to sending a message to an object that it does not understand. This paper differs from \nmost earlier theoretical anal\u00adyses of statically-typed object-oriented languages by working with a first-order \nlanguage with primitives for object-oriented notions like class, object, and message sending, rather \nthan simulating them within another, usually higher-order language. We hope the reader has found that \nour primitives and resulting language are closer to those of real object-oriented programming languages. \nThere has been considerable interest in the theo\u00adretical community in designing object-oriented lan\u00adguages \nwith clean semantical designs. The major influences on the design work described in this pa\u00adper have \ncome from Cook and his collaborators in the (late and lamented) ABEL project at HP Labs ([CCH+89, CO089, \nCCH089, CHC90]) and the work of Luca Cardelli, John Mitchell and their collaborators ([Car88~ CW85, Car88b, \nCL91, CM90, Car92a]). The research closest in spirit to this paper is that of [Car92b]. Cardelli s goal \nwas slightly different than that of this paper. He wished to find a minimal lan\u00ad guage which was sufficient \nfor expressing the key con\u00ad cepts of object-oriented programming language. Thus he provides a translation \nof a language similar to that given here into a simpler language with constructs for subtyping, bounded \nquantification, and powerful record operations. A recent series of papers by Pierce and his cowork\u00ad ers \n[PT92a, PT92b, PH92] represent an alternative ap\u00ad proach to that of Cardelli and this paper. Their goal \nis to model object-oriented languages using second\u00ad order bounded lambda calculus, but using existential \ntypes to replace the use of F-bounded lambda calcu\u00ad lus (as used in this paper and the work of Cook et \nal) or higher-order fixed points (as used in the work of Cardelli and Mitchell). While their language \nseems slightly less expressive (they have difficulty modelling our Point with eq method), their approach \nallows them to avoid some of the complexity which arises through the proliferation of fixed points in \ndetermin\u00ad ing the meaning of object-oriented constructs.  8 Conclusion In this paper we have described \na functional, object\u00adoriented programming language, TOOPL, and a set of type assignment rules for performing \na static type analysis of terms of the language. More importantly, we have shown that the type assignment \nrules are sound with respect to a semantics for the language. To our knowledge this is the first statically-typed \nobject\u00adoriented language to be proved to have a sound type system. Our language includes all of the \nstandard features of object-oriented programming languages, including ob\u00adjects, classes, methods, updatable \ninstance variables, subtypes, and subclasses. While the full language in\u00adcluding instance variables was \nonly sketched here, the instance variables are an important part of the lan\u00adguage. In order to support \ninformation hiding, objects only have access to their own instance variables. The semantics of objects \nwith instance variables is given using existential types ([M P88]). Because the seman\u00adtics of TOOPL is \ngiven in terms of a model of F< sup\u00adporting parametric polymorphism and recursion, it is easy to add \nthese and other features to the language without compromising the static type checking. It is not uncommon \nfor users to be provided with libraries in the form of compiled code along with in\u00adformation on the types \nof all accessible routines. The type-checking rules for TOOPL are designed to be es\u00adpecially useful in \nthis circumstance, since access to the source code of a class is not necessary in type checking a subclass. \nAll that is needed is the type information for the methods of the superclass, and the code for all method \nbodies added or modified in the subclass. It is worth noting that the subtype relation given in this \npaper is not as powerful as it could be. Since object types are really just recursively defined types, \nit is possible to add a Fold/Unfold rule for them that would allow an object type to be replaced by a \nrecord type in which all occurrences of MyType would be replaced by the object type. We have chosen not \nto include such a rule at this point because we are not convinced of its usefulness (even though it is \nclearly sound). If recursive types (which clearly are useful) were added to TOOPL, one would certainly \nwish to add such a rule for them. We have not discussed an algorithm for type check\u00ad ing in this paper. \nThe recent paper [Pie92] showed that the type-checking problem for F< is undecidable. Since the semantics \nof TOOPL is bw-ed on models of an extension of F<, one might suspect that the type\u00ad checking problem \nfor this language might be undecid\u00ad able as well. The undecidability of type checkhg F< results from \nthe undecidalility of determining if one type is a subtype of another. In contrast, [DM92] have recently \nshown that the subtype problem is decid\u00ad able for TOOPL.4 Buildlng on this, Bruce, Crabtree, Murtagh, \nand van Gent have created a simple variant of TOOPL, called TOOPLE (for TOOPL with Extra information). \nThe only differences in syntax between TOOPL and TOOPLE are that class, extend, and 4 Kozen et ~L[KPS93], \nhave shown that Subtwhw for the extension of TOOPL obtained by adding the Fold/Unfold rule suggested \nabove has an O (n2 ) algorithm. While their paper does not discuss record types, an addition to handle \nthis seems relatively straight-forward. update terms must be labeled with their intended types. Then, \napplying techniques suggested in [CG92], it can be shown (under very natural restrictions on C) that \nevery term which is typeable with respect to C, E has a minimum type. From this an algorithm can be derived \nwhich solves the type-checking problem for TOOPLE. Thus this language has useful practical as well aa \ntheoretical properties.  Acknowledgements Thanks to the following for helpful comments on TOOPL and \nthis entire project: Luca Cardelli, John Mitchell, Benjamin Pierce, Giuseppe Longo, the Har\u00advard University \nObject-Oriented Languages Seminar (including Peter Wegner and Andrew Black), Jon Riecke, and the Williams \nCollege TOOPL research group (Tom Murtagh, Jon Crabtree, Gerald Kanap\u00adathy, and Robert van Gent). References \n[AC90] Roberto Amadio and Luca CardeHi. Sub\u00adtyping recursive types. Technical Re\u00adport 62, Digital Systems \nResearch Center, 1990. [BM92] Kim B. Bruce and J. Mitchell. Per models of subtyping, recursive types \nand higher\u00adorder polymorphism. In P~oc. ACM Symp. on Principles of Programming Languages, pages 316-327, \n1992. [Bru92a] K. Bruce. The equivalence of two se\u00admantic definitions of inheritance in object\u00adoriented \nlanguages. In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, ?%oeeeding$ of the \n7th International Conference on lklathemati\u00adcal Foundations of Programming Seman\u00adtics, pages 102 124. \nLNCS 598, Springer-Verlag, 1992. [Bru92b] K. Bruce. A paradigmatic object-oriented programming language: \ndesign, static typ\u00ading and semantics. Technical Report CS\u00ad92-01, Williams College, 1992. [Car88a] L. \nCardelli. A semantics of multiple in\u00adheritance. Information and Computation, 76:138 164, 1988. Special \nissue devoted to Symp. on Semantics of Data !Q@%, Sophia-Antipolis (Prance), 1984. [Car88b] L. Cardelli. \nStructural subtyping and the notion of powertype. In PTOC 15th ACM Symp. Principles of Programming Lan\u00ad \nguages, pages 70-79, 1988. [Car92a] [Car92b] [CCH+89] [ccH089] [CDG+88] [CG92] [CHC90] [CL91] [CM90] \n[CO089] [CW85] [DM92] Luca Cardelli. Extensible records in a pure calculus of subtyping, Technical Re\u00adport \n81, DEC Systems Research Center, 1992. Luca Cardelli. Typed foundations of object-oriented programming, \n1992. Tu\u00adtorial given at POPL 92. P. Canning, W. Cook, W. Hill, J. Mitchell, and W. Olthoff. F-bounded \nquantification for object-oriented programming. In Func\u00adtional Prog. and Computer Architecture, pages \n273-280, 1989. P. Canning, W. Cook, W. Hill, and W. Olthoff. Interfaces for strongly-typed object-oriented \nprogramming. In Proc. ACM Conf. on Object-Oriented Program\u00adming: Systems, Languages and Applica\u00adtions, \npages 457 467, 1989. L. Cardelli, J. Donahue, L. Galssman, M. Jordan, B. Kalsow, and G. Nelson. Modula-3 \nreport. Technical Report SRC\u00ad31, DEC systems Research Center, 1988. P.L. Curien and G. Ghelli. Coherence \nof subsumption,minimum typing and type\u00adchecking in F<. Mathematical Structures in Computer ?cience, 2:55 \n91, 1992. William R. Cook, Walter L. Hill, and Pe\u00adter S. Canning. Inheritance is not subtyp\u00ading. In Proc. \n17-th ACM Symp. on Prin\u00adciples of Programming Languages, pages 125 13.5, January 1990. Luca Cardelli \nand Giuseppe Longo. A se\u00admantic basis for Quest. Journal of Func\u00adtional Programming, 1(4):417-458, 1991. \nL. Cardelli and J. C. Mitchell. Operations on records. In Math. Foundations of Prog. Lang. Semantics, \npages 22 52. Springer LNCS 442, 1990. W.R. Cook. A proposal for making Eiffel type-safe. In European \nConf. on Object-Oriented Programming, pages 57-72, 1989. L. Cardelli and P. Wegner. On understand\u00ading \ntypes, data abstraction, and polymor\u00adphism. Computing Surveys, 17(4):471-522, 1985.  Allyn Dimock and \nRobert Muller. Private communication, 1992. [Gir71] [GJ90] [KPS93] [Mey92] [Mit90] [MP88] [Omo91] [PH92] \n[Pie92] [PT92a] [PT92b] J.-Y. Girard. Une extension de I interpretation de G6del &#38; l analyse, et \nson application 2L l diminution des coupures clans l analyse et la thdorie des types. In J.E. Fenstad, \ned\u00aditor, 2nd Scandinavian Logic Symposium, pages 63 92. North-Holland, 1971. J. Graver and R,. Johnson. \nA type system for smalltalk. In ACM Symp. Principles of Programming Languages, pages 136-150, 1990. Dexter \nKozen, Jens Palsberg, and Michael I. Schwartzbach. Efficient recur\u00adsive subt yping. In 20th ACM Symp. \nPn n\u00adciples of Programming Languages, 1993. B. Meyer. Eiffel: the language. Prentice-Hall, 1992. J.C. \nMitchell. Toward a typed founda\u00adtion for method specialization and inheri\u00adtance. In Proc. 17-th ACM Symp. \non Prin\u00adciples of Programming Languages, pages 109 124, January 1990. J.C. Mitchell and G.D. Plotkin. \nAbstract types have existential types. ACM Trans. on Programming Languages and Systems, 10(3):470-502, \n1988. Preliminary ver\u00adsion appeared in Proc. 12-th ACM Symp. on Principles of Programming Languages, \n1985.  Stephen M. Omohundro. The Sather lan\u00adguage. Technical report, International Computer Science \nInstitute, 1991. Benjamin C. Pierce and Martin Hoffman. An abstract view of objects and subtyping (Preliminary \nreport). Technical Report to appear, University of Edinburgh, 1992. Benjamin C. Pierce. Bounded quantifica\u00adtion \nis undecidable. In Proc 19th ACM Symp. Principles of Programming Lan\u00adguages, pages 305 315, 1992. Benjamin \nC. Pierce and David N. Turner. Object-oriented programming without re\u00adcursive types. Technical Report \nECS\u00adLFCS-92-226, University of Edinburgh, 1992. Benjamin C. Pierce and David N. Turner. Simple type-theoretic \nfoundations for object-oriented programming. Technical report, University of Edinburgh, 1992. 296 [Rey74] \nJ.C. Reynolds. Towards a theory of type structure. In Pam s Colloq. on Pro\u00adgramming, pages 408 425. Springer-Verlag \nLNCS 19, 1974. [SCB+86] C. Schaffert, T. Cooper, B. Bullis, M. Kil\u00adian, and C Wilpolt. An introduction \nto Trellis/Owl. In 00PSLA 86 %oceed\u00adings, pages 9 16. ACM SIGPLAN No\u00adtices,21(ll), November 1986. [Str86] \nB. Stroustrop. The C++ Programming Language. Addison-Wesley, 1986. [T435] L. Tesler. Object Pascal report. \nTechnical Report 1, Apple Computer, 1985. A The formal definition of TOOPL Definition A.1 Let V be an \ninfinite collection of type variables, L be an infinite collection of labels, and C be a collection of \ntype constants which includes at least the type constants Bool and Num. The type expres\u00adsions with respect \nto V and C are defined as follows: 1. If t G V U C then t is a type expression. .2. If n and r are type \nexpressions, then so is u ~ T. 5 . Ifml,..., mm G L and rl, . . . . Tn are type expres\u00adsions , then {ml: \n71; . . .; mn: rn} is a (record) type expression. 4. If r is a record type expression and MyType G V, \n-then each of ObjectType(l vlyType)r and ClassType(MyType)~ are type expressions. MyType is considered \nto be a bound variable in these two type ezpreasions. In the above definition, the bound variable MyType \noccurring in the method types of object and class types stands for the type of the object which is executing, \nthe method. We will consider two type ex\u00adpressions to be the same if they are the same up to renaming \nof bound variables and reordering of record components. As explained in the body of the paper, s represents \nthe subtype relation between types, while ~~eth is an ordering relating types of objects whose classes \ncould have been defined using inheritance. Definition A.2 Relations of the form u < r and u <meth r, \nwhere u and r are type expressions, are said to be type constraints. 1A moreover, t is a type vam able \nthen we say t < r and t ~~eth T are simple type constraints. If for some r, t < r or t ~meth r are included \nin a set C of simple type constraints, then we say t is declared in C. A type constraint system is defined \nas follows: 1. The empty sequence, c, is a type constraint sys\u00adtem. 2. If C is a type constraint system \nand t < r is a simple type constraint such that t does not appear in C or r, then c; t < T is a type \nconstraint system. 3. If C is a type constraint system, T is of the form ObjectType(MyType)a, and t \n<meth T is a simple type constraint such that t does not appear in C or T, then C; t <m~th T is a type \nconstraint system.  We define type constraint derivations of the form C F u ~ r and C F u ~~~th r, \nfor C a type constraint system, and a, T type expressions, via the following sets of axioms and rules \ngiven below. Note that ~[a/t] denotes the expression obtained by replacing all free occurrences of variable \ntin ~by c. Axioms and Rules for subtypes: SRefl CFT <T, SVar c;t~Tbt <T, SEq C1-u <r  ck(7 <t7, ckT \n<T s-+ CI-O--+T<U +T CFUj<Tj, forl~j~k~n SRee CF{ml:Ul; . . ..mk.Ok; mtz:un}:un} ~ {ml:~l; . . ..mk. \nn} C; s < t 1-~[s/MyType] < #[t/My Type] SObj C 1-ObjectType(MyType)~ < ObjectType(MyType)~ In the \nSObj rule, neither s nor tmay occur free in c, T,or Tr. C; MyType <m.th ObjectType(MyType)r, E U {self \nMyType} F e: r Class C, E 1-class(self MyType)e: ClassType(MyType)~ C, E 1-c: ClassType(MyType)r Object \n C, E !-new c: ObjectType(MyType)~ C 1-y <tn.th ObjectType(MyType) {m: ~}, C, Eto:~ Message C, E E o \n~ m: r[y/MyType] C, E 1-c: ClassType(MyType) {ml: rI; ...; mm: r.}, CI-T; <T1, C; MyType <~~t~ ObjectType(MyType) \n{ml: r:; mz: rz; ...; mm: m}, E U {self: My Type; super: {ml: Tl; . . .; mm: Tn}} ~ e~: r~ Update C, \nE 1-update c by (self My Type; super: {ml: ~l; . . .; m.: ~n}){ml = ej}: ClassType(MyType) {ml: r;; m2: \n72; . . .; m.: ~.} C, E 1-c: ClassType(MyType) {ml: rl; . . .; mm: T.}, C; MyType <~et~ ObjectType(MyType) \n{ml: 71; ...; mn: rn; mn+l: rn+l}, E U {self MyType, super: {ml: ~l; ...; mn: Tn}} 1-en+l: Tn+l Ewtend \n C, E 1-extend c with (self: My Type; super: {ml: rl; . . .; m.: r.}){m.+l = e.+l}: ClassType(MyType) \n{ml: rl; . . .; m.: T.; mn+l: Tn+l} CI-O <T, C, E1-e:o Subsump C, Eke:r Figure 2: Type Assignment Rules \nAxioms and Rule for <me~h: l--ObjectType(MyType)r <m.th MRe f ObjectType(MyType)r, C 1-y <m~~h ObjectType(MyType)r, \nCI-T <T MT w? %~tk Ob.iectType(MyType)r Definition A.3 A syntactic type assignment, E, is a jinite \nset of the form: E = {X1:71, . . ..zn. rn) with no variable xi appearing more than once in E. The standard \ntype assignment rules for the object\u00adoriented terms of the language appear in Figure 2. The type assignment \nrules for the other terms are as usual. 298 \n\t\t\t", "proc_id": "158511", "abstract": "<p>In this paper we introduce a statically-typed, functional, object-oriented programming language, TOOPL, which supports classes, objects, methods, instance variable, subtypes, and inheritance.</p><p>It has proved to be surprisingly difficult to design statically-typed object-oriented languages which are nearly as expressive as Smalltalk and yet have no holes in their typing systems. A particular problem with statically type checking object-oriented languages is determining whether a method provided in a superclass will continue to type check when inherited in a subclass. This program is solved in our language by providing type checking rules which guarantee that a method which type checks as part of a class will type check correctly in all legal subclasses in which it is inherited. This feature enables library providers to provide only the interfaces of classes with executables and still allow users to safely create subclasses.</p><p>The design of TOOPL has been guided by an analysis of the semantics of the language, which is given in terms of a sufficiently rich model of the F-bounded second-order lambda calculus. This semantics supported the language design by providing a means of proving that the type-checking rules for the language are sound, ensuring that well-typed terms produce objects of the appropriate type. In particular, in a well-typed program it is impossible to send a message to an object which lacks a corresponding method.</p>", "authors": [{"name": "Kim B. Bruce", "author_profile_id": "81100168232", "affiliation": "", "person_id": "P161588", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158650", "year": "1993", "article_id": "158650", "conference": "POPL", "title": "Safe type checking in a statically-typed object-oriented programming language", "url": "http://dl.acm.org/citation.cfm?id=158650"}