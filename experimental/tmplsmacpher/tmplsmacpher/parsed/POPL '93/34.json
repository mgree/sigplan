{"article_publication_date": "03-01-1993", "fulltext": "\n Type C~ecking Type Classes Tobias Nipkow* and Christian Prehofer** TU Miinchentt Abstract We study the \ntype inference problem for a system with type classes as in the functional programming language Haskell. \nType classes are an extension of ML-style polymorphism with overloading. We generalize Milner s work \non polymorphism by introducing a separate con\u00adtext constraining the type variables in a typing judge\u00adment. \nThis leads to simple type inference systems and algorithms which closely resemble those for ML. In par\u00adticular \nwe present a new unification algorithm which is an extension of syntactic unification with constraint \nsolving. The existence of principal types follows from an analysis of this unification algorithm. 1 Introduction \nThe extension of Hindley/Damas/Milner polymorphism with the notion of type ciasses in the functional \npro\u00adgramming language I&#38;skell [6] has attracted much at\u00adtention. Type classes permit the systematic \noverloading of function names while retaining the advantages of the Hindley/Damas/Milner system: every \nexpression which has a type has a most general type which can be inferred automatically. Although many \nextensions to Haskell s *Research supported in part by ESPRIT BRA 3245, Logical Framework%. **Research \nsupported by the DFG under grant Br 887/41, De\u00adduktive Program mentwick[ung. t t Ad&#38;-ess: Institut \nfiir Informatik, Technische Universitiit Miinchen, Postfach 20 24 20, W-8000 Miinchen 2, Germany. Email: \n{nipkow,prehofer@informatik .tu-muenchen .de Permission to copy without fee all or part of this material \nis granted provided that the copies are not made or distributed for direct commercial advantage, the \nACM copyright notice and the title of the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery. To copy otherwiee, or to republish, requires \na fee and/or specific permission. ACM-20th PoPL-1/93-S.C., USA o 1993 ACM 0-89791 -561 -5/93 /0001 /0409 \n.,.$1 .50 type system have already been proposed (and also im\u00adplemented), we believe that the essence \nof Haskell s type inference algorithm has still not been presented in all its simplicity. The main purpose \nof this paper is to give what we believe to be the simplest algorithm published so far, a contribution \nfor implementors. At the same time we present a correspondingly simple type inference system, a contribution \naimed at users of the language. The algorithm is sound and complete with respect to the inference system, \nand both are very close to their ML-counterparts. Despite this proximity, the proofs are considerably \nmore involved and only the main steps are shown. A type class in Haskell is essentially a set of types \n(which all happen to provide a certain set of functions). The classical example is equality. In old versions \nof ML, the equality function = has the polymorphic type da.a * a * bool, where the type variable a ranges \nover all types. However, = should not be applied to ar\u00adguments of function type. To fix this problem, \nStandard ML [11] introduces special type variables that range only over types where equality is defined. \nEquality dif\u00adfers from other polymorphic functions not just because of its restricted domain but also \nbecause of its mixture of polymorphism and overloading: equality on lists is implemented differently \nfrom equality on integers. Type classes treat both issues in a systematic way: the type variable a is \nrestricted to elements of a certain type class, say Eq. Then for each type r where = should be defined, \nwe have to declare that T is of class Eq by providing an implementation of = of type r ~ r -+ bool. To \nexpress the fact that a type T is in some class C we introduce the judgement r : C.~ The idea of viewing \nHaskell as a three level system of expressions, types and classes, where classes classify types, goes \nback to Nipkow and Snelting [12]. However, in their system it is impossible to express that a type belongs \nto more than one class. To overcome this difficulty we introduce sorts I ~ ~l=~e~ me iewed as predicates \non types, this leads to the Haskell notation C(,). as finite sets of classes. The judgement r : {Cl, \n. . . . C ~} is a compact form of the conjunction r : C l A . . . A ~ : C ~. Alternatively we may think \nof {Cl,..., C~} as a notation for Cl n . . . n C~, the intersection of the types belonging to the classes \nCl to C.. This leads to a simple type inference system and algorithm. The former resembles that for Mini-ML \n[4], the latter is very similar to algorithm Z by Milner [10]. The main difference is that in both cases \nwe also compute a set of constraints of the forma : {Cl, ..., C.} where a is a type variable.  Mini-Haskell \nSince the aim of this paper is simplicity, we treat only the most essential features of Haskell relating \nto type classes. The resulting language is basically Mini-ML [4] plus class and instance declarations, \nMini-Haskell for short. Its syntax is shown in Figure 1. Although the next paragraph provides a brief \naccount oft ype classes, the reader should consult the Haskell Report [6] or the original paper on type \nclasses [14] for motivations and examples. Mini-Haskell extends ML by a restricted form of over\u00adloading. \nEach class declaration introduces a new class name C and a new overloaded function name x. Seman\u00adtically \nC represents the set of all types which support a function Z. For instance class Eq where eq : d~:Eq \n.a -a ~ bool introduces the class Eq of all those types ~ which pro\u00advide a function eq : r * r * boot. \nA class declaration is like a module interface in that it separates declara\u00adtions from implementations. \nIn order to prove that a particular type, say int, is in Eq, a witness for the re\u00adquired function eq \nneeds to be provided. This is the pur\u00adpose of instance declarations. In order to prove int : Eq we instantiate \neq by eq.int, some existing function of type int -+ int --+ bool: inst int : Eq where eq = eq-int As \nmotivated in the introduction, sorts are finite sets of classes. This representation is a key ingredient \nfor the concise treatment of type inference. Yet semantically the sort {Cl, . . . . C.} should be understood \naa Cl n.. .n C.. Thus {C} and C are equivalent, and the empty set {} is the sort/set of all types. If \nS1 is more specialized, i.e. represents fewer types, than S2, we write S1 s S2. Since sorts are interpreted \nas intersections, S1 s Sz e S1 ~ S2 holds. Hence any two sorts S1 and S2 have a greatest lower bound \nwhose representation is their union S1US2. Types in Mini-Haskell are simply terms over vari\u00adables and \nconstructors of fixed arity. Note that ~ is just another type constructor, i.e. T1 ~ T2 is short for \n+(TI, 72). The set of free variables in a type scheme is denoted by 3W(a). Bound variables in type schemes \nrange only over certain subsets of types: da :S.0 ab\u00adbreviates all instances [r/a]a where r : S, a judgment \ndefined formally below. Expressions are A-terms ex\u00adtended with let-definitions. A program is a sequence \nof declarations followed by an expression. A Mini-Haskell class declaration class C where z : Vcr:C.u \n(where a should contain no free variables except a) corresponds to the Haskell declaration class C a \nwhere z : a. The translation in the oppo\u00adsite direction is more involved because of the following simplifying \nassumptions: 1. A class declares only one function symbol, whereas Haskell allows a set of functions. \nThis feature is clearly not essential. Strictly speaking, we could have dropped clam names altogether \nsince there is a one to one correspondence between class names and the single function declared in that \nclass. How\u00adever this would have obscured the connection with Haskell. 2 Classes are not ordered. It has \nalready been ob\u00adserved [3] that subclasses are mere synt attic sugar. Section 6 discusses ways of dealing \nwith subclasses. A Mini-Haskell instance declaration inst t : (s,,..., Sn)C where z = e expresses that \nt(~l, . . . Tn) is in class C provided the ri are of s?rt S i. It corresponds to the Haskell declaration \ninst (con) ~ C(t Crl . . . an) where z = e where con is a list consist\u00ad ing of assumptions Cl ~i with \nC) E Si for all i = 1 . . .n. In the sequel a list of syntactic objects SI, . . . . Sn is abbreviated \nby ~. For inst ante, Van :Sn .U is equivalent with Vcrl:S1, . . . . an: Sn.u. 2.1 classifying Types Before \nwe embark on type inference, the simpler prob\u00adlem of sort inference has to be settled. In ML and many \nother languages we have the judgement e : T, expressing that e is of type ~. Similarly, we classify types \nby sorts with the judgement r : C, stating that type r is in class C. This judgement requires two kinds \nof information, namely the sorts of the type variables in r and the functionality of the type constructors. \nThe former is recorded in a sort context 17, which is a total mapping from type variables to sorts such \nthat flom(r) = {a I ra # {}} is finite. Sort contexts can be written as [al:Sl, . . . . afi:Sn]. The \nbehaviour of type constructors is specified by declarations of the form t : (~)C which have exactly the \nsame meaning aa Type classes c Sorts S={ fq,..., cn} Type variables a Type constructors t Types T=o![t(Tl,....Tn) \nType schemes u = T I va:s.(7 Identifiers x Expressions e = I fe~ e,) I Axe I letx=e~ine~ Declarations \nd = class C where z : Va:C.u I instt: (s,,..., Sn)C where x = e Programs P = d;ple Figure 1: Syntax \nof Mini-Haskell types and expressions the corresponding instance declarations. A set of such declarations \nis called a signature and is denoted by A. Given a context r and a signature A, we can infer the sort \nof a type r using the judgement 17,A t-T : S. The rules are shown in Figure 2. Remember that the sort \n{C} and the class C are equivalent. Having seen sort inference for Mini-Haskell types we are prepared \nfor our main goal, type inference and type reconstruction for Mini-Haskell programs.  3 Type Inference \nSystems In this section we present two type inference systems for Mini-Haskell. We start with a set of \ninference rules which define the types of Mini-Haskell programs and expressions. Then we proceed to a \nmore restricted, syntax-directed set of rules, which will be the basis for the type inference algorithm. \nAs usual in type inference for ML-like languages, an environment is a finite mapping E = [X1 :Ul, . . \n. . Xn :Un] from identifiers to types. The domain of E is Zlom(E) = {x,,..., ~n }. E[ZYY] is a new map \nwhich maps a to a and all other ~i to Oi, and the free type variables in E are fiV(E) = 3V(E(Z1)) U . \n. . U FV(J7(Zn)). If V is a set of type variables the restriction of 17to variables not in V is rlv = \n[da [ czG D0772(r) V]. The judgement f , A, E 1-p : u states that the Mini-Haskell program p is of type \na under A and the assump\u00adtions in I and E. For a program p, which begins with a series of class and inst \ndeclarations, the typing rules in Figure 3 can be applied backwards to build up A and E. For in\u00adst ante, \napplying rule INST backwards adds the new declaration t : (Z)C to A in the first premise. The second \nand third premises compare the types of x and e in order to type-check x = e. These assumptions in A \nand E are used in the typing rules for expressions e in Figure 4. The rules extend the classical system \nof Damas and Milner [5] by the notion of sorts, which are represented in contexts and in restricted quantifications \nof type vari\u00adables. The assumption a c YV(a) in VI is not really es\u00adsential (for soundness) but simplifies \nthe analysis later on. Its practical significance is discussed in Section 8. In contrast to the CLASS \nand INST rules, the sig\u00adnature A remains fixed in the typing derivation for an expression. 3.1 Syntax-directed \nType Inference The next step towards a type checking algorithm is a more restricted set of rules that \nis sufficient for type re\u00adconstruction. The application of the rules is determined by the syntax of the \nexpression whose type is to be com\u00adputed. To distinguish the syntax-directed system we use t- , ASM etc \nto denote its inferences and rules. Definition 3.1 The type scheme a = V=. r is a generic instance of \nu = QCYm5 m.T under r and A, writ\u00adten 17,A 1-a &#38; u , iff there exists a substitution d such that \n6%= T , Dom(0) ~ {G}, r[=~, A 1-19a~:S~ [i=l... m], {~} n m(~) = {}. For the syntax-directed system, \nthe rules APP and ABS remain unchanged, the quantifier rules are incor\u00adporated into ASM and LET, as shown \nin Figure 5. [i=l... n] 17,A< T:Ci S1 r, AFT: {cl,..., cn} r, A} T:{cl,..., cn} SE i=l. ..n I , Al-T:Ci \nr(a) =s TVAR r, A1-a!:s I [i=l... n] Figure 2: The judgement 17,At-~ : S I , A, E[dda:C.u] t-p : C CLASS \n r, A, E h class C where x :VmC.o; p: C I 17, AU{t:(z)C}, Et-p:&#38; E(z) = Va:C.C I [an:Sn], A, E F \ne : [t(7ZJ/@]o INST I , A, Et-inst t:(%) Cwherez=e; p:u Figure 3: The judgement I , A, E F p : u There \nis a straightforward correspondence between the two systems. The syntax-directed derivations are sound \nTheorem 3.2 If r, A,E F e:T then I , A, E F e :T. and in a certain sense complete w .r.t. the original \nsys\u00adtem: Theorem 3.3 If r, A, E !-e : VcYn:Sn.T then I [a~:S~], A,E t- e : ~. The last theorem clarifies \nin what sense h works differ\u00adently from t-: by applying the primed rules backwards, the sort constraints \nfor type variables are stored solely in I , and not in the type scheme of e. For instance, the LET rule \nexplicitly extends J7. The &#38; operation, used in the ASM rule, may introduce new type variables, whose \nsorts must be recorded in 17. The syntax-directed system already has a very operational flavour. In order \nto make the transition from a type inference system to an algorithm we need one more ingredient: unification. \n 4 Unification of Types with Sort Constraints This section deals with unification in the presence of \nsort constraints in the form of contexts. This problem can in principle be reduced to order-sorted unification, \nas done in [12], using the ordering coming from the in\u00adclusion between sorts. However, we have refrained \nfrom doing so because it is contrary to our quest for simplic\u00adit y: involving order-sorted unification \nmakes the algo\u00adrithm appear more complicated than it actually is. In addition, the standard theory of \norder-sorted unification assumes that variables are tagged and would thus need to be reformulated anyway. \nFor the remainder of this paper we assume a fixed signature A. This is simply a notational device which \navoids parameterizing judgments etc. by A. In our setting, a substitution is a finite mapping from type \nvariables to types. Substitutions are denoted by 6 and 6; {} is the empty substitution. Define 9orn(L9) \n= {a I da # a} and COCZ(0) = lJa.mO~(0) FV(%GV)). Since sort information is maintained in contexts, we \nfrequently work with pairs of contexts and substitutions. l_ ,A, El-e: Va:S.u r, At-T:S VE r, A, E1-e \n: [T/a]c 17[a:fTJ, A,ER e : u a G YV(U) FV(E) VI I , A, EI-e : Vcr:S.~ APP I , A, Ete1:T2+T1 17,A, EFe2:r2 \nI , A, EI-(el ez) :71 17,A, l?[z:r~] t-e : rZ ABS I , A, Ekkc.e:Tl-+Tz LET I , A,EF el : U1 I , A, E[z:al] \n1-ez : C72 I , A, El-let x=e1ine2:u2 Figure 4: The judgement I , A, E 1-e : u ASM, I , A 1-E(x) ~ T \nI , A, Et x:T I [a~:S~], A, E+ el : q r, A, E[i#dCYk:Sk.T1] l- ez : T2 {@} = FV(T1) FV(E)LET I , A, \nEk letx=e1ine2:r2 Figure 5: The judgement r, A, E k e : u A substitution O obeys the sort constraints \nof 1?in the Dorn(t, C) return the greatest element of D(t, C) or fail context of 17 , written 17 t-O \n: r, iff I , A i-Oa : ra if D(t, C) is empty. for all a. Because 17, A 1-da : I a is trivially fulfilled \nSorted unification can be expressed as unsorted uni\u00ad if 17a = {} it suffices to require I , A t-t9a : \nI a for all fication plus constraint solving. Given a coregular sig\u00ad ~ zh(r). nature A, this has the \nfollowing simple form: As usual, we define an ordering on context\u00ad ~ni~y(r, ~1=72) = substitution pairs: \nlet O = rngu(~l=~a) (r,e)~(r ,d ) ~ 3&#38;6d=# A I h6:17 r. = LL@m@)r~) o~ ~~~w~~l in (r. u (r\\D0~(6)), \n0) where 60 is their composition: (60)(s) = 6(0(s)). The set of unifiers of 71 and rz w.r.t. II, writ\u00adwhere \nmgu computes an unsorted mgu (in particu\u00adten U(r, ~l=7z), consists of the following context\u00adlar we assume \nthat O is idempotent and that Dom(d) Usubstitution pairs: Cod(O) ~ 3W(71 =Tz)) or fails if none exists. \nU(r,Tl=Tz) = {(r ,6) I 6%1 = 6%z A I F 6: I } A context I is more general than 17 , written I > I , if \n17a ~ I )cr for all a. The union of two sort contexts is A unifier (1 0, 190) e Z-I(I , 2-1=T2) is most \ngeneral if defined by(rO, O.) ~ (rl, 01) for all (rl, 8,) E ~(r, 7,=72). We say that unification modulo \nA is unitary if for all I and r1ur2 = [~: rla u r2a I cx E DOm(I ,) uDOm(I 2)] ~1=T2 the set ~ (r, rl \n=TZ ) is empty or cent ains a most general unifier. and constrain (~, S) computes the most general context \nA signature A is called coregular if for all type con-r such that r , A t r: S: structors t and all classes \nC the set D(t, C) = {%] t:(z)C c A} Const? ain(a, s) = [CY:sq is either empty or cent sins a greatest \nelement w .r.t. the constrain(t(%), S) = u constr(~, Dorn(t, C)) component-wise ordering of the ~. If \nA is coregular let Ccs const? (~, %) = u constr=ain(r~, S~) i=l. ..n Thus unify fails if mgu fails or \nifsome90m(t, C) used in constrain does not exist. Soundness and com\u00adpleteness of constrain are captured \nby the following lemmas: Lemma 4.1 constrain(~, S), A b T : s or constrain(r, S) fails. Proof by induction \non the structure of r. c! Lemma 4.2 constrain(dr, S) 1-0: constrain(~, S). Proof by comparing the calling \ntrees of constrain(~~, S) and const~ain(r, S), using Lemma 4.1 at the leaves of the constrain(~, S) tree. \n0 Lemma 4.3 If r, A 1-T : S then constrain(r, S) is dejirted and more generai than F. Proof by induction \non the structure of r. 1 Theorem 4.4 If A is coreguiar, unify computes a most general unifier. Proof \nTo show soundness, let uni f y(I , T1 =72) ter\u00adminate with result (1 O, @o). It follows directly that \n190rl = 60T2. It remains to be seen that 1701-00a : 17a for all a. If a @ Dorn(Oo), then ra c roa and \nthe claim follows trivially. If a ~ Dorn(Oo ) then r ~ 17c= constrain(eo~, rp) ~ co7wtrain(OOa, 17a) \n upah(~o) and the clalm follows from Lemma 4.1. To show completeness let (1 1, b 1) E 24(I , rl =rz), \ni.e. 191~1 = 1917z and I 1 F 61 : I . Since rl and T2 have an unsorted unifier 91, mgu(rl =T2) is defined \nand yields a substitution 00 such that 01 = 600 for some 6. Definedness of uni~y(r, 71=7-2) also requires \nde\u00adfinedness of constrain(~oa, I s): since rl 1-L91a : 17a, Lemma 4.3 implies definedness of constrain(el \na, J7a) which easily yields defmedness of const rain(80 a, I s). Thus uni~y(I , ~1=7-2) terminates with \na result (ro, 6.). It remains to be shown that 1 1 F 6 : 170. If @ E Dom(Oo) then I op = {} and hence \nrl 1-6P : I o~ holds trivially. Now assume ~ @Dom(OO ). Thus rof? = 17J3u I @. From 1 1 t-01:17 it follows \nthat rl F 68: I D. Prov\u00ading 1711-6: r. is more involved. From Lemma 4.2 it fol\u00adlows that constrain(dla, \nI s) t-6: constrain(Oocr, I s) for any a and hence Ua=DO~(@O1constrain(61a, I cx) F\u00ad LJa~DOm~OO~ cOnstrain(OOa, \nr~), i.e. Uaah(eo)r~)+~ rc(*)since eonst~a~n(el~,rl + 191aLemma 4.3 implies 171< constrain(O1~, I s) \n :17a, and hence rl < &#38;nOm(eO) constrain(6j a, ra). Thus 171k 6: r. follows from (*) by monotonicity. \n1 Theorem 4.5 Unification modulo A is unitary iff A is coregular. Proof The if direction is a consequence \nof Theo\u00adrem 4.4. For the only if direction let A not be coreg\u00adular. Let < denote the component-wise ordering \nof sort tuples ~. Thus there are two declarations t:(~)C and t :(~) C , ~ ~ ~, and ~ ~ ~, such that there \nis no third declaration t:(~)C, and Sn, T. < ~. Hence the unification problem ([,B:C], t(~)=~) does not \nhave a most general unifier. Two maximal ones are ([ml, 0) and ([an:T.], O) where O = {~ --+ t(?i!J}. \n0 Thus we have a precise characterization of those signa\u00adtures where principal types exist. 5 Principal \nTypes and Algorithm T The above syntax-directed rule system is non\u00addeterministic, since rule ASM can \nchoose any instance of the type of the identifier x. To obtain a determinis\u00adtic algorithm, we refine \nthe syntax directed system such that it keeps types as general as possible. The result is algorithm Z \nin Figure 6. In this section we assume that A is coregular otherwise unify is not well-defined. Algorithm \nZ follows the same pattern as Milner s orig\u00adinal algorithm of the same name [10]: the type of an expression \ne is computed by traversing e in a top-down manner. Z returns a quadruple (V, 17,0, ~), where 67 is the \ntype of e under the context I . The parameter V cent ains all used variables, i.e. variables that occur \nin r or in O or in E. Thus a type variable a @ V is a new variable. Observe the different let-constructs: \nthe one on the left hand side is in the object language, the ones on the right are part of the type inference \nalgorithm. For an environment E and a substitution 0, define 8E = [z : O(E(Z)) I z E Dom(E)]. We say \nE is closed if 3V(E) = {}. The free variables of a substitution O are defined as FV(0) = {FV(t9cz) U \n{a} \\ a c Dom(0)}. Let D denote the empty context. Theorem 5.1 (Correctness of Z) If Z(V, I , 6, E, e) \n= (V , I , 0 , T) and Dom(I ) u FV(0) u 7V(E) ~ V then I , A, 6 E P e :O T. Proof by induction on the \nstructure of e, using a num\u00adber of auxiliary lemmas. n A type reconstruction algorithm should compute \nmost general types, usually called principal types, if they exist. Definition 5.2 Let E be a closed environment. \nThe type scheme u is a principal type of an expression e w.r.t. Aand Eiffl, A, Ete: uandifuj A, E1-e:&#38; \nimplies O,AI-a &#38; a . Z(V, r, 0, E,e) = case e of X* let Va.:Sn.7 = 17(z) Pi @ v [i=l... n] in (v \nU {Z}, rwn:sn], o, [A/%lT) kc.e =+ let @@v (v , r , e , ~) = Z(V u {a}, r, 0, E[z:Q], e) in (v , r , \no , ~ ~ 7) (e, ez) * let (Vi, r1,61, ~1) = Z(V, r, 6, E, el) (w, r2, e2, T2) = Z(V1, I 1, 01, E, e2) \ncY@Yl! (r , 0 ) = ~ni~y(rz, 027, = 6272 ~ ~) in (V2 u {cY}, r , 8 02, a) letz=elinez * let (vi, rl, dl, \nT1) = Z(r, O,E,el) {~} = FV(OIT1) -FV(OIE) in T.(V1, I l\\{~}, 64, E[z: b ~~:rla~.dl~l], ez) Figure 6: \nAlgorithm Z The following lemma is crucial for establishing the principal type theorem. Lemma 5.3 If \nI , A, E F e : r where E = ti 8E and I F 6 : I then there exist V and b; such that Dorn(r) u 7V((?) \nu W(E) G V, Z(V, I , O, E,e) = (Vl,I 1,01,~1), E = 6{01E, 7- = 6{8171, r ~b; :rl. Proof by induction \non the structure of e, using a num\u00adber of auxiliary lemmas. 0 Theorem 5.4 1 o, A, E l- e : r and E as \nclosed then Z({}, u, {}, E,e) = (V, r, 0, T) and V@n:I an.6% is a principal type of e w.r.t. A and E, \nwhere G = 3V(8T). Proof follows from Lemma 5.3. 1 We may restrict our attention to closed environments \nbecause CLASS and INST declarations cannot intro\u00adduce free variables into an environment E: type schemes \nin CLASS declarations must be closed. Algorithm Z relies on unify which has only been defined for coregular \nsignatures. Hence it remains to be seen if Mini-Haskell s CLASS and INST declara\u00adtions yield coregular \nsignatures. In fact they do if re\u00adstricted by the following context condition which is the result of \ntranslating the restrictions actually adopted in Haskell [6, Sec. 4.3.2] to Mini-Haskell: For every class \nC and type constructor tthere is at most one instance declaration inst t : (SJc. The more complex restrictions \nfor Haskell collapse to this single requirement because of the absence of sub\u00adclasses. One can easily \nsee that a signature is coregular if it is derived from a set of instance declarations which meet the \nabove restriction. The converse does not hold: the following declarations violate the above restriction \nclass C where c : VCY:C.CY; inst int :06 where c = 1; inst int : OC where c= 2; although they give rise \nto the coregular signature {int : 0C}2. The reason is that although coregularity suffices for the existence \nof principal types, it does not preclude semantic ambiguities: the expression c + 1 is definitely of \ntype int but may evaluate to either 2 or 3, depending on which instance is chosen for c. Hence the above \naddi\u00adtional restriction which rules out situations like these. 6 Haskell = Mini-Haskell + Sub\u00adclasses \nCompared to standard Haskell, the main missing type class feat ure of Mini-Haskell is the notion of subclasses. \nSubclasses are clearly beneficial aa far as methodical as\u00adpects are concerned. However, for semantics \nand type reconstruction, subclasses are synt attic sugar and can be eliminated. We present two methods \nfor handling subclasses. Subclasses can be integrated into our type inference system by slightly changing \nsome definitions. 2It is easy to give similar examples where the INST declara\u00adtions not only differ in \nthe fmction (or constant) provided. As an alternative, we give a method for eliminating sub\u00adclasses. \nWJe assume the restrictions on inst ante decla\u00adrations adopted in actual Haskell, which are the reason \nwhy the latter method is particularly simple. Assume a set of Haskell classes C with an ordering <. If \nC ~ D, we say that C is asubclass of D and D is a superclass of C. To accommodate subclasses, we extend \nthe Mini-Haskell judgement that defines sort membership of types, I , A 1-r : S to the judgement r, A \nI-H ~ : S. The rules S1, SE, TVAR, and TCON are the same for the Haskell-judgement +H; we only have one \nadditional rule for the subclass ordering: SUB ~,LitHr:c C~D I jAtHr:D 6.1 Integrating Subclasses Our \nunification and type inference algorithms easily ac\u00adcommodate subclasses. We give a brief sketch of the \nnecessary extensions. In essence, only the unification algorithm is affected by the integration of subclasses. \nThe key idea is to redefine the ordering on sorts: S<s e  VC ES 3CES.C+C As above, the ordering < \nextends in the component\u00adwise way to sequences of sorts %. Then for a type constructor tand a class C, \nthe definition of D(t, C) is generalized to D(t, C) = {z I~D S C.t :(X)D cA} Coregularity is defined \nas above: D(t, C) must be empty or have a maximal element for all t and C. Similar to above, it can be \nshown that coregularity is necessary and sufficient for unitary unification and hence princi\u00adpal types. \nThe restrictions adopted in Haskell imply coregularit y also in the presence of subclasses and are also \nmotivated by semantic reasons, as discussed in Sec\u00adtion 8. 6.2 Eliminating Subclasses The idea behind \ntranslating Haskell type classes into Ivfini-Haskell is to replace Haskell classes by the set of their \nsuper sorts. Let CT = {C \\ C ~ C } and cor\u00ad respondingly ST = lJCc~ CT. Then a Haskell-like class declaration \nclass C ~ S where x = Va:C.Van:S~ .r states that C is a subclass of all C E S. Assume that the subclass \nordering < has been built up from the CLASS declarations. Then the above CLASS dec\u00adlaration translates \ninto the Mini-Haskell declaration class C where x = VcY:C.VcY~:Sn T.T A Haskell instance declaration \ninst t :(~)C where z = e simply translates into inst t : (Sn~)C where z = e In the last translation \nit is not necessary to expand C into several declarations, one for each element of CT, since Haskell \nrequires that if t(. . .) is declared as an inst ante for C, then it also has to be an inst ante of all \nsuper classes of C. Another consequence of this re\u00ad striction is that the rule SUB for type classification \nis redundant in the case of Haskell. Assume a Mini-Haskell class signature A that also includes an ordering \n< on classes. For this Haskell-like signature, let At denote the pure Mini-Haskell signa\u00adture obtained \nby translating all instance declarations in A with the above rule. Define further I ~ = [a : (1 a)~ a \n~ Dom(I )]. We show the correctness of the transla\u00adtion with the following theorem. Theorem 6.1 Let A \nbe a Mint-Haskell signature with an orderzng on classes. Then 17, A I--H T : C zflI ~, At + r : CT. It \nshould be noted that this translation loses some information about the class ordering. The difference \nto the former method emerges when Mini-Haskell is trans\u00ad lated into a functional language without classes, \ne.g. ML. For instance, assume the class ordering Ord < Eq. Then a type T of sort Ord would be translated \ninto a type of sort {Oral, Eq} by the latter method. This is equivalent in the sense that an object of \ntype r still provides the same functions. The particular instances of these functions cannot be computed \nat compile time and are usually carried around at run time in the form of dictionaries (of functions). \nNow we can see the dis\u00ad advantage of the latter method: an object of type ~ re\u00ad quires two dictionaries \ninstead of only one, In contrast, after integrating subclasses, the two sorts {Oral, Eq} and Ord are \nequivalent (since {Oral, Eq} s Ord and Ord ~ {Oral, Eq}) and only one dictionary has to be used for either \none. 7 Related Work The structure of algorithm Z is very close to that of Milner s algorithm of the same \nname [10]. Apart from the fact that our version of~ is purely applicative (hence we carry the substitution \nand the set of used variables around explicitly), the main difference is that we also have to maintain \na set of constraints r. In fact, this is the only real difference to Milner s algorithm. It is interesting \nto note that Milner s first formulation of t ype inference uses a purely functional algorithm W which \nis non-increment al, i.e, does not take a given substitution 0 and produce an extended one 6 , but computes \nthe result substitution from scratch. Whereas he considers Zmerely a more efficient refinement, in our \ncase there is a very strong simplicity argument in favour of the increment al version: when typing an \napplication (el ez) it is far simpler to type ez under the constraints due to el than compute two separate \nconstraints 1 1 and r2 and having to merge them afterwards. Probably the first combination of ML-style \npolymor\u00adphism and parametric overloading (as opposed to finite overloading as in Hope [2]) was presented \nby Kaes [8]. His language is in fact very close to our Mini-Haskell, ex\u00adcept that he does not introduce \nclasses explicitly. More importantly, he does not use contexts to record infor\u00admation about type variables \nbut tags the type variables directly. The original version of type classes as presented by Wadler and \nBlott [14] was significantly more powerful than what went into Haskell, the reason being that the original \nsystem was undecidable, as shown later by Vol\u00adpano and Smith [13]. The relationship to Haskell proper \nis discussed in Section 2. Nipkow and Snelting [12] realized that type inference for type classes can \nbe formulated as an extension of ordinary ML-style type inference with order-sorted uni\u00adfication, i.e. \nsimply by changing the algebra of types and the corresponding unification algorithm. Although this was \nan interesting theoretical insight, it only lead to a simple algorithm for a restricted version of Haskell \nwhere each type variable is constrained by exactly one class. In addition it was not possible to identify \nambigu\u00adous typings like [a: C], A, E h e : int because there was no notion of contexts and type variables \nwere tagged with their sort. Both problems have been eliminated in the present paper. An interesting \nextension of Haskell using the notion of predicated types was designed and implemented by Mark Jones \n[7]. The main difference is that he allows arbitrary predicates P(rl, . . . . rn ) over types as opposed \nto our membership constraints a : S. Independently of our own work Chen, Hudak and Odersky [3] developed \nan extension of type classes us\u00ad ing similar techniques and arriving at a similar type reconstruction \nalgorithm. Since their type system is more general, they use different and more involved for\u00ad malisms, \nin particular for unification. In contrast, we reduce unification to its essence by splitting it into \nstan\u00ad dard unification plus constraint solving. This enables us to give a sufficient and necessary criterion \nfor uni\u00ad tary unification, which is required for principal types. As discussed in Section 5, the restrictions \nin Haskell easily archive unit ary unification. An example where unitary unification is more difficult \nis the integration of subclasses (see Sec. 6.1), where Dom(t, C) is defined differently. Kaes [9] presents \nan extension of Hindley/Milner polymorphism with overloading, subtypes and recursive types. Due to the \noverall complexity of the resulting system, the simplicity of the pure system for overload\u00ading is lost. \n8 Ambiguity We would like to conclude this paper with a discussion of the ambiguity problem which affects \nmost type systems with overloading. It is caused by the fact that although a program may have a unique \ntype, it s semantics is not well-defined. According to our rules, the program class C where f : Va:C.a \n* int; class D where c : Va:D.a; (f c)  has type int in any context containing an assumption a : {C, \nD}. Yet the program has no semantics because there are no instances of ~ and c at all. If there were \nmultiple inst antes of both C and D, it would be impos\u00adsible to determine which one to use in the expression \n(f c). Motivated by such examples, a typing I j A, E 1-e : u is usually defined to be ambiguous if there \nis a type vari\u00adable in r which does not occur free in u or E. However, the only formal proof of a relationship \nbetween such ambiguous types and ill-defined semantics that we are aware of is due to Blott [1]. Since \nwe have not provided a semantics for our language, we have not introduced am\u00adbiguity formally. Nevertheless \nthere is one place in our inference system where we anticipate a particular treat\u00adment of ambiguity. \nIn rule VI, the proviso a G FV(a) is intended to propagate ambiguity problems: with this restriction, \nthe expression let z = (f c) in 5 (preceded by classes C and D as declared above) has type int only in \na context containing an assumption a : {C, D}. If the proviso is dropped, the expression also has type \nint in the empty context, thus disguising the local ambiguity. The reason is that x can be given the \nambiguous type Va:{C, D} .int, but since x does not occur in 5, this does not matter. Although in a lazy \nlanguage x need not be evaluated and hence the semantics of the whole let is indeed unambiguous, we would \nargue that for pragmatic reasons it advisable to flag ambiguities whenever they arise. From this discussion \nit is obvious that a semantics and a coherence proof for the type system w.r. t. a semantics are urgently \nneeded. References [1] S. Blott. An approach to overloading with polymorp\u00adhism. PhD thesis, Dept. of \nComputing Science, Uni\u00adversit y of Glasgow, 1992. [2] R. BurstaU, D. MacQueen, and D. Sannella. Hope: \nan experimental applicative language. In Proc. 1980 LISP Conference, pages 136-143, 1980. [3] K. Chen, \nP. Hudak, and M. Odersky. Parametric type classes. In Proc. ACM Conf. Lisp and Functional Pro\u00adgramming, \n1992. To appear. [4] D. Clc$ment, J. Despeyroux, T. Despeyroux, and G. Kahn. A simple applicative language: \nMini-ML. In Proc. ACM Conf. Lisp and Functional Programming, pages 13 27, 1986. [5] L. Damas and R. \nMilner. Principal type schemes for functional programs. In Proc. 9th ACM Symp. Princi\u00adples of Programming \nLanguages, pages 207 212, 1982. [6] P. Hudak, S. P. Jones, and P. Wadler. Report on the programming language \nHaskell: A non-strict, purely functional language. ACM SIGPLAN Notices, 27(5), May 1992. Version 1.2. \n[7] M. P. Jones. A theory of qualified types. In B. Krieg-Bruckner, editor, Proc. European Symposium \non Pro\u00adgramming, pages 287 306. LNCS 582, 1992. [8] S. Kaes. Parametric overloading in polymorphic pro\u00adgramming \nlanguages. In Proc. .2nd European Sympo\u00adsium on Programming, pages 131 144. LNCS 300, 1988. [9] S. Kaes. \nType inference in the presence of overloading, subtyping and recursive types. In Proc. ACM Conf. Lisp \nand Functional Programming, 1992. To appear. [10] R. Milner. A theory of type polymorphism in program\u00adming. \nJ. Comp. Sys. Sci., 17:348 375, 1978. [11] R. Milner, M. Tofte, and R. Harper. The Definition of Standard \nML. MIT Press, 1990. [lz!] T. Nipkow and G. Snelting. Type classes and overload\u00ading resolution via order-sorted \nunification. In Proc. 5th ACM Conf. Functional Programming Languages and Computer Architecture, pages \n1-14. LNCS 523, 1991. [13] D. M. Volpano and G. S. Smith. On the complexity of ML typability with overloading. \nIn Proc. 5th ACM Conf. Functional Programming Languages and Com\u00adputer Architecture, pages 15-28. LNCS \n523, 1991. [14] P. Wadler and S. Blott. How to make ad-hoc polymor\u00adphism less ad hoc. In Proc. 16th A \nCM Symp. Principles of Programming Languages, pages 60 76, 1989.  \n\t\t\t", "proc_id": "158511", "abstract": "<p>We study the type inference problem for a system with type classes as in the functional programming language Haskell. Type classes are an extension of ML-style polymorphism with overloading. We generalize Milner's work on polymorphism by introducing a separate context constraining the type variables in a typing judgement. This lead to simple type inference systems and algorithms which closely resemble those for ML. In particular we present a new unification algorithm which is an extension of syntactic unification with constraint solving. The existence of principal types follows from an analysis of this unification algorithm.</p>", "authors": [{"name": "Tobias Nipkow", "author_profile_id": "81100147685", "affiliation": "", "person_id": "PP39029747", "email_address": "", "orcid_id": ""}, {"name": "Christian Prehofer", "author_profile_id": "81100553817", "affiliation": "", "person_id": "PP40028517", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158698", "year": "1993", "article_id": "158698", "conference": "POPL", "title": "Type checking type classes", "url": "http://dl.acm.org/citation.cfm?id=158698"}