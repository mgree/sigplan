{"article_publication_date": "03-01-1993", "fulltext": "\n Semantics for Communication Primitives in a Polymorphic Language Atsushi Ohori Oki Electric Industty \nKansai Laboratory Crystal Tower, 1-2-27 Shiromi Chuo-ku, Osaka 540, JAPAN email: ohori@kansai.oki. co.jp \n Abstract We propose a method to extend an ML-style polymorphic language with transpzwent communication \nprimitives, and give their precise operational semantics. These primitives allow any polymo~hic programs \ndefinable in ML to be used remotely in a manner completely transparent to the program\u00admer. Furthermore, \ncommunicating programs may be based on different architecture and use different data representa\u00adtions. \nWe define a polymorphic functional calculus with trans\u00adparent communication primitives, which we call \ndML, as an extension of Damas and Milner s proof system for ML. We then develop an algorithm to translate \ndML to a core language containing only low-level communication primi\u00adtives that are readily implementable \nin most of distributed environments. To establish the type safery of communicating programs, we define \nan operational semantics of the core lan\u00adguage and prove that the polymorphic type system of dML is sound \nwith respect to the operational semantics of the translated terms of the core language. 1 Introduction \nConstructing a distributed application is a difficult task. Writ\u00ading a communicating program requires \ncomplicated code to intemct with the system s low-level communication primi\u00adtives. Moreover, the data \nstructures available for communi\u00adcation are rather limited and usually do not match those re\u00adquired for \nthe application. As a result, the programmer must encode necessary data structures in primitive form. \nIlk situation is particularly unfortunate when the programmer Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. ACM-20th PoPL-1 /93-S. C., USA a 1993 ACM \n0-89791 -561 -5/93 /0001 /0099 ...S1 .50 Kazuhiko Kato University of Tokyo Department of Information \nScience 7-3-1 Hongo, Bunkyo-ku Tokyo 113, JAPAN ernail: kato@is.s.u-tokyo. ac.jp cannot make full use \nof statically checked polymo~hic type systems, most notably that of ML [MTH90]. If transpar\u00adent communication \nprimitives were uniformly integrated in a type system of a polymorphic programming language, then development \nof a distributed application would be signifi\u00adcantly simpler and more reliable. There are a number of \nmodels for distributed computation [BST89]. For example, one may share a primary memory and other may \nbe coupled with a special programming lan\u00adguage. Accordingly, there are various approaches to design\u00ading \na distributed programming language. Our focus here is to develop a method to extend a general-purpose \nprogramming language with transparent communication primitives so that it can be used in a wide range \nof distributed environments. In particular, we would like to use a distributed language in a heterogeneous \ndistributed environment, where processors with different architecture and different data representations \nare connected by a communication network. To achieve such generality, we minimize our assumption on underly\u00ading \noperating system support for distributed communication and assume that the data that can be physically \nexchanged between processors are restricted to atomic data. ~pically, they are data of base types such \nas integers or boolean values. Those data can be easily encoded in a standard format and be safely transmitted \nthrough communication networks. Our goal is then to develop high-level transparent communication primitives \nbased on this very restrictive assumption. One useful concept for designing such a language is re\u00admofe \nprocedure call [BN84], which allows the programmer to use procedures (or functions) defined in a different \npro\u00adgram session residing in a different site. The advantages of this mechanism have been widely recognized \nand several distributed programming systems have been implemented based on this mechanism (see [BST89] \nfor a survey.) Un\u00adfortunately, however, this mechanism has not yet been well integrated in type systems \nof programming languages, and the types of functions that can be called remotely are still very limited. \nDespite some works [JR86, LBG+87, HS87] to extend this technique, there seems to be no systematic method \nthat achieves transparent call of higher-order func\u00adtions. Cooper and Krumvieda [CK92] proposed distributed \nprimitives for Stamkd ML based on a form of remote proce\u00addure call mechanism developed for C. They suggested \ncertain degree of remote access of polymorphic programs by giving polymorphic ~pes to their primitives. \nHowever, they only gave an explanation of these primitives for the case of a base type, and dld not provide \nany account for the cases of higher-order types or polymorphic types. To the authors knowledge, there \nis no successful proposal that achieves transparent call of polymorphic functions in a heterogeneous \ndistributed environment. Furthermore, there seems to be no formal attempt to establish the type safety \nof a distributed language. The goals of this paper are: (1) to extend an ML style poly\u00admorphic language \nwith transparent communication primi\u00adtives, (2) to give their precise operational semantics, and (3) \nto prove that our extension preserves the soundness of the polymorphic type system of ML, which guarantees \nthe type safety of communicating programs. While we focus on one language, namely ML, our method does \nnot require communicating programs to be written in the same language. Since our method does not assume \nany data representation specific to ML, dhlerent languages, once extended by our method, can exchange \ndata to the extent that the types of the data are representable in each of the languages involved. The \nrationale of presenting our method through ML is that its type system provides various desirable features \nincluding higher-order functions and polymorphism, and can serve as a model of advanced type systems. \nMonomorphic portion of our method, for example, can be used to extend other statically typed monomorphic \nlanguages. We define a polymorphic language with transparent com\u00admunication primitives, which we call \ndML, as an extension of I)amas and Milner s [DM82] proof system for ML. In addition to ML term constructors, \nit contains a declaration constructo~ export e as z which makes the value e accessible from remote sites \nthrough the name x, and a term constructo~ import x: a in e end which binds x in e to a remote datum \nof type a (made avail\u00adable by an export declaration). This syntactically simple addhion of export and \nimport statements to ML has a significant practical implication that it allows the program\u00admer to use \nremote data of any polymorphic type a in exactly the same way as one use polymorphic programs by ML s \nlet binding, Developing a theoretically sound method to imple\u00adment these statements constitutes a major \ntechnical challenge which we claim has never been successfully met. For exam\u00adple, how do we export a \npolymorphic higher-order function to a remote site that has different architecture? Our main technical \ncontribution is to establish one such method by de\u00adveloping an algorithm to translate dML to a core language \nthat can be implemented by using a conventional mechanism of remote procedure call as described in [BN84]. \nTo ver\u00adify the correctness of our translation and establish the type safety of dML, we define an operational \nsemantics of the core language and prove that dML polymorphic type sys\u00adtem is sound with respect to the \noperational semantics of the translated term of the core IIanguage. In addition to transparent communication, \nthere are hvo important issues in distributed computation. They are con\u00adcurrency and recovery from failure. \nFor the first point, it is natural to couple communication with asynchronous computation to exploit concurrency \nin distributed program\u00adming. However, since the primary purpose of this paper is to give a systematic \nmethod for transparent use of poly\u00admorphic programs between different systems, we will not deal with \nthe issue of concurrency and restrict our consid\u00aderation to synchronous communication in a Shnph? ChW\u00adserver \nstyle model. We believe that a mechanism of con\u00adcurrency is mostly orthogonal to a mechanism of transparent \ncommunication, and that our method can be combined with an appropriate mechanism of concurrency control \nsuch as [Rep91, BMT92] to design a concurnmt distributed program\u00adming language. For the second issue, \nalthough we claim that the operational semantics of the core langnage presented in this paper can be \nimplemented in most distributed environ\u00adments, an actual implementation requires careful consider\u00adations \nof recovery from failure. Here we ignore this issue and assume that inter-process communication is atomic \nand always succeeds. We believe that existing approaches such as [CK92] can be used to implement our \ncore language. The rest of the paper is organized as follows. Section 2 gives the definition of dML. \nSection 3 explains our strategy. Section 4 defines the core language. Section 5 gives the trans\u00adlation \nalgorithm. Section 6 defines an operational semantics of the core language, and lproves the soundness \nof the type system of dML with respect to the operational semantics of the translated terms. Our method \ncan be extended to deal with abstract data types. Section 7 discuss this extension. Section 8 describes \nan application of our method to shared persistent programming. By combining our method with dy\u00adnamic \ntypes [ACPP9 1], it is possible to develop a persistent system that can be shared in a heterogeneous \nenvironment. Section 9 concludes the paper by discussing topics of further investigations. 2 Definition \nof the Language dlML As in [DM82], the set of types is divided into the set of monotypes (ranged over \nby T) and the set ofpoly~pes (ranged over by a) given by the following abstract syntax: T::=tlbl T+T \no ::= T [ Vt.a where t stands for type variables and b for base types. The set of raw terms is given \nby the syntax: e::= cbIz Ikt. eI (ee) I let x =eine end I import z :a in e end  Cbdenotes constants \nof base type b. A top-level statement of the language is either a closed term having a closed type, or \nan export declaration of the form export e as z: u which allows the program e to be used remotely by \nthe name z of type u. If the type specification : U is omit\u00adted, then the principal type of e is assumed. \nThe identifier x in import x: a in M end plays double roles. It is a variable bound in M to a remote \nprog~, it is also an external name used to establish the binding of x to a remote program ma&#38; available \nby the export declaration contain\u00ading the same name Z. For the simplicity, we assume that an external \nname is unique in the entire network. The type system of this calculus is given by specifying a set of \nrules to derive a typing of the form dbe:~ where d is a type assignment, which is a function from a \nfinite set of variables to polytypes. Given a function A, we write A{z * a} for the function A such that \ndornain(d ) = domain(A) U {z}, and for any y c domain(A ) if y = z then d (y) = ~, otherwise d (y) = \nd(y). The set of typ\u00ading rules is given in Figure 1. In (tapp), the notation a[~/t] denotes the type \nobtained from a by substituting each oc\u00adcurrence oft with ~ (with the necessary bound type variable renaming.) \nIn (export), an export statement is not a term but a declaration, whose effect is a modification of a \nnetwork wide name blndlng. Note that the rule (import) allows transparent use of re\u00admote datx in the \nbody e of import x: a in e end the identifier z can be used as an ordhwy expression of type a without \nany restriction. As a simple example, one site may define a function and make it available to remote \nsites by an export declaration, as in: export ~f .~x. (f (f x) ) as TWICE A program in a different site \ncan use this function, as in: import TWICE : Vt.(t+t)+t+t in let addone = Ax.x + 1 in ( (TWICE addone) \n3 ) end end  2.1 &#38;pe Inference and Explicitly ~ped Terms The type system of dML is essentially \nthe same as that of the Damas-Milner system, and Mllner s [Mi178] algorithm W can be used to infer a \nprincipal type of any typable raw term. The following property was shown in [DM82]. (const) A D Cb: b \n(var) A b z : a if z Edomain(d), d(z) = a ~bel:~l+~z dDe2:rl (app) A b (el ez) :rz Abe:u (tabs) if t \ndoes not appear in d Abe: Vt.a dDe:Vt.u (~PP) A B e : ~[7/t] A{z+a}be:r (impoti) A b import z: a in e \nend : r (export) export e as z: a k well typed if 0 P e : u isderivable Figure 1: dML Type System \nTheorem 1 (Damas-Milner) There is an algorithm W which, given A and e, returns either a pair (6, T) of \na sub\u00adstitution 6 and a monotype T, or failure such that (1) if it returns (L9,T) then O(d) b e : T is \nderivable andfor any d ando if A b e ; u then there is some substitution 0 such that d (z) = O (O(A(x))) \nfor all x G domain(d), and a is a generic instance of O (m ) where a is the closure of T with respect \nto the type assignment O(A), and (2) ~~W returns failure then there is no 19 andcr such that O (d) D \ne : u . 1 As shown by Mitchell and Harper [MH88], the algorithm can be extended to infer an explicitly \ntyped term corresponding to a typing derivation constructed during a type inference process. This extension \nis useful to define a translation algo\u00adrithm in Section 5. The explicitly typed dML contains the following \nset of explicitly typed t&#38;&#38; M ::= (Cb:b) I z Ikc:T. M I (M M) IM.M [(M T) Ilet x:a .M in M end \nI import z: a in M end  and export declarations of the form export M as z :a M. M is type abstraction \nand (M T) is type application. l%e typing rules for the explicitly typed dML are obtained form those \nof dML by replacing the term of the conclusion in the rules (abs), (tabs), (tapp), and (let) with the \ncorresponding explicitly typed term. For example, rule (tabs) becomes: dbAf:cr (tabs) if tnot appear \nin A d b~t.~ :Vt.a The type erasure er(&#38;f) of an explicitly typed term M is the raw term obtained \nfrom M defined by the following rules: er((cb:b)) = Cb er(it) = z er(k : T.lf) = kc.er(kf) er( (MI M2)) \n= (er(kfl) er(kfz)) er(M.kf) = er(lf) er((M 7)) = er(kf) er(let x:a . Ml in M2 end) = let z = er(M1) \nin er(M2) end er(import x:a in M end) = import x: a in er(M) end er(export M as z:a) = export er(M) as \nz: a Theorem 2 (Mitchell-Harper) For any raw term e, ifd b e : w then there is an explicitly typed term \nM such that er(M) = e and A D M : u is derivable in the explicit calculus. Furthermore, M can be constructed \nefficiently from aderivation of A D e : U. ~ Combining these two theorems, we can extend Milner s al\u00adgorithm \nW so that it infers from a given raw term its principal typing and the corresponding explicitly typed \nterm. Later we make use of this to construct a translation algorithm from dML to the core language. \n 3 Strategy for Defining a Semantics of dML We aim to develop an algorithm to translate dML to the core \nlanguage. One role of the core language is to define a precise operational semantics of dML. The second \nis to provide an effective algorithm to implement dML for a wide range of distributed environments. To \nachieve the second goal, we need to make assumptions about communication mechanisms available in most \ndistributed environments. We require data that can be transmitted between sites to have a communication \ntype, which is either a base type in canonical representation (denoted by ~~ or an identifier type (denoted \nby id(a)). A value of type b is a value of type b encoded in common data format supported by the underlying \ncommunication protocol. A value of id(a) is an identifier of a value of type a. Identifiers can be any \nfixed length data and they are treated as atomic data during communication. They will never be interpreted \nin a remote system. An identifier sent from a remote system is used only as an argument to the primitive \nof remote function application described below. For communication, we assume that the underlying system \nprovides the following mechanisms: 1. a network-wide name server to bind a name to a remote datum of \na communication type, and 2. a mechanism to apply a remote function (passed as an identifier from a \nremote site) to a value of a communi\u00adcation type, and to receive the result which must also have a communication \ntype.  Whh the restriction on types of data, these primitives are implementable in most distributed \nsystems. In particular, the mechanism of applying remote functions can be implemented by the standard \nremote procedure call mechanism [BN84]. Under these assumptions, we develop an algorithm to translate \nexport and import statements into terms of the core language. The idea is to define for each type a, \nthe communication type C(a) representing a, and then define an encoder and decoder pair for each type \na that encodes values of type a into values of type C(cr) and decodes val\u00adues of type remote(C(a)) back \nto values of type cr. Type remote(C(a)) denotes values of type C(a) created in and passed from a (possibly) \ndifferent site. For a base type b, we assume that primitive functions encoderb and decoderb to convert \ndata formats are sup\u00adplied by the system. For a function ~ of type 71 + 72, the encoding is done at the \nexporting site by creating an identifier of a new function F of type remote(C(~l)) ~ C(r2) from ~. Function \nF first decodes its argument of type remote(C(~l)) to get a value of type ~1, then applies the given \nfunction f to it, finally encodes the result of the application in type C(7-2). At the importing site, \nthe corresponding decoding is done by creating a new function G of type T1 + T2 from the identifier of \nF passed from the exporting site. The function G first encodes the given argument of type 71 into type \nC(71 ), then invokes the remote function call mechanism to apply F to the encoded argument and receives \nthe result of type C(T2), and finally decodes the result to get a value of type TZ. Creating this new \nfunction G achieves the semantics of importing the original function f without physically transmitting \n~. We extend this encoding/decoding to arbitrarily higher mono\u00adtypes by inductively applying the above \ndescribed process. This extension is a special case of a general technique of lifting properties on base \ntypes to higher types. For example, Leroy s M192] algorithm for eliminating redundant pointer creation \nin a functional calculus has a similar structure. The process of generating encoder and decoder for higher-order \nfunctions can also be regarded as a systematic refinement of an ad-hoc method of stub generation for \nremote procedure call described in [BN84]. Since types are inferred statically, it is possible for the \ntranslator to create these encoders and decoders at compile-time. Dealing with polymorphic functions \nrequires mecha\u00adnisms for remote type application and for creating an en\u00ad 102 codeddecoder pair at the \ntime of type instantiation. To rep\u00adresent remote type application, we define the core language to have \nexplicit type abstraction and type application. A polymo~hic function is represented as a function that \ntakes a monotype and mtums a function. Remote type application can be done by a mechanism similar to \nremote function appli\u00adcation by allowing gmtmd monotypes to be passed through a communication network. \nPassing only ground types is suffi\u00adcient since, under our assumption that atop level statement is a term \nhaving a closed type, type variables in a polymorphic type are filly instantiated with ground monotypes \nin a local site befoxe it is executed. Since ground monotypes can be easily represented by a basic data \nstructtue, this extension does not require any special mechanism of the underlying system. To create \nan appropriate encoder and decoder at the time of type instantiation, we introduce two polymorphic combinators: \npoly-encoder : Vt.t + c(t) poly-decoder : Vt.renzote(c(t)) -t t where c(...) is a communication type \nconstmctor. The type system of the core language is defined in such a way that the appropriate equality \nholds for c to ensure that c(r) = C(r) for any monotype I-. At evaluation, terms (poly-encoder 6) and \n(poly-decoder 6) are re\u00adduced to the encoder and decoder for ground monotype 6 respectively, whose structures \nare described above. We define the core language so that for any type a, the corresponding encoder and \ndecoder are already kmtbda\u00addefinable. We then develop an algorithm to translate dML to the core language. \nThe algorithm must insert appropri\u00adate lambda terms representing necesstuy encoders/decoders of appropriate \ntypes. It also inserts type abstraction and type application for polymo~hic expressions to be exported \nand imported properly. This process requires precise type information of expressions involving communication. \nThe necessary type information is obtained by dML s polymor\u00adphic type inference system. Thus the translation \nalgorithm functions as follows: 1. to construct an explicitly typed term by an extended type inference \nalgorithm, and 2. from the explicitly typed term, to generate the translated term in the core language. \n  Finally, we prove that the polymorphic typing is sound with respect to the semantics resulting tlom \nthis translation. 4 The Core Language The types of the core language are given by the following abstract \nsyntax: P::=tIbI; Ip+ pjid(p) Ic(p) Iremote(p) r ::= p I Vt.n I id(m) I remote(m) The previous section \nexplained ~, id(n) c(p), and remote(n). We restrict type variables of the com language to range only \nover the set of monotypes of dML. For the type constructor c, the following equality holds: c(b) =t \nC(71 + 7-2) = id(remote(c(~l)) + c(~z)) In what follows, we consider types as equivalence classes of \nthis equality. A canonical representation of an equivalence class is a type satisfying the property that \nif it contains c(7) then ~ is a type variable. Among the types, we identi~ the following subsets as communication \ntypes: ( ::= c(t) I T I id(~ + f) I remote(<) P ::= &#38; I ki(Vt.fJ) ] Ternote(p) Since type variables \nrange only over monotypes of dML, for any communication type p and for any dML monotype r, p[r/t] is \nalso a communication type. The core language contains the set of raw terms: M ::= (c:K) I x I k:p.M \nI (M M) I X.M I (M T) I let X:T = e in M end I makeid(M) I [M M] I [M T] I import z: remote(p) in M end \n and the declarations of the form export M as x :p (c : n) stands for typed constants, [Al M] for remote \nfunction application, [M T] for remote type application, and make id ( M ) for identifier creation. The \nconstants of the language include the following: (cb:b) atomic constants, (7:F) atomic constants in canonical \nform, (encoder~: b ~ ~) encoders for atomic values, (decoderb : remote(k) + b) decoders for atomic values, \n(poly-encoder :Vt.t + c(t) ) the polymorphic encoder, and (poly-decoder :V t.remote(c(t)) + t) the polymorphic \ndecoder. Figure 2 shows the set of typing rules of the core language. The first seven rules (rules from \n(const) through (let)) are the same as those of the explicitly typed dML. Rules (Rapp), (Rtapp), (import) \nand (export) are those for inter-process communications. Rule (Rapp) states that remote function application \n[ &#38;fl M2 ] is well typed if Ml is an identifier of (Colflst) (Var) (a,bs) (app) (tabs) (ta]pp) (let) \n(makeid) (Rapp) (Rtapp) (import) (typeeq) (export) Figure AD(c:T):T A{ XI+ PI} DM:P2 AD AX. M:pl~pz AD \nMI:pI=+p2 dDMz:pl A D (Ml 3!fz) : PZ #t Ditf:r if t not appear in d A b~t.~ : Vt.a_ AbM:Vt.~ A b (M \nr) : z[T/t] AbMl:m A{z*n]b M2:p dbletx:~=MI in Mzend:p AbM:r A b makeid(M) : id(m) A b MI : rernote(id(rernote(cl) \n+ C2)) AbM2:&#38; A b [MI M21 : remote(g2) A b M : rernote(&#38;l(W.p)) A D [M T] : remote(p[~/t]) \nd{x w remote(p)} P M : p A D import x: remote(~) in M end : p AbM:p ~, M:;= export M as x: p is well \ntyped if@ b M : p is derivable for some closed p. 2: The Type System of the Core Language a function \nin a foreign she whose type is remote((l) + ~2, and the second argument M2 has the type &#38;. The result \nhas type. rernote(<2) and not (2 itself, since it is a value of type (2 sent by a foreign site. Rule \n(Rtapp) is for remote type application. In (export), an export statement is not a term but a declaration \nwhose effect is to modfy a network wide name binding. In these rules, note the restriction that some \ntypes must be communication types indicated by the usage of p and ~ instead of r and p. By this restriction, \nthe type system statically enforces the restriction that only data of communication types are being exchanged \nbetween processes. Also note that type variables in the core language ranges over monotypes of dML, which \nis indicated by the usage of ~ in rules (tapp) and (Rtapp).  5 The Translation We first develop an algorithm \nto translate explicidy typed terms of dML (as defined in Section 2.1) to the core language and then extend \nthe algorithm for the implicit calculus of dML. For any polytype a of dML, the communication type C(cJ) \nrepresenting a in the core language is defined as follows: c(b) =J c(t) = c(t) C(TI + 7-2) = id(rernote(C(Tl)) \n+ C(72)) C(vt.ff) = id(vt.c(c)) It is easy seen that for any a, C(a) is a communication type. The heart \nof the translation is the definitions of an encoder and decoder for each type a in dML, Given a term \nM of type 0 in the core language, we write @(a, M) for its encoded term in the core language. Given a \nterm M of type rernote(C(a)) in the core language, we write Y(a, M) for the decoded term in the core \nlanguage. Figure 3 gives the definitions for @(a, M) and + (a, M). It is easily seen that for any given \nterm M in the core language, cD(a, M) and Y (u, M) are both terms in the core language. Furthermom, they \nhave expected types: Proposition 1 VA D M : u is derivable in the core lan\u00adguage then so is A D @(~, \nAI) : C(a). If A D M : remote (C(,a)) is derivable in the core lan\u00adguage then sois A D W(a, M) : m. Proof \noutline This is proved by showing the two statements simultaneously by induction on the structure of \na. Here we only show the cases for rl -+ rz. For the first half of the simultaneous induction, as- SUmedb \nM: rl+r2. Since C(TI + T2) = id(remote(C(q)) + C(72)) and x is fresh, we have only to show A{x I+ remote \n(C(~l))} b cD(72, (M Y(?i, x) ) ) : C(7_2). By induction hypothesis, A{x * rernote(C(rl))} b V(TI, X) \n: T~. By the assumption on M, we have A{x w @(b, M) = (encodeb M) @(rl + T2, M) = makeid(Ax: ~emote(C(rl)). \n(@(T2, (M ?(q,x)) )) ) (x fresh) @(t, e) = ( (poly-encoder t) M) @(Vt.a, M) = make id ( At.@(a, (M t))) \n(t not appear elsewhere) Y(b, e) = (decoderb M) Y(~l + 72, M) = ~x:~l . (Y(r2, [M Y(t, e) = ( (poly-decoder \nY(Vt.a, M) = M. Y(u, [M t]) Figure 3: Definitions remote(C(q))} b (M P(T1, x) ) : T2. Then again by \ninduction hypothesis, we have A{x i+ rernote(C(q))} D @(T2, (M Y(T1, x) ) ) : C(T2), as desired. For \nthe other half of the simultaneous induction, assume A D M : remoi!e(C(Tl + T2)). Since x is fresh, by \ninduc\u00adtion hypothesis we have A{x H T1 } P CD(T1, x) : C(I-I ). Since C(TI + 7-2) = id(remote(C(Tl)) \n+ C(TZ)), by the as\u00adsumption on M and the rule (Rtapp) we have A{x I+ TI } D [M ~(~~,x)] : rernote(C(T2)). \nThen again by induction hypothesis, we have A{x w TI } D ?(T2, [M O(TI, x) ] ) : T2. The desired result \nfollows from rule (abs). I Note that an explicitly typed term of dML is also a term in the core language. \nThen, using these encoders and de\u00adcoders, we can define a translation algorithm that translates an explicitly \ntyped term of dML to a terms of the core kul\u00adguage. The translation algorithm is given in Figure 4. For \nthis translation, the following property hold. Theorem 3 ~d D M : u is derivable in the explicitly typed \nversion of dML then A D 773(M) : u is derivable in the core language. Proof outline This is proved by \ninduction on the structure of M using Proposition 1. I Since dML has a type inference algorithm that \ncan also in\u00adfer an explicitly typed term as shown in Theorems 1 and 2, a complete translation algorithm \nof dML to the core language is obtained by fhxt applying an extended type inference al\u00adgorithm to obtain \nan explicitly typed term and then applying the translation algorithm to get a term of the coxe language. \nSuch algorithm can be easily defined as an extension of the algorithm W. Figure 5 shows examples of the \ntranslation. 0(~1, x)])) (x fresh) t) M) (t not appear elsewhere) of Encoders and Decoders 6 Operational \nSemantics and Sound\u00adness of ~pe System This section defines an operational semantics of dML and establishes \nthat the dML polymorphic type system is sound with nxpect to the semantics. Since we have an algorithm \nto translate dML to the core language, we only need to give an operational semantics of the core language. \nThe semantics of a dML term is defined to be the operational semantics of the translated term of the \ncore language. 6.1 Operational Semantics of the Core Lan\u00adguage The semantics is given in the style of \n~of88] by defining a set of rules to reduce terms to canonical values (ranged over by v). To give a precise \naccount for communication primitives, we need to deal explicitly with the notion of multiple sites. Weuseff, \n~,... for variables ranging over site identifiers. The set of canonical values is given by the following \nsyntax: v ::= c I closure (E,l , z,M) I Tclosure(E, T,t, M) I id(a, v) I wrong where c stands for the \nconstants of the language; closure (13, T, z, M ) is a function closure where E is a variable environment \nmapping a finite set of variables to canonical values and T is a type environment mapping a finite set \nof type variables to ground monotypes of dML; Tc lo sure (E, T, t, M ) is a closure corresponding to \ntype abstraction; id(a, v) is an identifier of v created in the site a; and wrong represents runtime \ntype error. We also need to assume a network wide mapping of names to values as a model of a name server. \nFor this, we use a global variable S maintaining a mapping of the form {x -v,...} where x is an identifier \nspecified in an export statement and accessed in import statements. We use 6 as a variable ranging over \nthe following set of ground monotypes: 77?(Z) = x 77?(XZ :T. M) = kc: T . 77?(M) T7?((M1 M2)) = (7~(MI) \n77?(M2) ) 77?(M . M) = M. 77?(M) 77?((M ~)) = (77?(M) r) H3(let z :a = All in M2 end) = let z: a = 77?(M1) \nin 7R!(M2) end 7X!(import z: renote(a) in M end) = import z: rernote(C(a)) in let z: a . Y(a, z) in 77?(M) \nend end 77?(export M as z: a) = export @(a, 77?(M)) as z :C(a) Figure 4: Translation Algorithm from dML \nto the Core Language ~%?(export Ax. (x + 1) as ADDONE) = export make id ( Ja: re?note (~). ( encoderin~ \n( (~x:hd. (x + 1) ) (decoderin~ a) ) ) ) as ADDONE : id(~e7note(Z$ + GZ) 7~(import ADDONE: int a int \nin (ADDONE 3 ) end) = import ADDONE: remo~e(id(remote(~ + =)) i.n let addone: int+ id = ~a: ~nt. ( decoderint \n[ADDONE ( encoderint a) ] ) in ( addone 3 ) end end ?%(export Ax. x as ID) = export makeid (At .makeid \n(Aa: remote(c(t)). ( (poly-encoder t ) (((~t . ~x:t .x) t) ((poly-decoder t) a))) as ID: ~d(vt.id(remote(c(t)) \n+ c(t))) 7R(import ID :Vt.t -t in (ID 3 ) end) = import ID : re7note(id(Vt.id( remo~e(c(t)) 4 c(t)))) \nin let id = At .Aa: t. ( (poly-decoder t) [ [ID t] ( (poly-encoder t) a) 1 ) in ((id int) 3) end end \nFigure 5: Examples of Translation a+closure (E, Z , x,itf) :ql +~ if foranyv such that a+v:ql, ifal-l?{z~ \nv}, Z , M* v thena+v :~.  a + v : remote(~) if T is a communication type and ~ &#38; v : ~ for some \n~.  a # Tclos.ure(~, ~,t, kf) :Vt. y[t] if forany6 if a 1-E,T{t I+ 6}, M ~ v then a! + v : ~[6]. \n Figure 7: Types of Canonical Values b::==blfi+$ The operational semantics is then defined by specifying \nthe set of rules of the following form for each term constructo~ akE, T,M~ V which intuitively means \nthat in site a, M is reduced to v un\u00adder the value environment E, and the type environment T. The set \nof reduction rules are shown in Figure 6. If none of the rule applies then the reduction terminates with \nwrong. The rules from (13) through (16) involve inter-process commu\u00adnication. Rules (13) and (14) involve \nreductions in different site, which is indicated by site id B different from CYin the conclusion. Rule \n(15) accesses the network wide binding S and rule (16) modifies this binding. To emphasize that these \nrules involve communication, we use double lines to separate premises and the conclusion in these rules. \n 6.2 Soundness of theme System Since we have shown that the translation preserves typing (Theorem 3), \nthe soundness of dML is established by show\u00ading the soundness of the polymorphic type system of the core \nlanguage with respect to the operational semantics defined above. To do this, we first define types of \ncanonical values. Canonical values always have a closed type. We let q and y range over closed monotypes \nand closed polytypes of the core language respectively. We also use the notation -f[ ] for aground type \nwith hole s in it and ~[~] for a type obtained by replacing each hole in -Y[ ] with r. We write a + v \n: y if v has the type ~ in site a. The set of rules to determine types of canonical values is given in \nFigure 7. In the rule for Tclosure, note that t in Vt.a range only over monotypes of dML. For two programs \nto communicate properly, they must be properly linked and initialized . In our model, this requirement \ncorresponds to requiring the property: for each import z: remote(p) in M, there must be the corresponding \nexport declaration export M as x :p with the same type p, and this export declaration must be evaluated \nbefore corresponding import statements are evaluated. We assume this property. We say that an environment \nE respects a type assignment A in site a under a type environment T, written E, T l=a A, if domain(E) \n2 domain(d) and for any z E domain(d), T(d(z)) is a ground type and a 1= E(z) : T(d(z)). Theorem 4 If \nd b M : ~ is derivable in the core language then for any type environment T and for any environment E \nsuch that E,T +a A, (fCY t-E,T, M + v then a~v: T(r) Proof outline To deal with the cases involving import \nwhich depends on the corresponding export declara\u00adtion, and poly-encoder, poly-decoder combinators which \ndynamically generate a term and reduces it, the proof proceeds by a double induction. The outer induc\u00adtion \nis on the import degree defined as follows. For term import z: n in M, its import degree is one plus \nthe sum of the import degrees of M and M where M is the term in the corresponding export declaration. \nFor a term other than import . . .. its import degree is the sum of the import degrees of its subterms. \nUnder our assumption that programs are properly linked stated above, thk measure is well defined. The \ninner induction is on the complex\u00adity measure of the lexicographical pairing of the number of poly-encoders \nand poly-decoders, and the size of the term, The proof proceeds by cases with respect to the structure \nof terms, using the inductive argument. Here we only show some cases involving communications. The case \nfor [MI M21: assume that A b [Ml M21 : remote. By the typing rules, we must have: A b Ml : rernote(id(rernote(~z) \n-+ (I)) and A D M2 : C2, for some communication type &#38;. By induction hypothesis, if a t-E, T, Ml \n* VI then a + VI : remote(id(remote( T(f2)) + T(<l))), and if a i\u00adE,T,M2 ~ V2 then a ~ vz : T(tz). By \nthe definition of the communication types and the typing of canonical values, the only values having \na type of the form remote(id(~ernote(T(~2)) + T(&#38;))) are values of the form id(8, closure (E , T \n, z, M )). TIIUS w havevl = id(P, closure (E , T , z, M )), and/3 ~ closure (E , T , x, M ) : rernote(T(~2)) \n+ T (&#38;). Since a + V2 : T(&#38;), O + vz : rernote(T(&#38;)). Then by the definition of the typing \nof closure (. ), if ~ F E {z I+ v2}, T , M = V3 then p 1= us : T(gl), and therefore a # us : rernote(T(<l)). \nSince vz and us have a communication type, they are either T or a value of the form id(. . . ). Then \nthe desired property follows from reduction rule (13). The case for import z: remote(p) in Ml: assume \nthat A b import z: remote(p) in MI : p. By our (1) a 1-1?,T, z ~ E(z) if z E domain(E), E(z) = v (2) \nal-E,T, c~ C (3) al-E, T, Ax:p. M+ closure (E, T,z, M) crk E, T,M~v  (4)  a 1-E, T,makeid (M) + id(a, \nv) Q 1-E, T, Ml + encoderb al-E, T,M2* Cb  (5)  abE, T, (M1 M2) ~ Cb a i- E, T, Ml * decoderb cYi-E, \nT,M2* F (6) cYt-E, T, (Ml M2) ~ Cb al-E, T,M1 + closure (E , T , x,M~) aFE, T, M2=+ v a 1-E {x w v}, \nT , M{ =$. V (7) al- E,T, (Ml M2) =+ V  (8) al-E, T, M. M=+ rclosure(E, T,t, M) a 1-E,T, M ~ poly-encoder \na t-E, T, Ax: T(T). c.D(T(r), x) s v (x fresh)  (9)  al-E, T,(Mr)~v @ t-E, T, M q poly-decoder a 1-E, \nT, Ax: remote(C(T(7))). Y(T(~), x) + v (x fresh) (lo) al-J?3,T,(iWT)av CYI-E,T, M+ l?closure (E , T , \nt, M ) a 1-E , T {t w T(r)}, M s V (11) al- E, T,(M T)=+V CYt-E, T,M1~ v al-E{x*v}, T,M2~ v (12) al- \nE,T,let x:x . Ml in M2 end+ v al-E, T, MI=+ id(/?, closure (E , T , x, M )) ct 1-E7T7M2+ VI ifvl, v2areeither \nof the form id(... ) or~ al-E,T, [Ml M2] ~ V2 al-E, T,M~ id(j?, rclosure (E , T , t, M ) ) (13) ~+E {x \nw Vi}, T , Jf ~ v2  (14) P + E , T {t * T(~)}, M ,~ V ifvkeither of the forrnid(... ) or~ crl-E, Z , \n[M T]av al-E{z I+ S(Z)}, T,M ~ V  (15)  a 1-E,T, import x: remote(p) in M end ~ v QkE, T, M&#38;v \n (16)  export M as z: p is evaluated successfully at a under E, T with the effect of S := S{x ++ v} \nFigure 6: Operational Semantics of the Core Language (1) 108 assumption that terms are properly linked \nstated ea\u00adlier, we must have a &#38;claration export Mz as x: p. By the typing rules, O D M2 : p. By \nour assumption that programs are properly initialized , export iW2 as z: p must be evaluated at some \nsite/3, be\u00adfore import z: remote(p) in Ml is evaluated. By our definition, the complexity of the term \nMz is strictly smaller than that of import z: remote(fl) in Ml. Then since E, T &#38;p 0, by the reduction \nrule (16) and the induction hypothesis, the network wi&#38; value mapping S satisfies the property that \n@ + $(z) : Z (p). Since T(p) is a communi\u00adcation type, a ~ S(Z) : remote(T(p)). By the typing rules, \nA{z ++ remote(p)} D Ml : p. Then the desired property follows by the induction hypothesis and the reduction \nrule (15). I Since wrong has no type, we have the following desired result. Corollary 1 A typechecked \nprogram in the core language does not create a run time type erro~ 1 By combining this with Theorem 3, \nwe have the following desired property: Corollary 2 (Soundness of dML ~pe System) Suppose d b e : u is \nderivable in dML. tit Me be the term of the core language obtained ftorn e by the translation algo\u00adrithm. \nThen for any T, for any E such thut E, T ~ff A, if al-E, T,iWe~ vthencr+v: T(a). In particula~ ife is \nclosed, then we have 0 b e : -y, and ~al-O, O,Me* vthenck+v:~. 1  7 Abstract Data ~pes and Treatment \nof References Herlihy and Liskov [HL82] considered the problem of us\u00ading abstract data types remotely \nand proposed a solution. In their method, the programmer is required to define, for each abstract data \ntype definition, a canonical representation to\u00adgether with the way data should be transmitted. Our method \nprovides an alternative way to handle abstract data types (as well as other data structures) by exporting \nfunctions to manipulate them. The only assumption we need is that an abstract data type is implemented \nby a set of functions. This notion of abstract types, although somewhat different from abstract types \nas existential types as developed in [MP88], is adopted by many of the currently implemented systems \nincludhg Standard ML. To extend the translation, we have only to extend our definition of C(7) to abstract \ndata types as follows: C(T) = &#38;.f(T) if 7 is an abstract type !hCe WhX of type id(T) k always an \nidentifier, the trans\u00ad lated abstract values can be safely sent to the remote system. This situation \nis the same as the case for higher-order func\u00adtions. So far we have only considered data types that have \npmely functional semantics. Non-functional types such as refer\u00adence types as implemented in Standard \nML [MTH90] rue also very useful for some applications, and we would liie to extend our method to allow \nremote manipulation of ref\u00aderences. Such extension should be particularly useful for distributed programming \ninvolving large data such as dictio\u00adnaries, only part of which me accessed and modlied. Since a reference \ntype can be regarded as another abstract data type specified by the operations to create, de-reference \nand modify a reference, it is possible to extend the core language and our translation with references \nbased on the strategy for handling abstract data types explained above. However, it is well known that \nthe operational semantics of references is not compatible with ML-style polymorphic type system and the \ntype system of dMLcannot be directly extended to ref\u00aderences. Solutions have been proposed in rof88, \nMac88]. They differ in details but they are both based on the idea that the type system restricts substitution \non type variables in reference types in such a way that references created by a polymorphic functions \nhave a monomorphic type. A special case of their solutions is to restrict the reference type con\u00adstructor \nto take only a ground monotype. For this restricted case, it is fairly obvious that our method can be \nextended with references. We conjecture that our translation and the soundness result can also be extended \nto both of type systems proposed in [Tof88, Mac88]. We leave a full treatment of reference types to future \ninvestigation. 8 Application to Shared Persistent Store One important application of our method is to \ndevelop a per\u00adsistent store that can be shared by many users in a heteroge\u00adneous environment. During \nthe research and experimentation of persistent programming languages, most notably PS-rdgol [ABC+83], \nthe technique to access external persistent data has been established. However, the techniques so far \npro\u00adposed are limited to a single language system, persistent data must be created and accessed by a \nsingle presupposed pro\u00adgramming system. As we argued in [K092], for persistent programming to become \na viable approach to represent a shared external database system, we must break this restric\u00adtion and \nto generalize this mechanism to a heterogeneous environment. Since our method of transparent communica\u00adtion \nallows different programming systems to exchange data, it can be used to develop such a shared persistent \nsystem. As observed by Abadi et.al. [ACPP91], external &#38;ta can be introduced in a static type system \nby the mechanism of dynamic types. A type system with dynamic types contains a special constant type \ncalled Dynamic. A runtime object of type Dynamic can be understood as a pair consisting of a value and \nits type (or more precisely a type description.) A possible operations on values of type Dynamic is to \ninspect its type component and to bind a variable of that type to its value component. Since values of \ntype Dynamic contains their types, they can be safely exported to an external store and later be retrieved \nand used in a static type system. The recent studies [LM91, ACPR92] showed that the mechanism of dynamic \ntypes can be extended to polymorphic languages. When we combine this mechanism with our mechanism of \ntransparent communication, then we can achieve a persistent system that can be shared in a heterogeneous \nenvironment. In an explicitly typed version of dML, type Dynamic can be introduced by the typing rule: \nA b M : u (aclosed) (dyntic) A b dynmic ( M: u ) : Dyrwnk As an elimination operation, instead of introducing \nthe flexi\u00adble typecase statement, here we only consider the follow\u00ading simpler coercion statement A b \nM : Dynamic (COf31W) A b ~o~~ce (a, M)I : ~ which raises runtime exception when the type component of \nM is not o. Introduction of typec ase does not have additional difficulty. To make values of type Dynamic \nshareable by different language systems, in the core language we restrict types of expressions that can \nbe injected to type Dynamic to have a communication type. The terms dynamic (M: a ) and coerce (u, M \n) are translated to the core language with this restricted Dynamic by the following rules: 77?(dynamic \n(M :@) ) = dynamic (@(u, M) :C(a) ) 77?(coerce (a, M) ) = T(o, coerce (remote(C(a)), M) ) Type constructor \nremote in this context denotes the fact that the value may be c~ated by a different language system. \nBy this translation, a value is encoded and injected to type Dynamic, and later in a different language \nsystem it is projected to a static type and then decoded and used. By combining a polymorphic type system \nfor database programming such as the one developed in [B092], we hope that this extension will provide \na basis for representing shared database systems in a polymorphic language.  9 Conclusions and Further \nInvestiga\u00adtions We have presented a method to extend an ML-style polymor\u00adphic language with transparent \ncommunication primitives. These primitives allow programs of any ML types to be used remotely. Moreover, \nthe necessary inter-process communic\u00adation is completely transparent to the programmer. We have achieved \nthis by developing a translation method for such a language to a more primitive core language containing \nonly low-level inter-process communication mechanisms. We es\u00adtablish the type safery of our method by \ndefining a precise operational semantics and proving that ML style polymorphic type system is sound with \nrespect to the semantics. Since the core language we defined is readily implementable using a standard \ntechnique of remote procedure calls, the presented method can be incorporated in an existing statically \ntyped language. In particular, we believe it not hard to implement a distributed extension of Standard \nML by incorporating our translation algorithm in the front-end of the compiler and using some of available \nRPC toolkits in the runtime system. Such a system enables us to write a complex distributed ap\u00adplication \nin a comfortably abstract manner. Real client-server applications require complex communication sequences, \ntyp\u00adically nested callbacks in the event-driven structure, and ML s feature of polymorphic higher-order \nfunctions should be par\u00adticularly advantageous for writing such applications. Fur\u00adthermore, the ability \nto communicate with other language systems will open up the possibility of extending a language without \nmodifying its compiler. For example, a language can call existing libraries written in diverse languages \nas far as they have suitable interface. There are a number of ways to extend the idea presented in this \npaper. We conclude the paper by listing some of topics for further investigations. b Extensions of the \nTranslation Scheme One natural extension of our method is to extended it for communication with a language \nbased on a different computational paradigm such as logic programming or object-oriented programming. \nA recent work by Llnd\u00adstrom er,al. [LM092] showed that by using type infor\u00admation it is possible to use \na fictional language from a logic programming. Their mechanism is mostly dy\u00adnamic but has some similarity \nwith ours in that a foreign function is passed as a form of an identifier and is called accordhg to its \ntype information (obtained by dynamic inspection). An interesting investigation related to their work \nis to ask how far can we combine their work with our static analysis and compilation? Another interesting \ninvestigation is to consider polymorphic languages with subtyping [CW85] and other object-oriented features. \no More Efficient Translation The term generated by our translation algorithm con\u00adtains all the type abstraction \nand type application in\u00adserted by the type inference process. For implementa\u00adtion purpose, however, most \nof them are unnecessary. We can refine our translation algorithm to suppress un\u00adnecessary ones. The only \nnecessary type abstractions and type applications me those that originate from a in import z:a . . . \nand export e as x: a. To gen\u00aderate only those necessary type abstractions and type applications, we mark \n, in the explicitly typed terms of dML, the type variables, type abstraction and type applications that \nare related to types in export and import statements. The type inference algorithm can be refined so \nthat it constructs explicitly typed terms with those markings. The necessary technique is sim\u00adilar to \nthat is needed to deal with eqtypes in Standard ML and are also regarded as a simple case of kbuied \ntype abstraction presented in [Oho92]. The translation algorithm can then be changed so that it only \nproduces type abstractions and type applications for those marked ones. More on Correctness of the hanslation \nWe have proved the soundness of dML type system with respect to the operational semantics. This provides \na strong evidence that our translation correctly achieves the desired semantics of transparent communication. \nU is desirable if we can also establish that the behavior of communicating programs is essentially the \nsame as that of the corresponding single program. Intuitively, we would expect that some relationship \nshould hold between the semantics of communicating programs of the form export MI as z import z: a in \nJ4 and that of the corresponding single program: let X:U =MI in M end Since our translation algorithm \nmay insert extra lambda abstraction which may make a non-terminating pro\u00adgram terminating, we cannot \nhope that the behav\u00adior of the two be exactly same. One approach to establish a desimble Mationship between \nthe se\u00admantics of these corresponding programs might be to define a relation on the set of canonical \nval\u00adues, and to show that if evaluation of the tmns\u00adlated term of let z: a . All in M2 end yields a value \nv, then the evaluation of the translated term of import z: a in M2 (which also involves the eval\u00aduation \nof the translated term of export All as x) yiekis a value v that is related to v. Optimization A straightforward \nimplementation of our scheme causes inter-process communication for every access to remote data. This \nis particularly problematic when dealing with structured &#38;ta represented by abstract data types. \nWe believe that a heuristic method can be developed to reduce communication cost. One possible approach \nwould he to replicate and cache remote data. The first time a remote structu~d datum is accessed, the \nsystem sends a copy of the datum to the importing site. At the importing site, the system maintains the \nassociation of an identifier of a remote datum and the local copy of the datum. The subsequent access \nto any parts of the datum can then be handled locally. Since data accesses in general have locality, \nin many cases this may sub\u00adstantially improve the runtime performance. However, copying a remote datum \nmay be problematic in such cases where the datum is very large and only small parts of it are accessed, \nor it contains mutable references. We regard it an important future nxsearch to develop a sound and systematic \nmethod to optimize accesses of remote structured data. With timther efforts of efficient implementation, \nwe hope that the method presented here will provide a basis to develop a heterogeneous distributed programming \nsystem.  References [ABC+ 83] M.P. Atkinson, P.J. Bailey, K.J. Chisholm, W.P. Cockshott, and R. Morrison. \nAn approach to per\u00adsistent programming. Computer Journal, 26(4), November 1983. [ACPP91] M. Abadi, L. \nCardelli, B. Pierce, and G. Plotkin. Dynamic typing in a statically-typed language. ACM Translations \non Programming Languages and Systems, 13(2):237-268, 1991. [ACPR92] M. Abadi, L. Cardelli, B. Pierce, \nand D. R4my. Dynamic typing in polymo~hic languages. In ACM SIGPLAN Workshop on ML and its Appli\u00adcations, \n1992. [BMT92] D. Berry, R. Milner, and D. Turner. A semantics for ML concurrency primitives. In Proceedings \nof ACM Symposium on Principles of Program\u00adming Lunguages, pages 119-129,1992. [BN84] A. D. Birrell and \nB. J. Nelson. Implementing remote procedure calls. ACM Transaction on Computer Systems, 2(1):39-59, 1984. \n[B092] P. Buneman and A. Ohori, Polymoprhism and type inference in database programming. Tech\u00adnical report, \nUniversity of Pennsylvania, 1992. To appear in ACM Transaction on Database Sys\u00adtems. [BST89] H. E. Bal, \nJ. G. Steiner, and A. S. Tanenbaum. Programming languages for distributed comput\u00ading systems. Computing \nSurveys, 21(3):261\u00ad322,1989. [CK92] R. Cooper and C. Krumvieda. Distributed pro\u00adgramming with asynchronous \nordered channels in distributed ML. In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, \nJune 1992. [CW85]I L. Cardelli and P. Wegner. On tmderstand\u00ading types, data abstraction, and polymo~hism. \nComputing Surveys, 17(4):471-522, December 1985. [DM82] L. Damas and R. Milner. Principal type-schemes \nfor functional programs. In Proceedings ofACM Symposium on Principles of Programming Lan\u00adguages, pages \n207-212,1982. [HL82] M. Herlihy and B. Liskov. A value transmission method for abstract data types. ACM \nTransac\u00adtions on Programming Languages and Systems, 4(4):527-551, 1982. [HS87] R. Hayes and R. D. Schlichting. \nFacilitating mixed hmguage programming in distributed sys\u00adtems. IEEE Translations on Soj%vare Engineer\u00ading, \nSE-13(12): 1254-1264, December 1987. [JR86] M. B. Jones and R. F. Rashid. Mach and Match\u00admaker kernel \nand language support for object\u00adoriented distributed systems. In Proceedings of ACM OOPSLA Conference, \npages 67 77, 1986. [K092] K. Kato and A Ohori. An approach to multikm\u00adguage persistent type system. In \nProc. Hawaii International Confernece on System Science, pages 810-819,1992. [LBG+87] B. Liskov, T. Bloom, \nD. Gifford, and W. Weihl. Communication R. Scheifler, in the Mer\u00ad cury system. Programming Memo 59, MIT, \n1987. Methodology Group [Ler92] X. Leroy. Unboxed objects and polymorphic typing. In Proceedings of ACM \nSymposium on Principles of Programming Languages, pages 177-188,1992. [LM91] X. Leroy and M. Mauny. Dynamics \nin ML. In Proceedings of the ACM Conference on Func\u00adtional Programming Languages and Computer Architecture, \n1991. LM092] G. Lindstrom, J. Maluszyriski, and T. Ogi. Our LISP are sealed: Interfacing functional and \nlogic programming systems. In Proceedings of Sym\u00adposium on Programming Language Implemen\u00adtation and Logic \nProgramming, Springer Lec\u00adture Notes in Computer Science, vol. 631., pages 428-442,1992. August. [Mac88] \nD. MacQueen. References and weak polymor\u00adphism. Note in Standard ML of New Jersey Distribution Package, \n1988. [MH88] J. C. Mitchell and R. Harper. The essence of ML. In Proceedings of ACM Symposium on Princi\u00adples \nof Programming Ixmguages, pages 28-46, San Diego, California, January 1988. [Mi178] R. Milner. A theory \nof type polymorphism in programming. Journal of Computer and System Sciences, 17:348 375, 1978. [MP88] \nJ.C. Mitchell and G.D. Plotkin. Albstract types have existential type. ACM Transactionson Pro\u00adgramming \nLunguages and Systems, 10(3):470\u00ad502,1988. [MTH90] R. Milner, M. Tofte, tion of Standard ML. and R. Harper. \nThe Defini-The MIT Press, 1990. [Oho92] A Ohori. A compilation method for ML-style polymorphic record \ncalculi. In Proceedings of ACM Symposium on Principles of Programming Languages, pages 154-165, 1992. \n[Rep91] J. H. Reppy. CML: A higher-order language. In Proceedings of ACM on Programming Language Design \nmentation, pages 294-305, 1991. concurrent Conference and Imple\u00ad [Tof88] M. Tofte. Operational phic Type \nInference. of Computer Science, 1988. Semantics and Polymor-PhD thesis, Department University of Edinburgh, \n \n\t\t\t", "proc_id": "158511", "abstract": "<p>We propose a method to extend an ML-style polymorphic language with transparent communication primitives, and give their precise operational semantics. These primitives allow <italic>any</italic> polymorphic programs definable in ML to be used remotely in a manner completely transparent to the programmer. Furthermore, communicating programs may be based on different architecture and use different data representations.</p><p>We define a polymorphic functional calculus with transparent communication primitives, which we call <bold>dML</bold>, as an extension of Damas and Milner's proof system for ML. We then develop an algorithm to translate <bold>dML</bold> to a &#8220;core&#8221; language containing only low-level communication primitives that are readily implementable in most of distributed environments. To establish the <italic>type safety</italic> of communicating programs, we define an operational semantics of the core language and prove that the polymorphic type system of <bold>dML</bold> is sound with respect to the operational semantics of the translated terms of the core language.</p>", "authors": [{"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "", "person_id": "PP39030730", "email_address": "", "orcid_id": ""}, {"name": "Kazuhiko Kato", "author_profile_id": "81545553556", "affiliation": "", "person_id": "PP14119498", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158529", "year": "1993", "article_id": "158529", "conference": "POPL", "title": "Semantics for communication primitives in a polymorphic language", "url": "http://dl.acm.org/citation.cfm?id=158529"}