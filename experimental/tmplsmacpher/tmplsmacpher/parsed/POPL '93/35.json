{"article_publication_date": "03-01-1993", "fulltext": "\n Efficient Recursive Subtyping Dexter Kozen Jens Palsberg kozen~cs. cornell. edu palsberg~dairai .aau.dk \nComputer Science Department Computer Science Department Cornell University Aarhus University Ithaca, \nNew York 14853, USA 8000 Aarhus C, Denmark Michael I. Schwartzbach mis~daimi.aau .dk Computer Science \nDepartment Aarhus University 8000 Aarhus C, Denmark Abstract 1 Introduction Subtyping in the presence \nof recursive types for the Recursive types are present in most programming A-calculus was studied by \nAnzadio and Cardelli in languages, since they provide a means of typing 1991 [11. Inthatpaper they showed \nthat theprob-recursive functions and data structures. Subt yping Iem of deciding whether one recursive \ntype is a sub-is also present in many languages and is especially type of another is decidable in exponential \ntime. important in object-oriented languages as a means In this paper we give an 0(n2) algorithm. Our \nof typing functions in the presence of inheritance algorithm is based on a simplification of the defi-and \nlate binding. nition of the subtype relation, which allows us to The unrestricted combination of recursion \nand reduce the problem to the emptiness problem for a subt yping, found for example in Amber [2] and \ncertain finite automaton with quadratically many Quest [4, 3], is of substantial pragmatic value. states. \nSince it does not depend on programmer-defined It is known that equality of recursive types and names, \nit allows the flexible typing of such con\u00adthe covariant Bcihm order can be decided efficiently structs \nas data persistence and data migration. by means of finite automata. Our results extend The combination \nof recursive types and subtyp\u00adthe automata-theoretic approach to handle order-ing at an abstract level \nwas studied by Amadio ings based on contravariance. and Cardelli in 1991 [1]. They considered types for \nthe A-calculus generated by the following grammar, where v is a type variable: t ::=vl LlTlt1+t21pv.t \nPermission to copy without fee all or part of this material is Intuitively, 1-is a minimal type containing \nonly the granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the divergent computation; T k a maximal or universal title of the publication \nand its date appear, and notice is given type containing all values; tl+ t2 is the usual that cooving \nis by permission of the Association for Computing function space; and pv.t is a recursive type that Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. satisfies the equation \nACM-20th PoPL-1/93-S.C., USA @ 1993 ACM 0.89791 -561.5 /93/0001 /0419 . ..$1.50 /.Lv.t = t[v/pv.t] , \nwhere t[v/s] denotes the term t with s substituted for free occurrences of v (after renaming bound variables \nif necessary). In Amadio and Cardelli s approach, types are un\u00adderstood as collections of values, and \nsubtypes are subcollections. Thus, types are partially ordered by an inclusion relation <. It is postulated \nthat 1< t< T for any type t, and function spaces are ordered by the usual rule s+t<s~-+tf if and only \nif s < s and t < tt , i.e., + is covariant in the range and cent ravariant in the domain. This defines \na partial order induc\u00adtively on finite types, but not on recursive types. Amadio and Cardelli showed \nhow to extend the ordering to recursive types. Their definition in\u00advolves a rule of the form (v< v * \nt<t ) =+ (pv.t < jm .t ), where v occurs only in t and v occurs only in t . In other words, if by assuming \nthe inclusion of the recursion variables we can verify the inclusion of the bodies, then we can deduce \nthe inclusion of the recursive types. They also considered the standard representa\u00adtion of types as labeled \ntrees, defined a partial or\u00adder on infinite trees, and showed that it agrees with the type inclusion \norder. Their definition of the order on trees involves infinite sequences of finite approximations, where \nthe approximations are ob\u00adtained by truncating the trees at some finite level. The relation < holds between \ntwo trees iff it holds between all their finite truncations. For an illustration of the t ype and tree \norderings, consider the following two types and their tree rep\u00adresent ations. pu.((u + u) + L) */ \\ /\\+L \n~/ \\ L ./ 1: . pv.((v + l-) + T)  / \\ /\\T /\\ \u00ad/\\T 1 It can be shown using Amadio and Cardelli s type \nrules that the former type is included in the latter. It is somewhat easier to see this for the cor\u00adresponding \ntrees: all level-k truncationsare clearly ordered. In order to automate type checking in the pres\u00adence \nof subtypes and recursive types, the problem of deciding type inclusion is of paramount impor\u00adtance: \nGiven two types s and t,is s< t? Amadio and Cardelli showed that this problem is decidable, but gave \nno complexity analysis. How\u00adever, their algorithm involves the explicit construc\u00adtion of a binary tree \nof polynomial depth, thus is at best exponential. Their algorithm is based on a concrete representation \nof recursive types involving back-pointers to represent recursion. In this paper we show that the type \ninclusion problem is solvable in time 0(n2). Our algorithm is based on a simplification of Amadio and \nCardelli s definition of the subtype relation on trees; we show that the two definitions are equivalent. \nOur defi\u00adnition, which is a generalization of an order intro\u00adduced by us in [7], intuitively says: Two \ntrees are ordered if no common path detects a counterexample. This allows us to reduce the problem to \nthe empti\u00adness problem for a certain finite automaton which accepts a language of count erexamples. Our \nalgorithm represents recursive types as so\u00adcalled term automata. The automaton that detects counterexamples \nis then defined as a certain prod\u00aduct of two term automata. For an illustration of this, consider the \nfollowing two types, their tree representations, and the term automat a for these trees. p.(t) + 1) < \npu.(u + T) 4+ . .1 .T .. 0(++- (H-T These two types are not in the subtype relation: consider for \nexample their level-3 truncations. This can be detected by the following product automa\u00adton (we show \nonly the reachable states): +., o) + V9 1 0 ti\\ (+v, -+w1) (L T,o) \\1 ((1,7,1))  The idea is that the \naccept states (marked with double parentheses) are those where the first com\u00adponent is not less than \nthe second component in the ordering 1 < + < T. Because of cent ravariance, however, we use the third \ncomponent to signal if the ordering should be reversed: O means no and 1 means yes . The automaton above \naccepts the word 01, thus the level-3 truncations of the trees are not ordered. The test for emptiness \ntakes linear time in the size of the product automaton using depth first search. The size of the product \nautomaton is the product of the sizes of the two term automata. Thus, our algorithm runs in 0(n2) time. \nIt may be surprising that the inclusion of recur\u00ad sive types can be decided efficiently using finite \nau\u00ad tomata. To quote Amadio and Cardelli [1]: The problem of equating recursive types . . . can be related \nto well-known solvable problems, such as the equivalence of finite-state automata. However, the similar \nproblem for subtyping has no well\u00adknown parallel. On the contrary, our results establish that the automata-theoretic \napproach is fruitful even in the presence of subtyping and contravariance. Further evidence is provided \nby the results of [7], which es\u00adtablish the first known polynomial time algorithm for a type inference \nproblem studied by Thatte [9] and O Keefe and Wand [8]. In the remainder of the paper we provide the \ndef\u00adinitions of term automata and labeled trees, prove that Amadio and Cardell s tree ordering and ours \nagree, and give the details of our algorithm. We in\u00adtroduce term automata and labeled trees in a more \ngeneral form than needed here; they may be useful in other contexts. 2 Terms Here we give a general definition \nof (possibly infi\u00adnite) terms over an arbitrary finite ranked alphabet X. Such terms are essentially \nlabeled trees, which we represent as partial functions labeling strings over w (the natural numbers) \nwith elements of Z. In our application, types are terms over the ranked alphabet {1, +, T}; finite types \nare finite terms and recursive types are regular terms. Let Xm denote the set of elements of X of arity \nn. Let w denote the set of natural numbers and let w* denote the set of finite-length strings over w. \nDefinition 1 A term over X is a partial function with domain D(t) satisfying the following proper\u00ad ties: \n. D(t) is nonempt y and prefix-closed; if t(a) < Xn, then {i Iai 6 P(t)} =  {0,1,...,1} l}. The set \nof all terms is denoted TE. An element a c w* isaleaf oftif a c D(t) and a is not a proper prefix of \nany other element of D(t); equivalently, if t(a) 620. u A term t is finite if its domain D(t) is a finite \nset. We denote the set of finite terms over X by .FZ. A path in a term t is a maximal subset of D(t) \nlinearly ordered by the prefix relation. By Konig s Lemma, a term is finite iff it has no infinite paths. \nDefinition 2 Let t be a term and a 6 w*. Define the partial function t J a : w* + Y by If t j. a has \nnonempty domain, then it is a term, and is called the subterm oft at position a. 0 Definition 3 A term \nt is said to be regular if it has only finitely many distinct subterms; i.e., if {tja [a c w*} is a finite \nset. The set of regular terms is denoted .RZ. 0 Example 4 Let X = {~, g, a, b}, where ~,g, a, b have \narities 2,1,0,0 respectively. The following pic\u00adture represents a typical finite term t: / \\f 1} a / \n\\b a The leaves of t are the strings 00,100,101 with t(oo) = t(100) = a and t(lOl) = b. The domain D(t) \nof t is the set of all prefixes of these strings, namely c, O,1,10in addition to those already men\u00adtioned, \nwith t(~) = t(lO) = f and t(0) = t(1) = g. The following picture represents a typical infinite regular \nterm s: f  /\\ Jf\\ /f\\ /f\\ The domain ofs is the infinite regular set 1*+ 1*O, with s(lnO) = a and s(l \n) = f for all n > 0. The leaves are the elements of the regular subset 1*O. The term is regular because \nit has only two subterms, namely s itself and the singleton term a. c1 The sets TZ, Fx, and -RZ become \nalgebraic struc\u00adtures of signature X under the natural syntactic definition of the operators for each \nf c Engiven by f E(to, . . ..tn_~)(icl) = t~(a), 0< i <72 fT~(t@...,tn_~)(6) = f . Then n 1 D(fqto, \n....tn_~))= {6} u u {h \\ a e D(ti)}. i=0 In particular, CTE undefined for c c 2., otherwise. we have \nCTZ(c) = c and The following tary properties lemma of these establishes operators. some el em en- Lemma \n5 (i) Iff EZ. and O~i <n, then f z (to, . . ..tn_l)Ji=t~. (ii,) If t(e) = f c Zn, then t= fqtjo,..., \ntl(l) ))). (iii) (tja)j.@=tJc@. (iv) The string a is a leaf oft i~D(t la)= {6}, Proof. All properties \nare immediate conse\u00adquences of the definitions. c1 Term Automata Every regular term over a finite ranked \nalphabet Z has a finite representation in terms of a special type of automaton called a term automaton. \nDefinition 6 Let Z be a finite ranked alphabet. A term automaton over X is a tuple where: Q is a finite \nset of states,  q. E Q is the start state,  6: Q x w + Q is a partial function called the transition \nfunction, and  1: Q + Z is a (total) labeling function,  such that for any state q c Q, if l(q) G Zn \nthen {i [ b(q, i) is defined} = {0,1,. ... n-1} . We decorate Q, 6, etc. with the superscript M where \nnecessary. 1 Let M be a term automaton as in Definition 6. The partial function 6 extends naturally to \na partial function $: Qxw*+Q inductively as follows: F(g,6) = q F(q, CYi) = ($(F(q, a), i) . For any \nq c Q, the domain of the partial function kx.$(g, a) is nonempty (it always contains c) and prefix-closed. \nMoreover, because of the condition on the existence of i-successors in Definition 6, the partial function \nAa!.l?($(q, a)) is a term. Definition 7 Let M be a term automaton. The term represented by M is the term \ntM = Acr.t(F(qo, a)) . A term t is said to be representable if t = tN for some M. o Intuitively, t&#38;l \n(a) is determined by starting in the start state q. and scanning the input a, follow\u00ading transitions \nof M as far as possible. If it is not possible to scan all of a because some i-transition along the way \ndoes not exist, then tM (~) is un\u00addefined. If on the other hand M scans the entire input a and ends up \nin state q, then tM (a) = l(q). Lemma 8 Let t c TX. The following are equiva\u00adlent: (i) t is regular; \n (ii) t is representable;  (iii) t is described by a finite set of equations in\u00advolving the p operator. \nProof. (i) + (ii) Suppose t has only finitely many subterms. Define Q= {tJ.a\\ac Ld*,D(tla)+o} qo=t=tl~ \nl(s) = $(6) s~i, if O < i < arity(f?(s)) 6(s, i) = undefined , otherwise { and let M be the automaton \nwith these data. A straightforward inductive argument using Lemma 5 shows that t~cl!, if D(t Ja)#@ F(t,cl) \n= undefined , otherwise{ thus J?(i(qo, a)) = @(t, a)) = i(t, a)(c) = t J cl(c) = t(a) . Therefore t \n= tm. We remark that the converse of Definition 9(ii) holds as well, since FX is a free algebra. (ii) \n~ (i) For any term automaton M and a, /3 e W*, a straightforward inductive argument In order to handle \nrecursive types, we need to ex\u00adshows that tend the ordering <FIN to infinite types in a natural way. \nMuch of the effort in Amadio and Cardelli s i(!?o, %6) = mqo, ~), @ , paper [1] is devoted to this task. \nTheir definition, which involves infinite sequences of finite approx\u00adthus imations, is given later (Definition \n15). Here we give a simplified definition (Definition 11). We will t&#38;.1j~ = ~@.tM(@) eventually show \n(Theorem 16) that the two defini\u00ad  = A@-(qo, C@)) tions are equivalent.  = Ap.@(il(qo,a), /3)) Definition \n10 The parity of a ~ {O, 1}* is the number mod 2 of O s in a. The parity of a is de\u00adnoted ra. A string \na is said to be even if ira = Owhere Ma is M with start state ;(qo, a) (if it ex\u00ad and odd ifma=1. 0 \n ists) instead of qO. If $(qo, a) does not exist, then tm J a has empty domain. Thus tM has no more Definition \n11 Let <0 be the linear order subterms than there are states of M. .L<O+<OT The equivalence of (i) and \n(iii) is proved in [5]. 1 on X, and let <1 be its reverse 4 Types For s, tc Tx, define s < t if s(a) \n<ma t(a)for all Types are terms over the ranked alphabet X = ~ 6 D(s) n D(t). 0 {L, ~, T}, where+ is \nbinary and 1, T are nullary. Over this signature, every D(t) G {O, l}*. At the Lemma 12 The relation \n< is a partial order on risk of ambiguity, we omit the superscript TX on TX, and agrees with <FIN on \nFE. In particular, for the derived operators +TX, -LT~, TTX and use infix any s, t, s , t , notation \nfor ~; thus we write s + t for the term (i,) J-<t<T with left subterm s and right subterm t,and 1 and \nT for the singleton terms with the corresponding (ii) t <1 if and only if t = J\u00adlabels. (iii) T < t ifand \nonly ift= T The finite types F ~ are ordered naturally by the following inductively defined binary relation \n<FIN. (iv) s + t < s -+ t ifandonlyifs < s andt < t . This relation captures the natural type inclusion \nor Proof. First we show that < is a partial order. coercion order in that it is covariant in the range \nReflexivity is trivial, since <ma is a partial order. and contravariant in the domain of a function \ntype. For transitivity, suppose s < t< u. Let a~ D(s) n D(u). Surely ~ 6 D(t);and if@ is a proper Definition \n9 The order <FIN is the smallest bi\u00adnary relation on FX such that prefix of a in D(t),then (i) 1 <F~IN \nt <FIN T for all finite t; so @) = +, therefore @is not a leaf of D(t). Since (ii) ifs <FIN s and t <FIN \nt then ce D(t) and no proper prefix of a is a leaf of D(t), s* t<FIN S1-+ t . we must have a E D(t). \nBut then n s(a) <ma t(a) <ma u(a) , thus s(a) <r@ u(a) by the transitivity of <ma. Since a was arbitrary, \ns < u. For antisymmetry, assume s ~ t < s. Let ~ e D(s). Arguing as above, we must have a 6 D(t), thus \nD(s) ~ D(t), and by symmetry, D(t) ~ D(s). For any a 6 23(s) n D(t), we have s(a) <Ta t(a) <ma s(a) , \n thus s(a) = i(a). Since s and t have the same domain and agree on the intersection of their do\u00ad mains, \nthey are equal. We next establish the properties (i) (iv) in turn. (i) For any t, we have c G D(t) and \n1(6) <CI t(c) so T(c). (ii), @i) follow immediately from (i) and anti\u00adsymmetry. (iv) For ij suppose \ns < s and t < t and let acD(s + t) nD(s ~ t ).If a = c?we have (s+ t)(c) = (s + t )(.) = + so ($+ q(c) \n<T, (s + t )(c) . If a = 0~, then @ 6 D(s) n D(s ) and (s + t )(a) = (s + t )(op) = s (/3) <m? 4P) = \n(s+ t)(op) = (s+ t)(a) , therefore (s+ t)(a) Sma (s + t )(a) . If a = 18, then@ e D(t) n D(t ) and \n(s+ t)(a) % (s + t )(a) by a similar argument. For only i~ assume that s + t < s + t . Let a 6 land. \nThen Oa c D(s + ~)nD(s + #), therefore s(a) = (s --+ t)(oc!) sr(oci) (s + t )(oa) = s (a) , thus s (a) \n<ma s(a). Since a was arbitrary, S < S. A similar argument shows that for arbitrary a E D(t) n D(t ) \nwe have t(a) <ma t (a), thus t < t . Finally, we show that the orders <FIN and < agree on finite types, \ni.e., s < tif and only ifs <FIN t. We proceed by induction on the structure of s and t. Ifs= L or t= \nT then the result follows from (i). Ift = -1-then the result is immediate from (ii), and ifs = T then \nthe result is immediate from (iii). The remaining case S-+t<sl+t -s+t<FINS +t follows immediately from \n(iv) and the induction hypothesis on the subterms. c1 In order to define Amadio and Cardelli s order, \nwe have to consider finite approximations to infi\u00adnite terms. Definition 13 The level-k truncations tlk, \nt ~k, and tLkof the term t are defined by and where [al = { 1, T, a even Q odd, lC!J = T, a even { 1, \na odd. 1 The truncation t(kis the one originally employed by Amadio and Cardelli. It has the nice proP\u00aderty \nthat t[k <FIN t[k+l,although this property serves no apparent purpose in [1]. For technical reasons we \nprefer to work with the simpler t[~ defi\u00adnition. The following lemma shows that we obtain the same subtype \norder in any case. Lemma 14 FOY any k >0 and terms s and t,the following are equivalent: e sl~ <j71N \nt[~ o s[~ <FIN t[~ o s[k <FIN t[k.  Proof By Lemma 12, it suffices to show the equivalence of the \nabove statements with SFIN re\u00adplaced by s. Let t be any one of the three opera\u00adtors Ik, [~, lk. Foranya \ne D(st)n D(tt), if [al = k then st (a) = tt(a),thus st (a) <Ta t t (a); and if Ia[ < k then st (a) = \ns(a) and tt(a) = t(a),thus s t (a) ~ra t ~ (a) iff s(a) STa t(a). c1 Definition 15 Amadlo-Cardelli s \norder SAC is defined as S <AC t % $Ik <FIN ?$Ikfor au k >0 . 1 Theorem 16 The relation ~ agrees with \n~Ac. Prooj We prove the two inclusions. Assume first that s SAC t. Let a E D(s) fl D(t). Choose k = Ia![ \n+ 1. Since slk ~FIN tlk, we have sl~ ~ tlk by Lemma 12, thus s(a) = s[k(~) ~ma t[~(~) = t(~). Since \na was arbitrary, s s t. Assume conversely that s s t. Let k~ Oand let @ ~ D(slk) n D(tlk). If lal = k, \nthen slk(~) = tlk(~). If Ial < k, then slk(~) = S(CY) <ma t(ct) = tlk(CY) . In either case, S\\k(Q) <ma \ntl~(a), thus .$Ik < tlk, and by Lemma 12, slk <FIN t[k. Since k > 0 was arbitrary, s <.4c t. 1 5 An \nAlgorithm In this section we give an algorithm to decide whether s s t for two given regular types s \nand t. Assume s and t are given by term automata M and hf respectively over the ranked alphabet E = {1,+, \nT}. If s and t are given by other means, say by simultaneous equations as in [1], then results of [5] \ncan be used to obtain the au\u00adtomat a in linear time as described in Lemma 8 of Section 3. Recall from \nDefinition 11 that s ~ tiff s(a) <ma t(a) for all Q c 27(s) n D(t). Equivalently, s ~ tiff the set {~ \ne D(s) n D(t) I S(CY) gma t(~)} (1) is nonempt y. We show that the set (1) is a regular subset of {O, \n1}*, and describe a conventional finite automaton A (in the sense of [6]) over the input alphabet {O, \n1} that accepts exactly this set. Define A = (Qd, {0,1}, q$, 6A, -F d) where: e QA = QM x QN x {O,1} \nare the states of A; e qi$ = (qoM, q~, O) is the start state of A; e 6A : QA x {O, 1} + QA is the partial \nfunction which for b,i E {0,1}, p G Q , and q c QN gives 8A((p, q, b), i) = @ (p, i), 8N(q, i), b @ @ \nwhere @ denotes mod 2 sum; e the set of accept states of A is FA = {(p, q, b) I ~ (p) ~b ~N(q)} . According \nto this definition, 6A((p, q, b), i) is de\u00adfined if and only if l (p) = IN(q) = +. The automaton A is \nnondeterministic only in the sense that the state (p, q, b) has no i-successors if either .(? (p) or \nlN(q) c {1, T}. If l (p) = lN(q) = +, then the i-successor of (p, q, b) is defined and is unique. Theorem \n17 The automaton A accepts the set (l). Proof Extend the partial function 6A to a par\u00adtial function \niA :QA X{O,1}* + QA inductively as usual: V(p, 6)= p &#38;(p, ai) = @(&#38;(p, cl), i) . By definition, \na is accepted by A iff ~A(q&#38;, a) ex\u00adists and is in F A. We show by induction that for any a 6 {O, \nl}*, P~Q , q~QN, and be {0,1}, $A((p, q, b), a) = ($ (p, a), $N(q, Q), b@ m) . (2) (Of course, the use \nof the equality symbol = to compare expressions involving partial functions bears the extra semantic \ncondition that the left hand side is defined if and only if the right hand side is. This is an implicit \nbut important part of our equational arguments.) For the basis cr = c, we have $A((p, q, b), c) = (p, \nq, b) = (F (p, c), $ (q, e), b 6 TE) . For the induction step, $A((p, q, b), ai) = 6 4(@((p, q, b), \na), i) tiA((iM(p, Cr), w(q, a), bo 7ra), i) : (&#38;($M(P, ~), i ), cfN(;N(q, CY), i), b@ ma @ @ = (F \n(P, ai),$~(q, ai), b @ r(cri)) . From (2) we have that the domain of the partial function kr.$A((p, \nq, b), cr) is the in~ersection of the domains of Aa.~M (p, CZ) and k.b~(q, et). Thhi says that any string \na ac\u00adcepted by d must lie in the set I@#(q$,cr)) = P(kr.iM(q&#38; a)) n Z2(kr.w(qg, a)) = D(s) nD(t) \n. For such strings a, a is accepted by A s FA(qt, cr) e I d  + %((qoM, o),0 )c F A q{, * (W-f(qo$-l \nEFA  Cr),w(q$f a),o@7rcr) -($ % O ? 0$ %#? ~)! ~~) ~ ~A e w(w(q~> a)) gm. l~(w(&#38; a)) e s(a) -&#38; \nt(a) . Thus A accepts the set (1), 1 To decide whether s ~ t, we construct the au\u00adtomaton A and ask \nwhether it accepts a nonempty set, i.e., whether there exists a path from the start state to some final \nstate. This can be determined in linear time in the size of A using depth first search. The automaton \nA has 2. [QM 1. IQ I states and at most two t ransition edges from each state. Thus the entire algorithm \ntakes no more than (2([sI . It[) time, where Is[ and [tl are the sizes of the repre\u00adsent ations of the \nregular terms s and t. We have shown Theorem 18 The subtype relation for recursive types can be decided \nin time 0(n2). Acknowledgement This work was partially supported by the Danish Research Academy, the \nNational Science Founda\u00adtion, the John Simon Guggenheim Foundation, the U.S. Army Research Office through \nthe ACSyAM branch of the Mathematical Sciences Institute of Cornell University under contract DAAL03-91-C\u00ad0027, \nand the Danish Research Council under the DART Project (5.21.08.03). References [1] Roberto M. Amadio \nand Luca Cardelli. Subtyping recursive types. In Eighteenth Symposium on Pn n\u00adciples of Programming Languages, \npages 104 1 18. ACM Press, January 1991. To appear, Trans. on Prog. Lang. and Systems. [2]Luca Cardelli. \nAmber. In Combinators and Func\u00adtional Programming Languages, Proc. 13th Summer School School of the LITP. \nSpringer-Verlag (LNCS 242), May 1985. [3] Luca Cardelli. Typeful programming. In Leci. Notes for the \nIFIP Advanced Seminar on Formal Methods in Programming Language Semantics, 1989. [4] Luca Cardelli and \nPeter Wegner. On understanding types, data abstraction, and polymorphism. Com\u00adputing Surveys, 17:4:471 \n522, December 1985. [5] Bruno Courcelle. Fundamental properties of infinite trees. Theor. Comput. Sci., \n25:95-169, 1983. [6] John E. Hopcroft and Jeffrey D. Unman. Introduc\u00adtion to Automata Theory, Languages, \nand Compu\u00adtation. Addison-Wesley, 1979. [7] Dexter Kozen, Jens Palsberg, and Michael I. Schwartzbach. \nEfficient inference of partial types. In Proc. 39rd IEEE Symp. Found. Comput. Sci., October 1992. To \nappear. Also PB-394, Computer Science Department, Aarhus University, April 1992. [8] Patrick M. O Keefe \nand Mitchell Wand. Type in\u00adference for partial types is decidable. In Proc. ESOP 92, European Symposium \non Programming. Springer-Verlag (LNCS 582), 1992. [9] Satish Thatte. Type inference with partial types. \nIn Proc. International Colloquium on Automata, Languages, and Progmmming 1988. Springer-Verlag (LNCS \n317), 1988.  \n\t\t\t", "proc_id": "158511", "abstract": "<p>Subtyping in the presence of recursive types for the &#955;-calculus was studied by Amadio and Cardelli in 1991 [1]. In that paper they showed that the problem of deciding whether one recursive type is a sub-type of another is decidable in exponential time.</p><p>In this paper we give an O(n<supscrpt>2</supscrpt>) algorithm. Our algorithm is based on a simplification of the definition of the subtype relation, which allows us to reduce the problem to the emptiness problem for a certain finite automaton with quadratically many states.</p><p>It is known that equality of recursive types and the covariant Bo&uml;hm order can be decided efficiently by means of finite automata. Our results extend the automata-theoretic approach to handle orderings based on contravariance.</p>", "authors": [{"name": "Dexter Kozen", "author_profile_id": "81100623764", "affiliation": "", "person_id": "PP39079164", "email_address": "", "orcid_id": ""}, {"name": "Jens Palsberg", "author_profile_id": "81100375570", "affiliation": "", "person_id": "PP39040032", "email_address": "", "orcid_id": ""}, {"name": "Michael I. Schwartzbach", "author_profile_id": "81392609511", "affiliation": "", "person_id": "P198767", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/158511.158700", "year": "1993", "article_id": "158700", "conference": "POPL", "title": "Efficient recursive subtyping", "url": "http://dl.acm.org/citation.cfm?id=158700"}