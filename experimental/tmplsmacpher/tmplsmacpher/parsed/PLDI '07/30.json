{"article_publication_date": "06-10-2007", "fulltext": "\n Regularly Annotated Set Constraints * JohnKodumal UC Berkeleyand Coverity, Inc. jkodumal@coverity.com \nAbstract Ageneral class of program analyses are a combination of context\u00adfree and regular language reachability. \nWe de.ne regularly an\u00adnotated set constraints, a constraint formalism that captures this class. Our results \nextend the class of reachability problems ex\u00adpressible naturally in a single constraint formalism, including \nsuch diverse applications as interprocedural data.ow analysis, precise type-based .ow analysis, and pushdown \nmodel checking. Categories and Subject Descriptors D.2.4[Software Engineer\u00ading]: Software/ProgramVeri.cation; \nF.3.2[Logics and Meanings of Programs]: Semantics of Programming Languages General Terms Algorithms, \nDesign, Experimentation, Languages, Theory Keywords Set constraints, context-free language reachability, \n .ow analysis, annotated inclusion constraints, pushdown model checking 1. Introduction Manyprogram analyses \nreduce to reachability problems on labeled graphs with requirements that certain labels match: a constructor \nmust be matched with a corresponding destructor, a function call mustbe matchedwithafunction return,andsoon.Dynamic \ntransi\u00adtive closure [20], context-free reachability [23], and the cubic-time fragment of set constraints \n[10, 1] are all formalisms that describe such analyses. These three approaches are closely related: set \ncon\u00adstraint solvers are implemented using optimized dynamic transitive closure algorithms [7, 27, 11] \nand one ef.cient implementation of context-free reachability is based on a reduction to set constraints \n[15]. Representativeprogram analysis problems solvable with these methods include polymorphic .ow analysis \n[21] and .eld-sensitive points-to analysis [26]. There are more complex analysis problems where multiple \nreachability properties must be satis.ed simultaneously; e.g., one can easily de.ne problems that require \nmatching of both function calls/returns and data type constructors/destructors. Unfortunately, analysis \nproblems requiring satisfying two or more context-free properties simultaneously are undecidable [22].Ageneral, \ndecid\u00ad * Thisworkwas supportedbyNSF grants CCR-0085949 and CCF-0430378 and equipment donations from \nIntel and Dell. Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, to \nrepublish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or a \nfee. PLDI 07 June 11 13, 2007, San Diego, California, USA. Copyright c &#38;#169; 2007ACM 978-1-59593-633-2/07/0006...$5.00. \nAlex Aiken Stanford University aiken@cs.stanford.edu able classof reachability propertiesisthe combinationofacontext\u00adfree \nlanguagewithanynumberofregular languages.Anumberof natural analysis problemsfallintothisclass[3,5,13,12]. \nIn this paper we extend set constraints to express program anal\u00adyses involving one context-free and anynumber \nof regular reach\u00adability properties. Existing implementations of analyses that com\u00adbine context-free \nand regular reachability are hand optimized and tunedtoa particular analysis problem.Our constraint resolutional\u00adgorithm \nallows these analyses to be written at a higher level while also providing an implementation that is \nmore ef.cient than those written by hand. In short, we enlarge the class of program analy\u00adses that can \nbe solved ef.ciently with a single constraint resolution algorithm. Our approachbuilds on an idea .rst \nintroducedin [25], in which terms and constraints can be annotated with a word from some language.We \nintroduce regularly annotated set constraints, where eachconstructor of a term and each constraint can \nbe anno\u00adtated with a word from a regular language. The principal contribu\u00adtions of this paper are: We \nintroduce regularly annotated set constraints andgivea for\u00admal semantics (Section 2). Previous work on \nannotated con\u00adstraints has not addressed semantics, probably because the ap\u00adplications use only .nite \nlanguages [19]. Because our annota\u00ad tions are drawn from in.nite regular languages, annotations are not \nbounded in size and understanding even the termination of a constraint solver requires formalization. \n We present algorithms for solving regularly annotated set con\u00adstraints. Unlike the unannotated case, \nwhere all natural solving strategies have the same asymptotic complexity, for annotated constraints we \ncan give algorithms for either forward or back\u00adward solving that are asymptotically faster than bidirectional \nsolving (Section 5). If the .nite state machine for the regu\u00adlar annotations is small, the bidirectional \nstrategy is practical. This complexity difference shows that for analysis problems reducible to annotated \nset constraints, whole program analysis, which can be done with forwards or backwards solutions, is ap\u00adparently \nmore ef.cient than separate, compositional analysis, which requires bidirectional solving.  We solve \nan open problem:We combine previous results [15] with annotations to express a type-based .ow analysis \nsupport\u00ading polymorphic recursionand non-structural subtypinginala\u00adbel.ow analysis (Section7).Wealsoshowhowtoapply \nanno\u00ad tated inclusion constraints to solve pushdown model checking problems and interprocedural bit-vector \ndata.ow problems that operate on the program s control .ow graph (Section 6).  2. Annotated Constraints \nThis section introduces the syntax and semantics of regularly an\u00adnotated set constraints, gives an algorithm \nfor solving such con\u00adstraints, and works through an example. 2.1 Set Constraints Let c, d, . . . . C \nbe a set of constructors; each constructor c has arity a(c). Constructors inductively de.ne a domain \nT : T = {c(t1,...,ta(c))|ti . T . c . C} . {.} Constants (arity zero constructors) and . are the base \ncases of T . There is a standard ordering = on elements of T : .= t '''' t1 = t1 . ... . tn = tn . c(t1,...,ta(c)) \n= c(t1,...,ta(c)) The value . represents, as usual, unde.ned (e.g., non-terminating) terms. The reason \nfor using a domain with . instead of the simpler set of ground terms without . is that we want constructors \nto be non-strict (i.e., c(t, .) =.); we explain whyin Section 3. The class of set expressions we consider \nin this paper are set variables, constructors applied to set variables, and projections: se ::= X| c(X1,..., \nXa(c)) | c -i(X ) Set expressions denote downward-closed subsetsof the domain.A set T ' . T is downward-closed \nif '' '' .t . T. (t . T . t= t) . t. T Using downward-closed sets simply says that we do not attempt \nto reason about whether terms are fully de.ned (have no non-. sub-terms). An assignment . is a mapping \nfrom set variables to downward-closed subsets of T . Assignments are extended to set expressions in the \nnatural way: .(c(X1,..., Xa(c))) = {c(t1,...,ta(c))|ti . .(Xi)} .(c -i(X )) = {ti|c(t1,...,ta(c)) . .(X \n)} Aset constraint is an inclusion constraint se1 . se2 between any two set expressions, except that \nprojections may not appear on the right-hand side of a constraint. An assignment . is a solution of a \nconstraint se1 . se2 if .(se1) . .(se2). 2.2 Regularly Annotated Set Constraints Let M = (S, S, s0, \nd, Saccept) be a minimized deterministic .nite state automaton (DFA), where S is the input alphabet, \nS the set of states, s0 and Saccept the start state and set of .nal states respectively, and d(w, s)= \ns' is the machine s transition function. Werefer toL(M),the language acceptedbyM,whenever we need to \nappealtoalanguage characterization. Becauseregular languages are closed under products, it is suf.cient \nto deal only with a single machine representing the product of all the regular reachability properties \nfor a given application.  2.3 Annotated Terms The .rst step in our extension is to de.ne the domain \nof terms. Intuitively,each term shouldbe annotated withaword from L(M); suchaterm encodes information \nfor both the set constraint property (the term) and the regular reachability property (the word). This \nidea does notwork,however, withouttwo modi.cations: Word annotations are needed on every constructor \nin a term, not just at the root; different constructors in the same term may have different annotations. \n Because individual constraints express only part of a global so\u00adlution of all the constraints, it is \ntoo strong to require annota\u00adtions be full words in L(M). Instead, annotations may be par\u00adtial words \nin L(M ). The required language of partial words depends on the particular algorithm for computing solutions \nof the constraints.A forwards (backwards)solver propagates con\u00adstructors from lower (upper) bounds to \nupper (lower) bounds; it  turns out that a forwards (backwards) solver should admit pre\u00ad.xes (suf.xes) \nof words in L(M) (see Section 5).A bidirec\u00adtional solver may propagate information either forwards from \nlower bounds to upper bounds or backwards from upper bounds to lower bounds, and so a bidirectional solver \nshould accept ar\u00adbitrary substrings of words in L(M). In this paper we focus on bidirectional solving, \nasitis technically the most interesting case. The M-annotated domain over constructorsc, d, . . . . \nC and .nite automaton M is T M = {c w(t1,...,ta(c))|ti . T M . c . C . w . L(M)}.{.} Let Msub be the \nminimal DFAaccepting substrings of L(M) (the set of all substrings of a regular language is also regular). \nThe domain we are interested in for bidirectional solving is T Msub . To de.ne the semantics of annotated \nconstraints we need an operation that appends a word to all levels of an annotated term: w' ww '' c (t1,...,ta(c)) \n\u00b7 w= c , (t1 \u00b7 w,...,ta(c) \u00b7 w) ' .\u00b7w= . If Q is a set of terms then Q \u00b7 w = {t \u00b7 w|t . Q}. 2.4 Annotated \nSet Constraints An M-regularly annotated set constraint is an inclusion constraint se1 .x se2, where \nse1, se2 are set expressions and x . S . {E}.We often abbreviate se1 se2 by dropping the annotation .e \n se1 . se2. Note set expressions are not themselves annotated; we do not need to burden the analysis \ndesigner with annotating set expressions, becauseitispossibletoinfertheneededsetexpression annotations \nduring constraint resolution. We next de.ne assignments. mapping set expressions to sets of annotated \nground terms.Weextend setexpressions with word set variables attached to each constructor: se ::= X| \nc a(X1,..., Xa(c)) | c -i(X ) The word set variables a, \u00df, . . . range over subsets of L(Msub). An assignment \n. now maps set variables to sets of annotated terms and word variables to sets of words. .(c a(X1,..., \nXa(c)))={c w(t1,...,ta(c))|w . .(a) . ti . .(Xi)} .(c -i(X ))={ti|c w(t1,...,ta(c)) . .(X )} An assignment \n. is a solution of a system of annotated constraints {se1 .w se2} if .(se1) \u00b7 w . .(se2) for all constraints. \nSolutions may assign arbitrary sets to the word and term variables, provided they satisfy the constraints. \nWe now show a restricted family of solutions, the M-regular solutions, are suf.cient to characterize \nall solutions. We de.ne the following congruence on words in L(Msub ): '* ' w =M w..x, y . S . xwy . \nL(M) iff xwy . L(M) '' Theorem 2.1. w =M w=..s . S. d(w, s)= d(w,s) Proof. This result follows from \nthe Myhill-Nerode theorem; we in\u00adclude the proof because it is useful in understanding our constraint \nresolution algorithm. Assume w =M w' yet there is an s . S ' such that d(w, s)= si but d(w,s)= sk. Since \nthe machine is minimal, s must be reachable from s0, implying there is a word x with d(x, s0)= s. Minimality \nalso implies the existence of a word y where d(y, si) . Saccept and d(y, sk) ./Saccept, or viceversa.Without \nlossof generality, assume the .rst case. Then ' xwy . L(M) but xwy ./L(M), contradicting the assumption \n' that w =M w. Thus, each word equivalence class W de.nes a unique represen\u00adtative function from states \nto states: f(s)= d(w, s) for w . W . Associated withevery automaton M isa .nite setof representative \nfunctions F = = S i F i MM , computed inductively as follows: F 0 = {fs | s . S where fs(s)= d(s, s)}F \ni M = {f . g | f, g . F i-1}. F i-1 M MM The representative function for the word E in any machine is \nthe identity fe mapping each state to itself.We appeal to this function characterization of equivalence \nclasses shortly. We extend=M to an equivalence relation on annotated terms: ^ ww'' '' c (t1,...,ta(c)) \n=M c , (t1,...,t a(c)) . w =M w . ti =M ti i An assignment . is M-regular if w . .(a) . w =M w ' =. w \n' . .(a) t . .(X) . t =M t ' =. t ' . .(X) and t \u00b7 w . T Msub Lemma 2.2. If t =M t ' then t \u00b7 w =M t \n' \u00b7 w. Proof. By induction on the structure of t.Without loss of gener\u00ad x ality, assume t = c (t1,...,ta(c)). \nBecause t =M t ', we know ' y'' ' t = c(t1,...,t a(c)) where x =M y and ti =M ti. c x(t1,...,ta(c)) \u00b7 \nw = def. of \u00b7 xw(t1 c \u00b7 w, . . . , ta(c) \u00b7 w) =M xw'' c (t1 \u00b7 w, . . . , t a(c) \u00b7 w) =M yw'' c(t1 \u00b7 \nw, . . . , t a(c) \u00b7 w)= def. of \u00b7 y'' c(t1,...,t ) \u00b7 w a(c) T MsubFor the second step, t \u00b7 w . implies \nthat, for each i, \u00b7w . T Msub tiand therefore we can apply the inductionhypothesis to conclude ti \u00b7 w \n=M ti ' \u00b7 w.For the third step, observe x =M y implies that xw =M yw. We say. = . ' if .(a) . . ' (a) \nfor all word and set variables a.We say . ' is the M-regular completion of . if . ' isthe smallest assignment \nsuch that . ' = . and . ' is M-regular. Theorem 2.3. If . is a solution of a system of M-annotated con\u00adstraints, \nthen its M-regular completion . ' is also a solution. Proof. Consider anyconstraint e1 .w e2 and term \nt . . ' (e1);the goal is to show t \u00b7 w . . ' (e2). t . . ' (e1) .t ' =M t. t ' . .(e1) t ' \u00b7 w . .(e2) \nt ' \u00b7 w . . ' (e2) t \u00b7 w . . ' (e2) The last step follows from Lemma 2.2, using t =M t from the .rst \n\u00b7w . T Msub step and thefact that t ' \u00b7w . .(e2) implies t ' (because . is a solution and solutions range \nover subsets of T Msub ). Because the regular completion of every solution is also a so\u00adlution, it suf.ces \nto compute only regular solutions. Furthermore, in the regular solutions, each word set variable represents \na set of full equivalence classes, and by Theorem 2.1 each equivalence class corresponds to a unique \nrepresentative function. Thus, we can replace word set variables with representative function vari\u00adables \nand each annotation with the representative function for the . def. of regular completion . . is a solution \n . . ' = . .  '  Figure 1. Finite state automaton M1bit for the 1-bit language. annotation s equivalence \nclass and deal with .nite sets of repre\u00adsentative functions instead of in.nite sets of words. A mapping \n.(a)= {f1,f2,...} corresponds to the regular solution .(a)= {w|.f .{f1,f2,...}..s . S.f(s)= d(s, w)} \n From here on we refer to sets of representative functions, not sets of words, in constructor annotations; \nwe use the term representa\u00adtive function variables instead of word variables for clarity. Our algorithm \ninfers the representative functions needed as annotations automatically,which is whywe do not represent \nthem in the surface syntax. We illustrate annotated constraints with a simple example. As\u00adsume the input \nautomaton is M1bit shown in Figure 1. Example 2.4. Consider the following constraint system: a .g\u00df .g \nc W o (W) X X.e o . (Y) o . (Y) .e Z Let fg be the representative function containing the word g; fg(0) \n= 1 and fg(1) = 1. The solution for the function vari\u00adables is a, \u00df = {fe}, . = {fg} and for set variables \n(the downward-closure of) Y, W = {c fg }, X = {o fg (c fg )}, and Z = {o fg (c fg )}. Note that the solution \ninstantiates the constraint o \u00df(W) .g X to f, (c fg ) .fg fg (c fg ) oo The left-hand side illustrates \nthat annotations on different levels of constructors within a term are not always the same. 3. Solving \nAnnotated Constraints Our resolution algorithm uses a standard, two-phase approach: The .rst phase non-deterministically \napplies a set of resolution rules to the constraints until no more rules apply. The rules preserve all \nregular solutions of the constraints. If no manifest contradiction is discovered, the .nal constraint \nsystem is in solved form, which is guaranteed to have at least one solution.  The second phase tests \nentailment queries on the solved form system: Do the constraints imply, for example, that t . X for some \nannotated term t and set variable X?  3.1 Resolution Rules The .rst two resolution rules deal with \nconstraints between con\u00adstructor expressions: c a(X1,..., Xa(Vc)) .f c \u00df(Y1,..., Ya(c)) . i Xi .f Yi \n. f . a . \u00df c a(...) .f d\u00df (...) . no solution The .rst rule propagates inclusions between constructed \nterms to components and produces representative function constraints on function variables annotating \nconstructor expressions: the function annotations \u00df on the right-hand side constructor expression must \ncontain at least f . a, the composition of functions in a with f (we de.ne f . G, where G is a set of \nfunctions, to be {f . g | g . G}). Because functions are just constants (zero-ary constructors) and the \nset F = of representative functions is known and .xed for a M givenmachineM,these function constraints \nare themselves simple examples of set constraints. The second resolution rule simply recognizes manifestly \ninconsistent constraints where the top-level constructors do not match. The third rule resolves projection \nconstraints. c a(..., Xi,...) .Y . c -i(Y) .Z .Xi .Z These rules should be interpreted as follows: whenever \nthere are constraints satisfying the left-hand side of the rule, the right-hand side constraint is added \nto the system of constraints. Because con\u00adstraints are only added the rules are automatically sound (no \nnew solutions are created by the rules). It is easy to check that the rules are also complete (each rule \npreserves all solutions of the original systemof constraints).Theserulesarenot completeforasemantics \nthat uses strict constructors (i.e., if one component of a constructor expression is . then the entire \nconstruction collapses to .), and indeed this is the reason we have chosen to use the non-strict se\u00admantics \nhere. Constraints with at least one binary strict constructor are much moreexpensiveto solve [2];in practice, \nall implementa\u00ad tions we know of assume a non-strict semantics for constructors. Finally,atransitive \nclosure rule propagates annotationsbycom\u00adposing them: se1 .f X.g se2 . se1 .g.f se2 Because M is minimized,noworkneedbedone \npropagating anno\u00adtations that are necessarily non-accepting, obviating the need for a match operation \nas in [19]. Returning to Example 2.4, the solved form of this system is: a .fg \u00df .fg c W o (W) X X. o \n. (Y) o . (Y) .Z o \u00df(W) .fg o . (Y) W.fg Y c a .fg Y fg . \u00df . . a .fg .fg Note the transitive constraints \nc WY result in the a .fg constraint c Y because fg . fg = fg (see Figure 1). Lemma 3.1. Constraint resolution \nterminates. Proof. (Sketch) The interesting case is the transitive closure rule. The number of possible \nconstraints depends on the maximum num\u00adber of distinct functions and the number of set expressions. As \nthe resolution rulesdonot createanynewsetexpressionsandthe num\u00adberof functionsona .nitesetof statesto \nitselfis bounded,the total number of possible constraints is also bounded.  3.2 Queries In this section \nwe outline queries on solved systems. The simplest query we are interested in is whether a term t with \nan annotation in L(M) is always in a particular set variable X in all solutions. Intuitively, this question \nmodels whether a particular abstract value t always .ows to a program point corresponding to X along \na path annotated with a word in L(M). More precisely,we say that constraints C1 entail constraints C2, \nwritten C1 |= C2, if every solution of C1 is a solution of C2. The formalization of the simple query \nis: C . fe . a . fe . \u00df... |= _ t .f X f.Faccept where a, \u00df, . . . are the function variables appearing \nin t and Faccept = {f | f . F = M . f(s0) . Saccept}. Intuitively, Faccept is the subset of representative \nfunctions F = that lead to an accept M state from the initial state; these functions represent full \nwords in L(M).We can now explain important aspects of querying anno\u00adtated constraints: Set constraint \nsolvers differ in how much work theyassign to the solving phase and the query phase.We have described \nan eager solver that does essentially all the work in the resolution rules, as in [10]; queries in this \ncase are particularly easy to solve.Forexample, fora constant c a, the entailment C . fe . a |= _ c a \n.f X f.Faccept holds if and only if a constraint c a .f X is present in the solved form system C where \nf(s0) . Saccept. Demand driven solvers essentially move all of the work of res\u00adolution to queries [11]. \nAs an optimization, our solver does not generate function constraints or annotate constructors at all \nduring resolution and this decision has important performance advantages (see Section 8).For our queries, \nthe representative function constraints needed to answer a query can be recon\u00adstructed as part of the \nentailment computation itself.  Our applications use queries beyond asking whether a single term is \nin a set variable. The general form of a query is to ask whether a set of terms (given by a set expression) \nintersected withavariableis non-empty,giventhatthe constructorsmustbe annotated in certain states. Such \na query can be used to search for the existence of a term denoting an error in the program  (e.g when \nchecking .nite state properties).We present only the simpler case formally because it requires no additional \nnotation, and the general case introduces no new ideas. Returning again to Example 2.4, let C1 be the \nsolved form of the constraints. The query C1 . fe . a . fe . \u00df |= o \u00df (c a) .fg Z is true. The least \nsolution of C1 .fe . a.fe . \u00df is the assignment given in Example 2.4. We can now explain in more detail \nwhy we solve constraints over T Msub instead of T M . The transitive closure rule, in partic\u00adular, cannot \nsimply reject concatenations of words that are not in L(M),as such annotations may later combine with \nother annotated constraints through other uses of the transitive closure rule to form a word in L(M). \nSolving in the larger domain T Msub still guar\u00adantees termination and also preserves all entailment queries \nusing words in L(M ). 3.3 An Example: Bit-Vector Annotations As an example we show how to express bit-vector \nproblems as a regular annotation language. This annotation language could be used to implement bit-vector \nbased interprocedural data.ow anal\u00adysis [12]. For an analysis that tracks n facts, we pick an alpha\u00adbet \nS partitioned into two sets G = {g1,...,gn} and K = {k1,...,kn} (gens and kills, respectively). The idea \nis that a gen cancels an adjacent matching kill kill, as in the word giki, and that gens and kills are \nidempotent. Figure1shows the .nite state automaton M1bit fora single data.owfact.For this language, F \n= = {fe,fg,fk},sincefg .fg = fg and fk .fg = fe and so on. M Thus, we need not track arbitrary sequences \nof gens and kills;it suf.ces to track just three different possible annotations. An n-bit language can \nbe derived from a product construction. 4. Complexity Wesketchacomplexityargumentforthe constraintresolutionalgo\u00adrithm \ndescribedinSection3.Asystemof constraints containingno annotations can be solved in O(n 3) time, where \nn is the size (mea\u00adsured in number of symbols) of the system. Each of n variables can have up to n lower \nbounds and n upper bounds; thuseveryvariable in the transitive closure causes at most O(n 2) work and \nthere are O(n) variables. For an annotated system of constraints, we must compute a new number of lower \nand upper bounds. Consider a particular lower bound se .X (the argument for upper bounds is similar). \nThere may be one lower bound se .f X between se and X for each distinct equivalence class f annotating \nthe constraints, so the prob\u00adlem is to bound the number of distinct representative functions. Clearly, \nthen, |F = M | gives the number of possible lower bounds on any variable. In the n-bit language, for \ninstance, this approach au\u00adtomatically exploits order independence of distinct bits: If (shift\u00ading back \nto word annotations) a constraint X .g1g2 Y is already present in the system, the constraint X .g2g1 \nY is redundant (i.e., g1g2 = g2g1)and need not be added. Thus, each variable in an annotated system can \nhave up to n \u00b7M | lower bounds and n\u00b7M | upper bounds.With representa\u00ad |F = |F = tive functions as the \nannotations on constraints, function composi\u00adtion canbe implementedasaprecomputed tableandso f .g can \nbe computed in constant time via table lookup. Thus, each of n vari\u00adables in the constraint system the \nsolver does at most O(n 2 |F = ) M |2 3 |F = work. The total complexity is therefore O(n M |2). This \ngeneric argument may be sharpened for the constraints generated by a par\u00adticular application. Now we \nrelate complexityintermsof |F = M | to |S|, the number of states in M. One can build an adversarial machine \nsuch that |F = M | is superexponential in |S|, the number of states in M. The idea is to construct a \nmachine such that F = contains each of the M |S||S| possible functions from domain S to range S. One \nsuch machine,givenin Figure2, uses three operations rotate, swap, and merge to generate the entire space \nof functions as follows: rotate maps state i to state i +1, with wraparound.  swap maps state1to state2,and \nstate2to state1,while map\u00adping every other state to itself. Every sequence of rotates and swaps generatesa \npermutationofthe n states of the automaton, andevery permutationis generatedbysome sequenceof rotates \nand swaps.  merge allows the generation of information-losing functions (functions that are not injective) \nby mapping state 1 to itself, state2to state1,andanyother stateto itself.Usingan appro\u00adpriate sequence \nof swaps and rotates .rst, anypair of function outputs can be merged.  This machineis clearlyapathologicallybad \ncase,yetthe possibility of having an implementation that is superexponential in the size of the automata \nspeci.cation means that there could be examples that are simply too costly to implement using bidirectional \nsolving. On theotherhand,wehavelookedata numberoffairlycomplex .nite state properties and have not run \ninto this limitation in practice. In the next subsection, we discuss alternative solver strategies that \ntrade offthe ability to do separate analysis for improved asymptotic complexity. 5. Alternative Solution \nStrategies We have assumed constraint resolution operates by applying reso\u00adlutionrulesinanyorderuntilthesystemissolved.Wecallthisstrat\u00adegy \nbidirectional solving because the constraints are extended either forwards or backwards via transitive \nclosure. Two natural Figure 2. AmachineM withasmall alphabet where |F = M | is large.  alternatives \nare forward solving and backward solving. Consider the constraints f (c) .X .Y. f(Z).Aforwards solver \nonly propagates transitive closure by pushing lower bound sources to\u00adwards upper bound sinks: pushing \nf(c) forwards adds f (c) .Y and discovers f(c) . f (Z).Abackwards solver only applies tran\u00adsitive closure \nby pushing upper bound sinks towards lower bound sources: pushing f(Z) backwards adds X. f(Z) to discover \nthe samefact f(c) . f(Z). Bidirectional solvers can add both new constraints, in anyorder. 5.1 Tradeoffs \nBidirectional solving has two advantages. Bidirectional solving en\u00adables separate analysis, because the \nclosure rules do not need all sources and sinks to be present to solve the available constraints. Arelated \nadvantage is that constraints can be solved online. Uni\u00addirectional solvers defer most processing until \nthe entire constraint graph isbuilt. On the other hand, unidirectional solvers can naturally be made \ndemand driven.Forexample, solving forward froma constant can selectively answer the query For what set \nof variables must this constant appear in every solution? Bidirectional solvers typically compute a representation \nof all solutions prior to the query phase. The choice of solver directionality also affects the complexity \nof constraint resolution. Instead of the domain T Msub , in the forward case we need only consider the \ndomain T Mpre where words are pre.xes of words in L(M). In the forwards case, we relax the congruence \n=M to a right congruence =r: '* ' w =r w ..x . S . wx . L(M) iff wx . L(M) Here, F =r only distinguishes \nfunctions that map s0 to one of the M different |S| states in M,by the following analog of Theorem 2.1: \n'' w = w =. d(w, s0)= d(w ,s0) The construction for the backwards case is symmetric, using a left congruence \nin place of a right congruence. One signi.cant difference from the bidirectional case is that our initial \nannotations are representativefunctions drawn from F = M , while the annotations we derive are drawn \nfrom the coarser F =r . M Notice that the forwards solver always computes new annotations as g . f, \nwhere f . F =r and g . F = MM . Furthermore, the result\u00ading function g . f is always in F =r . In the \nbidirectional case, both M the initial and derived annotations are drawn from F = M .Infact, this is \nprecisely the source of the asymptotic complexity difference be\u00adtween unidirectional and bidirectional \nsolving. In the unidirectional case,weareabletouseacoarserequivalence relation, resultingina much tighter \nbound on the number of possible derived annotations between two set expressions. In general, the complexity \nof annotated constraint solving is O(n 3i2), where i is the number of possible derived annotations. Here, \nwe have shown how to express that number in terms of the number of states of M. In the unidirectional \ncase, i is exactly |S|. In the bidirectional case, i may be as much as |S||S|. Figure 3. Automaton for \nprocess privilege. 6. Application: Pushdown Model Checking In this section, we use regularly annotated \nset constraints to solve pushdown model checking problems.Weshowhowtoverifythe same class of temporal \nsafety properties as MOPS, a model check\u00ading tool for .nding securitybugs inCcode [5].Following the ap\u00ad \nproach of [5], we model the program as a pushdown automata P . Transitions in the PDAare determined by \nthe control .ow graph, and the stack is used to record the return addresses of unreturned function calls.Temporal \nsafety properties are modeledbya .nite state machine M. Intuitively we want to compute the parallel com\u00adposition \nof L(M) and L(P );the program is treated as a generator for this composed language. We use the following \nproperty concerning Unix process priv\u00adilege as a running example: a process should never execute an untrusted \nprogram in a privileged state it should drop all per\u00admissions beforehand. Concretely, if a program calls \nseteuid(0), granting root privilege, it should call seteuid(!0) before calling the execl() function.Aprogram \nthat violates this property may givean untrusted programfull accesstothe system.Figure3shows a .nite \nstate machine that characterizes this property, and the fol\u00adlowingisaCprogram that violates the property: \nseteuid(0); \u00b7\u00b7\u00b7 execl( /bin/sh , sh , NULL); This program gives the user a shell with root privileges, \nwhich probably represents a security vulnerability. 6.1 Modeling Programs with Constraints We now show \nhow to .nd violations of temporal safety properties using annotated constraints.With each statement s \nin the control .ow graph we associate a set constraint variable S.For each suc\u00adcessor statement si of \ns (with constraint variable Si), we adda constraint. The annotations are program statements relevant \nto the security property (i.e., the statements labeling transitions in Fig\u00adure 3). The speci.c form of \nthe constraint depends on s;there are three cases to consider: 1. If s is not relevant to the security \nproperty and is not a function call, add the constraint S.Si. 2. If s is relevant to the security property \n(labels a state transition in the FSM for the security property) add the constraint S.s Si. 3. If s \nis a call to function f at call site i, add the constraints  -1 oi(S) .Fentry and o (Fexit) .Si, where \nFentry (resp. i Fexit)is the node representing the entry (resp. exit) point of function f. To model the \nprogram counter, we createa single 0-ary constructor pc and add the constraint pc .Smain, where Smain \nis the con\u00adstraint variable corresponding to the .rst statement (entry point) of the program s main function. \nf0 : unpriv . priv f2 : unpriv . unpriv priv . priv priv . error error . error error . error f1 : unpriv \n. unpriv ferror : unpriv . error priv . unpriv priv . error error . error error . error Figure 4. A \nfew of the representative functions in F = for the M process privilege model. 6.2 Checking for Security \nViolations To check for violations of the property, we record each statement that could causea transitiontothe \nerror state.Foreachsuch state\u00adment, we query the least solution of the constraints by intersecting with \nan automaton for positive-negative reachability (PN reacha\u00adbility [15]), which allows partially matched \ncall-return paths (e.g., apathfroma callerto calleethatdoesnot returntothe callerispar\u00adtially matched \nbecause it has the constructorbut not the canceling error de\u00ad projection). The presence of an annotated \nground term pc notes a violation of the security property. The ground terms them\u00adselves serve as witness \npaths (in this setting, the sequence of con\u00adstructors in the term represent a possible runtime stack) \nthat leads to the error. 6.3 An Example Consider the followingCprogram: s1: seteuid(0); // acquire privilege \ns2: if(...) { s3: seteuid(getuid()); // drop privilege } else { s4: ... } s5: execl( /bin/sh , sh , \nNULL); s6: ...  This program violates the security property: the programmer has made the common error \nof forgetting to drop privileges on all paths to the execl call. The surface syntax constraints for this \nexample are in the left column below. Translating the example to our internal syntax, we compute the \nset F = and replace word M annotations with representativefunctions in the right column below (relevant \nfunctions are shown in Figure 4): , pc .S1 pc f.S1 S1 .seteuid(0) S2 S1 .f0 S2 S2 .S3 S2 .S3 S2 .S4 S2 \n.S4 S3 .seteuid(!0) S5 S3 .f1 S5 S4 .S5 S4 .S5 S5 .execl(...) S6 S5 .f2 S6 Constraint resolution discovers \nthe following constraint path: , pc f.S1 .f0 S4 .f2 S6 ferror The constraints imply pc is in S6, the \nconstraint variable correspondingto the program point after the execl call, indicating the presence of \na possible security vulnerability. 6.4 Parametric Annotations Pushdown model checking applications sometimes \nrequire a lim\u00adited ability to correlate pieces of data. An excellent example is an analysis that tracks \nthe opening and closing of .les; the automa\u00adton for this analysis is shown in Figure 5. The annotations \nx= Figure 5. Automaton for tracking .le state. s1: int fd1 = open( file1 ,O RDONLY); s2: int fd2 = open( \nfile2 ,O RDONLY); s3: close(fd1 ); s4: ... Figure 6. ExampleCprogram that manipulates .le descriptors. \nopen(...) and close(x) are parametric:thex should be treated as a parameter that should be matched in \nthe open and close calls. In Figure6 we showa simple program that manipulates two .le descriptors fd1 \nand fd2 .Wewould like an analysis that determines that fd2 remainsopenattheendofthe program,butnot fd1 \n.Type systems and data.ow analyses naturally incorporate this kind of information using a type environment \nor symbolic map which can separately track the types of multiple names, and we take a similar approach. \nAdding this capability allows us tofaithfully reproduce the functionality of a particular pushdown model \nchecker, MOPS [4], that we use for our experiments (see Section 8). To separate the states of each of \nthe .le descriptors in the program, the automaton in Figure5 must be instantiated for each possible .le \ndescriptor that occurs in the input program. However, our approach precludes explicit instantiation because \nwe compile awaythe automaton statically,beforetheinput programisavailable (recall Section 4). Instead \nof explicit instantiation, we perform instantiations on\u00adthe-.y by maintaining a substitution environment. \nEssentially, this data structure allows us to lazily construct the product automaton when there are multiple \ninstantiationsofagiven parameter.We.rst explain a simpler version of the data structure that supports \nonly one parameterper automaton.Wethenextendthedata structureto handle multiple parameters. Asubstitution \nenvironmentf maps instantiated parametric an\u00adnotations (storedasa parameter name/labelpair)toa representa\u00adtive \nfunction. The parameter name/label pairs form the domain of the substitution environment, while the representative \nfunctions are the range. Substitution environments havean additional component called a residual, which \nis itself just a representative function. The residual stores any non-parametric transitions that have \noccurred. Here is an example substitution environment f: [(x : fd1 ) . f;(x : fd2 ) . g | rf] This particular \nsubstitution environment contains two entries: one where parameter x is instantiated to fd1 and another \nwhere x is in\u00adstantiated to fd2 . The residual function is rf. The intuition is that this substitution \ntracks two copies of the automation in Figure 5. If any new instantiations are added via composition \n(e.g. (x : fd3 )), the residual rf is incorporated into that instantiation s representa\u00adtive function. \nIn a given substitution environment, the residual has already been incorporated into the existing instantiations. \nThe pre\u00adceding explanation can be formalized by showing the composition f1 : closed . opened f1 = [(x \n: fd1 ) . f1 | fe] opened . opened f2 = [(x : fd2 ) . f1 | fe] f3 = [(x : fd1 ) . f2 | fe] f2 : closed \n. closed opened . closed Figure 7. A few of the representative functions and substitution environments \nfor the .le state example. operation . on substitution environments: (f1 . f2)(i)= f1(i) . f2(i) Notice \nthat these de.nitions gracefullydegradeto the nonparamet\u00adric case if we treat nonparametric annotations \nas empty substitu\u00adtion environments with a residual function given by the represen\u00adtative function for \nthat annotation.We allude to thisby dropping the brackets when writing an empty substitution environment: \ne.g. [ | r] is simply written r. Before discussing how to handle multiple parameters, we walk through \nthe example from Figure 6. 6.4.1 Example In the surface syntax, the programin Figure6resultsin the system \nof constraints shown in the left column below. Internally, the con\u00adstraint system is translated into \nthe system of constraints in the right column(Figure7givesthe de.nitionsoftherelevant representative \nfunctions and substitution environments): f pc . S1 pc , . S1 S1 .open(fd1 ) S2 S1 .f1 S2 S2 .open(fd2 \n) S3 S2 .f2 S3 S3 .close(fd1 ) S4 S3 .f3 S4 These constraints imply pc .f3.f2.f1 S4 where: f3 . f2 . \nf1 = [(x : fd1 ) . f2;(x : fd2 ) . f1|fe]  6.4.2 Multiple Parametric Annotations We previously assumed \na single parametric annotation. In the case of multiple parameters, we need a slightly more complex substitu\u00adtion \nenvironment. Speci.cally, each entry in the environment could bea listof instantiations insteadofa single \ninstantiation.Forex\u00adample, [(x : i ,y : j ) . f;(x : k ) . g | rf] An entry i ina substitutionenvironmentis \ncompatible withanother entry j,writteni . j,if all the common parameter/label pairs agree and i has at \nleast as manyentries as j. By convention, every entry is compatible with the residual. When computing \n. on substitution environments, compatible entries are merged by expanding the entries to contain the \nunion of all the parameter label pairs. If we de.ne f(i) to return the largest entry1 in the domain of \nf that i is compatible with, we can reuse our de.nition of . on substitution environments and the desired \neffect is achieved. 7. Application: Flow Analysis In this section we describe a novel .ow analysis application \nthat uses regular annotations to increase precision. Our motivation is to investigate algorithms for \ncontext-sensitive, .eld-sensitive .ow analysis.AproofbyRepsshowsthe general problemtobe unde\u00adcidable \n[22]. As mentioned previously, the core issue is the arbi\u00ad trary interleaving of two matching properties: \nfunction calls and 1This is unambiguous if two entries have equal length, a larger entry in the domain \nof the substitution environment must also be compatible. -1 G(x)= s G f e1 : s1 G f e2 : s2 tl(s) . \ntl(s ' ) o (tl(s)) . tl(s ' ) (Var) (Pair) (Sub) i (Pos) G f x : s G f (e1,e2)L f s1 \u00d7L s2 s = s ' s \n.i s ' + G f e : s1 \u00d7L s2 G,x : s, f : s . s ' f e : s ' oi(tl(s ' )) . tl(s) s1 .i s3 s2 .i s4 (Proj \ni =1, 2) (Def) - + ' (Neg) (Fun) G f e.i : si G f f(x : t): t = e : s . s ' s .i s ' s1 . s2 .i s3 . \ns4 - + G f e : s f s = s ' G(f)= ss .+ i s ' (Int WL) (Var WL) (Sub) (Inst) aL intL f e : s ' G f fi \n: s ' 1 2 t [[ t tl(s1) .L tl(s1) . 2 L 1 Figure 8. Type rules for polymorphic recursive system. 1 2 \nt ]] t L. 1 tl(s1) L. 2 tl(s2) (Pair WL) s1 \u00d7L s2 returns, and type constructors and destructors.Viewing \nReps re- Figure 9. Constraint generation for polymorphic recursivesystem. sultinatype-based setting,the \nprobleminvolves precisely handling .ow through polymorphic recursive functions and recursive types. Practical \nsolutions to this problem require approximating one or the other matching property. In practice the approach \ntaken almost uni\u00adversally is to approximate function matchings, which is typically done by analyzing \nsets of mutually recursive functions monomor\u00adphically. Our view is that the essence of this approximation \nis reduc\u00ading one matching to a regular language, while precisely model\u00ading the other matching as a context-free \nlanguage. For example, treating recursivefunctions monomorphically reduces the language of calls and \nreturns to a regular language, while leaving the type\u00adconstructor matching language context-free. While \nthis approach can be modeled using annotated set constraints (see Section 7.6), we .rst present a natural \nalternative that models function match\u00adings asacontext-free language, while reducing the type-constructor \nmatchingproblemtoaregular language.Forthis analysis,weapply a previously known reduction strategy to \nmodel context-free lan-  uses of f. Functions must be instantiated before use via the rule (Inst). The \nrule (Sub) permits non-structural subtyping steps, i.e. s and s ' do not need to share the same type \nstructure. The constraint generation rules are shownin Figure9. Onekey aspect of constraint generation \nis that we do not apply constraints downward through types constraints extend only to the top-level constructors.2 \nConstraints between substructures of types are dis\u00adguage reachability of function matchings as a set \nconstraint prob\u00ad lem [15]. We use regular annotations to model regular language reachability of type \nconstructor/destructor matchings. This analysis permits non-structural subtyping constraints.To our knowledge, \nours is the .rst practical attempt to combine poly\u00ad morphic recursion with non-structural subtyping constraints. \n7.1 Source Language The analysis operates on the following source language: e ::= n fd ::= f(x : t ): \nt ' = e | x | fd; fd | (e1,e2) | e.i i =1, 2 | fi e In the function de.nition f(x : t ): t ' = e, f is \nbound within e. For simplicity, the source language does not include useful features such as conditionals, \nmutual recursion or higher-order functions. The analyses presented here can be extended to these features; \nwe omitthemonlyto simplifythe presentation.Weuse t to rangeover unlabeled types (pairs, integers, typevariables, \nand .rst-order func-tions).Types are labeled with setvariables L.We use s to range over labeled types, \nwhich are introducedbya spread operator: spread(t1 \u00d7 t2)= spread(t1) \u00d7L spread(t2) L fresh spread(int)= \nintL L fresh spread(a)= aL L fresh Function tl returns the top-level label of a labeled type.  7.2 Type \nRules and Constraint Generation Figure 8 shows the type system for the polymorphic recursive analysis. \nThe rules for variables, pairs, and pair projection are straightforward. The rule (Def) adds the types \nof the argument variablex and the function f to the environment, allowing recursive covered automatically \nas needed during constraint resolution. 7.2.1 Function Call Matching with Terms We apply a known reduction \nto model the matching of function calls and returns [15]. The result in [21] shows that this is equiva\u00ad \nlent to polymorphic recursive treatment of functions. 7.2.2 Type Constructor Matching with Annotations \nAnnotations are used to model the matching language of type con- Y )P structors and destructors.Forexample,in \n(x X ,y .1Z , the con\u00adstraint X.[1 P models the .ow from the .rst component of the int int pair to the \npair constructor, and the constraint P.]1 Z models the .ow from the pair to the projected result. The \ntwo annotations [1 int should cancel each other, re.ecting the .ow from X int and ]1 to Z via the un-annotated \nconstraint X .Z. While this language of matchings appears context-free,inthe absenceof recursivetypes \nit is not possible for a symbol of the form [it to be followed by an\u00adother of the same symbol without \n.rst encountering a correspond\u00ading ]it symboltocancelthe.rstsymbol.Forthis reasonweneedthe extra t component \non annotations to distinguish pair projection on differentlevelsofthetype.Thus,foragiveninput program,wecan \nplace a bound the longest string of annotations we need consider by the size of the largest type. In \nFigure 10 we show the .nite state 2As noted earlier we could also treat function types as type constructors \nand extend our construction to handle higher-order function types; we treat function types specially \nhere for brevity. pair main (y:int) : \u00df = (1A ,y Y )P ; () : int = (pairi 2B).2V void main() {int a,b; \nfoo1(&#38;a,&#38;b); // constructor o1 foo2(&#38;b,&#38;a); // constructor o2 Figure 11. Non-structural \nsubtyping example. }void foo(int // May x *x, and int *y) {y be aliased? } If this is the whole program, \nx and y clearly cannot be aliased -1 within foo. If the points-to sets themselves are not considered \n- H H HHHHH P 2 AYY [int yyyyyyy 1 [int i o context-sensitively, however, the points-to results contain \npt(x) = pt(y)= {a, b}, and the analysis reports that x and y may alias. In our setting, points-to sets \nare terms where unary constructors encode information about function calls. Our analysis would yield \nHHHHHHH I oi T H 1 ]int 2 BU V ]int yyyyyyy Figure 12. Constraint graph for the program in Figure 11 \n(only relevant edges are shown). automaton for this annotation language when the program s largest type \nis pair(int).Inthe presenceof recursive types, .ow mustbe approximated, for example by replacing annotated \nconstraints on recursive types with empty annotations.  7.3 Answering Flow Queries Toask whetheraparticular \nlabel (sayX ).ows to another label (say Y), the constraint x .X , where x is a fresh constant, is added \nto the system. Then X .ows to Y if x is in every solution of Y. This query yields answers for matched \n.ow, and this approach can be extended to partially-matched reachability through functions using PN reachability \n[15]. 7.4 An Example Consider the program in Figure 11 (from [8]). Non-structural sub\u00adtyping assigns \npair type intY . \u00dfH along with constraint \u00df = intA \u00d7P intY . Figure 12 shows a simpli.ed constraint graph \nfor this program. Flow from B to V is captured by constraints: oi(B) .Y Y.[int 2 P P.H o -i 1(H) .T T.]int \n2 V which imply the relationship B.V.  7.5 Stack-Aware Aliasing The analysis presented in this section \ncan be used to implement context-sensitive, .eld-sensitivealias analysis.An interesting con\u00adsequence \nof this formulation is that an additional dimension of sen\u00adsitivity can be recovered during the alias \nquery phase.Astandard approach to computing aliasing information from a points-to anal\u00adysis is to intersect \nsets of abstract locations an empty intersection indicates that two expressions do not alias. In our \nsetting, we can instead intersect the solutions of two variables and test for empti\u00adness, giving stack-aware \nalias queries. Consider the followingCprogram: the following solution (annotations and downward closure \nelided) representing points-to sets for the above program: X = {o1(a),o2(b)} Y = {o2(a),o1(b)}  Intersecting \nthe solutions for X and Y reveals that there are no common terms; hence the two variables are not aliased. \nThus, the constraint solutions themselves encode context-sensitive points-to sets. While the above example \nis somewhat contrived, stack-aware alias queries allay a real problem: in most alias analyses, the mem\u00adory \nabstraction is based on syntactic occurrences of calls to allo\u00adcation routines (e.g. malloc and new). \nSimple refactorings such as wrapping an allocation function can destroy the precision of the analysis. \nStack-aware alias queries use the call stack to dis\u00adambiguate object allocation sites, yielding yet another \ndimension of precision for context-sensitive alias analysis. While stack-aware queries are not likely \nto be as signi.cant as other recent approaches to context sensitivity (for example, object sensitivity), \nthe bene.t comes with almost no cost, as stack-aware alias queries are encoded in the constraint solutions \nalready. 7.6 A Dual Analysis As mentioned earlier, a more widely used approach to combining context-sensitivity \nand .eld sensitivity is to approximate the lan\u00adguage of function calls and returns by treating mutually \nrecursive functions monomorphically.We note that this analysisis alsoex\u00adpressiblein our framework.Thekeychangeistoswapthe \nrolesof annotations and terms: now annotations [i and ]i model call/return paths to a function call site \ni, and constructors oi(...) and projec\u00ad -1 tions oi (...) model constructing/destructing the ith .eld \nfrom a tuple.We can also take advantage of n-ary constructors to cluster types, so that instead of using \ntwo constructors o1 and o2 to repre\u00adsentthe .rstand second componentsofapair,we usea binary con\u00adstructor \npair to construct a pair, and projections pair-1(...) and pair-2(...) to deconstructa pair. This more \nnatural representation can improve performance, as edge additions that wouldbe discov\u00adered twice using \nunary constructors can be discovered once instead usinga binary constructor.With this approach, the constraint \nsys\u00adtem for the example program in Figure 11 is as follows: .[i BY pair(A, Y) .H HT.]i pair-2(T ) .V \n which implies the desired constraint B.V. 8. Experimental Results We have implemented regularly annotated \nset constraints in the publicly available BANSHEE toolkit [16, 14], which allows the speci.cation of \nprogram analyses using multiple, mixed constraint formalisms[6].Wehave addedsupportfor annotationstoBAN-SHEE \ns existing implementation of the Set sort. Some of the tech\u00adnical details (such as handling projection \nmerging [27] and cycle elimination[7]inthe presenceof annotations) are similarto those addressed in [25]; \nwe omit them here. SinceBANSHEEalready does specialization based onastatically\u00adspeci.ed description of \nthe term constructors used in an analysis, it is very natural to extend specialization to the input .nite \nstate automaton.We have created an annotation speci.cation language whose syntax is loosely based on \nML pattern matching syntax. Forexample,the processprivilege automatonshownin Figure3is speci.ed as follows \nin our language: start state Unpriv : | seteuid zero -> Priv; state Priv : | seteuid nonzero -> Unpriv \n| execl -> Error; accept state Error; This speci.cationis compiledbycomputingthe set F = M and cre\u00adating \na lookup table that implements the . operation. This allows us to compute a new annotation for the transitive \nclosure operation in constant time. At runtime, annotations are represented as sub\u00adstitution environments \nin order to support parametric annotations. Multiple parametric annotations are supported. Our implementation \nomits representative function variables on set expressions completely during constraint solving and instead \ndoes all of the calculations involving these functions during queries (recall Section3.2).Byomitting \nthesevariablesfromthesolverwe can do aggressive hash-consing of terms, and the memory savings from hash \nconsing is substantial. The time and space overhead needed to implement the operations in the transitive \nclosure rule is minimal, since function composition is reduced to table lookups by the specializer. To \nillustrate the viability of our approach, we have reproduced some experiments .rst done using MOPS. We \nchose to examine the applications of MOPS because pushdown model checking is super.cially very different \nfrom the usual applications of set con\u00adstraints. We chose a security property (Property 1 from [4]) and \nchecked several sensitive software packages for security violations using the approach outlined in Section \n6. The property we checked is a complete model of the simple process privilege property de\u00adscribed in \nSection 6. The complete model contains 11 states and 9different alphabet symbols. It is the most complex \nproperty and largest automaton reported in [4]. This property demonstrates that, in practice, the representative \nfunction sets may not exhibit worst case size while the set F = M could contain millions of elements \nfor an 11 state automaton, in this case there are only 58 distinct repre\u00adsentative functions. We reportinTable1the \nnumberof linesofcode for each pack\u00ad age, the number of executables for each package, and the time to \ncheckthe propertyfortheexecutablesinthepackageforbothBAN-SHEE and MOPS.3 Each executable in a package \nis checked sepa\u00adrately. Our analysis times show that our algorithm s scalability and performance is very \ngood, and that the bidirectional solver is us\u00adable for realistic applications. Performance is even better \nconsider\u00ad 3Theexperimentwas performed ona2.0 GHz Intel Core Duo machine with 512 Mb of memory. Benchmark \nSize Programs BANSHEE (s) MOPS (s) VixieCron 3.0.1 At 3.1.8 Sendmail 8.12.8 Apache 2.0.40 4k 6k 222k \n229k 2 2 1 1 .52 .52 2.3 .6 .57 .62 5.1 .7 Table 1. Benchmark data for process privilege experiment. \n ing that MOPS uses signi.cant hand-coded optimizations external to the core push-down model checker. \nIn particular, for improved performance MOPS .rst slices the program to extract the security\u00adrelevant \nportion in a pre-pass, resulting in a much smaller program to be checked by the push-down implementation, \nwhereas our im\u00adplementation simply generates and solves constraints for the entire program. 9. Related \nWork Regularly annotated set constraints generalize the annotated inclusion constraints presented in \n[25, 19]. We have shown how to incorporate in.nite regular languages as annotations, and we believe that \n.nite state automata are a more natural speci.cation language for annotations than the concat and match \noperators usedin priorwork.We also believe that the annotation languages used in [19] can be expressed \nin terms of .nite state automata. Parametricregularpath queries areadeclarativewayof specify\u00ading graph \nqueries as regular expression patterns [18]. Regular path queries are not as powerful as set constraints, \nthough the use of parameters to correlate related data may be a useful addition. The combination of polymorphic \nrecursion and non-structural subtyp\u00ading was .rst considered in [8]. The solution proposed in [8] has \nthe disadvantagethat polymorphismondatatypesisachievedbycopy\u00ading constraints. While there is no implementation \nof this algorithm, the general experience with constraint-copying implementations is that they are slow \n[9].For this reason we consider our approach, which relies on regular annotations rather than copying \nconstraints for polymorphism, to be a more practical algorithm for this class of analyses. However, our \nresults also suggest that a bidirectional solver is unlikely to scale for this problem, as the number \nof states of the DFA grows at least with the size of the largest type in the program being analyzed.We \nbelievea whole-program analysis us\u00ading a forwards or backwards solver (in the style of [11]) would scale; \nunfortunately BANSHEE includes only bidirectional solvers and currently no forwards or backwards solvers \nfor set constraints are publicly available. Weighted pushdown systems (WPDS) label transitions withval\u00adues \nfrom a domain of weights [24]. Weighted pushdown reacha\u00ad bility computes the meet-over-all-paths value \nfor paths that meet certain properties. WPDS have been used to solve various inter\u00adprocedural data.ow \nanalysis problems the weight domains are general enough to compute numerical properties (e.g., for constant \npropagation), which cannotbeexpressed using our annotations.On the other hand, WPDS focus on checkinga \nsingle,butextended, context-free property,while annotated constraints naturallyexpress a combination \nof a context-free and anynumber of regular reacha\u00adbility properties. The exact relationship between WPDS \nand regu\u00adlarly annotated constraints is not clear. Binary Decision Diagrams (BDDs) have been successful \nas an alternative to graph reachability for program analysis applications [28, 17]. BDD-based algorithms \nhave exponential worst-case com\u00ad plexity, whereas annotated set constraints can be solved in polyno\u00admial \ntime (but only using forwards or backwards solvers). Also, at leastto date BDD-based approacheshave not \nbeen integrated with context-free properties. 10. Conclusion We have described a formalism that extends \nset constraints with annotations drawn fromaregular language, allowing theexpression of reachability \nproblems involving simultaneous context-free and regular properties. We have shown how to express applications \nas diverse as type-based .ow analysis, interprocedural data.ow analysis, and pushdown model checking. \nReferences [1] A. Aiken, M.F\u00a8 A toolkit for ahndrich, J. Foster, and Z. Su. constructing type-and constraint-based \nprogram analyses. In Proc. of the Second International Workshop on Types in Compilation, 1998. [2]A.Aiken,D.Kozen,M.Vardi,andE.Wimmers. \nThe complexityof set constraints. In Proc. of the 7th Workshop on Computer Science Logic, pages 1 17. \nSpringer-Verlag, 1994. [3] R. Alur andP. Madhusudan. Visibly pushdown languages. InProc. of the Symp. \non Theory of Computing, pages 202 211, 2004. [4] H. Chen,D. Dean, andD.Wagner. Model checking one million \nlines ofC code. In Proc. of the 11th Annual Network and Distributed System Security Symp., pages 171 \n185, Feb. 4 6, 2004. [5] H. Chen andD.Wagner. MOPS:An infrastructure forexamining security properties \nof software. In Proc. of the 9th ACM Conf. on Computer and Communications Security, pages 235 244, 2002. \n[6] M.F\u00a8 Program analysis using mixed term ahndrich and A. Aiken. and set constraints. In Proc. of the \n4th International Symp. on Static Analysis, pages 114 126. Springer-Verlag, 1997. [7]M.F\u00a8ahndrich,J.Foster,Z.Su,andA.Aiken. \nPartial onlinecycle elimination in inclusion constraint graphs. In Proc. of the Conf. on Programming \nLanguage Design and Implementation, pages 85 96, June 1998. [8] M.F\u00a8ahndrich, J. Rehof, and M. Das. From \npolymorphic subtyping to c. reachability: Context-sensitive .ow analysis using instantiation constraints. \nTechnical Report MSR-TR-99-84, Microsoft Research, 1999. [9] J.Foster, M.F\u00a8ahndrich, and A. Aiken. Polymorphicversus \nMonomorphic Flow-insensitive Points-to Analysis for C. In Proc. of the Static Analysis Symposium, pages \n175 198, June 2000. [10] N. Heintze. Set Based Program Analysis. PhD dissertation, Carnegie Mellon University, \nDepartment of Computer Science, Oct. 1992. [11] N. Heintze and O.Tardieu. Ultra-fast aliasing analysis \nusing CLA: A million lines of c code in a second. In Proc. of the Conf. on Programming Language Design \nand Implementation, pages 254 263, 2001. [12] S. Horwitz, T. Reps, and M. Sagiv. Demand interprocedural \ndata.ow analysis. In Proc. of the Symp. on Foundations of Software Engineering, pages 104 115.ACM Press, \n1995. [13]T. Jensen,D.L. Metayer,andT. Thorn.Veri.cationof control.ow based security properties. In \nProc. of the 1999 IEEE Symp. on security and Privacy, 1999. [14] J.Kodumal. Banshee:A toolkit for constructing \nconstraint-based analyses. http://banshee.sourceforge.net, 2005. [15] J. Kodumal and A. Aiken. The set \nconstraint/CFL reachability connection in practice. In Proc. of the Conf. on Programming Language Design \nand Implementation, pages 207 218, 2004. [16] J. Kodumal and A. Aiken. Banshee: A scalable constraint-based \nanalysis toolkit. In Proc. of the 12th International Static Analysis Symposium, pages 218 234, Sept. \n2005. [17]O. Lhot\u00b4akandL. Hendren. Jedd:ABDD-based relationalextension of Java. In Proc. of the Conf. \non Programming Language Design and Implementation, 2004. [18]Y.A.Liu,T. Rothamel,F.Yu,S.D. Stoller,andN.Hu.Parametric \nregular path queries. In Proc. of the Conf. on Programming Language Design and Implementation, 2004. \n[19] A. Milanovaand B. Ryder. Annotated inclusion constraints for precise .ow analysis. In IEEE International \nConf. on Software Maintenance, Sept. 2005. [20] J.Palsberg. Ef.cientinference of object types. Information \nand Computation, (123):198 209, 1995. [21] J. Rehof and M. F\u00a8ahndrich. Type-based .ow analysis: From \npolymorphic subtyping to CFL-reachability. In Proc. of the Symp. on Principles of Programming Languages, \npages 54 66, Jan. 2001. [22] T. Reps. Undecidability of context-sensitive data-dependence analysis. In \nACM Trans. Prorgram. Lang. Syst., volume 22, pages 162 186, 2000. [23] T. Reps, S. Horwitz, and M. Sagiv. \nPrecise interprocedural data.ow analysis via graph reachability. In Proc. of the Symp. on Principles \nof Programming Languages, pages 49 61, Jan. 1995. [24] T. Reps, S. Schwoon, and S. Jha. Weighted pushdown \nsystems and their application tointerprocedural data.ow analysis. In Proc. 10th Int. Static Analysis \nSymp., pages 189 213, 2003. [25] A. Rountev, A. Milanova, and B. Ryder. Points-to analysis for Java using \nannotated constraints. In Proc. of the Conf. on Object-Oriented Programming, Systems, Languages, and \nApplications, pages 43 55, 2001. [26] M. Sridharan, D. Gopan, L. Shan, and R. Bodik. Demand-driven points-to \nanalysis for Java. In Proc. of the Conf. on Object-Oriented Programs, Systems, Languages, and Applications, \n2005. [27] Z. Su, M.F\u00a8ahndrich, and A. Aiken. Projection merging: Reducing redundancies in inclusion \nconstraint graphs. In Proc. of the Symp. on Principles of Programming Languages, pages 81 95, 2000. [28] \nJ. Whaleyand M. Lam. Cloning-based context-sensitive pointer alias analysis using binary decision diagrams. \nIn Proc. of the Conf. on Programming Language Design and Implementation, June 2004.    \n\t\t\t", "proc_id": "1250734", "abstract": "<p>A general class of program analyses area combination of context-free and regular language reachability. We define <i>regularly annotated set constraints</i>, a constraint formalism that captures this class. Our results extend the class of reachability problems expressible naturally in a single constraint formalism, including such diverse applications as interprocedural dataflow analysis, precise type-based flow analysis, and pushdown model checking.</p>", "authors": [{"name": "John Kodumal", "author_profile_id": "81100523487", "affiliation": "UC Berkeley and Coverity: Inc., Berkeley, CA", "person_id": "P517413", "email_address": "", "orcid_id": ""}, {"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "Stanford University, Stanford, CA", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250772", "year": "2007", "article_id": "1250772", "conference": "PLDI", "title": "Regularly annotated set constraints", "url": "http://dl.acm.org/citation.cfm?id=1250772"}