{"article_publication_date": "06-10-2007", "fulltext": "\n A General Framework for Certifying Garbage Collectors and Their Mutators Andrew McCreight Zhong Shao \nChunxiao Lin Long Li Department of Computer Science Yale University New Haven, CT 06520-8285, U.S.A. \n {aem, shao}@cs.yale.edu Abstract Garbage-collected languages such as Java and C# are becoming more \nand more widely used in both high-end software and real\u00adtime embedded applications. The correctness of \nthe GC implemen\u00adtation is essential to the reliability and security of a large portion of the world s \nmission-critical software. Unfortunately, garbage collectors especially incremental and concurrent ones \nare ex\u00adtremely hard to implement correctly. In this paper, we present a new uniform approach to verifying \nthe safety of both a mutator and its garbage collector in Hoare-style logic. We de.ne a formal garbage \ncollector interface general enough to reason about a variety of algorithms while allowing the mutator \nto ignore implementation\u00adspeci.c details of the collector. Our approach supports collectors that require \nread and write barriers. We have used our approach to mechanically verify assembly implementations of \nmark-sweep, copying and incremental copying GCs in Coq, as well as sample mutator programs that can be \nlinked with any of the GCs to produce a fully-veri.ed garbage-collected program. Our work provides a \nfoundation for reasoning about complex mutator-collector interac\u00adtion and makes an important advance \ntoward building fully certi.ed production-quality GCs. Categories and Subject Descriptors F.3.1 [Logics \nand Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams; D.2.4 [Software Engineering]: \nSoftware/Program Veri.ca\u00adtion correctness proofs, formal methods General Terms Languages, Veri.cation \nKeywords Garbage Collection, Abstract Data Type, Assembly Code Veri.cation, Separation Logic, Proof-Carrying \nCode 1. Introduction Type-safe programming languages with automatic memory man\u00adagement such as Java \n[15] and C# [21] allow the automatic veri\u00ad.cation of basic program properties, improving software security \nand reliability. However, implementations of these languages are not truly safe unless their entire runtime \nsystems, including their garbage collectors, are safe. Because of this, errors in the GC can Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 07 June 11 \n13, 2007, San Diego, California, USA. Copyright c . 2007 ACM 978-1-59593-633-2/07/0006. . . $5.00 Department \nof Computer Science and Technology University of Science and Technology of China Hefei, Anhui 230026, \nChina {cxlin3, liwis}@mail.ustc.edu.cn lead to security problems. This is especially bad because garbage \ncollectors are often used when running untrusted code. Unfortunately, garbage collectors especially incremental \nand concurrent ones are extremely hard to implement correctly. Bugs can be caused by incorrect interaction \nof the collector and the mutator or the violation of complex unstated invariants. These bugs are also \noften dif.cult to .nd and .x. This is not merely a theoretical concern last year, GC-related bugs were \n.xed in the Mozilla and Internet Explorer web browsers which had the possibility of allowing remote attackers \nto run arbitrary code [34, 36], due to either the violation of a mutator invariant or an incorrect garbage \ncollector implementation. The importance of correct garbage collector implementation will only grow as \nmore system critical code is written in garbage collected languages. For instance, the Singularity Project \n[22] is working on building an operating system using as much managed code as possible. As efforts like \nthis and the Verisoft Project [38] check more of the operating system kernel, garbage collectors will \nmake up an increasing portion of possibly unsafe code, if left unveri.ed. Formally verifying the safety \nof the mutator, the garbage col\u00adlector, and the interaction between them in a single system will improve \nthe reliability of systems with automated memory man\u00adagement. This is because we will only need to trust \na proof checker and de.nitions of the machine s behavior and safety, not the imple\u00admentation of the mutator \nor garbage collector. Java and C# programs run on a wide variety of computing plat\u00adforms ranging from \nsmall embedded devices, to multi-core ma\u00adchines, to large-scale parallel computers. To support these \npro\u00adgrams ef.ciently and reliably on different platforms, the underlying run time system will likely \nprovide a variety of garbage collectors, and we must be able to reason about all of them. In this paper, \nwe present a powerful new framework for reason\u00ading about general mutator-collector interfaces and building \ncerti.ed garbage collectors. We have used our framework to mechanically verify the safety of assembly \nlanguage implementations of mark\u00adsweep, Cheney copying and Baker incremental copying collectors. While \nthere has been much previous work on garbage collector ver\u00adi.cation (such as [11, 3, 41, 19, 4, 44, 30, \n20]), our system formal\u00adizes GC safety in a way that allows separate veri.cation of both the mutator \nand the collector by abstracting away implementation\u00adspeci.c details of the collector from the mutator, \nwhile still allow\u00ading veri.cation of partial correctness. We show how this approach is used in a Hoare-style \nlogic, using a MIPS-like abstract machine. After we present the general methodology, we discuss how to \napply it to verify a mutator program and the assembly-code implementa\u00adtion of a few standard GC algorithms \nincluding an incremental copying collector that requires a read barrier. We view the veri.\u00ad mutator \nGC read write allocate  Figure 1. High level view of mutator and GC as threads cation of incremental \ncollectors, which are .ner grained than stop\u00adthe-world collectors, as a stepping stone towards our ultimate \ngoal of verifying concurrent collectors, which are notoriously dif.cult to implement correctly [11]. \nOur paper builds upon previous work on program veri.cation but makes the following new contributions: \n As far as we know, our work is the .rst to successfully cer\u00adtify the real machine-level implementation \nof mutator programs together with a variety of standard garbage collectors. Doing our veri.cation at \nthe assembly level on real code forces us to address every aspect of the mutator-collector interaction \nin\u00adcluding read and write barriers and other low-level operations which are often abstracted away at \nthe source level. Our sys\u00adtem is fully mechanized in Coq [10] and can be directly used to construct foundational \nproof-carrying code [1]. Our implemen\u00adtation is available at [29].  In fact, as we ll show later in \nthe paper, our framework can cer\u00adtify the mutator-collector interface for many different GC al\u00adgorithms. \nThe properties veri.ed about the GC can range from simple type safety to partial correctness, allowing \nthe GC to be used with mutator programs with different correctness re\u00adquirements. Our thread-centric \nview of GC safety also extends naturally to the concurrent setting.  More speci.cally, we introduce \ntwo novel concepts an ab\u00adstract state representation predicate repr and a garbage collec\u00adtor behavior \nrelation gcStep to help de.ne a uniform and gen\u00aderal mutator-collector interface. The repr predicate \nrelates an abstract state seen by the mutator to its concrete binary rep\u00adresentation seen by the collector. \nThe gcStep relation speci.es the high-level behavior of the garbage collector. We show that these concepts \ncapture the essence of mutator-collector interac\u00adtion even in the presence of read and write barriers. \n As far as we know, our work is the .rst mechanized veri.cation of the Baker incremental copying garbage \ncollector.  Our intention is to support languages like Java and C# as mutators using a GC-aware certifying \ncompiler that emits typed assembly language (TAL). Prior work describes how to translate Java-like languages \ninto TAL [9] and how to represent TAL using our style of program logic [12]. In addition, Lin et al. \nhave demonstrated how to represent TAL within our garbage collection framework [27]. The rest of this \npaper is organized as follows: we .rst discuss the generic interface using examples and then describe \nthe abstract machine and its program logic. We then present the generic inter\u00adface in more detail, giving \nspeci.cations for the interface of the collector, and some abstract guarantees for GCs. In Section 5, \nwe discuss the speci.cation and veri.cation of an example. Section 6 discusses the speci.cations of the \nheaps for some actual GCs. In Section 7 we discuss our Coq implementation. Finally, we discuss related \nwork and conclude.  2. A general garbage collector interface There are a wide variety of garbage collection \nalgorithms [26], which interact in a variety of ways with mutators. At the same listSum (word* list) \n{ int sum = 0; while (list != NULL) { sum += first(list); list = second(list); } return sum; } Figure \n2. Example mutator root Figure 3. Abstract heap time, there are a range of properties about the mutators \nwe may wish to verify, from type safety to partial correctness. Informally, we can think of the mutator \nand the garbage collector as two separate threads, interacting via a .xed number of operations, as illustrated \nin Figure 1. Each of these threads has its own view of the machine, which we want to formalize. 2.1 Basic \noperations Three basic operations comprise the mutator s interface with the object heap, and thus the \ngarbage collector: the mutator can read the .eld of an object, write a new value to a .eld of an object, \nor allocate a fresh object. We also refer to reads and writes as read barriers and write barriers. Collection \nmay occur during any of these operations, depending on the algorithm. Consider the pseudo code program \nlistSum in Figure 2 that sums up a linked list. We will use this as a running example. The procedure \ntakes a single argument list that is a linked list. It loops through the list, adding the value stored \nin each element, until it reaches the end. The fourth and .fth lines of this procedure use read barriers \nto retrieve the .rst and second .elds of list. For the purposes of this paper, we will be attempting \nto verify that this procedure correctly computes the sum of the list in the presence of garbage collection. \n 2.2 Abstract and concrete states By looking at the implementation of one of these operations in a particular \ncollector we can develop a speci.cation given in terms of the gritty garbage collector machinery, but \nthe entire purpose of read and write barriers is to allow the mutator to go about its busi\u00adness without \nconcern for the cruel realities of the world. It would be a shame if we had to give that up simply because \nwe want to mechanically verify our programs. To avoid this, we make explicit the white lies the collector \ntells the mutator. Instead of having the mutator reason about the harsh concrete state that is the actual \nheap and registers of the machine our program is running on, we permit it to primarily reason about a \nhigher level abstract state. Because different collectors can have the same abstract interface, we can \nverify a mutator once and combine it with different collectors. The abstract state corresponds to what \ncan be observed of the concrete state using only the basic operations given in Sec 2.3. In Figure 3, \nwe give an example of an abstract state. For sim\u00adplicity, in this section we will refer to an object \ncontaining a value n in the .rst .eld as object n. The root points to a cyclic linked list containing \nthe objects 1, 3 and 5. Object 7 is unreachable and points Figure 4. Baker collector concrete heap to \nobject 5. This is the sort of view we want the mutator to have, where, say, dereferencing the second \n.eld of object 5 will give us a pointer to object 1. If we allocate a new object, a fresh object is produced, \nbut the mutator doesn t care where it came from. Next, consider Figure 4, where we give a possible concrete \nrep\u00adresentation of this abstract heap in a Baker collector [2]. One differ\u00adence from the abstract heap \nis that we have a block of memory that f ree points to, where new objects are allocated from. But there \nare more differences than that. The Baker collector is an incremental copying collector (discussed in \nmore detail in Section 6.3), which means that collection is done by copying all reachable objects from \none area (the from-space) to another (the to-space), and further that this copying is done a little bit \nat a time, so the mutator may run in a state where the heap has been only partially copied. In this example, \nobject 1 has been copied from the from-space to the to-space, and its .elds have been updated (it is \na black object), and object 3 has been copied to the to-space, but its .elds have not been updated (it \nis a gray object). Finally, objects 5 and 7 have not been copied (and are thus white objects). Assigning \nthese classes of objects these 3 colors is known as the tricolor abstraction [11]. In addition to these \nobjects, we also have the original copies of objects 1 and 3, which contain, in their .rst .elds, pointers \nto the new locations of these objects. We call these map objects. Object 1 points to a to-space object, \nwhile objects 3, 5 and 7 still point to from-space objects, Object 5 points to the old copy of object \n1. If the mutator could suddenly load the value of the second .eld of object 5, then load the .rst .eld \nof that object, it would be able to discover the GC is lying because the value would be a pointer, and \nnot 1 as expected. We must carefully construct our interface to prevent this, and require that all interaction \nwith the object heap occurs through read or write barriers. In our example, we have seen three types \nof abstraction. First, there is the simple hiding of heap data: the collector knows about the free block \n(and will update it as objects are allocated and col\u00adlected), but the mutator does not. Second, constraints \non the object heap are hidden: the collector knows that objects 5 and 7 are in the from-space and objects \n1 and 3 are in the to-space, but the mutator does not. Finally, and perhaps most dramatically, the state \nof the ob\u00adjects or even the roots may differ between views: in our example, the mutator and collector \ndo not agree, for instance, on the value of the second .eld of object 5. This last type of abstraction \nis not needed for stop-the-world or non-copying incremental collectors.  2.3 The collector interface \nTo allow the mutator to reason about the abstract level, we must create an abstract garbage collector \ninterface. This interface has three parts: Figure 5. High level view of GC interface  Figure 6. Connecting \ncollector and mutator 1. the abstract speci.cation of each operation, including the be\u00adhavior (given \nby readStep, writeStep and allocStep), along with the speci.cation of the actual collection, again at \nthe abstract level, which is given by a binary state predicate gcStep 2. a representation predicate \nrepr that de.nes the representation of an abstract state within a concrete state, along with rules to \nallow some manipulation of the state 3. an embedding function that transforms an abstract speci.cation \nto a concrete speci.cation using repr  We show how the interface is related to the concrete behavior \nof the machine in Figure 5. The top box contains the series of abstract states seen by the mutator. Edges \ncorresponding to GC activity are labeled with the abstract speci.cation of that action, while unlabeled \nedges represent mutator activity. The abstract behavior of the allocator (allocStep) is given in terms \nof the abstract behavior of the collector (gcStep). We can change gcStep depending on the property of \nthe mutator, such as type safety or partial correctness, that we wish to verify. The lower box contains \nthe series of concrete states of the actual execution of the program, and corresponds to the diagram \nshown in Figure 1. The speci.cation of the concrete behavior of the GC is derived from the abstract behavior \nby the function lJ, de.ned in Section 4.3. For example, the concrete behavior of the read barrier is \nlreadStepJ. Each abstract state in the upper box is related to a concrete state in the lower box by the \nrelation repr. If at a given point in the execution the abstract state is A and the concrete state is \nS, then the relation repr SA holds. A key point is that the mutator only needs to know a few basic properties \nof repr, not its de.nition.  2.4 Connecting the collector and the mutator We want to be able to separately \nverify the mutator and the col\u00adlector. This goal affects how each part is veri.ed and how they are combined. \nFigure 6 gives an overview of this process. The collec\u00adtor and the mutator are each veri.ed separately. \nThe collector is shown to match some interface, while the mutator assumes there is a collector with some \nother interface. The two interfaces are then (Program) P ::=(C, S, I) (CodeHeap) C ::= { f \" I}* (State) \nS ::=(H, R) (Heap) H ::= {l , w}* (RegFile) R ::= {r \" w}* {rk}kE{0...31} (Reg) r ::= (Nat) w, f ::= \n0 | 1 | 2 | ... (Addr) l ::= 0 | 4 | 8 | ... (InstrSeq) I ::= c;I | beq rs, rt , f ;I | bne rs, rt , \nf ; I | j f | jal f , fret | jr rs (Command) c ::= addu rd, rs, rt | addiu rd, rs, w | subu rd, rs, \nrt | sltu rd, rs, rt | andi rd , rs, 1 | lw rd, w(rs) | sw rs, w(rd) Figure 7. Machine Syntax shown to \nbe compatible using a lemma, which allows the two veri\u00ad.ed components to be combined into a veri.ed program. \nIn more detail, to verify the mutator, we select a gcStep that suits the needs of the mutator, which \nwill simplify reasoning and allow the mutator to be combined with more collectors. We also do not pick \na particular heap representation repr. Instead, we parameterize our veri.cation of the mutator by a representation, \na few standard properties of that representation, and a veri.ed collector implemen\u00adtation (including \nthe read and write barriers) that uses that represen\u00adtation. In Coq, this can be done using a functor. \nLater, we can in\u00adstantiate a veri.ed mutator with any veri.ed collector that matches the speci.cation \nto produce a fully veri.ed implementation. The mutator can only access the garbage collected heap using \nthe barriers because the actual representation is hidden from the mutator, but the soundness of our approach \ndoes not rely on this: if a mutator is veri.ed in terms of a speci.c repr, the soundness of the underlying \nprogram logic keeps the mutator from calling the collector unless the heap is well-formed. Verifying \nthe collector is more straightforward: we select a gcStep speci.c to the style of GC, and verify it as \nyou would any program. The abstract speci.cations of each collector must be the same as that of the mutator, \nmodulo the choice of gcStep. When it comes time to link the collector and the mutator, we must .rst coerce \nthe collector to match the speci.cation expected by the mutator. We can show that if a GC implements \nthe interface with some gcStep, and that any time we take a gcStep we also take a gcStep , then the GC \nalso implements the interface with gcStep . In the Coq implementation, this fact is embodied by a functor \nthat takes a collector with one interface along with a proof of compatibility with another interface \nand produces a collector with the second interface. Using this, we convert the GC to use the mutator \ns interface, without having to reverify the entire collector. After the collector has been coerced, it \ncan be combined with the mutator to produce an entire veri.ed program. We will discuss more details of \nthis approach after we have described the system we use to reason about programs.  3. Preliminaries \nBefore we can describe our approach in detail, we must present the formal setting, based on existing \nwork, that we are using. This has three parts: the abstract machine, the program logic SCAP, and separation \nlogic, used to reason about heaps. 3.1 Machine The abstract machine we use is a MIPS-like architecture. \nThe syntax is given in Figure 7. A program P is a code heap, a state, (C, S, I) .--P where if I = then \nP = c;I' (C, S' , I') if Nextc(S) = S' beq rs, rt , f ;I' (C, S, C( f )) if S(rs) = S(rt ) (C, S, I') \notherwise bne rs, rt , f ;I' (C, S, C( f )) if S(rs) .= S(rt ) (C, S, I') otherwise j f (C, S, C( f )) \njal f , fret (C, S{r31 . fret }, C( f )) jr rs (C, S, C(S(rs))) where if c = then Nextc(S)= addu rd, \nrs, rt S{rd . S(rs)+ S(rt )} addiu rd , rs, w S{rd . S(rs)+ w} subu rd, rs, rt S{rd . S(rs) - S(rt )} \nS{rd . k} if S(rs) < S(rt ), k = 1, else k = 0 sltu rd , rs, rt S{rd . k} if S(rs) is odd, k = 1, else \nk = 0 andi rd , rs, 1 lw rd , w(rs) S{rd . S(S(rs)+ w)} sw rs, w(rd ) S{(S(rd)+ w) . S(rs)} if (S(rd)+ \nw) . dom(S) Figure 8. Machine step (Prop) P ::= ... (SPred) p . State . Prop (Guar) g . State . State \n. Prop (BlockSpec) G ::=( p, g) (CodeHeapSpec) . ::= { f : G}* A ::= S Figure 9. Speci.cation syntax \nand an extended basic block. The basic block takes the place of a program counter, which simpli.es the \noperational semantics. A code heap C maps natural numbers to instruction sequences. A state is a heap \nand a register .le. A heap is a partial mapping of addresses to words, while a register .le is a partial \nmapping of registers to words. There are 31 registers. Register r0 always has the value 0. A nat or word \nis any natural number, while an address is any natural number that is a multiple of 4. An instruction \nsequence I is an extended basic block, and is either a command followed by another instruction sequence, \na branch to f if rs is equal to rt , a branch to f if rs is not equal to rt , a jump to block f , a call \nto the function at f (returning to fret ), or an indirect jump to the address stored in register rs. \nA command c is either an unsigned addition of a register and a register or a constant, the subtraction \nof two registers, the less-than comparison of registers rs and rt , the bitwise-and of a register with \n1, a load, or a store. The machine has a standard small step dynamic semantics, given in Figure 8. The \nstep relation P .-. P * says that P steps to P *. Nextc(S) is the state that results from executing a \nnon-control .ow command c in state S, if one exists. We write X(z) for the binding of z in any partial \nmap X when z is in the domain of X, and X{z \" v} for the addition of a binding of z to v (where an old \nbinding of z, if any, is removed), for various X and z. We write (H, R)(r) for R(r) and (H, R)(l) for \nH(l). We write (H, R){l , w} for (H{l \" w}, R) and (H, R){r \" w} for (H, R{r \" w}). We write (H, R) for \nH or R, when it is obvious from context. We de.ne dom(H, R)= dom(H) U dom(R). dom(H) is the domain of \nH, while dom(R) is the domain of R. 3.2 Program logic To reason about programs, we use the Hoare-logic-based \nlanguage SCAP (for Stack-based Certi.ed Assembly Programming) [13]. An assembly program that is valid \nin SCAP will run forever without, . P ok (Well-formed program) ' . C : ' p S ';(p, g) . I ok . (C, S, \nI) ok ' . (g S) WFST (PROG) '' . C : ' (Well-formed code heap) V f . dom('). '' ;'( f ) . C( f ) ok '' \n. C : ' (CDHP) ' . p WFST (Well-formed call stack) VS. p S -False ' . p WFST (BASE) '( f ) = (p, g) VS. \np0 S -S(r32) = f . p S ' . ('S ' . 3S. p0 S . g S S ' ) WFST (FRAME) ' . p0 WFST ';c . I ok (Well-formed \ninstruction sequence) ' ' ';(p , g ' ) . I ok VS. p S -3S ' .NextcS = S ' . p S ' . VS '' S ' S '' . \ng ' -g SS '' (SEQOK) ';(p, g) . c;I ok ';(p '' '( f )=(p ' , g ' ) , g '' ) . I ok (iop, op) .{(beq, \n=), (bne, . =)} VS. p S \u00ad (BROK) (S(rs) op S(rt ) -p ' S .VS ' . g ' SS ' -g SS ' ) . . g '' (\u00acS(rs) \nop S(rt ) -p '' S .VS ' SS ' -g SS ' ) ';(p, g) . iop rs, rt , f ;I ok ' ' ' '( f )=(p , g ' ) VS. p \nS -p S .VS ' . g SS ' -g SS ' (J) ';(p, g) . j f ok ' '' '' ) '( f )=(p , g ' ) '( fret )=(p , g VS. \np S -p ' S{r31 fret }.VS ' . g ' S{r31 fret } S ' \u00adp '' . g '' S ' S '' S ' .VS '' -g SS '' (CALL)VS, \nS ' . g SS ' -S(r31)= S ' (r31) ';(p, g) . jal f , fret ok VS. p S -g SS (RETURN) ';(p, g) . jr ra ok \nFigure 10. Typing rules for SCAP for instance, trying to load from an invalid memory address. We use \nSCAP to verify our mutators and collectors. With the power of SCAP and other CAP-style systems [45, 12] \n(which can be integrated with SCAP), our framework can be directly applied to support a wide range of \nmutator languages. The speci.cation syntax is given in Figure 9. Propositions P are propositions in the \nCalculus of Inductive Constructions (CIC) [39], a higher order predicate logic extended with inductive \nde.nitions. A state predicate p describes a single state, while a guarantee g relates a pair of states. \nState predicates are used to specify the precondition of an instruction block, which ensures that executing \nthe instruction block is safe. Guarantees describe the behavior of an instruction block by relating the \ncurrent state to the state in which the current procedure returns. An instruction block speci.cation \nG is a precondition and a guarantee. A code heap speci.cation . gives a speci.cation for each instruction \nblock in the code heap. The inference rules for SCAP are given in Figure 10. There are four judgments \nfor static checking in SCAP. . P ok holds if P is well-formed. For this to hold, the code heap must be \nclosed, a pre\u00adcondition p must hold on the current state, the current instruction sequence must be safe \nto execute assuming p and have a guarantee g. Finally, the stack must be well formed assuming g holds \non the current state. .* . C : . holds if C implements the speci.cations in ., assuming code with specs \n. is available. The rule for this judg\u00adment simply checks that each spec in . is properly implemented \nby the corresponding code block. . . p WFST holds if any state that satis.es p implies a well\u00adformed \ncall stack in which is okay to immediately return. If this precondition cannot be satis.ed by any state, \nthen this is a top\u00adlevel function that cannot be returned from. Otherwise, the precon\u00addition must imply \nthat the return register contains some return code pointer f of a function that has a speci.cation ( \np, g). The current state must satisfy the p, to allow the function to return, and when f has .nished \nexecuting, it is okay to return once more. Finally, .; G . I ok holds if, assuming code with specs . \nis available, sequence I matches speci.cation G. These rules each ensure that it is safe to take a step \nand that the guarantee correctly describes the behavior of the function until a return is executed. In \nthe RET rule, p must imply that g holds with the current state as both arguments. A typical g for this \nrule speci.es that the two states are equal. For the call rule, we must ensure that it is safe to call \nthe function f , and that it will be safe to call fret after we return from f . In addition, we require \nthat the behavior of the call instruction combines the behavior of the functions f and fret . The soundness \ntheorem for SCAP states that a well-formed program can always take a step to another well-formed program. \n 3.3 Separation logic We describe heaps using separation logic [40]. We de.ne separa\u00adtion logic predicates, \nwritten A and B, as state predicates, based on Reynolds s semantics [40]. A S holds if state S satis.es \nthe state predicate A. We de.ne this judgment in terms of standard CIC pred\u00adicates, allowing us to use \nseparation logic predicates in our speci\u00ad.cations. The syntax of the fragment of separation logic we \nuse in this paper is as follows: A, B ::= n .. m | true | A . B | A * B |:x. A | ... In the veri.cation \nitself we use other separation logic connec\u00adtives, such as iterated separating conjunction [4]. n .. \nm holds on a state if and only if the state s heap is {nm}. true holds on all states. A . B holds if \nthe state s heap can be split into two disjoint parts such that A holds on one and B on the other. A \n* B holds if both A and B hold on the entire state. :x. A holds if there exists an x such that Ax holds \non the state.  4. The garbage collector-mutator interface The garbage collector may require that various \nexotic invariants hold on the object heap, but the mutator does not have to worry about these details \nas long as it interacts with the object heap only through the appropriate barriers. We hide these details \naway by having the mutator reason about an abstract state, which presents a high-level view of the concrete \nstate which represents the ac\u00adtual machine state. For instance, in a mark-sweep garbage collec\u00adtor space \nis set aside for the collector to track which objects are marked, but the mutator never directly interacts \nwith this mark data, so it shouldn t have to keep track of it. Or, as we described earlier, in an incremental \ncopying collector the object heap might be in a partially copied state, with old and new copies of objects \ncoexist\u00ading. We can hide this mess from the mutator, and as long as the mutator only uses the operations \nwe provide, it will never discover the deception. We write A for a state that is intended to be an abstract \nstate. It is represented in the same way as a concrete state S, but for a particu\u00adlar state will not \nbe the same. In this section, we give speci.cations for the three garbage collector operations we discussed \npreviously, then discuss the speci.cation of the behavior of the garbage col\u00ad readPrek A ::= {rroot, \nA(rroot)+ 4k}~ dom(A) readStepk AA * ::= A * = A{v0 A(A(rroot)+ 4k)} writePrek A ::= {rroot, a0, A(rroot)+ \n4k}~ dom(A) writeStepk AA * ::= A * = A{A(rroot)+ 4k A(a0)} allocPre A ::= rroot . dom(A) allocStep AA \n** ::= :A * . gcStep AA * * (Vp. p A * . (p . A **(v0) .. NULL, NULL) A **) * A *(rroot)= A **(rroot) \nFigure 11. Abstract speci.cations for basic operations lector that the mutator can observe. Finally, \nwe discuss the general mechanism for relating the abstract and concrete states. 4.1 The operations The \nthree garbage collector operations are reading from an object, writing to an object, and allocating a \nnew object. Here we de.ne their basic speci.cations, in Figure 11, ignoring the effects of any garbage \ncollection that may occur. To simplify the presentation (and our implementation), we only allow registers \nto be roots. The set of roots is the set of registers in the domain of A. For example, for a read operation, \ninitially the register rroot must be a root. Afterwards, all of the registers that were roots are still \nroots, plus register v0. The speci.cations for the read and write are parameterized by the .eld k being \noperated on. For the read to be executed, rroot must be in the domain of the abstract state, and must \ncontain a valid pointer to the .eld of interest. After the read is performed, the return register v0 \ncontains the value of the root s kth .eld, but the state is otherwise unchanged. For a write to be executed, \nrroot must again be in the domain of the heap, and contain a valid pointer to the kth .eld. In addition, \nregister a0 must be in the domain of the abstract state, indicating it contains a valid abstract value. \nAfter the write is done, the kth .eld of the root is updated, but the state otherwise remains the same. \nTo safely perform an allocation, all roots must be in the domain of the abstract state to ensure they \nare valid abstract values, which is needed to ensure a collection will work. Afterwards, the collector \nhas taken a step, as de.ned by gcStep, and a fresh object has been allocated, initialized, and placed \nin register v0. We can, if we want, similarly add a gcStep to the read or write speci.cations. This can \nbe useful if the read or write barrier performs some collection work that is not hidden from the mutator, \nor if, as in a collector that uses reference counting, objects are actually collected during reading \nor writing. 4.2 Abstract collection During any of these operations, in particular allocation, the GC \nmight do some collection work, which will affect the abstract state. We specify this behavior with a \nbinary state predicate gcStep that relates the abstract state before the GC executes with the abstract \nstate after it executes. The de.nition of gcStep is .xed for a partic\u00adular mutator, as it describes the \nbehavior of the GC that the mutator can see. In Figure 12 we de.ne two basic GC step relations. The .rst, \nbasicGcStep, says that the roots are the same after the GC runs, and that all objects in the heap that \nare reachable from the roots in the initial state are exactly the same in the .nal state. The de.nition \nrequires the de.nition of two other heap predicates. The .rst, minObjHp(x) holds on any heap that contains \nexactly the objects reachable from x. The second, heq H, simply holds on any state where the heap is \nH. Essentially what we are doing is scooping out a heap H from the initial state that contains the objects \nbasicGcStep AA * ::= (VH. ((minObjHp(A(rroot)) * heq H) . true) A . (heq H . true) A * ) * A(rroot)= \nA *(rroot) typesafeGcStep AA * ::= Vr. stateHasType(r) A . stateHasType(r) A * Figure 12. Basic GC step \nrelations l(p, g)J ::=(lpJ, lgJ) lpJ ::= 'S. :A. repr AS * p A lgJ ::= 'S, S * . VA. repr AS .:A * . \nrepr A * S * * g AA * Figure 13. Speci.cation lifting functions reachable from the root, and saying \nthat the .nal state also contains this heap H. Therefore, if you can show that an object is reachable \nin the initial state A you can show that it is part of S, and thus has the same value in the .nal state \nA *. Secondly, this step relation guarantees that the roots remain the same. The second GC step relation \nwe de.ne, typesafeGcStep, is an example of how a step relation for type safety could be de.ned. We assume \nthat r is a map from registers to types and predicate stateHasType(r) holds on a state if the registers \ncan be given the types speci.ed in r. The step relation simply says that the .nal state has the same \ntype as the initial state. We can also de.ne more application-speci.c GC steps. Basic type safety is \ntoo weak to verify the partial correctness of our list summation example, while basicGcStep is stronger \nthan is necessary. Instead, we can use a GC step that speci.es that the GC is list sum preserving, so \nthat the the initial and .nal states contain linked lists with the same sum and heads. 4.3 From abstract \nto concrete While we want the mutator to reason abstractly as much as possible, at some point we must \nconnect the abstract and concrete behaviors. This is done using a binary state predicate repr AS which \nholds if the state S is a concrete representation of the abstract state A. Each garbage collector will \nhave its own repr. The veri.cation of a mutator is parameterized over a veri.ed implementation of a GC, \nwhich includes the de.nition of repr, keeping it abstract. This allows us to instantiate the veri.ed \nmutator with different collectors as needed. While it is mostly abstract, we need to give some additional \nrules to reason about the representa\u00adtion. The most important rules are the following: if an abstract \nor concrete root is atomic (i.e., not an object pointer), the abstract and concrete values of the root \nare equal; a value can be copied from one root to another; a root can always be assigned an atomic value. \nThese rules allows the mutator to reason about and manipulate the roots in a few speci.c circumstances. \nGiven a predicate repr, we can de.ne a function lJ in Figure 13 that lifts an abstract speci.cation to \na concrete speci.cation. We use the lifted forms of the speci.cations to verify the implementations of \nthe three GC operations. A speci.cation is lifted by lifting the precondition and the guarantee. A precondition \np is lifted by requiring that there exists an abstract state A that is represented in the current state \nS, such that p holds on A. A guarantee is lifted by requiring that for all abstract states A represented \nin the initial state S, there exists some other abstract state A * represented in the .nal concrete state \nS *, such that A and A * are related by g. menter: mloop2: addiu rsum,r0,1 addiu rtemp,rzero,1 j mloop \nsubu v0,v0,rtemp addu rsum,rsum,v0 mloop: jal read2, mloop3 addiu rtemp,r0,NULL beq rroot, rtemp, mret \nmloop3: jal read1, mloop2 addiu rroot,v0,0 j mloop mret: jr ra Figure 14. List sum implementation  \n5. Mutator speci.cation and veri.cation Now that we have de.ned our formal system, we can return to our \nlist summation example. Most mutator programs will be the re\u00adsult of compilation of a high-level language \nusing a compiler that generates typed assembly language (TAL) [33]. We can then em\u00adbed TAL into a SCAP-style \nsystem by representing the state typing judgment as a state predicate and showing that the typing rules \nfor instructions are admissible. For more details on this embedding, please see the companion paper [27]. \nTo avoid introducing another formal system, for our example we will instead verify the partial correctness \nof the list sum example using SCAP. We show the as\u00adsembly implementation, then discuss the speci.cation \nand, brie.y, the veri.cation. The assembly implementation (of the pseudo code from Figure 2) is given \nin Figure 14. Our goal is to verify that the mutator correctly sums a list. For our example, all atomic \nvalues are odd, allowing us to easily distinguish them from object pointers. With this encoding, an integer \nn would be stored in the state as 2n + 1. The translation is straightforward, aside from the need to \nadd in extra arithmetic to properly handle the integer encoding: 0 is encoded as 1, and we must subtract \n1 from a value we load before using it to increment the sum. The calls to first and second in the pseudo \ncode have been changed to calls to read1 and read2. We use register rtemp to hold intermediate values. \nAs before, register r0 is always 0. For the speci.cation, we must de.ne a list predicate which holds \non a state that contains a linked list starting at address x that has the sum n. This can be inductively \nde.ned in a straightforward manner and is de.ned as LListSumAt(n, x). Using this predicate, we can de.ne \nthe abstract speci.cations of the mutator entry point menter and the loop header mloop. These blocks \nhave the same precondition, which requires that the register rroot contains a linked list, with some \nsum n. More formally, this is de.ned as mpre A ::= :n. rroot . dom(A) * LListSumAt(n, A(rroot)) A The \nloop header guarantees that if rsum initially contains the encoding of some n and rroot contains a linked \nlist with the sum m, then in the state in which we return rsum contains the encoding of n + m. The guarantee \nfor the entire function is very similar. For simplicity, we do not specify that the heap is unchanged \nin the .nal state. Formally, the abstract loop guarantee is: loopGuar AA * ::= Vm, n. A(rsum)= 2n + 1 \n. LListSumAt(m, A(rroot)) A . A *(rsum)= 2(n + m)+ 1 In order to actually verify this mutator, we need \nto specify what behavior we expect from the collector by de.ning gcStep. We cannot simply require that \nthe GC preserves the sum of the list in the root, because this allows the head of the list to change \nwhenever we perform a read, if gcStep is in the speci.cation of the read. As we read the head of the \nlist before the tail, the old value we loaded from the head might become invalid, preventing us from \nverifying idRepr (H, R)(H * , R *) ::=(H = H *) * (R ~ R *) msRepr AS ::= (:objs, free, ohpSt, ohpEnd, \nfreePtr, stBot, stTop. (objHp(objs, objs) * idRepr A) . objHdrs (objs U free, 0) . freeList (freePtr, \nfree) . buffer(stTop, stBot) . msAuxOk(A, objs, free, ohpSt, ohpEnd, stBot, stTop, freePtr)) S Figure \n16. Mark-sweep predicate the mutator. Instead, we require that the GC does not change rroot if it is \nnull, or if it is not null, it will not change the head, but can change the tail to another list with \nthe same length. Finally, the value of rsum cannot be changed. With the speci.cation of the mutator and \nthe main loop deter\u00admined, along with the behavior of the read barriers, the basic out\u00adline of the veri.cation \nis complete. Veri.cation is more dif.cult than it would be in the absence of garbage collection, but \nthe ab\u00adstraction limits the complexity.  6. Collector speci.cation and veri.cation In this section, \nwe discuss the collector s view of the state by dis\u00adcussing how various collectors represent the abstract \nstate. Addi\u00adtional details about the collectors we veri.ed can be found in the extended version of this \npaper [28]. 6.1 Stop-the-world mark-sweep A mark-sweep garbage collector, as you might infer from the \nname, has two phases: mark and sweep. In the mark phase, all reachable objects are marked by a depth-.rst \ntraversal of the heap, using a mark stack to hold objects that remain to be examined. In our example \ncollector, the mark is held in an object header. In the sweep phase, the object heap is traversed. Any \nobject that remains unmarked must not be reachable from the root, and thus can be added safely to the \nfree list, which is also done during this phase, along with the resetting of the marks. Figure 15 is \ndiagram of a possible concrete mark-sweep heap for the abstract heap given in Figure 3. We de.ne the \nrepresentation predicate for a mark-sweep collec\u00adtor in Figure 16. We need a few auxiliary heap predicates \nto de\u00adscribe the heap. idRepr AS holds if S is a simple representation of A, where A and S share the \nheap, and the register .le of A is a sub\u00adset of the register .le of S. objHp(objs* , objs) holds on a \nheap if it exactly contains the objects in objs, and all of the object pointers in the heap are elements \nof objs*. Thus if objHp(objs, objs) holds on a heap, that heap is closed. objHdrs (objs, n) holds on \na heap that consists entirely of object headers for the objects in objs, where the headers all have the \nvalue n. We use 0 to indicate unmarked objects. isoState (H, R)(H * , R *) ::= :objs, objs* , <. objHp(objs, \nobjs) H * objHp(objs* , objs* ) H * * objs* . =< objs * Vx . objs* . objIsFwded< H * H x * Vr . dom(R). \n<* (R * (r)) = R(r) chRepr A ::= :objs, fromSt, fromEnd, toSt, toEnd, freePtr. (objHp(objs, objs) * \nisoState A) . buffer(freePtr, fromEnd) . buffer(toSt, toEnd) . chAuxOk(objs, fromSt, fromEnd, toSt, toEnd, \nfreePtr) Figure 18. Cheney collector state predicate freeList (n, S) holds on a heap that is a linked \nlist of pairs starting at n, and contains the objects in the set S in some order. A heap satis.es buffer(x, \ny) if it contains a buffer from address x to y, not including y. For the mark-sweep collector this is \nused to hold the mark stack. Finally, we have a predicate msAuxOk which ensures various constraints hold \non the auxiliary variables, such as ensur\u00ading that the set of objects matches up with the heap pointers, \nand checking that the registers are well-typed. To put these all together, we .rst require that one part \nof the heap both contains a closed set of objects objs (which msAuxOk will ensure includes all of the \nroots) and also contains the abstract heap. The identity representation is suf.cient because the mutator \nand collector views of this part of the heap coincide. Other than that, we require the state contain \nheaders for the objects, a free list containing objects free, space for a mark stack, and whatever is \nneeded to ensure the auxiliary variables are valid. 6.2 Stop-the-world copying In a copying collector, \nthe heap is divided into two semi-spaces. One, the from-space, contains all of the allocated objects, \nall in a row, and all of the free objects, also all in a row. The other semi\u00adspace, the to-space, lays \nfallow. During collection, the reachable objects in the from-space are copied to the to-space, then their \n.elds are forwarded and .nally the roles of the semi-spaces are swapped. All of the unreachable objects \nwill be automatically reused next cycle. In a Cheney collector [26], no extra space is needed for for\u00adwarding \npointers, because they can be stored within the abandoned hulks of the copied objects. The representation \nof objects within the concrete state depends on the abstract behavior of the GC, as de.ned by gcStep. \nIf gcStep can be satis.ed even if the objects are moved around, then we can use a simple object representation \nlike idRepr. This will be the case if gcStep only guarantees type safety, because the type of an object \ndoes not depend on its location, or if we simply state in gcStep that the objects might be copied. On \nthe other hand, if we want to use basicGcStep, we must hide any copying from the mutator. This can be \ndone by maintaining an isomorphism < from fwdObj(word* obj) { if (free == alloc) while(1) {}; // no space \nleft: give up x = obj[0]; // copy 1st field free[0] = x; x = obj[1]; // copy 2nd field free[1] = x; obj[0] \n= free; // store forwarding pointer in obj x = free; free += 2; // increment free by two words return \nx; // return location of new object } fromSpacePtr (x) { return !(x &#38; 1) &#38;&#38; x >= fromStart \n&#38;&#38; x < fromEnd; } toSpacePtr (x) { return !(x &#38; 1) &#38;&#38; x >= toStart &#38;&#38; x < \ntoEnd; } Figure 19. Baker pseudo code (auxiliary functions) the concrete object addresses to the abstract \naddresses: whenever we move objects in the concrete state we can update < instead of updating the abstract \nstate. The interface for representations does not tell the mutator anything about the relationship between \nconcrete and abstract pointers, so the collector can change this relationship (which in this case is \nprecisely given by <) at any time without the mutator being able to tell. The end result is that we can \ngive an implementation of a copying collector the same interface as a mark-sweep collector. We de.ne \na representation in Figure 18 that uses this approach to hide the action of the copying collector. The \nfrom-space ranges from fromSt to fromEnd and the to-space ranges from toSt to toEnd. The free pointer \nfreePtr divides the from-space into allocated and unallocated parts. objs is the set of objects in the \nallocated portion. Instead of using idRepr, we de.ne a new binary state predicate isoState AS, which \nholds if there exists an isomorphism < between the objects in A and those in S. We write <* for the extension \nof < by identity on non-pointers. We require that every object in the heap of S is forwarded to A using \n<, which can be de.ned following [4]. Roughly, if an object is located at x in S, then it must be located \nat <(x) in A, with the .elds mapped by <*. In addition, all of the roots must be forwarded with <* . \nchAuxOk describes the various constraints on the auxiliary vari\u00adables, such as that the allocated and \nfree objects must cover the from-space, and, importantly, that the from-and to-spaces have the same size. \nThis will let the collector run safely without a bounds check. For the actual representation, the state \nmust contain a closed well-formed object heap containing all of the objects in objs. This ensures that \nwe can safely trace the heap. This part of the heap must be isomorphic to the abstract state A. Next \nwe have buffers containing the free space and the to-space. We use buffers because we don t care about \ntheir contents. Finally, we must ensure that all the auxiliary variables are properly accounted for. \n 6.3 Incremental copying Baker s algorithm [2] is a variant of Cheney s algorithm that sup\u00adports incremental \ncollection. The basic layout of the Baker collec\u00adtor heap has already been shown in Figure 4, but we \ndiscuss here it in more detail. We give an excerpt from the pseudo code for this collector in Figures \n19 and 20. See the extended version [28] for the full pseudocode and assembly implementations of this \ncollector. Figure 19 contains the pseudocode implementation of the aux\u00adiliary functions of the Baker \ncollector. fwdObj copies the object bakerScanField (word* fieldPtr) { fval = *fieldPtr; if (fromSpacePtr(fval)) \n{ field1 = fval[0]; if (toSpacePtr(field1)) *fieldPtr = field1; else *fieldPtr = fwdObj(fval); } } bakerGC(word* \nroot) { count = 0; if (free == alloc) { ... // flip spaces, scan root } while (scan != free &#38;&#38; \ncount < scan_per_gc) { bakerScanField(scan); bakerScanField(scan + 1); scan = scan + 2; count = count \n+ 1; } } Figure 20. Baker pseudo code (collector) bakerRepr A ::= :B, B* , G,W, M, <, S. :ohpSt, ohpEnd, \ntoSt, toEnd, freePtr, allocPtr, scanPtr. ((<* U idto.W ) . S)= A * ((objHp(to, B U B*) . objHp(to U fr, \nG) . objHp(fr,W)) * idRepr S) . mapHp(M, <) . buffer(freePtr, allocPtr) . bAuxOk(B, B* , G,W, M, to, \nfr, <, ohpSt, ohpEnd, toSt, toEnd, scanPtr, allocPtr, freePtr) where to = B U B* U G and fr = W U M \n Figure 21. Baker collector state predicate located at obj to the start of the free space, which begins \nat free, stores the forwarding pointer in obj, and returns the location of the newly created object. \nfromSpacePtr returns true if the argu\u00adment x is not atomic, and is between the bounds of the from-space, \ngiven by the variables fromStart and fromEnd. toSpacePtr is the analogous function for the to-space. \nFigure 20 is the pseudocode implementation of the main func\u00adtions of the Baker collector. bakerScanField \nis the most complex part of the collector. It forwards the value of the .eld of an ob\u00adject pointed to \nby the argument fieldPtr, if necessary. The value of this .eld, fval, is either atomic, a to-space space \npointer, or a from-space pointer. In the .rst two cases, nothing needs to be done because the .eld value \nwill still be valid after the collection is done. If the .eld contains a from-space pointer, then the \ncollector must determine if the object has been forwarded already. It does this by loading the .rst .eld \nof the object into field1. field1 will either be a to-space pointer, an atomic value, or a from-space \npointer. In the .rst case, field1 must be the forwarding pointer of fval, so the collector update the \n.eld of the original object to fval. Otherwise the object must be forwarded using fwdObj. The function \nbakerGC is the main part of the collector. This function is invoked on every allocation and takes a single \nroot value as an argument. If free is equal to alloc, then there is no more free space, so the collector \nmust .ip the semi-spaces and scan the root. After this check, the collector begins scanning gray objects, \nwhich lie between scan and free. This is an incremental collector, so the GC will not scan more than \nscan per gc objects per invocation. An object is scanned by scanning each object, then updating the scan \npointer and the count. While the implementation of the Baker collector is similar to that of the Cheney \ncollector, the invariants are more complex, because invoking the Baker collector only partially processes \nthe heap. The most interesting part of the Baker state representation is how we reason about the partially-copied \nheap. For simplicity, we assume a gcStep which permits moving objects. (To avoid this, and allow the \nuse of basicGcStep, we can use the technique described in Section 6.2 for hiding copying by introducing \nan isomorphism between concrete and abstract addresses, but having two isomorphisms would obscure the \nissues speci.cally related to incremental copying collection.) As we discussed before, reasoning about \nthe heap of an incremental copying collector is dif.cult because object references may be out of date, \npointing to the old copies of objects. We avoid this by making the abstract heap a forwarded version \nof the concrete object heap. In some sense, the abstract heap is what the object heap will look like \nafter the collector has .nished1 . The speci.cation for the Baker heap is given in Figure 21. First, \nwe describe the different auxiliary variables. Black objects (B) have been copied to the to-space and \ntheir .elds forwarded. The GC will not visit them again. New black objects (B*) have been allocated during \nthe current cycle, starting from the end of the to\u00adspace, and will not be visited by the GC. Gray objects \n(G) have been copied, but not forwarded. The GC will eventually forward these objects. Gray objects can \ncontain to-space objects because the mutator may write to them before the collector scans them. White \nobjects (W) have not been examined by the GC. Map objects (M) store the mapping < from the old location \nof objects in M to their new location in the to-space: if an object at w has been forwarded to w *, then \n<(w)= w * and the heap contains w * at address w. This allows the collector to forward .elds while ensuring \nthat no object is copied more than once. ohpSt and ohpEnd are the bounds of from-space, while toSt and \ntoEnd are the bounds of to-space. freePtr and allocPtr point to the start and end of the free space, \nrespectively, which is located within the to-space. scanPtr marks the separation between black and gray \nobjects in the to-space. The from-space objects (M and W) together cover the entire from-space. The collector \nrelies on the fact that objects in the from-space can be dynamically distinguished from objects in the \nto-space.  As for the actual constraints, the .rst requirement relates the abstract state A to the part \nof the concrete state that contains the objects, given by S. We transform the concrete state to the abstract \nstate by mapping the range of S, including its registers. To forward the .elds, we must map everything \nin M using < and all non\u00adpointers, to-space pointers, and pointers in W using the identity function, \nbecause these .eld values do not need to be changed. We write idS for the identity on set S, and as before, \nwe write <* for the function < extended by the identity function on non-pointers. We scoop S out of the \nentire concrete state in the same manner as in the mark-sweep collector representation predicate, except \nthat we have three groups of objects instead of one. Black objects can only point to to-space objects, \nwhite objects can contain only point to from-space objects, and gray objects can point to either. mapHp(M, \n<) holds on a state that contains the mapping <, along with the rest of the objects in M. The buffer \ncontains the free space still left in the to-space. Finally, the predicate bAuxOk en\u00ad 1 This is not strictly \ntrue, because the collector may copy additional objects later. It is impossible to predict how this copying \nwill occur because it depends on mutator behavior, but this doesn t matter because as we said above our \ngcStep allows the collector to move objects freely. read1 (word* root) { word* fieldVal = root[0]; if \n(fromSpacePointer(fieldVal)) fieldVal = fwdObj(fieldVal); return fieldVal; } Figure 22. Baker read barrier \nforces the rest of the constraints on the auxiliary variables, includ\u00ading the requirement that < is an \nisomorphism from M to (B U G). This constraint is the reason we must keep B and B* separate. It also \nenforces the requirement that the roots must be in to-space. Note that while we must describe the entire \nheap at the boundaries of the GC, within the GC we use more local reasoning [4] that does not explicitly \ndescribe the entire state. We omit further details of bAuxOk in the interest of space. 6.3.1 Read barrier \nBecause the root set can only contain to-space objects, any write will preserve the color invariant, \nso the write barrier can be imple\u00admented using a single store instruction. However, we do need to use \na read barrier because if a root object is gray loading a .eld may break the color invariant for the \nroot set, because gray objects can contain pointers to from-space objects. The read barrier, seen in \npseudo code form in Figure 22, forwards the value loaded (copy\u00ading if needed) if it is a pointer to the \nfrom-space. This maintains the invariant, and thus the read barrier satis.es the speci.cation dis\u00adcussed \nin Section 4, though we must use the variation discussed in that section that includes a gcStep, because \nan object may be copied. If we use the more complex representation that is able to hide copying, then \nwe can use the simpler speci.cation (because this read barrier does not perform any collection) and thus \nmake the read barrier look like just a load operation.  6.4 Other collectors There are a variety of \nother collectors that can be veri.ed using our methods. There is the Brooks collector [6], which is a \nvari\u00adation of the Baker collector that uses a write barrier instead of a read barrier. We believe that \nan alteration of the repr predicate for the Baker collector would serve that collector, as the relationship \nbetween the objects in the concrete state and the objects in the abstract state is the same: only the \nauxiliary data structures used by the collector change. There are also incremental and concurrent mark-sweep \ncollectors, which must maintain complex color invari\u00adants [11, 46, 18, 26]. We have begun investigating \nthis type of col\u00adlector, and at least the incremental collectors seem to be a fairly natural extension \nof the stop-the-world mark-sweep collector, in the same way that the Baker collector is a fairly natural \nextension of the Cheney collector. Mark-sweep collectors do not move ob\u00adjects around, so the relationship \nbetween the concrete objects and the abstract objects is the same. 6.5 Conservative collectors Up until \nnow, we have only discussed precise collectors, where the collector is always able to tell if a value \nis an object pointer. Con\u00adservative collectors [5] relax this constraint, greatly reducing the impact \nof garbage collection on the mutator at a cost of decreased precision. In terms of the interface, the \ncollector can no longer ab\u00adstract object pointers, because it does not know exactly what is a pointer. \nThe practical implication of this is that we must add a lemma to the collector interface that says that \nthe representation of all heap values is the identity function. The interface still allows us to hide \nauxiliary data structures and constraints from the mutator. For instance, the collector may require mark \nbits, or segregate ob\u00adjects by size, but the particular details of this should not affect the mutator. \nAside from these additional constraints the collector may use to improve precision, the actual representation \nof objects within the concrete state will likely use something like idRepr, as de.ned in Section 6.1. \nFor details on how our approach can be used with a conservative collector, see [27]. component # of lines \ncore machine de.nitions 433 SCAP de.nition and soundness 975 separation logic library 4326 .nite set \nlibrary 3858 map libraries 1112 basic GC de.nitions 2258 dummy GC 1106 mark-sweep GC 10744 incremental \nmark-sweep GC 11016 Cheney copying GC 7775 Baker incremental copy GC 17252 list sum and reverse examples \n2832 misc. utility .les 1310 Figure 23. Length of proof scripts   7. Implementation The focus and key \nnovelty of our paper is the development of a general framework for reasoning about mutator-garbage collector \ninteraction. We discuss our mechanized proofs primarily to support our claim of generality. In our Coq \nimplementation [29] we have de.ned the machine semantics, implemented and proved sound SCAP and our fragment \nof separation logic. We have also veri.ed the list sum mutator example to match the speci.cation described \nin the paper, along with a list reversal example not mentioned here. We have veri.ed the safety of an \nassembly implementation of a minimal stub GC, a mark-sweep GC, a Cheney collector, a Baker collector, \nand shown that these collectors satisfy the abstract interface described in this paper. We have also \nundertaken a large part of the veri.cation of an incremental mark-sweep GC. The mark-sweep collectors \nuse a gcStep similar to basicGcStep, while the copying collectors use a gcStep similar to the heap isomorphism \nrelation of [8]. Consequently, the Baker representation predicate is slightly different than that presented \nin this paper. The Coq implementation is around 64,000 lines, including com\u00adments and whitespace, although \nmost of this is proofs. Figure 23 gives a breakdown of number of lines in the proof scripts for vari\u00adous \ncomponents. The length of the collectors includes their de.ni\u00adtions and veri.cation. The work has taken \nmany man months. Our Coq proofs do not use any axioms and pass the Coq proof checker. For Coq proofs, \nlines of code is probably a reasonable measure of effort, but a poor metric of complexity, as the length \nof a proof can vary greatly depending on how aggressively tactics are used. We found that the veri.cation \nof more complex collectors was denser than those of simpler ones, as we had improved the tool set enough \nas we were working to make things easier later. Also, there is some redundancy in the proofs, because \nthe incremental versions of stop-the-world collectors use altered versions of the original proofs. While \nwe made some effort to reduce the size of the proof scripts, there is probably a lot of room for improvement. \nA reworking of the veri.cation of the mark-sweep collector reduced the size by two-thirds. The veri.cation \nof a basic block can be broken into a few steps. First, we automatically infer a simple veri.cation condition \nin terms of explicit machine steps. This may produce a few simple side conditions. After those have been \nshown, we compute, step\u00adby-step, the .nal machine state of the block. For instructions that are always \nsafe this is trivial, but for instructions that operate on memory we must prove that the location being \naccessed is valid. In the event of a branch, we must consider both cases. Finally, we have a description \nof the .nal state in terms of the initial state. From this, we must show the .nal state satis.es the \nprecondition of whatever code block we will end up in, and that the behavior of this block plus the behavior \nof the rest of the procedure satis.es the speci.\u00adcation of this block. This .nal step constitutes the \noverwhelming portion of verifying a block, as it involves manipulating the high\u00adlevel predicates involved \nin the speci.cations. To simplify the veri.cation work, we use a wide variety of tactics. We use Coq \ns tactic for automatically applying a set of rewriting rules to simplify the state where possible. For \ninstance, S{r * n}(r) is equal to n when r * = r and equal to S(r) when r * . = r. We have 8 such rules. \nThis tactic greatly simpli.es verifying blocks of code that are mostly sequences of arithmetic instructions. \nThe Omega tactic, provided by Coq, does the bulk of the arithmetic reasoning we need. Another set of \nheavily used tactics manipulate proofs of separation logic predicates. One pair of tactics automat\u00adically \nperforms simpli.cation of assumptions or goals. These sim\u00adpli.cations include combining together all \ninstances of true, rear\u00adranging nested uses of . into a right-normal form, introducing or eliminating \nexistentials, and taking advantage of the fact that we can prove anything from a proof of H . x .. m. \nx .. n. A. Another set of tactics can be used to try to match up a separation logic goal with a hypothesis, \nwith varying degrees of aggressiveness about re\u00adordering. 8. Related work and conclusion There is a \nlarge body of work on verifying garbage collector algo\u00adrithms (such as [16, 17, 11, 3, 14]), including \nmechanized veri.\u00adcation in a variety of formal systems (such as [41, 24, 19, 35, 7]) This work mostly \nfocuses on verifying more abstract algorithms, in contrast to our focus on the veri.cation of actual \nmachine level implementations being executed on a (more or less) realistic ma\u00adchine. We also want to \nverify mutator and collector separately, with a well-de.ned interface between them, instead verifying \na model of the entire system at once. On the other hand, their work generally is able to verify liveness, \nwhile it is not clear how to handle it in our system. Their work also has veri.ed concurrent algorithms, \nwhile we have not. Higher level veri.cation is of course also very useful when doing lower level veri.cation. \nVechev et al. [43] discuss a way to apply a series of correctness\u00adpreserving transformations to a very \nabstract concurrent mark\u00adsweep algorithm, thereby deriving a more realistic (and still cor\u00adrect) algorithm. \nTheir work focuses on explaining the behavior of variants of a single class of collectors (concurrent \nmark-sweep) within a single framework, while we are attempting to describe a broader class of algorithms, \nbut we are focusing mostly on gener\u00adalizing the interface, and only on correctness. Morrisett et al. \n[32] discuss a high level semantics of garbage collection, which is sim\u00adilar to our work in that it involves \nreasoning about interference be\u00adtween the mutator and the garbage collector. Our work builds on work \nby Birkedal et al. on verifying the im\u00adplementation of a Cheney collector [4]. They use separation logic \ncombined with Hoare logic to reason about GC implementations, and the same kind of heap isomorphism predicate \nto describe the behavior of a copying collector. However, they only consider the veri.cation of the collector \nand do not consider hiding the rep\u00adresentation of the garbage collected heap. Our main contribution over \n[4] is the general framework for verifying mutator and collec\u00adtor together while using different levels \nof abstraction, even in the presence of read/write barriers needed for incremental collection. Additionally, \nwe have veri.ed more algorithms, and our proofs are machine checked. Other work focuses on the mutator \nside of mutator-GC inter\u00adaction. Calcagno et al. [8] give a means of reasoning about the behavior of \na copying collector from the perspective of the mu\u00adtator, and develop a program logic that is sound in \nthe presence of garbage collection being performed at any step. Hunter and Krishnamurthi [23] show that \nadding garbage collection (as an atomic step) to a formal model of Java is sound. Vanderwaart and Crary \n[42] present a type system able to describe the interface of the mutator with a modern, realistic garbage \ncollector. While this work all provides a variety of useful models for GC interfaces, it does not deal \nwith the veri.cation of the collector itself, and thus is unable to verify an entire program within a \nsingle system. There is also prior work focusing on type safe garbage collec\u00adtion [44, 30, 31, 20]. This \nwork allows verifying the safety of both mutator and collector in a single framework, while giving a \nwell\u00adde.ned interface between the two that allows them to be separately checked. However, these seem \nfairly linked to particular algorithms (aside from [20]) and notions of safety. If you wanted to prove \na stronger property than memory safety, you would need to construct a more expressive type system and \nreprove soundness. Hawblitzel et al. [20] mechanically verify the safety of an im\u00adplementation of the \nCheney collector. Their implementation uses a more complex object model, but for safety has an unnecessary \nbounds check that we are able to avoid. While it may be possible for them to avoid this, their system \nstill cannot prove partial correct\u00adness, in contrast to our system. Additionally, the overall soundness \nof their system is dependent on a paper proof of the safety of their type system, and on their own implementation \nof a type checker for their system, while our system is entirely mechanically veri\u00ad.ed using Coq, an \nexisting general purpose proof system (except of course for the de.nitions of safety and the machine \nsemantics). O Hearn et al. [37] also combine separation logic with a form of abstraction. Their approach \nuses a hypothetical frame rule that allows one part of a program (like a garbage collector) to hide some \nof the heap from another part of a program (like the mutator), in contrast to our approach of using an \nabstract heap representation predicate repr to hide information. While the hypothetical frame rule can \ncompletely hide parts of the heap, it is very coarse-grained: to the client each slice of the heap is \neither completely hidden or completely exposed. This seems insuf.cient to, for instance, give the Cheney \nand Baker collectors the same interface, as our approach is able to do. Furthermore, in contrast to our \napproach, the soundness of the hypothetical frame rule depends on the heap predicates being restricted \nin some way. As previously mentioned, our work also draws heavily on prior work on formal reasoning about \nprograms, such as Hoare logic, rely guarantee reasoning about concurrent programs [25], and sep\u00adaration \nlogic [40]. We have demonstrated a framework for the formal veri.cation of garbage collectors, including \nthe speci.cation of a general in\u00adterface that is general enough to handle a variety of collectors. By \ncombining this work with existing work on typed compilation and machine level Hoare logics for concurrency \n[45], it should be pos\u00adsible to produce FPCC [1] using a modern concurrent garbage col\u00adlector.  Acknowledgment \nWe thank anonymous referees for their suggestions and comments on an earlier version of this paper. This \nresearch is based on work supported in part by National Science Foundation (of USA) under Grant CCR-0524545, \ngifts from Intel (USA), Microsoft, and Intel China Research Center, Innovation Funds from Chinese Academy \nof Sciences, and the National Natural Science Foundation of China under Grant No. 60673126. Any opinions, \n.ndings, and conclu\u00adsions contained in this document are those of the authors and do not re.ect the views \nof these agencies. References [1] A. W. Appel. Foundational proof-carrying code. In Symp. on Logic in \nComp. Sci. (LICS 01), pages 247 258. IEEE Comp. Soc., June 2001. [2] H. G. Baker, Jr. List processing \nin real time on a serial computer. Commun. ACM, 21(4):280 294, 1978. [3] M. Ben-Ari. Algorithms for on-the-.y \ngarbage collection. ACM Trans. Program. Lang. Syst., 6(3):333 344, 1984. [4] L. Birkedal, N. Torp-Smith, \nand J. C. Reynolds. Local reasoning about a copying garbage collector. In POPL 04: Proc. of the 31st \nACM SIGPLAN-SIGACT symp. on Principles of prog. lang., pages 220 231, New York, NY, USA, 2004. ACM Press. \n[5] H.-J. Boehm and M. Weiser. Garbage collection in an uncooperative environment. Software Practice \nand Exp., 18(9):807 820, 1988. [6] R. A. Brooks. Trading data space for reduced time and code space in \nreal-time garbage collection on stock hardware. In LFP 84: Proc. of the 1984 ACM Symp. on LISP and functional \nprog., pages 256 262, New York, NY, USA, 1984. ACM Press. [7] L. Burdy. B vs. Coq to prove a garbage \ncollector. In R. J. Boulton and P. B. Jackson, editors, 14th Int l Conference on Theorem Proving in Higher \nOrder Logics: Supplemental Proc., pages 85 97, Sept. 2001. Report EDI INF RR 0046, Division of Informatics, \nUniversity of Edinburgh. [8] C. Calcagno, P. O Hearn, and R. Bornat. Program logic and equivalence in \nthe presence of garbage collection. Theoretical Comp. Sci., 298(3):557 581, 2003. [9] J. Chen and D. \nTarditi. A simple typed intermediate language for object-oriented languages. In POPL 05: Proceedings \nof the 32nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 38 49, New York, \nNY, USA, 2005. ACM Press. [10] Coq Development Team. The Coq proof assistant reference manual. Coq release \nv8.0, Oct. 2005. [11] E. W. Dijkstra, L. Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. \nOn-the-.y garbage collection: an exercise in cooperation. Commun. ACM, 21(11):966 975, 1978. [12] X. \nFeng, Z. Ni, Z. Shao, and Y. Guo. An open framework for foundational proof-carrying code. In The third \nACM SIGPLAN Workshop on Types in Language Design and Implementation, pages 67 78, Nice, France, Jan. \n2007. ACM Press. [13] X. Feng, Z. Shao, A. Vaynberg, S. Xiang, and Z. Ni. Modular verif. of assembly \ncode with stack-based control abstractions. In Proc. 2006 ACM Conf. on Prog. Lang. Design and Impl., \nJune 2006. [14] G. Gonthier. Verifying the safety of a practical concurrent garbage collector. In R. \nAlur and T. Henzinger, editors, Computer Aided Veri.cation CAV 96, Lecture Notes in Computer Science, \nNew Brunswick, NJ, 1996. Springer-Verlag. [15] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java \nLanguage Speci.cation Second Edition. Addison-Wesley, Boston, Mass., 2000. [16] D. Gries. An exercise \nin proving parallel programs correct. Commun. ACM, 20(12):921 930, 1977. [17] D. Gries. Corrigendum. \nCommun. ACM, 21(12):1048, 1978. [18] J. Guy L. Steele. Multiprocessing compactifying garbage collection. \nCommun. ACM, 18(9):495 508, 1975. [19] K. Havelund. Mechanical veri.cation of a garbage collector. In \nFMPPTA 99, 1999. [20] C. Hawblitzel, H. Huang, L. Wittie, and J. Chen. A garbage-collecting typed assembly \nlanguage. In The Third ACM SIGPLAN Workshop on Types in Lang. Design and Impl. ACM Press, Jan. 2007. \n[21] A. Hejlsberg, S. Wiltamuth, and P. Golde. The C# Programming Language. Addison-Wesley, Boston, Mass., \n2004. [22] G. Hunt, J. Larus, M. Abadi, M. Aiken, P. Barham, M. Fahndrich, C. Hawblitzel, O. Hodson, \nS. Levi, N. Murphy, B. Steensgaard, D. Tarditi, T. Wobber, and B. Zill. An overview of the Singularity \nproject. Technical Report MSR-TR-2005-135, Microsoft Research, Redmond, WA, 2005. [23] R. Hunter and \nS. Krishnamurthi. A model of garbage collection for oo languages. In Tenth Int l Workshop on Foundations \nof Object-Oriented Lang. (FOOL10), 2003. [24] P. Jackson. Verifying a garbage collection algorithm. In \nProc. of 11th Int l Conference on Theorem Proving in Higher Order Logics TPHOLs 98, volume 1479 of Lecture \nNotes in Computer Science, pages 225 244, Canberra, Sept. 1998. Springer-Verlag. [25] C. B. Jones. Tentative \nsteps toward a development method for interfering programs. ACM Trans. Program. Lang. Syst., 5(4):596 \n619, 1983. [26] R. E. Jones. Garbage Collection: Algorithms for Automatic Dynamic Memory Management. \nWiley, Chichester, July 1996. With a chapter on Distributed Garbage Collection by R. Lins. [27] C. Lin, \nA. McCreight, Z. Shao, Y. Chen, and Y. Guo. Foundational typed assembly language with certi.ed garbage \ncollection. In 1st IEEE &#38; IFIP International Symposium on Theoretical Aspects of Software Engineering \n(TASE 2007), June 2007. [28] A. McCreight, Z. Shao, C. Lin, and L. Li. A general framework for certifying \ngarbage collectors and their mutators (extended version). Technical Report YALEU/DCS/TR-1378, Yale University, \nNew Haven, CT, Mar. 2007. [29] A. McCreight, Z. Shao, C. Lin, and L. Li. A general framework for certifying \ngarbage collectors and their mutators (implementation). http://flint.cs.yale.edu/flint/publications/hgc.html, \nJan. 2007. [30] S. Monnier, B. Saha, and Z. Shao. Principled scavenging. In Proc. 2001 ACM Conf. on Prog. \nLang. Design and Impl., pages 81 91, New York, 2001. ACM Press. [31] S. Monnier and Z. Shao. Typed regions. \nTechnical Report YALEU/DCS/TR-1242, Dept. of Comp. Sci., Yale University, New Haven, CT, Oct. 2002. [32] \nG. Morrisett, M. Felleisen, and R. Harper. Abstract models of memory management. In FPCA 95: Proc. of \nthe 7th Int l conference on Functional prog. lang. and comp. architecture, pages 66 77, New York, NY, \nUSA, 1995. ACM Press. [33] G. Morrisett, D. Walker, K. Crary, and N. Glew. From system F to typed assembly \nlanguage. ACM Transactions on Programming Languages and Systems, 21(3):527 568, 1999. [34] Mozilla. Mozilla \nfoundation security advisory 2006-01. http:// www.mozilla.org/security/announce/2006/mfsa2006-01. html. \n[35] L. P. Nieto and J. Esparza. Verifying single and multi-mutator garbage collectors with owicki-gries \nin isabelle/hol. In MFCS 00: Proc. of the 25th Int l Symp. on Mathematical Foundations of Comp. Sci., \npages 619 628, London, UK, 2000. Springer-Verlag. [36] NIST. Vulnerability summary cve-2006-3451. http://nvd.nist. \ngov/nvd.cfm?cvename=CVE-2006-3451. [37] P. W. O Hearn, H. Yang, and J. C. Reynolds. Separation and information \nhiding. In POPL 04: Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages, pages 268 280, New York, NY, USA, 2004. ACM Press. [38] W. Paul, M. Broy, and T. In der Rieden. \nThe verisoft project. URL: http://www.verisoft.de , 2007. [39] C. Paulin-Mohring. Inductive de.nitions \nin the system Coq rules and properties. In Proc. TLCA, volume 664 of Lecture Notes in Computer Science, \n1993. [40] J. C. Reynolds. Separation logic: A logic for shared mutable data structures. In LICS 02: \nProc. of the 17th Annual IEEE Symp. on Logic in Comp. Sci., pages 55 74, Washington, DC, USA, 2002. IEEE \nComputer Society. [41] D. M. Russinoff. A mechanically veri.ed incremental garbage collector. Formal \nAspects of Computing, 6:359 390, 1994. [42] J. C. Vanderwaart and K. Crary. A typed interface for garbage \ncollection. In TLDI 03: Proc. of the 2003 ACM SIGPLAN Int l Workshop on Types in Lang. Design and Impl., \npages 109 122, New York, NY, USA, 2003. ACM Press. [43] M. T. Vechev, E. Yahav, and D. F. Bacon. Correctness-preserving \nderivation of concurrent garbage collection algorithms. In PLDI 06: Proc. of the 2006 ACM SIGPLAN conference \non Prog. Lang. Design and Impl., pages 341 353, New York, NY, USA, 2006. ACM Press. [44] D. C. Wang and \nA. W. Appel. Type-preserving garbage collectors. In Proc. of the 28th ACM Symp. on Principles of prog. \nlang., pages 166 178, New York, NY, USA, 2001. ACM Press. [45] D. Yu and Z. Shao. Veri.cation of safety \nproperties for concurrent assembly code. In Proc. 9th ACM SIGPLAN International Conference on Functional \nProgramming, September 2004. [46] T. Yuasa. Real-time garbage collection on general-purpose machines. \nJ. Syst. Softw., 11(3):181 198, 1990.  \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Garbage-collected languages such as Java and C# are becoming more and more widely used in both high-end software and real-time embedded applications. The correctness of the GC implementation is essential to the reliability and security of a large portion of the world's mission-critical software. Unfortunately, garbage collectors--especially incremental and concurrent ones--are extremely hard to implement correctly. In this paper, we present a new uniform approach to verifying the safety of both a mutator and its garbage collector in Hoare-style logic. We define a formal garbage collector interface general enough to reason about a variety of algorithms while allowing the mutator to ignore implementation-specific details of the collector. Our approach supports collectors that require read and write barriers. We have used our approach to mechanically verify assembly implementations of mark-sweep, copying and incremental copying GCs in Coq, as well as sample mutator programs that can be linked with any of the GCs to produce a fully-verified garbage-collected program. Our work provides a foundation for reasoning about complex mutator-collector interaction and makes an important advance toward building fully certified production-quality GCs.</p>", "authors": [{"name": "Andrew McCreight", "author_profile_id": "81331498902", "affiliation": "Yale University, New Haven, CT", "person_id": "PP35041512", "email_address": "", "orcid_id": ""}, {"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Yale University, New Haven, CT", "person_id": "PP14127817", "email_address": "", "orcid_id": ""}, {"name": "Chunxiao Lin", "author_profile_id": "81323492806", "affiliation": "University of Science and Technology of China, Hefei, China", "person_id": "P831738", "email_address": "", "orcid_id": ""}, {"name": "Long Li", "author_profile_id": "81442609095", "affiliation": "University of Science and Technology of China, Hefei, China", "person_id": "PP39067467", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250788", "year": "2007", "article_id": "1250788", "conference": "PLDI", "title": "A general framework for certifying garbage collectors and their mutators", "url": "http://dl.acm.org/citation.cfm?id=1250788"}