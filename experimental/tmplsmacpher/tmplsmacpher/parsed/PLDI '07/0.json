{"article_publication_date": "06-10-2007", "fulltext": "\n Exterminator:Automatically Correcting Memory Errors with High Probability Gene Novark Emery D. Berger \nBenjamin G. Zorn Dept. of Computer Science Dept. of Computer Science Microsoft Research University of \nMassachusetts Amherst University of Massachusetts Amherst One Microsoft Way Amherst, MA 01003 Amherst, \nMA 01003 Redmond, WA98052 gnovark@cs.umass.edu emery@cs.umass.edu zorn@microsoft.com Abstract Programs \nwritten in C and C++ are susceptible to memory er\u00adrors, including buffer over.ows and dangling pointers. \nThese er\u00adrors, which can lead to crashes, erroneous execution, and security vulnerabilities, are notoriously \ncostlyto repair.Trackingdown their locationin the source codeisdif.cult,even when the full memory state \nof the program is available. Once the errors are .nally found, .xing them remains challenging:even for \ncritical security-sensitive bugs, the average time between initial reports and the issuance of a patch \nis nearly one month. We present Exterminator, a system that automatically corrects heap-based memory \nerrors without programmer intervention. Ex\u00adterminator exploits randomization to pinpoint errors with \nhigh precision. From this information, Exterminator derives runtime patches that .x these errors both \nin current and subsequent execu\u00adtions. In addition, Exterminator enables collaborativebug correc\u00adtionby \nmerging patches generatedby multiple users. We present analytical and empirical results that demonstrateExterminator \nsef\u00adfectivenessat detectingand correctingboth injectedandrealfaults. Categories and Subject Descriptors \nD.2.5[Software Engineer\u00ading]: Error handling and recovery; D.2.0 [Software Engineer\u00ading]: Protection \nmechanisms; D.3.3[Programming Languages]: Dynamic storage management; G.3[Probability and Statistics]: \nProbabilistic algorithms General Terms Algorithms, Languages, Reliability, Security Keywords DieFast, \nExterminator, dynamic memory allocation, error correction, memory errors, probabilistic memory safety, \nran\u00addomized algorithms 1. Introduction The use of manual memory management and unchecked memory accesses \nin C and C++ leaves applications written in these lan\u00adguages susceptible to a range of memory errors. \nThese include bufferoverruns, where readsor writesgobeyond allocatedregions, and dangling pointers, when \na program deallocates memory while it is still live. Memory errors can cause programs to crash or pro- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n07 June 11 13, 2007, San Diego, California, USA. Copyright c &#38;#169; 2007ACM 978-1-59593-633-2/07/0006...$5.00. \nduce incorrect results.Worse, attackers are frequently able toex\u00adploit these memory errors togain unauthorized \naccess to systems. Debugging memory errors is notoriously dif.cult and time\u00adconsuming. Reproducing the \nerror requires an input that exposes it. Since inputs are often unavailable from deployed programs, de\u00advelopers \nmust either concoct such an input or .nd the problem via code inspection. Once a test input is available, \nsoftware develop\u00aders typicallyexecutethe applicationwithheapdebuggingtoolslike Purify[21]andValgrind[30,40], \nwhichslowexecutionbyanor\u00ad derof magnitude. When thebugis ultimately discovered,develop\u00aders must construct \nand carefully test a patch to ensure that it .xes thebugwithout introducing any new ones. According to \nSyman\u00adtec, the average time between the discovery of a critical, remotely exploitable memory errorandthe \nreleaseofapatchfor enterprise applicationsis28 days[44]. As an alternativetodebugging memory errors, \nresearchershave proposed a number of systems that either detect or tolerate them. Fail-stop systems are \ncompiler-based approaches that require ac\u00adcess to source code, and abort programs when theyperforms illegal \noperations likebufferover.ows[1,2,14,16,29,45,46]. They rely either on conservativegarbage collection[9]or \npool alloca\u00adtion[15, 17]to prevent or detect dangling pointer errors. Failure\u00adoblivious systems are also \ncompiler-based, but manufacture read values and drop or cache illegal writes for later reuse[35, 36]. \nFi\u00ad nally, fault-tolerant systemsmasktheeffectof errors, eitherbylog\u00adging and replaying inputs in an \nenvironment that pads allocation requests and defersdeallocations (e.g., Rx[32]), or through ran\u00ad domization \nand optional voting-based replication that reduces the odds that an error willhave anyeffect (e.g., DieHard[3]). \nContributions: This paper presents Exterminator, a runtime sys\u00adtem that not only toleratesbut also detects \nand corrects heap-based memory errors. Exterminator requires neither source code nor pro\u00adgrammer intervention,and \n.xesexisting errors without introducing new ones.To our knowledge, this systemis the .rstof its kind. \nExterminator relies onanef.cient probabilistic debugging allo\u00adcator that we call DieFast. DieFast is \nbased on DieHard s alloca\u00adtor[3,4], which ensures that heaps are independently randomized. However, while \nDieHard can only probabilistically tolerate errors, DieFast probabilistically detects them. When Exterminator \ndiscovers an error, it dumps a heap image that contains the complete state of the heap. Exterminator \ns proba\u00adbilistic error isolation algorithm then processes one or more heap imagesto locatethe sourceandsizeofbufferover.owsanddan\u00adgling \npointer errors. This error isolation algorithm hasprovably low false positive andfalse negative rates. \nOnce Exterminator locatesabufferover.ow,it determines the allocation site of the over.owed object, and \nthe size of the over\u00adTable 1. Asummary of howExterminator handles particular mem\u00adory errors (Section2):invalid \nand double freeshave noeffect, and Exterminator probabilistically corrects danglingpointers andbuffer \nover.ows. The asterisk superscript means probabilistically. Error DieHard [3] Exterminator invalid frees \ntolerate tolerate double frees tolerate tolerate uninitialized reads dangling pointers buffer over.ows \ndetect* tolerate* tolerate* N/A tolerate* &#38;correct* tolerate* &#38;correct* .ow.For dangling pointer \nerrors, Exterminator determines both the allocation and deletion sites of the dangled object, and computes \nhow prematurely the object was freed. With this information in hand, Exterminator corrects the errors \nby generating runtime patches. These patches operate in the con\u00adtext of a correcting allocator. The correcting \nallocator prevents over.owsby padding objects,andpreventsdangling pointer errors by deferring object \ndeallocations. These actions impose little space overhead because Exterminator s runtime patches are \ntailored to the speci.c allocation and deallocation sites of each error. After Exterminator completes \npatch generation, it both stores the patchesto correctthebugin subsequentexecutions,and triggers apatch \nupdateinthe running programto.xthebuginthe current execution. Exterminator s patches also compose straightforwardly, \nenabling collaborativebug correction: users running Extermina\u00adtor can automatically merge their patches, \nthus systematically and continuously improving application reliability. Exterminator can operate in three \ndistinct modes: an iterative mode for runs over the same input, a replicated mode that can correct errors \non-the-.y, and a cumulative mode that corrects errors across multiple runs of the same application. We \nexperimentally demonstrate that, in exchange for modest runtime overhead (geometric mean of 25%), Exterminator \neffec\u00adtively isolates and corrects both injected and real memory errors, includingbufferover.owsin the \nSquid web caching server and the Mozilla web browser. Outline: The remainder of this paper is organized \nas follows. First, Section 2 describes the errors that Exterminator detects and cor\u00adrects.Next, Section3introduces \nExterminator s software architec\u00ad ture. Section 4 presents Exterminator s error isolation algorithms \nfor its iterative and replicated modes, and Section5describes the isolation algorithms for its cumulative \nmode.Section6 describes the correction algorithm that applies the patches that the error iso\u00adlator generates. \nSection7empiricallyevaluates their costandeffec\u00ad tiveness on real applications, both with injected and \nactual mem\u00adory errors. Finally, Section8discusseskeyrelatedwork, Section9 presents directions for future \nwork, and Section 10 concludes. 2. Memory Errors Table 1 summarizes the memory errors that Exterminator \nad\u00addresses, and its response to each. Exterminator identi.es and cor\u00adrects dangling pointers, whereaheap \nobjectis freed whileitis still live, and buffer over.ows(a.k.a.bufferoverruns)ofheap objects. Notice \nthat this differs substantially from DieHard, which tolerates these errors probabilisticallybut cannot \ndetector correct them. Exterminator sallocator (DieFast) inherits from DieHard its im\u00admunity from twoother \ncommon memory errors: double frees,when a heap object is deallocated multiple times without an intervening \nallocation, and invalid frees, when a program deallocates an object that was never returned by the allocator. \nThese errors have serious Figure 1. An abstract view of Exterminator s heap layout. Meta\u00addata below the \nhorizontal line contains information used for error isolation and correction (see Section 3.2). consequences \nin other systems, where they can lead to heap cor\u00adruption or abrupt program termination. Exterminator \nprevents these invaliddeallocation requests from havinganyimpact.DieFast s bitmap-based allocator (Section \n3.2) makes multiple frees benign since a bit can only be reset once. By checking ranges, DieFast detects \nand ignores invalid frees. 2.1 Limitations Exterminator s ability to correct both dangling pointer errors \nand buffer over.ows has several limitations. First, Exterminator as\u00adsumes that buffer over.ows always \ncorrupt memory at higher addresses that is, they are forward over.ows. While it is possible to extend \nExterminator to handle backwards over.ows, we have not implemented this functionality.Exterminator can \nonly correct .nite over.ows, so that it can contain anygiven over.ow by over\u00adallocation. Similarly, Exterminator \ncorrects dangling pointer errors by inserting .nite delays before freeing particular objects. Finally, \nin iterated and replicated modes, Exterminator assumes that over\u00ad.ows and dangling pointer errors are \ndeterministic. However, the cumulative mode does not require deterministic errors. Unlike DieHard, Exterminator \ndoes not detect uninitialized reads, where a program makes use of a value left over in a previously-allocated \nobject. Because the intended value is un\u00adknown, it is not generally possible to repair such errors without \nadditional information, e.g. data structure invariants[12]. Instead, Exterminator .lls all allocated \nobjects with zeroes. 3. Software Architecture Exterminator ssoftware architectureextends and modi.es \nDieHard to enable its error isolating and correcting properties. This section .rst describes DieHard, \nand then shows how Exterminator aug\u00adments its heap layout to track information needed to identify and \nremedy memory errors. Second, it presents DieFast, a probabilistic debugging allocation algorithm thatexposes \nerrorsto Exterminator. Finally, it describes Exterminator s three modes ofoperation. 3.1 DieHard Overview \nThe DieHard system includes a bitmap-based, fully-randomized memory allocator that provides probabilistic \nmemory safety [3]. The latest version of DieHard, upon which Exterminator is based, adaptively sizes \nits heap be M times larger than the maximum neededby the application[4](see Figure2). ThisversionofDie-Hard \nallocates memory from increasingly large chunks that we call Figure 2. Theadaptive(new) DieHardheaplayout,usedbyExter\u00adminator. \nObjects in the same size class are allocated randomly from separate miniheaps, which combined hold M \ntimes more memory than required (here, M= 2). int computeHash (int * pc) int hash = 5381; for (int i \n=0; i < 5; i++) hash = ((hash << 5) + hash) + pc[i]; return hash; Figure 3. Site information hash function, \nused to store allocation and deallocation call sites (see Section 3.2). miniheaps. Each miniheap contains \nobjects of exactly one size. If an allocation would cause the total number of objects to exceed 1/M, \nDieHard allocates a new miniheap that is twice as large as the previous largest miniheap. Allocation \nrandomly probes a miniheap s bitmap for the given size class for a free bit: this operation takes O(1) \nexpected time. Freeing a valid object resets the appropriate bit. DieHard s use of randomization acrossanover-provisionedheapmakesit \nprobabilis\u00adtically likely thatbufferover.ows will land on free space, and un\u00adlikely that a recently-freed \nobject will be reused soon, making dan\u00adgling pointer errors rare. DieHard optionally uses replication \nto increase the probabil\u00adity of successful execution. In this mode, it broadcasts inputs to a number \nof replicas of the application process, each equipped with a different random seed.A voter intercepts \nand compares outputs across the replicas, and only actually generates output agreed on by a plurality \nof the replicas. The independent randomization of each replica s heap makes the probabilities of memory \nerrors inde\u00adpendent. Replicationthusexponentially decreasesthelikelihoodof a memory error affecting output, \nsince the probability of an error striking a majority of the replicas is low. 3.2 Exterminator s Heap \nLayout Figure1presents Exterminator s heap layout, which includes .ve .elds per object for error isolation \nand correction: an object id, al\u00adlocation and deallocation sites, deallocation time, which records when \nthe object was freed, and a canary bitset that indicates if the object was .lled with canaries (Section \n3.3). An object id of n means that the object is the nth object allo\u00adcated. Exterminator uses object \nids to identify objects across multi\u00adple heaps. These ids are needed because the object saddress cannot \nbe used to identify it across differently-randomized heaps. The site information .elds capture the calling \ncontext for allo\u00adcations and deallocations.For each, Exterminator hashes the least signi.cant bytes of \nthe .ve most-recent return addresses into 32 bits using the DJB2 hash function[6](see Figure3). This \nout-of-band metadata accounts for approximately 16 bytes plus two bits of space overhead for every object. \nThis overhead is void * diefast_malloc (size_t sz) { void * ptr = really_malloc (sz); // Check if the \nobject wasn t // canary-filled or is uncorrupted. bool ok = verifyCanary (ptr); if (!ok) { mark allocated; \nsignal error } return ptr; } void diefast_free (void ptr) { really_free (ptr); * // Check preceding and \nfollowing objects. bool ok = true; if (isFree (previous (ptr))) ok &#38;= verifyCanary (previous(ptr)); \nif (isFree (next(ptr))) ok &#38;= verifyCanary (next(ptr)); if (!ok) { signal error; } // Probabilistically \nfill with canary. if (notCumulativeMode || random() < p) fillWithCanary (ptr); } Figure 4. Pseudo-code \nfor DieFast, a probabilistic debugging al\u00adlocator (Section 3.3). comparable to that of typical freelist-based \nmemory managers like the Lea allocator, which prepend 8-byte (on 32-bit systems) or 16\u00adbyte headers (on \n64-bit systems) to allocated objects[24]. 3.3 DieFast:AProbabilisticDebuggingAllocator Exterminator \nuses a new, probabilistic debugging allocator that we call DieFast. DieFast uses the same randomized \nheap layout as DieHard,butextendsits allocationand deallocation algorithmsto detect and expose errors. \nFigure 4 presents pseudo-code for the DieFast allocator. Unlike previous debugging allocators, DieFast \nhas a number of unusual characteristics tailored for its use in the context of Exterminator. ImplicitFence-posts \nMany existing debugging allocators pad allocated objects with fence-posts (.lled with canary values) \non both sides. Theycan thus detect buffer over.ows by checking the integrity of these fence\u00adposts. This \napproach has the disadvantage of increasing space re\u00adquirements. Combined with the already-increased \nspace require\u00adments of a DieHard-based heap, the additional space overhead of padding may be unacceptably \nlarge. DieFast exploits two facts to obtain the effect of fence-posts without anyadditional space overhead. \nFirst, because its heap lay\u00adout is headerless, one fence-post serves double duty: a fence-post following \nan object can act as the one preceding the next object. Second, because allocated objects are separatedby \nE(M-1) freed objects on the heap, we use freed space to act as fence-posts. Random Canaries Traditional \ndebugging canaries include values that are readily dis\u00adtinguished from normal program data in a debugging \nsession, such as the hexadecimal value 0xDEADBEEF. However, one drawback of a deterministically-chosen \ncanary is that it is always possible for the program to use the canary pattern as a data value. Because \nDieFast uses canaries located in freed space rather than in allocated space,a.xed canarywouldleadtoahighfalsepositiverateifthat \ndata value were common in allocated objects. DieFast instead uses a random 32-bit value set at startup. \nSince both the canary and heap addresses are random and differ on every execution, any .xed data value \nhas a low probability of colliding with the canary, thus ensuringalowfalse positive rate (see The\u00adorem2).To \nincrease the likelihood of detecting an error, DieFast sets the last bit of the canary. Setting this \nbit will cause an align\u00adment error if the canary is dereferenced,butkeeps the probability of an accidental \ncollision with the canary low (1/231). ProbabilisticFence-posts Intuitively, the most effective way to \nexpose a dangling pointer er\u00adror is to .ll all freed memory with canary values. For example, dereferencinga \ncanary-.lled pointer will likely triggera segmenta\u00adtion violation. Unfortunately, reading random values \ndoes not necessarily cause programs to fail. For example, in the espresso bench\u00admark, some objects holdbitsets. \nFillinga freed bitsetwitha ran\u00addomvalue does not cause the programto terminatebutonlyaffects the correctness \nof the computation. If reading from a canary-.lleddangling pointer causes a pro\u00adgram to diverge, there \nis no way to narrow down the error. In the worst-case, half of the heap could be .lled with freed objects, \nall overwritten with canaries. All of these objects would then be po\u00adtential sources of dangling pointer \nerrors. In cumulative mode, Exterminator prevents this scenario by non-deterministically writing canaries \ninto freed memory randomly with probability p, and setting the appropriate bit in the canary bitmap. \nThis probabilistic approach may seem to degrade Exter\u00adminator s ability to .nd errors. However, it is \nrequired to isolate read-only dangling pointer errors, where the canary itself remains intact. Because \nit would take an impractically large number of iter\u00adations or replicas to isolate these errors, Exterminator \nalways .lls freed objects with canaries when not running in cumulative mode (see Sections 5.2 and 7.2 \nfor discussion). Probabilistic Error Detection Whenever DieFast allocates memory, it examines the memory \nto be returned to verify that anycanaries are intact. If not, in addition to signalling an error (see \nSection 3.4), DieFast sets the allocated bit for this chunk of memory. This bad object isolation ensures \nthat the object will not be reused for future allocations, preserving its contents for Exterminator s \nsubsequent use. Checking canary integrity on each allocation ensures that DieFast will detect heap corruption \nwithin E(H) allocations, where H is the number of objects on the heap. Afterevery deallocation, DieFast \nchecks both the preceding and subsequent objects.For each of these, DieFast checks if they are free. \nIf so, it performs the same canary check as above. Recall that because DieFast s allocation is random, \nthe identity of these adja\u00adcent objects will differ from run to run. Checking the predecessor and successoroneachfreeallowsDieFastto \ndetectbufferoverruns immediately upon object deallocation.  3.4 Modes of Operation Exterminator can \nbe used in three modes of operation: an iterative mode suitable for testing or whenever all inputs are \navailable, a replicated mode that is suitable both for testing and for restricted deployment scenarios, \nand a cumulative mode that is suitable for broad deployment. All of these rely on the generation of heap \nim\u00adages, which Exterminator examines to isolate errors and compute runtime patches. If Exterminator discovers \nan error when executing a program, or if DieFast signals an error, Exterminator forces the process to \nemit a heap image .le. This .le is akin to a core dump, but contains less data (e.g., no code), and is \norganized to simplify processing. In addition to the full heap contents and heap metadata, the heap image \nincludes the current allocation time (measured by the number of allocations to date). Iterative Mode \nExterminator s iterative mode operates without replication.To .nd a singlebug, Exterminatoris initiallyinvokedviaa \ncommand-line option that directs it to stop as soon as it detects an error. Exter\u00adminator then re-executes \nthe program in replay mode over the same input (but with a new random seed). In this mode, Extermi\u00adnator \nreads the allocation time from the initial heap image to abort execution at that point; we call this \na malloc breakpoint. Extermi\u00adnator then begins execution and ignores DieFast error signals that are raised \nbefore the malloc breakpoint is reached. Once it reaches the malloc breakpoint, Exterminator triggers \nanother heap image dump. This process can be repeated multiple times to generate independent heap images. \nExterminator then per\u00adforms post-mortem error isolation and runtime patch generation. A small number \nof iterations usually suf.ces for Exterminator to generate runtime patches for an individual error, as \nwe show in Section 7.2. When run with a correcting memory allocator that in\u00ad corporates these changes \n(described in detail in Section 6.3), these patches automatically .x the isolated errors. Replicated \nMode The iterated mode described above works well when all inputs are available so that re-running an \nexecution is feasible. However, when applications are deployed in the .eld, such inputs may not be available, \nand replaying may be impractical. The replicated mode of operation allowsExterminator to correct errors \nwhile the program is running, without the need for multiple iterations. Like DieHard, Exterminator can \nrun a number of differently\u00adrandomized replicas simultaneously (as separate processes), broad\u00adcasting \ninputstoallandvotingon their outputs.However, Extermi\u00adnator uses DieFast-based heaps, each with a correcting \nallocator. This organization lets Exterminator discover and.x errors. In replicated mode, when DieFast \nsignals an error or the voter detectsdivergent output, Exterminator sendsasignal that triggersa heap \nimage dump for each replica. If the program crashes because of a segmentation violation, a signal handler \nalso dumps a heap image. If DieFast signals an error, the replicas that dump a heap im\u00adage do not have \nto stop executing. If their output continues to be in agreement, they can continue executing concurrently \nwith the er\u00adror isolation process. When the runtime patch generation process is complete, that process \nsignals the running replicas to tell the cor\u00adrecting allocators to reload their runtime patches. Thus, \nsubsequent allocations in the same process will be patched on-the-.y without interrupting execution. \nCumulative Mode While the replicated mode can isolate and correct errors on-the\u00ad.y in deployed applications, \nit may not be practical in all situa\u00adtions.Forexample, replicating applications withhigh resource re\u00adquirements \nmay cause unacceptable overhead. In addition, multi\u00adthreaded or non-deterministic applications can exhibit \ndifferent al\u00adlocation activity and so cause object ids to diverge across replicas. To support these applications, \nExterminator uses its third mode of operation, cumulative mode, which isolates errors without replica\u00adtion \nor multiple identical executions. When operating in cumulative mode, Exterminator reasons about objects \ngrouped by allocation and deallocation sites instead of individual objects, since objects are no longer \nguaranteed to be identical across different executions. Figure 5. Exterminator s replicated architecture \n(Section 3.4). Replicas are equipped with different seeds that fully randomize their DieFast-based heaps \n(Section 3.3), input is broadcast to all replicas,andoutput goestoavoter.Acrash, outputdivergence,or \nsignal from DieFast triggers the error isolator (Section4), which generates runtime patches. These patches \nare fed to correcting al\u00adlocators (Section6), which .x thebug for current and subsequent executions. \nBecause objects from a given site only occasionally cause er\u00adrors, often at low frequencies, Exterminator \nrequires more execu\u00adtions than in replicated or iterative mode in order to identify these low-frequency \nerrorswithoutahighfalse positive rate.Insteadof storing heap images from multiple runs, Exterminator \ncomputes relevant statistics about each run and stores them in its patch .le. The retained data is on \nthe order of a few kilobytes per execution, compared to tens or hundreds of megabytes for each heap image. \n4. Iterative and Replicated Error Isolation Exterminator employs two differentfamilies of error isolation \nal\u00adgorithms: one set for replicated and iterative modes, and another for cumulative mode. When operating \nin its replicated or iterative modes, Extermina\u00adtor s probabilistic error isolation algorithm operates \nby searching for discrepancies across multiple heap images. Exterminator relies on corrupted canaries \nto indicate the presence of an error.A cor\u00adrupted canary(onethathasbeenoverwritten)can meantwothings: \nif every object has the same corruption, then it is likely a dangling pointer error,as Theorem1shows.If \ncanariesare corruptedinmul\u00ad tiple objects, thenitislikelytobeabufferover.ow. Exterminator limitsthenumberoffalsepositivesforbothover.owsand \ndangling pointer errors. 4.1 Buffer Over.ow Detection Exterminator examines heap images looking for discrepancies \nacrosstheheaps,bothinoverwrittencanariesandinlive objects.If an object is not equivalent across the heaps \n(see below), Extermi\u00adnator considers it to be a candidate victim of an over.ow. To identify victim objects, \nExterminator compares the contents ofboth objects identi.edby their objectid across all heaps,word\u00adby-word. \nExterminator builds an over.ow mask that comprises the discrepancies found across all heaps. However, \nbecause the same logical object may legitimately differ across multiple heaps, Exterminator must take \ncare not to consider these as over.ows. First,afreedobjectmaydiffer acrossheaps becauseitwas .lled with \ncanaries only in some of the heaps. Exterminator uses the canary bitmap to identify this case. Second, \nan object can contain pointers to other objects, which are randomly located on their respective heaps. \nExterminator uses both deterministic and probabilistic techniques to distinguish inte\u00adgers from pointers. \nBrie.y,ifavalue interpretedasa pointer points inside the heap area and points to the same logical object \nacross all heaps, then Exterminator considers it to be the same logical pointer, and thus not a discrepancy. \nExterminator also handles the case where pointers point into dynamic libraries, which newer ver\u00adsions \nof Linux place at random base addresses. Finally, an object can contain values that legitimately differ \nfrom process to process. Examples of these values include pro\u00adcess ids, .le handles, pseudorandom numbers, \nand pointers in data structures that depend on addresses (e.g., some red-black tree im\u00adplementations). \nWhen Exterminator examines an object and en\u00adcountersanywordthatdiffersatthesameposition acrosstheheaps, \nit considers it to be legitimately different, and not an over.ow. For small to modest over.ows, the risk \nof missing an over.ow by ignoring overwrites of the same objects across multiple heaps is low: Theorem \n1. Let k be the number of heap images, S the length (in number of objects)of theover.ow string,andHthe \nnumberof objectsonthe heap. Thentheprobabilityofanover.owoverwriting kobjects identically is at most: \n11 P(identical over.ow) = . 2k \u00d7 (H- S)k Proof. Assume thatbufferover.owsoverwrite past the endof an \nobject. Thus, for anover.owfrom object ito land onagiven object j, it must both precede it and be large \nenough to span the distance from i to j. An object i precedes j in k heaps with probability (1/2)k. Objects \ni and jare separated by S or fewer objects with probability at most (1/(H- S))k. Combining these terms \nyields the above formula. We now bound the worst-case false negative rate for buffer over.ows;thatis,theoddsofnot.ndingabufferover.ow \nbecause itfailedtooverwriteanycanaries. Theorem 2. LetMbetheheap multiplier,soaheapisnever more than \n1/M full. The likelihood that an over.ow of length b bytes fails to be detected by comparison against \na canary is at most: k M- 11 P(missed over.ow) =1- + . 2M256b Proof. Each heap is at least (M- 1)/M free. \nSince DieFast .lls free space with canaries with P= 1/2, the fraction of each heap .lled with canaries \nis at least (M- 1)/2M. The likelihood of a random write not landing on a canary across all k heaps is \nthus at most (1- (M- 1)/2M)k. The over.ow string could also match the canary value. Since the canary \nis randomly chosen, the odds of this are at most (1/256)b . Culprit Identi.cation At this point, Exterminator \nhas identi.ed the possible victims of over.ows.Foreach victim,it scanstheheapimagesfora matching culprit, \nthe source of the over.ow into a victim. Because Extermi\u00adnator assumes that over.ows are deterministic \nwhen operating in iterative or replicated modes, the culprit must be the same distance d bytes away from \nthe victim in every heap image. In addition, Ex\u00adterminator requires that the over.owed values have some \nbytes in common across the images, and ranks them by their similarity. Exterminator checks every other \nheap image for the candidate culprit, and examines the object that is the same d bytes forwards. If that \nobjectis free and shouldbe .lled with canariesbut they are not intact, then it adds this culprit-victim \npair to the candidate list. We nowbound thefalse positive rate. Becausebufferover.ows can be discontiguous, \nevery object in the heap that precedes an over.ow is a potential culprit. However, each additional heap \ndra\u00admatically lowers this number: Theorem 3. The expected number of objects (possible culprits) the same \ndistance d fromany given victim object acrosskheaps is: 1 E(possible culprits) = . (H- 1)k-2 Proof. Without \nloss of generality, assume that the victim object occupies the last slot in every heap. An object can \nthus be in anyof the remaining n= H-1slots.Theoddsofitbeinginthe sameslot in kheaps is p= 1/(H- 1)k-1. \nThis is a binomial distribution, so E(possible culprits) = np= 1/(H- 1)k-2. With only one heap image, \nall(H-1) objects are potential culprits, but one additional image reduces the expected number of culprits \nfor any victim to just1(1/(H- 1)0), effectively eliminating the riskoffalse positives. Once Exterminator \nidenti.esa culprit-victimpair,it recordsthe over.ow size for that culprit as the maximum of anyobserved \nd to a victim. Exterminator also assigns each culprit-victim pair a score that corresponds to its con.dence \nthat it is an actual over.ow. This score is1 - (1/256)S, where Sis the sum of the length of detected \nover.ow strings across all pairs. Intuitively, small over.ow strings (e.g., one byte) detected in only \na few heap images are given lower scores, and large over.ow strings present in manyheap images get higher \nscores. Afterover.ow processing completesandat least one culprithas a non-zero score, Exterminator generates \na runtime patch for an over.ow from the most highly-ranked culprit.  4.2 DanglingPointer Isolation Isolating \ndangling pointer errors falls into two cases: a program may read and write to the dangled object, leaving \nit partially or completely overwritten, or it may only read through the dangling pointer. Exterminator \ndoes not handle read-only dangling pointer errors in iterative or replicated mode because it would require \ntoo many replicas (e.g., around 20; see Section 7.2). However, it handles overwritten dangling objects \nstraightforwardly. When a freed object is overwritten with identical values across multiple heap images, \nExterminator classi.es the error as a dan\u00adgling pointer overwrite. As Theorem 1 shows, this situation \nis highly unlikely to occur for a buffer over.ow. Exterminator then generates an appropriate runtime \npatch, as Section 6.2 describes. 5. Cumulative Error Isolation When operating in cumulative mode, Exterminator \nisolates mem\u00adory errors by computing summary information accumulated over multiple executions, rather \nthan by operating over multiple heap images. This mode lets Exterminator isolate memory errors with\u00adout \nthe needfor replication, identical inputs, or deterministicexe\u00adcution. 5.1 Buffer Over.ow Detection Exterminator \ns buffer over.ow isolation algorithm proceeds in three phases. First,it identi.esheap corruptionbylookingforover\u00adwritten \ncanary values. Second, for each allocation site, it computes an estimate of the probability that an object \nfrom that site could be the source of the corruption. Third, it combines these indepen\u00addent estimates \nfrom multiple runs to identify sites that consistently appear as candidates for causing the corruption. \nAfter computing the set of corrupt object slots, Exterminator examines allocation sites and .nds possible \nculprits. To reason about an individual allocation site, Exterminator must consider all observed objects \nfrom that site. An object that causes corruption by a forward over.ow (i.e., it corrupts memory at higher \naddresses) must satisfy two crite\u00adria. First, it must lie on the same miniheap as the corruption. Be\u00adcause \nminiheaps are randomly located throughout the whole ad\u00address space, we assume that the probability that \nanover.owcrosses miniheap boundaries to cause corruption without .rst causing a segmentation violationisnegligible. \nSecond,theover.owed object must lie at a lower address than the corruption. For each object, the error \nisolation algorithm computes the prob\u00adability that the object satis.es these criteria. The total probability \nis the product of the probabilities of being allocated in the same mini\u00adheap (the left-hand term below), \ntimes the probability of itfalling on the left side of the corruption (the right-hand term). The .rst \nterm is the size of the corrupt miniheap, divided by the sum of the sizes of all miniheaps available \nin the size class at the time the ob\u00adject was allocated. Let Mc be the corrupted miniheap, kthe index \nof the corrupted slot in Mc, t(i) and t(Mj) the allocation time of object ior miniheap Mj, respectively, \nand size(Mi) the number of object slots in miniheap Mi. The probability P(Ci) that object isat\u00adis.es \nthe criteria is then: size'(i,Mc) k P(Ci)= \u00b7 .Mjsize'(i,Mj) size(Mc) where 0 t(Mj) > t(i)size'(i,Mj)=size(Mj) \nt(Mj) = t(i). For each allocation site A, Exterminator then computes the probability P(CA) that at least \none object from the site satis.ed the criteria (1 minus the probability of all objects not satisfying) \nas P(CA)= 1- . 1- P(Ci). i from A This value P(CA), combined with the actual observed valueCA, is the \ncomplete summary that Exterminator computes and stores between runs. Intuitively, each run can be thought \nof as a coin .ip, where P(CA) is the probability of heads, and CA = 1if the coin .ip resulted in heads. \nUsing the estimates from multiple runs, Exterminator then iden\u00adti.es allocation sites that satisfy the \ncriteria more than expected by random chance. These allocation sites are those that generate over\u00ad.owed \nobjects. Let .A be the probability that an observed corrupted objectwas causedbyanover.owfrom an object \nallocated from site A.For sites with noover.owerrors, .A= 0.For sites with errors, .A is some value greater \nthan zero, depending on the number of other bugs in the program. The algorithm compares the likelihoods \nof the twocompetinghypotheses: H0:.A= 0(no errors), andH1:.A > 0 (some error). Exterminator s error classi.er \ntakes as input the sequence of computed probabilities Xi= P(CA) and the observedvalues Yi= CA from each \nrun. Using a Bayesian model, Exterminator rejects H0 \u00af\u00af and identi.es Aas an error source when P(H1|X\u00af,Y) \n> P(H1|X\u00af,Y). This condition is equivalent (using Bayes rule) to \u00af P(X\u00af,Y|H1) P(H0) >. P(X\u00af,Y\u00af|H0) P(H1) \nBecause the true prior probabilities of the hypotheses are un\u00adknown, Exterminator estimates them. Different \nestimates trade off betweenfalse positiverateandthe numberof runs requiredto iden\u00adtify true errors. Usingapriorprobability \nP(H1)= 1/cN,whereNis the total number of allocation sites and casmall constant (currently, c = 4) generally \nproduces a well-behaved classi.er. This prior is reasonable because there is some probability that the \ncorruption was caused by an over.ow (as opposed to a dangling pointer), rep\u00adresentedby the1/c factor, \nand a small probability that each alloca\u00adtion siteis the culprit (the1/Nfactor). Finally, Exterminator \ncomputes the above values and compares them. Assuming H0, each independent run i has a Xi = P(CA) chance \nthat Yi = 1.By the product rule, \u00af P(X\u00af,Y|H0)= . (1- Xi)(1-Yi)+ XiYi . i Computing the likelihood of \nH1 requires consideration of all possible values of .A. The probability of Yi is then the causation probability \n.A, plus the probability due to random chance, (1- .A)Xi.We assume a uniform prior distribution on .A, \nthat is, 10< .A = 1 P(.A)= 0 otherwise The likelihood is then: 1 1- (1- .A)Xi- .A 1-Yi \u00af0 i +(1- .A)Xi+ \n.A Yi P(X\u00af,Y|H1)=. d.. Once Exterminator identi.es an erroneous allocation site A, it producesa runtime \npatch that corrects the error.To .nd the correct padding value, it searches backwards from the corruption \nfound during the current run until it .nds an object allocated from A. It then uses the distance between \nthat object and the end of the corruption as the padding value.  5.2 DanglingPointer Isolation As with \nbuffer over.ows, dangling pointer isolation proceeds by computing summary informationovera numberof runs.To \nforce each runtohaveadifferenteffect,Exterminator .lls freed objects with canaries with some probability \np, turningeveryexecution into a series of Bernoulli trials. If overwriting a prematurely-freed ob\u00adject \nwith canaries leads to an error, then its overwrite will correlate withafailedexecution with probability \ngreater than p. Conversely, if an object was not prematurely freed, then overwriting it with ca\u00adnaries \nshouldhave no correlation with thefailure or successof the program. For eachfailed run, Exterminator \ncomputes the probability that an objectwas canaried from each allocation site.Asin thebuffer over.ow \ncase, the summary information required is simply this probability(Xi)and whether or not a canary was \nobserved(Yi). Because the meaning of this data is the same as in thebuffer over.ow algorithm, Exterminator \nuses the samehypothesis test to compute the likelihood that each allocation site is the source of a dangling \npointer error. The choice of p re.ects a tradeoff between the precision of thebufferover.ow algorithm \nand dangling pointer isolation. Since over.ow isolation relies on detecting corrupt canaries, low values \nof pincrease the number of runs (though not the number of failures) required to isolate over.ows. However, \nlower values of pincrease the precision of dangling pointer isolation by reducing the risk that certain \nallocation sites willalways observe one canaryvalue.We currently set p= 1/2, though some dangling pointer \nerrors may require lower values of pto converge within a reasonable number of runs. Exterminator then \nestimates the required lifetime extension by locating the oldest canaried object from an identi.ed allocation \nsite, and computing the number of allocations between the time itwas freed and the time that the programfailed. \nThe correcting allocator then extends the lifetime of all objects corresponding to this allocation/deallocation \nsiteby twice this number. void * correcting_malloc (size_t sz) // Update the allocation clock. clock++; \n// Free deferred objects. while (deferralQ.top()->time <= clock) really_free (deferralQ().pop()->ptr); \nint allocSite = computeAllocSite(); // Find the pad for this site. int pad = padTable (allocSite); void \n* ptr = really_malloc (sz + pad); // Store object info and return. setObjectId (ptr, clock); setAllocSite \n(ptr, allocSite); return ptr; void correcting_free (void * ptr) // Compute site info for this pointer. \nint allocS = getAllocSite (ptr); int freeS = computeFreeSite(); setFreeSite (ptr, freeS); // Defer or \nfree? int defer = deferralMap (allocS, freeS); if (defer == 0) really_free (ptr); else deferralQ.push \n(ptr, clock + defer); Figure 6. Pseudo-code for thecorrecting memory allocator, which incorporates the \nruntime patches generated by the error isolator. 6. Error Correction We now describe how Exterminatoruses \nthe information from its error isolation algorithms to correct speci.c errors. Exterminator .rst generates \nruntimepatchesforeach error.Itthen reliesonacor\u00adrecting allocator that uses this information, padding \nallocations to prevent over.ows, and deferring deallocations to prevent dangling pointer errors. 6.1 \nBuffer over.ow correction For every culprit-victim pair that Exterminator encounters, it gen\u00aderates a \nruntime patch consisting of the allocation site hash and the padding needed to contain theover.ow(d + \nthe size of the over\u00ad.ow). If a runtime patch has already been generated for a given allocation site, \nExterminator uses the maximum padding value en\u00adcountered sofar. 6.2 Dangling pointer correction The \nruntime patch for a dangling pointer consists of the combi\u00adnation of its allocation site info and a time \nby which to delay its deallocation. Exterminator computes this delay as follows. Let t be the recorded \ndeallocation time of the dangled object, and T be the last allocationtime. Exterminatorhasnowayofknowinghowlong \nthe object is supposed to live, so computing an exact delay time is impossible. Instead, it extends the \nobject s lifetime (delays its free) by twice the distance between its premature free and the last allocation \ntime, plus one:2 \u00d7 (T- t)+ 1. This choice ensures that Exterminator will compute a correct patch in a \nlogarithmic number of executions. As we show in Sec\u00adtion 7.2,multiple iterations to correct pointer errors \nare rare in prac\u00ad tice, because the last allocation time can be well past the time that the object should \nhave been freed. It is important to note that this deallocation deferral does not multiply its lifetimebutrather \nits drag [39].To illustrate, an object mightlivefor1000 allocationsandthenbefreedjust10allocations too \nsoon. If the program immediately crashes, Exterminator will extend its lifetimeby21 allocations, increasing \nits lifetimeby less than 1% (1021/1010). Section 7.3 evaluates the impact of both over.ow and dangling \npointer correction on space consumption. 6.3 The Correcting Memory Allocator The correcting memory allocator \nincorporates the runtime patches described above and applies them when appropriate. Figure 6 presents \npseudo-code for the allocation and deallocation functions. At start-up, or upon receiving a reload signal \n(Section 3.4), the correcting allocator loads the runtime patches from a speci.ed .le. Itbuilds two hash \ntables:a pad table mapping allocation sites to pad sizes, and a deferral table, mapping pairs of allocation \nand deallocation sitestoadeferralvalue. Becauseit can reloadthe run\u00adtime patch .le and rebuild these \ntables on-the-.y, Exterminator can apply patches to runningprograms without interrupting their exe\u00adcution. \nThis aspect of Exterminator s operation may be especially useful for systems that mustbekept running \ncontinuously. On every deallocation, the correcting allocator checks to see if the objecttobe freed needstobe \ndeferred.Ifit .ndsadeferralvalue for the object s allocation and deallocation site, it pushes onto the \ndeferral priority queue the pointer and the time to actually free it (the current allocation time plus \nthe deferral value). The correcting allocator then checks the deferral queue onevery allocation to see \nif an object should now be freed. It then checks whether the current allocation site has an associated \npad value. If so, it adds the padvalue to the allocation request, and forwards the allocation request \nto the underlying allocator.  6.4 Collaborative Correction Each individual user of an application is \nlikely to experience dif\u00adferent errors. To allow an entire user community to automatically improve software \nreliability, Exterminator provides a simple util\u00adity that supports collaborative correction. This utility \ntakes as input a number of runtime patch .les. It then combines these patches by computingthe maximumbufferpad \nrequiredforanyallocationsite, and the maximal deferral amount for anygiven allocation site. The result \nis a new runtime patch .le that covers all observed errors. Because the size of patch .les is limited \nby the number of alloca\u00adtion sites in a program, we expect these .les to be compact and practicalto transmit.Forexample,thesizeofthe \nruntime patches that Exterminator generates for injected errors in espresso was just 130K, and shrinks \nto 17K when compressed with gzip. 7. Results Our evaluation answers the following questions: (1) What \nis the runtime overhead of using Exterminator? (2) How effective is Ex\u00adterminator at .nding and correcting \nmemory errors, both for in\u00adjected and realfaults?(3) Whatis theoverheadof Exterminator s runtime patches? \n7.1 Exterminator Runtime Overhead We evaluate Exterminator s performance with the SPECint2000 suite [43] \nrunning reference workloads, as well as a suite of allocation-intensive benchmarks.We use the latter \nsuite of bench\u00admarks both because they are widely used in memory management studies [3, 19, 22], and \nbecause their high allocation-intensity stresses memory management performance. For all experiments, \nwe .x Exterminator s heap multiplier(valueof M)at 2. All results are the average of .ve runs on a quiescent, \ndual\u00adprocessor Linux system with3 GB of RAM, with each 3.06GHz Figure 7. Runtime overhead for Exterminator \nacross a suite of benchmarks, normalized to the performance of GNU libc (Linux) allocator. Intel Xeon \nprocessor (hyperthreading active) equipped with 512K L2 caches. Our observed experimental variance is \nbelow 1%. We focus on the non-replicated mode (iterative/cumulative), which we expect to be a key limiting \nfactor for Exterminator s performance and the most common usage scenario. We compare the runtime of Exterminator \n(DieFast plus the cor\u00adrecting allocator) to the GNU libc allocator. This allocator is based on the Lea \nallocator[24], whichis among thefastestavailable[5]. Figure7 shows that,versus this allocator,Exterminatordegrades \nperformanceby from0%(186.crafty)to 132%(cfrac), with ageometric meanof 25.1%. While Exterminator soverheadis \nsub\u00adstantial for the allocation-intensive suite(geometric mean: 81.2%), where the cost of computing allocation \nand deallocation contexts dominates, its overhead is signi.cantly less pronounced across the SPEC benchmarks \n(geometric mean: 7.2%). 7.2 Memory Error Correction InjectedFaults Tomeasure Exterminator seffectivenessat \nisolatingand correcting bugs, we used the fault injector that accompanies the DieHard distribution to \ninjectbufferover.ows anddangling pointer errors. For each data point, we run the injector using a random \nseed until it triggers an error or divergent output. We next use this seed to deterministically trigger \na single error in Exterminator, which we run in iterative mode. We then measure the number of iterations \nrequired to isolate and generate an appropriate runtime patch. The total number of images (iterations \nplus the .rst run) corresponds to the number of replicas that would be required when running Exterminator \nin replicated mode. Buffer over.ows: We triggered 10 different buffer over.ows each of three different \nsizes (4, 20, and 36 bytes) by under.owing objects in the espresso benchmark. The number of images re\u00adquiredto \nisolateand correct these errorswas3inevery case. Notice that this result is substantially better than \nthe analytical worst-case. For three images,Theorem2bounds theworst-case likelihoodof missinganover.owto42% \n(Section4.1), ratherthanthe0%false negative rate we observe here. Dangling pointer errors: We then triggered \n10 dangling pointer faults in espresso with Exterminator running in iter\u00adative and in cumulative modes. \nIn iterative mode, Exterminator succeeds in isolating the error in only 4 runs. In another 4 runs, espresso \ndoes not write through thedangling pointer. Instead,it reads a canary value through the dangled pointer, \ntreats it as valid data, and either crashes or aborts. Since no corruption is present in the heap, Exterminator \ncannot isolate the source of the error. In the remaining2runs, writingcanaries into the dangled object \ntrig\u00adgers a cascade of errors that corrupt large segments of the heap. In these cases, the corruption \ndestroys the information Exterminator requires to isolate the error. In cumulative mode, however, Exterminator \nsuccessfully iso\u00adlates all10 injected errors.For runs where no large-scale heap cor\u00adruption occurs, Exterminator \nrequires between 22 and 30 execu\u00adtionsto isolateand correctthe errors.Ineach case,15failures must be \nobserved before the erroneous site pair crosses the likelihood threshold. Because objects are overwritten \nrandomly, the number of runs requiredto yield15failuresvaries.Where writing canaries corruptsa large \nfractionof the heap, Exterminator requires18fail\u00adures and 34 total runs. In some of the runs, execution \ncontinues long enough for the allocator to reuse the culprit object, preventing Exterminator from observing \nthat it was overwritten. RealFaults We also tested Exterminator with actualbugs in two applications: \nthe Squid web caching server, and theMozilla web browser. Squid web cache: Version 2.3s5 of Squid has \na buffer over\u00ad.ow; certain inputs cause Squid to crash with either the GNU libc allocator or the Boehm-Demers-Weiser \ncollector[3, 32]. We run Squid three times underExterminatorin iterative mode with an input that triggersabufferover.ow. \nExterminator contin\u00aduesexecuting correctlyin each run,buttheover.ow corruptsa ca\u00adnary. Exterminator s \nerror isolation algorithm identi.es a single al\u00adlocation site as the culprit and generatesapadofexactly6bytes, \n.xing the error. Mozilla web browser: We also tested Exterminator s cumula\u00adtivemodeonaknownheapover.owin \nMozilla 1.7.3/Firefox 1.0.6 and earlier. This over.ow (bug 307259) occurs because of an error in Mozilla \ns processing of Unicode characters in domain names. Not only is Mozilla multi-threaded, leading to non-deterministic \nal\u00adlocation behavior,buteven slight differencesinmoving the mouse cause allocation sequences to diverge. \nThus, neither replicated nor iterativemodes can identify equivalent objects across multiple runs. We \nperform two case studies that represent plausible scenarios for using Exterminator s cumulative mode. \nIn the .rst study, the user starts Mozilla and immediately loads a page that triggers the error. This \nscenario corresponds to a testing environment where a proof-of-concept input is available. In the second \nstudy, the user .rst navigates through a selection of pages (different on each run), and then visits \nthe error-triggering page. This scenario approxi\u00admates deployed use where the error is triggered in the \nwild. In both cases, Exterminator correctly identi.es the over.ow with no false positives. In the .rst \ncase, Exterminator requires 23 runs to isolate the error. In the second, it requires 34 runs. We believe \nthat this scenario requires more runs because the site that produces the over.owed object allocates more \ncorrect objects, making it harder to identify it as erroneous.  7.3 Patch Overhead Exterminator s approach \nto correcting memory errors does not im\u00adpose additionalexecutiontimeoverheadinthe presenceof patches. \nHowever, it consumes additional space, either by padding alloca\u00adtions orby deferring deallocations.Wemeasure \nthe spaceoverhead forbufferover.ow correctionsby multiplyingthe sizeof thepad by the maximum number of \nlive objects that Exterminator patches. The most spaceoverhead we observeisfor thebufferover.owex\u00adperiment \nwith over.ows of size 36, where the total increased space overheadis between 320 and 2816bytes. We measure \nspaceoverheadfor dangling pointer correctionsby multiplying the object size by the number of allocations \nfor which the object is deferred; thatis, we compute the total additional drag. In the dangling pointer \nexperiment, the amount of excess memory rangesfrom32bytesto1024bytes(one256byteobjectis deferred for4 \ndeallocations). This amount constitutes less than 1% of the maximum memory consumed by the application. \n8. RelatedWork 8.1 Randomized Memory Managers Several memory management systems employ some degree of \nrandomization, including locating the heap at a random base ad\u00address[7, 31], adding random padding to \nallocated objects[8], shuf\u00ad.ing recently-freed objects[23], or a mix of padding and object deferral[32]. \nThislevelofrandomizationis insuf.cientfor Exter\u00ad minator, which requires full heap randomization. Exterminator \nbuilds on DieHard, which tolerates errors prob\u00adabilistically; Section 3.1 provides an overview. Exterminator \nsub\u00ad stantially modi.es and extends DieHard s heap layout and alloca\u00adtion algorithms. It also uses probabilistic \nalgorithms that identify and correct errors. 8.2 Automatic Repair Demsky et al. s automatic data structure \nrepair [11, 12, 13]en\u00adforces data structure consistencyspeci.cations, guidedbya formal description of \nthe program s data structures (speci.edmanually or derived automaticallyby Daikon[18]). Exterminator \nattacksa dif\u00ad ferent problem, namely that of isolating and correcting memory er\u00adrors, and is orthogonal \nand complementary to data structure repair. Sidiroglou et al. propose STEM, a self-healing runtime that \nex\u00adecutes functions in a transactional environment so that if theyde\u00adtect the function misbehaving, theycan \nprevent it from doing dam\u00adage[41]. Using STEM, theyimplement error virtualization, which maps the set \nof possible errors in a function onto those that have an explicit error handler. The more recent SEAD \nsystem goes beyond STEM requiring no source code changes, handling I/O with virtual proxies, and by specifying \nthe repair policy explicitly through an external description[42]. While STEM and SEAD are promising approaches \nto automatically recovering from errors, neither pro\u00advides solutions for as broad a class of errors as \nExterminator, nor do theyprovide mechanisms to semantically eliminate the source of the error automatically, \nas Exterminator does. 8.3 Automatic Debugging Two previous systems apply techniques designed to help \nisolate bugs. Statistical bug isolation is a distributed assertion sampling technique that helps pinpoint \nthe location of errors, includingbut not limited to memory errors[25, 26, 27]. It works by injecting \nlightweight tests into the source code; the result of these tests, in bit vector form, can be processed \nto generate likely sources of the errors.This statistical processingdiffersfrom Exterminator sprob\u00adabilistic \nerror isolation algorithms, although Liu et al. also usehy\u00adpothesis testing[27]. Like statisticalbug \nisolation, Exterminator can leverage the runs of deployed programs. However, unlike sta\u00adtisticalbug isolation, \nExterminator requires neither source code nor alargedeployed userbaseinorderto.nd errors,and automatically \ngenerates runtime patches that correct them. Delta debugging automates the process of identifying the \nsmall\u00adest possible inputs thatdo anddo notexhibitagiven error[10,28, 48]. Given these inputs, it is up \nto the software developer to ac\u00ad tually locate thebugs themselves. Exterminator focuses ona nar\u00adrowerclassof \nerrors,butisableto isolateand correctan errorgiven just one erroneous input, regardless of its size. \n 8.4 FaultTolerance Recently, there has been an increasing focus on approaches for tol\u00aderating hardware \ntransient errors that are becoming more common duetofabrication process limitations.Workin this area \nranges from proposed hardware support[33]to softwarefault tolerance[34]. While Exterminator also uses \nredundancy as a method for detect\u00ading and correcting errors, Exterminator goes beyond tolerating soft\u00adware \nerrors, which are not transient, to correcting them perma\u00adnently. Like Exterminator, other efforts in \nthefault tolerance com\u00admunity seek to gather data from multiple program executions to identify potential \nerrors.Forexample,Guoetal.use statisticaltech\u00adniqueson internal monitoringdatato probabilistically detectfaults, \nincludingmemory leaks and deadlocks[20].Exterminator goes be\u00ad yond this previous work by characterizing \neach memory error so speci.cally that a correction can be automatically generated for it. Rinard et al. \npresent a compiler-based approach called bound\u00adlessbuffers that caches out-of-bound writesina hash table \nfor later reuse[35].This approach eliminatesbufferover.ow errors (though not dangling pointer errors),but \nrequires source code and imposes higher performance overheads (1.05x to 8.9x). Rx operates by checkpointing \nprogram execution and logging inputs[32]. Rx rolls back crashed applications and replays inputs to it \nin a new environment that pads all allocations or defers all deallocations by some amount. If this new \nenvironment does not yield success, Rx rolls back the application again and increases the pad values, \nup to some threshold. Unlike Rx, Exterminator does not require checkpointing or rollback, and precisely \nisolates and corrects memory errors.  8.5 Memory Managers Conservative garbage collection prevents dangling \npointer er\u00adrors[9],but does not preventbufferover.ows. Exterminator serror isolationand correctionis \northogonaltogarbage collection. Finally, there have been numerous debugging memory alloca\u00adtors; the documentation \nfor one of them, mpatrol, includes a list of over ninety such systems[38]. Notable recent allocators \nwith de\u00ad bugging features include dnmalloc[47], Heap Server[23], andver\u00adsion 2.8of the Lea allocator[24,37]. \nExterminator either prevents or corrects errors that these allocators can only detect. 9. FutureWork \nWhile Exterminator can effectively locate and correct memory errors on the heap, it does not yet address \nstack errors. We are investigating approaches to apply Exterminator to the stack. In addition,while Exterminator \nsruntime patches contain infor\u00admation that describe the error location and its extent, it is not in a \nhuman-readable form.Weplantodevelopatoolto process runtime patches intobug reports with suggested .xes. \n10. Conclusion This paper presents Exterminator, a system thatautomatically cor\u00adrects heap-based memory \nerrors in C and C++ programs with high probability. Exterminator operates entirely at the runtime level \non unaltered binaries, and consists of three key components: (1) DieFast, a probabilistic debugging allocator, \n(2) a probabilistic er\u00adror isolation algorithm, and (3) a correcting memory allocator. Ex\u00adterminator \ns probabilistic error isolation isolates the source and ex\u00adtentof memory errors withprovablylowfalsepositiveandfalse \nnegative rates. Its correcting memory allocator incorporates run\u00adtime patches that the error isolation \nalgorithm generates to correct memory errors. Exterminator is not only suitable for use during testing,but \nalso can automatically correct deployed programs. Acknowledgments The authors would like to thank Sam \nGuyer, Mike Hicks, Erik Learned-Miller, Sarah Osentoski, Martin Rinard, and the anony\u00admous reviewers \nfor their valuable feedback. This material is based upon work supported by Intel, Microsoft Research, \nand the Na\u00adtional ScienceFoundation under CAREERAward CNS-0347339 and CNS-0615211. Anyopinions, .ndings, \nand conclusions or rec\u00adommendations expressed in this material are those of the author(s) and do not \nnecessarily re.ect the views of the National Science Foundation. References [1] T. M. Austin, S. E. Breach, \nand G. S. Sohi. Ef.cient detection of all pointer and array access errors. In Proceedings of theACM SIGPLAN \n1994 Conference on Programming Language Design and Implementation, pages 290 301, NewYork, NY, USA, 1994.ACM \nPress. [2] D. Avots, M. Dalton, V. B. Livshits, and M. S. Lam. Improving software security withaC pointer \nanalysis. In Proceedings of the 27th International Conference on Software Engineering, pages 332 341,NewYork,NY, \nUSA, 2005.ACM Press. [3] E. D. Berger and B. G. Zorn. DieHard: Probabilistic memory safety for unsafe \nlanguages. In Proceedings of the 2006ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 158 168,NewYork,NY, USA, 2006.ACM Press. [4] E. D. Berger and B. G. Zorn. Ef.cient probabilistic \nmemory safety. Technical Report UMCS TR-2007-17, Department of Computer Science, University of Massachusetts \nAmherst, Mar. 2007. [5] E. D. Berger, B. G. Zorn, and K. S. McKinley. Composing high\u00adperformance memory \nallocators. In Proceedings of the 2001ACM SIGPLAN Conference on Programming Language Design and Implementation, \nSnowbird, Utah, June 2001. [6] D. Bernstein. Usenet posting, comp.lang.c. http://groups.google.com/ group/comp.lang.c/msg/6b82e964887d73d9, \nDec. 1990. [7] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfuscation: An ef.cient approach to \ncombat a broad range of memory error exploits. In Proceedings of the 12th USENIX Security Symposium, \npages 105 120. USENIX, Aug. 2003. [8] S. Bhatkar, R. Sekar, and D. C. DuVarney. Ef.cient techniques for \ncomprehensive protection from memory error exploits. In Proceedings of the 14th USENIX Security Symposium, \npages 271 286. USENIX, Aug. 2005. [9] H.-J. Boehm and M.Weiser. Garbage collection in an uncooperative \nenvironment. Software Practice and Experience, 18(9):807 820, 1988. [10] H. Cleve and A. Zeller. Locating \ncauses of program failures. In Proceedings of the 27th International Conference on Software Engineering, \npages 342 351, 2005. [11] B. Demsky, M. D. Ernst,P. J. Guo, S. McCamant, J. H. Perkins, and M. Rinard. \nInference and enforcement of data structure consistency speci.cations. In Proceedings of the 2006 International \nSymposium on SoftwareTesting and Analysis, pages 233 244, NewYork, NY, USA, 2006.ACM Press. [12] B. Demskyand \nM. Rinard. Automatic detection and repair of errors in data structures. In Proceedingsof the 18th annualACM \nSIGPLAN Conference on Object-oriented Programing, Systems, Languages, and Applications, pages 78 95, \nNewYork, NY, USA, 2003.ACM Press. [13] B. Demskyand M. Rinard. Data structure repair using goal-directed \nreasoning. In Proceedings of the 27th International Conference on Software Engineering, pages 176 185, \n2005. [14] D. Dhurjati and V. Adve. Backwards-Compatible Array Bounds CheckingforCwithVeryLowOverhead.In \nProceedings of the 2006 International Conference on Software Engineering, Shanghai, China, May 2006. \n[15] D. Dhurjati and V. Adve. Ef.ciently Detecting All Dangling Pointer Uses in Production Servers. In \nInternational Conference on Dependable Systems and Networks (DSN 06), pages 269 280, 2006. [16] D. Dhurjati, \nS.Kowshik, andV. Adve. SAFEcode: enforcing alias analysis for weakly typed languages. In Proceedings \nof the 2006 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 144 157, \nNewYork, NY, USA, 2006.ACM Press. [17] D. Dhurjati, S.Kowshik,V. Adve, and C. Lattner. Memory safety \nwithout runtime checks orgarbage collection. In ACM SIGPLAN 2003 Conference on Languages, Compilers, \nandTools for Embedded Systems (LCTES 2003), San Diego, CA, June 2003.ACM Press. [18] M. D. Ernst, A. \nCzeisler,W. G. Griswold, and D. Notkin. Quickly detecting relevant program invariants. In Proceedings \nof the 22nd International Conference on Software Engineering, pages 449 458, NewYork,NY, USA, 2000.ACM \nPress. [19] D. Grunwald, B. Zorn, and R. Henderson. Improving the cache local\u00adity of memory allocation. \nIn Proceedings of SIGPLAN 93 Conference on Programming Languages Design and Implementation, volume 28(6) \nof ACM SIGPLAN Notices, pages 177 186, Albuquerque, NM, June 1993.ACM Press. [20]Z.Guo,G.Jiang,H.Chen,andK.Yoshihira.Tracking \nprobabilistic correlationof monitoringdataforfault detectionincomplex systems. In Proceedings of the \n2006 International Conference on Dependable Systems and Networks, pages 259 268, Los Alamitos, CA, USA, \n2006. IEEE Computer Society. [21] R. Hastings andB.Joyce. Purify:Fast detectionof memory leaks and access \nerrors. In Proc.oftheWinter1992 USENIXConference, pages 125 138, San Francisco, California, 1991. [22] \nM. S. Johnstone and P. R. Wilson. The memory fragmentation problem: Solved? InP. Dickman andP.R.Wilson, \neditors, OOPSLA 97Workshop on GarbageCollection and Memory Management,Oct. 1997. [23] M. Kharbutli, X. \nJiang, Y. Solihin, G. Venkataramani, and M. Prvulovic. Comprehensivelyand ef.ciently protecting the heap. \nIn Proceedings of the 12th International Conference on Architectural Support for Programming Languages \nand Operating Systems, pages 207 218,NewYork,NY, USA, 2006.ACM Press. [24] D. Lea.Amemory allocator. \nhttp://gee.cs.oswego.edu/dl/html/malloc.html. [25] B. Liblit, A. Aiken, A. Zheng, and M. Jordan. Bug \nisolation via remote program sampling. In Proceedings of the ACM SIGPLAN 2003 Conference on Programming \nLanguage Design and Implementation, 2003. [26] B. Liblit, M. Naik, A. X. Zheng, A. Aiken, and M. I. Jordan. \nScalable statisticalbug isolation. In Proceedings of theACM SIGPLAN 2005 Conference on Programming Language \nDesign and Implementation, pages 15 26,NewYork,NY, USA, 2005.ACM Press. [27] C. Liu, X.Yan, L. Fei, J. \nHan, and S.P. Midkiff. SOBER: statistical model-basedbug localization. In Proceedings of the 10th European \nSoftware Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations \nof Software Engineering, pages 286 295, New York, NY, USA, 2005. ACM Press. [28] G. Misherghi and Z. \nSu. HDD: Hierarchical delta debugging. In Proceedings of the 28th International Conference on Software \nEngineering, pages 142 151, New York, NY, USA, 2006. ACM Press. [29] G. C. Necula, S. McPeak, and W. \nWeimer. CCured: type-safe retro.tting of legacy code. In Proceedings of the 29th ACM SIGPLAN-SIGACT symposium \non Principles of Programming Languages, pages 128 139,NewYork,NY, USA, 2002.ACM Press. [30] N. Nethercote \nand J. Fitzhardinge. Bounds-checking entire programs without recompiling. In SPACE 2004,Venice, Italy, \nJan. 2004. [31] PaX Team. PaX address space layout randomization (ASLR). http://pax.grsecurity.net/docs/aslr.txt. \n[32]F. Qin,J.Tucek,J. Sundaresan, andY. Zhou. Rx:Treatingbugs as allergies:Asafe method to survive softwarefailures. \nIn Proceedings of the Twentieth Symposium on Operating Systems Principles, volume XX of Operating Systems \nReview, Brighton, UK, Oct. 2005. ACM. [33] M. K. Qureshi, O. Mutlu, andY. N.Patt. Microarchitecture-based \nintrospection: a technique for transient-fault tolerance in micropro\u00adcessors. In Proceedings of the 2005 \nInternational Conference on Dependable Systems and Networks (DSN 2005), pages 434 443, 2005. [34] G. \nA. Reis, J. Chang, N.Vachharajani, R. Rangan, and D. I. August. SWIFT: Software ImplementedFaultTolerance. \nIn Proceedings of the International Symposium on Code Generation and Optimization, pages 243 254, Washington, \nDC, USA, 2005. IEEE Computer Society. [35]M.Rinard,C.Cadar,D. Dumitran,D.M.Roy,andT.Leu.Adynamic technique \nfor eliminatingbufferover.ow vulnerabilities (and other memory errors). In Proceedings of the 2004 Annual \nComputer Security Applications Conference, Dec. 2004. [36] M. Rinard,C. Cadar,D. Dumitran,D.M.Roy,T. \nLeu, andJ.William S. Beebee. Enhancing serveravailability and security throughfailure\u00adoblivious computing. \nIn Sixth Symposium on Operating Systems Design and Implementation,San Francisco, CA, Dec. 2004. USENIX. \n[37] W. Robertson, C. Kruegel, D. Mutz, and F. Valeur. Run-time detection of heap-based over.ows. In \nProceedings of the 17th Large Installation Systems Administration Conference, pages 51 60. USENIX, 2003. \n[38] G. S. Roy. mpatrol: Related software. http://www.cbmamiga.demon. co.uk/mpatrol/mpatrol 83.html, \nNov. 2006. [39] C. Runciman and N. Rojemo. Lag, drag and postmortem heap pro.ling. In Implementation \nof Functional LanguagesWorkshop, Bastad, Sweden, Sept. 1995. [40] J. Seward and N. Nethercote. Using \nValgrind to detect unde.ned value errors with bit-precision. In Proceedings of the USENIX 05 AnnualTechnical \nConference, Anaheim, California, USA, Apr. 2005. [41] S. Sidiroglou, M. E. Locasto, S. W. Boyd, and A. \nD. Keromytis. Building a reactive immune system for software services. In USENIX AnnualTechnical Conference, \npages 149 161. USENIX, 2005. [42]S. Sidiroglou,M.E. Locasto,S.W.Boyd,andA.D.Keromytis. From STEM to SEAD: \nSpeculative execution for automated defense. In USENIX AnnualTechnical Conference. USENIX, 2007. [43] \nStandard Performance Evaluation Corporation. SPEC2000. http://www.spec.org. [44] Symantec. Internet security \nthreat report. http://www.symantec.com/ enterprise/threatreport/index.jsp, Sept. 2006. [45] W. Xu, D. \nC. DuVarney, and R. Sekar. An ef.cient and backwards\u00adcompatible transformation to ensure memory safety \nofCprograms. In Proceedings of the 12th ACM SIGSOFT Twelfth International Symposium onFoundationsof Software \nEngineering, pages 117 126, NewYork,NY, USA, 2004.ACM Press. [46] S. H.Yong and S. Horwitz. ProtectingCprograms \nfrom attacks via invalid pointer dereferences. In 11thACM SIGSOFT International Symposium onFoundationsof \nSoftware Engineering, pages 307 316, NewYork,NY, USA, 2003.ACM Press. [47]Y.Younan,W. Joosen,F. Piessens,andH.V.den \nEynden. Security of memory allocators forC and C++. Technical Report CW 419, Department of Computer Science, \nKatholieke Universiteit Leuven, Belgium, July 2005. [48]A. Zeller.Yesterday,my programworked.Today,it \ndoes not.Why? In Proceedings of the 7th European SoftwareEngineering Conference held jointly with the \n7thACM SIGSOFT International Symposium on Foundations of Software Engineering, pages 253 267, London, \nUK, 1999. Springer-Verlag.     \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Programs written in C and C++ are susceptible to memory errors, including buffer overflows and dangling pointers. These errors, whichcan lead to crashes, erroneous execution, and security vulnerabilities, are notoriously costly to repair. Tracking down their location in the source code is difficult, even when the full memory state of the program is available. Once the errors are finally found, fixing them remains challenging: even for critical security-sensitive bugs, the average time between initial reports and the issuance of a patch is nearly one month.</p> <p>We present Exterminator, a system that automatically correct sheap-based memory errors without programmer intervention. Exterminator exploits randomization to pinpoint errors with high precision. From this information, Exterminator derives <i>runtime patches</i> that fix these errors both in current and subsequent executions. In addition, Exterminator enables collaborative bug correction by merging patches generated by multiple users. We present analytical and empirical results that demonstrate Exterminator's effectiveness at detecting and correcting both injected and real faults.</p>", "authors": [{"name": "Gene Novark", "author_profile_id": "81350568767", "affiliation": "University of Massachusetts Amherst, Amherst, MA", "person_id": "P871672", "email_address": "", "orcid_id": ""}, {"name": "Emery D. Berger", "author_profile_id": "81100228645", "affiliation": "University of Massachusetts Amherst, Amherst, MA", "person_id": "PP14089241", "email_address": "", "orcid_id": ""}, {"name": "Benjamin G. Zorn", "author_profile_id": "81100190820", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "P28972", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250736", "year": "2007", "article_id": "1250736", "conference": "PLDI", "title": "Exterminator: automatically correcting memory errors with high probability", "url": "http://dl.acm.org/citation.cfm?id=1250736"}