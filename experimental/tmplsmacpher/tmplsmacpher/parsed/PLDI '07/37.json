{"article_publication_date": "06-10-2007", "fulltext": "\n Parameterized Tiled Loops for Free Lakshminarayanan Renganarayanan DaeGon Kim Sanjay Rajopadhye Michelle \nMills Strout Computer Science Department Colorado State University {ln,kim}@cs.colostate.edu Sanjay.Rajopadhye@colostate.edu \nmstrout@cs.colostate.edu Abstract Parameterized tiled loops where the tile sizes are not .xed at compile \ntime, but remain symbolic parameters until later are quite useful for iterative compilers and auto-tuners \nthat produce highly optimized libraries and codes. Tile size parameterization could also enable optimizations \nsuch as register tiling to become dynamic optimizations. Although it is easy to generate such loops for \n(hyper) rectangular iteration spaces tiled with (hyper) rectan\u00adgular tiles, many important computations \ndo not fall into this re\u00adstricted domain. Parameterized tile code generation for the general case of \nconvex iteration spaces being tiled by (hyper) rectangular tiles has in the past been solved with bounding \nbox approaches or symbolic Fourier Motzkin approaches. However, both approaches have less than ideal \ncode generation ef.ciency and resulting code quality. We present the theoretical foundations, implementation, \nand experimental validation of a simple, uni.ed technique for gen\u00aderating parameterized tiled code. Our \ncode generation ef.ciency is comparable to all existing code generation techniques including those for \n.xed tile sizes, and the resulting code is as ef.cient as, if not more than, all previous techniques. \nThus the technique provides parameterized tiled loops for free! Our one-size-.ts-all solution, which \nis available as open source software can be adapted for use in production compilers. Categories and Subject \nDescriptors D.3.4 [Programming Lan\u00adguages]: Processors Compilers, Optimization General Terms Algorithms, \nExperimentation, Performance Keywords parameterized tiling, bounding box, Fourier-Motzkin elimination, \ncode generation 1. Introduction Tiling [12, 27, 18, 31] is a loop transformation that matches pro\u00adgram \ncharacteristics (locality, parallelism, etc.) to those of the ex\u00adecution environment (memory hierarchy, \nregisters, number of pro\u00adcessors, etc.) Many problems relating to tiling have been exten\u00adsively studied: \nhow to pre-process a loop to make tiling legal (e.g. loop-skewing and other unimodular transformations) \n[31, 18]; tile shape optimization [7, 26, 11]; and tile size selection to optimize for memory hierarchy \nas well as interprocessor communication [8, 4]. However, as noted by Goumas et al. [9], the code generation \nprob- Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n07 June 11 13, 2007, San Diego, California, USA. Copyright c &#38;#169; 2007 ACM 978-1-59593-633-2/07/0006. \n. . $5.00 lem after tiling has not received as much attention. Until their paper, most compilers and \nautomatic parallelizers did not generate tiled\u00adcode for arbitrary parallelepiped-shaped tiles, and arbitrary \npolyhe\u00addral iteration spaces, even though an algorithm was described in the early work of Irigoin and \nTriolet [12]. The techniques of Goumas et al. are the current state of the art when the tile sizes are \n.xed at compile time. In this paper we address the problem when tile sizes are not compile-time constants, \nbut remain symbolic parameters in the code. There are many reasons why the parameterized tiled code gen\u00aderation \nproblem is important. First, iterative compilers [16, 17] and autotuners or application-speci.c code \ngenerators such as AT-LAS [29] and SPIRAL [24], optimally tune parameters including tile sizes, through \nexploration of a design-space of parameter val\u00adues. A recent study of tiling for stencil computations \n[14] found that selecting the tile size that results in the best performance is dif.cult. With a .xed \ntiled code generator, the code needs to be re\u00adpeatedly generated and recompiled for each tile size, whereas, \nwith a parameterized tiled code generator, the code is generated only once and used for all the tile \nsizes. Second, parameterized tiled code enables run-time feedback and dynamic program adaptation. For \nexample, run-time tile size adaptation has been successfully used improve execution on shared cache processors \n[22] and also for adapting parallel programs to varying workloads [21]. Finally, parallelizing compilers \nshould generate code that enables the number of processors to be set at run time [2]. For polyhedral \niteration spaces, this problem is simi\u00adlar to the general problem of generating parameterized tiled code; \ntherefore, any solution for generating parameterized tiled code can be directly adapted to enable setting \nthe number of processors at runtime. There is an easy solution to the parameterized tiled loop gen\u00aderation \nproblem: simply produce a parameterized tiled loop for the bounding box of the iteration space, and introduce \nguards to test whether the point being executed belongs to the original iteration space. When the iteration \nspace is itself (hyper) rectangular, as in matrix multiplication, this method is obviously ef.cient. \nHowever, many important computations, such as LU decomposition, triangu\u00adlar matrix product, symmetric \nrank updates, do not fall within this category. Moreover, even if the original iteration space is (hyper) \nrectangular, the compiler may choose to perform skewing transfor\u00admations to exploit temporal locality \n(e.g. stencil computations) thus rendering it parallelepiped shaped. Parallelepiped-shaped iteration \nspaces also occur when skewing is performed to make (hyper) rect\u00adangular tiling legal. For such programs, \nthe bounding box strategy results in poor code quality, because a number of so called empty tiles are \nvisited and tested for emptiness. Another drawback for the bounding box strategy is that calculating \nthe bounding box of arbitrary iteration spaces may be time-consuming. The worst-case time complexity \nof computing a bounding box is exponential [5]. The main dif.culty with generating parameterized tiled \nloop code has been the fact that the Fourier-Motzkin elimination tech\u00adnique that is used for scanning \npolyhedra [3] does not naturally han\u00addle symbolic tile sizes, and leads to a nonlinear formulation. Ama\u00adrasinghe \nproposed a symbolic extension of the standard Fourier-Motzkin elimination technique [2, 1] and implemented \nit in the SUIF system [30]. It is well known that Fourier-Motzkin elimina\u00adtion has doubly exponential \nworst case complexity. The symbolic extension inherits this worst case complexity, adds to the number \nof variables in the problem, and reduces the possibilities for redun\u00addancy elimination. In this paper, \nwe present a simple and ef.cient approach for generating parameterized tiled code that handles any polyhedral \niteration space and parameterized (hyper) rectangular tilings. We show that the problem can be formulated \ninto the subproblems of generating loops that iterate over tile origins, and loops that iterate over \nthe points within tiles. These subproblems can be formulated as a set of linear constraints where the \ntile sizes are parameters, similar to problem size parameters. This allows us to reuse exist\u00ading code \ngenerators for polyhedra, such as CLooG [6], and imple\u00adment our code generator through simple pre-and \npost-processing of the CLooG input and outputs. The key insight is expressing the bounds for the tile \nloops as a superset of the original iteration space and then post processing the generated loops by adding \na stride and modifying the computation of the lower bounds. In addition, we de\u00advelop and prove the correctness \nof two loop overhead optimization techniques that avoid visiting empty tiles and avoid unnecessary guards \nfor full tiles. This paper makes the following contributions: We present an algorithm that generates \ntiled loops from any parameterized polyhedral iteration space, while keeping the tile sizes symbolic \nvariables. The fact that our algorithm can be directly applied to the case when the tile sizes are .xed, \nmakes our method a one-size-.ts-all solution, ideal for inclusion in production compilers.  An empirical \nevaluation on benchmarks such as LUD and tri\u00adangular matrix product show that our algorithm is both ef.cient \nand delivers good code quality. Our experiments present the .rst quantitative analysis of the cost of \nparameterization in tiled loops.  We also present an algorithm that separates the loops into those that \niterate over partial tiles and those that iterate over full tiles. Such a separation has the added bene.t \nthat it enables trans\u00adformations like loop unrolling or software pipelining, (which are often applied \nonly to rectangular loops) to be applied to the (rectangular) loops that iterate over the full tiles. \n Our implementation is available as open source software [28].  In the next section, we present the \nimportant issues involved in tiled code generation. Next, Section 3 resolves the .rst problem, namely \nscanning the tile origins, and Section 4 describes how to scan the individual tiles. In Section 5, we \npresent the experimental validation of our method. Section 6 then describes the optimization that enables \nsplitting the full and partial tiles, together with the proof of the technique. Section 7 discusses related \nwork, and we conclude in Section 8.  2. Anatomy of Tiled Loop Nests Tiling is an iteration reordering \ntransformation that transforms a d\u00addepth loop nest into one of depth up to 2d. In this section we study \nthe structure of tiled loops and develop an intuition for the concepts involved in generating them. In \nlater sections, these concepts are formalized and used in deriving a simple and ef.cient algorithm for \nthe generation of tiled loops. for (k =1;k <= Nk ;k++) for(i =k+1; i <= k+Ni ;i++) S1(k,i); Figure 1. \n2D iteration space found commonly in stencil computa\u00adtions. The body of the loop is represented with \nthe macro S1 for brevity. Consider the iteration space of a 2D parallelogram such as the one shown in \nFigure 1, which is commonly found in stencil computations [18]. Figure 2 shows a geometric view of the \niteration space superimposed with a 2 \u00d7 2 rectangular tiling. Observe that there are three types of tiles: \nfull which are completely contained in the iteration space, partial which have a partial, non-empty intersection \nwith the iteration space, and empty which do not intersect the iteration space. The lexicographically \nearliest point in a tile is called its origin. The goal is to generate a set of loops that scans (i.e., \nvisits) each integer point in the original iteration space based on the tiling transformation, where \nthe tiles are visited lexicographically and then the points within each tile are visited lexicographically. \nWe can view the four loops that scan the tiled iteration space as two sets of two loops each, where the \n.rst set of two loops enumerate the tile origins and the next set of two loops visit every point within \na tile. We call the loops that enumerate the tile origins the tile-loops and those that enumerate the \npoints within a tile the point-loops. 2.1 Bounding Box Method One solution for generating the tile-loops \nis to have them enumerate every tile origin in the bounding box of the iteration space and push the responsibility \nof checking whether a tile contains any valid iteration to the point-loops. The tiled loop nest generated \nwith this bounding box scheme is shown in Figure 3. The .rst two loops (kT and iT) enumerate all the \ntile origins in a bounding box of size Nk \u00d7 (Ni + Nk) and the two inner loops (k and i) scan the points \nwithin a tile. A closer look at the point-loop bounds reveals its simple structure. One set of bounds \nare from what we refer to as the tile box bounds, which restrict the loop variable to points within a \ntile. The other set of bounds restricts the loop variable to points within the iteration space. Combining \nthese two sets of bounds we get the point loops that scan points within the iteration space and tiles. \nGeometrically, the point loop bounds correspond to the intersection of the tile box (or rectangle) and \nthe iteration space, here the parallelogram in Figure 2. The bounding box scheme provides a couple of \nimportant in\u00adsights into the tiled loop generation problem. First, the problem can be decomposed into \nthe generation of tile-loops and the generation of point-loops. Such a decomposition leads to ef.cient \nloop gener\u00adation, since the time and space complexity of loop generation tech\u00adniques is a doubly exponential \nfunction of the number of bounds. The second insight is the scheme of combining the tile box bounds and \niteration space bounds to generate point-loops. Another impor\u00adtant feature of the bounding box scheme \nis that tile sizes need not be .xed at loop generation time, but can be left as symbolic param\u00adeters. \nThis feature enables generation of parameterized tiled loops, which has many applications as discussed \nin the previous section. However, the bounding box scheme can suffer from inef.ciency in the generated \nloops in that the tile-loops can enumerate many empty tiles. 2.2 When Tile Sizes Are Fixed When the \ntile sizes can be .xed at the loop generation time an exact tiled-loop nest can be generated. Tile-loops \nthat only enumerate origins of tiles that have a non-empty rational intersection with Figure 2. A 2\u00d72rectangular \ntiling of the 2D stencil iteration space with Ni =Nk =6is shown. The bounding box of the iteration space \ntogether with full, partial, and empty tiles and their origins are also shown. for (kT=1; kT <=Nk; kT \n+= Sk) for (iT = 2; iT <= Ni+Nk; iT += Si) for (k= max(kT ,1);k<=min(kT+Sk -1,Nk);k++) for (i= max(iT \n,k+1);i<=min(iT+Si -1,k+Ni);i++) S1(k,i); Figure 3. Tiled loops generated using the bounding box scheme. \nthe iteration space are exact. Ancourt and Irigoin [3] proposed the .rst and now classic solution for \ngenerating the exact tiled loops when the tile sizes are .xed. When the tile sizes are .xed the tiled \niteration space can be described as a set of linear constraints and the loops that scan this set can \nbe generated using Fourier-Motzkin elimination [3, 31]. The exact tiled loop nest for the 2D stencil \nexample is shown in Figure 4. Note that the ef.ciency due to the exactness of the tile-loops has come \nat the cost of .xing the tile sizes at generation time. Such loops are called .xed tiled loops. The classic \nscheme, in addition to requiring .xed tile sizes, also suffers from loop generation inef.ciency. It takes \nas input all the constraints that describe the bounds of the 2d loops of the tiled iteration space, where \nd is the depth of the original loop nest. Since the method is doubly exponential on the number of constraints, \nthis increased number of constraints might lead to situations where the loop generation time may become \nprohibitively expensive [9]. for(kT=0;kT <=L(Nk/2)J;kT++) for(iT=max(1,kT ); iT <=min(L(2*kT+Ni +1)/2J,LNk+Ni \n/2J);iT ++) for(k=max(max(1 ,2* kT),2*iT -Ni); k<=min(min (2*kT+1 ,2* iT),Nk);k++) for(i=max(2*iT ,k+1); \ni<=min (2*iT+1,k+Ni);i++) S1(k,i) ; Figure 4. Tiled loops generated for .xed tile sizes using the classic \nscheme. Figure 5. A 2\u00d7 2rectangular tiling of the 2D stencil iteration space with Ni =Nj =6. The outset \nand bounding box are also shown. Compare the number of empty tile origins contained in each of them. \nGoumas et al. [9] improve on the classic scheme by dividing the loop generation problem into two subproblems, \nsimilar to the approach taken with bounding box, but their generated code visits fewer empty tiles than \nbounding box. However, their solution is still only applicable to .xed tile sizes. 2.3 Best Of Both \nWe propose a tiled code generation method that achieves the best of both worlds: the simple decomposed \nloop structure used by the bounding box method and the Goumas et al. technique, the code quality provided \nby the .xed tile size methods, and the bene.ts of parameterized tile sizes provided by the bounding box \nmethod. We develop formal theory and use it to derive a method which provides ef.cient generation of \nef.cient parameterized tiled loops. kTLB = -Sk+2; kTLB = rkTLB/Skl*Sk; for(kT = kTLB; kT <= Nk; kT += \nSk) iTLB = kT -Si+2; iTLB = riTLB/Sil*Si; for(iT = iTLB; iT <= kT+Ni+Sk-1; iT += Si) for(k= max(kT ,1);k<=min \n(kT+Sk -1,Nk);k++) for(i=max(iT ,k+1);i<=min(iT+Si -1,k+Ni);i++) S1(k,i); Figure 6. Parameterized tiled \nloops generated using outset. The variables kTLB and iTLB are used to shift the .rst iteration of the \nloop so that it is a tile origin, and explained later (Section 3.2.2). The key insight is the construction \nof a set called the outset, which contains all possible tile origins for non-empty tiles. The outset \nis similar to the Tile Origin Space (TOS) constructed by Goumas et al. [9], but there are two important \ndifferences. First, the outset we construct includes the tiles sizes as parameters, whereas the tile \nsizes are .xed for the TOS. Second, we feed the outset to any code generator capable of scanning polyhedra, \nand then post\u00adprocess the resulting code to add a step size and shift the lower bounds of the tile loops. \nGoumas et al. generate tile loops that iterate over the image of the TOS after applying tiling. The outset \nhas all the bene.ts of a bounding box, but enumerates very few empty tiles. In general, it is parameterized \nby the tile size, but for illustration purposes Figure 5 shows the outset instantiated for the 2D stencil \nexample and 2 \u00d7 2 tiles. In this example, the outset includes only one empty tile origin at (0, 0),far \nfewerthan the number of empty tiles that the bounding box includes. Geometrically, the outset construction \ncan be viewed as shifting of the hyper-planes that de.ne the lower bounds of the loops. For our 2D example, \nwe shift the left vertical line and the two 45 degree lines, where the left vertical line and the top \n45 degree line constitute the lower bound of k, and the bottom 45 degree line forms the lower bound for \ni. These lines are shifted out so that they will contain the origin of any tile which has a non\u00adempty \nintersection with the iteration space, i.e., any tile that would contain a valid iteration point. Loops \nthat scan the outset are post- Our input model is perfectly nested loops. Our techniques are applicable \nto cases where rectangular tiling is valid or can be made valid by any loop transformation. Many important \napplications contain loops of this kind. We assume that the input loop nest is appropriately transformed \nso that rectangular tiling is (now) valid.  3.1 The Outset and its Approximation For correctness, tiled \ncode should visit all the tiles that contain points in the original iteration space. To generate the \ntile loops separately from the point loops, we visit all of the tile origins within a polyhedron we call \nthe outset. The outset includes all possible tile origins where the tile for that tile origin includes \nat least one point from the original iteration space. The original loop is represented as a set of inequalities \nPiter = {xz | Qxz = (qx+ Bxp)}, where z is the iteration vector of size d, Q is a m \u00d7 d matrix, xq is \na constant vector of size m, xp is a vector of size n containing sym\u00adbolic parameters for the iteration \nspace, and B is a m \u00d7 n matrix. The tiling is represented with the vector xs,where si indicates the size \nof the tile in dimension i,for i =1 ...d. We de.ne the true outset polyhedron as the set of points in \nthe original iteration space that, if they were tile origins, would de.ne a tile that includes at least \none point in the original iteration space. Formally, let tile(xx) specify the set of points that belong \nto the tile whose origin is xx, tile(xx)= {xz | xx = xz = xx + sxl}, where sxl = xs - x1 with x1 being \na size d vector containing all ones. Thetrueoutset is Pout = {xx | tile(xx) n Piter = \u00d8}. Pout as de.ned \nabove is an union of all tiles whose intersection with Piter is non-empty. Computing this set explicitly \nis very expensive. So, we derive a reasonably tight approximation of Pout that is a single polyhedron \nand can be directly computed from the constraints of Piter. We denote this approximation by d Pout. \nAs processed and then used as the tile-loops. The tiled loops generated a comparison, one could also \nview the bounding box as a very d Pout The outset has several important properties. It can be con-space \nlinear in the number of constraints in Piter. On the other structed without .xing the tile sizes, hence \ncan be used for gen-hand, to the best of our knowledge, we are not aware of any linear erating parameterized \ntiled loops. Second, it can be constructed time algorithm for computing the bounding box from constraints \nin by scanning the outset is shown in Figure 6. loose approximation of Pout.can be computed in time and \nvery ef.ciently in time and space linear in the number of loop Piter. Henceforth we call d d Pout the \noutset. The outset discussed in bounds. In comparison, automatic construction of the bounding previous \nsections also refers toPout. box is more expensive we are not aware of any linear time al\u00ad d Pout, by \nshifting all the lower bounds of the original iteration space along the normal that faces out of the \nWe compute the outset,gorithm that constructs a bounding box given the constraints that de.ne an iteration \nspace. Third, the outset can be used to decom\u00ad pose tiled loop generation into separate tile-loop and \npoint-loop iteration space. The outset is de.ned as generation. Fourth, it can be used ef.ciently in \ncases when the tile sizes are .xed, parameterized or mixed, i.e., some are .xed and some are left as \nparameters. These properties lead to a single sim\u00adple ef.cient algorithm for both parameterized as well \nas .xed tiled loop generation. The following sections discusses these properties d Pout where Q+ is \na m \u00d7 d matrix de.ned as follows: = {xx | Qxx = (qx+ Bxp) - Q+ sxl}, Q+ = ij j Qij , if Qij = 0 0, if \nQij < 0 in more detail. Note that the d d Pout is de.ned using the constraint matrix, Q of the iteration \nspace polyhedron. We can compute Q+ with a single  3. Generating the Tile-Loops with Outset pass over \nthe entries of Q and hence in time linear on the number Pout contains In this section, we describe our \nmethod for generating the tile\u00ad of constraints of Piter. We now formally prove that loops. We .rst formally \nde.ne the set that contains all the non\u00adall the non-empty tile origins. empty tile origins and then motivate \na relaxation of this set which can be computed ef.ciently. We then reduce the problem of gen\u00ad d Pout. \n erating tile-loops to one of generating loops that scans the inter\u00adsection of the outset polyhedron \nand a parameterized lattice. We Proof: describe a single method that can be used to generate tile-loops \nfor If a point xx is in Pout, then there exists a point xz such that xz is both .xed as well as parameterized \ntile sizes. in Piter, xz is in tile(xx),and xz = xx +xi,where x0 = xi = sxl.Since xz THEOREM 1. Pout \n. is in Piter, the following is true: Qxz =(xq + Bxp). By substituting xz with x +xi, we derive the following: \nx + Qx0 =xl Qxi =(xq + Bxp), for xi =sx. Due to the constraints on xi and the fact that Q+ = Q, it follows \nthat Q+ sxl =Qi, and so the point x is also in d Pout: Qxx + Q+ sxl =(qx+ Bxp). Thus, each point that \nis in Pout is also in d Pout. Notice that though the tile sizes are not .xed and are included as parameters, \nthe outset is still a polyhedron. This key property enables us to generate parameterized tile-loops, \nfor now we can use all the theory and tools developed for generating loops that scan parameterized polyhedra. \n3.2 Generating tile-loops The tile-loops enumerate the tile origins. Two choices are available: (i) enumerate \nthe tile origins as tile numbers in the tile space or (ii) enumerate the tile origins in the coordinates \nof the original iteration space. When the former is chosen, we need additional computations to map the \ntile numbers from the tile space to tile origins in the iteration space coordinates. Our method avoids \nthis computation and generates loops that directly enumerate the tile origins in the original iteration \nspace coordinates. We can view the set of tile origins as the points in a lattice whose period is the \ntile sizes. We de.ne the tile origin lattice, L(xs), as the lattice whose period is given by the symbolic \ntile size vector xs. Note, that we are not .xing the tile sizes. Hence, L(xs) is actually a parameterized \ntile origin lattice. We also do not require that the tile origin lattice start at any particular coordinate. \nThe outset contains all the non-empty tile origins and also other points which are not tile origins. \nThe key insight is to generate loops that scans the whole of outset and modify them so that they skip \nthe iterations that are not tile origins. Formally, we want to visit the points in the intersection of \nthe outset and the tile origin lattice, i.e., ds). Pout nL(x 3.2.1 Striding the loops Figure 7 shows \nan outset and a tile origin lattice for a 2 \u00d73 tiling. Let us call the loops that scan all the integer \npoints in the outset as outset-loops. For a moment assume that the .rst iteration of every loop is aligned \nwith a tile origin. Then we can skip the non\u00adtile origins by just adding a stride to the loop variable \nwith the corresponding tile size parameter. This simple post-processing of the loops that scans the outset \ngives us the loops that scans the intersection of outset and tile origin lattice. Note that the stride \ncan be a .xed constant or a symbolic parameter. This allows us to use the same method for generating \ntile loops for both .xed and parameterized tile sizes. 3.2.2 Shifting Lower Bounds We now address the \nissue of aligning the .rst iteration of the outset\u00adloops to a tile origin. Figure 7 shows two non-tile \norigins that correspond to .rst iterations of the i loop. We need to shift the lower bound to an iteration \nthat corresponds to the next tile origin. Let LBi be the lower bound of a loop variable i. Note that \nLBi could be a function of the outer loop indices and parameters. The required shift can be thought of \nas the difference between the value of LBi lm and the next tile origin. This shift can be computed as \nLBi \u00d7si. si We would like to emphasize that this shift can be generated for .xed as well as parameterized \ntile sizes. This yields a single method for both .xed and parameterized tiled loop nest generation. \nFigure 7. Intersection of a tile origin lattice for 2 \u00d73 tiles and the outset is shown. The original \niteration space is omitted for ease of illustration. Note that the .rst iteration of the loops that scans \nthe outset could be a non-tile origin. We need to shift this iteration to the next iteration that is \ntile origin. The code previously presented in Figure 6 showing the param\u00adeterized tiled loops for the \n2D stencil example (Figure 1) was gen\u00aderated using the scheme described above. Note how the skipping \nof the non-tile origins naturally translates into parametric strides of the loop variables. Also note \nhow the lower bound shifts can be expressed as loop variable initializations. 3.2.3 Implementation Our \ncode generator takes as input the constraints that de.ne Piter. It constructs the outset ( d Pout), which \nis parameterized by the pro\u00adgram and tile parameters. The outset-loops are generated using a standard \nloop generator for parameterized polyhedra. Thanks to our theory, all that is required to turn them into \ntile loops is a simple post-processing, actually pretty-printing, to add strides and lower bound shifts. \nThese tile loops are then composed with the point\u00adloops whose generation is described in the next section. \n  4. Generating the Point Loops The point-loops make up a loop nest that enumerates all the points \nwithin a tile. To ensure that they scan points only in the original iteration space, their bounds are \ncomposed of tile bounds as well as iteration space bounds. When the point-loops are generated separately, \nthe tile origin is not known. Consider the triangular iteration space shown in Figure 8. Es\u00adsentially, \nthe intersection of a tile (without .xing the tile origin) and the iteration space is the set of points \nto be scanned by point-loops. j (n,n) n tiles  tile origins  1  i 1 n Figure 8. A triangular \niteration space and tiles To generate them, we can construct the intersection that is now pa\u00adrameterized \nby both program parameters and tile origin index. This approach does, however, increase the number of \ndimensions, which is a major factor at code generation time. Since the tile bounds for rectangular tiling \nare simple, we can optimize the generation of the point loops. We .rst construct a loop nest that scans \nthe original iteration space. Then, for each lower bound lbi and upper bound ubi, we add the tile lower \nbound, tlbi, and upper bound, tlbi - si +1, (si is the tile size of i-th dimension) producing the lower \nbound max(lbi,tlbi)and upper bound min(ubi,tlbi - si +1) of the point-loops. The point\u00adloops for the \nexample in Figure 8 are given below, with iT and jT representing the tile origin indices, and Si and \nSj representing the sizes of the tiles along the i and j dimensions. for i=max(1,iT) to min(N,iT-Si+1) \nfor j=max(1,jT) to min(i,jT-Sj+1) body; In addition, we can also generate simple point loops where iteration \nspace bounds are not included. As shown in Figure 8, if a tile is a full tile, i.e., a subset of the \niteration space, then the bounds for the original iteration space are not necessary. Such simple point \nloops are useful for the optimization described in Section 6.  5. Implementation and Experimental Results \nWe implement four different tiled loop generators: two for .xed tile sizes and two for parameterized \ntile sizes. The loop generator is available as open source software [28]. For .xed-size tiles, we implement \nthe classic and decomposed methods. For the classic method, the constraints that represent the tiled \niteration space are constructedfromtheoriginalloopboundsandthenfedto CLOOG to generate the tiled loops. \nFor the decomposed method, we construct an outset with .xed tile sizes and use them to generate tile-loops \nand generate the point loops separately as discussed in the previous sections. For parameterized tiled \ncode generation, we implement the parameterized decomposed method presented in this paper and the bounding \nbox method. For the bounding box method, we as\u00adsume that the bounding box is provided as an input. The \nbounding box is used in the place of outset to generate tile-loops and the parameterized point loops \nare generated as in the .xed methods ex\u00adcept the tile sizes are now symbolic parameters for the point \nloops. For the parameterized decomposed method, we .rst generate the outset from the input loop bounds \nand use it to generate the tile\u00adloops. We then generate the parameterized point loops and embed them \nin the tile-loops to get the .nal tiled loop nest. Description Loop depth/ # tiled loops SSYRK Symmetric \nRank k Update. 3/ 2 LUD LU decomposition of a matrix without pivoting. 3/ 2 STRMM Triangular matrix multiplica\u00adtion. \n3/ 2 3D Stencil Gauss-Seidel Style 2D/3D stencil computation. 3/ 3 Table 1. Benchmarks used for code \nquality evaluation. The experiments compare the various loop generating tech\u00adniques in terms of the quality \nof the generated tile code and the ef.\u00adciency of the tiled loop generation. Both of these measures depend \nheavily on the underlying code generator, because the techniques presented in this paper enable the implementation \nof parameterized decomposed tiling to use any loop generator capable of generat\u00ading loops that scan a \npolyhedron as a black box. For generating the loops that scan a polyhedron we use the CLOOG loop generator, \nwhich has been shown to quickly generate high quality loops [6]. However, it is possible to replace the \nCLOOG generator with a dif\u00adferent code generator such as the Omega code generator [23]. 5.1 Experimental \nSetup To evaluate the quality of the generated code, we use linear algebra computation kernels from BLAS3 \nand a stencil computation, as listed in Table 1. The stencil computation has a 3D iteration space, and \noperates on two dimensions of data. It is necessary to skew the stencil computation before applying tiling. \nColumn 3 in Table 1 indicates the loop depth of the original loop, and the number of loops that are tiled. \nWe ran the experiments on an Intel Core2 Duo processor run\u00adning at 1.86 GHz with an L2 cache of size \n2MB. The system is running SMP Linux. For compiling our tiled loop nests we used g++ version 4.1.1. with \nthe highest optimization level (-O3). The timings use gettimeofday().  5.2 Results For each combination \nof benchmark and implemented tiled code generation method, we time an approximation of loop overhead, \nthe total run of the tiled benchmark, and the time required to generate the tiled code. Figure 9 shows \nthe loop overhead for SSYRK (symmetric rank k update) as a percentage of the total loop execution time. \nWe time the execution time of the tiled loop bounds with only a counter as the body and divide the measured \nexecution time by the execution time for the loop with the full body including the loop counter. The \nloop overhead is only approximate, because in the loop with the full loop body some of the loop bound \ninstructions can be scheduled with instructions from the body, therefore this measure is an upper bound \non the loop overhead. The approximate loop overhead on average can be as high as 40%. Figure 10 shows \nthe total execution time for the SSYRK as the tile sizes vary. Notice that as the tile sizes become large \nenough to result in improved performance of the overall loop, the approximate percentage of time spent \non loop overhead increases. Figures 10-13 show the total execution time for the various benchmarks as \nthe tile size varies. The cache effect that occurs as the tile size better uses cache can most clearly \nbe seen for STRMM, 3D Stencil, and SSYRK. In general, the quality of the generated tiled code is comparable. \nThe outliers occur at smaller tile sizes, where the parameterized tiled code generator based on bounding \nbox signi.cantly increases the running time for all benchmarks. Comparison of generated loops for SSYRK \nComparison of generated loops for LUD Percent Loop Overhead0 10 30 50 20 40 Fixed Decom Fixed Decom \nTotal Time (seconds) 0 50 100 150 200  2 4 8 16 32 64 128256512 2 4 8 16 32 64 128256512 Square Tile \nSizes Square Tile Sizes Figure 9. Percentage loop overhead =(counter / body and Figure 11. Total execution \ntime for LUD on a matrix of size counter)\u00d7100 of the SSYRK for matrices of size 3000 \u00d7 3000. 3000 \u00d7 3000. \n Comparison of generated loops for SSYRK Comparison of generated loops for STRMM Total Time (seconds) \n0 20 40 60 80 100 120 Param Outset Param Bbox Fixed Classic Fixed Decom Total Time (seconds) 0 10 20 \n30 40 50 60 70 Param Outset Param Bbox Fixed Classic Fixed Decom 2 4 8 16 32 64 128256512 Square Tile \nSizes Figure 10. Total execution time for symmetric rank k update for matrices of size 3000 \u00d7 3000. For \ncache tiling, the smaller tile sizes do not experience the best performance improvement; however, smaller \ntile sizes are critical for register tiling [13]. The parameterized decomposed method presented in this \npaper performs much better than bounding box at smaller tile sizes. We also performed the same set of \nexperiments on an AMD Opteron dual core processor running at 2.4 GHz with a cache of size 1MB, and obtained \nsimilar results as presented here. The compilation time (in milliseconds) for the four tiled loop generation \nmethods, viz., .xed classic, .xed decomposed, param\u00adeterized bounding box, and parameterized outset are \nshown in Ta\u00adble 2. The timings shown in the table are the average over .ve runs for each benchmark and \neach method. The timings include .le IO. Further, the timings for the parameterized bounding box method \ndo not include the time to generate the bounding box from the iteration space polyhedron. For the experiments \nit was given as user input. In a fully automated scenario, this additional time for generating 2 4 8 \n16 32 64 128256512 Square Tile Sizes Figure 12. Total execution time for STRMM for matrices of size 3000 \n\u00d7 3000. the bounding box will add to the generation time of the bounding box method. Overall, the cost \nof code generation for the three methods, viz., .xed decomposed, bounding box, and parameterized outset, \nfalls within the range of 45 to 55 milliseconds. Hence they have very comparable generation ef.ciency \n(even when the time to generate the bounding box is not included). Though the .xed classic method seems \nto be signi.cantly more ef.cient than the .xed decomposed method, as observed by Goumas et al. [9], it \nis expected to have scaling problems as the number of number of tiled loops increase. In summary, the \nparameterized decomposed method presented in this paper generates code with performance comparable if \nnot better than both .xed and parameterized tiled code generation methods. For parameterized tiled code \ngeneration, the parame\u00adterized decomposed method based on the outset is clearly better than the traditional \nbounding box method, especially for smaller Comparison of generated loops for 3D Stencil 2 4 8 16 32 \n64 128256512 Cubic Tile Sizes Figure 13. Total execution time for 3D Stencil on a 2Ddatagrid of size \n3000 \u00d73000 over 3000 time steps. LUD SSYRK STRMM 3D Stencil fClassic 32.4 28.6 29.0 26.0 fDecom 55.2 \n51.0 50.4 45.0 pBbox 53.5 53.2 51.2 54.0 pOutset 52.0 53.8 52.1 54.1 Table 2. Tiled loop generation \ntimes (in milliseconds) of the four methods on the four benchmarks. The four methods .xed classic, .xed \ndecomposed, parameterized bounding box, and parameter\u00adized outset are denoted by fClassic, fDecom, pBbox,and \npOutset respectively. tile sizes. The code generation time for all of the methods is com\u00adparable and \nquite small.  6. Finding Full Tiles Using the Inset One possible source of loop overhead occurs within \nthe loop bounds for each tile, which contain the bounds for the original iteration space as well as the \ntile so that no iterations outside of the original iteration space are executed. Ancourt and Irigoin \n[3] suggest that tiled code may be optimized by generating different code for full tiles versus partial \ntiles. Previous work [13] uses index set splitting to break the iteration space into full and partial \ntiles so that iteration bounds can be removed from the bounds for the full tiles. Other work [9] indicates \nthat they differentiate between full and partial tiles, but details are not provided. Since distinguishing \nbetween full and partial tiles is important for register tiling and possibly hierarchical tiling, we \npresent two possible approaches for doing just that. Both approaches are based on constructing the inset \npolyhedron such that any tile origins within the inset polyhedron Pin are tile origins for full tiles. \nDistinguishing between full and partial tiles is applicable to all of the tiled code generation techniques \ndiscussed in Section 2. The inset can be computed as quickly as the outset, and it is possible to show \nthat points are in the calculated inset if and only if they are possible tile origins for full tiles. \nOnce the inset has been computed, it is possible to leverage existing code generators to generate the \ntile loops that traverse the inset executing only full tiles and the outset minus the inset executing \npartial tiles. 6.1 Algorithm for Computing Inset As in Section 2, the original loop in question is represented \nas a set of inequalities Piter = {xz |Qxz =(qx+ Bxp)}, where z is the iteration vector of size d, Q is \na m \u00d7d matrix, xq is a constant vector of size m, xp is a vector of size n containing symbolic parameters \nfor the iteration space, and B is a m \u00d7n matrix. The vector xs speci.es the (hyper) rectangle tiling, \nwith si indicating the tile size for the ith dimension of the iteration space. We de.ne the inset polyhedron \nPin such that any tile origins that lie within the inset polyhedron are tile origins for full tiles. \nAll the points in a tile satisfy an inequality constraint if and only if the extreme points for the tile \nsatisfy the constraint. The extreme points of a (hyper) rectangle tile can be calculated as follows. \nLet xl s= xs -x1 and let Sl = diag(xs -x1).Then Sl times any binary vector of size d is an extreme point \nof the tile. Formally, the inset is xlx Pin = {xz |.b .{0, 1}d,Q(xz + Sb) =(xq + Bxp)}, It is possible \nto compute the inset directly from the de.nition, but that would result in m*2d constraints, with many \nof them being redundant. Instead, we calculate a matrix Q- from the Q matrix in the constraints for the \noriginal iteration space, such that j - Qij , if Qij < 0 Qij = . 0, if Qij =0 The algorithm for computing \nQ- is O(md) and results in m constraints for the inset, d-(xl -x Pin = {xz |Qxz =(xq + Bxp) -Qs1)}, where \nxs is the size d vector of tile sizes and x1 is a size d vector containing all ones. THEOREM 2. d Pin \n= Pin. Proof: The proof proceeds by construction. First, we write each bound for Pin on a separate line. \n01 Q1dSl @ ... ... ... A =(xq + Bxp) -Qxz Qm1Sl ... Q11S11l b1 ... ddbd 11b1 QmdSl ddbd Note that the \nabove inequality is true for all binary vectors xb. Each row represents 2d constraints: one for each \npossible value of the binary vector xb. Since all of the entries in the Sl matrix are non-negative, it \nis possible to select a particular binary vector for each row that results in the least possible value \nfor each entry and therefore provides a tight bound for all the constraints represented by that row. \nSpeci.cally that binary vector has entry bj equal to one if and only if Qij is negative. Selecting the \nbinary vector for each row, which results in the tightest bound is equivalent to calculating the matrix \nQ- . For all binary vectors xb, the following is true: 01 Q11S11l b1 ... Q1dSl ddbd @ ... ... ... A =Q- \nsxl =(xq + Bxp) -Qxz, Qm1S11l b1 ... QmdSl ddbd where sxl s -xPin is Pin with all redundant bounds = \nx1. Therefore, dremoved.  6.2 Code Generation Implementation One property of an inset Pin is that tile(z) \nnPiter = tile(z) for all z .Pin. In other words, constraints on the iteration space are redundant for \nany tile whose origin is in the inset. By removing these unnecessary loop bounds in the point loops, \nwe can possibly reduce the loop overhead further. One may perform this optimiza\u00adtion by checking whether \na tile origin belongs to the inset before executing point loops or by splitting the inset from the outset. \nTo use the check approach, code must be generated that deter\u00admines if a particular iteration lies within \nthe inset. The other ap\u00adproach is to split the inset from the outset. Consider the fact that Pin . Pout. \nWe associate a statement X1 with Pin and a state\u00adment X2 with Pout and feed both polyhedra to a code \ngenerator. Now, if a loop nest scans both Pout and Pin without guards, then loops that scan the inset \nmust include both statements. incorporat\u00ading. and Pin without guards different statements, statements. \nNow, we know that iteration constraints are redundant whenever there are two statements in the loop since \nPin . Pout. Therefore, we replace the loop bodies with statements X1 and X2 with the tile loops for full \ntiles, and we replace the loop bodies with statement X2 only with tile loops for partial tiles. one statement, \nThis splitting scheme based on the union of inset and outset provides a way to enable a full versus partial \ntile optimization for parameterized tile code. Also, it is easy to incorporate this scheme using existing \ncode generators. Note that many code generators have been designed and developed to remove guards by \nsplitting the iteration space into disjoint regions associated to different sets of statements. The tradeoff \nbetween splitting and inserting a check has not been fully explored. For register tiling, it would seem \nthat checking each tile to determine if it is full clearly introduces too much overhead. However, splitting \ncan result in signi.cant blowup in code size, which can cause instruction cache problems. it reduces \nloop overhead without introducing another overhead checking is preferable in terms of code size.  7. \nRelated Work Ancourt and Irigoin proposed a technique [3] for scanning a single polyhedron, based on \nFourier-Motzkin elimination over inequality constraints. Le Verge et al. [19, 20] proposed an algorithm \nthat ex\u00adploits the dual representation of polyhedra with vertices and rays in addition to constraints. \nThe general code generation problem for af.ne control loops requires scanning unions of polyhedra. Kelly \net al. [15] solved this by extending the Ancourt-Irigoin technique, and together with a number of sophisticated \noptimizations, devel\u00adoped the widely distributed Omega library [23]. The SUIF [30] tool includes a similar \nalgorithm. Quillere et al. proposed a dual repre\u00adsentation algorithm [25] for scanning the union of polyhedra, \nand this algorithm is implemented in the CLooG code generator [6] and its derivative Wloog is used in \nthe WRaP-IT project. Techniques for generating loops that scan polyhedra can also be used to generate \ncode for .xed tile sizes, thanks to Irigoin and Triolet s proof that the tiled iteration space is a polyhedron \nif the tile sizes are constants [12]. Either of the above tools may be used (in fact, most of them can \ngenerate such tiled code). However, it is well known that since the worst case complexity of Fourier-Motzkin \nelimination is doubly exponential in the number of dimen\u00adsions, this may be inef.cient. Methods for generating \ncode for non\u00adunimodular transformations use techniques similar to ours, how\u00adever they use .xed lattices \nand we use a parameterized lattice. Our work is similar in scope to that of Goumas et al. [9], who decompose \nthe generation into two subproblems, one to scan the tile origins, and the other to scan points within \na tile, thus obtaining signi.cant reduction of the worst case complexity. They proposed a technique to \ngenerate code for .xed-sized, parallelogram tiles. Their technique computes an approximation to the outset, \nsimilar dd to our Pout. Speci.cally, they compute the image of Pout by the tiling transformation, H, \nand generate code to scan this image. Because of this, their code has ceiling and .oor operations, and \nthe loop body must compute an af.ne function of the loop indices to determine the tile origins. Their \nmethod can handle arbitrary parallelogram shaped tiles, and they also use a technique similar to our \ninset to optimize the code. Note however, that all their techniques are applicable only to .xed tile \nsizes. Comparatively our algorithm handles parameterized tile sizes. The key insight is that we view \nthe outset as a polyhedron with, other than the program parameters, n additional parameters, namely the \ntile sizes. This allows us to ef.ciently leverage most of the well developed tools, and our technique \nperforms as well as, if not better than, all others, at no additional cost. There are also a number of \nadditional differences. Our algo\u00adrithm generates tile loops whose indices always remain in the co\u00adordinate \nspace of the original loop. This avoids .oor and ceiling functions, and enables us to generate tile loops \nthrough a very sim\u00adple post-processing: adjust the lower bounds, and introduce a stride corresponding \nto the tile size. Our method is restricted to transfor\u00admations that can be expressed as a composition \nof a unimodular transformation, followed by a rectangular tiling (blocking). There has been relatively \nlittle work for the case where tile sizes are symbolic parameters, except for the very simple case of \northogonal tiling: either rectangular loops tiled with rectangular tiles, or loops that can be easily \ntransformed to this. For the more general case, the standard solution, as described in Xue s text [31] \nhas been to simply extend the iteration space to a rectangular one (i.e., to consider its bounding box), \napply the orthogonal technique with appropriate guards to avoid computations outside the original iteration \nspace. Amarasinghe and Lam [1, 2] implemented, in the SUIF tool set, a version of FME that can deal with \na limited class of symbolic coef.cients (parameters and/or block sizes), but the full details have not \nbeen made available. Gr\u00a8o\u00dflinger et al. [10] proposed an extension to the polyhedral model, in which \nthey allow arbitrary rational polynomials as coef.\u00adcients in the linear constraints that de.ne the iteration \nspace. Their genericity comes at the price of requiring computationally expen\u00adsive machinery like quanti.er \nelimination in polynomials over the real algebra, to simplify constraints that arise during loop genera\u00adtions. \nDue to this their method does not scale with the number of dimensions and the number of non-linear parameters. \nJim\u00b4enez et al. [13] develop code generation techniques for reg\u00adister tiling of non-rectangular iteration \nspaces. They generate code that traverses the bounding box of the tile iteration space to en\u00adable parameterized \ntile sizes. The focus of their paper is applying index-set splitting to tiled code to traverse parts \nof the tile space that include only full tiles. Their approach involves less overhead in the loop nest \nthat visits the full tiles; however, the resulting code experiences signi.cant code expansion. We suggest \ntwo possible approaches for differentiating between full and partial tiles: either generate a check to \ndetermine if the tile being visited is a full tile, or associate two different loop bodies with the inset \nand outset and let any polyhedra scanning code generator generate the appropriate code. The trade-off \nbetween the overhead due to the check versus the cost due to code expansion that occurs using index-set \nsplitting or loops that scan the union of polyhedra is unclear and an area for further study. 8. Conclusions \nIteration space tiling is an essential transformation for match\u00ading computation/communication characteristics \nof programs with loops to those of the resources (memory hierarchy as well as in\u00adterprocessor communication). \nParameterized tiled loop generation is the problem of producing tiled code where the tile sizes remain \nsymbolic parameters until link, or even run time. Previous solu\u00adtions to this problem were based on either \nthe bounding box, or on symbolic Fourier Motzkin elimination. The bounding box tech\u00adnique, although very \nsimple, has poor code quality, especially for non-rectangular iteration spaces, where the overhead after \ntiling may be as high as 50%. The symbolic Fourier Motzkin elimina\u00adtion technique, has high complexity. \nWe presented a single, simple technique for .xed and parameterized tiled loop generation that subsumes \nall previously known algorithms. Our experiments com\u00adpared the generation ef.ciency and code quality \nof the parameter\u00adized technique with those for .xed tile sizes. They demonstrate that in terms of generation \nef.ciency, the parameterized technique is as good as the state of the art for .xed tile sizes. The generated \ncode is also as ef.cient as the tiled loops with .xed tile sizes. Thus the technique provides parameterized \ntiled loops for free! Our ongoing work involves more detailed experimentation and incorporation of the \ngenerator in an autotuner for special applica\u00adtion domains. We are currently working on using the concepts \nof inset and outset to generate multi-level parameterized tiled code. As a future work, we plan to extend \nthe outset based technique to generate parameterized tiled loops for imperfect loop nests.  References \n[1] S. Amarasinghe. Parallelizing Compiler Techniques Based on Linear Inequalities. PhD thesis, Stanford \nUniversity, 1997. [2] S. P. Amarasinghe and M. S. Lam. Communication optimization and code generation \nfor distributed memory machines. In PLDI 93: Proceedings of the ACM SIGPLAN 1993 conference on Programming \nlanguage design and implementation, pages 126 138, New York, NY, USA, 1993. ACM Press. [3] C. Ancourt \nand F. Irigoin. Scanning polyhedra with DO loops. In Proceedings of the 3rd ACM SIGPLAN Symposium on \nPrinciples and Practice of Parallel Programming, pages 39 50, April 1991. [4] R. Andonov and S. Rajopadhye. \nOptimal orthogonal tiling of 2-d iterations. Journal of Parallel and Distributed Computing, 45(2):159 \n165, September 1997. [5] R. Bagnara, P. M. Hill, and E. Zaffanella. The Parma Polyhedra Library: Toward \na complete set of numerical abstractions for the analysis and veri.cation of hardware and software systems. \nQuaderno 457, Dipartimento di Matematica, Universit`a di Parma, Italy, 2006. [6] C. Bastoul. Code generation \nin the polyhedral model is easier than you think. In PACT 13 IEEE International Conference on Parallel \nArchitecture and Compilation Techniques, pages 7 16, Juan-les-Pins, September 2004. [7] P. Boulet, A. \nDarte, T. Risset, and Y. Robert. (pen)-ultimate tiling? INTEGRATION, the VLSI journal, 17:33 51, August \n1994. [8] S. Coleman and K. S. McKinley. Tile size selection using cache organization and data layout. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), June 1995. [9] G. \nGoumas, M. Athanasaki, and N. Koziris. An ef.cient code generation technique for tiled iteration spaces. \nIEEE Transactions on Parallel and Distributed Systems, 14(10), October 2003. [10] A. Gr\u00a8o\u00dflinger, M. \nGriebl, and C. Lengauer. Introducing non-linear parameters to the polyhedron model. In Michael Gerndt \nand Edmond Kereku, editors, Proc. 11th Workshop on Compilers for Parallel Computers (CPC 2004), Research \nReport Series, pages 1 12. LRR-TUM, Technische Universit\u00a8at M\u00a8unchen, July 2004. [11] K. H\u00a8ogstedt, L. \nCarter, and J. Ferrante. Determining the idle time of a tiling. In Principles of Programming Languages, \npages 160 173, Paris, France, January 1997. ACM. [12] F. Irigoin and R. Triolet. Supernode partitioning. \nIn 15th ACM Symposium on Principles of Programming Languages, pages 319 328. ACM, January 1988. [13] \nM. Jim\u00b4enez, J. M. Llaber\u00b4ia, and A. Fern\u00b4andez. Register tiling in nonrectangular iteration spaces. \nACM Trans. Program. Lang. Syst., 24(4):409 453, 2002. [14] S. Kamil, K. Datta, S. Williams, L. Oliker, \nJ. Shalf, and K. Yelick. Implicit and explict optimizations for stencil computations. In Memory Systems \nPerformance and Correctness, 2006. [15] W. Kelly, W. Pugh, and E. Rosser. Code generation for multiple \nmappings. In Frontiers 95: The 5th Symposium on the Frontiers of Massively Parallel Computation, McLean, \nVA, 1995. [16] T. Kisuki, P. M. W. Knijnenburg, and M. F. P. O Boyle. Combined selection of tile sizes \nand unroll factors using iterative compilation. In PACT 00: Proceedings of the 2000 International Conference \non Parallel Architectures and Compilation Techniques, page 237, Washington, DC, USA, 2000. IEEE Computer \nSociety. [17] P. M. W. Knijnenburg, T. Kisuki, and M. F. P. O Boyle. Iterative compilation. In Embedded \nprocessor design challenges: systems, architectures, modeling, and simulation-SAMOS, pages 171 187. Springer-Verlag \nNew York, Inc., New York, NY, USA, 2002. [18] M. S. Lam and M. E. Wolf. A data locality optimizing algorithm \n(with retrospective). In Best of PLDI, pages 442 459, 1991. [19] H. Le Verge, V. Van Dongen, and D. Wilde. \nLa synth`esedenids de boucles avec la biblioth`eque poly\u00b4edrique. In RenPar 6, Lyon, France, June 1994. \nEnglish version Loop Nest Synthesis Using the Polyhedral Library in IRISA TR 830, May 1994. [20] H. Le \nVerge, V. Van Dongen, and D. Wilde. Loop nest synthesis using the polyhedral library. Technical Report \nPI 830, IRISA, Rennes, France, May 1994. Also published as INRIA Research Report 2288. [21] D. K. Lowenthal. \nAccurately selecting block size at runtime in pipelined parallel programs. Int. J. Parallel Program., \n28(3):245 274, 2000. [22] D. S. Nikolopoulos. Dynamic tiling for effective use of shared caches on multithreaded \nprocessors. International Journal of High Performance Computing and Networking, pages 22 35, 2004. [23] \nW. Pugh. Omega test: A practical algorithm for exact array dependency analysis. Comm. of the ACM, 35(8):102, \n1992. [24] M. P\u00a8uschel, J. M. F. Moura, J. Johnson, D. Padua, M. Veloso, B. Singer, J. Xiong, F. Franchetti, \nA. Gacic, Y. Voronenko, K. Chen, R. W. Johnson, and N. Rizzolo. Spiral: Code generation for dsp transforms. \nProceedings of the IEEE, 93(2):232 275, February 2005. [25] F. Quiller\u00b4e, S. Rajopadhye, and D. Wilde. \nGeneration of ef.cient nested loops from polyhedra. International Journal Parallel Programming, 28(5):469 \n498, 2000. [26] J. Ramanujam and P. Sadayappan. Tiling multidimensional iteration spaces for multicomputers. \nJournal of Parallel and Distributed Computing, 16(2):108 120, 1992. [27] R. Schreiber and J. Dongarra. \nAutomatic blocking of nested loops. Technical Report 90.38, RIACS, NASA Ames Research Center, August \n1990. [28] TLOG: A parameterized tiled loop generator. Available at: http://www.cs.colostate.edu/~ln/TLOG/. \n[29] R. C. Whaley and J. J. Dongarra. Automatically tuned linear algebra software. In Supercomputing \n98: Proceedings of the 1998 ACM/IEEE conference on Supercomputing (CDROM), pages 1 27, Washington, DC, \nUSA, 1998. IEEE Computer Society. [30] R. P. Wilson, R. S. French, C. S. Wilson, S. P. Amarasinghe, J. \nM. Anderson, S. W. K. Tjiang, S-W. Liao, C-W. Tseng, M. W. Hall, M. S. Lam, and J. L. Hennessy. SUIF: \nAn infrastructure for research on parallelizing and optimizing compilers. SIGPLAN Notices, 29(12):31 \n37, 1994. [31] J. Xue. Loop Tiling For Parallelism. Kluwer Academic Publishers, 2000. \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Parameterized tiled loops-where the tile sizes are not fixed at compile time, but remain symbolic parameters until later--are quite useful for iterative compilers and \"auto-tuners\" that produce highly optimized libraries and codes. Tile size parameterization could also enable optimizations such as register tiling to become dynamic optimizations. Although it is easy to generate such loops for (hyper) rectangular iteration spaces tiled with (hyper) rectangular tiles, many important computations do not fall into this restricted domain. Parameterized tile code generation for the general case of convex iteration spaces being tiled by (hyper) rectangular tiles has in the past been solved with bounding box approaches or symbolic Fourier Motzkin approaches. However, both approaches have less than ideal code generation efficiency and resulting code quality. We present the theoretical foundations, implementation, and experimental validation of a simple, unified technique for generating parameterized tiled code. Our code generation efficiency is comparable to all existing code generation techniques including those for fixed tile sizes, and the resulting code is as efficient as, if not more than, all previous techniques. Thus the technique provides parameterized tiled loops for free! Our \"one-size-fits-all\" solution, which is available as open source software can be adapted for use in production compilers.</p>", "authors": [{"name": "Lakshminarayanan Renganarayanan", "author_profile_id": "81331502405", "affiliation": "Colorado State University, Fort Collins, CO", "person_id": "P871681", "email_address": "", "orcid_id": ""}, {"name": "DaeGon Kim", "author_profile_id": "81322498118", "affiliation": "Colorado State University, Fort Collins, CO", "person_id": "P814962", "email_address": "", "orcid_id": ""}, {"name": "Sanjay Rajopadhye", "author_profile_id": "81100397005", "affiliation": "Colorado State University, Fort Collins, CO", "person_id": "P259874", "email_address": "", "orcid_id": ""}, {"name": "Michelle Mills Strout", "author_profile_id": "81100191330", "affiliation": "Colorado State University, Fort Collins, CO", "person_id": "PP39065757", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250780", "year": "2007", "article_id": "1250780", "conference": "PLDI", "title": "Parameterized tiled loops for free", "url": "http://dl.acm.org/citation.cfm?id=1250780"}