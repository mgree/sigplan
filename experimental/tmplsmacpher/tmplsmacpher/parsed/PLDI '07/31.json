{"article_publication_date": "06-10-2007", "fulltext": "\n Ef.cient Static Analysisof XMLPaths andTypes Pierre Genev ` es Ecole PolytechniqueF\u00b4ed\u00b4eralede Lausanne \n* pierre.geneves@ep..ch Abstract WepresentanalgorithmtosolveXPath decision problems under regular tree \ntype constraints and show its use to statically type\u00adcheck XPath queries. To this end, we prove the decidability \nof a logic with converse for .nite ordered trees whose time complexity is a simple exponential of the \nsize of a formula. The logic cor\u00adresponds to the alternation free modal \u00b5-calculus without greatest .xpoint, \nrestrictedto.nitetrees,andwhere formulasarecycle-free. Our proof method is based on two auxiliary results. \nFirst, XML regular tree types and XPath expressions have a linear translation to cycle-free formulas. \nSecond, the least and greatest .xpoints are equivalent for .nite trees, hence the logic is closed under \nnegation. Building on these results, we describe a practical, effective system for solving the satis.ability \nof a formula. The system has been experimented with some decision problems such as XPath emptiness, containment, \noverlap, and coverage, with or without type constraints. The bene.t of the approach is that our system \ncan be effectively used in static analyzers for programming languages manipulating both XPath expressions \nand XML type annotations (as input and output types). Categories and Subject Descriptors E.1[Data Structures]:Trees; \nF.4.1[Mathematical Logic and Formal Languages]: Mathemat\u00adical Logic modal logic; F.4.3 [Mathematical \nLogic and For\u00admal Languages]: Formal Languages decision problems; H.2.1 [Database Management]: LogicalDesign; \nH.2.3[Database Man\u00adagement]: Languages Query Languages GeneralTerms Algorithms, languages, theory, veri.cation \nKeywords Modal logic, satis.ability, type checking, XPath 1. Introduction This work is motivated by the \nneed of ef.cient type checkers for XML-based programming languages whereXML types andXPath queries are \nused as .rst class language constructs. In such settings, XPath decision problems in the presence of \nXML types such as DTDs or XML Schemas arise naturally. Examples of such decision problems include emptiness \ntest (whether an expression ever se\u00adlects nodes), containment (whether the results of an expression are \nalways includedinthe resultsof anotherone),overlap (whethertwo * Majorpartofthisworkdonewhenthe authorwasatINRIARh \none-Alpes. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n07 June 11 13, 2007, San Diego, California, USA. Copyright c . 2007ACM 978-1-59593-633-2/07/0006...$5.00 \nNabil Laya\u00a8ida Alan Schmitt INRIA Rh one-Alpes {nabil.layaida, alan.schmitt}@inria.fr expressions select \ncommon nodes), and coverage (whether nodes selectedby anexpression arealways containedinthe unionofthe \nresults selected by several other expressions). XPath decision problems are not trivial in that theyneed \nto be checkedona possibly in.nite quanti.cationoverasetof trees.An\u00adother dif.culty arisesfrom the combination \nof upward and down\u00adward navigation on trees with recursion [31]. The most basic decision problem for \nXPath is the emptiness test of an expression [3]. This test is important for optimization of host languages \nimplementations: for instance, if one can decide at compile time that a query result is empty then subsequent \nbound computations can be ignored. Another basic decision problem is the XPath equivalence problem: whether \nor not two queries always return the same result. It is important for reformulation and opti\u00admizationofanexpression[17], \nwhichaimat enforcing operational properties while preserving semantic equivalence [23]. The most essential \nproblem for type-checking is XPath containment. It is re\u00adquired for the control-.ow analysis of XSLT[25], \nfor checking in\u00adtegrity constraints, and for XML security [12]. The complexity of XPath decision problems \nheavily depends on the language features. Previousworks [28,3]showed that including general comparisons \nof data values from an in.nite domain may lead to undecidability. Therefore, we focus on a XPath fragment \nwhich covers all features except counting [8]and data values. In our approach to solve XPath decision \nproblems, two issues need to be addressed. First, we identify the most appropriate logic withsuf.cientexpressivenessto \ncapturebothregulartreetypesand our XPath fragment. Second, we solve ef.ciently the satis.ability problem \nwhich allows to test if a given formula ofthe logic admits a satisfying .nite tree. The essence of our \nresults lives in a sub-logic of the alternation free modal \u00b5-calculus (AFMC) with converse, some syntactic \nre\u00adstrictions on formulas, without greatest .xpoint, and whose models are .nite trees.We prove thatXPathexpressions \nand regular tree type formulas conform to these syntactic restrictions. Boolean clo\u00adsureisthekeypropertyfor \nsolvingthe containment(a logicalim\u00adplication). In order to obtain closure under negation, we prove that \nthe leastand greatest .xpoint operators collapseina single .xpoint operator. Surprisingly, the translations \nof XML regular tree types andalargeXPathfragmentdoesnot increasecomplexitysincethey are linear in the \nsize of the corresponding formulasin the logic. The combination of these ingredients lead to our main \nresult: a satis.\u00adability algorithm for a logic for .nite trees whose time complexity is a simple exponential \nof the size of a formula. The decision procedure has been implemented in a system for solving XML decision \nproblems such as XPath emptiness, con\u00adtainment, overlap, and coverage, with or without XML type con\u00adstraints. \nThe system can be used as a component of static analyzers for programming languages manipulating XPath \nexpressions and XML type annotations for both input and output. 2. Outline The paperis organized as follows.We \n.rst present our data model, trees with focus, and our logic in \u00a73and\u00a74.We next presentXPath and its \ntranslation in our logic in \u00a75. Our satis.ability algorithm is introduced and proven correct in \u00a76, and \na few details of the implementation arediscussedin \u00a77. Applications fortype checking and someexperimental \nresults are describedin \u00a78.Westudy related work in \u00a79and conclude in\u00a710. Detailed proofs and implementation \ntechniques can be found in a long version of this paper [16]. 3. Trees withFocus In order to represent \nXML trees that are easy to navigate we use fo\u00adcused trees, inspiredbyHuet s Zipper data structure [20].Focused \ntrees not only describea treebut also its context: its previous sib\u00adlings and its parent, including its \nparent context recursively. Explor\u00ading such a structure has the advantage to preserve all information, \nwhich is quite useful when considering languages such as XPath that allow forward and backward axes of \nnavigation. Formally, we assume an alphabetS of labels, rangedoverby s. t ::= s[tl] tree tl ::= list \nof trees f empty list c |::= t :: tl cons cell context (tl, Top, tl) root of the tree f |::= (tl, c[s], \ntl) (t, c) context node focused tree In order to deal with decision problems such as containment, we \nneed to represent in a focused tree the place where the evaluation was started using a start mark, often \nsimply called mark in the following.Todoso,we consider focused trees wherea single tree or a single context \nnode is marked, as in s\u00ae[tl] or (tl,c[s\u00ae], tl). When the presence of the mark is unknown, we write it \nas s.[tl]. We writeF for the set of .nite focused trees with a single mark. The name of a focused tree \nis de.ned as nm(s.[tl],c)= s. We now describe how to navigate focused trees, in binary style. There are \nfour directions that can be followed: for a focused tree f, f (1) changes the focus to the children of \nthe current tree, f (2) .\u00b8 changes the focus to the next sibling of the current tree, f 1changes the \nfocus to the parent of the tree if the current tree is .\u00b8 a leftmost sibling, and f 2changes the focus \nto the previous sibling. Formally,we have: .[t :: tl],c) (1) def . (s=(t, (f, c[s], tl)) .' :: tlr)) \n(2) def '. (t, (tll,c[s],t=(t, (t :: tll,c[s], tlr)) . .\u00b8 def. (t, (f, c[s], tl))1=(s[t :: tl],c) . '.\u00b8 \ndef .' (t, (t :: tll,c[s], tlr))2=(t, (tll,c[s],t:: tlr)) When the focused tree does not have the required \nshape, these operations are not de.ned. 4. The Logic We introduce in this section the logic to which \nXPath expressions and XML regular tree types are going to be translated, a sub-logic of the alternation \nfree modal \u00b5-calculus with converse. We also introduce a restriction on the formulas we consider and \ngive an interpretationof formulas as setsof .nite focused trees.We .nally show that the logic has a single \n.xpoint for these models and that it is closed under negation. L\u00b5 ., . ::= formula T true |||||||| s \n| \u00acs \u00ae | \u00ac\u00ae X . . . . . . (a). | \u00ac (a) T \u00b5Xi..i in . .Xi..i in . atomic prop (negated) start prop (negated) \nvariable disjunction conjunction existential (negated) least n-ary .xpoint greatest n-ary .xpoint Figure \n1. Logic formulas def def = F = {f | nm(f)= s} [T]V [s]V def def [X]V = V (X) [\u00acs]V = {f | nm(f)= s} \nno def def \u00ae [. . .]V = [.]V . [.]V [\u00ae]V = f | f =(s[tl],c) def def [. . .]V = [.]V n [.]V [\u00ac\u00ae]V = {f \n| f =(s[tl],c)} [(a) .]V def = {f (a)| f . [.]V . f (a) de.ned} def [\u00ac(a)T]V = {f | f (a) unde.ned} \\n \no def [\u00b5Xi..i in .]V = let Ti = Ti .F| [.i]V [Ti/Xi] . Ti i in [.]V [Ti/Xi] [n o def [.Xi..i in .]V \n= let Ti = Ti .F| Ti . [.i]V [Ti/Xi] i in [.]V [Ti/Xi] Figure 2. Interpretation of formulas In the following \nde.nitions, a .{1, 2, 1, 2} are programs and atomic propositions s correspond to labels from S.Wealso \nassume that a = a.Formulas de.ned in Fig.1include the truth predicate, atomic propositions (denoting \nthe name of the tree in focus), start propositions (denoting the presence of the start mark), disjunction \nand conjunction of formulas, formulas under an existential (denot\u00ading the existence a subtree satisfying \nthe sub-formula), and least and greatest n-ary .xpoints.We choseto includean-aryversionof .xpoints because \nregular types are often de.ned as a set of mutu\u00adally recursivede.nitions, making their translation in \nour logic more succinct. In the following we write \u00b5X.. for \u00b5X.. in . . Wede.neinFig.2an interpretationof \nour formulasas setsof.\u00adnitefocusedtreeswithasinglestartmark.The interpretationofthe n-ary .xpoints .rst \ncompute the smallest or largest interpretation for each .i then returns the interpretation of .. We now \nrestrict the set of valid formulas tocycle-free formulas, i.e. formulas that have a bound on the number \nof modality cycles independently of the number of unfolding of their .xpoints. A modality cycle is a \nsubformula of the form (a) . where . contains a top-level existential of the form (a) .. (By top-level \nwe mean underan arbitrary numberof conjunctionsor disjunctions,butnot under anyother construct.)For instance, \nthe formula \u00b5X. (1) (.. .\u00b8 1X) in X is not cycle free: for any integer n, there is an unfolding of the \nformula with n modalitycycles.Ontheother hand, .\u00b8 the formula \u00b5X. (1) (X .Y ), Y. 1(Y .T) in X iscycle \nfree: there is at most one modality cycle. Cycle-free formulas have a very interesting property, which \nwe now describe.To test whethera tree satis.es a formula, one may de.ne a straightforward inductive relation \nbetween trees and for\u00admulas that only holds when the root of the tree satis.es the formula, unfolding \n.xpoints if necessary. Given a tree, if a formula . is cy\u00adcle free, then every node of the tree will \nbe tested a .nite number of time against any given subformula of .. The intuition behind this property, \nwhichholdsa central rolein the proofof lemma 4.2, is the following. If a tree node is tested an in.nite \nnumber oftimes againstasubformula,thentheremustbeacycleinthenavigationin the tree, corresponding to some \nmodalities occurring in the subfor\u00admula, between one occurrence of the test and the next one. As we consider \ntrees,thecycle implies thereisa modalitycycleinthefor\u00ad . \u00b8.\u00b8 mula (as cycles of the form (1)(2) 12cannot \noccur). Hence the numberof modalitycyclesinanyexpansionof . is unbounded, thus the formula is not cycle \nfree. Wearenowreadytoshowa.rst result:inthe .nite focused-tree interpretation, the least and greatest \n.xpoints coincide for cycle\u00adfree formulas. To this end, we prove a stronger result that states that a \ngiven focused tree is in the interpretation of a formula if it is in a .nite unfolding of the formula. \nIn the base case, we use the formula s .\u00acs as false . DEFINITION 4.1 (Finite unfolding). The .nite unfolding \nof a for\u00admula . is the set unf (.) inductively de.ned as def unf (.)= {.} for . = T, s, \u00acs, \u00ae, \u00ac\u00ae, X, \n\u00ac(a)T .\u00af def ''' ' unf (. . .)= . . . | . . unf (.),. . unf (.) .\u00af def ''' ' unf (. . .)= . . . | . . \nunf (.),. . unf (.) .\u00af def '' unf ((a) .)= (a) . | . . unf (.) def unf (\u00b5Xi..i in .)= unf (.{\u00b5Xi..i in \nXi/Xi }) .{s .\u00acs} def unf (.Xi..i in .)= unf (.{.Xi..i in Xi/Xi }) .{s .\u00acs} LEMMA 4.2. Let . acycle-free \nformula, then[.]V = [unf (.)]V . The reason whythis lemma holds is the following. Given a tree satisfying \n., we deduce from the hypothesis that . is cycle free thefact thatevery nodeof the tree willbe testeda \n.nite numberof times against every subformula of .. As the tree and the number of subformulas are .nite, \nthe satisfaction derivation is .nite hence onlya .nite numberof unfoldingis necessarytoprovethatthe tree \nsatis.es the formula, which is what the lemma states. As least and greatest .xpoints coincide when only \na .nite number of unfolding is required, this is suf.cient to show that theycollapse. Note that this \nwould not hold if in.nite trees were allowed: the formula \u00b5X. (1) X is cycle free, but its interpretation \nis empty, whereas the interpretation of .X. (1) X includes every tree with an in.nite branch of (1) children. \nWe now illustrate why formulas need to be cycle free for the .\u00b8 .xpoints to collapse. Consider the formula \n\u00b5X. (1.) \u00b81X. Its in\u00adterpretationis empty.The interpretationof .X. (1) 1X however contains every focused \ntree that has one (1) child. In the rest of the paper, we only consider least .xpoints. An important \nconsequence of Lemma 4.2 is that the logic restricted in this way is closed under negation using De Morgan \ns dualities, extended to eventualities and .xpoints as follows: def \u00ac(a) . = \u00ac(a)T.(a)\u00ac. def \u00ac\u00b5Xi..i \nin . = \u00b5Xi.\u00ac.i{Xi/\u00acXi } in \u00ac.{Xi/\u00acXi } 5. XPath and RegularTree Languages XPath[6]isapowerful languagefornavigatinginXML \ndocuments and selecting sets of nodes matching a predicate. In their simplest form,XPathexpressionslooklike \ndirectorynavigationpaths .For LXPath e ::= XPath expression /p absolute path Path p |||::= p e1 . e2 \ne1 n e2 relative path union intersection path p1/p2 path composition Qualif q |||::= p[q] a::s a::* quali.ed \npath step with node test step quali.er q1 and q2 conjunction Axis a |||::= q1 or q2 not q p disjunction \nnegation path tree navigation axis |||| child | self | parent descendant | desc-or-self ancestor | anc-or-self \nfoll-sibling | prec-sibling following | preceding Figure 3. XPath Abstract Syntax. example, the XPath \nexpression /child::book/child::chapter/child::section navigates from the root of a document (designated \nby the lead\u00ading / ) through the top-level book node to its chapter child nodes and on to its child nodes \nnamed section . The result of the evaluation of the entire expression is the set of all the section nodes \nthat can be reached in this manner. The situation becomes more interesting when combined with XPath scapability \nof search\u00ading along axes other than child .For instance, one may use the preceding-sibling axis for navigating \nbackward through nodes of the same parent, or the ancestor axis for navigating upward re\u00adcursively. Furthermore, \nat each step in the navigation the selected nodes can be .ltered using quali.ers: boolean expression \nbetween brackets that can test theexistence or absenceofpaths. We consider a large XPath fragment covering \nall major features oftheXPath recommendation[6]except countingand comparisons between data values. Fig. \n3 gives the syntax of XPath expressions. Fig. 4 gives an interpretation of XPath expressions as functions \nbetween sets of focused trees. 5.1 XPath Embedding We now explain how an XPath expression can be translated \ninto an equivalent L\u00b5 formula that performs navigation in focused trees in binary style. Logical Interpretation \nof Axes The translation of navigational primitives (namelyXPathaxes)is formally speci.edinFig.5.The translation \nfunction, noted A.[a]. , takes an XPath axis a as input, and returns its L\u00b5 translation, parameterizedbythe \nL\u00b5 for\u00admula . given as parameter. This parameter represents the context in which the axis occurs and \nis needed for formula composition in order to translate path composition. More precisely, the formula \nA. [a]. holds for all nodes that can be accessed through the axis a from some node verifying .. Let us \nconsider an example. The formula A.[child]., trans\u00ad .\u00b8 .\u00b8 lated as \u00b5Z. 1. . 2Z, is satis.ed by children \nof the context .. These nodes consist of the .rst child and the remaining chil\u00addren. From the .rst child, \nthe context must be reached immediately Se[\u00b7]\u00b7 : LXPath . 2F . 2F def Se[/p]F = Sp[p]root(F ) def Se[p]F \n= Sp[p]{(s\u00ae[tl],c).F } Se[e1 I e2]F def = Se[e1]F .Se[e2]F def Se[e1 n e2]F = Se[e1]F nSe[e2]F Sp[\u00b7]\u00b7 \n: Path. 2F . 2F no def '' Sp[p1/p2]F = f | f .Sp[p2](Sp[p1hF ) def Sp[p[q]]F = {f | f .Sp[p]F .Sq[q]f \n} def Sp[a::s]F = {f | f .Sa[a]F . nm(f)= s} def Sp[a::*]F = {f | f .Sa[a]F } Sq[\u00b7]\u00b7 : Qualif .F.{true, \nfalse} def Sq[q1 and q2]f = Sq[q1]f .Sq[q2]f def Sq[q1 or q2]f = Sq[q1]f .Sq[q2]f def Sq[not q]f = \u00acSq[q]f \ndef Sq[p]f = Sp[p]{f} = \u00d8 Sa[\u00b7]\u00b7 : Axis . 2F . 2F def Sa[self]F = F def Sa[child]F = fchild(F ) .Sa[foll-sibling]fchild(F \n) def Sa[foll-sibling]F = nsibling(F ) .Sa[foll-sibling]nsibling(F ) def Sa[prec-sibling]F = psibling(F \n) .Sa[prec-sibling]psibling(F ) def Sa[parent]F = parent(F ) def Sa[descendant]F = Sa[child]F .Sa[descendant](Sa[childhF \n) def Sa[desc-or-self]F = F .Sa[descendant]F def Sa[ancestor]F = Sa[parent]F .Sa[ancestor](Sa[parenthF \n) def Sa[anc-or-self]F = F .Sa[ancestor]F Sa[following]F def = Sa[desc-or-self](Sa[foll-siblingh(Sa[anc-or-self]F \n)) Sa[preceding]F def = Sa[desc-or-self](Sa[prec-siblingh(Sa[anc-or-self]F )) def fchild(F )= {f (1)| \nf . F . f (1) de.ned} def nsibling(F )= {f (2)| f . F . f (2) de.ned} ..\u00b8 .\u00b8\u00af def psibling(F )= f 2| \nf . F . f 2de.ned def . parent(F )= {(s[rev a(tll,t :: tlr)],c) | (t, (tll,c[s.], tlr)) . F } def rev \na(f, tlr)= tlr def rev a(t :: tll, tlr)= rev a(tll,t :: tlr) def \u00ae root(F )= {(s[tl], (tl, Top, tl)) \n. F } . root(parent(F )) A. [\u00b7]\u00b7 : Axis .L\u00b5 .L\u00b5 def A. [self]. = . . def A[child]. = \u00b5Z. . 1\u00b8 . . . 2\u00b8Z \n. def A[foll-sibling]. = \u00b5Z. . 2\u00b8 . . . 2\u00b8Z def A. [prec-sibling]. = \u00b5Z. (2) . .(2) Z . def A[parent]. \n= (1) \u00b5Z.. .(2) Z . def A[descendant]. = \u00b5Z. . 1\u00b8 (. . . Z\u00b8 ) . . 2\u00b8 Z .\u00b8 def A. [desc-or-self]. = \u00b5Z.. \n. \u00b5Y. 1(Y . Z) . 2Y . def A[ancestor]. = (1) \u00b5Z.. .(1) Z .(2) Z . def A[anc-or-self]. = \u00b5Z.. .(1) \u00b5Y.Z \n.(2) Y . def . A[following]. = A[desc-or-self].1 . def . A[preceding]. = A[desc-or-self].2 def . = A[foll-sibling]A.[anc-or-selfh \n.1 . def . .2 = A[prec-sibling]A.[anc-or-selfh . Figure 5. Translation of XPath Axes. E. [\u00b7]\u00b7 : LXPath \n.L\u00b5 .L\u00b5 . def .E[/p]. = P [p]((\u00b5Z.\u00ac(1)h.(2)Z).(\u00b5Y...\u00ae.(1)Y .(2)Y )) . def . E= P [p]. [p](..\u00ae) . def \n.. E= E [e1 I e2]. [e1]. . E[e2]. . def .. E= E [e1 n e2]. [e1]. . E[e2]. P . [\u00b7]\u00b7 : Path.L\u00b5 .L\u00b5 . \ndef . P [p1/p2]. = P [p2](P .[p1h.) . def .. P = P [p[q]]. [p]. . Q[q]h . def . P [a::s]. = s . A[a]. \n. def . P [a::*]. = A[a]. Figure 6. Translationof Expressions andPaths. by going once upward via 1. \nFrom the remaining children, the con\u00adtext is reached by going upward (anynumber of times) via 2 and then \n.nally once via 1. Logical Interpretation of Expressions Fig.6gives the translation of XPath expressions \ninto L\u00b5. The translation function E. [e]. takes an XPath expression e and a L\u00b5 formula . as input, and \nre\u00adturns the corresponding L\u00b5 translation.The translationofarelative XPath expression marks the initial \ncontext with \u00ae. The translation ofan absoluteXPathexpressionnavigatestothe root whichistaken as the initial \ncontext. Figure 7 illustrates the translation of the XPath expression child::a[child::b] . This expression \nselects all a child nodesofa given context which have at least one b child. The translated L\u00b5 formula \nholds for a nodes which are selected by the expression. The .rst part of the translated formula, ., corresponds \nto the step Figure 4. InterpretationofXPathin termsofFocusedTrees. ... . Translated Query: child::a \n[child::b] .\u00b8.\u00b8 a . (\u00b5X. 1(. . \u00ae) . 2X) .(1) \u00b5Y.b .(2) Y | {z }|{z} .. Figure 7. XPathTranslation Example. \nchild::a which selects candidates a nodes. The second part, ., navigates downward in the subtrees of \nthese candidate nodes to verify that theyhave at least one immediate b child. Note that without converse \nprograms we would have been un\u00adable to differentiate selected nodes from nodes whose existence is tested: \nwe must state properties on both the ancestors andthe de\u00adscendants of the selected node. Equipping the \nL\u00b5 logic with both forward and converse programs is therefore crucial for supporting XPath. Logics without \nconverse programs may only be used for solvingXPath emptinessbut cannotbe usedfor solving other deci\u00adsion \nproblems such as containment ef.ciently. XPath composition construct p1/p2 translates into formula composition \nin L\u00b5, such that the resulting formula holds for all nodes accessed through p2 from those nodes accessed \nthrough p1 from .. The translation of the branching construct p[q] signi.\u00adcantly differs. The resulting \nformula must hold for all nodes that can be accessed through p and from which q holds.To preserve se\u00admantics, \nthe translation of p[q] stops the selecting navigation to those nodes reached by p, then .lters them \ndepending on whether q holds or not.Weexpress thisby introducinga dual formal trans\u00adlation function for \nXPath quali.ers, noted Q.and de.ned in [q]\u00b7 Fig. 8, that performs .ltering instead of navigation. Speci.cally, \nP .can be seen as the navigational translating function: the [\u00b7]\u00b7 translated formula holds for target \nnodes of the given path. On the opposite, Q.can be seen as the .ltering translating func\u00ad [\u00b7]\u00b7 tion: \nit states the existence of a path without moving to its result. The translated formula Q.[q]. (respectively \nP .[p].)holds for nodes from which there exists a quali.er q (respectively a path p) leading to a node \nverifying .. XPath translation is based on these two translating modes , the .rst one being used for \npaths and the second one for quali.ers. Whenever the .ltering mode is entered, it will never be left. \nThe translation of paths inside quali.ers is also given in Fig. 8. It uses the translation for axes and \nis based on XPath symmetry: symmetric(a) denotes the symmetric XPath axis corresponding to the axis a \n(for instance symmetric(child)= parent). We may now state that our translation is correct, by relating \nthe interpretation of an XPath formula applied to some set of trees to the interpretationofits translation,by \nstatingthatthe translationof a formula is cycle-free, and by giving a bound in the size of this translation. \nWe restrict the sets of trees to which an XPath formula may be applied to those that may be denoted by \nan L\u00b5 formula. This restrictionwillbe justi.edin Section5.2whereweshowthatevery regular tree language \nmay be translated to an L\u00b5 formula. PROPOSITION 5.1 (Translation Correctness). The following hold for \nan XPath expression e and a L\u00b5 formula . denoting a set of focused trees, with . = E. [e].: Q. : Qualif \n.L\u00b5 .L\u00b5 [\u00b7]\u00b7 . def .. Q[q1 and q2]. = Q[q1]. . Q[q2]. . def .. Q[q1 or q2]. = Q[q1]. . Q[q2]. . def . \nQ[not q]. = \u00ac Q[q]. . def . Q= P [p]. [p]. P . : Path.L\u00b5 .L\u00b5 [\u00b7]\u00b7 . def . P [p1/p2]. = P [p1](P .[p2h.) \n. def . P = P [p[q]]. [p](..Q.[qhT) . def . P [a::s]. = A[a](..s) . def . P [a::*]. = A[a]. A. : Axis \n.L\u00b5 .L\u00b5 [\u00b7]\u00b7 . def . A[a]. = A[symmetric(a)]. Figure 8. Translation of Quali.ers. 1. [.]\u00d8 = Se[e][.h\u00d8 \n2. . is cycle-free 3. the size of . is linear in the size of e and .  5.2 Embedding RegularTree Languages \nSeveral formalisms exist for describing types of XML documents (e.g. DTD, XML Schema, Relax NG). In this \npaper we embed regular tree languages, whichgather all of them [26] into L\u00b5.We rely on a straightforward \nisomorphism between unranked regular tree types and binary regular tree types [19]. Assuminga countably \nin.nite set of type variables ranged over by X, binary regular tree type expressions are de.ned as follows: \nLBT T ::= tree type expression \u00d8 empty set | f leaf | T1 I T2 union | s(X1,X2) label | let Xi.Ti in T \nbinder Werefer the reader to [19] for the denotational semantics of regular tree languages, and directly \nintroduce their translation into L\u00b5: [\u00b7] : LBT .L\u00b5 def = s .\u00acs for T = \u00d8,f [T1 I[TT 2]] def = [T1] . \n[T2] def [s(X1,X2)] = s . succ1(X1) . succ2(X2) def [let Xi.Ti in T ] = \u00b5Xi.[Ti] in [T ] where we use \nthe formula s .\u00acs as false , and the function succ\u00b7(\u00b7) takes care of setting the type frontier: 8 < \u00ac(a)T \nif X is bound to f succa(X)= \u00ac(a)T.(a) X if nullable(X) : (a) X if not nullable(X) according to the \npredicate nullable(X) which indicates whether the type T = f bound toXcontains the empty tree. Note that \nthe translation of a regular tree type uses only down\u00adward modalities since it describes the allowed \nsubtrees at a given context. No additional restriction is imposed on the context from which the type \nde.nition starts. In particular, navigation is allowed in the upward direction so that we can supporttype \nconstraints for which we have only partial knowledge in a given direction. How\u00adever, when we know the \nposition of the root, conditions similar to those of absolute paths are added in the form of additional \nformulas describing the position that need to be satis.ed. This is particularly useful when a regular \ntype is used by an XPath expression that starts its navigation at the root(/p)since the path will not \ngo above . \u00b8.\u00b8 the root of the type (by adding the restriction \u00b5Z.\u00ac 1T. 2Z). On the other hand, if the \ntype is compared with another type (typically to check inclusion of the result of an XPath expression \nin this type), then there is no restriction as to where the root ofthe type is (our translation does \nnot impose the chosen node to be at the root). This is particularly useful since an XPath expression \nusually returns a set of nodes deep in the tree which we may compare to this partially de.ned type. 6. \nSatis.ability-Testing Algorithm In this section we present our algorithm, show that it is sound and complete, \nand prove a time complexity boundary. To check a formula ., our algorithmbuilds satis.able formulas outof \nsome subformulas (and their negation) of ., then checks whether . was produced.We .rst describehowtoextractthe \nsubformulasfrom .. 6.1 Preliminary De.nitions def For. =(\u00b5Xi..i in .) we de.ne exp(.)= .{\u00b5Xi..i in Xi/Xi \n}which denotes the formula . in which every occurrence of a Xi is replaced by (\u00b5Xi..i in Xi). Wede.ne \ntheFisher-Ladner closurecl(.) ofaformula . as the set of all subformulas of . where .xpoint formulas \nare additionally unwound once. Speci.cally, we de.ne the relation .e.L\u00b5 \u00d7L\u00b5 as the least relation that \nsatis.es the following: .1 . .2 .e .1, .1 . .2 .e .2  .1 . .2 .e .1, .1 . .2 .e .2  (a) . ' .e . ' \n \u00b5Xi..i in . .e exp(\u00b5Xi..i in .)  The closure cl(.) is the smallest set S that contains . and closed \nunder the relation .e, i.e. if .1 . S and .1 .e .2 then .2 . S. We callS(.) the set of atomic propositions \ns used in . along with another name, sx, that does not occur in. to represent atomic propositions not \noccurring in .. We de.ne cl* (.)= cl(.) . {\u00ac. | . . cl(.)}. Every formula . . cl* (.) can be seen as \na boolean combination of formulas of a set called the Lean of ., inspired from [27]. We note this set \nLean(.) and de.ne it as follows: . \u00af Lean(.)= (a)T | a .{1, 2, 1, 2}. S(.) .{\u00ae} . {(a) . |(a) . . cl(.)} \nA.-type (or simplya type )(Hintikka set in the temporal logic literature) is a set t . Lean(.) such that: \n.(a) . . Lean(.), (a) . . t .(a)T . t (modal consis\u00adtency); . \u00b8 .\u00b8 1T./t . 2T./t (a tree node cannot \nbe both a .rstchild and a second child);  exactly one atomic proposition s . t (XML labeling); we use \nthe function s(t) to return the atomic proposition of a type t;  \u00ae may belong to t.  . . Lean(.) . \n. t T. . t =. (\u00d8, \u00d8) . . . t =. ({.}, \u00d8) .1 . . t =. (T1,F1) .2 . . t =. (T2,F2) .1 . .2 . . t =. (T1 \n. T2,F1 . F2) .1 . . t =. (T1,F1) .2 . . t =. (T2,F2) .1 . .2 . . t =. (T1,F1) .1 . .2 . . t =. (T2,F2) \n. ./. t =. (T,F ) exp(\u00b5Xi..i in .) . . t =. (T,F ) \u00ac. . . t =. (T,F ) \u00b5Xi..i in . . . t =. (T,F ) . . \nLean(.) . . t . ./. t =. (\u00d8, {.}) .1 ./. t =. (T1,F1) .2 ./. t =. (T2,F2) .1 . .2 ./. t =. (T1 . T2,F1 \n. F2) .1 ./. t =. (T1,F1) .2 ./. t =. (T2,F2) .1 . .2 ./. t =. (T1,F1) .1 . .2 ./. t =. (T2,F2) . . . \nt =. (T,F ) exp(\u00b5Xi..i in .) ./. t =. (T,F ) \u00ac. ./. t =. (T,F ) \u00b5Xi..i in . ./. t =. (T,F ) Figure 9. \nTruth assignment of a formula We callTypes(.) the set of .-types.For a .-type t, the comple\u00adment of \nt is the set Lean(.) \\ t. Atype determinesatruth assignmentofevery formulaincl* (.) with the relation \n. . de.ned in Fig. 9. Note that such derivations are .nite because the number of naked \u00b5Xi..i in . (that \ndo not occur under modalities) strictly decreases after each expansion. We often write . . . t if there \nare some T,F such that . . . t =. (T,F ).We say that a formula . is true at a type t iff . . . t. We \nnow relate a formula to the truth assignment of its.-types. PROPOSITION 6.1. If . . . t =. (T,F ), then \nwe have T . t, VV F . Lean(.) \\ t, and . .\u00ac. implies . (every ..T..F tree in the interpretation of \nthe .rst formula is in the interpretation of the second). If . ./. t =. (T,F ), then we have T . t, VV \n F . Lean(.) \\ t, and . .\u00ac. implies \u00ac.. ..T..F We next de.ne a compatibility relation between types \nto state that two types are related according to a modality. DEFINITION 6.2 (Compatibility relation). \nTwo types t and t ' are compatible under a .{1, 2}, written .a(t, t ' ), iff ' .(a) . . Lean(.), (a) \n. . t . . . . t .(a) . . Lean(.), (a) . . t ' . . . . t  6.2 The Algorithm The algorithm works on sets \nof triples of the form (t, w1,w2) where t is a type, and w1 and w2 are sets of types which represent \nevery witness for t according to relations .1(t, \u00b7) and .2(t, \u00b7). The algorithm proceeds in a bottom-up \napproach, repeatedly adding new triples until a satisfying model is found (i.e. a triple whose .rst component \nis a type implying the formula), or until no def .... Upd(X)= X .{(t, w1(t, X), w2(t, X)) | \u00ae ./t . Types(.) \n.(1)T . t . w1(t, X)= \u00d8.(2)T . t . w2(t, X)= \u00d8} no ..\u00ae .. . (t, w1(t, X), w2(t, X))| \u00ae . t . Types(.) \n.(1)T . t . w1(t, X)= \u00d8.(2)T . t . w2(t, X)= \u00d8 no \u00ae.\u00ae\u00ae. . (t, w1(t, X), w2(t, X))| \u00ae ./t . Types(.) .(1)T \n. t . w1(t, X)= \u00d8.(2)T . t . w2(t, X)= \u00d8 no . (t, w1(t, X.), w2(t, X\u00ae))\u00ae | \u00ae ./t . Types(.) .(1)T . t \n. w1(t, X.)= \u00d8.(2)T . t . w2(t, X\u00ae)= \u00d8 no def \u00ae def \u00ae wa(t, X)= {type(x) | x . X .(a)T . type(x) . .a(t, \ntype(x))} X= x . X | x =( ,, ) def \u00ae . def FinalCheck(., X)= .x . X, dsat(x, .) ..a .{1, 2}, (a)T ./type(x) \nX= {x . X | x =( ,, )} def ''' ' def dsat((t, w1,w2),.)= . . . t ..x, dsat(x ,.) . (x . w1 . x . w2) \ntype((t, w1,w2)) = t Figure 10. Operations usedby the Algorithm. more triple can be added. Each iteration \nof the algorithm builds types representing deeper trees (in the 1 and 2 direction) with pending backward \nmodalities that will be ful.lled at later iterations. Types with no backward modalities are satis.able, \nand if such a type implies the formula being tested, then it is satis.able. The main iteration is as \nfollows: X .\u00d8 repeat X ' . X X . Upd(X ' ) if FinalCheck(., X) then return . is satis.able until X = \nX ' return . is unsatis.able where X . Types(.) \u00d7 2Types(.) \u00d7 2Types(.) and the operations Upd(\u00b7) and \nFinalCheck(\u00b7) are de.ned on Fig. 10. We note Xi the set of triples and T i the set of types after i .\u00af \niterations: T i = type(x) | x . Xi . Note that T i+1 is the set of types for which at least one witness \nbelongs to T i .  6.3 Correctness and Complexity In this section we de.ne the necessary notions to prove \nthe correct\u00adness of the satis.ability testing algorithm, and show that its time complexity is 2O(|Lean(.)|). \nTHEOREM 6.3 (Correctness). The algorithm decides satis.ability of L\u00b5 formulas over .nite focused trees. \nTermination For. .L\u00b5,since cl(.) isa.nite set, Lean(.) and 2Lean(.) are also .nite. Furthermore, Upd(\u00b7) \nis monotonic and each \u00d7 2Types(.) Xi is included in the .nite setTypes(.) \u00d7 2Types(.) , therefore the \nalgorithm terminates.To .nish the proof, it thus suf\u00ad.ces to prove soundness and completeness. Preliminary \nDe.nitionsfor Soundness First, we introduce a no\u00adtion of partial satis.ability for a formula, where backward \nmodal\u00adities areonly checkeduptoagivenlevel.Aformula . is partially satis.ed iff [.]0 = \u00d8 as de.ned in \nFig. 11. V For a typet, we note .c(t) its most constrained formula, where atoms are taken from Lean(.). \nIn the following, . stands for \u00ae if \u00ae . t, and for \u00ac\u00ae otherwise. ^ ^^ .c(t)= s(t) .\u00acs ... (a) . . \u00ac(a) \n. s.S,s /(a)..t .t .t (a)./ We now introduce a notion ofpaths, written . which are con\u00adcatenations of \nmodalities: the empty path is written f,and path con\u00adcatenation is written .a. n def n V = F V [T][X] \nn def nn n [. . .]V = [.]V . [.]V [p]V n def nn n [. . .]V = [.]V n [.]V [\u00acp]V .\u00b8 0 def n 1V = F V .][\u00ae][.\u00b8 \n0 def n 2V = F V [ .][\u00ac\u00ae] .. n>0 def 1= VV def = V (X) def = {f | nm(f)= p} def = {f | nm(f)= p} no def \n\u00ae = f | f =(s[tl],c) def = {f | f =(s[tl],c)} \u00af [ \u00b8 .] f (1)| f . [.] n-1 . f (1) de.ned n>0 def n-1 \n[ . 2\u00b8 .]V = . f (2)| f . [.]V . f (2) de.ned \u00af ..\u00b8 .\u00b8\u00af n def n+1 = f 1. f 1de.ned [(1) .]V | f . [.]V \n..\u00b8 .\u00b8\u00af n def n+1 [(2) .]V = f 2| f . [.]V . f 2de.ned n def [\u00ac(a)T]V = {f | f (a) unde.ned} \\n o n def \nn [\u00b5Xi..i in .]V = let Ti = Ti .F| [.i] . Ti V [Ti/Xi] in [.] n V [Ti/Xi] Figure 11. Partial satis.ability \nEverypath maybegivena depth: depth(f) def = 0 depth(.a) depth(.a) def = depth(.) + 1 def = depth(.) \n- 1 if a . {1, 2} if a . {1, 2} Aforward path is a path that only mentions forward modalities. We de.ne \na tree of types T as a tree whose nodes are types, T (\u00b7)= t, with at most two children, T(1) and T(2). \nThe nav\u00adigationin treesof typesistriviallyextendedto forward paths.A tree of types is consistent iffforevery \nforward path . and forevery child a of T(.), we have T(.) (\u00b7)= t, T(.a) (\u00b7)= t ' implies (a)T . t, (a)T \n. t ', and .a(t, t ' ). Givena consistent treeof types T , we nowde.nea dependency graph whose nodes \nare pairs of a forward path . and a formula in t = T(.) (\u00b7) or the negation of a formula in the complement \nof t. The directed edges of the graph are labeledwith modalities con\u00adsistent with the tree. This graph \ncorresponds to what the algorithm ultimatelybuilds, asevery iteration discovers longer forward paths. \nFor every(., .) in the nodes webuild the following edges: . . S(.) .\u00acS(.) .{\u00ae, \u00ac\u00ae, (a)T, \u00ac(a) T}:no edge \n . = f and . = (a) . ' with a .{1, 2}:no edge  . = . ' a and . = (a ' ) . ':lett = T(.) (\u00b7). We .rst \nconsider the case where a ' .{1, 2} and let t ' = T(.a ' ) (\u00b7). As T is consistent, we have . ' . . t \n' hence there are T,F such that . ' . . t ' =. (T,F ) with T a subset of t ' , and F a subset of the \ncomplement of t '.For every .T . T we  add an edge a ' to (.a ' ,.T ), and for every .F . F we add an \nedge a ' to (.a ' , \u00ac.F ). We now consider the case where a ' .{1, 2} and .rst show that we have a ' \n= a. As T is consistent, we have (a)T in t. Moreover, as t is a tree type, it must contain (a ' )T. As \na ' is a backward modality, it must be equal to a as at most one may be present. Hence we have . ' aa \n' = . ' and we let t ' = T(. ' ) (\u00b7). ' By consistency, we have . ' . . t ', hence . ' . . t =. (T,F \n) and we add edges as in the previous case: to (. ' ,.T ) and to (. ' , \u00ac.F ). . ' is not in t then no \nedge is added. Otherwise, we proceed as in the previous case. For downward modalities, we let t ' = ' \n. = a and . = \u00ac(a ' ) . ': let t = T(.) (\u00b7). If (a ' )T T(.a ' ) (\u00b7) and we compute . ' ./. t =. (T,F \n), which we know to holdby consistency.We then add edges to (.a ' ,.T ) and to (.a ' , \u00ac.F ) as before.Forupward \nmodalities,aswehave (a ' )T in t, we must have a ' = a and we let t ' = T(. ' ) (\u00b7).We compute . ' ./. \nt ' =. (T,F ) and we add the edges to (. ' ,.T ) and to (. ' , \u00ac.F ) as before. LEMMA 6.4. The dependencygraphofa \nconsistenttreeof typesof a cycle-free formula is cycle free. LEMMA 6.5 (Soundness). Let T betheresultsetofthe \nalgorithm. 0 For any typet . T and any . suchthat . . . t, then [.]= \u00d8. \u00d8 Proof outline: Theproof(detailedin[16])proceedsby \ninduction on the number of steps of the algorithm. For every t in T n and every witness tree T rooted \nat t built fromXn, we show that T is a consistent tree type andwebuilda focused tree f that is rooted \n(i.e. of the shape (s.[tl], (f, Top, tl ' ))). We then proceed to show thatf satis.es .c(t) at level \n0.To do so, we use a further induction on the dependencytree. D LEMMA 6.6 (Completeness). Fora cycle-free \nclosed formula. . L\u00b5, if [.]\u00d8 = \u00d8 then the algorithm terminates with a set of triples X suchthat FinalCheck(., \nX). Proof outline: As the formula is satis.able, we consider a smallest focused tree f satisfying it. \nWe then use Lemma 4.2 to derive a .nite satisfaction relation of . that contains f.We then rely on this \nrelationtobuildarunofthe algorithmthat producesatypewithno backward modality implying the formula. D \nLEMMA 6.7 (Complexity). For. .L\u00b5 the satis.ability problem [.]\u00d8 = \u00d8 is decidable in time 2O(n) where \nn = |Lean(.)|. 7. ImplementationTechniques Our implementation relies on a symbolic representation of \nsets of .-types using Binary Decision Diagrams (BDDs) [5]. First, we observe that the implementation \ncan avoid keeping track of every possible witnesses of each .-type. In fact, for a formula ., we can \ntest [.]\u00d8 = \u00d8 by testing the satis.ability of the (linear-size) plunging formula . = \u00b5X.. .(1) X .(2) \nX at the root of focused trees. That is, checking [.]0 = \u00d8 while \u00d8 ensuring there is no unful.lled upward \neventuality at top level 0. One advantage of proceeding this way is that the implementation only need \nto deal with a current set of .-types at each step. We now introduce a bit-vector representation of.-types.Types \nare complete in the sense that either a subformula or its negation mustbelongtoatype.Itisthuspossibleforaformula \n. . Lean(.) to be represented using a single BDD variable. For Lean(.)= {.1, ..., .m}, we represent a \nsubset t . Lean(.) by a vector xt = (t1, ..., tm).{0, 1}m such that .i . t iff ti =1.ABDD with m variablesis \nthen usedto representa setof suchbitvectors. We de.ne auxiliary predicates for programsa .{1, 2}: isparenta(xt) \nis read xt is a parent for program a and is true iff the bit for (a)T is true in xt  ischilda(xt) is \nread xt isachildfor program a and is true iffthe bit for (a)T is true in xt  For a setT . 2Lean(.), \nwe note .T its corresponding character\u00adistic function. Encoding .Types(.) is straightforward. The predicate \nstatus.(xt) is the equivalent of . . on the bit vector representation. We now construct the BDD of the \nrelation.a for a .{1, 2}. This BDD relates all pairs (xx, xy) that are consistent w.r.t the program a, \ni.e., such that xy supports all of xx s (a) . formulas, and vice-versa xx supports all of xy s (a) . \nformulas: 8 ^ < xi . status.(yx) if .i = (a) . def .a(xx, xy)= yi . status.(xx) if .i = (a) . 1=i=m : \nT otherwise Fora .{1, 2}, we de.ne the set of witnessed vectors: def .Wita(T )(xx)= isparenta(xx) ..xy \n[ h(yx) . .a(xx, xy)] where h(xy)= .T (yx) . ischilda(xy). Then, the BDD of the .xpoint computation \nis initially set to the false constant, and the main functionUpd(\u00b7) is implemented as: 0 1 ^ .Upd(T )(xx) \ndef = .T (xx) . @.Types(.)(xx) . a .{1,2} .Wita(T )(xx)A Finally, the solver is implemented as iterations \nover the sets .Upd(T ) until a .xpoint is reached. The .nal satis.ability condition consists in checking \nwhether . is present in a .-type of this .xpoint with no unful.lled upward eventuality. We use two major \ntechniques for further optimization. First, BDD relational products(.xy [ h(xy) . .a(xx, xy)])are computed \nusing conjunctive partitioning and early quanti.cation [10]. Sec\u00adond, we observed that choosing a good \ninitial order of Lean(.) formulas does signi.cantly improve performance. Experience has shown that thevariable \norder determinedbythe breadth-.rst traver\u00adsal of the formula . to solve, which keeps sister subformulas \nin close proximity, yields better results in practice. 8. TypingApplications and Experimental Results \nFor XPathexpressionse1, ..., en,we can formulate several decision problems in the presence of XML type \nexpressions T1, ..., Tn : XPath containment: E.[e1][T1h .\u00acE.[e2][T2h (if the for\u00admula is unsatis.able \nthen all nodes selected by e1 under type constraint T1 are selectedby e2 under type constraint T2)  \nXPath emptiness: E.  [e1][T1h XPath overlap: E. [e1][T1h . E.[e2][T2h XPath coverage: E.V \u00acE. [e1][T1h \n. 2=i=n [ei][Tih Two problems are of special interest for XML type checking: Static type checking of \nan annotated XPath query: E. [e1][T1h .\u00ac[T2] (if the formula is unsatis.able then all e1 /a[.//b[c/*//d]/b[c//d]/b[c/d]] \ne2 /a[.//b[c/*//d]/b[c/d]] e3 a/b//c/foll-sibling::d/e e4 a/b//d[prec-sibling::c]/e e5 a/c/following::d/e \ne6 a/b[//c]/following::d/e n a/d[preceding::c]/e e7 *//switch[ancestor::head]//seq//audio[prec-sibling::video] \ne8 descendant::a[ancestor::a] e9 /descendant::* e10 html/(head I body) e11 html/head/descendant::* e12 \nhtml/body/descendant::* Figure 12. XPath Expressions Used in Experiments. DTD Symbols Binary Type Variables \nSMIL 1.0 19 11 XHTML 1.0 Strict 77 325 Table 1. Types Used in Experiments. nodes selected by e1 under \ntype constraint T1 are included in the type T2.) XPath equivalence under type constraints: E. [e1][T1h.\u00acE.[e2][T2h \nand \u00acE.[e1][T1h.E. (This test can be used to check that the nodes selected after a[e2][T2h modi.cation \nof a type T1 by T2 and an XPath expression e1 by e2 are the same, typically when an input type changes \nand the corresponding XPath query has to change as well.) As no third-party implementation we know of \naddresses reverse axes and recursion, we simply provide evidence that our approach isef.cient.We carried \noutextensive tests1 [16], and present here only a representative sample that includes the most complex \nlan\u00adguage features such as recursive forward and backward axes, in\u00adtersection, large and very recursive \ntypes with a reasonable alpha\u00adbet size. The tests use XPath expressions shown on Fig. 12 (where // is \nused as a shorthand for /desc-or-self::*/ ) and XML types shown onTable1.Table2 presents somedecision \nproblems and corresponding performance results.Timesreportedin milliseconds correspond to the running \ntime of the satis.ability solver without the (negligible) time spent for parsing and translating into \nL\u00b5. The .rst XPath containment instance was .rst formulated in [24] as an example for which the proposed \ntree pattern homomor\u00adphism technique is incomplete. The e8 example shows that the of\u00ad.cial XHTML DTD \ndoes not syntactically prohibit the nesting of anchors.For the XHTML case, we observe that the time neededis \nmore important,but it remains practically relevant, especially for static analysis operations performed \nonly at compile-time. 9. RelatedWork The XPath containment problem has attracted a lot of research at\u00adtentioninthe \ndatabase community,wherethe focuswasgiventothe study of the impact of different XPath features on the \ncontainment complexity (see [28] for an overview). The complexity of XPath satis.ability in the presence \nof DTDs also is extensively studied in [3]. From these results, we know that XPath containment with or \nwithout type constraints ranges from EXPTIME to undecidable. 1Experimentshave been conducted withaJAVA \nimplementation running ona Pentium4,3Ghz, with 512Mbof RAM withWindowsXP. XPath Decision Problem XML \nType Time (ms) e1 . e2 and e2 . e1 e4 . e3 and e4 . e3 e6 . e5 and e5 . e6 none none none 353 45 41 e7 \nis satis.able SMIL 1.0 157 e8 is satis.able e9 . (e10 . e11 . e12) XHTML 1.0 XHTML 1.0 2630 2872 Table \n2. Some Decision Problems and CorrespondingResults. Most formalisms used in the context of XML are related \nto one of the two logics used for unranked trees: .rst-order logic (FO), and Monadic Second Order Logic \n(MSO). FO and relatives are frequently used for querylanguages since they nicely capture their navigational \nfeatures [2]. In a attempt to reach more expres\u00adsive power, the work found in [1] proposes a variant \nof Proposi\u00adtional Dynamic Logic (PDL) with an EXPTIME complexity. MSO, speci.cally the weak monadic second-order \nlogic of two succes\u00adsors(WS2S)[9],isoneofthemostexpressive decidablelogicused when both regular types \nand queries [2] are under consideration. WS2S satis.abilityisknowntobe non-elementary.Adrawbackof the \nWS2S decision procedure is that it requires the full construction and complementation of tree automata. \nSome temporal and .xpoint logics closely related to MSO have been introduced and allow to avoid explicit \nautomata construction. The propositional modal \u00b5-calculus introduced in [22] has been shown to be as \nexpressive as nondeterministic tree automata [11]. Since it is trivially closed under negation, it constitutes \na good alternative for studying MSO-related problems. Moreover, it has been extended with converse programs \nin [31]. The best known complexity for the resulting logic is obtained through reduction to the emptiness \nproblem of alternating tree automaton which is in 2O(n 4 \u00b7log n), where n corresponds to the length of \na formula [18]. Unfortunately the logic lacks the .nite model property. From [31], we know that WS2S \nis exactly as expressive as the alternation-free fragment (AFMC) of the propositional modal \u00b5-calculus. \nFurther\u00admore, the AFMC subsumes all early logics such as CTL and PDL (see [2] for a complete surveyon \ntree logics). The goal of the research presented so far is limited to estab\u00adlishing new theoretical properties \nand complexity bounds. Our re\u00adsearch differs in that we seek precise complexity bounds, ef.cient implementation \ntechniques, and concrete design that may be di\u00adrectly applied to the type checking of XPath queries under \nregular tree types. In this line of research, some experimental results based on WS2S, through the Mona \ntool [21], have recently been reported for XPath containment [15]. However, for static analysis purposes, \nthe explosiveness of the approach is very dif.cult to control due to the non-elementary complexity. Closer \nto our contribution, the recent work found in [29] provides a decision procedure for the AFMC with converse \nwhose time complexity is 2O(n\u00b7log n).How\u00adever, models of the logic are Kripke structures (in.nite graphs). \nEnforcing the .nite tree model property can be done at the syntac\u00adtic level [29], and this has been further \ndeveloped in the XML set\u00adting in [14]. Nevertheless, the drawbackof this approach is that the AFMC decision \nprocedure requires expensive cycle-detection for rejecting in.nite derivation paths for least .xpoint \nformulas. The present work shows how this can be avoided for .nite trees. As a consequence, the resulting \nperformance is much more attractive. In an earlier work on XML type checking, a logic for .nite trees \nwas presented [30],but the logicis not closed under negation. In [7], a technique is presented for statically \nensuring correct\u00adness of paths. The approach only deals with emptiness of XPath expressions without reverse \naxes, whereas our approach solves the more general problem of containment, including reverse axes. The \nwork [25] presents an approximated technique that is able to statically detect errors in XSLT stylesheets. \nTheir approach could certainly bene.t from using our exact algorithm instead of their conservative approximation. \nThe XDuce [19], CDuce [4], and XStatic [13] languages support pattern-matching through regular expression \ntypesbut notXPath.A survey onexisting research on staticallytypecheckingXML transformationscanbefoundin[25]. \n10. Conclusion The main result of our paper is a sound and complete algorithm for the satis.ability of \ndecision problems involving regular tree types and XPath queries with a tighter 2O(n) complexity in the \nlength of a formula. Our approachisbased ona sub-logicof the alternation\u00adfree modal \u00b5-calculus with converse \nfor .nite trees. Our proof method reveals deep connections between this logic and XPath decision problems. \nFirst, the translations of XML reg\u00adular tree types and a large XPath fragment are cycle-free and lin\u00adear \nin the size of the corresponding formulas in the logic. Second, on .nite trees, since both operators \nare equivalent, the logic with a single .xpoint operator is closed under negation. This allows to addresskeyXPath \ndecision problems such as containment. Finally, there are a number of interesting directions for further \nresearch that build on ideas developed here: extending XPath to restricted data values comparisons that \npreserves this complexity, for instance data values on a .nite domain, and integrating related work on \ncounting [8] to our logic.We also plan on continuing to improve the performance of our implementation. \nAcknowledgments Wewouldliketo thank Giorgio Ghelliforhis helpfulcommentson earlier drafts and Benjamin \nC. Pierce for his useful suggestions. References [1] L.Afanasiev,P. Blackburn,I. Dimitriou,B. Gaiffe,E. \nGoris,M. Marx, and M. de Rijke. PDL for ordered trees. Journal of Applied Non-Classical Logics, 15(2):115 \n135, 2005. [2]P. Barcel\u00b4o andL. Libkin. Temporal logicsover unranked trees. In LICS 05: Proceedings of \nthe 20th Annual IEEE Symposium on Logic in Computer Science, pages 31 40,NewYork,NY, USA, 2005. [3] M. \nBenedikt, W. Fan, and F. Geerts. XPath satis.ability in the presence of DTDs. In PODS 05: Proceedings \nof the twenty-fourth ACM Symposium on Principles of Database Systems, pages 25 36, NewYork,NY, USA, 2005.ACM \nPress. [4] V. Benzaken, G. Castagna, and A. Frisch. CDuce: An XML\u00adcentric general-purpose language. In \nICFP 03: Proceedings of the EighthACM SIGPLAN International Conference on Functional Programming, pages \n51 63,NewYork,NY, USA, 2003.ACM Press. [5] R. E. Bryant. Graph-based algorithms for boolean function \nmanipulation. IEEETrans. on Computers, 35(8):677 691, 1986. [6] J. Clark and S. DeRose. XML path language \n(XPath) version 1.0, W3C recommendation, November 1999. http://www.w3.org/TR/ 1999/REC-xpath-19991116. \n[7]D. Colazzo,G. Ghelli,P. Manghi,andC. Sartiani. Static analysisfor path correctness of XML queries. \nJ. Funct. Program., 16(4-5):621 661, 2006. [8] S. Dal Zilio, D. Lugiez, and C. Meyssonnier. Alogic you \ncan count on. In POPL 04: Proceedings of the31stACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages, pages 135 146,NewYork,NY, USA, 2004.ACM Press. [9] J. Doner. Tree acceptors and some of their \napplications. Journal of Computer and System Sciences, 4:406 451, 1970. [10] J. Edmund M. Clarke, O. \nGrumberg, and D. A. Peled. Model checking. MIT Press, Cambridge, MA, USA, 1999. [11] E. A. Emerson and \nC. S. Jutla. Tree automata, \u00b5-calculus and determinacy. In Proceedings of the 32nd annual Symposium on \nFoundations of Computer Science, pages 368 377, Los Alamitos, CA, USA, 1991. IEEE Computer Society Press. \n[12]W.Fan, C.-Y. Chan, andM. Garofalakis. Secure XML querying with security views. In SIGMOD 04:Proceedingsofthe2004ACM \nSIGMOD International Conference on Management of Data, pages 587 598,NewYork,NY, USA, 2004.ACM Press. \n[13] V. Gapeyev and B. C. Pierce. Regular object types. In European Conference on Object-Oriented Programming \n(ECOOP), Darmstadt, Germany, 2003. Apreliminary version was presented at FOOL 03. [14]P. Genev`ida.Asystem \nfor the static analysisofXPath. es and N. Laya\u00a8ACMTrans. Inf. Syst., 24(4):475 502, 2006. [15]P.Genev`esandN.Laya\u00a8ida. \nDecidingXPath containementwithMSO. Data&#38;Knowledge Engineering, to appear, 2007. [16]P. Genev`es,N.Laya\u00a8ida,andA. \nSchmitt. Asatis.ability solverfor XML and XPath, June 2006. http://wam.inrialpes.fr/xml. [17]P. Genev`es \nand J.-Y.Vion-Dury. Logic-basedXPath optimization. In DocEng 04:Proceedingsofthe 2004ACM Symposiumon \nDocument Engineering, pages 211 219,NY, USA, 2004.ACM Press. [18] E. Gr\u00a8adel,W. Thomas, andT.Wilke, editors. \nAutomata logics, and in.nite games: a guide to current research. Springer-Verlag, New York, NY, USA, \n2002. [19]H.Hosoya,J.Vouillon,andB.C. Pierce. Regularexpressiontypes for XML. ACMTrans.Program. Lang. \nSyst., 27(1):46 90, 2005. [20] G.P. Huet. The zipper. J. Funct. Program., 7(5):549 554, 1997. [21] N. \nKlarlund, A. M\u00f8ller, and M. I. Schwartzbach. MONA1.4, January 2001. http://www.brics.dk/mona/. [22] D. \nKozen. Results on the propositional \u00b5-calculus. Theoretical Computer Science, 27:333 354, 1983. [23] \nM.Y. Levin and B. C. Pierce. Type-based optimization for regular patterns. In DBPL 05: Proceedings of \nthe 10th International Symposium on Database Programming Languages, volume 3774 of LNCS, London, UK, \nAugust 2005. Springer-Verlag. [24]G. MiklauandD. Suciu. Containmentandequivalencefora fragment of XPath. \nJournalof theACM, 51(1):2 45, 2004. [25] A. M\u00f8ller and M. I. Schwartzbach. The design space of type checkers \nfor XML transformation languages. In Proc.Tenth International Conference on Database Theory, ICDT 05, \nvolume 3363 of LNCS, pages 17 36. Springer-Verlag, January 2005. [26] M. Murata,D. Lee,M. Mani, andK.Kawaguchi.Taxonomyof \nXML schema languages using formal language theory. ACMTransactions on InternetTechnology, 5(4):660 704, \n2005. [27]G.Pan,U. Sattler,andM.Y.Vardi. BDD-based decision procedures for the modal logic K. Journal \nof Applied Non-classical Logics, 16(1-2):169 208, 2006. [28] T. Schwentick. XPath query containment. \nSIGMOD Record, 33(1):101 109, 2004. [29]Y.Tanabe,K.Takahashi,M.Yamamoto,A.Tozawa,andM. Hagiya. A decision \nprocedure for the alternation-free two-way modal \u00b5\u00adcalculus. In In TABLEAUX 2005, volume 3702 of LNCS, \npages 277 291, London, UK, September 2005. Springer-Verlag. [30] A.Tozawa. On binary tree logic for XML \nand its satis.ability test. In PPL 04: Informal Proceedings of the Sixth JSSSTWorkshop on Programming \nand Programming Languages, 2004. [31] M.Y.Vardi. Reasoning about the past with two-way automata. In ICALP \n98: Proceedings of the 25th International Colloquium on Automata, Languages and Programming, pages 628 \n641, London, UK, 1998. Springer-Verlag.  \n\t\t\t", "proc_id": "1250734", "abstract": "<p>We present an algorithm to solve XPath decision problems under regular tree type constraints and show its use to statically type-check XPath queries. To this end, we prove the decidability of a logic with converse for finite ordered trees whose time complexity is a simple exponential of the size of a formula. The logic corresponds to the alternation free modal &#956;-calculus without greatest fixpoint, restricted to finite trees, and where formulas are cycle-free.</p> <p>Our proof method is based on two auxiliary results. First, XML regular tree types and XPath expressions have a linear translation to cycle-free formulas. Second, the least and greatest fixpoints are equivalent for finite trees, hence the logic is closed under negation.</p> <p>Building on these results, we describe a practical, effective system for solving the satisfiability of a formula. The system has been experimented with some decision problems such as XPath emptiness, containment, overlap, and coverage, with or without type constraints. The benefit of the approach is that our system can be effectively used in static analyzers for programming languages manipulating both XPath expressions and XML type annotations (as input and output types).</p>", "authors": [{"name": "Pierre Genev&#232;s", "author_profile_id": "81331492783", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "PP39070777", "email_address": "", "orcid_id": ""}, {"name": "Nabil Laya&#239;da", "author_profile_id": "81100149392", "affiliation": "INRIA, Montbonnot, France", "person_id": "PP39055050", "email_address": "", "orcid_id": ""}, {"name": "Alan Schmitt", "author_profile_id": "81326492348", "affiliation": "INRIA, Montbonnot, France", "person_id": "PP37036321", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250773", "year": "2007", "article_id": "1250773", "conference": "PLDI", "title": "Efficient static analysis of XML paths and types", "url": "http://dl.acm.org/citation.cfm?id=1250773"}