{"article_publication_date": "06-10-2007", "fulltext": "\n Path Invariants Dirk Beyer Thomas A. Henzinger Rupak Majumdar SFU EPFL UCLA Andrey Rybalchenko EPFL \nand MPI Abstract The success of software veri.cation depends on the ability to .nd a suitable abstraction \nof a program automatically. We propose a method for automated abstraction re.nement which overcomes some \nlimitations of current predicate discovery schemes. In cur\u00adrent schemes, the cause of a false alarm is \nidenti.ed as an infeasi\u00adble error path, and the abstraction is re.ned in order to remove that path. By \ncontrast, we view the cause of a false alarm the spurious counterexample as a full-.edged program, namely, \na fragment of the original program whose control-.ow graph may contain loops and represent unbounded \ncomputations. There are two advantages to using such path programs as counterexamples for abstraction \nre.nement. First, we can bring the whole machinery of program analysis to bear on path programs, which \nare typically small com\u00adpared to the original program. Speci.cally, we use constraint-based invariant \ngeneration to automatically infer invariants of path pro\u00adgrams so-called path invariants. Second, we \nuse path invariants for abstraction re.nement in order to remove not one infeasibility at a time, but \nat once all (possibly in.nitely many) infeasible er\u00adror computations that are represented by a path program. \nUnlike previous predicate discovery schemes, our method handles loops without unrolling them; it infers \nabstractions that involve universal quanti.cation and naturally incorporates disjunctive reasoning. Categories \nand Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and \nMeanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General Terms Veri.cation, \nReliability, Languages Keywords Formal Veri.cation, Software Model Checking, Predi\u00adcate Abstraction, \nAbstraction Re.nement, Invariant Synthesis 1. Introduction Even the most experienced programmers make \nmistakes while pro\u00adgramming, and they spend much time on testing their programs and .xing bugs. Although \nmature syntax and type checkers are Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 07 June 11 13, 2007, San Diego, California, USA. Copyright c &#38;#169; \n2007 ACM 978-1-59593-633-2/07/0006. . . $5.00 available today, automatic proof-and bug-.nding tools on \nthe se\u00admantic level are required to produce robust and reliable code. Pro\u00adgram veri.cation has been a \ncentral topic of research since the early days of computer science. While it has long been known that \nas\u00adsertions (program invariants) are the key to proving a program cor\u00adrect [20,27], the available techniques \nfor automatically .nding use\u00adful assertions are still rather limited. We can broadly classify the techniques \nfor deriving provable as\u00adsertions into two categories. The .rst class of methods relies on the user to \nset up a veri.cation framework i.e., an abstract interpre\u00adtation [13] within which algorithms, often \nbased on constraint solving, can ef.ciently search for program invariants. Examples of such veri.cation \nframeworks include abstract domains (e.g., nu\u00admerical [4, 15], shapes [39]) and invariant templates (e.g., \nlinear arithmetic [43], uninterpreted functions [3]). With these methods, much care must be spent on \nchoosing, for a given program, a suit\u00adable framework which is both suf.ciently expressive to limit the \nnumber of false alarms and suf.ciently inexpensive to compute in\u00advariants ef.ciently. More recently, \nan ambitious approach that originated within model checking [8] has been transferred to program veri.cation \n[2, 26]. This approach, called counterexample-guided abstraction re.nement (CEGAR), attempts to automatically \ntune the veri.ca\u00adtion framework to the necessary degree of precision. In CEGAR, a false alarm called \na counterexample is analyzed for informa\u00adtion how to re.ne the abstract interpretation in order to remove \nthe false alarm. This process is iterated until either a proof or a bug is found. The persuasive simplicity \nof CEGAR has also been its main limitation: a counterexample is an infeasible program path, and to remove \nthat path one adds a predicate on program vari\u00adables [2, 25] i.e., a predicate abstraction [22] to be \ntracked by the abstract interpretation. However, a veri.cation framework that consists solely of tracking \npredicates based on individual infeasi\u00adble program paths is woefully inadequate for many applications. \nFor example, loops are often unrolled iteration by iteration, only to .nd and remove longer and longer \ncounterexamples. Common loops over arrays cannot be handled at all, as the invariant requires universal \nquanti.ers (rather than quanti.er-free predicates) whose .nite instantiations are added by each successive \nre.nement step. We overcome these limitations of CEGAR by generalizing the notion of counterexample. \nFor us, a counterexample is not just a single infeasible program path, but a full-.edged program, namely, \nthe smallest syntactic subprogram of the original program which produces the infeasibility. Such a program \nis called a path pro\u00adgram. Since a path program may contain loops, it often represents not a single infeasibility, \nbut a whole family of infeasibilities all those obtained from unrolling the loops. Hence, by re.ning \nthe ab\u00adstraction in order to remove the counterexample, we remove many (potentially in.nitely many) false \nalarms in one step. However, such a re.nement may require more than the addition of a simple, quanti.er-free \npredicate expressing a relationship between program variables: in general, it requires the addition of \na precise invariant for the path program the so-called path invariant. Thus, instead of relying on heuristics \nfor discovering relevant information about counterexamples, we can bring to bear the entire well-developed \nmachinery for synthesizing program invariants. A path program exhibits only a small portion of the original \nprogram, which is controlled by the property of interest. Hence, in\u00advariant generation for path programs \nis more likely to scale than for the original program. We can apply existing methods and tools, e.g., \nabstract interpreters based on widening, or constraint-based invariant generation methods. The use of \npath programs as coun\u00adterexamples shifts the focus from heuristics for discovering rele\u00advant information, \nto heuristics for ef.ciently discovering informa\u00adtion (relevance is guaranteed). In other words, path \nprograms de\u00adcompose a program veri.cation problem into a series of simpler problems about fragments of \nthe original program. While we are free to apply any program analysis to path pro\u00adgrams, we use template-based \ninvariant generation for the com\u00adbined theories of linear arithmetic, uninterpreted functions, and universal \nquanti.cation over arrays [3] to derive invariants of path programs. This allows us to overcome two major \nlimitations of previous CEGAR-based schemes. First, by synthesizing invariants for path programs with \nloops, we avoid the iterative unwinding of loops suffered by CEGAR tools like SLAM [2] and BLAST [26]. \nThese approaches, by using .nite paths as counterexamples, can never guarantee that the next counterexample \nwould not be a simple variation of the current one, where some of the loops are traversed some more times. \nPath program-based re.nement solves this prob\u00adlem. Second, by synthesizing universally quanti.ed assertions, \nwe can handle a considerably larger class of programs, such as pro\u00adgrams whose correctness depends on \nthe contents of arrays. Again, by using .nite paths as counterexamples, which look only at .nite numbers \nof array cells, it is fundamentally impossible to make jus\u00adti.ed universally quanti.ed statements that \nhold for an unbounded number of array indices. Path programs solve also this problem. Our approach combines \nthe strengths of predicate abstraction and invariant generation. Predicate abstraction performs well \nfor case analysis-based reasoning, e.g., reasoning that depends on aliasing between pointer variables, \nor on boolean .ags that con\u00adtrol the program .ow. Invariant generation, by contrast, is strong in arithmetic \nreasoning and capable of quanti.ed reasoning. Our re\u00ad.nement method is modular, in that it can be easily \nintegrated into existing CEGAR-based software model checkers. We simply need to replace the predicate \ndiscovery module by a call to an invariant synthesizer for path programs. Related Work. Our work is a \nsynthesis of two approaches to pro\u00adgram analysis: counterexample-guided abstraction re.nement and invariant \nsynthesis. Our work uni.es these approaches by general\u00adizing counterexamples from paths (as they are \nusually formulated in CEGAR) to program fragments (path programs) on which we apply invariant-synthesis \ntechniques. As a result, we obtain a pro\u00adgram analysis that can automatically generate richer relationships \nbetween program variables without paying the high cost of search\u00ading through the space of program invariants \nfor the original pro\u00adgram. There has been much recent interest in predicate abstraction\u00adbased software \nmodel checking [16,22], where the set of predicates is extended as the analysis proceeds by analyzing \nspurious coun\u00adterexamples [2, 7, 25, 26, 28, 37]. The incompleteness of traditional implementations of \nCEGAR-based predicate abstraction is well\u00adknown [10, 14], and there have been several attempts to suggest \nprocedures that, in the limit, gain completeness: through carefully choosing widening operations [1], \nor through carefully orchestrat\u00ading the proof search in the underlying decision procedures [29]. In contrast, \nour technique is parameterized by the invariant generation to apply on path programs. There exist invariant \ngenerators that are sound and complete modulo the template language, but the invari\u00adants required to \nprove a program may not exist within the template language. There are several techniques for invariant \nsynthesis, most no\u00adtably by abstract .xpoint computation on a suitably constructed abstract domain [13, \n39], or by a constraint-based analysis that in\u00adstantiates the parameters of an invariant template [30, \n41]. While in our concrete instantiation of path invariants, we have chosen the latter algorithm, our \nframework can equally well be instantiated with an algorithm based on abstract interpretation. Invariants \nfor arithmetic abstract domains have been studied extensively in both styles of analysis: in the abstract \ninterpretation style [15, 32, 38], and using constraint-based methods [5,9,12]. For quanti.ed invari\u00adants \ninvolving arrays, there are algorithms that compute .xpoints using a carefully constructed array domain \n[11,21]. The main draw\u00adback of abstract interpretation methods is a high rate of false alarms (due to \na lack of precision for ef.cient analyses), and the main ob\u00adstacle to applying constraint-based methods \nis their high compu\u00adtational cost. Constraint-based algorithms often do not scale well to large programs, \nand therefore most of their applications have been limited to tricky but small programs. Path invariants \nautomat\u00adically produce small subproblems, making the application of these techniques feasible by restricting \nattention to small programs. The overall CEGAR loop combines these subproblems into a proof of correctness \nof the entire program. The need for universally quanti.ed assertions in the analysis of programs that \nmanipulate unbounded data structures such as ar\u00adrays is well-known, and several approaches have been \nsuggested to use quanti.ed assertions for predicate abstraction. However, these techniques either require \nthe user to specify the assertions (often with Skolem constants for the quanti.ed variables) [19], or \nuse heuristics to derive quanti.ers by generalization from .nite exam\u00adples [34]. In contrast, we apply \nan invariant-generation technique that is sound and complete for a class of invariant templates [3]. \nThe language of our invariants is the combined theory of linear arithmetic and uninterpreted functions, \nextended with a universally quanti.ed array fragment [6]. For templates outside the given tem\u00adplate language, \nwe can still apply our algorithm and generate sound invariants, but as expected, there is no completeness \nguarantee. Treatment of disjunction can be incorporated into the abstract interpretation framework by \nsuitable manipulation of the control\u00ad.ow graph of the program [36, 40]. We can use path invariants to \nimplement such a manipulation in a property-guided way; see Section 5.  2. Examples We illustrate the \nuse of path invariants for automatic re.nement on three examples. The formal exposition of the method \nshall be given in the subsequent sections. The .rst example is a program FORWARD, whose correctness argument \ndepends on the interplay between values of counter and data variables during the loop execution. The \nexample shows that path invariants identify relevant predicates that eliminate not only a given counterexample \npath p , but also all counterexample paths that can be obtained from p by unwinding loops. The second \nexample is a program INITCHECK, which manipu\u00adlates arrays. Its correctness proof requires loop invariants \nthat con\u00adtain universal quanti.ers, and the automatic discovery of such in\u00advariants has been posed as \na challenge in previous work on predi\u00adcate abstraction and discovery [29,37]. Path invariants identify \nrel\u00adFigure 1. Program FORWARD illustrates the discovery of relevant predicates that prevent loop unwinding: \n(a) program; (b) counterexample path; (c) CFG of the path program that is extracted from the counterexample \npath; and (d) potential new counterexample path resulting from loop unrolling when path invariants are \nnot tracked. In the path and CFG representation, we use [\u00b7]to denote assumptions that represent conditional \ncontrol statements of the program. As usual, updates are denoted by :=. Double circles denote locations \nat entry points of nested blocks of a program, i.e., entry points of loops. void forward(int n) { int \ni, n, a, b; A[n= 0] i:= 0 A[n= 0] A B A: assume( n >= 0 ); i=0; a=0;b=0; Ba:= 0 b:= 0 i:= 0 a:= 0 \nb:= 0 C[i<n] C B: while( i<n){ if( ... ) { [i<n] B a:= a+1 b:= b+2 C: a = a+1; b = b+2; C [i= n] \n Ei:= i+1 B E } else { a:= a+1 D: a = a+2; b:= b+2 F b = b+1; E C } E: i = i+1; i:= i+1 [a+ b =3n] \n} F: assert( a+b == 3*n ); E } B F E [i= n] [a+ b =3n] E B F E (a) (b) (c) (d) evant universally \nquanti.ed formulas together with predicates over the loop counter. The third example program, PARTITION, \naddresses the dif.\u00adculty of dealing with global invariants. Since path programs capture only some of \nthe computations of the original program, the corre\u00adsponding path invariants may be smaller, and represent \nonly parts of the set of reachable program states. The corresponding global invariants, which cover all \nreachable states, can be derived from a combination of several path invariants. Thus, path invariants \nallow us to implement a lazy construction of program invariants, which is guided by counterexamples. \n2.1 Example FORWARD: Capture Arbitrary Loop Unwinding Our .rst example is program FORWARD from Figure \n1(a), whose correctness argument depends on the interplay between values of counter and data variables \nduring the loop execution. The program executes a loop ntimes, and in each iteration, depending on some \n(unmodeled) condition, either increments the variable aby 1and b by 2, or increments aby 2and bby 1. \nAt the end of the loop, we want to assert the claim that the sum a+bmust be equal to 3n. Abstraction \nRe.nement. First, let us brie.y describe how current techniques attempt to prove the assertion, and thus \nset up a back\u00adground for demonstrating the advantages of using path invariants over existing methods. \nA standard counterexample-guided abstrac\u00adtion re.nement (CEGAR) algorithm implemented in a tool like \nBLAST attempts to prove the program FORWARD in the follow\u00ading way. The initial abstraction discards all \ndata relationships (that is, no predicates are tracked), and the reachability analysis (.rst phase of \nCEGAR) checks if there is a path in the control-.ow graph (CFG) that leads to an error location, where \nthe assertion is vio\u00adlated. There are such paths in the CFG, and Figure 1(b) shows one such counterexample \npath, which traverses the while-loop once, takes the then-branch in the body of the loop, and then violates \nthe assertion after leaving the loop. Notice that while this is a syntac\u00adtic path in the CFG, the counterexample \npath is spurious,thatis, it cannot be executed by the program. The second phase of CEGAR is to check \nif the produced coun\u00adterexample path is genuine or spurious, and if spurious, to proceed with abstraction \nre.nement, i.e., to .nd additional predicates that rule out the path. The counterexample path is translated \ninto a log\u00adical formula called the path formula, which is satis.able iff the counterexample path can \nbe executed in the program [33]. The path formula is the conjunction of constraints derived from the \nopera\u00adtions along the path when the path is written in static single assign\u00adment form, that is, where \neach assignment to a variable is given a fresh name. The path formula for the counterexample in Figure \n1(b) is the following conjunction, where each line corresponds to a tran\u00adsition between control locations: \nn0 = 0. i1 =0. a1 =0. b1 =0. fA . fB i1 <n0 . fB . fC a2 =a1 +1. b2 =b1 +2. fC . fE i2 =i1 +1. fE . fB \ni2 = n0 . fB . fF a2 +b2 =3n0 fF . fE The formula is unsatis.able, because there is no initial valuation \nof program variables that leads to a program execution along the counterexample path. In the third phase \nof CEGAR, predicates are extracted from the unsatis.able path formula, and added to the predicate abstraction. \nThis re.ned abstraction ensures that the new predicates are tracked during subsequent reachability analyses, \nand that therefore the cur\u00adrent counterexample path will not reoccur. One way to discover predicates \nis to extract all atomic predicates that appear in a proof of unsatis.ability of the path formula. (In \npractice, tools imple\u00adment a more complicated scheme based on interpolants [25, 37], but this does not \nchange our argument below.) For our counterex\u00adample path, a possible set of such predicates is {i =0,i \n=1,a =0,a =1,b =0,b =2}, which tracks the variables i, a,and b along the path. While this set of predicates \neliminates the given counterexample path, the next round of reachability analysis encounters a longer \ncounterexample path which is obtained by unwinding the loop one more time, namely, the path shown in \nFigure 1(d). This new counterexample path is eliminated by tracking in addition the predicates in the \nset {i =2,a =2,b =4}. In general, in the k-th re.nement round, we .nd the set of predi\u00adcates {i =k, a \n=k, b =2k}, and the method does not terminate. Path Invariants. Our new re.nement approach is based on \niden\u00adtifying path invariants. Path invariants are not inferred from path formulas, but from special path \nprograms, whose construction is guided by the statements that appear along a counterexample path. The \npath program for the counterexample path in Figure 1(b) is shown in Figure 1(c). We observe that the \npath program contains only control locations that are traversed by the counterexample path. Its statements \nare taken from the counterexample path, and its CFG captures the counterexample path as well as its unwind\u00adings. \nWe shall de.ne formally how path programs are constructed in Section 3. The counterexample path passes \ntwo times through the control location fB , which labels the loop entry. So the path program has a loop \nfB . fC . fE . fB in its CFG at location fB . To re.ne the analysis so that the family of counterexample \npaths represented by the path program are all refuted at once, we apply invariant-generation techniques. \nSince there are loops in the program, we can no longer construct a path formula that is linear in the \nlength of the counterexample. Instead, we look for invariant maps.A path-invariant map is a mapping from \nthe locations of a path program to formulas such that the following two conditions hold: (initiation) \nthe initial location of the path program is mapped to the formula true, and (inductiveness) for each \npair of locations f and f. with an edge (f, ., f')in the path program, the successor of the formula at \nf with respect to the program operation . implies the formula at f'. The path-invariant map is safe if \nthe error location (i.e., the location that violates the assertion that is to be proved) is mapped to \nthe formula false. Notice that an invariant map of a path program need not be an invariant map of the \noriginal program when the set of locations is extended, because it may violate the inductiveness requirement. \nIn our example we can generate invariants in arithmetic do\u00admains, e.g., by applying methods described \nin [9, 43], and obtain the following path-invariant map: ..fA = true ..fB =3i =a +b . a +b = 3n ..fC \n=3i =a +b . a +b = 3n ..fE =3i +3=a +b . a +b - 3= 3n ..fF = a +b =3n ..fE = false The map is safe as \nfE is mapped to false. A subsequent reachability analysis that tracks the truth of these formulas at \nthe corresponding locations is guaranteed to eliminate the original counterexample. Furthermore, any \nspurious counterexample path that is obtained by traversing the path program is eliminated by tracking \nthese for\u00admulas. For example, consider a potential unwinding of the original counterexample path, which \ntraverses the loop twice, as shown in Figure 1(d). When following this path and reaching the control \nlo\u00adcation fB for the .rst time, a program analysis tracking the formulas from the path-invariant map \ncomputes an overapproximation of the reachable states at fB that is at least as strong as the formula \nde.ned by the map at fB . Since the path-invariant map is inductive and safe, we conclude that the overapproximation \ncomputed for the second visit to the location fB is again as strong as the formula assigned to fB . This \nmeans that the path shown in Figure 1(d) cannot appear as a spurious counterexample. We can use similar \nreasoning to show that any unwinding of the original counterexample within the CFG of the path program \nwill not produce a new (spurious) counterexample. This means that any path whose sequence of visited \ncontrol locations is in the language de.ned by the regular expression fA fB (fC fE fB ) * fF fE can never \nbe reported as a spurious counterexample, once the formulas from the path-invariant map determine the \nabstraction. The formal justi.\u00adcation of this statement, which characterizes the relevance of the formulas \nobtained from path invariants, relies on the completeness of abstract interpretation [10].  2.2 Example \nINITCHECK: Universally Quanti.ed Predicates The previous example showed how path programs can be used \nto refute a family of counterexample paths arising from unrolling a loop. The next example shows how \nthe same technique may be used to infer quanti.ed invariants about the program state. Rea\u00adsoning about \nmany programs that manipulate unbounded data, e.g., data stored in container data structures like arrays, \nrequires univer\u00adsally quanti.ed formulas. Usually, these formulas contain univer\u00adsal quanti.cation over \nindices, positions, or keys, which provide reference to data values stored in the data structure. There \nexist a fundamental obstacle that prevents the systematic discovery of universally quanti.ed invariants \nbased on (.nite) counterexample paths. Namely, such paths can expose only a bounded number of data items \nthat are stored in the data structure. Thus, it is dif.cult to derive and formally justify universal \nquanti.cation over discovered predicates. However, from path programs we can infer quanti.ed invariants \nby simultaneously considering all unrollings of a loop. The next example demonstrates how an invariant-synthesis \nalgo\u00adrithm for inferring quanti.ed invariants [3] can be applied to path programs. Consider the program \nINITCHECK from Figure 2(a),which initializes an array to 0, and then checks that all elements in the \narray are 0. We wish to prove that all assertions hold. Abstraction Re.nement. The path shown in Figure \n2(b) repre\u00adsents a spurious counterexample that would be found by a veri\u00ad.cation tool that does not track \nthe array contents precisely. The path contains a statement that corresponds to the assertion viola\u00adtion, \nwhich appears after traversing each loop once. From the .rst part of the counterexample path (traversal \nof the .rst loop) we can conclude that the .rst element in the array is initialized to 0, and discover \nthe predicate a[0] = 0. Then, by considering this fact in the second part in the counterexample path, \nwhere the equality a[i]=0is checked for i =0, we conclude that the predicate a[0]=0is suf.cient to eliminate \nthe given counterexample. However, tracking the predicate a[0] = 0eliminates only this particular counterexample \npath. It does not eliminate the longer counterexample path which traverses each loop twice; this would \nrequire tracking the predicate a[1] = 0. In fact, counterexample\u00adbased predicate-abstraction re.nement \nis likely to generate an in\u00ad.nite family of predicates a[i]=0, one for each i = 0.Since the number of \narray elements being initialized and subsequently checked by INITCHECK is determined by the variable \nn, and hence is arbitrary, no .nite number of predicates obtained from .nite counterexample paths created \nby loop unwinding will suf.ce to prove the program correct. We need the universally quanti.ed for\u00admula \n.k :0= k<n . a[k]=0to verify INITCHECK. void init_check(int *a, int n) { int i; A B i:=0 A A: [i<n] \nB: for( i = 0;i<n;i++ ){ i:=0 C: a[i] = 0; C [i<n] D: } for( i = 0;i<n;i++ ){ [i= n] a[i]:=0 i:=i+1 B \nC E: assert( a[i] == 0 ); } D B i:=0 [i= n] i:=0 a[i]:=0 i:=i+1 } [i<n] [i<n] D E E [a[i]=0] i:=i+1 [a[i]=0] \ni:=i+1 [a[i]=0] D E [i<n] [a[i]=0] E E (a) (b) (c) Figure 2. Program INITCHECK illustrates the discovery \nof universally quanti.ed invariants for the challenge example from [29, 37]: (a) program; (b) counterexample \npath; (c) CFG of the path program that is extracted from the counterexample path. Path Invariants. Justi.cation \nof the universal quanti.cation re\u00adquires consideration of all possible paths that traverse the initial\u00adization \nand checking loops located at fB and fD , respectively. We use a path program to represent this family \nof paths. The path pro\u00adgram extracted from the original counterexample path is shown in Figure 2(c). \nUsing this path program, we can provide a systematic justi.cation of universal quanti.cation by deriving \npath invariants. The technical complication is that we have to infer invariant maps that map certain \nlocations to universally quanti.ed formulas. An inductive invariant map, say ., for our path program \nneeds to assert that at location fE the contents of a[i]is 0. Note that the transition to the error location \nfE , which is taken from fE if a[i]=0 holds, appears within a loop that iteratively increments the value \nof i. Hence, the formula assigned by . to the location fE must imply a[i]=0for all values of i that are \nreachable from fE ,thatis, all values of i in the interval from 0to n - 1. We observe that the .rst loop \nassigns 0toanarraycell a[i]for each value of i that is subsequently checked in the second loop. We compute \nthe path-invariant map . that formalizes the above reasons for the non-reachability of the error location \nin the path program. (See [3] for a discussion of algorithms for computing invariants that contain universal \nquanti.cation.) The formulas in . restrict the value of the counter variable i and contain universally \nquanti.ed statements about the contents of the initialized cells of the array a. The formulas for the \nlocations in the .rst loop refer only to the array contents up to the position i, whereas the formulas \nfor the second loop refer to each array element between 0and n-1: ..fA = true ..fB = .k :0= k<i . a[k]=0 \n..fC = .k :0= k<i . a[k]=0 ..fD = .k :0= k<n . a[k]=0 ..fE = .k :i = k<n . a[k]=0 ..fE = false. By tracking \nthe four formulas in the range of the path-invariant map, we are guaranteed that all potential counterexample \npaths that visit a sequence of control locations from the set de.ned by the regular expression fA fB \n(fC fB ) * fD (fE fD ) * fE fE are eliminated.  2.3 Example PARTITION: Incremental Construction Path \ninvariants identify local reasons that refute a family of coun\u00adterexample paths. To prove an assertion \nin the program, though, an analysis may have to iterate through several different path pro\u00adgrams, each \nof which presents a different family of paths to a viola\u00adtion of the assertion. We now illustrate how \npath invariants can be used within a CEGAR framework to incrementally construct global invariant maps, \nusing path programs derived from different coun\u00adterexample paths to learn additional information. Consider \nthe program PARTITION in Figure 3, which partitions the elements of an input array a into two arrays \nge and lt,which contain, respectively, the elements of a greater or equal to 0, and less than 0. In order \nto prove the assertions, we need a loop invariant at location B which is the conjunction of .k :0= k< \ngelen . ge[k]= 0 (1) .k :0= k< ltlen . lt[k]< 0 (2) Instead of applying invariant generation on the entire \nprogram at once, CEGAR with path invariants will .nd the two conjuncts of the loop invariant at B one \nat a time. For example, consider .rst a spurious counterexample path that traverses the then-branch of \nthe conditional in the for-loop. The corresponding path program looks almost identical the path program \nfor example INITCHECK from Figure 2(c), except that instead of a direct write to ge[i], the coun\u00adterexample \npath contains the operations assume( a[i]>=0 ) and ge[i] = a[i]. Performing invariant synthesis on this \npath pro\u00adgram leads to a path-invariant map similar to the one for Exam\u00adple INITCHECK. In particular, \nat the location B, we obtain the in\u00advariant from Equation (1). These invariants, however, are not enough \nto prove the asser\u00adtions, and a second counterexample path is found. This path tra\u00adverses the else-branch \nof the conditional in the for-loop. Again, the path program is similar to the path program from Exam\u00adple \nINITCHECK. This time, the path-invariant map generates the second conjunct of the loop invariant, i.e., \nEquation (2). Together, the conjuncts suf.ce to prove the assertions. Thus, the CEGAR al\u00adgorithm breaks \nthe search for global program invariants (as per\u00adformed by invariant synthesis techniques) into several \nsearches for individual components of the invariant, thus restricting the searches to smaller spaces. \nvoid partition(int *a, int n) { int i, gelen, ltlen; int ge[n], lt[n]; A: gelen = 0; ltlen = 0; B: for(i=0;i<n;i++ \n){ if( a[i] >= 0 ) { C: ge[gelen] = a[i]; gelen++; } else { D: lt[ltlen] = a[i]; ltlen++; } } E: for(i=0; \ni<gelen;i++){ F: assert( ge[i] >= 0 ); } G: for(i=0; i<ltlen;i++){ H: assert( lt[i] < 0 ); } } Figure \n3. Program PARTITION illustrates how reasoning over sev\u00aderal path programs can be combined.  3. Path \nPrograms and Invariants Programs. We assume an abstract representation of programs by transition systems \n[35]. A program P =(X,L,f0,T,fE )consists of a set X of variables, a set L of control locations, an initial \nlocation f0 .L,aset Tof transitions, and an error location fE .L. Each transition t .Tis a tuple (f,.,f'),where \nf,f' .L are control locations, and . is a constraint over free variables from X .X'. The variables from \nX denote values at control location f, and the variables from X' denote the values of the variables from \nX at control location f'. We assume that the error location fE does not have any outgoing transitions. \nThe sets of locations and transitions naturally de.ne a directed graph, called the control-.ow graph \n(CFG) of the program. (Note that we put the transition constraints at the edges of the graph.) A state \nof the program P is a valuation of the variables from X. The set of all states is denoted val.X. We shall \nrepresent sets of states using constraints. For a constraint .over X .X' and a val\u00aduation (s,s').val.X \n\u00d7val.X', we write (s,s')|=.if the valu\u00adation satis.es the constraint ..A computation of the program P \nis a sequence (f0,s0),(f1,s1),...,(fk,sk). (L \u00d7val.X) * , where f0 is the initial location and for each \ni .{0,...,k-1}, there is a transition (fi,.,fi+1) .T such that (si,si+1)|=.. A state s is reachable at \nlocation f if (f,s)appears in some computation. The program is safe if the error location fE ap\u00adpears \nin no computation. A path of the program P is a sequence p =(f0,.0,f1),(f1,.1,f2),...,(fk-1,.k-1,fk)of \ntransitions, where f0 is the initial location. The path p is feasible if there is a computation (f0,s0),...,(fk,sk)such \nthat for each i . {0,...,k -1},wehave (si,si+1) |= .i. If the path p ends at the error location, i.e., \nlk = fE , then we call p an error path (or counterexample path). Feasible counterexample paths are referred \nto as genuine; infeasible ones, as spurious. Invariants. An invariant of P at a location f .L is a set \nof states containing the states reachable at f.An invariant map is a function .from L to formulas over \nprogram variables from X such that the following conditions hold: Initiation: For the initial location \nf0,wehave ..f0 =true. Inductiveness: For each f,f' .L such that (f,.,f').T, the formula ..f ..implies \n(..f')'. Here, (..f')' is the formula obtained by substituting variables from X' for the variables from \nX in ..f'. Safety: Forthe errorlocation fE ,wehave ..fE =false. The invariant-synthesis problem is to \nconstruct an invariant map for a given program. For ease of exposition, we assume that an invariant map \nassigns an invariant to each program location. For ef.ciency, one can require invariants to be de.ned \nonly over a program cutset, i.e., a set of program locations such that every syntactic cycle in the CFG \npasses through some location in the cutset. Path Programs. We consider a program P =(X,L,f0,T,fE )to\u00adgether \nwith an error path p =(f0,.0,f1),...,(fk-1,.k-1,fE ). Given P and p, we construct the path program Pp \n= (Xp ,Lp,fp 0 ,TpE )such that ,fp the set of variables remains the same: Xp =X;  the program locations \nare exactly those that are visited by the path: Lp ={f1,...,fk-1,fE };  the initial and error locations \nremain the same: fp 0 = f0 and fp  E =fE ; the set of transitions is restricted to the transitions that \nare taken along the path: Tp ={(f0,.0,f1),...,(fk-1,.k-1,fE )}. Intuitively, the paths of the path program \nPp include the error path p, and in addition all paths that result from p by unrolling it following the \ncontrol-.ow graph of P. Hence the path program Pp may traverse some loops that are traversed by pmore \noften, but it contains no transitions that do not occur in p. An invariant map .p for a path program \nPp is called a path\u00adinvariant map. Computation of Path Invariants. There are several methods to generate \npath invariants for a path program, e.g., via abstract inter\u00adpretation with specialized domains (cf. \n[4, 15, 21, 32, 38, 39]), and via reduction to constraint solving (cf. [3, 5, 9, 12, 30, 41, 42, 43]). \nIn our implementation of path invariants, we have used template\u00adbased invariant generation [5, 9]. By \nexploiting recent advances in reasoning about the hierarchical combination of theories [6,31,44], our \nalgorithm [3] is able to generate invariants over the combined theory of arithmetic and uninterpreted \nfunction symbols with uni\u00adversal quanti.cation. This combined theory is known to be ex\u00adpressive enough \nfor a wide variety of software veri.cation prob\u00adlems [2,18,19,24,26], including reasoning about arrays \n[6]. In template-based invariant synthesis, we assume that for each control location in the domain of \nthe map .,wehaveaso-called invariant template, which is a parametric constraint over program variables. \nAn example for a simple template constraint over the program variables iand nis pi \u00b7i+pn \u00b7n=p, where \npi, pn,and p are unknown parameters whose values need to be determined. This template denotes a set of \nformulas that can be obtained by giving values to the parameters, e.g., 2i-3n =5. The crux of the template-based \napproach consists in de.ning and solving a system of constraints over the template s parameters such \nthat the resulting values yield an inductive invariant map. The constraints over the parameters of the \ntemplate encode the initiation, inductiveness, and safety conditions of invariant maps. For example, \nfor each transition (f,.,f')of a program, we gen\u00aderate the constraint that states that the invariant \ntemplate at f con\u00adjoined with the transition relation . implies the invariant template at f'. This constrains \nthe values of the parameters of the templates at fand f' to values that ensure the inductiveness of the \ngenerated invariants. In addition, we add constraints that the template at the initial location f0 is \ntrue, and the template at the error location fE implies false. A solution to the constraints then provides \nvalues for the template parameters. For the combined theory of linear arith\u00admetic and uninterpreted function \nsymbols, all constraints fall into a class that can be solved using the constraint solving techniques \ndescribed in [9]. In our implementation, we use the algorithm from our previous work [3] to infer universally \nquanti.ed invariants for array pro\u00adgrams, in addition to linear arithmetic and uninterpreted function \nsymbols. We construct a suitable template by analyzing a given path program. If the program contains \nan assertion that is itera\u00adtively checked within a loop, then we add a universally quanti.ed implication \nto the template. The right-hand-side of the implication contains a generalization of the assertion. The \nposition at which the assertion reads from the array becomes a fresh, universally quan\u00adti.ed variable. \nFor the left-hand-side of the implication we choose a conjunction of linear inequalities over the program \nvariables and the fresh variable. For example, given the program INITCHECK and the path program from \nFigure 2(c), we construct the templates . and . for the locations fB and fD , respectively, as . =(.k \n:p 1(i, n)=k =p 2(i, n).a[k]=p 3(i, n)), . =(.k :q 1(i, n)=k =q 2(i, n).a[k]=q 3(i, n)), where rrrr p \n(i, n)= pi \u00b7i +pn \u00b7n +p for each r .{1,..., 3}, rrrr q (i, n)= qi \u00b7i +qn \u00b7n +q for each r .{1,..., 3}. \nOur implementation of the quanti.ed invariant generator .nds an instantiation of the parameters that \nyields the path-invariant map shown in Section 2.2. 4. CEGAR with Path Invariants We apply path invariants \nin a predicate abstraction-based CEGAR loop, where path invariants are used to suggest formulas to re.ne \nthe predicate abstraction. However, our technique to consider path programs (instead of paths) as counterexamples \ncan be used in any CEGAR-based program analysis. A predicate abstraction .is a function that maps each \ncontrol location to a set of formulas over the program variables, namely, those formulas whose truth \nvalues are tracked by the program anal\u00adysis. Conceptually, the CEGAR algorithm has three phases [2, 8]: \nabstract reachability, counterexample analysis, and abstraction re\u00ad.nement. The abstract-reachability \nphase tries to construct a safety proof for the program by unwinding the CFG into a labeled tree, where \neach node of the unwinding is annotated with an abstract state. The abstract state at a node with location \nf is a boolean combination of the formulas in ..f, which represents an overap\u00adproximation of the set \nof reachable states of the program when it executes the path from the root of the tree to the current \nnode. The root is labeled with the abstract state true. If an abstract state at a node v implies the \nabstract state at another node with the same location, then the unwinding stops at the node v. This unwinding \nprocess produces an abstract reachability tree (ART); see [26] for a formal de.nition. If the abstract \nreachability tree does not contain the error loca\u00adtion, then a safety proof is found, and the algorithm \nterminates. Otherwise, the algorithm moves to the counterexample-analysis phase. In this phase, a counterexample \npath (i.e., a path from the root to the error location) is chosen from the ART, and the algo\u00adrithm checks \nif this counterexample is genuine (i.e., if the error path is feasible). For implementing this check, \na logical formula is constructed from the counterexample path which is satis.able iff the path is feasible. \nIf the formula is satis.able, then a bug is found and the algorithm stops. Otherwise, the algorithm proceeds \nwith the abstraction-re.nement phase. Now, instead of discover\u00ad void disj() { int x, y; A A: x=0;y=50; \nB: while(x<100){ ta if(x<50){ C: x=x+1; tb tc } else { B D: x=x+1; y = y+1; td te } } E: assert( y >= \n100 ); E F: assert( y <= 100 ); } Figure 4. Program DISJ, which requires reasoning with disjunc\u00adtive \ninvariants (cf. [23]), and its CFG. We omit intermediate (non\u00adcutpoint) locations. The transition ta \ninitializes the variables before entering the loop. The transitions tb and tc traverse the loop by tak\u00ading \nthe positive and negative branch, respectively. The transitions td and te exit the loop and violate the \n.rst and second assertion, respectively. ing new predicates for the predicate abstraction from the spuri\u00adous \ncounterexample path, using for example interpolation-based approaches [17, 25, 37], we construct the \npath program P p from the counterexample path p. Then we use an invariant-synthesis al\u00adgorithm to produce \na path-invariant map .p for P p [3]. This in\u00advariant map is used to re.ne the predicate abstraction: \nwe add all atomic predicates that appear in ..f to the predicate abstraction ..f at each location f, \nin this process treating universally quanti.ed formulas as atomic predicates. Note that if some unwinding \nof the error path p is feasible, then no invariant map .p can be found. After abstraction re.nement, \nthe algorithm proceeds with an\u00adother abstract-reachability phase, this time tracking more predi\u00adcates \n(including universally quanti.ed formulas). The three phases are repeated until either a proof or a bug \nis found (or, since the problem is undecidable, the loop does not terminate). The key property of the \nre.nement step using path invariants is that formulas that appear in path-invariant maps rule out all \ncoun\u00adterexample paths that arise from arbitrary unwindings of loops in the path program. This is in contrast \nto the existing implementa\u00adtions of CEGAR, where each re.nement step only guarantees to remove a single \ncounterexample path, and hence, may get stuck in removing in.nitely many counterexample paths that result \nfrom unrolling a loop. In the following theorem, let Reach..denote the set of all rooted paths in the \nabstract reachability tree that is con\u00adstructed for a predicate abstraction .. THEOREM 1 (Re.nement Progress). \nConsider an error path p of the program P , and an invariant map .p for the corresponding path program \nP p. For every predicate abstraction .such that for each f . Lp we have .p.f . ..f,the set Reach..of \npaths in the abstract reachability tree does not contain any paths that are constructed only from transitions \nin P p . 5. Disjunctive Reasoning with Path Invariants In this section, we show that path invariants \ncan facilitate disjunc\u00adtive reasoning when dealing with program invariants. We illus\u00adtrate the need for \ndisjunctive reasoning using the example program DISJ from Figure 4. When attempting to verify this program, \nour invariant-generation algorithm fails to compute an invariant map for the path program extracted from \na counterexample path that traverses both branches of the loop and violates the second asser\u00ad A: while(...) \n{ tc ... if(...) { ... ta B: break; AD } else { tb C: ... D: while(...) { td te ... } E: ... } F: ... \n} G: ... Figure 5. Control-.ow graph that contains two nested blocks (we omit intermediate, non-cutpoint \nlocations). The inner block corre\u00adsponds to the while-loop at location fD . Its entry/exit point is the \nlocation fD . The outer block corresponds to the while-loop at lo\u00adcation fA . Its entry point is the \nlocation fA , and its exit points are fA and fB . tion. Any attempts to increase the number of conjuncts \nin the tem\u00adplate fail. This is because proving the validity of the assertions re\u00adquires an invariant \nmap . that assigns a disjunctive linear invariant (x = 50 . y = 50) .(50 <x = 100 . x = y) to loca\u00adtion \nfB . Such a disjunctive invariant is not captured by the conjunc\u00adtive templates used in [3]. We propose \ndisjunctive path programs, an extension of path programs, to support disjunctive reasoning. Disjunctive \nPath Programs. We assume that control-.ow graphs are structured into blocks. Each block is a strongly \nconnected com\u00adponent of the CFG. Each block is induced by a control-.ow state\u00adment that allows code to \nbe executed repeatedly; examples of such statements include while-loop and for-loop statements. We ex\u00adclude \ngoto-statements from consideration to simplify the expo\u00adsition. Thus, each block B has a single entry \nlocation, denoted by Entry.B, which is also an exit location. The block B con\u00adtains all nodes and edges \nof the CFG that are strongly connected to Entry.B. A block may have additional exit locations, which \ncorrespond to break-statements. Nested loop statements induce nested blocks, i.e., strongly connected \ncomponents that are not maximal. We illustrate blocks, nesting, and entry/exit locations in Figure 5. \nThe control-.ow graph shows transition ta, which con\u00adnects the locations fA and fD by following the negative \nbranch of the if-statement and traversing the non-cutpoint location fC . The body of the inner loop corresponds \nto tc, which is a self-loop at the loca\u00adtion fD . The transition tb connects the inner loop with fA . \nThe tran\u00adsition td exits the outer while-loop by violating its condition. The transition te exits the \nouter loop by taking the break-statement. Before giving a formal de.nition of disjunctive path programs \n(DPPs), we informally describe how they differ from (plain) path programs, as introduced in Section 3. \nIn DPPs, each control loca\u00adtion visited by a path appears several times, indexed by its position in the \npath. Thus, the invariant map for DPPs can assign different formulas to the same location at different \npositions. Furthermore, DPPs contain copies of transitions that are repeatedly reachable from a given \nlocation (i.e., lie within a common block) at each po\u00adsition of the location. See Figures 6 and 7 for \nexamples of DPPs that are constructed according to the de.nition below. We consider a program P =(X,L,f0,T,fE \n) together with an error path p =(f0,.0,f1),...,(fk-1,.k-1,fE ).Wewrite L.p for the set {f0,...,fk-1,fE \n} of locations visited by the path p, and T.p for the set {(f0,.0,f1),...,(fk-1,.k-1,fE )}of transi\u00adtions \nin p.Let Blocks.p be the set of blocks of the control-.ow graph of the program P which contain the set \nof locations L.p. Given P and p, we construct the disjunctive path program P.p = .p .p (X.p ,L.p,f0 ,T.p,fE \n) such that the set of variables remains the same: X.p = X;  the program locations contain two copies \nfor each location to model loop unwindings, and are paired with labels for the positions in the path: \nL.p = {f,f |f.L.p}\u00d7{0,...,k};  the initial location is the .rst location in the path p, labeled with \n0,thatis, f0 .p =(f0,0);  for each position i . [0..k -1] of the path p, the disjunctive path program \ncontains the transition ((fi,i),.i,(fi+1,i+1)); moreover, if p.i is a back-edge in the CFG, i.e., if \nthere is a block B . Blocks.p such that fi . B and fi+1 = Entry.B, then the DPP contains also the following \ntransitions:  ((fi+1,i+1),.X'=X ,(f i+1,i+1)), ((f j ,i+1),.j ,(f j+1,i+1)) for each (fj ,.j ,fj+1) \n.T.p such that j =iand both fj and fj+1 are in B, ((f i+1,i+1),.X'=X ,(fi+1,i+1)), where .X'=X denotes \nthe constraint that preserves the valua\u00ad tion of all variables, i.e., .X'=X = x.X x = x; the error location \nis fE.p =(fE ,k). Intuitively, the paths of the disjunctive path program P.p include the error path p, \nand in addition all paths that result from p by staying within some nested blocks of p for some additional \nun\u00adwindings of loops. Hence, the path program P.p may iterate some loops that are traversed by p more \noften, but it contains no transi\u00adtion that does not occur in p. Consider, e.g., an error path p of the \nprogram from Figure 5 that .rst traverses the while-loop without going into the inner while-loop, then \ntraverses the inner while\u00adloop once, and .nally leaves the outer while-loop by executing the break-statement \n(we write fE for fG ): fA .fC .fD .fE .fF . fA .fC .fD .fD .fE .fF . fA .fB .fE This counterexample path \nand the corresponding disjunctive path program are shown in Figure 6. The nested blocks of this path \nare B1 = {fA ,...,fF }and B2 = {fD }, with B2 being nested in B1. The complete set of transitions of \nthe DPP P.p is (( A ,0),.a,( D ,1)), (( D ,1),.b,( A ,2)), (( A ,2),.X'=X ,( A ,2)), (( A ,2),.a,( D \n,2)), (( D ,2),.b,( A ,2)), (( A ,2),.X'=X ,( A ,2)), (( A ,2),.a,( D ,3)), (( D ,3),.c,( D ,4)), (( \nD ,4),.X'=X ,( D ,4)), (( D ,4),.c,( D ,4)), (( D ,4),.X'=X ,( D ,4)), (( D ,4),.b,( A ,5)), (( A ,5),.X'=X \n,( A ,5)), (( A ,5),.a,( D ,5)), (( D ,5),.c,( D ,5)), (( D ,5),.b,( A ,5)), (( A ,5),.X'=X ,( A ,5)), \n (( A ,5),.e,( E ,6)). A ta D tb A ta D tc D tb A te E (a) A , 0 ta D , 1  tb tX ' =X ta A , 2 \n A , 2 D , 2 tX ' =X tbta tc D , 3 tc tX ' =X D , 4 tc D , 4 tX ' =Xtb tX ' =X ta A , 5 A , 5 D , 5 \ntX ' =X tbte E , 6 (b) Figure 6. Counterexample and CFG of the corresponding DPP. tb tb tc Figure 7. \nDisjunctive path program for the example from Figure 4 and a path that traverses the locations fA ,fB \n,fC ,fB ,fD ,fB ,fE ,fF ,fE . By viewing P.p instead of p as a counterexample, we can simul\u00adtaneously \nhandle an unbounded number of error paths (similarly to a path program for p), namely, all error paths \nthat extend p by loop unwindings of the blocks B1 and B2 for an arbitrary number of iterations. In contrast \nto a path program for p (whose control\u00ad.ow graph is almost identical to the one shown in Figure 5 with \nan exception that the transition td is removed), the DPP P.p con\u00adtains several copies of the locations \nfA and fD , as well as additional loops at these locations. They induce a .ner partition of the set of \nreachable states of P.p, which is re.ected by a disjunctive path invariant. Disjunctive Path Invariants. \nAn invariant map ..p for a disjunc\u00adtive path program P.p may contain several formulas for a control location \nf. L of the program P.Let Le and L e be the set of P.p\u00adlocations that correspond to a P-location fat \ndifferent positions in the control-.ow graph and their additional copies: Le = {(f,i1),...,(f,im)}, and \nL e = f,j1),...,( n)}. {( f,j We can use the disjunction of formulas in the map ..p over all copies of \nf,which is ( ..p(f,i) . ..pf,j), (e,i).L\u00a3 ( L\u00a3e,j). to re.ne the abstraction at location fas proposed \nin Section 4. Locations traversed by the path Time FORWARD fA ,fB ,fC ,fE ,fB ,fF ,fE 0.05 s fA ,fB ,fD \n,fE ,fB ,fF ,fE 0.12 s INITCHECK fA ,fB ,fC ,fB ,fD ,fE ,fD ,fE ,fE 0.27 s PARTITION fA ,fB ,fC ,fB ,fE \n,fF ,fE ,fF ,fE 1.2 s fA ,fB ,fD ,fB ,fE ,fG ,fH ,fG ,fH ,fE 2.4 s DISJ fA ,fB ,fC ,fB ,fD ,fB ,fE ,fE \n0.43 s fA ,fB ,fC ,fB ,fD ,fB ,fE ,fF ,fE 2.8 s Table 1. Experiments with computing path invariants. \nTime gives the time taken by the invariant generator (on a 1.7 GHz laptop running SICSTUS Prolog). We \ncomputed a disjunctive path invari\u00adant for the last error path. For example, we recall the program DISJ \nfrom Fig\u00adure4.Given theerrorpath p that traverses the locations fA ,fB ,fC ,fB ,fD ,fB ,fE ,fF ,fE , \nwe obtain the DPP P.p shown in Figure 7. We compute an invariant map ..p such that ..p(fB ,1) = x =0 \n. y =50 ..p(fB ,3) = y = 50 . 0 = 1 ..p(fB ,5) = x = 100 . y = x together with initiation and safety \nconditions ..p(fA ,0) = true and ..p(fE ,7) = false. This map instantiates an invariant tem\u00adplate that \nassigns two conjuncts to each location. Any attempt to instantiate a simpler template with a single conjunct \nper location failed. (Although, it would suf.ce to have a single conjunct at the location (fB ,3), namely, \ny = 50.) Thus, for the location fB of P we obtain the disjunctive assertion (x =0 . y =50) . (y = 50) \n. (x= 100 . y = x), which we use to compute a predicate abstraction of the program P that is precise \nenough to rule out all spurious counterexamples that violate the second assertion. 6. Conclusion We \nproposed a new approach to counterexample-guided abstrac\u00adtion re.nement, which does not consider .nite \nprogram paths, but path programs as counterexamples. Path programs are full-.edged programs, performing \npossibly unbounded (looping) computations. However, path programs are usually small fragments of the \norigi\u00adnal program, thus permitting more ef.cient analyses. We automati\u00adcally generate invariants for \npath programs, which deliver property\u00addependent information used to re.ne the analysis of the original \nprogram. The path invariants eliminate all infeasible error paths that remain within the control-.ow \nstructure of the path program, i.e., which result from an arbitrary unwinding of the loops within the \npath program. Furthermore, by considering unbounded com\u00adputations of path programs, unlike previous predicate \nabstraction\u00adbased CEGAR methods, we can infer universally quanti.ed predi\u00adcates. This is necessary for \nreasoning about unbounded data struc\u00adtures such as arrays. We have applied our algorithm, as outlined \nin Section 4, to small examples involving arithmetic and array reasoning, including the examples from \nSections 2 and 5. The initial experiments with our prototype implementation are promising; see Table \n1. We show the computation times for the synthesis of the most interesting path invariants (i.e., those \nwith loops). We used the obtained predicates in the CEGAR loop, which on the listed examples required \nonly a few re.nement steps for each program. We note that none of these examples could be proved by BLAST \n[26], which analyzes longer and longer counterexample paths without terminating. Acknowledgments. The \n.rst author is supported in part by the grant SFU/PRG, 06-3. The second author is supported in part by \nthe Swiss National Science Foundation. The third author is sponsored in part by the NSF grants CCF-0427202 \nand CCF-0546170. The fourth author is supported in part by Microsoft Research through the European Fellowship \nProgramme.  References [1] T. Ball, A. Podelski, and S. K. Rajamani. Relative completeness of abstraction \nre.nement for software model checking. In Proc. TACAS, LNCS 2280, pp. 158 172. Springer, 2002. [2] T. \nBall and S. K. Rajamani. The SLAM project: Debugging system software via static analysis. In Proc. POPL, \npp. 1 3. ACM, 2002. [3] D. Beyer, T. A. Henzinger, R. Majumdar, and A. Rybalchenko. Invariant synthesis \nfor combined theories. In Proc. VMCAI, LNCS 4349, pp. 378 394. Springer, 2007. [4] B. Blanchet, P. Cousot, \nR. Cousot, J. Feret, L. Mauborgne, A. Mine,\u00b4 D. Monniaux, and X. Rival. A static analyzer for large safety-critical \nsoftware. In Proc. PLDI, pp. 196 207. ACM, 2003. [5] A. R. Bradley, Z. Manna, and H. B. Sipma. Linear \nranking with reachability. In Proc. CAV, LNCS 3576, pp. 491 504. Springer, 2005. [6] A. R. Bradley, Z. \nManna, and H. B. Sipma. What s decidable about arrays? In Proc. VMCAI, LNCS 3855, pp. 427 442. Springer, \n2006. [7] S. Chaki, E. M. Clarke, A. Groce, S. Jha, and H. Veith. Modular veri.cation of software components \nin C. IEEE Trans. Software Eng., 30:388 402, 2004. [8] E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and \nH. Veith. Counterexample-guided abstraction re.nement. In Proc. CAV, LNCS 1855, pp. 154 169. Springer, \n2000. [9] M. Col\u00b4on, S. Sankaranarayanan, and H. B. Sipma. Linear invariant generation using non-linear \nconstraint solving. In Proc. CAV, LNCS 2725, pp. 420 432. Springer, 2003. [10] P. Cousot. Partial completeness \nof abstract .xpoint checking. In Proc. SARA, LNCS 1864, pp. 1 15. Springer, 2000. [11] P. Cousot. Veri.cation \nby abstract interpretation. In Veri.cation: Theory and Practice, LNCS 2772, pp. 243 268. Springer, 2003. \n[12] P. Cousot. Proving program invariance and termination by parametric abstraction, Lagrangian relaxation \nand semide.nite programming. In Proc. VMCAI, LNCS 3385, pp. 1 24. Springer, 2005. [13] P. Cousot and \nR. Cousot. Abstract interpretation: a uni.ed lattice model for the static analysis of programs by construction \nor approximation of .xpoints. In Proc. POPL, pp. 238 252. ACM, 1977. [14] P. Cousot and R. Cousot. Comparing \nthe Galois connection and widening/narrowing approaches to abstract interpretation. In Proc. PLILP, LNCS \n631, pp. 269 295. Springer, 1992. [15] P. Cousot and N. Halbwachs. Automatic discovery of linear restraints \namong variables of a program. In Proc. POPL, pp. 84 96, 1978. [16] S. Das, D. L. Dill, and S. Park. Experience \nwith predicate abstraction. In Proc. CAV, LNCS 1633, pp. 160 171. Springer, 1999. [17] J. Esparza, S. \nKiefer, and S. Schwoon. Abstraction re.nement with Craig interpolation and symbolic pushdown systems. \nIn Proc. TACAS, LNCS 3920, pp. 489 503. Springer, 2006. [18] C. Flanagan, K. R. M. Leino, M. Lillibridge, \nG. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In Proc. PLDI, pp. 234 245. ACM, \n2002. [19] C. Flanagan and S. Qadeer. Predicate abstraction for software veri.cation. In Proc. POPL, \npp. 191 202. ACM, 2002. [20] R. W. Floyd. Assigning meanings to programs. In Mathematical Aspects of \nComputer Science, pp. 19 32. AMS, 1967. [21] D. Gopan, T. W. Reps, and M. Sagiv. A framework for numeric \nanalysis of array operations. In Proc. POPL, pp. 338 350. ACM, 2005. [22] S. Graf and H. Sa\u00a8idi. Construction \nof abstract state graphs with PVS. In Proc. CAV, LNCS 1254, pp. 72 83. Springer, 1997. [23] S. Gulwani \nand N. Jojic. Program veri.cation as probabilistic inference. In Proc. POPL, pp. 277 289. ACM, 2007. \n[24] S. Gulwani and A. Tiwari. Combining abstract interpreters. In Proc. PLDI, pp. 376 386. ACM, 2006. \n[25] T. A. Henzinger, R. Jhala, R. Majumdar, and K. L. McMillan. Abstractions from proofs. In Proc. POPL, \npp. 232 244. ACM, 2004. [26] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy abstraction. \nIn Proc. POPL, pp. 58 70. ACM, 2002. [27] C. A. R. Hoare. An axiomatic basis for computer programming. \nCommun. ACM, 12:576 580, 1969. [28] F. Ivancic, Z. Yang, M. K. Ganai, A. Gupta, I. Shlyakhter, and P. \nAshar. F-SOFT: Software veri.cation platform. In Proc. CAV, LNCS 3576, pp. 301 306. Springer, 2005. [29] \nR. Jhala and K. L. McMillan. A practical and complete approach to predicate re.nement. In Proc. TACAS, \nLNCS 3920, pp. 459 473. Springer, 2006. [30] D. Kapur. Automatically generating loop invariants using \nquanti.er elimination. Technical Report 05431 (Deduction and Applications), IBFI Schloss Dagstuhl, 2006. \n[31] D. Kapur and C. Zarba. A reduction approach to decision procedures. Technical Report TR-CS-2005-44, \nUniversity of New Mexico, 2005. [32] M. Karr. Af.ne relationships among variables of a program. Acta \nInf., 6:133 151, 1976. [33] J. C. King. Symbolic execution and program testing. Commun. ACM, 19:385 394, \n1976. [34] S. K. Lahiri and R. E. Bryant. Indexed predicate discovery for unbounded system veri.cation. \nIn Proc. CAV, LNCS 3114, pp. 135 147. Springer, 2004. [35] Z. Manna and A. Pnueli. Temporal Veri.cation \nof Reactive Systems: Safety. Springer, 1995. [36] L. Mauborgne and X. Rival. Trace partitioning in abstract \ninterpre\u00adtation based static analyzers. In Proc. ESOP, LNCS 3444, pp. 5 20. Springer, 2005. [37] K. L. \nMcMillan. Lazy abstraction with interpolants. In Proc. CAV, LNCS 4144, pp. 123 136. Springer, 2006. [38] \nA. Min\u00b4e. The octagon abstract domain. Higher-Order and Symbolic Comp., 19:31 100, 2006. [39] M. Sagiv, \nT. W. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. ACM Trans. Program. Lang. Syst., \n24:217 298, 2002. [40] S. Sankaranarayanan, F. Ivancic, I. Shlyakhter, and A. Gupta. Static analysis \nin disjunctive numerical domains. In Proc. SAS, LNCS 4134, pp. 3 17. Springer, 2006. [41] S. Sankaranarayanan, \nH. B. Sipma, and Z. Manna. Constraint-based linear-relations analysis. In Proc. SAS, LNCS 3148, pp. 53 \n68. Springer, 2004. [42] S. Sankaranarayanan, H. B. Sipma, and Z. Manna. Non-linear loop invariant generation \nusing Gr\u00a8 obner bases. In Proc. POPL, pp. 318 329. ACM, 2004. [43] S. Sankaranarayanan, H. B. Sipma, \nand Z. Manna. Scalable analysis of linear systems using mathematical programming. In Proc. VMCAI, LNCS \n3385, pp. 25 41. Springer, 2005. [44] V. Sofronie-Stokkermans. Hierarchic reasoning in local theory extensions. \nIn Proc. CADE, LNCS 3632, pp. 219 234. Springer, 2005. \n\t\t\t", "proc_id": "1250734", "abstract": "<p>The success of software verification depends on the ability to find a suitable abstraction of a program automatically. We propose a method for automated abstraction refinement which overcomes some limitations of current predicate discovery schemes. In current schemes, the cause of a false alarm is identified as an infeasible error path, and the abstraction is refined in order to remove that path. By contrast, we view the cause of a false alarm -the <i>spurious counterexample</i>- as a full-fledged program, namely, a fragment of the original program whose control-flow graph may contain loops and represent unbounded computations. There are two advantages to using such <i>path programs</i> as counterexamples for abstraction refinement. First, we can bring the whole machinery of program analysis to bear on path programs, which are typically small compared to the original program. Specifically, we use constraint-based invariant generation to automatically infer invariants of path programs-so-called <i>path invariants</i>. Second, we use path invariants for abstraction refinement in order to remove not one infeasibility at a time, but at once all (possibly infinitely many) infeasible error computations that are represented by a path program. Unlike previous predicate discovery schemes, our method handles loops without unrolling them; it infers abstractions that involve universal quantification and naturally incorporates disjunctive reasoning.</p>", "authors": [{"name": "Dirk Beyer", "author_profile_id": "81100495756", "affiliation": "Simon Fraser University, Surrey, BC, Canada", "person_id": "PP38029701", "email_address": "", "orcid_id": ""}, {"name": "Thomas A. Henzinger", "author_profile_id": "81100034124", "affiliation": "EPFL, Lausanne, Switzerland", "person_id": "P280800", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "University of California, Los Angeles, CA", "person_id": "P335105", "email_address": "", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "EPFL and MPI, Lausanne, Switzerland", "person_id": "P688961", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250769", "year": "2007", "article_id": "1250769", "conference": "PLDI", "title": "Path invariants", "url": "http://dl.acm.org/citation.cfm?id=1250769"}