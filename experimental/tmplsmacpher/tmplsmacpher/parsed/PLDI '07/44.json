{"article_publication_date": "06-10-2007", "fulltext": "\n Practical Memory Leak Detection using Guarded Value-Flow Analysis * Sigmund Cherem Lonnie Princehouse \nRadu Rugina Computer Science Department Cornell University Ithaca, NY 14853 {siggi, lonnie, rugina}@cs.cornell.edu \nAbstract This paper presents a practical inter-procedural analysis algorithm for detecting memory leaks \nin C programs. Our algorithm tracks the .ow of values from allocation points to deallocation points us\u00ading \na sparse representation of the program consisting of a value .ow graph that captures def-use relations \nand value .ows via program assignments. Edges in the graph are annotated with guards that de\u00adscribe branch \nconditions in the program. The memory leak analysis is reduced to a reachability problem over the guarded \nvalue .ow graph. Our implemented tool has been effective at detecting more than 60 memory leaks in the \nSPEC2000 benchmarks and in two open-source applications, bash and sshd, while keeping the false positive \nrate below 20%. The sparse program representation makes the tool ef.cient in practice, and allows it \nto report concise error messages. Categories and Subject Descriptors D.2.4 [Software/Program Veri.cation]: \nReliability; D.3.4 [Processors]: Compilers, Mem\u00adory management; F.3.2 [Semantics of Programming Languages]: \nProgram Analysis General Terms Algorithms, Languages, Reliability, Veri.cation Keywords Static error \ndetection, memory leaks, memory manage\u00adment, value-.ow analysis 1. Introduction The increasing importance \nof software reliability has led to a large body of research aimed at identifying violation of various \nprogram safety properties, including memory safety properties (such as null pointer dereferences, or \nheap errors), resource usage properties (e.g., .le usage or locking discipline), or security properties \n(such as the use of tainted data). Among these, several important properties can be expressed as properties \nof the following form: on any execution of the program, the value v generated by a program event A must \n.ow into (or * This work was supported in part by National Science Foundation grant CCF-0541217 and AFOSR \ngrant FA9550-06-1-0244. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 07 June 11 13, 2007, San Diego, California, USA. Copyright c . 2007 ACM 978-1-59593-633-2/07/0006. \n. . $5.00 be consumed by) exactly one occurrence of another event B.We refer to such properties as source-sink \nproperties. Examples include detecting lock usage violations (where A is the lock acquire action, B is \nthe lock release, and the value is the pointer to the lock); or detecting potential memory leaks or double \nfrees (where A is the heap allocation event, B represents heap deallocation, and the value is the pointer \nto the allocated heap cell). Current error-detection techniques include both general-purpose tools for \nchecking arbitrary .nite-state machine properties [7, 5, 1]; as well as tools that have been used to \ncheck speci.c properties such as memory leaks [11, 21, 14]. The existing approaches largely fall into \ntwo categories: data.ow analysis approaches that track the state of program values through the control-.ow, \ncomputing in\u00adformation at each program point; and .ow-insensitive approaches, that track the .ow of values \nusing a sparse representation of the program (for instance, using de.nition-use chains or SSA form), \nbut ignoring the control-.ow otherwise. The latter is more ef.cient due to the sparse representation \nof value .ows, but it is not appli\u00adcable to checking arbitrary state-machine properties since it cannot \nreason about events that must eventually take place on all program paths, such as deallocating memory, \nreleasing locks, or closing .les. To the best of our knowledge, all of the existing memory leak detection \ntechniques use .ow-sensitive approaches. This paper presents a novel inter-procedural analysis algorithm \nfor checking source-sink properties using a sparse representation of value .ows, and applies this algorithm \nto the detection of heap memory errors, such as memory leaks or double frees. Our analysis identi.es \nvalue .ows from malloc sources to free sinks through program assignments and use-def chains using a value-.ow \ngraph representation of the program. A simple case of a memory leak occurs when a source never reaches \na sink in the value-.ow graph. Checking the other cases, where a malloc source reaches a free sink on \nall program paths, and only once on each path, is more challenging. Our approach is to annotate the edges \nin the value-.ow graph with guards that represent branch conditions under which the value .ow happens, \nand then use the guard information to reason about sink reachability on all paths. The following list \nhighlights the main features of our approach: Ef.ciency: The analysis is ef.cient due to the sparse \nprogram representation using value .ows. The .ows of data from sources to sinks need not be tracked through \nall of the intermediate program points, but only through the relevant ones;  Analysis re.nement: The \nanalysis .rst uses simple techniques to identify potential errors. It falls back on the more expensive \nreasoning about guarded value-.ows only when the simple ap\u00adproaches fail. Guards are computed in a demand-driven \nfashion, only for the relevant portions of the program.  Concise error reports: The use of sparse value-.ows \nmakes it possible to report concise messages to point to a few relevant assignments and path conditions \nthat cause the error to happen. We have implemented our memory leak detection analysis and applied it \nto the set of SPEC2000 benchmark programs. Our re\u00adsults show that the analysis presented in this paper \nis substan\u00adtially faster than existing leak detectors. Compared to a backward data.ow analysis memory \nleak detector that we have previously proposed [14] and where we experimented with a similar set of benchmarks, \nthe value-.ow analysis presented in this paper runs faster, .nds roughly the same number of errors, and \nyields a lower number of false warnings. We have also used our method to derive a classi.cation of heap \nallocation and deallocation patterns. We .nd this classi.cation useful for understanding how heap allocation \nis being used, and how dif.cult is it to reason about deallocation in real programs. The remainder of \nthe paper is organized as follows. We .rst present the problem statement in Section 2. Next, Section \n3 presents a motivating example. Section 4 presents an overview of our sys\u00adtem. We discuss the analysis \nalgorithm in Section 5, present an evaluation in Section 6, discuss related work in Section 7, and con\u00adclude \nin Section 8. 2. Problem Statement and Classi.cation We de.ne a classi.cation of value-.ow problems \nand place the memory leak and double free problems in this context. DEFINITION 1. Consider a program \nP that consists of three kinds of statements: source statements s that produce fresh values when executed; \nassignment statements that copy values; and sink state\u00adments k that receive values. A source-sink[n,m] \nsafety-checking problem is the problem of checking that each dynamic value in\u00adstance produced by a source \nwill eventually .ow into at least n and at most m sinks in any execution of the program. Example source \nstatements include heap allocation statements, opening .les, acquiring locks, or loading untrusted values. \nCorre\u00adsponding sink statements include heap deallocations (frees), clos\u00ading .les, releasing locks, or \nstoring values into trusted memory lo\u00adcations. Given this de.nition, the memory leak detection problem \nis a source-sink[1,8] problem, since it requires that each allocated cell must be eventually freed. On \nthe other hand, the double-free prob\u00adlem is a source-sink[0,1] problem since it requires that each allo\u00adcated \ncell must be freed at most once. Checking both properties be\u00adcomes a source-sink[1,1] problem, that is, \neach allocated cell must be freed exactly once. We will refer to source-sink[1,1] problems simply as \nsource-sink problems. In contrast, the problem of determining that an untrusted value never .ows into \na trusted location is a source-sink[0,0] problem. We will refer to such problems as source-not-sink problems. \nSolving source-sink problems using a sparse representation of value .ows (such as def-use chains, or \nSSA form) is more dif.cult than solving source-not-sink problems. This is the case because value-.ow \nedges are may edges, so value-.ow paths indicate that values may .ow from sources to sinks. This information \nis enough for source-not-sink problems, but not for source-sink problems. The latter require more precise \ninformation to determine that values must eventually .ow into sinks. This paper addresses the source-sink \nproblem in the context of memory leak detection. Our solution is to annotate each value-.ow edge with \na guards that precisely describe the branch conditions under which the value-.ow takes place. Finite-state \nmachine properties form a more general class of properties, of which source-sink and source-not-sink \nproblems are Figure 1. Example: leaked cell on an early exit path. A dealloca\u00adtion free(p) is needed \nbefore returning at line 8. 1 int func() { 2 int *p = malloc(); 3 if (p == NULL) 4 return -1; 5 6 int \n*q = malloc(); 7 if (q == NULL) 8 return -1; 9 10 ... /* use p[i] and q[j] */ 11 12 free(p); 13 free(q); \n14 return 0; 15 } particular cases. More general .nite-state machine problems in\u00adclude checking the \nabsence of unsafe accesses through dangling\u00adpointers, or checking that .le operations access opened .les. \nThis paper does not address such problems. In the remainder of the paper we will only discuss the memory \nleak and double free problems, and will use the terms malloc and source, and free and sink interchangeably. \n 3. Examples This section discusses two examples that illustrate the main chal\u00adlenges of analyzing source-sink \nproblems in the context of the memory leak detection problem. 3.1 Example 1: Missing Free on Function \nExit Path The code fragment from Figure 1 shows a simpli.ed version of several leaks found in ammp, one \nof the SPEC2000 benchmarks. The program manipulates two heap-allocated arrays: array p allo\u00adcated at \nline 2, and array q allocated at line 6. The function uses the arrays locally, and deallocates them at \nthe end of the function, at lines 12 and 13. The omitted code at line 10 accesses array ele\u00adments p[i] \nand q[j], but doesn t store copies of pointers p or q in other variables or program structures. After \neach allocation, the program checks if the call to malloc() successfully returns a non\u00adnull pointer (lines \n3 and 7); if so, the function immediately returns an error code. The program leaks memory at the return \nat line 8. At that point, the function returns without freeing the successfully allocated array p. 3.1.1 \nLeak Detection via Data.ow Analysis This leak can be identi.ed using any of the data.ow analyses proposed \nin [7, 5, 10]. Starting from a (successful) allocation at line 2, a data.ow analysis will analyze all \nforward program paths from that point, tracking the typestate of p (i.e., allocated or deallocated state) \nup to each of the return points at lines 4, 8, and 14, when p goes out of scope. The analysis will identify \nthat the path to line 4 is infeasible when the allocation was successful; that the returning at line \n14 is safe because the cell has just been deallocated at line 12; and that an error occurs at line 8 \nbecause the cell is not freed on that return path. Note that the data.ow analysis doesn t need to be \npath-sensitive (i.e., be able to identify correlated branches, as in [5]) to handle this example. 3.1.2 \nLeak Detection via Guarded Value Flows Our goal is to identify the memory leak in the above example just \nby reasoning about value .ows in the program. We describe value\u00ad.ows using a graph whose nodes represent \nde.nitions of program variables, and edges describe .ows via program assignments. In addition, there \nis a node for each free(x) statement; its predeces\u00adsors are the de.nitions of x. The value-.ow graph \nfor the above example is shown below: q=malloc() p=malloc() free(q) free(p) The graph indicates that \neach of the values p and q .ows into its corresponding free. The other uses of p and q,suchas p[i] and \nq[j], are not included since they do not store copies of these pointers, so they are not relevant. However, \nthe information in the above value-.ow graph is not enough for identifying the error: it shows that p \nand q may be freed freed; but it doesn t show that they always freed, on all program paths. In fact, \nwe can write a correct program that would have the same value-.ow graph: p = malloc(); if (p == NULL) \nreturn -1; else { ...; free(p); } q = malloc(); if (q == NULL) return -1; else { ...; free(q); } The \nquestion is how to distinguish between the two cases. Our solution to this problem is to annotate the \nvalue-.ow edges with guards that describe the branch conditions under which the value\u00ad.ow takes place. \nFor the program from Figure 1, the guarded .ow graph is: q=malloc() p=malloc() p!=NULL .q!=NULL q!=NULL \nfree(q) free(p) The condition q != NULL for q is redundant, and so is the condition p != NULL for p, \nbecause the analysis is only con\u00adcerned with the cases where allocations are successful. Excluding these \nconditions, the analysis determines that the allocation q= malloc() always .ows into free(q), hence it \nis safe; but the allocation p = malloc() .ows into free(p) only when q!= NULL. The analysis therefore \nconcludes that the program leaks in the opposite case, when q == NULL, and reports the error: Error: \ntest.c, line 2: allocation leaks memory Leak path: q == NULL test.c, line 7 The message concisely summarizes \nthe problem and its cause.  3.2 Example 2: Aliases and Multiple Deallocations Identifying that source \nmallocs .ow into frees on all program paths using value-.ow graphs becomes more dif.cult when the program \ncreates aliases of the allocated cell. The code fragment below illustrates the issue: int *p = malloc(); \nif (c) { ...; free(p);} else { q = p; ...; free(q);} The above program safely deallocates the allocated \nheap cell on each of the two program paths. However, deallocation takes place at multiple points, through \ndifferent value aliases. The guarded value .ow graph for this example is as follows (where the edge labeled \ntrue indicates that the value assigned at the de.nition q=p always .ows into free(q)): !c p=malloc() \n q=p c true free(p) free(q) Using the guards on the edges, the analysis performs the fol\u00adlowing reasoning \nto show the absence of errors. The analysis in\u00adspects each free reachable from the allocation and determines \nthat: free(p) takes place when condition c holds; and free(q) takes place when !c . true =!c holds. Using \nthis information, the com\u00adpiler can check for heap errors as follows: Absence of leaks: Since c . !c \n=true it means that the two cases cover all possibilities, so the allocated cell is freed on all paths; \n Absence of double frees: Since c . !c =false it means that the conditions under which the two frees \ntake place are disjoint, hence the allocated cell is never freed twice.   4. System Overview Figure \n2 gives an overview of our program analysis system. The system is built using Crystal [16], a program \nanalysis system for C. The shaded components have been developed part of this work, while the others \nare provided by Crystal or have been taken from external sources. The analyzer consists of the following \ncompo\u00adnents: Front-end. The front-end parses the program and builds a control-.ow graph representation \nof the program.  Reaching de.nition analysis. A standard data.ow analysis com\u00adputes the set of uses \nfor each de.nition in the program.  Value-.ow graph construction. The results of the reaching def\u00adinitions \nanalysis are used to build the value .ow graph. The guards on the value-.ow edges are not computed yet; \nthe guard computation is postponed for a subsequent phase.  Region points-to analysis. The analyzer \nuses the pointer analy\u00adsis provided by Crystal to disambiguate indirect memory refer\u00adences via pointers. \nThis is a .ow-insensitive uni.cation-based points-to analysis [18]. The analysis is context-insensitive, \nbut .eld-sensitive. The equivalence classes computed by the anal\u00adysis provide a partitioning of the memory \ninto disjoint regions. Indirect memory accesses are represented in the value-.ow graph using their memory \nregion.  Unguarded reachability analysis. Once the value-.ow graph is computed, the analyzer checks \neach allocation site in turn. The analysis searches the value-.ow graph for all of the frees that the \nallocation may reach. The reachability algorithm is context\u00adsensitive and matches value .ows at calls \nand returns. If no free statements are encountered, the analyzer classi.es the current allocation site \nas one that is never freed. Otherwise, it extracts the sub-graph relevant to the allocation site and \nproceeds to the guard computation in the next phase.  Guarded reachability analysis. In this phase, \nthe analyzer re\u00adquests guard information on each of the value-.ow edges in the subgraph relevant to the \ncurrently analyzed allocation site. These queries are answered by the guard analyzer module. Once value-.ow \nguards are computed, the algorithm derives larger formulas describing the entire path from the malloc \nto  Figure 2. Analysis system overview each free. The analyzer then generates two queries, one for \nmemory leaks and another for double frees, as in the example discussed Section 3.2. The resulting formulas \nare checked for satis.ability using a SAT-solver. If a satisfying assignment of boolean values to guards \nis reported by the solver, then a viola\u00adtion is detected and reported. Guard analysis. This component \nanswers queries about guards on value-.ow edges. The analysis identi.es the program points that correspond \nto the source s and target t of the edge, and then performs a local analysis of the control-.ow between \nthese points. The computed formula describes the program conditions under which the control .ows from \ns to t.  SAT Solver. Satis.ability queries are answered using SAT4J, freely available SAT-solver [3]. \n The following section discusses the program representation pro\u00advided by the front-end. Next, it presents \nthe details of our analyses. 4.1 Program Representation The front-end parses the source program and builds \na control-.ow graph (CFG). The input program is simpli.ed to a canonical form where each node in the \ncontrol-.ow graph is one of the following: ' Assignment node: e = e',where e and eare program expres\u00adsions. \n Call node: e = f(e1, ..., ek),where e, e1,.., ek are expres\u00adsions in canonical form. The left-hand \nside expression might be missing, so this also models calls to functions that return void, or calls that \ndon t assign the returned value.  Return node: return e,where e is a program expression.  Switch node: \nswitch e (c1 : n1, ..., ck : nk),where e is the test condition, ci are the case constants for each branch, \nand  ni are the corresponding successor nodes. Control .ows to ni when e = ci. A constant default represents \nthe default case. If statements are modeled as switch e (0 : nf , default : nt). Allocation sites are \ncalls of the form x = malloc(); and deal\u00adlocations are calls of the form free(x). For simplicity, assume \nthat in both cases x is a local variable. We denote by V the set of local variables, and P the set of \nfunction parameters. Variables whose addresses are taken with the address-of operator &#38; are considered \nas non-local expressions. We use N to represent the set of all CFG nodes. For each node n . N (switch \nor otherwise), kn is the number of successors of n,and In = {1, .., kn} is the range of possible successors. \nWe denote by ni the i-th successor of n,where i . In. Assignments and call nodes each have a single successor. \nExpressions e don t have side-effects and include variables (lo\u00adcals, parameters, or globals), as well \nas arbitrary expression trees involving pointer dereferences, .eld accesses, array accesses, and unary \nor binary operations.  5. Analysis Algorithm This section covers the details of the memory leak analysis, \ndis\u00adcussing the algorithm for each of the shaded components in Fig\u00adure 2. 5.1 Reaching De.nitions This \nis the standard reaching de.nitions analysis implemented as a bitvector data.ow analysis. The analysis \ntracks only local variables and parameters whose addresses have not been taken. For each node n, the \nanalysis computes a set of variable de.nitions that reach node n. 5.2 Building the Value-Flow Graph \nThe value-.ow graph (VFG) captures the .ow of values through program assignments. The nodes of the value-.ow \ngraph include: Variable de.nitions: There is a VFG node for each de.nition of a variable x . V at a \nCFG node n. By abuse of notation, we also refer to the resulting VFG node as n. De.nitions at allocation \nsites are marked as source nodes.  Frees: There is a VFG node for each free statement. These are marked \nas sink nodes.  Regions: There is a VFG node for each memory region that doesn t correspond to a local \nvariable or a parameter. As mentioned earlier, the region partitioning is provided by the uni.cation-based \npointer analysis.  Call sites: There is a VFG node for each local variable x . V passed as an argument \nat a call site. The VFG node of an actual argument x at a call node n is denoted by [x@n].  Parameters: \nThere is a VFG node for each formal parameter p . P , denoted by [p].  Returns: There is a VFG node \nfor each return statement n in a function.  The edges of the value-.ow graph are constructed by travers\u00ading \neach CFG node n in the program and performing one of the following actions: If n is an assignment x \n= y where x, y . V , add an edge n' . n from each de.nition ny of y that reaches n.  If n is of the \nform x = e where x . V but e/. V , then query the points-to analysis for the region r of e, add a load \nedge nr . n from the node nr of region r.  Statement (n) Added edges y = xnx . n free(x) nx . n return(x) \nnx . n y = f(..., x, ...) nx . [x@n] [x@n] . [p] f nret . n Where x, y . V , nx is a de.nition of x that \nreaches n, p is the formal f parameter of argument x,and n is a return node of function f. ret Figure \n3. Value Flow Graph construction rules for propagation of values through program variables. If n is \nof the form e = x where x . V and e/. V ,add a store edge n . nr from n to the region r of e.  If n \nis a free(x) statement, add an edge nx . n from de.nition nx of x that reaches n.  If n is a return(e) \nstatement, add edges from the reaching de.nitions of e (if e . V ) or from the region of e (if e . V \n)to the return node n.  If n is a call e = f(x1, ..., xn), the analysis adds three kinds of edges. First, \nit adds an edge nxi . [xi@n] from each reaching de.nition nxi of xi to [xi@n]. Second, it adds a call \nedge [xi@n] . [pi] from the node of each actual argument xi to the node of its corresponding formal parameter \npi.Third,the analysis adds return edges to model the assignment of the return value to the left hand \nside of the call assignment. For each return node nret in the callee, the analysis adds a return edge \nnret . n, if e . V . Otherwise, it queries the points-to analysis for the region r of e and adds a store \nedge nret . nr. For indirect function calls through function pointers, the analysis repeats the above \nprocedure for each potential callee.  Call edges and return edges are labeled with call-site informa\u00adtion \nin a standard fashion: for a call site n, call edges are la\u00adbeled with open parentheses (n and return \nedges are labeled with close parentheses )n. Feasible inter-procedural value .ows correspond to paths \ncontaining properly nested parentheses and context sensitive analyses can be formulated as context-free \nlan\u00adguage (CFL) reachability problems [15]. Figure 3 summarizes the process of building the value-.ow \ngraph for the propagation of values through variables and pa\u00adrameters. The edges constructed so far are \nnot annotated with guards. Branch conditions will be computed subsequently, only when needed. 5.3 Unguarded \nReachability Detection Once the value-.ow graph is built, the algorithm analyzes each source allocation \nsite src. The goal of this stage is to determine whether the allocation reaches any free, and if so, \nwhat is the relevant portion of the VFG that connects the malloc to the frees. The algorithm is as follows: \n1. Identify the set of nodes Fsrc reachable from the source src using a forward traversal of the nodes \nN of the VFG: Fsrc = CFLForwardReach(src,N) The algorithm uses CFL-reachability to match call and return \nedges and eliminate unfeasible inter-procedural .ows of val\u00adues. Hence the analysis is context-sensitive. \nThe algorithm uses function summaries to cache and reuse matched calls and re\u00adturns. This is a standard \napproach and we omit the details. 2. Identify a set of reachable sinks K: K = {k . Fsrc | k is a free \nnode} 3. Apply one of the following three cases:  If there are no reachable sinks, then classify src \nas an allo\u00adcation that is never freed. The analysis of this allocation site stops here.  If some region \nnode nr is reachable from src (nr . Fsrc) then classify the allocation as one that .ows into global scope \nor aggregate data structures such as arrays. The al\u00adgorithm will classify this case as too complex, and \nwill not further analyze this allocation site.  Otherwise, identify a relevant slice R of the VFG, consist\u00ading \nof all nodes on paths from src to a reachable sink. This is the set of relevant nodes for the allocation \nsrc with respect to its safe deallocation properties. The slice is computed us\u00ading a backward traversal \nfrom the sinks K to the source, but going only through the nodes in Fsrc that have been discov\u00adered in \nthe forward traversal:   R = BackwardReach(K, Fsrc) The backward traversal doesn t match calls and \nreturns, since invalid inter-procedural .ows have already been .l\u00adtered out in the forward traversal. \nIn this case, the analysis proceeds to the next phase to per\u00adform guarded reachability over the slice \nR of the currently analyzed allocation site src. 5.4 Guarded Reachability Detection The goal of this \nphase is to perform a deeper analysis over the value-.ow graph when the previous step has determined \nthat the current allocation site might be freed on some execution paths. Given an allocation site src, \na relevant VFG slice R for this alloca\u00adtion, and a non-empty set of reachable sinks K . R, the analysis \ndetermines whether the allocated cell is freed exactly once on each program execution path. As sketched \nin the examples from Sec\u00adtion 3, the analysis uses guards on the value-.ow edges to reason about the \npossibility of heap errors. The guards are boolean formulas that include standard logical operators (and, \nor, not), boolean constants, and boolean variables that represent switch conditions: Guards g ::= true \n| false (constants) | g1 . g2 | g1 . g2 (and, or) | g (negation) | (e = ci)n (switch test) The switch \ntest (e = ci)n describes an instance of the test that occurs at switch node n and tests expression e \non the branch on which the test e = ci succeeds. For each switch statement n,a consistency formula Cn \nmodels the fact that one and only one of its branches can be taken: h_ih^ i Cn =(e = ci)n . (e = ci)n \n. (e = cj )n ii= j The guarded reachability algorithm proceeds as follows. First, it computes guards \nfor each edge in the relevant slice R by exploring CFG paths. Next, it aggregates VFG guards into larger \nformulas. Finally, it performs satis.ability tests to detect errors. We describe each of these steps \nbelow. CFG guard computation. For each value-.ow edge n . m, where n and m are two program points in \nthe same function, the analysis computes a formula describing when the value de.ned at n .ows into its \nuse at node m. This guard is computed by exploring cguard(n .m)=cg(x, n, m, \u00d8) where n is of the form \nx =e cg(x, n, m, E)= 8 > true if pdom(x, n, m, \u00d8) > > > cg(x, n1,m,E) if n is not a switch < and \u00acde.nes(n1,x) \n= _ > cond(n, ni,E). > > otherwise > : cg(x, ni,m,E .{(n, ni)}) i.In,x,E where In,x,E ={i .In |\u00acde.nes(ni,x) \n.(n, ni)./E} cond(n, ni,E)= 8 < (e =ci)n if n is switch e (..., ci :ni, ...) = and nj . (n, nj ).E : \ntrue otherwise pdom(x, n, m, S)= 8 > true if m =n or n .S > < false otherwise if n is a return node \n= ^ \u00acde.nes(ni,x). > > otherwise : pdom(x, ni,m,S .{n}) i.In Figure 4. Demand-Driven CFG Guard Computation. \nThe predi\u00adcate de.nes(n, x)indicates that node n writes variable x. the structure of the control-.ow \ngraph (CFG) between points n and m. Intuitively, the computed guard summarizes the portion of the CFG \nbetween n and m. The guard computation algorithm is performed by the func\u00adtion cguard(n . m) in Figure \n4, implemented using dynamic programming (i.e., caching). The algorithm uses a helper function cg(x, \nn, m, E)that maintains the variable x whose value .ow is being tracked and the set E of traversed edges. \nThe guard between n and m is the disjunction of the guards over all possible paths, where the guard of \neach path is the conjunction of conditions on all control-.ow edges on that path: _ cond(n, ni,E) . cg(x, \nni,m, E .{(n, ni)}) i.In,x,E The algorithm considers only those paths that allow the value of variable \nx de.ned at n to .ow into node m. Hence, paths that rede.ne x do not contribute to the value .ow from \nn to m (i.e., these paths have a false guard). The algorithm in Figure 4 .lters out control-.ow paths \nthat rede.ne variable x using the predicate de.nes(n, x). In the presence of loops, guards can grow unbounded. \nTo avoid unbounded conjunctions that describe all loop iterations, the anal\u00adysis bounds loops to at most \none iteration. This is done using the set E of visited edges. The de.nition of In,x,E .lters out control\u00ad.ow \nedges that have been already traversed, ensuring that loops are traversed at most once. Furthermore, \nthe analysis adds the loop exit condition only when the loop is not executed. The reason for this is \nthat the analysis does not distinguish between different instances of the loop test: entering the loop \nis described by (e =ci)n, and exiting the loop after the .rst iteration would correspond to (e =ci)n. \nWithout distinguishing between the two different instances of this test, their conjunction would make \nthis path infeasible. To avoid this, the analysis does not add the exit condition (e =ci)n on the path \nthat enters the loop. This is formalized in the algorithm by the condition nj . (n, nj ).E in the de.nition \nof cond. vguard(n, m)=vg(n, m, \u00d8) vg(n, m, E)= = 8 < : true _ n.n' /.E vg ' (n .n ' ,m,E) if n =m otherwise \n' ' ( vg n .n ,m,E)= 8 < vg(n ' ,m,E .{n .n ' }) if n is call or return node = cguard(n .n ' ) . otherwise \n: vg(n ' ,m, E .{n .n ' }) Figure 5. VFG Guard Computation. In addition, the analysis uses post-dominance \ninformation to simplify the computation of guards. More precisely, the algorithm computes a post-dominance \nrelation pdom and returns a true guard for the edge n .m whenever m post-dominates node n. The post\u00addominance \nrelation pdom is computed on-demand, as shown in Figure 4. The post-dominance computation also excludes \nprogram paths that rede.ne variable x. VFG guard computation. Next, the analysis computes aggregate guards \nfor the entire value .ows from the source src to each of the sinks. The algorithm traverses the value-.ow \ngraph, accumulating guards along each path and combining guards from different paths. The algorithm is \nsimilar to the computation of guards in the CFG, except that it is performed on the VFG and it doesn \nt use post\u00addominators. The value-.ows in VFG do not exhaustively cover all program paths, hence using \ndominators would be unsafe. Recursion is bounded in a similar way as loops: recursive call sites can \nbe invoked at most once. Figure 5 presents the algorithm. The result of this part of the analysis is \nan aggregate guard Gk for each reachable sink k. The guard Gk describes the entire path from the source \nto the sink k. Satis.ability testing and error detection. Once aggregate guards are computed for each \nsink, the analysis performs two tests to identify potential errors. First, it checks for potential leaks \nby testing the satis.ability of the following formula: _ FL = Gk .C k.K where formula C combines the \nconsistency conditions Cn of all switch statements n that appear in the guards Gk. The consistency formula \nC eliminates cases that contradict the semantics of switch statements (for instance, cases where both \nbranches of a conditional are taken). If the formula FL is satis.able, then there may be a memory leak. \nThe satisfying assignment A gives truth values for branches: a true value for a branch indicates that \nthe branch is taken, and a false value indicates that the branch is not taken. Hence, the satisfying \nassignment A describes the error path. Similarly, the analysis checks for double frees by testing the \nsatis.ability of the following formula for each pair of sinks i, j . K, i =j: FDF =(Gi .Gj) .C If the \nformula FDF is satis.able, then a double free error is detected and the satisfying assignment indicates \nthe error path. The overall guard reachability and error detection algorithm is summarized in Figure \n6. GUARDEDREACHABILITY(source src, slice R, sinks K) 1 for (each value-.ow edge n . m in R) 2 compute \nthe edge guard cguard(n . m) 3 4 for (each sink k . K) 5 compute aggregate guard Gk =vguard(src,k) 6 \n7Let S be the switch nodes appearing in all of Gk V 8 Build a switch consistency formula C = n.S Cn 9 \n W 10 if (the formula FL = k.K Gk . C is satis.able) 11 then let A be a satisfying assignment 12 report \nmemory leak for s on path A 13 14 for (all sinks i, j . K s.t. i =j) 15 if (the formula FDF =Gi . Gj \n. C is satis.able) 16 then let A be a satisfying assignment 17 report double free for s on path A Figure \n6. Error Detection via Guarded Graph Reachability. 5.5 Extensions We present several extensions of the \nbasic analysis presented so far aimed at improving its precision, ef.ciency, or its error reports. 5.6 \nAllocator Functions Applications often use allocator functions that return fresh heap cells allocated \nin their bodies. Examples include allocation wrapper functions that extend the standard malloc() by testing \nthe returned value against null and aborting the program if allocation fails; or initializer functions \nthat allocate fresh data structures and return them to their callers. If an allocator function is called \nmultiple times, then the cell created in the allocator body will .ow into each of the allocator s call \nsites. As a result, slices can get larger and error reports can become complex. To keep the slices and \nerror reports small and easy to under\u00adstand, we enhance the algorithm to automatically detect alloca\u00adtor \nfunctions and to use knowledge about allocators to construct smaller slices. More precisely, for each \ndetected allocator function the analyzer builds: 1) one slice for each call to the allocator, treat\u00ading \nthe call site as a source node; and 2) one additional slice show\u00ading the .ow of values inside the allocator \nitself, treating the alloca\u00adtor return point as a sink node in that slice. An allocator function is a \nfunction that may return a fresh heap cell created in its body. We do not require that allocators always \nreturn fresh cells: they might return non-fresh values on some executions, and fresh cells on others. \nHowever, the slices starting at their call sites only refer to those executions where they returned a \nfresh value. Allocator functions can be nested, that is, cells created inside them might be generated \nby inner allocators. Detecting allocator functions is performed during the forward traversal of the VFG \nin the slicing phase, in Section 5.3. If the traversal for an allocation src in a function f reveals \na value .ow path from src to the return variable nret f of function f, and that path consists only of \nlocal variables and parameters, then function f is marked as an allocator. All of the call sites of f \nare marked as allocation sites and the algorithm will subsequently analyze them, building a separate \nslice for each of them. The algorithm uses a worklist of discovered allocation sites. The worklist is \ninitialized with all the malloc sites in the program. As new allocators are discovered, they are added \ninto the worklist. At each step, the analysis removes an allocation site from the worklist and builds \nits slice. The algorithm terminates when the worklist is empty. 5.6.1 Constant Tests As discussed in \nSection 3, tests comparing the allocated value against NULL can be replaced with an appropriate constant \ntruth value. For instance, if the currently analyzed allocation is x= malloc(), then test conditions \nof the form (x == NULL) can be replaced by false because the analysis only considers the cases where \nthe allocation is successful. This simpli.cation technique can be generalized to tests of the form (y \n==e) where variable y de.nitely points to the allocated cell, but expression e is different than the \ncell. To determine that y points to the allocated cell, the analysis checks all the de.nitions of y reaching \nthe test can be traced back in the value-.ow graph to the value of x. To determine that expression e \ndoes not refer to the cell, the analysis checks that either e is not a variable (for instance NULL)orit \nisavariable butthe valueof x never .ows into that variable. If these conditions are met, y and e are \ndifferent, so the test (y == e) is false. 5.6.2 Pointer Arithmetic Programs sometimes manipulate pointers \ninside (or even outside) allocated memory blocks instead of pointers to the beginning of memory blocks. \nEven though a freed pointer may correctly point to the beginning of its block, values may .ow to the \nfree through pointers in the middle of the block, as in the example below: x = malloc(); y = x + 4; free(y \n-4); To support value .ows through pointer arithmetic, the VFG con\u00adstruction algorithm abstracts away \noffsets within allocated blocks. More precisely, each occurrence of a pointer arithmetic expression x \n+e or x - e in an assignment, a return expression, or an actual function argument is treated just as \nan occurrence of variable x. Hence, the VFG captures the .ow of pointers to allocated blocks, without \nrecording their offsets into the blocks. To keep the error detector simple and practical, we don t check \nthat arithmetic oper\u00adations from the allocation to the free cancel each other. Freeing a pointer into \na block always counts as freeing the block. 5.6.3 Formula Simpli.cation The guard computation from Figure \n4 can lead to an exponential blowup in the size of the computed formulas when the analysis traverses \ncode fragments that involve many branches. To maintain smaller formulas, the analysis performs on-the-.y \nsimpli.cations using standard logical identities: f . true =ff . false =false f . true =true f . false \n=f (f . g). (f . g)=f The last identity eliminates irrelevant tests when both branches (g and g) of an \nif statement are taken. Even after such simpli.cations, formulas can still become large for programs \nwith complex, unstructured control-.ow. To keep the tool practical, the analysis bounds the sizes of \nthe computed formulas by bounding the height of expression trees to a .xed value (30 in our experiments). \nWhen a formula exceeds the bound, the analysis stops analyzing the current allocation site and classi.es \nthe current allocation as one having unknown guards.  5.7 Discussion: Test Conditions and Unsoundness \nIn our framework, test conditions (e = ci)n are distinguished based on the program point n where they \noccur. In fact, in our implementation a test condition is represented as a CFG edge em\u00adanating from switch \nstatement n. Therefore: 1) tests at different program points are considered uncorrelated even if they \ntest the same condition; and 2) different dynamic instances of the same test are the same because they \noccur at the same program point. The former can lead to imprecision, whereas the latter is a source of \nun\u00adsoundness, i.e., may cause the tool to miss some errors. Additional analyses could be developed to \naddress these issues. For instance, a sound treatment would require an analysis checking that all dy\u00adnamic \ninstances of a given test have the same truth value during the lifetime of the currently analyzed allocation. \nIn practice, we have not seen cases that would justify such an analysis. Other sources of unsoundness \nare due to our treatment of loops: Bounding the number of loops iterations implies a stronger guard \nfrom malloc to free, i.e., fewer paths to the frees than the program has. Interestingly, this means that \nbounding loop itera\u00adtions is actually sound for detecting memory leaks. However, it is unsound for detecting \ndouble frees.  Dropping the test condition on exit after the .rst iteration makes the guard on this \nprogram path weaker. Hence, this is unsound for the memory leak problem, but is sound for the double \nfree problem.  In practice, we have not seen cases where our tool missed errors due to these sources \nof unsoundness. We have manually checked all cases where the analysis reported that allocated cells were \nsafely freed and all of these reports were correct.  6. Results We have built an error detection tool \nFastCheck 1 that implements the analysis algorithm described in this paper, including the exten\u00adsions \ndiscussed in Section 5.5. The analysis was implemented in Crystal [16], a program analysis for C written \nin Java. Crystal pro\u00advides a uni.cation-based .eld-sensitive pointer analysis and uses the points-to \ninformation to disambiguate indirect function calls. The control-.ow graph representation provided by \nCrystal is simi\u00adlar to the one presented in Section 4.1. In addition, FastCheck uses SAT4J [3], a freely \navailable boolean satis.ability solver written in Java. All of our experiments were executed on a 3.2GHz \nPentium D machine with 3GB of memory running Linux. We have exper\u00adimented with programs from the SPEC2000 \nbenchmarks [20] and with two open-source applications, the shell program bash-3.1 and the ssh daemon \nsshd-4.3p2-4. 6.1 Analysis times The left portion of Table 1 presents the analysis times for each ap\u00adplication. \nThis includes the time for building the value-.ow graph and performing the reachability analysis. The \nlatter includes the guard computation and satis.ability solving times. For most bench\u00admarks, the entire \nanalysis takes less than a second. The most expen\u00adsive application is bash, where the analysis takes \n5 seconds. The analysis time is about one order of magnitude smaller than the time spent parsing the \nsource .les. For instance, parsing gcc takes about 20 seconds, and parsing bash takes about 40 seconds. \n 6.2 Memory Leak Study A key feature of FastCheck is its ability to classify allocation sites into several \ncategories and selectively report these categories the the user. The high-priority category contains \nlikely errors; the medium-priority class contains errors that are possibly benign; whereas the low-priority \ncategory contains more complex scenarios where the analysis cannot precisely reason about possible errors. \nIn addition, the tool identi.es a set of safe allocations where it has determined that cells are correctly \nfreed. The classi.cation consists of the following categories: 1 Available at: http://www.cs.cornell.edu/projects/crystal/fastcheck \n1. Never freed: a cell allocated at that site is never deallocated. We divide this category in two sub-categories: \n(a) local: The allocated cell is manipulated only through local variables and parameters. In many cases, \ncells of this kind do not escape the function s scope, but in some cases they are passed to and returned \nfrom functions. The tool further re.nes this into: i. local allocations in main. These allocations are \nlikely to be live throughout the program, so the tool classi.es them as possibly benign leaks. ii. local \nallocations in functions other than main.These are likely errors and are reported with high priority. \n (b) not local: The allocated cell is stored in a global structure, heap structure, or array. Since such \ncell may be live through the rest of the program, the tool also classi.es them as possibly benign leaks. \n 2. Freed, precisely known: the path from the allocation to each free is described by our tool using \nguards. In particular, the al\u00adlocated cell cannot have pointer aliases and its value .ows only through \ncopy assignments, method calls and return statements. We further divide this class into two sub-categories: \n(a) always: the allocated cell is always deallocated. The anal\u00adysis can derive that the condition to \ndeallocate the cell is either true or a simple test that checks if the allocation re\u00adturned a non-null \nvalue. These allocations are safe. (b) conditional: the allocated cell may leak, but only on certain \npaths. The tool derives an error path and reports the error with high priority.  3. Freed, but unknown: \nthe allocated cell may be freed, but the analysis can t derive a precise condition under which it is \ndeal\u00adlocated. This can happen when the allocated cell is only copied through local variables, but the \nsize of a guard formula exceeds the .xed bound; or, when the cell is simply not local, i.e., its address \nis stored in a structure, array or global variable. The right portion of Table 1 summarizes the results \nfor each application. The leak messages section shows the total number of source allocations and the \nnumber of warnings (total, true, and false warnings) issued by the tool in the standard mode of operation, \nwhere only the high-priority errors are reported. The number of source allocations include all malloc \nsites and all calls to allocator functions, as discussed in Section 5.6 (the breakdown between malloc \nsites and calls to allocators is shown next in Section 6.6). The portion portion of the table, labeled \nmessages by category , provides a detailed breakdown of the allocations by category. In the default setting, \nonly the two columns shown in bold are reported. Our tool provides additional command-line .ags for reporting \nthe other categories. Error Reporting Methodology. For each allocation site, FastCheck provides the following \ninformation to users: An error message at the console indicating the location of the allocation site \nin the source .le and the error path as a sequence of branches that lead to the error.  An HTML .le \nthat highlights statements of the relevant slice in the source code, as well as the branches that lead \nto the error;  A graphical representation of the slice graph using the dot [9] format.  We found the \nHTML and dot error reports extremely useful in quickly understanding the errors. The relevant slices \nfor all of the warnings were very small: the average size of the relevant slice Analysis Times (sec) \nLeak Messages Messages by Category Size Programs (Kloc) Building Reachability VFG Unguarded Guarded Total \nLeak Leak False Sources Warn. Bugs pos. Never Freed Freed Known Unknown not local always cond local not \nlocal main other local ammp 13.3 0.14 0.01 0.15 37 20 20 0 10 0 0 5 20 0 2 art 1.3 0.02 0.01 0.01 11 \n1 1 0 9 0 1 1 0 0 0 bzip 4.6 0.05 0.01 10 0 0 0 5 1 0 0 0 0 4 crafty 18.9 0.19 0.01 12 0 0 0 0 1 0 \n0 0 011 equake 1.5 0.08 0.01 29 0 0 0 29 0 0 0 0 0 0 gap 59.5 1.75 0.11 0.01 2 0 0 0 1 0 0 1 0 0 0 gcc \n205.8 2.22 0.02 0.09 126 37 35 2 43 0 25 17 12 920 gzip 7.8 0.07 0.01 5 0 0 0 2 1 0 0 0 0 2 mcf 1.9 \n0.04 0.01 3 0 0 0 0 0 0 0 0 0 3 mesa 49.7 0.39 0.02 0.11 133 2 0 2 6 0 0 29 2 195 parser 10.9 0.16 0.01 \n 1 0 0 0 0 0 0 0 0 0 1 perlbmk 58.2 0.79 3.77 0.09 321 4 1 3 29 0 1 27 3 0 261 twolf 19.7 0.29 0.07 0.02 \n185 2 2 0 77 1 2 18 0 087 vortex 52.7 0.75 0.06 9 0 0 0 0 0 0 0 0 0 9 vpr 17.0 0.14 0.11 0.08 157 1 \n0 1 31 0 0 57 1 068 bash 100.0 sshd 48.7 1.53 0.50 2.46 1.11 0.06 0.13 276 3 2 1 454 3 2 1 25 0 0 67 \n6 1 88 3 243 2 5 155 0 135 Averages 55% 27% 18%  14% 19% 1% 2% 27% 2% 1% 48% Table 1. Analysis times, \nleak warnings statistics, and leak messages classi.cation. Only cases in bold are reported as high priority \nerrors. was two nodes, and the biggest slice in the reported warnings had 11 nodes. As a result, error \nreports were small and easy to understand. There are two main reasons for relevant slices to be small. \nFirst, they only include value .ows that lead to frees. For instance, passing a pointer to an allocated \ncell to a function that only accesses the cell contents is not highlighted in the report. In the extreme \ncase, slices for allocations that are never freed consist of a single node, the allocation site. Second, \ndetecting allocator functions and using one slice per allocator call site breaks down larger slices into \nseveral smaller and simpler slices. Reported Warnings. For these benchmarks, our tool has reported 73 \nmemory leak warnings, of which 63 were actual errors, yielding a false positive rate of 14%. Overall, \nthese warnings account for a small fraction (4%) of the total number of allocations. The distribu\u00adtion \nof warnings and errors across the benchmarks is uneven, with ammp and gcc accounting for the majority \nof errors. Several of the errors referred to allocations that were never freed. Many bugs in gcc come \nfrom mishandling concatenation of strings (we discuss an instance of this bug in the following section). \nThe tool also pointed out a few cases in gcc where memory leaks occur when adding entries to a symbol \ntable. The program creates a symbol string and passes it to a function that performs the insertion. However, \nthe insertion function creates a copy of the string and doesn t deallocate the original string. The string \nis not deallocated in the caller either and is leaked shortly after insertion. Applications such as twolf \nand art create dynamic arrays that are used locally, but are never deallocated. Conditional leaks are \ncases where functions don t deallocate memory when returning on error conditions. Cases in ammp are similar \nto the example from Section 3, where cells are leaked when other allocations fail. Other conditional \nleaks were found in perlbmk and bash (we discuss the example bug in bash in the following section). The \nfalse positives were due to several different reasons: ex\u00adplicit reference counting and deallocation \nwhen reference counts become zero (two warnings in mesa); ignoring extra parameters for functions variable \nnumber of arguments (two warnings in gcc); not recognizing exit functions such as execve (one warning \nin perl); bounding the number of loop iterations(in sshd and vpr); and not recognizing unfeasible program \npaths two warning in perl and one in bash. The example below shows the false positive from bash: if (lose \n== 0) { name_vector = malloc (); lose |= name_vector == NULL; } if (lose) { ... return; } The tool reports \na possible leak at the return point. Identifying that the path from the malloc to the return is infeasible \nwould require reasoning about the bitwise operation after the allocation. Other categories. The tool \nhas identi.ed that 27% of the allo\u00adcations are safely freed. Since the tool is unsound, allocations re\u00adported \nto be safe might leak memory. However, this never happened for our benchmarks: we have manually inspected \nall of the alloca\u00adtions in this category and determined that all were freed correctly. About 20% of the \nallocations in the program were never freed. Many of these cells were placed into global variables and \nwere live throughout the application. For this reason, we classi.ed all of the errors in this category \nas possibly benign. Allocations in the unknown category represent about half of the allocations in our \nbenchmarks. These allocations include cells that escape to the heap, to global variables, or to aggregate \nstructures such as arrays. Handling such cases would require more sophisti\u00adcated analyses, such as shape \nanalysis for reasoning about recursive data structures, or array analysis for reasoning about array of \npoint\u00aders to allocated cells. In the future, we envision a re.nement-based tool that .rst uses the lightweight \nvalue-.ow analysis in this pa\u00adper to check the simpler cases, and subsequently uses more heavy\u00adweight \nanalyses for the allocations in the unknown category. /* file \"c-aux-info.c\" */ 53: char* concat (char* \ns1, char* s2) { 54: if (!s1) s1 = \"\"; 55: if (!s2) s2 = \"\"; 56: int size1 = strlen (s1); 57: int size2 \n= strlen (s2); 58: char* ret_val = malloc (size1 + size2 + 1); 59: strcpy (ret_val, s1); 60: strcpy (&#38;ret_val[size1], \ns2); 61: return ret_val; 62: } ... ... 281: char* gen_formal_list_for_func_def(tree fdecl) { 282: char* \nf_list = \"\"; ... ... 290: while (fdecl) { 291: if (...) 292: f_list = concat(f_list, \",\"); 293: f_list \n= concat(f_list, formal); ... ... 302: } 303: return f_list; 304: } Figure 7. Example bug from gcc: the \ncell pointed by f list is leaked on subsequent calls to concat.  6.3 Memory Leak Examples We discuss \ntwo example memory leaks from gcc and bash in more detail. The code for these examples is slightly reformatted \nfor clarity purposes. 6.3.1 Allocation Never Freed About 20 of the messages in gcc referred to string \nbuffers that were never freed. Our tool reported messages of the form: Error: \"c-aux-info.c\", line 292: \nallocation never freed: f_list = concat(f_list, \", \"); Figure 7 presents the actual code for concat \nextracted from gcc. The code allocates a new string containing the concatenation of the input strings. \nHence, concat is an allocator function. The lower portion of Figure 7 shows a function gen formal list \nfor func that generates a string containing the list of formal arguments of a function declaration. The \ncode uses concat to concatenate strings and stores the intermediate results in f list. The fresh cell \nallocated by the call to concat at line 292 is leaked when the subsequent assignment at line 293 overwrites \nf list. 6.3.2 Conditional Leak Bug Figure 8 presents a code fragment from bash where a conditional leak \noccurs. There are two possible deallocation sites for the cell allocated at line 354: at line 360, when \nrl translate keyseq() returns a non-zero value; and at the end of the program, at line 427. The program \nleaks this cell when returning at line 371. The guarded .ow graph generated by the analysis is presented \non Figure 8. The special variable c359 denotes the result of rl translate keyseq() at line 359. The condition \non the right edge of the graph describes the program path to the free at line 427. Finally, the error \nmessage shown below the graph presents one in\u00adstantiation of program conditions that reaches the error \nline 371. This line is reached when the program enter the loop at line 366, and one of the conditions \nat line 370 is true. Tool Size KLOC Speed KLOC/s Bug Count FP (%) Saturn [21] Clouseau [11, 12] Contradiction \n[14] Shape analysis [10] 6822 1086 321 68 0.05 0.5 0.3 0.6 455 409 26 38 10% 64% 56% 60% This analysis \n671 37.9 63 14% Figure 9. Comparison with other memory leak detectors. Program Sites Total checked checks \nammp 2 6 mesa 5 14 bash 14 165 sshd 28 48 Table 2. Total double-free checks performed. No checks were \nperformed in the other programs.  6.4 Comparison to Other Tools Figure 9 presents a comparison of our \nmemory leak analysis to other published tools. The Speed column indicates the number of analyzed lines \nof code per second; and the FP column shows the false positive ratio. We want to emphasize that speed \nnumbers should be regarded only as rough estimates, since these tools have been implemented in different \nlanguages (C and Java), executed on different machines, and applied to different benchmarks. The table \nshows that our analysis provides a good trade-off between speed, and effectiveness of .nding errors with \na low rate of false warnings. 6.5 Double-Frees Study We have also tested allocations in our benchmarks \nfor double\u00adfrees. Tests were performed only for allocations that .ow into more than one free; in this \ncase, each pair of frees was tested using our boolean satis.ability procedure. Allocations with zero \nor one free were not tested. This may be unsound in the presence of loops, as a single cell could be \ndeallocated multiple times at the same point, on different loop iterations. Table 2 shows the number \nof checked allocations and the total number of tests performed. Most sites in sshd have exactly 2 frees, \nhence only one test per allocation is needed. In contrast, one site in bash is freed at 9 different locations, \nyielding 36 double-free tests. The tool correctly reported that none of the tested sites was double-freed. \n 6.6 Function Behavior Study We also evaluated the distribution of functions that are allocation and \ndeallocation wrappers. Free wrappers are functions that deal\u00adlocate a value supplied in an argument. \nTable 3 presents the results. Overall, very few functions are marked as wrappers. This indicates that \nlocal cells are typically allocated and freed in the same func\u00adtion, unless the allocated cell is stored \nin a non local expression. On average, only 1.8% of the functions are considered allocators, and less \nthan 0.1% are considered deallocation wrappers. Table 3 also shows the number of source nodes that are \ncalls to allocation wrappers. Some benchmarks such as perlbmk allocate most of their data using allocation \nwrappers. Finally, some of the applications use custom memory allocation. For instance, parser allocates \na large block at the beginning and manages the block internally. Our tool is not aimed at recognizing \ncustom functions that provide the malloc-free functionality. For parser, our tool analyzes one single \nallocation site. /* file \"bind.c\" */ 338: int rl_generic_bind(...) { ... ... 354: keys = (char *) xmalloc \n(...); ... ... 359: if (rl_translate_keyseq (...)) { 360: free (keys); 361: return -1; 362: } ... ... \n366: for (i = 0; i < keys_len; i++) { 367: unsigned char uc = keys[i]; 368: int ic; 369: ic = uc; 370: \nif (ic < 0 || ic >= KM_SIZE) 371: return -1; ... ... 426: } 427: free(keys); 428: return 0; 429: } keys=malloc() \nbind.c line 354 c359 [ !c359 . !(i < keys len) ] . free(keys) [ !c359 . (i < keys len) . bind.c line \n359 !(ic < 0) . !(ic >= KM SIZE) ] free(keys) bind.c line 427 Error: \"bind.c\", line 354: allocation \nleaks memory keys = xmalloc(...); Leak path: ! c359 bind.c, line 359 i < keys_len bind.c, line 366 ic \n< 0 bind.c, line 370 Figure 8. Warning from bash: cell allocated at line 354 is leaked at line 371. \nAnalysis generates message which includes the affected source code and relevant slice of the guarded \nVFG. Program Total Alloc Free Func. Wrappers Allocation Calls to Sites Allocators ammp 197 0 0 37 0 art \n44 0 0 11 0 bzip2 92 0 0 10 0 crafty 127 0 0 12 0 equake 45 0 0 29 0 gap 872 0 0 2 0 gcc 2271 13 1 53 \n73 gzip 128 0 0 5 0 mcf 44 0 0 3 0 mesa 1124 22 2 67 66 parser 342 0 0 1 0 perlbmk 1094 20 1 4 317 twolf \n209 6 2 2 183 vortex 941 0 0 9 0 vpr 290 17 6 2 155 bash sshd 2200 41 0 940 60 4 141 135 118 336 Table \n3. Wrapper functions and distribution of source nodes.  7. Related Work In recent years there has been \na large body of research devoted to checking safety properties. We classify the related work into .ow\u00adsensitive \nand .ow-insensitive approaches, and restrict the discus\u00adsion to the techniques that are most relevant \nto our work. Flow-sensitive Safety Checking. A standard approach to safety checking is to describe the \ndesired safety property as a .nite state machine, and then perform a .ow-sensitive analysis of the program \nto track the current state at each program point, and detect viola\u00adtions as transitions to the error \nstate. There are many existing sys\u00adtems that implement this approach, either using data.ow analysis, \nas Metal [7] or ESP [5]; or using model checking, as SLAM [2] or [22]. These approaches are generic, \nmeaning that they allow users to specify arbitrary state machines. The analyzer then uses a generic data.ow \nengine to check for property violations. The .ow\u00adsensitive state tracking process can be enhanced in \nmany ways, for instance using context-sensitive inter-procedural analysis, using path-sensitive analysis \n[5], or predicate re.nement [2]. These tools can be used to check for memory leaks by instantiating the \nstate machine with a machine consisting of two states, and transitions from the .rst to the second on \nallocation, and from the second to the .rst on deallocation. In contrast to the data.ow approaches, our \nanalysis reasons about heap violations using a sparse value-.ow graph representation, not by walking \nthe control-.ow graph. The use of data.ow analysis in our system is restricted only to identify\u00ading de.nition-use \nchains and to the demand-driven computation of guards (essentially a mini-data.ow analysis between two \nprogram points). In addition to the above techniques, several tools have been speci.cally developed for \n.nding heap errors such as memory leaks, or accesses through dangling pointers. Clouseau [11, 12] is \na leak detection tool that uses a notion of pointer ownership to de\u00adscribe those variables responsible \nfor freeing heap cells, and for\u00admulate the analysis as an ownership constraint system. Saturn [21] reduces \nthe problem of memory leak detection to a Boolean satis\u00ad.ability problem, and then use a SAT-solver to \nidentify potential errors. Both Saturn and Clouseau are essentially constraint formu\u00adlations of a data.ow \nanalysis problem: they encode the data.ow transfer functions as constraints in their system. A complication \nin these systems is that it becomes more dif.cult to map constraint system violations back to the program \ncode, and report errors that can be easily understood by the programmers. None of the above techniques \nis capable of reasoning about leaks and other heap errors in recursive data structures, such as lists \nor trees. Shape analysis refers to the class of data.ow anal\u00adyses that use more advanced heap abstractions \nand are capable of reasoning about individual heap cells in recursive structures. Dor and Sagiv [6] use \nTVLA, a shape analysis tool based on 3-valued logic, to prove the absence of memory leaks and other memory \ner\u00adrors in several list manipulation routines. However, TVLA has not been used for error detection in \nlarger programs. Hackett and Rug\u00adina [10] use a shape analysis that tracks single heap cells to identify \nmemory leaks. More recently, Orlovich and Rugina [14] have pro\u00adposed a novel approach to memory leak \ndetection where the analy\u00adsis assumes the presence of errors and then performs a backward data.ow analysis \nto disprove their feasibility. The analysis pre\u00adsented in this paper is not designed to reason about \nmanipulation of recursive structures; it trades this imprecision for the ef.cient detection and reporting \nof heap errors in non-recursive structures. Flow-insensitive Safety Checking Flow-insensitive analyses \ndis\u00adcard the control-.ow in the program and treat the program as a set of assignments that can be performed \nin any order. Such analy\u00adses are simpler and more ef.cient, but less precise than their .ow\u00adsensitive \ncounterparts. Common examples of .ow-insensitive anal\u00adyses are type-based analyses and .ow-insensitive \npointer analyses. A standard procedure is to compute de.nition-use chains, as the analysis in this paper, \nor an SSA representation[4] of the program before treating program assignments in a .ow-insensitive manner, \nthus recovering a certain amount of .ow-sensitivity. For the pur\u00adpose of this discussion, we still classify \nthem as .ow-insensitive. The CQual system [8] is a system that infers type quali.ers in C programs using \na set-constraint formulation. The system can be used to perform tainting analysis, i.e., to determine \nthat a value from a tainted source (such as reading data from the network) never .ows into a sink that \nmust not be tainted (such as a critical kernel structure). Livshits and Lam [13] propose a similar tainting \nanalysis, but using an augmented SSA form called IPSSA. Both analyses are context-sensitive; in addition, \nthe latter analysis uses a guarded SSA form [19] that annotates value-.ow edges at .\u00adnodes with branch \nconditions. The tainting analysis problem is a source-not-sink problem, aiming at checking that source \nvalues never .ow into a sink. This is a fundamentally different than the source-sink problem discussed \nin this paper, and none of the above approaches can be used for the memory leak problem. This is because \ntheir value-.ow representation is not powerful enough to determine that a source value .ows into the \nsink on all paths. Although in the system of Livshits and Lam, value-.ow edges of .\u00adnodes are tagged \nwith branch conditions, the .ows via assignments are not, therefore their analysis cannot solve source-sink \nproblems. For instance, the examples from Section 3 do not contain .-nodes from the source allocations \nto sink frees, hence none of these value\u00ad.ows would be guarded. Snelting et al. [17] present a tainting \nanalysis based on value\u00ad.ows using a program dependence graph (PDG) structure. They also annotate value \n.ows in the dependence graph using path con\u00additions. However, they use path conditions to improve the \nprecision for a source-no-sink problem. In contrast, we use path conditions to solve source-sink problems \nsuch as memory leak detection. 8. Conclusions We have presented a new analysis for detecting memory \nleaks. The analysis uses a sparse representation of the program in the form of a value-.ow graph. The \nanalysis reasons about program behavior on all paths by computing guards for the relevant value-.ow edges. \nThe approach makes the analysis ef.cient, and allows it to generate concise, easy-to-understand error \nmessages.  References [1] Thomas Ball, Rupak Majumdar, Todd Millstein, and Sriram K. Rajamani. Automatic \npredicate abstraction of C programs. In Proceedings of the ACM Conference on Program Language Design \nand Implementation, Snowbird, Utah, June 2001. [2] Thomas Ball and Sriram K. Rajamani. The SLAM project: \ndebugging system software via static analysis. In Proceedings of the ACM Symposium on the Principles \nof Programming Languages, Portland, OR, January 2002. [3] Daniel Le Berre and Anne Parrain. SAT4J: A \nsatis.ability library for java. URL: http://www.sat4j.org/. [4] Ron Cytron, Jeanne Ferrante, Barry Rosen, \nMark Wegman, and F. Kenneth Zadeck. An ef.cient method of computing static single assignment form. In \nProceedings of the ACM Symposium on the Principles of Programming Languages, Austin, TX, June 1989. [5] \nManuvir Das, Sorin Lerner, and Mark Seigle. ESP: Path-sensitive program veri.cation in polynomial time. \nIn Proceedings of the ACM Conference on Program Language Design and Implementation, Berlin, Germany, \nJune 2002. [6] Nurit Dor, Michael Rodeh, and Mooly Sagiv. Checking cleanness in linked lists. In Proceedings \nof the International Static Analysis Symposium, Santa Barbara, CA, July 2000. [7] Dawson Engler, Benjamin \nChelf, Andy Chou, and Seth Hallem. Checking system rules using system-speci.c, programmer-written compiler \nextensions. In Proceedings of the Symposium on Operating System Design and Implementation, San Diego, \nCA, October 2000. [8] Jeffrey S. Foster, Robert Johnson, John Kodumal, and Alex Aiken. Flow-insensitive \ntype quali.ers. ACM Transactions on Programming Languages and Systems, 28(6):1035 1087, November 2006. \n[9] Emden R. Gansner and Stephen C. North. An open graph visualization system and its applications to \nsoftware engineering. Software Practice and Experience, 30(11):1203 1233, 2000. [10] Brian Hackett \nand Radu Rugina. Shape analysis with tracked locations. In Proceedings of the ACM Symposium on the Principles \nof Programming Languages, Long Beach, CA, January 2005. [11] David L. Heine and Monica S. Lam. A practical \n.ow-sensitive and context-sensitive C and C++ memory leak detector. In Proceedings of the ACM Conference \non Program Language Design and Implementation, San Diego, CA, June 2003. [12] David L. Heine and Monica \nS. Lam. Static detection of leaks in polymorphic containers. In Proceeding of the International Conference \non Software Engineering, Shanghai, China, May 2006. [13] V. Benjamin Livshits and Monica S. Lam. Tracking \npointers with path and context sensitivity for bug detection in C programs. In ACM SIGSOFT Symposium \non the Foundations of Software Engineering, Helsinki, Finland, September 2003. [14] Maksim Orlovich and \nRadu Rugina. Memory leak analysis by contradition. In Proceedings of the International Static Analysis \nSymposium, Seoul, Korea, August 2006. [15] Thomas Reps, Susan Horowitz, and Mooly Sagiv. Precise interproce\u00addural \ndata.ow analysis via graph reachability. In Proceedings of the ACM Symposium on the Principles of Programming \nLanguages,San Francisco, CA, January 1995. [16] Radu Rugina, Maksim Orlovich, and Xin Zheng. Crystal: \nA program analysis system for C. URL: http://www.cs.cornell.edu/projects/crystal. [17] Gregor Snelting, \nTorsten Robschink, and Jens Krinke. Ef.cient path conditions in dependence graphs for software safety \nanalysis. ACM Transactions on Software Engineering and Methodology, 15(4):410 457, October 2006. [18] \nBjarne Steensgaard. Points-to analysis in almost linear time. In Proceedings of the ACM Symposium on \nthe Principles of Programming Languages, St. Petersburg Beach, FL, January 1996. [19] Peng Tu and David \nPadua. Ef.cient building and placing of gating functions. In Proceedings of the ACM Conference on Program \nLanguage Design and Implementation, La Jolla, CA, June 1995. [20] Joseph Uniejewski. SPEC Benchmark Suite: \nDesigned for today s advanced systems. SPEC Newsletter Volume 1, Issue 1, SPEC, Fall 1989. [21] Yichen \nXie and Alex Aiken. Context-and path-sensitive memory leak detection. In ACM SIGSOFT Symposium on the \nFoundations of Software Engineering, Lisbon, Portugal, September 2005. [22] Junfeng Yang, Paul Twohey, \nDawson Engler, and Madanlal Musu\u00advathi. Using model checking to .nd serious .le system errors. In Proceedings \nof the Symposium on Operating System Design and Implementation, San Francisco, CA, December 2004. \n\t\t\t", "proc_id": "1250734", "abstract": "<p>This paper presents a practical inter-procedural analysis algorithm for detecting memory leaks in C programs. Our algorithm tracks the flow of values from allocation points to deallocation points using a sparse representation of the program consisting of a value flow graph that captures def-use relations and value flows via program assignments. Edges in the graph are annotated with guards that describe branch conditions in the program. The memory leak analysis is reduced to a reachability problem over the guarded value flowgraph. Our implemented tool has been effective at detecting more than 60 memory leaks in the SPEC2000 benchmarks and in two open-source applications, bash and sshd, while keeping the false positive rate below 20%. The sparse program representation makes the tool efficient in practice, and allows it to report concise error messages.</p>", "authors": [{"name": "Sigmund Cherem", "author_profile_id": "81100413343", "affiliation": "Cornell University, Ithaca, NY", "person_id": "P699724", "email_address": "", "orcid_id": ""}, {"name": "Lonnie Princehouse", "author_profile_id": "81331502017", "affiliation": "Cornell University, Ithaca, NY", "person_id": "P871682", "email_address": "", "orcid_id": ""}, {"name": "Radu Rugina", "author_profile_id": "81100094619", "affiliation": "Cornell University, Ithaca, NY", "person_id": "P237448", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250789", "year": "2007", "article_id": "1250789", "conference": "PLDI", "title": "Practical memory leak detection using guarded value-flow analysis", "url": "http://dl.acm.org/citation.cfm?id=1250789"}