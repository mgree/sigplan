{"article_publication_date": "06-10-2007", "fulltext": "\n UCC: Update-Conscious Compilation for Energy Ef.ciency in Wireless Sensor Networks Weijia Li Youtao \nZhang Jun Yang Jiang Zheng Computer Science Department, University of Pittsburgh, Pittsburgh PA 15260 \n{weijiali,zhangyt, jzheng}@cs.pitt.edu, junyang@engr.pitt.edu Abstract Wireless sensor networks (WSN), \ncomposed of a large number of low-cost, battery-powered sensors, have recently emerged as promising computing \nplatforms for many non-traditional applica\u00adtions. The preloaded code on remote sensors often needs to \nbe up\u00addated after deployment in order for the WSN to adapt to the chang\u00ading demands from the users. Post-deployment \ncode dissemination is challenging as the data are transmitted via battery-powered wire\u00adless communication. \nRecent studies show that the energy for send\u00ading a single bit is about the same as executing 1000 instructions \nin a WSN. Therefore it is important to achieve energy ef.ciency in code dissemination. In this paper, \nwe propose novel update-conscious compila\u00adtion (UCC) techniques for energy-ef.cient code dissemination \nin WSNs. An update-conscious compiler, when compiling the modi\u00ad.ed code, includes the compilation decisions \nthat were made when generating the old binary. The compiler employs a detailed energy model and strives \nto match the old decisions for a more energy\u00adef.cient result. In most cases, matching the previous decisions \nimproves the binary code similarity, reduces the amount of data to be transmitted to remote sensors, \nand thus, consumes less energy. In this paper, we develop update-conscious register allocation and data \nlayout algorithms. Our experimental results show that they can achieve great improvements over the traditional, \nupdate-oblivious approaches. Categories and Subject Descriptors D.3.4 [Programming Lan\u00adguages]: Processors \nCompilers; C.2.3 [Network Operations]: Network Management Reprogramming General Terms Design, Languages, \nPerformance Keywords Register allocation, Sensor networks, Code dissemina\u00adtion 1. Introduction The wireless \nsensor network (WSN) [3, 13, 14] has recently emerged as a promising computing platform for many nontradi\u00adtional \napplications such as wild.re monitoring in forests, and intel\u00adligence surveillance in the battle .eld. \nA WSN usually consists of hundreds or thousands of low-cost, battery-powered sensor nodes Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 07 June 11 \n13, 2007, San Diego, California, USA. Copyright c &#38;#169; 2007 ACM 978-1-59593-633-2/07/0006. . . \n$5.00 that are preloaded with application code and data, and then de\u00adployed into the .eld to track events \nof interest. Sensing results are constructed into data packets, and routed back to a sink node which \nis typically more powerful, user accessible and has few energy con\u00adstraints. In contrast, the sensor \nnodes are usually left unattended after deployment, so they are extremely energy and storage con\u00adstrained. \nOf all constraints in a WSN, the energy constraint is more predominant and largely determines the lifetime \nof the network. Due to the changes of user requirements and environmental con\u00additions, the preloaded \nprogram code and data on wireless sensors often need to be updated. For example, a WSN may be deployed \nin a .eld where there is limited familiarity of, e.g., deep ocean or wild nature. In those environments, \npeople .rst collect and analyze the .eld data and then develop more effective sensing functions to process \nmore interesting and important phenomena. Such func\u00adtions are often missing in the preloaded code. A \nWSN can also be deployed inside a building to detect water damage, sound propa\u00adgation, earthquake damage, \netc. Preloading all functions into the sensors is infeasible due to their limited memory sizes. In addition, \nit may also be infeasible to deploy a new WSN for every new task. Hence, reprogramming sensors on demand \nis more economical and practical [20]. Since sensor nodes are left unattended (or even become un\u00adreachable) \nafter deployment, reprogramming can only be done through wireless communication which is expensive in \nterms of energy consumption. For large WSNs where the sink cannot reach every node through broadcasting, \nupdates can only be transmitted hop-by-hop within the WSN, consuming signi.cant energy. Re\u00adcent studies \nhave shown that sending a single bit of data consumes about the same energy as executing 1000 instructions \n[29, 28]. As a result, it is essential to conserve the energy in a WSN during the code and data dissemination, \nespecially when the update happens frequently. The current code dissemination approaches can be categorized \naccording to what is to be transmitted over the network. The sim\u00adplest solution, employed by XNP (the \ndefault code distribution scheme in TinyOS[31]), is to transmit the complete updated binary code to replace \nthe old version on sensors. Another approach the diff-based design compares the code of successive \nversions and generates an edit script that summarizes the difference. Only the script is transmitted \nto the remote sensor where the new code is re-generated from both the old image and the edit script. \nSince less data is transmitted over the network, and the edit script is usually simple and can be easily \ninterpreted by the sensor, the diff-based approach signi.cantly improves energy-ef.ciency and has become \nmore popular in WSNs [28, 25, 12, 23, 16, 7]. Code can also be disseminated at different levels. Some \nrecent work introduced a small virtual machine [20] or a dynamic linker [7, 16] on remote sensors. Instead \nof binary instructions, the code is represented at a higher level, e.g., virtual machine primitives, \nwhich can minimize the code difference in many cases. The tradeoff is that such approaches introduce \nhigh runtime overhead and may consume more energy in the long run. Though the concept of incremental \nupdate was incorporated in the above approaches, the code differences are derived from bina\u00adries generated \nusing the conventional compiler s code generation methods, with possibly some optimizations. Therefore, \na simple change in the source code may result in many changes in the .\u00adnal binary. This has limited the \ndiff-based approaches to only small updates such as .xing a bug [28]. In this paper, we propose update-conscious \ncompilation (UCC) techniques that target at improving the code similarity between the binary code and \nits previous version. Speci.cally, we attempt to minimize the instruction differences so that the update \ntransmission over a WSN is greatly reduced. However, this may result in a compromise in code execution \ntime which is a concern since the new code is executed on remote sensors hereafter. We consider this \ntradeoff and generate the new code in a way that the overall energy consumption is reduced in the long \nrun. After generating the new code, the differences are summarized in a small script which is then transmitted \nto the remote sensor. The new code is generated on the remote sensor through interpreting the update \nscript to change the old binary. This concludes the code dissemination process. The remainder of the \npaper is organized as follows. The overview of update-conscious compilation is presented in Sec\u00adtion \n2. We discuss update-conscious register allocation in Sec\u00adtion 3, and update-conscious data allocation \nin Section 4. The ex\u00adperimental results are presented in Section 5. More related work is discussed in \nSection 6. Finally, we conclude this paper in Section 7. 2. Overview The conventional compilation takes \nthe following steps to gener\u00adate a binary code from the source code, as depicted in Figure 1. First, \nthe compiler converts the source code S into an intermediate representation ir. Next, the compiler optimizes \nthe ir for several iterations, and produces the optimized intermediate representation IR. Finally, the \ncode generation stage uses IR to generate the bi\u00adnary code E by applying data allocation, code placement, \nregister allocation, etc. Our proposed update-conscious compilation is performed at the code generation \nstage, i.e. from IR to E. This helps to preserve the performance improvements from the optimization passes. \nIn this paper we focus on the register allocation and data allocation techniques. For clarity, we assume \nthat the optimization passes are independent of register allocation and data allocation, and other optimizations \nwill be investigated in our future work.  S so roeaoode ir intermediatearepresentation R intermediatearepresentationaaoteraoptimization \n E binaryaeeeo tableao raS  Symbolsa itea rea pdatedae rsions aisateeadiooerenoeabet eenaR aandaR Uaisateea \npdateasoript   Figure 1. The sink-side update-aware compilation. i o Figure 2. The sensor-side code \nupdate and execution. When S is updated to S (Figure 1), ir and IR are also updated to ir and IR respectively. \nLet 6 represent the differences be\u00adtween the IR and its previous version IR. With 6, the compiler can \nanalyze and decide how to generate the binary E such that its difference from E, denoted as U, is small. \nThe decision is made by considering the energy gain and cost from transmitting the code to versus executing \nthe code on remote sensors. Finally when E is generated, U is produced and summarized in a script which \nis then disseminated to the sensors. The code update on remote sensors is relatively simple, as il\u00adlustrated \nin Figure 2. The update script U is interpreted locally to change the old binary E to E . Changes may \ninclude insert\u00ading/removing instructions, constant updates, register name replace\u00adment, etc. As a comparison, \nprevious schemes such as code update with virtual machine on sensors [20], or using a dynamic linker \n[7] do not store the executables in sensors. Thus, they tend to introduce much more runtime overhead \nand consume more energy than our binary level update scheme. 2.1 The power model and its application \nin compilation While improving the code similarity is our goal, it is also essential to consider its \nimpact to energy consumption when the code is executed on remote sensors. In general, improved code similarity \nresults in a smaller update script, and thus less transmission energy consumption. In some cases, slightly \nslower code may still have better energy-ef.ciency. For example, it might worth the effort to reduce \nthe update script by one word because the new code is not executed very frequently but very necessary \non the sensors. One can also argue for a counterexample. To achieve a good balance between transmission \nenergy and execution energy, we need to .rst develop a power model for our framework. We select the Mica2 \nMote [34] as our test bed while the tech\u00adniques are applicable to other types of sensors as well. Mica2 \nMote includes a 7.3Mhz CPU, 128KB program .ash memory, 512KB measurement .ash memory, and 4KB con.guration \nEEPROM. It can transmit data at 38.4Kbps. For Mica2 Motes, transmitting a data bit takes more CPU cycles \nand more overhead than execut\u00ading an instruction. In Figure 3, we show the current that the sen\u00adsor draws \nat different operational modes [29]. From these param\u00adeters, prior work [29] showed that for a typical \nbattery capacity of 2700mAH, a Mica2 node that stays active for about 15 minutes per day can last for \nabout one year. In such a sensor network, transmit\u00adting more data adds buffering overhead and increases \nthe possibil\u00adity of signal collision. A recent study showed that for such sensors, transmitting a single \nbit consumes about 1000 times more energy than executing an ALU instruction [28]. Mode Current Mode \n Current CPU active 8.0mA Radio Rx 7 mA CPU idle 3.2mA Tx(+10dB) 21.5mA CPU Standby 216\u00b5A EEPROM read \n6.2mA LEDs 2.2mA EEPROM write 18.4mA Figure 3. The power model for Mica2. Next we collect program execution \npro.les to estimate how often an updated code will be in use. This will help make good update decisions. \nFor example, assume we need to make a decision whether to add one more instruction in the .nal binary \nbut save one instruction word in transmission. It is overall energy-ef.cient only if the new instruction \nis executed in less than 16,000 times (16-bit word width \u00d7 1000). Let us consider another example that \nrequires the knowledge of the target WSN. Typical sensors need to accomplish two types of tasks: data \nprocessing and data transmission. Thus, the correspond\u00ading program code can be categorized into two types \nas well. For large multi-hop WSNs that have thousands of nodes, a data report may jump 70 or more hops \nbefore reaching the sink [35]. An inter\u00adesting event may invoke the data processing code in the originating \nsensor once but the data transmission code 70 times along the path to the sink. As a result, it is more \nenergy-ef.cient to update data processing code with the highest similarity to its previous version, but \nupdate data transmission code with one that consumes the low\u00adest energy (and less similarity to its previous \nversion). 2.2 Disseminating the update To distribute the new code onto remote sensors, the update is \nsummarized in an edit script (U in Figure 2) and then transmitted over the WSN. Such an edit script usually \ncontains several simple update primitives such as copy, insert, replace, and remove. The details of update \nscript and its dissemination may be cou\u00adpled with the network protocol design [11, 17]. The script is \nusu\u00adally divided into a sequence of data packets. These packets may be encrypted and/or authenticated \nfor security protection [18, 8]. The packets may also be grouped so that when remote sensors receive \ngroups out of order, they are still able to perform updates indepen\u00addent of the receiving order. The \ndesign of the script primitives also impacts the size of the script. To facilitate the description of \nour compilation tech\u00adniques, we adopt four update primitives similar to those in prior work [28] insert, \nreplace, copy, and remove. Both the insert and replace primitives have one-byte opcode and n bytes of \ndata/instructions to be incorporated. The copy and remove prim\u00aditives take one byte each and specify \nthe size of old data/instruction block to be copied or removed.  3. Update-conscious Register Allocation \nAs mentioned in the overview, we perform update-conscious com\u00adpilation in the code generation stage which \ntypically involves regis\u00adter allocation, data and code placement. We focus on the former two tasks in \nthis paper and will investigate the code placement problem in our future work. In this section, we discuss \nthe update-conscious register allocation design. We will .rst illustrate our strategy using a motivational \nexample and formulate the update-conscious allocation problem as a mixed integer non-linear programming \nproblem which targets at both per\u00adformance improvement and energy minimization. It is not a linear problem \ndue to the non-linear speci.cations of the update energy consumption. We then discuss how to approximate \nthe non-linear speci.cation using an integer linear programming (ILP) program. The latter can be solved \nmagnitudes times faster than the former for problems of similar sizes. 3.1 Example: register allocation \nand code similarity While the register allocation problem has been well studied with great success in \nthe past two decades [4, 10, 9, 22, 36, 15], no algo\u00adrithm has been proposed to address the update problem \nuncovered in sensor networks. In Figure 4, we illustrate why different regis\u00adter allocation decisions \ncan greatly impact the code similarity, and the update cost. In this example, two variables a and b initially \nhave disjoint live ranges and can be allocated to the same regis\u00adter R1 (Figure 4(a)). Assume a small \ncode change extends b s live (1)a= (1)a=  (1)a= (5) =a+. a:R1 (5)b=a+. a:R1 (5)b=a+.  a:R1 (10) \n=a (10) =a (10) =a . . b:R2 (12)b= (12)b= [movR2,R1]  . b:R2 . (12)b= b:R1 b:R1(15) =b (15) =b . (15) \n=b (a)variablesaandb (b)aandb sliveranges (c)splitb sliverangeand areassignedtouseR1 overlapaftertheupdate \nassignanewregister Figure 4. Allocating different registers for improved energy ef.\u00adciency. range into \na s. If there are enough free registers, a modern register allocator will assign different registers \nto them, as depicted in Fig\u00adure 4(b). Variable b is assigned to a new register R2, resulting in a name \nchange for all the uses in subsequent statements in the state\u00adment range {5,15}. In contrast, an alternative \nupdate-conscious de\u00adcision may allocate b to R2 only for the range {5,11} where R1 is not free, and match \nthe old allocation for the range {12, 15} with one extra mov instruction, as shown in Figure 4(c). By \ncomparing these two solutions, it is clear that while the solution (b) achieves better code quality, \nthe solution (c) results in less update cost. The discrepancy in energy consumption between data transmission \nand instruction execution makes the solution (c) more appealing as it consumes less energy unless the \ncode is very frequently executed, or the update is extremely rare.  3.2 Update-conscious register allocation \nThe basic idea of update-conscious register allocation (UCC-RA) is to retain mostly the old register \nassignments and perform new regis\u00adter allocations to changed and new instructions with preferences to \nthe decisions made by the old register allocator. To achieve this, we .rst identify IR instructions as \nchanged or non-changed , and then group successive instructions of the same type into chunks. A chunk \nis considered as non-changed if (i) all its instructions are not changed, and (ii) the chunk size is \nlarger than K instructions, where K is a predetermined threshold to prevent from overly small chunks. \nOtherwise, it is merged with neighboring chunks to form a changed chunk. Our register allocator then \nallocates registers for each changed chunk, and gradually matches the register assignment, or alloca\u00adtion \ndecisions from both changed and non-changed chunks for se\u00admantic correctness. Decisions for changed chunks \nare made by our UCC-RA while decisions for unchanged chunks are taken from the old code before the update. \nThe two decisions are made con\u00adjointly. If a variable s live range spans across the chunk boundary, from \nchanged to non-changed or vice versa, then the assign\u00adment in the changed chunk gives preference to the \nassignment in the non-changed chunk to maximize the similarity. However, this preference may not always \nbe adopted by the allocator. If the allo\u00adcator decides to use a new register in the changed chunk, then \na mov instruction between the two chunks should be inserted to move data between the new and the old \nregisters. Register prefer\u00adence should also be given to the same variables on different control .ow paths \n(they might be of different chunk types). However, if the allocator chooses a different register, then \na mov instruction is also necessary. Clearly, placing too many inter-register movement instructions requires \nnot only transmitting more update data to remote sensors but also executing more instructions at runtime. \nTherefore it is desirable to develop a precise cost-bene.t model such that an inter\u00adregister movement \ninstruction is inserted only if it is estimated to be energy-ef.cient. (1)a= (2)b= (6) =a+b (9) =b \n mov register memory mov register memory graph graph graph graph graph graph (a)acodechunk (b)atadefinitionpoint(statement(1) \n(c)atausepoint(statement(6)  Figure 5. Decision variables. Preferred-register tag. In UCC-RA, we tag \neach variable in an unchanged IR instruction with the register name that was assigned in the old binary. \nA preferred-register tag is a hint to improving code similarity in UCC-RA.  3.3 Formalizing the update-conscious \nregister allocation Motivated by the 0/1 integer linear programming research for reg\u00adister allocation \n[9], we formalize our update-conscious register al\u00adlocation as a non-linear integer programming problem. \nWe use a simple example in Figure 5 to explain our proposed procedure. The code contains several instructions: \nthe .rst two are the de.nitions of variable a and b respectively, while the third one uses both vari\u00adables. \nLet us assume at statement (6), a is dead but b is still alive, and the preferred-registers of a and \nb are R1 and R2 respectively. The decision variables. For the code chunk in Figure 5(a), we .rst introduce \na set of decision variables that represent the register assignments we need to make at each program point. \nFor example, If variable a is allocated to register R1 at statement (1), then we have XR1 =1 and IRi, \nRi =.R1,XRi =0. Here XRi is a def.a.1 def.a.1 def.a.s decision variable to show if variable a is assigned \nto the register Ri at statement s. A decision variable X::can take value 0 or 1, with 1 meaning that \nthe corresponding assertion is true, and 0 otherwise. X XRi =1. (1) def.a.s As another example, if we \ndecided to insert an instruction mov R2 toR3 for b before statement (4), we set XR2 =1, mov.out.b.4 XR3 \n=1, and all other mov decision variables X: mov.in.b.4 mov.:.b.4 as 0. As discussed, such a mov instruction \nmay be inserted to release R2 for other variables, or to match the old assignment of b to R3 after statement \n(4). The following is a full list of decision variables that we used in UCC-RA. When de.ning proper decision \nvariables, we aim to keep their total number small so that the solver takes less time to .nd a solu\u00adtion. \nFor example, we introduce two decision variables X Ri mov.in.a.s and XRi instead of a more intuitive \nXRi:Rj (move a mov.out.a.s mov.a.s from Rj to Ri at statement s) because of the following reason. As\u00adsume \nthere are 31 registers; the one-variable de.nition would intro\u00adduce 31 \u00d7 30 mov decision variables for \neach variable at a program point. This will increase the problem size and slow down the solver. Instead, \nwe decouple the mov s source register from the destination register such that only 31 \u00d7 2 decision variables \nare required. Then, we simply combine correctly the corresponding move-in and mov\u00adout variables to implement \nthe register move. The constraints. With above decision variables, we convert the register allocation \nproblem into a problem of assigning value 0 and 1 to these variables. To ensure that the value assignment \ncan be mapped back to a valid register assignment, these variables are subject to a set of constraints. \nWe .rst de.ne the constraints for variable de.nitions. Each variable should be allocated to one and only \none register at its de.nition point. Thus we have, for each variable a at its de.nition point s, one \nand only one XRi def.a.s can be 1, or, VRi To ensure valid inter-register movements, we de.ne constraints \non mov decision variables as well. Since we may and may not insert a move instruction at a program point; \nand the move-in and move\u00adout decision variables should appear in pairs, we have: X XRi mov.out.a.s < \n1 a/s/Ri variable a / statement s / Register Ri (1:i:31); VRi X XRi X XRi (2) mov.in.a.s = XRi if a is \nmoved from Ri to another register at s; mov.out.a.s VRi VRi mov.out.a.s XRi mov.in.a.s if a is moved \nfrom another register to Ri at s; XRi def.a.s XRi cont.a.s XRi lastUse.a.s XRi use.a.s XRi useCont.a.s \nXRi st.a.s XRi ld.a.s if a is allocated to Ri at its de.nition point s; if a is allocated to Ri after \nits def point s; if a is allocated to Ri at its last use point s and a is dead after s. if a is allocated \nto Ri at s, but not in Ri after s; statement s is not the last use. if a is allocated to Ri at s, and \nis also in Ri after s; statement s is not the last use. if a is spilled from Ri to memory after s; if \na is loaded from memory to Ri before its use At a statement s, variable a may be loaded from the memory, \nor come from inter-register movement. After de.ning the variable, the value in the register may be spilled \nto the memory, or moved to another register, or stay for later use. Thus we have: XRi < XRi st.a.s mov.in.a.s \ndef.a.s + XRi XRi < XRi mov.out.a.s def.a.s XRi < XRi cont.a.s def.a.s + XRi (3) mov.in.a.s For the \ncode spill at a de.nition point, only a store instruction may be possibly generated. Thus, we have: point \ns; < X XRi st.a.s (4) Xmem cont.a.s if the variable is kept in memory after the state-Xmem cont.a.s \n ment s; VRi Etrans We next de.ne the constraints for variable uses. Since we can know if a use is the \nlast use (through backward analysis), Eexe XRi + XRi lastUse.a.s is always exclusive from (XRi use.a.s \nuseCont.a.s). In addition, XRi and XRi are exclusive, and a use use.a.s useCont.a.s should be in a register. \nThe above are speci.ed as: prefer(a, s) the energy consumed to disseminate one instruction in WSN; the \nenergy consumed to execute one instruction. We use the averaged number here and differentiate the memory \naccess (load,store) and ALU instructions in the implementation. the preferred-register for variable a \nat statement s; X XRi freq(s) the execution frequency count of statement s; = 1; or lastUse.a.s VRi \nchg(s) if s is an unchanged IR instruction. chg(s)=1 if s has (XRi + XRi use.a.s useCont.a.s) = 1; (5) \nbeen changed; =0 otherwise; X VRi At a use point, a variable may be located in a register due to its \nuse in the previous instruction, or loaded from the memory, or moved from another register. Depending \non whether it is the last use, we have one of the following two constraints: XRi + XRi + XRi use.a.s \nuseCont.a.s < XRi mov.in.a.s cont.a.(s-1) ld.a.s + XRi XRi + XRi last.a.s < Xcont.a.Ri (s-1) ld.a.s + \nXRi (6) mov.in.a.s Since we only generate load spill, or inter-register movement before the use point, \nwe have: spill(a, Ri, s) if variable a was spilled to Ri/loaded back from Ri at statement s in the old \nbinary; the main goal of many existing allocators. The latter is not neg\u00adligible when a new spill is \ngenerated or an old spill is removed. It is zero for all other cases, i.e. either (1-spill(a, Ri, s))=0 \nor (XRi st.a.s)=0 in the equation (13). For example, if a is spilled to R1 in both new and old binaries, \nthen we have zero transmission cost: ld.a.s + XRi for R1, 1-spill(a,R1,s)=0, XR1 st.a.s=1 ld.a.s + XR1 \nfor Ri(Ri.ld.a.s + XRi =0 =R1), 1-spill(a,Ri,s)=1,XRi st.a.s Echanged IR speci.es the energy consumption \ndue to changed X VRi XRi IR instructions. It includes both the execution and the dissemination ld.a.s \n< Xmem cont.a.(s-1) energy consumption as well. As we can see, no matter which X VRi XRi register allocator \nis used, a changed IR instruction always results in mov.out.a.s < XRi (7) cont.a.(s-1) a binary instruction \nthat should be disseminated to remote sensors. To ensure that each register holds one variable at a time, \nwe specify, for example, the following constraints at statement (1) and (6) in Figure 5: XRi cont.a.1 \n+ XRi def.b.2 < 1 XRi (8) lastUse.a.6 + XRi useCont.b.6 < 1 use.b.6 + XRi For Mica2 micro controllers, \nwe need to enforce another type of constraint. Each register in Mica2 has 8 bits, i.e. one byte. A 32-bit \ninteger variable should be allocated to four consecutive registers, i.e., byte a, a+1, a+2, and a+3 should \nbe in register Ri, Ri+1, Ri+2, and Ri+3 respectively: XRi Ri+1 = X use.(a).s use.(a+1).s XRi Ri+1 = X \nuse.(a+1).s use.(a+2).s XRi Ri+1 = X (9) use.(a+2).s use.(a+3).s At the boundary of changed and unchanged \ncode chunks, and at the merge point of control .ows, we insert inter-register move instructions to make \nsure that the values are in proper registers before their next uses. In our future work, instead of performing \ninter-register movements, we will introduce constraints similar to those in [9] for the merge point of \ncontrol .ows. The objective function. The goal of our integer programming is to minimize the objective \nfunction on total energy consumption, as expressed in equation (10) in Figure 6. The equation de.nes \nthe total energy consumption of the changed IR chunk under different register allocation decisions. The \nnotations used in equation (10) are listed in the right column. Other terms are explained as follows. \nEspill speci.es the energy consumption due to code spill. It in\u00adcludes two components: the execution \nenergy and the dissemina\u00adtion energy. The former has to do with the code quality which is Therefore Echanged \nIR is a constant in the model. Eunchanged IR speci.es the energy consumption due to un\u00adchanged IR instructions. \nAssume we have an unchanged IR instruc\u00adtion a=a+b and a and b s preferred-registers are R1 and R2 re\u00adspectively. \nIf the new allocation decision follows the old allocation scheme, then there is no dissemination cost, \ni.e. the same binary instruction add R1, R2 is generated. If a is assigned to a differ\u00adent register, \nsay R3, and we generate add R3, R2 , then this new instruction needs to be disseminated to replace the \nold one on the sensor. As shown in equation (12), this component is non-linear \u00adone Etrans is introduced \nfor either one or two changes of the two preferred registers. Eextra is the extra energy consumption \ndue to inserted inter\u00adregister movements. This term is zero if a traditional compiler decision is used. \nOur UCC-RA targets at achieving overall energy ef.ciency, i.e. Eextra is positive only when we can gain \nmore reduction from other components, e.g. Eunchanged IR. In the above model, X:: are decision variables \nthat need to be determined by the UCC-RA, while others such as chg(s), freq(s), etc. are known for a \ngiven code chunk. Since equation (12) is non-linear, the above formulation of UCC-RA results in a mixed \ninteger non-linear programming problem (MINLP) [24]. While the speed of MINLP solvers has been improved \ngreatly in recent years [24], it is still much slower than solving a linear problem. Our experiments \nresults show that MINLP can be orders of magnitude slower than a linear problem of similar sizes, i.e., \nsimilar number of decision variables and constraint. We next discuss how to convert the MINLP problem \nto an ILP problem through approximation.  3.4 Solving an ILP problem In this section we model the update \nenergy consumption linearly such that the UCC-RA can be solved using an ILP solver. For an unchanged \nIR instruction with two variables a and b (to comply with Mica2 AVR ISA, each IR instruction in our model \nhas at most two different operands). Assume their preferred registers are R1 and R2 respectively, we \nmodel the energy consumption as Etotal = Echanged IR + Eunchanged IR + Espill + Eextra (10) where Echanged \nIR = (chg(s) \u00d7 freq(s) \u00d7 Eexe)+ X (chg(s) \u00d7 Etrans) (11) Vs Vs X ((1 - chg(s)) \u00d7 freq(s) \u00d7 Eexe)+ X \n ((1 - chg(s)) \u00d7 (1 - Y prefer(a,s) ) \u00d7 Etrans) (12) Eunchanged IR = X def/use.a.s Vs Vs Va X + XRi \n(freq(s) \u00d7 (XRi st.a.s ld.a.s ) \u00d7 Eexe)+ X ((1 - spill(a, Ri, s)) \u00d7 (XRi ) \u00d7 Etrans) (13) st.a.s ld.a.s \n+ XRi Espill =Vs,a,Ri Vs,a,Ri X (freq(s) \u00d7 XRi mov.in.a.s \u00d7 Eexe)+ X (XRi (14) mov.in.a.s \u00d7 Etrans) \nEextra =Vs,a,Ri Va,s,Ri Figure 6. The objective function. change the program code because of the relocated \nvariables. The second option incurs less code changes but leaves holes in the ((1 - chg(s)) \u00d7 ((1 - XR1 \n) + (1 - XR2 ))) \u00d7 Etrans \u00d7 use.a...use.b... data segments at runtime. As a hybrid of these two options, \nour X Vs (15) where 8 =3/4, a coef.cient that approximates the update cost. It is decided as follows. \nAssume each variable has equal opportunity of being assigned and not assigned to its preferred register. \nFor the instruction with two variables a and b and preferred registers R1 and R2 respectively, there \nare four possibilities altogether: (i) a is in R1, b is in R2; (ii) a is in R1, b is not in R2; (iii) \na is not in R1, b is in R2; (iv) a is not in R1, b is not in R2. It is clear that case (i) has no update \ncost while each of other three cases needs to update one instruction. Therefore the averaged update cost \nis (3/4) \u00d7 Costsingle, which decides 8 to be 3/4. After converting the model into an ILP problem, we \nadopt a widely used ILP solver LP solve [2] to .nd the optimal assignment of decision variables such \nthat the cost (modeled in the objective cost function) is minimized. We then map decision variables back \nto register assignments, and generate the code and the corresponding update script as well.  4. Update-conscious \ndata allocation In addition to register allocation schemes, the data allocation strat\u00adegy can also affect \nthe similarity between different versions of code, as illustrated in the example in Figure 7. In the \noriginal code (Figure 7(a)), three variables a, b, and c are allocated with off\u00adset 0, 2, and 4 respectively, \nto a base address. Assume the code is updated by replacing variable a with a constant, and introducing \na new variable d. The existing compiler may generate the data allo\u00adcation scheme as shown in Figure 7(b), \nin which all variables are assigned with new offsets, resulting in three update primitives in the update \nscript. However, an update-conscious algorithm should put the new variable d in a s location, as shown \nin Figure 7(c), re\u00adsulting in only one update primitive in the script. On the other hand, if there was \nno d in the new code and if we did not reclaim the word taken by a, we would waste the word in the data \nsegment or more if the function is recursively invoked. This will increase the memory footprint on remote \nsensors. 4.1 Threshold-based data allocation To address the problem described above, we propose a threshold\u00adbased \ndata allocation mechanism. The intuition is to reuse the space of deleted variables as much as we can. \nIf there are more new variables than deleted ones, we will .rst use up the space of the deleted variables \nand then allocate more space. If there are more deleted variables, then we have two options to choose \nfrom: (i) relocate some old variables; (ii) do not relocate. The .rst option does not waste the space \nresource on sensor node, but it needs to proposed algorithm ensures that the total wasted space is less \nthan a given threshold SpaceT . For ease of illustration, we elaborate on the procedures for variables \nof word type only. The principle can be applied to other data types such as array and composite structures \nsimilarly. First, we collect the following pro.les for each function Pi(i 2 0) in the program. P0 is \na dummy function that contains all global variables. DelVi the total number of deleted variables; NewVi \nthe total number of new variables; Depthi the projected maximal simultaneous instances of Pi; Usagei(a) \nthe usage of variable a in Pi. Second, we gradually allocate new variables within each proce\u00addure Pi \nas follows. We do not remove the deleted variables directly. Instead, we only mark them as deleted variables \nso that their space can be reused by new variables. If NewVi 2 DelVi, we reuse all the space from deleted \nvariables and allocate extra space to satisfy the remaining new variables. If NewVi < DelVi, i.e., new \nvari\u00adables cannot reuse all space of the deleted ones, then we compute that there are Extrai = Deli -NewVi \nnumber of words left to be .lled, and move to the next step. Third, we adjust the data allocation by \nincrementally relocating the last variable in each function. We keep moving the last variable into a \nhole left by a deleted variable, until all the holes are .lled. That is, X Extrai \u00d7 Depthi : SpaceT (16) \nVPi As we have shown in Figure 7, such a move will cause changes in all the instructions that use the \nlast variable. If equation (16) cannot be satis.ed for all procedures, to keep the changes minimum, we \nshould .rst serve those that might demand the most runtime mem\u00adory but have the least number of uses. \nThat is, we should .nd a procedure j such that Depthj Depthi = MAX( )(li, Extrai > 0) (17) Usagej (last) \nUsagei(last) We then relocate the last variable in procedure j to one deleted memory word. By doing so, \nwe can shrink the maximal runtime memory usage by Depthj (as it is the last variable in that proce\u00addure), \nand incur less code changes (as the variable with less usage is selected). We then decrement Extraj and \ncontinue this step until equation (16) is satis.ed. For example in Figure 7, if d is not introduced, \nwe will reuse a s space with c if SpaceT =0, i.e. no wasted space. This will result in an edit script \nwith two primitives to update c and d respectively.      (a) (c) (b) Figure 7. An incremental data \nallocation example ((a)original source and assembly code; (b)new code and the update script; (c)incrementally \ngenerated new code with a smaller update script.) This code still outperforms the default scheme in Figure \n7(b) which requires three update primitives. The data allocation problem may become more complicated \nif it is coupled with code generation where data offset are encoded with instruction types. For example \nsuccessive instructions using post\u00adincrement addressing (PIA) mode will access successive data in memory \nwith implicit address increment between two instructions. If data is relocated, new instructions must \nbe inserted to change the memory access address in the next instruction. Fortunately, we experimented \nwith gcc 3.4.3 compiler and found that the PIA mode is mainly used to access the four bytes of an integer \nvariable and thus is insensitive to the variable relocation. For this reason, we do not consider the \nimpact the PIA mode when relocating the data. If they are used beyond a word boundary, we treat them \nindividually by inserting new addressing instructions.  5. Experiments We have implemented our proposed \nupdate-conscious register allo\u00adcation (UCC-RA) and data allocation (UCC-DA) techniques, and compared \nthem with the results generated by the GNC C compiler (GCC-RA and GCC-DA). In this section, we discuss \nour experi\u00admental settings and present the results on code quality, energy ef.\u00adciency, and compilation \ntime. 5.1 Settings We simulated a sensor network that consists of Mica2 mote nodes [34] running TinyOS \n[31], an open source operating system de\u00adsigned for WSNs. The processor that Mica2 (MPR400CB model) uses \nis the AMTEL AVR micro controller ATmega128L [34]. To compile the code for Mica2, we chose ncc, the \nNesC com\u00adpiler included in TinyOS release, and avr-gcc, the GNU C com\u00adpiler (GCC) re-targeted for AMTEL \nAVR micro controllers. We used -O3 option to compile the code and ensured the code .t in the sensor storage \n(i.e. we considered -Os option as well). We used the default register allocator of the gcc/avr-gcc, for \nusing the new iterative graph allocator (with the option -fnew-ra) would give similar results. We selected \nAvrora, an instruction-level sensor network sim\u00adulator, to collect the execution cycles of the code before \nand after compiling the updated code with UCC and GCC (the accuracy of the simulator has been reported \nin prior work [32]). We then inte\u00adgrated the energy model and execution pro.les to study the energy consumption \ntradeoffs with different compilation approaches.  5.2 Code update benchmark Applications running on \nremote sensors may be updated for vari\u00adous reasons, e.g. bug .xes, code patches, sensor recon.gurations \n Benchmark Blink Source TinyOS Details It starts a 1Hz timer and toggles the red LED every time it .res. \nCntToLeds TinyOS It maintains a counter on a 4Hz timer and displays the lowest three bits of the counter \nvalue. The red LED is the least signi.cant of the bits, while the yellow is the most signi.\u00adcant. CntToRfm \nTinyOS It maintains a counter on a 4Hz timer and sends out the value of the counter in an IntMsg AM packet \non each increment. CntToLeds AndRfm TinyOS It maintains a counter on a 4Hz timer; it com\u00adbines the tasks \nperformed by CntToRfm and CntToLeds. AES Crypto Lib It encrypts a given 128 bit input buffer us\u00ading AES \nalgorithm. We select the encryption code in the experiment. Figure 8. Benchmark programs. for adapting \nto changing environments, and change of applications. A recent study showed that code .xes and sensor \nrecon.gurations happen more often than changing the application completely be\u00adcause the latter is much \nmore costly [7]. We categorize different updates into three types according to their impact on code structures: \n(a) small changes, which are made to local basic blocks; (b) medium changes, which include changes in \na large function or across several functions, but still preserve the overall structure of the original \ncode; (c) large changes, which signi.cantly change the code structure. Frequent updates such as code \n.xes and sensor recon.gurations are mainly small or medium changes, while replacing the application with \na new one introduces medium to large changes. We show our results for all three types of changes in this \nsection. The benchmark programs we used for testing our UCC-RA and UCC-DA are listed in Figure 8. Those \nare from the TinyOS release and the crypto library [6].  5.3 The dissemination cost Figure 9 summarizes \nthe updates that we made to the benchmarks. The updates vary from small, through medium, to large changes, \nas described below: The small and medium test cases cover a wide range of changes including constant \nchanges, variable changes, param\u00adeter changes, instruction changes, and control .ow changes. More complex \nupdates may require one or more such changes. Case Update Update details 500 # Level 1 Small In CntToLeds: \nchange the color of blink.  450 several times in TOSH run next task function. 400 350 300 250 200 150 \n100 50 inst Diff Medium In Blink: insert a global variable and use it in a new if/then branch in TOSH \nrun next task function. Test Case Number 11 Medium In Blink: add an else branch for an if statement in \nTimer HandleFire. 12 Large Change the application from CntToRfms to Cnt- ToLedsRfm 13 Large Change the \napplication from CntToLeds to Cnt- ToRfms. Figure 9. Experimental update details. Complex updates tend \nto create changes over many functions, though most of these test cases impact only one function. To fairly \nevaluate the UCC-RA and decouple its impact from data allocation and code layout, we only report the \nchanges in the functions that are directly affected (rather than, for instance, code shifting due to \nexpansion/shrinkage of neighbor func\u00adtions). In addition, we observed minimal inter-procedural cor\u00adrelation. \nFor example, the same global variable can be assigned with different registers in different functions. \nTherefore the overall impact of large updates can be estimated by summa\u00adrizing the changes in simple \nupdates.  We evaluate the code changes using Diffinst, the number of different instructions between \nthe old and the new binaries. We use Diffinst instead of the edit script size since the latter is  Figure \n10. The code dissemination cost. case 13 represents another type of large changes, the application CntToLeds \nis quite different from CntToRfms. The former has 828 instructions while the latter has 4351 instructions. \nIt is an expensive update since all new instructions and functions have to be disseminated across the \nnetwork. There is some code similarity due to the fact that applications in the same TinyOS environment \nfollow a generic structure. GCC-RA can reuse 422 instructions and need to update 3929 instructions. UCC-RA \ncan reuse 63 more instructions, which represents an increase of 15% from GCC-RA, and accounts for about \n7.6% of the old code (CntToLeds).  5.4 The code quality comparison Next, we compared the code quality \nresulting from different algo\u00adrithms. The code quality is quanti.ed using Diffcycle, the changes in execution \ncycles between the old and new version of the binary. This metric also indicates the slowdown in execution \ntime after ap\u00adplying update-conscious compilation. 180 dependent on other factors such as packing or \ngrouping the code 160 differences in different manners. For example, assume we have two scripts which \ncontain 10 and 11 edit primitives respectively. 140 If one transmission packet can pack 10 edit primitives, \nthe script 120 with 11 primitives needs two packets a 100% increase from the one with 10 primitives \nin terms of the packet number. We .rst conducted experiments to compare the dissemination cost between \nUCC-RA and GCC-RA. For GCC-RA, we manually .nd the best match between the new and the old binaries. This \nis the lower bound of existing binary-diff-based code dissemination algorithms [26, 28]. That is, we \ncompared our results against the best possible implementation of existing update-unconscious ap\u00adproaches \n[26, 28]. Figure 10 shows the results, in Diffinst, for update test cases 1 to 12. As we can see, UCC-RA \ngreatly reduces the code difference as it effectively localizes the code changes the majority of the \ncode can be kept the same. On the contrary, GCC-RA may generate only local changes (test case 1), but \nmay also propagate local changes to a much larger range (test case 4). We then study the two large changes. \nTest case 12 introduces several new functions most of which are small inlined functions. They disturb \nthe register selection in a large function and introduce signi.cant number of differences, which are \nseen when using GCC-RA. Fortunately, those differences are minimized in UCC-RA. Test cycle 100 Diff \n80 60 40 20 0 Test Case Number Figure 11. The performance comparison (single run). Figure 11 shows the \nresults for test case 1 to 12. In most of these cases, UCC-RA and GCC-RA have the same Dif fcycle, i.e. \nthey have the same code quality. This is because both of them can .nd free registers to use, and no extra \nspill code need to be generated. Thus, register con.icts are small. In some cases, e.g., test case 12, \nUCC-RA inserts three mov instructions since by doing so, it can save 406 instruction updates and achieve \noverall energy ef.ciency. The slowdown from applying UCC-RA is negligible in nearly all cases. For example, \nthe three cycles introduced by UCC-RA in test case 12 accounts for less than 0.01% of 244K cycles the \ntotal number of cycles per single run for the application CntToRfm. We study its energy consumption over \na long period after many invocations, in the next section. For test case 13, UCC-RA only uses the preferred \nregister tag as hint when selecting registers. It has the same code quality as the one generated by GCC-RA. \n 5.5 The energy consumption The energy savings per update are calculated as follows. We .rst compute \nDiffenergy (de.ned below), the energy consumption difference (per single run) before and after the code \nupdate. It incorporates the energy consumed in both date transmission and instruction execution. Second, \nwe compute the energy savings per update for GCC-RA and UCC-RA respectively. Diffenergy = (Diffinst \n\u00d7 Etrans + Diffcycle \u00d7 Eexe \u00d7 Cnt) (18) EnergySavings = DiffGCC-RA energy - DiffUCC-RA energy (19) Figure \n12. The energy savings per update with different code execution frequency.  where Cnt is the total number \nof times that the code may be exe\u00adcuted before it retires. A code retires when either it is overwritten \nby a later update or the sensor node has consumed all its battery energy and dies. Figure 12 plots the \nthe energy savings of UCC-RA over GCC-RA as a function of Cnt, which is projected from the execution \npro.les and the code update frequency. Code fragments that reside in a loop, or retire after a long time, \nhave larger Cnts than others. From the .gure, we can see that when UCC-RA and GCC-RA generate the same \nquality code (same Diffcycle, such as for test case 1), the energy savings are independent of Cnt. The \nsavings mainly come from the reduced transmission energy. The larger number of instructions we reduce \nfrom GCC-RA, the less data we need to transmit, and the more savings we gain from UCC-RA. When the code \ngenerated from UCC-RA runs slightly slower than from GCC-RA (e.g., test case 12), extra energy will be \ncon\u00adsumed in instruction execution. This can diminish the transmission energy savings when the code is \nexecuted very frequently. There\u00adfore, our UCC-RA adaptively inserts mov instructions according to execution \npro.les and update frequency. A large Cnt would dis\u00adable the insertion such that UCC-RA and GCC-RA have \nthe same energy consumption in the worst case. For example, UCC-RA falls back to GCC-RA when test case \n12 is executed more than 107 times because of the diminishing energy gain.  5.6 The problem complexity \nand compilation time Since the ILP problem is more complex to solve when the number of instructions and \nvariables increase, we discuss the problem com\u00adplexity in this section. Figure 13 plots the number of \nconstraints as a function of instruction number. We can see that the number of constraints increases \nalmost linearly with the number of IR in\u00adstructions. We plot the number of iterations that the LP solve \n[2] requires as a function of (the number of variables \u00d7 the number of IR instructions) in Figure 14. \nAn interesting observation we found is that the preferred reg\u00adister tag helps to improve the performance. \nComparing to an ILP\u00adbased register allocator which allocates register from scratch, the preferred register \ntag is a hint to the solver and can reduce the num\u00adber of iterations that solver needs to try. As an \nextreme case, we also tested misleading preferred register tags, e.g., variables are as\u00ad 25 101010 Execution \nFrequency signed to the preferred register tag randomly, we found the solver may need 2 or 3 times more \niterations to solve. To see how fast the problem can be solved, we conducted timing experiments on Intel \nXeon 3.6GHz processor running Fedora Linux 2.4.21 kernel. The physical memory size is 2GB while in the \nexperiments, the largest observed memory usage is less than 256 MB. Figure 15 shows that the average \ntime required to solve one iteration increase about linearly with the problem complexity. It usually \ntakes the solver less than 175 seconds to allocate registers for a chunk of 250 IR instructions. As a \ncomparison, it takes GCC-RA less than one second to solve the same problem. While UCC-RA is much slower \nthan GCC-RA, it is not a signi.cant problem for WSNs due to the following reasons: (i) sensor applications \nare small programs limited by the memory size of the sensor node; (ii) UCC-RA is applied only to the \nidenti.ed changed chunks instead of the complete functions or the whole application; (iii) it is worthwhile \nto trade the compilation time at the server side, where both energy and computation power are abundant, \nfor the energy savings on sensor nodes where resources are highly constrained. We also performed experiments \non testing whether approximat\u00ading the original non-linear integer programming problem with a linear problem \ndegraded the .nal results. We observed the same al\u00adlocation decisions for all the test cases with or \nwithout the approx\u00adimation. The only difference is that solving a non-linear problems is orders of magnitude \nslower than a linear problem. 5.7 The update-conscious data allocation Finally, we studied the effectiveness \nof update-conscious data al\u00adlocation. When new global variables are added to a program (test case D1 \nFigure 16), the data layout could change greatly. This could signi.cantly reduce the code similarity \nin the .nal binary. For ex\u00adample, when we added a global variable in CntToLeds, we ob\u00adserved 517 instruction \ndifference which accounts for about 10% of the total instructions. In our second test case D2, we shuf.ed \nthe global variables in the code and changed their names. Interestingly, no code change was observed \nin GCC-RA unless the variable names were changed. This is because the data allocation scheme in gcc hashes \nthe variable into the symbol table using their names. This helps to improve the compilation speed, but \nalso creates dif.culties under the update\u00adconscious requirement. For example, a newly added variable \nmay be allocated to the beginning of the data segment, causing many changes in data layout, even if it \nis de.ned at the end of a function. Similarly, even for functions with few variables, this is dif.cult \nto 4 x 10 8 7 6 5 4 3 2 1 0 0 50 100 150 200 250 Instruction Number Figure 13. The number of constraints \nas a function of number of Constraint Number IR instruction. Case # Update details D1 In CntToRfm: Insert \nseveral global variables. D2 In CntToLEDs: Shuf.e the order of variables and change variable names. \nFigure 16. Data layout update details. attack as the function may be inlined during optimizations. Notice \nthat a name change of a variable is essentially a deletion of the old variable plus an insertion of a \nnew variable. This can be handled naturally by UCC-DA as the new variable always takes the space of a \ndeleted variable. Therefore, the change of variable names can be solved easily with UCC-DA to improve \nthe code similarity.  6. Related Research We have discussed prior research that are closely related \nto our work in the introduction section. Here we focus on the previous work on register allocation in \na traditional compilation framework. In the past twenty years, the register allocation problem has been \nextensively studied with great success in many aspects. Tradi\u00adtional register allocators construct the \ninterference graph of vari\u00adables and solve the global register allocation as a graph color\u00ading problem \n[4, 10, 1, 5]. To achieve fast compilation, linear-scan algorithms assign variables to available registers \nthrough a sim\u00adple scan of the program, instead of constructing the interference graph [27, 33]. It was \nreported that linear-scan allocators gener\u00adate similar code as those from graph coloring-based allocators. \nRe\u00adcently, the optimal or near optimal register allocation was formu\u00adlated and solved through integer \nlinear programming [9] or multi\u00adcommodity network .ows [15]. In addition to achieving better per\u00adformance, \nalgorithms have been proposed to achieve many other objectives. For example, an early work [22] considered \nthe code size constraint in register allocation, and generated compact code for embedded systems. Researchers \nalso [36] exploited differential encoding designs that allow the use of more registers in the pro\u00adgram. \nTo save the compilation time after small code changes, Bivens and Soffa proposed the incremental register \nallocation (IRA) scheme [30] which, similar to UCC, only reallocates registers for Number of Iterations \n12000 10000 8000 6000 4000 2000 0 0 0.5 1 1.5 2 Number of Variables * Number of Instructions 2.5 x 107 \nFigure 14. The number of iterations as a function of (the number of variables \u00d7 the number of IR instructions). \n 0.03 0.025 the changed code while preserving the assignment for unchanged code. The difference is, \nIRA exploits the traditional graph coloring algorithm for the changed code without considering code similar\u00adity \nand energy consumption model. IRA uses a different criteria to identify changed code and it neither performs \ninter-register move\u00adment nor gives register selection priority to preferred-registers. The register assignment \ngenerated from IRA is not update-conscious. 7. Conclusions Time per Iteration 0 0 0.5 1 1.5 2 2.5 Number \nof Variables * Number of Instructions x 107 In this paper, we proposed update-conscious compilation \ntech\u00adniques for achieving energy ef.ciency in wireless sensor networks. We present algorithms on how \nto perform update-conscious data allocation and register allocation. The experimental results showed \ngreat improvements over update-unconscious solutions. In the fu\u00adture, we will extend the update-conscious \ncompilation research to other environments using costly wireless communication, such as cellular phone \nusers in ad-hoc networks.  Acknowledgment This work is partially supported by NSF grants CCF-0541456 \nand CAREER CCF-0641177. We thank Dr. Kim Hazelwood and Figure 15. The time to solve one iteration as \na function of (the anonymous reviewers for their insightful comments for improving number of variables \n\u00d7 the number of IR instructions). the paper. We also thank Dr. Bruce Childers and Mr. Yu Du for the helpful \ndiscussions regarding this work. References [1] Preston Briggs, Keith D. Cooper, and Linda Torczon, \nImprovements to Graph Coloring Register Allocation, ACM Transactions on Programming Languages Systems, \n16(3):428 455, May 1994. [2] Michel Berkelaar et al., LP solve 5.5. [3] Edgar H. Callaway, Jr. Wireless \nSensor Networks: Architectures and Protocols, CRC Press, 2003. [4] Gregory J. Chaitin, Marc A. Auslander, \nAshok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein, Register Allocation via Coloring, \nComputer Languages, 6:45 57, 1981. [5] Frederick Chow, and John Hennessy, Register Allocation by Priority-based \nColoring, ACM SIGPLAN Symposium on Compiler Construction, pages 222 232, 1984. [6] Wei Dai, The Crypto++ \nLibrary, http://www.eskimo.com/ weidai/cryptlib.html . [7] Adam Dunkels, Niclas Finne, Joakim Eriksson, \nand Thiemo Voigt, Run-Time Dynamic Linking for Reprogramming Wireless Sensor Networks, ACM International \nConference on Embedded Networked Sensor Systems (SenSys), pages 15 28, 2006. [8] Prabal K. Dutta, Jonathan \nW. Hui, David C. Chu, and David E. Culler, Securing the Deluge Network Programming System, International \nSymposium on Information Processing in Sensor Networks (IPSN), pages 326 333, 2006. [9] David W. Goodwin, \nand Kent D. Wilken, Optimal and Near\u00adoptimal Global Register Allocations using 0/1 Integer Programming, \nSoftware: Practice and Experience, 26(8):929 965, 1996. [10] Lal George, and Andrew W. Appel, Iterated \nRegister Coalescing, ACM Transactions on Programming Languages and Systems, 18(3):300 324, 1996. [11] \nJonathan W. Hui, and David E. Culler, The Dynamic Behavior of a Data Dissemination Protocol for Network \nProgramming at Scale, ACM International Conference on Embedded Networked Sensor Systems(SenSys), pages \n81 94, 2004. [12] Jaein Jeong, and David E. Culler, Incremental Network Program\u00adming for Wireless Sensors, \nIEEE Sensor and Ad Hoc Communica\u00adtions and Networks (SECON), pages 25 33, 2004. [13] Philo Juang, Hidekazu \nOki, Yong Wang , Margaret Martonosi, Li-Shiuan Peh, and Daniel Rubenstein, Energy Ef.cient Computing \nfor Wildlife Tracking: Design Tradeoffs and Early Experiences with ZebraNet, ACM/IEEE International Conference \non Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 96 107, 2002. \n[14] Joseph M. Kahn, Randy Howard Katz, and Kristofer S. J. Pister, Emerging Challenges: Mobile Networking \nfor Smart Dust Journal of Communications and Networks, 2(3):188 196, 2000. [15] David Ryan Koes, and \nSeth Copen Goldstein, A Global Progressive Register Allocator, ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation (PLDI), pages 204 215, 2006. [16] Joel Koshy, and Raju Pandey, Remote \nIncremental Linking for Energy-Ef.cient Reprogramming of Sensor Networks, European Workshop on Wireless \nSensor Networks, pages 354 365, 2005. [17] Sandeep S.Kulkarni, and Limin Wang, Mnp: Multihop Network \nReprogramming Service for Sensor Networks, International Confer\u00adence on Distributed Computing Systems \n(ICDCS), 2005. [18] P. E. Lanigan, R. Gandhi, and P. Narasimhan, Sluice: Secure Dissemination of Code \nUpdates in Sensor Networks, International Conference on Distributed Computing Systems (ICDCS), 2006. \n[19] Chunho Lee, Miodrag Potkonjak, and William H. Mangione-Smith, MediaBench: A Tool for Evaluating \nand Synthesizing Multimedia and Communications Systems, International Symposium on Microarchitecture \n(MICRO), pages 330 335, 1997. [20] Philip Levis, and David Culler, Mate: A Tiny Virtual Machine for Sensor \nNetworks, International Conference on Architectural Support for Programming Languages and Operating Systems \n(ASPLOS), pages 85 95, 2002. [21] Stan Liao, Srinivas Devadas, Kurt Keutzer, Steven Tjiang, and Alvert \nWang, Storage Assignment to Decrease Code Size, ACM SIGPLAN Conference on Programming Language Design \nand Implementation (PLDI), pages 235 253, 1995. [22] Mayur Naik, and Jens Palsberg, Compiling with Code-size \nCon\u00adstraints, ACM SIGPLAN/SIGBED Conference on Languages, Com\u00adpilers, and Tools for Embedded Systems \n(LCTES), pages 120 129, 2002. [23] Pedro Jose Marron, Matthias Gauger, Andreas Lachenmann, Daniel Minder, \nOlga Saukh, and Kurt Rothermel, FlexCup: A Flexible and Ef.cient Code Update Mechanism for Sensor Networks, \nEuropean Workshop on Wireless Sensor Networks (EWSN), pages 212 227, 2006. [24] Nonlinear Mixed Integer \nProgramming. http://projects.coin\u00ador.org/Bonmin. [25] Rajesh K. Panta, Issa Khalil, and Saurabh Bagchi, \nStream: Low Overhead Wireless Reprogramming for Sensor Networks, IEEE Conference on Computer Communications \n(Infocom), 2007. [26] Carl von Platen, and Johan Eker, Feedback Linking: Optimizing Ob\u00adject Code Layout \nfor Updates, ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES), \npages 2 11, 2006. [27] Massimiliano Poletto, and Vivek Sarkar, Linear Scan Register Allocation, ACM Transactions \non Programming Languages and Systems, 21(5):895 913, 1999. [28] Niels Reijers, and Koen Langendoen, Ef.cient \nCode Distribution in Wireless Sensor Networks, International Workshop on Wireless Sensor Network Architecture, \npages 60 67, 2003. [29] Victor Shnayder, Mark Hempstead, Ror-rong Chen, Geoff Werner Allen, and Matt \nWelsh, Simulating the Power Consumption of Large-Scale Sensor Network Applications, ACM Conference on \nEmbedded Networked Sensor Systems (SenSys), pages 188 200, 2004. [30] Mary P. Bivens, and Mary Lou Soffa, \nIncremental Register Allocation, Software: Practice and Experience, 20(10):1015 1047, 1990. [31] TinyOS. \nhttp://www.tinyos.net/. [32] Ben L. Titzer, Daniel K. Lee, and Jens Palsberg, Avrora: Scalable Sensor \nNetwork Simulation with Precise Timing, International Symposium on Information Processing in Sensor Networks \n(IPSN), pages 477 482, 2005. [33] Omri Traub, Glenn Holloway, and Michael D. Smith, Quality and Speed \nin Linear-scan Register Allocation, ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), pages 142 151, 1998. [34] Mica2 Wireless Measurement System. http://www.xbow.com/. [35] Fan Ye, \nGary Zhong, Songwu Lu, and Lixia Zhang, GRAdient Broadcast: A Robust Data Delivery Protocol for Large \nScale Sens or Networks, ACM Wireless Networks, 11(2):285 298, 2005. [36] Xiaotong Zhuang, and Santosh \nPande, Differential Register alloca\u00adtion, ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), pages 168 179, 2006. \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Wireless sensor networks (WSN), composed of a large number of low-cost, battery-powered sensors, have recently emerged as promising computing platforms for many non-traditional applications. The preloaded code on remote sensors often needs to be updated after deployment in order for the WSN to adapt to the changing demands from the users. Post-deployment code dissemination is challenging as the data are transmitted via battery-powered wireless communication. Recent studies show that the energy for sending a single bit is about the same as executing 1000 instructions in aWSN. Therefore it is important to achieve energy efficiency in code dissemination.</p> <p>In this paper, we propose novel <i>update-conscious compilation(UCC)</i> techniques for energy-efficient code dissemination in WSNs. An update-conscious compiler, when compiling the modified code, includes the compilation decisions that were made when generating the old binary. The compiler employs a detailed energy model and strives to match the old decisions for a more energy-efficient result. In most cases, matching the previous decisions improves the binary code similarity, reduces the amount of data to be transmitted to remote sensors, and thus, consumes less energy. In this paper, we develop update-conscious register allocation and data layout algorithms. Our experimental results show that they can achieve great improvements over the traditional, update-oblivious approaches.</p>", "authors": [{"name": "Weijia Li", "author_profile_id": "81444601804", "affiliation": "University of Pittsburgh, Pittsburgh, PA", "person_id": "PP39067469", "email_address": "", "orcid_id": ""}, {"name": "Youtao Zhang", "author_profile_id": "81100126819", "affiliation": "University of Pittsburgh, Pittsburgh, PA", "person_id": "PP15023478", "email_address": "", "orcid_id": ""}, {"name": "Jun Yang", "author_profile_id": "81408596070", "affiliation": "University of Pittsburgh, Pittsburgh, PA", "person_id": "PP39072889", "email_address": "", "orcid_id": ""}, {"name": "Jiang Zheng", "author_profile_id": "81342517476", "affiliation": "University of Pittsburgh, Pittsburgh, PA", "person_id": "PP39082911", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250778", "year": "2007", "article_id": "1250778", "conference": "PLDI", "title": "UCC: update-conscious compilation for energy efficiency in wireless sensor networks", "url": "http://dl.acm.org/citation.cfm?id=1250778"}