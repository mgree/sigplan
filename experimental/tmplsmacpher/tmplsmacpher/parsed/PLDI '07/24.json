{"article_publication_date": "06-10-2007", "fulltext": "\n Thread-Modular Shape Analysis Alexey Gotsman Josh Berdine University of Cambridge Microsoft Research \nAlexey.Gotsman@cl.cam.ac.uk jjb@microsoft.com  Abstract We present the .rst shape analysis for multithreaded \nprograms that avoids the explicit enumeration of execution-interleavings. Our ap\u00adproach is to automatically \ninfer a resource invariant associated with each lock that describes the part of the heap protected by \nthe lock. This allows us to use a sequential shape analysis on each thread. We show that resource invariants \nof a certain class can be charac\u00adterized as least .xed points and computed via repeated applications \nof shape analysis only on each individual thread. Based on this ap\u00adproach, we have implemented a thread-modular \nshape analysis tool and applied it to concurrent heap-manipulating code from Windows device drivers. \nCategories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; F.3.1 \n[Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Pro\u00adgrams General Terms \nLanguages, Theory, Veri.cation Keywords Abstract interpretation, concurrent programming, shape analysis, \nstatic analysis 1. Introduction The analysis of multithreaded programs is complicated in the con\u00adtext \nof heap-manipulation, in particular, in the presence of deep heap update, which occurs when linked data \nstructures are altered after traversing some a priori unbounded distance. Flow-insensitive analysis for \nsuch programs is too imprecise. Hence, to date, the sound, accurate, and automatic analyses for these \nprograms have implemented .ow-sensitive analyses that rely on enumerating the interleavings of executions \nof threads in the program [26]. This leads to state-space explosion and unscalability. Our goal in this \npaper is to create a shape analysis for programs with deep heap update that is scalable, sound, and accurate. \nWe do so by constructing a shape analysis that avoids enumerating inter\u00adleavings. Our approach is to \ninfer a resource invariant [20, 19] as\u00adsociated with each lock that describes the part of the heap protected \nby the lock and has to be preserved by every thread. E.g., a resource invariant for a lock can state \nthat the lock protects a cyclic doubly\u00adlinked list with a sentinel node pointed to by the variable head.For \n* A part of this work was done while visiting Microsoft Research, Cam\u00adbridge, UK. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 07 June 11 13, 2007, \nSan Diego, California, USA. Copyright c . 2007 ACM 978-1-59593-633-2/07/0006. . . $5.00 Byron Cook Mooly \nSagiv * Microsoft Research Tel-Aviv University bycook@microsoft.com msagiv@post.tau.ac.il any given \nthread, the resource invariant restricts how other threads can interfere with it. If resource invariants \nare known, analyzing a multithreaded program does not require enumerating interleavings and can be done \nusing a sequential shape analysis. The challenge is to infer the resource invariants. A resource invariant \ndescribes two orthogonal kinds of infor\u00admation: it simultaneously carves out the part of the heap protected \nby the lock and de.nes the possible shapes that this part can have during program execution. Hence, informally, \nresource invariants for heap-manipulating programs are not least .xed points of any .rst-order equation. \nWe show that, if we specify the borders of the part of the heap protected by a lock (i.e., the former \nkind of infor\u00admation), then we can characterize the shape of the part (i.e., the latter kind of information) \nas a least .xed point. This .xed point can be computed by repeatedly performing shape analysis on each \nindividual thread, but not on the whole program, i.e., performing the analysis thread-modularly. The \nanalysis is able to establish that the program being analyzed is memory-safe (i.e., it does not deref\u00aderence \nheap cells that are not allocated), does not leak memory, and does not have data races (including races \non heap cells). We specify the borders of the part of the heap protected by a lock with two sets of program \nvariables the set of entry points and the set of exit points. The part of the heap protected by the lock \nis de.ned as everything that is reachable from entry points up to exit points. Therefore in the subheap \ncarved out by a resource invariant, exit points are pointers that lead to parts of the global heap owned \nby others. Fortunately, for systems code (e.g., device drivers), we .nd that automatic tools [22, 25, \n5] suf.ce for inferring the entry points1. In more complex cases the entry and exit points can be given \nby the user as annotations (or may be other analyses for them could be found). Our approach can be rephrased \nas follows: we assume that the borders between parts of the heap owned by different threads or protected \nby different locks are stable in the sense that they are pointed to by .xed stack variables. These borders \nare not required to be immovable, and we do not preclude ownership transfer of heap cells between areas \nowned by different threads or locks. That is, while the stack variables which mark the borders are .xed, \ntheir values are mutable. So heap cells can move between the parts owned by different threads or protected \nby different locks. Our contributions can be summarized as follows: We propose a framework for constructing \nthread-modular pro\u00adgram analyses, which is particularly suitable for shape anal\u00adyses due to the locality \nexhibited by the semantics of heap\u00admanipulation (Section 3). Our framework is parametric in the sequential \nshape analysis domain and can be instantiated with different domains. 1 Moreover, the soundness of our \nanalysis does not depend on the particular association of locks and entry points: the analysis can be \nused with any association. V ::= x,y,... E ::= null | V . ::= . . . | E = E S ::= S * S | emp | true \n| E.{prev: E,next: E}| dll(E,E,E,E) F ::= V.. . S .v Figure 2. A subset F of separation logic formulae \n We give a .xed-point characterization of a class of resource in\u00advariants for heap-manipulating programs \nthat provides a way to compute them via a thread-modular .xed-point computation (Section 4). For programs \nthat have resource invariants from this class, the precision of our thread-modular analysis depends only \non the precision of the underlying (sequential) shape anal\u00adysis.  Based on the framework and on the \n.xed-point characterization we develop a thread-modular shape analysis (Section 5) and ap\u00adply it to multithreaded \nheap-manipulating code from Windows device drivers (Section 6).   2. Illustrative example The example \nprogram in a C-like language shown in Figure 1 represents a typical pattern occurring in systems code, \nsuch as Windows device drivers. In this case two concurrently executing threads are accessing the same \ncyclic doubly-linked list protected by a lock e. The list is accessed via a sentinel head node pointed \nto by a variable h. In this example thread1 adds nodes to the head of the list and thread2 removes nodes \nfrom the head of the list. When applied to this code, the implementation of our analysis presented in \nSections 5.2 and 6 establishes that the area of the heap protected by the lock its resource invariant \nhas the shape of a cyclic doubly-linked list and that the program is memory-safe (i.e., it does not dereference \nheap cells that are not allocated), does not leak memory, and has no data races (including races on heap-cells). \nThe analysis uses an underlying sequential shape analysis, which is similar to the one presented in [9]. \nThe abstract states and resource invariants in the analysis denote sets of stack-heap pairs and are represented \nby disjunctions of formulae in the subset of separation logic [23] de.ned in Figure 2. The informal meaning \nof the formulae is as follows: emp describes states where the heap is empty, with no allocated locations. \nE .{prev: E1, next: E2}describes states where the heap con\u00adtains a single allocated location E, with \ncontents being a struc\u00adture in which the .elds prev and next are equal to E1 and E2. The values of the \nother .elds in the structure are unspeci.ed by this formula. S1 *S2 describes states where the heap \nis the union of two disjoint heaps (with no locations in common), one satisfying S1 and the other satisfying \nS2.  E1 = E2 describes states where the stack gives E1 and E2 equal values.  dll(E1,E2,E3,E4) is de.ned \nas the least predicate such that  dll(E1,E2,E3,E4) ..x.(E1 = E3 .E2 = E4 .emp) . (E1 .{prev: E2, next: \nx}*dll(x, E1,E3,E4)) and represents all of the states in which the heap has the shape of a (possibly \nempty) doubly-linked list, where E1 is the ad\u00address of the .rst node of the list, E4 is the address of \nthe last node, E2 is the pointer in the prev .eld of the .rst node, and E3 is the pointer in the next \n.eld of the last node. The meaning of propositional connectives, true and the existen\u00adtial quanti.er \nis standard. The analysis .rst uses a tool for analyzing correlations between locks and program variables, \nsuch as [22, 25, 5], to determine that the variable h is protected by the lock e.The variable h becomes \nan entry point associated with the lock e: the part of the heap protected by the lock is reachable from \nthe entry point. There are no exit points associated with the lock e in this example. The analysis is \nperformed iteratively. On each iteration, we analyze the code of each thread and discover new shapes \nthe part of the heap protected by each lock can have new disjuncts in its resource invariant. On the \nnext iteration each thread is re-analyzed taking the newly discovered disjuncts into account. This loop \nis performed until no new disjuncts in the resource invariant are discovered, i.e., until we reach a \n.xed point on the value of the resource invariant. Note that the particular order of the iteration is \nnot important for the soundness of the analysis. In the example below we chose the order that is convenient \nto illustrate how the analysis works. Executing the analysis. As a .rst step, we run the underlying sequential \nshape analysis on the main function to determine the initial approximation I0 = h.{prev: h, next: h}of \nthe resource invariant associated with the lock e. The initial states of the threads in this case are \nemp. First iteration. We run the underlying sequential shape analysis on the code of thread1 with the \ntreatment for acquire and release commands described below. The analysis performs a .xed-point computation \nto determine invariants of all the loops in thread1. Suppose the analysis reaches line 14 with an abstract \nstate s. Upon acquiring the lock e the thread gets ownership of the part of the heap protected by the \nlock. We mirror this in the analysis by *-conjoining the current approximation I0 of the resource invariant \nassociated with the lock e to the current state s yielding s *I0. The analysis of the code in lines 15 \n20 starting from this state then gives us the state s1 = s *h.{prev: n, next: n}*n.{prev: h, next: h}at \nline 21. Upon releasing the lock e the thread has to give up the ownership of the part of the heap protected \nby the lock. This means that the analysis has to partition the current heap s1 into two parts, one of \nwhich becomes the local heap of the thread (the part of the heap that the thread owns) and the other \nis added as a new disjunct to the resource invariant. We compute the partitioning in the following way: \nthe part of the heap reachable from the entry points associated with the lock e becomes a new disjunct \nin the resource invariant and the rest of the heap becomes the local state of the thread. Intuitively, \nwhen a thread modi.es pointers to a heap cell so that it becomes reachable from the entry points associated \nwith a lock, the cell becomes protected by the lock and a part of its resource invariant. In this way, \nwe discover a new disjunct I1 = .x.h.{prev: x, next: x}*x.{prev: h, next: h}in the resource invariant \nand a new state s reachable right after line 21. Note that since the variable n is not an entry point \nassociated with the lock e, we existentially quantify it in I1. We keep running the .xed-point computation \nde.ned by the underlying sequential shape analysis starting from this state to discover the invariant \nof the loop in line 13 (as well as all other loops in the thread). The processing of lines 14 and 21 \nis the same as before, i.e., we use the same approximation I0 of the resource invariant and get the same \ndisjunct I1. We stop when the underlying shape analysis reaches a .xed point. One new disjunct I1 of \nthe resource invariant has been discovered. We now analyze the code of thread2. Whenever the analysis \nreaches line 28 with an abstract state q, we conjoin the current approximation I1 of the resource invariant \nto the state q yielding 1 2 3 4 5 6 7 8 9 struct ListEntry { ListEntry* next; ListEntry* prev; int data; \n}; Lock i; ListEntry* h; 10 11 12 13 14 15 16 17 18 19 20 21 22 23 thread1() {int data; ListEntry* n; \nwhile (nondet()) {... acquire(i); n= new ListEntry; n-data = data; n-next = h-next; n-prev = h; h-next \n= n; n-next-prev = n; release(i); ... }} 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 thread2() {int \ndata; ListEntry* n; while (nondet()) {... acquire(i); n = h-next; if (n != h) {n-prev-next = n-next; \nn-next-prev = n-prev; data = n-data; delete n; }release(i); ... }} 39 40 41 42 43 44 45 main() {h= new \nListEntry; h\u00adnext = h; h-prev = h; startThread(&#38;thread1); startThread(&#38;thread2); } Figure 1. \nExample program. nondet() represents non-deterministic choice. q*I1 and analyze the code in lines 29 \n35 starting from this state. This gives us the state q1 = q*h.{prev: h,next: h}at line 36. We again take \nthe part of the heap reachable from has a new disjunct in the resource invariant and let the rest of \nthe heap be a new local state of the thread. In this case the new disjunct in the resource invariant \nis the same as the starting one I0, so, no new disjuncts in the resource invariant are discovered. Second \niteration. On the previous iteration we found a new dis\u00adjunct I1 in the resource invariant associated \nwith the lock e.This means that whenever a thread acquires the lock e, it can get own\u00adership of a piece \nof heap with this new shape. To account for this in the analysis we now consider this possibility for \nall acquire(e) commands in the program and perform the analysis on threads starting from the resulting \nnew states. In thread1 we obtain a new state s*I1 at line 15. The analysis of the code in lines 15 20 \nin this case gives us the state s2 = .x.s *h.{prev: x,next: n}*n.{prev: h,next: x}*x.{prev: n,next: h}.at \nline 21. Again, the part of the heap reachable from h forms a new disjunct in the re\u00adsource invariant. \nTo ensure convergence we abstract it before sav\u00ading: the abstraction procedure similar to the one presented \nin [9] abstracts the heap that has two cells nand xconnected in a doubly\u00adlinked list to a general doubly-linked \nlist giving us a new dis\u00adjunct in the resource invariant: I2 = .x,y.h.{prev: x,next: y}*dll(y,h,h,x). \nA similar procedure for thread2 again gives us the state q1 at line 36. No new disjuncts in resource \ninvariants are dis\u00adcovered while analyzing this thread. Third iteration. We propagate the newly discovered \ndisjunct I2 of the resource invariant to acquire commands. The new state s *I2 at line 15 gives rise \nto the state s3 = .x,y.s *h.{prev: x,next: n}*n.{prev: h,next: y}*dll(y,n,h,x) at line 21. Partitioning \nit into the part reachable from h and the part unreachable from h and abstracting the latter gives us \nagain the resource invariant I2 and the state s. Propagating the new dis\u00adjunct in the resource invariant \nto line 28 yields the state q2 = .x,y.q*h.{prev: x,next: y}*dll(y,h,h,x) at line 36. Partition\u00ading this \nstate again does not result in new disjuncts in the resource invariant being discovered. No new disjuncts \nin resource invariants were discovered on this iteration, hence, we have reached a .xed point. The resource \ninvariant for the lock e computed by the analysis is I0 .I1 .I2. Furthermore, the program is memory-safe. \n0  3. Thread-modular shape analyses In this section we present a general framework for constructing \nthread-modular shape analyses based on the inference of resource invariants associated with each lock \nthat describe the part of the program state protected by the lock. Abstracting from particu\u00adlar domains \nused in shape analyses we formulate it in general lattice-theoretic terms. We use the framework .rst \nin Section 4 to give a .xed-point characterization of resource invariants for heap-manipulating programs \nand then in Section 5 to implement a thread-modular shape analysis. 3.1 Preliminaries We consider concurrent \nprograms consisting of a bounded number of threads that use a bounded number of non-aliased locks for \nsynchronization. Each thread is represented by its control-.ow graph (CFG). For any nodes v1 and v2 in \na CFG there are three types of edges that can connect them: (v1,C,v2),where C is an element of a .xed \nset Cof sequential commands;  (v1,acquire(e),v2) corresponding to acquiring the lock e;  (v1,release(e),v2) \ncorresponding to releasing the lock e.  Consider a program with m threads P1,...,Pm in which Pi is represented \nby a CFG with the set of nodes Ni and the set of edges Ei.Let L= {e1,...,en}be the set of locks used \nin the program. SS Let N = m = m Ei,and starti be the start node i=1 Ni, E i=1 of thread i. Without loss \nof generality we assume that there are no edges in the CFG of the program leading to a start node. We \ncall a tuple (v1,...,vm),where vi .Ni a location. We now de.ne a collecting interleaving semantics for \nthe program. In this paper by a domain D we understand a join-semilattice F (D,.,,.,T) with a bottom \nelement .. We assume given a domain D representing sets of states of the program and a set of monotone \nconcrete transfer functions fC : D .D representing the semantics of sequential commands C .C. The function \nfC maps pre-states to states obtained by executing the command C from a pre-state. Programs in our semantics \ndenote mappings from locations and sets of locks held by each thread to elements of the do\u00admain D. Formally, \nprograms denote elements of the domain Db= (N1 \u00d7... \u00d7Nm) .((P(L))m .D) ordered by the point\u00adwise extension \nof .. We call an element from (P(L))m a lockset and say that a lockset (L1,...,Lm) is admissible if the \nsets of F(q)= q' where q'(start1,...,startm,\u00d8,...,\u00d8)= pre; m FF j 0 q'(v1,...,vm,L1,...,Lm)= gC (q(v1,...,vj \n,...,vm),L1,...,Lm),if (L1,...,Lm) is admissible, where 0 j=1 (vj ,C,vj ).E 8 >fC (s(L1,...,Lm)), if \nC is a sequential command; > > < j s(L1,...,Lj \\{ii},...,Lm) if C is acquire(ii) and ii .Lj; gC (s,L1,...,Lm)= \n >s(L1,...,Lj .{ii},...,Lm) Us(L1,...,Lj,...,Lm) if C is release(ii) and ii. Lj ; > > : ., otherwise. \nFigure 3. The functional F de.ning the concrete collecting semantics for a multithreaded program locks \nheld by different threads are disjoint, i.e., for each i and j such that i nLj D, = j it is the case \nthat Li = \u00d8.For q .bq(v1,...,vm,L1,...,Lm), denotes the set of reachable states of the program at the \nlocation (v1,...,vm)such that the lockset held by threads is (L1,...,Lm). The reason for having a lockset \nas an argument of q is that locking does not have to be lexically scoped, hence, reachable states at \neach location may have different locksets. We assume a given pre .D representing the initial states of \nthe program. The semantics of the program is de.ned using the functional F :Db.Dbthat takes a function \nq .Dband maps it to a function q' .Dbfollowing the rules shown in Figure 3. Since the transfer functions \nfC are monotone, by Tarski s .xed point theorem the functional F has least .xed point lfp(F), which represents \nthe denotation of the program. Consider the second equation in Figure 3. According to it, to compute \nthe state at any location (except for the initial one) we consider all the edges in the CFG that can \nbe taken by any single thread that lead to this location (hence, the semantics is based on interleaving) \nand take the join of the application of the function g for each of these edges (hence, the semantics \nis collecting) to the state at the source node. Note that here we use partial application of the function \nq. The function g de.nes the semantics of the statement at each edge of the CFG. For a sequential command \nit applies the transfer function for this command. Post-states of acquire(ei)for a lockset in which the \nthread Pj holds the lock ei are the same as pre-states in which the thread Pj does not hold the lock \nei. Hence, acquiring a lock by a thread corresponds to adding this lock to the lockset of the thread. \nFor the acquire(ei)command the function g.lters out the pre-states in which the thread Pj holds the lock \nei. Hence, a thread locking the same lock twice deadlocks. Post-states of release(ei)for a lockset in \nwhich the thread Pj does not hold the lock ei contain pre-states in which the thread Pj does not hold \nthe lock ei as well as pre-states in which it does. Hence, releasing a lock by a thread corresponds to \nremoving it from the lockset of the thread if it is there, and to a no-op if it is not there. This semantics \nof releasing a lock corresponds to treating locks as binary semaphores.  3.2 Abstract interpretation \nwith state separation As can be seen from the illustrative example in Section 2, in our thread-modular \nshape analysis we have to split abstract heaps into disjoint parts. For this to be possible the concrete \nand abstract do\u00admains have to have a separated structure that allows for performing such splittings. \nIn this section we specialize the conventional notion of abstract interpretation [7] for the case when \nthe domains have such a structure. In the subsequent sections we use this specializa\u00adtion as a foundation \nfor designing thread-modular shape analyses. DEFINITION 1 (Separation domain). A separation domain is \na do- F main (D,, ,.,T,e,*) equipped with an operation of sepa\u00adrate combination *:(D \u00d7D) .D such that \n(D, ,e,*)is a partially-ordered commutative monoid, i.e.: Values = {...,-1,0,1,...} Locs = {1,2,...} \nVars = {x,y,...} Stacks = Vars ..n Values Heaps = Locs ..n Values States = (Stacks \u00d7Heaps) .{T} D = P(States) \n Figure 4. Example of a separation domain *is associative and commutative: .u,v,w .D.u*(v*w)=(u*v)*w; \n.u,v .D.u*v =v*u; *has the unit e: .u .D.u*e=u; *is monotone: .u1,u2,v .D.u1 u2 .u1 *vu2 *v. We use a \nslight variation on the following instance of a sepa\u00adration domain in the further sections to design \na thread-modular shape analysis. Example. Figure 4 de.nes a separation domain D for the con\u00adcrete semantics \nof heap-manipulating programs [27]. A state of the program is a stack-heap pair or a special error state \nT. A stack is a .nite partial function from variables to values, a heap is a .nite partial function from \nlocations to values. The domain consists of sets of states of the program. We identify all the sets of \nstates con\u00adtaining Tand denote such elements of the domain simply with T. The order in the domain D is \nsubset inclusion with Tbeing the topmost element. This is essentially equivalent to using a topped powerset. \nHowever, in the further sections the formulation we use here allows us to simplify certain de.nitions. \nIn this paper we use the following notation for partial functions: f(x).means that the function f is \nde.ned on x, f(x).means that the function f is unde.ned on x,and dom(f)denotes the set of arguments on \nwhich the function f is de.ned. We denote with f[x : y]the function that has the same value as f everywhere, \nexcept for x, where it has the value y (even if f(x).). f lg is the union of the disjoint partial functions \nf and g. It is unde.ned if dom(f)ndom(g) d the function identical =\u00d8. We denote with f|to f except for \nits domain has been restricted to the set d. We de.ne the operation of separate combination on the domain \nDin the following way: for s1,s2 .States s1 *s2 ={(t1 lt2,h1 lh2)|(t1,h1).s1 .(t2,h2).s2}, s1 *T=T*s2 \n=T. The unit element with respect to this operation is a singleton set containing a pair of everywhere \nunde.ned functions. A reader familiar with separation logic [23] can immediately notice that the de.nition \nof *we gave here corresponds to the model of the separating conjunction from separation logic in the \ncase when variables are treated as resources [21]. As can be seen from the example above, in this paper \nwe use the topmost element of a separation domain to indicate a potential error. In this case the *operation \nshould also satisfy the following requirement: .u, v .D. u *v = T.u = T.v = T. (1) That is, *does not \nproduce the error state unless one of its argu\u00admentsisthe errorstate. For a program analysis to bene.t \nfrom the structure present in a separation domain, transfer functions de.ning the concrete semantics \nof sequential program statements have to behave in a local way with respect to this structure. The following \nde.nition formalizes this condition. DEFINITION 2 (Local function). A function f : D .D de.ned F over \na separation domain (D,, , ., T,e, *) is local if for all u, v .D it is the case that f(u *v) f(u) *v. \n(2) For the separation domains we consider in this paper, intuitively, if f is the meaning of a command \nC, this condition requires that if executing C from a state in u *v results in an error f(u *v)= T, then \nexecuting C from a smaller state in u also produces an error: T.f(u) *v implies f(u)= Tby (1). Furthermore, \nif executing C from a state in u does not produce an error, then executing C from a larger state, in \nu *v, has the same effect and leaves v unchanged: f(u *v)= f(u) *v. The construction of thread-modular \nshape analyses is possible due the fact that concrete transfer functions for all standard heap\u00admanipulating \ncommands are local as illustrated by the following example. Example. Consider the domain D from the previous \nexample and a transfer function f : D .D corresponding to the command that stores the value of the variable \ny at the address equal to the value of the variable x, in C syntax *x = y . We .rst de.ne a function \nf : States .D.For t .Stacks and h .Heaps ( (t,h[t(x): t(y)]), if t(x)., t(y)., h(t(x)).; f(t, h)= T, \notherwise, We let f(T)= Tand lift f to D pointwise. The function f is local when run on a piece of state \nit either produces the same result as when run on the extended state or it produces T. 0 Consider a concurrent \nprogramming language from the class de\u00ad.ned in Section 3.1. In Section 3.3 we show how, given an analysis \nfor the underlying sequential language, we can construct a thread\u00admodular analysis for the concurrent \nlanguage. More precisely, we assume given: F a concrete separation domain (D,, , ., T,e, *) represent\u00ading \nsets of concrete states of the program; F an abstract separation domain (Di,,, ., T,ei,I) repre\u00adsenting \nsets of abstract states of the program;  a monotone concretization function . : Di .D;  monotone concrete \ntransfer functions fC : D .D de.ning the concrete semantics of sequential commands C .C;  abstract transfer \nfunctions fC : Di .Di de.ning the abstract semantics of sequential commands C .C.  i We assume further \nthat: concrete transfer functions fC are local; ' Fi(Q,I)=(Q ,I ' )where Q ' (starti,\u00d8)=Prei(prei); F \ni Q ' (v,L)= g(Q(v0),L)for every node v .N,where C (v0,C,v).E i gC (s,L)= 8 i >f(s(L)), if C is a sequential \ncommand; > > C < s(L\\{ii})HIi, if C is acquire(ii)and ii .L; >Locali(s(L.{ii}))Us(L), if C is release(ii)and \nii .L; > > : ., otherwise; F ' I =Initi(prei)U Framei(Q(v0,L)) i (v 0 ,release(\u00a3i),v).E, {\u00a3i}nL =\u00d8 for \neach lock ii. Figure 5. The functional Fi de.ning a thread-modular analysis. Functions Locali and Framei \nde.ne a heuristic that decides how to split the state upon releasing a lock. Prei and Initi decide how \nto split the initial abstract state prei between threads and locks. . is a homomorphism between the monoids \nin the abstract and concrete separation domains: i .u, v .D..(uIv)= .(u) *.(v); (3) abstract transfer \nfunctions over-approximate the concrete ones: ii .u .D,C .C.fC (.(u)) .(fC (u)). (4) Note that we use \nthe same symbols for the order, bottom and top elements, and the join operator for both domains when \nit does not cause confusion. Note also that we do not require that the abstract transfer functions be \nlocal or monotone. 3.3 Constructing thread-modular shape analyses We now de.ne a thread-modular analysis \non a multithreaded pro\u00adgram. The main idea of the analysis is to infer the part of the state protected \nby each lock its resource invariant. Resource in\u00advariants are computed incrementally during the analysis, \ntherefore, for each lock ei the analysis maintains the current approximation Ii .Di of a corresponding \nresource invariant. In addition, for ev\u00adery node v in the CFG and every set of locks L the analysis main\u00adtains \nthe part of the state Q(v, L) .Di owned by the thread at the node v in the case when the set of locks \nheld by the thread is L its local state. Formally, the analysis operates on the domain Dbi =(N .(P(L) \n.Di)) \u00d7(Di)n ordered by the pointwise extension of the abstract order . We denote with IIk = Ithe iterated \nversion of I: I i=1 xi x1 I...Ixk. The thread-modular analysis is de.ned using the functional Fi : Dbi \n.Dbi that takes a tuple (Q,I) and produces a tuple (Q ' ,I ' ) as shown in Figure 5. The analysis receives \nas input an abstract initial state of the program prei .Di such that pre .(pre i) (5) and is parameterized \nwith the following functions: Locali : Di .Di and Framei : Di .Di for each i =1..n such that for all \ns .Di .(s) .(Locali(s) I Framei(s)); (6) Prei :Di .Di for each i =1..m and Initi :Di .Di for each i =1..nsuch \nthat for all s.Di \u00ab \u00ab\u00ab mn .(s) .IPrei(s) IIIniti(s) . (7) II i=1 i=1 Prei and Initi determine the initial \nsplitting of abstract state pre i between threads and locks. Prei and Initi map the abstract initial \nstate of the program pre i to the abstract initial state of thread i, respectively, the initial approximation \nof the resource invariant Ii. The condition (7) ensures that, when recombined, the results are an over-approximation \nof the abstract initial state. The interesting part of the analysis concerns the treatment of acquiring \nand releasing locks. When a thread acquires a lock ei, it obtains the current approximation of the corresponding \nresource invariant the current approximation of the resource invariant is I\u00adconjoined with the current \nlocal state of the thread to yield a new local state. When a thread releases the lock ei, its current \nlocal state is partitioned into two parts, one of which returns to the resource invariant and the other \none stays with the thread. The functions Locali and Framei determine this splitting. The function Locali \ndetermines the part of the state that becomes the local state of the thread and the function Framei the \npart that goes to the resource invariant. The condition (6) ensures that the combination of the parts \nof the splitting over-approximates the given abstract state. Note that the treatment of locksets in processing \nacquire or release commands in Figure 5 mimics the one in the concrete semantics (Figure 3). A computation \nof a .xed point of the functional Fi would an\u00adalyze each thread accumulating possible values of resource \ninvari\u00adants during the analysis. Each time a new possible value of a re\u00adsource invariant associated with \na lock is discovered, it would have to be propagated to every acquire command for the lock. Hence, each \nthread is analyzed repeatedly, but separately, without explor\u00ading the set of interleavings. In this sense \nthe analysis de.ned by Fi is thread-modular. Note also that after the analysis splits the state at a \nrelease command, it loses correlations between the parts of the state that become local states of the \nthread and the parts that go to the resource invariant. This loss of precision is similar to the one \nobserved in thread-modular model checking [11]. We are now in a position to state and prove the soundness \nof the analysis de.ned by the functional Fi. The following theorem says that reachable states at the \nlocation (v1,...,vm)such that the lockset held by threads is (L1,...,Lm)are over-approximated by the \ncombination of the local states of all threads along with resource invariants associated with the locks \nthat are not in the lockset. The conditions listed at the end of Section 3.2 pinpoint the suf.cient requirements \nthat the underlying sequential analysis has to satisfy for the thread-modular analysis to be sound and \nare used in the proof of the theorem. THEOREM 1 (Soundness). Let q be least .xed point of the func\u00adtional \nF de.ned in Figure 3 and (Q,I)be a .xed point of the func\u00adtional Fi de.ned in Figure 5. Then for each \nlocation (v1,...,vm) and admissible lockset (L1,...,Lm) \u00ab \u00ab\u00ab m q(v1,...,vm,L1,...,Ln) .IQ(vi,Li) IIIi \nII i=1 \u00a3i.L where L=L1 .....Lm. The proof appears in Appendix A. Note that although we have assumed a \n.xed number of threads, from the de.nition of the functional Fi it follows that the results of the analysis \nare sound for an unbounded number of copies of these threads provided they have the same initial states \nas the original V ::= x, y, . . . variables E ::= null | V expressions G ::= E == E | E != E branch guards \nC ::= V = E | V = V -next sequential commands | V -next = E | V = new | delete V | assume(G) Figure \n6. Sequential commands for a heap-manipulating concur\u00adrent programming language ones. Formally, if we \nadd an extra copy of a thread Pi into the program and change the concrete and the abstract initial states \nso that the condition (7) is still satis.ed (which corresponds to adding an extra piece of state to the \ninitial state of the program to form a precondition for a newly added thread), then the results of the \nanalysis for the new program with the Q for the new thread equal to the Q for Pi still form a .xed point \nof the new functional Fi and, hence, over-approximate the concrete semantics. Similar versions of the \nspecialization of abstract interpretation presented in Section 3.2 were developed independently and can \nalso be used as a basis for scaling up other static analysis algo\u00adrithms even for programs without multithreading \nand dynamically allocated memory (see [13] for more information). For example, they are applicable in \ninterprocedural analysis to split off the (ab\u00adstract) state of the called procedure from the abstract \nstate of the caller [24, 12].  4. Resource invariants as least .xed points In this section we show \nthat if the borders of the part of the heap protected by a lock are speci.ed, then the resource invariant \ndescribing this part can be de.ned as least .xed point of a .rst\u00adorder equation. For programs that have \nresource invariants from the class we de.ne here the precision of our thread-modular analysis depends \nonly on the precision of the underlying (sequential) shape analysis. To show how to design thread-modular \nshape analyses we ab\u00adstract from the particular shape domain used and construct an ide\u00adalistic shape \nanalysis that operates on concrete states. We do this by instantiating the framework of Section 3.3 with \nthe same con\u00adcrete and abstract domains. In Section 5 this instantiation serves as a template for designing \nthread-modular shape analyses. The instantiation provides a .xed-point characterization of a class of \nresource invariants and can be seen as de.ning a non-standard con\u00adcrete semantics. Theorem 1 ensures \nits adequacy with respect to the standard collecting interleaving semantics. 4.1 Programming language \nand concrete semantics Programming language. We consider a concurrent heap\u00admanipulating programming language \nfrom the class of concurrent CFG-based languages de.ned in Section 3.1 with sequential com\u00admands shown \nin Figure 6. To simplify presentation we assume that each structure stored in the heap has only one .eld \nnext. The devel\u00adopment carried out in this section generalizes easily to the case of structures with \nmultiple .elds. The meaning of commands is stan\u00addard. assume(G)acts as a .lter on the state space of \nprograms G is assumed tobetrueafter assume is executed. It is used to replace conditional expressions \nin while and if statements while translating programs to CFGs. Consider a program in the language introduced \nabove consisting of threads P1,...,Pm (represented by their CFGs) with locks e1,...,en and a precondition \npre. The domain of states. We now de.ne a concrete semantics and F a corresponding concrete separation \ndomain (D,, ,.,T,e,*) Values = {...,-1,0,1,...} Locs = {1,2,...}Heaps = Locs .n Values Perms = (0,1] \nStacks = Vars .n (Values \u00d7Perms) Vars = {x,y,...}States = (Stacks \u00d7Heaps) .{T} D = P(States) Figure 7. \nThe domain D of the concrete semantics for this language. As was previously noted, in our .xed-point \nchar\u00adacterization of resource invariants for heap-manipulating programs, we assume that the borders between \nparts of the heap owned by dif\u00adferent threads or protected by different locks are stable, i.e., pointed \nto by .xed stack variables. We thus have to account for the fact that local state of several threads \nand resource invariants of several locks may reference the same variable. Supposing that there are k \nsuch locks and threads, we handle this case by giving to each thread and lock a fractional permission \n1/k for this variable [2]. The permis\u00adsion shows how much of this variable is owned by the thread or \nprotected by the lock. The idea is that a thread having a permission less than 1 for a variable can read \nit; a thread can write to a variable only if the permission associated with it in its local state is \nequal to 1, i.e., only if it gathers the permissions from all the other locks that own this variable \nby acquiring them. Thus, as our concrete do\u00admain we chose an extension of the example of a separation \ndomain presented in Section 3.2 with fractional permissions for variables. The domain D is de.ned in \nFigure 7. As before, we identify all the sets of states from States containing Tand denote such elements \nof the domain simply with T. The order in the domain is subset inclusion with Tbeing the topmost element, \nthe join operation is set union, and the bottom element is the empty set. We proceed to de.ne an operation \nof separate combination *on the domain. Informally, *adds up permissions for variables and computes the \ndisjoint combination of heaps. It corresponds to the model of the separating conjunction from separation \nlogic in the case when variables are treated as resources with permissions. For t .Stacks let functions \nValt and Permt be selectors for values, respectively, permissions, of variables on the stack: for all \nx .Vars, (Valt(x), Permt(x)) = t(x) and, additionally, Permt(x)=0 if t(x).. We de.ne the combination \nt1 *t2 of stacks t1,t2 .Stacks as follows: if .x .Vars. Permt1 (x)+Permt2 (x) =1.(Valt1 (x)..Valt2 (x)..Valt1 \n(x)= Valt2 (x)),then x = y,t,hp t[x :(Valt(y),1)],h if Permt(x)=1,t(y). x = null,t,hp t[x :(0,1)],h if \nPermt(x)=1 x = y-next,t,hp t[x : h(Valt(y))],h if Permt(x)=1, t(y).,h(Valt(y)). x-next = y,t,hp t,h[Valt(x): \nValt(y)] if t(x).,t(y)., h(Valt(x)). x-next = null,t,hp t,h[Valt(x):0] if t(x).,h(Valt(x)). x = new,t,hp \nt[x : a],h[a : e] if Permt(x)=1, a .Locs \\dom(h), e.Values delete x,t,h[Valt(x): e] p t,h if t(x).,e \n.Values assume(G),t,hp t,h if [G]t.,[G]t = true assume(G),t,hp if [G]t.,[G]t = false C,t,hp T otherwise \nFigure 8. Transition relation for primitive commands. [G]t .{true, false}is the valuation of the guard \nG over the stack t (which is unde.ned if t is unde.ned for a variable used in G). Here 1 denotes that \nthe command does not fault, but gets stuck. show that for each primitive command C from Figure 6 the \ntransfer function fC is monotone and local.  4.2 Fixed-point characterization In the setup of Section \n3.3 we let both the abstract separation domain Di and the concrete D be equal to the domain de.ned in \nSection 4.1 and the abstract transfer functions be equal to the concrete ones. . is the identity function. \nWe also let pre i = pre. All the conditions listed at the end of Section 3.2 are satis.ed. We would like \nto characterize resource invariants as least .xed points of a functional from the class de.ned in Figure \n5. To do this we have to provide functions Locali and Framei (i =1..n)for each lock, Prei (i =1..m) for \neach thread, and Initi (i =1..n)for each lock. To this end we assume that for each lock ei we are given \ntwo sets of program variables, which specify the borders of the part of the heap protected by the lock \nthe set of entry points Entry(ei) and the set of exit points Exit(ei). The part of the heap protected \nby the lock is de.ned as everything that is reachable from entry points up to exit points. Therefore, \nexit points are pointers that lead to parts of the heap owned by others. In addition, for each thread \nPi we assume given the set Owns(Pi) of program variables that it owns. These are variables that the thread \nis allowed to access even without (t1 *t2)(x)= First, we de.ne how Locali and Framei partition the stack. \n(Valt1 (x), Permt1 (x)+ Permt2 (x)), if Valt1 (x).; To this end we de.ne an auxiliary function that describes \nthe 8 >< (Valt2 (x), Permt1 (x)+ Permt2 (x)), if Valt2 (x).; ownership partitioning of the stack. For \na thread or lock P , Perm0 P unde.ned, otherwise, de.nes via permissions the part of the stack owned \nby P : for each x .Vars holding any locks. We de.ne Owns(ei)= Entry(ei) .Exit(ei). >: and t1 *t2 is unde.ned \notherwise. We de.ne the combination h1 *h2 of heaps h1,h2 .Heaps in the following way: Perm0 P (x)= \n( '' 1/|{P |x .Owns(P )}|, if x .Owns(P ); unde.ned, otherwise. ( h1 lh2, if dom(h1) ndom(h2)= \u00d8; For \na stack t .Stacks if .x .Vars.t(x)..Perm0 \u00a3i (x) = h1 *h2 = unde.ned, otherwise. Permt(x),thenlet .Stacks \nand h1,h2 .Heaps we let (t1,h1) *Locali(t)= .x.(Valt(x), Permt(x) -Perm0 \u00a3iFinally, for t1,t2 (x)), (t2,h2)=(t1 \n*t2,h1 *h2),for s .D we let T*s = T*s = T, and we lift *to D pointwise. The unit element e of *is the \nsingleton set containing a pair of an empty heap and an empty stack, both represented by everywhere unde.ned \nfunctions. Transfer functions. We de.ne the concrete transfer functions fC : D .D for primitive commands \nusing the transition relation 1 shown in Figure8. Welet fC (t, h)= {s |C, t, h 1 s}, fC (T)= T, and lift \nfC to D pointwise. It is not dif.cult to Framei(t)= .x.(Valt(x), Perm0 \u00a3i (x)), otherwise let Locali(t)= \nFramei(t)= T. We now de.ne how Locali and Framei partition the heap. Framei takes the part of the heap \nreachable from entry points up to exit points. The intuition is that modifying pointers to a heap cell \nsuch that it moves into this part of the heap means that it becomes protected by the corresponding lock \nand a part of its resource invariant (recall that in the analysis Framei computes the part of the heap \nthat goes into the resource invariant). The rest of the heap becomes the result of Locali. For t .Stacks, \nh .Heaps, and a lock ei let d(ei,t,h) be the smallest set d such that (Valt(Entry(ei)) .(h(d) \\Valt(Exit(ei))))nLocs.d.d(ei,t,h)de.nes \nthe part of the heap reachable from the entry points of the lock ei up to exit points as\u00adsociated with \nthis lock. We now let for t .Stacksand h .Heaps Locali(t,h)=(Locali(t),h|dom(h)\\d(\u00a3i,t,h)), Framei(t,h)=(Framei(t),h|d(\u00a3i,t,h)). \nHere we assume that (T,h)= T.We let Locali(T)= Framei(T)=Tand lift Locali and Framei to D pointwise. \nWe proceed to determine the initial splitting of the heap among threads and locks. This is done in the \nsame spirit as splitting the heap at release commands. For each thread Pi we de.ne Entry(Pi)= Owns(Pi), \nExit(Pi)= {Owns(Pk) |1 =i =m .i = k}.{Entry(ei)|1 =i =n}. That is, for a thread Pi we consider the entry \npoints of its initial states to be the vari\u00adables owned by the thread and exit points to be the variables \nowned by other threads and entry points of locks. For a thread Pi let d(Pi,t,h)be de.ned as before, but \nwith new Entry and Exit.For a stack tand a heap hwe let Prei(t,h)=(.x.(Valt(x),Perm0 (, Pi x)),h|d(Pi,t,h)) \nIniti(t,h)=(.x.(Valt(x),Perm0 (x)),h|d(\u00a3i,t,h)). \u00a3i For s .D we de.ne Prei(s)={Prei(t,h)|(t,h).s}, Prei(T)=T, \nIniti(s)={Initi(t,h)|(t,h).s}, Initi(T)=T, if for each (t,h).s (lmi=1dom(Prei(t,h)))l(lni=1dom(Initi(t,h)))=dom(h), \nwhere dom(t,h)= dom(h)and Prei(s)= Initi(s)= Toth\u00aderwise. The latter case corresponds to the situation \nwhen we are unable to split the initial states using the de.nitions of Entry and Exit above. Since the \ntransfer functions fC and functions Locali, Framei Prei,and Initi are monotone, by Tarski s .xed point \ntheorem the functional Fi de.ned in Figure 5 given the instantiations above always has least .xed point \n(Q,I). It is not dif.cult to show that Locali and Framei de.ned above satisfy (6) and Prei and Initi \nde.ned above satisfy (7). Hence, from Theorem 1 it follows that (Q,I)over-approximates the concrete semantics \n(as de.ned in Figure 3) and provides a valid .xed-point characterization of resource invariants for a \nclass of heap-manipulating programs. Example. The program in Figure 9 is adapted from [19]. Two threads \na producer and a consumer use .ne-grained synchro\u00adnization to access an unbounded buffer represented \nby a singly\u00adlinked list. Variables .rst and last point to the .rst, respectively, last element of the \nlist. Variable x is a local variable of the con\u00adsumer, y of the producer. The last element is a dummy \nnode. The producer adds a portion to the buffer by placing that portion in the data .eld of last, then \nallocates a new cell, and links that cell into the list making it the last (and dummy). Removing a portion \nre\u00adsults in a value being read from the data .eld of the .rst node, disposing this node, and moving .rst \nalong the list by one. When the list is of length one last and .rst are equal, and this corre\u00adsponds \nto an empty buffer; it is in this case that synchronization is necessary. In this example Entry(e)={.rst}, \nExit(e)={last}, Owns(producer)={last,y},and Owns(consumer)= {.rst,x}. Figure 10 de.nes a .xed point of \nthe functional introduced above. We use separation logic formulae to denote elements of the do\u00admain D \n(in fact, the formulae in Figure 10 represent an outline of a proof in concurrent separation logic). \nThe only deviation from the standard syntax and semantics [23] is that we treat variables as resources \n[21] (as required by the semantics in Section 4.1). The syntax of formulae is the same as in Figure 2 \nexcept for the follow\u00ading: Each formula is pre.xed with an expression of the form p1x1,...,pkxk describing \nthe stack, where pi is a number in (0,1] representing the permission for the variable xi and x1,...,xk \nis the list of free variables in the formula.  We use E1.{next:E2}instead of E.{prev:E,next:E}.  We \nuse a predicate ls(E1,E2)for singly-linked lists rather than a predicate for doubly-linked lists.  We \ncontract 1x to simply x, E1.{next:E2}to E1.E2,and use x. instead of x.x ' when the value of x ' is irrelevant. \nls(E1,E2)is the least predicate such that ls(E1,E2)..x.(E1 = E2 .emp).(E1 =E2 .E1.x*ls(x,E2))and denotes \nall of the states in which the heap has the shape of an acyclic (possibly empty) singly-linked list, \nwith the head node E1 and the value of the next .eld of the last node E2. Note that E2 must beadangling \npointer in a heap de.ned by ls(E1,E2). The adjustments to the semantics of formulae for handling variables \nas resources are as in [21]. The formula for the line v corresponds to the value of Q(v,L),where L is \nthe set of locks held at v by the thread to which v belongs (in this example for each CFG node v the \nset L can be determined syntactically). The resource invariant associated with the lock eis 12 .rst, \n12 last I ls(.rst,last). We omitted formulae for some program lines to conserve space. 0  5. Instantiating \nthe framework By instantiating the framework for thread-modular analyses pre\u00adsented in Section 3.3 with \nthe concrete domain de.ned in Sec\u00adtion 4.1, and abstract domain and transfer functions from differ\u00adent \nsequential shape analyses we can get different thread-modular shape analyses. In this section we present \nan instantiation of the framework on which our implementation is based and outline two other instantiations. \nTheir design follows the .xed-point character\u00adization of resource invariants presented in Section 4.2, \ni.e., the anal\u00adyses split the heap on releasing a lock by computing (an approxi\u00admation of) reachability \nbetween entry and exit points. We .rst note an important property of thread-modular shape analyses obtained \nby instantiating the framework with the concrete domain de.ned in Section 4.1 they detect data races, \ni.e., having a data race in the program results in the analysis signaling a possible bug. 5.1 Data race \nfreedom Suppose we are given a thread-modular shape analysis obtained from an instantiation of the framework \nof Section 3.3 in which the concrete separation domain D is equal to the domain de.ned in Section 4.1. \nThus, we assume given an abstract separation domain i Di, a concretization function ., abstract transfer \nfunctions fC , and functions Localii , Frameii , Preii ,and Initii . We .x a program in the programming \nlanguage introduced in Section 4.1 and let q be least .xed point of the functional F (Figure 3) that \nde.nes the concrete semantics of the program. We prove that the success of the thread-modular shape analysis \non the program implies that the program has no data races (both on stack variables and on heap cells). \nThe analysis succeeds if the .xed point (Qi,Ii)of the functional Fi (Figure 5) that de.nes its result \nis such that for every node v and every set of locks L it is the case that Qi(v,L) c Tand for all locks \nei it is the case that Iii c T. We denote this with (Qi,Ii) c T. In other words, a possible error found \nby the analysis is denoted by the topmost element in the abstract domain. This requires us to put an \nadditional constraint on the abstract 1 2 3 4 5 6 7 8 struct ListEntry { ListEntry* next; int data; \n}; Lock i; ListEntry* x, y, .rst, last; 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 consumer() \n{while (true) {x = .rst; while (true) {acquire(i); if (.rst != last) {.rst = .rst-next; release(i); break; \n} else {release(i); }}consume(x-data); delete x; }} 26 27 28 29 30 31 32 33 34 35 producer() {while (true) \n{last-data = produce(); y = new ListEntry; last-next = y; acquire(i); last = y; release(i); }} 36 37 \n38 39 40 41 main() {last = new ListEntry; .rst = last; startThread(&#38;consumer); startThread(&#38;producer); \n} Figure 9. Example program Line Local state 10 x, 1 2 .rst I emp 11 x, 1 2 .rst I emp 13 x, 1 2 .rst \nI x = .rst . emp 14 x, .rst, 1 2 last I x = .rst . ls(.rst, last) 16 x, .rst, 1 2 last I x..rst * ls(.rst, \nlast) 17 x, 1 2 .rst I x..rst 19 x, .rst, 1 2 last I .rst = last . x = .rst . ls(.rst, last) 20 x, 1 \n2 .rst I x = .rst . emp 21 x, 1 2 .rst I x = .rst . emp 23 x, 1 2 .rst I x..rst 24 x, 1 2 .rst I emp \n28 y, 1 2 last I last. 30 y, 1 2 last I last. * y. 31 y, 1 2 last I last.y * y. 32 y, last, 1 2 .rst \nI ls(.rst, last) * last.y * y. 33 y, last, 1 2 .rst I y = last . (ls(.rst, last) * last. ) 34 y, 1 2 \nlast I last. Figure 10. The .xed point de.ned by the .xed-point characteri\u00adzation for the program in \nFigure 9. Results for some lines of the program are elided.  37 x, y, .rst, last I emp 39 x, y, .rst, \nlast I .rst = last . last. domain: we require that .s.Di..(s)=T.s=T. (8) Let accesses(C,t,h), respectively, \nwrites(C,t,h)be the set of variables and locations that the primitive sequential command C may access \n(i.e., read, write or dispose), respectively, write to or dispose, when run from the state (t,h). DEFINITION \n3 (Interfering commands). Primitive se\u00adquential commands C1 and C2 interfere with each other when executed \nfrom the state (t,h), denoted with C1 N (t,h) C2,if accesses(C1,t,h) nwrites(C2,t,h)= \u00d8or writes(C1,t,h)naccesses(C2,t,h)=\u00d8. \nGiven this formulation of interference, the usual notion of data races is formulated as follows. DEFINITION \n4 (Data race). The program has a data race if for some location (v1,...,vm), admissible lockset (L1,...,Lm), \nand state (t,h) .q(v1,...,vm,L1,...,Lm) c Tthere exist CFG edges (v1,C1,v1' ) .Ei and (v2,C1,v2' ) .Ej \n(i = j) labeled with sequential commands C1 and C2 such that C1,t,h 1 T, C2,t,h 1 Tand C1 N (t,h) C2. \nTHEOREM 2 (Data race freedom). Suppose that (Qi,Ii)is a .xed point of the functional Fi obtained from \nan instantiation of the framework from Section 3.3 with the concrete domain from Sec\u00adtion 4.1 and a concretization \nfunction .satisfying (8). If (Qi,Ii)c T, then the program has no data races. The proof appears in Appendix \nB.  5.2 Thread-modular shape analysis with separated heap abstractions We de.ne a thread-modular analysis \nbased on a sequential shape analysis in which abstract states are represented by separation logic formulae. \nThe underlying sequential analysis is specialized for handling doubly-linked lists and is similar to \nthe one of [9]. The abstract domain Di is the domain of sets of separation logic formulae from the subset \nde.ned in Section 2 (Figure 2) and ex\u00adtended to handle variables as resources as described at the end \nof Section 4.2. A special element T.Di denotes an error. The order on the domain is subset inclusion \nwith Tbeing the topmost ele\u00adment. The concrete domain is the domain from Section 4.1 mod\u00adi.ed in the \nobvious way to account for multiple .eld selectors in structures. The concretization function is de.ned \nfollowing the se\u00admantics of separation logic formulae. The operation of separate combination Ion the \nabstract domain is just separating conjunction *lifted to the sets of formulae. Transfer functions are \nsimilar to those presented in [9, 12], but adapted for handling doubly-linked lists rather than singly-linked \nlists. Functions Localii , Frameii , Preii , and Initii mirror their concrete counterparts de.ned in \nSection 4.2. Their implementation is similar to the implementation of the oper\u00adations used in interprocedural \nshape analysis with an abstract rep\u00adresentation based on separation logic [12] to split the abstract \nheap at a procedure call (functions local and frame in [12]). The dif\u00adference with respect to the concrete \noperations is that instead of computing reachability precisely in the concrete, we compute its approximation \nreachability in the formula as de.ned in [12]. The analysis performs the sequential shape analysis of \nthe initialization code to obtain an abstract precondition pre i of the program. The reader may now revisit \nthe example in Section 2 to get the idea of how the analysis works. Note that to simplify presentation \nwe elided the discussion of treating variables as resources in the anal\u00adysis while presenting the example. \n   We note that in situations when all of the heap cells in the data structure protected by a lock \nare reachable from some set of program variables, the sets of exit points are empty and the set of program \nvariables protected by a lock forms a reasonable guess for the set of entry points associated with the \nlock. The set of entry points can then be inferred using, e.g., tools (both static and dynamic) for analyzing \ncorrelations between locks and variables that determine the set of locks that are held consistently each \ntime a variable is accessed [22, 25, 5]. 5.3 Other instantiations Distefano et al. [9] present a shape \nanalysis for singly-linked lists in which abstract states are represented by separation logic formulae. \nThe construction of a thread-modular shape analysis that uses [9] as the underlying sequential analysis \nis done in the same way as de\u00adscribed in Section 5.2. Unlike the domain presented in Section 5.2, the \ndomain from [9] is .nite provided the number of program vari\u00adables is bounded. Hence, the corresponding \nthread-modular analy\u00adsis is always guaranteed to terminate, which is not the case for the analysis presented \nin Section 5.2. Lev-Ami et al. [16] present a shape analysis that handles a wider range of data structures \nincluding singly-and doubly-linked lists and binary trees. Abstract states in the analysis are represented \nby shape graphs. To de.ne functions Localii , Frameii , Preii ,and Initii for this abstract domain we \nhave to be able to split shape graphs creating dangling pointers across splittings. The abstract represen\u00adtation \nof [16] does not allow dangling pointers, but can be ex\u00adtended [15] so that it is suitable for us in \na restricted case in which the set of exit points for each lock is empty and each stack vari\u00adable is \nowned by only one process or resource (i.e., sets Entry and Owns are pairwise disjoint). More precisely, \nas the concrete sepa\u00adration domain we again take the domain from Section 4.1. The ab\u00adstract domain is \nrepresented by a topped powerset of shape graphs extended to allow special unusable pointers. These are \npointers such that no information about them is preserved by the analy\u00adsis and dereferencing them results \nin an error. Adding them pre\u00adserves the .niteness of the domain. The operation of separate com\u00adbination \nis the union of shape graphs. Functions Localii , Frameii , Preii ,and Initii are de.ned following their \nconcrete counterparts in Section 4.2 using reachability in shape graphs. Since we assume empty sets of \nexit points, there may only be two kinds of dangling pointers: dangling pointers resulting from the delete \ncommand and pointers from the part of the heap computed by Frameii to the part of the heap computed by \nLocalii . Both of these kinds of pointers can be modeled in the abstract representation by unusable pointers. \n  6. Implementation and experimental results We have implemented the thread-modular shape analysis described \nin Section 5.2 in a prototype tool and applied it to multithreaded heap-manipulating code from Windows \ndevice drivers. The results from our experiments are presented in Figure 11. Tests were per\u00adformed on \na 3.4GHz Pentium 4 PC. In all of our experiments the maximum memory usage by the tool was 22MB. The sizes \nof ac\u00adtual C code (without comments, irrelevant de.nitions, etc.) that was analyzed for examples from \nFigure 11 ranged from 50 to 300 LOC. Each program we attempted to verify consisted of 2-6 threads representing \nconcurrently executing dispatch routines of device drivers that performed different operations on doubly-linked \nlists. The precondition of each thread was just the empty heap. Hence, according to the note at the end \nof Section 3.3, the results of our analysis are also valid for an unbounded number of copies of Threads \n3 6 9 12 15 Time (sec) 11.4 27.7 50.3 79.9 118.7 170.7 Figure 12. Results of testing the tool on programs \nwith varying number of threads threads that are present in the code. In all cases we let the sets of \nexit points for all locks be empty. The tool found bugs in three programs and proved that the rest of \nprograms are memory-safe, do not leak memory and are data race free. In each case the analysis converged \nwithin a few iterations. We have not encountered any false bugs in our experiments. The bugs found by \nthe analysis were due to accesses to data structures not protected by locks and would manifest themselves \nas dereferencing a dangling pointer or a memory leak. To speed up convergence to a .xed point in our \nimplementation we use a non-standard widening operator [8, 4] that eliminates re\u00addundant formulae from \nsets of formulae representing abstract states using a prover for entailment between separation logic \nformulae similar to the one described in [1]. The proof of Theorem 1 can be adjusted to ensure the soundness \nof the analysis using the widen\u00ading operator. Due to the use of the non-standard widening, in most cases \nthe .nal number of states per program point was 1 or 2. To assess the scalability of our shape analysis \nwe took program 2 and duplicated the code of threads in it knowing that the analyzer will not realize \nthat the threads are duplicates. The results are presented in Figure 12. As can be seen from the .gure, \nwe do not observe the analysis being exponential in the number of threads.  7. Related work The shape \nanalysis for concurrent programs presented in [26] han\u00addles unbounded numbers of locks (in the heap) \nand threads but re\u00adlies on abstracting program interleaving and thus does not scale well. A number of \nanalyses have been developed to detect races in multithreaded programs, both automatic (e.g., [25, 5, \n18, 22, 17]) and requiring user annotations (e.g., [10, 3, 14]). To the best of our knowledge all of \nthe automatic tools are either overly imprecise or unsound in the presence of deep heap update. The analyses \nthat require annotations, which are usually based on type systems, pre\u00adclude ownership transfer; besides, \nthe annotations required by them are often too heavyweight. In contrast, our analysis handles own\u00adership \ntransfer and requires lightweight annotations that can be in\u00adferred by existing automatic tools. Some \nof the techniques for race detection (including [22, 25, 5]) provide information about which locks protect \nwhich variables. Such techniques are complimentary to ours they can be used to discover entry points \nfor resource in\u00advariants needed by our analysis. Our method for constructing thread-modular shape analyses \nis inspired by concurrent separation logic [19], which adapted the idea of resource invariants to heap-manipulating \nprograms. Here we use this idea in the context of program analysis. However, it is important to note \na difference between the approach we are taking in this paper and the approach that is taken in concurrent \nseparation logic. In concurrent separation logic resource invariants have to be precise informally, they \nhave to unambiguously pick out an area of heap; see [19] for a formal de.nition. The reason is that having \nimprecise resource invariants leads to the possibility of choosing different splittings of the heap at \nrelease commands in a proof, which makes the conjunction rule of Hoare logic unsound. Here the determinism \nof heap splittings at release commands is enforced by using deterministic functions Locali and Framei. \nHence, in our analysis we can compute resource invariants without worrying about their precision and \nstill keep the analysis sound.  Test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16           Time \n(sec) 2.2 11.7 3.4 4.2 3.5 6.6 8.6 13.3 6.9 6.6 27.2 28.6 9.7 5.3 3.4 5.3  Bug found No No No No No \nNo No No No No No No No Yes Yes Yes Figure 11. Results of the application of the tool to multithreaded \ncode from Windows device drivers Previous work [6] presented a .xed-point characterization of re\u00adsource \ninvariants for integer programs with semaphores in the case when programs have no shared variables. This \npaper is the .rst, to the best of our knowledge, to present a .xed-point characterization of a class \nof resource invariants for heap-manipulating programs.  8. Conclusion We have described a new analysis \ndesigned to eliminate the consid\u00aderation of interleavings for programs with deep heap update while preserving \nsoundness and precision. Our analysis is able to estab\u00adlish that the program is memory-safe (i.e., it \ndoes not dereference heap cells that are not allocated), does not leak memory and does not have data \nraces (including races on heap cells). The analysis handles low-level language features including non-lexically \nscoped and nested locking, and memory disposal. Our solution works par\u00adticularly well in situations in \nwhich all of the heap cells in the data structure protected by a lock are reachable from some set of \npro\u00adgram variables as it is the case, e.g., in systems code. Acknowledgements. We would like to thank \nCristiano Calcagno, Dino Distefano, Peter O Hearn, Tal Lev-Ami, Stephen Magill, Ro\u00adman Manevich, Matthew \nParkinson, Andreas Podelski, Zvonimir Rakamaric, Ganesan Ramalingam, John Reynolds, Noam Rinetzky, Viktor \nVafeiadis, Hongseok Yang, Jian Zhang, and the anonymous reviewers for comments and discussions that helped \nto improve the paper. References [1] J. Berdine, C. Calcagno, and P. O Hearn. Symbolic execution with \nseparation logic. In APLAS 05: Asian Symposium on Programming Languages and Systems, volume 3780 of LNCS, \npages 52 68. Springer, 2005. [2] R. Bornat, C. Calcagno, P. W. O Hearn, and M. Parkinson. Per\u00admission \naccounting in separation logic. In POPL 05: Principles of Programming Languages, pages 259 270. ACM Press, \n2005. [3] C. Boyapati, R. Lee, and M. C. Rinard. Ownership types for safe programming: preventing data \nraces and deadlocks. In OOPSLA 02: Object-Oriented Programming, Systems, Languages, and Applications, \npages 211 230. ACM Press, 2002. [4] C. Calcagno, D. Distefano, P. W. O Hearn, and H. Yang. Beyond reachability: \nShape abstraction in the presence of pointer arithmetic. In SAS 06: Static Analysis Simposium, volume \n4134 of LNCS, pages 182 203. Springer, 2006. [5] J. Choi, K. Lee, A. Loginov, R. O Callahan, V. Sarkar, \nand M. Srid\u00adharan. Ef.cient and precise datarace detection for multithreaded object-oriented programs. \nIn PLDI 02: Programming Languages Design and Implementation, pages 258 269. ACM Press, 2002. [6] E. Clarke. \nSynthesis of resource invariants for concurrent programs. ACM Trans. Program. Lang. Syst., 2(3):338 358, \n1980. [7] P. Cousot and R. Cousot. Abstract interpretation: a uni.ed lattice model for static analysis \nof programs by construction or approximation of .xpoints. In POPL 77: Principles of Programming Languages, \npages 238 252. ACM Press, 1977. [8] P. Cousot and R. Cousot. Abstract interpretation frameworks. Journal \nof Logic and Computation, 2(4):511 547, 1992. [9] D. Distefano, P. W. O Hearn, and H. Yang. A local shape \nanalysis based on separation logic. In TACAS 06: Tools and Algorithms for Analysis and Construction of \nSystems, volume 3920 of LNCS, pages 287 302. Springer, 2006. [10] C. Flanagan and S. N. Freund. Type-based \nrace detection for Java. In PLDI 00: Programming Languages Design and Implementation, pages 219 232. \nACM Press, 2000. [11] C. Flanagan and S. Qadeer. Thread-modular model checking. In SPIN 03: Workshop \non Model Checking Software, volume 2648 of LNCS, pages 213 224. Springer, 2003. [12] A. Gotsman, J. Berdine, \nand B. Cook. Interprocedural shape analysis with separated heap abstractions. In SAS 06: Static Analysis \nSymposium, volume 4134 of LNCS, pages 240 260. Springer, 2006. [13] A. Gotsman, N. Rinetzky, J. Berdine, \nB. Cook, D. Distefano, P. W. O Hearn, M. Sagiv, and H. Yang. Abstract interpretation with state separation. \nIn preparation, 2007. [14] D. Grossman. Type-safe multithreading in Cyclone. In TLDI 03: Types in Languages \nDesign and Implementation, pages 13 25. ACM Press, 2003. [15] T. Lev-Ami. Personal communication. 2006. \n[16] T. Lev-Ami, N. Immerman, and M. Sagiv. Abstraction for shape analysis with fast and precise transformers. \nIn CAV 06: Computer Aided Veri.cation, volume 4144 of LNCS, pages 547 561. Springer, 2006. [17] M. Naik \nand A. Aiken. Conditional must not aliasing for static race detection. In POPL 07: Principles of Programming \nLanguages, pages 327 338. ACM Press, 2007. [18] M. Naik, A. Aiken, and J. Whaley. Effective static race \ndetection for Java. In PLDI 06: Programming Languages Design and Implementation, pages 308 319. ACM Press, \n2006. [19] P. W. O Hearn. Resources, concurrency and local reasoning. In CONCUR 04: International Conference \non Concurrency Theory, volume 3170 of LNCS, pages 49 67. Springer, 2004. [20] S. Owicki and D. Gries. \nVerifying properties of parallel programs: An axiomatic approach. Commun. ACM, 19(5):279 284, 1976. [21] \nM. Parkinson, R. Bornat, and C. Calcagno. Variables as resource in Hoare logics. In LICS 06: Logic in \nComputer Science, pages 137 146. IEEE Press, 2006. [22] P. Pratikakis, J. S. Foster, and M. Hicks. Locksmith: \ncontext-sensitive correlation analysis for race detection. In PLDI 06: Programming Languages Design and \nImplementation, pages 320 331. ACM Press, 2006. [23] J. Reynolds. Separation logic: A logic for shared \nmutable data structures. In LICS 02: Logic in Computer Science, pages 55 74. IEEE Press, 2002. [24] N. \nRinetzky, M. Sagiv, and E. Yahav. Interprocedural shape analysis for cutpoint-free programs. In SAS 05: \nStatic Analysis Symposium, volume 3672 of LNCS, pages 284 302. Springer, 2005. [25] S. Savage, M. Burrows, \nG. Nelson, P. Soblvarro, and T. Anderson. Eraser: A dynamic data race detector for multithreaded programs. \nACM Trans. on Comp. Syst., 15(4):371 411, 1997. [26] E. Yahav. Verifying safety properties of concurrent \nJava programs using 3-valued logic. In POPL 01: Principles of Programming Languages, pages 27 40. ACM \nPress, 2001. [27] H. Yang and P. W. O Hearn. A semantic basis for local reasoning. In FOSSACS 02: Foundations \nof Software Science and Computation Structures, volume 2303 of LNCS, pages 402 416. Springer, 2002. \nA. Proof of Theorem 1 (Soundness) and Let q .Dbbe de.ned as follows: for each location (v1,...,vm) q \n(v1,...,vj ,...,vm,L1,...,Lj ,...,Lm) 0 and admissible lockset (L1,...,Lm) \u00ab\u00ab q (v1,...,vj ,...,vm,L1,...,Lj \n,...,Lm). (15) \u00ab m I We .rst prove (14). Let sbe de.ned by (11) with L I I I = L1 ..... q (v1,...,v \nm,L1,...,Ln)= .Q(vi,Li) IIi 0 j ,Lj .{ i=1 \u00a3i.L ek}) and s2 = Q(vj,Lj ). We can m .{ek} L, s1 = Q(v (where \nL = L1 .....Lm) and for each location (v1,...,vm) and inadmissible lockset (L1,...,Lm), q (v1,...,vm,L1,...,Ln)= \n.. We show that F( q) q . By Park induction principle this implies that q = lfp(F) q , which is required. \nFirst of all, from (5) and (7) it follows that (F( q))(start1,...,startm,\u00d8,...,\u00d8) q (start1,...,startm,\u00d8,...,\u00d8). \nAccording to the de.nition of the functional F (Figure 3), it is now suf.cient to show that for all locations \n(v1,...,vj,...,vm), admissible locksets (L1,...,Lm), and edges (vj 0,C,vj ) .E it is the case that j \n0 gC ( q(v1,...,v j ,...,vm),L1,...,Lm) q (v1,...,vj ,...,vm,L1,...,Lm). (9) There are three cases corresponding \nto the type of the command C. Case 1. C is a sequential command. We have to show that fC ( q(v1,...,vj \n0 ,...,vm,L1,...,Lm)) q (v1,...,vj ,...,vm,L1,...,Lm). (10) Let L = L1 .....Lm, s1 = Q(vj 0,Lj ), s2 \n= Q(vj,Lj ),and assume that the lockset (L1,...,Lj .{ek},...,Las otherwise the left-hand side of (14) \nis ..Since ek .Lj, (14) is then equivalent to .(sIs1) .(sIs2 IIk). From the de.nition of the functional \nFi we get Localk(s1) s2 and Framek(s1) Ik. From the monotonicity of Iit follows that Localk(s1) IFramek(s1) \ns2 IIk. (16) Then, since *is monotone, .(sIs1)= .(s) *.(s1) by (3) .(s) *.(Localk(s1) IFramek(s1)) by \n(6) .(s) *.(s2 IIk) by (16) = .(sIs2 IIk) by (3) which proves (14). We now proceed to prove (15). Let \nsbe de.ned by (11) and let s1 = Q(vj 0,Lj ), s2 = Q(vj,Lj). Then (15) is equivalent to .(sIs1) .(sIs2). \nFrom the de.nition of the functional Fi we have that s1 s2. The required then follows from the monotonicity \nof . and I. So, in all the cases (9) is ful.lled, which implies the statement of the theorem. 0  B. \nProof of Theorem 2 (Data race freedom) m) is admissible s= 0 B@ Q(vi,Li) i=j and (v2,C1,v2) .Ej (i = \nj) labeled with sequential com\u00admands C1 and C2 such that C1,t,h 1 T, C2,t,h 1 Tand 1 CA.Since .(sIs)(Q,I)2 \nSuppose the contrary: there exist a location (v1,...,vm), \u00ab an admissible lockset (L1,...,Lm),a state \n(t,h) . I IIi . (11) I I Iq(v1,...,vm,L1,...,Lm), CFG edges (v1,C1,v1' ) .Ei 1=i=m, \u00a3i.L ' Then (10) \nis equivalent to fC (.(sIs1)) C1 N (t,h) C2.Let s1 = Qi(vi,Li), s2 = Qi(vj ,Lj ),and is a .xed point \nof the functional Fi, by the de.nition of Fi (Fig\u00adure5)weget s0 = 0 B@ I I Q i (vk,Lk) 1 CA I I I ! fi \nC (s1) s2. (12) i I . k Then, since *and . are monotone, 1=k=m, \u00a3k.L1.....Lm k=i, k=j fC (.(sIs1)) = \nfC (.(s) *.(s1)) by (3) Then by Theorem 1 and (3), (t,h) ..(s0) *.(s1) *.(s2). Hence, .(s) *fC (.(s1)) \nby (2) (t,h)=(t0,h0) *(t1,h1) *(t2,h2), (17) i .(s) *.(fC (s1)) by (4) where i = .(sIfC (s1)) by (3) \n(t0,h0) ..(s0), (t1,h1) ..(s1), (t2,h2) ..(s2). (18) .(sIs2) by (12) Case 2. C is acquire(ek). We can \nassume that ek .Lj , otherwise the left-hand side of (9) is .. Thus, we have to show that Since (Qi,Ii) \nc T, from the de.nition of the functional Fi (Figure 5) it follows that fi (s1) c T,fi (s2) c T. (19) \nC1 C2 q (v1,...,vj 0 ,...,vm,L1,...,Lj \\{ek},...,Lm) q (v1,...,vj ,...,vm,L1,...,Lj,...,Lm). (13) Let \ns be de.ned by (11) with L = L1 .... .Lm and let s1 = Q(vj 0,Lj \\{ek}) and s2 = Q(vj,Lj). Since the lockset \n(L1,...,Lm) is admissible and ek .Lj , (13) can then be rewrit\u00adten as .(sIs1 IIk) .(sIs2). From the de.nition \nof the func\u00adtional Fi we get s1 IIk s2. The required then follows from the monotonicity of Iand .. Case \n3. C is release(ek). We can assume that ek .Lj ,other\u00adwise the left-hand side of (9) is .. Thus, we have \nto show that q (v1,...,vj 0 ,...,vm,L1,...,Lj .{ek},...,Lm) q (v1,...,vj ,...,vm,L1,...,Lj ,...,Lm) (14) \nTherefore, fC1 (t1,h1) fC1 (.(s1)) by (18) .(fi C1 (s1)) by (4) c Tby (8) and (19) So, fC1 (t1,h1) c \nTand, analogously, fC2 (t2,h2) c T. Hence, C1,t1,h1 1 Tand C2,t2,h2 1 T. From this and the fact that \nC1 N (t,h) C2 using the de.nition of *and transfer functions for sequential commands given in Section \n4.1 we easily get that (t1,h1) *(t2,h2) is unde.ned, which contradicts (17). The intu\u00adition behind this \nis that from C1,t1,h1 1 Tand C2,t2,h2 1 Tit follows that both (t1,h1) and (t2,h2) should have the full \nper\u00admission for the same variable or location accessed by C1 and C2, which makes the state (t1,h1) *(t2,h2) \ninconsistent.  \n\t\t\t", "proc_id": "1250734", "abstract": "<p>We present the first shape analysis for multithreaded programs that avoids the explicit enumeration of execution-interleavings. Our approach is to automatically infer a resource invariant associated with each lock that describes the part of the heap protected by the lock. This allows us to use a sequential shape analysis on each thread. We show that resource invariants of a certain class can be characterized as least fixed points and computed via repeated applications of shape analysis only on each individual thread. Based on this approach, we have implemented a thread-modular shape analysis tool and applied it to concurrent heap-manipulating code from Windows device drivers.</p>", "authors": [{"name": "Alexey Gotsman", "author_profile_id": "81322494535", "affiliation": "University of Cambridge, Cambridge, United Kngdm", "person_id": "P831272", "email_address": "", "orcid_id": ""}, {"name": "Josh Berdine", "author_profile_id": "81100298282", "affiliation": "Microsoft Research, Cambridge, United Kngdm", "person_id": "PP33025071", "email_address": "", "orcid_id": ""}, {"name": "Byron Cook", "author_profile_id": "81323489213", "affiliation": "Microsoft Research, Cambridge, United Kngdm", "person_id": "PP40031078", "email_address": "", "orcid_id": ""}, {"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Tel-Aviv University, Tel-Aviv, United Kngdm", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250765", "year": "2007", "article_id": "1250765", "conference": "PLDI", "title": "Thread-modular shape analysis", "url": "http://dl.acm.org/citation.cfm?id=1250765"}