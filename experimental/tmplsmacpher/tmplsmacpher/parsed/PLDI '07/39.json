{"article_publication_date": "06-10-2007", "fulltext": "\n Searching for Type-Error Messages Benjamin S. Lerner Matthew Flower Dan Grossman Craig Chambers University \nof Washington {blerner, m.ower, djg, chambers}@cs.washington.edu Abstract Advanced type systems often \nneed some form of type inference to reduce the burden of explicit typing, but type inference often leads \nto poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers \nand presenting type\u00aderror messages in which the type-checker itself does not produce the messages. Instead, \nit is an oracle for a search procedure that .nds similar programs that do type-check. Our two-fold goal \nis to improve error messages while simplifying compiler construction. Our primary implementation and \nevaluation is for Caml, a lan\u00adguage with full type inference. We also present a prototype for C++ template \nfunctions, where type instantiation is implicit. A key ex\u00adtension is making our approach robust even \nwhen the program has multiple independent type errors. Categories and Subject Descriptors D.2.5 [Software \nEngineer\u00ading]: Testing and Debugging; D.3.4 [Programming Languages]: Compilers General Terms Languages, \nDesign Keywords Type-Checking, Type-Inference, Error Messages, Ob\u00adjective Caml, Seminal 1. Introduction \nAdvanced type systems play an increasingly important role in many modern programming languages. They \nhave widely touted bene.ts for detecting errors, expressing invariants, and enforcing abstrac\u00adtions. \nThey are central to many languages that originated in the re\u00adsearch community (such as ML and Haskell), \nand features such as parametric polymorphism are quickly gaining popularity in more commercially popular \nlanguages (such as Java and C#). Unfortunately, when types get complicated, it can be burden\u00adsome to \nrequire programmers to write down explicit types (e.g., on variables, function arguments, and type applications), \nso modern languages typically provide some form of type inference. In par\u00adticular, for the languages \nconsidered in this paper, Caml requires almost no type annotations and C++ often allows implicit instan\u00adtiation \nof template functions. While inference is amazingly conve\u00adnient for programs that typecheck, it often \nleads to inscrutable error messages for ill-typed programs. In particular, the type-checker of\u00adten reports \nerror locations that are far from the simplest source of the problem, an issue that has been acknowledged \nfor decades [22]. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 07 June 11 13, 2007, San Diego, California, USA. Copyright c . 2007 ACM 978-1-59593-633-2/07/0006. \n. . $5.00. Improving type-error messages would positively affect many programmers and would make type-system \nadvances more widely embraced, but addressing the problem can be a thankless task. Pro\u00adducing good messages \nduring inference is an engineering challenge that can lead to a larger, slower (even for code that type-checks), \nless maintainable, and potentially buggier compiler. Researchers developing novel uses for types generally \nfocus on programs that type-check, but bad messages for those that do not can hinder adoption of the \nideas. Researching the error-message problem it\u00adself leads to a dif.cult evaluation question: if an ill-typed \nprogram is semantically meaningless, how can we evaluate whether one error message is better than another? \nWe are pursuing a new approach to producing better type-error messages in the face of inference. Our \napproach requires no change to a compiler s existing type-checker. Instead, a search procedure looks \nfor a program close to the original one that does type-check. The search procedure has no knowledge of \ntype-system speci.cs; it simply uses the existing type-checker as an oracle to see if a change type-checks, \nwhich in turn guides further search. The messages complement the conventional approach of reporting a \ntype error by reporting changes that lead to type-correct programs. For example, a message might say \nthat f(x,y) (in the original code) does not type-check but f(y,x) (at the same location) does. This general \napproach has several advantages. (1) By not chang\u00ading the type-checker, it imposes no burden to compiler \ncorrectness or compile-time ef.ciency for well-typed programs. The computa\u00adtional cost of searching should \nbe measured against the speed of the human writing the program. (2) It can free the type-checker implementor \nfrom worrying about error messages, which often re\u00adquires maintaining extra state or traversing the program \nin a less convenient order. (3) It can produce better error locations because it can search for a small \nchange independently of how type inference works. (4) It can produce more concise and useful error messages \nbecause the compiler architecture makes it easy for the compiler writer to try a slightly different expression \nat a relevant location. In short, we believe searching for error messages is a rare win-win situation \nwhere we can simplify compiler construction (by decou\u00adpling error-message generation from type-checking) \nwhile improv\u00ading the programmers experience (by producing better messages). In a recent workshop paper \n[16] we described an initial pro\u00adtotype of our approach for Caml, which we called SEMINAL (for Searching \nfor Error Messages IN Advanced Languages). In ex\u00adtending this work to make it practical and evaluate \nits effective\u00adness, we have (1) developed an extended search procedure that works even when a function \nhas multiple independent type errors, (2) compared the error-message quality of our system to the very \nmature Caml type-checker on a large corpus of automatically col\u00adlected programs, and (3) implemented \na second prototype for C++ template-function errors. Our quantitative results for Caml show that we do \nbetter than the underlying type-checker and that support for multiple independent errors is important. \nOur preliminary expe\u00adrience with C++ suggests that the type-checker s messages (specif\u00ad Figure 1. The \ncompiler architecture for our approach ically gcc) can be so bad that any complementary technique is \nuse\u00adful. Adapting the approach to C++ raises some new technical chal\u00adlenges, but overall the two systems \nare reassuringly similar. The rest of this paper is organized as follows. Section 2 presents a complete \ndescription of our approach, proceeding in stages to present more sophisticated versions of our search. \nSection 3 de\u00adscribes our empirical evaluation on Caml .les we collected auto\u00admatically from students. \nSection 4 describes our prototype for C++ templates, emphasizing the differences due to the language \nand the platform. Section 5 discusses related work. Section 6 concludes.  2. Our Approach This section \nexplains how we produce type-error messages using a search procedure that does not require changing the \ntype-checker. For speci.city, we describe our Caml system and use Caml exam\u00adples, though the approach \ngeneralizes. The algorithm takes as input an untyped abstract-syntax tree that does not type-check. That \nis, the new compiler code sits between parsing and type-checking and is bypassed entirely for .les that \ntype-check. The output is a ranked list of error messages (though we often present only one to the programmer). \nFigure 1 shows how the main components of our system interact. The changer produces modi.ed untyped abstract-syntax \ntrees and uses the type-checker to see which ones type-check. These results guide subsequent search. \nThose that succeed in type-checking are also passed to the ranker, which sorts them. To explain how the \nchanger and ranker work in more detail, we proceed by describing increasingly more sophisticated techniques \nin our search procedure. Section 2.1 considers only changes that remove parts of the program, which suf.ces \nto understand our compiler architecture and how our approach can produce better error-message locations. \nSection 2.2 adds constructive changes, which lets the system produce error messages that can sometimes \nidentify the particular mistake in the program. Section 2.3 adds changes that identify when the problem \nis that a well-typed subex\u00adpression is used incorrectly. Finally and most importantly, Sec\u00adtion 2.4 modi.es \nthe search procedure so that it can .nd a precise type-error location if the input has multiple independent \nerrors. 2.1 Top-down Removal To understand the top-down nature of our search procedure, con\u00adsider the \nill-typed Caml program on the left of Figure 2. The func\u00adtion map2 correctly creates a list by applying \nf to corresponding elements of the two lists aList and bList. However, it expects f to take two arguments \nin curried form but the use of map2 in the binding of lst provides a function expecting one pair argument. \nHence this expression does not type-check and the type-checker re\u00adports an error. However, its decision \nto report an error for the addi\u00adtion expression x+y makes sense only to someone familiar with uni.cation-based \ntype inference and even then it requires nontrivial reasoning and manual type-checking to determine the \ntrue source of the error. The type-checker s error message is thus (1) nonlo\u00adcal (the location is not \nwhere the error was made), (2) inaccurate (the error has nothing to do with addition), and (3) misleading \n(no change at that location will make the program type-check). The searcher begins with the abstract \nsyntax for the entire ill\u00adtyped .le and descends recursively to .nd small subexpressions1 that could \nbe changed in some way to produce a type-correct program. The searcher works by constructing variations \nof the input program and calling the type-checker to see if the changes are successful. The searcher \n.rst tests increasingly-long pre.xes of the top-level de.nitions to .nd the .rst top-level de.nition \nthat has a type error. In our example, the searcher .nds that while the de.nition of map2 type-checks \nby itself, the de.nitions of map2 and lst together do not. It does not examine the third top-level binding \nbecause the second one already causes a type error. After localizing the type error to the second top-level \nbinding, the searcher proceeds to examine its initializer expression, i.e., map2 (fun (x, y) -> x + y) \n[1;2;3] [4;5;6] The searcher removes this entire expression, by which we ac\u00adtually mean it replaces it \nwith a wildcard expression that will always type-check in any context, and discovers that the modi.ed \nprogram now type-checks. In presenting error messages, we write [[...]] for the wildcard replacement \nexpression. For communi\u00adcating with the type-checker, we use raise Foo (where Foo is any exception) as \nthe wildcard, since it is always legal and introduces no constraints on type-checking.2 After learning \nthat removing the entire initializer expression eliminates the type error, the searcher attempts to localize \nthe type error by examining each of its subexpressions in turn and recur\u00adsively testing whether removing \nthat subexpression alone is suf\u00ad.cient to remove the type error. In this example, removing either map2 \nor (fun (x,y) -> x+y) removes the type error, but re\u00admoving [1;2;3] or [4;5;6] does not. Further recursion \non the two successful subexpressions does not identify any smaller subex\u00adpressions whose removal eliminates \nthe type error, so the searcher is done. In particular, no change to x+y (the expression identi.ed by \nthe type-checker) can produce a well-typed program. The searcher has identi.ed two candidate error locations, \nboth of which are less misleading than the one found by Caml s type\u00adchecker. Our ranker prefers changes \ncloser to the leaves in the abstract-syntax tree, but in this case the two suggestions are tied by this \nmetric. Therefore, the ranker would present both, favoring the removal of (fun (x,y) -> x+y) since there \nis a heuristic for preferring the expression on the right in a function application. The next section \nexplains that our system actually produces a much more precise message for this example. Another example \nwhere search outperforms the type-checker is letx =e1ine2 where e1 type-checks but does not have the \ntype the programmer intended and e2 uses x many times. The type\u00adchecker reports an error at a use of \nx but .xing this error only leads to another error at another use. Assuming e1 is smaller than e2, our \nalgorithm will suggest removing e1 (or a subexpression therein). 1 The searcher also tries changing members \nof other syntax categories (e.g., patterns and bindings), but our explanation focuses on expressions. \n2 In other languages, the lack of an expression with any type could compli\u00adcate top-down search; see \nSection 4 for how we deal with C++. (* List.combine : a list -> b list -> ( a * b) list *) (* List.map \n: ( a -> b) -> a list -> b list *) (* List.filter : ( a -> bool) -> a list -> a list *) let map2 f aList \nbList = List.map (fun (a, b) -> f a b) (List.combine aList bList) let lst = map2 (fun (x, y) -> x + \ny) [1;2;3] [4;5;6] let ans = List.filter (fun x -> x==0) lst Type-checker: The expression x+y has type \nint but is here used with type a-> b Our approach: Try replacing fun (x, y) -> x + y with funxy -> x+y \nof type int -> int -> int within context let lst = map2 (fun xy -> x+y) [1;2;3] [4;5;6]  Figure 2. A \nprogram where the approach outlined in Sections 2.1 and 2.2 produces a better error message than the \nunderlying type-checker. (The actual type-checker prints line/column information instead of expressions, \nbut that is an orthogonal issue.) 2.2 Constructive Changes For each expression for which its removal \nsucceeds in type\u00adchecking, we also try more speci.c modi.cations. What modi\u00ad.cations we try depends on \nthe kind of expression encountered (such as function application, conditional expression, pattern\u00admatch, \netc.) but does not depend on any type information. For function de.nitions that take a single tupled \nargument (such as (fun (x,y) -> x+y)), we try among other things chang\u00ading them to take curried arguments \n(e.g., (funxy -> x+y)), which for our example leads to an ideal result. The type re\u00adported in our message \nis simply what the type-checker gave to (funxy -> x+y); all we do is print it in case it is help\u00adful. \nIn our example, the algorithm also tries several other con\u00adstructive changes, such as permuting the arguments \nto map2, uncurrying the arguments to map2, and adding arguments to (fun (x,y) -> x+y), but these are \nunsuccessful. Because our ranker prefers constructive changes to removals, the error message in Figure \n2 is ranked highest for the exam\u00adple. Though we have experimented with various principled ranking measures \nsuch as tree-edit distance, we have found simple heuris\u00adtics such as this one suf.ce. Creating Constructive \nChanges The quality of error messages often depends on whether the algorithm attempts a constructive \nchange that concisely summarizes the reason the program does not type-check. Therefore, it is important \nto have an architecture that makes it easy for the compiler writer to de.ne changes and try them ef.ciently, \nand it is important to create an effective methodology for thinking of changes. In our experience, the \nbest approach when de.ning constructive changes for a kind of syntax node is to exploit both straightfor\u00adward \ntree manipulations (e.g., swapping the positions of children) and ad hoc knowledge of the language (e.g., \nthat currying versus tu\u00adpling can lead to errors). Figure 3 describes some of the changes we try, including \nexamples of both sorts. (For additional examples, see our prior work [16].) A key feature of our approach \nis that trying something unusual is a local decision that does not pollute type\u00adchecking (many of the \nchanges would be extremely awkward in the type-checker) and has no more cost beyond additional calls \nto the type-checker. Special cases are encouraged rather than discour\u00adaged. For example, to the type-checker, \n:= is just another function (with in.x syntax), but it can be misused in ways worthy of special cases. \nModular Implementation To manage the various changes, we decompose the changer into a searcher and an \nenumerator. The role of the enumerator is to take a syntax node and return a list of things to try (though \nwe re.ne this notion below). The enumerator is essentially a giant case expression that matches on the \nsort of node it is given and produces a list of modi.cations. It also returns the syntax children for \nthe purpose of recursive descent. The role of the searcher is to manage a worklist of changes to try \nand where in the overall abstract-syntax tree a change is being attempted (so that it can plug in the \nchange and call the type-checker). By separating out the enumerator, adding a new constructive change \ntypically requires only a few lines of code in the compiler and never requires modifying the core search \nprocedure. One could even imagine an open framework where programmers could add possible changes (especially \nsince it does not threaten compiler correctness), but we leave this to future work. More Ef.cient Search \nKeeping the number of changes tractable is necessary for ef.ciency. For example, trying all permutations \nof function arguments is exponential, so we should not try them all indiscriminately. Therefore, the \nenumerator/searcher interface is not just a large .at list of changes to try. Rather, the enumerator \nproduces a structured collection of changes where some changes are attempted only if other changes succeed \nor fail. For example, we can try changing (e1,e2,e3) to (raise Foo, raise Foo, raise Foo), to test whether \nany 3-tuple would type-check in this location, and follow up with trying permutations (e1,e3,e2), (e2,e3,e1), \netc., only if this succeeds. The follow-up changes are also computed lazily so that we reduce the amount \nof syntax created as well as reducing calls to the type-checker. For more details and more sophisticated \nexamples, see our prior work [16].  2.3 Adaptation to Context Consider the code if e1 e2 then e3 else \ne4, where e1 has type string->string and e2 has type string. The algorithm as presented thus far will \ngive the sort of concise and local message that compiler writers do not mind and programmers do: Try \nreplacing e1 with [[...]] of type string->bool within context if e1 e2 then e3 else e4 This suggestion \nbelies the fact that the function call e1 e2 does type-check it just does not type-check within its parent, \nwhich expects a bool at that location. It focuses on e1 rather than e1 e2; the ranker preferred it to \nthe larger change of replacing all of e1 e2. Fortunately, improving the algorithm amounts to adding just \none more attempted change that is as general as removal but is ranked more highly: see if the expression \nwould type-check if its result type were not constrained by its parent in the syntax tree. We call this \nchange adaptation (to context). In Caml, the simplest way to test this is to replace e with adapt e where \nwe de.ne:3 let adapt x = raise Foo 3 (e; raise Foo) works just as well. Example syntax node Example \nchange Description f a1 a2 a3 f a1 a3 Remove an argument from a function call f a1 a2 a3 f a1 [[...]] \na2 a3 Add an argument to a function call f a1 a2 a3 f a3 a2 a1 Reorder arguments in a function call f \na1 a2 a3 f (a1 a2 a3) Reassociate to make a nested call f a1 a2 a3 f (a1,a2,a3) Put call-arguments in \na tuple f (a1, a2, a3) f a1 a2 a3 Curry arguments instead of tupling e1.fld := e2 e1.fld <\u00ad e2 Replace \nreference-update with .eld-update [e1, e2, e3] [e1; e2; e3] Make an n-element list, not a 1-element list \nof an n-tuple let f x = e1 in e2 let rec f x = e1 in e2 Make a function recursive Figure 3. A small \nsample of constructive changes: some are systematic, such as rearranging a function call s arguments; \nothers are speci.c to idiosyncrasies of Caml s concrete syntax. The function adapt has type a . \u00df. Other \nlanguages may not have functions of such a general type, which could require a more complicated syntax-transformation \nto achieve the same effect. The one place where adaptation is not just another construc\u00adtive change is \nthe ranker. We prefer adapting larger expressions, whereas with other changes we prefer modifying smaller \nexpres\u00adsions. This preference is intuitive since it .nds a place high in the syntax tree where a type \nconstraint was unsolvable. It is also nec\u00adessary for our example. After all, adapting e1 also succeeds, \nwhich is only a bit more useful than the message without adaptation. Overall, the ranker prefers adaptation \nto removal, but prefers constructive changes to adaptation.  2.4 Triage for Multiple Errors The algorithm \nas presented thus far makes a fundamental assump\u00adtion that the program has one type error. If there is \nmore than one, the only changes likely to succeed involve removing an ancestor in the syntax-tree that \nincludes all the errors. Even within one top\u00adlevel function, this result can be terrible. Consider: letx \n=3+ true in ... (* many lines of correct code *) ... 4 + \"hi\" ... (* many more lines of correct code \n*) ... Suggesting this entire code fragment be replaced does not help the programmer .nd the errors. \nIn contrast, the conventional type\u00adchecker s messages do not suffer from this problem: the type\u00adchecker \nreports the .rst error it encounters. Extending our algorithm to .nd multiple small changes simul\u00adtaneously \nseems daunting especially since the number of errors is unknown. It is also of questionable worth since \nwe expect program\u00admers will often .x one error and recompile. Therefore, we extend our algorithm to recursively \nsearch for good error messages in one subtree while simultaneously removing one or more other problem\u00adatic \nsubtrees. We call this approach triage because it ignores some other parts of the program to focus on \none problem. In this way, we recover the speci.city the type-checker has by reporting one error while \nstill leveraging our algorithm s ability to search for effective locations and constructive changes. \nConsider .rst a simple scenario where the function application e1 e2e3e4 does not type-check, some of \nthe four subexpres\u00adsions are large, removing the entire application succeeds in elimi\u00adnating the type \nerror, and removing no single one of the four subex\u00adpressions succeeds. The changer would deem the suggested \nchange too large and enter triage mode to .nd a more speci.c error in this portion of the program. As \nbefore, the changer recursively searches (i.e., focuses on) each subexpression e1,..., e4 in turn, but \nin triage mode it does so in a context where some of the other ei are also re\u00admoved. By focusing on one \nsubexpression and removing some sib\u00adling subexpressions (thereby removing their type constraints), we \naim to .nd better error messages for the focused-on subexpression. Consider focusing on e1. Which of \ne2, e3, e4 should also be removed such that some modi.cation of e1 can be type-checked? One approach \nremoves them all, searching within e1 in the context e1 [[...]] [[...]] [[...]] to .nd an e1 such that \ne1 [[...]] [[...]] [[...]] type\u00adchecks, but removing all n- 1other expressions may leave e1 less constrained \nthan necessary. Another approach exhaustively com\u00adputes minimal subsets of the n - 1 expressions to remove \nwith which e1 can be .xed, but this is potentially exponential. We cur\u00adrently use an algorithm between \nthese extremes. We cumulatively remove the other n - 1 expressions one at a time in some order, test \neach context to see if it permits any .x for e1, and recur with the .rst one that succeeds. So for this \nexample we would try the following contexts in sequence:4 1. [[...]] e2 e3 e4 2. [[...]] e2 e3 [[...]] \n 3. [[...]] e2 [[...]] [[...]] 4. [[...]] [[...]] [[...]] [[...]]  For example, if (1) failed but (2) \nsucceeded, then we would recur on e1 in the context e1 e2 e3 [[...]]. (The .rst failure implies e4 overconstrains \nthe typechecker; the second success implies some .x exists for e1 at the very least, it can be removed.) \nWe use the same procedure to .nd contexts to use for focusing on e2, ..., e4. The results of the four \nrecursive searches are passed to the ranker, which in addition to its preference for small changes has \na preference for removing fewer of the other n - 1expressions. While Section 3 demonstrates that triage \nis important, our intu\u00adition is that the details of the algorithm for removing other expres\u00adsions are \nless important. There are many variations we could try, but our current procedure has proven effective. \nHandling Binding Occurrences The example above did not in\u00advolve an expression with variable bindings, \nsuch as a pattern-match expression. For such expressions, we cannot delete the binding oc\u00adcurrences and \nexpect other subexpressions to type-check since they may now refer to unbound variables. We therefore \nre.ne the triage search for such expressions to include phases. As an example, we describe how triage \nworks for the pattern match in Figure 4. The .rst phase focuses on the scrutinee (x,y), type-checking \nit in a context where the patterns and correspond\u00ading expressions have been removed. If this does not \ntype-check, the changer would just recur on it in the reduced context and not proceed to subsequent phases, \nskipping searching the patterns and expressions. In this example, the scrutinee does type-check, so we \nproceed. In the second phase, we add the patterns, type-checking the scrutinee and the patterns in a \ncontext where the corresponding 4 We need not actually try the .rst one since we already know it failed \nnor the last one since it must always succeed. Original expression: First phase: scrutinee only (* val \nx: int *) match (x, y) with (* val y: a list *) _ -> [[...]] match (x, y) with Second phase: patterns \n0,[] -> [] match (x, y) with | n, [] -> n 0, [] -> [[...]] | _,5 ->5+ \"hi\" | n, [] -> [[...]] | _, 5 \n-> [[...]] Third phase: entire expression match (x, y) with 0,[] -> [] | n, [] -> n | _,5 ->5+ \"hi\" Figure \n4. A pattern match with several type errors, and the three phases that triage attempts to isolate them. \nexpressions have been removed. If the combination of the scruti\u00adnee and the patterns type-checks, then \nwe would proceed to the third phase, where we would perform triage on the corresponding expressions. \nIn this example, the patterns do not type-check. With a triage procedure similar to that for subexpressions \n(trying each pattern with a greedy subset of others that work), we can report: Your code has several \ntype errors. If you ignore the surrounding code, try replacing 5 with _ in match (x, y) with 0, [] -> \n[[...]] | n, _ -> [[...]] | _, _ -> [[...]] Triage is crucial for reaching this result because two of \nthe triaged expressions fail to type-check (the .rst two branches have incom\u00adpatible types and 5+\"hi\" \nis always ill-typed). In this example, hav\u00ading an algorithm that is robust to multiple errors avoids \ntelling the programmer to remove an entire match expression, which is almost never useful. Integrating \nTriage and Search Extending the architecture in Fig\u00adure 1 to support triage is nontrivial because, unlike \nadding new con\u00adstructive changes or adaptation, it affects the core search procedure. As described above, \nthe searcher maintains a mode for each syntax node of interest and switches from regular to triage mode \nwhen the only regular suggestion for a node with a nontrivial number of de\u00adscendents is removing it. \nWe have a second enumerator for triage mode since the work for ordering the changes into phases and the \ngreedy algorithm for deciding what branches to prune are quite dif\u00adferent from the regular changes. When \nthe searcher recurs for each focused subexpression in triage it again uses regular mode, which can in \nturn invoke additional triage on its subtrees. The ranker prefers triaged solutions least of all. When \ncompar\u00ading different triaged solutions, it prefers small changes. The details of the ranking are less \nimportant than the nontrivial question of how to present results using triage to the programmer. We .rst \nprint only the small change found as a result of triage and a message indicat\u00ading triage occurred (i.e., \nthat other type errors remain, meaning the change will not make the program type-check by itself). We \nalso print a representation of which parts of the program were triaged, but our experience is this information \nis only occasionally useful. 3. Empirical Evaluation for Caml To evaluate our approach s effectiveness, \nwe collected Caml pro\u00adgrams from students and manually inspected the error messages from (1) the underlying \ntype-checker, (2) our approach without triage, and (3) our approach with triage. The results show that: \n For most programs, our approach and the type-checker produce messages of comparable quality (suggesting \nit is reasonable to pursue our approach in lieu of type-checker messages as a way to simplify compiler \nconstruction).  For a signi.cant number of programs, our approach produces a message that is at a better \nlocation or signi.cantly more accu\u00adrate in identifying the problem (suggesting that our approach adds \nvalue even for compilers that already have good type\u00adchecker messages).  Triage provides a signi.cant \nimprovement over the system with triage disabled.  Section 3.1 discusses our methodology, which tries \nto minimize the inevitable subjectivity of the evaluation. Section 3.2 presents overall statistics. Section \n3.3 presents some real examples where our approach works well. 3.1 Methodology Data Collection: Students \nin one of the author s courses were asked to volunteer to use a modi.ed version of the Caml compiler \nthat stored to the local disk (1) any .le passed to it that did not type-check and (2) a timestamp for \nthe .le. This compiler did not have our approach implemented; it was just a data collector. Students \nthen emailed the collected .les to us. So volunteers opted in twice: when they installed the modi.ed \ncompiler and when they sent us results. The saved .les had comments obfuscated (e.g., (* hi mom *) replaced \nwith (* XX XXX *)) since we thought this might encourage participation. The course was a graduate-level \nprogramming-languages course for part-time students with at least two years professional software\u00addevelopment \nexperience. We believe this population is particularly interesting: they were not beginner programmers \nbut they were new to Caml. We analyzed 5 homework assignments, each requir\u00ading 100 200 lines of code. \nWe plan to make the assignments and data available. 10 of 44 class members participated. Analysis: When \nmanually analyzing a .le and the quality of the three error messages, it is necessary to identify the \nactual problems. Doing so is inherently subjective, so we simply removed any .les for which it was unclear. \nTwo factors make this process less subjective. First, using the time-sorted .les we can see what the \nprogrammers actually changed in the near-future. Second, the code is for a speci.c programming task; \nwe are not trying to determine the purpose of arbitrary code. When a collection of .les in time sequence \nall have the same problems, we count them only once (choosing a representative .le from the equivalence \nclass). This quotienting of results is important for two reasons. First, it normalizes for different \nprogrammers behavior since some programmers tend to try recompiling much more often than others. Second, \nthe programmers were getting only the type-checker s messages. So in cases where our approach is superior \none would expect a misleading type-checking message to lead to several .les with the same problem while \nthe programmer discovers the misdiagnosis. Counting each of these .les separately would make our approach \nlook better. A second potential source of subjectivity is determining whether an error message accurately \ndescribes one of the real type-checking problems. However, the program location identi.ed by a message \nis not subjective, so we separately counted whether a message iden\u00adti.ed a good location and whether \na message described the prob\u00adlem at that location correctly. Considering only location strictly in\u00adcreases \nthe number of good results for each of the three error mes\u00adsages, but only slightly, so due to space \nconstraints we have chosen only to report the theoretically more subjective measurements.  (a) Results \nseparated by programmer (b) Results separated by assignment Figure 5. Results separated by programmer \nand by homework assignment; programmer experience increases for higher-numbered assign\u00adments. Moving \nfrom bottom to top, the stacked bars represent .les where (1) both approaches (type-checker and our approach) \nproduce an equally good message even without triage, (2) both approaches produce an equally good message \nbut triage is necessary, (3) our approach is better even without triage, (4) our approach is better but \ntriage is necessary, and (5) our approach is inferior to the type-checker.  Figure 6. Size of groups \nof .les that are the same problem. In results, only one .le from each group is counted. Note log-scale. \nValidity: In addition to the subjective evaluation described above, we can identify some other threats \nto validity. Because we wrote the homework assignments and taught Caml programming, we could have implicitly \nencouraged a programming style or designed homeworks for which one error-message style is better. There \ncould also have been bias in the self-selection of participants. On the other hand, we should not discount \nour overall conclu\u00adsion that our approach is usually comparable to the type-checker s messages and is \noften better. Our prototype is still preliminary com\u00adpared to the mature type-checker which has been \nused and re.ned for many years. We also did not allow ourselves to modify the im\u00adplementation after we \nstarted analyzing the .les. The data suggests a few new constructive changes we can easily add to our \ntool. This feedback and the ease of exploiting it is a bene.t of our approach and would, of course, signi.cantly \nimprove our results. 3.2 Aggregated Results We start by presenting our primary results and then provide \nsome additional data to describe our set of sample .les and the ef.ciency of our prototype. For each \n.le we analyze (recalling that for a group of .les in time-sequence with the same error we analyze only \none), we consider three messages (from the type-checker, from our approach, and from our approach with \ntriage disabled). We then place the .le in one of these .ve categories: 1. Our approach produces a message \ncomparable in quality to the type-checker, and triage is unnecessary to achieve this tie. 2. Our approach \nproduces a message comparable in quality to the type-checker, and triage is necessary to achieve this \ntie.  Figure 7. Cumulative distribution of time to run our prototype on the analyzed .les. The bottom \ncurve is for our full tool. The middle curve disables one constructive change with a performance bug. \nThe top curve disables triage. 3. Our approach produces a message better than the type-checker, and triage \nis unnecessary to achieve this win. 4. Our approach produces a message better than the type-checker, \nand triage is necessary to achieve this win. 5. The type-checker produces a message better than our \napproach.  As the TOTAL bars in Figure 5(a) and Figure 5(b) show, our approach is better (the sum of \ncategories 3 and 4) 19% of the time and the underlying type-checker is better 17% of the time. Adding \ntogether categories 1 4, our approach is no worse 83% of the time, supporting our claim that one could \nfeasibly not rely on the type\u00adchecker s messages at all. Triage increases by 44% the .les for which our \napproach pro\u00adduces a better result (category 4 divided by category 3) and in\u00adcreases the ties by 19% \n(category 2 divide by category 1). In all, triage improves our results for 16% of the .les (sum of categories \n2 and 4). Qualitatively, in the cases where triage helps, it helps a lot without it, the messages are \ntypically much worse than those from the type-checker. Not shown in the graphs is a distinction between \nties where both approaches produce a good message and ties where both approaches produce a bad message. \nWe deemed 9% of the .les ties where no approach was very helpful, suggesting that type errors could still \nbe improved, though this number is in.ated by input programs too nonsensical for a reasonable message. \nFigure 5(a) separates the results by programmer to see if per\u00adsonal coding style might affect the results. \nFigure 5(b) separates the (* List.mem : a -> a list -> bool *) let add str lst = if List.mem str lst \nthen lst else str::lst (* ... in a function later in the file ... *) add vList1 s Type-checker: The expression \ns has type string but is here used with type string list list Our approach: Try replacing add vList1 \ns with add s vList1 ... Figure 8. Example where our approach .nds a better message. results by homework \nassignment; programmers are more familiar with Caml on later homeworks. While there is signi.cant variation, \nsample sizes are moderate and we can draw no .rm conclusions. Figure 6 shows how big the equivalence \nclasses of time-ordered .les with the same problem are. While most equivalence classes are very small, \nwe would have been over-counting by having hundreds more data points had we not chosen representatives \nfrom each class. In all, we analyzed 1075 .les from a total of 2122 collected. Finally, Figure 7 presents \na cumulative distribution function of the time our prototype took to run on the analyzed .les. The full \napproach completed in less than 4 seconds on over 75% of .les and less than 30 seconds on over 90% of \n.les.5 We conclude that the prototype is already usually ef.cient enough to replace the conven\u00adtional \napproach and is almost always a complementary technique worth using while puzzling over the type-checker \ns message. More importantly, our collected .les now give us our .rst opportunity to debug the performance \nof our system. (Recall we made no changes to the system after we started the manual analysis.) The additional \ndata in Figure 7 suggest improving performance will be easy. First, about one third of the .les that \ntake longer than 4 seconds do so be\u00adcause of a single performance bug in a single constructive change \nthat has to do with reparenthesizing nested match-expressions. Sec\u00adond, without triage the newest part \nof our system and therefore the part that we have optimized least not a single .le takes longer than \n4 seconds and over 95% take less than 2 seconds. 3.3 Examples In analyzing the .les we collected from \nreal programmers, we found many compelling situations where our approach produced better locations, produced \nmore accurate messages, or used triage to avoid a poor message. Here we share a few examples. 6 Figure \n8 shows the de.nition and subsequent use of a function add intended as a simple utility for adding a \nstring to a list. The pro\u00adgrammer passed the arguments to add in the wrong order, but add actually has \nthe polymorphic type a -> a list -> a list, so the .rst argument of type string list constrains the second \nto have type string list list. Hence the type-checker s error message is in a reasonable location, but \nonly programmers used to the idiosyncrasies of polymorphic types and uni.cation-based type inference \n.nd this message intuitive. 5 Qualitatively, time is not correlated with size of the .le; the search \nquickly descends into a small portion of the .le. 6 As in Figure 2, we modify the type-checker s messages \nto use expressions rather than line numbers. type move = For of int * (move list) | (* ... *) let rec \nloop movelist x y dir acc = (* ... some other local bindings ... *) match movelist with [] -> acc | For(moves, \nlst)::tl -> let rec finalLst index searchLst = if (index = (moves-1)) then [] else (List.nth searchLst) \n ::(finalLst (index+1) searchLst) in loop (finalLst 0 lst) x y dir acc | (*... branches for other kinds \nof moves ...*) Type-checker: The expression (finalLst 0 lst) has type (int -> move) list but is here \nused with type move list Our approach: Try replacing (List.nth searchLst) with (List.nth searchLst [[...]]) \n... Figure 9. Example where our approach .nds a better location. Figure 9 shows a larger example where \nour approach .nds a better location. The code, extracted from an attempt to write a small-step interpreter \nfor a simple Logo-like language, de.nes a recursive local helper function finalLst that is supposed to \nre\u00adturn a move list. However, the call to List.nth has one too few arguments, which is not in itself \nan error because this is just a partial application of a curried function. In fact, finalLst still type-checks, \nbut as a function that returns a list of functions (type (int -> move) list). Hence the type-checker \nreports no er\u00adror until the result of a call to finalLst is passed to the outer function loop, which \ndue to its pattern-match expression needs a move list. Our top-down search .nds small suggestions both \nin the body of finalLst and its use, but only in the former is there a constructive change (adding an \nargument to the call to List.nth), which becomes the top-ranked suggestion. Most examples with triage \nare too large to be shown in their entirety, but we can describe a scenario where it is necessary for \ndoing as well as the type-checker. Suppose the programmer calls print in each branch of a match-expression \nwhere the actual standard-library function is called print_string. The underlying type-checker works \nwell, .nding one use of print and reporting it as an unbound variable. Our approach without triage is \nterrible, suggesting removal of the entire match expression. With triage, we determine that the match-expression \ntype-checks except for the expressions in the branches and that one of the branches can be .xed by removing \na call to print. In fact, because removing print works but replacing it with adapt print does not, we \ncan conclude that print is an unbound variable. Improving our tool s presentation to report unbound variable \nwhen removing a variable works but adapting it does not would be straightforward and is independent of \nthe search algorithm. There are coding practices for which our approach is ill-suited. As an extreme \nexample, consider again letx =e1ine2 where x is used many times in e2. Savvy ML programmers who change \ne1 to have a different type may rely on the type-checker to .nd all the uses of x. Our approach will \ninstead suggest changing e1 (perhaps back to what it was), which is clearly not desired. 4. Prototype \nfor C++ Template Functions While our approach is ideal for an ML-like language (type infer\u00adence creates \na need, and polymorphic types for expressions like raise Foo aid the implementation), the bene.ts extend \nbeyond strongly typed functional languages. As a proof of concept, we have developed a prototype for \nproducing error messages for C++ programs that use template functions, which are common because template \nfunctions pervade the Standard Template Library (STL). This section explains our focus on template functions \n(Section 4.1), describes how we modify our approach for the C++ language (Sec\u00adtion 4.2), and sketches \nour prototype (Section 4.3). 4.1 The Problem with Templates C++ does not generally suffer from nonlocal \ntype-error messages because all variables and functions have explicit, monomorphic types, so we see insuf.cient \nneed to change how most type-error messages are produced. Template functions, however, are fertile ground: \nthey take type parameters the caller need not specify, and some type-checking of template bodies is delayed \nuntil each use. Misuse by a client often manifests itself as a type error several layers deep in template \ncalls. As a simple example, consider this template function in the commonly used gcc extension to the \nSTL: template <class _Operation1, class _Operation2> compose1(const _Operation1&#38; __fn1, const _Operation2&#38; \n__fn2) { return unary_compose<_Operation1,_Operation2> (__fn1, __fn2); } The function is a polymorphic \nwrapper around a template class (unary_compose) for representing the composition of two func\u00adtors. 7 \nNot seen here is that arguments to compose1 must have par\u00adticular STL types or an error arises in the \nbody of unary_compose. Compilers like gcc do report the location of the outermost template call, but \nthe programmer must still manually dissect the error and call-chain to determine how to change the client \ncode. Continuing our example, consider the C++ code in Figure 10. The intended effect is to initialize \nthe elements of outv with a function of the inv values. Using the higher-order features of the STL keeps \nmyFun concise and at a high level of abstraction; we generally encourage code in this style. It is also \nalmost type-correct. The problem is compose1 expects to receive two functors, and labs is merely a function \npointer. The STL provides a function ptr_fun to convert a function pointer to a functor; the .x is to \nadapt labs by writing ptr_fun(labs). The use of functors is not universal, however; other places in template \nlibraries require function pointers. In short, this sort of error is simple, easy to make, and (with \nthe right diagnosis) easy to .x. The error messages reported by gcc for this error are shown in Figure \n11. The .rst eight lines do describe the problem, but in terms of a bad template call several layers \ndeep in the functional library. The remaining lines describe a no template found error that is a cascading \nerror resulting from the .rst problem. As in\u00adscrutable as these messages may seem, we have chosen an \nexam\u00adple where they are tractably small. If we had made the same mis\u00adtake for an operation over vector<vector<long> \n> instead of vector<long> (and vectors of vectors are certainly a realistic use of the STL), the messages \nwould have been over twice as long. Our approach, of course, produces an error message indicating that \nchanging labs to ptr_fun(labs) eliminates the typing errors in myFun. Because ptr_fun is just a library \nfunction, it is an ad 7 This STL term for classes representing function closures should not be confused \nwith the functors of ML or category theory. #include <algorithm> // for transform #include <vector> // \nfor vector #include <functional> // for multiplies, bind1st, ptr_fun #include <ext/functional> // for \ncompose1 #include <cmath> // for labs using namespace std; using namespace __gnu_cxx; // compute outv[i] \n= labs(5 * inv[i]) void myFun(vector<long>&#38; inv, vector<long>&#38; outv){ transform(inv.begin(), \ninv.end(), outv.begin(), compose1(bind1st(multiplies<long>(),5), (labs))); // type error } Figure 10. \nAn STL client with a type error hoc constructive change to try wrapping function pointers with it. Trying \nthis change is justi.ed by its usefulness. 4.2 Our Approach in C++ The algorithm we use for Caml largely \nworks for C++, but there are interesting differences in how we perform top-down search, what constructive \nchanges we try, how we do adaptation, and how we call the type-checker. We highlight the most important \ndifferences. Top-Down Search and Adaptation Because C++ is explicitly typed, we do not .nd it necessary \nto perform search over the en\u00adtire program. Rather, we consider only a function containing a template-call \nerror8 and any template functions it may call (transi\u00adtively). Within a function body, removing statements \nand initializer expressions is trivial because we can just delete them. However, removing or adapting \nan expression proves more dif\u00ad.cult because we do not have the convenience of expressions like raise \nFoo (which can have any type) or adapt (which can take any expression and have any return type). Ironically, \nwe can (ab)use a template function to create expressions of the right type: template <class A, class \nB> B magicFun(A x){ for (;;);}; Now, removing an expression e can mean replacing it with magicFun(0) \nand adapting it can mean replacing it with magicFun(e). Unfortunately, using magicFun is imperfect be\u00adcause \nC++, for deep reasons involving ambiguity and overloading, does not have full inference. So in many contexts, \nmagicFun(0) or magicFun(e) will not type-check because an appropriate return type cannot be resolved. \nAs a result, our changer often resorts to alternate techniques to determine which subexpressions contain \ntyping errors. Most sim\u00adply, we can hoist expressions (e.g., replace e0(e1,e2); with e0; e1; e2;), taking \nsome care to circumvent odd C++ restrictions (e.g., function names cannot appear as top-level expressions).9 \nFull hoisting is sometimes avoidable with additional C++ chicanery. For example, given x =e, we can retain \nthe constraint that e has a type compatible with x by replacing the assignment with magicFunAssign(x,e) \nwhere we de.ne: template <class A, class B> A magicFunAssign(A&#38; x, B e) { x = adapt<A>(e); return \nx; } 8 Simple processing of the error message identi.es the location, and the abstract-syntax tree indicates \nthat the location contains a template call. 9 It suf.ces to wrap the expressions with a void-returning \nvariant of magicFun. /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/ext/functional: In instantiation \nof __gnu_cxx::unary_compose<std::binder1st<std::multiplies<long int> >, long int ()(long int)> : ../tester2.cpp:9: \ninstantiated from here /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/ext/functional:128: error: long \nint ()(long int) is not a class, struct, or union type /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/ext/functional:136: \nerror: long int ()(long int) is not a class, struct, or union type /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/ext/functional:131: \nerror: field __gnu_cxx::unary_compose<std::binder1st<std::multiplies<long int> >, long int ()(long int)>::_M_fn2 \ninvalidly declared function type /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/stl_algo.h: In function \n_OutputIterator std::transform(_InputIterator, _InputIterator, _OutputIterator, _UnaryOperation) [with \n_InputIterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int, std::allocator<long int> \n> >, _OutputIterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int, std::allocator<long \nint> > >, _UnaryOperation = __gnu_cxx::unary_compose<std::binder1st<std::multiplies<long int> >, long \nint ()(long int)>] : ../tester2.cpp:9: instantiated from here /usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/stl_algo.h:789: \nerror: no match for call to (__gnu_cxx::unary_compose<std::binder1st<std::multiplies<long int> >, long \nint ()(long int)>) (long int&#38;) Figure 11. The error message from gcc for Figure 10, with additional \nlinebreaks to improve readability. Constructive Changes As expected, each language has different common \nerrors worth detecting. For C++, we try several language\u00adlevel changes (e.g., switching e.f to e->f and \nvice-versa), as well as changes speci.c to the STL (such as adding or removing ptr_fun). Other changes \nare just like in Caml, such as rearranging arguments at a call-site. Calling the Type-Checker As explained \nbelow, instead of mod\u00adifying gcc, we print each change in concrete syntax and call the type-checker. \nBecause C++ is prone to cascading errors during compilation, we focus solely on the .rst error and speci.cally \non the line it cites as instantiated from here. However, we maintain all the reported error lines, so \nthat we can properly evaluate whether a modi.cation succeeded or not: if it eliminates some errors while \nintroducing no new ones, it is a success. Partially implicit in this de.nition is a notion of triage: \nwe ignore any later erroneous code, so that we can focus on suggestions for one statement. 4.3 Implementation \nOur prototype is implemented as a plugin for the Eclipse 3.2 IDE, using the CDT 3.1 plugin (which provides \nan abstract syntax tree for C++) and gcc (since we assume the type-checker s error mes\u00adsages are in a \nparticular format). We take an abstract syntax tree, change it, and use the CDT to print it to a .le, \nwhich we then pass to gcc. While this architecture makes for an expedient prototype, the process and \nI/O overhead of printing and parsing the program for each change is too high for interactive use. On \nthe other hand, by using an IDE we have the ability to perform our algorithm in the background. Moreover, \nour presentation of error messages uses Eclipse s support for problem markers and quick .xes. That is, \nwe provide a marker in the user interface that brings up a menu item, such as, replace this expression \nby wrapping it in ptr_fun. 5. Related Work This work extends and evaluates the approach advocated in \nour recent workshop publication [16]. We discuss our relation to that work before discussing other approaches \nto improving type\u00adchecker error messages and other related techniques. 5.1 SEMINAL We have extended our \nprior work in the following important ways: Our prior work had no way to give good error messages when \nthe same function had multiple independent type errors. Triage (Section 2.4) overcomes this fundamental \nproblem, and our results demonstrate that triage is signi.cant in practice.  Our approach of adapting \nexpressions to their context (Sec\u00adtion 2.3) is new, can sometimes lead to much more accurate  messages, \nand requires a different approach to ranking since a large expression may need only a small adaptation. \n Our prior work had no evaluation of the system s effectiveness (only that it was reasonably ef.cient). \nOur analysis on actual .les (Section 3) is, to our knowledge, the only evaluation of its kind ever completed \nand encompasses a larger sample set than anything considered by another system.  Our prototype for C++ \ntemplate-function instantiation errors is entirely new and requires different techniques than in Caml. \n Our prior publication includes more details on the implementa\u00adtion of the SEMINAL system for Caml, \nparticularly the interaction between the searcher and the enumerator. 5.2 Other type-checker approaches \nWhile SEMINAL was hardly the .rst project to attempt to address the nonlocal and unintuitive nature of \nML-style type-error mes\u00adsages, all prior approaches of which we are aware made pervasive changes to the \ntype-checker. Doing so makes compiler construc\u00adtion and the ef.cient compilation of well-typed programs \nmore dif\u00ad.cult. Such changes take many forms, including trying different program-traversal orders (thereby \nchanging the order of the under\u00adlying uni.cation problem) [15, 17], maintaining slice information to \nrecord what expressions affect what parts of the uni.cation prob\u00adlem [5, 10, 21], and providing an interactive \nenvironment revealing the internals of the type-inference algorithm [4, 20]. Heeren s re\u00adcent summary \n[11] of these systems and others [1, 2, 7, 8, 9, 13, 22] provides more details. The approach most similar \nto ours is from McAdam [18]. He en\u00adriches the type-checker with type-level linear morphisms that can \nbe used to make a program type-check that otherwise would not. For example, a morphism from t1 . t2 . \nt3 to t2 . t1 . t3 would allow f xy to type-check even if it should be fy x. The resulting error message \ncan then show what morphisms were used. While this clearly has commonalities with our constructive changes, \nit has the same nonlocal problems as the conventional ap\u00adproach (it never searches for other locations) \nand presents messages in terms of types that the programmer never wrote. For C++ template errors, there \nare ad hoc tools available that post-process error messages to make them more readable [24]. The process \nlargely involves regular-expression matching to trim out namespaces and other irrelevant features of \nerror messages. We view the existence of such tools as evidence of a problem rather than as a complete \nsolution. Unlike our tool, the result is still in terms of types and does not analyze the source program. \n5.3 Other work Parsing errors can also be nonlocal and unintuitive. Structurally, the problems are different \nbecause parsing takes a token stream instead of an abstract syntax tree. Nonetheless, the approach by \nBurke and Fisher [3] is similar in that an error-.nder separate from the parser tries single-token changes \n(by directly changing the parse-stack) and seeing which ones lead to more progress in parsing. Also note \nthat a compiler may often treat as a type error what the programmer views as a parsing error. For example, \nin Caml [1,2,3] is a list holding one triple whereas [1;2;3] is a list of three integers. Our tool presents \na good message in this case be\u00adcause it always tries replacing a list with one tuple with a list hold\u00ading \nthe tuple s elements. In the tool this is a syntax-tree transforma\u00adtion, but the actual error message \nis in concrete syntax, giving the illusion of suggesting a parsing change. The dynamic testing technique \nof delta-debugging is another example of automatic search to produce a concise error. Recent work has \nfocused on changing dynamic program state [6]. Older work on changing the program code worked by applying \na subset of changes between two versions [23] under the assumption that the new version had a bug the \nold version did not. In our setting, it is much less clear this assumption is valid or that consulting \na previous version of the code would be fruitful. Ongoing work on adding concepts to C++ [12, 19] aims \nto make type-checking for templates more modular. This work ac\u00adknowledges that nonlocal errors and long \nmessages (hundreds or thousands of lines) are real problems with templates. It is men\u00adtioned that preliminary \nexperience with concepts shows they can improve the situation. In terms of the example in Figure 10, \nus\u00ading concepts in the STL would probably lead to the correct error location (in the client), but not \nmake the .x any more intuitive. Concepts add additional static checking via more-explicit type in\u00adformation \n(template writers indicating requirements about template parameters), so less-annotated code would remain \nproblematic. 6. Conclusions By decoupling type-checking from the generation of type-error messages, we \nhave pursued a novel approach to circumventing the tension among type inference, ef.cient type-checking, \nand quality error messages. We have developed proofs-of-concept in two quite different settings and carefully \nevaluated the effectiveness of one of the systems. Our approach often .nds good messages that describe \ndifferent program locations and are more concise than the conven\u00adtional approach of producing error messages \nin the type-checker. Being robust when programs have an unknown number of inde\u00adpendent type errors proved \nto be an important advance. There are several directions for future work beyond the obvi\u00adous steps of \nattacking new languages with inference and improv\u00ading the systems we have. First, we would like to integrate \nour systems into IDEs and focus on the user-interface issues that are clearly important for error-message \nquality. Second, a controlled user study could bolster our conclusions. Third, an open system where programmers \ncould describe new search strategies or con\u00adstructive changes to try would increase usefulness. In particular, \nwhen embedding a domain-speci.c language in a general-purpose language, the domain-speci.c language implementor \nwould like to de.ne error messages in higher-level terms [14] and our approach should make this easier \nthan it has been. References [1] M. Beaven and R. Stansifer. Explaining type errors in polymorphic languages. \nACM Letters on Programming Languages and Systems, 2(1-4):17 30, 1993. [2] K. Bernstein and E. Stark. \nDebugging type errors (full version). Technical report, State University of New York at Stony Brook, \n1995. [3] M. G. Burke and G. A. Fisher. A practical method for LR and LL syntactic error diagnosis and \nrecovery. ACM Transactions on Programming Languages and Systems, 9(2):164 197, 1987. [4] O. Chitil, F. \nHuch, and A. Simon. Typeview: a tool for understanding type errors. In M. Mohnen and P. Koopman, editors, \n12th Inter\u00adnational Workshop on Implementation of Functional Languages, Aachner Informatik-Berichte, \n2000. [5] V. Choppella and C. T. Haynes. Diagnosis of ill-typed programs. Technical Report 426, Indiana \nUniversity, December 1994. [6] H. Cleve and A. Zeller. Locating causes of program failures. In 27th International \nConference on Software Engineering, 2005. [7] D. Duggan. Correct type explanation. In ACM SIGPLAN Workshop \non ML, 1998. [8] D. Duggan and F. Bent. Explaining type inference. Science of Computer Programming, 27(1):37 \n83, July 1996. [9] M. Gandhe, G. Venkatesh, and A. Sanyal. Correcting errors in the Curry system. In \n16th Conference on Foundations of Software Technology and Theoretical Computer Science, 1996. [10] C. \nHaack and J. B. Wells. Type error slicing in implicitly typed higher-order languages. Science of Computer \nProgramming, 50(1\u00ad3):189 224, 2004. [11] B. J. Heeren. Top Quality Type Error Messages. PhD thesis, Universiteit \nUtrecht, The Netherlands, Sept. 2005. [12] J. J\u00a8arvi, D. Gregor, J. Willcock, A. Lumsdaine, and J. Siek. \nAlgorithm specialization in generic programming: challenges of constrained generics in C++. In ACM Conference \non Programming Language Design and Implementation, 2006. [13] Y. Jun, G. Michaelson, and P. Trinder. \nExplaining polymorphic types. The Computer Journal, 45(4):436 452, 2002. [14] S. Krishnamurthi, Y.-D. \nErlich, and M. Felleisen. Expressing structural properties as language constructs. In European Symposium \non Programming, 1999. [15] O. Lee and K. Yi. Proofs about a folklore let-polymorphic type inference algorithm. \nACM Transactions on Programming Languages and Systems, 20(4):707 723, 1998. [16] B. Lerner, D. Grossman, \nand C. Chambers. Seminal: Searching for ML type-error messages. In ACM SIGPLAN Workshop on ML, 2006. \n[17] B. J. McAdam. On the uni.cation of substitutions in type inference. In K. Hammond, A. J. Davie, \nand C. Clack, editors, Implementation of Functional Languages, volume 1595 of LNCS, 1998. [18] B. J. \nMcAdam. Repairing Type Errors in Functional Programs. PhD thesis, Laboratory for Foundatations of Computer \nScience, The University of Edinburgh, 2001. [19] G. D. Reis and B. Stroustrup. Specifying C++ concepts. \nIn 33rd ACM Symposium on Principles of Programming Languages, 2006. [20] P. J. Stuckey, M. Sulzmann, \nand J. Wazny. Interactive type debugging in Haskell. In ACM SIGPLAN Workshop on Haskell, 2003. [21] F. \nTip and T. B. Dinesh. A slicing-based approach for locating type errors. ACM Transactions on Software \nEngineering and Methodology, 10(1):5 55, 2001. [22] M. Wand. Finding the source of type errors. In 13th \nACM Symposium on Principles of Programming Languages, 1986. [23] A. Zeller. Yesterday, my program worked. \ntoday, it does not. Why? In 7th European Software Engineering Conference and 7th ACM Symposium on the \nFoundations of Software Engineering, 1999. [24] L. Zolman. STLFilt: An STL error message decryptor for \nC++. http://www.bdsoft.com/tools/stl.lt.html, 2005.   \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.</p>", "authors": [{"name": "Benjamin S. Lerner", "author_profile_id": "81318490369", "affiliation": "University of Washington, Seattle, WA", "person_id": "P871666", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flower", "author_profile_id": "81331492628", "affiliation": "University of Washington, Seattle, WA", "person_id": "P871684", "email_address": "", "orcid_id": ""}, {"name": "Dan Grossman", "author_profile_id": "81405594870", "affiliation": "University of Washington, Seattle, WA", "person_id": "PP39066827", "email_address": "", "orcid_id": ""}, {"name": "Craig Chambers", "author_profile_id": "81100528252", "affiliation": "University of Washington, Seattle, WA", "person_id": "PP39047059", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250783", "year": "2007", "article_id": "1250783", "conference": "PLDI", "title": "Searching for type-error messages", "url": "http://dl.acm.org/citation.cfm?id=1250783"}