{"article_publication_date": "06-10-2007", "fulltext": "\n Static Speci.cation Inference Using Predicate Mining Murali Krishna Ramanathan Ananth Grama Suresh Jagannathan \nDepartment of Computer Science, Purdue University {rmk, ayg, suresh}@cs.purdue.edu Abstract The reliability \nand correctness of complex software systems can be signi.cantly enhanced through well-de.ned speci.cations \nthat dictate the use of various units of abstraction (e.g., modules, or procedures). Oftentimes, however, \nspeci.cations are either miss\u00ading, imprecise, or simply too complex to encode within a signature, necessitating \nspeci.cation inference. The process of inferring spec\u00adi.cations from complex software systems forms the \nfocus of this paper. We describe a static inference mechanism for identifying the preconditions that \nmust hold whenever a procedure is called. These preconditions may re.ect both data.ow properties (e.g., \nwhenever p is called, variable x must be non-null) as well as control-.ow properties (e.g., every call \nto p must be preceded by a call to q). We derive these preconditions using an inter-procedural path-sensitive \ndata.ow analysis that gathers predicates at each program point. We apply mining techniques to these predicates \nto make speci.\u00adcation inference robust to errors. This technique also allows us to derive higher-level \nspeci.cations that abstract structural similari\u00adties among predicates (e.g., procedure p is called immediately \nafter a conditional test that checks whether some variable v is non-null.) We describe an implementation \nof these techniques, and validate the effectiveness of the approach on a number of large open-source \nbenchmarks. Experimental results con.rm that our mining algo\u00adrithms are ef.cient, and that the speci.cations \nderived are both pre\u00adcise and useful the implementation discovers several critical, yet previously, \nundocumented preconditions for well-tested libraries. Categories and Subject Descriptors D.2.7 [Software \nEn\u00adgineering]: Distribution, Maintenance, and Enhancement Documentation; F.3.1 [Logics and Meaning of \nPrograms]: Specifying and Verifying and Reasoning about Programs; D.2.4 [Software Engineering]: Software/Program \nVeri.cation Statistical Methods General Terms Algorithms, Documentation, Veri.cation Keywords speci.cation \ninference, preconditions, predicate min\u00ading, program analysis Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 07 June 11 13, 2007, San Diego, California, \nUSA. Copyright c n 2007 ACM 978-1-59593-633-2/07/0006. . . $5.00 1. Introduction Well-de.ned speci.cations \ncan signi.cantly enhance the reliabil\u00adity and correctness of complex software systems. When avail\u00adable, \nthey can be used to verify correctness of libraries and de\u00advice drivers [4, 7, 21, 36], enable modular \nreuse [29], and guide testing mechanisms toward bugs [13, 18]. When speci.cations are provided by the \nuser, type systems [16, 17, 11], model check\u00ading [21, 7], typestate interpretation [24, 20], and other \nrelated static analyses [36] can be used to check whether implementations satisfy necessary invariants. \nOften, speci.cations are easy to de.ne (e.g., procedure p must al\u00adways be called after data structure \nd is initialized), or are well\u00addocumented (e.g., pthread mutex init must be present on all program paths \nreaching a call to pthread mutex lock). In many cases, though, speci.cations are not known, and even \nwhen avail\u00adable, are often informal, imprecise, or incomplete. This is espe\u00adcially true for complex system \nsoftware libraries. For example, con\u00adsider the function BN is prime in the openssl library, a widely\u00adused \nsecure socket layer implementation. The function s signature is complex, taking .ve arguments, including \na callback procedure. It returns true if its .rst argument, which is a pointer to a bignum object, is \nprime. Its documentation, however, makes no assertions about the expected structure of its arguments; \nfor example, it does not specify the function s behavior if a null pointer value is sup\u00adplied as the \n.rst argument. Clients must therefore either examine its implementation to determine the appropriate \nconstraints on ar\u00adguments, or proactively perform error checks before making the call. Both approaches \nhave obvious drawbacks, and neither work if the client is not even aware that a potential issue exists. \nOne way to determine the appropriate conditions under which BN is prime can be safely called is to examine \nthe collection of calls made to the function from other clients. The underlying hy\u00adpothesis is that the \ncon.dence and speci.city of a property inferred for BN is prime, is re.ected in its satisfaction at various \ncall sites. However, manually identifying call sites to BN is prime over a large number of client programs, \nand examining how the argu\u00adments are de.ned and used prior to the call, is generally infeasible. On the \nother hand, automated techniques for correlating invariants across different call sites to the same procedure \nmust take into ac\u00adcount the possibility that programs may contain bugs which can mask real invariants. \nFor example, it may be the case that in some calls to BN is prime, the .rst argument is incorrectly not \nchecked prior to the call. Failure to perform this check may not necessarily lead to an error if the \nargument values at these call sites serendip\u00aditously happen to be non-null. Automated techniques must \nalso be able to distinguish between invariants that are signi.cant enough to be included as part of the \nfunction s speci.cation from those that, while possibly true, are irrelevant. For example, there may \nbe sev\u00aderal properties that hold at each call-site to BN is prime related to global or temporary variables \nthat are inconsequential to its speci\u00ad.cation.         In this paper, we consider the problem \nof statically inferring speci\u00ad.cations transparently without requiring programmer annotations. Speci.cally, \nwe consider the problem of generating speci.cations that de.ne preconditions for procedures predicates \nthat must al\u00adways hold when the procedure is called. We consider two important classes of preconditions: \ncontrol-.ow predicates that de.ne prece\u00addence properties among procedures (e.g., a call to fgets is always \npreceded by a call to fopen), and data-.ow predicates that cap\u00adture data.ow properties associated with \nvariables (e.g., whenever fgets is called, pointer fp must not be null). We de.ne an inter-procedural, \npath-sensitive static analysis that identi.es a collection of constraints whose solution de.nes poten\u00adtial \npreconditions. If procedure p has precondition J, it means that J holds on all calls to p. To compute \npreconditions, our analysis collects a predicate set along each distinct path to each call-site. To manage \nthe size of this set, intersections of predicate sets are con\u00adstructed at join points where distinct \npaths merge. Predicates com\u00adputed within a procedure are memoized and are used to compute preconditions \nthat capture inter-procedural control and data.ow in\u00adformation. To compute the preconditions of a procedure \np, we con\u00adsider the intersection of the predicate sets at each call-site to p. There are several signi.cant \ndesign issues that need to be resolved for the derived preconditions to have any practical signi.cance. \nWe observe that using simple set intersection on predicates is too frag\u00adile to yield interesting speci.cations \nin general. This is because the predicates generated are insuf.ciently abstract (e.g., at a call to procedure \np, variable x bound in p is read, and the contents of lo\u00adcations a and b allocated in p are compared. \n). The intersection of any set S with a set containing just these predicates would be non-empty only \nif S contained identical predicates, re.ecting the same operations on the same variables and locations. \nTo relax this limitation, we examine techniques that allow us to de.ne structural similarities among \npredicate sets. Such similarities enable precon\u00additions that specify properties which are abstracted \nover variable names, references, and values. We are thus able to de.ne precon\u00additions that de.ne more \nabstract properties such as procedure q is called whenever some integer variable v is greater than zero, \nand the contents of some pair of locations l1 and l2 holding a value of type T are equal. While the use \nof intersection guarantees safety by ensuring that de\u00adrived preconditions for a procedure hold at all \ncall-sites, it is not a robust mechanism in the presence of errors. An error that causes a predicate \nto be omitted along some path leading to a call to proce\u00addure p would result in the predicate not being \nincluded as part of p s preconditions. To address this concern, we employ frequent item\u00adset and sequence \nmining on the predicates computed at each call\u00adsite to p, and use the predicates that are most frequently \noccurring as the preconditions for p. Like other mining-based approaches, we assume that errors violating \ninvariants occur infrequently, thus making mining a feasible strategy to .lter such deviations from the \ngenerated speci.cations. It is our approach to these issues, and the kinds of speci.cations generated \nas a result, that distinguish our work from previous ef\u00adforts that have used mining techniques (both \ndynamic [4, 14, 35, 38] and static [23, 26, 28, 13]) to extract and validate program prop\u00aderties. While \ndynamic mining techniques can be used to generate speci.cations, the integrity of the speci.cation depends \nupon the comprehensiveness of the input data. On the other hand, prior static approaches have not been \nwell-integrated within a program analy\u00adsis framework, and therefore are not effective in generating useful \npreconditions. Our primary contribution is this systematic integra\u00adtion of data .ow analysis with scalable \nmining algorithms. This paper makes the following additional technical contributions: 1. Precondition \nInference: We present and formalize a new path\u00adsensitive inter-procedural static analysis for inferring \nprecondi\u00adtions for procedures transparently with no programmer annota\u00adtions, pro.ling, or instrumentation. \n 2. Robust Speci.cations: We describe the use of mining tech\u00adniques to generate correct speci.cations \neven for programs that may have subtle bugs that lead to necessary invariants being erroneously omitted \nalong certain paths. Mining also provides a way to compensate for imprecision introduced by the static \nanalysis that would ordinarily result in omitting valid predicates from a precondition. 3. Experimental \nEvaluation: We demonstrate the practicality of our techniques to large open-source C programs, and provide \na detailed quantitative and qualitative assessment of the effective\u00adness of our approach. Our results \nshow that the analysis is (a) selective the number of elements comprising derived precon\u00additions tend \nto be small (less than .ve on average); (b) precise  the analysis derives approximately 78% of documented \nspec\u00adi.cations to library calls made by openssh; and (c) useful we discovered several bugs in the benchmarks \nthat exist because of failure to adhere to derived speci.cations.  2. Motivating Example We motivate \nour approach using a real-world example deriving a speci.cation for the bind system call in the Linux \nsocket li\u00adbrary. While the application of our approach is in deriving speci\u00ad.cations for undocumented \nprocedures, it is illustrative to demon\u00adstrate the technique for a procedure such as bind, which has \na well-documented interface. The bind system call takes three pa\u00adrameters, viz., a socket descriptor \n(type: int), the local address to which the socket needs to bind (type: struct sockaddr *), and the length \nof the address (type: socklen t). For a stream socket to start receiving connections, it needs to be \nassigned to an address, which is achieved by using bind. Summarizing the documenta\u00adtion, the necessary \nconditions that must hold before bind can be called are: 1. A socket system call must have occurred. \n 2. The return value of socket must have been checked for valid\u00adity. 3. The address (second parameter \nto bind) corresponds to a spe\u00adci.c address family (e.g., AF UNIX, AF INET).  Ideally, our goal is to \nobtain the above information by tracking various calls to bind in the source. Figure 1 shows code fragments \nof two procedures (out of eight, total) that invoke the bind system call in openssh-4.2p1. Figure 1(a) \nshows a code fragment from the .le sshd.c where bind is invoked from main. Before the call to bind, as \nper the documented requirements, observe that there is a call to socket on line 1287. The returned value \nlisten socket is checked to ensure that it is a valid descriptor, and the address is set (lines 1075 \nand 1272). In fact, in a convoluted chain, the procedure fill default server options in main invokes \nadd listen addr, which in turn invokes add one listen addr where the address that is eventually used \nin bind is set. Apart from       870 main(...) 883 struct addrinfo *ai; 918 initialize  server \noptions(&#38;options); 1075 fill default   server options(&#38;options); 1272 for (ai=options.listen \n addrs; ai;ai=ai->ai next) { 1273 if(ai->ai family != AF INET &#38;&#38;  ai->ai family != AF INET6) \n1274 continue; 1275 if (num listen  socks >= MAX LISTEN SOCKS) ... 1278 if ((ret = getnameinfo(...))) \n{  ... 1287 listen sock = socket(ai->ai family,...); 1289 if (listen sock < 0) { ... 1294 if (set nonblock(listen \nsock) == -1) { ... 1302 if (setsockopt(...) == -1) 1304 error( setsockopt SO REUSEADDR: ... ); 1309 if \n(bind(listen sock, ai->ai addr, ai->ai addrlen) < 0) { ... (a) sshd.c 991 ssh control listener(void) \n993 struct sockaddr un addr; 997 if (options.control path == NULL || 998 options.control master == SSHCTL \nMASTER NO) 999 return; 1003 memset(&#38;addr, 0, sizeof(addr)); 1004 addr.sun family = AF UNIX; 1005 \naddr len = offsetof(...) 1008 if (strlcpy(addr.sun path, options.control path, 1009 sizeof(addr.sun \npath)) >= sizeof(addr.sun path)) 1010 fatal( ControlPath too long ); 1012 if ((control fd = socket(PF \nUNIX, SOCK STREAM, 0)) < 0) 1013 fatal(...); 1015 old umask = umask(0177); 1016 if (bind(control fd, \n(struct sockaddr*)&#38;addr, addr len) == -1) { ... (b) ssh.c Figure 1. Code fragments of two different \ncall sites to bind in openssh-4.2p1. sshd.c ssh.c Variables Attributes Variables Attributes (*ai).ai \naddrlen ai inetd flag {(arg(3), bind)} {(:=, options.listen addrs),(.=, 0) } {(=, 0)} addr.sun family \naddr len old umask {(:=, 1)} {(:=, res( strlen)), (arg(3), bind)} {(:=, res( umask))} listen sock num \nlisten socks ret {(:=,res( socket)), (*, 0), (arg(1), bind), (arg(1), setsockopt)} {(<, 16)} {(:=, res( \ngetnameinfo)), (=, 0)} control fd options.control master options.control path {(:=, res( socket)), (*, \n0), (arg(1), bind)} {(.=, 0)} {(.=, 0)} Table 1. A subset of predicates associated with the bind calls \nshown in Figure 1. these known requirements, other operations dependent on the appli\u00adcation context are \nalso performed (e.g., the family of the address is checked in line 1273, the num listen socks is checked \nin line 1275, etc.). By observing just a single use of bind alone, we can generate some properties on \nthe required operations before bind is called. Table 1 shows the subset of properties generated for the \ncorre\u00adsponding bind call. For example, we observe a property where a variable listen sock is assigned \nthe return value of socket, has a value greater than or equal to 0 and is the .rst parameter in calls \nto setsockopt and bind. As explained above, these proper\u00adties form some of the preconditions for calls \nto bind. However, not all properties generated before this bind call need to hold always before any other \ncall to bind. For example, ret is assigned the return value of getnameinfo and is equal to 0 before the \nbind call. This property may be relevant in the context of calls to bind in sshd.c, but may not be relevant \nin calls made within other .les. Unfortunately, simply examining this single call without any a pri\u00adori \nknowledge of bind s behavior would not permit us to discard this property from its speci.cation. To improve \nprecision, we collect properties from other call sites to bind. Figure 1(b) presents one such call site \nin procedure ssh control listener in ssh.c. For this call, we obtain prop\u00aderties that include the known \nrequirements (see lines 1004, 1005, 1012) and also shown in Table 1. We also obtain other irrelevant \noperations (e.g., the control path is checked at line 997, size of path checked in 1008, etc.). Based \non the properties here and the properties previously obtained with respect to the bind call in Fig\u00adure \n1(a), an intersection of the derived properties can be computed. By repeated application of this process \nto each call to bind at other call-sites, we obtain the necessary operations that must be performed before \nevery call to bind.   To summarize the example, observe that deriving the desired pre\u00adconditions using \nintersection must account for the fact that (a) the names of relevant variables in the two .les are not \ncomparable (e.g., listen sock in sshd.c and control fd in ssh.c); (b) opera\u00adtions relevant to the bind \ncall (e.g., listen sock * 0 in sshd.c and ((control fd = ...) * 0) in ssh.c) are interspersed with irrelevant \noperations; (c) the types of corresponding param\u00adeters to bind before casting are different ( struct \nsockaddr * in sshd.c and struct sockaddr un * in ssh.c); (d) there is no .xed order of calls to procedures \nsetting the address family and the call to socket in the two .les and (e) there can be differ\u00adent number \nof attributes associated with the corresponding vari\u00adables across call-sites (e.g., listen sock is used \nas a parameter in setsockopt whereas control fd does not have any such at\u00adtribute.).  3. Speci.cation \nLanguage We formalize our informal discussion above by de.ning a simple, call-by-value language equipped \nwith .rst-class procedures and references. Superscripts on expressions denote labels that are used in \nde.ning our analysis. The exact semantics for the language is standard and omitted here. Informally, \na let-expression binds x in e, A y.e' constructs a lexically-scoped .rst-class procedure, y(z) denotes \ncall-by-value application, ref(y) constructs a .rst-class reference cell that holds the value denoted \nby y, and deref(y) extracts the value of the cell \u00a31 \u00a3)\u00a3 bound to y. The expression ( set x := yin e' \nassigns the value of y to the cell bound to x, and continues with e. Bound and free variables are de.ned \nas usual. A program P is a closed \u00a3 expression, and e. P is true if e\u00a3 is a subexpression of P . In addition \nto the usual assumption that bound variables are distinct from free variables in different expressions, \nwe also assume that all bound variables in a program are distinct. The last variable of an expression, \nwhich yields the expression s value, is de.ned as follows: \u00a3 last(x\u00a3)= x ' \u00a31 \u00a3)\u00a3\u00a3 last(( let x = tin \ne)= last(e) \u00a31 \u00a3)\u00a3' \u00a3 last(( set x := yin e)= last(e) Our analysis is de.ned in two steps. First, we \ncompute a .ow anal\u00adysis for the program, F , that associates with every variable and label, a set of \nabstract values. An abstract value is either a con\u00adstant, a label corresponding to the de.nition point \nof a procedure (abstract procedure) or reference (abstract location), or a primitive operation paired \nwith the abstract values of its arguments. Thus, given variable x, F (x) (or F (.), if given label .) \nde.nes the set of procedures, constants, references, and primitive operations that x (or the expression \nwith label .) can denote during execution of the program. We do not present details of the analysis here, \nbut any monovariant .ow analysis in the spirit of [30, 33] suf.ces for our purpose. A judgment is a three-place \nrelation on speci.cation maps, .ows, and expressions. Thus, the judgment 6 |= F e\u00a3 is read Assuming a \n.ow analysis F , expression e\u00a3 has the preconditions de.ned by 6(.). Given a .ow function F , and program \nP , we are interested in the least speci.cation map 6 for which the judgment holds. Speci.cation inference \nis de.ned by a collection of inference rules (see Figure 2) that leverages the result of the .ow analysis. \nEach rule is of the form: c1 ,...,cn , 6 |= F e where the consequent de.nes a judgment whose validity \ndepends upon the satis.ability of the constraints de.ned by the antecedent. The constraints impose restrictions \non the structure of the speci.ca\u00adtion map 6, a map that identi.es a set of preconditions with every program \npoint. A precondition J of an expression e de.nes an action or predicate that must hold prior to e s \nexecution. Our analysis tracks a num\u00adber of such actions; these actions are de.ned with respect to the \nabstract values computed for each expression in the program by the .ow analysis. Thus, an action of the \nform read(., v ) asserts that a reference created at label . holding the abstract value v is read; write(., \nv ) asserts a similar condition for reference assign\u00adment; and, alloc(., v ) holds if in an expression \nref(z)\u00a3 . P and F (z)= v . In the same vein, bind(x, v ) is true whenever variable x is bound to e\u00a3 and \nF (.) is v , and cbind(x, v ) is used to express predicates that re.ect if-splitting of .ow values across \nconditionals; .nally, call(.1 + .2 ) is used to capture control-.ow precedence relationships among procedure \ncalls it holds whenever a proce\u00addure with label .2 is invoked after an invocation of a procedure with \nlabel .1 , with no intervening invocation of any other procedure. The rules for expressions that bind \nconstants and primitive oper\u00adations are straightforward. The preconditions of the expression in the let-body \nwithin which the binding occurs includes the precon\u00additions of the let expression, as well as a precondition \nthat re.ects the existence of the new binding. If a variable is bound in a let\u00adexpression to the result \nof a call to a primitive operation, the precon\u00additions of the expression in the let-body must include \nthis action; the values of the arguments to the primitive are approximated by the abstract values of \nthe operation s arguments as determined by the .ow analysis. A reference binding induces a precondition \non the let-body that includes both the binding as well as a predicate that captures the reference creation. \nSince references are .rst-class, a variable occur\u00adrence may be bound to many different references during \nits lifetime. \u00a3' In an expression of the form, ( let x = deref(y)\u00a31 in e)\u00a3, consider the set of references \nthat y may be bound to (de.ned by F (y)). Each element in this set contains a label . corresponding to \na reference expression ref(z) found in the program. The pre\u00adcondition for e\u00a3 must therefore include predicates \nthat re.ect the potential read of each such location, and predicates that re.ect the binding of x to \nthe contents of these locations. Assignment expres\u00adsions are de.ned similarly, with write predicates \nreplacing reads as a consequence of the operation. The preconditions following a con\u00additional include \nthe intersection of the speci.cation sets of the two branches; within these branches, an action that \nre.ects the value of the Boolean guard is included as part of the precondition associated with the respective \nbranches. We now describe the rules dealing with procedure abstraction and call. The precondition associated \nwith the procedure body is de\u00ad.ned as the intersection of a collection of sets, each of which rep\u00adresents \nthe speci.cations extant at a speci.c (distinct) call point to the procedure. Thus, the speci.cations \nde.ning the entry to a pro\u00adcedure re.ect the common preconditions extant at every call point to the procedure. \nFor example, the speci.cation associated with the entry to the procedure body de.nes a predicate that \nrelates the for\u00admal parameter to an abstract value. This value is constructed as the intersection of \nthe abstract values (set of labels, constants, etc.) of the actual parameters to the procedure. Similarly, \nthe intersection of the set of preconditions that exist at each such call de.nes the smallest set of \npredicates that is guaranteed to hold whenever the procedure is called. A procedure call y(z) is de.ned \nsimilarly. Its de.nition relies on an \u00a3 auxiliary procedure A that given the label of an expression e. \nP returns the label of the closest enclosing A, if one exists, and the distinguished label .main, otherwise. \nIf the set of procedures that y may be associated with is Py (as determined by our .ow analysis), then \nthe intersection of the speci.cations extant upon exit from each procedure p . Py de.nes the conditions \npresent upon exit from the call guaranteed to hold for all procedures p that may be invoked at this call. \nObserve that these rules are slightly different from typical static analyses that would consider the \nde.nition of the procedure independently from its call-sites. This is because preconditions that hold \nat the entry to a procedure p depend upon the conditions extant at all call-sites to p; similarly, the \ninvariants that hold upon completion of a call depend upon the invariants extant at the return point \nof all procedures that could be invoked at that call. As currently de.ned, the preconditions associated \nwith each pro\u00adgram point are constructed by simple unions and intersections of abstract value sets computed \nby an inter-procedural data.ow anal\u00adysis. It is straightforward to see that the predicates computed repre\u00adsent \na conservative summary of the information present in the .ow function. SYNTAX: DOMAINS: e . Exp ::= \nx \u00a3 | F . Flow = Var + Label n AVal \u00a31 \u00a3)\u00a3 ' v . AVal = P(Label + Constant + ( let x = tin e | \u00a31 \u00a3)\u00a3 \n' Op(AVal \u00d7 ... \u00d7 AVal)) ( set x := y in e 6 . SpecMap = Label nP(Pred) t . Term ::= c | A x.e | x(y) \n| A . ProcMap= Label n Label ( if x then e \u00a3t else e \u00a3f ) | 12 J . Pred = read(Label, AVal)+ write(Label \n, AVal)+ ref(x) | deref(x) | alloc(Label, AVal)+ bind(Var , AVal)+ op(x1 ,...,xn) cbind(Var , AVal)+ \ncall(Label + Label) 6(. ' ) U{bind(x, {c})}. 6(.) 6(. ' ) U{bind(x, op(F (x1),...,F (xn)))}. 6(.) \u00a31 \n\u00a3)\u00a3 ' \u00a3)\u00a3 ' 6 |= F ( let x = c in e 6 |= F ( let x = op(x1 ,...,xn)\u00a31 in e 6(. ' ) U{alloc(.1 ,F (y)), \nbind(x, .1 )}. 6(.) S = {read(.i,F (.i)), bind(x, F (.i)) | .i . F (y) . ref(z)\u00a3i . P } 6 |= F ( let \nx = ref(y)\u00a31 in e \u00a3)\u00a3 ' 6(. ' ) U{S}. 6(.) \u00a3)\u00a3 ' 6 |= F ( let x = deref(y)\u00a31 in e S = {write(.i,F (y)) \n| .i . F (x), ref(z)\u00a3i . P } 6(. ' ) U{S}. 6(.) 6(. ' ) U{cbind(y, true)}. 6(.t) \u00a31 \u00a3)\u00a3 ' 6(. ' ) U{cbind(y, \nfalse)}. 6(.f ) 6 |= F ( set x := y in e 6. ' U (6(.t) n 6(.f )) U{bind(x, F (.1))}. 6(.) \u00a3t \u00a3f \u00a3)\u00a3 \n' 6 |= F ( let x =( if y then e1 else e2 )\u00a31 in e {6(.i) | ( let zi = xi(yi) in ei)\u00a3i ,.1 . F (x)}. \n6(.1 ) {bind(w, v ) | ( let zi = xi(yi) in ei)\u00a3i ,.1 . F (x),v = n(F (yi))}. 6(.b) 6(. ' ) U{bind(x, \n.1 )}. 6(.) \u00a3b )\u00a31 \u00a3)\u00a3 ' 6 |= F ( let x =(A w.eb in e S = {.j | .i . F (y) . (Awi.ei)\u00a3i . P . ej\u00a3j = \nlast(ei)} 6(. ' ) U{call(A(.1 ) + .i) | .i . F (y) . (Awi.ei)\u00a3i . P }U{{6(.j ) | .j . S}U{bind(x, S)}. \n6(.) \u00a3)\u00a3 ' 6 |= F ( let x = y(z)\u00a31 in e Figure 2. Speci.cation inference via .ow analysis. let r = A \nz. ref(z)\u00a31 ... g2 = A c2 . let x1 = ref(c2 )\u00a33 g1 = A c1 . let y1 = A w. ref(w)\u00a32 x2 = A w . ... ref(w \n)\u00a34 ... y2 = r(c1 ) x3 = ref(c3 )\u00a35 y3 =y1 (y2 ) x4 =x2 (c4 ) y4 = deref(y3 ) in ... op2 (x1 ,x4 ) y5 \n= deref(y2 ) ... op1 (x3 ,x1 ) in ... op1 (y2 ,y3 ) ... set x3 := c3 in ... f(...) ... op2 (y4 ,y3 \n) ... set y2 := c1 in f(...)  Figure 3. A program fragment illustrating the need for structural matching \nof predicates. Syntactic sugar is used to simplify the examples. There are two interesting issues to \nnote about the analysis. First, a predicate is recorded as part of a precondition at a program point \nonly if the predicate occurs on all paths to that point. Consider a module whose designer expects certain \npreconditions to hold when procedures de.ned within the module are called. Our anal\u00adysis would certainly \ninfer these preconditions for correctly written programs, but fail to identify the desired speci.cation \nin the pres\u00adence of errors that result in the omission of some of these legitimate predicates. The ability \nof the analysis to derive meaningful speci.\u00adcations in the presence of errors is consequently poor. There \nis an obvious conundrum here, given that the inferred speci.cations are derived from a program source \nthat potentially contains bugs, and can thus potentially compromise the integrity of the speci.cations \nthemselves. Second, the intersection of precondition sets fails to consider struc\u00adtural equivalence among \npredicates. In particular, our speci.cation language does not permit predicates to be abstracted over \nan ar\u00adbitrary set of locations, names, or constants. To illustrate this, con\u00adsider the program fragments \nshown in Figure 3. We are interested in the speci.cation that should be inferred for the entry to procedure \nf based on the preconditions extant at its two call-sites in g1 and g2 . Suppose g1 and g2 are called \nfrom the following expression: if pred then g1 (c) else g2 (c) alloc(.1 ,{ c}) alloc(.3 ,{ c}) read(.1 \n,{ c1 }) alloc(.4 ,{ c4 }) write(.1 ,{ c}) alloc(.5 ,{ c3 }) alloc(.2 ,{.1 }) write(.5 ,{ c3 }) read(.2 \n,{.1 }) op2 ({.3 },{.4 }) op2 ({.1 },{.2 }) op1 ({.3 },{.5 }) op1 ({.1 },{.2 }) (a) (b) Figure 4. A subset \nof the preconditions that hold prior to the call to procedure f in procedure g1 (a) and procedure g2 \n(b). At the calls to f in procedures g1 and g2 , there are a number of preconditions that hold. Ignoring \npredicates that describe variable bindings, the most interesting are those related to abstract locations \n.1 and .2 (see Figure 4(a)) allocated and accessed by procedure g1 and abstract locations .3 ,.4 , and \n.5 accessed by procedure g2 (see Figure 4(b)). Based on the structure of the rules, we would conclude \nthat no interesting preconditions exist that are common to both calls since the sets of locations manipulated \nby the two procedures are disjoint. This is clearly overly conservative. For example, it is the case \nthat prior to both calls (i) two locations are allocated and used in operation op2 (.1 and .2 in procedure \ng1 , and .3 and .4 in procedure g2 ), and (ii) the contents of one of these locations (.1 in g1 and .3 \nin g2 ) holds the constant c. By unifying .1 and .3 , and .2 and .4 , we derive the preconditions for \nf: there exist a pair of locations (call them a and b) such that a and b are used as arguments in an \noperation op2 , and hold the constant c . Surprisingly, by considering an alternative mapping of locations \nin the two calls, we can deduce another equally valid speci.cation. Prior to both calls it is also the \ncase that (i) two locations are allocated (.1 and .2 in g1 , and .3 and .5 in g2 ) and used in operation \nop1 ; and (ii) one location is written with a constant (.1 in g1 and .5 in g2 ). To extract commonalities \nsuch as those among sets of predicates extant at the two calls requires us to match locations, names, \nand constants across these different sets. As the example illustrates, there are potentially many such \nmatches that can be constructed. Of course, some commonalities could be extracted by examining the body \nof f, but this would compromise scalability and modularity. Other commonalities can be derived by examining \nf s signature, the types of values stored in these locations, etc. We exploit some of these heuristics \nin our implementation. As we show in the next section, simply enumerating the set of all possible matches \nover the predicate sets used to de.ne precondi\u00adtions is infeasible. We therefore consider an alternate \nstrategy to identify matches among the precondition sets computed at different call-sites (or among procedures \ncalled at the same call-site) inspired by data mining techniques. As we shall discuss, these approaches \nsacri.ce optimality for scalability and ef.ciency; our experimen\u00adtal results reveal that they yield surprisingly \nvaluable speci.cations even in the presence of complex control-and data-.ow, even in the presence of \nbugs that result in invariants being omitted along cer\u00adtain program paths.  4. Extracting speci.cations \nWe use mining as a tool for deriving common properties across multiple call sites instead of ensuring \nthat properties hold across each call site. The reasons for adopting such a strategy are two-fold. First, \neven when programs are well-tested, they are not necessarily free from errors. Hence, by imposing the \nstrong requirement that a property must hold at each call-site in order to be a precondition candidate, \nwe may omit preconditions that otherwise might have been detected. Second, by identifying frequently \noccurring proper\u00adties, we can detect call-sites where the preconditions do not hold. If the property \nis indeed a valid precondition, its absence at certain call-sites may point to an error. To motivate \nour problem further, we consider two examples taken from our benchmark suite. Consider the code fragment \nin Figure 5(a). This fragment shows part of procedure RI FKey check from PostgreSQL, version 8.1.3. Observe \nthat the call to ri BuildQueryKeyFull at line 303 is preceded by calls to ri DetermineMatchType, heap \nopen, and ri CheckTrigger in this order. This pattern occurs at sev\u00aderal other locations in the program, \nwhich suggests that this might be a feasible control predicate precondition. However, in one speci.c \ninstance of the call to ri BuildQueryKeyFull at line 250, the rule is not satis.ed, since there is no \ncall to ri DetermineMatchType preceding it. The absence of this call is signi.cant; if the match type \nis RI MATCH TYPE PARTIAL, the call to ri BuildQueryKeyFull is erroneous because the proce\u00addure does not \nhandle arguments of this type. Figure 5(b) shows the code fragment of the procedure add listen addr found \nin .le serverconf.c from openssh 4.2p1. This procedure is called from the procedure fill default server \noptions, which in turn precedes a call to bind. In the body of the procedure, there are several calls \nto add one listen addr, which is responsible for setting an address family, eventually supplied as the \nsecond argument to bind. There are several ways in which a call to add one listen addr can take place; \nnotably, when port == 0 and options->num ports is less than one, the call does not happen. It so happens \nthat lines 403 and 404 reveal that this situation cannot arise, and thus the loop must be executed at \nleast once whenever port is zero. Unfortunately, in the absence of a theorem prover or model checker \n[15] that can assert options->num ports is always greater than zero at line 407 because of the operations \nperformed at lines 403 and 404, we must conclude that it is not always the case that add one listen addr \nis called from add listen addr, and thus, the second argument to bind need not always be set to a speci.c \naddress family. Even if there are no bugs in the program, limitations of the analysis in determining \na precise set of feasible paths can be overcome using mining techniques. By mining the set of predicates \ncomputed along different paths to bind calls, we discover that it is only along one path (namely the \ninfeasible one described above) that the second argument to bind is not set to an address family. By \nsetting con.dence thresholds appropriately, the absence of this predicate would not be considered a critical \nomission, and the predicate asserting that the second argument to bind is always set would be recorded \nas part of bind s preconditions. 4.1 Mining Strategies Recall that our analysis collects control-.ow \nand data.ow predi\u00adcates. The elements in a set of data.ow predicates have no order\u00ading relationship among \none another. Control-.ow predicates, on the other hand, do re.ect a speci.c ordering: each element represents \na procedure call, and the order of calls de.nes a precedence rela\u00adtion. We use frequent itemset mining \nto derive preconditions for data.ow predicate sets, and subsequence mining to derive precon\u00additions for \ncontrol-.ow predicates. 181 RI FKey check(PG FUNCTION ARGS) 182 { 199 ri CheckTrigger(...); 210 pk rel \n= heap open(...); 248 if (tgnargs == 4) 249 { 250 ri BuildQueryKeyFull(...); 294 } 296 match type = ri \nDetermineMatchType(...); 298 if (match type == RI MATCH TYPE PARTIAL) 299 ereport(...); 303 ri BuildQueryKeyFull(...); \n437 } (a) PostgreSQL-8.1.3 399 add listen addr(ServerOptions *options, char *addr, u short port) 400 \n{ 403 if (options->num ports == 0) 404 options->ports[options->num ports++] = SSH DEFAULT PORT; 407 if \n(port == 0) 408 for (i = 0; i < options->num ports; i++) 409 add one listen addr(options, addr, options->ports[i]); \n410 else 411 add one listen addr(options, addr, port); 412 } (b) openssh-4.2p1 Figure 5. Code fragments \nillustrating the application of mining techniques. void c1() { void c2() { void c3() { void c4() { if(packets \n> 0) if(packets > 0) if(packets > 0) if(packets > 0) pack flag = true; size = MIN SIZE; i = 0; i = 0; \nsize = MAX SIZE; buf = allocbuf(size); pack flag = true; size = MAX SIZE; buf = allocbuf(size); if(buf \n= NULL) size = MIN SIZE; buf = allocbuf(size); readbuf(buf, size); while(l = lock(buf)); buf = allocbuf(size); \nwhile(l = lock(buf)); ... readbuf(buf, size); if(buf = NULL) readbuf(buf, size); ... ... while(l = lock(buf)); \n... ... ... readbuf(buf, size); ... ... ... ... ... } } } } (a) c1 (b) c2 (c) c3 (d) c4 Figure 6. Illustrative \nexample. 4.1.1 Frequent Itemset Mining To obtain a speci.cation on predicates where ordering is not criti\u00adcal, \nwe use maximal frequent itemset mining [9]. In this technique, there is assumed to be a set of transactions; \neach transaction con\u00adtains a collection of elements. The elements that occur in at least n transactions, \nwhere n is a con.dence threshold speci.ed by the user, is a frequent itemset. For our application, a \ntransaction is a call-site and the set of predicates that hold at the call-site form the elements of \nthe transaction. We illustrate the mining process using the code fragments shown in Figure 6. We observe \nthat there are four different call-sites to function readbuf and each call-site is preceded by a number \nof operations. For ease of understanding, we use the same names for the associated variables across call-sites. \nBased on the operations preceding each call to readbuf, a number of properties are gleaned and are shown \nin Table 2. Observe that there are four1 transactions, equal to the number of call-sites of readbuf in \nthe example. For example, observe that there are six items for transaction c3. Each item is composed \nof multiple attributes ( e.g., the item associated with variable l has two attributes viz., l is assigned \nthe return value of lock(buf) and is equal to 0 before the call to readbuf.). When the frequent items \nare extracted at con.dence 75%, we obtain the following speci.cation: packets: {>,0} size: {(arg(1), \nallocbuf), (arg(2), readbuf)} l: {(=,0), (:=,res( lock))} 1 Each transaction encodes properties on all \npossible paths to the call-site. buf: {(arg(1), lock), (arg(1), readbuf), (. =,0), (:=,res( allocbuf))} \nDepending upon on the level of precision required by the user, the above mining technique can be easily \ntranslated into the more restrictive intersection technique, by simply .xing n to be the total number \nof call-sites (con.dence = 100%).  4.1.2 Sequence Mining For control-.ow predicates, frequent itemset \nmining does not suf\u00ad.ce since the order of elements in the transaction is not consid\u00adered. For deriving \nprecedence relations [31], we use sequence min\u00ading [2]. A sequence mining algorithm takes as input a \nset of se\u00adquences (I), a user-de.ned con.dence threshold, and outputs a set (S) of sequences that occur \nas subsequences in a minimum frac\u00adtion (as speci.ed by the con.dence threshold) of input sequences. Observe \nthat if a subsequence s is frequently occurring, all subse\u00adquences of s also occur at least as frequently \nas s. Therefore, we consider only maximal subsequences, i.e., it must be the case that every sequence(si) \nin S is not a subsequence of any other sequence present in S. For example, if the set of sequences is \ngiven by {(a + b + c + e), (a + d + c + e), (d + a + c + e), (a + c + d + e + f ), (e + f + d + c + a)}, \na sequence miner detects (a + c + e) as a frequently occurring subsequence. Observe that, the same set \nof transactions without ordering in frequent itemset mining would generate the set {a, c, d,e}. For our \napplication, a transaction corresponds to a call site and the sequence within a transaction corresponds \nto the sequence of procedure calls that c2 {(>, 0)} Variables c1 packets {(>, 0)} pack flag {(:=, true)} \nsize {(:=, MAX SIZE), (arg(1), allocbuf), (arg(2), readbuf)} buf {(:=, res( allocbuf)), (arg(1), readbuf)} \nl i  {(:=, MIN SIZE), (arg(1), allocbuf), (arg(2), readbuf)} {(:=,res( allocbuf)), (.=, 0), (arg(1), \nlock), (arg(1), readbuf)} {(=, 0), (:=,res( lock))} Transactions c3 {(>, 0)} {(:=,true)} {(:=, MIN \nSIZE), (arg(1), allocbuf), (arg(2), readbuf)} {(:=,res( allocbuf)), (. =, 0), (arg(1), lock), (arg(1), \nreadbuf)} {(=, 0), (:=, res( lock))} {(:= 0)} c4 {(>, 0)} {(:=, MAX SIZE), (arg(1), allocbuf), (arg(2), \nreadbuf)} {(:=, res( allocbuf)), (. =, 0), (arg(1), lock), (arg(1), readbuf)} {(=, 0), (:=, res(lock))} \n{(:= 0)} Table 2. Transactions associated with calls to readbuf shown in Figure 6. occurred before the \ncall site. Our implementation uses the Apriori\u00ad all algorithm by Agrawal and Srikant [2], which is known \nto scale to over a million sequences. For the example shown in Figure 6, we generate the speci.cation \nallocbuf + lock + readbuf.  4.2 The Structural Similarity Problem In Figure 6, the names of the variables \nare the same across multiple call-sites whereas this does not hold in real programs (as noted ear\u00adlier \nin this section). In other words, as discussed earlier, predicates computed along different paths may \nshare structural, if not syntac\u00adtic similarities. In order to capture such similarities, a technique \nto determine the locations, names, values, etc. that can be abstracted uniformly among different sets \nis necessary. Consider every predicate expression as being mapped to a set of locations. Thus, assume \na set of location sets, {L1 = {.11 ,.12 , ....1m1 }, L2 = {.21 ,.22 , ....2m2 }, ... Lk = {.k1 ,.k2 , \n....1mk }}, where Li corresponds to locations associated with predicates that reach call-site i of procedure \nP . Now, for ev\u00adery element in Li, we wish to .nd a corresponding element in every other Lj such that \nthe cumulative matching of the attribute sets for such a mapping is maximal. Given three sets A, B and \nC, we say A and B match maximally, if and only if | A n B | is greater than | A n C | or | B n C |. THEOREM \n1. The maximal matching problem as stated above is NP-hard. Proof By reduction from maximal bipartite \n(k, .)-clique in a bi\u00adpartite graph. [37, 19]. Fortunately, there are a number of heuristics that can \nbe employed to map locations based on semantic information available within programs. We describe below \nheuristics that match the attribute sets across multiple call-sites that we have used in our implementation. \n Type: Attribute sets can be divided based on the type of the variable. e.g., two variables, x and y \nwith attributes [ x: {(:=, true)}] and [ y: {(>, 20)}] can never be matched.  Parameter: If variables \nare supplied as arguments to the same parameter for a given procedure at different call-sites, their \nat\u00adtributes can be matched. Note, however, that while using posi\u00adtional parameter information for the \npurposes of matching may be a useful heuristic, other variables that are not used as param\u00adeters, but \nnevertheless are signi.cant as preconditions, need to be detected as well (e.g., matching attribute sets \nassociated with l in Figure 6).  Result: Variables that are assigned the return values of the same function \ncan have their attribute sets matched.  let a= A arga. let ptr = ref(...) in p(...) in ... let mkptr \n= A z. let ptr = ref(...) in ... b= A argb. ... mkptr(...) ... p(...) in ... let mkptr = Az. let ptr \n= ref(...) in ... e= A arge. ... mkptr(...) c= A argc. ... e (...) ... p (...) in ... Figure 7. Example \nshowing the need for FPA evaluation.  5. Implementation Design Our implementation takes as input the \nprogram source and a user\u00adde.ned con.dence level for determining when a property should form part of \na precondition. We .rst generate the control-.ow graph for each procedure using an ef.cient program analysis \ntool [6]. The direction of all edges in the control .ow graph are reversed, since we need to construct \npreconditions. The graphs obtained are fed into the intra-procedural analysis framework, which builds \nthe ini\u00adtial set of predicates. This data is processed by the inter-procedural analysis framework iteratively \nuntil a .xed-point is reached. There are two categories of .xed-point iterations that are essential for \ngenerating predicates that cross multiple function boundaries. One iteration (FPA Fixed Point Iteration \nA) corresponds to the set of tasks accomplished when a procedure is invoked and which are at a lower \nlevel of the invocation tree and the other iteration (FPB Fixed Point Iteration B) corresponds to the \nset of operations performed before a call to the procedure. We discuss this issue in detail. Figure 7 \npresents an example for FPA. From the example, it is clear that calls to procedures a, b, and c always \nallocate a pointer variable and then call procedure p. Furthermore, procedure mkptr always allocates \nthe pointer variable. To reduce redundant computation of these properties, we maintain a memoization \ntable for each of the procedures in the source, and update the information iteratively until .xed point \nis reached. Observe that while the above .xed point iteration accumulates facts in one direction (down \nthe call graph invocation path towards the leaves), there is a necessity for .xed point computation in \nthe reverse direction as well (towards the root in the call graph). Consider the example shown in Figure \n8. It is clear that before p is invoked, apart from the pointer being allocated, cond is always true. \nHowever, to obtain this information, a .xed point iteration (FPB) in the direction towards the root of \nthe call graph needs to be performed. let x = A argx. if cond then a(...) else ... in ... let y = A argy \n. if cond then b(...) else c(...) in ... let call y = A argk . if cond then y(...) in ... Figure 8. Example \nshowing the need for FPB evaluation. procedure BUILDPREDICATES \" Input: G(V,E), directed, acyclic (reversed) \nCFG of a; V is topologically sorted; \" Output: true if dflow or cflow changes from previous iteration \nfor any node in V; false otherwise; \" Auxiliary Information: LCS: longest common subsequence of multiple \nstrings; data predicates(i): data predicates generated at i; concat(i,j,k): concatenates strings i, j, \nk; CALLSITE(i): true if i is a callsite; RETURN(i): true if i is the exit node from procedure a; 1 for \neach node i = 1to |V| 2 for all neighbors j of i 3 in data flow(i) +n dflow(j) 4 in control flow(i) + \nLCS( cflow(j)) 5 dflow(i) + in data flow(i) U data predicates(i) 6 if CALLSITE(i) is true then 7 dflow(i) \n+ dflow(i) U data signature[ func(i)] 8 cflow(i) + concat( cflow(i), func(i), 9 control signature[ func(i)]) \n10 if RETURN(i) is true then 11 data signature[ a] + dflow(i) 12 control signature[ a] + cflow(i)  \n     Figure 9. Algorithm for building predicates. Figure 9 presents pseudo-code describing details \non building the control and data .ow predicates, apart from computing procedure summaries (memoization \ntables) used in FPA. The algorithm fol\u00adlows closely from the analysis formalized in Figure 2. At the \nend of FPA, a set of predicates ( data precond and control precond) for all the procedures in the program \nare obtained. Figure 10 presents the pseudo-code that performs the mining process that forms part of \nFPB iteration. There are two mining implementations that we use in our approach a frequent item-set \nminer [9] on data .ow predicates, where ordering is not necessary, and a sequence miner [2] for control \n.ow predicates. At the end of FPB, the pre\u00adconditions for the procedures are obtained.  6. Experiments \nWe validate our ideas on selected benchmark sources, with a view to demonstrating its scalability and \neffectiveness. We extract pre\u00adconditions for seven sources: apache, linux, openssh, osip, postgreSQL, \nprocmail and zebra. Speci.c details relating to the sources are provided in Table 3. The size of selected \nbench\u00admarks varies from 9K to 1.98MLoc. Since default con.gurations are used to compile these sources, \nwe believe that the number of control .ow nodes represents a more reliable indicator of effective source \nsize than lines of code. The number of control .ow nodes ranges from 16K to 958K. We also present the \nnumber of proce\u00addures examined in the table. We implemented our tool in C++ and perform experiments on \na Linux 2.6.11.10 (Gentoo release 3.3.4-r1) system running on an Intel(R) Pentium(R) 4 CPU machine operating \nat 3.00GHz,  procedure CONCATPREDICATES \" Input: a: a procedure in the program; C = {c1 ,c2 , ...cn} \nis the set of call sites of a; E = {e1 ,e2 , ...en } is the set of enclosing procedures for respective \ncall sites; \" Output: true if dflow precond or cflow precond changes from previous iteration; false otherwise; \n\" Auxiliary Information: in control flow(ci ): see Figure 9 concat(i,j,k): concatenates strings i, j, \nk; 1 for each node ci 2 dflow t(ci ) + dflow(ci) U dflow precond[ei ] 3 cflow t(ci ) + concat( cflow \nprecond[ei ], in control flow(ci ), -) 4 Input dflow t for all ci into the frequent itemset miner 5 \ndflow precond[a] + result of Step 4 6 Input cflow t for all ci into the sequence miner 7 cflow precond[a] \n+ result of Step 6        Figure 10. Mining preconditions. with 1GB memory. The time taken for \nperforming the analysis is presented in Table 3. 6.1 Quantitative Assessment We derive two kinds of \npredicates data-.ow and control-.ow. For data-.ow predicates, we derive assignments to variables and \nlogi\u00adcal relations between variables with other variables and constants. Control-.ow predicate specify \nthe procedures that are called before the associate procedure is called. The total number of preconditions \ngenerated for procedures mined at 70% con.dence is presented in Table 3. Our choice of mining at 70% \nis somewhat arbitrary, chosen to be resilient to latent errors in the benchmark, without comprising accuracy \nof the results. The predicate size distribution (the number of predicates found within a precondition) \nfor the generated pre\u00adconditions is given in Figure 11. For generated data-.ow precondi\u00adtions, the size \nof the predicate set is less than three for a majority of the procedures. For example, observe that approximately \n95% of the procedures in postgreSQL have fewer than two predicates in their preconditions. In the case \nof control-.ow predicates, we observe the predicate set size to be less than .ve for a majority of the \nprocedures. Thus, the output of the tool is tractable for further examination and analysis by users. \nTo further quantify the effect of the con.dence threshold on the preconditions derived, we performed \nexperiments on apache over different thresholds. Figure 12 presents the results on the change in the \nnumber of preconditions with change in con.dence. As expected, we observe that the number of predicates \nderived reduces with increase in the con.dence threshold, although the change is not dramatic. For example, \nthere are 60 additional procedures for which no preconditions are derived when the con.dence level changes \nfrom 60% to 100%. This is expected because increase in con.dence, leads to more aggressive pruning of \npredicates. Experiments we conducted that did not include the structural matching heuristics resulted \nin uninteresting (and fewer) precon\u00additions. This is expected as the attribute sets across call-sites \nare improperly matched. We also found that parameter matching was by far the most useful heuristic to \nemploy since most real programs employ a coding style that encodes signi.cant semantic informa\u00adtion through \nthe .ow of parameters and results into and out of func\u00adtions. 100% 100% 80% 80%   Percentage of functionsPercentage \nof functions 800 1 predicates0 predicates  3 predicates2 predicates equal to zero. We do not observe \nany explicit sanity check on 3-5 60% 0 predicates 2 or less 40% 40% 20%20% 0%0% apache linux openssh \nosip postgreSQLprocmail zebra Benchmarks Benchmarks (a) Data.ow predicate distribution (b) Control .ow \npredicate distribution Figure 11. Predicate distributions. Source Version LoC CFG Procedure Total number \nof speci.cations Analysis time(s) nodes count Data-.ow Control-.ow apache 2.2.3 273K 102K 2079 556 330 \n157 linux 2.2.26 1.98M 958K 7465 5862 101 1258 openssh 4.2p1 68K 88K 1281 625 202 120 osip 3.0.1 24K \n34K 666 213 51 46 postgreSQL 8.1.3 618K 548K 8568 3348 615 1007 procmail 3.22 9K 16K 298 84 105 26 zebra \n0.95a 183K 145K 3342 1397 608 162 Table 3. Benchmark Information. 6.2 Qualitative Assessment effectively \nprune away irrelevant predicates. For example, in a few cases, a predicate is included in the precondition \nto a procedure call To study the quality of our results, we examine the effectiveness of because the \nprocedure was invoked only twice and in both cases, our technique in discovering protocols associated \nwith library calls the calling context contained similar irrelevant invariants. made in openssh. We mine \nthe predicates at a 100% con.dence Besides being potential sources of bugs, false negatives can also \nthreshold. We correlate the effectiveness of the analysis by compar\u00admanifest because of limitations in \nthe implementation. In addition ing our results manually with the documentation found in the man to the \nobvious approximations introduced by our heuristics (recall pages of the corresponding library functions. \nthat a precise solution to structural matching, the heart of the 1,400 precondition inference problem, \nis NP-hard), there are two other limitations in our approach addressed brie.y below: 1,200 Absence of \ntheorem proving: A precondition for the proce\u00ad 1,000 >=4 predicates dure BN mod word is that the second \nparameter must not be Number of functions 600 400 200 0 confidence Figure 12. Reduction in number of \npredicates in apache with the second parameter in the program source. On further inspec\u00adtion, we notice \nthat there is a chain of assignments leading to the second parameter, where we may be able to prove that \nthe second parameter will be non-zero on any invocation. Automat\u00adically formulating this conclusion is \npossible with the aid of a theorem prover. The integration of theorem proving to the ex\u00adisting infrastructure \nto handle these predicates is part of our on\u00adgoing research. Closed world assumptions: Sometimes preconditions \nare for\u00adincrease in con.dence threshold Out of the 242 library procedures that are invoked in openssh, \nwe derive preconditions correctly for 199 of them (77.13% accuracy). Moreover, we were able to derive \npreconditions for an additional nine procedures that were not documented. We observe 12 false\u00adpositives \n(our tool derives preconditions where none exist) and 31 false negatives (our tool did not derive the \npreconditions the doc\u00adumented speci.cation claims should hold). These false negatives are potential sources \nof bugs. False positives occur primarily be\u00adcause there is an insuf.cient number of use cases for mining \nto mulated with respect to environment variables whose values are directly manifest in the program source. \nSince our implementa\u00adtion analyzes the program source in a closed-world setting, it is unable to accurately \nderive preconditions for those procedures whose predicates depend upon values of environment variables. \n 6.2.1 Bug Detection We discuss several bugs detected in openssh-4.2p1. In the code fragment shown below, \nneither variables p or q are checked for being non-null. Subsequent use of these values in proce\u00addure \nprime test results in a segmentation fault. The computa\u00adtional complexity of the Miller-Rabin primality \ntesting performed in prime test makes it dif.cult to generate comprehensive test suites that would detect \nthis bug. We exercised this fault by making the system run out of buffer space and using the test case \n(ssh-keygen -T <outfile> -f <infile>), the program crashes in the then latest release openssh-4.4p1. \nBased on our re\u00adport, these bugs are now .xed in openssh-4.5p1. We also observe a similar bug associated \nwith invocation of BN new and subsequent absence of sanity check in the procedure gen candidates. 473 \np = BN new(); 474 q = BN new(); 475 ctx = BN CTX new(); Observe that return value of BN CTX new is also \nnot checked as being non-null. Even though this does not result in a crash, this violation potentially \nleads to a signi.cant degradation in the per\u00adformance of the library call BN is prime used in prime test, \nas documented in the man pages. There are several other instances of similar errors in the program. The \nexisting documentation for library procedure initgroups, for example, claims that the .rst parameter \nto this procedure must al\u00adways be non-null. However, our analysis does not generate predi\u00adcates to this \neffect because this check is not performed. Similarly, before invoking procedure RSA size, the .eld n \nof its parameter must be non-null. Even though the parameter is checked for being non-null, n itself \nis not. A similar bug exists in the invocation of DH size. Any one of these bugs can be exercised with \nappropriate inputs, and could lead to a server crash.  7. Related Work There has been signi.cant research \ntowards automatically validat\u00ading program properties, and detecting program errors when pro\u00adgrams are \nannotated with partial speci.cations describing desired invariants [3, 16, 11, 21, 7, 24, 20, 36, 8, \n22, 15]. Our approach differs fundamentally from these other efforts insofar we assume no input from \nthe programmer on the speci.cations that need to be validated. In [4], Ammons et al. perform speci.cation \nmining by summa\u00adrizing frequent interaction patterns as state machines that capture temporal and data \ndependencies when interacting with API s or abstract data types. Subsequently, Ammons et al. present \nan ap\u00adproach [5] to debug derived speci.cations using concept analysis. Ernst et al. [14] present Daikon, \na tool for dynamically detecting in\u00advariants in a program. Yang et al. [38] present scalable dynamic \nin\u00adference techniques that also work effectively with imperfect traces. While these techniques can indeed \nbe used to derive preconditions, they critically rely on test input providing comprehensive coverage. \nIn this regard, they differ in obvious ways from our approach. Li and Zhou present PR-Miner [26], a tool \nthat relies on mining [1] to identify frequently occurring program patterns. Our work dif\u00adfers signi.cantly \nfrom theirs because we integrate mining within a path-sensitive data.ow framework. Livshits and Zimmermann \n[28] present a tool which uses mining to analyze revision histories of programs. Li et al. [25] also \nuse data mining techniques to detect copy-paste bugs in large software systems. Mandelin et al. [29] \npresent a technique for synthesizing jungloid code fragments au\u00adtomatically based on the input and output \ntypes that describe the code. Their approach is useful for reusing existing code. Because none of these \ntechniques tightly integrate data.ow and control-.ow information with the mining engine, it would be \ndif.cult to leverage them for deriving useful preconditions. It is precisely this synthesis that is the \ndistinguishing contribution of this work. There are several other related approaches that address the \nprob\u00adlem of mining speci.cations. An automatic speci.cation mining technique that uses information about \nexceptions and errors to identify temporal safety rules is presented in [34]. Engler et al. [13] use \nmining to detect relations between pairs of functions, and Kremenek et al. [23] signi.cantly generalizes \nthese earlier ideas. However, [23] is domain speci.c, and requires either ma\u00adchine learning or user speci.cations \nto generate initial annotation probabilities, and employs naming conventions for identifying in\u00adteresting \nprocedures to improve accuracy. As a result, their ap\u00adproach would be ineffective in deriving the speci.cations \nfor the example programs in Figures 1, 5, or Section 6.2. To summarize, unlike these other efforts, our \napproach requires no annotations or guidance from programmers, leverages no pre\u00adsumed semantics of library \nor primitive functions, is not restricted to limited program contexts (e.g., examining only pairs of \nfunc\u00adtions [13], leveraging program semantics [34], or using domain\u00adspeci.c knowledge [23]), and can \ndetect arbitrarily large and com\u00adplex preconditions (e.g., Figure 5). Apart from mining based approaches, \nmany other interesting tech\u00adniques have been devised for bug detection in software systems [18, 39, 27]. \nRinard et al. [32] present an approach on failure oblivious computing that enables servers to run even \nin the presence of mem\u00adory errors. Castro et al. [10] present an approach where a data .ow graph is generated \nand ensures that the data .ow integrity is pre\u00adserved at run time. Because our work focuses on an entirely \nnew di\u00admension, namely statically extracting preconditions from program source transparently, it is conceivable \nthat it could be used in con\u00adjunction with these other approaches to operate with even greater precision \nand scale. 8. Conclusion This paper focuses on the problem of deriving speci.cations us\u00ading predicate \nmining and describes a static inference mechanism for detecting the preconditions that must be valid \nwhenever a pro\u00adcedure is invoked. We derive these preconditions using an inter\u00adprocedural path-sensitive \ndata.ow analysis that gathers predicates at each program point. We apply mining techniques to these pred\u00adicates \nto make speci.cation inference robust in the presence of er\u00adrors. We demonstrate the practicality of \nour techniques by apply\u00ading it to large open-source C programs. Quantitative and qualitative analysis \nof the preconditions generated by our system validate its effectiveness.  Acknowledgements This work \nis supported in part by the National Science Foundation under grant STI 501-1398-1078. We thank Kathleen \nFisher and the anonymous reviewers for their insightful comments. We also thank GrammaTech Inc. for providing \nCodesurfer used to generate the control .ow and data .ow graphs required for our experiments. References \n[1] R. Agrawal and R. Srikant. Fast algorithms for mining association rules. In Proc. 20th Int. Conf. \nVery Large Data Bases, VLDB, pages 487 499, 1994. [2] R. Agrawal and R. Srikant. Mining sequential patterns. \nIn Eleventh International Conference on Data Engineering, pages 3 14, 1995. [3] R. Alur, P. Cerny, P. \nMadhusudan, and W. Nam. Synthesis of interface speci.cations for java classes. In POPL 05: Proceedings \nof the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 98 109, 2005. \n[4] G. Ammons, R. Bodik, and J. Larus. Mining speci.cations. In POPL 02: Proceedings of the 29th ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 4 16, 2002. [5] G. Ammons, D. \nMandelin, R. Bodik, and J. Larus. Debugging temporal speci.cations with concept analysis. In PLDI 03: \nProceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation, pages \n182 195, 2003. [6] P. Anderson, T. Reps, and T.Teitelbaum. Design and implementation of a .ne-grained \nsoftware inspection tool. IEEE Trans. on Software Engineering, 29(8):721 733, August 2003. [7] T. Ball \nand S.K. Rajamani. Automatically validating temporal safety properties of interfaces. In SPIN 2001, Workshop \non Model Checking of Software, LNCS 2057, pages 103 122, May 2001. [8] B. Blanchet. A computationally \nsound mechanized prover for security protocols. In IEEE Symposium on Security and Privacy, pages 140 \n154, 2006. [9] D. Burdick, M. Calimlim, J. Flannick, J. Gehrke, and T. Yiu. Ma.a: A performance study \nof mining maximal frequent itemsets. In Workshop on Frequent Itemset Mining Implementations (FIMI 03), \n2003. [10] M. Castro, M. Costa, and T. Harris. Securing software by enforcing data-.ow integrity. In \nOSDI 06: Proceedings of the 7th Usenix Symposium on Operating Systems Design and Implementation, pages \n147 160, 2006. [11] B. Chin, S. Markstrum, and T. Millstein. Semantic type quali.ers. In PLDI 05: Proceedings \nof ACM SIGPLAN Conference on Program\u00adming Language Design and Implementation, pages 85 95, 2005. [12] \nC. Cortes, K. Fisher, D. Pregibon, and A. Rogers. Hancock: a language for extracting signatures from \ndata streams. In KDD 00: Proceedings of the sixth ACM SIGKDD International Conference on Knowledge Discovery \nand Data mining, pages 9 17, 2000. [13] D. Engler, D. Chen, and A. Chou. Bugs as inconsistent behavior: \nA general approach to inferring errors in systems code. In SOSP 01: Proceedings of the 18th ACM Symposium \non Operating Systems Principles, pages 57 72, 2001. [14] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin. \nDynamically discovering likely program invariants to support program evolution. IEEE TSE, 27(2):1 25, \nFebruary 2001. [15] J. Fischer, R. Jhala, and R. Majumdar. Joining data.ow with predicates. In ESEC-FSE \n05: 10th European Software Engineering Conference and 13th ACM SIGSOFT international symposium on Foundations \nof Software Engineering, pages 227 236, 2005. [16] J. Foster, T. Terauchi, and A. Aiken. Flow-sensitive \ntype quali.ers. In PLDI 02: Proceedings of ACM SIGPLAN Conference on Program\u00adming Language Design and \nImplementation, pages 1 12, 2002. [17] M. Furr and J. Foster. Checking type safety of foreign function \ncalls. In PLDI 05: Proceedings of ACM SIGPLAN Conference on Programming Language Design and Implementation, \npages 62 72, 2005. [18] P. Godefroid, N. Klarslund, and K. Sen. Dart: Directed automated random testing. \nIn PLDI 05: Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation, \npages 213 223, Chicago, Il, 2005. [19] D. Gunopulos, R. Khardon, H. Mannila, S. Saluja, H. Toivonen, \nand R. Sharma. Discovering all most speci.c sentences. ACM Transactions on Database Systems, 28:140 \n174, 2003. [20] T. Henzinger, R. Jhala, and R. Majumdar. Permissive interfaces. SIGSOFT Softw. Eng. Notes, \n30(5):31 40, 2005. [21] G.J. Holzmann. The SPIN Model Checker: Primer and Reference Manual. Addison-Wesley, \n2004. [22] R. Jhala and R. Majumdar. Path slicing. In PLDI 05: Proceedings of the ACM SIGPLAN 2005 Conference \non Programming Language Design and Implementation, pages 38 47, 2005. [23] T. Kremenek, P. Twohey, G. \nBack, A. Ng, and D. Engler. From uncertainty to belief: Inferring the speci.cation within. In OSDI 06: \nProceedings of the 7th Usenix Symposium on Operating Systems Design and Implementation, pages 161 176, \n2006. [24] P. Lam, V. Kuncak, and M. Rinard. Generalized typestate checking for data structure consistency. \nIn VMCAI 05: Proceedings of 6th International Conference on Veri.cation, Model Checking and Abstract \nInterpretation, pages 430 447, 2005. [25] Z. Li, S. Lu, S. Myagmar, and Y. Zhou. Cp-miner: A tool for \n.nding copy-paste and related bugs in operating system code. In OSDI 04: Proceedings of the 6th Usenix \nSymposium on Operating Systems Design and Implementation, pages 289 302, 2004. [26] Z. Li and Y. Zhou. \nPr-miner: Automatically extracting implicit programming rules and detecting violations in large software \ncode. In ESEC-FSE 05: 10th European Software Engineering Conference and 13th ACM SIGSOFT international \nsymposium on Foundations of Software Engineering, pages 306 315, 2005. [27] B. Liblit, M. Naik, A. Zheng, \nA. Aiken, and M. Jordan. Scalable statistical bug isolation. In PLDI 05: Proceedings of the ACM SIGPLAN \n2005 Conference on Programming Language Design and Implementation, pages 15 26, Chicago, Illinois, 2005. \n[28] B. Livshits and T. Zimmermann. Dynamine: Finding common error patterns by mining software revision \nhistories. In ESEC-FSE 05: 10th European Software Engineering Conference and 13th ACM SIGSOFT international \nsymposium on Foundations of Software Engineering, pages 296 305, 2005. [29] D. Mandelin, L. Xu, R. Bodik, \nand D. Kimelman. Jungloid mining: helping to navigate the api jungle. In PLDI 05: Proceedings of the \nACM SIGPLAN 2005 Conference on Programming Language Design and Implementation, pages 48 61, 2005. [30] \nJ. Palsberg. Closure analysis in constraint form. ACM Trans. Program. Lang. Syst., 17(1):47 62, 1995. \n[31] M.K. Ramanathan, A. Grama, and S. Jagannathan. Path-sensitive inference of function precedence protocols. \nIn ICSE 07: Proceedings of the 29th International Conference on Software Engineering, 2007. [32] M. Rinard, \nC. Cadar, D. Dumitran, D. M. Roy, T. Leu, and W.S. Beebee. Enhancing server availability and security \nthrough failure\u00adoblivious computing. In OSDI 04: Proceedings of the 6th Usenix Symposium on Operating \nSystems Design and Implementation, 2004. [33] O. Shivers. Control-Flow Analysis of Higher-Order Languages. \nPhD thesis, Carnegie Mellon University, May 1991. [34] W. Weimer and G. Necula. Mining temporal speci.cations \nfor error detection. In TACAS 05: Eleventh International Conference on Tools and Algorithms for the Construction \nand Analysis of Systems, pages 461 476, April 2005. [35] J. Whaley, M. Martin, and M. Lam. Automatic \nextraction of object\u00adoriented component interfaces. In Proceedings of the International Symposium of \nSoftware Testing and Analysis, ISSTA, 2002. [36] Y. Xie and A. Aiken. Scalable error detection using \nboolean satis.ability. In POPL 05: Proceedings of the 32nd ACM Symposium on Principles of Programming \nLanguages, pages 351 363, 2005. [37] G. Yang. The complexity of mining maximal frequent itemsets and \nmaximal frequent patterns. In KDD 04: Proceedings of the tenth ACM SIGKDD International Conference on \nKnowledge Discovery and Data mining, pages 344 353, 2004. [38] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, \nand M. Das. Perracotta: Mining temporal api rules from imperfect traces. In ICSE 06: Proceedings of the \nInternational Conference on Software Engineering, 2006. [39] J. Yang, P. Twohey, D. Engler, and M. Musuvathi. \nUsing model checking to .nd serious .le system errors. In OSDI 04: Proceedings of the 6th Usenix Symposium \non Operating Systems Design and Implementation, pages 273 288, San Francisco, CA, 2004.  \n\t\t\t", "proc_id": "1250734", "abstract": "<p>The reliability and correctness of complex software systems can be significantly enhanced through well-defined specifications that dictate the use of various units of abstraction (e.g., modules, or procedures). Often times, however, specifications are either missing, imprecise, or simply too complex to encode within a signature, necessitating specification inference. The process of inferring specifications from complex software systems forms the focus of this paper. We describe a static inference mechanism for identifying the preconditions that must hold whenever a procedure is called. These preconditions may reflect both data flow properties (e.g., whenever <i>p</i> is called, variable <i>x</i> must be non-null) as well as control-flow properties (e.g., every call to <i>p</i> must bepreceded by a call to <i>q</i>). We derive these preconditions using a ninter-procedural path-sensitive dataflow analysis that gathers predicates at each program point. We apply mining techniques to these predicates to make specification inference robust to errors. This technique also allows us to derive higher-level specifications that abstract structural similarities among predicates (e.g., procedure <i>p</i> is called immediately after a conditional test that checks whether some variable <i>v</i> is non-null.) We describe an implementation of these techniques, and validate the effectiveness of the approach on a number of large open-source benchmarks. Experimental results confirm that our mining algorithms are efficient, and that the specifications derived are both precise and useful-the implementation discovers several critical, yet previously, undocumented preconditions for well-tested libraries.</p>", "authors": [{"name": "Murali Krishna Ramanathan", "author_profile_id": "81100198525", "affiliation": "Purdue University, West Lafayette, IN", "person_id": "PP35036013", "email_address": "", "orcid_id": ""}, {"name": "Ananth Grama", "author_profile_id": "81100425502", "affiliation": "Purdue University, West Lafayette, IN", "person_id": "P16548", "email_address": "", "orcid_id": ""}, {"name": "Suresh Jagannathan", "author_profile_id": "81100208907", "affiliation": "Purdue University, West Lafayette, IN", "person_id": "PP39032551", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250749", "year": "2007", "article_id": "1250749", "conference": "PLDI", "title": "Static specification inference using predicate mining", "url": "http://dl.acm.org/citation.cfm?id=1250749"}