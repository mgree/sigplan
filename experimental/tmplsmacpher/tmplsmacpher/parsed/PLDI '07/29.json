{"article_publication_date": "06-10-2007", "fulltext": "\n Proving ThreadTermination Byron Cook Andreas Podelski AndreyRybalchenko Microsoft Research University \nof Freiburg EPFL and MPI bycook@microsoft.com podelski@mpi-sb.mpg.de rybal@mpi-sb.mpg.de Abstract Concurrent \nprograms are often designed such that certain func\u00adtions executing within critical threads must terminate. \nExamples of such cases can be found in operating systems, web servers, e\u00admail clients, etc. Unfortunately, \nno known automatic program ter\u00admination prover supports a practical method of proving the termi\u00adnation \nof threads. In this paper we describe such a procedure. The procedure s scalability is achieved through \nthe use of environment models that abstractaway the surrounding threads. The procedure s accuracy is \ndue to a novel method of incrementally constructing environment abstractions. Our method .nds the conditions \nthat a thread requires of its environment in order to establish termination by looking at the conditions \nnecessary to prove that certain paths through the thread represent well-founded relations if executed \nin isolation of the other threads. The paper gives a description of ex\u00adperimental results using an implementation \nof our procedure on Windowsdevicedrivers,andadescriptionofapreviously unknown bug found with the tool. \nCategories and Subject Descriptors D.2.4[Software]: Software Engineering ProgramVeri.cation; D.4.5[Software]: \nOperating Systems Reliability General Terms Reliability,Veri.cation Keywords Concurrency, Formal veri.cation, \nModel checking, Programveri.cation,Termination, Threads 1. Introduction Concurrent event-driven systems \n(e.g. operating systems, web servers, mail servers, database engines) usually execute event\u00adhandling \nroutines in independent threads that communicate through shared-memory. It is often the case that the \nsystem s reliability and usability relies on termination guarantees from code executed in these threads. \nDevice drivers, for example, provide event-handling dispatch routines that are allowed by the operating \nsystem to tem\u00adporarily take over the execution context of the thread in which the event occurred. Failing \nto terminate while handling these events is considered as a violation of correctness. The complication \nfor a programmer trying to ensure termination of a dispatch routine is that other dispatch routines from \nthe same device driver may likely be concurrently modifying shared data and, thus, perhaps inadver\u00adtently \ncause the loop to diverge. The code in Figure 1, for exam- Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 07 June 11 13, 2007, San Diego, California, \nUSA. Copyright c . 2007ACM 978-1-59593-633-2/07/0006...$5.00. KeAcquireSpinLock(&#38;Ext->SpinLock, &#38;irql); \ndo { irp = DequeueReadByFileObject(Ext, FileObject); if (irp) { irp->IoStatus.Status = STATUS_CANCELLED; \nirp->IoStatus.Information = 0; InsertTailList (&#38;listHead,LinkPtr(irp)); } } while (irp != NULL); \nKeReleaseSpinLock(&#38;Ext->SpinLock, irql); Figure1. Code fragmentfromakeyboarddevicedriverwhoseter\u00admination \npartially depends on the correct behavior of other threads from the driver. ple, is a demonstration of \nthis problem. This loop, which comes fromakeyboarddevicedriver, coulddivergeif other threads from the \nsame driver begin adding elements into the queue without .rst acquiring the spinlock &#38;Ext->SpinLock. \nThis scenario would render thekeyboard and machine useless. Unfortunately, today s automatic program \ntermination provers are designed only to support sequential programs. Note that we cannot prove the termination \nof a thread by simply applying a sequential program termination prover individually to the thread: a \nsound proof of termination must consider the possible interactions with the other threads. Furthermore, \nmerely encoding all possible interleavings between threads as a single sequential program does not lead \nto a scalable solution using today s termination provers. What is needed is a practical, automatic, accurate \nand scalable termination-proof technique that supports threads. In an effort to achievethisgoal,inthispaperweadapt \nthread-modularveri.cation techniques based on environment abstractions(e.g. [15,26,30,33]) for the application \nof proving thread termination. The challenge in this approach is to .nd a sound abstraction of the environment \nthat is accurate enough to prove the property of interest. The technical contribution of this paper is \na novel method of constructing sound environment abstractions in the context of thread-modular termination \nproofs. Our method .nds the condi\u00adtions that a thread requires of its environment in order to establish \ntermination by looking at the conditions necessary to prove that certain paths through the thread represent \nwell-founded relations if executed in isolation of the other threads.If sucha proofexists, the method \nextracts information from this proof in order to incremen\u00adtally strengthen the environment abstraction. \nThe method also uses failed attempts to prove the soundness of the environment abstrac\u00adtion in order \nto incrementally weaken it. To demonstrate the practical utility of the proposed method we have appliedittoprovingthatWindowsdevicedriver \ndispatch rou\u00adtinesdo notdiverge whenexecutedin concurrent setting. Theseex\u00adFigure 2. Example concurrent \nprogram P = 1 . x' = x is an environment model(a.k.a. 1 lock(lck); 1 while(nondet()) { 1 while(nondet()) \n{ 2 while(x>0) { 2 InterlockedDecrement(&#38;x); 2 y = y + 1; 3 InterlockedDecrement(&#38;x); 3 } 3 lock(lck); \n4 } 4 x = nondet(); 5 unlock(lck); 5 unlock(lck); 6 } T1 T2 T3 T1||T2||T3. The binary relation A . lck= \nagreement) suf.cient to show thread-termination of T1. InterlockedDecrement(&#38;x) isaWindowskernel-level \nAPI that implements x:=x-1 atomically. Note that, without InterlockedDecrement(&#38;x), the instruction \nx=x-1 would be treated non-atomically as two separate instructions(e.g. t=x-1;x=t;). The function nondet() \nis used to represent non-deterministic choice.We note that non\u00adtermination of the threads T2 and T3 does \nnot affect the thread-termination property of the thread T1. periments represent the .rst known application \nof automatic thread\u00adtermination proofs for industrial software. Related work. All automatic tools known \nto be successful at proving properties of concurrent programs employ some form of reduction or elimination \nof the number of interleavings and chan\u00adnels of interaction considered during their search for a proof. \nEx\u00adamples include [13, 16, 24, 25, 27, 29 31, 34, 35]. In the case of tools that attempt to eliminate \nall interleavings(e.g.thread-modular tools[26,30]),theburdenof performanceand accuracylargelyfalls to \nthe techniques used to .nd the environment abstractions thatfa\u00adcilitate the use of only sequential program \nanalysis tools. The dis\u00adtinguishing characteristic of our approach in comparison to previ\u00adous thread-modular \ntechniques is the novel method described for iteratively strengthening environment models for the application \nof thread-modular termination analysis. Avariety of program termination provers have been reported in \nthe literature(e.g. for imperative programs see[2,5,8,9,17 19,21, 22,40]). Our work differs from these \nprevious works in that we are the .rst to describe a practical method for proving termination of threads \nto date all of the existing work on automatic termination analysis has focused on sequential programs. \nIn order tobuildaworking solution to the thread-termination problemwehavebuiltuponpreviouslyreported \ntechniques.Weuse existing tools for sequential program termination analysis.We also use sequential safety \nprovers when checking the soundness of can\u00addidate abstract environment models.We usea well-known method \nfor computing thread-local program invariants(e.g. [32]).We also use a technique of computing relational \nmeanings for instructions via single-step symbolic simulation with freshvariables(as seenin e.g. [6,22,36,39]). \n2. Example Before providing a more formal description we begin with an ex\u00adample which shows thekeyaspectsof \nthe algorithm. Figure2 con\u00adtains a concurrent program P which is formed by the composition of three threads: \nT1, T2, and T3. Imagine that we would like to prove the termination of T1 meaning that no computation \nof the program P contains in.nitely many T1-steps. Notice that P itself does not guarantee termination. \nOur algorithm is in search for an environment model, call it A, thatover-approximatesthebehaviorofthe \nthreads T2 and T3 while being precise enoughtofacilitatetheproofof T1 s termination. A isabinary relationoverthe \nstatesofthe program P expressed using only primed and unprimed versions of P s shared variables (which \nare x, x , lck, and lck for our program).We use the primed variables, such as x for example, to represent \nvalues of program variables after taking a transition. In this work we call A an agreement, as our algorithm \nimple\u00admentsaformoftwo-waynegotiation whichinvolvesboth strength\u00adening and weakening. The search for an \nA uses feedback both from the thread that we are trying to prove terminating and the threads in the environment. \nDuring its execution the algorithm .nds a se\u00adries of draft agreements, A1, A2, etc. The algorithm attempts \nto compute a .xpoint on these draft agreements. Both the draft agree\u00adments and the .nal agreement are \nrepresented in conjunctive nor\u00admal form. Strengthenings are implemented as additional conjuncts, and \nweakenings as additional disjunctions withinasingle conjunct. We begin with the weakest possible draft \nagreement A1 . true , whichimposesno constraintsonthechangeofthesharedvariables by the threads T2 and \nT3. Clearly T2 and T3 meet this agreement. Our algorithm then attempts to prove thread-termination of \nT1 not in the original concurrent setting of P,but instead in a concur\u00adrent setting represented by A1. \nThis amounts to considering com\u00adputations that arise from alternatingexecution stepsof T1 with non\u00addeterministic \nupdates that respect the agreement. In our case of the weakest possible agreement A1 . true, we must \nassume that the updates can change the value of x arbitrarily and the value of lck in anyway that obeys \nthe locking discipline assumed to hold of the program. Inthe .rst iteration,the algorithm .ndsa counterexampletothe \ntermination of T1 in the concurrent setting with the agreement A1. The counterexample is a sequence of \ninstructions through T1 and together with instructions representing the interleaving with A1. In this \ncase the counterexample contains the following statements, where the statement x=nondet() models the \neffect of interleav\u00ading with the agreement A1: x=x-1; x=nondet(); assume(x>0); Noticethat this instruction \nsequenceis not well-founded(i.e. the sequence can be repeated forever without reaching an inconsistent \nstate). However, it is a spurious counterexample, as it does not represent an execution allowed in P. \nThe algorithm then uses this path to strengthen the agreement. Strengthening here means that we add a \nconjunction to the agree\u00adment such that the found counterexample is eliminated in the next iteration \nof the algorithm. The relation ' A2 . true . x= x becomes the new agreement. The strengthening, x' = \nx, is inferred from a ranking relation for the restriction of the counterexample to the steps taken only \nby the thread T1 (i.e. from the proof that the sequence of statements x=x-1; assume(x>0); is not a valid \ncounterexample to termination). In the second iteration, we succeed in proving termination of T1 in the \nconcurrent setting with the agreement. We must then check whether the other threads in the program P, \ni.e. the threads T2 and T3, respect the draft agreement A2. In order to show that the thread T2 respects \nthe agreement A2, we must prove that InterlockedDecrement(&#38;x), which implements the decre\u00adment x=x-1 \natomically, does not increase the value of x. This check succeeds.Wethen attempt to prove that T3 respects \nA2 by checking that the non-deterministic assignment x=nondet() re\u00adspects A2. This check fails meaning \nthat the agreement A2 true . x ' = x is too strong to be satis.ed by the thread T3. In response to thisfailed \ncheck we attempt to weaken A2. To weakenA2 we take the locking into account: The statement x=nondet(), \nwhichfailed the check,is protectedbya lock lck. Thus we weaken the agreement with a side-condition that \nrules out this case: A3 true . (lck =1 . x ' = x) . The range of lck is over the thread identi.ers {1, \n2, 3}. Infor\u00admally stated, A3 states that the environment should ensure that itnever increasesthevalueof \nx in the case that thread T1 holds the lock lck . We now restart the algorithm with the weakened draft \nagree\u00adment A3.We can still prove the termination of T1 in the context of the weaker agreement A3. Furthermore, \nwe can now prove that both T2 and T3 respect A3. Thus, we have found a .xpoint and proved that T1 is \nthread-terminating in the concurrent program P using the .nal agreement AA3 true . (lck =1 . x ' = x) \n. Practical reasons for success. The strategy proposed in this sec\u00adtion usesacollectionof toolsas sub-procedures \nwhich approximate solutions to undecidable problems(e.g. both safety and termination for in.nite-state \nsystems) thus we cannot guarantee that the ap\u00adproach will always terminate, nor can we guarantee that \ncounterex\u00adamples found with the approach will not be spurious. However, as we will see in Section 7, \nin practice our preliminary implementa\u00adtion performs well. The following notes provide some explanation \nas to why: Manyloops used in industrial programs use termination condi\u00adtions that only depend on thread-local \nvariables. As we will see in Section7, more than halfof the loops fromWindowsdevice drivers are provably \nthread-terminating with A1 true. In the remaining cases only a few rounds of strengthening and weak\u00adeningaretypically \nrequired.Thisisduetothefactthatprogram\u00admers typically use defensive techniques when writing loops, e.g. \nthey typically do not depend on complex whole-program invariants to establish termination. It is for \nthis reason that our strategy of considering program paths in isolation works: the reason that a path \ndoes not represent a divergent execution will likely not involve much reasoning about the surrounding \nenvi\u00adronment.  Our de.nition of thread-termination does not rule out deadlock, as deadlock is a safety \nproperty. That is, we are proving that T1 eventually stopsexecuting, not that T1 eventually reachesa \ncall to exit or return. This separation of concerns allows us to use methods that would otherwise be \nprecluded.  It is known that both termination and safety checking can be made practical for some classes \nof industrial sequential soft\u00adware (e.g. [3, 7, 21, 28]). In our setting we are applying this same class \nof tools on sequential programs that encode the in\u00adterleaving of only two threads (as opposed to 3, 4, \netc), one of  which is a representation of a typically very simple artifact (the agreement A). Thus, \nin practice, the sequential program analy\u00adsis tools still perform adequately on these programs. Sequential \nprogram termination provers typically do not prove the validity of the counterexamples that they return. \nThat is, these tools typically are attempting only to prove termination and not prove non-termination. \nIn theory this could cause our analysis to loop forever as it tries to strengthen/weaken agree\u00adments \nbased on counterexamples that are not only spurious in the concurrent settingbut also the sequential \nsetting. In prac\u00adtice, however, this is not a problem. If the termination prover supports linear arithmetic, \nbit-vectors, and heaps then the num\u00adber of spurious counterexamples is quite low.  The agreements necessary \nto prove thread termination typically needonlyexpress conditionsonthe directionsin whichtheval\u00adues of \nshared variables may change, i.e. the direction of vari\u00adance of a shared variable rather than a unary \ninvariance rela\u00adtionship. Aside from conditions on lock variables our method never introduces unary state \nassertions, e.g. y > 0,but rather always uses binaryvariance assertions, e.g. x ' = x. It is for this \nreason that we can easily prove that threads in the environment respect the agreement A. In the case \nthat A y > 0, stronger methods would be required to prove that T3 from Figure2 re\u00adspects A.  3. Formal \nde.nitions The previous section informally introduced our thread-modular algorithm for proving thread \ntermination. In this section we make the algorithm more precise. 3.1 Preliminaries Weassumea.xed programP \ncomposed from N concurrent threads T1,...,TN. Let G be the set of global states de.ned as valuations \nof shared variables. Let Li be the local states of thread Ti de.ned by valuations of local variables \nof thread Ti. A program state s consists of a global state g together with local states l1,...,lN of \nthe threads, i.e. s =(g, l1,...,lN). Let S be the set of all states of the program P, i.e. S= G \u00d7 L1 \n\u00d7\u00b7 \u00b7\u00b7\u00d7 LN. When making a transition from a state s, we assume that in practice each thread Ti can only \nmodify the global state g and its local state li;all other local stateslj ,wherej = i,remain the same. \nFormally, the transition relationRi of the thread Ti is a subset of S \u00d7 S such that for each ((g, l1,...,lN), \n(g ' ,l ' N)) . Ri 1,...,l ' we have that for all j = i, lj = lj ' holds. Moreover, without loss of generality, \nwe assume that li = li'.Forexample we can assume that each threadhas a local program counter which changes \nits value if andonlyifthe corresponding threadmakesastep.This assumption is for De.nition 1. The transition \nrelation R of the program P is the disjoint union of the transition relations of the threads, R = R1 \n\u00b7 \u00b7\u00b7 RN. Non-atomicreadsandwritescanbe modelledinthisframeworkby splitting single statements into composite \nstatements with tempo\u00adrary variables(e.g. x=x+1 can be re-written as t=x; x=t+1;). Let I . S be the set \nof initial states of the program P. We de.ne a computation s of the program P to be a (possibly in.nite) \nsequence of states s = s1,s2,... such that s1 is an initial state, and each pair of consecutivestates \n(s, s ' ) is in R.Wesay thatastate is reachable if it appears in some computation, and write Reach(P) \nfor the set of all reachable states of the program P. We assume a .nite set of lock-variables, Locks. \nAssume that wehavea lock lck . Locks. Intuitively,ifthevalueofthe lock lck in the state s is 3 then this \nmeans that the thread T3 (and no other thread) holds the lock lck in the state s. If its value is 0 then \nno thread holds the lock. We assume that threads satisfy the following locking discipline: A thread can \nacquire a lock only for itself, and it can release a lock only when it owns it. Thus, we are not currently \nconsidering mutexes. Formally, for each thread Ti and lock variable lck we assume Ri . DAi and Ri . DBi \n, where ' '' DAi {(s, s ) | s(lck)=0 . s (lck)=0 . s (lck)= i} DB '' i {(s, s ) | s(lck)= i . s(lck)=0 \n. s (lck)= s(lck)} DA Later in the paper we will use i and DBi as formulae over variables rather than \nsets of states, e.g. lck =0 . lck ' =0 . lck ' = i . 3.2 Thread termination Assumethat T1 is the thread \nwhose termination behavior is under investigation. DEFINITION 1 (Thread termination). T1 is thread terminating \nif in each computation of the program P it makes only .nitely many steps. Formally, for every computation \ns = s1,s2,... of the program P there exists a position k = 1 such that there are no T1 steps after k, \ni.e. if (si,si+1) . R1 then i = k. DEFINITION 2 (AgreementA). An agreement A is a binary rela\u00adtion over \nstates that expresses a constraint on the change of global states, and leaves the change of local states \nunconstrained. For\u00admally, for each pair of states ((g, . . . ), (g ' ,... )) .A and for each i .{1,..., \nN} we have ' '' {(li,l i) | ((g, . . . , li,... ), (g ,...,l i,... )) . A} = Li \u00d7 Li . We de.ne the relational \ncomposition of two relationsA and B over states in the usual way, i.e. A . B = {(s, s '' ) |.s ' . (s, \ns ' ) . A . (s ' ,s '' ) . B}. Let A * denote the re.exive transitive closure of A. For each i .{1,..., \nN} we de.ne a restricted identity relation idLi over states (which constrains only the local states of \nthread Ti): idLi = { ((g, . . . , li,... ), (g ' ,...,li,... )) | (g, . . . , li,... ) . S and (g ' ,...,l \ni' ,... ) . S} . Ideally, we would like to use the agreement A to break the proof of thread termination \nfor T1 into the checking that i) T1 s transition relation when combined with A and restricted to states \nReach(P) \u00d7 Reach(P) is well-founded, and ii) that the transi\u00adtion relations of the remaining threads \nrespect A when restricted to Reach(P) \u00d7 Reach(P). However, the dif.culty is that the restric\u00adtion to \nReach(P) \u00d7 Reach(P) requires us to consider the set of all possible interleavings between thevarious \nthreads.For this reason, following existing techniques for thread-modular veri.cation, we compute a thread-local \ninvariant Si for each thread Ti. A thread-local invariant Si approximates Reach(P) by con\u00adstraining only \nthe local part li of states of the thread Ti. This means that the global part of the state and the local \nparts of the other threads remain unrestricted. DEFINITION 3 (Thread-localinvariantSi). A set of states \nSi is a thread-local invariant for the thread Ti in the concurrent program P if it only constrains the \npart of the state that is local to the thread Ti, contains the initial states I, and is closed under \nthe image operation of the transition relation Ri of the thread Ti that is applied in composition with \nthe non-deterministic assignment to the globalvariables.Formally, Si needs to satisfy the conditions: \n{g | (g, . . . ) . Si} = G {lj | (...,lj ,... ) . Si} = Lj for each j .{1,..., N}\\{i} I . Si [(Si \u00d7 S) \nn idLi ] . Ri . S \u00d7 Si T1 is thread terminating if there exists an agreement A and thread-local invariants \nS2,...,SN such that 1. The sequential program SeqComp(T1, A) terminates, 2. [Ri n (Si \u00d7 Si)] .A for \neach i .{2,..., N}.  Figure 3. Thread-termination proof rule. We use thread-local invariants to restrict \nthe domain and range of Ri when checking it with respect to the agreement A.Aproof rule making this preciseisgivenin \nFigure3.In the rule we use the sequential program SeqComp(T1, A) de.ned below (intuitively, we abstract \nthe interleaving of thread T1 with the other threads by composing each of its statements with any number \nof non\u00addeterministic,but A-conform assignments to the global variables). DEFINITION 4 (SeqComp). Let \nSeqComp(T1, A) beasequential program with the set of initial states I1 and the transition relation [An \nidL1 ] * . R1 . Soundness of the proof rule in Figure3relies on the following lemma relating thread-local \ninvariants and premises of the proof rule. LEMMA 1. A thread-local invariant Si, where i .{2,..., N}, \napproximates the set of reachable states of the program P, i.e. Reach(P) . Si. PROOF We show thatevery \nreachable states in Reach(P) is con\u00adtained in Si by induction over the shortest number of transitions \nn which is required to reach s.For n =0 we have that s is in I , and hence in Si.For the induction step, \nwe assume that s is reachable after n transitions,and hencebythe inductionhypothesisitisin Si We prove \nthat its successor s ' is in Si. Let Tj be the thread that makes the transition from s to s ' , i.e. \n(s, s ' ) . Rj . Now we con\u00adsider the case when i = j.Wehave (s, s) . [(Si \u00d7S)nidLi ],from which follows \nthat (s, s ' ) . S \u00d7 Si. If i = j then the li-part of s does not change during transition. Since Si restricts \nonly Ti-local part of the state, we have s ' . Si. D THEOREM 1. The proof rule in Figure 3 is sound. \nExistence of an agreement A and a set of thread-local invariants S2,...,SN, which satisfy the premises \nof the proof rule, implies the thread\u00adtermination property of the thread T1. PROOF Assume that the conditions \nof the proof rule hold for an agreement A and thread-local invariants S2, ..., SN,but T1 is not thread \nterminating.We shallderivea contradictiontothe .rst con\u00addition, i.e. we show that the sequential program \nSeqComp(T1, A) does not terminate. Let s = s1,s2,... be an in.nite computation of P that vio\u00adlates the \nthread termination property for T1. Then, s contains in\u00ad.nitely manytransitions of T1, which are possibly \ninterleaved with transitions of other threads. We show that s is a computation of SeqComp(T1, A).We need \nto prove that each transition (s, s ' ) in s that is not taken by the thread T1 satis.es the agreement \nA, as we have (s, s ' ) . idLi . Let (s, s ' ) . Ri for some i .{2,..., N}. From Lemma 1, we have that \ns and s ' are in Si. Hence, from the second condition of the proof rule we have (s, s ' ) .A. D 3.3 \nAlgorithm Our algorithm for proving thread-terminationis de.nedover four sub-procedures: a termination \nchecker (for sequential programs), a strengthening procedure,a guarantee checker, and a weakening procedure. \nSee Figure4for the algorithm. The termination checker is used in Figure4during attempts to prove the \ntermination of sequential programs constructed from T1 input concurrent program P = T1|| ... ||TN begin \nA := true repeat if SeqComp(T1, A) terminates then return T1 is thread terminating else p := lasso counterexample \nin T1 if strengthening of A is not possible using p then return T1-termination prooffailed else A := \nstrengthened agreement found with p foreach i .{2,..., N} do if Ti fails to guaranteeA then weaken A \ndone done done end. Figure 4. Algorithm for checking thread-termination using termi\u00adnation agreements. \nand A, i.e. SeqComp(T1, A). When this proof succeeds then we can argue that T1 is thread terminating \nif A is a sound overap\u00adproximation of T2,...TN, i.e. the environment respects A. If the sequential termination \ncheck fails then we expect that the termi\u00adnation prover returns a potential counterexample, which is \na lasso path pA through SeqComp(T1, A).We say that pA is de.ned to = pA,s be a lasso path if pA .(pA,c). \nand both pA,s and pA,c are .nite sequences (the s is short for stem , c is short for cycle ). As is done \nin [21], we can actually think of pA asasequential program (independent of P and its threads) that represents \nexecutions of the .(pA,c form pA,s )..We can even use other termination provers to try and prove that \nthese representative programs are terminating, i.e. that the paths are spurious counterexamples to termination. \nFur\u00adthermore, we can remove the A-steps from pA. Let this version of pA be p. The path p can also be \nviewed as a program representing all executions in T1 of the form ps .(pc). where, again, ps and pc are \n.nite sequences. The strengthening procedure in Figure4attempts to prove the cyclic component of the \nsequential program that p represents is terminating(i.e. that the relation that it represents is well-founded) \nin order to mine information about the assumptions under which the thread T1 terminates. If the strengthening \nprocedure succeeds in proving well-foundedness of the cycle, then pA may represent a spurious counterexample \nto T1 s thread-termination in P. In this case the strengthening procedure strengthens the agreement A \nus\u00ading the information mined from the proof of pc swell-foundedness. Under the assumption that the environment \nsatis.esthe new agree\u00adment, the path p is not a counterexample to thread-termination in the concurrent \ncontext with the new agreement.Adetailed descrip\u00adtion of this procedure and its connection to the sequential \ntermina\u00adtion checker is contained in Section 5. The guarantee checker in Figure4takes an agreement A \nand a thread Ti and attempts to ensure that Ti in its concurrent execution respects the agreement A. \nIf the guarantee checkerfails then the the weakening procedure is used. The weakening procedure takes \nas input the agreement A, the thread Ti, and an explanation for the failure of the guarantee check. The \nweakening procedure attempts to produce a new weaker agreement respected by the thread Ti.A detailed \ndescription of the checking and weakening mechanisms appear in Section 6. 4. Proving termination with \nagreements Our goal in this section is to provide a method of encoding SeqComp(T1, A) such that it can \nbe passed to an existing sequen\u00adtial termination prover and such that the counterexamples produced by \nthe termination prover can be examined in isolation of A. We assume thatA is a formula expressed over \nthe shared vari\u00adables of the program, say V (including Locks), and their primed versions V ' (including \nLocks ').For now we will assume that A is re.exive and transitive later we will discuss an implementation\u00adlevel \ndetail that encodes the re.exive and transitive closure of A. To implement SeqComp(T1, A) we de.ne a \nnew sequential program S with a control-.ow graph that is identical to that of T1, with the exception \nof additional instructions within the basic blocks. The construction of S is thus performed at the instruction\u00adlevel \non the instructions from the thread T1. DEFINITION 5 (Transformation implementingSeqComp(T1, A)). Let \nS be a program constructed from the thread T1 such that S has the same control-.ow graph as T1 and a \ncall to the procedure A STAR() is placed in front of each statement. We de.ne A STAR() to be: 1. a series \nof assignment statements v ' := nondet(); for each v ' . V ' (including Locks '), 2. assume(A); 3. \nassume(DAj ); for each j .{2,..., N} and for each lock variable lck, 4. assume(DBj ); for each j .{2,..., \nN} and for each lock variable lck, 5. a series of assignment statements v := v ' ; for each v ' . V \n' (including Locks '),  Our transformation creates a program whose transition relation corresponds to \nthe sequential composition of the transition relation of the thread T1 and the relation de.ned by the \nagreement A. It is achieved by having a statement that correspond to A-respecting steps before each statement \nof the thread T1. Counterexamples. The counterexample produced by the sequen\u00adtial program termination \nprover will include instructions inside of A_STAR. Thus, this counterexample produced from S is the pA \nmentioned in Section 3. In order to construct the T1-centric coun\u00adterexample p we need only remove the \ninstructions from A_STAR from pA . 4.1 Examples Agreements without locks. We consider theT1 in Figure \n2, and assume the agreement A x ' = x. Informally this means The other threadsexecuting concurrently \nwill only make x smaller if theymodify x at all. An application of the transformation from De.nition \n5 on the thread T1 produces the program shown in Figure 5. TERMINATOR, for example, is able to prove \nthe termination of this sequential program. Furthermore, the termination proof of this program implies \nthat T1 terminates when executed in an environ\u00adment which agrees to A. Agreements with locks. We can \nalso support agreements with predicates over locks, such as A [lck =1 . x ' = x] . The intention of A \nisalmost the same as before withtheextra side condition that the guarantee need only be provided by the \nother threads when thread 1 holds the lock lck. In case that another thread does have the lock lck, then \nlck =1 and thus, nothing is promised. void A_STAR() { lck = nondet(); x = nondet(); assume(!(lck==0 &#38;&#38; \nlck !=0) || lck >1); assume( lck!=1 || lck ==l); assume(x <=x); lck = lck ; x = x ; } void S() { A_STAR(); \nlock(lck) A_STAR(); while(x>0) { A_STAR(); InterlockedDecrement(&#38;x); A_STAR(); } A_STAR(); unlock(lck); \n } Figure 5. Result of transformation in De.nition 5 on T1 from Figure2and A = x ' = x. void A_STAR() \n{ lck = nondet(); x = nondet(); assume(!(lck==0 &#38;&#38; lck !=0) || lck >1); assume( lck!=1 || lck \n==l); assume(x <=x || lck!=1); lck = lck ; x = x ; } void S() { A_STAR(); lock(lck) A_STAR(); while(x>0) \n{ A_STAR(); InterlockedDecrement(&#38;x); A_STAR(); } A_STAR(); unlock(lck); } Figure 6. S constructed \nfrom A [lck =1 . x ' = x] and T1 from Figure 2. We consider again the threadT1 from Figure 2, in which \nthe in\u00adstruction lock(lck) is placed just before the start of the loop. Using this example together with \nour new A will give us a se\u00adquential program in which the de.nition of A_STAR is contained in Figure \n6. The available program termination provers can prove the termination of this program also. However, \nwithout the call to lock(lck) the termination proofwouldfail. 4.2 Supporting non-transitive agreements \nIn the case that the agreement A is not transitive, we can encode its re.exive and transitive closure \nin our translation by placing the following code-fragment instead of A_STAR() in front of each statement \nin the thread T1: while(nondet()) { IgnoreCutpoint(); A_STAR(); } We assume that the use of IgnoreCutpoint() \ncauses the program termination prover to ignore failures of program termi\u00adnation in which the in.nite \nsubsequence of the non-termination execution remains strictly within the loop enclosing calls to IgnoreCutpoint(). \nIn practice (where termination provers are based on the identi.cation of cutpoints in the program s control\u00ad.ow \ngraph) this is easy to implement. 5. Strengthening agreements In this section we describe a method of \nstrengthening the termina\u00adtion agreement A with additional constraints. This has the effect of placing \nadditional constraints on the environment, thus giving the thread of interest more guarantees about the \ndirection of the vari\u00adance of the variables that it is reading and updating. We assume the situation \nwhere the sequential termination prover has found a counterexample path pA in the sequential pro\u00adgram \nS. This means that thereexistsa sequenceof statementsonly from the thread T1. Let p be the subsequence \nof pA that consists of the statements from the thread T1. Recent termination provers can produce such \ncounterexamples and represent them in form of lasso paths (as described in [21]). Hence, we assume that \np consists of two parts, ps and pc.For simplicity of exposition, we only use the cycle part of the lasso \nfor re.ning the agreement. In order to in\u00adcrease precision, the stem part can be taken into account following \nan algorithm in [21]. The strengthening algorithm analyzes whether the non\u00adtermination is caused by the \ninterleaving with A. This analy\u00adsis amounts to the computation of a ranking function for the se\u00adquence \npc (which does not contain anystatements from A). If such a ranking function exists then we say that \nthe counterexample is potentially spurious.We say potentially spurious because A might truly represent \na possible behavior of the environment. In the case that pc is well-founded, the strengthening algorithm \nsuggests a strengthening Ad of the termination agreement that can be used for pruning the counterexample \non the next iteration of the algorithm.We thus use Ad to strengthen A: A := A.Ad Ad needs to satisfy \nthe following properties. Anyinterleaving of Ad with the statements from pc is a well\u00adfounded relation, \ni.e. the sequence below is well-founded. A * d p1cA * d ... Ad * pnc A * d Here, A * d represents an \narbitrary sequence of Ad elements. This property guaranties that our thread-termination algorithm makes \nprogress at each iteration each counterexample appears only once. Section 6 describes an algorithm that \nuses lock\u00ading information to weaken agreements, while maintaining the progress property. Ad must be a \nre.exive relation, and hence admit void environ\u00adments not modifying shared variables. We argue that the \nbinary relation that captures the non-increase of the ranking function for pc, together with the identity \nrelation provide a good candidate for a stronger termination agreement. Let r(x) be an expression over \nthe L1-variables that determines the ranking function computed for the sequence pc.We de.ne Ad = r(x \n' ) = r(x) . We observe that Ad is transitive and re.exive as required by our algorithm. Additionally, \nAd guarantees the elimination of this counterexample if all assertions that are used in the proof of \nwell\u00adfoundedness of pc are transitive, which is often observed in systems code. LEMMA 2. Let the sequential \ncomposition of statements stmt1 and stmt2 given over the variables x and x ' be included in the strictly \ndecreasing relation rx ' = rx - 1 induced by a linear ranking function rx. Then, for Ad = rx ' = rx we \nhave that the transition relation of the sequence of statements stmt1 ; x ' = nondet(); assume(Ad); x \n= x ' ; stmt2 ; is included in rx ' = rx - 1 provided that the transition relations of the statements \nstmt1 ; and stmt2 ; are transitive. PROOF Let the transition relations of the statements stmt1 and `\u00b4 \nstmt2 be represented by the relations (PP ' ) xx = p and `\u00b4 : x (QQ ' ) x: = q, respectively. First, \nfrom their transitivity follows that P = -P ' and Q = -Q '. (The proof relies on the assumption that \nthe rows of (PP ' ) and (QQ ' ) are linearly independent, which holds for transition relations of program \nstatements.) Second, since their sequential composition is included in the strictly decreasing relation, \ni.e. 01 01 \u00ab \u00ab xx ' `\u00b4 PP 0 p '' @x A = =.-r 0 r @x A =-1 ,0 QQ ' q '' '' xx we have that for some non-negative \nvectors . and \u00b5 ' .P = -r .P = -\u00b5Q \u00b5Q ' = r. We consider the sequential composition of the statements \ninter\u00adleaved with the agreement: 01 01 x 01 ' PP 00 p ' B x C @0 -rr 0 A@ '' A = @0A . x 00 QQ ' q ''' \nx We observe that the linear combination de.ned by the vector (. 1 \u00b5) yields the desired implication \nrx ''' = rx - 1. D Now by induction over the length of the sequence pc we can prove that the transition \nrelation of the sequence A * d p1cA * d ... Ad * pc A * is included in rx ' = rx - 1. nd 5.1 Example \nConsider a program S representing SeqComp(T1, A), where T1 is drawn from Figure 2, and A = true. See \nFigure 7. In this case a sequential program termination prover would produce counterex\u00adample including \nthe cycle expressed by the line numbers of the traversed statements. A,c p=3.A . 3 . 4.A . 2 . A.1 void \nA_STAR(int i) A.2 { A.3 x = nondet(); A.4 lck = nondet(); A.5 assume(!(lck==0 &#38;&#38; lck !=0) || \nlck >1); A.6 assume( lck!=1 || lck ==lck); A.7 assume(true); A.8 x=x ; A.9 lck = lck ; A.10 } 0 void \nS() { 1.A A_STAR(); 1 lock(lck); 2.A A_STAR(); 2 while(x>0) { 3.A A_STAR(); 3 InterlockedDecrement(&#38;x); \n4.A A_STAR(); 4} 5.A A_STAR(); 5 unlock(lck); 6} Figure 7. S constructed from A = true and T1 from Figure \n2. When we consider the representation of pA,s in static single as\u00adsignment form, we get the following \nrelation, [ pA,c] = { ((x0 , lck0 ), (x3 , lck2 )) | lck0 =0 . lck1 =0 . lck1 > 1 // 3.A: creating x1 \nand lck1 . lck0 =1 . lck1 = lck0 // 3.A: . x2 = x1 - 1 // 3: . lck1 =0 . lck2 =0 . lck2 > 1 // 4.A: creating \nx3 and lck2 . lck1 =1 . lck2 = lck1 // 4.A: . x3 > 0 // 2: } Because the A-statements non-deterministically \nchange the value of the variable x, we can always .nd a value for x3 such that x3 > 0. Thus the relation \nthat pA,c represents is not well\u00adfounded. However, if we consider only the statements in pA,c that come \nfrom T1 (i.e. pc =3 . 2 .)we get a relation [ pc] that is provably well-founded. [ pc] = {((x0 , lck0 \n), (x1 , lck0 )) | x1 = x0 - 1 . x1 > 0} In this case tools based on rank function synthesis(e.g. RANK-FINDER \n[38] or POLYRANK [9 12]) would produce a witness to the well-foundedness in the form of a ranking function \nx. Every relation step decreases the value of the ranking function by at least one, and this decreaseis \nbound from belowby zero. We are now in the situation where the counterexample found in S is either due \ntoa real concurrencybug or an insuf.cient en\u00advironment assumption. The observation that we make here \nis that the computation of the ranking function in the non-concurrent case can provide a useful hint \nfor the construction of the environment assumption that the developer of the thread T1 is expecting.Fol\u00adlowing \nLemma2we consider the relation Ad = x ' = x for strengthening of the agreement. Note that a termination \nprover for sequential programs does not produce the same counterexample when supplied a program implementing \nSeqComp(T1, A.Ad), as the relation represented by the cycle pA.Ad,s is well-founded, [ pA.Ad,c] = { ((x0 \n, lck0 ), (x3 , lck2 )) | lck0 =0 . lck1 =0 . lck1 > 1 // 3.A: creating x1 and lck1 . lck0 =1 . lck1 \n= lck0 // 3.A: . x1 = x0 // 3.A . x2 = x1 - 1 // 3: . lck1 =0 . lck2 =0 . lck2 > 1 // 4.A: creating x3 \nand lck2 . lck1 =1 . lck2 = lck1 // 4.A: . x3 = x2 // 4.A . x3 > 0 // 2: } 6. Checking and weakening \nagreements In this section, we describe a method for checking if the other threads in the program P respect \nthe agreement A. Our method relies on a sequential safety checker for the computation of thread\u00adlocal \ninvariants S2,...,SN.We also describe a method of weaken\u00ading A in the case that the environment does \nnot respect it. We check that the threadsT2,...,TN respect A by proving the assertion validity for a \nset of sequential programs AgChk(T2, A), ..., AgChk(TN, A) (de.ned below in De.nition 6). Each program \nis constructed by adding additional statements into the control\u00ad.ow graph of the thread, and using auxiliary \nvariables ' V that are copies of the shared variables V. These statements serve two goals. Firstly, they \nensure that the set of reachable states of a program AgChk(Ti, A) corresponds to a thread-local invariant \nSi for the thread Ti. Secondly,theycheck if the agreement A is satis.ed. This check naturally takes the \nthread-local invariant Si into account. DEFINITION 6 (AgChk(Ti, A)). Let Qi = AgChk(Ti, A) be a program \nconstructed from the thread Ti, where i .{2,..., N}such that Qi has the same control-.ow graph as Ti \nand each state\u00adment stmt; is replacedby the following sequenceof statements: 1. a series of assignment \nstatements v ' := nondet(); for each v ' . V ' , 2. assume(\u00ac(lck =0 . lck ' = 0) . lck ' = i ); for each \nlock variable lck, 3. assume(lck = i . lck ' = i); for each lock variable lck, 4. a series of assignment \nstatements ' v := v; for each ' v . ' V, 5. a series of assignment statements v := v ' ; for each v \n. V, 6. stmt; and 7. assert(A[ ' V/V][V/V ' ]));  The output of this transformation, Qi can be passed \nto a se\u00adquential safety checker.We observe that thesetof reachable states of Qi represent a thread-local \ninvariant Si that satis.es the con\u00additions of the proof rule and is suf.ciently strong to support the \nproof of agreement satisfaction. In practice, the accuracy of our method depends on determining which \nlocks and relations be\u00adtween thread variables are held at each program location within the threads {2,... \nN}. This information can be represented as arith\u00admetic program invariants and can thus be computed using \nexisting analysis tools for sequential programs(i.e. [23, 37]) or by adding additional predicates over \nthe lock variables before applying the property-driven safety checker.We assume that all threads in the \nprogram respect locking discipline DA and DB. That is: our algo\u00adrithm never checks that the the lock-discipline \nis respected, though this can be easily assured via a static check that threads only use lock and unlock \nto modify the values of lock variables. THEOREM 2. If the program Qi satis.es its assertions then the \nthread Ti respects agreement A, i.e., the condition2in the proof rule holds for the thread Ti. Weakening. \nIf the agreement A is not a sound overapproxima\u00adtion of the environment threads then there will exist \na thread Ti, where i .{2,..., N}, such that an assert statement in the cor\u00adresponding sequential program \nQi fails. Let k be the location of this assert in the body of Qi. Also assume that A = A ' . ., and that \nthe conjunct . causes the assertion failure at the location k. In this case we weaken the agreement by \nreplacing . in A with . . lck =1 if we can prove that pc = k . lck = i is a thread\u00adlocal invariant of \nthe thread Ti for some lockvariable lck . Locks. If we cannot .nd such a lock, we report a case of potential \nthread\u00adnontermination together with the last counterexample pc examined. We observe that such weakening \nalgorithm preserves the progresspropertyoftheoverall method, i.e. that no counterexample is discovered \nmore than once. The strengthening phase eliminates the counterexampleby restricting the agreement.If \nanyweakening takes place, then it does not undo the strengthening since it is only applied when the thread \nholds a lock.   6.1 Example Consider T3 from Figure 2, and the agreement A =[l =1 . x ' = x].We show \nhow our method checks that the thread T3 respects the agreement A on example of the statement x=nondet();. \nThe transformation AgChk(T3, A) produces the following code fragment for the statement above. lck = nondet(); \nx = nondet(); assume(!(lck==0 &#38;&#38; lck !=0) || lck != 3); assume(lck!=3 || lck =3); lck = lck ; \nx = x ; x = x; lck = lck; x = nondet(); assert( lck!=1 || x <= x ); By applying a program analysis on \nthe sequential program AgChk(T3, A), we can check that the assertion holds. The proof relies on the discoveryof \nthefact that lck =3 when the assertion is checked. 7. Experimental results In order to evaluate the effectiveness \nof our thread-termination al\u00adgorithm, we have constructed a preliminary implementation and applied it \nto the problem of proving thread-termination of dispatch routines fromWindows device drivers.We found \nthat the transla\u00adtion implementing SeqComp(T1, A) produces programs that are unnaturally dif.cult for \ntermination provers based on [21]. The ter\u00admination proof techniques described in [4], however, are largely \nunaffected by the translation. The technique from [4], however, does not produce counterexamples, whereas \n[21] does. Thus, dur\u00ading these experiments we used an implementation of a sequential termination prover \nthat combined the techniques from [4] and [21]. As describedin[5], terminationproofsfor some1loopsinWin\u00addows \ndevice drivers require an analysis that is capable of reason\u00ading about the lengths of linked data-structures.Following \n[8], we have added integer length-variables to our model of queues and other data-structures accessedbykernel-levelAPIsby \nthedevice drivers. TheWindowskernel interlocked dequeue operation, for example, is modelled to atomically \ndecrement a counter stored in 1Perhaps 30% on average. the queue data-structure. Our change was not made \nin code being proved terminating, but rather the model of the operating system that is used in conjunction \nwith the device driver. Note that locks in Windows device drivers are stored in the heap, and not as \nglobal variables. However, in all cases seen in our evaluation, the locks were stored in a single data-structure \ncreated during the driver s startup: thus we modi.ed the device driver code used in our evaluation to \nuse global lock variables. An additional complication is that, in some circumstances,Windows device drivers \nuse locking mechanisms not supported in our current formulation(e.g. mutexes). These cases were were \navoided in our evaluation. Results. SeeTable1for the resultsof ourexperiments. Example 17 includes the \ncode from Figure 1, and Example1 includes the code from Figure8. EachexampleinTable1representsa thread\u00adtermination \nproof for a single loop(i.e. cutpoint in the control-.ow graph) within a dispatch routine. Dispatch routines \nusually contain between 2 to 30 loops each, thus a complete thread-termination proof for a whole dispatch \nroutine will require more processing time (perhaps 2x, 30x, or in some cases more). The device drivers \nrange in sizes from 1,000 to 30,000 lines of code, however the reachable code from a single dispatch \nroutine (device drivers usu\u00adally export up to 10) usually ranges from 300 to 10,000 of lines of code. \nTable 1 demonstrates promise that our algorithm from Fig\u00adure 4 can be made to be practical, automatic, \naccurate and scal\u00adable. The tool is completely automatic. Only two false negatives were reported, both \ndue to inaccuracies in the underlying termina\u00adtion prover s treatment of bitvectors. Furthermore, the \nperformance (while expensive) in many cases is not intractable. Table 1 also demonstrates that, at least \nin this domain, simple agreements suf\u00ad.ce.Weexpectthe sametobe truefor most instancesof industrial software. \nComparison with existing tools. As mentionedin Section1, until now no known termination prover has natively \nsupported thread termination. Before now the sound option available was to apply a sequential termination \nprover on a program that represents an encoding of all of the interleavings of T1 to TN. In order to \ncompare against our new algorithm we have tried this for the .rst three examples fromTable1:all three \ncases resultedina timeout after 3hours usingTERMINATOR. The other potential competitor to our technique \nis simply to run a sequential termination prover on the single thread in question, thussimply ignoringthe \nunsoundness(duetobugsthatcanonlybe found in the concurrent setting). During the analysis that produced \nTable1we found3previously unknownbugs (Examples1,5, and 19). The bugs in Examples 1 and 19 indeed require \nsupport for concurrencyin order to be found, meaning that in principle no other known program termination \nprover would be able to .nd these bugs. This assertion was veri.ed experimentally for at least one sequential \ntermination prover(i.e. TERMINATOR) meaning that we appliedTERMINATOR to the individual threads withbugs \nfrom Examples1and 19 and found that the sequential tool reported an unsound resultduetothefactthatitwas \nignoringthe interleavings with the environment. As A = true in Example 5, however, this bug can be found \nsimply with a sequential termination prover. Notes on the bug from Example 1 of Table 1 (Figure 8). Figure8 \nshows the loop from the .rstexampleinTable1. Thisis not all of the code used in the example, just the \nbody of the loop. All of the code reachable from this loop was considered during the thread\u00adtermination \nproof together with all of the code from all of the other threads that could be executing concurrently \nwith it. This example comes from the I/O control dispatch routine of a modem driver. Duringtheexecutionofthis \ndispatch routine,thecodeinthe read-Table 1. Results of experimental evaluation on device drivers. Each \nexample represents a single loop in a dispatch routine for a device driver. Strengthenings indicates \nhow many times the strengthening procedure was called, and Weakenings how many times the weakening procedure \nwas invoked from the checking procedure. T/O indicates timeout. The timeout threshold was set to3hours(= \n10800s). CEX indicatesabug found, False representsafalsebug found, and Pass represents the case where \na termination proof is found. Example Time Result Strengthenings Weakenings 1 6192s CEX 1 1 2 3235s Pass \n1 1 3 1366s Pass 0 0 4 T/O - - - 5 932s CEX 0 0 6 833s Pass 1 0 7 145s False 0 0 8 T/O - - - 9 2116s \nFalse 0 0 10 T/O - - - 11 521s Pass 0 0 12 4799s Pass 1 1 13 167s Pass 0 0 14 T/O - - - 15 6733s Pass \n2 2 16 99s Pass 1 1 17 339s Pass 1 1 18 8831s Pass 2 1 19 1955s CEX 1 1 20 4224s Pass 1 1 21 54s Pass \n0 0 22 28s Pass 0 0 23 T/O - - - 24 139s Pass 1 1 25 344s Pass 0 0 request dispatch routine (not displayed) \ncould be executed many times concurrently. This read-request dispatch routine can, in cases, add elements \nto the queue that is being emptied in Figure 8. Thus, if an ongoing supply of read-requests arrive concurrently \nduring the execution of the loop in Figure 8, the thread executing the I/O control dispatch routine may \nnot terminate. The dif.culty in this code is that the spinlock &#38;devExt->SpinLock is released and \nre-acquired within the loop that is draining the list of request packets. The motivation for releasing \nthe lock is due to the performance cost of the procedure that removes and completes the I/O request packets \n(IRPs) in the queue: the programmer has decided that it is too expensive to call this operation while \nholding the lock.A.x is to create a new list, remove the elements from ReadQueue, place them into the \nnew list, release the lock, and then remove and complete each request from the new queue. Examples 2 \nand 3 fromTable1represent the two loops from this proposed .x. 8. Future work Wenowrefer to the current \nlimitations of the proposed method that might be interesting to address in future work. Supporting general \nliveness. In this paper we haverestricted our\u00adselves to termination only, and excluded arbitrary liveness \nprop\u00aderties [1](i.e. fair termination) from consideration. However, it is likely that recentwork on provingfair \ntermination for sequential programs[20] canbeadaptedtothe settingof thread-modularlive\u00adness checking. \nwhile (!IsListEmpty(&#38;devExt->ReadQueue)) { PLIST_ENTRY ListElement; KIRQL CancelIrql; ListElement=RemoveHeadList( \n &#38;devExt->ReadQueue ); Irp=CONTAINING_RECORD(ListElement,IRP, Tail.Overlay.ListEntry); IoAcquireCancelSpinLock(&#38;CancelIrql); \n if (Irp->Cancel) { // this one has been canceled Irp->IoStatus.Information=STATUS_CANCELLED; IoReleaseCancelSpinLock(CancelIrql); \ncontinue; } IoSetCancelRoutine( Irp, NULL); IoReleaseCancelSpinLock(CancelIrql); KeReleaseSpinLock( &#38;devExt->SpinLock \n , OldIrql); Irp->IoStatus.Information=0; RemoveReferenceAndCompleteRequest( devExt->DeviceObject, Irp, \nSTATUS_CANCELLED); KeAcquireSpinLock( &#38;devExt->SpinLock , &#38;OldIrql); } Figure 8. Fragmentof Example1fromTable1(a \nmodemdevice driver) containinga concurrency/terminationbug. Unbounded threads, thread creation, thread \ndestruction, etc. We have made the simplifying assumption that the set of threads in P is .xed. In principle \nour tool could be adapted to support an unbounded number of threads in the environment so long as they \nare drawn from a .nite amount of code. Synchronization primitives. For simplicity we have ignored sev\u00aderal \nformsof synchronization(e.g. mutexes). In practice, however, these mechanisms are used in real programs \nand should be sup\u00adported by our tool. Stronger proof rule, stronger environment checking. Note that, \nwhen checking that Ti respects A, we assume nothing of the envi\u00adronment that Ti executes in.Techniquesexist \nto support this sce\u00adnario(e.g. [33] and [35]), and could potentially be adapted to our setting. Memory \nmodels. For simplicity we havelargely ignored the com\u00adplicationsdueto non-atomic reads/writesto sharedvariables.Asan \nexample, our current setupwouldfailtoprovethe terminationof T1 from Figure2ifthecallto InterlockedDecrement(&#38;x) \nwere replaced with the assignment x=x-1, even though the pro\u00adgram still does guarantee termination. 9. \nConclusion Concurrent programs are often designed such that the execution of certain subroutines(i.e. \ndevice driver dispatch routines) within threads will not diverge.We call this property thread-termination. \nWe have described the .rst known program termination prover that natively supports proofs of thread-termination. \nWhen proving that the thread T1 terminates, our prover attempts to .nd an abstract model of the environment \nthat overapproximates the behavior of the other threads T2, T3, etc. This model allows us to perform \nthe analysis thread-locally we only consider each thread in isolation together with the environment abstraction. \nThe novelty of the work presented here is the method of strengthening the environment abstraction: it \nis incrementally com\u00adputedusing informationminedfromtheexaminationofpathsinthe thread. Thekeyidea is \nthat we can take paths from the concurrent setting and prove them well-founded in the sequential setting. \nThe witnesses to these proofs can lead to stronger environment abstrac\u00adtions. Wehavedemonstratedthe practicalityofthe \napproachbyimple\u00admenting a tool and performing experiments with it on loops from device drivers. Thisevaluation \nrepresents the .rst knownsuccessful application of a termination prover for concurrent programs to in\u00addustrial \nsoftware. During the evaluation a number of driver loops were proved terminating, and several previously \nunknown bugs were also found. Acknowledgments We thank Josh Berdine, Georges Gonthier, Peter O Hearn, \nand ViktorVafeiadis for comments andsuggestions. The third author is supported in part by Microsoft Research \nthrough the European Fellowship Programme. References [1]B.AlpernandF. Schneider. De.ningliveness. Information \nprocessing letters, 21:181 185, 1985. [2] I. Balaban, A. Cohen, and A. Pnueli. Ranking abstraction of \nrecursive programs. In VMCAI 06:Veri.cation, Model Checking, and Abstract Interpretation, 2006. [3] T. \nBall et al. Thorough static analysis of device drivers. In EuroSys 06: European Systems Conference, 2006. \n [4] J. Berdine, A. Chawdhary, B. Cook, D. Distefano, andP. O Hearn. Variance analyses from invariance \nanalyses. InPOPL 07: Principles of Programming Languages, 2007. [5] J. Berdine, B. Cook, D. Distefano, \nand P. O Hearn. Automatic termination proofs for programs with shape-shifting heaps. In CAV 06: International \nConference on Computer AidedVeri.cation, 2006. [6] A. Biere, C. Artho, andV. Schuppan. Liveness checking \nas safety checking. In FMICS 02: Formal Methods for Industrial Critical Systems, 2002. [7] B. Blanchet,P. \nCousot, R. Cousot, J. Feret, L. Mauborgne, A. Min\u00b4e, D. Monniaux, and X. Rival. A static analyzer for \nlarge safety\u00adcritical software. In PLDI 03: Programming Language Design and Implementation, 2003. [8] \nA. Bouajjani, M. Bozga, P. Habermehl, R. Iosif, P. Moro, and T.Vojnar. Programs with lists are counter \nautomata. In CAV 06: International Conference on Computer AidedVeri.cation, 2006. [9] A. Bradley, Z. \nManna, and H. Sipma. Linear ranking with reachability. In CAV 05: Computer-AidedVeri.cation, 2005. [10] \nA. Bradley, Z. Manna, and H. Sipma. The polyranking principle. In ICALP 05: International Colloquium \nonAutomata, Languages and Programming, 2005. [11] A. Bradley, Z. Manna, and H. Sipma. Termination analysis \nof integer linear loops. In CONCUR 05: Concurrency Theory, 2005. [12] A. Bradley, Z. Manna, and H. Sipma. \nTermination of polynomial programs. In VMCAI 05:Veri.cation, Model Checking, and Abstract Interpretation, \n2005. [13] S. Chaki, E. M. Clarke, J. Ouaknine, N. Sharygia, and N. Sinha. Ef.cient veri.cation of sequential \nand concurrent C programs. Formal Methods in System Design, 25(2-3):129 166, 2004. [14] E. Clarke, O.Grumberg, \nand D. Peled. Model Checking. MIT Press, 2000. [15] E. M. Clarke, M.Talupur, and H.Veith. Environment \nabstraction for parameterized veri.cation. In VMCAI 06:Veri.cation, Model Checking, and Abstract Interpretation, \n2006. [16]J.M. Cobleigh,D. Giannakopoulou,andC.S.Pasareanu. Learning assumptions for compositionalveri.cation. \nIn TACAS 04:Tools and Algorithms for the Construction and Analysis of Systems, 2003. [17] M. Codish and \nC. Taboch. A semantic basis for the termination analysis of logic programs. The Journal of Logic Programming, \n41(1):103 123, 1999. [18]M. Col\u00b4on and H. Sipma. Practical methods for proving program termination. In \nCAV 02: Computer AidedVeri.cation, 2002. [19] E. Contejean, C. March\u00b4e, B. Monate, and X. Urbain. Proving \nTermination of Rewriting with CiME. In WST 03: International Workshop onTermination, 2003. [20] B. Cook, \nA. Gotsman, A. Podelski, A. Rybalchenko, and M.Vardi. Proving that software eventually does something \ngood. In POPL 07: Principles of Programming Languages, 2007. [21] B. Cook, A. Podelski, and A. Rybalchenko. \nTermination proofs for systems code. In PLDI 06: Programming Language Design and Implementation, 2006. \n[22]P. Cousot. Proving programinvarianceand terminationby parametric abstraction, lagrangian relaxation \nand semide.nite programming. In VMCAI 05:Veri.cation, Model Checking, and Abstract Interpreta\u00adtion, 2005. \n[23] P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of a program. \nIn POPL 78: Principles of Programming Languages, 1978. [24] C. Flanagan, S. N. Freund, S. Qadeer, and \nS. A. Seshia. Modular veri.cation of multithreaded programs. Journal on Theoretical Computer Science, \n338(1 3):153 183, 2005. [25]C. Flanagan andP. Godefroid. Dynamic partial-order reduction for model checking \nsoftware. In POPL 05: Principles of Programming Languages, 2005. [26] C. Flanagan and S. Qadeer. Thread-modular \nmodel checking. In SPIN 03, 2003. [27]P. Godefroid.Partial-order methods for theveri.cationof concurrent \nsystems an approach to the state-explosion problem. PhD thesis, 1994. [28] K. Havelund andT. Pressburger. \nModel checking Java programs using JavaPathFinder. InternationalJournal on SoftwareTools for TechnologyTransfer, \n2(4), 1998. [29] T. A. Henzinger, R. Jhala, and R. Majumdar. Permissive interfaces. In FSE 05, 2005. \n[30] T. A. Henzinger, R. Jhala, R. Majumdar, and S. Qadeer. Thread\u00admodular abstraction re.nement. In \nCAV 03, 2003. [31] G. J. Holzmann. The model checker SPIN. IEEETransactions on Software Engineering, \n23(5):279 295, 1997. [32] B. Jacobs, K. R. M. Leino, F. Piessens, and W. Schulte. Safe concurrency for \naggregate objects with invariants. In SEFM 05: Software Engineering andFormal Methods, 2005. [33] C. \nJones. Speci.cation and design of (parallel) programs. In IFIP Congress, 1983. [34] V. Kahlon, A. Gupta, \nand N. Sinha. Symbolic model checking of concurrent programs using partial orders and on-the-.y transactions. \nIn CAV 06: International Conference on Computer AidedVeri.cation, 2006. [35] R. J. Lipton. Reduction: \na method of proving properties of parallel programs. Communicationsof theACM, 18(12):717 721, 1975. [36] \nZ. Manna and A. Pnueli. Axiomatic approach to total correctness of programs. Acta Informatica, 1974. \n[37] A. Min\u00b4 e. The octagon abstract domain. Higher-Order and Symbolic Computation, 19:31 100, 2006. \n[38] A. Podelski and A. Rybalchenko. A complete method for the synthesis oflinear ranking functions. \nIn VMCAI 04:Veri.cation, Model Checking, and Abstract Interpretation, 2004. [39] J. C. Reynolds. The \nCraft of Programming. London, 1981. [40]A.Tiwari. Terminationof linear programs. In CAV 04: Computer \nAidedVeri.cation, 2004.  \n\t\t\t", "proc_id": "1250734", "abstract": "<p>Concurrent programs are often designed such that certain functions executing within critical threads must terminate. Examples of such cases can be found in operating systems, web servers, e-mail clients, etc. Unfortunately, no known automatic program termination prover supports a practical method of proving the termination of threads. In this paper we describe such a procedure. The procedure's scalability is achieved through the use of environment models that abstract away the surrounding threads. The procedure's accuracy is due to a novel method of incrementally constructing environment abstractions. Our method finds the conditions that a thread requires of its environment in order to establish termination by looking at the conditions necessary to prove that certain paths through the thread represent well-founded relations if executed <i>in isolation of the other threads</i>. The paper gives a description of experimental results using an implementation of our procedureon Windows device drivers and adescription of a previously unknown bug found withthe tool.</p>", "authors": [{"name": "Byron Cook", "author_profile_id": "81323489213", "affiliation": "Microsoft Research, Cambridge, Great Britain", "person_id": "PP40034081", "email_address": "", "orcid_id": ""}, {"name": "Andreas Podelski", "author_profile_id": "81100130920", "affiliation": "University of Freiburg, Freiburg, Germany", "person_id": "PP39028940", "email_address": "", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "EPFL and MPI, Lausanne, Switzerland", "person_id": "P688961", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1250734.1250771", "year": "2007", "article_id": "1250771", "conference": "PLDI", "title": "Proving thread termination", "url": "http://dl.acm.org/citation.cfm?id=1250771"}