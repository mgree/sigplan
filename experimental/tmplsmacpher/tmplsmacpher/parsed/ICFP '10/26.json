{"article_publication_date": "09-27-2010", "fulltext": "\n A Certi.ed Frameworkfor Compiling and Executing Garbage-collected Languages Andrew McCreight Tim Chevalier \nAndrewTolmach Portland State University {mccreigh,tjc,apt}@cs.pdx.edu Abstract We describe the design, \nimplementation, and use of a machine\u00adcerti.ed framework for correct compilation and execution of pro\u00adgrams \nin garbage-collected languages. Our framework extends Leroy sCoq-certi.ed Compcert compiler and Cminor \nintermediate language.Weadd:(i)anewintermediate language, GCminor,that includes primitives for allocating \nmemory in a garbage-collected heapandfor specifyingGC roots;(ii)aprecise,low-level speci.ca\u00adtion fora \nCminor library forgarbage collection; and (iii)a proven semantics-preserving translation from GCminor \nto Cminor plus the GC library. GCminor neatly encapsulates the interface between mutator and collector \ncode, while remaining simple and .exible enough to be used with a wide variety of source languages and \ncollector styles. Front ends targeting GCminor can be implemented using any compiler technology and any \ndesired degree of veri.\u00adcation, including full semantics preservation, type preservation, or informal \ntrust. As an example application of our framework, we describe a compiler for Haskell that translates \nthe Glasgow Haskell Com\u00adpiler sCore intermediatelanguageto GCminor.Tosupportasimple but useful memory \nsafety argument for this compiler, the front end uses a novel combination of type preservation and runtime \nchecks, which is of independent interest. Categories and Subject Descriptors D.3.4[Processors]: Com\u00adpilers, \nMemory management (garbage collection); D.2.4[Soft\u00adware/ProgramVeri.cation]: Correctness proofs GeneralTerms \nLanguages,Veri.cation, Reliability, Security. 1. Introduction Programming in high-level, type-safe languages \nsuch as Haskell, ML, or Java eliminates large classes of potential bugs, thus in\u00adcreasing reliability \nwhile reducing implementation time and cost in many application domains. Safe languages should be particularly \nattractive for implementing systems that demand the highest pos\u00adsible levels of assurance, such as safety-critical \ndevice control or high-security data processing, which are currently very expensive to produce. But the \nappeal of these languages for high-assurance applicationsis undercutbytheir relianceonlarge, complexruntime \nsystems, usually writteninC or assembler.Forexample, the run\u00adtime system of the Glasgow Haskell Compiler \n(GHC) [31] consists of roughly 75,000 linesofCcode. Such systems areverydif.cult to verify, even informally. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright c &#38;#169; 2010ACM 978-1-60558-794-3/10/09... \n$10.00 Garbage collection (GC)isakeyruntime service thatis oftena source ofbugs. GCbugs can result from \nerroneous algorithms or incorrect collector implementations, or because the intended inter\u00adface between \nthe collector and themutator the application code that makes allocation requests and performs reads and \nwrites on theheap hasbeen violated.Moreover,GCbugsareoftendif.cult to reproduce and diagnose. Garbage \ncollection is therefore a good application area for formal methods, including machine-certi.ed correctness \nproofs, and several proofs of collector implementations have been developed in recent years [14, 22, \n24, 36]. Bugs often occur because the collector-mutator interface has not beenexplicitly speci.ed,makingiteasyfor \nimplementerson either sideto violate intendedinvariants. Precisegarbage collectors must be able to access \nall roots,i.e., pointers from mutator data structures into the heap, and to ascertain the layout, i.e., \nsize and embedded pointer positions, for all heap records. The collector proofs cited above formalize \nthe interface as seen from the collector s side. But there has been much less work on ensuring that the \nmutator obeys its side of the interface. In this work, we show how to encapsulate the key aspects of \nthe collector-mutator interface into the semantics of a generic intermediate language, called GCminor,that \ncan serveas the target for compilinga rangeofgarbage-collected languages, and as the source for a machine-certi.ed \nsemantics-preserving compiler back end. GCminor makes the collector-mutator interface both explicit and \nprecise.A client, i.e., a compiler front end, can use the back end simply by generating code in GCminor \nand record layout descriptions in a format that GCminor can accept. GCminor supports many styles of uniprocessor \nmemory man\u00adagers, including mark-sweep, copying, and generational collectors. Any real collector implementation \nwill modify the heap and pos\u00adsibly the values of root variables. However, GCminor s semantics completelyhidetheseeffects:fromthe \nperspectiveofmutatorcode, the heap and reachable pointers do not appear to change at all dur\u00ading a collection. \nThis property makes it much easier to verify that the mutatorcodeobeystheGC interface.Weenforce correctnessof \nroot declarations using a block-based memory model together with a novel pointer-clearing technique at \nthe semantic level. Our work extends Leroy s Compcert compiler and Cminor in\u00adtermediate language [16, \n18]. Compcert compiles (most of)C to PowerPC or ARM assembly code, and is proven to preservethe ob\u00adservable \nbehavior of the program: its sequence of system calls and .nal return value. The proof is certi.ed using \nthe Coq Proof Assis\u00adtant [2]. Cminor is an untyped, low-level imperative intermediate language with C-like \ncontrol constructs, which sits between Comp\u00adcert s C-speci.c front end and its processor-speci.c back \nend. It supports global and local memory,but nota heap. We de.ne GCminor as a small extension to Cminor \nthat adds statements for allocating in a garbage-collected heap and decla\u00adrations for specifying heap \nroots. We implement new Compcert pipeline stages to translate GCminor programs into ordinary Cmi\u00adnor \ncode, intended to be linked against a memory management li\u00adbraryalso writtenin Cminor.Theexisting Compcertbackend \ncom\u00ad \n\t\t\t", "proc_id": "1863543", "abstract": "<p>We describe the design, implementation, and use of a machine-certified framework for correct compilation and execution of programs in garbage-collected languages. Our framework extends Leroy's Coq-certified Compcert compiler and Cminor intermediate language. We add: (i) a new intermediate language, GCminor, that includes primitives for allocating memory in a garbage-collected heap and for specifying GC roots; (ii) a precise, low-level specification for a Cminor library for garbage collection; and (iii) a proven semantics-preserving translation from GCminor to Cminor plus the GC library. GCminor neatly encapsulates the interface between mutator and collector code, while remaining simple and flexible enough to be used with a wide variety of source languages and collector styles. Front ends targeting GCminor can be implemented using any compiler technology and any desired degree of verification, including full semantics preservation, type preservation, or informal trust.</p> <p>As an example application of our framework, we describe a compiler for Haskell that translates the Glasgow Haskell Compiler's Core intermediate language to GCminor. To support a simple but useful memory safety argument for this compiler, the front end uses a novel combination of type preservation and runtime checks, which is of independent interest.</p>", "authors": [{"name": "Andrew McCreight", "author_profile_id": "81331498902", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2338218", "email_address": "", "orcid_id": ""}, {"name": "Tim Chevalier", "author_profile_id": "81470652567", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2338219", "email_address": "", "orcid_id": ""}, {"name": "Andrew Tolmach", "author_profile_id": "81100247872", "affiliation": "Portland State University, Portland, OR, USA", "person_id": "P2338220", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863584", "year": "2010", "article_id": "1863584", "conference": "ICFP", "title": "A certified framework for compiling and executing garbage-collected languages", "url": "http://dl.acm.org/citation.cfm?id=1863584"}