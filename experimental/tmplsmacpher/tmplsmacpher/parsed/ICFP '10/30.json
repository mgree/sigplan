{"article_publication_date": "09-27-2010", "fulltext": "\n Program Veri.cation Through Characteristic Formulae Arthur Chargu\u00b4 eraud INRIA arthur.chargueraud@inria.fr \nAbstract This paper describes CFML, the .rst program veri.cation tool based on characteristic formulae. \nGiven the source code of a pure Caml program, this tool generates a logical formula that implies any \nvalid post-condition for that program. One can then prove that the program satis.es a given speci.cation \nby reasoning interac\u00ad tively about the characteristic formula using a proof assistant such .x. .P. . \n...... (x =0 . P 0) . (x . =0 . (x =1 . False) . (x . =1 . .P . . (AppReturns half (x - 2) P .) as Coq. \nOur characteristic formulae improve over Honda et al s . (.y. (P . y) . P (y + 1)) )) total characteristic \nassertion pairs in that they are expressible in standard higher-order logic, allowing to exploit them \nin practice to . AppReturns half xP When x is equal to zero, the function half returns zero. So, verify \nprograms using existing proof assistants. Our technique has if we want to show that half returns a value \nsatisfying P , we been applied to formally verify more than half of the content of have to prove P 0 \n. When x is equal to one, the function half Okasaki s Purely Functional Data Structures reference book. \n crashes, so we cannot prove that it returns any value. The only way to proceed is to show that the instruction \nfail cannot be reached. Categories and Subject Descriptors D.2.4 [Software/Program Veri.cation]: Formal \nmethods General Terms Veri.cation Hence the proof obligation False. Otherwise, we want to prove that \nlet y = half (x - 2) in y +1 returns a value satisfying P . To that end, we need to exhibit a post-condition \nP . such that the recursive call to half on the argument x - 2 returns a value satisfying P . . 1. Overview \n Then, for any name y that stands for the result of this recursive 1.1 Introduction to characteristic \nformulae This paper describes an effective technique to formally specify and verify the source code of \nan existing purely functional program. The key idea is to generate, in a systematic manner, a logical \nformula for each top-level de.nition from the source program. Those formulae, expressed solely with standard \nhigher-order logic connectives, carry a precise account of what the program does. Veri.cation of the \nprogram can then be conducted by reasoning on its characteristic formula using an off-the-shelf proof \nassistant. For the sake of example, consider the following recursive func\u00adtion, which divides by two \nany non-negative even integer. let rec half x = if x =0 then 0 else if x =1 then fail else let y = half \n(x - 2) in y +1 The corresponding characteristic formula appears next. Given an argument x and a post-condition \nP , the characteristic formula for half describes what needs to be proved in order to establish that \nthe application of half to x terminates and returns a value satisfying the predicate P , written AppReturns \nhalf xP . Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright c . 2010 ACM 978-1-60558-794-3/10/09. \n. . $10.00 call, assuming that y satis.es P ., we have to show that the output value y +1 satis.es the \npost-condition P . More generally, the characteristic formula .t. associated with a term t can be used \nto prove that this term returns a value satisfying a particular post-condition. For any post-condition \nP , the term t terminates and returns a value satisfying P if and only if the proposition .t. P is true. \nThe application .t. P is a standard higher-order logic proposition that can be proved using an off-the\u00adshelf \nproof assistant. Thus, characteristic formulae can be used in practice to verify that a program satis.es \nits speci.cation. For program veri.cation to be realistic, the proof obligation .t. P should be easy \nto read and manipulate. Fortunately, our characteristic formulae can be pretty-printed in a way that \nclosely resemble source code. For example, the characteristic formula as\u00adsociated with half is displayed \nas follows. LET half := Fun x .. If x =0 Then Return 0 Else If x =1 Then Fail Else Let y := App half \n(x - 2) In Return (y + 1) At .rst sight, it might appear that the characteristic formula is merely a \nrephrasing of the source code in some other syntax. To some extend, this is true. A characteristic formula \nis a sound and complete description of the behaviour of a program. Thus, it car\u00adries no more and no less \ninformation than the source code of the program itself. However, characteristic formulae enable us to \nmove away from program syntax and conduct program veri.cation en\u00adtirely at the logical level. Characteristic \nformulae thereby avoid all the technical dif.culties associated with manipulation of program syntax and \nmake it possible to work directly in terms of higher\u00adorder logic values and formulae.  1.2 Speci.cation \nand veri.cation One of the key ingredient involved in characteristic formulae is the predicate AppReturns, \nwhich is used to specify functions. Because of the mismatch between program functions, which may fail \nor diverge, and logical functions, which must always be total, we cannot represent program function using \nlogical functions. For this reason, we introduce an abstract type, named Func, which we use to represent \nprogram functions. Values of type Func are exclusively speci.ed in terms of the predicate AppReturns. \nThe proposition AppReturns f xP states that the application of the function f to an argument x terminates \nand returns a value satisfying P . Hence the type of AppReturns, shown below. AppReturns : .A B. Func \n. A . (B . Prop) . Prop Remark: an OCaml function f of type A . B is described in Coq at the type Func, \nregardless of what A and B might be. This is not a problem because propositions of the form AppReturns \nf xP can only be derived when x has type A and P has type B . Prop. The predicate AppReturns is used \nnot only in the de.nition of characteristic formulae but also in the statement of speci.cations. One \npossible speci.cation for half is the following: if x is the double of some non-negative integer n, then \nthe application of half to x returns an integer equal to n. The corresponding higher-order logic statement \nappears next. .x. .n. n = 0 . x =2 * n . AppReturns half x (= n) Remark: the post-condition (= n) is \na partial application of equal\u00adity: it is short for .a. (a = n) . Here, the value n corresponds to a \nghost variable: it appears in the speci.cation of the function but not in its source code. The speci.cation \nthat we have considered for half might not be the simplest one, however it illustrates our treatment \nof ghost variables. Our next step is to prove that the function half satis.es its spec\u00adi.cation using \nits characteristic formula. We .rst give the mathe\u00admatical presentation of the proof and then show the \ncorresponding Coq proof script. The speci.cation is to proved by induction on x. Let x and n be such \nthat n = 0 and x =2*n. We apply the charac\u00adteristic formula to prove AppReturns half x (= n) . If x is \nequal to 0, we conclude by showing that n is equal to 0. If x is equal to 1, we show that x =2 *n is \nabsurd. Otherwise, x = 2. We instantiate P . as = n - 1 , and prove AppReturns half (x - 2) P . using \nthe induction hypothesis. Finally, we show that, for any y such that y = n - 1, the proposition y +1 \n= n holds. This completes the proof. Note that, through this proof by induction, we have proved that \nthe function half terminates on its domain. Formalizing the above piece of reasoning in a proof assistant \nis straightforward. In Coq, a proof script takes the form of a se\u00adquence of tactics, each tactic being \nused to make some progress in the proof. The veri.cation of the function half could be done using only \nbuilt-in Coq tactics. Yet, for the sake of conciseness, we rely on a few specialized tactics to factor \nout repeated proof patterns. For example, each time we reason on a if statement, we want to split the \nconjunction at the head of the goal and introduce one hy\u00adpothesis in each subgoal. The tactics speci.c \nto our framework can be easily recognized: they start with the letter x . The veri.cation proof script \nfor half appears next. xinduction (downto 0). xcf. introv IH Pos Eq. xret. auto. xfail. auto. xlet. xapp \n(n-1); auto. xret. auto. xcase. (* (* (* (* (* x = 0 *) x = 1 *) otherwise *) half (x-2) return y+1 *) \n*)  The interesting steps in that proof are: the setting up of the induction on the set of non-negative \nintegers (xinduction), the application of the characteristic formula (xcf), the case analysis on the \nvalue of x (xcase), and the instantiation of the ghost variable n with the value n - 1 when reasoning \non the recursive call to half (xapp). The tactic auto runs a goal-directed proof search and may also \nrely on a decision procedure for linear arithmetic. The tactic introv is used to assign names to hypotheses. \nSuch explicit naming is not mandatory, but in general it greatly improves readability of proof obligations \nand robustness of proof scripts. When working with characteristic formulae, proof obligations always \nremain very tidy. The Coq goal obtained when reaching the subterm let y = half (x - 2) in y +1 is shown \nbelow. In the conclusion (stated below the line), the characteristic formula associated with that subterm \nis applied to the post-condition to be established (= n). The context contains the two pre-conditions \nn = 0 and x =2 * n, the negation of the conditionals that have been tested, x .. =0 and x =1, as well \nas the induction hypothesis, which asserts that the speci.cation that we are trying to prove for half \nalready holds for any non-negative argument x . smaller than x. x : int IH :forallx ,0<=x ->x <x-> foralln, \nn>=0->x =2*n-> AppReturns half x (= n)  n : int Pos: n>=0 Eq : x = 2 * n C1:x<> 0 C2:x<> 1  (Let y \n:= App half (x-2) in Return (1+y)) (= n) As illustrated through the example, a veri.cation proof script \ntypically interleaves applications of x -tactics with pieces of gen\u00aderal Coq reasoning. In order to obtain \nshorter proof scripts, we set up an additional tactic that automates the invokation of x-tactics. This \ntactic, named xgo, simply looks at the head of the character\u00adistic formula and applies the appropriate \nx-tactic. A single call to xgo may analyse an entire characteristic formula and leave a set of proof \nobligations, in a similar fashion as a Veri.cation Condition Generator (VCG). Of course, there are pieces \nof information that xgo cannot infer. Typically, the speci.cation of local functions must be provided \nexplicitly. Also, the instantiation of ghost variables cannot always be inferred. In our example, Coq \nautomation is slightly too weak to infer that the ghost variable n should be instantiated as n - 1 in \nthe recursive call to half. In practice, xgo will stop running whenever it lacks too much information \nto go on. The user may also explicitly tell xgo to stop at a given point in the code. Moreover, xgo accepts \nhints to be exploited when some information cannot be inferred. For example, we can run xgo with the \nindication that the function application whose result is named y should use the value n - 1 to instantiate \na ghost variable. In this case, the veri.cation proof script for the function half is reduced to: xinduction \n(downto 0). xcf. intros. xgo~ y (Xargs (n-1)). Note that automation, denoted by the tilde symbol, is \nable to handle all the subgoals produced by xgo. For simple functions like half, a single call to xgo \nis usually suf.cient. However, for more complex programs, the ability of xgo to be run only on given \nportions of code is crucial. In particular, it allows one to stop just before a branching point in the \ncode in order to establish facts that are needed in several branches. Indeed, when a piece of reasoning \nneeds to be carried out manually, it is extremely important to avoid duplicating the corresponding proof \nscript across several branches. To summarize, our approach allows for very concise proof scripts whenever \nverifying simple pieces of code, thanks to the automated processing done by xgo and to the good amount \nof au\u00adtomation available through the proof search mechanism and the decision procedures that can be called \nfrom Coq. In the same time, when verifying more complex code, our approach offers a very .ne-grained \ncontrol on the structure of the proofs and it greatly bene.ts from the integration in a proof assistant \nfor proving non\u00adtrivial facts interactively.  1.3 Implementation Our implementation is named CFML, an \nacronym for Character\u00adistic Formulae for ML. It parses an OCaml source code and nor\u00admalizes its syntax, \nmaking sure that applications and function def\u00adinitions be bound to a name. Our tool then type-checks \nthe code and produces a set of Coq de.nitions. For each type de.nition in the source program, it generates \nthe corresponding de.nition in the logic. For each top-level value de.nition, it introduces one abstract \nvariable to represent the result of the evaluation of this de.nition, plus one axiom stating the characteristic \nformula associated with the de.nition. For example, for the program let x = let y = 2 in y * y , we generate \na .rst axiom, named x, of type int, and a second axiom with a type of the form .P. [...] . Px . This \ncharacteristic formula for x describes what needs to be proved in order to establish that x satis.es \na given predicate P . We have proved on paper that characteristic formulae are sound with respect to \nthe logic of Coq, by showing that those axioms could be realized in Coq, at least in theory. (In practice, \ngenerating actual proof terms would require a lot of effort, so we have not implemented it.) Moreover, \nin order to preserve soundness, each time we introduce an axiom to represent a value we generate a proof \nthat the type of this value is inhabited. For example, our tool rejects the program de.nition let x = \nfail because the type .A.A cannot be proved to be inhabited. Rejecting this kind of program is not really \na limitation since it would not be possible anyway to prove that such a program returns a value. For \nthe time being, only purely functional programs are sup\u00adported. However, we strongly believe that characteristic \nformulae can be extended with heap descriptions and frame rules, without compromising the possibility \nof pretty-printing characteristic for\u00admulae like source code. We leave the extension to side-effects \nto future work and focus in this paper on demonstrating the bene.ts of characteristic formulae for reasoning \non pure programs. This paper is organized as follows. First, we explain how our approach compares against \nexisting program veri.cation tech\u00adniques (\u00a72). Second, we describe formalizations of purely func\u00adtional \ndata structures (\u00a73). Third, we describe the algorithm for generating characteristic formulae (\u00a74), and \nformally de.ne our speci.cation predicates (\u00a75). Finally, we discuss the soundness and completeness of \ncharacteristic formulae (\u00a76), and conclude (\u00a77). 2. Comparison with related work 2.1 Characteristic \nformulae The notion of characteristic formula originates in process calculi. Given the syntactic de.nition \nof a process, the idea is to generate a temporal logic formula that precisely describes that process \n[12, 17, 23]. In particular, behavioural equivalence or dis-equivalence of two processes can be established \nby comparing their characteristic formulae. Such a proof can be conducted in temporal logic rather than \nthrough reasoning on the syntactic de.nition of the processes. In a similar way, the characteristic formula \nof a program is a logical formula that carries a precise description of this program, without referring \nto its syntactic de.nition. For the sake of reason\u00ading on functional correctness, programs can be studied \nin terms of their most-general speci.cation. The theoretical insight that any program admits a most-general \nHoare triple which entails all other correct speci.cations is nearly as old as Hoare logic. Gorelick \n[9] proved that every program admits a weakest pre-condition (the minimum requirement to ensure safe \ntermination) and a strongest post-condition (the maximal amount of information that can be gathered about \nthe output of the program). The suggestion that most-general speci.cations could be ex\u00adploited to verify \nprograms .rst appears, as far as we know, in recent work by Honda, Berger and Yoshida [10]. The authors \nconsider a particular Hoare logic and exhibit an algorithm for constructing the total characteristic \nassertion pair (TCAP) of a program, which corresponds to most-general Hoare triple. TCAPs offer an alterna\u00adtive \nway of proving that a program satis.es a given speci.cation: rather than building a derivation using \nthe reasoning rules of the Hoare program logic, one may simply prove that the pre-condition of the speci.cation \nimplies the weakest pre-condition and that the post-condition of the speci.cation is implied by the strongest \npost\u00adcondition. The veri.cation of those two implications can be con\u00adducted entirely at the logical level. \nOur work builds upon a similar idea, relying on characteristic formulae to move away from pro\u00adgram syntax \nand carry out the reasoning in the logic. Our main contribution is to express the characteristic formula \nof a program in terms of a standard higher-order logic. By contrast, TCAPs are expressed in an ad-hoc \nlogic. In particular, the values from this logic are well-typed PCF values, including .rst-class functions. \nIt is not immediate to translate this logic into a standard logic, because of this mismatch between program \nfunctions, which may fail or diverge, and logical functions, which must always be total. Due to the nonstandard \nlogic it relies upon, Honda et al s TCAPs cannot be manipulated in an existing theorem prover. In this \nwork, we show how an abstract type Func can be introduced to support the ability to refer to .rst-class \nfunctions from the logic. Our characteristic formulae also improve over TCAPs in that they are human-readable. \nWhile Honda et al s TCAP did not .t on a screen for a program of more than a few lines, we show characteristic \nformulae can be displayed just like source code. The ability to read charactersitic formulae is very \nimportant in interactive proofs since the characteristic formula shows up as part of the proof obligation \nthat the user must discharge. 2.2 Veri.cation Condition Generators Tools such as Spec# [1] for C# programs, \nKrakatoa [14] for Java programs, Caduceus [7] for C programs, Pangolin [24] for pure ML programs, and \nWho [11] for imperative ML programs, are all based on VCGs. They generate a set of proof obligations \nand rely on automated theorem provers to discharge these obligations. In the latter three systems, proof \nobligations that are not veri.ed au\u00adtomatically can be discharged using an interactive proof assistant. \nHowever, in practice, those proof obligations are often large and clumsy, and their proofs are generally \nquite brittle because proof obligations are very sensitive to changes in either the source code or its \ninvariants. In our approach, proof obligations remain tidy and can be easily related to the point of \nthe program they arise from. Moreover, the user has the possibility to invest a little extra effort in \nnaming hypotheses explicitly in order to be able to build very robust proof scripts. The tool Jahob [26], \nwhich supports the veri.cation of linked data structures implemented in a subset of Java, tries to avoid \nas much as possible the need for interactive proofs by annotating pro\u00adgrams not only with their invariants \nbut also with proof hints to guide automated theorem provers. As acknowledged by the au\u00adthors, .nding \nthe appropriate hints can be very time-consuming. In particular, one needs to compute and read the new \nproof obligations after any modi.cation of a hint. Moreover, guessing hints requires a deep understanding \nof the VCG process and of the automated the\u00adorem provers being used. Nevertheless, there are some particular \nsituations where providing such hints is actually very effective. Our approach naturally supports this \nproof technique, simply by giving the appropriate hints as argument to our tactic xgo. We may also set \nup Coq automation to apply a user-de.ned sequence of tactics to any proof obligation satisfying a particular \npattern. Among the tools cited above, few of them support higher-order functions: Pangolin [24] and \nWho [11], which combines ideas from Caduceus [7] and Pangolin [24] to handle effectfull higher\u00adorder \nprograms. One notable difference with our work lies in the way in which functions are lifted to the logical \nlevel. In Pangolin and Who, a function is re.ected in the logic as a pair of a pre\u00adcondition and of a \npost-condition. Instead, we re.ect a function in the logic as a value of the abstract type Func and use \nAppReturns to specify the behaviour of this value. We believe that our approach is more appropriate when \nfunctions are given several speci.cations, when functions are stored in data-structures, and when higher-order \nfunctions are applied to functions speci.ed with ghost variables.  2.3 Shallow embedding techniques \nA radically different approach consists in programming directly within a theorem prover and verifying \nproperties of the code in\u00adteractively inside the same framework. Indeed, the logic of a proof assistant \nsuch as Coq is so rich that it contains a purely functional programming language. An extraction mechanism \ncan then be used to isolate the actual source code from proof-speci.c elements. The shallow embedding \napproach can be applied in two very different styles, depending on how much types are used to enforce \ninvariants. The .rst possibility is to write programs using only basic ML types. This style is employed \nfor instance in Leroy s formally\u00adveri.ed C compiler [13]. While it can be quite effective for some applications, \nthis approach also suffers from a number of severe re\u00adstrictions that restrict its scope of use. In particular, \nall functions must be total and recursive functions must satisfy a syntactical ter\u00admination criteria. \nOn the contrary, characteristic formulae can ac\u00adcommodate various syntaxes for the source language, allowing \nfor the veri.cation of existing programs. In particular, any (well-typed) function de.nition can be handled: \ntermination does not need to be established at de.nition time but can be proved by induction while reasoning \non the characteristic formula (the induction may be on a measure, on a well-founded relation or on any \nCoq predicate). The second possibility is to write programs with more elabo\u00adrated types, relying on dependent \ntypes to carry invariants (e.g. us\u00ading the type list n to describe lists of length n). Programming with \ndependent types has been investigated in particular in Epi\u00adgram [15], Adga [5] and Russell [25]. The \nlatter is an extension to Coq, which behaves as a permissive source language which elab\u00adorates into Coq \nterms. In Russel, establishing invariants, justify\u00ading termination of recursion and proving the inaccessibility \nof cer\u00adtain branches from a pattern matching can be done through interac\u00adtive Coq proofs. While Russel \ncertainly manages to smoothen the writing of dependently-typed terms, the manipulation of dependent types \nremains fairly technical for non-experts. Moreover, the treat\u00adment of ghost variables remains problematic \nin the current imple\u00admentation of Coq because extraction is not suf.ciently .ne-grained to erase all \nghost variables. As a consequence, some ghost variables may remain in the extracted code, leading to \nruntime inef.ciencies and possibly to incorrect asymptotic complexity. Because they rely directly on \nCoq terms, the two shallow embedding approaches describe above cannot support impure programming features \nsuch as side-effects and non-termination. HTT [19], its implementation in Ynot [4] and HTT s new imple\u00admentation \n[20] try to overcome this limitation by extending Coq with a monad in order to support effects. Like \nin Russel, speci.ca\u00adtion appears in types. They typically take the form STsep PQ where P and Q describe \nthe pre-and the post-condition in terms of heap descriptions. Veri.cation proofs are constructed by appli\u00adcation \nof Coq lemmas that correspond to the reasoning rules of the program logic. This process is partially \nautomated through a tactic (which is implemented by re.ection). In our approach, most of this work is \nperformed during the generation of characteristic formu\u00adlae, by our external tool. In the end, although \nthe implementation strategies differ, similar kinds of proof obligations are generated. Note that the \ntrusted base of HTT is not much smaller than ours since HTT also needs to rely on some external tool \nin order to ex\u00adtract OCaml or Haskell code from Coq scripts. Although we do not yet support side effects, \nwe see one main advantage that character\u00adistic formulae may have compared to HTT-based approaches in \nthe long run. Characteristic formulae can be adapted to existing pro\u00adgramming languages. On the contrary, \nfollowing HTT s approach forces one to rewrite programs in terms of the language of Coq and of the constructors \nof HTT s monad. Some programming language features cannot be handled easily by HTT. For example, because \npattern matching is deeply hard-wired in Coq, supporting handy features such as alias-patterns and when-clauses \nwould be a real challenge for HTT. A slightly different approach to shallow embeddings relies on the \nde.nition of a translation from a programming language into higher-order logic. Myreen et al [18] describe \nan effective tech\u00adnique for reasoning on machine code, which consists in decom\u00adpiling machine code procedures \ninto higher-order logic functions. This translation is possible only because the functional translation \nof a while loop is a tail-recursive function, and that nonterminating tail-recursive functions are safely \naccepted as logical de.nitions in HOL4. Lemmas proved interactively about the higher-order logic functions \ncan then be automatically transformed into lemmas about the behaviour of the machine code. While this \napproach works for reasoning on machine code, it does not seem possible to apply it to programs featuring \narbitrary recursion and higher-order functions. 2.4 Deep embedding techniques A fourth approach to reasoning \nformally on programs consists in describing the syntax and the semantics of a programming language in \nthe logic of a proof assistant using inductive de.nitions. In the\u00adory, the deep embedding approach can \nbe applied to any program\u00adming language, it does not suffer from any limitation in terms ex\u00adpressiveness \nand it is compatible with the use of interactive proofs. Mehta and Nipkow [16] have set up a proof of \nconcept of a deep embedding, axiomatizing a small procedural language in Is\u00adabelle, proving Hoare-style \nreasoning rules, and verifying a short program using those reasoning rules. More recently, the frame\u00adworks \nXCAP [21] and SCAP [6] rely on deep embeddings for rea\u00adsoning in Coq about assembly programs. They support \nreasoning on advanced patterns such as strong updates, embedded code point\u00aders and higher-order calls. \nThey have been used to verify short but complex assembly routines, whose proof involves hundreds of lines \nper instruction. Previoulsy, the author of the present paper has in\u00advestigated the use of a deep embedding \nof the pure fragment of OCaml in Coq [2]. Characteristic formulae arose from that work, bringing major \nimprovements. In a deep embedding, reasoning rules of the program logic take the form of lemmas that \nare proved correct with respect to the axiomatized semantics of the source language. When verifying a \nprogram, those reasoning rules are applied almost in a systematic manner, following the syntax of the \nprogram. The idea that the application of those reasoning rules could be anticipated lead to characteristic \nformulae. To illustrate this idea, consider the rule for reasoning on let\u00adexpressions in a deep embedding. \nThe rule reads as follows: to show that let x = t1 in t2 returns a value satisfying P , the subterm \nt1 must be shown to return a value satisfying a post\u00adcondition P ., and the term t2 must be shown to \nreturn a value satisfying P under the assumption that x satis.es P .. The statement of this rule, shown \nbelow, relies on a predicate capturing that a term t returns a value satisfying a post-condition P , \nwritten t .| P . (For the sake of presentation, many technical details are omitted.) t1 .| P . .x. P \n. x . t2 .| P (let x = t1 in t2) .| P With characteristic formulae, the proposition .let x = t1 in t2. \nP captures the fact that let x = t1 in t2 returns a value satisfying P . This proposition is de.ned \nin terms of the characteristic formulae .t1. and .t2. associated with the two subterms t1 and t2. More \nprecisely, .t1. P . asserts that t1 returns a value satisfying P . and .t2. P asserts that t2 returns \na value satisfying P . Formally: .let x = t1 in t2. P = .P. .t1. P ..x.P x . .t2. P Although this equation \nlooks very similar to the reasoning rule, there is one important difference. With the program logic reasoning \nrule, the intermediate speci.cation P . needs to be provided at the time of applying the rule. On the \ncontrary, characteristic formulae are able to anticipate the application of the reasoning rule even without \nany knowledge of this intermediate speci.cation, thanks to the existential quanti.cation on P .. While \nit may appear to be fairly natural, this form of existential quanti.cation of an intermediate speci.cation, \nwhich takes full advantage of the strength of higher\u00adorder logic, does not seem to have been exploited \nin previous work. From our experience on working on the veri.cation of pure OCaml programs both with \na deep embedding and with charac\u00adteristic formulae, we conclude that moving to characteristic for\u00admulae \nbrings at least three major improvements. First, character\u00adistic formulae do not need to represent and \nmanipulate program syntax. Thus, they avoid many technical dif.culties, in particular those associated \nwith the representation of binders. Also, the re\u00adpeated computations of substitutions that occur during \nthe veri.\u00adcation of a deeply-embedded program typically lead to the gener\u00adation of a proof term of quadratic \nsize, which can be problematic for scaling up to larger programs. Second, with characteristic for\u00admulae \nthere is no need to apply reasoning rules of the program logic manually. Indeed, the applications of \nthose rules have been anticipated in the characteristic formulae. A practical consequence is that proof \nscripts are lighter and easier to automate. Third and last, characteristic formulae avoid the need to \nrelate the deep em\u00adbedding of program values with the corresponding logical values, saving a lot of technical \nburden. For example, consider a list of inte\u00adgers in a OCaml program. In the deep embedding, the description \nof this list is encoded using constructors from the grammar of OCaml values. With characteristic formulae, \nprogram values are translated into logical values once and for all upon generation of the formula. Thus, \nthe list of integers would appear in the characteristic formula directly as a list of integers, signi.cantly \nsimplifying proofs. The fact that characteristic formulae outperform deep embed\u00addings is after all not \na surprize: characteristic formulae can be seen as an abstract layer built on the top of a deep embedding, \nso as to hide uninteresting details and retain only the essence of the reason\u00ading rules supported by \nthe deep embedding. 3. Formalizing purely functional data structures Chris Okasaki s book Purely Functional \nData Structures [22] con\u00adtains a collection of ef.cient data structures, with concise imple\u00admentation \nand nontrivial invariants. Its code appeared as a excel\u00ad module type Fset = sig | module type Ordered \n= type elem | sig type fset | type t val empty: fset | val lt: t -> t -> bool val insert: elem -> fset \n-> fset | end val member: elem -> fset -> bool | end | Figure 1. Module signatures for .nite sets and \nordered types module RedBlackSet (Elem : Ordered) : Fset = struct type elem = Elem.t type color = Red \n| Black type fset = Empty | Node of color * fset * elem * fset let empty = Empty let rec member x = function \n| Empty -> false | Node (_,a,y,b) -> if Elem.lt x y then member x a else if Elem.lt y x then member x \nb else true  let balance = function | (Black, Node (Red, Node (Red, a, x, b), y, c), z, d) | (Black, \nNode (Red, a, x, Node (Red, b, y, c)), z, d) | (Black, a, x, Node (Red, Node (Red, b, y, c), z, d)) | \n(Black, a, x, Node (Red, b, y, Node (Red, c, z, d))) -> Node (Red, Node(Black,a,x,b), y, Node(Black,c,z,d)) \n| (col,a,y,b) -> Node(col,a,y,b) let rec insert x s = let rec ins = function | Empty -> Node(Red,Empty,x,Empty) \n| Node(col,a,y,b) as s -> if Elem.lt x y then balance(col,ins a,y,b) else if Elem.lt y x then balance(col,a,y,ins \nb) else s in match ins s with | Empty -> raise BrokenInvariant | Node(_,a,y,b) -> Node(Black,a,y,b) \n end Figure 2. Okasaki s implementation of Red-Black sets lent benchmark for testing the usability of \nour approach to program veri.cation. So far, we have veri.ed more than half of the contents of the book. \nThis paper focuses on the formalization of red-black trees and give statistics on the other formalizations \ncompleted. Red-black trees behave like binary search trees except that each node is tagged with a color, \neither red or black. Those tags are used to maintain balance in the tree, ensuring a logarithmic asymp\u00adtotic \ncomplexity. Okasaki s implementation appears in Figure 2. It consists of a functor that, given an ordered \ntype, builds a module matching the signature of .nite sets. Signatures appear in Figure 1. We specify \neach OCaml module signature through a Coq mod\u00adule signature. We then verify each OCaml module implementation \nthrough a Coq module implementation that contains lemmas estab\u00adlishing that the OCaml code satis.es its \nspeci.cation. We rely on Coq s module system to ensure that the lemmas proved actually correspond to \nthe expected speci.cation. This strategy allows for modular veri.cation of modular programs. 3.1 Speci.cation \nof the signatures In order to specify functions manipulating red-black trees, we need to introduce a \nrepresentation predicate called rep. Intuitively, ev\u00adery data structure admits a mathematical model. \nFor example, the model of a red-black tree is a set of values. Similarly, the model of a priority queue \nis a multiset, and the model of a queue is a se\u00adquence (a list). Sometimes, the mathematical model is \nsimply the value itself. For instance, the model of an integer or of a value of type color is just the \nvalue itself. We formalize models through instances of a typeclass named Rep. If values of a type a \nare modelled by values of type A, then we write Rep aA . For example, consider red-black trees that contain \nitems of type t. If those items are modelled by values of type T (i.e. Rep tT ), then trees of type fset \nare modelled by values of type set T (i.e. Rep fset (set T )), where set is the type constructor for \nmathematical sets in Coq. The typeclass Rep contains two constructors, as shown below. For an instance \nof type Rep aA , the .rst .eld, rep, is a binary relation that relates values of type a with their model, \nof type A. Note that not all values admit a model. For instance, given a red\u00adblack tree e, the proposition \nrep eE can only hold if e is a well\u00adbalanced, well-formed binary search tree. The second .eld of Rep, \nnamed rep unique, is a lemma asserting that every value of type a admits at most one model (we sometimes \nneed to exploit this fact in proofs). Class Rep (a:Type) (A:Type) := {rep: a->A->Prop; rep_unique : forall \nx X Y, repxX-> repxY->X=Y}. Remark: while representation predicates have appeared in previous work (e.g. \n[7, 16, 19]), our work seems to be the .rst to use them in a systematic manner through a typeclass de.nition. \nFigure 3 contains the speci.cation for an abstract .nite set module named F. Elements of the sets, of \ntype elem, are expected to be modelled by some type T and to be related to their models by an instance \nof type Rep elem T . Moreover, the values implementing .nite sets, of type fset, should be related to \ntheir model, of type set T , through an instance of type Rep fset (set T ) . The module signature then \ncontains the speci.cation of the values from the .nite set module F. The .rst one asserts that the value \nempty should be a representation for the empty set. The speci.cations for insert and member rely on a \nspecial notation, explained next. So far, we have relied on the predicate AppReturns to specify functions. \nWhile this works well for functions of one argument, it becomes impractical for curried functions of \nhigher arity, in particular because we want to specify the behaviour of partial applications. So, we \nintroduce the Spec notation, explaining its meaning informally and postponing its formal de.nition to \n\u00a75.2. With the Spec notation, the speci.cation of insert, shown below, reads like a prototype: insert \ntakes two arguments, x of type elem and e of type fset. Then, for any model X of x and for any set E \nthat models e, the function returns a .nite set e which admits a model E equal to {X}. E.(\\{X} is a Coq \nnotation for a singleton set.) Parameter insert_spec : Spec insert (x:elem) (e:fset) |R>> forall XE,repxX \n->repe E-> R (fun e => exists E , repe E /\\ E = \\{X}\\uE). The variable R should be read as the application \nof insert returns a value satisfying the following post-condition . R is bound in |R>> and it is applied \nto the post-condition of the function. As it is often the case that arguments and/or results are described \nthrough their rep predicate, we introduce the RepSpec notation. With this new layer of syntactic sugar, \nthe speci.cation becomes: Parameter insert_spec : RepSpec insert (X;elem) (E;fset) |R>> R (fun E => E \n= \\{X} \\u E ; fset). Module Type FsetSigSpec. Declare Module F : MLFset. Import F. Parameter T : Type. \nInstance elem_rep : Rep elem T. Instance fset_rep : Rep fset (set T). Parameter empty_spec : rep empty \n\\{}. Parameter insert_spec : RepTotal insert (X;elem) (E;fset) >> = \\{X} \\u E ; fset. Parameter member_spec \n: RepTotal member (X;elem) (E;fset) >> bool_of (X \\in E). End FsetSigSpec. Figure 3. Speci.cation of \n.nite sets Module Type OrderedSigSpec. Declare Module O : MLOrdered. Import O. Parameter T : Type. \nInstance rep_t : Rep t T. Instance le_inst : Le T. Instance le_order : Le_total_order. Parameter lt_spec \n: RepTotal lt (X;t) (Y;t) >> bool_of (LibOrder.lt X Y). End OrderedSigSpec. Figure 4. Speci.cation of \nordered types The speci.cation is now stated entirely in terms of the models, and does no longer refer \nto the names of OCaml input and output values. Only the type of those program values remain visible. \nThose type annotation are introduced by semi-columns. The speci.cation for the function insert given \nin Figure 3 makes two further simpli.cations. First, it relies on the notation RepTotal, which avoids \nthe introduction of a name R when it is immediately applied. Second, we have employed for the sake of \nconciseness a partial application of equality, of the form = {X}. E . Overall, the interest of introducing \nseveral layers of notation is that the .nal speci.cations from Figure 3 are about the simplest possible \nformal speci.cations one could hope for. Let us describe brie.y the remaining speci.cations. The func\u00adtion \nmember takes as argument a value x and a .nite set e, and returns a boolean which is true if and only \nif the model X of x be\u00adlongs to the model E of e. Figure 4 contains the speci.cation of an abstract ordered \ntype module named O. Elements of the ordered type t should be modelled by a type T . Values of type T \nshould be ordered by a total order relation. The order relation and the proof that it is total are described \nthrough instances of the typeclasses Le and Le total order, respectively. An instance of the strict-order \nre\u00adlation (LibOrder.lt) is automatically derived through the typeclass mechanism. This relation is used \nto specify the boolean comparison function lt, de.ned in the module O. 3.2 Veri.cation of the implementation \nIt remains to verify the implementation of red-black trees. Con\u00adsider a module O describing an ordered \ntype. Assume the mod\u00adule O has been veri.ed through a Coq module named OS of signa\u00adture OrderedSigSpec. \nOur goal is then to prove correct the module obtained by applying the functor RedBlackSet to the module \nO, through the construction of Coq module of signature FsetSigSpec. Thus, the veri.cation of the OCaml \nfunctor RedBlackSet is carried through the implementation of a Coq functor named RedBlackSet\u00adSpec, which \ndepends both on the module O and on its speci.cation OS. The .rst few lines of this Coq functor are shown \nbelow. Module RedBlackSetSpec (O:MLOrdered) (OS:OrderedSigSpec with Module O:=O) <: FsetSigSpec with \nDefinition F.elem := O.t. Module Import F <: MLFset := MLRedBlackSet O. The next step in the construction \nof this functor is the de.nition of an instance of the representation predicate for red-black trees. \nTo start with, assume that our goal is simply to specify a binary search tree. The rep predicate would \nbe de.ned in terms of an inductive invariant called inv, as shown below. First, inv relates the empty \ntree to the empty set. Second, inv relates a node with root y and subtrees a and b to the set {Y}. A \n. B, where the uppercase variables are the model associated with their lowercase counterpart. Moreover, \nwe need to ensure that all the elements of the left subtree A are smaller than the root Y, and that, \nsymmetrically, elements from B are greater than Y. Those invariants are stated with help of the predicate \nforeach. The proposition foreach PE asserts that all the elements in the set E satisfy the predicate \nP . Inductive inv : fset -> set T -> Prop := | inv_empty : inv Empty \\{} | inv_node : forall col a y \nb A Y B, invaA ->invbB->repyY -> foreach (is_lt Y) A -> foreach (is_gt Y) B -> inv (Node col a y b) (\\{Y} \n\\u A \\u B). A red-black tree is a binary search tree satisfying three invari\u00adants. First, every path \nfrom the root to a leaf contains the same number of black nodes. Second, no red node can have a red child. \nThird, the root of the tree must be black. In order to capture the .rst invariant, we extend the predicate \ninv so that it depends on a natu\u00adral number n representing the number of black nodes to be found in every \npath. For an empty tree, this number is zero. For a nonempty tree, this number is equal to the number \nm of black nodes that can be found in every path of each of the two subtrees, augmented by one if the \nnode is black. The second invariant, asserting that a red node must have black children, can be enforced \nsimply by testing colors. Finally, the rep predicate relates a red-black tree e with a set E if there \nexists a value n such that inv n e E holds and such that the root of e is black (the third invariant). \nThe extended de.ni\u00adtion of inv appears in Figure 5. In practice, we further extend the invariant with \nan extra boolean (this extended de.nition does not appear in the present paper). When the boolean is \ntrue, the de.nition of inv is unchanged. How\u00adever, when the boolean is false, then second invariant might \nbe bro\u00adken at the root of the tree. This relaxed version of the invariant is useful to specify the behaviour \nof the function balance. Indeed, this function takes as input a color, an item and two subtrees, and \none of those two subtrees might have its root incorrectly colored. Figure Figure 6 shows the lemma corresponding \nto the veri\u00ad.cation of insert. Observe that the local recursive function ins is speci.ed in the script. \nIt is then veri.ed with help of the tactic xgo.  3.3 Statistics We have speci.ed and veri.ed various \nimplementations of queues, double-ended queues, priority queues (heaps), sets, as well as sortable lists, \ncatenable lists and random-access lists. OCaml im\u00adplementations are directly adapted from Okaski s SML \ncode [22]. All code and proofs can can be found online.1 Figure 7 contains statistics on the number of \nnon-empty lines in OCaml source code and in Coq scripts. The programs considered are generally short, \n1 http://arthur.chargueraud.org/research/2010/cfml/ Inductive inv : nat -> fset -> set T -> Prop := \n| inv_empty : forall, inv 0 Empty \\{} |inv_node:forallnm col ay bAYB, invm aA -> inv mbB->repyY -> foreach \n(is_lt Y) A -> foreach (is_gt Y) B -> (n = match col with Black => m+1 | Red => m end) -> (match col \nwith | Black => True | Red => root_color a = Black /\\ root_color b = Black end) -> invn (Nodecol ay b)(\\{Y}\\uA \n\\u B). Global Instance set_rep : Rep fset (set T). Proof. apply (Build_Rep (fun e E => exists n, inv \nn e E /\\ root_color e = Black)). [...] Defined. Figure 5. Representation predicate for red-black trees \n Lemma insert_spec : RepTotal insert (X;elem) (E;fset) >> = \\{X} \\u E ; fset. Proof. xcf. introv RepX \n(n&#38;InvE&#38;HeB). xfun_induction_nointro_on size (Spec ins e |R>> forallnE,invtrue ne E->R (fune \n=> inv (is_black (root_color e)) n e (\\{X} \\u E))). clears s n E. intros e IH n E InvE. inverts InvE \nas. xgo*. simpl. constructors*. introv InvA InvB RepY GtY LtY Col Num. xgo~. (* case insert left *) destruct~ \ncol; destruct (root_color a); tryifalse~. ximpl as e. simpl. applys_eq* Hx 1 3. (* case insert right \n*) destruct~ col; destruct (root_color b); tryifalse~. ximpl as e. simpl. applys_eq* Hx 1 3. (* case \nno insertion *) asserts_rewrite~ (X = Y). apply~ nlt_nslt_to_eq. subst s. simpl. destruct col; constructors*. \nxlet as r. xapp~. inverts Pr; xgo. fset_inv. exists*. Qed. Figure 6. Invariant and model of red-black \ntrees but note that OCaml is a concise language and that Okasaki s code is particularly minimalist. \nDetails are given about Coq scripts. The column inv indicates the number of lines needed to state the \ninvariant of each structure. The column facts gives the length of proof script needed to state and prove \nfacts that are used sev\u00aderal times in the veri.cation scripts. The column spec indicates the number of \nlines of speci.cation involved, including the speci.\u00adcation of local and auxiliary functions. Finally, \nthe last column de\u00adscribes the size of the actual veri.cation proof scripts where charac\u00adteristic formulae \nare manipulated. Note that Coq proof scripts also contain several lines to import and instantiate modules, \na few lines to set up automation, as well as one line per function to register its speci.cation in a \ndatabase of lemmas. We evaluate the relative cost of a formal veri.cation by com\u00adparing the number of \nlines speci.c to formal proofs (.gures from columns facts and verif ) against the number of lines required \nin a properly-documented source code (source code plus invariants and speci.cations). For particularly-tricky \ndata structures, such as bootstrapped queues, Hood-Melville queues and binominal heaps, this ratio is \nclose to 2.0. In all other structures, the ration does not exceed 1.25. For a user as .uent in Coq proofs \nas in OCaml pro\u00adgramming, it means that the formalization effort can be expected to be comparable to \nthe implementation and documentation effort. Development Caml Coq inv facts spec verif BatchedQueue \n20 73 4 0 16 16 BankersQueue 19 95 6 20 15 16 PhysicistsQueue 28 109 8 10 19 32 RealTimeQueue 26 104 \n4 12 21 28 ImplicitQueue 35 149 25 21 14 50 BootstrappedQueue 38 212 22 54 29 77 HoodMelvilleQueue 41 \n363 43 53 33 180 BankersDeque 46 172 7 26 24 58 LeftistHeap 36 132 16 28 15 22 PairingHeap 33 137 13 \n17 16 35 LazyPairingHeap 34 132 12 24 14 32 SplayHeap 53 176 10 41 20 59 BinomialHeap 48 367 24 118 41 \n110 UnbalancedSet 21 85 9 11 5 22 RedBlackSet 35 183 20 43 22 53 BottomUpMergeSort 29 151 23 31 9 40 \nCatenableList 38 153 9 20 23 37 RandomAccessList 63 272 29 37 47 83 Total 643 3065 284 566 383 950 Figure \n7. Non-empty lines of source code and proof scripts 4. Characteristic formula generation 4.1 Source \nlanguage and normalization CFML takes as input programs written in the pure fragment of OCaml, which \nincludes algebraic data types, pattern matching, higher-order functions, recursion and mutual recursion. \nPolymor\u00adphic recursion, whose support was recently added to OCaml and which is used extensively in Okasaki \ns book, is also handled. Mod\u00adules and functors are supported as long as the corresponding signa\u00adtures \nare de.nable in Coq s module system. Lazy expressions are supported under the condition that the code \nwould terminate without any lazy annotation. While this re\u00adstriction certainly does not enable reasoning \non in.nite data struc\u00adtures, it covers the use of laziness for computation scheduling, as described in \nOkasaki s book. In fact, our tools simply ignores any annotation relative to laziness. The key idea is \nthat if a program satis.es its speci.cation when evaluated without any lazy annota\u00adtion, then it also \nsatis.es its speci.cation when evaluated with lazy annotations. (Of course, the reciprocal is not true.) \nProgram veri.cation based on characteristic formulae could presumably be applied to another programming \nlanguage. Yet, we make the assumption throughout this work that the source language is call-by-value \nand deterministic. For the sake of simplicity, pro\u00adgram integers are modelled as unbounded mathematical \nintegers. Before generating the characteristic formula of a program, the program is automatically transformed \ninto its normal form: the pro\u00adgram is arranged so that all intermediate results and all functions become \nbound by a let-de.nition (except applications of simple to\u00adtal functions such as addition and subtraction). \nThis transformation, similar to A-normalization [8], is straightforward to implement and greatly simpli.es \nformal reasoning on programs (see [10, 24] for similar transformations in the context of program veri.cation). \nThe grammar of terms in normal form is given below, for a subset of the source language. It will later \nbe extended with curried n-ary functions and curried n-ary applications (\u00a75.3). x, f := variables v := \nx | n | (v, v) | injk v t := v | (vv) | fail | if x then t else t | let x = t in t | let f =(\u00b5f..x.t) \nin t Throughout this work, we consider only programs that are well\u00adtyped in ML with recursive types. \nThe grammar of types and type schema is recalled below. T := A | int | T \u00d7 T | T + T | T . T | \u00b5A.T \nS := .A.T  4.2 Characteristic formula generation: informal presentation The characteristic formula of \na term t, written .t., is generated us\u00ading a recursive algorithm that follows the structure of t. Recall \nthat, given a post-condition P , the characteristic formula is such that the proposition .t. P holds \nif and only if the term t terminates and returns a value that satis.es P . In terms of a denotational \nin\u00adterpretation, .t. corresponds to the set of post-conditions that are valid for the term t. In terms \nof types, the characteristic formula associated with a term t of type T applies to a post-condition P \nof type T . Prop and produces a proposition, so .t. admits the type (T . Prop) . Prop. The key ideas \ninvolved in the construction of characteristic formulae are explained next. The re.ection of Caml values \ninto Coq and the treatment of polymorphism are described afterwards. The de.nition of .t. for a particular \nterm t always takes the form .P. H , where H expresses what needs to be proved in order to show that \nthe term t returns a value satisfying the post-condition P . To show that a value v returns a value satisfying \nP , it suf.ces to prove that Pv holds. So, .v. is de.ned as .P. (Pv) . Next, to prove that an application \nfv returns a value satisfying P , one must exhibit a proof of AppReturns fvP . So, .fv. is de.ned as \n.P. AppReturns fvP . To show that if x then t1 else t2 re\u00adturns a value satisfying P , one must prove \nthat t1 returns such a value when x is true and that t2 returns such a value when x is false. So, the \nformula .if x then t1 else t2. is de.ned as .P. (x = true . .t1. P ) . (x = false . .t2. P ) To show \nthat the term fail returns a value satisfying P , the only way to proceed is to show that this point \nof the program cannot be reached, by proving that the assumptions accumulated at that point are contradictory. \nTherefore, .fail. is de.ned as .P. False . The treatment of let-bindings is more interesting. To show \nthat a term let x = t1 in t2 returns a value satisfying P , one must prove that there exists a post-condition \nP . such that t1 returns a value satisfying P . and that t2 returns a value satisfying P for any x satisfying \nP .. Formally, .let x = t1 in t2. is de.ned as .P. .P . . (.t1. P .) ..x. (P . x) . (.t2. P ) Slightly \ntrickier is the treatment of functions and recursive func\u00adtions. In fact, we generate the same formula \nregardless of whether a function is recursive or not (except, of course, for the treatment of binding \nscopes). Indeed, as suggested in the example of the func\u00adtion half (\u00a71.2), speci.cation for recursive \nfunctions are proved by induction, using the induction principles provided by Coq. Thus, there is no \nneed to add further support for reasoning by induction inside characteristic formulae. Consider a possibly-recursive \nfunction \u00b5f..x.t . The state\u00adment .x. .P . . .t. P . . AppReturns f xP . , called the body description \nfor f, captures the fact that, in order to prove that the application of f to x returns a value satisfying \na post-condition P . , it suf.ces to prove that the body t, instantiated with that particular value of \nx, terminates and returns a value satisfying P .. The char\u00adacteristic formula for the function \u00b5f..x.t \nthen states that, in order to prove a property P to hold of \u00b5f..x.t, it suf.ces to prove that the body \ndescription for f implies the proposition Pf for any abstract name f. The formula .\u00b5f..x.t. is thus de.ned \nas: .P. .f. .x. .P. .t. P . AppReturns f xP . Pf The treatment of pattern matching and mutually-recursive \nfunc\u00adtions can be found in the technical appendix [3].  4.3 Re.ection of values in the logic So far, \nwe have abusively identi.ed program values from the pro\u00adgramming language with values from the logic. \nThis section clar\u00adi.es the translation from ML types to Coq types, as well as the translation from ML \nvalues to Coq values. We map every ML value to its corresponding Coq value, except for functions. As \nexplained earlier on, due to the mismatch between the programming language arrow type and the logical \narrow type, we represent OCaml functions using values of type Func. For each ML type T , we de.ne the \ncorresponding Coq type, written .T .. This type is simply a copy of T where all the arrow types are replaced \nwith the type Func. Formally: .A.= A .int.= Int .T1 \u00d7 T2. =.T1.\u00d7.T2. .T1 + T2. =.T1. + .T2. .\u00b5A.T .= \n\u00b5A..T . .T1 . T2.= Func Technical remark: a ML algebraic data type de.nition can be trans\u00adlated into \na Coq inductive de.nition without any dif.culty regard\u00ading negative occurrences. Indeed, since all arrow \ntypes are mapped to Func, there simply cannot be any negative occurrence. Now, given a type T , we de.ne \nthe translation from Caml values of type T towards Coq values of type .T .. The translation of a value \nv of type T is written .v.G T . The context G, which maps Caml variables to Coq variables, is used to \ntranslate non-closed values. The de.nition of the operator .\u00b7., called decoder, appears next. .x.G T \n= G(x) .n.G = n int .(v1,v2).G = T1 , .v2.G (.v1.G ) T1\u00d7T2 T2 .injk v.G = injk .v.G T1+T2 Tk .v.G =.v.G \n\u00b5A.T ([A.(\u00b5A.T )] T ) .\u00b5f..x.t.G = not needed at this time T1.T2 When decoding closed values, the context \nG is typically empty. Henceforth, we write .v.T as a shorthand for .v.\u00d8 . Moreover, T when there is no \nambiguity on the type T of the value v, we omit the type T and simply write .v.G and .v.. 4.4 Characteristic \nformula generation: formal presentation The characteristic formula generator can now be given a formal \npresentation in which OCaml values are re.ected into Coq, through calls to the decoding function .\u00b7.. \nIf t is a term of type T , then its characteristic formula .t.G is actually a logical predicate of type \n(.T .. Prop) . Prop. The environment G describes the substitution from program variables to Coq variables. \nIn order to justify that characteristic formulae can be displayed like the source code, we proceed in \ntwo steps. First, we describe the characteristic formula generator in terms of an intermediate layer \nof notation (Figure 8). Then, we de.ne the notation layer in terms of higher-order logic connectives \nas well as in terms of the predicate AppReturns (Figure 9). The contents of those .gures simply re.nes \nthe informal presentation from \u00a74.2.  4.5 Polymorphism The treatment of polymorphism is certainly one \nof the most delicate aspect of characteristic formula generation. We need to extend the characteristic \nformula so as to quantify type variables needed to type-check the bodies of polymorphic let-bindings. \nThe translation of a polymorphic OCaml type .B.T is a poly\u00admorphic Coq type of the form .A..T .. The \nset of type variables A is obtained by removing from the set B all the type variables that do not occur \nfree in .T .. Indeed, as all arrow types are mapped di\u00adrectly towards the type Func, some variables occuring \nin T may no longer occur in .T .. So, the set B might be strictly smaller than A. Consider a polymorphic \nlet-binding let x = t1 in t2 . The type checking of the term t1 involves a set of type variables that \nare to be generalized at this let-binding on variable x. Let C denotes that set of generalizable type \nvariables, and let T be the type of t1 before generalization. The variable x thus admits a type of the \nform .B.T , where B is a subset of C. Note that, in general, C is a strict subset of B because not all \nintermediate type variables are visible in the result type of an expression. Our goal is to de.ne the \ncharacteristic formula associated with the term let x = t1 in t2 in a context G. To that end, let .A..T \n. be the Coq translation of the type .B.T . Since A is a subset of B and B is a subset of C, we can de.ne \na set A. such that C is equal to the union of A and A.. Then, we de.ne: .let x = t1 in t2.G = .P. .P \n. :(.A.(.T .. Prop)). (.A. .A. G (P . A)) . .t1. (G,x..X) ..X :(.A..T .). (.A. (P . A)(XA)) . (.t2.P \n) The post-condition P . describing X is a polymorphic predicate of type .A.(.T .. Prop). Note that \nit is not a predicate on a poly\u00admorphic value, which would have the type (.A..T .) . Prop. (Indeed, we \nonly care about describing the behaviour of monomor\u00adphic instances of the polymorphic variable X.) If \nwe write type applications explicitly, then a particular monomorphic instance of X takes the form XA \nand it satis.es the predicate P . A. Those type applications appear in the characteristic formula stated \nabove. Remark: we need to update slightly the translation from OCaml variables to Coq variables, because \nthe context G may now asso\u00adciate program variables with polymorphic logical variables. The translation \na monomorphic occurrence of a polymorphic variable x is the application of the Coq type variable G(x) \nto some appropri\u00adates types, which depend on the type of x at its place of occurrence. Finally, we give \nthe characteristic formula for polymorphic functions, which is simpler than that of other polymorphic \nvalues because functions are simply re.ected in the logic using the type Func. If A denotes the set of \ngeneralizable type variables associ\u00adated with the body t of a function \u00b5f..x.t, then the characteristic \nformula is constructed as follows. .\u00b5f..x.t.G = .P. .F. (.AXP . (G,f..F,x..X) P . . AppReturns FXP .) \n. PF . .t. 5. Speci.cation predicates Through this section, we formally describe the meaning of the \npred\u00adicates AppReturns and Spec. We then generalize those predicates to n-ary functions. Finally, we \ninvestigate how the predicate Spec can be used to specify higher-order functions. 5.1 De.nition of the \nspeci.cation predicate Consider the speci.cation of the function half, written in terms of the predicate \nAppReturns. .x. .n = 0.x =2 * n . AppReturns half x (= n) The same speci.cation can be rewritten with \nthe Spec notation as: Spec half (x : int) | R >> .n = 0.x =2 * n . R (= n) The notation based on Spec \nin fact stands for an application of a higher-order predicate called Spec1. The proposition Spec1 fK \nasserts that the function f admits the speci.cation K. The predicate K takes both x and R as argument, \nand speci.es the result of the application of f to x. The predicate R is to be applied to the G = Ret \n.v.G.v.G .fv.= App .f .G .v.G .fail.G = Fail .if x then t1 else t2.G = If .x.G Then .t1.G Else .t2.G \nG (G,x..X) .let x = t1 in t2.= Let X := .t1.G in .t2. G (G,f..F,x..X) (G,f...F .) .let f. =(\u00b5f..x.t1) \nin t2.= Let F . := Fun FX := .t1.in .t2. Figure 8. Characteristic formula generator Ret V = .P. PV App \nFV = .P. AppReturns FV P Fail = .P. False If V Then Q Else Q. = .P. (V = true . QP ) . (V = false . Q. \nP ) Let X := Q in Q. = .P. .P .. QP . . (.X. P . X . Q. P ) Fun FX := Q = .P. .F. .X. .P .. QP . . AppReturns \nFXP . . PF Figure 9. Syntactic sugar to display characteristic formulae post-condition that holds of \nthe result of fx . For example, the previous speci.cation for half stands for: Spec1 half (.x R. .n = \n0.x =2 * n . R (= n)) In .rst approximation, the predicate Spec1 is de.ned as follows: Spec1 fK =.x. \nKx (AppReturns fx) where K has type A . ((B . Prop) . Prop) . Prop, where A and B correspond to the input \nand the output type of f, respectively. The reader may check that unfolding the de.nition of Spec1 in \nthe speci.cation for half expressed using Spec1 yields the speci.cation for half expressed in terms of \nAppReturns. The true de.nition of Spec1 actually include an extra side\u00adcondition, expressing that K is \ncovariant in R. It is needed to ensure that the speci.cation K actually concludes about the be\u00adhaviour \nof the application of the function. Formally, covariance is captured by the predicate Weakenable, de.ned \nas follows: Weakenable H =. GG. (.x. G x . Gx) . HG . HG where H has type (X . Prop) . Prop for some \nX. The formal de.nition of Spec1 appears in the middle of Figure 10. Fortunately, thanks to appropriate \nlemmas and tactics, the predicate Weakenable never needs to be manipulated explicitly by the user.  \n5.2 Direct treatment of n-ary functions In order to obtain a realistic tool for program veri.cation, \nit is cru\u00adcial to offer direct support for reasoning on the de.nition and ap\u00adplication of n-ary curried \nfunctions. Generalizing the de.nitions of Spec1 and AppReturns1 to higher arities is not entirely straightfor\u00adward, \nbecause we want the ability to reason on partial applications and over applications. Intuitively, the \nspeci.cation of a n-ary cur\u00adried function should capture the property that the application to a number \nof arguments less than n terminates and returns a function with the appropriate specialization of the \noriginal speci.cation. Firstly, we de.ne the predicate AppReturnsn. The proposition AppReturnsn fv1 ...vn \nP states that the application of f to the n arguments v1 ... vn returns a value satisfying P . The family \nof predicates AppReturnsn is de.ned by recursion on n in terms of the predicate AppReturns, as shown \nat the top of Figure 10. For instance, AppReturns2 fv1 v2 P states that the application of f to v1 returns \na function g such that the application of g to v2 returns a value satisfying P . More generally, if m \nis smaller than n, then applications at arities n and m are related as follows: AppReturnsn fv1 ...vn \nP .. AppReturnsm fv1 ...vm (.g. AppReturnsn-m gvm+1 ...vn P )  Secondly, we de.ne the predicate Specn. \nAgain, we proceed by recursion on n. For example, a curried function f of two arguments is a total function \nthat, when applied to its .rst argument, returns a unary function g that admits a certain speci.cation \nwhich depends on that .rst argument. Formally: Spec2 fK = Spec1 f (.xR. R (.g. Spec1 g (Kx))) where \n(K : A1 . A2 . ((B . Prop) . Prop) . Prop). Remark: Spec2 is polymorphic in the types A1, A2 and B. The \nactual de.nition, given in Figure 10, includes a side condi\u00adtion to ensure that K is covariant in R, \nwritten Is specn K. Note: the speci.cation of a curried function described using Specn can always be \nviewed as a unary function speci.ed using Spec1. This property will be useful for reasoning on higher-order \nfunctions. The high-level notation for speci.cation used in \u00a73 can now be easily explained in terms of \nthe family of predicates Specn. Spec f (x1 : A1) ... (xn : An) | R >>H = Specn f (.(x1 : A1). ....(xn \n: A1). .R. H)  5.3 Characteristic formulae for curried functions In this section, we update the generation \nof characteristic formulae to add direct support for reasoning on n-ary functions using Specn and AppReturnsn. \nNote that the grammar of terms in normal form is now extended with n-ary applications and n-ary abstractions. \nIntuitively, the characteristic formula associated with an ap\u00adplication fv1 ...vn is simply .P. AppReturnsn \nv1 ...vn P . The formal de.nition, which takes decoders into account, is: .fv1 ...vn. G = .P. AppReturns.f.G \n.v1.G ... .vn.G P n The characteristic formula for a function \u00b5f..x1 ...xn.t as\u00adserts that to prove \nSpecn fK it suf.ces to show that the propo\u00adsition Kx1 ...xn .t. holds for any arguments xi. Remark: the \ntreatment of unary functions given here is different but provably equivalent to that given earlier on \n(\u00a74.2). It may be surprizing to see the predicate Kx1 ...xn being applied to a characteristic formula \n.t.. It is worth considering an example. Recall the de.nition of the function half. It takes the form \n\u00b5half..x.t , where t stands for the body of half. Its speci.cation takes the form Spec1 half K , where \nK is equal to .x R. .n = 0.x =2 * n . R (= n) . According to the new characteristic formula for functions, \nin order to prove that the function half satis.es its speci.cation, we need to prove the proposition \n.x.K x .t. . Unfolding K, we obtain: .n = 0.x = 2 * n . .t. (= n) . As expected, we are required to prove \nthat the body of the function half (described by the characteristic formula AppReturns1 f xP = AppReturns \nf xP AppReturnsn fx1 ...xn P = AppReturns fx1 (.g. AppReturnsn-1 gx2 ...xn P ) Is spec1 K =.x. Weakenable \n(Kx) Is specK =.x. Is spec(Kx) nn-1 Spec1 fK = Is spec1 K ..x.K x (AppReturns fx) Specn fK = Is specn \nK . Spec1 f (.xR. R (.g. Specn-1 g (Kx))) In the .gure, n> 1 and (f : Func) and (xi : Ai) and (P : B \n. Prop) and (K : A1 . ...An . ((B . Prop) . Prop) . Prop). Figure 10. Formal de.nitions for AppReturnsn \nand Specn .t.) returns a value equal to n, under the assumption that n is a non-negative integer such \nthat x =2 * n. Characteristic formulae for functions are constructed as follows. .\u00b5f..x1 ...xn.t.G = \n.P. .F. (G,f..F,xi..Xi) .K. .X1 ...Xn.KX1 ...Xn .t.. PF . Is specn K . Specn FK  5.4 Speci.cation of \nhigher-order functions The speci.cation of a function, whether unary or n-ary, can always take the form \nSpec1 fK. Thus, given a function f, we can quantify over every possible speci.cation that f might admit \nsimply by quantifying universally over the variable K. Let us illustrate this ability with the functions \napply and compose. The function apply, de.ned as .x. .f. (fx) , can be speci.ed as follows. Spec2 apply \n(.xf R. .K. Spec1 fK . KxR) The conclusion KxR states that the behaviour R of the term apply fx is described \nby the predicate Kx . The predicate Kx indeed speci.es the behaviour of the term fx , since Spec1 fK \nimplies Kx (AppReturns1 fx) . Consider now the function compose, which is de.ned as .f1 f2 x. f1 (f2 \nx) . Its speci.cation is expressed in terms of the speci.cations K1 and K2 of the functions f1 and f2, \nrespectively. Spec3 compose (.f1 f2 x R. .K1 K2. Spec1 f1 K1 . Spec1 f2 K2 . K2 x (.P. .y. P y . K1 yR))) \nThe last line can be read as follows. First, we want to unfold the speci.cation K2 x associated with \nthe application of f2 onto x, since this inner call is the .rst to be performed. Then, for any post\u00adcondition \nP that holds of the result y of the application f2 x , the behaviour R of the term f1 (f2 x) is the same \nas the behaviour of f1 y . Since the behaviour of f1 y is described by the predicate K1 y , the conclusion \nis K1 yR . The speci.cation given above speci.es in particular the re\u00adsult obtained by applying compose \nto two functions. For exam\u00adple, we were able to prove in a few lines of Coq that the term compose half \nhalf yields a function that divides its argument by four. More precisely, using a weakening lemma for \nspeci.cation, we have proved that the resulting function admits the speci.cation .x R. .n = 0.x =4 * \nn . R (= n) . (See [3] for details.) Using similar techniques, we were able to assign a concise speci.cation \nto the Y .xed-point combinator, and then to verify it. We have also started to investigate the speci.cation \nof higher\u00adorder iterators such as map and fold on lists and sets. However, due to lack of space and because \nwe lack experience in using those speci.cations, we do not report on that recent work in this paper. \n6. Soundness and completeness Characteristic formulae can be displayed in a way that closely re\u00adsemble \nsource code. However, proving the soundness and com\u00adpleteness of a characteristic formula with respect \nto the source code it describes is not entirely straightforward. First, we show how the type Func and \nthe predicate AppReturns can be given concrete im\u00adplementations in the logic. This construction, which \nhas been ver\u00adi.ed in Coq for a subset of the source language, relies on a deep embedding of the source \nlanguage and on the de.nition of func\u00adtions called encoders, which are the reciprocal of decoders. Sec\u00adond, \nwe present the statements of the soundness and completeness theorems, which have been proved on paper \n[3]. 6.1 Realization of Func and AppReturns To realize the type Func, we construct a deep embedding \nof the source language. More precisely, we use inductive de.nitions to de.ne the set of runtime values, \nnamed Val, and to de.ne the set of program terms, named Trm. Runtime values, written v throughout this \nsection, extend source program values with function closures. We then de.ne Func as the set of function \nclosures, that is, as the set of values of type Val of the form \u00b5f..x.t. In order to prove interesting \nfacts about characteristic formulae, we need to de.ne a decoder for function closures created at runtime. \nWe de.ne the decoding of a function as the deep embedding of the code of that function. In other words, \nthe decoder for functions is the identity. .\u00b5f..x.t.G = (\u00b5f..x.t): Func T1.T2 Note that the context \nG is ignored as function closures are always closed values. To realize the predicate AppReturns, we need \nto de.ne the semantics of the source language and to de.ne encoders. First, we describe the semantics \nof the deep embedding of the source language through a big-step reduction relation. This inductively\u00adde.ned \njudgment, written t . v , relates a term t of type Trm with a value v of type Val. Second, we de.ne encoders, \nwhich are the reciprocal of decoders. For each program type T , we de.ne an encoder function, written \n.V ..T . or simply .V ., that translates a logical value V of type .T . towards the deep embedding of \nthe corresponding program value. Thus, .V ..T . is always a logical value of type Val. The de.nition \nof encoders, not shown here, is such that ..v.T ..T . = v and ..V ..T . .T = V . We can now give the \nconcrete implementation to AppReturns. The judgment AppReturns FV P asserts that the application of \nF to the embedding of V terminates and returns the embedding of a value V . that satis.es P . Remark: \nsince F is a value of type Func, F is also equal to its encoding .F .. AppReturns FV P =.V . . (PV .) \n. (F .V .) ..V ..  6.2 Soundness and completeness theorems The soundness theorem states that if a predicate \nP satis.es the characteristic formula of a term t, then the term t terminates and returns the encoding \nof a value V satisfying P . Theorem 6.1 (Soundness) For any closed term t of type T and any predicate \nP of type .T .. Prop , \u00d8 P ..V. t ..V .. PV .t. The completeness result states that the characteristic \nformula of a term implies any true speci.cation satis.ed by this term. To avoid complications related \nto the occurrence of functions in the .nal result of a program, we present here only the particular case \nwhere the program produces an integer value as .nal result. Theorem 6.2 (Completeness for integer results) \nLet t be a well\u00adtyped closed term, n be an integer, and P be a predicate on integers. If t ..n. and Pn \nare true then the proposition .t.\u00d8 P is provable, even without knowledge of the concrete de.nitions \nof Func and AppReturns. A more precise theorem can be found in the appendix [3].  6.3 Quanti.cation \nover type variables Polymorphism has been treated by quantifying over logical type variables, but we \nhave not mentioned what exactly is the sort of these variables in the logic. A tempting solution would \nbe to assign them the sort Type. (In Coq, Type is the sort of all types from the logic, including the \nsort of Prop.) But in fact, type variables used to represent ML polymorphism are only meant to range \nover re.ected types, i.e. types of the form .T .. Thus, we ought to assign type variables the sort RType, \nde.ned as { X : Type |.T.X = .T .}. Since we provide RType as an abstract de.nition, users do not need \nto exploit the fact that universally-quanti.ed types correspond to re.ected ML types. A question naturally \nfollows: since RType is an abstract type, would it remain sound and complete to use the sort Type instead \nof the sort RType as a sort for type variables? We conjecture that the answer is positive. In the implementation, \nwe use the sort Type for the sake of convenience, however we could switch to RType if it ever turned \nout to be necessary. 7. Conclusion We have presented CFML, a tool for the veri.cation of pure OCaml programs. \nIt consists of two parts: a characteristic formula gener\u00adator (implemented in 3000 lines OCaml) and a \nset of lemmas, no\u00adtation and tactics for manipulating characteristic formulae (a 4000\u00adline Coq library). \nWe have reused OCaml s parser and type-checker to achieve maximal compatibility, making it possible to \nverify ex\u00adisting code, even if it is was not originally intented to be veri.ed. We have employed our \ntool to specify and verify total correct\u00adness of a number of advanced purely-functional data structures. \nComplex invariants can be expressed concisely, thanks to the high expressiveness of higher-order logic. \nNontrivial proof obligations can be discharged easily, thanks to the use of interactive proofs. When \nthe code or its speci.cation is incorrect, the proof assis\u00adtant provides immediate feedback, explaining \nwhat proof obliga\u00adtion fails and where this obligation comes from. In our experience, the process of \nverifying a program can be conducted relatively quickly. Most often, the hardest part is to .gure out \nvery precisely all the invariants that the program relies upon. References [1] Mike Barnett, Rob DeLine, \nManuel F\u00a8 ahndrich, K. Rustan M. Leino, and Wolfram Schulte. Veri.cation of object-oriented programs \nwith invariants. JOT, 3(6), 2004. [2] Arthur Chargu\u00b4eraud. Veri.cation of call-by-value func\u00adtional programs \nthrough a deep embedding. Unpublished. http://arthur.chargueraud.org/research/2009/deep/, March 2009. \n[3] Arthur Chargu\u00b4eraud. Technical appendix to the current paper. http://arthur.chargueraud.org/research/2010/cfml/, \nApril 2010. [4] Adam Chlipala, Gregory Malecha, Greg Morrisett, Avraham Shinnar, and Ryan Wisnesky. Effective \ninteractive proofs for higher-order imperative programs. In ICFP, September 2009. [5] Thierry Coquand. \nAlfa/agda. In Freek Wiedijk, editor, The Seventeen Provers of the World, volume 3600 of Lecture Notes \nin Computer Science, pages 50 54. Springer, 2006. [6] Xinyu Feng, Zhong Shao, Alexander Vaynberg, Sen \nXiang, and Zhaozhong Ni. Modular veri.cation of assembly code with stack\u00adbased control abstractions. \nIn M. Schwartzbach and T. Ball, editors, PLDI. ACM, 2006. [7] Jean-Christophe Filli atre and Claude March\u00b4e. \nMulti-prover veri.ca\u00adtion of C programs. In Formal Methods and Software Engineering, 6th ICFEM 2004, \nvolume 3308 of LNCS, pages 15 29. Springer-Verlag, 2004. [8] Cormac Flanagan, Amr Sabry, Bruce F. Duba, \nand Matthias Felleisen. The essence of compiling with continuations. In PLDI, pages 237 247, 1993. [9] \nG. A. Gorelick. A complete axiomatic system for proving assertions about recursive and non-recursive \nprograms. Technical Report 75, University of Toronto, 1975. [10] Kohei Honda, Martin Berger, and Nobuko \nYoshida. Descriptive and relative completeness of logics for higher-order functions. In M. Bugliesi, \nB. Preneel, V. Sassone, and I. Wegener, editors, ICALP (2), volume 4052 of LNCS. Springer, 2006. [11] \nJohannes Kanig and Jean-Christophe Filli atre. Who: a veri.er for effectful higher-order programs. In \nML 09: Proceedings of the 2009 ACM SIGPLAN workshop on ML, pages 39 48, New York, NY, USA, 2009. ACM. \n[12] Henri Korver. Computing distinguishing formulas for branching bisimulation. In Kim Guldstrand Larsen \nand Arne Skou, editors, CAV, volume 575 of LNCS, pages 13 23. Springer, 1991. [13] Xavier Leroy. Formal \ncerti.cation of a compiler back-end or: pro\u00adgramming a compiler with a proof assistant. In POPL, pages \n42 54, January 2006. [14] Claude March\u00b4Thee, Christine Paulin Mohring, and Xavier Urbain. Krakatoa tool \nfor certi.cation of Java/JavaCard programs annotated in JML. JLAP, 58(1 2):89 106, 2004. [15] Conor McBride \nand James McKinna. The view from the left. JFP, 14(1):69 111, 2004. [16] Farhad Mehta and Tobias Nipkow. \nProving pointer programs in higher-order logic. In Franz Baader, editor, CADE, volume 2741 of LNCS, pages \n121 135. Springer, 2003. [17] R. Milner. Communication and Concurrency. Prentice-Hall, 1989. [18] Magnus \nO. Myreen, Michael J. C. Gordon, and Konrad Slind. Machine-code veri.cation for multiple architectures: \nan application of decompilation into logic. In FMCAD, pages 1 8, Piscataway, NJ, USA, 2008. IEEE Press. \n[19] Aleksandar Nanevski, J. Gregory Morrisett, and Lars Birkedal. Hoare type theory, polymorphism and \nseparation. JFP, 18(5-6):865 911, 2008. [20] Aleksandar Nanevski, Viktor Vafeiadis, and Josh Berdine. \nStructur\u00ading the veri.cation of heap-manipulating programs. In Manuel V. Hermenegildo and Jens Palsberg, \neditors, POPL, pages 261 274. ACM, 2010. [21] Zhaozhong Ni and Zhong Shao. Certi.ed assembly programming \nwith embedded code pointers. In POPL, 2006. [22] Chris Okasaki. Purely Functional Data Structures. Cambridge \nUni\u00adversity Press, 1999. [23] David Park. Concurrency and automata on in.nite sequences. In Peter Deussen, \neditor, Theoretical Computer Science: 5th GI-Conference, Karlsruhe, volume 104 of LNCS, pages 167 183, \nBerlin, Heidelberg, and New York, March 1981. Springer-Verlag. [24] Yann R\u00b4egis-Gianas and Franc\u00b8ois \nPottier. A Hoare logic for call-by\u00advalue functional programs. In MPC, July 2008. [25] Matthieu Sozeau. \nProgram-ing .nger trees in coq. SIGPLAN Not., 42(9):13 24, 2007. [26] Karen Zee, Viktor Kuncak, and Martin \nRinard. An integrated proof language for imperative programs. In PLDI, 2009.    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>This paper describes CFML, the first program verification tool based on characteristic formulae. Given the source code of a pure Caml program, this tool generates a logical formula that implies any valid post-condition for that program. One can then prove that the program satisfies a given specification by reasoning interactively about the characteristic formula using a proof assistant such as Coq. Our characteristic formulae improve over Honda <i>et al's total characteristic assertion pairs</i> in that they are expressible in standard higher-order logic, allowing to exploit them in practice to verify programs using existing proof assistants. Our technique has been applied to formally verify more than half of the content of Okasaki's <i>Purely Functional Data Structures</i> reference book</p>", "authors": [{"name": "Arthur Chargu&#233;raud", "author_profile_id": "81372592434", "affiliation": "INRIA, Rocquencourt, France", "person_id": "P2338227", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863590", "year": "2010", "article_id": "1863590", "conference": "ICFP", "title": "Program verification through characteristic formulae", "url": "http://dl.acm.org/citation.cfm?id=1863590"}