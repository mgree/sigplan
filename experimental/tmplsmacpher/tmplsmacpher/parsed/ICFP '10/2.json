{"article_publication_date": "09-27-2010", "fulltext": "\n Functional Pearl: Every Bit Counts Dimitrios Vytiniotis Andrew J. Kennedy Microsoft Research, Cambridge, \nU.K. Microsoft Research, Cambridge, U.K. dimitris@microsoft.com akenn@microsoft.com Abstract We show \nhow the binary encoding and decoding of typed data and typed programs can be understood, programmed, \nand veri.ed with the help of question-answer games. The encoding of a value is determined by the yes/no \nanswers to a sequence of questions about that value; conversely, decoding is the interpretation of binary \ndata as answers to the same question scheme. We introduce a general framework for writing and verifying \ngame\u00adbased codecs. We present games for structured, recursive, poly\u00admorphic, and indexed types, building \nup to a representation of well-typed terms in the simply-typed .-calculus. The framework makes novel \nuse of isomorphisms between types in the de.nition of games. The de.nition of isomorphisms together with \nadditional simple properties make it easy to prove that codecs derived from games never encode two distinct \nvalues using the same code, never decode two codes to the same value, and interpret any bit sequence \nas a valid code for a value or as a pre.x of a valid code. Categories and Subject Descriptors D.1.1 [Programming \nTech\u00adniques]: Applicative (Functional) Programming; D.3.3 [Program\u00adming Languages]: Language Constructs \nand Features; E.4 [COD-ING AND INFORMATION THEORY]: [Data compaction and com\u00adpression] General Terms \nDesign, Languages, Theory 1. Introduction Let s play a guessing game: I am a simply-typed program.1 Can \nyou guess which one? Are you a function application? No. You must be a function. Is your argument a Nat? \nYes. Is your body a variable? No. Is your body a function application? No. It must be a function. Is \nits argument a Nat? Yes. Is its body a variable? Yes. 1 A closed program in the simply-typed .-calculus \nwith types t ::= Nat |t . t and terms e ::= x | ee | .x:t.e, identi.ed up to a-equivalence. We have deliberately \nimpoverished the language for simplicity of presen\u00adtation; in practice there would also be constants, \nprimitive operations, and perhaps other constructs. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright \n&#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 c Is it bound by the nearest .? No. You must \nbe .x:Nat..y:Nat.x. You re right! From the answer to the .rst question, we know that the program is \nnot a function application. Moreover, the program is closed, and so it must be a .-abstraction; hence \nwe proceed to ask new questions about the argument type and body. We continue asking questions until \nwe have identi.ed the program. In this example, we asked just seven questions. Writing 1 for yes, and \n0 for no, our answers were 0100110. This is a code for the program .x:Nat..y:Nat.x. By deciding a question \nscheme for playing our game we ve thereby built an encoder for programs. By interpreting a bit sequence \nas answers to that same scheme, we have a decoder. Correct round\u00adtripping of encoding and decoding follows \nautomatically. If, as in this example, we never ask silly questions that reveal no new information, then \nevery code represents some value, or is the pre.x of a valid code. In other words, every bit counts. \nRelated ideas have previously appeared in domain-speci.c work; tamper-proof bytecode [10, 13] and compact \nproof witnesses in proof carrying code [18]. In the latter case, an astonishing improve\u00adment of a factor \nof 30 in proof witness size is reported compared to previous syntactic representations! By contrast, \nstandard serial\u00adization techniques do not easily guarantee tamper-proof codes, nor take advantage of \nsemantic information to yield more compact en\u00addodings. Our paper identi.es and formalizes a key intuition \nbehind those works: question-and-answer games. Moreover, we take a novel typed approach to codes, using \ntypes for domains of values, and representing the partitioning of the domain by type isomorphisms. Concretely, \nour contributions are as follows: We introduce question-answer games for encoding and decod\u00ading: a novel \nway to think about and program codecs (Section 2). We build simple codecs for numeric types, and provide \ncombi\u00adnators that construct complex games from simpler ones, pro\u00adducing coding schemes for structured, \nrecursive, polymorphic, and indexed types that are correct by construction.  Under easily-stated assumptions \nconcerning the structure of games, we prove round-trip properties of encoding and decod\u00ading, and the \nevery bit counts property of the title (Section 3).  We develop more sophisticated codecs for abstract \ntypes such as sets and multisets, making crucial use of the invariants asso\u00adciated with such types (Section \n4).  We build games for untyped and simply-typed terms that yield every-bit-counts coding schemes (Section \n5). Stated plainly: we can represent programs such that every suf.ciently-long bit string represents \na well-typed term. To our knowledge, this is the .rst such coding scheme for a typed language that has \nbeen proven correct.  We discuss .lters on games (Section 6). Finally, we discuss future developments \nand present connections to related work (Sections 7 and 8).   Figure 1: Unary game for naturals We \nwill be using Haskell (for readability, familiarity, and exe\u00adcutability) but the paper is accompanied \nby a partial Coq formal\u00adization (for correctness) downloadable from: http://research.microsoft.com/people/dimitris/ \nThe correctness and compactness properties of our coding schemes follow by construction in our Coq development, \nand by very local\u00adized reasoning in our Haskell code. We make use of in.nite struc\u00adtures, utilizing laziness \nin Haskell (and co-induction in Coq), but the code should adapt to call-by-value languages through the \nuse of thunks. 2. From games to codecs We can visualize question-and-answer games graphically as binary \ndecision trees. Figure 1 visualizes a (na\u00a8ive) game for natural numbers. Each rect\u00adangular node contains \na question, with branches to the left for yes and right for no. Circular leaf nodes contain the .nal \nresult that has been determined by a sequence of questions asked on a path from the root. Arcs are labelled \nwith the knowledge at that point in the game, characterised as subsets of the original domain. Let s \ndry-run the game. We start at the root knowing that we re in the set {n | n 0}. First we ask whether \nthe number is exactly 0 or not. If the answer is yes we continue on the left branch and immediately reach \na leaf that tells us that the result is 0. If the answer is no then we continue on the right branch, \nknowing now that the number in hand is in the set {n | n 1}. The next question asks whether the number \nis exactly 1 or not. If yes, we are done, otherwise we continue as before, until the result is reached. \nFigure 2 shows a more interesting game for natural numbers in {0..15}. This game proceeds by asking whether \nthe number in hand is greater than the median element in the current range. For example, the .rst question \nasks of a number n whether n> 7, splitting the range into disjoint parts {8..15} and n .{0..7}. If n \n.{8..15} we play the game given by the left subtree. If n .{0..7} we play the game given by the right \nsubtree. In both games, the encoding of a value can be determined by labelling all left edges with 1 \nand all right edges with 0, and returning the path from the root to the value. Conversely, to decode, \nwe interpret the input bitstream as a path down the tree. So in the game of Figure 1, a number n . N \nis encoded in unary as n zeroes followed by a one, and in the game of Figure 2, a number n .{0..15} is \nencoded as 4-bit binary, as expected. For example, the encoding of 2 is 0010 and 3 is 0011. There is \none more difference between the two games: the game of Figure 1 is in.nite whereas the game of Figure \n2 is .nite. It s clear that question-and-answer games give rise to codes that are unambiguous: a bitstring \nuniquely determines a value. Moreover,  Figure 2: Binary game for {0..15} the one-question-at-a-time \nnature of games ensures that codes are pre.x-free: no code is the pre.x of any other valid code [19]. \nNotice two properties common to the games of Figure 1 and 2: every value in the domain is represented \nby some leaf node (we call such games total), and each question strictly partitions the domain (we call \nsuch games proper). Games satisfying both properties give rise to codecs with the following property: \nany bitstring of is a pre.x of or has a pre.x that is a code for some value. This is the every bit counts \nproperty of the title. In Section 3 we pin these ideas down with theorems. But how can we actually compute \nwith games? We ve explained the basic principles in terms of set membership and potentially in.nite trees, \nand we need to translate these ideas into code. We must represent in.nite games without constructing \nall the leaf nodes ahead-of-time. This is easy: just construct the game tree lazily.  We need something \ncorresponding to a set of possible values , which we ve been writing on the arcs in our diagrams. Types \nare the answer here, sometimes with additional implicit invariants; for example, in Haskell, Ints between \n4 and 7 .  We must capture the splitting of the domain into two disjoint  ~ parts. This is solved by \ntype isomorphisms of the form t = t1 + t2, with t1 representing the domain of the left subtree (corresponding \nto answering yes to the question) and t2 repre\u00adsenting the domain of the right subtree (corresponding \nto no). Lastly, we need a means of using this splitting to query the data (when encoding), and to construct \nthe data (when decoding). Type isomorphisms provide a very elegant solution to this task: we simply use \nthe maps associated with the isomorphism. Let s get concrete with some code, in Haskell! 2.1 Games in \nHaskell We ll dive straight in, with a data type for games: data Game :: * . * where Single :: ISO t \n() . Game t Split :: ISO t (Either t1 t2) . Game t1 . Game t2 . Game t A value of type Game t represents \na game (strictly speaking, a strategy for playing a game) for domain t. Its leaves are built with Single \nand represent singletons, and its nodes are built with Split and represent a splitting of the domain \ninto two parts. The leaves carry a representation of an isomorphism between t and (), Haskell s unit \ntype. The nodes carry a representation of an isomor\u00adphism between t and Either t1 t2 (Haskell s sum type), \nand two subtrees of type Game t1 and Game t2.2 What is ISO? It s just a pair of maps witnessing an isomorphism: \n--(Iso to from) must satisfy --left inverse: from . to =id --right inverse: to . from = id data ISOts=Iso \n{to::t . s,from :: s . t} In our Coq formalization, the ISO type also records proofs of the left inverse \nand right inverse properties. Without further ado we write a generic encoder and decoder, once and for \nall. We use Bit for binary digits rather than Bool so that output is more readable: data Bit=O|I Given \na Game t, here is an encoder for t: enc :: Game t . t . [Bit] enc (Single _) x = [] enc (Split (Iso ask \n_) g1 g2) x = case ask x of Left x1 . I : enc g1 x1 Right x2 . O : enc g2 x2 If the game we are playing \nis a Single leaf, then t must be a singleton, so we need no bits to encode t, and just return the empty \nlist. If the game is a Split node, we ask how x of type t can become either a value of type t1 or t2, \nfor some t1 and t2 that split type t disjointly in two. Depending on the answer we output I or O and \ncontinue playing either the sub-game g1 or g2. A decoder is also simple to write: dec :: Game t . [Bit] \n. (t, [Bit]) dec (Single (Iso _ bld)) str = (bld (), str) dec (Split _ _ _) [] = error \"Input too short\" \ndec (Split (Iso _ bld) g1 g2) (I : xs) = let (x1, rest) = dec g1 xs in (bld (Left x1), rest) dec (Split \n(Iso _ bld) g1 g2) (O : xs) = let (x2, rest) = dec g2 xs in (bld (Right x2), rest) The decoder accepts \na Game t and a bitstring of type [Bit]. If the input bitstring is too short to decode a value then dec \nraises an exception.3 Otherwise it returns a decoded value and the suf.x of the input list that was not \nconsumed. If the game is Single, then dec returns return the unique value in t by applying the inverse \nmap of the isomorphism on (). No bits are consumed, as no questions need answering! If the game is Split \nand the input list is non-empty then dec decodes the rest of the bitstring using either sub-game g1 or \ng2, depending on whether the .rst bit is O or I, building a value of t using the bld function of the \nisomorphism gadget.  2.2 Number games These simple de.nitions already suf.ce for a range of numeric \nencodings. We make the Haskell de.nition type Nat = Int to document that our integers are non-negative. \nWhere the Haskell type system isn t rich enough to express precise invariants, we will put Coq types \nin comments, lifted directly from our Coq development. 2 The type variables t1 and t2 are existential \nvariables, not part of vanilla Haskell 98, but supported by all modern Haskell compilers. 3 We could \nalternatively have dec return Maybe (t,[Bit]); this is indeed what our Coq formalization does. {x}~ \n= 1 singleIso :: a . ISO a() --. x:a,ISO{z| z=x} unit singleIso x = Iso (const ()) (const x) X ~ = Y \n+(X \\ Y ) splitIso :: (a . Bool) . ISO a (Either a a) --. p:a.bool, ISO a ({x|p x = true}+{x|p x = false}) \nsplitIso p = Iso ask bld where ask x = if p x then Left x else Right x bld x=case xof Lefty . y; Right \ny . y B ~ = 1 + 1 boolIso :: ISO Bool (Either () ()) boolIso = Iso ask bld where ask True = Left () ask \nFalse = Right () bld (Left ()) = True bld (Right ()) = False N ~ = 1 + N succIso :: ISO Nat (Either () \nNat) succIso = Iso ask bld where ask 0 = Left () ask (n+1) = Right n bld (Left ()) = 0 bld (Right n) \n= n+1 N ~ = N+ N parityIso :: ISO Nat (Either Nat Nat) parityIso = Iso (.n . if even n then Left(n div \n2) else Right(n div 2)) (.x . case x of Left m . m*2; Right m . m*2+1) X* ~ = 1 + X \u00d7 X* listIso :: ISO \n[t] (Either () (t,[t])) listIso = Iso ask bld where ask [] = Left () ask (x:xs) = Right (x,xs) bld (Left \n()) = [] bld (Right (x,xs)) = x:xs X* ~ =Sn : N.Xn depListIso :: ISO [t] (Nat,[t]) --ISO (list t) { \nn:nat &#38; t^n } depListIso = Iso ask bld where ask xs = (length xs, xs) bld (n,xs) = xs Figure 3: \nSome useful isomorphisms Unary naturals. The game of Figure 1 can be expressed as fol\u00adlows: geNatGame \n:: Nat . Game Nat --. k:nat,Game{x|x k} geNatGame k = Split (splitIso ((==) k)) (Single (singleIso k)) \n(geNatGame (k+1)) The function geNatGame returns a game for natural numbers greater than or equal to \nits parameter k. It consists of a Split node whose left subtree is a Singleton node for k, and whose \nright subtree is a game for values greater than or equal to k+1. The isomorphisms singleIso and splitIso \nare used to express singleton values and a partitioning of the set of values respectively. Their signatures \nand de.nitions are presented in Figure 3, along with some other basic isomorphisms that we shall use \nthroughout the paper. In this game, the isomorphisms just add clutter to the code: one might ask why \nwe didn t de.ne a Game type with elements at the leaves and simple predicates in the nodes. But isomorphisms \nshow their true colours when they are used to map between different representations or possibly even \ndifferent types of data. Unary naturals, revisited. Consider this alternative game for nat\u00adural numbers: \nunitGame :: Game () unitGame = Single (Iso id id) unaryNatGame :: Game Nat unaryNatGame = Split succIso \nunitGame unaryNatGame This time we re exploiting the isomorphism N ~1 + N, pre\u00ad = sented in Figure 3. \nLet s see how it s used in the game. When en\u00adcoding a natural number n, we ask whether it s zero or not \nusing the forward map of the isomorphism to get answers of the form Left () or Right (n - 1), that capture \nboth the yes/no answer to the question and data with which to continue playing the game. If the answer \nis Left () then we just play the trivial unitGame on the value (), otherwise we have Right (n - 1) and \nplay the very same unaryNatGame for the value n - 1. When decoding, we apply the inverse map of the isomorphism \nto build data with Left () or Right x as determined by the next bit in the input stream. We can test \nour game using the generic enc and dec functions: > enc unaryNatGame 3 [O,O,O,I] > enc unaryNatGame 2 \n[O,O,I] > dec unaryNatGame [O,O,I] Just (2,[]) Finite ranges. How about the range encoding for natural \nnum\u00adbers, sketched in Figure 2? That s easy: rangeGame :: Nat . Nat . Game Nat --. mn:nat,Game{ x|m : \nx&#38;&#38; x : n} rangeGame m n | m == n = Single (singleIso m) rangeGame m n = Split (splitIso (.x \n. x > mid)) (rangeGame (mid+1) n) (rangeGame m mid) where mid = (m + n) div 2 Let s try it out: > enc \n(rangeGame 0 15) 5 [O,I,O,I] > dec (rangeGame 0 15) [O,I,O,I] (5,[]) Binary naturals. The range encoding \nresults in a logarithmic coding scheme, but only works for naturals in a .nite range. Can we give a general \nlogarithmic scheme for arbitrary naturals? Yes, and here is the protocol: we .rst ask if the number n \nis 0 or not, making use of succIso again. If yes, we are done. If not, we ask whether n - 1 is divisible \nby 2 or not, making use of parityIso from Figure 3 that captures the isomorphism N ~N+ N. Here is = the \ncode: binNatGame :: Game Nat binNatGame = Split succIso unitGame (Split parityIso binNatGame binNatGame) \nWe can test this game; for example: > enc binNatGame 8 [O,O,O,I,O,I,I] > dec binNatGame [O,O,O,I,O,I,I] \nJust (8,[]) > enc binNatGame 16 [O,O,O,I,O,I,O,I,I] After staring at the output for a few moments one \nobserves that the encoding takes double the bits (plus one) that one would expect for a logarithmic code. \nThis is because before every step, an extra bit is consumed to check whether the number is zero or not. \nThe .nal extra I terminates the code. In the next section we explain how the extra bits result in pre.x \ncodes, a property that our methodology is designed to validate by construction. The accompanying Haskell \ncode gives additional examples of games for natural numbers, including Elias codes [8], as well as codes \nbased on prime factorization. 2.3 Game combinators To build games for structured types we provide combinators \nthat construct complex games from simple ones. Constant. Our .rst combinator is trivial, making use of \nthe iso\u00admorphism between the unit type and singletons. constGame :: t . Game t --. (k:t), Game { x | \nx=k } constGame k = Single (singleIso k) Cast. The combinator (+>) transforms a game for t into a game \nfor s, given that s is isomorphic to t. (+>) :: Game t . ISO s t . Game s (Single j) +> i = Single (i \nseqI j) (Split j g1 g2) +> i = Split (i seqI j) g1 g2 What is seqI? It is a combinator on isomorphisms, \nwhich wires two isomorphisms together. In fact, combining isomorphisms together in many ways is generally \nuseful, so we de.ne a small library of isomorphism combinators. Their signatures are given in Figure \n4 and their implementation (and proof) is entirely straightforward. Choice. It s dead easy to construct \na game for the sum of two types, if we are given games for each. The sumGame combinator is so simple \nthat it hardly has a reason to exist as a separate de.nition: sumGame :: Game t . Game s . Game (Either \nt s) sumGame = Split idI Composition. Suppose we are given a game g1 of type Game t and a g2 of type \nGame s. How can we build a game for the product (t,s)? A simple strategy is to play g1, the game for \nt, and at the leaves play g2, the game for s. Graphically, if g1 looks like the tree on the left, below, \ncomposing it with g2 produces the tree on the right.  ... . .. =. . g2 . .. .. .. . . .. g2 The prodGame \ncombinator achieves this, as follows: prodGame :: Game t . Game s . Game (t,s) prodGame (Single iso) \ng2 = g2 +> prodI iso idI seqI prodLUnitI prodGame (Split iso g1a g1b) g2 = Split (prodI iso idI seqI \nprodLSumI) (prodGame g1a g2) (prodGame g1b g2)   A ~= A idI :: ISO a a A ~= B . B ~= A invI :: ISO \na b .ISO b a A ~= B . B ~= C . A ~= C seqI :: ISO a b .ISO b c .ISO a c A ~= B . C ~= D . A \u00d7 C ~= B \n\u00d7 D prodI :: ISO a b .ISO c d .ISO (a,c) (b,d) A ~= B . C ~= D . A + C ~= B + D sumI :: ISO a b .ISO \nc d .ISO (Either a c) (Either b d) A \u00d7 B ~= B \u00d7 A swapProdI :: ISO (a,b) (b,a) A + B ~= B + A swapSumI \n:: ISO (Either a b) (Either b a) A \u00d7 (B \u00d7 C) ~= (A \u00d7 B) \u00d7 C assocProdI :: ISO (a,(b,c)) ((a,b),c) A + \n(B + C) ~= (A + B) + C assocSumI :: ISO (Either a (Either b c)) (Either (Either a b) c) 1 \u00d7 A ~= A prodLUnitI \n:: ISO ((),a) a A \u00d7 1 ~= A prodRUnitI :: ISO (a,()) a A \u00d7 (B + C) ~= (A \u00d7 B) + (A \u00d7 C) prodRSumI :: ISO \n(a,Either b c) (Either (a,b) (a,c)) (B + C) \u00d7 A ~= (B \u00d7 A) + (C \u00d7 A) prodLSumI :: ISO (Either b c,a) \n(Either (b,a) (c,a)) Figure 4: Isomorphism combinator signatures If the game for t is a singleton node, \nthen we play g2, which is the game for s. However, that will return a Game s, whereas we d like a Game \n(t,s). But from the type of the Single constructor we know that t is the unit type (), and so we coerce \ng2 to the appropri\u00adate type using combinators from Figure 4 to construct an isomor\u00adphism between s and \n((),s). In the case of a Split node, we are given an isomorphism iso of type ISO t (Either t1 t2) for \nun\u00adknown types t1 and t2, and we create a new Split node whose subtrees are constructed recursively, \nand whose isomorphism of type ISO (t,s) (Either (t1,s) (t2,s)) is again constructed us\u00ading the combinators \nfrom Figure 4. Lists. What can we do with prodGame? We can build more com\u00adplex combinators, such as the \nfollowing recursive lstGame that en\u00adcodes lists: listGame :: Game t . Game [t] listGame g = Split listIso \nunitGame (prodGame g (listGame g)) It takes a game for t and produces a game for lists of t. The question \nasked by listIso is whether the list is empty or not. If empty then we play the left sub-game a singleton \nnode and if non-empty then we play the right sub-game, consisting of a game for the head of the list \nfollowed by the list game for the tail of the list. This is just the product prodGame g (listGame g). \nComposition by interleaving. Recall that prodGame pastes copies of the second game in the leaves of the \n.rst game. An alternative approach is to interleave the bits of the two games. We illustrate this graphically, \nstarting with example games given below: A2 Interleaving the two games, starting with the left-hand \ngame gives: B2 A2 A2  B2 B2 B1   The ilGame below does that by playing a bit from the game on the \nleft, but always .ipping the order of the games in the recur\u00adsive calls. Its de.nition is similar to \nprodGame, with isomorphism plumbing adjusted appropriately: ilGame :: Game t . Game s . Game (t,s) ilGame \n(Single iso) g2 = g2 +> prodI iso idI seqI prodLUnitI ilGame (Split iso g1a g1b) g2 = Split (swapProdI \nseqI prodI idI iso seqI prodRSumI) (ilGame g2 g1a) (ilGame g2 g1b) The resulting encoding of product \nvalues of course differs between ilGame and prodGame, although it will use exactly the same number of \nbits. Dependent composition. Suppose that, after having decoded a value x of type t, we wish to play \na game whose strategy depends on x. For example, given a game for natural numbers, and a game for lists \nof a particular size, we could create a game for arbitrary lists paired up with their size. We can do \nthis with the help of a dependent composition game combinator. depGame :: Game t . (t . Game s) . Game \n(t,s) --Game t . (. x:t, Game(s x)) . Game {x:t &#38; s x} depGame (Single iso) f = f (from iso ()) +> \nprodI iso idI seqI prodLUnitI depGame (Split iso g1a g1b) f = Split (prodI iso idI seqI prodLSumI) (depGame \ng1a (f . from iso . Left)) (depGame g1b (f . from iso . Right)) The de.nition of depGame resembles the \nde.nition of prodGame, but notice how in the Single case we apply the f function to the singleton value \nto determine the game we must play next. Lists, revisited. We can use depGame to create an alternative \nen\u00adcoding for lists. Suppose we are given a function vecGame :: Game t . Nat . Game [t] --Game t .. n:nat, \nGame t^n that builds a game for lists of the given length. Its de.nition should be straightforward and \nwe leave it as an exercise for the reader. We can then de.ne a game for lists paired with their length, \nand use the isomorphism depListIso from Figure 3 to derive a new game for lists, as follows: listGame \n:: Game t . Game [t] listGame g = depGame binNatGame (vecGame g) +> depListIso  3. Properties of games \nPearly code is all very well, but is it correct? In this section we study the formal properties of game-derived \ncodecs, proving basic correctness and termination results, and also the every bit counts property of \nthe title. All theorems have been proved formally using the Coq proof assistant. 3.1 Correctness The \nfollowing round-trip property follows directly from the left inverse property of isomorphisms embedded \ninside the games. LEMMA 1 (Enc/Dec). Suppose g : Game t and x : t. If enc gx = e then dec g (e ++ es)=(x, \nes). The lemma asserts that if x encodes to a bitstring e, then the decod\u00ading of any extension of e returns \nx together with the extension. The literature on coding theory [19] emphasizes the essential prop\u00aderty \nof codes being unambiguous: no two values are assigned the same code. This follows directly from Lemma \n1. COROLLARY 1 (Unambiguous codes). Suppose g : Game t and v, w : t. If enc gv = e and enc gw = e then \nv = w. A stronger property that implies unambiguity is pre.x-freedom: no pre.x of a valid code can itself \nbe a valid code. For pre.x codes, we can stop decoding at the .rst successfully decoded value: no look\u00adahead \nis required. This property also follows from Lemma 1, or can be proved directly from the de.nition of \nenc. COROLLARY 2 (Pre.x encoding). Suppose g : Game t and v, w : t. If enc gv = e and enc gw = e ++ es \nthen v = w. It is worth pausing for a moment to return brie.y to the game binNatGame from Section 2.1. \nObserve that the standard binary encoding for natural numbers is not a pre.x code. For example the encoding \nof 3 is 11 and the encoding of 7 is 111. The extra bits inserted by binNatGame are necessary to convert \nthe standard encoding to one which is a pre.x encoding. The anticipated down\u00adside are the inserted terminator \nbits that double the size of the encoding (but keeping it T(log n)).  3.2 Termination A close inspection \nof Lemma 1 reveals that the property is con\u00additional on the termination of the encoder. Although in traditional \ncoding theory termination of encoding for any value is taken for granted, it doesn t follow automatically \nfor our game-based codecs. Here is a problematic example of a somewhat funny game for the type Maybe \nNat, appearing in Figure 5. At step i, the game asks whether the value in hand is Some i, or any other \nvalue in the type Maybe Nat. Notice that when asked to encode a value Nothing the encoder will simply \nplay the game for ever, diverging. That s certainly no good! Fortunately, we can require games to be \ntotal, meaning that every element in the domain is represented by some leaf node. DEFINITION 1 (Totality). \nA game g of type Game t is total iff for every value x of type t, there exists a .nite path g x, where \nis inductively de.ned below: g1 x1 Single (Iso ab) b () Split (Iso ab) g1 g2 b (Left x1) g2 x2 Split \n(Iso ab) g1 g2 b (Right x2)  Figure 5: Game for optional naturals The reader can check that, with the \nexception of the game in Figure 5, the games presented so far are total; furthermore the combinators \non games preserve totality. LEMMA 2 (Termination). Suppose g : Game t. If g is total then enc g terminates \non all inputs. 3.3 Compactness Lemma 1 guarantees basic correctness of game-based codes.4 But we can \ngo further, and show how to construct codecs for which every bit counts, i.e. there are no wasted bits. \nConsider the following trivial codec for booleans: boolGame :: Game Bool boolGame = Split boolIso unitGame \nunitGame It encodes False as 0, as True as 1. You can t do better than that! Now consider a codec in \nwhich both 00 and 01 code for False, and 10 and 11 code for True. The second bit of this code is wasted, \nas the .rst bit uniquely determines the value. Fortunately, correct construction of game guarantees not \nonly that two values will never be assigned the same code, but also that two codes cannot represent the \nsame value. We show this by .rst proving another round-trip property that follows directly from the right \ninverse property of isomorphisms. LEMMA 3 (Dec/Enc). Suppose g : Game t. If dec ge =(x, es) then there \nexists ep such that enc gx = ep and ep ++ es = e. Injectivity of decoding is a simple corollary. COROLLARY \n3 (Non-redundancy). Suppose dec ge1 =(x, []) and dec ge2 =(x, []). Then e1 = e2. Unfortunately non-redundancy \ndoesn t tell us that every bit counts. Consider a slight variation on the wasteful encoding of booleans \nabove in which True is encoded as 11 and False as 00, and 01 and 10 are simply invalid. This corresponds \nto a question-answer game in which the question Are you True? is asked twice. We can write such a game, \nas follows: --precondition: t is uninhabited voidGame :: Game t voidGame = Split (splitIso (const True)) \nvoidGame voidGame badBoolGame :: Game Bool badBoolGame = Split (splitIso id) (Split (splitIso id) (constGame \nTrue) voidGame) (Split (splitIso id) voidGame (constGame False)) 4 But, to be fair, sometimes lossy \ncoding may be acceptable; for instance in video codecs. It may take a little head-scratching to work \nout what s going on: the question expressed with splitIso id asks whether a boolean value is True or \nFalse and goes Left or Right respectively. But in both branches we ask the same question again, though \nwe re now in a singleton set. Here s a session that illustrates the badBoolGame behaviour: > enc badBoolGame \nFalse [O,O] > enc badBoolGame True [I,I] > dec badBoolGame [O,I] (False,*** Exception: Input too short \n> dec badBoolGame [I,O] (True,*** Exception: Input too short The .rst question asked by the game effectively \npartitions the booleans into {False} and {True}. But these are singletons, so any further questions would \nnot reveal further information. If we do ask a question, using Split, then one branch must be dead, i.e. \nhave a domain that is not inhabited hence the use of voidGame in the code. For domains more complex \nthan Bool, such non-revealing ques\u00adtions are harder to spot. Suppose, for example, that in the game for \nprograms described in the introduction, the .rst question had been Are you a variable? Because we know \nthat the program under in\u00adspection is closed, this question is silly, and we already know that the answer \nis no. We call a game proper if every isomorphism in Split nodes is a proper splitting of the domain. \nEquivalently, we make the following de.nition. DEFINITION 2 (Proper games). A game g of type Game t is \nproper iff for every subgame g' of type Game s, type s is inhabited. It is immediate that voidGame is \nnot a proper game and conse\u00adquently badBoolGame is not proper either. Codecs associated with proper games \nhave a very nice property that justi.es the slogan every bit counts: every possible bitstring either \ndecodes to a unique value, or is the pre.x of such a bitstring. LEMMA 4 (Every bit counts). Let g be \na proper and total Game t. Then, if dec ge fails then there exists es and a value x of type t such that \nenc gx = e ++ es. The careful reader will have observed that this lemma requires that the game be not \nonly proper, but also total. Consider the following variation of binNatGame from Section 2.2. badNatGame \n:: Game Nat badNatGame = Split parityIso badNatGame badNatGame The question asked splits the input set \nof all natural numbers into two disjoint and inhabited sets: the even and the odd ones. However, there \nare no singleton nodes in badNatGame and hence Lemma 4 cannot hold for this game. As a .nal observation, \nnotice that even in a total and proper game with in.nitely many leaves (such as the natural numbers game \nin Figure 1) there will be an in.nite number of bit strings on which the decoder fails. By K\u00a8 onig s \nlemma, in such a game there must exist at least one in.nite path, and the decoder will fail on all pre.xes \nof that path.  3.4 Summary Here is what we have learned in this section. Games constructed from valid \nisomorphisms give rise to codes that are unambiguous, pre.x-free, non-redundant, and which satisfy a \nbasic round-trip correctness property.  The encoder terminates if and only if the game is total.  If \nadditionally the game is proper then every bitstring encodes some value or is the pre.x of such a bitstring. \n  For the the rest of this paper we embark in giving more ambitious and amusing concrete games for sets \nand .-terms. 4. Sets and multisets So far we have considered primitive and structured data types such \nas natural numbers, lists and trees, for which games can be constructed in a type-directed fashion. Indeed, \nwe could even use generic programming techniques [12, 14] to generate games (and thereby codecs) automatically \nfor such types. But what about other structures such as sets, multisets or maps, in which implicit invariants \nor equivalences hold, and which our games could be made aware of? For example, consider representing \nsets of natural numbers using lists. We know (a) that duplicate ele\u00adments do not occur, and (b) that \nthe order doesn t matter when con\u00adsidering a list-as-a-set. We could use listGame binNatGame for this \ntype. It would satisfy the basic round-tripping property (Enc/Dec); however, bits would be wasted in \nassigning distinct codes to equivalent values such as [1,2] and [2,1], and in assigning codes to non-values \nsuch as [1,1]. In this section we show how to represent sets and multisets ef.\u00adciently. First, we consider \nthe speci.c case of sets and multisets of natural numbers, for which we can hand-craft a delta encoding \nin which every bit counts. Next, we show how for arbitrary types we can use an ordering on values induced \nby the game for the type to construct a game for sets of elements of that type. 4.1 Hand-crafted games \nHow can we encode the multiset {3, 6, 5, 6}? We might start by or\u00addering the values to obtain the canonical \nrepresentation [3, 5, 6, 6]. But now imagine encoding this using a vanilla list of natural num\u00adbers game \nlistGame binNatGame: when encoding the second ele\u00adment, we would be wasting the codes for values 0, 1, \nand 2, as none of these values can possibly follow 3 in the ordering. So instead of encoding the value \n5 for the second element of the ordered list, we encode 2, the difference between the .rst two elements. \nDoing the same thing for the other elements, we obtain the list [3, 2, 1, 0], which we can encode using \nlistGame binNatGame without wasting any bits. To decode, we reverse the process and add the difference. \nWe can apply the same delta idea for sets, except that the delta is smaller by one, taking account of \nthe fact that the difference between successive elements must be non-zero. In Haskell, we implement diff \nand undiff functions that respec\u00adtively compute and apply difference lists. diff minus [] = [] diff minus \n(x:xs) = x : diff x xs where diff base [] = [] diff base (x:xs) = minus x base : diff x xs undiff plus \n[] = [] undiff plus (x:xs) = x : undiff x xs where undiff base [] = [] undiff base (x:xs) = base : undiff \nbase xs where base = plus base x The functions are parameterized on subtraction and addition oper\u00adations, \nand are instantiated with appropriate concrete operations to obtain games for .nite multisets and sets \nof natural numbers, as follows: natMultisetGame :: Game Nat . Game [Nat] natMultisetGame g = listGame \ng +> Iso (diff (-) . sort) (undiff (+)) natSetGame :: Game Nat . Game [Nat] natSetGame g = listGame \ng +> Iso (diff (. xy . x-y-1) . sort) (undiff (. xy . x+y+1)) Here is the multiset game in action, using \nour binary encoding of natural numbers on the example multiset {3, 6, 5, 6}. > enc (listGame binNatGame) \n[3,6,5,6] [O,O,I,O,I,I,O,O,O,O,O,I,O,O,I,O,O,I,O,O,O,O,I,I,I] > enc (natMultisetGame binNatGame) [3,6,5,6] \n[O,O,I,O,I,I,O,O,O,I,O,O,I,I,O,I,I] > dec (natMultisetGame binNatGame) it ([3,5,6,6],[]) As expected, \nthe encoding is more compact than a vanilla list representation. Observe that here the round-trip property \nholds up to equivalence of lists when interpreted as multisets: encoding [3,6,5,6] and then decoding \nit results in an equivalent but not identical value [3,5,6,6].  4.2 Generic games That s all very well, \nbut what if we want to encode sets of pairs, or sets of sets, or sets of .-terms? First of all, we need \nan ordering on elements to derive a canonical list representation for the set. Conveniently, the game \nfor the element type itself gives rise to natural comparison and sorting functions: compareByGame :: \nGame a . (a . a . Ordering) compareByGame (Single _) x y = EQ compareByGame (Split (Iso ask bld) g1 g2) \nx y = case (ask x, ask y) of (Left x1 , Left y1) . compareByGame g1 x1 y1 (Right x2, Right y2) . compareByGame \ng2 x2 y2 (Left x1, Right y2) . LT (Right x2, Left y1) . GT sortByGame :: Game a . [a] . [a] sortByGame \ng = sortBy (compareByGame g) We can then use the list game on a sorted list, but at each successive \nelement adapt the element game so that impossible elements are excluded. To do this, we write a function \nremoveLE that removes from a game all elements smaller than or equal to a particular element, with respect \nto the ordering induced by the game. If the resulting game would be empty, then the function returns \nNothing. removeLE :: Game a . a . Maybe (Game a) removeLE (Single _) x = Nothing removeLE (Split (Iso \nask bld) g1 g2) x = case ask x of Left x1 . case removeLE g1 x1 of Nothing . Just (g2 +> rightI) Just \ng1 . Just (Split (Iso ask bld) g1 g2) Right x2 . case removeLE g2 x2 of Nothing . Nothing Just g2 . Just \n(g2 +> rightI) where rightI = Iso (.x . case ask x of Right y . y) (bld . Right) The code for listGame \ncan then be adapted to do sets: setGame :: Game a . Game [a] setGame g = setGame g +> Iso (sortByGame \ng) id where setGame g = Split listIso unitGame $ depGame g $ .x . case removeLE g x of Just g . setGame \ng Nothing . constGame [] Notice the dependent composition, which, once a value is deter\u00admined plays \nthe game having removed all smaller elements from it.5 5. Codes for programs We re now ready to return \nto the problem posed in the introduction: how to construct games for programs. As with the games for \nsets described in the previous section, the challenge is to devise games that satisfy the every-bit-counts \nproperty, so that any string of bits represents a unique well-typed program, or is the pre.x of such \na code. 5.1 No types First let s play a game for the untyped .-calculus, declared as a Haskell datatype \nusing de Bruijn indexing for variables: data Exp = Var Nat | Lam Exp | App Exp Exp For any natural number \nn the game expGame n asks questions of expressions whose free variables are in the range 0 to n - 1. \nexpGame :: Nat . Game Exp expGame 0 = appLamG 0 expGame n = Split (Iso ask bld) (rangeGame 0 (n-1)) (appLamG \nn) where ask (Var i) = Left i aske =Right e bld (Left i) = Var i bld (Right e) = e If n is zero, then \nthe expression cannot be a variable, so expGame immediately delegates to appLamG that deals with expressions \nknown to be non-variables. Otherwise, the game is Split between variables (handled by rangeGame from \nSection 2) and non-variables (handled by appLamG). The auxiliary game appLamG n works by splitting between \napplication and lambda nodes: appLamG n = Split (Iso ask bld) (prodGame (expGame n) (expGame n)) (expGame \n(n+1)) where ask (App e1 e2) = Left (e1,e2) ask (Lam e) = Right e bld (Left (e1,e2)) = App e1 e2 bld \n(Right e) = Lam e For application terms we play prodGame for the applicand and applicator. For the body \nof a .-expression the game expGame (n+1) is played, incrementing n by one to account for the bound variable. \nLet s run the game on the expression IK where I = .x.x and K = .x..y.x. > let tmI = Lam (Var 0) > let \ntmK = Lam (Lam (Var 1)) > enc (expGame 0) (App tmI tmK) [O,I,O,I,I,I,O,I] > dec (expGame 0) it (App (Lam \n(Var 0)) (Lam (Lam (Var 1))),[]) It s easy to validate by inspection the isomorphisms used in expGame. \nIt s also straightforward to prove that the game is total and proper. 5 The $ notation is just Haskell \nsyntactic sugar that allows applications to be written with fewer parentheses: f (h g) can be written \nas f$hg. x:t . GG e1 : t1 . t2 G e2 : t1 VAR APP G x : t G e1 e2 : t2 G,x:t1 e : t2 LAM G .x:t1.e : \nt1 . t2 Figure 6: Simply-typed .-calculus  5.2 Simple types We now move to the simply-typed .-calculus, \nwhose typing rules are shown in conventional form in Figure 6. In Haskell, we de.ne a data type Ty for \ntypes and Exp for ex\u00adpressions, differing from the untyped language only in that .\u00adabstractions are annotated \nwith the type of the argument: data Ty = TyNat | TyArr Ty Ty deriving (Eq, Show) data Exp = Var Nat | \nLam Ty Exp | App Exp Exp Type environments are just lists of types, indexed de Bruijn-style. It s easy \nto write a function typeOf that determines the type of an open expression under some type environment \n assuming that it is well-typed to start with. type Env = [Ty] typeOf :: Env . Exp . Ty typeOf env (Var \ni) = env !! i typeOf env (App e _) = let TyArr _ t = typeOf env e in t typeOf env (Lam t e) = TyArr t \n(typeOf (t:env) e) We d like to construct a game for expressions that have type t under some environment \nenv. If possible, we d like the game to be proper. But wait: there are combinations of env and t for \nwhich no expression even exists, such as the empty environment and the type TyNat. We could perhaps impose \nan inhabitation precondition on the parameters of the game. But this only pushes the problem into the \ngame itself, with sub-games solving inhabitation problems lest they ask super.uous questions and so be \nnon-proper. As it happens, type inhabitation for the simply-typed .-calculus is decidable but PSPACE-complete \n[20], which serves to scare us off! We can make things easier for ourselves by solving a different problem: \n.x the type environment env (as before), but instead of .xing the type as previously, we will instead \n.x a pattern of the form t1 . \u00b7 \u00b7\u00b7 . tn . ? where ? is a wildcard standing for any type. It s easy to \nshow that for any environment env and pattern there exists an expression typeable under env whose type \nmatches the pattern. We can de.ne such patterns using a data type Pat, and write a function that determines \nwhether or not a type matches a pattern. data Pat = Any | PArr Ty Pat matches :: Pat . Ty . Bool matches \nAny _ = True matches (PArr t p) (TyArr t1 t2) = t1==t &#38;&#38; matches p t2 matches _ _ = False Now \nlet s play some games. Types are easy: tyG :: Game Ty tyG = Split (Iso ask bld) unitGame (prodGame tyG \ntyG) where ask TyNat = Left () ask (TyArr t1 t2) = Right (t1,t2) bld (Left ()) = TyNat bld (Right (t1,t2)) \n= TyArr t1 t2 To de.ne a game for typed expressions we start with a game for variables. The function \nvarGame below accepts a predicate Ty . Bool and an environment, and returns a game for all those indices \n(of type Nat) whose type in the environment matches the predicate. varGame :: (Ty . Bool) . Env . Maybe \n(Game Nat) varGame f [] = Nothing varGame f (t:env) = case varGame f env of Nothing . if f t then Just \n(constGame 0) else Nothing Just g . if f t then Just (Split succIso unitGame g) else Just (g +> Iso pred \nsucc) Notice that varGame returns Nothing when no variable in the envi\u00adronment satis.es the predicate. \nIn all other cases it traverses the in\u00adput environment. If the .rst type in the input environment matches \nthe predicate and there is a possibility for a match in the rest of the input environment varGame returns \na Split that witnesses this possible choice. It is easy to see that when varGame returns some game, that \ngame will be proper. The function expGame accepts an environment and a pattern and returns a game for \nall expressions that are well-typed under the environment and whose type matches the pattern. expGame \n:: Env . Pat . Game Exp --. (env:Env) (p:Pat), --Game{e| . t, env f e:t&#38;&#38;matches pt =true } expGame \nenv p = case varGame (matches p) env of Nothing . appLamG Just varG . Split varI varG appLamG where appLamG \n= Split appLamI appG (lamG p) appG = depGame (expGame env Any) $ .e . expGame env (PArr (typeOf env e) \np) lamG (PArr t p) = prodGame (constGame t) $ expGame (t:env) p lamG Any = depGame tyG $ .t . expGame \n(t:env) Any varI = Iso ask bld where ask (Var x) = Left x aske =Right e bld (Left x) = Var x bld (Right \ne) = e appLamI = Iso ask bld where ask (App e1 e2) = Left (e2,e1) ask (Lam t e) = Right (t,e) bld (Left \n(e2,e1)) = App e1 e2 bld (Right (t,e)) = Lam t e The expGame function .rst determines whether the expression \ncan possibly be a variable, by calling varGame. If this is not possible (case Nothing) the game proceeds \nwith appLamG that will deter\u00admine whether the non-variable expression is an application or a .\u00adabstraction. \nIf the expression can be a variable (case Just varG) then we may immediately Split with varI by asking \nif the expres\u00adsion is a variable or not it not we may play appLamG as in the .rst case. The appLamG \ngame uses appLamI to ask whether the expres\u00adsion is an application, and then plays game appG; or a .-abstraction, \nand then plays game lamG. The appG performs a dependent compo\u00adsition. After playing a game for the argument \nof the application, it binds the argument value to e and plays expGame for the function value, using \nthe type of e to create a pattern for the function value. The lamG game analyses the pattern argument. \nIf it is an arrow pat\u00adtern we play a composition of the constant game for the type given by the pattern \nwith the expression for the body of the .-abstraction in the extended environment. On the other hand, \nif the pattern is Any we .rst play game tyG for the argument type, bind the type to t and play expGame \nfor the body of the abstraction using t to extend the environment. That was it! Let s test expGame on \nthe example expression from Section 1: .x:Nat..y:Nat.x. > let ex = Lam TyNat (Lam TyNat (Var 1)) > enc \n(expGame [] Any) ex [O,I,O,O,I,I,O] > dec (expgame [] Any) it (Lam TyNat (Lam TyNat (Var 1)),[]) Compare \nthe code with that obtained in the introduction. A perfect match we have been using the same question \nscheme! Finally we can show properness and totality.6 PROPOSITION 1. For all patterns p and environments \nG, the game expGame G p is proper and total for the set of expressions e such that G e : t and t matches \nthe pattern p.  5.3 Stronger non-proper games for typed expressions Let us be brave now and return to \nthe original problem. Given any environment and type we will construct a game for expressions typeable \nin that environment with that type. As we have noted above, obtaining a proper game (and hence an every \nbit counts encoding) is dif.cult, but we can certainly obtain a game easily without having to implement \na type inhabitation solver if we give up properness. The function expGameCheck below does that. --. (env:Env) \n(t:Ty), Game { e | env f e:t} expGameCheck :: Env . Ty . Game Exp expGameCheck env t = case varGame (== \nt) env of Nothing . appLamG t Just varG . Split varI varG (appLamG t) where appLamG TyNat = appG +> Iso \n(.(App e1 e2).(e2,e1)) (.(e2,e1).App e1 e2) appLamG (TyArr t1 t2) = let ask (App e1 e2) = Left (e2,e1) \nask (Lam t e) = Right e bld (Left (e2,e1)) = App e1 e2 bld (Right e) = Lam t1 e in Split (Iso ask bld) \nappG (lamG t1 t2) appG = depGame (expGame env Any) $ .e . expGameCheck env (TyArr (typeOf env e) t) lamG \nt1 t2 = expGameCheck (t1:env) t2 Similarly to expGame, expGameCheck .rst determines whether the expression \ncan be a variable or not and uses the variable game or the appLamG next. The appLamG game in turn pattern \nmatches on the in\u00adput type. If the input type is TyNat the we know that the expression can t possibly \nbe a .-abstraction and hence play the appG game. On the other hand, if the input type is an arrow type \nTyArr t1 t2 then the expression may be either application or abstraction. The appli\u00adcation game appG \nas before plays a game for the argument of an application, binds it to e and recursively calls expGameCheck \nusing the type of e. Interestingly we use expGame env Any to determine the type of the argument alternatively \nwe could perform a depen\u00addent composition where the .rst thing would be to play a game for the argument \ntype, and subsequently use that type to play a game for the argument and the function. The lamG game \nis straightfor\u00adward. There are no obvious empty types in this game why is it non proper? Consider the \ncase when the environment is empty and the expected type is TyNat. According to expGameCheck the game \nto be played will be the appG game for applications. But there can t be any closed expressions of type \nTyNat to start with, and the game can t possibly have any leaves something that we failed to check. \nWe ve asked a silly question (by playing appG) on an uninhabited type! 6 Since we do not have expGame \nin Coq, we ve only shown this on paper, hence it s a Proposition and not a Theorem. In other words the \nexpGameCheck game is non-proper and hence vi\u00adolates the every bit counts property. On the other hand \nit s de.nitely a useful game and enjoys all other properties we ve been discussing in this paper. Happily, \nthere is a way to convert non-proper games to proper games in many cases and we return to this problem \nin the next section. 6. Filtering games Non-proper .ltering. Sometimes it s convenient not to be proper. \nUsing voidGame from Section 3.3 we can write filterGame, which accepts a game and a predicate on t and \nreturns a game for those elements of t that satisfy the predicate. filterGame :: (t . Bool) . Game t \n. Game t --. (p : t . Bool), Game t . Game {x |px} filterGame p g@(Single (Iso _ bld)) = if p (bld ()) \nthen g else voidGame filterGame p (Split (Iso ask bld) g1 g2) = Split (Iso ask bld) (filterGame (p . \nbld . Left) g1) (filterGame (p . bld . Right) g2) It works by inserting voidGame in place of all singleton \nnodes that do not satisfy the .lter predicate. We may, for instance, .lter a game for natural numbers \nto obtain a game for the even natural numbers. > enc (filterGame even binNatGame) 2 [I,I,O] > dec (filterGame \neven binNatGame) [I,I,O] (2,[]) Naturally, since the game is no longer proper, decoding can fail: > dec \n(filterGame even binNatGame) [I,O,I,O,O,I,I,I,I] (*** Exception: Input too short Moreover, for the above \nbitstring, no suf.x is suf.cient to convert it to a valid code we have entered the voidGame non-proper \nworld. What is so convenient with the non-proper filterGame implemen\u00adtation? First, the structure of \nthe original encoding is intact with only some codes being removed. Second, it avoids hard inhabita\u00adtion \nquestions that may involve theorem proving or search. Proper .nite .ltering. Now let s recover properness, \nwith the following variant on .ltering: filterFinGame :: (t . Bool) . Game t . Maybe (Game t) --. (p \n: t . Bool), Game t . option(Game{x| px }) filterFinGame p g@(Single (Iso _ bld)) = if p (bld ()) then \nJust g else Nothing filterFinGame p (Split iso@(Iso ask bld) g1 g2) = case (filterFinGame (p . bld . \nLeft) g1, filterFinGame (p . bld . Right) g2) of (Nothing, Nothing) . Nothing (Just g1 , Nothing) . Just \n$ g1 +> iso1 (Nothing, Just g2 ) . Just $ g2 +> iso2 (Just g1 , Just g2 ) . Just $ Split iso g1 g2 where \nfromLeft (Left x) = x fromRight (Right x) = x iso1 = Iso (fromLeft . ask) (bld . Left ) iso2 = Iso (fromRight \n. ask) (bld . Right) The result of applying filterFinGame is of type Maybe (Game t). If no elements \nin the original game satisfy the predicate, then filterFinGame returns Nothing, otherwise it returns \nJust a game for those elements of t satisfying the predicate. In contrast to filterGame, though, filterFinGame \npreserves proper-ness: if the input game is proper, then the result game is too. It does this by eliminating \nSplit nodes whose subgames would be empty. There is a limitation, though, as its name suggests: filterFinGame \nworks only on .nite games. This can be inferred from the obser\u00advation that filterFinGame explores the \ngame tree in a depth-.rst manner. Nevertheless, for such .nite games we can use it pro.tably to obtain \nef.cient encodings: > enc (fromJust (filterFinGame even (rangeGame 0 7))) 4 [I,O] Compare this to the \noriginal encoding before .ltering: > enc (rangeGame 0 7) 4 [I,O,O] Proper in.nite .ltering. What about \nin.nite domains, as is typ\u00adically the case for recursive types? Can we implement a .lter on games that \nproduces proper games for such types? The answer is yes, if we are willing to drastically change the \norigi\u00adnal encoding that the game expressed, and if that original game has in.nitely many leaves that \nsatisfy the .lter predicate. Here is the idea, not given here in detail for reasons of space, but implemented \nin the accompanying code as function filterInfGame: perform a breadth-.rst traversal of the original \ngame, and each time you en\u00adcounter a new singleton node (that satis.es the predicate) insert it into \na right-spined tree: . . . The ability to become proper in this way can help us recover proper games \nfor simply-typed expressions of a given type in a given environment, from the weaker games that expGameCheck \nof Section 5.3 produces, if we have a precondition that there exists one expression of the given type \nin the given environment. If there exists one expression of the given type in the given environment, \nthere exist in.nitely many, and hence the expGameCheck game has in.nitely many inhabitants. Consequently \nit is possible to rebalance it in the described way to obtain a proper game for simply-typed expressions! \nexpGameCheckProper env t = filterInfGame (._ . True) (expGameCheck env t) 7. Discussion Practicality. \nThere is no reason to believe that the game-based approach is suitable only for theoretical investigations \nbut not for real implementations. To test this hypothesis we intend to apply the technique to a reasonably-sized \ncompiler intermediate language such as Haskell Core [22] or .NET CIL [7]. (We ve already created an every-bit-counts \ncodec for ML-style let polymorphism.) Determining the space complexity of games is somewhat tricky: as \nwe navigate down the tree, pointers to thunks representing both the left and the right subtrees are kept \naround, although only one of two pointers is relevant. An optimization would involve embedding the next \ngame to be played on inside the isomorphism, by making the ask functions return not only a split but \nalso, for each alternative (left or right), a next game to play on. Hence only the absolutely relevant \nparts of the game would be kept around during encoding and decoding. This representation could then be \nsubject to the optimizations described in stream fusion work [5]. For this paper though our goal has \nbeen to explain the semantics of games and not their optimization and hence we used the easier-to-grasp \nde.nition of a game as just a familiar tree datatype. It s also worth noting that the encoding and decoding \nfunctions can be specialized by hand for particular games, eliminating the game construction completely. \nFor a trivial example, consider inlining unaryNatGame into enc, performing a few simpli.cations, to obtain \nthe following code: encUnaryNat x = case x of 0 . I : [] n+1 . O : encUnaryNat n Compression. For reasons \nof space, we have compressed away any discussion of classic techniques such as Huffman coding. In the \naccompanying code, however, the reader can .nd a function huffGame that accepts a list of frequencies \nassociated with elements of type t and returns a Game t constructed using the Huffman technique. Adaptive \n(or dynamic) Huffman encoding is achieved using just two more lines of Haskell! Investigation of other \ncompression techniques using games remains future work. In particular, we would like to integrate arithmetic \ncoding, for which slick Haskell code already exists [2]. It would also be interesting to make use of \nstatistical models in our games for typed programs [3], producing codes that are even more compact than \nis attained purely through the use of type information. Test generation. Test generation tools such as \nQuickcheck [4] are a potential application of game-based decoding, since generating random bitstrings \namounts to generating programs. As a further di\u00adrection for research, we wold like to examine how the \nprogrammer could affect the distribution of the generated programs, by tweak\u00ading the questions asked \nduring a game. Program development and veri.cation in Coq. Our attempts to encode everything in this \npaper in Coq tripped over Coq s lim\u00adited support for co-recursion, namely the requirement that recur\u00adsive \ncalls be guarded by constructors of coinductive data types [1]. In many games for recursive types the \nrecursive call was under a use of a combinator such as prodGame, which was itself guarded. Whereas it \nis easy to show on paper that the resulting co-.xpoint is well-de.ned (because it is productive), Coq \ndoes not admit such de.nitions. On the positive side, using the proof obligation genera\u00adtion facilities \nof Program [21] was a very pleasant experience. Our Coq code in many cases has been a slightly more verbose \nversion of the Haskell code (due to the more limited type inference), but the isomorphism obligations \ncould be proven on the side. Our over\u00adall conclusion from the experience is that Coq itself can become \na very effective development platform but it would bene.t from bet\u00adter support for more general patterns \nof recursion, co-recursion, and type inference. 8. Related work Our work has strong connections to Kennedy \ns pickler combina\u00adtors [16]. There, a codec was represented by a pair of encoder and decoder functions, \nwith codecs for complex types built from simple ones using combinators. The basic round-trip property \n(Enc/Dec) was considered informally, but stronger properties were not stud\u00adied. Before developing the \ngame-based codecs, we implemented by hand encoding and decoding functions for the simply-typed .\u00adcalculus. \nCompared to the game presented in Section 5, the code was more verbose partly because out of necessity \nboth encoder and decoder used the same logic . In our opinion, games are more succint representations \nof codecs, and are easier to verify, requiring only local reasoning about isomorphisms. Note that other \nrelated work [6] identi.es and formally proves similar round-trip proper\u00adties for encoders and decoders \nin several encryption schemes. One can think of games as yet another technique for datatype\u00adgeneric \nprogramming [12], where one of the most prominent ap\u00adplications is generic marshalling and unmarshalling. \nMany of the approaches to datatype-generic programming [14] are based on the structural representations \nof datatypes, typically as .xpoints of functors consisting of sums and products. It is straightforward \nto derive automatically a default structural game for recursive and polymorphic types. On the other hand, \ngames are convenient for ex\u00adpressing semantic aspects of the values to be encoded and decoded, such as \nnaturals in a given range. Moreover, the state of a game and therefore the codes themselves can be modi.ed \nas the game progresses, which is harder (but not impossible, perhaps through generic views [15]) in datatype-generic \nprogramming techniques. Another related area of work is data description languages, which associate the \nsemantics of types to their low-level representa\u00adtions [9]. The interpetation of a datatype is a coding \nscheme for values of that datatype. There, the emphasis is on avoiding man\u00adually having to write encode \nand decode functions. Our goal is slightly different; more related to the properties of the resulting \ncoding schemes and their veri.cation rather than the ability to au\u00adtomatically derive encoders and decoders \nfrom data descriptions. Though we have not seen games used for writing and verifying encoders and decoders, \ntree-like structures have been proposed as representations of mathematical functions. Ghani et al. [11] \nrepre\u00adsent continuous functions on streams as binary trees. In our case, thanks to the embedded isomorphisms, \nthe tree structures represent at the same time both the encode and the decode functions. Other researchers \nhave investigated typed program compression, claiming high compression ratios for every-bit-counts (and \nhence tamper-proof) codes for low-level bytecode [13, 10]. Although that work is not formalized, it is \ngoverned by the design principle of only asking questions that make sense . That is precisely what our \nproperness property expresses, which provably leads to every bit counts codes. Also closely related is \nthe idea behind oracle-based checking [18] in proof carrying code [17]. The motivation there is to eliminate \nproof search for untrusted software and reduce the size of proof encodings. In oracle-based checking, \nthe bitstring oracle guides the proof checker in order to eliminate search and unam\u00adbiguously determine \na proof witness. Results report an improve\u00adment of a factor of 30 in the size of proof witnesses compared \nto their na\u00a8ive syntactic representations. Although not explicitly stated in this way, oracle-based checking \nreally amounts to some game for well-typed terms in a variant of LF. Acknowledgments The authors appreciated \nthe lively discussions on this topic at the Type Systems Wrestling event held weekly at MSR Cambridge. \nSpecial thanks to Johannes Borgstr\u00a8om for his helpful feedback, and to the anonymous reviewers for many \nhelpful suggestions. References [1] Y. Bertot and P. Casteran. Interactive Theorem Proving and Program \nDevelopment. Springer-Verlag, 2004. [2] R. Bird and J. Gibbons. Arithmetic coding with folds and unfolds. \nIn J. Jeuring and S. Peyton Jones, editors, Advanced Functional Programming 4, volume 2638 of Lecture \nNotes in Computer Science, pages 1 26. Springer-Verlag, 2003. Code available at http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/ \npublications/arith.zip. [3] J. Cheney. Statistical models for term compression. In DCC 00: Proceedings \nof the Conference on Data Compression, page 550, Washington, DC, USA, 2000. IEEE Computer Society. [4] \nK. Claessen and J. Hughes. Quickcheck: a lightweight tool for random testing of Haskell programs. In \nICFP 00: Proceedings of the .fth ACM SIGPLAN International Conference on Functional Programming, pages \n268 279, New York, NY, USA, 2000. ACM. [5] D. Coutts, R. Leshchinskiy, and D. Stewart. Stream fusion: \nfrom lists to streams to nothing at all. In ICFP 07: Proceedings of the 12th ACM SIGPLAN International \nConference on Functional Programming, pages 315 326, New York, NY, USA, 2007. ACM. [6] J. Duan, J. Hurd, \nG. Li, S. Owens, K. Slind, and J. Zhang. Functional correctness proofs of encryption algorithms. In Logic \nfor Programming, Arti.cial Intelligence and Reasoning (LPAR), volume 3835 of LNCS, pages 519 533. Springer, \n2005. [7] ECMA. Standard ECMA-335: Common language infrastructure (CLI), 2006. [8] P. Elias. Universal \ncodeword sets and representations of the integers. IEEE Transactions on Information Theory, 21(2):197 \n203, 1975. [9] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data description languages. SIGPLAN \nNot., 41(1):2 15, 2006.  [10] M. Franz, V. Haldar, C. Krintz, and C. H. Stork. Tamper-proof annotations \nby construction. Technical Report 02-10, Dept of Information and Computer Science, University of California, \nIrvine, March 2002. [11] N. Ghani, P. Hancock, and D. Pattinson. Representations of stream processors \nusing nested .xed points. Logical Methods in Computer Science, 5(3), 2009. [12] J. Gibbons. Datatype-generic \nprogramming. In R. Backhouse, J. Gibbons, R. Hinze, and J. euring, editors, Datatype-Generic Programming, \nvolume 4719 of LNCS, chapter 1, pages 1 71. Springer, Berlin, Heidelberg, 2007. [13] V. Haldar, C. H. \nStork, and M. Franz. The source is the proof. In NSPW 02: Proceedings of the 2002 workshop on New security \nparadigms, pages 69 73, New York, NY, USA, 2002. ACM. [14] R. Hinze, J. Jeuring, and A. L\u00a8oh. Comparing \napproaches to generic programming in Haskell. In Spring School on Datatype-Generic Programming, 2006. \n[15] S. Holdermans, J. Jeuring, A. L\u00a8oh, and A. Rodriguez. Generic views on data types. In In T. Uustalu, \neditor, Proceedings of the 8th International Conference on Mathematics of Program Construction, MPC06, \nvolume 4014 of LNCS, pages 209 234. Springer, 2006. [16] A. J. Kennedy. Functional Pearl: Pickler Combinators. \nJournal of Functional Programming, 14(6):727 739, October 2004. [17] G. C. Necula and P. Lee. The design \nand implementation of a certifying compiler. In PLDI 98: Proceedings of the ACM SIGPLAN 1998 Conference \non Programming Language Design and Implementation, pages 333 344, New York, NY, USA, 1998. ACM. [18] \nG. C. Necula and S. P. Rahul. Oracle-based checking of untrusted software. In POPL 01: Proceedings of \nthe 28th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 142 154, New York, \nNY, USA, 2001. ACM. [19] D. Salomon. A Concise Introduction to Data Compression. Undergraduate Topics \nin Computer Science. Springer, 2008. [20] M. H. S\u00f8rensen and P. Urzyczyn. Lectures on the Curry-Howard \nIsomorphism, Volume 149 (Studies in Logic and the Foundations of Mathematics). Elsevier Science Inc., \nNew York, NY, USA, 2006. [21] M. Sozeau. Subset coercions in Coq. In Selected papers from the International \nWorkshop on Types for Proofs and Programs (TYPES 06), pages 237 252. Springer, 2006. [22] M. Sulzmann, \nM. Chakravarty, and S. Peyton Jones. System F with type equality coercions. In ACM Workshop on Types \nin Language Design and Implementation (TLDI). ACM, 2007.   \n\t\t\t", "proc_id": "1863543", "abstract": "<p>We show how the binary encoding and decoding of typed data and typed programs can be understood, programmed, and verified with the help of question-answer games. The encoding of a value is determined by the yes/no answers to a sequence of questions about that value; conversely, decoding is the interpretation of binary data as answers to the same question scheme.</p> <p>We introduce a general framework for writing and verifying game-based codecs. We present games for structured, recursive, polymorphic, and indexed types, building up to a representation of well-typed terms in the simply-typed &#955;-calculus. The framework makes novel use of isomorphisms between types in the definition of games. The definition of isomorphisms together with additional simple properties make it easy to prove that codecs derived from games never encode two distinct values using the same code, never decode two codes to the same value, and interpret any bit sequence as a valid code for a value or as a prefix of a valid code.</p>", "authors": [{"name": "Dimitrios Vytiniotis", "author_profile_id": "81100156369", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2338138", "email_address": "", "orcid_id": ""}, {"name": "Andrew J. Kennedy", "author_profile_id": "81100450709", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2338139", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863548", "year": "2010", "article_id": "1863548", "conference": "ICFP", "title": "Functional pearl: every bit counts", "url": "http://dl.acm.org/citation.cfm?id=1863548"}