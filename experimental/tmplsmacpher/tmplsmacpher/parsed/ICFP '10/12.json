{"article_publication_date": "09-27-2010", "fulltext": "\n TeachScheme! A Checkpoint Matthias Felleisen PLT Northeastern University, Boston, Massachusetts matthias@ccs.neu.edu \nAbstract In 1995, my team and I decided to create an outreach project that would use our research on \nfunctional programming to change the K-12 computer science curriculum. We had two different goals in \nmind. On the one hand, our curriculum should rely on mathematics to teach programming, and it should \nexploit programming to teach mathematics. All students not just those who major in computer science should \nbene.t. On the other hand, our course should demonstrate that introductory programming can focus on program \ndesign, not just a speci.c syntax. We also wished to create a smooth path from a design-oriented introductory \ncourse all the way to courses on large software projects. My talk presents a checkpoint of our project, \nstarting with our major scienti.c goal, a comprehensive theory of program design. Our work on this theory \nprogresses through the development of program design courses for all age groups. At this point, we offer \ncurricular materials for middle schools, high schools, three college\u00adlevel freshman courses, and a junior-level \ncourse on constructing large components. We regularly use these materials to train K-12 teachers, after-school \nvolunteers, and college faculty; thus far, we have reached hundreds of instructors, who in turn have \ndealt with thousands of students in their classrooms. Categories and Subject Descriptors D.1.0 [Programming \nTech\u00adniques]: General; K.3.0 [Computers and Education]: General General Terms Design, Human Factors Keywords \nCurriculum Design, Program Design Designing programs for the bene.t of all The TeachScheme! project employs \nfunctional programming as a vehicle to deliver two intertwined messages about the introduc\u00adtory programming \ncurriculum. First, if the community wishes to enroll all students in a .rst course on programming and \ncomputing, the curriculum must bene.t everyone, not just those who continue to program or those who become \ncomputer science majors. Sec\u00adond, even the .rst course on programming should demonstrate that good programming \ninvolves a systematic approach, which we call design. Simply put, a design-based programming curriculum \ncan bene.t everyone. Our starting point is the insight that programming can easily bene.t all students \nif it aligns itself with K-12 mathematics in- Copyright is held by the author/owner(s). ICFP 10, September \n27 29, 2010, Baltimore, Maryland, USA. ACM 978-1-60558-794-3/10/09. struction [2]. Hence functional \nprogramming is the most natural .t. Unlike books, functional programming brings mathematics to life for \nkids directly and without much ado. In this context, an animation is a mathematical function (from time \nto scenes); an interactive, graphical program is a mathematical expression; and a family of web pages \nis the result of some more mathematics. With functional programming, mathematics becomes fun; it is no \nlonger a dry, paper-and-pencil exercise. Best of all, the basic rules of algebraic expression evaluation \nexplain the computational model of functional programming, justifying the idea that it teaches the principles \nof computing and programming. At this point, our cur\u00adriculum works with algebraic, geometric, trigonometric, \nand pre\u00adcalculus knowledge; implicitly, it also touches on mathematical in\u00adtegration in several different \nways. Good programming also means planning, organizing, and stick\u00ading to a discipline. As such, programming \ncan bene.t students by teaching how to solve problems systematically. We realized from the beginning, \nhowever, that the connection between conventional programming courses and systematic problem solving \nwas tenu\u00adous at best. More commonly, students and teachers would approach programming with the goal of \nsatisfying the parser and getting de\u00adcent output for a few program runs. Even books on functional pro\u00adgramming \ndidn t offer more. If we wanted to use functional pro\u00adgramming to teach systematic problem solving, we \nhad to create a curriculum that was explicitly design-oriented. Fifteen years ago, it didn t exist [5]. \nHow to Design Programs (HtDP), our text for high schools and colleges [3], is the principal result of \nour effort. It uses the ideas of the functional community to teach programming as a systematic activity, \ni.e., as a design activity. A functional program deals with values; there is no imperative to parse text \nfrom some input medium or to write text to some output medium to see how the program works. Values come \nin a wide variety of .avors: atomic values; compound values; unions; hierarchically nested values; arbitrarily \nlarge values; higher-order values; and so on. In sum, functional program design is easy to explain as \na two-dimensional grid: one axis describes the process, and the other axis describes the varieties of \ndata. The content of the grid is program design, and this grid can be turned into courses for various \nage groups. From middle school to college For the .rst ten years, we focused on outreach to high schools \nand on the college-level freshman course [4]. We trained teachers on how to use the .rst two parts of \nHtDP; the complete book (and more) was used to teach the freshman course at Rice University. By connecting \nthe two levels explicitly, we hoped that this continu\u00adity would guarantee a smooth path into a full-.edged \nCS curricu\u00adlum. Over time, however,it became clear that the project needed to expand in two directions: \nupstream and downstream. On the upstream side, students encounter computers in mid\u00addle school (approx. \ngrades 4 through 8), not just high school (ap\u00adprox. grades 9 through 12). They listen to their high school \nfriends and siblings when they discuss programming in Python or Java. Conversely, middle school introduces \nthe few algebraic concepts that are needed to understand functional programming. Introducing simple functional \nprogramming at this level can help teach essential mathematical ideas, such as function and variable, \nwhile simulta\u00adneously preparing the ground for full-.edged programming. It may also preempt students \nfrom adopting certain prejudices about pro\u00adgramming that we see in so many high school students.  With \nEmmanuel Schanzer (Harvard U.), we launched the Boot\u00adstrap project, an after-school program, that is \nstaffed by volunteer teachers. The program currently works with students in some ten underserved neighborhoods \nacross the US. Bootstrap provides the strongest evidence yet that teaching functional programming di\u00adrectly \naffects the mathematics skills and interests of K-12 students. On the downstream side, students must \nsee how the design principles in HtDP apply to class-based, object-oriented languages such as Java. These \nlanguages are what students need for their .rst co-op or internship. At the same time, these languages \ndo not come with algebraic data types; such forms of data are encoded. These languages do not use pattern \nmatching to evaluate function calls; they rely on method dispatch instead. Last but not least, object-oriented \nlanguages support different means for abstracting over repeated patterns; indeed, many abstraction mechanisms \nare protocols that simulate features built into functional languages. To establish a bridge between the \nHtDP course and the main\u00adstream languages that students encounter at work and downstream in conventional \ncurricula, we created a course dubbed How to De\u00adsign Classes. The purpose of the course is to demonstrate \nhow the design principles from the functional world seamlessly apply to the object-oriented world. Next \nthe course moves on to object-oriented means for abstracting code while retaining the design principles \nfor abstraction in functional languages. Finally, the course introduces imperative-style programming \nwith for and while loops but also explains why doing so violates object-oriented design. Beyond object-oriented \nprogramming, the typical computing curriculum offers two more chances to re-emphasize the mes\u00adsages of \ndesign and functional programming: a course on logic and a course on large-scale program development, \noften called soft\u00adware construction. At Northeastern, we have recently revamped the second-semester logic \ncourse [1]. In the past this course employed a rather conventional syllabus, focusing on logic as an \nexercise in studying formal systems and their meta-theorems. Now the course continues where the HtDP \ncourse leaves off though with ACL2 as the programming language. Students are introduced to ACL2 as an \nalternative syntax to the teaching languages of the .rst-semester course. Then they learn to state and \nprove theorems about their programs. While they start with small functions and theorems, their .nal project \nis typically an interactive, graphical game. Stu\u00addents quickly learn that ACL2 s theorem prover veri.es \ntheorems easily about functions designed according to HtDP and chokes on spaghetti functions.1 At Northeastern \nand Northwestern, we have developed a course on How to Design Systems. The goal of the course is to remind \njunior-level students one more time of the design principles of HtDP and to demonstrate how these ideas \napply at a large scale. While students choose their favorite programming language to im\u00adplement a reasonably \nlarge system, we demonstrate how the de\u00adsign process of HtDP applies at that scale and to all languages. \nThe key to the course is that the project speci.cation changes on a weekly basis, growing from a short, \none-paragraph statement into the description of a distributed system; we also rotate students from 1 \nAlso see Rex Page s Besseme project on functional programming in dis\u00adcrete mathematics [8] and on theorem \nprovers in software engineering [9]. one code base to another mid-semester. The students public design \npresentations routinely illustrate why a systematic design process is critically important when the project \nis large and when its speci.ca\u00adtions continuously change. Students often con.rm the importance of this \ncourse with notes from their .rst positions in industry. Side effects The ! in TeachScheme! is a pun. \nOne interpretation suggests that the goal of the project is to teach Scheme. It isn t, because the alter\u00adnative \nexplanation says that ! is post.x notation for not. While we never had the intention of teaching plain \nScheme, lab observa\u00adtions during our .rst year drove home the important point that no off-the-shelf programming \nlanguage is suitable for novices. This insight forced us to develop an entire series of teaching program\u00adming \nlanguages as well as DrScheme, a pedagogical IDE [6], that supports these teaching languages. The decision \nto develop our own support software ensured our continued presence in the research community. To support \nthe construction of a series of teaching languages, we developed a programming language for creating \nfull-.edged, ready-to-use pro\u00adgramming languages. Over the years, Racket [7], formerly known as PLT Scheme, \nhas served as our platform to explore novel linguis\u00adtic constructs and to contribute ideas to the functional \nprogramming community. In short, TeachScheme! created a virtuous cycle our outreach projects inspire \nmostly functional research projects, and the results of the research assist our outreach projects. Acknowledgments \nCormac Flanagan asked the right question at the right time; it got us started. Matthew Flatt, Shriram \nKrishna\u00admurthi, and Bruce Duba immediately agreed to drop everything we were doing and to help launch \nthe TeachScheme! project; with\u00adout them, it would all have been a short daydream. Robby Findler knew \nwhat he was getting into when he joined a year later, and he came to build DrScheme anyway. Kathi Fisler \nhad the courage to take over my workshops; her contributions have been critical to the survival of the \nTeachScheme! and Bootstrap workshops. To all the other members of PLT, thank you very much for your labor \nof love. Over the past 15 years, TeachScheme! and Bootstrap have re\u00adceived generous support from the \nDepartment of Education, the National Science Foundation, Cord, Exxon, Google, Jane Street, and Microsoft. \nReferences [1] C. Eastlund, D. Vaillancourt, and M. Felleisen. ACL2 for freshmen .rst experiences. In \nProc. 7th ACL2 Workshop, pages 200 211, 2007. [2] M. Felleisen and S. Krishnamurthi. Why computer science \ndoesn t matter. Commun. ACM, 52(7):37 40, 2009. [3] M. Felleisen, R. B. Findler, M. Flatt, and S. Krishnamurthi. \nHow to Design Programs. MIT Press, 2001. [4] M. Felleisen, R. B. Findler, M. Flatt, and S. Krishnamurthi. \nThe TeachScheme! project: Computing and programming for every student. Computer Science Education, 14:55 \n77, 2004. [5] M. Felleisen, R. B. Findler, M. Flatt, and S. Krishnamurthi. The structure and interpretation \nof the computer science curriculum. Journal of Functional Programming, 14(4):365 378, 2004. [6] R. B. \nFindler, J. Clements, C. Flanagan, M. Flatt, S. Krishnamurthi, P. Steckler, and M. Felleisen. DrScheme: \nA programming environment for Scheme. Journal of Functional Programming, 12(2):159 182, Mar. 2002. [7] \nM. Flatt and PLT. Reference: Racket. Technical report, PLT Inc., June 2010. http://racket-lang.org/tr1/. \n[8] R. L. Page. Software is discrete mathematics. In International Confer\u00adence on Functional Programming, \npages 79 86, 2003. [9] R. L. Page, C. Eastlund, and M. Felleisen. Functional programming and theorem \nproving for undergraduates. In Functional and Declarative Programming in Education, pages 21 30, 2008. \n \n\t\t\t", "proc_id": "1863543", "abstract": "<p>In 1995, my team and I decided to create an outreach project that would use our research on functional programming to change the K-12 computer science curriculum. We had two different goals in mind. On the one hand, our curriculum should rely on mathematics to teach programming, and it d exploit programming to teach mathematics. All students - not just those who major in computer science - should benefit. On the other hand, our course should demonstrate that introductory programming can focus on program design, not just a specific syntax. We also wished to create a smooth path from a design-oriented introductory course all the way to courses on large software projects.</p> <p>My talk presents a checkpoint of our project, starting with our major scientific goal, a comprehensive theory of program design. Our work on this theory progresses through the development of program design courses for all age groups. At this point, we offer curricular materials for middle schools, high schools, three college-level freshman courses, and a junior-level course on constructing large components. We regularly use these materials to train K-12 teachers, after-school volunteers, and college faculty; thus far, we have reached hundreds of instructors, who in turn have dealt with thousands of students in their classrooms.</p>", "authors": [{"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2338170", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863563", "year": "2010", "article_id": "1863563", "conference": "ICFP", "title": "TeachScheme!: a checkpoint", "url": "http://dl.acm.org/citation.cfm?id=1863563"}