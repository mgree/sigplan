{"article_publication_date": "09-27-2010", "fulltext": "\n Bidirectionalizing GraphTransformations Soichiro Hidaka Zhenjiang Hu Kazutaka Matsuda Keisuke Nakano \nKazuhiro Inaba Hiroyuki Kato Tohoku University, Japan The University of kztk@kb.ecei.tohoku.ac.jp Electro-Communications, \nJapan National Institute of Informatics, Japan {hidaka,hu,kinaba,kato}@nii.ac.jp ksk@cs.uec.ac.jp Abstract \nBidirectional transformations provide a novel mechanism for syn\u00adchronizing and maintaining the consistencyof \ninformation between input and output. Despite manypromising results on bidirectional transformations,thesehavebeen \nlimitedtothe contextof relational orXML (tree-like)databases.Wechallengethe problemof bidirec\u00adtional \ntransformations within the context of graphs, by proposing a formal de.nition of a well-behaved bidirectional \nsemantics for UnCAL, i.e., a graph algebra for the known UnQL graph query language. The key to our successful \nformalization is full utiliza\u00adtion of both the recursive and bulk semantics of structural recur\u00adsion \non graphs.We carefully re.ne theexisting forwardevaluation of structural recursion so that it can produce \nsuf.cient trace infor\u00admation for later backwardevaluation.We use the trace information for backwardevaluationto \nre.ect in-place updatesand deletionson the view to the source, and adopt the universal resolving algorithm \nfor inverse computation and the narrowing technique to tackle the dif.cult problem with insertion.We \nprove our bidirectionalevalu\u00adation is well-behaved. Our current implementation is available on\u00adline and \ncon.rms the usefulness of our approach with nontrivial applications. Categories and Subject Descriptors \nD.3.2[Programming Lan\u00adguages]: Language Classi.cations Specialized application lan\u00adguages; E.1[Data Structures]: \nGraphs and networks General Terms Design, Languages Keywords bidirectional transformation, view updating, \ngraph query and transformation, structural recursion 1. Introduction Bidirectional transformations (Czarnecki \net al. 2009;Foster et al. 2005) provide a novel mechanism for synchronizing and maintain\u00ading the consistencyof \ninformation between input and output. They consist of a pair of well-behaved transformations: forward \ntrans\u00adformation is used to produce a target view from a source, while the backward transformation is \nused to re.ect modi.cation on the view to the source. This pair of forward and backward transformations \nshould satisfy certain bidirectional properties. Bidirectional trans\u00adformationsareindeedpervasiveandcanbeseeninmanyinteresting \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright c &#38;#169; 2010ACM 978-1-60558-794-3/10/09... \n$10.00 applications, including the synchronization of replicated data in dif\u00adferent formats(Foster et \nal. 2005), presentation-oriented structured document development (Hu et al. 2008), interactive user interface \ndesign (Meertens 1998), coupled software transformation(L\u00a8 ammel 2004), and the well-known view updating \nmechanism which has been intensively studied in the database community (Bancilhon and Spyratos 1981; \nDayal and Bernstein 1982; Gottlob et al. 1988; Heg\u00adner 1990; Lechtenb \u00a8 orger andVossen 2003). Despite \nmany promising results on bidirectional transforma\u00adtions, theyare limited to the context of relational \nor XML (tree-like) databases. It remains unresolved (Czarnecki et al. 2009) whether bidirectional transformations \ncan be addressed within the context of graphs containing node sharing and cycles. It would be remark\u00adably \nuseful in practice if bidirectional transformation could be ap\u00adplied to graph data structures, because \ngraphs play an irreplace\u00adable role in naturally representing more complex data structures such as those \nin biological information, WWW, UML diagrams in software engineering (Stevens 2007), and the Object Exchange \nModel (OEM) used for exchanging arbitrary database structures (Papakonstantinou et al. 1995). There are \nmany challenges in addressing bidirectional trans\u00adformation on graphs. First, unlike relational or XML \ndatabases, there is no unique way of representing, constructing, or decom\u00adposing a general graph, and \nthis requires a more precise de.nition of equivalence between two graphs. Second, graphs have shared \nnodes and cycles, which makes both forward and backward com\u00adputation much more complicated than that \non trees; na\u00a8ivecomputa\u00adtion on graphswould visit the same nodes manytimes and possibly in.nitely. It \nis particularly dif.cult to handle insertion in backward transformation becauseit requiresa suitable \nsubgraphtobe created and inserted into a proper place in the source. This paper reports our .rst solution \nto the problem of bidirec\u00adtional graph transformation.We approach this problemby provid\u00ading a bidirectional \nsemantics for UnCAL, which is a graph algebra for the known graph query language UnQL (Buneman et al. \n2000); forward semantics (forward evaluation) corresponds to forward transformation and backward semantics \n(backwardevaluation) cor\u00adresponds to backward transformation. We choose UnQL/UnCAL as the basis of our \nbidirectional graph transformation for two main reasons. First, UnQL/UnCAL is a graph query language \nthat has been well studied in the database community with a solid foundation and ef.cient implementation. \nIt has a concise and practical sur\u00adface syntax based onselect-where clauses like SQL, and can be easily \nused to describe manyinteresting graph transformations.  Second, and more importantly, graph transformations \nin UnQL can be automatically mapped to those in terms of structural recursion in UnCAL, which can be \nevaluated in a bulkmanner (Buneman et al. 2000); a structural recursion is evaluated by .rst processing \nin parallel on all edges of the input graph and   then combining the results. This bulk semantics signi.cantly \ncontributes to our bidirectionalization, providing a smart way of treating shared nodes and cycles in \ngraphs and of tracing back from the view to the source. Our main technical contributions are summarized \nas follows. We are, as far as we are aware, the .rst to have recognized the importance of structural \nrecursion and its bulk semantics in addressing the challenging problem of bidirectional graph transformation, \nand succeeded in a novel two-stage framework of bidirectional graph transformation based on structural \nre\u00adcursion.We demonstrate that graph transformations de.ned in terms of structural recursions (being \nsuitable for optimization ashavebeen intensively studiedthusfar (Bunemanetal.2000)) make backward evaluation \neasier.  We give a formal de.nition of bidirectional semantics for Un-CAL by (1) re.ning the existing \nforward evaluation so that it can produce useful trace information for later backward evalu\u00adation (Section \n4), and (2) using the trace information to re.ect in-place updates and deletions on the view to the source, \nand adopt the narrowing technique to tackle the dif.cult problem with insertion (Section 5).We prove \nour bidirectional evalua\u00adtion is well-behaved.  We have fully implemented our bidirectionalization presented \nin this paper and con.rmed the effectiveness of our approach through many non-trivial examples, including \nall those pre\u00adsented in this paper and some typical bidirectional graph trans\u00adformations in database \nmanagement and software engineering. More examples and demos are available on our BiG project Web site* \n.  We consider an operation based approach, which means that the user explicitly provides editing operations \nin terms of rename , delete , and insert . Currently these operations are treated ac\u00adcording to the order \nspeci.ed by users. It might be challenging to produce these operation sequences automatically from the \nstates before and after user s modi.cations on the view,but it is beyond the scope of this paper. The \nforward transformations we consider is based on UnCAL, which is bisimulation generic, meaning that the \ntransformation can t distinguish between graphs that are bisimilar. For example, it can textract .rst \nchild of a node . Extending our model to cope with order is included in our future work. Also note that \nbackward transformation is not bisimulation generic, meaning that two results ofupdates that are bisimilar \ndo not always lead to bisimilar source. However, this is not necessar\u00adily a limitation introduced by \nour bidirectionalization, since this asymmetry comes from the expressiveness of conditional expres\u00adsion \nin the original UnCAL graph algebra. Similar argument apply for isomorphic updates. Outline We start \nwith a brief review of the basic concept of a graph data model and the structural recursion of UnCAL \nin Sec\u00adtion 2. Then, we clarify the bidirectional properties within our con\u00adtext and give an overview \nof our two-staged framework for bidi\u00adrectionalizing graph transformations in Section 3. After explaining \nhow to extend the forward evaluation of UnCAL with trace infor\u00admationin Section4,wegivea formal de.nitionof \nbidirectional se\u00admantics for UnCAL and prove that it is well-behaved in Section 5. We discuss implementation \nissuesin Section6and relatedworkin Section7.We conclude the paperin Section8. * http://www.biglab.org \n Figure 1. Graph Equivalence Based on Bisimulation 2. UnCAL:AGraph Algebra We adopted UnCAL (Buneman \net al. 2000), a well-studied graph algebra, as the basisof our bidirectional graph transformation.We \nwill brie.y review its graph data model and the core of UnCAL. 2.1 Graph Data Model We deal with rooted, \ndirected, and edge-labeled graphs with no order on outgoing edges. Theyare edge-labeled in the sense \nthat all information is stored on labels of edges while labels of nodes serve only as a unique identi.er \nwithout a particular meaning. UnCAL graph data model has twoprominent features, markers and .-edges. \nNodes may be marked with input and output markers, which are used as an interface to connect them to \nother graphs. An .-edge represents a shortcut of two nodes, working like the .-transition in an automaton \n.We use Label to denote the set of labels and M to denote the set of markers. Formally, a graph G, sometimes \ndenoted by G(V,E,I,O), isa quadruple (V, E, I, O), where V is a set of nodes, E . V \u00d7 (Label.{.})\u00d7V isasetof \nedges, I . M\u00d7V isasetof pairsof an input marker and the corresponding input node, and O . V \u00d7M is a set \nof pairs of output nodes and associated output markers. For each marker&#38;x .M, there is at most one \nnode v such that (&#38;x, v) . I. The node v is called an input node with marker &#38;x and is denotedby \nI(&#38;x). Unlikeinput markers, more than one node can be marked with an identical output marker. They \nare called output nodes. Intuitively,input nodes are root nodes of the graph (we allow a graph to have \nmultiple root nodes, and for singly rooted graphs, we often use default marker &#38; to indicate the \nroot), while an output nodecanbe seenasa context-hole ofgraphswhereaninputnode withthe samemarkerwillbepluggedlater.Wewrite \ninMarker(G) to denote the set of input markers and outMarker(G) to denote the set of output markers in \na graph G. In addition, we write label(() to denote the label of the edge (. Note that multiple-marker \ngraphs are meant to be an internal data structure for graph composition. In fact, the initial source \ngraphs of our transformation have one input marker (single-rooted) and no output markers (no holes).For \ninstance, the graph in Fig\u00adure 1(a) is denoted by (V, E, I, O) where V = {1, 2, 3, 4, 5, 6}, E = {(1, \na, 2), (1, b, 3), (1, c, 4), (2, a, 5), (3, a, 5), (4, c, 4), (5, d, 6)}, I = {(&#38;, 1)}, and O = {}. \nValue Equivalence between Graphs Twographs arevalue equiv\u00adalent if theyare bisimilar. Please refer to \n(Buneman et al. 2000) for the complete de.nition. Informally, graph G1 is bisimilar to graph G2 if every \nnode x1 in G1 has at least a bisimilar counterpart x2 Thisanalogywould chooseNFAratherthanDFA,sinceweallowmultiple \noutgoing edges with identical labels from a node.  Figure 2. Graph Constructors in G2 and vice versa, \nand if there is an edge from x1 to y1 in G1, then there is a corresponding edge from x2 to y2 in G2 that \nis a bisimilar counterpart of y1, and vice versa. Therefore, unfolding a cycle or duplicating shared \nnodes does not really change a graph. This notion of bisimulation is extended to cope with .-edges.For \ninstance,thegraphin Figure1(b)isvalueequivalenttothegraphin Figure 1(a); the newgraph has an additional \n.-edge (denotedbythe dotted line), duplicates the graph rooted at node 5, and unfolds and splits the \ncycle at node 4. Unreachable parts are also disregarded, i.e., two bisimilar graphs are still bisimilar \nif one adds subgraphs unreachable from input nodes. Graph Constructors Figure 2 summarizes the nine graph \ncon\u00adstructors that are powerful enough to describe arbitrary (directed, edge-labeled, and rooted) graphs \n(Buneman et al. 2000): G ::= {} { single node graph } |{l : G} { an edge pointing to a graph } | G1 . \nG2 { graph union } | &#38;x := G { label the root node with an input marker } | &#38;y { a node graph \nwith an output marker } | () { empty graph } | G1 . G2 { disjoint graph union } | G1 @G2 { append of \ntwo graphs } | cycle(G) { graph with cycles } Here, {} constructs a root-only graph, {l : G} constructs \na graph by adding edge l pointing to the root of graph G, and G1 . G2 adds two .-edges from the new root \nto the roots of G1 and G2. Also, &#38;x := G associates an input marker, &#38;x, to the root node of \nG, &#38;y constructs a graph with a single node marked with one output marker &#38;y,and() constructs \nan empty graph that has neither a node nor an edge. Further, G1 . G2 constructsa graphbyusinga componentwise(V, \nE, I and O)union.. differs from . in that . uni.es input nodes while . does not. . requires input markers \nof operands to be disjoint, while . requires them to be identical. G1 @ G2 composestwographsverticallyby \nconnectingthe output nodes of G1 with the corresponding input nodes of G2 with .-edges, and cycle(G) \nconnects the output nodes with the input nodes of G to form cycles. Newly created nodes have unique identi.ers. \nWe will give this creation rule extended for our bidirectionalization in Section 4.1. The de.nition here \nis based on graph isomorphism (identical graph constructionexpressions resultsin identical graphs up \nto isomorphism), and they are, together with other operators, also bisimulation generic (Buneman et al. \n2000), i.e., bisimilar result is obtained for bisimilar inputs. e ::= {} | {l : e}| e . e | &#38;x := \ne | &#38;y | () | e . e | e @e | cycle(e) { constructor } | $g { graph variable } | if l = l then e else \ne { conditional } | rec('($l, $g).e)(e) { structural recursion application } Figure 3. Core UnCAL Language \nExample 1. The graph equivalent to that in Figure 1(a) can be constructed as follows (though not uniquely). \n&#38;z @cycle((&#38;z := {a : {a : &#38;z1}} . {b : {a : &#38;z1}} . {c : &#38;z2}) . (&#38;z1 := {d \n: {}}) . (&#38;z2 := {c : &#38;z2})) For simplicity,we often write {l1 : G1,...,ln : Gn} to denote {l1 \n: G1}.\u00b7 \u00b7\u00b7.{ln : Gn}.  2.2 The Core UnCAL UnCAL (Unstructured Calculus) is an internal graph algebra \nfor the graph query language UnQL, and its core syntax is depicted in Figure 3. It consists of the graph \nconstructors, variables, condi\u00adtionals, and structural recursion.Wehave already detailed the data constructors, \nwhile variables and conditionals are self explanatory. Therefore, we will focus on structuralrecursion, \nwhichisapower\u00adful mechanism in UnCAL to describe graph transformations. A function f on graphs is called \na structural recursion if it is de.nedby the following equations f({})= {} f({$l :$g})= e @f($g) f($g1 \n. $g2)= f($g1) . f($g2), where the expression e may contain references to variables $l and $g (but no \nrecursive calls to f). Since the .rst and the third equations are common in all structural recursions, \nwe write the structural recursion in UnCAL simply as f($db)= rec('($l, $g).e)($db). Despite its simplicity, \nthe core UnCAL is powerful enough to describe interesting graph transformation including all graph queries \n(in UnQL) (Buneman et al. 2000), and nontrivial model transformations (Hidaka et al. 2009). Some simple \nexamples are given below. Example 2. The following structural recursion a2b replaces edge label a with \nb and leaves other labels unchanged. a2b($db)= rec('($l, $g). if $l = a then {b : &#38;1}2 else {$l : \n&#38;3}4) ($db)5 (The superscripts are for identifying code positions, which will be important in Section \n4; they can simply be ignored for now.) Here is an instance of an execution: cc 8 8  a = . a2b . \nb where . denotes the root of the graph. Informally, the meaning of this de.nition can be considered \nto be a .xed point (though may not necessarily unique) over the graph, which is again de.ned by a set \nof equations using the three constructors {}, :, and ..For instance, the graph in Figure 1(a) can be \nconsidered to be the .xed point of the following equations: Groot = {a : {a : G5}, b : {a : G5}, c : \nG4} G5 = {d : {}} G4 = {c : G4}.  After c-edges (a) Before Removing c-(b) Removing c-edges edges (c) \nRemoving Figure 4. Bulk Semantics of Structural Recursion in UnCAL Example 3. The following structural \nrecursion a2d xc replaces all labels a with d and removes edges labeled c. a2d xc($db)= rec('($l, $g). \nif $l =a then {d : &#38;1}2 else if $l = c then {. : &#38;3}4 else {$l : &#38;5}6) ($db)7 Applying the \nfunction a2d xc to the graph in Figure 1(a) yields the graph in Figure 4(c). Example 4. The following \nstructural recursion consecutive ex\u00adtracts subgraphs that canbe accessibleby traversingtwoconnected edges \nof the same label. consecutive($db)= ' rec('($l, $g). rec('($l', $g). if $l =$l' then {result :$g'}1 \nelse {}2 )($g)3)($db)4 For example, we have ! a a - X - result X - - = .  consecutive root node. . \na a a bbb        d bc e - ) = a a -  -  -  -  -  = . abab(.  2.3 Bulk Semantics of Structural \nRecursion rec('($l, $g).e) which is to be applied to an input graph G. Inbulk semantics, we Byallowing \n-edges,wecanevaluateastructuralrecursionina.bulkmanner.Considerthestructuralrecursion, applybody independently \noneveryedge inwhereisthe(l,g) Gle label of the edge and g is the graph that the edge is pointing to, \nthen join the results with .-edges(asin the @constructor). Recall the structural recursion a2d xc de.ned \nin Example 3. Applying it to the input graph in Figure 1(a) yields the graph in Figure 4(a), where each \nedge from i to j in the input graph leads to a subgraph containing a graph with an edge from Sij to Eij \nin the output graph (where the dotted edge denotes an .-edge), and these subgraphs are connected with \n.-edges according to the original shape of the graph. If we eliminate all .-edges asexplained in Section \n3.2, we obtain a standard graph in Figure 4(c). One distinct feature ofbulk semantics is that the shape \nof the input graph is remembered through additional .-edges, which will be fully utilized in our later \nbidirectionalization. 3. Overview: Bidirectionalizing UnCAL It is more challenging to bidirectionalize \ntransformations on graphs than trees, because graphsmay contain shared nodesorcycles.We shall demonstrate \nthat the structural recursion in UnCAL can serve as the basis to solve this problem. Although structural \nrecursion was proposed within the context of query optimization, we will show that it plays a crucial \nrole in our bidirectionalization. 3.1 Bidirectional Properties Bidirectionalization is used to derive \nbackward transformation from forward transformation.We approach the problemof bidirec\u00adtionalization in \ngraph transformation by providing a bidirectional semantics for UnCAL; forward semantics (forward evaluation) \n.. b a - Y - corresponds to forward transformation and backward semantics (backward evaluation) corresponds \nto backward transformation. Note that the structural recursive de.nition of consecutive uses graph parameter \n$g' to achieve the transformation. Also note that structural recursions are allowed to be nested, and \ninner recursion can refer to outer variables (as $l in the example). This enables us to express the join \nof multiple queries. Example 5. Although theexamplesgiven sofar are self-recursive, it is possible to \nsimulate mutualrecursion by returning graphs with multiple markers.For instance, the following function \nabab abab($db)= &#38;z1 @rec('($l, $g). &#38;z1 :={a : &#38;z2}. &#38;z2 := {b : &#38;z1})($db) changes \nall edges of even distances from the root node to a, and odd distance edges to b. We may consider the \nmarkers &#38;zi as a mutually recursivecall, and abab to consist of twomutual recursive functions. The \n.rst is &#38;z1,which, at each edge in the original graph, generates a new a edge pointing to the result \nof &#38;z2 at the original destination node. The second is &#38;z2 that generates b edges pointing to \nthe result of &#38;z1 from its destination. The result of the whole expression is de.ned to be the result \nof the &#38;z1 at the root node of the argument graph. The following .gure should be helpful. The dashed \nedges denote the edges that are unreachable from the output Before giving our bidirectional semantics \nfor UnCAL, let us clarify the bidirectional properties that the forward and backward evaluations should \nsatisfy. Let F[ e] p denote a forward evaluation (get)of expressione under environment p to produce a \nview, and B[ e]](p, G') denote a backward evaluation(put)of expression e under environment p to re.ect \na possibly modi.ed view G' to the source by computing an updated environment. p isa setof mappings with \nform $x .. G with a graph (or label) G. The following are two important properties: F[ e] p = G (GETPUT) \nB[ e]](p, G)= p B[ e]](p, G')= p' G' . Range(F[ e]]) (PUTGET) F[ e] p' = G' The (GETPUT) property states \nthat unchanged view G shouldgive no change on the environment p in the backward evaluation, while the \n(PUTGET) property statesthatifaviewis modi.edto G' which is in the range of the forward evaluation, then \nthis modi.cation can be re.ected to the source such that a forward evaluation will produce the same view \nG'. These two properties are essentially the same as those in (Fos\u00adter et al. 2005). One problem with \nthe (PUTGET) property is that it  Figure 5. General .-edge Elimination Procedure needs to check whether \na graph is in the range of forward evalua\u00adtion,whichisdif.culttodoin practice.Toavoidthisrange check\u00ading, \nwe allow the modi.ed view and the view obtained by back\u00adward evaluation followed by forward evaluation \nto differ, but re\u00adquire both views to have the same effect on the original source if backward evaluation \nis applied. '' = G '' B[ e]](p, G ' )= p F[ e] p (WPUTGET) B[ e]](p, G '' )= p ' The getin our (WPUTGET) \ncan be considered as an amendment of the modi.ed view G ' to G ''. Certainly, if the (PUTGET) property \nholds, so does the (WPUTGET). We say that a pair of forward and backward evaluations is well-behaved \nif it satis.es (GETPUT) and (WPUTGET) properties. In the rest of this paper, we will give a bidirectional \nevaluation (semantics) for UnCAL, and prove the following theorem, which is a direct consequenceof Lemmas2,3, \nand4that willbe discussed later. Theorem1(Well-behavedness). Our forwardand backwardeval\u00aduations are \nwell-behaved, provided their evaluations succeed.  3.2 Two-Stage Bidirectionalization Recall a2d xc, \nwhich maps the source graph in Figure 1(a) to the viewgraphinFigure4(c).Thebiggap betweenthe sourceandthe \nview makes it hard to re.ect changes on the view to the source. Our ideato bridgethisgapwastodividetheforwardevaluationintotwo \neasily handled stages: Stage1:Forwardevaluation(inthebulk semantics) withsuf.\u00adcient .-edges,sothattheoutputgraphwillhavea \nsimilarshape to the input graph, making the later backward evaluation easier.  Stage 2: Elimination \nof .-edges to produce a usual view.  For a2d xc, Stage 1 maps the source graph to the intermediate graphinFigure4(a),andStage2mapsthe \nintermediategraphtothe view graph (Figure 4(c)). By doing so, each stage becomes easier to bidirectionalize. \nFirst, let us consider Stage 2. The .-edge elimination procedure is simple: new edges are added to skip \nthe .-closure (Figure 5). It is easy to de.ne a well-behaved backward evaluation for this procedure. \nFirst, all nodes in the result graph, Gv, exist in the original graph, Gs,so each node inGv can be traced \nto Gs. Second, although an edge in Gs may be duplicated in Gv ((E25, d, E56) and (E35, d, E56) in Figure \n4(b))\u00a7, each edge in Gv should have a uniquely corresponding edge in Gs. Therefore, adding a new node \nto Gv corresponds to adding a new node to Gs, and adding a new edge to Gv corresponds to adding a new \nedge between two corresponding nodes in Gs. Similar correspondence holds for deletions of nodes and edges, \nand in-place updates of edges. Next, let us consider Stage1. Onefactworth notingis that after the backward \nevaluation in Stage 2, the modi.cation to the view in \u00a7 Note that Figure 4(c) does not have this duplication \nbecause for this particular graph, it is safe to glue the source and the destination nodes of an c-edge \ntogether. It is unsafe, if and only if, the source has another outgoing edge and the destination has \nanother incoming edge. Here, duplication is unavoidable. Stage1satis.es the .-marker preserving property:(1) \nNo .-edges are added or deleted, (2) Markers are not added, deleted, or changed and (3) Unreachable parts \nare not modi.ed. This property is very important in our bidirectionalization, because it not only enforces \nthe nine graph constructors so that they are invertible,but it also makes it easy to bidirectionalize \nstructural recursion because there is a clear correspondence between the input and output graphs. In \nthe rest of this paper, we will focus on bidirectional graph transformation in Stage 1. 4. TraceableForwardEvaluation \nAn UnCALexpression usually speci.esa forwardevaluation map\u00adping a graph database (which is just a graph) \nto a view graph (in Section 2). The main purpose of the present paper is to give back\u00adwardevaluation \n(backwardsemantics), which speci.es how to re\u00ad.ectviewupdatestothegraph database.Forthis purpose,wehave \nto detect how each node of the view is generated, particularly when it is constructed through connecting \ninput/output markers and re\u00admoving .-edges, which areno longerintheview.Tomaketheview more informative, \nviz., traceable, we enrich the original seman\u00adtics of UnCAL by embedding trace information (like provenance \ntraces (Cheneyet al. 2008)) in all nodes of the view that possibly includes .-edges. In this section, \nwe explain what kind of trace in\u00adformation is embedded in the view, and extend the original seman\u00adtics \nfor UnCAL expressions to be evaluated into traceable views. 4.1 TraceableViews A view is obtained by \nevaluating an UnCAL expression with a database. Every node of the view originates in either a node of \nthe database or a construct in the UnCAL expression, except when the node is generated through a structural \nrecursion with a rec construct (in the bulk semantics). Recall that an expression rec('($l, $g).e1)(e2) \nis evaluated by binding variables $l and $g in e1 to a part of the evaluation result of e2. In this case, \na node in the view may originate not only in the whole rec expressionbut also a sub-expression in e2. \nAtraceable view is a view each node of which has information for tracing its origin. The information, \ncalled trace ID, is de.ned by TraceID ::= SrcID | Code Pos Marker | RecN Pos TraceID Marker | RecE Pos \nTraceID Edge, where SrcID rangesoveridenti.ers uniquely assigned to all nodes of the database, Pos ranges \nover code positions in the UnCAL expression, Marker ranges over input/output markers, and Edge stands \nfor TraceID \u00d7 Label \u00d7 TraceID witha setof labels Label. We now brie.y explain the meaning of each trace \nID. Let i be a trace ID of a node u in a traceable view. When i is a node identi.er in SrcID, node u \noriginates in the node assigned by i in the database. When i is Code p &#38;m with code position p and \ninput marker &#38;m, node u originates in the subexpression at p in the UnCAL expression. The marker \n&#38;m is only required when the subexpressionisgivenbythe . or cycle construct. This is because these \nconstructs yield as many.-edges as input markers. When i is either RecN pi0 &#38;m or RecE pi0 (i1, a, \ni2), node u is generated through the rec construct at the code position p. RecN and RecE stand for what \nnode and edge, respectively, of the argument of the recursion, the node originates in. Let us explain \nthese cases through an example where the Un-CAL expression a2d xc inExample3 is applied to the database \nGsrc in Figure 1(a). The traceable view we want can be ob\u00adtained from the graph Gview in Figure 4(a) \nby assigning trace IDs to all nodes. The trace ID assigned to node 1 in Gview is (RecN 71 &#38;) because \nthe node originates in node 1 of Gsrc in SrcID, which is used as a part of the argument of the rec con\u00adstruct \nat code position 7 in a2d xc. The trace ID assigned to node S12 in Gview is (RecE 7(Code 2) (1, a, 2)) \nbecause the node originates in the a-labeled edge from node 1 to 2 of Gsrc in Edge through the graph \nconstructor {d : } at code position 2 in the rec construct at 7 in a2d xc. When the argument of the rec \nconstruct is also a rec expression, RecN and RecE in the trace ID are nested like (RecN p (RecE p ' ... \n) ... ) and (RecE p (RecE p ' ... )(RecN . . . , a, RecN ... )).  A traceable view is denoted by a quadruple \n(V, E, I, O) just like an ordinary UnCAL graph. The only difference is that in traceable views, trace \nIDs are assigned to all nodes.  4.2 EnrichedForward Semantics Traceable views can be computed by a simple \nextension of the original forward semantics of UnCAL so that tracing information is recorded when a node \nis created. Let ep denote an UnCAL subexpression e at code position p. We write p($x) for G when ($x \n.. G) . p. p is naturally used as variable substitution in UnCAL expressions, e.g., ep for an expression \ne.We inductively de.ne the enriched forward semantics F[ ep] p for each UnCAL construct of e. Graph Constructor \nExpressions. The semantics of graph con\u00adstructor expressions is straightforward according to the construc\u00adtionin \nFigure2.For instance, wehave F[ {}p] p =({Code p}, \u00d8, {(&#38;, Code p)}, \u00d8), which creates a graph having \na single node with the trace ID of Code p (indicating the node is constructed by the code at position \np), no edges, an input node (the single node itself), and no output nodes.As anotherexample,the semanticsfortheexpression \ne1 .e2 is de.ned below to unify two graphs by connecting their input nodes with matching markers using \n.-edges: F[[(e1 . e2)p] p = F[ e1] p .p F[ e2] p, where .p is a union operator for two graphs concerning \nposition p and is de.ned by G1 .p G2 =(V . V1 . V2,E . E1 . E2,I,O1 . O2) where (V1,E1,I1,O1)= G1 (V2,E2,I2,O2)= \nG2 M = inMarker(G1)= inMarker(G2) V = {Code p &#38;m | &#38;m . M}E = {(Code p &#38;m, ., v) | (&#38;m, \nv) . I1 . I2}I = {(&#38;m, Code p &#38;m) | &#38;m . M}. We omit de.nitions for other constructor expressions. \nVariable. Avariable looks up its binding from environmentp. F[[($v)p] p = p($v) Condition. The forward \nsemantics of a condition is de.ned as F[[(if l1 = l2 then e1 else e2)p] p . F[ e1] p if l1p = l2p = F[ \ne2] p otherwise. It .rst evaluates the conditional expression l1 = l2, and with the result it evaluates \neither the then branch or the else branch. Structural Recursion. The semantics of a structural recursion \nis given by bulk semanticsas reviewed in Section 2.3, which can be formally de.ned by F[[(rec('($l, $g).eb)(ea))p] \np = composep (fwd eachedge(Ga, p, eb),Ga,M) rec where M = inMarker(eb) . outMarker(eb) Ga = F[ ea] p, \nwhere fwd eachedge and composerec are de.ned in Figure 6. Intuitively, fwd eachedge evaluates the bodyexpression \neb at each edge ( of the argument graph Ga obtained by evaluating ea and returns the set of result graphs. \nThen, composerec p glues all the graphs together along the structure of Ga concerning code position p. \nNote that subgraph(G, () denotes the subgraph to which the edge ( is pointing in the graph G. Example \n6. We will now illustrate the semantics ofrec through an example: the structural recursion a2d xc, which \nis de.ned with position informationin Example3,is appliedto Gsrc in Figure 1(a), and the traceable view \nis a graph similar to Gview in Figure 4(a). First, Gsrc is bound to a variable $db. Then, fwd eachedge \ngenerates a set of pairs of an edge and a local result for each edge in Gsrc. The local result is obtained \nby evaluating the body of rec under p = {$db .. Gsrc}.{$l .. L, $g .. G} with the label L of the edge \nand a subgraph G reachable from the edge. For example, as the local result for edge (3, a, 5) in Gsrc, \nedge (Code 2, d, Code 1) with input node Code 2 and output node Code 1 is generated because the subexpression \n{d : &#38;1}2 is used due to $l = a. The function composerec p glues all pairs of an edge and a local \nresult after adding RecN or RecE to their nodes.Forexample,regardingapairofedge ( = (3, a, 5) and its \nlocal result containing edge (Code 2, d, Code 1), the set ERecE contains edge (RecE 7(Code 2) (, d, RecE \n7(Code 1) () where 7 is the code position of the concerned rec, while set ERecN contains edge (RecN 73 \n&#38;, ., RecE 7(Code 2) () and (RecE 7(Code 1) (, ., RecN 75 &#38;) due to (&#38;, Code 2) . I and (Code \n1, &#38;) . O. The former corresponds to the edge from S35 to E35 of Gview and the latter corresponds \nto two edges from 3 to S35 and from E35 to 5 of Gview. In this ex\u00adample, EE is an empty set since Gsrc \nhas no .-edges. The sets IRecN and ORecN of input and output nodes are obtained with I = {(&#38;, 1)} \nand O = \u00d8, respectively, which are those of Gsrc. Hence, IRecN = {(&#38;.&#38;, RecN 71 &#38;)} and ORecN \n= \u00d8 because M = inMarker(eb) . outMarker(eb)= {&#38;}. Here, . denotes Skolem function (Buneman et al. \n2000) that satis.es (&#38;x.&#38;y).&#38;z = &#38;x.(&#38;y.&#38;z) (associativity) and &#38;.&#38;x \n= &#38;x.&#38; = &#38;x (left and right identity).  (( ) More concretely, if the source graph is s = \n1 ) ba 2 , a2d xc(s)( gives the graph RecN 71 &#38; ) y _ ( )( ) RecE 7(Code 6) (1, b, 2) RecE 7(Code \n2) (1, a, 2) b d ( )( ) RecE 7(Code 5) (1, b, 2) RecE 7(Code 1) (1, a, 2) ( y ))4 RecN 72 &#38; d \n8 which is bisimilar to the graph .. . b 5. Backward Evaluation of UnCAL With traceable views and the \n.-marker preserving property (Sec\u00adtion 3) on the modi.cation of such views, backward evaluation (in Stage1) \nturnsouttobe simplerfortwo reasons. First, the graph constructors becomeinvertible.For instance,if G \n= G1 . G2, G is modi.ed to G ', but the modi.cation is .-marker preserving; then, we can follow tracing \ninformation, .-edges, and marker information to uniquely decompose G ' to G ' 1 and G ' 2 such that G1 \n' . G ' 2 = G ' holds.\u00b6 We will write this \u00b6 G1(V1,E1,I1,O1) = G2(V2,E2,I2,O2), the exact equivalence \nof two graphs, is de.ned by V1 = V2 . E1 = E2 . I1 = I2 . O1 = O2.  n. o . fwd eachedge(G( ,E, ), p,e)= \n((, F[ e] pd ) . ( . E, label(() == c, pd = p .{$l .. label((), $g .. subgraph(G, ()} , composep (G, \n(V, E, I, O),M)=(VRecE . VRecN,ERecE . ERecN . EE,IRecN,ORecN) rec where VRecE = {RecE pv ( | ((, (Vd \n,,, )) .G,v . Vd } ERecE = {(RecE pu (,l, RecE pv() | ((, ( ,Ed ,, )) .G, (u, l, v) . Ed} VRecN = {RecN \npv &#38;m | v . V, &#38;m . M} ERecN = {(RecN pv &#38;m, c, RecE pu() | &#38;m . M, (( =(v, , ), ( , \n,Id , )) .G, (&#38;m, u) . Id} .{(RecE pu (,c, RecN pv &#38;m) | &#38;m . M, (( =( , ,v), ( , , ,Od)) \n.G, (u, &#38;m) . Od} EE = {(RecN pv &#38;m, c, RecN pu &#38;m) | (v, c, u) . E, &#38;m . M} IRecN = \n{(&#38;n.&#38;m, RecN pv &#38;m) | (&#38;n, v) . I, &#38;m . M} ORecN = {(RecN pv &#38;m, &#38;n.&#38;m) \n| (v, &#38;n) . O, &#38;m . M} Figure 6. CoreofForward Semanticsof rec at Code Position p decomposition \nas decompG1.G2 ., and applying it to G ' will give (G ' 1,G ' 2). Second, backwardevaluationofastructural \nrecursion rec(e) is reduced to that of its body e (followedbyresult gluing), because of thebulk semanticsof \nstructural recursion. Backward evaluation greatly depends on what updates are al\u00adlowed on the view.We \nallow the following three general updates on our edge-labeled graphs: (1) in-place updates as modi.cation \nof edge labels, (2) deletion of edges, and (3) insertion of edges or a subgraph rooted at a node. And \nwe accept a sequence of these updates on the view and re.ect them to the source. In the rest of this \nsection, we shall explain the respective backward evaluation for these updates on views. (G1 = G2), then \nthe binding on the left is adopted, and vice versa.Ifboth are updatedtodifferentvalues,itfails, leadingtothe \nfailure of the entire backward evaluation. Label variable bindings are treated similarly. We have omited \nthe de.nitions for other constructor expres\u00adsions, which can be de.ned similarly. Variable. Avariable \nsimply updates its binding as B[[$v]](p, G ' )= p[$v . G ' ]. Here, p[$v . G ' ] is an abbreviation for \n(p \\{$v .. }) .{$v .. G ' }. Condition. The backwardevaluationofa conditionis de.nedby 8< = l2 then e1 \nelse e2]](p, G ' ' '' p1 if l1p = l2p . l1p1 = l2p1 B[ if l1 ) 5.1 Re.ection of In-place Updates In \nthis section, we formally de.ne backward semantics for UnCAL, ' '' p2 if l1p .2 . = l2p . l1p = l2p = \n2 : where only in-place updates are considered. FAIL otherwise Recall thatbackward semantics B[ e]](p, \nG ' ) is used to compute a new environment from the original input environment p and the modi.ed view \nG '. Like forward semantics, backward semantics can be de.ned inductively over the construction of expression. \n5.1.1 Backward Evaluation of Simple Expressions Graph Constructor Expressions. Since each constructor \nis re\u00advertible and is associated with a decomposition function, we can decompose the views of constructor \nexpressions so as to de.ne the backward semantics inductively.For example, we have B[[(e1 . e2)p]](p, \nG ' )= B[ e1]](p, G ' 1) \u00d8p B[ e2]](p, G2' ) where G1 = F[ e1] p G2 = F[ e2] p (G ' 1,G ' 2)= decompG1.G2 \n(G ' ) UnlikeFosteretal. (2005),wehavevariable binding,and therefore multiple environments produced by \nbackward evaluation of the operands are merged by \u00d8p de.ned below, using an approach similar to that \nin Liu et al. (2007), which deals with variable bindings. where p1 ' = B[ e1]](p, G ' ) p ' 2 = B[ e2]](p, \nG ' ), which is reduced to the backward evaluation of e1 if l1 = l2 holds,andtothe backwardevaluationof \ne2 otherwise.Toguarantee well-behavedness, we ensure that l1 = l2 does not change after backward evaluation. \n 5.1.2 Backward Evaluation of Structural Recursion Duetothe traceablebulkforwardevaluationof structural \nrecursion rec and the .-marker preserving property that retains similarity in shape between input and \noutput graphs, backward semantics can easily be de.ned as B[ rec('($l, $g).eb)(ea)]](p, G ' ) = merge(p, \nea,Ea, bwd eachedge(Ga, p, eb, decomprec(G ' ,Ea))) where Ga =( ,Ea,, )= F[ ea] p This de.nition is easy \nto understand if we note duality with the def\u00adinition of its forward semantics. Backward semantics .rst \ndecom\u00ad poses through decomprec the modi.ed result graph G ' into pieces of graphs, which is intuitively \nan inverse operation of composerec. For every non-. edge ( . Ea in the source argument graph, the de\u00ad \ncomposition extracts (possibly modi.ed) subpart G 'd of G ', which originates at the result Gd of the \nforward computation on the edge. Then, in bwd eachedge,we carry out backward computation of the 8< (p1 \n\u00d8p p2) ($v .. mg(G, G1,G2) ...... 9= ; = G2 ($v .. G1) . p1, ($v .. G) . = G . G1 p, = : ($v .. G2) \n. p2 8< : G1 if G2 where mg(G, G1,G2)= G2 if G1 = G bodyexpression eb on each edge and compute the updated \nenviron-FAIL otherwise ment pd'. Finally, these environments are mergedinto the updated environment p \n' of the whole expression. The merge function does \u00d8p uni.es each binding by mg. If only the binding \non the left hand side is modi.ed(G2 = G), or both are consistently updated twopiecesofwork. First,bycombiningthe \ninformation pd'($l) and pd'($g) from the updated environments (and .-edgesexistingin the edges Ea of \nthe source argument graph), it computes the modi\u00ad .ed argument graph G ' a. Then, we inductively carry \nout backward . It would be more precise to write it as decompG1,.,G2 in that the decomposition depends \non three arguments.  8 >>>>< 9 >>>>= ( . Ea, label(() = = c, V ' = {w | (RecE pw() . V ' }, d E ' \n= {(w1,l, w2) | (RecE pw1 (, l, RecE pw2 () . E ' }, d {(&#38;m, w) | (RecN pv &#38;m, c, RecE pw() \n. E ' }, {(w, &#38;m) | (RecE pw (,c, RecN pv &#38;m) . E ' } o decomp rec ((V ' ,E ' ,I ' ,O ' ),Ea)= \n' ((, (V ' ,E ' ,I ,O ' d dd d )) >>>>: ' .......... >>>>; I = d O ' d = ... n bwd eachedge(G, p, e, \nG ' )= ((, B[ e]](p,G ' dd ((, G ' ) .G ' d ,p )) = p .{$l .. label((), $g .. subgraph(G, ()} ((,p \n' d o ... d Un ' merge(p, ea,Ea, R)= B[ ea]](p, G ' ) .p p a S \\{$l .. ,Ia,Oa  }\\{$g .. } ) .R d S \nV '' G ' = a d E '' d where ,Eeps . Eeps = {(u, c, v) | (u, c, v) . Ea} (V '' ,E '' )= V ' .{u},E ' \n.{(u, p ' ($l),I ' (&#38;))} for each ((,p ' ) .R, letting (u, , )= ( and (V ' ,E ' ,I ' ,O ' )= p ' \n($g) ddd d dd d ddddd  Figure 7. Core of Backward Semantics of rec at Code Position p evaluation on \nthe argumentexpressionea to obtain another updated ''' ' environment pa. This pa and all pd s are merged \ninto p . Letusexplainin more detailthe de.nitionof decomprec,which is thekeypointof the backwardevaluation. \nThe function .rst extracts from result graph G ' nodes Vd ' and edges Ed ' that belong to each edge ( \nby matching trace ID RecE p(. Note that if there are nodes that have been freshly inserted into the view, \nwe also require these nodes to have this structure, so that these nodes are also passed to the backward \neval\u00aduation of the recursion body. Input and output nodes with marker &#38;m are recovered by selecting \nthose pointed from/to hub nodes having structure RecN &#38;m.Top-level constructors of trace ID are erased \nso that we can inductively compute the backward image from the body expression. Example 7. Recall the \nsimpleexample in Example3 where the ( ) b ( ) source is s =1 a 2 , and a2d xc(s) gives the graph G. If \nthe graph G is modi.ed to G ' where the edge label b is updated to X, then B[ a2d xc]]({$db .. s},G ' \n) returns binding {$db .. s ' } ( ) X ( ) where s ' =1 a 2 . Therefore, the in-place update of the change \non the view graph is re.ected to the source. Lemma 2 (Well-behavedness for In-place Updates). If output \ngraphs are modi.ed by in-place updates on edges, then for any expression e, the two evaluations F[ e] \nand B[ e]]( , ) form a well-behaved bidirectional transformation, if theysucceed. Proof. This statement \ncan be proved by induction on the structure of e. For the base case where e is a variable, it clearly \nholds. Considering the inductive case, (1) if e is a constructor expression, it holds because each constructor \nis revertible within our context, (2) if e is a condition, its backward evaluation is reduced to that \non either its true branch or itsfalse branch, so the statement holdsby induction, and (3) if e isa structural \nrecursion,bybulk semantics, its backward computation is reduced to its body expression, so the statement \nholds by induction.  5.2 Re.ection of Deletion Deletion in a view is re.ected as deletion of the corresponding \npart in the source by using trace IDs. Suppose we want to delete the edge labeled d in the view of Example \n7. Since both endpoints of the edge have trace IDs of the form RecE 7 (1, a, 2), we can see that the \nselected edge has been generated due to the existence of the source edge (1, a, 2), which is the corresponding \npart to be deleted in the source. In general, for a labeled edge ( =(u, l, v) with l .., its = corresponding \nedge corr(() is de.ned as: corr((u, l, v)) = (u, l, v) if u, v . SrcID corr((RecE pu( ' ., l, RecE pv( \n' )) corr((u, l, v)) if corr((u, l, v)) .= FAIL = corr(( ' ) if corr((u, l, v)) = FAIL corr(()= FAIL \notherwise. Here, FAIL means failure on .nding the corresponding edge. The .rst case means that if the \nedge ( is a copyof an edge in the source, then ( itself is the corresponding edge. The second and the \nthird cases are for when ( is a result of some structural recursion. According to the forward semantics \nof rec in Figure 6, the non-. edge ( must have the form (RecE pu( ' , l, RecE pv( ' ) for some p, u, \nv, and another non-. edge ( '. This means that ( consists of an edge (u, l, v) originating from an evaluation \nof a recursion-body at ( '. Hence, for this case, we .rst recursively trace the corresponding source \nof (u, l, v),andif thisfails, thentry thatof( '. In other cases, corr fails to .nd the corresponding \nsource, because it must be the case that u hasatraceIDoftheform Code ,meaning that the edge is not derived \nfrom the sourcebut from an UnCALexpression. Let $db be the source graph, Gview be the view produced by \nF[ e] p from a forward computation of expression e with en\u00advironment p, and G ' be a graph from Gview \nview with a set of edges Dout = {(1,...,(n} removed. Our backward evaluation B[ e]](p, G ' view) consists \nof the following three steps. 1. Compute the set of source edges Din = {corr((i) | (i is not an .-edge}. \n 2. If FAIL . Din, backward evaluation fails. If it is obtained successfully withoutfailure, compute \n ' Gsrc = p($db) - Din, where G - E denotes removal of the edges in the set E from graph G. 3. Return \np ' = p[$db . G ' ] as the result if F[ e] p ' = G ' srcview, andfail otherwise. Lemma3(Well-behavedness \nfor Deletion). If output graphs are modi.ed by edge deletion, then for any expression e, the two eval\u00aduations \nF[ e] and B[ e]]( , ) form a well-behaved bidirectional transformation, if theysucceed. Proof. The (GETPUT) \nproperty is clear because of the fact that Din = \u00d8 if Dout = \u00d8. For the (WPUTGET) property, it holds \nbecause the third step actually does this check.  5.3 Re.ection of Insertion Re.ection of insertion \nis much more complicated than that of inplace-updating and deletion. This is because there are no corre\u00adsponding \nedges in the source for the freshly inserted edges in the view, which requires us not only to create \nnew informationbut also to add it to a proper location in the source graph. Our idea was to use the Universal \nResolving Algorithm (URA) (Abramov and Gl\u00a8 uck 2002), a powerful method of inversion com\u00adputation,toderivearightinverseoftheforwardevaluation,and \nuse the distributive property of structural recursion rec(e)($g1 . $g2 )= rec(e)($g1 ) . rec(e)($g2 ) \nto properly re.ect insertion to the source. In this section, we shall give our algorithm for this re.ection, \nbefore we highlight how URA can be used to derive the right inverse. 5.3.1 Insertion Re.ection with Right \nInverse We assume the monotonicity of insertion in that an insertion on the view is translated to an \ninsertion on the source rather than other updating operations. The monotonicity comes from the absence \nof isEmpty (Bunemanetal.2000)in our core UnCAL.Weonly con\u00adsider insertion on the viewgraph producedbyforward \ncomputation ofavariableexpression ora structural recursion.For the caseofa variable, this re.ection is \ndone in the same way as in Section 5.1.1. Insertion for structural recursion, the basic computation unit \nin Un-CAL, needs to be carefully designed. In the following, we will fo\u00adcus on structural recursion, \nomitting other cases for simplicity. Before giving our re.ection algorithm, we should clarify the meaning \nof right inverse. In general, a function h is saidtobea right inverse of f if for anyx in the range of \nf,f(h(x)) = x holds. Within our context, for an expressione and a graph G, F.[ e]](G) is said to be a \nright inverse computation if it returns p ' such that F[ e] p ' = G. Now, we will return to our re.ection \nalgorithm. Let Gsrc be the source graph, Gview = F[ rec(e)($db)]]p, where p = {$db .. Gsrc}, and G ' \nbe a graph from G with new edges inserted. view Notice that it is suf.cient to consider $db as the argument \nof rec, because $db can be bound to other expression. Our backward evaluation B[ rec(e)($db)]](p, G ' \np as the result if view) returns there are no new edges inserted in Gview; otherwise, it does the following: \n1. Extract the inserted subgraph G ' from G ' view such that '' Gview = Gview . G. 2. Compute with right \ninverse computation: ' = F.' p1 [ rec(e)($db)]](G ). 3. Return p ' 2 = {$db .. Gsrc . p1' ($db)} as the \nresult. The .rst step of extraction is possible provided that insertion happens at the root node**. The \nsecond step of right inverse com\u00adputationwillbeexplainedin Section 5.3.3.Thelaststepistoupdate the binding \nof $db and return this environment as our result. The following lemma shows the correctness of the algorithm. \nLemma4(Well-behavedness for Insertion). If output graphs are modi.ed by edge insertion, then for a structural \nrecursion of the form rec(e)($db) where e contains no free variables, then two evaluations F[ e] and \nB[ e]]( , ) form a well-behaved bidirec\u00adtional transformation, if theysucceed. ** Insertions to non-root \npositions are possible due tobulk semantics that allows similar treatment for every node. Proof. First, \nthe (GETPUT) property clearly holds because p is re\u00adturned when no insertions occur. Next, we prove the \n(WPUTGET) property by using the following calculation. F[ rec(e)($db)]]p2 ' = { partial application } \nF[ rec(e)(p2' ($db))]]p2 ' ' = { def. of p } 2 F[ rec(e)(Gsrc . p1' ($db))]]p2 ' = { structural recursion \nproperty }F[ rec(e)(Gsrc) . rec(e)(p1' ($db)))]]p ' 2 = { forward evaluation } ' '' F[ rec(e)(Gsrc)]]p2 \n.F[ rec(e)(p1($db)))]]p2 = { e does not contain free variable } Gview .F[ rec(e)($db)]]p1 ' = { right \ninversion } Gview . G ' It is worth noting that we have simpli.ed our discussion in both the above algorithm \nand lemma by making it a requirement that e in rec(e)($db) does not contain any free variables. With \nthis requirement, our forward and backward evaluation satis.es the stronger (PUTGET) property. Infact, \nit is acceptable to relax this condition by allowing e to contain other free variables and the initial \np contains binding of other variables. Then, right inversion will produce p1 ' that will be used to update \nall variable bindings in addition to $db. In this case, F[ rec(e)(Gsrc)]]p ' 1 may produce a graph that \nis different from the original view Gview. In any case, this different graph will not have an additional \neffect on the source when we apply backward evaluation to this new graph. Therefore, (WPUTGET) always \nholds. With this idea, we shall propose an algorithm in which (PUTGET) property is satis.ed without any \nadditional require\u00adments. The idea is to utilize theTrace ID information, as will be discussed later. \n 5.3.2 Improving Insertion Re.ection The method above satis.es the (PUTGET) property only if the variables \nof e are disjoint from the variables bound in the initial environment p. However, in general, since a \ntransformation may havemultiplevariable references, moreeffortis requiredto achieve the (PUTGET) property. \nWe tackle the problem by .rst locating where we insert a graph by using trace IDs, and then applying \nthe URA algorithm (to be described later) to .nd what graph should be inserted. Consider the transformation \na2d xc and the viewin Example 6. Suppose we want to insert a graph Gvins rooted at the view node v = \nRecN 72 &#38;. Where should some graph be inserted into the source to re.ect this insertion? The answer \nis that we must insert a graph rooted at the source node 2 because there would be no edge from v in the \nview unless there were an edge from 2 in the source according to thebulk semantics of structural recursion. \nNow, our next task is to .nd what graph should be inserted under the source node 2. That is, we hope \nto .nd Gsins such that the following holds. ! ( ) b ( ) \u00ad a2d xc 1 a 2 Gsins ( ) RecN 71 &#38; y ( ) \n( ) RecE 7(Code 4) (1, b, 2) RecE 7(Code 2) (1, a, 2) y b y d = ( ) ( ) RecE 7(Code 3) (1, b, 2) RecE \n7(Code 1) (1, a, 2) y. ( ) - RecN 72 &#38; Gvins  tr(SrcID)= SrcID tr(RecN tid )= tr(tid) tr(Code )= \nFAIL tr(RecE tid )= tr(tid) Figure 8. Tracing Node ID URA can help us to .nd such Gsins for Gvins. For \nexample, if Gvins is {b : {}}, then URA returns Gsins = {b : {}}. If Gvins is {d : {}}, then URA returns \none of the possibilities, Gsins = {a : {}} or Gsins = {d : {}}, depending on the search method used in \nURA. According to the soundness and the completeness of URA, the re.ection by URA is always correct in \nthe sense that (PUTGET) holds, and moreover URA always returns a Gsins if such Gsins exists. Of these, \nsoundness is the keyto insertion re.ection satisfying(PUTGET) for general UnCAL transformations. In summary, \nour insertion-re.ection algorithmis as follows. 1. Let v be a node under which we want to insert a graph \nGvins. 2. By using the tr function in Figure 8, we .nd the source node u = tr(v) underwhichwe insertagraphto \nre.ectthe insertion. 3. Let G ' view be a graph obtained from the view by adding .-edge from v to Gvins. \n 4. We .nd a graph Gsins connected from u by an .-edge, by applying URA for G '  view. 5. We return \na graph G ' obtained from the source by adding an src .-edge from u to Gsins. The soundness of the insertion-re.ection \nalgorithm is directly derived from the soundness of URA. Lemma5(Soundness of Insertion). Our insertion-re.ection \nalgo\u00adrithm satis.es (PUTGET). Note that we use URA for G ' view instead of Gvins. Thus, URA rejects anyinsertion \nof Gsins that violates (PUTGET). In addition, our insertion-re.ection algorithmis complete in the sense \nthat, if there exist some source insertions to re.ect the view insertion under some conditions, the algorithm \nwill .nd one of them. Lemma6(Completeness of Insertion). Let v be a node suchthat tr(v) .FAIL.For any \nsource graph G, we can insert any graph = into its view if there exists a source insertion that re.ects \nthe view insertion and v still occurs in the view of the insertion-re.ected source. Recall that we only \nconsider insertion on the view graph pro\u00adduced by forward computation of a variable expression or a struc\u00adtural \nrecursion, which is expressed by tr(v) .FAIL. This lemma = can be proved using the property of trace \nIDs stating that, to insert a graph rooted at view node v, we must insert a graph rooted at source node \ntr(v). By induction on the trace ID of v, we can show that, if there is an edge from v, it must be the \ncase that there is an edge from tr(v),whichisimpliedbythe propertyoftraceIDs.Note that Gvins has no edge \nto the original view. However, this is not a restriction since if there is a crossing edge pointing to \na subgraph of the original view, we can duplicate the subgraph and integrate it to Gvins so that the \nedge can be eliminated.  5.3.3 RightInverse Computationby URA Recall that the right inverse computation \nof an expression e is to take a graph Gview and return a p such that F[ e] p = Gview. We adopt theuniversal \nresolving algorithm (URA) (Abramov and Gl\u00a8 uck 2002),apowerfuland generalinversion mechanism,to com\u00adpute \np. The basic idea behind URA is to search on a perfect pro\u00adcess tree (Gl\u00a8 uck and Klimov 1993), which \nrepresents all possible computations of an expression, and to .nd a computation path that produced the \nresult. Our right inverse computation consists of three steps. 1. It lazily enumerates possibleevaluation \npathsbysymbolic com\u00adputation called needed narrowing (Antoyet al. 1994) . 2. From the generated evaluation \npaths, it constructs a table of input/output pairs of computations. 3. If there is a pair in the table \nwhose output is Gview, it generates a substitution (environment) from the path and returns it as the \nresult.  Example 8. As a simple example, let us see how we .nd p such that F[ a2d xc($x)]]p = Gview \nwhere Gview = {d : {}}. We search p by symbolic evaluation of a2d xc($x).To evaluate a2d xc($x), we unfold \n$x and recur\u00adsively evaluate a2d xc, i.e., a structural recursion. There are many ways to instantiate \n$x such as $x .. {}, $x .. {$l1 :$x1}, $x .. {$l1 :$x1, $l2 :$x2}. If we choose $x .. {}, the computation \n.nishes, yielding a table consisting of an input/output pair ({}, {}). Since this table does not contain \na pair whose output is Gview, we continue searching. Assume that we choose $x .. {$l1 :$x1}. Then a2d \nxc($x ) is unfolded to (if $l1 = a then {d : &#38;} else (if $l1 = c then {. : &#38;} else {$l1 : &#38;})) \n@a2d xc($x1). As evaluation gets stuck here because of a free variable $l1 in the if condition, we .nd \na suitable $l1 to resume the evaluation. If we choose $l1 .. a, then the expression is reduced to {d \n: &#38;} @a2d xc($x1) and input/output pair ({a : {}}, {d : {}}) is obtained by choosing $x1 .. {}. Since \nGview = {d : {}}, wegather all bindings along this computation and return the following environment as \nthe result. {$x .. {a : {}}} Figure9 shows partofa perfect process treein our right-inverse computation: \nthe left is the tree and the right is a table of a pair of input/output graph templates (it is more general \nthan a pair of input/output graph instances, as we discussed above). Note this tree is a variant of SLD-resolution \ntrees (Gl\u00a8uck and S\u00f8rensen 1994). To use URA effectively for our right inverse computation of UnCAL, \nwe de.ne a small-step semantics for UnCAL such that a perfect process tree can be constructed though \nthese small steps. The only non-standard feature of this semantics is that we use memoization to avoid \nin.nite loops probably caused by cycles in the source graph (See Appendix of (Hidaka et al. 2010) for \ndetails). In addition, we provide a Dijkstra-searching strategy to enumerate all the possible evaluation \npaths so that a solution can always be found if one exists. The two heuristics we use to design the cost \nfunction are: We use a (weighted) size of graphs (to be inserted into the source) as a cost function \nin the Dijkstra-search.  For the weighted size, the depth (the length of the path) has more weight than \nthe width (the number of paths). This strategy works nicely for consecutive in Example 4.  Moreover,weshowthatasuitablebindingto \ncontinueevaluationof conditional expressions can easily be found for our core UnCAL, because the conditional \npart of a conditional expression is in the simple form of l1 = l2. The same notion is called driving \n(Gl\u00a8uck and Klimov 1993; Gl\u00a8uck and S\u00f8rensen 1994)in (Abramov andGl\u00a8 uck 2002).  Input/OutputPairs Gsrc \nGview . T t at dT t c T t$l1 t$l1 $l1 . = a, c .. . ... ... \\ \\ a \\a\\d - . d-. - T .. . ... ... Figure \n9. URA for a2d xc and Enumerated Input/OutputPairs with Constraints (nodes without branchinghave been \ncontracted) 6. Implementation and Experiments The prototypesystemhasbeen implementedandisavailableonour \nBiG projectWebsite.In additiontoalltheexamplesin Buneman et al. (2000) and in this paper, we have tested \nthree non-trivial examples, demonstratingits usefulnessin software engineeringand database management. \n Customer2Order:Acase study in the textbook on model-driven software development (Pastor and Molina 2007). \n PIM2PSM:Atypical example of transforming a platform inde\u00adpendent object model to a platform speci.c \nobject model.  Class2RDB;Anon-trivial benchmark application for testing the power of model transformation \nlanguages (Bezivin et al. 2005).  All of these have demonstrated the effectiveness of our approach in \npractical applications. In our implementation, we carefully treat .-edges introduced during operations \nrelated to markers, and retrieval of edges or nodes of interest, which greatly affect performance. Poor \ntreatment would hinder large-scale UnQL queries to evaluate in bidirectional mode in a reasonable amount \nof time. Speed-up of several orders of magnitude has been achieved since our initial implementation due \nto the above and the following optimizations. Reduction in number of .-edges As mentioned in the UnQL \npa\u00adper (Buneman et al. 2000), .-edges are generously generated dur\u00ading evaluation, especially in rec. \nThis slows the evaluation pro\u00adcess due to the increase in input size. Removing .-edges during evaluation \nhas no harm on forward semantics because of bisimu\u00adlation equivalence. However, since .-edges play an \nimportant role in backward evaluation, theyare not freely omitted in our bidirec\u00adtional settings. Moreover, \na straightforward implementation of the removal algorithm (Buneman et al. 2000) may introduce additional \nedges, which may harm backwardevaluation.Toward prudently re\u00admoving .-edges that are suitable for backward \nevaluation, our .\u00adremoval algorithm glues source and destination nodes of . as long as bisimulation equivalence \nis not violated. Optimization by fusion transformation Note that the backward evaluation of rec(e1)(rec(e2)(e3)), \na composition of structural recursions, requires to generate intermediate result of backward transformation, \nwhich is very expensive. This can be avoided by fusingthetwostructural recursionsinto one.Wehaveimplemented \nthis based on the fusion rule (Buneman et al. 2000): if e1(l, G) does not depend on G then rec(e1)(rec(e2)(e3)) \n= rec(rec(e1) . e2)(e3).With auxiliary rewriting rules such as e1 @e2 = e1 for e1 that produces no output \nnodes, 30% and 50% of CPU time reduc\u00adtions are respectively achieved for forward and backwardexecution \nNote thatwe preserveevery resultof forward computationinthe bidirec\u00adtional mode. in Customer2Order composed \nwith selection, 30% and 65% reduc\u00adtions for simpler examples that appeared in the evaluation for uni\u00addirectional \ntransformation (Hidaka et al. 2009). These experiments arefor in-place updates,but similar reduction \ncouldbe achievedfor other updates. 7. RelatedWork Bidirectional transformation has been discussed as \nview updat\u00ading problem in the database community. Bancilhon and Spyratos (1981) proposed a general approach \nto the view updating problem. Theyintroduced an elegant solution based on the concept of a con\u00adstant \ncomplementviewthat capturesthe informationintheviewbut not in the original database. Their idea was not \nonly applied to re\u00adlational databases (Hegner 1990; Lechtenb \u00a8 orger andVossen 2003) but also to tree \nstructures (Matsuda et al. 2007). Constant comple\u00adment views satisfy very strong bidirectional properties \nat the sac\u00adri.ce of the number of re.ectable updates. Although such strong properties are nice for some \napplications (Hegner 1990), theyare too strong for our purpose, i.e., model transformation in software \nengineering. Recent work by Fegaras (2010) propagates updates on XML views created from relational databases. \nIt supports dupli\u00adcatesbut detectsviewsideeffectsatbothcompileandruntime. In the area of programming \nlanguages, view updating has been studied as bidirectional transformation. Foster et al. (2005) pro\u00adposed \nthe .rst linguistic approach to solving this problem. They developed some domain speci.c languages to \nsupport the develop\u00adment of bidirectional transformation on strings and trees. Bohannon et al. (2006) \napplied these techniques to relational databases, mak\u00ading use of functional dependencies in relations \nto correctly prop\u00adagate updates. However, their approach is limited to strings, trees and relations, \nand is dif.cult to apply to graph transformation due to graph-speci.c features such as circularity and \nsharing. Within the context of software engineering, there has been sev\u00aderal works on bidirectional model \n(graph) transformation (Ehrig et al. 2005; Jouault andKurtev 2005; OMG 2005; Sch\u00a8urr and Klar 2008; Stevens \n2007), which can deal with kinds of graph structures. However, theylacka clear formal bidirectional semantics \nand there has not yet been anypowerful method of bidirectionalization that can be used to automatically \nderive backward model transforma\u00adtions from forward model transformations, so that both transforma\u00adtions \ncan form a consistent bidirectional model transformation. The concept of structural recursion is not \nnew and has been studied in both the database (Breazu-Tannen et al. 1991) and the functional programming \ncommunities (Sheard and Fegaras 1993). However, most of these have focused on structural recursion over \nlists or trees instead of graphs. Examples include the higher order function fold (Sheard and Fegaras \n1993) in ML and Haskell, and the generic computation pattern called catamorphism in programming algebras \n(Bird and de Moor 1996). UnCAL (Buneman et al. 2000) demonstrates that the idea of structural recursion \ncan be extended to graphs,butthe original focuswasonthe optimizationof query fusion rather than bidirectionalization. \n Our work was greatly inspired by interesting work on ef.cient graph querying (Buneman et al. 2000; \nSheng et al. 1999). Un\u00adlike trees, graphs involve subtle issues on their representation and equivalence. \nThe use of bisimulation and structural recursion in (Bunemanetal.2000) opensanewwayofbuildingaframeworkfor \nboth declarative and ef.cient graph querying with high modularity and composability.Thismotivatedustoextendtheframeworkfrom \ngraph querying to graph transformation and apply it to model trans\u00adformation (Hidaka et al. 2009). This \nwork is a further step in this direction to extend it from unidirectional model transformation to bidirectional \nmodel transformation. 8. Concluding Remarks This paper reports our .rst attempt toward solving the challeng\u00ading \nproblem of bidirectional transformation on graphs. We show that structural recursion on graphs and its \nunique bulk semantics play an important role not only in query optimization, which has been recognized \nin the database community,but also in automatic derivation of backward evaluation, which has not been \nrecognized thusfar.Asfar as we areaware, the bidirectional semanticsof Un-CAL proposed in this paper \nis the .rst complete language-based framework for general graph transformations. Future work includes \nextending the framework from unordered graphs to ordered graphs, introducing graph schemas to provide \nstructural information for more ef.cient bidirectional computation, an ef.cient algorithm for checking \nupdatability, and more practical applications of the system for bidirectional model transformation in \nsoftware engineering. Acknowledgments We thank Mary Fernandez who kindly provided us with the SML source \ncodes of an UnQL system. We thank Fritz Henglein and James Cheney, and anonymous reviewers for their \nthorough com\u00adments on earlier versions of the paper. The research was supported in partby the Grand-Challenging \nProject on LinguisticFounda\u00adtion for Bidirectional Model Transformation from the National Institute of \nInformatics, Grant-in-Aid for Scienti.c Research No. 22300012, No. 20500043, and No. 20700035. References \nS. M. Abramov and R. Gl\u00a8uck. Principles of inverse computation and the universal resolving algorithm. \nIn The Essence of Computation, pages 269 295, 2002. S. Antoy, R. Echahed, and M. Hanus. A needed narrowing \nstrategy. In POPL 1994, pages 268 279, 1994. F. Bancilhon and N. Spyratos. Update semantics of relational \nviews. ACM Trans. Database Syst., 6(4):557 575, 1981. J. Bezivin,B. Rumpe,andT.L.Sch\u00a8 urr A. Model transformation \nin practice workshop announcement. InMoDELS Satellite Events 2005,pages 120 127, 2005. R. Bird and O. \nde Moor. Algebras of Programming. Prentice Hall, 1996. A. Bohannon,B.C. Pierce,andJ.A.Vaughan. Relational \nlenses:alanguage for updatable views. In PODS 2006, pages 338 347, 2006. V. Breazu-Tannen, P. Buneman, \nand S. Naqvi. Structural recursion as a query language. In DBPL 1991, pages 9 19, 1991. P. Buneman,M.F. \nFernandez,andD. Suciu. UnQL:a query languageand algebra for semistructured data based on structural recursion. \nVLDBJ., 9(1):76 110, 2000. J. Cheney, U. A. Acar, and A. Ahmed. Provenance traces. CoRR, abs/0812.0564, \n2008. K. Czarnecki, J. N.Foster, Z. Hu, R.L\u00a8ammel, A. Sch\u00a8urr, and J.F.Ter\u00adwilliger. Bidirectional transformations:Across-discipline \nperspective. In ICMT 2009, pages 260 283, 2009. U.DayalandP.A. Bernstein.Onthe correct translationofupdate \noperations on relational views. ACMTrans. Database Syst., 7(3):381 416, 1982. K. Ehrig, E. Guerra, J. \nde Lara, L. Lengyel, T. Levendovszky, U. Prange, G. Taentzer, D. Varr\u00b4o-Gyapay.  o, and S. Varr\u00b4Model \ntransformation by graph transformation: A comparative study. Pre\u00adsented at MTiP 2005. http://www.inf.mit.bme.hu/FTSRG/ \nPublications/varro/2005/mtip05.pdf, 2005. L. Fegaras. Propagating updates through xml views using lineage \ntracing. In ICDE 2010, pages 309 320, 2010. J. N.Foster, M. B. Greenwald, J.T. Moore, B. C. Pierce, and \nA. Schmitt. Combinators for bi-directional tree transformations: a linguistic ap\u00adproach to the view update \nproblem. In POPL 2005, pages 233 246, 2005. R.Gl\u00a8uckandA.V. Klimov. Occam s razorin metacompuation:the \nnotion of a perfect process tree. In WSA 1993, pages 112 123, 1993. R. Gl\u00a8  uckandM.H. S\u00f8rensen.Partial \ndeductionanddrivingareequivalent. In PLILP 1994, pages 165 181, 1994. G. Gottlob,P.Paolini, and R. Zicari. \nProperties and update semantics of consistent views. ACMTrans. Database Syst., 13(4):486 524, 1988. S. \nJ. Hegner. Foundations of canonical update support for closed database views. In ICDT 1990, pages 422 \n436, 1990. S. Hidaka, Z. Hu, H. Kato, and K. Nakano. Towards a compositional ap\u00adproach to model transformation \nfor software development. In SAC2009, pages 468 475, 2009. S. Hidaka, Z. Hu, K. Inaba, H. Kato, K. Matsuda, \nand K. Nakano. Bidirec\u00adtionalizing graph transformations. Technical Report GRACE-TR-2010\u00ad06, GRACE Center, \nNational Institute of Informatics, July 2010. Z.Hu, S.-C.Mu,andM.Takeichi.Aprogrammable editorfordeveloping \nstructured documents based on bidirectional transformations. Higher-Order and Symbolic Computation, 21(1-2):89 \n118, 2008. F. Jouault and I. Kurtev. Transforming models with ATL. In MoDELS Satellite Events 2005, \npages 128 138, 2005.  R.L\u00a8ammel. Coupled SoftwareTransformations (Extended Abstract). In SET 2004, Nov. \n2004. J. Lechtenb\u00a8On the computation of relational view  orger and G. Vossen. complements. ACMTrans. \nDatabase Syst., 28(2):175 208, 2003. D.Liu,Z.Hu,andM.Takeichi. Bidirectional interpretationof XQuery.In \nPEPM 2007, pages 21 30, 2007. K. Matsuda,Z.Hu,K. Nakano,M. Hamana,andM.Takeichi. Bidirection\u00adalization \ntransformation based on automatic derivation of view comple\u00adment functions. In ICFP 2007, pages 47 58, \n2007. L. Meertens. Designing constraint maintainers for user interaction. http: //www.cwi.nl/ lambert, \nJune 1998.  OMG. MOF QVT .nal adopted speci.cation. http://www.omg.org/ docs/ptc/05-11-01.pdf, 2005. \nY.Papakonstantinou,H. Garcia-Molina, andJ.Widom. Objectexchange across heterogeneous information sources. \nIn ICDE 1995, pages 251 260, 1995. O. Pastor and J. C. Molina. Model-Driven Architecture in Practice: \nA Software Production Environment Based on Conceptual Modeling. Springer-VerlagNewYork,Inc., Secaucus,NJ,USA,2007. \n A.Sch\u00a8urrandF.Klar.15yearsoftriplegraph grammars.In ICGT 08: Pro\u00adceedingsof the 4th international conference \nonGraphTransformations, pages 411 425. Springer-Verlag, 2008. T. Sheard and L. Fegaras. A fold for all \nseasons. In FPCA 1993, pages 233 242, Copenhagen, June 1993. L. Sheng, Z. M. Ozsoyoglu, and G. Ozsoyoglu. \nA graph query language and its query processing. In ICDE 1999, pages 572 581, 1999. P. Stevens. Bidirectional \nmodel transformations in QVT: Semantic issues and open questions. In MoDELS 2007, pages 1 15, 2007. \n    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Bidirectional transformations provide a novel mechanism for synchronizing and maintaining the consistency of information between input and output. Despite many promising results on bidirectional transformations, these have been limited to the context of relational or XML (tree-like) databases. We challenge the problem of bidirectional transformations within the context of graphs, by proposing a formal definition of a well-behaved bidirectional semantics for UnCAL, i.e., a graph algebra for the known UnQL graph query language. The key to our successful formalization is full utilization of both the recursive and bulk semantics of structural recursion on graphs. We carefully refine the existing forward evaluation of structural recursion so that it can produce sufficient trace information for later backward evaluation. We use the trace information for backward evaluation to reflect in-place updates and deletions on the view to the source, and adopt the universal resolving algorithm for inverse computation and the narrowing technique to tackle the difficult problem with insertion. We prove our bidirectional evaluation is well-behaved. Our current implementation is available online and confirms the usefulness of our approach with nontrivial applications.</p>", "authors": [{"name": "Soichiro Hidaka", "author_profile_id": "81329489357", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2338191", "email_address": "", "orcid_id": ""}, {"name": "Zhenjiang Hu", "author_profile_id": "81100253989", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2338192", "email_address": "", "orcid_id": ""}, {"name": "Kazuhiro Inaba", "author_profile_id": "81384607640", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2338193", "email_address": "", "orcid_id": ""}, {"name": "Hiroyuki Kato", "author_profile_id": "81418592890", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2338194", "email_address": "", "orcid_id": ""}, {"name": "Kazutaka Matsuda", "author_profile_id": "81392597731", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2338195", "email_address": "", "orcid_id": ""}, {"name": "Keisuke Nakano", "author_profile_id": "81100633478", "affiliation": "The University of Electro-Communications, Chofu, Japan", "person_id": "P2338196", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863573", "year": "2010", "article_id": "1863573", "conference": "ICFP", "title": "Bidirectionalizing graph transformations", "url": "http://dl.acm.org/citation.cfm?id=1863573"}