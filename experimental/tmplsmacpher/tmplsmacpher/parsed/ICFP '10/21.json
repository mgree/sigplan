{"article_publication_date": "09-27-2010", "fulltext": "\n Experience Report: Growing Programming Languages for Beginning Students Marcus Crestani University \nof T\u00a8 ubingen crestani@informatik.uni-tuebingen.de Abstract A student learning how to program learns \nbest when the program\u00adming language and programming environment cater to her speci.c needs. These needs \nare different from the requirements of a profes\u00adsional programmer. Consequently, the design of teaching \nlanguages poses challenges different from the design of professional lan\u00adguages. Using a functional language \nby itself gives advantages over more popular, professional languages, but fully exploiting these ad\u00advantages \nrequires careful adaptation to the needs of the students as-is, these languages do not support the students \nnearly as well as they could. This paper describes our experience adopting the didac\u00adtic approach of \nHow to Design Programs, focussing on the design process for our own set of teaching languages. We have \nobserved students as they try to program as part of our introductory course, and used these observations \nto signi.cantly improve the design of these languages. This paper describes the changes we have made, \nand the journey we took to get there. Categories and Subject Descriptors D.2.10 [Software Engineer\u00ading]: \nDesign Methodologies; K.3.2 [Computers and Education]: Computer and Information Science Education Computer \nScience Education General Terms Design, Languages Keywords Introductory Programming 1. Introduction Functional \nprogrammers know that the choice of language affects the thinking of programmers and thus the design \nof software. The choice of language also matters when it comes to teaching intro\u00adductory programming: \nIt profoundly affects the students thinking repertory, as well as their learning experience. An off the \nrack language poses signi.cant challenges for beginners and tends to be an obstacle to learning (Felleisen \net al. 2004; Findler et al. 2002). In 1999, the University of T\u00a8ubingen started revising its intro\u00adductory \ncourse: A functional-programming-based course replaced more traditional previous offerings using Pascal, \nC++, or Java. The course was, to a large degree, based on the classic Struc\u00adture and Interpretation of \nComputer Programs (or SICP) (Abel\u00adson et al. 1996). We were aware at the time of Rice PLT s efforts, \nled by Matthias Felleisen, that would result in How to Design Pro\u00adgrams (or HtDP) (Felleisen et al. 2001), \nwhich, however, had not been published yet consequently, we only had a vague idea of its Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 10, September \n27 29, 2010, Baltimore, Maryland, USA. Copyright c &#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 \nMichael Sperber DeinProgramm sperber@deinprogramm.de central tenets. We used PLT s DrScheme (now called \nDrRacket) for the course, seeing it mainly as a graphical IDE for Scheme, and thus easier to use for \nstudents than traditional Scheme systems. Specif\u00adically, we ignored its hierarchy of language levels \nand instead ran DrScheme in its R5RS mode. Our underlying assumption was the same as that of SICP, namely \nthat the sheer power of functional programming combined with the syntactic simplicity of Scheme would \nmake both teaching and learning so easy that we would .x all the problems of the previous courses instantly. \nHowever, while Scheme .xed many problems, signi.cant issues remained.1 After having written a textbook \non this approach, it took us until 2004 to realize that SICP s example-driven approach to teaching did \nnot work as well as we had expected with a large portion of our students: SICP admirably explains how \nmany concepts of software development abstraction in particular work, but this is not enough to enable \nstudents to solve problems on their own. By this time, HtDP had appeared, and we started to adopt its \ncentral didactic concept, the design recipes, which implement an explicit programming process, driven \nby a data analysis. Adopting the design recipes meant expressing their concepts in code. However, pure \nR5RS Scheme is a poor match for the de\u00adsign recipes it lacks native constructs for compound data, mixed \ndata ( sum types ), and noting violations. Consequently, we started implementing our own language level, \nwhich included the miss\u00ading features and allowed us to adopt HtDP s design recipes, while staying close \nto standard Scheme. We still shunned HtDP s own language levels, as they deviate signi.cantly from R5RS \nScheme. However, even though we did not know it at the time, we had repli\u00adcated the .rst step of PLT \ns own journey towards the language lev\u00adels, and we would replicate more. For reasons initially unrelated \nto the language, we started ob\u00adserving our students as they worked on exercises (Bieniusa et al. 2008). \nSoon, we saw that, despite Scheme s simplicity, students were making syntactic and other trivial mistakes. \nExperienced pro\u00adgrammers see these mistakes immediately, but students often do not. This can be immensely \nfrustrating, and a signi.cant number of students gave up on programming on their own as a result. Dis\u00adturbingly, \nmany of these mistakes could have been detected by the Scheme implementation if only the language and \nthe error mes\u00adsages were restricted to what the students knew. Consequently, we started implementing \nrestrictions in line with the course, and cus\u00adtom error messages replicating another step of PLT s experience. \nMoreover, we saw that some students would read ahead and make use of programming-language features not \nyet covered in the course (most popular: assignments), which destroyed important di\u00addactic points: Thus, \nwe implemented a sequence of progressively bigger language levels, replicating and thus con.rming the \n.nal es\u00adsential step of PLT s development of the HtDP language levels. In 2006, after adding more add-on \nfeatures analogous to HtDP s, such as the handling of images and functional animations, we had lan\u00ad 1 \nWe were wrong about the course on other aspects as well (Bieniusa et al. 2008).  guage levels almost \ncompletely analogous to HtDP s. We also pub\u00adlished our own follow-up textbook, Die Macht der Abstraktion \n(or DMdA, German for The Force of Abstraction) (Klaeren and Sperber 2007). In retrospect, we could have \ngotten there much faster and cheaper. However, at the time, we did not have PLT s experience and the \nrationale for their design, and thus had proudly assumed a not-invented-here stance. Nevertheless, the \ndesign process for our teaching languages did not end there: The HtDP language levels still had insuf.cient \nsupport for some aspects of the design recipes in particular, test cases, mixed data, and contracts. \nMoreover, new desirable aspects of teaching languages emerged most recently, the support for for\u00admal \nproperties of programs. This paper documents our experience with adopting the HtDP approach and evolving \nour teaching lan\u00adguages to better meet the students needs. 2. HtDP s Language Levels The HtDP (and DMdA) \nlanguages have evolved from Scheme, which, at the time, had been the basis for many introductory text\u00adbooks \nand courses, as its small size make it attractive for class\u00adroom use, and beginning students take well \nto the simple Lisp-style parenthesized pre.x syntax. However, standard Scheme does not solve all language \nproblems of the introductory course. Thus, im\u00adproving the students experience meant changing and improving \nthe language, as PLT s TeachScheme! project has been doing since 1995 (Felleisen et al. 2004; Findler \net al. 2002). In particular, students make mistakes when writing code. If the student is to make independent \nprogress, the programming environment must provide feedback that enables the student to .x the mistakes \non her own. These mistakes are often trivial: Syntax errors (which occur even with the trivial Scheme \nsyntax) and type errors can be detected by the programming environment. Helping students .x other kinds \nof mistakes misunderstanding the syntax or using features not yet covered in class require actual changes \nto the languages beginners program in. In DrScheme, at any given time, the beginner uses one of sev\u00aderal \nlanguage levels. A language level is an operation mode of DrScheme that provides a language subset tailored \nto the needs of the beginner at that time. As the student progresses, she switches to more advanced language \nlevels, each of which is a superset of the previous level. Each language level has its own implementation \nof error reporting tailored to the beginner s needs. The error messages only mention terms that the course \nhas introduced up to that point. 3. Popularity= Success Adopting HtDP s insights for what would become \nDMdA was a lengthy process: Prior to the 2004 course, we only had a vague idea what the students were \ndoing when they were on their own. That did not keep us from believing we had a fairly good idea of what \nthey were doing, namely solving their homework problems using the techniques we had taught them. Only \nwhen we started personally supervising lab exercises, we found out that the students did not always follow \nthe path we had laid out for them, and encountered numerous dif.culties. This was easy to address during \npersonal supervision, but would have kept the students from solving homework problems when on their own. \nIn fact, many students resorted to copying somebody else s homework (Bieniusa et al. 2008), and our impressions \nof what the students were doing turned out to be quite wrong, even though we thought we had good reason \nto believe they were right: The course was popular with students, and passing rates were higher than \nwith the previous, traditional courses, even though we had covered more dif.cult material. When we realized \nthis, we started observing our students more closely. Speci.cally, we recorded the mistakes they made, \nthe error messages from DrScheme that reported the mistakes, and the stu\u00addents reaction to the error \nmessages. The authors did this person\u00adally, and additionally trained our student TAs to look for mistakes, \nand report their observations to us. We also tried to raise the stu\u00addents awareness of these issues and \nreport them. However, most of the helpful observations we made ourselves, closely followed by the TAs \nreports we received very little unsolicited feedback from the students, and even this was mostly ad-hoc \nin-class feedback. The following insights from our experience have stayed with us: We did not even know \nwe had a problem, even though we have always maintained an open door and open ears for our students. \nConsequently, it was extremely easy to deceive ourselves that everything was .ne.  Mistakes made by \none student were often repeated by other students.  What seems easy or natural to us does not necessarily \nappear that way to the students.  We could not expect the students to give us, on their own initiative, \nthe speci.c feedback we need to improve the course and the software for the course.  The design decisions \ndocumented in this paper were mostly direct consequences of this action research, which is ongoing. Student \ns scores in the programming exercises of the .nal exams have con\u00adtinually risen since we have adopted \ndesign recipes and started im\u00adproving our teaching languages. 4. Simple Differences The original DMdA \nlanguages of 2006 differed from the HtDP languages in several minor ways partly to reduce the differences \nwith standard Scheme, and partly to cater more speci.cally to our German audience. The HtDP languages \ngenerally appeal to the students prior training in algebra, sacri.cing some of the original Scheme syntax, \nwhereas the DMdA languages stay closer to the original Scheme. The differences illustrate some of the \ndecisions designers of languages for beginners face. 4.1 Procedure/Function De.nitions The difference \nin the handling of algebra is most visible in proce\u00addure de.nitions: In HtDP, procedures (called functions \nthere) are de.ned with the usual Scheme syntactic sugar: (define (f x) ...) This emphasizes the similarity \nto function de.nitions in mathemat\u00adics as well as the visual congruence between function de.nitions and \ncalls, and makes it easy to see the substitution that occurs. Conversely, DMdA s procedure de.nitions \nuse an explicit lambda: (define f (lambda (x) ...)) This makes it easier later to introduce higher-order \nprocedures, as it is straightforward to move the lambda somewhere else as opposed to explaining the concept \nof syntactic sugar, but loses the visual congruence. This is no great loss, however, as German students \ntypically cannot identify the mathematical substitution principle, anyway the subject does not play the \nexplicit role in German high school that it enjoys in US curricula.2 Explaining it from scratch with \nlambda is thus no more dif.cult than explaining it using the syntactic sugar. 2 Ironically, Felleisen \ntraces back the algebraic aspect to his training in German high school, where algebra sadly has since \nbeen de-emphasized.  4.2 Record De.nitions An important part of HtDP and DMdA is the treatment of com\u00adpound \ndata. Instructors teach students to recognize compound data, and use record de.nitions as implementations \nof the resulting data de.nitions. Teaching compound data effectively is surprisingly dif\u00ad.cult, as beginning \nstudents tend to get confused about the idea of several things becoming one. Both DMdA and HtDP instructors \nteach simple heuristics such as that the number of components in the data de.nition should match the \nnumber of .elds. ( How many parts does a calendar date have? Three! How many .elds does the record-type \nde.nition for calendar dates have? Three! ) This means that the programming aspects of compound data \nought to be as sim\u00adple as possible, to not add to the students burden. Scheme has a long history of record \nwars (Clinger et al. 2005), hence it is no surprise that DMdA and HtDP chose different syntaxes for their \nrecord-type-de.nition forms. HtDP has chosen a so-called implicit-naming form. For example, consider \nthe fol\u00adlowing HtDP struct de.nition : (define-struct ant (weight loc)) This is in fact a de.nition of \nfour procedures: A record constructor called make-ant, a predicate ant?, and two selectors ant-weight \nand ant-loc. The names are not explicitly mentioned in the form, hence implicit-naming. The DMdA teaching \nlanguages provide an explicit-naming form. Here is a de.nition equivalent to the above: (define-record-procedures \nant make-ant ant? (ant-weight ant-loc)) This is more verbose than the HtDP form, but makes it easier \nfor the students to see that the form de.nes identi.ers, and what those identi.ers are. Also, define-record-procedures \nallows choosing arbitrary names for the various procedures, even though we emphasize the value of the \nconventions used above. Moreover, the DrScheme Rename menu entry works with explicit naming form, but \nnot with the implicit naming. Some instructors in Germany experimenting with the HtDP lan\u00adguages reported \nthat a signi.cant number of students had dif.\u00adculty understanding the magic of implicit naming. This \npartic\u00adular problem is not as signi.cant in DMdA courses; signatures (see Section 5.2) further alleviate \nany problems the students may have with writing record-type de.nitions. 4.3 Print Format The REPL of \na typical Scheme implementation accepts an expres\u00adsion and then prints its value. While the output format \nof the value is not standardized, most Scheme implementations output the (stan\u00addard) external representation \nof the value: 5 prints as 5, true prints as #t, and the list with elements 1, 2, and 3 prints as (1 2 \n3). While the use of the external representation has advantages for dealing with advanced features of \nScheme such as representing program source code as data, eval and quote, it confuses many beginning students \nabout the difference between expressions and values. For example, the expression (list + 1 2) evaluates \nto (+ 12), which looks like an expression that evaluates to 3. HtDP and DMdA avoid this confusion by \nusing output formats different from the external representation. As HtDP emphasizes the relationship \nbetween algebra and programming, it prints out each value as a canonical form that evaluates to it. Thus, \nthe list with elements 1, 2, 3 prints as (cons 1 (cons 2 (cons 3 empty))) or (list1 23) (depending on \nthe language level), which, as an expression, again evaluates to a list with elements 1, 2, 3. Record \nvalues are printed as constructor calls for example, an ant will print out as (make-ant w (make-posn \nxy)). With DMdA, we instead chose to emphasize the distinction between the expression (make-posn 1 2) \nand its value. This is particularly relevant in DrScheme s stepper (Findler et al. 2002), which displays \nintermediate reductions as expression. In DMdA, the list prints as #<list 1 2 3>, and the ant prints \nas #<record:ant w #<record:posn xy>>. This has the tech\u00adnical disadvantage of not being usable as an \nexpression, but also prevents certain abstraction violations: In particular, it prevents students from \ncutting and pasting the result directly into a test case. Both approaches have been successful at avoiding \nthe confusion associated with the standard external representation.  4.4 Minor Language Changes We made \nadditional minor changes over the HtDP languages. One example is the omission of symbols in favor of \nstrings: HtDP (and an ordinary Scheme programmer) uses symbols for enumerations ( solid, liquid, gaseous) \nwhere DMdA uses strings. This avoids the notational dif.culties of using symbols, in particular the syntactic \nrestrictions (no spaces etc.), and also the notational con.uence between symbols and variables. We had \nobserved these problems in earlier incarnations of the course, and switching to strings solved them all. \n(One might argue that this is less ef.cient, but it is the introductory course, after all.) Delaying \nsymbols enables DMdA to also relegate quote (in\u00adcluding quoted lists) to the very end, the general notion \nof which was quite confusing to students when introduced earlier. The inconvenience (list \"solid\" \"liquid\" \n\"gaseous\") instead of (solid liquid gaseous) is well worth it. 5. Growing the Teaching Languages In 2006, \nwhen the DMdA teaching languages had become roughly analogous to the HtDP languages, we could focus on \nfurther im\u00adprovements. In particular, we adopted and improved upon newer developments in the HtDP languages \nsuch as the support for testing. We have also developed two new additions: support for signatures, and \nthe formulation of general, checked properties of procedures. 5.1 Encouraging Testing Writing test cases \nis an early step of the design recipes. In particu\u00adlar, students should write test cases before they \nwrite the procedure de.nition itself. When we originally introduced testing as a mandatory part of the \ndesign recipes, we adopted graphical test boxes, which HtDP had implemented previously, that the students \nhad to insert via a menu and .ll out like a form. A test box would contain Test and Should be .elds, \nthat would be tested for equality. DrScheme would decorate test boxes of successful tests with green \nmarks and failed tests with red marks and the actual value. The idea was that the graphical and form-like \napproach would make testing more attractive to students, but in fact the opposite was the case: The students \nfound the GUI manipulation required to use test boxes too cumbersome. Moreover, the test boxes had to \ncome after the procedure de.nition of the procedure they were supposed to test even though the design \nrecipes specify that the students write them before writing the procedure de.nition. As a result, many \nstudents wrote their test cases after completing the procedure body. To encourage the students to test \nmore, we replaced the mech\u00adanism for writing tests by one HtDP had implemented earlier: In\u00adstead of graphical \ntest boxes, test cases are formulated as plain code using the check-expect form that accepts a test expression \nand a should-be expression as operands. The test case for is-5? can be formulated as a check-expect form \nlike this: (check-expect (is-5? 7) #f)  When we replaced graphical test boxes by check-expect, the students \nwrote signi.cantly more test cases. The check-expect form allows quick creation, keyboard-based manipulation \nand easy duplication.3 Also, check-expect-based tests run after the rest of the program, and can be placed \nabove the procedure de.nition. This successfully encourages the students to write test cases before writing \nthe procedure de.nition. Thus, even though the difference between the graphical test boxes and check-expect \nis linguistically insigni.cant, the results differ dramatically: Details matter.  5.2 Signatures An \nimportant part of the design recipes is the formulation of a contract for every procedure. In HtDP the \ncontracts are comments: ;; is-5? : number -> boolean (define (is-5? n) (=n 5)) The HtDP language of contracts \nis informal. (HtDP predates PLT s well-known research on contracts as part of the programming lan\u00adguage.) \nMost contracts look like type signatures. (Some represent more complex predicates, but this is not the \nmain point here.) Writing down contracts is important for the students, as it helps answer typical questions, \nsuch as how many arguments they should supply in a procedure call, or how they should order them. Thus, \ncontracts further guide decisions students have to make when they write their programs, and, once written, \ndo so without requiring the student to think about the concrete problem at hand. Consequently, the remove \nthe process of constructing the program from solving the whole problem by one often crucial step. Furthermore, \nTAs use contracts as anchors for giving helpful instructions, As contracts are not subject to static \ntype checking, type errors do not keep a student from running the program and observing its behavior. \nConsequently, while writing down a type signature would have the same bene.ts as writing down the contract, \nthe effects of doing this in a statically typed language would be detrimental for the beginning student \nwhen trying to run the program. The complete lack of checking also creates problems: Many students quickly \nrealize that the contract comments have no bearing on the running program, and as a result they are sloppy \nwith more complicated contracts. This led DMdA to add signatures as formal parts of the teaching languages \nin 2008, which take the place of HtDP s informal contracts. Here is a signature declarations: (: is-5? \n(number -> boolean)) Any signature violation is logged like a test-case violation see Figure 1. The feedback \nto the student includes the expression in the program whose evaluation violated the signature, the signature \nthat was violated, and the value that violated it. The value is important for the student, as it provides \nconcrete evidence that the program did something wrong (rather than a type system s assertion that the \nprogram might do something wrong), and helps the student .gure out the source of the problem. While replacing \ncontracts with signatures does not signi.cantly alter the pedagogy of the course, automatic checking \nplays the role of the lab supervisor for the students, and provides more immediate and precise feedback. \nThe introduction of signatures showed instant results in class: The students were more thorough about \nwriting them, and programming was more in line with the design recipes, as each part of a data de.nition \nnow results in an actual piece of program code: The code for a de.nition for mixed 3 In hindsight, this \nseems obvious, but it was far from obvious at the time, considering the prevalence of graphical paradigms \nin professional development environments. data (the terminology used by DMdA and HtDP for sums ), which \npreviously had no counterpart in the code, looks like this: (define animal (signature (mixed ant armadillo \nbigfoot))) This de.nition can be read as an animal is an ant, armadillo, or a bigfoot or, more precisely, \na value matching the signa\u00adture animal must match one of the signatures ant, armadillo, bigfoot. The \nsignature keyword marks the expression as writ\u00adten in signature syntax.4 Compound data requires no new \nspecial form with signatures students write regular signatures for the constructors, predicates, selectors \nand mutators. For the ants record de.nition from Sec\u00adtion 4.2, students would typically write the following \nsignatures: (: make-ant (real posn -> ant)) (: ant? (%a -> boolean)) (: ant-weight (ant -> real)) (: \nant-loc (ant -> posn)) The .rst line declares that the constructor for ants accepts a real number and \na position, and returns an ant record, the next that ant? accepts any value and returns a boolean, and \nthe two follow\u00ading lines that the selectors for the weight and loc .elds accept an ant record and return \na real number and position, respectively. The .rst declaration already says all there is to say about \nants all pred\u00adicates have the same signature. The selector signatures simply mir\u00adror the constructor \nsignature, and we originally taught our students to only write this .rst line. To our (pleasant) surprise, \nthe students soon insisted on writing all signatures, which have since been con\u00adsistently helpful in \ngetting students to understand the concepts of predicate and selector. The %a signature is a signature \nvariable, as is every identi.er appearing in a contract that starts with a %. This notation allows formulating \ntypical polymorphic signatures like this: (: map ((%a -> %b) (list %a) -> (list %b))) The implementation \nviews any such signature as meaning any hence, the system does not check correct use of parametric poly\u00admorphism, \nand thus fails to prevent students from being sloppy with proper use of signature variables. However, \nthis problem is quite minor compared with the sloppiness we had observed earlier. Note that signatures \nwork as invariants for procedure calls. Conversely, the real contracts that are available in Racket monitor \nthe .ow of values across module boundaries (Flatt et al. 2010).  5.3 Properties We noticed in the T\u00a8ubingen \n2008 course that some students, when the course introduced check-expect, would ask whether it might be \npossible to check for properties rather than examples. This struck a nerve with the DMdA team, as the \ntextbook includes a section on formal speci.cation using equational properties based on ADTs. This section \nhad never worked particularly well, as it requires talking about semantics in terms of universal algebra. \nThis was time-consuming and too obscure for students to grasp in the .rst semester. Moreover, we found \nthat formulating interesting properties such as fundamental properties of search trees was 4 The signature \nsyntax could almost but not quite be expressed as a com\u00adbinator library, or individual macros for mixed \netc.: The signature syn\u00adtax delays references to signature variables and invocations of signature abstractions \nto allow recursive signatures. Moreover, it attaches fresh loca\u00adtions to the various parts of the syntax \nto enable intuitive error reporting. For example, when the number signature of is-5? above is violated, \nthe visual feedback marks the particular occurrence of number in is-5? s signature. To enable this, the \nsystem must treat number differently from a generic variable reference.  Figure 1. Signature violation \nin DrScheme beyond the reach of the framework we had introduced, which was already too complex. Consequently, \nwe decided to instead introduce properties in the concrete context of programming and add support for \nthem to the DMdA languages. Here is an example: (define +-is-commutative (for-all ((a number) (b number)) \n(= (+a b)(+b a))) The range of variables in the new for-all construct is speci.ed using signatures. Thus, \nadding signatures to the language paid off in an unexpected way. Properties are objects, which can be \ncomposed. The new check-property form can be used to check a property: (check-property +-is-commutative) \nThis invokes a QuickCheck clone (Claessen and Hughes 2000), and DrScheme displays counterexamples along \nwith the test results. As signatures are run-time objects, the system constructs the value generators \nneeded for QuickCheck using regular program\u00adming rather via type-class-based overloading. The fact that \nsigna\u00adtures are objects enables simple abstractions accessible to begin\u00adners, such as this: (: commutativity \n((number number -> number) signature -> property)) (define commutativity (lambda (op sig) (for-all ((a \nsig) (b sig)) (= (op a b) (op b a))))) This enables concrete practice dealing with abstract properties \nthis is helpful for our beginning students who struggle with the gen\u00aderal concept of commutativity when \ndivorced from arithmetic. Properties have now replaced the ADT-based approach to for\u00admal speci.cation \nin the course, and the course segues from the QuickCheck testing to actual proofs of properties. Initial \nfeed\u00adback from the 2009/2010 courses in T\u00a8 ubingen and Freiburg has been positive. In the T\u00a8 ubingen \ncourse, which placed more em\u00adphasis on properties, the students invented properties typically simple \nalgebraic properties such as commutativity, associativity, distributivity throughout the course. Consequently, \nwe are con.\u00addent that properties will play a more prominent and supportive role in future courses. However, \nwe will need to assess more systematic feedback and gather more experience to fully realize this potential. \n6. Assessing Success Many pedagogic interventions have unexpected effects: Often, the best intentions \nare not suf.cient to make a good idea work in practice. We generally assess the success of our own interventions \nthrough frequent testing, .nal exams, and direct observation, al\u00adways comparing the results to those \nof previous courses, some of which have yielded signi.cant empirical effects (Bieniusa et al. 2008). \nHowever, it is dif.cult to isolate the effects of individual changes in the teaching languages in empirical \nmeasurements. In particular, it is dif.cult to measure how many problems students were unable to solve \nbecause of language-design issues. Thus, we rely on direct observation in our supervised lab exercises, \nwhere our TAs log any problems the students have where the program environment or the programming language \nmay help. We were able to observe some speci.c effects, however: For ex\u00adample, before the introduction \nof signatures, most contracts written by the students contained errors, whereas afterwards, most signa\u00adtures \ndid not contain errors. The effect of properties is not empiri\u00adcal, as they enable a particular didactic \napproach we believe the basic approach is already validated, as many students are able to write properties \non their own, whereas the previous ADT-based ap\u00adproach to speci.cation was a disaster, as students were \nnot able to formulate properties on their own. 7. Growing Teaching Languages While it has become clear \nthat standard Scheme as-is was not an ideal teaching language, it was still a good starting point for \nour endeavors: Functional programming is a more appropriate begin\u00adners paradigm than imperative or object-oriented \nprogramming; Scheme, being a functional language, supports the paradigms needed for implementing the \ndesign recipes, and its general ab\u00adstraction mechanisms make it ideal for practicing abstraction. Its \nsimple syntax makes classroom treatment easy. Educators and implementors can improve the learning experi\u00adence \nwith any (functional) language. This requires substantial ac\u00adtion research and observation-driven improvement \nas part of a long\u00adrunning process, as our experience has demonstrated. Moreover, educators do well to \nclearly de.ne their teaching goals. Appropriate goals are de.ned in terms of the actual learning experience \nrather than the subject coverage in class. The following principles have served us well on our journey: \n Observe your students directly and closely.  Be willing to abandon your favorite aspects of the course \nor teaching language at least be willing to move them to a dif\u00adferent place.  Keep making changes, evaluate \nthem, and be willing to abandon them if they do not work.  Cooperate with others who are doing similar \nwork. Learn from their mistakes.   8. Related Work There are surprisingly few constructive investigations \nof how par\u00adticular design elements of a programming language can support or hinder a beginner s effort \nto learn programming. Wadler s critique of Scheme for teaching (Wadler 1987) is such a constructive inves\u00adtigation; \nWadler stresses the importance of a type-based approach to program construction, recognizes the problems \nof Scheme s ex\u00adternal representation, and the importance of algebraic techniques in understanding programs. \nThe work on support for testing in Profes\u00adsorJ (Gray and Felleisen 2007) shows the importance of a concise \nand lightweight notation for tests, and thus mirrors the experience we had with test boxes and check-expect. \nThe paper by McIver and Conway (McIver and Conway 1996) identi.es a number of issues in the design of \nlanguages for intro\u00adductory programming. The paper aptly concludes: This implies that the most important \ntool for pedagogical programming language design is usability testing, and that genuinely teachable programming \nlanguages must evolve through prototyping rather than springing fully-formed from the mind of the language \ndesigner. The work on Helium (Heeren et al. 2003) demonstrates the Haskell community s insight that beginners \nhave needs different from those of professionals speci.cally, that they require better (type) error messages. \nAlso, Helium, lacking type classes, is effectively a be\u00adginner s language level for Haskell. The Helium \nproject uses con\u00adcrete observations of students interactions with the system to im\u00adprove it (van Keeken \n2006). Generally, producing comprehensible type error messages in Hindley-Milner-typed languages is ongo\u00ading \nresearch (Rahli et al. 2009). Marceau et al. have recently stud\u00adied the quality of the error messages \nin DrScheme more systemati\u00adcally and concluded that there is still signi.cant room for improve\u00adment (Marceau \net al. 2010). DrJava (Hsia et al. 2005) has picked up the concept of language levels from DrScheme. 9. \nConclusions The programming language used by an introductory course can be either a help to the student, \nor an obstacle. However, even though the typical professional functional language is less complex than \nthe typical professional object-oriented language, problems remain. Improving this situation requires \nlanguage design specif\u00adically geared towards beginning students. The properties of these languages arise \nfrom the pedagogic principles of the course the design recipes and continual improvement from an ongoing \npro\u00adcess and observation of the students. The HtDP and DMdA languages have come a long way in sup\u00adporting \nthe beginning student. However, work on them is ongoing, and we believe further re.nements are possible. \nIn the near future, we will continue to work on the error messages, again following PLT s lead (Marceau \net al. 2010). We have also ported the work on signatures in the DMdA levels to the HtDP levels, which \nwill be available in a future version of DrRacket. As many signatures al\u00adready look like types, we also \nplan to experiment with adding addi\u00adtional levels that treat the signatures as type declarations. Moreover, \nwe expect experience to guide us towards further improvements. In the future, we may bene.t from a more \nsystematic approach to eval\u00aduating our success instead of our past action research. We welcome new adopters \nand their feedback. We call on educators who teach programming using other languages to use similar or \nimproved pro\u00adcesses to tailor their tools to the needs of their students. 10. Acknowledgments Many people \nwere involved in shaping the DMdA and HtDP lan\u00adguage levels: Matthias Felleisen and the members of the \nPLT group particularly Matthew Flatt, Robby Findler, Shriram Kr\u00adishnamurthi, and John Clements are responsible \nfor the ongo\u00ading development of DrRacket. Martin Gasbichler helped develop the DMdA language levels. \nPeter Thiemann and Torsten Grust and their groups provided helpful suggestions on the design of the DMdA \nlanguages, based on their own intro courses. Carl Eastlund suggested adding randomized testing to the \nlanguage levels. References Harold Abelson, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation \nof Computer Programs. MIT Press, Cambridge, Mass., second edition, 1996. Annette Bieniusa, Markus Degen, \nPhillip Heidegger, Peter Thiemann, Ste\u00adfan Wehr, Martin Gasbichler, Marcus Crestani, Herbert Klaeren, \nEric Knauel, and Michael Sperber. HtDP and DMdA in the battle.eld. In Frank Huch and Adam Parkin, editors, \nFunctional and Declarative Pro\u00adgramming in Education, Victoria, BC, Canada, September 2008. Koen Claessen \nand John Hughes. QuickCheck: A lightweight tool for ran\u00addom testing of Haskell programs. In Philip Wadler, \neditor, Proceedings International Conference on Functional Programming 2000, pages 268 279, Montreal, \nCanada, September 2000. ACM Press, New York. ISBN 1-58113-202-6. doi: http://doi.acm.org/10.1145/351240.351266. \nWill Clinger, R. Kent Dybvig, Michael Sperber, and Anton van Straaten. SRFI 76: R6RS records. http://srfi.schemers.org/srfi-76/, \nSeptember 2005. Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Kr\u00adishnamurthi. \nHow to Design Programs. MIT Press, 2001. Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and \nShriram Kr\u00adishnamurthi. The TeachScheme! project: Computing and programming for every student. Computer \nScience Education, March 2004. Robert Bruce Findler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram \nKrishnamurthi, Paul A. Steckler, and Matthias Felleisen. DrScheme: A programming environment for Scheme. \nJournal of Func\u00adtional Programming, pages 159 182, March 2002. Matthew Flatt, Robert Bruce Findler, and \nPLT. Guide: Racket. PLT, 2010. Available from http://pre.plt-scheme.org/docs/. Kathryn E. Gray and Matthias \nFelleisen. Linguistic support for unit tests. Technical Report UUCS-07-013 2007, University of Utah, \n2007. Bastiaan Heeren, Daan Leijen, and Arjan van IJzendoorn. Helium, for learning Haskell. In Johan \nJeuring, editor, Proceedings of the 2003 ACM SIGPLAN Haskell Workshop, pages 62 71, Uppsala, Sweden, \nAugust 2003. James I. Hsia, Elspeth Simpson, Daniel Smith, and Robert Cartwright. Taming Java for the \nclassroom. In SIGCSE 2005, February 2005. Herbert Klaeren and Michael Sperber. Die Macht der Abstraktion. \nTeubner Verlag, 1st edition, 2007. Guillaume Marceau, Kathi Fisler, and Shriram Krishnamurthi. Measuring \nthe effectiveness of error messages designed for novice programmiers. In 2010 Workshop on Scheme and \nFunctional Programming, Montr\u00b4eal, Qu\u00b4ebec, Canada, August 2010. Linda McIver and Damian Conway. Seven \ndeadly sins of introductory programming language design. In Proceedings Software Engineering: Education \n&#38; Practice, pages 309 316, Los Alamitos, CA, USA, 1996. IEEE Computer Society Press. Vincent Rahli, \nJ. B. Wells, and Fairouz Kamareddine. Challenges of a type error slicer for the SML language. Technical \nReport HW-MACS\u00adTR-0071, Heriot-Watt University, School of Mathematics &#38; Computer Science, September \n2009. Peter van Keeken. Analyzing Helium programs obtained through logging the process of mining novice \nHaskell programs . Master s thesis, Utrecht University, October 2006. INF/SCR-05-93. Philip Wadler. A \ncritique of Abelson and Sussman or why calculating is better than scheming. SIGPLAN Notices, 22(3):83 \n94, March 1987.   \n\t\t\t", "proc_id": "1863543", "abstract": "<p>A student learning how to program learns best when the programming language and programming environment cater to her specific needs. These needs are different from the requirements of a professional programmer. Consequently, the design of teaching languages poses challenges different from the design of professional languages. Using a functional language by itself gives advantages over more popular, professional languages, but fully exploiting these advantages requires careful adaptation to the needs of the students' as-is, these languages do not support the students nearly as well as they could. This paper describes our experience adopting the didactic approach of How to Design Programs, focussing on the design process for our own set of teaching languages. We have observed students as they try to program as part of our introductory course, and used these observations to significantly improve the design of these languages. This paper describes the changes we have made, and the journey we took to get there.</p>", "authors": [{"name": "Marcus Crestani", "author_profile_id": "81372593321", "affiliation": "University of T&#252;bingen, T&#252;bingen, Germany", "person_id": "P2338200", "email_address": "", "orcid_id": ""}, {"name": "Michael Sperber", "author_profile_id": "81100100127", "affiliation": "DeinProgramm, T&#252;bingen, Germany", "person_id": "P2338201", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863576", "year": "2010", "article_id": "1863576", "conference": "ICFP", "title": "Experience report: growing programming languages for beginning students", "url": "http://dl.acm.org/citation.cfm?id=1863576"}