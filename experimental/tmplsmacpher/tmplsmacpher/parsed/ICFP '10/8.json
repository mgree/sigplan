{"article_publication_date": "09-27-2010", "fulltext": "\n Using Functional Programming within an Industrial Product Group: Perspectives and Perceptions David \nScott Richard Sharp Thomas Gazagnaire Anil Madhavapeddy Citrix Systems UK R&#38;D INRIA Sophia Antipolis \nComputer Laboratory Building 101 2004 route des Lucioles University of Cambridge Cambridge Science Park \nF-06902 Sophia Antipolis William Gates Building Cambridge CB4 0FY, UK Cedex, France Cambridge CB3 0FD, \nUK .rst.last@eu.citrix.com .rst.last@inria.fr .rst.last@cl.cam.ac.uk Abstract We present a case-study \nof using OCaml within a large product development project, focussing on both the technical and non\u00adtechnical \nissues that arose as a result. We draw comparisons be\u00adtween the OCaml team and the other teams that worked \non the project, providing comparative data on hiring patterns and cross\u00adteam code contribution. Categories \nand Subject Descriptors D.2.m [Software Engineer\u00ading]: [Miscellaneous] ; D.3.2 [Programming Languages]: \nLanguage Classi.cations Applicative (functional) languages General Terms Human Factors, Languages, Management \nKeywords Industry, Functional Programming, Perceptions 1. Introduction We present our experiences of \nusing the programming language OCaml within the Citrix XenServer product group. The case-study is interesting \nfor three reasons: 1. XenServer is deployed in over 40,000 companies worldwide, often in mission-critical \ninfrastructure, with the largest sin\u00adgle customer having more than 20,000 machines running XenServer \n[13]. We are presenting a very real-world use of functional programming. 2. It provides insight into \nthe pros and cons of using OCaml for a major systems software project. 3. The team that used OCaml was \none of .ve teams working on XenServer. This enables us to draw comparisons between the OCaml team and \nother teams within the XenServer group.  We start with a brief background into the XenServer engineer\u00ading \ngroup (\u00a71.1) and the product (\u00a71.2). Next we describe the au\u00adthors perspectives of using OCaml for the \nXenServer project, re\u00ad.ecting on both our technical experiences and the different reac\u00adtions within the \ncompany that we encountered regarding the use of Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright \nc &#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 a non-mainstream language for product development \n(\u00a72). In the remainder of the paper we present data that compares the OCaml team with other XenServer \nteams, in terms of hiring patterns (\u00a73) and code contribution (\u00a74). Finally, we examine other work in \nthe community (\u00a75) and conclude (\u00a76). 1.1 The XenServer Engineering Group The XenServer engineering group \nis organised into .ve separate engineering teams, each responsible for different software compo\u00adnents \nthat comprise the XenServer product. There is a Hypervi\u00adsor/Kernel team, a Storage team, a Management \nTools team (MTT), a Windows Driver team and a User Interface team. Four of these teams use mainstream \nlanguages (including C, Python and C#), but the MTT use OCaml as their primary development language. \nThere are about 40 engineers in total within XenServer engi\u00adneering, including 10 full-time OCaml programmers \nin the MTT who are responsible for extending and maintaining a code-base that consists of approximately \n130 KLoC of OCaml. The MTT team s components consume and provide interfaces and APIs to those of all \nother teams; thus there is constant interaction between the OCaml programmers and the rest of the development \ngroup.  1.2 The XenServer Product Citrix XenServer is a managed virtualisation platform built on the \nopen-source Xen hypervisor [1], offering a range of additional management features. Some of the features \ninclude: Resource pools: The ability to create clusters of servers and shared-storage that are managed \nas a unit. Virtual Machines (VMs) can be moved between servers in the pool while contin\u00aduing to run [3]. \nHigh Availability (HA): The ability to restart VMs on other servers automatically, if the server they \nwere executing on fails. Clus\u00adter fencing, required to preserve data integrity in the storage layer [5], \nis provided in software by the XenServer manage\u00adment tools. XenAPI: An XML-RPC management API that provides \nthe ability to create resource pools and VMs, and con.gure all aspects of the system. XenCenter Management \nConsole: A Windows GUI that allows administrators to create and con.gure VMs and resource pools. 1.2.1 \nArchitectural Overview XenServer is based on a type-1 hypervisor [1], and is installed straight onto \nthe bare metal and booted directly from a server s BIOS. The hypervisor is the .rst component to be loaded \nand takes control of CPUs, memory and interrupt mappings. Next, it spawns a control domain a small Linux \nVM that provides system management services and provides physical device drivers for networking and storage. \n The main XenServer management process that resides in the control domain is known as XAPI, because \nit is the service that provides the XenAPI. The service s primary responsibility is to lis\u00adten to XenAPI \ncalls (made over the network) and execute these re\u00adquests. In addition XAPI itself implements resource \npools (dealing with the distributed systems challenges that this entails), maintains a durable, replicated \npersistent database of con.guration data on behalf of the resource pool and is responsible for high-availability \nplanning and failover1. The XAPI source code, consisting of ap\u00adprox. 130 KLoc of OCaml, is open source \nand can be freely down\u00adloaded under the LGPLv2 license2. One of the de.ning characteristics of XAPI is \nthat it communi\u00adcates with all major components of the system. On the one hand it accepts connections \nfrom clients (e.g. the XenCenter GUI), per\u00adforming XenAPI requests on their behalf and providing access \nto a variety of data-streaming services (e.g. remote-access to VM con\u00adsoles, importing and exporting \nVM disk images). On the other hand, XAPI interfaces with other software components within the server, \nincluding the Xen hypervisor and the networking and stor\u00adage subsystems. This requires XAPI to use a \nvariety of different in\u00adterfaces, including (i) calling into statically-linked C APIs to com\u00admunicate \nwith the Xen hypervisor and the Linux kernel; (ii) fork\u00ading new processes to invoke vendor-speci.c storage \nscripts or other shell commands; (iii) utilising a variety of different IPC mecha\u00adnisms, for example \nto communicate with subprocesses involved in a live VM migration [3]; and (iv) performing protocol processing \nfunctions over both TCP and Unix domain sockets to receive and parse XenAPI requests. Another property \nof XAPI is that it is highly concurrent. As well as managing a number of long-running background housekeeping \nthreads, XAPI accepts and processes concurrent XenAPI requests across multiple connections from multiple \nclients and deals with communication between the multiple servers and shared storage devices that comprise \na resource pool. 2. Authors Perspectives In this section we describe our perspectives of using OCaml \nwithin the context of the XenServer project. We discuss why OCaml was selected, describe the reactions \nwithin the company to using a non\u00admainstream language for product development and relate some of our \ntechnical experiences. 2.1 Selection of OCaml The XenServer product did not start out within Citrix, \nbut was .rst conceived within a startup called XenSource. Citrix acquired XenSource (and hence the XenServer \nteam and product) in 2007. There were a number of factors within XenSource that drove the choice of OCaml \nand enabled the XAPI project to reach inception: 1. XenSource was staffed by a number of ex-researchers \nfrom the University of Cambridge Computer Laboratory. Many of these engineers had used OCaml before in \na research environment and believed that, for large projects, the OCaml language of\u00adfered signi.cant \nproductivity bene.ts over both traditional sys\u00adtems languages such as C, and dynamically typed languages, \nsuch as Python [10]. 2. As a startup, XenSource had a culture of innovation and risk\u00adtaking. In this \nenvironment there were a number of in.uential  1 See http://community.citrix.com/x/O4KZAg 2 See http://www.xen.org/products/cloudxen.html \npeople within the company who supported the use of OCaml, feeling that the risks of using a non-mainstream \nlanguage were worth taking in return for the ef.ciencies that the engineers claimed it would bring. 3. \nXenSource had weak project governance within engineering. Thus, even though there were many people within \nthe company who felt that using a non-mainstream language was not the right decision, the OCaml project \nstarted anyway and quickly built momentum as a grassroots effort. These factors are all non-technical; \nthey created the environment in which a product-development initiative based on a non-mainstream language \ncould be seeded. But there were also technical reasons why OCaml was chosen over other languages for \nthe XAPI project: 1. Performance: XenSource engineers had used OCaml on previ\u00adous projects and were con.dent \nthat it could deliver the required performance for the project [11]. 2. Integration: OCaml s low-overhead \nforeign-function interface and existing Unix bindings facilitated the required interac\u00adtions with the \nmyriad of software components that made up the XenServer system. 3. Robustness: As a long-running service, \nXAPI must not crash. This requirement made OCaml s static type-safety and man\u00adaged heap very appealing, \noffering the potential to reduce run\u00adtime failures due to type errors, memory leaks or heap corrup\u00adtion. \n 4. Compactness: there were plans for embedded versions of XenServer on .ash storage as small as 16MB. \nThe relatively simple OCaml run-time and compact native code output were key to this requirement.  There \nwere other languages that met the above criteria, the most notable being Haskell. The primary reason \nfor choosing OCaml over Haskell was non-technical. The engineers involved in the project had considerably \nmore experience of using OCaml, and using it reduced training costs (this being a luxury in a fast-paced \nstartup). Our previous experiences had also given us con.dence that the OCaml tool-chain would meet the \nproject requirements.  2.2 Reactions within the company Choosing OCaml for a product development project \nwas a con\u00adtentious decision that created some heated debate within Xen-Source. While the engineers in \nthe MTT .rmly believed that the bene.ts of using OCaml outweighed the risks, others strongly be\u00adlieved \nthat the risks of using a non-mainstream language for a major product development project were simply \ntoo great. Speci.c risks that were highlighted included: 1. We will not be able to hire OCaml programers \nquickly enough to grow the team. 2. A large code base in a non-mainstream language will make XenSource \na less attractive acquisition target. 3. Other teams (staffed with programmers who don t know OCaml) \nwill not able to work with the MTT because of the language barrier . 4. The OCaml tool-chain may not \nbe mature enough to support the development of a complex system.  The MTT had enough experience of using \nOCaml to argue con\u00advincingly that Risk 4 could be effectively mitigated. However, at the time the XAPI \nproject was initiated, there was no data avail\u00adable regarding Risks 1 3, so debate (although heated) \nmade little forward progress.  In hindsight, none of the risks above materialised. A year af\u00adter work \non XAPI started, Citrix paid $500M for XenSource, and the technical due-diligence process performed during \nthe acquisi\u00adtion made it very clear that a large chunk of XenServer was im\u00adplemented in OCaml. There \nwere also no problems hiring OCaml programmers (\u00a73), and other teams were able to work very effec\u00adtively \nwith the MTT (\u00a74).  2.3 Technical experiences We conducted a preliminary user study among the engineering \ngroup, with a set of open-ended questions designed to elicit individ\u00adual opinions. Overall, the MTT report \npositive experiences of using OCaml on the XenServer project. Without exception, the engineers within \nthe MTT believe that developing XAPI in OCaml has been a success, with the type system and automatic \nmemory management being the most widely cited bene.ts of the language. Engineers also report that they \nenjoy programming in OCaml , particularly em\u00adphasising the fact that they believe OCaml allows them to \nexpress complex algorithms concisely. There is also a shared belief within the MTT that, overall, the \nchoice of OCaml has enabled the team to be more productive than they would have been had they chosen \na more mainstream language for the project (e.g. C++ or Python). Note that Java and .NET-based languages \nwere not included due to the size of their runtime environments not being conducive to the compactness \nrequirement (\u00a72). These positive experiences are backed up by internal test data and component defect \nlevels that demonstrate that the quality and performance of the XAPI compo\u00adnent is good. However, despite \nthe overall positive outcome, there have been some technical challenges that relate to the choice of \nOCaml. These challenges are not due to the OCaml language per se, but are due to lack of available library \nsupport, the complexity of the Foreign Function Interface (FFI) and the limitations of the OCaml toolchain. \nWe consider each of these issues in more detail in the remainder of this section. 2.3.1 Lack of Library \nSupport We found that OCaml s library support for common data struc\u00adtures and algorithms generally suf.cient \nfor our needs. However, the lack of library support for common systems protocols was more problematic. \nIn particular we ended up having to write a pipelined HTTP/1.1 server from scratch and handcrafting our \nown SSL so\u00adlution using separate stunnel3 processes to terminate and initiate SSL connections, and communicating \nwith these over IPC. There were some open source HTTP and SSL OCaml libraries available. However, at \nthe time, the libraries that we evaluated were not fully featured or robust enough to meet the requirements \nof the XAPI project. 2.3.2 C Bindings Writing C bindings was dif.cult and error-prone. Despite careful \ncode-review and a policy of keeping things simple (avoiding references into the heap across the FFI, \nand avoiding use of call\u00adbacks whenever possible) some bugs still crept through, creating occasional \nXAPI segmentation faults that were hard to reproduce and track down. 2.3.3 Lack of Tool Support Our \nheavy use of threads and fork(2) made it impossible for us to effectively use ocamldebug or ocamlprof. \nInstead we relied on gdb and gprof directly against the compiled binary. This was better than nothing, \nbut the low-level nature of gdb made it hard to relate the debugging output back to the OCaml source. \n3 Universal SSL wrapper: http://www.stunnel.org Likewise, the lack of high-level pro.ling data made perfor\u00admance \ntuning harder than it should have been, and made it dif.cult to track down memory leaks4.  2.4 Technical \nLessons Learnt Over the last four years of commercial OCaml development, we have learnt several technical \nlessons regarding its use. Some of these are outlined in this section. 2.4.1 Stability of Tools and Runtime \nIn the early days of XAPI development, we had no idea if the OCaml runtime (e.g. the garbage collector) \nwould be robust enough to support long-running processes like XAPI that are required to execute continuously \nfor months at a time. We joined the OCaml Consortium to offset this risk, providing us with a support \nchannel in case bugs arose. However, it transpired that the OCaml runtime was remark\u00adably stable. Our \nautomated test system puts XAPI through 2000 machine-hours of testing per night, and also runs regular \nstress and soak tests that last for weeks on end. Customers also run their XenServers for several months \nat a time without restarting XAPI. Despite all this testing, we have never had a single XenServer de\u00adfect \nreported from internal testing or from the .eld that can be traced back to a bug in the OCaml runtime \nor compiler. (During de\u00advelopment we did once .nd a minor compiler bug, triggered when compiling auto-generated \nOCaml code with many function argu\u00adments, but this was already .xed in the development branch by the \ntime we reported it and so no interaction with the maintainers at INRIA was required.)  2.4.2 The Right \nStyle for the Right Job OCaml allows for many programming techniques to be used in the same codebase. \nXAPI takes full advantage of this fact, using different programming styles to solve different problems: \nImperative Many of the lower-level modules of XAPI (e.g. those that interface with the hypervisor and \ncontrol domain kernel) consist of step-wise, imperative code and look like type-safe C. OCaml fully supports \nthis style with language constructs such as for/while loops and references. Functional Although a good \nchunk of XAPI is unashamedly im\u00adperative, some of the higher-level aspects of the system are functional \nin nature. For example the high-availability feature requires algorithms for distributed failure planning. \nThese algo\u00adrithms (e.g. bin packing) are implemented in a functional style. One function of XAPI is to \ncommunicate with Xenstore. The Xenstore service, which runs in the control domain, provides a tuple-space \nthat is used for co-ordination between VMs and the XenServer management tools [7]. Xenstore exposes an \nasyn\u00adchronous event interface that is hard to use. XAPI abstracts much of this complexity behind a straight-forward \ncombinator library that handles events via composable functions. For exam\u00adple, consider the following \ncode fragment: wait_for (any_of [ OK, value_to_appear \"/path1\" Failed, value_to_become \"/path\" v ]) \nThe expression value to appear \"/path1\" represents the act of waiting for any value to become associated \nwith key \"/path1\". The expression value to become \"/path\" v 4 In a garbage collected language, like OCaml, \nmemory leaks occur when global references to objects are not cleaned up explicitly (e.g. if something \nis added to a global hash-table and not subsequently removed).  represents the act of waiting for a \nspeci.c value v to become as\u00adsociated with key \"/path\". The expression any of represents the act of waiting \nfor any one of a set of labelled options; in this example the label OK is used to represent a success \ncase and the label Failed represents a failure case. Finally the function wait for uses the Xenstore \nevent interface, returning either OK or Failed as appropriate. Meta-programming XAPI has a distributed \ndatabase that runs across all the hosts in a resource pool, including failover and replication algorithms. \nThe OCaml code to interface with this database and remote calls is all auto-generated from a succinct \nspeci.cation and compiler. Similarly, all of the XenAPI bind\u00adings to other languages (C, C#, Java) are \ngenerated from a sin\u00adgle data-model. Object-oriented OCaml provides a comprehensive object system, but \nit is not used in XAPI except in small, local cases. Although we have nothing speci.c against using it, \na compelling case for introducing them has never emerged. Modules, functors and polymorphic variants \nhave been suf.cient to date, and we anticipate that .rst-class packaged modules (in OCaml 3.12+) will \nfurther reduce the need for using objects.  2.4.3 Garbage Collect Everything The automatic memory management \nthat OCaml provides is a huge improvement over using C, but we still frequently get leaks due to mismatched \nallocation/deallocation of other limited OS resources, such as .le descriptors and shared memory segments. \nThese are usually only detected after automated stress testing detects the failure since the code involved \nworks .ne during development. Nowadays, we make an effort to abstract as many of the OS resources as \npossible behind our own extensions to the standard library. 3. Hiring Patterns Despite concerns raised \nat the start of the XAPI project, the MTT has had no dif.culty in .nding and hiring good OCaml program\u00admers, \nand has been able to grow at a comparable rate to the other XenServer teams that used mainstream languages. \nFrom October 2006 to April 2010, 12 engineers have been hired into OCaml\u00adprogramming positions (roughly \na quarter of all XenServer engi\u00adneers hired over the period). There are two interesting observations \nabout the MTT s hir\u00ading patterns. Firstly, we found that posting on functional program\u00adming mailing lists \n(including the OCaml List and Haskell Cafe) has consistently generated good in.ows of high quality candidates \nin\u00adterested in industrial functional programming positions. And, sec\u00adondly, we have found that previous \nOCaml experience is not a pre\u00adrequisite for hiring into OCaml-programming positions. In fact, of the \n12 engineers hired, only 2 had prior experience of OCaml; the other 10 learnt OCaml after they started \nwork at XenSource or Citrix. Interestingly, having to learn OCaml did not make a big difference to the \ntraining time of the new engineers: the 10 engineers that did not know OCaml became productive at about \nthe same speed as the 2 engineers that did have prior OCaml experience. We believe that this is because, \nfor a complex software product like XenServer, getting to know one s way around the various code-bases \nand getting to grips with the architectural principles of the wider system is a much more time consuming \ntask than learning a new programming language. The 10 engineers that did not know OCaml were already \nhighly pro.cient programmers who had a solid grounding in data-structures, algorithms and computer science \nmore generally. 4. OCaml Code contribution As described earlier (\u00a71.1), the XenServer Engineering Group \ncon\u00adsists of .ve teams of full-time software engineers, supplemented by contractors. Each team is responsible \nfor a different software com\u00adponent. The source code for each component is stored in a num\u00adber of version-controlled \nrepositories using Mercurial [14]. Each repository contains a complete historical record listing every \ncode change, when it was made, who made it and why. In this section we will examine this historical record \nto identify and analyse which teams contributed to which components. We shall use this data to answer \nthe question: Did the use of OCaml within the MTT prevent engineers from other teams making signi.cant \ncontributions to the XAPI project? For our analysis we shall focus on four components: 1. Management \nConsole: a windows user-interface maintained by the User Interface team; 2. Storage: a set of plugin \nmodules to connect XenServer to back\u00adend storage arrays where VM disks are stored maintained by the Storage \nteam; 3. XAPI: the component which implements the XenAPI main\u00adtained by the MTT; and 4. Windows drivers: \ndrivers required for high-performance VM I/O, maintained by the Windows Driver team.  The components \nwere chosen for the following reasons: 1. they were all created solely for the XenServer product unlike, \nfor example, the open-source Xen hypervisor that was created as part of a research project a few years \nbefore the XenServer product emerged; 2. they are all maintained by different teams; and 3. they all \nprimarily use different programming languages (even the XAPI code contains traces of C).  The following \ntable gives approximate sizes and primary lan\u00adguage data for each component5: Component Size Main Languages \nXAPI 130kLOC OCaml Windows Drivers 80 kLOC C, C++ Management Console 200kLOC C# Storage 40 kLOC Python, \nC The diagram in Figure 1 displays four bars, one for each com\u00adponent in the analysis. The height of \neach bar indicates the total number of individuals who contributed code to each component. The bars are \nsubdivided into sections, each one coloured to indi\u00adcate the team the contributor belonged to. The diagram \nin Figure 2 displays four bars, one for each compo\u00adnent as before. The bars now represent the relative \ncontribution size from members of each team to each component. It is clear that, in all cases, the team \nresponsible for maintaining a component makes the majority of contributions. However it is also clear \nthat, in all cases, members of other teams made contributions. The size and colouring of the bar corresponding \nto XAPI in Figure 1 clearly shows that the use of OCaml did not prevent engineers from other teams making \ncontributions. Furthermore, the size and colouring of the bar corresponding to XAPI in Figure 2 5The \nXAPI number excludes auto-generated OCaml code, the Windows driver excludes header .les as most are auto-generated, \nand the Manage\u00adment Console excludes auto-generated XenAPI and Windows Forms code.   Figure 1. The \ntotal height of each bar shows the total number of unique contributors to each component. The color indicates \nthe proportion of contributors from each team. clearly shows that these contributions were as signi.cant \n(in terms of size) as contributions made to other non-OCaml components. 5. Related Work There are several \ngroups using OCaml in industrial settings. Jane Street Capital is a successful proprietary trading company \nwhich uses OCaml for a wide range of tasks. In their experi\u00adence report [12], they share several of our \ntechnical concerns with OCaml: (i) generic pretty-printing facilities have to be addressed via macros; \nand (ii) the lack of a wide range of community li\u00adbraries for common tasks. Since their report, some \nof these aspects have improved somewhat. OCamlForge provides a central place to locate community libraries, \nand systems such as dyntype [8] and deriving [16] make it easier to operate on generic values and types \nwithout modifying the core OCaml tool-chain. Like them, XAPI also does not use the OCaml object system \nmuch. One concern we do not share is the lack of a multi-threaded garbage collector. Since XAPI is not \na CPU-intensive service, and the control domain is limited to a single virtual CPU, the simplicity and \nstability bene.ts of the existing collector exceed the more complex concurrent alternative. XenServer \nis not a hosted service, but a product that ships ex\u00adternally to many customers. MLdonkey [9] was one \nof the earliest (and for some time, the most popular) peer-to-peer client applica\u00adtions, written entirely \nin OCaml. We restricted our use of OCaml to the server-side component of XenServer, and wrote the native \nWindows client using C#. We made some attempts to compile portions of the OCaml code (e.g. the command-line \ninterface) for Windows, but the lack of robust libraries (particularly SSL) made it not worth the effort. \nSince our decision in 2006, desktop programming using functional languages has advanced considerably, \nas (i) Microsoft F# provides full access to Windows APIs [15]; and (ii) web browsers can host entire \napplications in Javascript, and be programmed in a functional style [2, 6]. We have not yet built a client \nusing these technologies, however. OCaml is traditionally popular as a compiler tool, and Frama-C is \nan example of an industrial-grade static analysis product [4]. Figure 2. Each coloured section indicates \nthe size of contributions to a component by a team, relative to the total contributions. XAPI also has \ncompilers written in OCaml to generate bindings from an executable speci.cation for more verbose languages \nlike C#, C, Java and Javascript. This helped keep the various XenAPI clients synchronised with the server \nas it developed rapidly in the early days. 6. Conclusions The XAPI project is perceived as a success \nwithin XenServer engi\u00adneering. The MTT works effectively with other teams (i.e. without any language \nbarrier problems ), engineers have been hired into OCaml programming positions quickly and effectively \nand, techni\u00adcally, the XAPI component has shown itself to be stable and robust. Although there were some \ndrawbacks to using OCaml, namely a lack of library support for common protocols (e.g. SSL, HTTP) and \na lack of tool support, engineers within the MTT believe that overall OCaml has brought signi.cant productivity \nand ef.ciency bene.ts to the project. In particular, MTT engineers believe that OCaml has enabled them \nto be more productive than they would have been had they adopted one of the mainstream languages that \nwould have met the requirements of the project (e.g. C++ or Python). Since the XAPI code-base was open \nsourced in mid-2009 it has become possible for engineers beyond Citrix to work on the project. It remains \nto be seen whether the use of OCaml will act as a barrier to wider contribution, but based on our experiences \nreported in this paper, we are hopeful that it will not. We are already seeing some code submissions \nto the XAPI project from beyond Citrix and are working with development partners and the research community \nto encourage further contribution. The source code can be obtained from http://xenbits.xen. org/XCP/. \n7. Acknowledgments We thank Eleanor Scott, Richard Mortier, Jonathan Knowles, Yaron Minsky, Tim Deegan, \nJonathan Ludlam, Stephen Kell, Euan Har\u00adris, our Citrix colleagues and the anonymous reviewers for their \nfeedback.  References [1] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neugebauer, \nI. Pratt, and A. War.eld. Xen and the art of virtu\u00adalization. In Proceedings of the 19th ACM Symposium \non Operat\u00ading Systems Principles (SOSP), pages 164 177, New York, NY, USA, 2003. ACM Press. [2] B. Canou, \nV. Balat, and E. Chailloux. O Browser: Objective Caml on browsers. In Proceedings of the 2008 ACM SIGPLAN \nworkshop on ML, pages 69 78, New York, NY, USA, 2008. ACM. [3] C. Clark, K. Fraser, S. Hand, J. G. Hansen, \nE. Jul, C. Limpach, I. Pratt, and A. War.eld. Live migration of virtual machines. In Proceedings of the \n2nd Symposium of Networked Systems Design and Implementation, May 2005. [4] P. Cuoq, J. Signoles, P. \nBaudin, R. Bonichon, G. Canet, L. Correnson, B. Monate, V. Prevosto, and A. Puccetti. Experience report: \nOCaml for an industrial-strength static analysis framework. In ICFP 09: Proceedings of the 14th ACM SIGPLAN \ninternational conference on Functional programming, pages 281 286, New York, NY, USA, 2009. ACM. [5] \nM. DeBergalis, P. Corbett, S. Kleiman, A. Lent, D. Noveck, T. Talpey, and M. Wittle. The Direct Access \nFile System. In Proceedings of the 2nd USENIX Conference on File and Storage Technologies, pages 175 \n188, Berkeley, CA, USA, 2003. USENIX Association. [6] J. Donham. OCamlJS, July 2010. http://jaked.github.com/ \nocamljs. [7] T. Gazagnaire and V. Hanquez. Oxenstored: an ef.cient hierarchi\u00adcal and transactional database \nusing functional programming with reference cell comparisons. In ICFP 09: Proceedings of the 14th ACM \nSIGPLAN international conference on Functional programming, pages 203 214, New York, NY, USA, 2009. ACM. \n[8] T. Gazagnaire and A. Madhavapeddy. Statically-typed value persis\u00adtence for ML. In Proceedings of \nthe Workshop on Generative Tech\u00adnologies, March 2010. [9] F. Le Fessant and S. Patarin. MLdonkey, a Multi-Network \nPeer-to-Peer File-Sharing Program. Research Report RR-4797, INRIA, 2003. [10] A. Madhavapeddy. Creating \nhigh-performance, statically type-safe network applications. Technical Report UCAM-CL-TR-775, Univer\u00adsity \nof Cambridge, Computer Laboratory, Apr. 2006. [11] A. Madhavapeddy, A. Ho, T. Deegan, D. Scott, and R. \nSohan. Melange: creating a functional Internet. SIGOPS Oper. Syst. Rev., 41(3):101 114, 2007. [12] Y. \nMinsky and S. Weeks. Caml trading experiences with functional programming on Wall Street. J. Funct. \nProgram., 18(4):553 564, 2008. [13] T. Morgan. Citrix desktop virt soars in Q4, Jan. 2010. http: //bit.ly/ciB74a. \n[14] B. O Sullivan. Mercurial: the de.nitive guide. O Reilly Media, .rst edition, 2009. [15] D. Syme, \nA. Granicz, and A. Cisternino. Expert F#. [16] J. Yallop. Practical generic programming in OCaml. In \nProceedings of the 2007 workshop on Workshop on ML, pages 83 94, New York, NY, USA, 2007. ACM.    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>We present a case-study of using OCaml within a large product development project, focussing on both the technical and non-technical issues that arose as a result. We draw comparisons between the OCaml team and the other teams that worked on the project, providing comparative data on hiring patterns and cross-team code contribution.</p>", "authors": [{"name": "David Scott", "author_profile_id": "81100544954", "affiliation": "Citrix Systems UK R&#38;D, Cambridge, United Kingdom", "person_id": "P2338153", "email_address": "", "orcid_id": ""}, {"name": "Richard Sharp", "author_profile_id": "81327491599", "affiliation": "Citrix Systems UK R&#38;D, Cambridge, United Kingdom", "person_id": "P2338154", "email_address": "", "orcid_id": ""}, {"name": "Thomas Gazagnaire", "author_profile_id": "81384616771", "affiliation": "INRIA Sophia Antipolis, Cedex, France", "person_id": "P2338155", "email_address": "", "orcid_id": ""}, {"name": "Anil Madhavapeddy", "author_profile_id": "81100020371", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P2338156", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863557", "year": "2010", "article_id": "1863557", "conference": "ICFP", "title": "Using functional programming within an industrial product group: perspectives and perceptions", "url": "http://dl.acm.org/citation.cfm?id=1863557"}