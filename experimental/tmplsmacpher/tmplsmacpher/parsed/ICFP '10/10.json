{"article_publication_date": "09-27-2010", "fulltext": "\n Semantic Subtyping with an SMT Solver Gavin M. Bierman C.at.alin Hrit\u00b8cu David Langworthy Andrew D. \nGordon Saarland University Microsoft Corporation Microsoft Research Abstract We study a .rst-order functional \nlanguage with the novel com\u00adbination of the ideas of re.nement type (the subset of a type to satisfy \na Boolean expression) and type-test (a Boolean expression testing whether a value belongs to a type). \nOur core calculus can express a rich variety of typing idioms; for example, intersection, union, negation, \nsingleton, nullable, variant, and algebraic types are all derivable. We formulate a semantics in which \nexpressions denote terms, and types are interpreted as .rst-order logic formu\u00adlas. Subtyping is de.ned \nas valid implication between the seman\u00adtics of types. The formulas are interpreted in a speci.c model \nthat we axiomatize using standard .rst-order theories. On this basis, we present a novel type-checking \nalgorithm able to eliminate many dy\u00adnamic tests and to detect many errors statically. The key idea is \nto rely on an SMT solver to compute subtyping ef.ciently. Moreover, interpreting types as formulas allows \nus to call the SMT solver at run-time to compute instances of types. Categories and Subject Descriptors \nF.3.3 [Logics and Mean\u00adings of Programs]: Studies of Program Constructs Type struc\u00adture; D.3.1 [Programming \nLanguages]: Formal De.nitions and Theory Semantics; F.3.2 [Logics and Meanings of Programs]: Semantics \nof Programming Languages Denotational semantics; Operational semantics; Program analysis General Terms \nLanguages, Theory, Veri.cation 1. Introduction This paper studies .rst-order functional programming in \nthe pres\u00adence of both re.nement types (types quali.ed by Boolean expres\u00adsions) and type-tests (Boolean \nexpressions testing whether a value belongs to a type). The novel combination of type-test and re.ne\u00adment \ntypes appears in a recent commercial functional language, code-named M [1], whose types correspond to \nrelational schemas, and whose expressions compile to SQL queries. Re.nement types are used to express \nSQL table constraints within a type system, and type-tests are useful for processing relational data, \nfor example, by discriminating dynamically between different forms of union types. Still, although useful \nand extremely expressive, the combination of type-test and re.nement is hard to type-check using conventional \nsyntax-driven subtyping rules. The preliminary implementation of M uses such subtyping rules and has \ndif.culty with certain sound Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright c &#38;#169; \n2010 ACM 978-1-60558-794-3/10/09... $10.00 idioms (such as uses of singleton and union types). Hence, \ntype safety is enforced by dynamic checks, or not at all. This paper studies the problem of type-checking \ncode that uses type-tests and re.nements via a core calculus, named Dminor, whose syntax is a small subset \nof M, and which is expressive enough to encode all the essential features of the full M language. In \nthe remainder of this section, we elaborate on the dif.culties of type-checking Dminor (and hence M), \nand outline our solution, which is to use semantic subtyping rather than syntactic rules. 1.1 Programming \nwith Type-Test and Re.nement The core types of Dminor are structural types for scalars, unordered collections, \nand records. (Following the database orientation of M, we refer to records as entities.) We write S <: \nT for the subtype relation, which means that every value of type S is also of type T . Two central primitives \nof Dminor are the following: A re.nement type, (x : T where e), consists of the values x of T satisfying \nthe Boolean expression e.  A type-test expression, e in T , returns true or false depending on whether \nor not the value of e belongs to type T .  As we shall see, many types are derivable from these primitive \nconstructs and their combination. For example, the singleton type [v], which contains just the value \nv, is derived as the re.nement type (x : Any where x == v), where Any is the type of all values. The \nunion type T | U, which contains the values of T together with the values of U, is derived as (x : Any \nwhere (x in T ) || (x in U)). Here is a snippet from a typical Dminor (and M) program for processing \na DSL, a language of while-programs. The type is a union of different sorts of statements, each of which \nis an entity with a kind .eld of singleton type. (The snippet relies on an omitted but similar recursive \ntype of arithmetic expressions.) type Statement = {kind:[\"assignment\"]; var: Text; rhs: Expression;}| \n{kind:[\"while\"]; test:Expression; body:Statement;}| {kind:[\"if\"]; test:Expression; tt:Statement; .:Statement;}| \n{kind:[\"seq\"]; s1:Statement; s2:Statement;}| {kind:[\"skip\"];}; In languages in.uenced by HOPE [10], such \nas ML and Haskell, we would use the built-in notion of algebraic type to represent such statements. But \nlike many data formats, including rela\u00adtional databases, S-expressions, and JavaScript Object Notation \n(JSON) [11], the data structures of M and Dminor do not take as primitive the idea of data tagged with \ndata constructors. Instead, we need to follow an idiom such as shown above, of taking the union of entity \ntypes that include kind .elds of distinct singleton types. If y has type Statement, we may process such \ndata as follows: ((y.kind == \"assignment\") ? y.var : \"NotAssign\") Intuitively, this code is type-safe \nbecause it checks the kind .eld before accessing the var .eld, which is only present for assignment statements. \nMore precisely, to type-check the then-branch y.var to type Text, we have y : Statement (i.e. a union \ntype encoded using re.nements and type-test), know that y.kind == \"assignment\", and need to decide [y] \n<: {var : Text;}. Subtyping should succeed, but clearly requires relatively sophisticated symbolic computation, \nincluding case analysis and propagation of equations. This is a typi\u00adcal example where syntax-driven \nrules for re.nements and type-test are inadequate, and indeed this simple example cannot be checked statically \nby the preliminary release of M. Our proposal is to dele\u00adgate the hard work to an external prover.  \n1.2 An Opportunity: SMT as a Platform Over the past few years, there has been tremendous progress in \nthe .eld of Satis.ability Modulo Theories (SMT), that is, for (frag\u00adments of) .rst-order logic plus various \nstandard theories such as equality, real and integer (linear) arithmetic, bit vectors, and (ex\u00adtensional) \narrays. Some of the leading systems include CVC3 [5], Yices [17], and Z3 [13]. There are common input \nformats such as Simplify s [15] unsorted S-expression syntax and the SMT-LIB standard [36] for sorted \nlogic. Hence, .rst-order logic with standard theories is emerging as a computing platform. Software written \nto generate problems in a standard format can rely on a wide range of back-end solvers, which get better \nover time due in part to healthy competition,1 and which may even be run in parallel when suf.\u00adcient \ncores are available. There are limitations, of course, as .rst\u00adorder validity is undecidable even without \nany theories, so solvers may fail to terminate within a reasonable time, but recent progress has been \nremarkable. 1.3 Semantic Subtyping with an SMT Solver The central idea in this paper is a type-checking \nalgorithm for Dmi\u00adnor that is based on deciding subtyping by invoking an external SMT solver. To decide \nwhether S is a subtype of T , we construct .rst-order formulas F[[S]](x) and F[[T ]](x), which hold when \nx be\u00adlongs to the type S and the type T , respectively, and ask the solver whether the formula F[[S]](x)=. \nF[[T ]](x) is valid, given any ad\u00additional constraints known from the typing environment. This tech\u00adnique \nis known as semantic subtyping [2, 22], as opposed to the more common alternative, syntactic subtyping, \nwhich is to de.ne syntax-driven rules for checking subtyping [34]. The idea of using an external solver \nfor type-checking with re\u00ad.nement types is not new. Several recent type-checkers for func\u00adtional languages, \nsuch as SAGE [20, 26], F7 [6], and Dsolve [38], rely on various SMT solvers. However, these systems all \nrely on syntactic subtyping, with the solver being used as a subroutine to check constraints during subtyping. \nTo the best of our knowledge, our proposal to implement se\u00admantic subtyping by calling an external SMT \nsolver is new. Se\u00admantic subtyping nicely exploits the solver s knowledge of .rst\u00adorder logic and the \ntheory of equality; for example, we represent union and intersection types as logical disjunctions and \nconjunc\u00adtions, which are ef.ciently manipulated by the solver. Hence, we avoid the implementation effort \nof explicit propagation of known equality constraints, and of syntax-driven rules for union and inter\u00adsection \ntypes [16]. Moreover, we exploit the theories of extensional arrays [14], integer arithmetic, and algebraic \ndatatypes. 1.4 Contributions of the Paper (1) Investigation of semantic subtyping for a core functional \nlan\u00adguage with both re.nement types and type-test expressions (a novel combination, as far as we know). \nWe are surprised that so many typing constructs are derivable from this combination. 1 Most important \nis the SMT-COMP [4] competition held each year in con\u00adjunction with CAV and in which more than a dozen \nSMT solvers contend. (2) Development of the theory, including both a declarative type assignment relation, \nand algorithmic rules in the bidirectional style. Our correctness results cover the core type assignment \nrelation, the bidirectional rules, the algorithmic purity check, and some logical optimizations. (3) \nAn implementation based on checking semantic subtyping by constructing proof obligations for an external \nSMT solver. The proof obligations are interpreted in a model that is formalized in Coq and axiomatized \nusing standard .rst-order theories (in\u00adtegers, datatypes and extensional arrays). (4) Devising a systematic \nway to use the models produced by the SMT solver as evidence of satis.ability in order to provide pre\u00adcise \ncounterexamples to typing, detect empty types and gener\u00adate instances of types. The latter enables a \nnew form of declar\u00adative constraint programming, where constraints arise from the interpretation of a \ntype as a formula.   1.5 Structure of the Paper \u00a72 describes the formal syntax of Dminor together with \na small\u00adstep operational semantics, e . e', where e and e' are expressions. We encode a series of type \nidioms to illustrate the expressiveness of the language and its type system. \u00a73 presents a logical semantics \nof pure expressions (those with\u00adout side-effects) and Dminor types; each pure expression e is inter\u00adpreted \nas a term R[[e]] and each type T is interpreted as a .rst-order logic formula F[[T ]](t). The formulas \nare interpreted in a speci.c model that we have formalized in Coq. Theorem 1 is a full abstrac\u00adtion result: \ntwo pure expressions have the same logical semantics just when they are operationally equivalent. We \ndescribe how to show purity of expressions using a syntactic termination restriction together with a \ncon.uence check that relies on the logical seman\u00adtics. Theorem 2 shows that our algorithmic purity check \nis indeed a suf.cient condition for purity. \u00a74 presents the declarative type system for Dminor. The type \nassignment relation has the form E f e : T , meaning that expres\u00adsion e has type T given typing environment \nE. Theorem 3 concerns logical soundness of type assignment; if e is assigned type T then formula F[[T \n]](R[[e]]) holds. Progress and preservation results (The\u00adorems 4 and 5) relate type assignment to the \noperational semantics, entailing that well-typed expressions cannot go wrong. \u00a75 develops additional \ntheory to justify our implementation techniques. First, we present simpler variations of the translations \nR[[e]] and F[[T ]](t), optimized by the observation that during type\u00adchecking we only interpret well-typed \nexpressions, and so we need not track error values. Theorem 6 shows soundness of this opti\u00admization. \nSecond, since the declarative rules of \u00a74 are not directly algorithmic, we propose type checking and \nsynthesis algorithms, presented as bidirectional rules. Theorem 7 shows these are sound with respect \nto type assignment. \u00a76 shows how to use the models produced by the SMT solver to provide very precise \ncounterexamples when type-checking fails and to .nd inhabitants of types statically or dynamically. \u00a77 \nreports some details of our implementation. We survey related work in \u00a78, before concluding in \u00a79. A \ntechnical report [8] contains additional details and proofs. 2. Syntax and Operational Semantics Dminor \nis a strict .rst-order functional language whose data in\u00adcludes scalars, entities, and collections; it \nhas no mutable state, and its only side-effects are non-termination and non-determinism. This section \ndescribes: (1) the syntax of expressions, types, and global function de.nitions; (2) the operational \nsemantics; (3) the de.ni\u00adtion of pure expressions (those without side-effects); and (4) some encodings \nto justify our expressiveness claims.  The following example introduces the basic syntax of Dminor. \nAn accumulate expression is a fold over an unordered collection; to evaluate from x in e1 let y = e2 \naccumulate e3, we .rst evaluate e1 to a collection v, evaluate e2 to an initial value u0, and then compute \na series of values ui for i . 1..n, by setting ui to the value of e3{vi/x}{ui-1/y}, and eventually return \nun, where v1, ..., vn are the items in the collection v, in some arbitrary order. NullableInt = Integer \n| [null] removeNulls(xs : NullableInt*): Integer* { from x in xs let a =({}:Integer*) accumulate (x!=null)?(x \n:: a): a } The type NullableInt is de.ned as the union of Integer with the sin\u00adgleton type containing \nonly the value null. We then de.ne a function removeNulls that iterates over its input collection and \nremoves all null elements. As expected, executing removeNulls({1, null, 42, null}) produces {1, 42} (which \ndenotes the same collection as {42, 1}). Given that the collection xs contains elements of type NullableInt \n(xs : NullableInt*), that x is an element of xs, and the check that x != null, our type-checking algorithm \ninfers that on the if branch x : Integer, and therefore the result of the comprehension is Integer*, \nas declared by the function. If we remove the check that x != null, and copy all elements with x :: a \nthen type-checking fails, as expected. 2.1 Expressions and Types We observe the following syntactic conventions. \nWe identify all phrases of syntax (such as types and expressions) up to consistent renaming of bound \nvariables. For any phrase of syntax f we write f{v/x} for the outcome of a capture-avoiding substitution \nof v for each free occurrence of x in f. We write fv(f) for the set of variables occurring free in f. \nWe assume some base types for integers, strings, and logical values, together with constants for each \nof these types, as well as a null value. We also assume an assortment of primitive operators; they are \nall binary apart from negation !, which is unary. Scalar Types, Constants, and Operators: G ::= Integer \n| Text | Logical scalar type K(Integer)= {i | integer i} K(Text)= {s | string s} K(Logical)= {true,false} \nc . K(Integer) . K(Text) . K(Logical) .{null} scalar constants ..{+,-,\u00d7,<,>, ==,!, &#38;&#38;,||} primitive \noperators A value may be a simple value (an integer, string, boolean, or null), a collection (a .nite \nmultiset of values), or an entity (a .nite set of .elds, each consisting of a value with a distinct label). \nSyntax of Values: v ::= value c scalar (or simple value) {v1,...,vn} collection (multiset; unordered) \n{ei . vi i.1..n} entity (ei distinct) We identify values u and v, and write u = v, when they are identical \nup to reordering the items within collections or entities. Although collections are unordered, ordered \nlists can be encoded using nested entities (see \u00a72.4). Syntax of Types: S,T,U ::= type Any the top type \nG scalar type T * collection type {e: T } (single) entity type (x : T where e) re.nement type (scope \nof x is e) All values have type Any, the top type. The values of a scalar type G are the scalars in the \nset K(G) de.ned above. The values of type T * are collections of values of type T . The values of type \n{e : T } are entities with (at least) a .eld e holding values of type T . (We show in \u00a72.4 how to de.ne \nmulti-.eld entity types as a form of intersection type.) Finally, the values of a re.nement type (x : \nT where e) are the values v of type T such that the boolean expression e{v/x} returns true. Syntax of \nExpressions: e ::= expression x variable c scalar constant .(e1,...,en) operator application e1?e2: e3 \nconditional let x = e1 in e2 let-expression (scope of x is e2) e in T type-test {ei . ei i.1..n} entity \n(ei distinct) e.e .eld selection {v1,...,vn} collection (multiset) e1 :: e2 adding element e1 to collection \ne2 from x in e1 iteration over collection let y = e2 accumulate e3 (scope of x and y is e3) f (e1,...,en) \nfunction application Variables, constants, operators, conditionals, and let-expressions are standard. \nWhen . is binary, we often write e1 . e2 instead of .(e1,e2).A type-test, e in T , returns a boolean \nto indicate whether or not the value of e inhabits the type T . The accumulate primitive can encode all \nthe usual operations on collections: counting the number of elements of or occurrences of a certain element, \nchecking membership, removing duplicates and elements, multiset union and difference, as well as LINQ \n[30] queries and comprehensions in the style of the nested relational calculus [9]. The precise de.nitions \nare in the technical report. To complete the syntax of Dminor, we interpret types and expressions in \nthe context of a .xed collection of .rst-order, dependently-typed, potentially recursive function de.nitions. \nWe assume for each expression f (e1,...,en) in a source program that there is a corresponding function \nde.nition for f with arity n. Function De.nitions: f (x1: T1,...,xn : Tn) : U{e}We assume a .nite, global \nset of function de.nitions, each of which associates a function name f with a dependent signature x1: \nT1,...,xn : Tn . U, formal parameters x1,...,xn, and a body e, such that fv(e) .{x1,...,xn} and fv(U) \n.{x1,...,xn}.  2.2 Operational Semantics We de.ne a nondeterministic, potentially divergent, small-step \nre\u00adduction relation e . e ', together with a standard notion of expres\u00adsions going wrong, to be prevented \nby typing. Each primitive operator is a partial function represented by a set of equations .(v1,...,vn) \n. v0 where each vi is a value. The == operator implements syntactic equality, which for collections and \nentities is up to reordering of elements. Apart from ==, the other operators only act on scalar values. \nReduction Contexts: R ::= reduction context .(v1,...,vj-1, ,ei+1,...,en) ?e2: e3 | let x = in e2 | in \nT {ei . vi i.1.. j-1,e j . ,ei . ei i. j+1..n} .e | :: e | v :: | from x in let y = e2 accumulate e3 \nf (v1,...,vj-1, ,ei+1,...,en)  Reduction Rules for Standard Constructs: ' e . e =. R[e] . R[e ' ] .(v1,...,vn) \n. v if .(v1,...,vn) . v de.ned true?e2: e3 . e2 false?e2: e3 . e3 let x = v in e2 . e2{v/x}{ei . vi i.1..n}.e \nj . vj where j . 1..n v :: {v1,..., vn}.{v1,...,vn,v}from x in {v1,..., vn} let y = e2 accumulate e3 \n. let y = e2 in let y = e3{v1/x} in ... let y = e3{vn/x} in y f (v1,...,vn) . e{v1/x1}...{vn/xn}given \nfunction de.nition f (x1: T1,...,xn : Tn) : U{e} Reduction Rules for Type-Test: v in Any . true e true \nif v . K(G) v in G . false otherwise e vj in Tj if v = {ei . vi i.1..n}. j . 1..n v in {e j : Tj}. false \notherwise e v1 in T &#38;&#38; ... &#38;&#38; vn in T if v = {v1,...,vn} v in T *. false otherwise v \nin (x : T where e) . v in T &#38;&#38; e{v/x} The reduction rules for type-test expressions, e in U, \n.rst reduce e to a value v and then proceed by case analysis on the structure of the type U. In case \nU is a re.nement type (x : T where e) then v is a value of U if and only if v is a value of type T and \ne{v/x} re\u00adduces to the value true. Nondeterminism arises from the reduction rule for accumulate expressions. \nSince collections are unordered, the rule applies for any permutation of {v1,...,vn}. For example, consider \nthe expression pick v1 v2 = from x in {v1,v2} let y = null accumulate x; we have both pick true false \n.* true and pick true false .* false. Next, we use reduction to de.ne an evaluation relation, which relates \na closed expression to its return values, or to Error, in case reduction gets stuck before reaching a \nvalue. Stuckness, Results, and Evaluation: e . r for closed e '' Let e be stuck if and only if e is not \na value and \u00ac.e .e . e . r ::= Error | Return(v) results of evaluation e . Return(v) if and only if e \n.* v ' '' e . Error if and only if there is e such that e .* e and e is stuck. Let closed expression \ne go wrong if and only if e . Error. For example, we have that stuck . Error, where stuck = {}.e for \nsome label e. In the presence of type-test and re.nement types, expressions can go wrong in unusual ways. \nFor example, given the re.nement type T =(x : Any where stuck), any type-test v in T goes wrong. The \nmain goal of our type system is to ensure that no closed well-typed expression goes wrong.   2.3 Pure \nExpressions and Re.nement Types A problem in languages with re.nement types (x : T where e) is that the \nre.nement expression e, even though well-typed, has effects, such as non-termination or non-determinism, \nand so makes no sense as a boolean condition. In Dminor calls to recursive functions can cause divergence, \nand since collections are unordered, iterating over them with accumulate may be nondeterministic, as \nabove. To address this problem, we de.ne the set of pure expressions, the ones that may be used as re.nements. \nThe details, below, are a little technical, but the gist is that pure expressions must be terminating, \nhave a unique result (which may be Error), and must only call functions whose bodies are pure. The typing \nrule (Type Re.ne) in \u00a74 requires that for (x : T where e) to be well-formed, the expression e must be \npure and of type Logical (which guarantees that e yields true or false without getting stuck). Checking \nfor purity is undecidable, but we present suf.cient conditions for checking purity algorithmically, in \n\u00a73.1. We assume that a subset of the function de.nitions are labeled\u00adpure; we intend that only these \nfunctions may be called from pure expressions. Let an expression e be terminating if and only if there \nexists no unbounded sequence e . e1 . e2 . .... Let a closed expression e be pure if and only if (1) \ne is terminating, (2) there exists a unique result r such that e . r, (3) for every subexpression f (e1,...,en) \nof e, the function f is labeled-pure, and (4) all subexpressions of e are pure. Let an arbitrary expression \ne be pure if and only if es is pure for all closing substitutions s that assign a value to each free \nvariable in e. Finally, we require that the body of every labeled-pure function is a pure expression. \n  2.4 Derived Types We end this section by exploring the expressiveness of the primitive types introduced \nabove, and in particular of the combination of re.nement types and dynamic type-test. We show that the \nrange of derivable types is rather wide. We begin with some basic examples. Encoding of Empty and Singleton \nTypes: Empty =(x : Any where false) [e]=(x : Any where x == e) (e pure, x ./fv(e)) The type Empty has \nno elements; it is a subtype of all other types. The singleton type, [e], contains only the value of \npure expression e (for example, type [null] consists just of the null value). Our calculus includes the \noperators of propositional logic on boolean values. We lift these operators to act on types as follows. \nEncoding of Union, Intersection, and Negation Types: T | U =(x : Any where (x in T ) || (x in U)) x ./fv(T,U) \nT &#38; U =(x : Any where (x in T ) &#38;&#38; (x in U)) !T =(x : Any where !(x in T )) A value of the \nunion type, T | U, is a value of T or of U. A value of the intersection type, T &#38; U, is a value of \nboth T and U. A value of the negation type,!T , is a value that is not a value of T . Next, we de.ne \nthe types of simple values, collections, and entities. We rely on the primitive types Integer, Text, \nand Logical, the primitive type constructor T * for collections, and the fact that every proper value \nis either a scalar, a collection, or an entity: so the type of entities is the complement of the union \ntype General |Collection. Encoding of Supertypes: General = Integer | Text | Logical | [null] Collection \n= Any* Entity = !(General | Collection) The primitive type of entities is unary: the type {e : T } is \nthe set of entities with a .eld e whose value belongs to T (and possibly other .elds). As in Forsythe \n[37], we derive multiple-.eld entity types as an intersection type. One advantage of this approach is \nthat it immediately entails width subtyping for entities. Encoding of Multiple-Field Entity Types: {ei \n: Ti; i.1..n} = {e1: T1} &#38; ... &#38; {en : Tn} (ei distinct,n > 0) We can also derive closed entity \ntypes, which only contain entities with a .xed set of labels and therefore do allow width subtyping. \nTo do so we constrain the multiple-.eld entity types above to additionally satisfy an eta law. Encoding \nof Closed Entity Types: closed{ei : Ti; i.1..n} = (x : {ei : Ti; i.1..n} where x == {ei . x.eii.1..n}) \n Pair types are just a special case of closed entity types. Given pair types, re.nement types, and type-test, \nwe can also encode dependent pair types Sx : T.U where x is bound in U. Encoding of Pair Types and Dependent \nPair Types: T *U = closed{fst : T ; snd : U; } (Sx : T.U)=(p : T * Any where let x = p.fst in (p.snd \nin U)) Sum types are obtained from union types by adding an addi\u00adtional Boolean tag; variant types are \na simple generalization. Encoding of Sum and Variant Types: T +U = ([true] * T ) | ([false] *U) e1: T1;...; \nen : Tn = ([e1] * T1) | ... | ([en] * Tn) Recursive types can be encoded as boolean recursive functions \nthat dynamically test whether a given value has the required type. Using recursive, sum, and pair types \nwe can encode any algebraic datatype. For instance the type of lists of elements of type T can be encoded \nas follows. Encoding List Types ListT =(T * (x : Any where fListT (x))) + [null] where fListT (x) is \na new labeled pure function de.ned by fListT (x : Any) : Logical { x in ((T * (x : Any where fListT (x))) \n+ [null])} Lists can be used to encode XML and JSON. Hence, Dminor can be viewed as a richly typed functional \nnotation for manipulat\u00ading data in XML format. In fact, DTDs can be encoded as Dminor types. XML data \ncan be loaded into Dminor even if there is no prior schema. We map an XML element to an entity, with \na .eld to rep\u00adresent the name of the element, additional .elds for any attributes on the element, and \na .nal .eld holding a list of all the items in the body of the element. Next, we show how to derive entity \ntypes for the common situ\u00adation where the type of one .eld depends on the value of another. A dependent \nintersection type (s : T &#38; U) [27] is essentially the intersection of T and U, except that the variable \ns is bound to the underlying value, with scope U. The type T cannot mention s, but we can rely on s : \nT when checking well-formedness of U. Encoding of Dependent Intersection Types: (s : T &#38; U)=(s : \nT where s in U) With this construct, we can de.ne entity types where the type of one .eld depends on \nthe value of another. For example, (p : {X : Integer} &#38; {Y : (y : Integer where y < p.X)}) is the \ntype of points below the diagonal. To further illustrate the power of collection types combined with \nre.nements, we give types below that express universal and existential quanti.cations over the items \nin a collection. Collection {v1,...,vn} : T * has type all(x : T )e if e{vi/x} for all i . 1..n, and, \ndually, it has type exists(x : T )e if e{vi/x} for some i . 1..n. Quantifying Over Collections: all(x \n: T )e =(x : T where e)* exists(x : T )e = T * &#38;!(all(x : T )!e) 3. Logical Semantics In this section \nwe give a set-theoretic semantics for types and pure expressions. Pure expressions are interpreted as \n.rst-order terms, while types are interpreted as formulas in many-sorted .rst-order logic (FOL). These \nformulas are interpreted in a .xed model, which we formalize in Coq. We represent a Dminor subtyping \nproblem as a logical implication, supply our SMT solver with a set of axioms that are true in our intended \nmodel, and ask the solver to prove the validity of the implication. We use Coq to state our model and \nto derive soundness of the axioms given to the SMT solver, but semantic subtyping calls only the SMT \nsolver, not Coq. To represent the intended logical model formally sets are en\u00adcoded as Coq types, and \nfunctions are encoded as Coq functions. We start with inductive types Value and Result given as grammars \nin \u00a72 (for brevity we omit the corresponding Coq de.nitions; they are given in the technical report [8] \n). We de.ne a predicate Proper that is true for results that are not Error, and a function out V that \nreturns the value inside if the result passed as argument is proper and null otherwise. Model: Proper \nResults: De.nition Proper (res : Result) := match res with | Return v .true | Error .false end. De.nition \nout V (res : Result): Value := match res with | Return v .v | Error .v null end. Our semantics uses many-sorted \n.rst-order logic (each sort is interpreted by a Coq type of the same name). We write predicates as functions \nto sort bool, with truth values true and false. We assume a collection of sorted function symbols whose \ninterpretation in the intended model is given below. Let t range over FOL terms; we write t : s to mean \nthat term t has sort s; if we omit the sort of a bound variable, it may be assumed to be Value. Similarly, \nfree variables have sort Value by default. If F is a formula, let |= F mean that F is valid in our intended \nmodel. Our semantics consists of three translations: For any pure expression e, we have the FOL term \nR[[e]] : Result.  For any Dminor type T and FOL term t : Value, we have the FOL formula F[[T ]](t), \nwhich is valid in the intended model if and only if the value denoted by t is a member of the type T \n.  For type T and FOL term t : Value, we have the formula W[[T ]](t), which holds if and only if a type-test \ngoes wrong when showing that the value denoted by t is a member of T . For instance, we have |= W[[(x \n: Any where stuck)]](null) . true, but |= W[[Any]](null) . false.  These three (mutually recursive) \ntranslations are de.ned below. We rely on notations for let-binding within terms (let x = t in t '), \nand terms conditional on formulas (if F then t else t '). These notations are supported directly by most \nSMT solvers. Given these we can de.ne the monadic bind for propagating errors as a simple notation. Notice \nthat |=(Bind x . Return(v) in t)= t{v/x} and |=(Bind x . Error in t)= Error. Notation: Monadic Bind for \nPropagating Errors: Bind x . t1 in t2 = (if \u00acProper(t1) then Error else let x = out V(t1) in t2) We begin \nby describing the semantics of some core types and expressions. The semantics of re.nement types F[[(x \n: T where e)]](t) relies on the result of evaluating e with x bound to t. Remember however that operationally \nthe type test v in (x : T where e) evalu\u00adates to Error if e{v/x} evaluates to Error or to a value that \nis not true or false. We use W[[(x : T where e)]](t) to record this fact, and we enforce that R[[e in \nT ]] returns Error if W[[T ]](t) holds. Tracking type tests going wrong is crucial for our full-abstraction \nresult. Semantics: Core Types and Expressions: F[[Any]](t)= true W[[Any]](t)= false F[[(x : T where e)]](t)= \nF[[T ]](t) . let x = t in (R[[e]] = Return(true)) W[[(x : T where e)]](t)= W[[T ]](t). let x = t in (\u00ac(R[[e]] \n= Return(false) . R[[e]] = Return(true)))  R[[x]] = Return(x) R[[e1?e2: e3]] = Bind x . R[[e1]] in \n(if x = true then R[[e2]] else (if x = false then R[[e3]] else Error)) R[[let x = e1 in e2]] = Bind x \n. R[[e1]] in R[[e2]] R[[e in T ]] = Bind x . R[[e]] in (if W[[T ]](x) then Error else (if F[[T ]](x) \nthen Return(true) else Return(false))) Next, we specify the semantics of scalar types and values. Model: \nTesters for Simple Values: De.nition In Logical v := (is Gv) &#38;&#38; is G Logical (out Gv). De.nition \nIn Integer v := (is Gv) &#38;&#38; is G Integer (out Gv). De.nition In Text v := (is Gv) &#38;&#38; is \nG Text (out Gv). Semantics: Scalar Types, Simple Values and Operators: F[[Integer]](t)= In Integer(t) \nR[[c]] = Return(c) F[[Text]](t)= In Text(t) W[[G]](t)= false F[[Logical]](t)= In Logical(t) R[[.(e1,...,en)]] \n= Bind x1 . R[[e1]] in ...Bind xn . R[[en]] in (if F[[T1]](x1) .\u00b7\u00b7\u00b7. F[[Tn]](xn) then Return(O.(x1,...,xn)) \nelse Error) where . : T1,...,Tn . T The notation . : T1,...,Tn . T de.nes type signatures for each primitive \noperator .. We omit the details, as well as the de.nitions of the functions O. interpreting each primitive \noperator .. The semantics of an entity type {e : T } is the set of all val\u00adues (denoted by t) that are \nentities (is E(t)) having the .eld e (v has .eld(e,t)), which contains a value of type T (F[[T ]](v dot(t,e))). \nModel: Functions and Predicates on Entities: Program De.nition v has .eld (s : string)(v : Value): bool \n:= match TheoryList.assoc eq str dec s (out Ev) with | Some v .true | None .false end. Program De.nition \nv dot (s : string)(v : Value): Value := match TheoryList.assoc eq str dec s (out Ev) with | Some v .v \n| None .v null end. Semantics: Entity Types and Expressions: F[[{e : T }]](t)= is E(t) . v has .eld(e,t) \n. F[[T ]](v dot(t,e)) W[[{e : T }]](t)= is E(t) . v has .eld(e,t) . W[[T ]](v dot(t,e)) R[[{ei . ei i.1..n}]] \n= Bind x1 . R[[e1]] in ...Bind xn . R[[en]] in Return({ei . xi i.1..n}) R[[e.e]] = Bind x . R[[e]] in \n(if is E(x) . v has .eld(e,x) then Return(v dot(x,e)) else Error) The semantics of from x in e1 let y \n= e2 accumulate e3 relies on a function res accumulate that folds over a collection by applying a function \nof sort ClosureRes2, and if no error occurs at any step it returns a value, otherwise it returns Error. \nThe model of the sort ClosureRes2 is the set of functions from Value to Value to Result. We write the \nlambda-abstraction fun xy . R[[e3]] for such a function. There are several standard techniques for representing \nlambda-abstractions in .rst-order logic [31]. Since the accumulate expression is pure it produces the \nsame result no matter what order is used when folding. Model: Functions and Predicates on Collections: \nProgram De.nition v mem (v cv : Value): bool := mem eq rval dec v (out Ccv). Program De.nition v add \n(v cv : Value): Value := (C (insert in sorted vb v (out Ccv))). De.nition ClosureRes2 := Value .Value \n.Result. Program Fixpoint res acc fold (f : ClosureRes2)(vb : VBag)(a : Result) {measure List.length \nvb} : Result := match vb with | nil .a | v :: vb .match a with Return va .res acc fold vb (f va v) | \nError .Error end end. De.nition res accumulate (f : ClosureRes2)(cv v : Value): Result := if is Ccv then \nres acc fold f (out Ccv)(Return v) else Error. The semantics of the collection type T * is the set of \nall val\u00adues (denoted by t) that are collections (is C(t)) containing only el\u00adements of type T (.x.v mem(x,t) \n. F[[T ]](x)). Semantics: Collection Types and Expressions: F[[T *]](t)= is C(t) . (.x.v mem(x,t) . F[[T \n]](x)) x ./fv(T,t) W[[T *]](t)= is C(t) . (.x.v mem(x,t) . W[[T ]](x)) x ./fv(T,t) R[[{v1,..., vn}]] \n= Return({v1,...,vn}) R[[e1 :: e2]] = Bind x1 . R[[e1]] in Bind x2 . R[[e2]] in (if is C(x2) then Return(v \nadd(x1,x2)) else Error) R[[from x in e1 let y = e2 accumulate e3]] = Bind x1 . R[[e1]] in Bind x2 . R[[e2]] \nin res accumulate((fun xy . R[[e3]]),x1,x2) In order to give a semantics to function applications we \nrecall that pure expressions may only call labeled-pure functions, and that the body of a labeled-pure \nfunction is itself a pure expres\u00adsion. For each labeled-pure function de.nition f (x1: T1,...,xn : Tn) \n: U{e}, the model of the symbol f is the total function f . Valuen . Result such that f (v1,...,vn) is \nthe result r such that e{v1/x1}...{vn/x1}. r. (We know that there is a unique r such that e{v1/x1}...{vn/x1}. \nr because e is pure.) Hence, the follow\u00ading holds by de.nition: LEMMA 1. If f (x1: T1,...,xn : Tn) : \nU{e} and e is pure and e{v1/x1}...{vn/xn}. r then |= f (v1,...,vn)= r. Semantics: Function Application: \nR[[ f (e1,...,en)]] = Bind x1 . R[[e1]] in ... Bind xn . R[[en]] in f (x1,...,xn) The operational semantics \npreserves logical meaning: ' PROPOSITION 1. For all closed pure expressions e and e', if e . e then |= \nR[[e]] = R[[e ' ]]. Moreover, we have a full abstraction result for this .rst-order language: the equalities \ninduced by the operational and logical semantics of closed pure expressions coincide. THEOREM 1 (Full \nAbstraction). For all closed pure expressions e and e' , |= R[[e]] = R[[e ' ]] if and only if, for all \nr, e . r . e '. r. 3.1 Algorithmic Purity Check The purity property de.ned in \u00a72.3 is undecidable. We \nuse a syntac\u00adtic termination condition on the applied functions together with a restriction on the accumulate \nexpressions to make the purity checks tractable. We call an expression e algorithmically pure if and \nonly if the following three conditions hold: (1) if e is a function application f (e1,..., en) then f \nis labeled-pure, and only calls f (directly or indirectly) on structurally smaller arguments; (2) if \ne is of the form from x in e1 let y = e2 accumulate e3 then  |= R[[let y = e3{x1/x}{y1/y} in e3{x2/x}]] \n= R[[let y = e3{x2/x}{y1/y} in e3{x1/x}]]  (where the variables x1, x2, and y1 do not appear free in \ne3); (3) all the proper subexpressions of e are algorithmically pure (in\u00adcluding the ones inside all \nre.nement types contained by e). Condition (1) enforces termination of algorithmically pure ex\u00adpressions: \nonly labeled-pure functions can be called and if these functions are recursive then recursive calls can \nonly be on syntac\u00adtically smaller arguments. Condition (2) only allows accumulates in an algorithmically \npure expression if the order in which the ele\u00adments are processed is irrelevant for the .nal result. \nIn general we call a (mathematical) function f : X \u00d7 Y . Y order-irrelevant if f (x1, f (x2, y)) = f \n(x2, f (x1,y)) for all x1, x2 and y. Enforcing that the semantics of the body of accumulate expressions \nis an order\u00adirrelevant function is a suf.cient condition for the uniqueness of evaluation results. We \nphrase this condition in terms of the logical semantics and check it using the SMT solver. Order-irrelevance \nis less restrictive than conditions found in the literature such as asso\u00adciativity and commutativity \n[28]. If f is associative and commuta\u00adtive then f is also order-irrelevant, but the converse fails in \ngeneral. If f is order-irrelevant its two arguments need not even have the same type. THEOREM 2. If e \nis algorithmically pure then e is pure. The logical semantics is de.ned only on pure expressions. Given \nthe logical semantics, we obtain algorithmic purity, a suf\u00ad.cient condition for purity. In the remainder \nof the paper we rely only on algorithmic purity. 4. Declarative Type System In this section, we give \na non-algorithmic type assignment relation, and prove preservation and progress properties relating it \nto the operational semantics. In the next section, we present algorithmic rules the basis of our type-checker \nfor proving type assignment. Each judgment of the type system is with respect to a typing environment \nE, of the form x1: T1,..., xn : Tn, which assigns a type to each variable in scope. We write \u00d8 for the \nempty environment, dom(E) to denote the set of variables de.ned by a typing environ\u00adment E, and F[[E]] \nfor the logical interpretation of E. Environments and their Logical Semantics: E ::= x1: T1,...,xn : \nTn type environments dom(x1: T1,...,xn : Tn)= {x1,...,xn} F[[x1: T1,...,xn : Tn]] = F[[T1]](x1) .\u00b7\u00b7\u00b7. \nF[[Tn]](xn) Environments and Judgments of the Declarative Type System: E fo environment E is well-formed \nE f T in E, type T is well-formed '' E f T <: T in E, type T is a subtype of T E f e : T in E, expression \ne has type T Global Assumptions: For each function de.nition f (x1: T1,...,xn : Tn) : U{ef }we assume \nthat x1: T1,...,xn : Tn f ef : U. Rules of Well-Formed Environments and Types: E fo, E f T (Env Empty) \n(Env Var) (Type Any) (Type Scalar) E f Tx ./dom(E) E fo E fo \u00d8fo E,x : T fo E f Any E f G (Type Re.ne) \n(Type Collection) (Type Entity) E,x : T f e : Logical E f TE f T e alg. pure E f T * E f{e: T } E f (x \n: T where e) The subtype relation is de.ned as logical implication between the logical semantics of well-formed \ntypes. Rule of Semantic Subtyping: (Subtype) ' E f TE f Tx ./dom(E) |=(F[[E]] . F[[T ]](x)) =. F[[T ' \n]](x) ' E f T <: T Rules of Type Assignment: E f e : T (Exp Singular Subsum) E f e : T E f [e : T ] <: \nT ' (Exp Var) E f o (x : T ) . E (Exp Const) E f o E f e : T ' E f x : T E f c : Any (Exp Eq) (Exp Operator) \n(Exp Cond) E f e1: T1 . = (==) E f e1: Logical E f e2: T2 . : T1,...,Tn . TE, : Ok(e1) f e2: T T = Logical \nE f ei : Ti .i . 1..nE, : Ok(!e1) f e3: T E f e1 == e2: TE f.(e1,...,en) : TE f (e1?e2: e3) : T (Exp \nLet) (Exp Test) E f e1: TE,x : T f e2: Ux ./fv(U) E f e : Any E f T E f let x = e1 in e2: UE f e in \nT : Logical (Exp Entity) (Exp Dot) E f ei : Ti .i . 1..nE fo E f e : {e: T } E f{ei . ei i.1..n} : {ei \n: Ti i.1..n} E f e.e : T (Exp Coll) (Exp Add) E f vi : T .i . 1..nE fo E f e1: TE f e2: T * E f{v1,...,vn} \n: T * E f (e1 :: e2) : T * (Exp Acc) (Exp App) E f e1: T * E f e2: U given f (x1: T1,...,xn : Tn) : U{ef \n} E,x : T,y : U f e3: U {x1,...,xn}n dom(E)= \u00d8 x,y ./fv(U) si = {e1/x1}...{ei/xi}.i . 0..n E f from x \nin e1: U ei alg. pure E f ei : Tisi-1 .i . 1..n let y = e2 E f f (e1,... en) : Usn accumulate e3 The \nrule (Exp Cond) records the appropriate test expression in the environment, when typing the branches. \nThe actual value of a type Ok(e) is arbitrary, the point is simply to record that condition e holds [23], \nprovided it is pure. When e is not pure, Ok(e) is equivalent to Any. Typed Singleton Types and Ok Types: \ne (x : T where x == e)(x ./fv(e)) if e alg. pure [e : T ]= T otherwise e (x : Any where e)(x ./fv(e)) \nif e alg. pure Ok(e)= Any otherwise The rule (Exp Singular Subsum) can be seen as a combination of the \nfollowing conventional rules of subsumption and singleton introduction. (Exp Subsum) (Exp Singleton) \n' E f e : TE f T <: TE f e : T ' E f e : TE f e : [e : T ] Both these rules are derivable from (Exp Singular \nSubsum). In fact, we can go in the other direction too so that the type assign\u00adment relation would be \nunchanged were we to replace (Exp Sin\u00adgular Subsum) with (Exp Subsum) and (Exp Singleton). Still, the \ngiven presentation is simpler to work with because (Exp Singular Subsum) is the only rule not determined \nby the structure of the ex\u00adpression being typed.  In the rule (Exp App), we require that each ei in \na dependent function application f (e1,...en) is (algorithmically) pure. This al\u00adlows us to substitute \nthese expressions into U. To form, say, f (e) where e is impure, we can work around this restriction \nby writing let x = e in f (x) instead. The following soundness property relates type assignment to the \nlogical semantics of types and expressions. Point (1) is that the logical value of a well-typed expression \nsatis.es the interpretation of its type as a predicate. Point (2) is that evaluating a type-test for \na well-formed type cannot go wrong. THEOREM 3 (Logical Soundness). (1) If e is alg. pure and E f e : \nT then:  |= F[[E]] =. Proper(R[[e]])  |= F[[E]] =. F[[T ]](out V(R[[e]]))  (2) If E f U then |= F[[E]] \n=..y.\u00acW[[U]](y), for y ./fv(U).  The rule (Exp Singular Subsum), depends on the relation E f [e : T \n] <: T ', which we refer to as singular subtyping. We illus\u00adtrate (Exp Singular Subsum) and singular \nsubtyping with regard to (Exp Const). For example, to derive that E f [42 : Any] <: Integer note that \n|= F[[[42 : Any]]](x) . x = 42 and hence that |= F[[[42 : Any]]](x)=. In Integer(x). LEMMA 2 (Singular \nSubtyping). ' Suppose E f e : T and E f T and x ./dom(E). (1) If e is alg. pure then: ' E f [e : T ] \n<: T iff |= F[[E]] . F[[T ]](out V(R[[e]])) =. F[[T ' ]](out V(R[[e]])) (2) If e is not alg. pure then: \n' E f [e : T ] <: T iff |= F[[E]] . F[[T ]](x)=. F[[T ' ]](x) By the following lemma, singular subtyping \nis transitive, and hence we have that any derivation of a type assignment can be seen as one instance \nof a structural rule plus one instance of (Exp Sin\u00adgular Subsum). This observation is useful, for example, \nin proving type preservation, Theorem 4. LEMMA 3 (Transitivity of Singular Subtyping). ' '' '' If E f \n[e : T ] <: T and E f [e : T ' ] <: T then E f [e : T ] <: T. We have proved standard derived judgment, \nweakening, bound weakening, and substitution lemmas for the type system, which are used in the proofs \nof the progress and preservation theorems. THEOREM 4 (Preservation). ' If E f e : T and e . e then E \nf e ' : T. THEOREM 5 (Progress). '' If \u00d8f e : T and e is not a value then .e .e . e. 5. Algorithmic Aspects \n5.1 Optimizing the Logical Semantics Our logical semantics propagates error values so as to match the \nstuck expressions of our operational semantics. Tracking errors is important, but observe that when we \nuse our logical semantics during semantic subtyping, we only ever ask whether well-formed types are related. \nEvery expression occurring in a well-formed type is itself well-typed, and so, by Theorem 3, its logical \nsemantics is a proper value, not Error. This suggests that when checking subtyping we can optimize the \nlogical semantics given the assumption that the expressions occurring within the two types are well-typed. \nIn particular, we can apply the following lemma to transform monadic error-checking binds into ordinary \nlets. LEMMA 4. If e alg. pure and E f e : T then |= F[[E]] =. (Bind x . R[[e]] in t)=(let x = out V(R[[e]]) \nin t). Proof: By de.nition of notation, Bind x . R[[e]] in t is the term (if \u00acProper(R[[e]]) then Error \nelse let x = out V(R[[e]]) in t). By Theorem 3, |= F[[E]] =. Proper(R[[e]]). Hence the result. 0 The \nfollowing tables present the optimized de.nitions used in our type-checker, and the following theorem \nstates their correctness with respect to the error tracking semantics of \u00a73. Optimized Semantics of Types: \nF' [[T ]](t) F' [[Any]](t)= true F' [[Integer]](t)= In Integer(t) F' [[Text]](t)= In Text(t) F' [[Logical]](t)= \nIn Logical(t) F' [[{e : T }]](t)= is E(t) . v has .eld(e,t) . F' [[T ]](v dot(t,e)) F' [[T *]](t)= is \nC(t) . (.x.v mem(x,t) . F' [[T ]](x)) x ./fv(T,t) F' [[(x : T where e)]](t)= F' [[T ]](t) . let x = \nt in V[[e]] = true x ./fv(T,t) Optimized Semantics of Pure Typed Expressions: V[[e]] V[[x]] = x V[[c]] \n= c V[[.(e1,...,en)]] = O.(V[[e1]],...,V[[en]]) V[[e1?e2: e3]] = (if V[[e1]] = true then V[[e2]] else \nV[[e3]]) V[[let x = e1 in e2]] = let x = V[[e1]] in V[[e2]] V[[e in T ]] = (if F' [[T ]](V[[e]]) then \ntrue else false) V[[e : T ]] = V[[e]] V[[{ei . ei i.1..n}]] = {ei . V[[ei]] i.1..n} V[[e.e]] = v dot(V[[e]],e) \nV[[{v1,..., vn}]] = {v1,...,vn} V[[e1 :: e2]] = v add(V[[e1]],V[[e2]]) V[[from x in e1 let y = e2 accumulate \ne3]] = v accumulate((fun xy . V[[e3]]),V[[e1]],V[[e2]]) We omit the de.nition of the function v accumulate, \nwhich is a variant of res accumulate that works with values rather than results. See the technical report \nfor the full details [8]. THEOREM 6 (Soundness of Optimized Semantics). (1) If E f T and x ./dom(E) then: \n|=(F[[E]] =. (F[[T ]](x) . F' [[T ]](x)). (2) If E f e : T then: |= F[[E]] =. (R[[e]] = Return(V[[e]])). \nProof: The proof is by simultaneous induction on the derivations of E f T and E f e : T , with appeal \nto Theorem 3 and Lemma 4.0  5.2 Bidirectional Typing Rules The Dminor type system is implemented as \na bidirectional type system [35]. The key concept of bidirectional type systems is that there are two \ntyping relations, one for type checking, and one for type synthesis. The chief characteristic of these \nrelations is that they are local in the sense that type information is passed between adjacent nodes \nin the syntax tree without the use of long-distance constraints such as uni.cation variables, as used \nin, e.g., ML. Judgments of the Algorithmic Type System: E f e . T in E, expression e synthesizes type \nT E f e . T in E, expression e checks against type T E ' o environment E is alg. well-formed E ' T in \nE, type T is alg. well-formed E ' S <: T in E, type S is alg. a subtype of type T Both subtyping and \nwell-formedness rely on type-checking, so we need to distinguish versions of these judgments that use \nthe declarative typing rules from versions that use the bidirectional typ\u00ading rules (and in the case \nof subtyping, the optimized semantics). For brevity we omit the de.nitions, which may be found in the \ntechnical report [8].  Rules of Type Synthesis: E f e . T (Synth Var) (Synth Const) E ' o (x : T ) . \nEE ' o E f x . [x : T ] E f c . [c : typeof (c)] (Synth Operator) E f ei . Ti .i . 1..n . : T1,..., Tn \n. T E f.(e1,...,en) . [.(e1,...,en): T ] (Synth Cond) E f e1 . Logical E, : Ok(e1) f e2 . T2 E, : Ok(!e1) \nf e3 . T3 E f (e1?e2: e3) . (if e1 then T2 else T3) (Synth Let) E f e1 . T1 E,x : T1 f e2 . T2 E f T2{e1/x} \nE f let x = e1 in e2 . T2{e1/x} (Synth Test) (Synth Ascribe) E f e . Any E ' TE f e . T E f e in T . \nLogical E f (e: T ) . T (Synth Entity) E f e1 . T1 \u00b7\u00b7\u00b7 E f en . Tn E ' o E f{ei . ei i.1..n}.{e1: T1} \n&#38; \u00b7\u00b7\u00b7 &#38; {en : Tn}(Synth Dot) E f e . T norm(T )= DD.e U E f e.e . [e.e : U] (Synth Coll) E f \nvi . Ti .i . 1..nE ' o E f{v1,...,vn}. (T1 | ... | Tn)* (Synth Add) E f e1 . T1 E f e2 . T2 norm(T2)= \nD2 D2.Items U2 E f e1 :: e2 . ([e1: T1] | U2)* (Synth Acc) E f e1 . T1 norm(T1)= D1 D1.Items U1 E f e2 \n. T2 E,x : U1,y : T2 f e3 . T2 E f from x in e1 let y = e2 accumulate e3 . T2 (Synth App) given f (x1: \nT1,...,xn : Tn) : U{ef } si = {e1/x1}...{ei/xi}.i . 0..n ei is alg. pure E f ei . (Tisi-1) .i . 1..n \n E f f (e1,...en) . Usn The rules (Synth Var), and (Synth Const) yield singleton types for all variables \nand constants, where the function typeof returns the type of a given constant. Rule (Synth Entity) uses \nintersection types to encode record types. The (Synth Cond) rule synthesizes a conditional type, which \nis the union of the two types synthesized for the branches along with the test expression (if it is pure) \nto allow more precise typing. Encoding of Conditional Types: if e then T else U = e ( : T where e) | \n( : U where !e) if e alg. pure T | U otherwise The (Synth Ascribe) rule allows the user to provide hints \nto the type-checker in the form of type annotations (e : T ). Such type annotations have no operational \nsigni.cance (in the small-step semantics e : T . e), and are necessary in case the type-checker cannot \ninfer the loop invariants of accumulate expressions. In several of the type synthesis rules we need to \ninspect compo\u00adnents of intermediate types. In simple type systems this is straight\u00adforward as one can \nrely on the syntactic structure of types, but for rich type systems such as the one of Dminor this is \nnot possible. In other dependently-typed languages, either the programmer is re\u00adquired to insert casts \nto force the type into the appropriate syntac\u00adtic shape [43], or types are .rst executed until a normal \nform is reached [3]. Unfortunately, neither approach is acceptable in Dmi\u00adnor: the former forces too \nmany casts on the programmer, and the latter is not feasible because re.nements often refer to potentially \nvery large data sets. One pragmatic possibility is to attempt type normalization but place some ad hoc \nbound on evaluation [26]. As an alternative, we de.ne a disjunctive normal form (DNF) for types, along \nwith a normalization function, norm, for translating types into DNF, and procedures for extracting type \ninformation from DNF types. In practice, this approach works well. Normal Types (DNF): D ::= R1 | ... \n| Rn normal disjunction (Empty if n = 0) R ::= x : C where e normal re.ned conjunction C ::= A1&#38; \n... &#38; An normal conjunction (Any if n = 0) A ::= G | T *|{e: T } atomic type We can de.ne two partial \nfunctions to extract .eld and item types from normalized entity and collection types. These are written \nD.e U and D.Items U, respectively. For example ({e : Integer}|{e : Logical}).e Integer | Logical and \n((Text* &#38; Logical) | Integer*).Items Text | Integer. Note that both these functions are partial, \ne.g. ({e: Integer}|{e ' : Logical}).e . The simple de.nitions of these functions are in the technical \nreport [8]. Rules of Type Checking: E f e . T (Check Cond) (Swap) E f e1 . Logical ' E f e . TE ' [e: \nT ] <: TE, : Ok(e1) f e2 . T ' E, : Ok(!e1) f e3 . T E f e . T E f e1?e2: e3 . T (Check Let) (Check Dot) \nE f e1 . TE,x : T f e2 . Ux . fv(U) E f e .{e : T } E f let x = e1 in e2 . UE f e.e . T The (Swap) rule \ntests for singular subsumption and applies if the expression to be type-checked is not a conditional, \nlet-expression or a .eld selection. Typically (e.g. SAGE [26]), the type checking relation for a bidirectional \ntype system consists of a single rule of the form: E f e . SE ' S <: T E f e . T However, we have found \nin practice that in the cases where the ex\u00adpression is a conditional or a let-expression, we get better \nprecision of type checking by passing the type through to the subexpressions, as shown in the (Check \nCond) and (Check Let) rules. Similarly, we can pass through an entity type in the (Check Dot) rule. LEMMA \n5 (Synthesis Checkable). If E f e . T then E f e . T. THEOREM 7 (Soundness of Algorithmic Type System). \n(1) If E ' o then E fo. (2) If E ' T then E f T. (3) If E ' S <: T and E f S then E f S <: T. (4) \nIf E f e . T then E f e : T. (5) If E f e . T then E f e : T.   6. Exploiting SMT Models SMT solvers \nsuch as Z3 can produce a potential model in case they fail to prove the validity of a proof obligation \n(that is, when they show the satis.ability of its negation, or when they give up). In our case such models \ncan be automatically converted into assign\u00adments mapping program variables to Dminor values. Because \nof the inherent incompleteness of the SMT solver2 and of the axiom\u00adatization we feed to it, the obtained \nassignment is not guaranteed to be correct. However, given a way to validate assignments, one can use \nthe correct ones to provide very precise counterexamples when type-checking fails, and to .nd inhabitants \nof types statically or dynamically, in a way that amounts to a new style of constraint logic programming. \n6.1 Precise Counterexamples to Type-checking The type-checking algorithm from \u00a75.2 crucially relies on \nsubtyp\u00ading, as in the rule (Swap), and our semantic subtyping relation ' E f T <: T produces proof obligations \nof the form |=(F[[E]] . F[[T ]](x)) =. F[[T ' ]](x) for some fresh variable x. If the SMT solver fails \nto prove such an obligation, it produces a potential model from which we can extract an assignment s \nmapping x and all variables in E to Dminor values. To verify that s is a valid counterexample, we check \nthe following three conditions: ' (1) E f T and E f T (2) (ys in Us) .* true, for all (y : U) . E; \n(3) (xs in (T &#38;!T ' )s) .* true.  Condition (1) enforces that we only evaluate pure expressions \ntherefore ensuring termination and con.uence of the reduction. Condition (2) enforces that the values \nfor all variables in E have their corresponding (possibly dependent) types. Condition (3) checks whether \nthe value assigned to x by s is an element of T but not an element of T '. If these three checks succeed, \ns is a valid counterexample to typing that we display to the user. ' LEMMA 6. If the three checks above \nsucceed then E f T <: T. Since the type-checker is itself over-approximating, there is no guarantee that \nan expression e that fails to type-check is going to get stuck when evaluated. The best we might do is \nto evaluate es for a .xed number of steps, a .xed number of times (remember that e can be non-deterministic), \nsearching for a counterexample trace we can additionally display to the user. 6.2 Finding Elements of \nTypes Statically Type emptiness can be phrased in terms of subtyping as E f T <: Empty, or equivalently \n|= \u00ac(F[[E]] . F[[T ]](x)) for some fresh x. We additionally check that F[[E]] is satis.able (and the \nmodel the SMT solver produces is a correct one) to exclude the case that the environment is inconsistent \nand therefore any subtyping judgment holds vacuously. Hence, we can detect empty types during type\u00adchecking \nand issue a warning to the user if an empty type is found. This is useful, since one can make mistakes \nwhen writing types containing complicated constraints. Moreover, if the SMT solver cannot prove that \na type is empty we again obtain an assignment s, which we can validate as in \u00a76.1. If validation succeeds \nwe know that xs is an element of T s, and we can display this information if the user hovers over a type. \n2 Other than background theories with a non-recursively enumerable set of logical consequences such as \ninteger arithmetic, other sources of incom\u00adpleteness in SMT solvers are quanti.ers (which are usually \nheuristically instantiated) and user-de.ned time-outs. ' LEMMA 7. If the three checks in \u00a76.1 succeed \nfor T = Empty then \u00d8f xs : T s and \u00d8f ys : Us for all (y : U) . E.  6.3 Finding Elements of Types Dynamically \nWe can use the same technique to .nd elements of types dynam\u00adically. We augment the calculus with a new \nprimitive expression elementof T (not present in the M language) which tries to .nd an inhabitant of \nT . If successful the expression returns such a value, but otherwise it returns null. (We can always \nchoose T so that null is not a member, so that returning null unambiguously signals that no member of \nT was found.) Operational Semantics for Finding Elements of Types: elementof T . v where v in T .* true \nelementof T . null Finding elements of types is actually simpler to do dynamically than statically: at \nrun-time all variables inside types have already been substituted by values, so there are fewer checks \nto perform. The outcome of elementof T is in general non-deterministic, and depends in practice on the \ncomputational power and load of the system as well as on the timeout used when calling the SMT solver. \nBecause of this elementof T expressions are considered algorithmically impure, and therefore cannot appear \ninside types. Typing rules for elementof: (Exp elementof) (Synth elementof) E f TE f T E f elementof \nT : (T | [null]) E f elementof T . (T | [null]) LEMMA 8. If elementof T . v and \u00d8f T then \u00d8f v : T | \n[null]. The new elementof T construct enables a form of constraint programming in Dminor, in which we \niteratively change the con\u00adstraints inside types in order to explore a large state space. For in\u00adstance \nthe following recursive function computes all correct con.g\u00adurations of a complex system when called \nwith the empty collection as argument. Correctness is speci.ed by some type GoodCon.g. allGoodCon.gs(avoid \n: GoodCon.g*): GoodCon.g*{ let m = elementof (GoodCon.g where !(value in avoid)) in (m == null)? {} :(m \n:: (allGoodCon.gs(m :: avoid))) } Programming in this purely declarative style can be appealing for rapid \nprototyping or other tasks where ef.ciency is not the main concern. One only needs to specify what has \nto be computed in the form of a type. It is up to the SMT solver to use the right (semi\u00ad)decision procedures \nand heuristics to perform the computation. If this fails or is too slow one can instead implement the \nrequired functionality manually. There is little productivity loss in this case since the types one has \nalready written will serve as speci.cation for the code that needs to be written manually. 7. Implementation \nOur prototype Dminor implementation is approximately 2700 lines of F. code, excluding the lexer and parser. \nOur type-checker imple\u00adments the algorithmic purity check from \u00a73.1, the optimized logical semantics \nfrom \u00a75.1, and the bidirectional typing rules from \u00a75.2. We use Z3 [13] to discharge the proof obligations \ngenerated by se\u00admantic subtyping. Together with the proof obligations we feed to Z3 a 500 line axiomatization \nof our intended model in SMT-LIB format [36], which uses the theories of integers, datatypes and ex\u00adtensional \narrays. The formal de.nition of our intended model of Dminor is just over 4000 lines of Coq.  We have \ntested our type-checker on a test suite consisting of about 130 .les, some type-correct and some type-incorrect, \nsome hand-crafted by us and some transliterated from the M preliminary release. Even without serious \noptimization the type-checker is fast. Checking each of the 130 .les in our test suite on a typical laptop \ntakes from under 1 second (for just startup and parsing) to around 3 seconds (for type-checking an interpreter \nfor while-programs see \u00a71.1 that discharges more than 300 proof obligations). Also, our experience with \nZ3 has been very positive so far whilst it is possible to craft subtyping tests that cannot be ef.ciently \nchecked,3 Z3 has performed very well on the idioms in our test suite. Still, we cannot draw .rm conclusions \nuntil we have studied bigger examples. We have also implemented the techniques for exploiting SMT solver \nmodels described in \u00a76. We built a plugin for the Microsoft Intellipad text editor [1] that displays \nprecise counterexamples to typing, .ags empty types and otherwise displays one element of each type de.ned \nin the code. Moreover, our interpreter for Dminor supports elementof for dynamically generating instances \nof types (\u00a76.3). This works well for simple constraints involving equalities, datatypes and simple arithmetic, \nand types that are not too deeply nested. However, scaling this up to arbitrary Dminor types is a chal\u00adlenge \nthat will require additional work, as well as further progress in SMT solvers. 8. Related Work Whilst \nDminor s combination of re.nement types and type-tests is new and highly expressive, it builds upon a \nlarge body of related work on advanced type systems. Re.nement types have their ori\u00adgins in early work \nin theorem proving systems and speci.cation languages, such as subset types in constructive type theory \n[33], set comprehensions in VDM [25], and predicate subtypes in PVS [39]. In PVS, constraints found when \nchecking predicate subtypes be\u00adcome proof obligations to be proved interactively. More recently, Sozeau \n[41] extends Coq with subset types; as in PVS the proofs of subset type membership have to be constructed \nusing tactics. Freeman and Pfenning [21] extended ML with a form of re\u00ad.nement type, and Xi and Pfenning \n[43] considered applications of dependent types in an extension of ML. In both of these systems, decidability \nof type checking is maintained by restricting which ex\u00adpressions can appear in types. Lovas and Pfenning \n[29] presented a bidirectional re.nement type system for LF, where a restriction on expressions leads \nto an expressive yet decidable type system. Other work has combined re.nement types with syntactic sub\u00adtyping \n[6, 38] but none includes type-test in the re.nement lan\u00adguage. Closest to our type system is the work \nof Flanagan et al. on hybrid types and SAGE [26]. SAGE also uses an SMT solver to check the validity \nof re.nements but not for subtyping (checked by traditional syntactic techniques), and does not allow \ntype-test ex\u00adpressions in re.nements. However, SAGE supports a dynamic type and employs a particular \nform of hybrid type checking [20] that allows particular expressions to have their type-check deferred \nun\u00adtil run-time. The idea of hybrid types is to strike a balance between runtime checking of contracts, \nas in Eiffel [32] and DrScheme [18], and static typing. Compared to purely static typing this can reduce \nthe number of false alarms generated by type-checking. In spite of early work on semantic subtyping by \nAiken and Wimmers [2] and Damm [12], most programming and query lan\u00adguages instead use a syntactic notion \nof subtyping. This syntactic approach is typically formalized by an inductively or co-inductively de.ned \nset of rules [34]. Unfortunately, deriving an algorithm from such a set of rules can be dif.cult, especially \nfor advanced features such as intersection and union types [16]. 3 Z3 gets at most 1 second for each \nproof obligation by default. X10 [40] is an object-oriented language that supports re.ne\u00adment types. \nA class C can be re.ned with a constraint c on the immutable state of C, resulting in a type written \nC(:c). The base language supports only simple equality constraints but further con\u00adstraints can be added \nand multiple constraint solvers can be inte\u00adgrated into the compiler. In comparison with Dminor, X10 \nuses a mixture of semantic and syntactic subtyping, while its constraint language [40, \u00a72.11] does not \nsupport type-test expressions. The introduction of XML and XML query languages led to renewed (practical) \ninterest in semantic subtyping. In the context of XML documents, there is a natural generalization of \nDTDs where the structures in XML documents can be described using regular expression operations (such \nas *, ?, and |) and subtyping between two types becomes inclusion between the set of sequences that are \ndenoted by the regular expression types. Hosoya and Pierce .rst de.ned such a type system for XML [24] \nand their language, XDuce. Frisch, Castagna, and Benzaken [22] extended semantic subtyping to function \ntypes and propositional types, with type-test, but not re.nement types, resulting in the language CDuce \n[7]. CDuce allows expressions to be pattern-matched against types and statically detects if a pattern-matching \nexpression is non\u00adexhaustive or if a branch is unreachable. If this is the case a coun\u00adterexample XML \ndocument is generated that exhibits the problem. CDuce also issues warnings if empty types are detected. \nThese tasks are much simpler in CDuce than they are in our setting, since we additionally have to deal \nwith general re.nement types. Typed Scheme [42] makes use of type-test expressions, union types and notions \nof visible and latent predicates to type-check Scheme programs. It would be interesting to see if these \nidioms can be internalized in the Dminor type system using re.nements. PADS [19] develops a type theory \nfor ad hoc data formats such as system traces, together with a rich range of tools for learn\u00ading such \nformats and integrating into existing programming lan\u00adguages. The PADS type theory has re.nement types, \ndependent pairs, and intersection types, but not type-test. There is a syntactic notion of type equivalence, \nbut not subtyping. Dminor would be a useful language for programming transformations on data parsed using \nPADS, as our type system would enforce the constraints in PADS speci.cations, and hence guarantee statically \nthat trans\u00adformed data remains well-formed. Existing interfaces of PADS to C or to OCaml do not offer \nthis guarantee. 9. Conclusions We have described Dminor, a simple, yet .exible, functional lan\u00adguage \nfor de.ning data models and queries over these data models. The main novelty of Dminor is its especially \nrich type system. The combination of re.nement types and type-test appears to be new. On top of familiar \narithmetic constraints on types (analogous to the sort checked dynamically by other data modeling languages) \nwe have given examples of how this type system can, in addition, encode singleton, nullable, union, intersection, \nnegation, and alge\u00adbraic types, although without .rst-class functions. The other main contribution of \nthis paper is a technique to type\u00adcheck Dminor programs statically: we combine the use of a bidirec\u00adtional \ntype system with the use of an SMT solver to perform seman\u00adtic subtyping. (Other systems have either \ndevised special purpose algorithms for semantic subtyping, or used theorem provers only for re.nement \ntypes.) The design of our bidirectional type system to enable precise typing of programs appears novel. \nWe have im\u00adplemented our type system in F using the Z3 SMT solver. SMT solvers are now of suf.cient maturity \nthat they can realistically be thought of as a platform upon which many applications, including type \nsystems, may be built. Our type-checker, like all static analyzers, has the potential to generate false \nnegatives, that is, rejecting programs as type incor\u00adrect that are, in fact, type correct. As any SMT \nsolver is incomplete for the .rst-order theories that we are interested in, it is possible that the solver \nis unable to determine an answer to a logical state\u00adment. SAGE [20] avoids these problems by catching \nthese cases and inserting a cast so that the test is performed again at run-time. This has the pleasant \neffect of not penalizing the developer for any pos\u00adsible incompletenesses of the SMT solver. The techniques \nused in SAGE should apply to Dminor without any great dif.culty.  Finally, the implications of this \nwork go beyond the core cal\u00adculus Dminor. PADS, JSON, and M, for example, show the sig\u00adni.cance of programming \nlanguages for .rst-order data. Our work establishes the usefulness of combining re.nement types and type\u00adtest \nexpressions when programming with .rst-order data, and the viability of type-checking such programs with \nan SMT solver. Acknowledgments We thank Nikolaj Bj\u00f8rner for his invaluable help in using Z3. James Margetson \nhelped with F# programming issues. Paul Anderson, Ioannis Baltopoulos, Johannes Borgstr\u00a8 om, Nate Foster, \nTim Harris, and Thorsten Tarrach commented on a draft. Discussions with Mart\u00b4in Abadi, Cliff Jones, and \nBenjamin Pierce were useful, as were the comments of the anonymous re\u00adviewers. Cat.. alin Hrit\u00b8cu is \nsupported by a fellowship from Microsoft Research and the IMPRS. References [1] The Microsoft code name \nM Modeling Language Speci.cation Version 0.5. Microsoft Corporation, Oct. 2009. Preliminary implementation \navailable as part of the SQL Server Modeling CTP (November 2009). [2] A. Aiken and E. Wimmers. Type inclusion \nconstraints and type inference. In Proceedings of ICFP, 1993. [3] D. Aspinall and M. Hofmann. Dependent \ntypes. In Advanced Topics in Types and Programming Languages, chapter 2. MIT Press, 2005. [4] C. Barrett, \nM. Deters, A. Oliveras, and A. Stump. Design and results of the 3rd Annual SMT Competition. International \nJournal on Arti.cial Intelligence Tools, 17(4):569 606, 2008. [5] C. Barrett and C. Tinelli. CVC3. In \nProceedings of CAV, 2007. [6] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and S. Maffeis. Re.nement \ntypes for secure implementations. In Proceedings of CSF, 2008. [7] V. Benzaken, G. Castagna, and A. Frisch. \nCDuce: An XML-friendly general purpose language. In Proceedings of ICFP, 2003. [8] G. M. Bierman, A. \nD. Gordon, C. Hrit\u00b8cu, and D. Langworthy. Semantic subtyping with an SMT solver. Technical Report MSR \nTR 2010 99, Microsoft Research, July 2010. [9] P. Buneman, S. Naqvi, V. Tannen, and L. Wong. Principles \nof programming with complex objects and collection types. Theoretical Computer Science, 149(1):3 48, \n1995. [10] R. M. Burstall, D. B. MacQueen, and D. Sannella. HOPE: An experimental applicative language. \nIn LISP Conference, pages 136 143, 1980. [11] D. Crockford. The application/json media type for JavaScript \nObject Notation (JSON), July 2006. RFC 4627. [12] F. Damm. Subtyping with union types, intersection types \nand recursive types. In Proceedings of TACS, 1994. [13] L. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT \nsolver. In Proceedings of TACAS, 2008. [14] L. M. de Moura and N. Bj\u00f8rner. Generalized, ef.cient array \ndecision procedures. In FMCAD, 2009. [15] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: a theorem \nprover for program checking. J. ACM, 52(3):365 473, 2005. [16] J. Dun.eld and F. Pfenning. Tridirectional \ntypechecking. In Proceedings of POPL, pages 281 292, 2004. [17] B. Dutertre and L. de Moura. The YICES \nSMT solver. Available at http://yices.csl.sri.com/tool-paper.pdf, 2006. [18] R. Findler and M. Felleisen. \nContracts for higher-order functions. In ICFP, 2002. [19] K. Fisher, Y. Mandelbaum, and D. Walker. The \nnext 700 data description languages. In Proceedings of POPL, 2006. [20] C. Flanagan. Hybrid type checking. \nIn Proceedings of POPL, 2006. [21] T. Freeman and F. Pfenning. Re.nement types for ML. In Proceedings \nof PLDI, 1991. [22] A. Frisch, G. Castagna, and V. Benzaken. Semantic subtyping: Dealing set-theoretically \nwith function, union, intersection, and negation types. J. ACM, 55(4), 2008. [23] A. D. Gordon and A. \nJeffrey. Typing one-to-one and one-to-many correspondences in security protocols. In Proceedings of ISSS, \n2002. [24] H. Hosoya, J. Vouillon, and B. Pierce. Regular expression types for XML. In Proceedings of \nICFP, 2000. [25] C. Jones. Systematic software development using VDM. Prentice-Hall Englewood Cliffs, \nNJ, 1986. [26] K. Knowles, A. Tomb, J. Gronski, S. Freund, and C. Flanagan. SAGE: Uni.ed hybrid checking \nfor .rst-class types, general re.nement types and Dynamic. Technical report, UCSC, 2007. [27] A. Kopylov. \nDependent intersection: A new way of de.ning records in type theory. In LICS, pages 86 95. IEEE Computer \nSociety, 2003. [28] K. R. M. Leino and R. Monahan. Reasoning about comprehensions with .rst-order SMT \nsolvers. In Proceedings of SAC, 2009. [29] W. Lovas and F. Pfenning. A bidirectional re.nement type system \nfor LF. In Proceedings of LFMTP, 2007. [30] E. Meijer, B. Beckman, and G. Bierman. LINQ: Reconciling \nobjects, relations and XML in the .NET framework. In Proceedings of SIGMOD, 2007. [31] J. Meng and L. \nC. Paulson. Translating higher-order problems to .rst-order clauses. Journal of Automated Reasoning, \n40(1):35 60, 2008. [32] B. Meyer. Eiffel: the language. Prentice Hall, 1992. [33] B. Nordstr\u00a8om and K. \nPetersson. Types and speci.cations. In IFIP 83, 1983. [34] B. C. Pierce. Types and Programming Languages. \nMIT Press, 2002. [35] B. C. Pierce and D. N. Turner. Local type inference. In Proceedings of POPL, 1998. \n[36] S. Ranise and C. Tinelli. The SMT-LIB Standard: Version 1.2, 2006. [37] J. C. Reynolds. Design of \nthe programming language Forsythe. In Algol-Like Languages, chapter 8. Birkh\u00a8aser, 1996. [38] P. Rondon, \nM. Kawaguchi, and R. Jhala. Liquid types. In Proceedings of PLDI, 2008. [39] J. Rushby, S. Owre, and \nN. Shankar. Subtypes for speci.cations: Predicate subtyping in PVS. IEEE Transactions on Software Engineering, \n24(9):709 720, 1998. [40] V. Saraswat, N. Nystrom, J. Palsberg, and C. Grothoff. Constrained types for \nobject-oriented languages. In Proceedings of OOPSLA, 2008. [41] M. Sozeau. Subset coercions in Coq. In \nProceedings of TYPES, 2006. [42] S. Tobin-Hochstadt and M. Felleisen. Logical types for Scheme. In Proceedings \nof ICFP, 2010. [43] H. Xi and F. Pfenning. Dependent types in practical programming. In Proceedings of \nPOPL, 1999.    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>We study a first-order functional language with the novel combination of the ideas of refinement type (the subset of a type to satisfy a Boolean expression) and type-test (a Boolean expression testing whether a value belongs to a type). Our core calculus can express a rich variety of typing idioms; for example, intersection, union, negation, singleton, nullable, variant, and algebraic types are all derivable. We formulate a semantics in which expressions denote terms, and types are interpreted as first-order logic formulas. Subtyping is defined as valid implication between the semantics of types. The formulas are interpreted in a specific model that we axiomatize using standard first-order theories. On this basis, we present a novel type-checking algorithm able to eliminate many dynamic tests and to detect many errors statically. The key idea is to rely on an SMT solver to compute subtyping efficiently. Moreover, interpreting types as formulas allows us to call the SMT solver at run-time to compute instances of types.</p>", "authors": [{"name": "Gavin M. Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2338163", "email_address": "", "orcid_id": ""}, {"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "P2338164", "email_address": "", "orcid_id": ""}, {"name": "C&#259;t&#259;lin Hri&#355;cu", "author_profile_id": "81384610090", "affiliation": "Saarland University, Saarbrucken, Germany", "person_id": "P2338165", "email_address": "", "orcid_id": ""}, {"name": "David Langworthy", "author_profile_id": "81100060545", "affiliation": "Microsoft Corporation, Redmond, WA, USA", "person_id": "P2338166", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863560", "year": "2010", "article_id": "1863560", "conference": "ICFP", "title": "Semantic subtyping with an SMT solver", "url": "http://dl.acm.org/citation.cfm?id=1863560"}