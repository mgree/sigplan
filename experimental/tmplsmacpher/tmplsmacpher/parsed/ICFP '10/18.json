{"article_publication_date": "09-27-2010", "fulltext": "\n Matching Lenses: Alignment and View Update DaviM.J. Barbosa Julien Cretin NateFoster Michael Greenberg \nBenjaminC. Pierce \u00b4\u00b4 Ecole Polytechnique Ecole Polytechnique Princeton University University of Pennsylvania \nINRIA Abstract Bidirectional programming languages are a practical approach to the view update problem. \nPrograms in these languages, called lenses, de.ne both a view and an update policy i.e., every pro\u00adgramcanbereadasa \nfunctionmapping sourcestoviewsaswellas one mapping updated views back to updated sources. One thorny \nissue that has not received suf.cient attention in the design of bidirectional languages is alignment. \nIn general, to correctly propagate an update to a view, a lens needs to match up the pieces of the view \nwith the corresponding pieces of the underlying source, even after data has been inserted, deleted, or \nreordered.However,existing bidirectional languages either support only simple strategies that fail on \nmany examples of practical interest, or else propose speci.c strategies that are baked deeply into the \nunderlying theory. Weproposeageneral frameworkofmatching lenses that param\u00adeterizes lenses over arbitrary \nheuristics for calculating alignments. We enrich the types of lenses with chunks identifying reorder\u00adable \npieces of the source and view that should be re-aligned after an update, and we formulate behavioral \nlaws that capture essential constraints on the handlingof chunks.Wedevelopa core language of matching \nlenses for strings, together with a set of alignment combinators that implement a variety of alignment \nstrategies. Categories and Subject Descriptors D.3.2[Programming Lan\u00adguages]: Language Classi.cations \nSpecialized application lan\u00adguages General Terms Languages, Design, Theory Keywords Bidirectional languages, \nlenses, alignment, view up\u00addate problem, Boomerang 1. Introduction The view update problem isa classic \nissuein data management[6]: given a view and an update to the view, how do we .nd a new source that accurately \nre.ects the update? Recent work in the pro\u00adgramming languages community has made progress on this old \nproblem by developing new languages in which programs, called lenses, can be read both as view de.nitions \nand as update transla\u00adtors. This approach avoids code duplication and allows once-and\u00adfor-all proofs \nof round-tripping laws as corollaries of type sound\u00adness. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, \nUSA. Copyright c . 2010ACM 978-1-60558-794-3/10/09... $10.00 Formally, abasic lens l mapping between \nsets of sources S and views V with respect to complements C comprises functions: l.get . S . V l.res \n. S . C l.put . V . C . S l.create . V . S The get function mapsa sourcetoaview.The res ( residue ) func\u00adtion \nmaps a source to a complement, a structure that records (at least) the information not re.ected in the \nview i.e., the informa\u00adtion that needs to be remembered so that it can be mixed together with an updated \nview to produce an updated source. The other two functions handle updates: put takes a view and a complement \nand builds a new source, while create handles the special case where weneedtomapaviewtoa sourcebutdonothavea \ncomplement available.Itbuildsasourcefromaviewdirectly,.llinginanymiss- C ing information with defaults.We \nwrite S .. V for the set of all basic lenses between S and V with respect to C.1 Basic lenses must obeythe \nfollowing laws for every source s, view v, and complement c:2 l.get (l.put vc)= v (PUTGET) l.put (l.get \ns)(l.res s)= s (GETPUT) These laws are closely related to the conditions on update trans\u00adlators that \nhave been proposed in the database literature[1,6, 14]. PUTGET ensures that updates to the view are translated \nexactly i.e., that,givena view anda complement, the put func\u00adtion produces a source that get maps back \nto the very same view. GETPUT ensures a stability property for the source i.e., it re\u00adquires that the \nput function return the original source unmodi.ed whenever the update to the view is a no-op. It also \nguarantees that the complement computedby res records all of the source informa\u00adtion not re.ected in \nthe view. Lenseshave been studiedextensively[3,4,10,13,18 22,24] and appliedin areas asdiverse as user \ninterfaces[20], structure ed\u00aditors[15], con.guration management[18], software model trans\u00adformations[7, \n23, 26],pattern matching[25], data synchroniza\u00adtion[9], and security[12]. See[5]fora survey. However,one \nfundamental issue continues to hinder wide appli\u00adcation of these ideas: alignment. In general, the get \nfunction may discard some of the information in the source, so the put function needs to recombine parts \nof the view with parts of the complement to produce the updated source. When the source and view include \n1Readersfamiliar with lenses will see some small differences from previous formulations: the put function \nhas type V -C -S rather than V -S -S and we assume that every lens has a res function that extracts a \ncomplement fromasource.Torecover the original presentation, we can take the set C to be S and let res \nbe the identity function. The added precision thatwegetby breakingouta separatesetof complementswillbehelpfulin \nformulating the concepts we re working with here. 2Lenses also obey a CREATEGET law analogous to PUTGET. \nTo save space, we elide this law and all other laws involving create. Complete de.nitions canbe foundinthelongversion(viathe \nlast author sweb page).  ordered data (lists, strings, XML trees, etc.), doing this recombina\u00adtion correctly \nrequires matching up the pieces of the updated view with the corresponding pieces of the complement. \nConsider a sim\u00adpleexample where the sourceisaWiki page =Tour de France= The Tour is held in July... =Vuelta \na Spain= The Vuelta is held in September... and the view is a string containing just the section headings: \nTour de France Vuelta a Spain If we change the view by replacing Spain with Espana and adding a line \nfor the Giro, we would like the put function to take the new view Giro d Italia Tour de France Vuelta \na Espana togetherwiththe complementofthe original sourceandbuildanew source re.ecting the same updates. \nBut if the lens uses a simple positional strategy the only one available in most bidirectional languages \nthen the .rst line in the view will be matched up with the .rst section in the source, the second with \nthe second, and so on. The result willbea mangledWiki page =Giro d Italia= The Tour is held in July... \n=Tour de France= The Vuelta is held in September... =Vuelta a Espana= in which the paragraph for theTour \nappears underneath the heading for the Giro and the paragraph for theVuelta appears underneath the headingfortheTour \na recipefor tragedyinthecyclingworld! Existing bidirectional languages deal with the challenge of alignment \nin different ways. At the simple end of the spectrum, many languages ignore the issue entirely and use \na straightfor\u00adward positional strategy to match up pieces of the source and view[10, 19, 22, 24, 25]. \nThis works in some cases when the structures are unordered to begin with, or when theyare suf.ciently \nrigid that updates only need to modify information in-place, with\u00adout changing its position butfailsin \nmanyothers. Other languages deal with alignment by adopting an operation\u00adbased approach[15,20,21,26] \nthat is, rather than taking the state of the new view as an argument, the put function is told what up\u00addate \noperation was appliedtotheview.Workingwithexplicitoper\u00adations gives the put function detailed information \nabout the nature ofthe update appliedtotheview,which canhelpit calculateagood alignment. However, this \nsolution is not fully general. The update language recognized by put functions is .xed and usually sim\u00adple, \ntokeep the theory manageable so complicated updates have tobe brokendown into several smaller ones.Forexample, \nmany update languages support inserting and deleting itemsbut not mov\u00ading items from one location to \nanother. To move an item in the view,wehaveto deletethe itemand re-insertitatthenewlocation, causing \nthe hidden information associated with the item to be lost. Finally, a few systems align the pieces of \nthe source and view using keys.For example, in our own earlier proposal for dictionary lenses [3], the \nprogrammer identi.es the reorderablechunks in the sourceand speci.eshowto computeakeyforeach one.The \nput function useskeys rather than positionsto locatea chunkfor each piece of the view. This alignment \nstrategy works well when chunks havestablekeys,butitis also notacomplete solution.In particular, whenthe \nchunksdonothavea naturalkey(e.g., becausethey are (a) positional (b) best match  (c) best non-crossing \nmatch (d) actual operations Figure 1. Alignment strategies blocksof otherwise unstructuredtext)orwhenkeys \nthemselvescan be editedintheview(asintheWikiexampleabove),the simple alignment strategy baked into dictionary \nlenses can lead to mangled or lost data. Similar limitations apply to relational lenses [4],which use \nfunctional dependencies to identify keys that can be used to perform database operations like joinin \nan updatablefashion. Our goal is a completely generic mechanism that overcomes the limitations of all \nthese approaches and addresses the issue of alignment once and for all. To this end, we propose a new \nframework of matching lenses that separates the process of aligning the original and edited views from \nthe process of weaving together the original sourceandthe updatedviewtobuildan updated source. This separation \nyields a .exible framework that can be instantiated with arbitrary heuristic alignment strategies without \ncomplicating the basic theory. Figure1depicts some possible choices:(a) simple positional alignment; \n(b) best match alignment, which tries to match chunks without regard to ordering (good for set-like data \nwhere ordering is not critical); (c) a variant of best-match that only considers non-crossing matches, \nlike the longest common subsequence heuristic used by diff (this can lose hidden data if the actual edit \nis a move, but in return it can use local context to guide matching and will often perform better on \ndocument-like data);and(d)usingthe actualedit operations performedbythe user (assuming these are available) \nto calculate exactly the intended match. The matching lens framework can accommodate all of these, and \nmanyothers. At the level of the mathematical semantics, we enrich lens types with annotations specifying \nwhat constitutesareorderable chunk, and we add behavioral laws that capture the essential constraints \non the handling of chunks e.g., these stipulate that lenses must carry chunks in the source through to \nchunks in the view and vice versa, and theyguarantee that reorderings on the chunks in the view are translated \nto corresponding reorderings on the source. Operationally, we make the separation of concerns described \nabove explicit by splitting the complement into two pieces: a rigid complement that represents the source \ninformation that should be handled positionally and a resource that represents the information extracted \nfrom chunks.To supplya lens witha precise alignment directive, we simply rearrange the resource according \nto the direc\u00adtive and obtain a pre-aligned resource in which each piece of the source matches up with \nthe speci.ed piece of the view. Finally, we instantiate this abstract framework with primitive matching \nlenses and combinators for string data.3 We give coer\u00ad 3We work concretely with strings, rather than \nricher structures like trees or graphs, but we use regular expression types to overlay tree structures \n cions that convert basic lenses to matching lenses and vice versa, and we show how to interpret each \nof the regular operators (union, concatenation, and Kleene star) as well as the composition opera\u00adtor \non matching lenses. Finally, we describe primitives for speci\u00adfying, combining, and tuning alignment \nstrategies using notions of species, tags, keys, and thresholds. Our contributions can be summarized \nas follows: 1. We de.ne a new semantic space of matching lenses that en\u00adriches the types of lenses with \nchunks and adds behavioral laws ensuring that chunks are handled correctly (Section3). 2. We de.ne a \nsimple syntax for matching lenses over string data (Section4),andweprove(inthelongversionofthe paper)that \neach primitive is well behaved at its speci.ed type. 3. We develop several ways of calculating alignments, \nusing no\u00adtionsof species , tags , keys, and thresholds (Section5). Alignments are represented as concrete \ndata structures, making a clean interface between the core lens behaviors described in Sections3and4and \nthese alignment-generating algorithms.  4.Wesketchextensionstothe framework (Section6)and discuss an \nimplementation based on Boomerang[11](Section7). Related and futurework are discussedin Sections8and9. \n2. Example Let spushtheWikiexamplealittle further,topreviewthe essential ingredientsof our solution. \nFirst, hereisaBoomerang program that implements the originalWiki lens with positional alignment: let \nNONSPECIAL : regexp = [^=\\n] let HEADING : regexp = [^=\\n ] . NONSPECIAL* let LINES : regexp = (NONSPECIAL+ \n. \"\\n\")* let PARAGRAPHS : regexp = LINES . (\"\\n\" . LINES)* let section : lens = \"=\"<->\"\" . copy HEADING \n. (\"=\\n\" . PARAGRAPHS)<->\"\\n\" let wiki : lens = section* The .rst few lines de.ne regular expressions \ndescribing non\u00adspecial characters (everything except = and \\n ), section head\u00adings, lines of text, and \nparagraphs. The section lens processes one section of the Wiki source. The copy E lens recognizes a source \nstring matching the regular expression E and copies it (in both directions). The get directionofthe replaceby \nconstant lens E <-> u recognizes a source string matching E but adds the .xed string u to the view; the \nput direction recognizes u and restores the original source from the complement. The concatenation operator \n. uses one sublens to process the beginning of its input and the other for the end. The wiki lens, de.ned \nusing the Kleene star operator *, iterates the section lens to handle a list of sections. ThisversionoftheWikilens \nusesasimple positional alignment strategy for matching up paragraphs in the source with lines in the \nview, leading to the unfortunate behavior described in the introduc\u00adtion. Here is a better version, written \nusing the features developed in this paper, that uses section headings to locate the corresponding paragraphs \nfrom the source: let section : lens = \"=\"<->\"\" . key (copy HEADING) . (\"=\\n\" . PARAGRAPHS)<->\"\\n\" onto \nstrings. Indeed, our types are already expressive enough to describe arbitrary XML structures with non-recursive \nschemas. let wiki : lens = <best:section>* We ve made two changes. First, in the de.nition of thewiki \nlens, we have indicated that each section in the source should be treated as a reorderable chunk by enclosing \nthe section lens in angle brackets. Second, we have speci.ed the policythat should be used to align chunks \nusing the annotations key and best. The key annotation indicates the portions of each chunk that should \nbe taken into account when computing an alignment. The alignment species best selects the overall heuristic \nto use for computing a correspondence between chunks: one that minimizes the sum of the edit distances \nbetween thekeysof matched chunks. The point of this example is that we can provide programmers with simple, \ncompositional primitives that allow them to specify rich alignment strategies directly in a lens program. \nIn particular, if we put back the updated view Giro d Italia Tour de France Vuelta a Espana with the \ncomplement from the original source, we obtain a new source in which paragraphs are restored to the appropriate \nsections: =Giro d Italia= =Tour de France= The Tour is held in July... =Vuelta a Espana= The Vuelta is \nheld in September... Readersfamiliar with dictionary lenses[3]will recall similar constructs for specifying \nchunks and alignment policies. Indeed, on the surface, matching lenses are designed to look like a straight\u00adforward \ngeneralization of dictionary lenses. Under the hood, the criticaldifferencethatmakesthe generalizationworkisthat \nmatch\u00ading lenses make all alignment decisions in a separate phase that happens before the outermost put \nfunction is called, whereas dic\u00adtionary lenses interleave alignment decisions with the operation of put \nfunctions. This untangling of mechanisms has several bene.\u00adcial effects. First, it modularizes the framework, \nallowing us to use manydifferent alignment strategies instead of just one. Second, it allows us to use \nglobal alignment strategies that optimize some distance metricoverthe whole structure;in particular,we \ncan relax the assumption thatkeys are never edited,a major practical restric\u00adtion of dictionary lenses. \nThird, it permits an elegant treatment of the composition operator(see Section4), whichwehave foundim\u00adportant \nin practical bidirectional programming but which doesn t interact nicely with dictionary lenses.Fourth,it \nclari.es the under\u00adlying theory by treating alignment algorithms, which are typically complex and heuristic, \nseparately from the core language, which remains simple and generic. And .nally, it avoids some arbitrary \nchoices forced by the locality of alignment decisions in dictionary lenses e.g., the left bias of concatenation \nand Kleene star. 3. Semantics Webegin our technicaldevelopmentbyde.ningthe semantic space of matching \nlenses, which areorganized aroundatwo-tier architec\u00adture:a top-level matching lens processes the information \noutside of chunks while a subordinate basic lens processes the chunks them\u00adselves.To simplify the presentation, \nwe assumein this section that chunks only appear at the top level, that the same basic lens is used to \nprocess every chunk, and that lenses themselves do not reorder chunks.We relax eachof these assumptionsin \nSection6. Consideranexamplethat illustrateshow matching lenseswork: let k : lens = key (copy [A-Z]) . \n[a-z]<->\"\" let l : lens = <best:k> . (copy \",\" . <best:k>)*  The basic lens k copies an upper-case letter \nfrom source to view and deletes a lower-case letter, while the matching lens l iterates k overa non-emptylistof \ncomma-separated chunks.Thebehaviorof l s get component is straightforward e.g., it maps Xx,Yy,Zz to X,Y,Z \n. Its put function is more interesting: it restores the lower\u00adcase letters from source chunks by matching \nupper-case letters in the old and new views. For example, if we reorder the view and insert W in the \nmiddle, then put behaves as follows: l.put \"Z,Y,W,X\" into \"Xx,Yy,Zz\" = \"Zz,Yy,Wa,Xx\" Theevaluationof \nl.put proceeds in several steps. First, it uses l.res to extract a complement from the source. In a matching \nlens, the complement is represented as two structures: a rigid complement c that contains the information \noutside of chunks and a resource r that contains the information within chunks. Jay s shapely types , \nwhich require that it be possible to divide structures into a shape and a list of data items with the \narity of the shape equal to the number of items in the list, capture the same concept[16]. Chunk Compatibility \nTo ensure that chunks can be freely re\u00adordered, we require that the sets of sources and views must be \nclosed under the operation of replacing chunks by other chunks. Formally, we say that a set of structures \nwith chunks U is chunk compatible with an ordinary set of structures U ' if and only if the chunks of \nevery structure in U belong to U ' i.e., for every u in U and n in locations(u) we have u[n] in U ', \nand  membership in U is preserved when we replace arbitrary  chunks with elements of U ' i.e., for \nevery u in U, n in '' ' locations(u), and in U we have u[n:=u ] in U. c =(0, [( , , 0), ( , , 0)]) r \n= ...... 8< : 1 .. Xx 2 .. Yy 3 .. Zz The rigid complement records the position of each chunk and the \n..=...;. 9 u Resources We represent resources using .nite maps from loca\u00ad tions to basic lens complements. \nThis makes it easy to re-align a resource we simply apply a (possibly lossy) reordering to the map.We \nwrite commas separating the chunks; its structure (a pair whose second {||} for the totally unde.ned \nmap, component is a list of pairs) comes from the structure of the lens l. The resource records a mapping \nfrom chunk locations to chunk contents i.e., r(i) contains the contents of the ith chunk in s, while \nc has a 0 at the corresponding location. Next, the put function invokes an alignment function to compute \na correspondence g between the locations of chunks in the new and old views, and composes this correspondence \nwith the resource r to obtain a pre-aligned resource (r . g): = ...... 8< : 1 .. 3 2 .. 2 4 .. 1 ..=...;. \n9 (r . g)= ...... 8< : 1 .. Zz 2 .. Yy 4 .. Xx ..=...;. 9 {|n .. c|} for the singleton map that associates \nthe location n to the basic lens complement c and is otherwise unde.ned,  r(n) for the basic lens complement \nthat the .nite map r asso\u00adciates to n,  dom(r) for the domain of the .nite map r,  |r| for the largest \nelement of {0}. dom(r),  (r1 ++ r2) for the .nite map that behaves like the .nite map  r1 on locations \nin dom(r1) and like the .nite map r2 with ( locations shifted up by |r1| otherwise, r1(n) if n =|r1|otherwise, \n(r1 ++ r2)(n) 6 r2(n -|r1|) Finally, it runs l.put on the updated view, the rigid complement, and and \nthe pre-aligned resource. The overall effect is that each lower\u00adcase letter is restored to the chunk \ncontaining the appropriate upper\u00ad {|N .. C|} for the set of all .nite maps from locations to elements \nof C, where C is a set of basic lens complements. case letter. Notice that the third chunk, W is created \nwith the default lower-case letter a because the pre-aligned resource (r . g) is unde.ned on location \n3. 3.1 Preliminaries Before we can de.ne matching lenses formally, we need some notation for chunks and \nresources. Structures with Chunks The semantic space of matching lenses is generic the source and view \ncan be arbitrary but we require that structures come equipped with a notion of what constitutes a chunk. \nWhen u isa(source or view)structure with chunks, we write chunks(u) for the list of chunks in u,  |u| \nfor the length of chunks(u),  locations(u) for the set {1, ..., |u|} of locations of chunks in u,  \nu[n] for the nth chunk in u, where n is in locations(u),  u[n:=v] for the structure obtained by setting \nthe nth chunk in u to v, and  skel(u) for the skeleton structure obtained by replacing each chunk in \nu with 0, a special element not appearing in normal structures.  Notice that the number of chunks |u| \nis equal to the number of occurrences of 0 in skel(u). Examples of such structures abound, including \nconventional datatypes such as trees, lists, matrices, etc.  3.2 Matching Lenses Let S and V be sets \nof structures with chunks, C a set of structures Ck ( rigid complements ), and k a basic lens in Sk .. \nVk such that S is chunk compatible with Sk and V is chunk compatible with Vk. Also let align be a function \nthat takes the list of chunks for the new and old views and computes a correspondence between them, represented \nformally as a partial injective function from new locations to old locations. A matching lens l on S, \nC, k, and V comprises four functions l.get . S . V l.res . S . C \u00d7 {|N .. Ck|} l.put . V . C \u00d7 {|N .. \nCk|} . S l.create . V . {|N .. Ck|} . S obeying the laws in Figure 2 (to be explained below). We write \nC,k S .. V for the set of all matching lenses between S and V with respect to C and k. The get function \nhas the same type as in basic lenses. The put function takes a view together with a rigid complement \nand a resource as arguments, while the res function extracts a rigid complement and a resource from a \nsource. The create function takesjustaviewandaresource;thismakesit possiblefor matching lenses to restore \ninformation to chunks whose rigid complement is newly created e.g., the last chunk in the example from \nthe  n . (locations(v) n dom(r)) l.get (l.put v (c, r)) = v (PUTGET) (CHUNKPUT) (l.put v (c, r))[n]= \nk.put v[n](r(n)) l.put (l.get s)(l.res s)= s (GETPUT) n . (locations(v) \\ dom(r)) (NOCHUNKPUT) locations(s)= \nlocations(l.get s) (GETCHUNKS) (l.put v (c, r))[n]= k.create v[n] c, r = l.res s skel(v)= skel(v ' ) \n(RESCHUNKS) (SKELPUT) locations(s) = dom(r) '' skel(l.put v (c, r)) = skel(l.put v (c, r )) Figure \n2. Matching lens laws beginning of this section, which contains X .To createa source from scratch, we \ninvoke create with the empty resource {||}. ThePUTGET andGETPUT lawsin Figure2 express the same fundamental \nconditions as the corresponding basic lens laws; the remaining laws capture essential constraints on \nthe handling of chunks. The GETCHUNKS law stipulates that the get function must carry each chunk in the \nsource to a chunk in the view; the RESCHUNKS law imposes an analogous constraint on the resource generated \nby res. (We do not state PUTCHUNKS as a law because it can be derived from the other laws.) TheCHUNKPUT \nandNOCHUNKPUT laws are the most impor\u00adtant. They ensure that the put function uses its resource argument \ncorrectly. TheC HUNKPUT law stipulates that the nth chunk in the source producedby put must be identical \nto the structure produced byapplyingk.put to the nth chunk in the view and the complement associated \nto n in the resource (if the resource contains a comple\u00adment for n).For instance,in theexample above,it \nstipulates that the second chunk in the source obtained by putting back the up\u00addated view Z,Y,W,X using \nthe pre-aligned resource (r . g) must be equal to the result obtained by applying k.put to Z,Y,W,X [2] \nand (r . g)(2) i.e., to Y and Yy . The NOCHUNKPUT law is similar,but handles the case where the resource \ndoes not containa complement for n.Forexample,it stipulatesthatthe third chunkin the sourcemustbeequaltotheresult \nobtainedbyapplying k.create to Z,Y,W,X [3] i.e., W . The last law, SKELPUT, states that the skeleton \nof the sources produced by put must not depend on anyof the chunks in the view or complements in the \nresource. Among other things, this law is critical for ensuring that matching lenses translate reorderings \non the view to reorderings on the source. Compared to the basic lens laws, these laws have a somewhat \nlow-level and operational feel, spelling out the handling of chunks and resources in quite a bit of detail. \nOther axiomatizations of matching lenses are possible (see Section9).We chose these laws because theyexpress \nconditions that are readily veri.ed using sim\u00adple, local checks. In addition, we can use them to derive \nhigher\u00adlevel properties. For instance, we can show that the put function translates reorderings on the \nchunks in the view to corresponding reorderings on the chunks in the source. We write Perms(u) for the \nset of permutations of chunks in u and Oq u for the structure obtained by reordering the chunks of u \naccording to a permutation q. The next lemma follows directly from the matching lens laws: C,k 3.1 Lemma \n[ReorderPut]: Let l be a matching lens in S .. V . For every view v in V , rigid complement c in C, resource \nr in {|N .. k.C|}, and permutation q in Perms(v), we have Oq (l.put v (c, r)) = l.put (Oq v)(c, r . q \n-1). Lowering To complete the discussion of semantics, we de.ne a coercion .\u00b7. (pronounced lower ) that \ntakes a matching lens C,k l in S .. V and packages it up with the interface of a basic S lens in S .. \nV . This coercion performs the steps needed to actually use the put component of a matching lens, as \ndescribed in the example at the start of this section. It turns out that we only need a single constraint \non the alignment function align to ensure well-behavedness of the lens resulting from .\u00b7.: when presented \nwith identical lists of chunks, it must yield the identity alignment. The typing rule in the top box \ncan be read as a lemma asserting C,k that, if l is a matching lens in S .. V , then .l. is a basic lens \nin S S .. V .Aproof appears in the long version of this paper. The bottom box de.nes the components of \n.l.. The get function is just l.get. The res function uses the whole source as the basic lens complement. \nThe put function takesa (possibly updated) view v and a basic lens complement s as arguments. It .rst \nuses l.res to calculate a rigid complement c and a resource r from s, and then uses align to calculate \na correspondence g between the locations of chunks in the updated view v and chunks in the original view \nl.get s. Next, it composes r and g as functions, which has the effect of rearranging the complements \nin the resource r according to the alignment g. To .nish the job, the put function passes v, c, and (r \n. g) to l.put, which produces the new source. The basic create function invokes l.create with the view \nand the empty resource. 4. Matching Lenses for Strings Having de.ned the semantic space of matching lenses, \nwe nowturn our attention to syntax. This section de.nes a collection of match\u00ading lens primitives for \nstrings, based on the basic and dictionary lenses for strings that we have studied previously[3, 13]. \n 4.1 Notation Let . be a .nite alphabet (e.g., ASCII). The . symbol denotes the empty string and (u\u00b7v) \ndenotes the concatenation of strings u and v.A language L is a subset of .*;concatenation is lifted to \nlanguages in the usual way: L1\u00b7L2 6 {u\u00b7v | u . L1 and v . L2}. The iterationofalanguage L is L * 6 S8 \nLn,whereLn denotes n=0 the n-fold concatenation of L with itself. Many of our de.nitions require that \nevery string in the con\u00adcatenation of two languages have a unique factorization into smaller strings \nbelonging to the languages being concatenated. Two languagesL1 and L2 are unambiguously concatenable, \nwrit\u00adten L1\u00b7 !L2,provided that, for all stringsu1 and v1 in L1 and u2 and v2 in L2, if (u1\u00b7u2)=(v1\u00b7v2) \nthen u1 = v1 and u2 = v2. Sim\u00adilarly, a language L is unambiguously iterable, written L!*, if for all \nstrings u1 to um and v1 to vn in L, if (u1 \u00b7\u00b7\u00b7 um)=(v1 \u00b7\u00b7\u00b7 vn) then m = n and ui = vi for i from 1 to \nn.  The set of regular expressions is generated by the grammar R ::= \u00d8| u | R\u00b7R | R|R | R* where u ranges \nover strings. The denotation [ E] of a regular ex\u00adpression E is a regular language. Regular languages \nare closed under the boolean operators and have many decidable properties including emptiness, inclusion, \nand equivalence. It is also decid\u00adable whether two regular languages are unambiguously concaten\u00adable \nand whether a single regular language is unambiguously iter\u00adable (see[2, Prop. 4.1.3]).  4.2 Types Thetypesofourprimitivesaregivenbyregular \nlanguagesofstrings decorated with annotations that indicate the locations of chunks. Let . and . be fresh \nsymbols not in . The set of chunk\u00adannotated regular expressions is generatedby the grammar: A ::= R | \n.R. | A|A | A\u00b7A | A* Note that every ordinary regular expression is also a chunk\u00adannotated regular expression \nand that chunks are not nested. The denotation [ A] of a chunk-annotated regular expression A is a lan\u00adguage \nof chunk-annotated strings i.e., a set of strings over the extended alphabet .{ . , . } in which occurrences \nof . and . are balancedandnot nested.Weusethese annotationsto determine the number |u| of chunks in u, \nthe chunk u[n] at n in u, and so on. For example, ifu is .A1..B2..C3. , then |u| is 3, u[2] is B2 , and \nu[2:= Z9 ] is .A1..Z9..C3. . Although our primitives formally manipulate chunk-annotated strings, we \ncan also use them to process ordinary strings indeed, this is how we most often use them! Let .\u00b7. be \nthe function that maps chunk-annotated strings to ordinary strings (by removing . and . characters and \nmapping every other character to it\u00adself), and lift .\u00b7. to languagesin theobviousway.We say thata language \nof chunk-annotated strings L is chunk unambiguous if and only if L is isomorphic to .L.. Not all languages \nare chunk unambiguous e.g., in { .a.b , a.b. } the ordinary string ab corresponds to two different chunk-annotated \nstrings but for lan\u00adguages that are, we can get back and forth between ordinary strings and chunk-annotated \nstrings unambiguously. Using the isomor\u00adphism between a chunk-unambiguous language and its erasure, we \ncan view our matching lens primitives as acting either on chunk\u00adannotated strings or on ordinary strings.To \nusea componentofa lens to process an ordinary string, we .rst parse the input string, then apply the \nlens function to the resulting chunk-annotated string, and .nally erase the annotations in the chunk-annotated \noutput string. Moreover, for languages given by chunk-annotated regular expressions, implementing parse \nand erase functions is straightfor\u00adward. In each of the typing rules below,we will be careful to ensure \nthat the source and view types are chunk unambiguous.  4.3 Primitives The .rst two primitives convert \nbasic lenses into matching lenses. Lift It should be clear that matching lenses generalize basic lenses. \nThe lift operator witnesses thisfact, and makes it possible to use basic lenses like copy and <-> as \nmatching lenses. As the source and view are ordinary strings, the lifted lens does not have chunks so \nit satis.es the new matching lens laws vacuously.  Note that the basic lens k ' mentioned in the type \nof bk is arbitrary. Match Another way to lift a basic lens is to place it in a chunk:  The lens .k. \n(pronounced match k )is the essential matching lens. It uses the basic lens k to process strings in both \ndirections, treating the entire source as a reorderable chunk. The get component of .k. simply passes \noffcontrol to the basic lens k. The res function takes a source s and produces 0 as the rigid complement \nand {|1 .. k.res s|} as the resource. The put function accesses the complement through its resource argument: \nit invokes k.put on the view and r(1) if r is de.ned on 1 and k.create on the view otherwise. The create \nfunction is identical. In examples, we often specify the global align parameter as an argument to match \ne.g., we write <best:k> to indicate that chunks should be aligned using the best heuristic. The typechecker \nveri.es that all occurrences of match use the same heuristic see Section5. Concatenation These regular \noperators represent a core lan\u00adguage that can be used to express manyuseful transformations on strings. \nConcatenation is simplest: The get function splits the source into s1 and s2, applies the get functions \nof l1 and l2 to these strings, and concatenates the results. We writes1\u00b7s2 in patterns to indicate that \ns1 and s2 are strings in S1 and S2 that concatenate to s1\u00b7s2. The typing rule requires that the concatenation \nof .S1. and .S2. be unambiguous, so s1 and s2 are unique. Also, as S1 and S2 are chunk unambiguous, this \ncondition also ensures that S1\u00b7S2 is chunk unambiguous.  The res function applies l1.res to s1 and l2.res \nto s2, yielding rigid complements c1 and c2 and resources r1 and r2. It merges the rigid complements \nintoapair (c1,c2) and the resources intoa.nite map (r1 ++ r2). As the same basic lens k is mentioned \nin the types of both l1 and l2, the resources r1, r2, and (r1 ++ r2) are all .nite maps in {|N .. Ck|}.4 \nThis ensures that we can freely reorder the resource and pass arbitrary portions of it to l1 and l2. \nThe put function splits each of the view, rigid complement, and resource in two, applies the put functions \nof l1 and l2 to the corresponding pieces of each, and concatenates the results. It splits the resource \nusing split, which yields a resource that behaves like r on locations less than or equal to |v1| and \none that behaves like r shifted down by |v1| on locations greater than |v1|.Formally, split is de.ned \nas follows: The get and res components of the Kleene star lens are straight\u00adforward generalizations of \nthe corresponding components of the concatenation lens. The put function, however is different. Because \nit must be a total function, it needs to handle situations where the number of substrings of the view \nis different than the num\u00adber of items in the list of rigid complements i.e., chunks have been added \nto or removed from the view. When there are more rigid complements than substrings of the view, the lens \nsimply dis\u00adcards the extra complements. When there are more substrings than rigid complements, it processes \nthe extra substrings using l.create. This is the reason that create takes a resource as an argument the \nresource often has entries for the extra chunks (especially if the Kleene star lens appears embedded \nin an instance of the lower combinator,which pre-aligns the resource against the updated view .. before \nit invokes put). r(m) if m = n and m . dom(r) unde.ned otherwise Union The .nal regular operator is union: \nr(m + n) if (m + n) . dom(r) (p1(split(n, r)))(m)= (p2(split(n, r)))(m)= unde.ned otherwise. The union \nlens behaves like a bidirectional conditional operator. Splitting resources in this way ensures that \na complement aligned with a chunk in the view remains aligned with the same chunk in the corresponding \nsubstringoftheview.TheproofofGETPUTuses the equality split(|r1|,r1 ++ r2)=(r1,r2). The typing rule requires \nthat l1 and l2 be de.ned over the same basic lens k, which ensures that the resource (r1 ++ r2) has a \nuniform type. It is tempting to relax this condition and al\u00ad low l1 and l2 to be de.ned over different \nbasic lenses, as long as those lenses have compatible complements. Unfortunately, this would require \naccepting weaker properties.Forexample, consider .k1.\u00b7.k2., where k1 and k2 are de.ned as follows: () \nk1 6 (a . b | b . a | c . c) .{a, b, c}.= k2 6 (a . b | b . c | c . a) .{a, b, c}.= . {a, b, c} . {a, \nb, c}  () Invoking put on bc yields ab asaresult.5Swappingthe chunks of bc gives cb . According to Lemma \n3.1, the put function should produce ba i.e., the string obtained by swapping the chunks of ab . But \nthis is not what happens: invoking put on cb yields ca . Thus, although it is tempting to allow matching \nlenses to use different lenses to process chunks, we do not allow it. The get function selects l1.get \nor l2.get by testing whether the source string belongs to .S1. or .S2.. The typing rule requiresKleene \nStar The Kleene star operator iterates a lens: that these types be disjoint, so this choice is deterministic. \nThe res function also selects l1.res or l2.res bytesting the source string. It places the resulting rigid \ncomplement in a tagged sum, producing Inl(c) if the source belongs to .S1. and Inr(c) if it belongs to \n.S2.. It does not tag the resource because l1 and l2 are de.ned over the same basic lens k for chunks, \nwe can safely pass a resource computed by l1.res to l2.put and vice versa. The put function is slightly \nmore complicated, because the typ\u00ading rule allows the view types to overlap. It tries to select one of \nl1.put or l2.put using the view and uses the rigid complement dis\u00adambiguate cases where the view belongs \nto both .V1. and .V2.. The create function is similar. Note that because put isa total func\u00adtion, it \nneeds to handle cases where the view belongs to (.V1.\\ .V2.) but the complement is of the form Inr(c). \nTo satisfy the PUTGET law, it must invoke one of l1 s component functions,but it cannot invoke l1.put \nbecause the rigid complement c does not necessarily belong to C1. It discards c and uses l1.create instead. \nThe side condition (.V1.n.V2.) ..V1 nV2. in the typing rule for union ensures that (V1 . V2) is chunk \nunambiguous i.e., that strings in the intersection (V1 n V2) have unique parses. It rules out languages \nof chunk-annotated strings such as { .a.b , a.b. }. 4Recall that Ck is the set of basic lens complements \nfor k. 5As k1 and k2 are bijective , the rigid complement and resource do not Composition The composition \noperator puts two matching affect the evaluation of put. lenses in sequence:  This operator is especially \ninteresting as a matching lens because it handles alignment in two sequential phases of computation. \nCom\u00adposition provides strong evidence that our design for matching lenses is robust. Unlike the composition \noperator de.ned in our previous work on dictionary lenses, whose behavior was often un\u00adpredictable,the \nconstraintsimposedbythe matchinglenslawslead naturally to a de.nition of an operator whose behavior is \nintuitive. The get function applies l1.get and l2.get in sequence. The res function applies l1.res to \nthe source s, yieldinga rigid complement c1 and resource r1, and l2.res to l1.get s, yielding c2 and \nr2. It merges the rigid complements intoa pair .c1,c2. and combines the resources by zipping them together, \nwhere the zip function takes a C1-resource and a C2-resource to a C1 . C2-resource as follows:6 . .r1(m),r2(m). \nif m . dom(r1) n dom(r2) (zip r1 r2)(m)= unde.ned otherwise Note that we have the following equalities \ndom(r1)= locations(s) byRESCHUNKS for l1 = locations(l.get s) byGETCHUNKS for l1 = dom(r2) byRESCHUNKS \nfor l2 so zip r1 r2 is de.ned on all locations in dom(r1) and dom(r2). The put function unzips the resource \nand applies l2.put and l1.put in that order. The unzip function is de.ned by ( ci if r(m)= .c1,c2. (pi(unzip \nr))(m)= unde.ned otherwise where i .{1, 2}. Because the zipped resource represents the resources generated \nby l1 and l2 together, rearranging the resource has the effect of pre-aligning the resources for both \nphases of computation.To illustrate, consider the followingexample: letk1: lens = copy [A-Z]. copy [a-z] \n. [0-9]<->\"\" let k2 : lens = [A-Z]<->\"\" . key (copy [a-z]) let l : lens = <best:k1> . (copy \",\" . <best:k1>)* \n; <best:k2> . (copy \",\" . <best:k2>)* The get functiontakesanon-emptylistof comma-separated chunks containing \nan upper-case letter, a lower-case letter, and a number, and deletes the number in the .rst phase and \nthe upper-case letter in the second phase: l.get \"Aa1,Bb2,Cc3\" = \"a,b,c\" The resource produced by res \nrepresents the upper-case letter and number together, so even though the alignment is only calculated \nagainst the .nal view, the effect after applying the alignment to 6The angle brackets and type operator \n0 distinguish these pairs from the ordinary pairs generated as rigid complements for the concatenation \nlens. the resource is that the put function restores information from both sequential phases to the appropriate \nchunk: l.put \"b,a\" into \"Aa1,Bb2,Cc3\" = \"Bb2,Aa1\" The typing rule for the composition lens requires that \nthe view type of l1 be identical to the source type of l2. In particular, it re\u00adquires that the chunks \nin these types must be identical. Intuitively, this makes sense the only way that the put function can \nreason\u00adably translate alignments on the view back through both phases of computation to the source is \nif the chunks in the types of each lens agree. However, in some situations, it is useful to compose lenses \nthat have identical erased typesbut different notions of chunks e.g., one lens does not have anychunks, \nwhile the other lens does have chunks. To do this asymmetric form of composition, we can convert both \nlenses to basic lenses using .\u00b7., which forgets the chunks in the source and view, and compose them as \nbasic lenses. 5. Alignments So far, our discussion has focused on the core mechanisms of matching lenses \nextending basic lenses with chunks and devel\u00adoping an interface for supplying lenses with explicit alignment \ndi\u00adrectives. But we have not said where these alignment directives come from! In this section, we describe \nthe primitives for speci\u00adfying alignments implemented in our extension of the Boomerang language. We \ndescribe three alignment species and show how alignments can be tuned using keys and thresholds . Because \nalignment is a fundamentally heuristic operation, the choice of an alignment function depends intimately \non the details of the applica\u00adtion at hand. One of the main strengths of the matching lens frame\u00adwork \nis its .exibility. Matching lenses can be instantiated with arbi\u00adtrary alignment functions since well-behavedness \ndoes not hinge on anyspecial properties of the function used to align chunks: the only property we require \nis that it returns the identity alignment when its arguments are identical. Thus, the functions described \nin this sec\u00adtion are not exhaustive; it would be easy to add new primitives as needed. Species Boomerang \ncurrently supports three different alignment species , depicted graphicallyin Figure1(a-c): Positional: \nThe alignment matches chunks by position. If one list containsmorechunks,theextrasattheendofthelongerlist \nare not matched with anychunk in the other list.  Best match: The alignment minimizes the sum of the \ntotal edit distances between matched chunks and the lengths of un\u00admatched chunks.  Best non-crossing \nmatch: The alignment minimizes the same heuristic asin best match,but only considers alignmentswith non-crossing \nedges. This heuristic can be computed ef.\u00adciently using a variant of the standard algorithm for computing \nlongest common subsequence.  For example: let l : lens = key [A-Z] . [0-9]<->\"\" <pos:l>*.put \"BCA\" into \n\"A1B2C3\" = \"B1C2A3\" <best:l>*.put \"BCA\" into \"A1B2C3\" = \"B2C3A1\" <nonx:l>*.put \"BCA\" into \"A1B2C3\" = \n\"B2C3A0\" When we convert a matching lens to a basic lens using the lower coercion, .\u00b7., the align function \nis instantiated using the species indicated in the match combinator. The Boomerang system checks that \nthe same annotation is used on every instance of the match combinator e.g., it disallows (<pos:l> . <nonx:l>), \nwhich uses two different species.  Keys Typically we only want to consider a part of each chunk when \nwe compute an alignment. Boomerang includes two primi\u00adtives, key and nokey, that provide a way for programmers \nto con\u00adtrol the portion of each chunk that is used to compute an alignment. These combinatorstakea basiclensasanargumentbuttheydonot \nchange the get/put behavior of the lens theyenclose. Instead, they add extra annotations to the view \ntype that we use to read off the keyforchunks(justasweuse annotationsonregularexpressionsto read off \nthe locations of chunks). When the align function com\u00adputes an alignment for twolists of chunks, it .rst \nuses the viewtype toextract the regionsof each chunk marked askeys and then com\u00adputes an alignment.To \nillustrate the useofkeys, considera simple example: let k :lens = copy [A-Z] . copy [a-z] . [0-9]<->\"\" \nlet l : lens = <best:k>* l.put \"CcBbAa\" into \"Aa1Bb2Cc3\" = \"Cc1Bb2Aa3\" This program uses the best species,but \nbehaves positionally be\u00adcause the view type does not contain anykeyannotations i.e., the keyofevery chunkis \nthe empty string.By addingakeyannotation we obtain a lens whose put function matches up chunks using \nthe upper-case letters in the view: let k :lens = key(copy [A-Z]) . copy [a-z] . [0-9]<->\"\" let l : \nlens = <best:k>* l.put \"CcBbAa\" into \"Aa1Bb2Cc3\" = \"Cc3Bb2Aa1\" Note that lower-case letters, which are \nnot marked as a part of the key, do not affect the alignment: l.put \"CaBbAc\" into \"Aa1Bb2Cc3\" = \"Ca3Bb2Ac1\" \nThe nokey primitive is dual to key it removes thekeyannotation ontheviewtype.Wecan writeanequivalentversionoftheprevious \nlens using nokey: let k : lens = key(copy [A-Z] . nokey(copy [a-z]) . [0-9]<->\"\") These simple mechanisms \nfor indicating keys suf.ce for many practical examples, but they could be extended in several ways. Forexample,wecouldprovide \nprogrammerswithwaysto generate unique keys or build keys structured as tuples or records (rather than \n.attening the portion of each chunk marked as a key into a string).Weplantoexplore these ideasin futurework. \nThresholds The best and nonx species compute alignments by minimizing the sum of the total edit distances \nbetween matched chunks and the lengths of unmatched chunks. In some applications, it is important to \nnot matchup chunks that are too different, even if aligning those chunks would produce a minimal cost \nalignment. For instance,inthefollowingexample,wherekeysarethreechar\u00adacters long let k : lens = key [A-Z]{3} \n. [0-9]<->\"\" let l : lens = <best:k> . (copy \";\" . <best:k>)* l.put \"DBD;CCC;AAA\" into \"AAA1;BBB2;CCC3\" \n= \"DBD2;CCC3;AAA1\" we might prefer to not align the DBD and BBB2 chunks with each other. The best species \ndoes align them because the cost of a two\u00adcharacter edit is less than the six-character edit of deleting \nBBB from the view and adding DBD.To obtain the desired behavior, we can add a threshold annotation: let \nl:lens = <best 50:k> . (copy \";\" . <best 50:k>)* l.put \"DBD;CCC;AAA\" into \"AAA1;BBB2;CCC3\" = \"DBD0;CCC3;AAA1\" \n The best species takes an optional integer n as an argument. When supplied with such an integer, it \nminimizes the total edit distances between aligned chunks,butit only aligns chunks whose longest common \nsubsequence is at least n%of the lengths of their keys. (The strict key-based alignment used in dictionary \nlenses can be simulated using best 100.) The revised version of the l lens does not align DBD with BBB2 \nbecause the longest common subsequence computed from theirkeys does not meet the threshold. The nonx \nspecies also supports thresholds.Weoften use nonx with a threshold to align chunks containing totally \nunstructured text. 6. Extensions To streamline the discussion, our presentation of matching lenses in \nthe preceding sections has made three important assumptions: (1) chunks only appear at the top level, \n(2) the same basic lens processes every chunk, and (3) the lens does not reorder chunks in going from \nsource to view. Of course, in many applications, it is important to be able to nest chunks, to use different \nbasic lenses to process chunks, and to reorder chunks. This section describes how we can extend the matching \nlens framework to accommodate these features. Each of these extensions is implemented in Boomerang. \n6.1 Nested Chunks To handle sources with reorderable information at several different levels,itis often \nusefulto nest chunks inside each other.Forexam\u00adple, suppose that wewanttoextend ourWiki lensto handle \nseveral levels of nested structure: sections, subsections, and paragraphs. So the get function will map \nthe source =Grand Tours= The grand tours are major cycling races... ==Giro d Italia== The Giro is usually \nheld in May and June... =Classics= The classics are one-day cycling races... ==Milan-San Remo== The Spring \nclassic is held in March... to a view that contains just section and subsection headings: Grand Tours \nGiro d Italia Classics Milan-San Remo If we modify the view by reordering sections and adding new subsections, \nClassics Milan-San Remo Paris-Roubaix Grand Tours Giro d Italia Tour de France we would like paragraphs \nto be restored to the appropriate section or subsection. Wecanbuilda matchinglensthathas chunksat multiplelevels \nof structure using the lower combinator, which converts a match\u00ading lens to a basic lens: let subsection \n: lens = \"==\"<->\" \" . key (copy HEADING) . (\"==\\n\" . PARAGRAPHS)<->\"\\n\"  let section : lens = \"=\"<->\"\" \n. key (copy HEADING) . (\"=\\n\" . PARAGRAPHS)<->\"\\n\" . lower <best:subsection>* let wiki : lens = <best:section>* \nThe subsection lens inserts two characters of indentation, copies the heading, and deletes anyparagraphs \nthat follow. The section lens copies the heading, deletes the paragraphs that follow,and then uses lower \nto convert the matching lens that processes the list of subsection chunks into a basic lens. The top-level \nwiki lens uses the section lensto processalistof section chunks.Ifwe put back the updated view into the \noriginal source, we get an updated source where paragraphs are restored appropriately: =Classics= The \nclassics are one-day cycling races... ==Milan-San Remo== The Spring classic is held in March... ==Paris-Roubaix== \n=Grand Tours= The grand tours are major cycling races... ==Giro d Italia== The Giro is usually held in \nMay and June... ==Tour de France== The main thing to notice about this program is that we can use lower \ntobuild matching lenses that process nested chunks. Lenses builtin thisway align chunksin strict nestedfashion \ne.g.,in this example, the top-levelwiki lens aligns the section chunks and then aligns the nested chunks \nfor subsections within each section.  6.2 Multiple Lenses We can alsobuild matching lenses that use \ndifferent basic lenses to process chunks. Returningtoourrunningexample, supposethatwe wantedaversionof \nthewiki lens in which subsections and sections are aligned separately. Why would we want this? Observe \nthat the lens described in the previous section never aligns subsections that appear in different sections. \nThis means that if we move a subsection from one section to another Classics Grand Tours Giro d Italia \nMilan-San Remo the paragraph under that subsection will be lost when we put the result back into the \noriginal source =Classics= The classics are one-day cycling races... =Grand Tours= The grand tours are \nmajor cycling races... ==Giro d Italia== The Giro is usually held in May and June... ==Milan-San Remo== \nbecause the alignment strictly follows the nesting structure of the document. We can build a lens that \naligns section and subsections sepa\u00adrately by using two different kinds of chunks, as in the following \nprogram, written using tags : let section : lens = \"=\"<->\"\" . key (copy HEADING) . (\"=\\n\" . PARAGRAPHS)<->\"\\n\" \nlet wiki : lens = ( < tag \"section\" best : section > . < tag \"subsection\" best : subsection >* )* This \nversion of the wiki lens has two chunks at the top level one for sections and another for subsections. \nThe tag primitives assigns a distinct name to each kind of chunk, where each tag is associated with a \ndifferent basic lens. On the same inputs as above, the put function of this lens produces a new source \n=Classics= The classics are one-day cycling races... =Grand Tours= The grand tours are major cycling \nraces... ==Giro d Italia== The Giro is usually held in May and June... ==Milan-San Remo== The Spring \nclassic is held in March... where the paragraph under the Milan San Remo subsection is restored from \nthe source.Toextend matching lenses with tags we simply generalize each of our structures with an extra \nlevel of indirection e.g., we change the type of resources from .nite maps from locations to complements \nto .nite maps from tags to locations to complements. When we align chunks, we compute a separate alignment \nfor each tag.  6.3 Reordering Chunks Some applications require matching lenses that reorder chunks in \ngoing from source to view. The swap operator (l1 ~ l2) is similar to concatenation,but inverts the order \nof the strings in the view. Adding swap as a primitive breaks the procedure for using a matching lens \nimplemented by the .\u00b7. coercion described in Section3where we pre-align the resource usinga correspondence \ncomputed between the old and new view. It also causes problems with the sequential composition operator \nin general, the lenses being composed may reorder the source chunks differently, so it does not make \nsense to simply zip the resources generated by each lens together and align the result against the view. \nTo recover the behavior we want, we need to extend matching lenses with another function thatkeeps trackof \nthe permutation on chunks computedby the lens: l.perm . I s : .S.. Perms(locations(s)) It is straightforward \nto add perm to each of the lenses we have seen sofar e.g., the lift primitivereturns the empty permutation, \nmatch returns the identity permutation on its single chunk, the concate\u00adnation operator merges the permutations \nreturned by its sublenses in the obvious way, and so on. We also need the CHUNKPUT and NOCHUNKPUT laws \nto use perm the old versions are no longer valid for lenses that reorder chunks: n . (locations(v) n \ndom(r)) (l.perm (l.put v (c, r)))(m)= n (CHUNKPUT) (l.put v (c, r))[m]= k.put v[n](r(n)) n . (locations(v) \n\\ dom(r)) (l.perm (l.put v (c, r)))(m)= n (NOCHUNKPUT) (l.put v (c, r))[m]= k.create v[n] Theselaws generalizethelawsgivenin \nSection3.TheCHUNKPUT law stipulates that the mth chunk in the source produced by put mustbe identicaltothe \nstructure producedby applying k.put to the nth chunk in the view and the element r(n) in the resource, \nwhere the permutation computedbythe perm function on the source maps m to n. The other laws generalize \nsimilarly. Composition Using perm, we can re.ne sequential composition operator to use the permutation \non chunks computed in each phase: The res function applies the inverse of the permutation computed by \nl2 on the intermediate view to the resource computed by l1, which puts it into the view order of l2. \nLikewise, the put function puts the r1 resource back into the view order of l1.  Swap The swap lens \nis de.ned as follows: Like the concatenation lens, the get component of swap splits the source string \nin two and applies l1.get and l2.get to the resulting substrings. However, before it concatenates the \nresults, it swaps their order. The res, put, and create functions are similar. The perm component of \nswap combines permutations using the (**) operator ( q1(m)+ |q2| if m< |q1| (q2 ** q1)(m)= q2(m -|q1|) \notherwise which behaves like the (++) operator for resources. 7. Implementation To test the expressiveness \nand usability of our framework, we have extended the Boomerang implementation with the string match\u00ading \nlenses discussed in Section 4, with all the alignment strate\u00adgies describedin Section5andtheextensionsin \nSection6.Type\u00adchecking is decidable indeed, it can be made quite ef.cient using standard regular-expression \nalgorithms over an extended alphabet .{ . , . }, where theextra characters are used for checking side \nconditions involving chunk annotations. Alignment strategies are implemented using a straightforward \nalgorithm for the positional strategy, a diff-like least-common-subsequence algorithm for the non-crossing \nbest matching, and a version of the Hungarian algo\u00adrithm for the best-match strategy.Wehavedeveloped \nseveral small applications, including lenses for structured documents,Wikis, and literate Coq sources. \n8. Related Work This paper extends our previous work on lenses[3,4, 10, 12, 13]with new mechanisms for \nspecifying and using alignments. The original paper on lenses[10] includes an extensive survey of relevant \nthreads from the database and programming languages literature.We focus here on the most closely relatedwork. \nMatching lenses grew out of the dictionary lenses we proposed previously[3],but theydifferin several \nimportantways. First, dic\u00adtionary lenses are based on a single alignment mechanism by keys whereas matching \nlenses provide a generic framework for using alignments in lenses that can be instantiated with arbitrary \nfunctions. Second, the semantic laws that govern the behavior of dictionary lenses express much weaker \nconstraints than the match\u00ading lens laws, which specify the handling of chunks directly and in detail. \nSpeci.cally, dictionary lenses obey an EQUIVPUT law that forces the put function to be oblivious to certain \nfeatures of sources characterized by an equivalence relation ~. By picking ~ to be an equivalence that \nrelates strings differing only in the rela\u00adtiveorderof chunkswithdifferentkeysweget some constraintson \nput e.g., it forbids lenses that operate positionally but these con\u00adstraints are weaker than the conditions \nstated in the matching lens laws.Forexample, Lemma 3.1 does not hold for dictionary lenses because the \ntype system does notexplicitlykeep trackof chunks. Much of the previous work on view update assumes that \nthe user will modify the view using special operations in some update language , and, often, these update \noperations can be used to infer an intended alignment.Forexample,in Meertens swork on con\u00adstraint maintainers \nfor user interfaces [20]users manipulate lists using small updates for which it is easy to maintain the \ncorre\u00adspondence between source and view items. Similarly, the bidirec\u00adtional languagesXandInv[15,21]assume \nthat edit operations are appliedtothedatatoyield annotatedvaluesthat indicate whethera value was newly \ncreated or deleted. Their languages handle single insertions and deletionsbut not general reorderings. \nDiskin, Xiong, and Czarnecki s u-lenses [8]offer a much more general semantic space for lenses operating \non updates. The details are quite differ\u00adent, but there are some intriguing intuitive similarities to \nthe ap\u00adproach in this paper; in particular, their notion of sameness rela\u00adtions, which they use to identify \ncorresponding structures in the source and view, seems deeply related to our alignments. Many relational \nview update translators use schemas to guide the selection of a source update. For example Keller identi.es \ncriteria for view update translators requiring that thekey of each source item appearsin the view[17]. \nMatching lenses also usea notion ofkeys for alignment,but theypermit the correspondence between chunks \nto be computed using arbitrary heuristics. Alignment issues also come up in software model transforma\u00adtions. \nSome systems offer traceability links that can be used for alignment[5, 23]. 9. Conclusions and Future \nWork Matching lenses provide a general solution to the problems that comeupwhen updatableviewsare de.nedover \nordered structures. Decoupling the handling of rigidly ordered and reorderable infor\u00admation yields a \n.exible framework that can be instantiated with arbitrary heuristics for alignment. Ourwork canbeextendedin \nseveral directions.We are inter\u00adested in exploring other axiomatizations of matching lenses. One idea, \noriginally suggested by Alexandre Pilkiewicz, is to replace the current laws with laws stated in terms \nof a lens on skeletons andabasiclensmappedonthelistof chunks.Thiswouldprovidea moreelegant descriptionofthe \nsemanticsof matching lenses.How\u00adever, we believe it would make it more complicated to verify oper\u00adators \nsuch as concatenation.We are interested in instantiating the framework of matching lenses in other settings \nbesides strings and exploring implementation issues, including algebraic optimization and lenses for \nstreaming data.  Acknowledgments We thank Zack Ives, Alexandre Pilkiewicz, ValTannen, PhilipWadler, \nSteve Zdancewic, and the anonymous ICFPreviewersfor helpful comments.Ourworkis supportedbythe National \nScienceFoundation under grants IIS-0534592 Linguistic Foundations for XML View Update, and CT-0716469 \nManifest Se\u00adcurity. References [1] Franc\u00b8ois Bancilhon and NicolasSpyratos. Update semanticsof rela\u00adtional \nviews. ACM Transactions on Database Systems, 6(4):557 575, December 1981. [2] Jean Berstel, Dominique \nPerrin, and Christophe Reutenauer. Codes and Automata. Cambridge University Press, 2009. [3] Aaron Bohannon, \nJ. Nathan Foster, Benjamin C. Pierce, Alexandre Pilkiewicz, and Alan Schmitt. Boomerang: Resourceful \nlenses for string data. In ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages (POPL), \nSan Francisco, CA, pages 407 419, January 2008. [4] Aaron Bohannon, JeffreyA.Vaughan, and BenjaminC. \nPierce. Rela\u00adtional lenses: A language for updateable views. In ACM SIGACT SIGMOD SIGART Symposium on \nPrinciples of Database Systems (PODS), Chicago, TL, 2006. Extended version available as Univer\u00adsity of \nPennsylvania technical report MS-CIS-05-27. [5] Krzysztof Czarnecki, J. NathanFoster, Zhenjiang Hu, RalfL\u00a8 \nammel, Andy Sch\u00a8urr, and JamesF.Terwilliger. Bidirectional transformations: Across-discipline perspective. \nGRACE meeting notes, state of the art, and outlook. In International Conference on Model Transformations \n(ICMT), Zurich, Switzerland, pages 260 283, June 2009. Invited paper. [6] Umeshwar Dayal and Philip A. \nBernstein. On the correct translation of update operations on relational views. ACM Transactions on Database \nSystems, 7(3):381 416, September 1982. [7] Zinovy Diskin. Algebraic models for bidirectional model synchro\u00adnization. \nIn International Conference on Model Driven Engineering Languages and Systems (MoDELS), Toulouse, France, \npages 21 36, September 2008. [8] Zinovy Diskin,Yingfei Xiong, and Krzysztof Czarnecki. From state\u00adto \ndelta-based bidirectional model transformations. In LaurenceTratt and Martin Gogolla, editors, ICMT, \nvolume 6142 of Lecture Notes in Computer Science, pages 61 76. Springer, 2010. [9] J. NathanFoster, Michael \nB. Greenwald, Christian Kirkegaard, Ben\u00adjamin C. Pierce, and Alan Schmitt. Exploiting schemas in data \nsyn\u00adchronization. Journal of Computer and System Sciences, 73(4), June 2007. Short version in DBPL 05. \n[10] J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Ben\u00adjamin C. Pierce, and Alan Schmitt. \nCombinators for bidirectional tree transformations: A linguistic approach to the view update problem. \nACM Transactions on Programming Languages and Systems, 29(3), May 2007. [11] J. Nathan Foster and Benjamin \nC. Pierce. Boomerang Program\u00admer s Manual, 2009. Available from http://www.seas.upenn. edu/~harmony/. \n[12]J.NathanFoster,BenjaminC.Pierce,andSteveZdancewic. Updatable security views. In IEEE Computer Security \nFoundations Symposium (CSF), Port Jefferson, NY, pages 60 74, July 2009. [13] J. NathanFoster, Alexandre \nPilkiewcz, and BenjaminC. Pierce. Quo\u00adtient lenses. In ACM SIGPLAN International Conference on Func\u00adtional \nProgramming (ICFP), Victoria, BC, pages 383 395, September 2008. [14] G. Gottlob,P.Paolini, andR. Zicari. \nProperties and update semantics of consistent views. ACM Transactions on Database Systems (TODS), 13(4):486 \n524, 1988. [15] Zhenjiang Hu, Shin-Cheng Mu, and Masato Takeichi. A pro\u00adgrammable editor for developing \nstructured documents based on bidi\u00adrectional transformations. Higher-Order and Symbolic Computation, \n21(1 2), June 2008. [16] C. Barry Jay and J. Robin B. Cockett. Shapely types and shape poly\u00admorphism. \nIn Proceedings of the European Symposium on Program\u00adming (ESOP), London, UK, pages 302 316, 1994. [17] \nArthurM.Keller. Algorithmsfor translatingview updatesto database updates for views involving selections, \nprojections, and joins. In Proceedings of Fourth Annual ACM Symposium on Principles of Database Systems \n(PODS), pages 154 163, march 1985. Portland, Oregon. [18] David Lutterkort. Augeas A con.guration API. \nIn Linux Symposium, Ottawa, ON, pages 47 56, 2008. [19] Kazutaka Matsuda, Zhenjiang Hu,Keisuke Nakano, \nMakoto Hamana, and Masato Takeichi. Bidirectionalization transformation based on automatic derivation \nof view complement functions. In ACM SIG-PLAN International Conference on Functional Programming (ICFP), \nFreiburg, Germany, pages 47 58, 2007. [20] Lambert Meertens. Designing constraint maintainers for user \ninterac\u00adtion, 1998. Manuscript, available from ftp://ftp.kestrel.edu/ pub/papers/meertens/dcm.ps. [21] \nShin-Cheng Mu, Zhenjiang Hu, and MasatoTakeichi. An algebraic approach to bi-directional updating. In \nASIAN Symposium on Pro\u00adgramming Languages and Systems (APLAS), pages 2 20, November 2004. [22] Hugo Pacheco \nand Alcino Cunha. Generic point-free lenses. In International Conference on Mathematics of Program Construction \n(MPC), Qu\u00b4ebec City, QC, 2010. To appear. [23] Perdita Stevens. Bidirectional model transformations in \nQVT: Seman\u00adtic issues and open questions. In International Conference on Model Driven Engineering Languages \nand Systems (MoDELS), Nashville, TN, volume 4735 of Lecture Notes in Computer Science, pages 1 15. Springer-Verlag, \n2007. [24] JanisVoigtl\u00a8ander. Bidirectionalization for free! In ACM SIGPLAN SIGACT Symposium on Principles \nof Programming Languages (POPL), Savannah, GA, pages 165 176, January 2009. [25] MengWang, Jeremy Gibbons, \nKazutaka Matsuda, and Zhenjiang Hu. Gradual re.nement: Blending pattern matching with data abstraction. \nIn International Conference on Mathematics of Program Construction (MPC), Qu\u00b4ebec City, QC, 2010. To \nappear. [26]Y.Xiong,Z.Hu,H.Zhao,H.Song,M.Takeichi,andH.Mei. Support\u00ading automatic model inconsistency.xing. \nIn ACM SIGSOFT Sympo\u00adsium on the Foundations of Software Engineering (FSE), Amsterdam, Netherlands, pages \n315 324, 2009.   \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Bidirectional programming languages are a practical approach to the view update problem. Programs in these languages, called <i>lenses</i>, define both a view and an update policy - i.e., every program can be read as a function mapping sources to views as well as one mapping updated views back to updated sources.</p> <p>One thorny issue that has not received sufficient attention in the design of bidirectional languages is <i>alignment</i>. In general, to correctly propagate an update to a view, a lens needs to match up the pieces of the view with the corresponding pieces of the underlying source, even after data has been inserted, deleted, or reordered. However, existing bidirectional languages either support only simple strategies that fail on many examples of practical interest, or else propose specific strategies that are baked deeply into the underlying theory.</p> <p>We propose a general framework of <i>matching lenses</i> that parameterizes lenses over arbitrary heuristics for calculating alignments. We enrich the types of lenses with \"chunks\" identifying reorderable pieces of the source and view that should be re-aligned after an update, and we formulate behavioral laws that capture essential constraints on the handling of chunks. We develop a core language of matching lenses for strings, together with a set of \"alignment combinators\" that implement a variety of alignment strategies.</p>", "authors": [{"name": "Davi M.J. Barbosa", "author_profile_id": "81470645351", "affiliation": "&#201;cole Polytechnique, Paris, France", "person_id": "P2338186", "email_address": "", "orcid_id": ""}, {"name": "Julien Cretin", "author_profile_id": "81470655088", "affiliation": "&#201;cole Polytechnique, Paris, France", "person_id": "P2338187", "email_address": "", "orcid_id": ""}, {"name": "Nate Foster", "author_profile_id": "81444600818", "affiliation": "Princeton University, Princeton, NJ, USA", "person_id": "P2338188", "email_address": "", "orcid_id": ""}, {"name": "Michael Greenberg", "author_profile_id": "81406593888", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2338189", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P2338190", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863572", "year": "2010", "article_id": "1863572", "conference": "ICFP", "title": "Matching lenses: alignment and view update", "url": "http://dl.acm.org/citation.cfm?id=1863572"}