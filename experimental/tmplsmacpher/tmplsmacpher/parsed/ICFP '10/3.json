{"article_publication_date": "09-27-2010", "fulltext": "\n ReCaml: Execution State as the Cornerstone of Recon.gurations J\u00b4er\u00b4emy Buisson Universit\u00b4eenne de Bretagne \n e Europ\u00b4 \u00b4 Ecoles de St-Cyr Co\u00a8etquidan / VALORIA Guer, France jeremy.buisson@st-cyr.terre-net.defense.gouv.fr \nAbstract To .x bugs or to enhance a software system without service dis\u00adruption, one has to update it \ndynamically during execution. Most prior dynamic software updating techniques require that the code to \nbe changed is not running at the time of the update. However, this restriction precludes any change to \nthe outermost loops of servers, OS scheduling loops and recursive functions. Permitting a dynamic update \nto more generally manipulate the program s ex\u00adecution state, including the runtime stack, alleviates \nthis restriction but increases the likelihood of type errors. In this paper we present ReCaml, a language \nfor writing dynamic updates to running pro\u00adgrams that views execution state as a delimited continuation. \nRe-Caml includes a novel feature for introspecting continuations called match cont which is suf.ciently \npowerful to implement a variety of updating policies. We have formalized the core of ReCaml and proved \nit sound (using the Coq proof assistant), thus ensuring that state-manipulating updates preserve type-safe \nexecution of the up\u00addated program. We have implemented ReCaml as an extension to the Caml bytecode interpreter \nand used it for several examples. Categories and Subject Descriptors D.3.2 [Programming Lan\u00adguages]: \nLanguage Classi.cations Applicative (functional) lan\u00adguages; D.3.3 [Programming Languages]: Language \nConstructs and Features Control structures; D.3.4 [Programming Languages]: Processors Compilers; F.3.2 \n[Logics and Meanings of Pro\u00adgrams]: Semantics of Programming Languages General Terms Languages Keywords \ndynamic software updating, continuation, functional language, execution state introspection, static typing, \nCaml 1. Introduction Stopping a critical and long-running system may not be possible or more simply not \nacceptable as it would incur an excessive .nancial or human cost. Dynamic software updating technology \naddresses this challenge by enabling updates to running software, including bug.xes, feature additions, \nor even temporary instrumentation for diagnosis or performance tuning [3, 28]. One of the main issues \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright c . 2010 ACM 978-1-60558-794-3/10/09. \n. . $10.00 Fabien Dagnat Universit\u00b4eenne de Bretagne e Europ\u00b4 Institut Tel\u00b4\u00b4el\u00b4 ecom / T\u00b4ecom Bretagne \nPlouzan\u00b4 e, France Fabien.Dagnat@telecom-bretagne.eu when updating a running software is to ensure safety. \nAfter an up\u00addate, the modi.ed software must remain consistent and continue to achieve its goals. Final \nresults must not be compromised even if intermediate results are reused in a different context. The Gmail \noutage in February 2009 [11] has shown possible consequences of unsafe updates: an update of the data \nplacement service inconsis\u00adtent with the redundancy strategy has caused a global denial of ser\u00advice. \nMuch prior work on dynamic software updating has observed that forms of safety (such as type safety) \ncan be ensured by re\u00adstricting updates to active system components [1, 9, 19, 22, 36]. For example, if \nan update attempts to .x a bug in function foo, then the update may be rejected if foo happens to be \non the call stack. Baumann et al. [7] and Arnold and Kaashoek [4] report that for an OS kernel, up to \n80% to 90% of the security .xes are sup\u00adported by this approach. However, it happens that a function \nthat never becomes passive, potentially in critical parts of the software system, needs to be updated. \nNot being able to update actively run\u00adning functions prevents for instance updating the outermost loop \nof a server. Extracting loop bodies into separate functions [28] makes the code brie.y inactive between \neach iteration. However, this tech\u00adnique does not solve any of the following additional cases. The pri\u00admary \nLinux scheduler function is never passive as it is on the stack of all threads [4]. Baumann et al. [7] \nalso mention exception han\u00ad dlers in a kernel which may need update at runtime [26]. The use of some \ncompilers that squash software structure makes the situation even worse. For example, synchronous languages, \nused to program embedded systems, rely on compilers [2] that interleave instruc\u00ad tions coming from many \ncomponents and depending on the same input data into a single block of code. The compiled software struc\u00adture \nthus causes what were once independent source-code units to be considered active when any one of them \nis. In order to support more updates, Hofmeister and Purtilo [20] have proposed to focus on the execution \nstate rather than the pro\u00adgram structure. Upon update, the runtime stack is captured, ad\u00adjusted then \nrestored. Because the stack is appropriately handled, it does not matter if some of the updated functions \nare actively run\u00adning. However, this approach has currently no formal semantics and provides no guarantee \nthat update developers will not produce type-incorrect states. This paper places the execution state \napproach [10, 20, 25] on safer ground by de.ning ReCaml, a functional language designed for manipulating \nexecution states in a safe manner. We have de.ned ReCaml formally and proved it sound. Viewing the execution \nstate as a delimited continuation [15], updating a computation consists in capturing, modifying and reinstating \na continuation. To support the modi.cation of a continuation, we de.ne a new match cont pattern-matching \noperator. It matches a continuation with call sites to decompose it in stack frames peforming speci.c \nupdate actions on each of them. Depending on the execution state, the update programmer speci.es the \naction to apply, e.g., discarding a frame, modifying a frame or keeping it unmodi.ed. Combining such \nac\u00adtions, the approach is .exible enough to support many policies, such as completing the computation \nat the old version, combining old results with subsequent new computation, or discarding old re\u00adsults \nfor recomputing entirely at the new version. Attaching types to call sites allows us to check that the \nmatch cont operator is well typed, and therefore that stack introspection is correct. The main contributions \nof our work are:  Explicit execution state management. Updates are expressed as manipulations of the \nexecution states. The work of update de\u00advelopers focuses mainly on this aspect, which we call compen\u00adsation. \nIn doing so, a developer can implement resulting deter\u00administic behaviors by explicitly controlling the \noperations exe\u00adcuted by the update depending on its timing.  Optimistic update. As a consequence of \nthe previous point, up\u00addates can occur at any time. A compensation ensures consis\u00adtency afterwards, according \nto the execution state at the time of the update. Therefore, no preventive action (such as waiting for \nelements of the software to become inactive) is required. In ad\u00addition, even if updates might not be \neffective immediately, they are executed with no delay.  DSU as manipulation of delimited continuations. \nWhile contin\u00aduations are common when studying languages and modelling exceptions and coroutines, they \nhave not before been used for dynamic software updating. Relying on continuations, ReCaml does not require \nany source code transformation or any speci.c compilation scheme. DSU as manipulation of continuations \n.ts nicely within a functional framework.  Formal semantics and static type system. ReCaml comes with \noperators for capturing, modifying and reinstating continua\u00adtions. It is equipped with a formal operational \nsemantics. Al\u00adthough it is aimed at manipulating execution states, which are dynamic structures, ReCaml, \nand especially the continuation manipulation, is statically typed. The type system is proved to be sound \nusing the Coq theorem prover.  Working prototype. We have developed a prototype of ReCaml, which we \nhave used to implement a few examples.  In Section 2 we .rst present concrete strategies based on our \napproach. Section 3 outlines our approach. Section 4 describes in details ReCaml, the formal language \nunderlying our approach. Section 5 discusses implementation issues. 2. Update Complexity vs Application \nSimplicity In this section, our aim is to convince the reader that updates can be so complex that the \nsearch for sophisticated solutions is justi.ed. We are aware that supporting tools will be required in \norder to ease the proposed solution. We leave this problem to subsequent work, beyond the scope of this \npaper. Our argumentation relies on a program computing a Fibonacci number. This very simple toy example \nis just aimed as a proof of concept to illustrate the dif.culties when updating a program which is repeatedly \nactive at the time of the update. If updates are already complex for such a simple program, then it should \nbe worse for real applications. The initial version of our example is: let rec fib n= if n < 2 then \nn else (fib (n -1)) + (fib (n -2)) in fib 12345 2.1 Initial Remarks and Overall Approach There is no \npoint in splitting this code in .ner structural elements1. This program is built around a single recursive \nfunction, whose out\u00adermost execution completes only when the whole program termi\u00adnates. Hence trying \nto passivate the fib function makes no sense. If old and new versions can be mixed, dynamic rebinding \n[12, 14] obviously solves the problem: active calls complete with the old version while new calls can \nbe directed to the new version. Usu\u00adally, this assumption implies that the type of the rebound function \ndoes not change. If the type of the fib function is changed, then rebinding it breaks consistency. An \nupdate has therefore to deal with the current execution state. It corresponds to the stack of calls already \nstarted with their argu\u00adments. Such ongoing calls are called activations in the rest of the paper. Updating \na function requires to specify the action to handle each activation. Such speci.cations are called compensations2. \nFor example, updating a function f of type t1 . t2 while changing its type to t1 . . t2 . may require \nto convert its argument to its new type (t1. ) or its result to be used by code expecting values of the \nold type (t2). More generally, a compensation can: yield to the activation, hence executing the old \nversion until the completion of the activation. The result may need to be converted to conform to the \nnew type of its calling activation if it has changed. Note that this is the semantics of Erlang [14], \nJava HotSwap [12] and more generally of dynamic rebinding, where result conversion is the identity function. \n cancel the activation, hence starting over the call with the new version. Call parameters shall be \nconverted according to the new version. The result shall also be converted according to how the compensation \nhandles its calling activation.  extract intermediate results from the activation in order to feed some \ncustom code. Depending on how the calling activation is compensated, this custom code computes the new \nresult in place of the canceled activation.  The relative worth of each strategy depends on the time \nat which the update occurs. For example, if the considered activation is close to its completion, then \nit may be worthwhile to let it complete its execution. If the activation has started recently, then it \nmay be better to abort and start over. If the update occurs in the middle of the execution period, then \nthe third option could be more appropriate. In the third option, the amount of reusable intermediate \nresults varies depending on the old and new versions. The extreme case where no intermediate result can \nbe reused matches the second option, i.e., aborting the activation and starting over the call. The quantity \nof reusable results gives an additional hint in order to choose the most advantageous option.  2.2 Replacing \nthe Type of Integers We .rst emphasize problems arising when modifying a type. As the computed Fibonacci \nnumber becomes high, using .xed-size integers will result in an over.ow. Instead, it is safer to use \narbitrary precision integers. The new version of the program is3: 1 Except possibly abstracting arithmetic \noperations in the integer data type. Here, the abstract data type is implicit as Haskell s Num type class. \n2 Makris and Bazzi [25] use the name stack/continuation transformer and Gupta et al. [18] use state mapping. \nBeing functional, ReCaml does not allow in place modi.cation of a continuation but favors the construction \nof a new future. Hence, we prefer a new name to avoid misunderstanding. 3 In Caml libraries, num of int \nis the function that converts an integer to arbitrary precision; +/ is the addition over arbitrary precision \nintegers.  let rec fib n= if n < 2 then num of int n else (fib (n -1)) +/ (fib (n -2)) Obviously, using \ndynamic rebinding forbids this update as the type of fib is changed and there is at least one active \ncall. Assum\u00ading that the integer data type has been well abstracted, one possible strategy could consist \nin updating this data type, like Gilmore et al. [16] and Neamtiu et al. [28] do. This approach has two \nmajor draw\u00ad backs. First, it updates all the uses of integers, while we want that only the result of \nthe fib function has the overhead of arbitrary precision integers. Second, at the time of the update, \nsome of the executions of the fib function might have already produced over\u00ad.owed integers. A systematic \nupdate of all integers has no chance to distinguish the over.owed values that must be recomputed. One \npossible update is as follows. Given an activation, if none of the recursive calls has been evaluated, \nthen the activation can start over with the new version of the function. Otherwise, the com\u00adpensation \nchecks intermediate results in order to detect whether an over.ow has occurred. Only non-over.owed results \nare converted to the new type. Over.owed or missing results are computed using the new version. Last, \nthe compensation uses the arbitrary preci\u00adsion operator in order to perform the addition. The compensation \nhandles caller activations in a similar way, taking into account the fact that the type of the call result \nhas already been converted. The code of this update is outlined in Section 3 and detailed in Section \n6 to illustrate ReCaml.  2.3 Introducing Memoization Second, we emphasize dif.culties that occur when \nchanging the algorithmic structure. In our example, there is a well-known algo\u00adrithm with linear time \ncomplexity, while the initial one has expo\u00adnential time complexity. The new version of the program is4: \nlet rec fib ni fi fi1 = if i=n then fi else fib n (i+1) (fi +/ fi1) fi in let fib n= if n < 2 then num \nof int n else fib n2 1/ 1/ We can safely mix new and old versions and rebind dynamically the name fib \nas the type of the function is not changed. However, in this case, the effective behavior still has polynomial \ntime com\u00adplexity. Indeed, in the worst case, there is a stack of n activations of the old function, each \nof which subsequently performs up to one call to the new version. The effective behavior is worse than \nabort\u00ading and starting over the program, which is not satisfactory. A better way to perform this update \nis to look out for two consecutive Fibonacci numbers in intermediate results. The new version is evaluated \nfrom the greatest pair, passed as parameters to the fib function. If there is no such pair, it is not \nworth reusing any intermediate result and the program would rather start over.  2.4 Discussion Using \nthese two simple examples, we aim at showing that updating a software at runtime and in the right way \nis a dif.cult task. There is no general scheme that applies well to all of the cases. In the .rst case \n(Section 2.2), each activation is converted independently of the others to the new version. In the second \ncase (Section 2.3), as the algorithm changes radically, all of the activations are cancelled and there \nis a lookup for speci.c intermediate results. These update schemes are complex despite the simplicity \nof the application. 4 To keep the program simple, we extend Caml with 1/ to denote the arbi\u00adtrary precision \nliteral 1 similarly to the +/ notation for arbitrary precision addition. In addition, our examples show \nthat even for a single applica\u00adtion, the right scheme depends on the update itself. This is the rea\u00adson \nwhy we argue in favor of a mechanism that allows developers to design speci.c schemes for each update. \nThis approach would not prevent proposing some update schemes off-the-shelf , e.g., rely\u00ading on some \ntools such as code generators, thus avoiding burdening developers when possible. Makris and Bazzi [25] \nfor instance have already proposed such automatic generation strategies. 3. Overview of the Approach \nIn the above examples, the key mechanism is the ability to intro\u00adspect activations when updating. Updates \nof Section 2 require in\u00ad termediate results from activations. They also need to identify what has been \ndone and what has still to be evaluated in each activation. For the implementer, this means that we need \na mechanism to reify the state of the execution, including the call stack. To achieve this, we use continuations \nto model activations and we propose a new pattern matching operator match cont, abbreviated as mc. Given \na continuation, it matches the return address of the top stack frame as an indication of what remains \nto be done in the activation. It pops this stack frame and picks values from it in order to retrieve \ninter\u00admediate results. To do this, we extend the semantics with low-level details of the dynamics of \nthe runtime stack. In the following, we give an overview of how this operator helps in the fib example \n(Section 2.2). Here we give only part of it to make it easier to comment and understand. Section 6 gives \nmore details and the full source code is in Figure 7. The version below of the fib function is annotated \nfor the pur\u00adpose of update. Call sites labels may be given by the update devel\u00adoper or generated by some \nassisting tool. The labelling strategy is not discussed here because it is beyond the scope of this paper. \nlet rec fib n= if n < 2 then n else ( let fn1 = <L1> fib (n-1) in let fn2 = <L2> fib (n-2) in fn1+fn2) \nin <Lroot> fib 12345 Using these labels, the update developer can write a function that chooses the most \nappropriate strategy for each activation of fib depending on the point it has reached. The main function \ncompensating the effect of the update from int to num is given below. At each step, this function match \nfib callers proceeds by .nding what is the state of the activation at the top of the current continuation \n(k) using match cont. The second parameter (r) is the result value that would have been used to return \nto the top stack frame. let rec match fib callers k r = match cont k with | <L1:n> :: k . (* (1) complete \nwith new version *) | <L2:n fn1> :: k . (* (2) convert fn1 *) let nfn1 = if (n-1)>44 then fib (n-1) else \nnum of int nfn1 in let r = (fn1 +/ r) in match fib callers k r | <Lroot> :: . (* (3) resume normal execution \n*) Notice that when .ltering a case the update developer can spec\u00adify values that he wants to extract \nfrom the current activation. For example, in case (1), he may use the rank of the Fibonacci number being \ncalculated (here it is bound to n) and in case (2), he may also access the intermediate result of fib \n(n-1) named here fn1. As described in Section 2.2, when the top stack frame matches L2, the compensation \nhas .rst to check whether fib (n-1) has over.owed. Assuming that integers are coded by, e.g., 31-bits \nsigned integers, we statically know that the biggest correct (smaller than 230 - 1) Fibonacci number \nhas rank 44. So the compensation compares the rank n-1 (where n is picked from the stack frame on top \nof the continuation k) to 44 in order to decide wether fn1 can be reused. We assume here that r has already \nbeen handled appro\u00adpriately by the compensation, hence its type is num. See Section 6 for details on \nhow it switches from int to num. Then the com\u00adpensation completes the popped activation in r . Last, \nwe have to compensate the tail k of the continuation. Because the next stack frame is also suspended \nat a call of fib (L2 originates from fib), we have to check once again for the callers of fib. Hence \nthe tail k is compensated by a recursive call of match fib callers .  4. The ReCaml Language Building \non the .-calculus, ReCaml adds a model of stack frames, which are generated by the compiler. On top of \nthis model and of a continuation framework, it implements the mc operator. In doing so, developers programming \nupdates in ReCaml can manipulate runtime states using the same language. Embedding the operator in the \nlanguage allows us to extend the type system in order to eliminate statically unsound update programs. \nTriggering and executing an update is the responsibility of the execution platform. It is done by some \nkind of interrupt that can preempt execution at any time. However, updates must deal on their own with \ntheir timing with respect to the application execution. The execution platform captures the execution \nstate and passes it as an argument to the update. In return, updates have to guess when the execution \nhas been preempted to select appropriate actions. To mit\u00adigate the issue in bootstraping the compensation \nand to align con\u00adtinuation extremities on stack frame boundaries, as a .rst imple\u00admentation, we check \nfor the trigger only when the execution con\u00adtrol returns to a caller. This restriction is equivalent \nto explicit up\u00addate points. The application developer can cause additional points thanks to dummy calls, \neach of which incurs a return. 4.1 Syntax We .rst describe the syntactical constructs and notations \n(Figure 1) then we discuss the choices in the design of the grammar. 4.1.1 Description of the grammar \nBecause we use an environment-based semantics, we need explicit closures and environment management. \nWhile .x.e is the usual abstraction construct, (.x.e, E) denotes a closure such that the captured environment \nE is used to evaluate the body of the function upon application. The syntax of the application operator \n(<l> ee) is extended with a label <l> that names the call site. The (envE e) operator evaluates its subterm \ne in the environment E instead of the current evaluation environment. Recursive functions are de.ned \nas usual (let rec x = .x.e in e). Our continuation framework de.nes .rst-class instantiable prompts and \n.rst-class delimited continuations. Intuitively, prompts are delimiters that bound the outermost context \nthat shall be cap\u00adtured within a continuation. Hence a delimited continuation rep\u00adresents only part of \nthe remainder of execution. The newprompt operator instantiates a fresh prompt. The (setprompt<l> ee) \noper\u00adator inserts a delimiter in the evaluation context. Given a prompt, the (capture<l> up to e with \ne) operator captures and replaces the current continuation up to the innermost delimiter. The continua\u00adtion \nis wrapped by the cont (k) constructor. The (reinstate<l> ee) operator reinstates and evaluates a continuation. \nWe shall explain later in Section 4.1.2 the capup to p with v operator, which <l>,E is an explicit intermediate \nstep in the capture of a continuation. In order to model the state structure, we introduce an operator \n(frame<l>,E,p. e), which annotates activation boundaries. The opera-In the following, v is a value; e \ndenotes a term; x is a variable; k is a continuation, i.e., an evaluation context; p denotes a prompt; \n<l> names a call site; and E is an environment. v ::= (.x.e, E) | p | cont (k) e ::= v | x | .x.e | let \nrec x = .x.e in e | <l> ee | frame<l>,E,p. e | envE e | mc e with (<l>, x, x, x, e) ee | captureup to \ne with e | capup to p with v <l><l>,E | reinstate<l> ee | setpromptee | newprompt <l> k ::= . | <l> kv \n| <l> ek | frame<l>,E,p. k | envE k | mc k with (<l>, x, x, x, e) ee | captureup to k with v | captureup \nto e with k <l><l> | reinstate<l> kv | reinstate<l> ek | setpromptke <l> p . ::= p |. E ::= [] | (x .. \nv) :: E Additional constraint: A continuation cont (k) is either empty (k is .) or its innermost operator \nis frame (k ends with frame<l>,E,p. .). Figure 1. Grammar of terms and continuations tor denotes that \ne is evaluated in a new stack frame that results from the call/return site <l>. At the boundary, a prompt \nis possibly set if the third annotation p . is not . (i.e., it is the name of a prompt). E recalls the \nevaluation environment of the enclosing context of the operator thus keeping track of the values accessible \nin this frame. The last operator (mc e with (<l>,x1,x2,x3,e1) e2 e3) de\u00adconstructs a continuation relying \non its stack frame structure. It compares <l> and the return address on top of the continuation. If the \nlabels match, the continuation is split at the second inner\u00admost frame operator in a head (the inner \nsubcontinuation) bound to x1 and a tail (the outer subcontinuation) bound to x2. Further\u00admore, the variables \nx3 are bound to the values of the topmost stack frame. Then e1 is executed in the so extended evaluation \nenviron\u00adment. There are two other cases: either the return address does not match (e2 is executed) or \nthe continuation is empty (e3 is executed). The language has 3 kinds of values: closures, prompts and \ncontinuations.  4.1.2 Discussion Having explicit closures and the env operator is the usual ap\u00adproach \nfor the implementation of lexical scoping in small-step environment-based semantics. As a side-effect, \nthe env operator also ensures that continuations are independent of any evaluation environment, i.e., \nany continuation brings its required environment in an env construct. To some extent, this is similar \nto the destruct\u00adtime .-calculus [8, 33], which delays substitutions until values are consumed. That way, \nbindings can be marshalled and move be\u00adtween scopes. Delimited continuations are a natural choice in \nour context. In\u00addeed, when the mc operator splits a continuation into smaller ones, it instantiates continuations \nthat represent only parts of execution contexts. This is what delimited continuations are designed for. \nOur framework is similar to the ones of Gunter et al. [17] and Dybvig et al. [13]. The following table \napproximates how our operators match with existing frameworks. Readers can refer to Shan [34], Kiselyov \n[21] and Dybvig et al. [13] for more complete compar\u00ad In addition, we adapt the framework: isons. ReCaml \nnewprompt setprompt capture reinstate Dybvig et al. [13] newPrompt pushPrompt withSubCont pushSubCont \nGunter et al. [17] new prompt set cupto fun. application   We align the delimiters of continuations \nwith the delimiters of stack frames. To do so, we annotate the frame operator with an optional prompt \nin order to delimit where prompts are set. Furthermore, the continuation operators must have a call site \nlabel <l> in order to insert frame constructs.  We have to introduce a dummy cap operator to align a \nstack frame delimiter with the inner delimiter of the continuation. To do so, a frame operator (which \nneeds the evaluation environ\u00adment) is inserted at the innermost position of the continuation, in place \nof the capture operator. The cap operator saves the needed evaluation environment (the one at the position \nof the capture operator) before the continuation is actually captured.  Like Dybvig et al. [13], we \nencode continuations in a speci.c cont form rather than a closure [17]. That way, the linear structure \nof continuations (a stack in the implementation; the nesting of evaluation contexts in the language) \nis maintained and can be used by the mc operator. Furthermore, encoding a continuation as a closure would \nintroduce a variable, which would infringe the type preservation lemma due to the typing of call site \nlabels, as we will see later (Section 4.4). Last, making the distinction between continuations and closures, \nthe mc operator does not have to handle regular closures.  Intuitively, a frame operator is inserted \nwhen a call is done and disappears when the callee terminates. Thus, when a continuation is captured, \nall its activations are delimited by frame operators. The mc operator uses them to split continuations \ninto smaller ones. One can note that the environment of a frame is redundant. This envi\u00adronment indeed \ncomes from the enclosing env construct. While our choice imposes a dummy cap operator in the continuation \nframe\u00adwork, it makes mc simpler. Indeed, it does not need to look for env constructs to collect environments \nwhen a continuation is split.  4.2 Semantics The small step operational semantics of Figure 2 formalizes \nthe above description of ReCaml. We adopt an environment-based ap\u00adproach with lexical scoping of variables. \nThe judgment E. e . e . asserts that the term e reduces to e . in the evaluation environment E. Rules \nSUBST, CLOSE and LETREC are the classical ones for substituting a variable, building a closure and recursive \nde.nitions, respectively. As usual with environment-based semantics, the env operator installs a local \nenvironment in order to evaluate the nested term (rule ENV). Because the frame operator bounds activations, \nthe local environment used to evaluate the nested term is empty (rule FRAME). Here, it is the role of \nthe inner env operator to give the actual execution environment. Figure 2 gives only primitive re\u00adduction \nrules. Except frame and env, which need special treatment oftheenvironment,the CONTEXT rulegenericallyreducescontexts \naccording to the grammar of k. Because it is constrained with val\u00adues, it .xes a strict right-to-left \ncall-by-value evaluation order. The management of the frame operator is one originality of the semantics. \nIt implements the life cycle of activations. This operator is instantiated when a closure is applied \n(rule APPLY), when a prompt is set (rule SETPROMPT) and when a continuation is reinstated (rule REINSTATE). \nIt collapses when a callee activation returns a value (rule FRAMEVAL). Paired with the frame operator, \nthe env operator provides the local evaluation environment for the instantiated activation. For instance, \napplying a closure, e.g., the identity function, proceeds as follows: APPLY E. <l> (.x.x, E2) v - -----. \nframe<l>,E,. env(x..v)::E2 x FRAME,ENV,SUBST - -----. frame<l>,E,. env(x..v)::E2 v FRAME,ENVVAL - -----. \nframe<l>,E,.v FRAMEVAL - -----. v Capturing a continuation is done in two steps. First, the evalu\u00adation \nenvironment at the capture operator is saved, mutating the operator into cap (rule CAP1). The second \nstep is the standard con\u00adtinuation capturing. A cap operator using prompt p is only reduced within a \nframe tagged by p. If such a frame exists, the context k between this frame and cap is rei.ed as a continuation \ncont(k). A frame is inserted in place of cap consistently with the constraint of our language (see at \nthe bottom of Fig. 1). The closure argument of cap is applied to the resulting continuation (rule CAP2). \nIn rule CAP2, the enclosing prompt p is consumed. The system proceeds as follows: E1 . frame<l1>,E1,p \nenvE2 capture<l2> up to p with (.x.e, E3) FRAME,ENV,CAP1 -----. frame<l1>,E1,p envE2 capup to p with(.x.e, \nE3) <l2>,E2 CAP2 .. -----. frame<l1>,E1,. env(x..cont(k))::E3 e with k = envE2 (frame<l2>,E2,..) We proceed \nin two steps in order to handle easily any context in place of envE2 . If no frame tagged by p encloses \ncap p (terms structured like k capup to p with v where k does not con\u00ad <l2>,E2 tain any frame<>, ,p), \na runtime error occurs. The mc operator splits a continuation at the second innermost frame, which delimits \nthe top stack frame (rule MCMATCH). The rule MCMATCH handles the case where the continuation contains \na single stack frame. The tail subcontinuation is therefore the empty continuation. The rules for mc \nassume that the continuation is either empty (rule MCEMPTY) or the innermost operator within the continuation \nis frame (rules MCNOMATCH, MCMATCH and MCMATCH ). As shown in Fig. 1, this is enforced as a structural \nconstraint on the language. It is trivial to show that the semantics produces only continuations that \nconform to this constraint.  4.3 Type System The type system adheres to the usual design of the simply-typed \n.-calculus. Types may be type variables5, usual functional types, prompt types or continuation types. \nThe type of a prompt is pa\u00adrameterized by the type of the values that .ow through delimiters tagged by \nthat prompt. The type of a continuation is parameterized by the type of the parameter and the type of \nthe result of the con\u00adtinuation. The grammar for types is: . t ::= a | t . t | t prompt | t -. t Fig. \n3 gives the type system for the term language. The judge\u00ad ment E, P, L, t . e : te asserts that given \nthe typing environ\u00ad ments E, P and L, in an enclosing function whose return type is t , the term e has \ntype te. E (resp. P ) maps variables (resp. prompts) to types. L maps call site labels to label types, \nwhich are triplets {tpar,tres,V } where tpar and tres are types; and V is an en\u00ad vironment that maps \nvariables to types. The inference algorithm computes te and L. The L environment is intended for splitting \ncontinuations at ac\u00ad tivation boundaries. Figure 4 gives an intuition of its interpretation, . based \non the semantics of the mc operator. A t1 -. tn continuation 5 We use type variables for convenience \nto solve the type inference problem. As ReCaml is simply typed, type variables are never generalized \nas type parameters. Instead, they are unknown types that shall later be instantiated by uni.cation. This \nis similar to Caml s weak type variables such as a in the type a list ref of ref [].  SUBST: E. x .E \n(x) CLOSE: E. .x.e . (.x.e, E) APPLY: E1 . <l> (.x.e, E2) v . frame<l>,E1,. env(x..v)::E2 e LETREC: E. \nlet rec x1 = .x2.e1 in e2 . env(x1..(.x2.let rec x1=.x2.e1 in e1,E))::E e2 FRAMEVAL: E1 . frame<l>,E2,p. \nv . v ENVVAL: E1 . envE2 v . v MCEMPTY: E. mc cont (.) with (<l>,x1,x2,x3,e1) e2 e3 . e3 l1 . = l2 MCNOMATCH: \n E1 . mc cont (k [frame<l1>,E2,p.]) with (<l2>,x1,x2,x3,e1) e2 e3 . e2 k1 does not contain any frame \nE1 (x3)= v3 MCMATCH: E. mc cont (k2 [frame<l2>,E2,p2 (k1 [frame<l1>,E1,p1 .])]) with (<l1>,x1,x2,x3,e1) \ne2 e3 e1 . env(x1..cont(k1[frame<l1>,E1,p1 .]))::(x2..cont(k2[frame<l2>,E2,p2 .]))::(x3..v3)::E k1 does \nnot contain any frame E1 (x3)= v3 MCMATCH : E. mc cont (k1 [frame<l1>,E1,p1 .]) with (<l1>,x1,x2,x3,e1) \ne2 e3 p is fresh NEWPROMPT: e1 . env(x1..cont(k1[frame<l1>,E1,p1 .]))::(x2..cont(.))::(x3..v3)::E E. \nnewprompt . p CAP1: E. captureup to v1 with v2 . capup to v1 with v2 <l><l>,E k does not contain any \nframe<>, ,p CAP2: .. E1 . frame<l1>,E2,pk capup to p with (.x.e, E4) . frame<l1>,E2,. e <l2>,E3 env(x..cont(k[frame<l2>,E3,..]))::E4 \nSETPROMPT: E. setprompt<l> pe . frame<l>,E,p (envE e) REINSTATE: E. reinstate<l> cont (k) v . frame<l>,E,.k \n[v] Context rules: [] . e . e E2 . e . e E. e . e FRAME: ENV: if no other rule matches, CONTEXT: .. E1 \n. frame<l>,E2,p. e . frame<l>,E2,p. e E1 . envE2 e . envE2 e E. k [e] . ke k [a] substitutes a for . \nin k, where a is either a term, hence resulting in a term, or a continuation, hence resulting in a continuation. \nFigure 2. Operational semantics .. k is split into khead (t1 -. t2) and ktail (t2 -. tn). Composing the \ntwo subcontinuations results obviously in the original continu\u00adation. t2 is the return type of the function \nthat encloses l1. This is the reason why the type judgment has t (the type of the enclosing function) \nin its left-hand side. t1 is the return type of the call l1. In order to type values that mc retrieves \nfrom the popped activation, e.g., the value of x1, the type of l1 contains the type environment at the \ncall l1. Consequently, the type of l1 is: tparl1 = t1 is the type of the value that .ows at the boundary; \n tresl1 = t2 is the return type of the enclosing function;  Vl1 =[x1 .. tx1 ] binds types to the activation \nvariables.  In the example (Section 3), the types of labels are: L1..{tpar = int; tres = int; V =[fib \n.. int . int; n .. int]}L2..{tpar = int; tres = int; V =[fib .. int . int; n .. int; fn1 .. int]}Lroot..{tpar \n= int,tres = unit,V =[fib .. int . int]} As usual, when typing an application (APPLY), the two subex\u00adpressions \nare typed using the same hypotheses. The .rst subexpres\u00adsion must be a function accepting values of the \ntype of the second subexpression. The originality of our rule concerning application is the calculus \nof the type of the label. This type captures the type of the enclosing function t1, the current environment \nE and the type t3 that .ows at the label, i.e., the type of the result. Some constructs introduce frames \nand therefore modify the type of the enclosing function of a subexpression. For example, the type of \nthe enclosing function of e2 in setprompt<l> e1 e2 is t2 because the setprompt operator encloses e2 in \na frame whose prompt is of type t2 (see SETPROMPT in Figures 2 and 3). Typing a continuation expression \n(CONT) requires a speci.c type system. It is mutually recursive with the type system for terms. . The \njudgment E, P, L, t .. k : t1 -. t2 is similar to the one for terms. Most of the rules derive from the \ntype system for terms. For instance, the following rule is immediate from rule APPLY (Fig. 3): . E, P, \nL, t1 .. k : t2 -. (t3 . t4) E, P, L, t1 . v : t3 L (l)= {tpar = t4,tres = t1,V = E} APPLYL: . E, P, \nL, t1 .. <l> kv : t2 -. t4 We therefore omit the rules, except the following additional one for empty \ncontinuations: . HOLE: E, P, L, t1 .. . : t2 -. t2  4.4 Soundness We consider soundness as the conjunction \nof type preservation and progress, stated as follows. LEMMA 1 (Type preservation). Given a term e1 and \nan evaluation environment E such that T (E) , P, L, t1 . e1 : t2. If e1 reduces to e2 in E, then there \nexists an extension P . of P (.p and tp,P (p)= tp . P . (p)= tp) such that in P . , e2 has the same type \nas e1, i.e., T (E) ,P ., L, t1 . e2 : t2.  . (x .. t2) :: T (E) , P, L, t3 . e : t3 [] , P, L, t3 .. \nk : t2 -. t3 CONT: E, P, L, t1 . (.x.e, E): t2 . t3 PROMPT: E, P, L, t . p : P (p) prompt E, P, L, t1 \n. cont (k): t2 -. t3 (x .. t2) :: E, P, L, t3 . e : t3 CLOSURE: . ABS: VAR: E, P, L, t . x : E (x) \nE, P, L, t1 . .x.e : t2 . t3 (x1 .. t3 . t4) :: (x2 .. t3) :: E, P, L, t4 . e1 : t4 (x1 .. t3 . t4) :: \nE, P, L, t1 . e2 : t2 LETREC: E, P, L, t1 . let rec x1 = .x2.e1 in e2 : t2 E, P, L, t1 . e1 : t2 . t3 \nE, P, L, t1 . e2 : t2 L (l)= {tpar = t3,tres = t1,V = E} APPLY: E, P, L, t1 . <l> e1 e2 : t3 [] , P, \nL, P (p) . e : P (p) L (l)= {tpar = P (p) ,tres = t,V = E} E = T (E) T (E) , P, L, t1 . e : t2 FRAME: \nENV: E, P, L, t . frame<l>,E,pe : P (p) E, P, L, t1 . envE e : t2 [] , P, L, t2 . e : t2 L (l)= {tpar \n= t2,tres = t1,V = E} E = T (E) FRAME : E, P, L, t1 . frame<l>,E,.e : t2 NEWPROMPT: E, P, L, t1 . newprompt \n: t2 prompt . E, P, L, t1 . e1 : t3 -. t5 L (l)= {tpar = t3,tres = t4,V = E} .. x1 .. t3 -. t4 :: x2 \n.. t4 -. t5 :: (x3 .. E (x3)) :: E, P, L, t1 . e2 : t2 E, P, L, t1 . e3 : t2 E, P, L, t1 . e4 : t2 MC: \n E, P, L, t1 . mc e1 with (<l>,x1,x2,x3,e2) e3 e4 : t2 E, P, L, t1 . e1 : t3 prompt E, P, L, t1 . e2 \n: -.= t1,V = E} t2 . t3 . t3 L (l)= {tpar = t2,tres CAPTURE: E, P, L, t1 . capture<l> up to e1 with \ne2 : t2 . T (E) , P, L, t1 . v : t2 -. P (p) . P (p) L (l)= {tpar = t2,tres = t1,V = E} E = T (E) CAP: \n E, P, L, t1 . capup to p with v : t2 <l>,E . E, P, L, t1 . e1 : t3 -. t2 E, P, L, t1 . e2 : t3 L (l)= \n{tpar = t2,tres = t1,V = E} REINSTATE: E, P, L, t1 . reinstate<l> e1 e2 : t2 E, P, L, t1 . e1 : t2 prompt \nE, P, L, t2 . e2 : t2 L (l)= {tpar = t2,tres = t1,V = E} SETPROMPT: E, P, L, t1 . setprompt<l> e1 e2 \n: t2 Where T (E)=[x .. tx| [] , P, L, t .E (x): tx], i.e., function T computes a type environment from \nan evaluation environment. Figure 3. Type system for terms The existential quanti.cation of P . is the \ntechnique of Gunter et al. [17]6 in order to handle the newprompt case. Assume T (E) , P, L, t1 . newprompt \n: t2 prompt. newprompt reduces to a fresh prompt p in E. p is not in the domain of P . Hence choos\u00ading \nP . =(p .. t2) :: P trivially ensures type preservation. In the other cases, we systematically choose \nP . = P . Unlike usual proofs, we do not use a lemma showing that ex\u00adtending the environment would preserve \ntyping. Instead, we use a context invariance approach. While Pierce [30], Pierce et al. [31] do so for \npedagogical reasons, we have to because the standard weakening lemma is false due to the typing of call \nsites. Indeed, in L, the V .eld of the type associated with the label stores the typ\u00ading environment \n(rules APPLY, FRAME, FRAME , CAPTURE, CAP, REINSTATE and SETPROMPT). Hence adding new variables to the \n6 Gunter et al. [17] note e1/P1 . e2/P2, where P1 and P2 are sets of prompts. The . relation denotes \nthat given a typing environment over P1, there exists an extension over P2 such that e1 and e2 have the \nsame type in their respective prompt environments. Using our P and P . as typing environments (respectively \nover P1 and P2), the . relation is (part of) what our type preservation lemma states. environment, even \nif they do not occur free, may change label types in L. Intuitively, it would change the structure and \ncontent of stack frames, hence their types. Nevertheless, we must prove that the type of a value is independent \nof the context. LEMMA 2 (Typing values). Given a value v, the type of v is inde\u00adpendent of any context: \nE, P, L, t . v : tv, implies E., P, L, t . . v : tv for any E. and t . . This lemma is trivial following \nthe CLOSURE, PROMPT and CONT typing rules. Type preservation for the SUBST reduction rule is therefore \nimmediate. Restricting evaluation environments to values is a pragmatic solution to avoid any variable \ncapture issue upon substitution. In order to prove each of the other cases, we proceed in two stages. \nWe .rst show that in order to type subterms, the rules build exactly the same environment before and \nafter reduction. Hence reduction preserves the type of subterms. Then we use these results as premises \nof the typing rules for the reduced term. Let s sketch for instance the case of the APPLY reduction rule. \nBefore reduction, assuming the parameter v has type tv, the body  continuation k: . continuation ktail \n. : t2 -. tn t n tresl2 = t3 tparl2 = t2 continuation khead . : t1 -. tn t n t3 t2 t1 is split into: \n: t1 -. t2 tresl 1 = t2 tparl1 = t1 Figure 4. Intuition for typing activation boundary annotations. e \nof the closure is typed in the (x .. tv) :: T (E) environment and the return type of the enclosing function \nis te the type of e (CLOSURE typing rule). After reduction, it is typed in the environ\u00adment T ((x .. \nv) :: E) according to the FRAME and ENV typing rules. From the de.nition of T , and invoking the lemma \non typ\u00ading values, the two environments are equal. Hence the type of sub\u00adterm e is preserved. Using the \nENV and FRAME typing rules, we conclude that the type is the same before and after reduction. Last we \ncheck that the APPLY typing rule (before reduction) and the FRAME typing rule (after reduction) compute \nthe same label type for l. Hence the APPLY reduction rule preserves types. Traversing the evaluation \ncontext to the redex, evaluation rules CONTEXT, FRAME and ENV computeateachstepanewevaluation environment \nfor each subcontext. Typing rules do the same with typing environments. Along the path to the redex, \nwe observe that the rules recursivelly ensure that the evaluation and typing environments are equal up \nto T . This completes the proof. LEMMA 3 (Progress). Given e1 such that [] , P, L, t . e1 : t . Then \ne1 is either a value; or e1 is a runtime error (redex position is cap<>, up to p with v but it is not \nenclosed by any frame<>, ,p); or e1 reduces to some term e2 in the empty evaluation environment. In order \nto prove progress, we inductively analyze the typing rules. This proof is classical. The proofs have \nbeen mechanized using the Coq theorem prover and the library of Aydemir et al. [6], which together help \nto do machine-veri.ed formal proofs on language semantics and type systems. For commodity reason, our \nCoq scripts differ in the fol\u00adlowing from the system of this paper. We explode the MCMATCH, MCMATCH , \nCAP1/CAP2and REINSTATE reductionrulesintode\u00adtailed small steps. For example, we instantiate the CAP2 \nfor each operator in the language k of evaluation contexts. For this purpose, we introduce additional \ndummy operators for in-progress mc and reinstate. In addition, the implementation of the mc operator \nhas to look for the innermost (frame) operator of the continuation operand. Instead, it is much more \nconvenient to reverse the nesting of operators in the continuation. At the cost of yet another dummy \noperator and of additional rules, we therefore represent continua\u00adtions inside out. We use the technique \nof Gunter et al. [17] to im\u00ad plement the freshness of instantiated prompts. Last, we move from the grammar \nto the type system the constraint on the form of con\u00adtinuations (bottom of Fig. 1).  4.5 Alternatives \nOne of the constraints that guides our work is to leave unchanged the application compiler. The rationale \nbehind this constraint is that it makes it easier to integrate the ReCaml approach into existing compilers. \nTo ful.ll this constraint, we need to accommodate the choices done in legacy compilers. We identify several \nalternatives that shall impact dynamic updates. In the following, we present how these points integrate \nour formal system. We focus on the speci.cities of our language. Hence we do not discuss variations, \ne.g., of the continuation framework, which have already been stud\u00adied by Dybvig et al. [13]. Usually, \nthe implementation of execution states is not of great interest in the design of a language. This issue \nregards the compiler. But because ReCaml focuses on modelling state manipulations, we have to take into \nconsideration the implementation. For instance, label types depend on the context, and therefore on captured \nenvi\u00adronments when building closures. Regarding variables, we implement the following rules in the semantics \nand type system: When a closure is built, it captures all the variables in the scope of which the . \noperator lies, regardless these variables occur free in the body of the function.  The parameter of \na function is systematically added to the evaluation environment, regardless it occurs free in the body \nof the function. We do the same for let rec.  This is a coarse behavior. Indeed, many compilers optimize \nclosures in order to capture only the variables that occur free. In order to model this behavior in ReCaml, \nwe can replace the CLOSE reduction rule with the following one: RESTRICT-CLOSE: E. .x.e . (.x.e, restricte \n(E)) where restrict computes the restriction of the environment, e.g., [x .. E (x) |x . fv (e)] to capture \nonly the variables that occur free in the body. We have to change the type system accordingly, replacing \nABS with: (x .. t2) :: restricte (E) , P, L, t3 . e : t3 RESTRICT-ABS: E, P, L, t1 . .x.e : t2 . t3 Type \nsoundness obviously still holds. This implementation does the restriction when the closure is built. \nThis is what happens in many compilers. Instead, we could have delayed the restriction until application, \nhence insert\u00ading restrict in the APPLY reduction rule and in the CLOSURE and ABS typing rules. As of \nReCaml, both implementations have the same behavior. We can also restrict parameters and let rec\u00adbound \nvariables using the same technique. Accurate modelling of the variables is important as it impacts type \nlabels and the amount of values the mc operator is able to retrieve from continuations. Other aspects, \nsuch as tail-call opti\u00admization and function inlining, impact when new stack frames are created. Consequently, \nthey (indirectly) impact the outcome of the mc operator as well. Tail-call optimization consists in destroying \nthe calling activa\u00adtion at the time of a call when it occurs at the return position. We can implement \nthis optimization thanks to additional rules, e.g., du\u00adplicating the APPLY reduction rule for the speci.c \ncase, such that it does not insert any new frame operator. Possibly, there are also several env constructs \nthat must collapse with the stack frame. k contains only (0 or more) env TAIL-APPLY: E. frame<l1>,E1,p. \n(k [<l2> (.x.e, E2) v]) 1.. . frame<l1>,E1,p. env(x..v)::E2 e 1 Notice that the frame in the right-hand \nside is the exact copy of the left-hand side one. Indeed, the properties of the enclosing stack frame \n(return address, local environment) are unaffected. In order to handle inlined calls, the idea is coarsely \nthe same, without any constraint on the context of the call. Nevertheless, there  pending arguments \nreturn address, environment &#38; number of pending arguments above the stack frame local variables &#38; \narguments  stack growing to the right Figure 5. Structure of the stack in the virtual machine. number \nof pending arguments: #pa =0 #pa = 1 #pa =0  l5, #pa = 0 Figure 6. Splitting a continuation. are additional \ndif.culties: call sites within the inlined function are replicated; the environment of the caller and \ncallee environments shall merge. We do not run into deeper details in this paper, leaving the issues \nto further contributions. 5. Compiler Implementation As a proof of concept, we have developed a prototype \ncompiler of ReCaml, which targets a modi.ed ZAM2 [23] virtual machine. The machine has a single stack \nfor locals, function arguments, register backup and return addresses. In addition to the stack pointer, \nthe machine has 4 registers: the program counter points at the next instruction to execute;  the environment \npoints at the values stored in the closure;  the argument counter tells how many pending arguments have \nbeen pushed, as the machine implements the push / enter uncur\u00adrying technique [27];  the accumulator \nholds an intermediate result.  As shown in Figure 5, stack frames are delimited by blocks that save \nthe return program counter, the environment and the argu\u00adment counter registers. Pending arguments, if \nany (possibly 0), are pushed immediately above this block. The virtual machine provides a speci.c instruction \nfor tail calls. Like our TAIL-APPLY rule (Sec\u00adtion 4.5), this instruction pops the local environment; \nit pushes a new one; and it branches to the body of the callee. The push / en\u00adter uncurrying technique \nlets the caller of a function push all the available arguments onto the stack. The callee is responsible \nof popping only those it can immediately handle (or to build a partial\u00adapplication closure if there are \nnot enough parameters on the stack). While there are some pending arguments on the stack, the return \ninstruction assumes that the return value is a closure, and makes a call. When all the pending arguments \nare consumed, the instruction returns back to the caller. We extend the virtual machine to support continuations. \nA con\u00adtinuation is implemented as a slice of the machine stack with a copy of the argument counter register. \nOther registers (program counters, closure environment and accumulator) are saved within the slice of \nthe stack by the generated code as required by the ZAM2. A prompt is a pointer to a position in the stack. \nThe capture operator copies to the heap the slice between the prompt and the top of the stack; it saves \nthe argument counter; and it makes a call to the body func\u00adtion. The reinstate operator copies from the \nheap back to the stack; it restores the argument counter; and it performs a return instruction with the \nargument. In addition to retrieving the stack pointer, setting a prompt makes a call such that the lower \nbound of a continuation is always aligned with a stack frame boundary, consistently with our semantics. \nBased on this implementation of continuations, the mc operator .rst checks whether the continuation is \nempty. If not, it uses the recorded number of pending arguments in order to skip data down to the .rst \nreturn address. The retrieved address is compared with the operand of the mc operator. Static knowledge \ngives the structure and size of the matching stack frame at the top of the continuation. This information \nallows to split the continuation at the stack frame boundary and retrieve values from the popped stack \nframe. Tail call optimization does not need any special treatment. In\u00addeed, activation annotations of \ntail calls simply never match as there is no corresponding location in the code. In order to handle currying, \nthe generated code uses the recorded number of pending arguments in order to .nd the location of the \nreturn address. Pending arguments are simply skipped, as if the callee was .-expanded according to the \ncall. Following the same principle, arguments between the two subcontinuations belong to the tail. Therefore, \nthe number of pending arguments has to be adjusted in subcontinuations like in Figure 6. In the head \nsubcon\u00ad tinuation, the number of pending arguments in the stack frame is set to 0, as there is no pending \nargument below the stack frame. In the tail subcontinuation, the number of pending arguments on top of \nthe stack comes from the popped stack frame (1 in the example). As Marlow and Peyton-Jones [27] have \npreviously noticed, the push / enter uncurrying technique is not the most favorable setup in order to \nwalk the stack, which is what our mc operator achieves. More precisely, we remark that problems arise \nonly when push / enter is combined with tail call optimization. Assume the following code: let f2 = .a. \ncapture<l5> up to p with v in let f1 = .a..b. (<l4> (<l3> f2 x3) x4) in let x = <l2> (<l1> f1 x1) x2 \nin e As uncurrying is done, l1 and l2 (resp. l3 and l4) refer to the same code location. They differ \nin the number of pending arguments above the return address, respectively 0 and 1. Due to tail call opti\u00admization, \nl1 and l3 (resp. l2 and l4) cannot be distinguished. Given the above description of the compiler, the \ncaptured continuation is split like in Figure 6. If the tail subcontinuation is subsequently compared \nto l1, it matches as there is 1 pending argument. Our for\u00admal system assumes that the type of the produced \nhead subcontin\u00ad . uation is (tx2 . tx) -. t. However, its effective (runtime) type is . (tx4 . tx) -. \nt. The problem arises because, due to tail call opti\u00admization, there is no means at this point to know \nwhere the pending parameter comes from, i.e., to distinguish between l1 and l3. Since our formal system \ndoes not implement uncurrying or tail\u00adcall optimization, it does not raises the problem, consistently \nwith our type soundness result. Indeed, our formal system produces the following continuation, which \nis different from Figure 6: let x = frame<l2>,r,p (<l4> (frame<l3>,r,p.) x4) in e Notice that this continuation \nis actually the same as the one an eval / apply compiler would produce: as the arity of the f2 closure \nis 1, l4 is not applied and l3 is not a tail call. In order to solve this problem in our prototype, we \nsimply prevent uncurrying tail calls. Alternatively, we could have implemented the push / enter technique \nin our formal system, for instance extending our frame operator with pending arguments. We have identi.ed \nthe following options the mc operator can handle pending arguments: Pending arguments can go to the tail \nsubcontination, as depicted in Figure 6 and described earlier in this section. Adding tail  1 2 3 4 \n5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \n41 p r o m p t p . (* ***************************************** *) (* I ni ti a l v er s io n *) le t \nre c f ib n = if n<2 t h e n n e l s e ( l et fn 1 = <L1>fib ( n-1) in l et fn 2 = <L2>fib ( n-2) in \nfn1 + f n2 ) in (* ***************************************** *) (* New ve rs i on *) le t re c f i b \nn u m n = if n<2 t h e n n u m o f i n t n e l s e ( l et fn 1 = f i b n u m ( n-1) in l et fn 2 = f \ni b n u m ( n-2) in fn1 +/ fn2 ) in (* ***************************************** *) (* u pda t e from \nfixed-size to ar bi t ra ry *) (* pr e c i si o n in te ger *) (* if n is after 44 , r has o ve r fl \no we d so *) (* r etu r n f i b n e w n else r is co r re ct *) le t i f n o t o v e r n r = if n>44 \nt h e n f i b n u m n e l s e n u m o f i n t r in (* call graph : *) (* fib : L1 . fib *) (* fib : L2 \n. fib *) (* [ root ]: Lroot . fib *) (* : Lupdt . upd ate *) (* to the fib node in the call graph : *) \nle t re c m a t c h f i b c a l l e r s r k = m a t c h c o n t k w i t h (* - L1 : r is fib (n-1) *) \n<L1 : n> :: tl . le t fn2 = f i b n u m ( n-2) in (* back to the c a lle r : fib *) m a t c h f i b c \na l l e r s ( r +/ fn2 ) tl (* - L2 : r is fib (n-2) &#38; fn1 is fib (n-1) *) | <L2 : n fn1> :: tl . \n(* ch e c k wh e th er fn1 has o v er f lo w ed *) le t n f n 1 = i f n o t o v e r ( n-1) fn 1 in 42 \n43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 \n77 78 79 80 81 82 (* back to the c alle r : fib *) m a t c h f i b c a l l e r s ( nfn 1 +/ r ) tl (* \n- Lroot : r is the res u lt of the p ro gr am *) | <Lro ot> :: tl . r e i n s t a t e tl r | . (* erro \nr *) (0/ -/1/) in le t m a t c h f i b c a l l e r s r k = m a t c h c o n t k w i t h (* - L1 : r is \nfib (n-1) *) <L1 : n> :: tl . (* c h eck wh eth er r has ov e rf l ow e d *) le t fn1 = i f n o t o v \ne r (n-1) r in le t fn2 = f i b n u m ( n-2) in (* back to the c alle r : fib *) m a t c h f i b c a \nl l e r s ( f n1 +/ fn 2 ) tl (* - L2 : r is fib (n-2) &#38; fn1 is fib ( n-1) *) | <L2 : n fn1> :: tl \n. (* c h eck wh eth er fn1 has o v e r f lo w ed *) le t n f n 1 = i f n o t o v e r ( n-1) fn1 in (* \nc h eck wh eth er r has ov e rf l ow e d *) le t n f n 2 = i f n o t o v e r ( n-2) r in (* back to the \nc alle r : fib *) m a t c h f i b c a l l e r s ( nfn 1 +/ nf n 2 ) tl (* - Lroot : r is the res u lt \nof the p ro gr am *) | <Lro ot> :: tl . r e i n s t a t e tl ( i f n o t o v e r 1 2 3 4 5 r ) | . (* \nerro r *) (0/ -/1/) in (* c o m p e n sa t i on fib . f i b n u m *) le t c o m p e n s a t e r k = m \na t c h c o n t k w i t h (* we \" know \" that we are in fib *) <Lup dt> :: tl . m a t c h f i b c a l \nl e r s r tl | . (* erro r *) (0/ -/2/) in (* ***************************************** *) (* main p \nro g ra m *) (* re gi st er the c o m p e n s a t i o n *) le t = s e t u p d a t e r o u t i n e ( fu \nn r . ca p tur e<Lupdt> u pto p as k in c o m p e n s a t e r k ) in (* in i ti al call *) n u m o f \ni n t (<Lroot>fi b 1 2 3 4 5 ) Figure 7. Real ReCaml code: from .xed-size to arbitrary precision integers. \ncall optimization breaks type preservation for call site labels because each tail call can push new pending \nparameters with types different than those previously popped from the stack; and the types of pending \narguments appear in label types. Hence we con.rm what Marlow and Peyton-Jones [27] say with a stronger \nargument: push / enter with tail-call optimization and mc-like stack-walking is not type-sound. Pending \narguments can go to the head subcontinuation. In this case, the type of the subcontinuations depends \non how many arguments are pending on the stack. In the example, we would have to discriminate between \nl5 / no pending argument, l5 / 1 pending argument, and so on.  Pending arguments can be dropped. In \nthis case, part of the calculation captured by the original continuation is lost.  Nevertheless, notice \nthat the updated program actually walks the stack. We feel that one of the weaknesses of our current \napproach is that our mc operator handles one stack frame independently of any context. We leave the issue \nfor future works. 6. Detailed Example Figure 7 contains the full source code that updates fib from int \nto num. The set update routine primitive (line 78) registers the L1 root of Lroot compensate execution \nLupdt L2 Figure 8. Static call graph of the program Figure 7. function that is called when the virtual \nmachine receives an update signal. In addition we use the following syntactic sugar: line 1 prompt p \n. e .. let p = newprompt in (setprompt<> p e) line 79 capture<Lupdt> upto p as k in e .. captureup to \np with .k.e <Lupdt> The captured continuation corresponds to a path in the static call graph of the program \n(Figure 8) going from the root of ex\u00ad ecution to the compensation. The compensation is implemented by \nthe compensate function (line 70). As represented by the dashed Lupdt edge in the call graph, the top \nstack frame is an activation of the anonymous function (line 79) registered by the set update routine \nprimitive. It comes from the update infras\u00adtructure. Hence line 70, match cont pops this useless stack \nframe before entering the effective compensation. In a more realistic ap\u00adplication, we would have to \n.nd out which function the update is called from. In the example, as it can only be the fib function \nthe compensation calls the match fib callers function (lines 47 67) to handle the calls to fib according \nto the strategy described in Section 2.2:  L1 The compensation function receives the result of fib (n-1). \nUsing ifnotover, we ensure that it is correct (line 52). Notice that if the result has over.owed, the \nfunction ifnotover re\u00adcomputes the Fibonacci number using the new version (line 23). To complete the \nfib function, we compute fib (n-2) with the new version (line 53) then we sum the two results (line 55). \nLast, we recursively compensate the tail of the continuation (line 55) as if the popped stack had returned \nthe newly com\u00adputed value. L2 The compensation function receives the result of fib (n-2). Futhermore, \nthe match cont gets the value of fib (n-1) from the call stack frame naming it fn1. Using the ifnotover \nfunction, we ensure that those intermediate results are correct (lines 58 61). Last we complete the fib \nfunction and we recur\u00adsively compensate the tail of the continuation (line 63). Lroot At this point, \nr is fib 12345 and the compensation has completed. We use ifnotover to ensure r is correct before reinstating \nthe tail subcontinuation (line 66). The match fib callers function (lines 31 46) is almost a clone of \nmatch fib callers, except that it assumes the compensation has already dealt correctly with the received \nresult (parameter r). So recursive calls in match fib callers do in fact switch to match fib callers \n. In these functions, we assume that (1) the evaluation order is known, i.e., that fib (n-1) is evaluated \nbefore fib (n-2); and (2) intermediate results have names. To make this explicit, we use let. Instead, \nintermediate results could have had system-generated or a posteriori names. The evaluation order shall \nbe inferred by the compensation. Because we have not integrated any exception handling in our prototype, \na negative number is returned (lines 46, 67 and 73) to notify errors. Runtime errors can occur if the \ncontinuation does not match, when the update developer forgets to handle some call sites. 7. Discussions \nand Conclusions In this paper, we have presented two dynamic software updates (Sec. 2 though only one \nexample is detailed in Sec. 6 and Fig. 7) that many current systems are unable to implement. Even if \nwe con\u00adsider a toy example, we have argumented that the technique is still relevant in realistic applications. \nDespite the apparent simplicity of our use case, the two updates show high complexity both in design \nand in implementation. These examples contrast with the usual sim\u00adple updates of complex applications \nin related works. In our work, we accept that updates might be dif.cult to design and implement. We have \n.rst focused in this paper on being able to achieve these updates. Still, we acknowledge that our current \nproposal is not very handy yet. In the context of a similar approach, Makris and Bazzi [25] have for \ninstance proposed automatic generators for some of the updates, which could be used as building blocks \nfor a higher level update language. The ReCaml language is the cornerstone of our work. It pro\u00advides \nan operator (match cont or mc) in order to introspect and walk continuations. Our examples have indeed \nemphasized how this operation helps in updating. We have formalized its environment-based semantics and \nde.ned a type system whose soundness is proved mechanicaly. Even if we have not discussed it in this \npaper, we have also developed a sound substitution\u00adbased semantics. Our prototype compiler of ReCaml \nis able to execute all the updates of Section 2. The two examples of this article, the compiler and proofs \n(the coq scripts) can be found at http://perso.telecom-bretagne.eu/fabiendagnat/recaml. In this paper, \nwe have built ReCaml on top of a simply typed .\u00adcalculus for simplicity reasons. It is well known that \npolymorphism with continuations needs restrictions in order to ensure sound\u00adness [5, 24, 35, 37]. As \nthe mc operator splits continuations at ac\u00adtivation boundaries, any type variable involved in an application \nmight cause problems if it is generalized. One of the future chal\u00adlenges is therefore to reconcile ReCaml \nwith polymorphism and to infer more precise types. We have adopted a strict functional language and the \nZAM2 virtual machine [23]. The ZAM2 machine has allowed us quick and easy prototyping. Strict evaluation \nhas made it easier to un\u00adderstand and therefore to manipulate the execution state. Unlike similar approaches \n[20, 25], ReCaml does not require any speci.c code generation. Instead, relying on low level details \nof the under\u00adlying machine, it is adapted to the form of the code generated by the legacy Caml compiler. \nUsing continuations is not a necessity. Yet it provides sound formal foundations for our work. As works \nthat provide production level JVM and CLR with continuations [29, 32] use speci.c code generation, targeting \nsuch machines might not be in the scope of ReCaml. On the contrary, call site types are actually close \nto usual debug information. Therefore the debugging infras\u00adtructures of JVM and CLR could be used to \nimplement ReCaml for these platforms. While these infrastructures provides mecha\u00adnisms to manipulate \nstates, ReCaml brings static typing. We there\u00adfore plan experiences to ensure that our approach also \n.ts these platforms. To do so, we will have to enhance ReCaml to support imperative features, especially \nshared data. We will also have to consider multithreading, reusing previous work such as [25]. Acknowledgments \nWe would like to kindly thank Kristis Makris and Ralph Matthes for their comments. We also thank Michael \nHicks for shepherding the revision of the paper. The work presented in this paper has been partly funded \nby the French ministry of research through the SPaCIFY consortium (ANR 06 TLOG 27). References [1] Gautam \nAltekar, Ilya Bagrak, Paul Burstein, and Andrew Schultz. Opus: online patches and updates for security. \nIn USENIX Secu\u00adrity Symposium, pages 287 302, Baltimore, Maryland, USA, August 2005. [2] Pascalin Amagb\u00b4egnon, \nLo\u00a8ic Besnard, and Paul Le Guernic. Imple\u00admentation of the data.ow synchronous language SIGNAL. ACM SIGPLAN \nNotices, 30(6):163 173, June 1995. doi: 10.1145/223428. 207134. [3] Jonathan Appavoo, Kevin Hui, Craig \nSoules, Robert Wisniewski, Dilma Da Silva, Orran Krieger, Marc Auslander, David Edelsohn, Ben Gamsa, \nGregory Ganger, Paul McKenney, Michal Ostrowski, Bryan Rosenburg, Michael Stumm, and Jimi Xenidis. Enabling \nautonomic behavior in systems software with hot swapping. IBM Systems Jour\u00adnal, 42(1):60 76, 2003. [4] \nJeff Arnold and M. Frans Kaashoek. Ksplice: automatic rebootless kernel updates. In European Conference \non Computer Systems, pages 187 198, Nuremberg, Germany, April 2009. doi: 10.1145/1519065. 1519085. [5] \nKenichi Asai and Yukiyoshi Kameyama. Polymorphic delimited con\u00adtinuations. In Asian Symposium on Programming \nLanguages and Sys\u00adtems, volume 4807 of LNCS, pages 239 254, Singapore, December 2007. doi: 10.1007/978-3-540-76637-7 \n16. [6] Brian Aydemir, Aaron Bohannon, Benjamin Pierce, Jeffrey Vaughan, Dimitrios Vytiniotis, Stephanie \nWeirich, and Steve Zdancewic. Using proof assistants for programming lan\u00adguage research or, how to write \nyour next popl paper in coq. http://www.cis.upenn.edu/~plclub/popl08-tutorial/, 2008. POPL 2008 tutorial. \n [7] Andrew Baumann, Jonathan Appavoo, Robert Wisniewski, Dilma Da Silva, Orran Krieger, and Gernot \nHeiser. Reboots are for hardware: challenges and solutions to updating an operating system on the .y. \nIn USENIX Annual Technical Conference, Santa Clara, California, USA, June 2007. [8] Gavin Bierman, Michael \nHicks, Peter Sewell, Gareth Stoyle, and Keith Wansbrough. Dynamic rebinding for mashalling and update, \nwith destruct-time .. In International Conference on Functional Programming, pages 99 110, Uppsala, Sweden, \nAugust 2003. doi: 10.1145/944705.944715. [9] Eric Bruneton, Thierry Coupaye, Matthieu Leclerq, Vivien \nQu\u00b4 ema, and Jean-Bernard Stefani. The Fractal component and its support in java. Software: Practice \n&#38; Experience, special issue on experiences with auto-adaptive and recon.gurable systems, 36(11-12):1257 \n1284, September 2006. doi: 10.1002/spe.767. [10] J\u00b4er\u00b4emy Buisson and Fabien Dagnat. Introspecting continuations \nin order to update active code. In Workshop on Hot Topics in Software Upgrades, Nashville, Tennessee, \nUSA, October 2008. doi: 10.1145/ 1490283.1490289. [11] Acacio Cruz. Of.cial Gmail Blog: Update on today \ns Gmail outage. http://gmailblog.blogspot.com/2009/02/ update-on-todays-gmail-outage.html, February 2009. \n[12] Mikhail Dmitriev. Safe class and data evolution in large and long-lived java applications. Technical \nReport TR-2001-98, Sun Microsystems, August 2001. [13] Kent Dybvig, Simon Peyton-Jones, and Amr Sabry. \nA monadic framework for delimited continuations. Journal of Functional Programming, 17(6):687 730, November \n2007. doi: 10.1017/ S0956796807006259. [14] Ericsson AB. Erlang 5.6.3 Reference manual, chapter 12. Compi\u00adlation \nand code loading. 2008. http://www.erlang.org/doc/ reference_manual/part_frame.html. [15] Matthias Felleisen. \nThe theory and practice of .rst-class prompts. In Principles of Programming Languages, pages 180 190, \nSan Diego, California, USA, January 1988. doi: 10.1145/73560.73576. [16] Stephen Gilmore, Dilsun Kirli, \nand Christopher Walton. Dynamic ML without dynamic types. Technical Report ECS-LFCS-97-379, University \nof Edinburgh, December 1997. [17] Carl A. Gunter, Didier R\u00b4emy, and Jon G. Riecke. A generalization of \nexceptions and control in ML-like languages. In International Conference on Functional Programming Languages \nand Computer Architecture, pages 12 23, La Jolla, California, USA, June 1995. doi: 10.1145/224164.224173. \n[18] Deepak Gupta, Pankaj Jalote, and Gautam Barua. A formal framework for on-line software version change. \nIEEE Transactions on Software Engineering, 22(2):120 131, February 1996. doi: 10.1109/32.485222. [19] \nJennifer Hamilton, Michael Magruder, James Hogg, William Evans, Vance Morrison, Lawrence Sullivan, Sean \nTrowbridge, Jason Zander, Ian Carmichael, Patrick Dussud, John Hamby, John Rivard, Li Zhang, Mario Chenier, \nDouglas Rosen, Steven Steiner, Peter Hallam, Brian Crawford, James Miller, Sam Spencer, and Habib Heydarian. \nMethod and system for program editing and debugging in a common language runtime environment. Patent \nUS7516441, Microsoft Corporation, April 2009. [20] Christine Hofmeister and James Purtilo. Dynamic recon.guration \nin distributed systems: adapting software modules for replacement. In International Conference on Distributed \nComputing Systems, pages 101 110, Pittsburgh, Pennsylvania, USA, May 1993. doi: 10.1109/ ICDCS.1993.287718. \n[21] Oleg Kiselyov. How to remove a dynamic prompt: static and dynamic delimited continuation operators \nare equally expressible. Technical Report TR611, Indiana University, March 2005. [22] Jeff Kramer and \nJeff Magee. The evolving philosophers problem: dy\u00adnamic change management. IEEE Transactions on Software \nEngineer\u00ading, 16(11):1293 1306, November 1990. doi: 10.1109/32.60317. [23] Xavier Leroy. The ZINC experiment, \nan economical implementation of the ML language. Technical Report 117, INRIA, 1990. [24] Xavier Leroy. \nPolymorphism by name for references and con\u00adtinuations. In Principles of Programming Languages, pages \n220 231, Charleston, South Carolina, USA, January 1993. doi: 10.1145/ 158511.158632. [25] Kristis Makris \nand Rida Bazzi. Multi-threaded dynamic software updates using stack reconstruction. In USENIX Annual \nTechnical Conference, San Diego, California, USA, June 2009. [26] Kristis Makris and Kyung Dong Ryu. \nDynamic and adaptive updates of non-quiescent subsystems in commodity operating system kernels. In European \nConference on Computer Systems, pages 327 340, Lis\u00adboa, Portugal, March 2007. doi: 10.1145/1272996.1273031. \n[27] Simon Marlow and Simon Peyton-Jones. Making a fast curry: push/enter vs eval/apply for higher-order \nlanguages. Journal of Func\u00adtionnal Programming, 16(4-5):415 449, July 2006. doi: 10.1017/ S0956796806005995. \n[28] Iulian Neamtiu, Micheal Hicks, Gareth Stoyle, and Manuel Oriol. Practical dynamic software updating \nfor C. In Conference on Pro\u00adgramming Language Design and Implementation, pages 72 83, Ot\u00adtawa, Ontario, \nCanada, June 2006. doi: 10.1145/1133981.1133991. [29] Greg Pettyjohn, John Clements, Joe Marshall, Shriram \nKrishnamurthi, and Matthias Felleisen. Continuations from generalized stack inspec\u00adtion. In International \nConference on Functional Programming, pages 216 227, Tallinn, Estonia, September 2005. doi: 10.1145/1090189. \n1086393. [30] Benjamin Pierce. Lambda, the ultimate TA: Using a proof assistant to teach programming \nlanguage foundations, September 2009. Keynote address at International Conference on Functional Programming. \n[31] Benjamin Pierce, Chris Casinghino, and Michael Greenberg. Software foundations. 2010. http://www.cis.upenn.edu/~bcpierce/ \nsf/. [32] Tiark Rompf, Ingo Maier, and Martin Odersky. Implementing .rst\u00adclass polymorphic delimited \ncontinuations by a type-directed selec\u00adtive CPS transform. In International Conference on Functional \nPro\u00adgramming, Edinburgh, Scotland, UK, September 2009. doi: 10.1145/ 1596550.1596596. [33] Peter Sewell, \nGareth Stoyle, Michael Hicks, Gavin Bierman, and Keith Wansbrough. Dynamic rebinding for marshalling \nand up\u00addate, via redex-time and destruct-time reduction. Journal of Func\u00adtional Programming, 18(4):437 \n502, July 2008. doi: 10.1017/ S0956796807006600. [34] Chung-Chieh Shan. Shift to control. In ACM SIGPLAN \nScheme Workshop, Snowbird, Utah, USA, September 2004. [35] Mads Tofte. Type inference for polymorphic \nreferences. Informa\u00adtion and computation, 89(1):1 34, November 1990. doi: 10.1016/ 0890-5401(90)90018-D. \n[36] Yves Vandewoude, Peter Ebraert, Yolande Berbers, and Theo D Hondt. Tranquility: a low disruptive \nalternative to quiescence for ensuring safe dynamic updates. IEEE Transactions on Software En\u00adgineering, \n33(12):856 868, December 2007. doi: 10.1109/TSE.2007. 70733. [37] Andrew Wright. Polymorphism for imperative \nlanguages without im\u00adperative types. Technical Report TR93-200, Rice University, February 1993.   \n\t\t\t", "proc_id": "1863543", "abstract": "<p>To fix bugs or to enhance a software system without service disruption, one has to update it dynamically during execution. Most prior dynamic software updating techniques require that the code to be changed is not running at the time of the update. However, this restriction precludes any change to the outermost loops of servers, OS scheduling loops and recursive functions. Permitting a dynamic update to more generally manipulate the program's execution state, including the runtime stack, alleviates this restriction but increases the likelihood of type errors. In this paper we present ReCaml, a language for writing dynamic updates to running programs that views execution state as a delimited continuation. ReCaml includes a novel feature for introspecting continuations called match_cont which is sufficiently powerful to implement a variety of updating policies. We have formalized the core of ReCaml and proved it sound (using the Coq proof assistant), thus ensuring that state-manipulating updates preserve type-safe execution of the updated program. We have implemented ReCaml as an extension to the Caml bytecode interpreter and used it for several examples.</p>", "authors": [{"name": "J&#233;r&#233;my Buisson", "author_profile_id": "81309508106", "affiliation": "Universit&#233; Europ&#233;enne de Bretagne / Ecoles de St-Cyr Co&#235;tquidan / VALORIA, Guer, France", "person_id": "P2338141", "email_address": "", "orcid_id": ""}, {"name": "Fabien Dagnat", "author_profile_id": "81331490732", "affiliation": "Universit&#233; Europ&#233;enne de Bretagne / Institut T&#233;l&#233;com / T&#233;l&#233;com Bretagne, Brest, France", "person_id": "P2338142", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863550", "year": "2010", "article_id": "1863550", "conference": "ICFP", "title": "ReCaml: execution state as the cornerstone of reconfigurations", "url": "http://dl.acm.org/citation.cfm?id=1863550"}