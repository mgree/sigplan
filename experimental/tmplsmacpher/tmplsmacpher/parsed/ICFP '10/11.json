{"article_publication_date": "09-27-2010", "fulltext": "\n Logical Types for Untyped Languages * Sam Tobin-Hochstadt Matthias Felleisen Northeastern University \n {samth,matthias}@ccs.neu.edu Abstract Programmers reason about their programs using a wide variety of \nformal and informal methods. Programmers in untyped languages such as Scheme or Erlang are able to use \nany such method to reason about the type behavior of their programs. Our type system for Scheme accommodates \ncommon reasoning methods by assigning variable occurrences a subtype of their declared type based on \nthe predicates prior to the occurrence, a discipline dubbed occurrence typing. It thus enables programmers \nto enrich existing Scheme code with types, while requiring few changes to the code itself. Three years \nof practical experience has revealed serious short\u00adcomings of our type system. In particular, it relied \non a system of ad-hoc rules to relate combinations of predicates, it could not rea\u00adson about subcomponents \nof data structures, and it could not fol\u00adlow sophisticated reasoning about the relationship among predicate \ntests, all of which are used in existing code. In this paper, we reformulate occurrence typing to eliminate \nthese shortcomings. The new formulation derives propositional logic formulas that hold when an expression \nevaluates to true or false, respectively. A simple proof system is then used to determine types of variable \noccurrences from these propositions. Our imple\u00admentation of this revised occurrence type system thus \ncopes with many more untyped programming idioms than the original system. Categories and Subject Descriptors \nD.3.3 [Programming Lan\u00adguages]: Language Constructs and Features General Terms Languages Keywords Type \nsystems, Untyped languages, Logic 1. Reasoning about Untyped Languages Developing programs in a typed \nlanguage helps programmers avoid mistakes. It also forces them to provide some documentation, and it \nestablishes some protective abstraction barriers. As such, the type system imposes a discipline on the \nprogramming process. Nevertheless, numerous programmers continue to choose un\u00adtyped scripting languages \nfor their work, including many who work in a functional style. When someone eventually decides that explic\u00aditly \nstated type information reduces maintenance cost, they face a * This research was partially supported \nby grants from the US NSF and a donation from the Mozilla Foundation. Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, \nMaryland, USA. Copyright c . 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 dilemma. To address this situation, \nwe need to develop typed sis\u00adter languages for untyped languages. With those, programmers can enrich \nexisting programs with type declarations as needed while maintaining smooth interoperability. A type \nsystem for an existing untyped language must accommo\u00addate the existing programming idioms in order to \nkeep the cost of type enrichment low. Otherwise, type enrichment requires changes to code, which may \nintroduce new mistakes. Put positively, the ideal typed sister language requires nothing but the addition \nof type speci.cations to function headers, structure de.nitions, etc. Our experience shows that programming \nidioms in untyped functional languages rest on a combination of traditional type\u00adbased reasoning with \nreasoning about control .ow. In particular, conditionals and data-type predicates are used to establish \nthe na\u00adture of variables values, and based on this .ow-sensitive reasoning, programmers use variables \nat more speci.c types than expected. Put differently, the programmer determines the type of each vari\u00adable \noccurrence based on the predicates that .ow-dominate it. Multiple researchers over the decades have discovered \nthis in\u00adsight. In his paper on the static analysis of untyped programs, Reynolds [1968] notes that such \nreasoning is necessary, stating that in future systems, some account should be taken of the premises \nin conditional expressions. In his work on TYPED LISP, Cartwright [1976, \u00a75] describes having to abandon \nthe policy of rejecting type\u00adincorrect programs because the variables in conditionals had overly broad \ntypes. Similarly, in their paper on translating Scheme to ML, Henglein and Rehof [1995] state type testing \npredicates aggravate the loss of static type information since they are typically used to steer the control \n.ow in a program in such a fashion that execution depends on which type tag an object has at run-time. \nWe exploited this insight for the development of Typed Scheme, a typed sister language for Racket (formerly \nPLT Scheme) [Tobin-Hochstadt and Felleisen 2008]. Its type system combines several preexisting elements \ntrue recursive union types, subtyping, polymorphism with the novel idea of occurrence typing,1 a type \ndiscipline for exploiting the use of data-type predicates in the test expression of conditionals. Thus, \nif a test uses (number? x), the type system uses the type Number for x in the then branch and the declared \ntype of x, minus Number, otherwise. Three years of extensive use have revealed several shortcom\u00adings \nin our original design. One signi.cant problem concerns con\u00adtrol .ow governed by logical combinations \n(e.g., and, or, not) of predicate tests. Another is that the type system cannot track uses of predicates \napplied to structure selectors such as car. This lack of expressiveness in the type system is due to \nfun\u00addamental limitations. First, our original system does not consider asymmetries between the then and \nelse branches of conditionals. For example, when the expression (and (number? x)(> x 100)) is true, the \ntype system should know that x is a number, but x might or 1 Komondoor et al. [2005] independently coined \nthe term occurrence typ\u00ading in the context of providing an advanced type system for COBOL.  might not \nbe a number when the expression is false, since it might be 97 or \"Hello\". Second, the type system does \nnot appropriately distinguish between selector expressions such as (car x) and predi\u00adcate expressions \nsuch as (number? x). Third, the treatment of com\u00adbinations of tests relies on an ad-hoc collection of \nrules. In this paper, we present a new and simple framework for oc\u00adcurrence typing that eliminates all \nthree problems via an increase in expressive power. The key innovation is to turn control .ow pred\u00adicates \ninto formulas in propositional logic for reasoning about the types of variables. The atomic propositions \ninclude statements that a particular variable has a particular type, replacing the previous collection \nof special cases with textbook rules of logical inference. This new design allows the type system to \nreason about combi\u00adnations of predicates: (cond [(and (number? (node-left x)) (string? (node-right y))) \n;; known: (node-right y) is a string, (node-left x) is a number ...] [(number? (node-left x)) ;; known: \n(node-right y) is not a string ...] [(string? (node-right y)) ;; known: (node-left x) is not a number \n. . . ]) Now the programmer and the revised type system both determine that since (number? (node-left \nx)) is true in the second clause, (string? (node-right y)) must be false, and thus, (node-right y) is \nnot a string. Using propositional logic to reason about predicates handles this and many other similar \nsituations. Beyond the new type system, this paper contributes: a full-.edged implementation of the \ncalculus, now known as Typed Racket, addressing the full complexities of the functional core of Racket, \nsuch as mutable data and multiple arguments;  an empirical study of the usefulness of our extensions; \nand  a novel model-theoretic proof technique for type soundness.  The paper begins with a brief review \nof the essence of occur\u00adrence typing with an emphasis on programming idioms that our original system \ncannot typecheck. We then describe the new sys\u00adtem in a semi-formal manner. In the three following sections, \nwe describe the system formally: .rst the core system of occurrence typing, then several extensions demonstrating \nthe expressiveness of the system, and third the proof of soundness. These sections are followed by a \ndescription of our implementation strategy and empirical measures of its usefulness on existing code. \nFinally, we discuss related work and conclude. 2. A Brief Introduction to Occurrence Typing Here is the \nsimplest example of occurrence typing: Example 1 ... (if (number? x)(add1 x) 0) ... Regardless of the \nvalue of x, this program fragment always pro\u00adduces a number. Thus, our type system should accept this \nfragment, regardless of the type assigned to x, even if the type is not legitimate for add1. The key \nto typing this program is to assign the second oc\u00adcurrence of x a different, more precise type than it \nhas in the outer context. Fortunately, we know that for any value of type Number, number? returns #t; \notherwise, it returns #f. Therefore, it is safe to use Number as the type of x in the then branch. 2.1 \nExisting Capabilities The following function f always produces a number: (de.ne: (f [x : ( String Number)]) \nExample 2 (if (number? x)(add1 x)(string-length x))) If (number? x) produces #t, x is an appropriate \ninput for add1. If it produces #f, x must be a String by process of elimination; it is therefore an acceptable \ninput to string-length. To handle this program, the type system must take into account not only when \npredicates hold, but also when they fail to hold. Our next fragment represents the essence of a common \nidiom: ... (let ([x (member v l)]) Example 3 (if x compute with x (error fail))) ... This idiom, seen \nhere in member, uses arbitrary non-#f values as true and uses #f as a marker for missing results, analogous \nto ML s NONE. The type for member speci.es this behavior with an appropriate type signature. It can thus \ninfer that in the then branch, x has the type of the desired result and is not #f.  2.2 Challenges Of \ncourse, programmers write tests beyond simple applications of predicates such as (number? x). For example, \nlogical connectives can combine the results of predicates:2 ... (if (or (number? x)(string? x)) (fx) \n0)... Example 4 For this fragment to typecheck, the type system must recognize that (or (number? x)(string? \nx)) ensures that x has type ( String Number) in the then branch, the domain of f from example 2. For \nand, there is no such neat connection: ... (if (and (number? x)(string? y)) Example 5 (+ x (string-length \ny)) 0) ... Example 5 is perfectly safe, regardless of the values of x and y. In contrast, the next example \nshows how little we know when a conjunction evaluates to false: ;; x is either a Number or a String Example \n6 ... (if (and (number? x)(string? y)) (+ x (string-length y)) (string-length x)) ... Here a programmer \nfalsely assumes x to be a String when the test fails. But, the test may produce #f because x is actually \na String, or because y is not a String while x is a Number. In the latter case, (string-length x) fails. \nIn general, when a conjunction is false, we do not know which conjunct is false. Finally, and is expressible \nusing nested if expressions, a pattern that is often macro-generated: ... (if (if (number? x)(string? \ny) #f) Example 7 (+ x (string-length y)) 0) ... One way for the type system to deal with this pattern \nis to reason that it is equivalent to the conjunction of the two predicates. So far, we have seen how \nprogrammers can use prede.ned predicates. It is important, however, that programmers can also abstract \nover existing predicates: (de.ne: (strnum? [x : .]) ;; . is the top type Example 8 (or (string? x)(number? \nx))) 2 The original system could handle only an encoding of or, with different semantics than that provided \nby Racket.  Take the previous example of a test for ( String Number). A programmer can use the test \nto create the function strnum?, which behaves as a predicate for that type. This means the type system \nmust represent the fact that strnum? is a predicate for this type, so that it can be exploited for conditionals. \nIn example 4, we saw the use of or to test for disjunctions. Like and, or is directly expressible using \nif: (if (let ([tmp (number? x)]) Example 9 (if tmp tmp (string? x))) (fx) 0) The expansion is analyzed \nas follows: if (number? x) is #t, then so is tmp, and thus the result of the inner if is also #t. Otherwise, \nthe result of the inner if is (string? x). This code presents a new challenge for the type system, however. \nSince the expression tested in the inner if is the variable reference tmp, but the system must also learn \nabout (number? x) from the test of tmp. Selectors All of the tests thus far only involve variables. It \nis also useful to subject the result of arbitrary expressions to type tests: Example 10 ... (if (number? \n(car p)) (add1 (car p)) 7) ... Even if p has the pair type .., .., then example 10 should pro\u00ad duce a \nnumber.3 Of course, simply accommodating repeated appli\u00adcations of car is insuf.cient for real programs. \nInstead, the rele\u00advant portions of the type of p must be re.ned in the then and else branches of the \nif. In the next example: (.: ([p : .., ..]) Example 11 (if (and (number? (car p)) (number? (cdr p))) \n(gp) no)) the test expression re.nes the type of p from the declared .., .. to the required .Number, \nNumber.. This is the expected result of the conjunction of tests on the car and cdr .elds. Example 12 \nshows how programmers can simultaneously ab\u00ad stract over the use of both predicates and selectors: (de.ne \ncarnum? Example 12 (.: ([x : .., ..]) (number? (car x)))) The carnum? predicate tests if the car of its \nargument is a Number, and its type must capture this fact. Reasoning Logically Of course, we do learn \nsomething when conjunctions such as those in examples 5 and 6 are false. When a conjunction is false, \nwe know that one of the conjuncts is false, and thus when all but one are true, the remaining one must \nbe false. This reasoning principle is used in multi-way conditionals, which is a common idiom extensively \nillustrated in How to Design Programs [Felleisen et al. 2001]: ... (cond Example 13 [(and (number? x)(string? \ny)) 1 ] [(number? x) 2 ] [else 3 ])... This program represents a common idiom. In clause 1, we obvi\u00adously \nknow that x is a Number and y is a String. In clause 2, x is again a Number. But we also know that y \ncannot be a String. To effectively typecheck such programs, the type system must be able to follow this \nreasoning. 3 Racket pairs are immutable; this reasoning is unsound for mutable pairs.  2.3 Putting it \nall Together Our type system correctly handles all of the preceding examples. Finally, we combine these \nfeatures into an example that demon\u00adstrates all aspects of our system: (.: ([input : ( Number String)] \nExample 14 [extra : .., ..]) (cond [(and (number? input)(number? (car extra))) (+ input (car extra))] \n[(number? (car extra)) (+ (string-length input)(car extra))] [else 0])) In section 5.3, we return to \nthis example with a type system that checks it correctly. 3. How to Check the Examples Next we use the \npreceding examples to explain the basic ideas of our new system for occurrence typing. 3.1 Propositions \nand Objects Recall example 1: (if (number? x)(add1 x) 0) In this example, the typechecker must propagate \ninformation from the test to the then branch. Therefore, the typechecker really proves the proposition \nthat if the test evaluates to #t, then x is a number , a proposition abbreviated as Nx , with N short \nfor Number. The typechecker then uses this proposition to check the then branch. The proposition Nx is \ncomputed from (number? x) by combin\u00ading information from two sources. On one hand, the type of num\u00adber? \nincludes the information that it is a predicate. On the other, testing x produces information about the \nvariable x. The addition of a proposition as part of the type of the number? function accomplishes the \n.rst goal. Speci.cally, the added propo\u00adsition allows the type of a function to describe what propositions \nare derivable when the function produces a true value. Borrowing terminology from work on effect systems \n[Lucassen and Gifford 1988], we refer to these propositions as latent. Borrowing notation from dependent \ntypes, we name the argument in each function, al\u00adlowing latent propositions to be well-scoped in function \ntypes. If the argument to number? is named y, the latent proposition is Ny . This makes the type of number?: \nNy y:.--.B To satisfy the second goal, we modify the type system so that it derives an object for each \nexpression. The object describes which part of the environment an expression accesses. In our example, \nit is simply x. Given these pieces of information, the typechecker obtains the desired proposition about \na predicate application from the substi\u00adtution of the actual object for the formal parameter in the latent \nproposition. For the .rst example, the result is Nx . In example 2, x initially has the type ( String \nNumber). To check the else branch, the typechecker needs the information that x is not a Number; i.e., \nthat it is a String. It computes this information via two propositions, one for each of the then and \nelse branches. For the then branch the proposition is Nx , as above. For the else branch, the type checker \nmust propagate the proposition x is not a Number written Nx from the test to the else branch. To this \nend, function types are actually equipped with two latent propositions: one for when the function produces \na true value, and one for when it produces a false value. Thus, the type of number? is now  Ny |Ny y:.- \n---.B with the two propositions separated by |. Substituting x for y in the latent propositions produces \nthe desired results. Contrary to appearances, pairs of propositions need not be com\u00adplementary. Recall \n(and (number? x)(> x 100)) from section 1. In this case, the then proposition should be Nx , because \nif the and ex\u00adpression produces #t, x must be a number. But the else proposition cannot be Nx , since \nx might have been 97, which would produce #f but is nonetheless a number.  3.2 Handling Complex Tests \nFor complex tests, such as those of example 4, the type system com\u00adbines the propositions of different \nsubexpressions. In the cited ex\u00adample, the propositions for (number? x) and (string? x) are Nx |Nx and \nSx |Sx , respectively. For the or expression, these should be combined to Nx . Sx for the then branch \nand Nx . Sx for the else branch. From these complex propositions, the typechecker derives propositions \nabout the type of x. If x is a number or a string, x is in ( NS). By codifying this as a rule of inference, \nit is pos\u00ad sible to derive ( NS)x from Nx . Sx , just what is needed to check the then branch. From \nNx . Sx it is similarly possible to derive ( NS)x , as expected for the else branch. To propagate propositions, \nwe use a proposition environment instead of a type environment; the type environment becomes a special \ncase. Examples 5 and 6 are dealt with in the same manner, but with conjunction instead of disjunction. \nIn example 7, the test expression of the outer if is itself an if expression. The typechecker must derive \npropositions from it and propagate them to the then and else branches. Thus, it .rst computes the propositions \nderived for each of the three subexpressions, giving Nx |Nx for the test and Sy |Sy for the then branch. \nSince the else branch a plain #f never produces a true value, the relevant propositions are .. and .., \nthe impossible and trivial propositions. 3.3 Abstracting over Predicates The next challenge, due to \nexample 8, is to include proposition information in function types for user-de.ned predicates: (.: ([x \n: .]) (or (string? x)(number? x))) As explained above, the typechecker assigns the body of the func\u00ad \n tion type B and derives ( NS)x |( NS)as the then and else x propositions. To add these to a function \ntype, it merely moves these propositions into the arrow type: ( NS)x |( NS) x x:.- -----------.B The \nkey to the simplicity of this rule is that the bound variable of the . expression becomes the name of \nthe argument in the function type, keeping the propositions well-scoped. 3.4 Variables as Tests In examples \n3 and 9, the test expression is just a variable. For such cases, the typechecker uses the proposition \n#fx in the else branch to indicate that variable x has the value #f. Conversely, in the then branch, \nthe variable must be true, giving the proposition #fx . Example 9 demands an additional step. In the \nthen branch of the if, tmp must be true. But this implies that (number? x) must also be true; the propsition \nrepresenting this implication, #ftmp . Nx , is added to the environment used to check the body of the \nlet expression. 3.5 Selectors The essence of example 10 is the application of predicates to se\u00adlector \nexpressions, e.g., (car p). Our type system represents such expressions as complex objects. For example, \n(number? (car p)) involves a predicate with latent propositions Nx |Nx applied to an expression whose \nobject indicates that it accesses the car .eld of p. We write car(p) for this object. Thus, the entire \nexpression has proposition Ncar(p) for the then branch and Ncar(p) for the else branch, obtained by substituting \ncar(p) for x in the latent propo\u00adsitions. Combinations of such tests (example 11) and abstraction over \nthem (example 12) work as before. To specify the access behavior of selectors, each function type is \nequipped with a latent object, added below the arrow. For car, it is car. But, since selectors can be \ncomposed arbitrarily, the function (.: ([x : .., .., ...]) (car (cdr x))) has the type #fcar(cdr(x))|#fcar(cdr(x)) \nx:.., .., ...-----------------.. car(cdr(x)) 3.6 Reasoning Logically Next we revisit conjunctions such \nas (and (number? x)(string? y)). If this expression evaluates to #f, the typechecker can infer some propositions \nabout x and y. In particular, since the original expres\u00adsion derived the proposition Nx . Sy for the \nelse branch, the type system can combine this environmental information with the re\u00adsults of subsequent \ntests. In example 13, the type system derives the proposition Nx when the second cond clause produces \ntrue, which means Sy holds, too. In short, maintaining propositions in the environment allows the typechecker \nto simulate the reasoning of the programmer and to track the many facts available for deduc\u00ading type \ncorrectness for an expression.  3.7 The Form of the Type System The essence of our discussion can be \ndistilled into .ve ideas: Propositions express relationships between variables and types.  Instead \nof type environments, we use proposition environments.  Typechecking an expression computes two propositions, \nwhich hold when the expression evaluates to true or false, respectively.  Typechecking an expression \nalso determines an object of in\u00adquiry, describing the particular piece of the environment pointed to \nby that expression. This piece of the environment may also be a portion of a larger data structure, accessed \nvia a path.  Latent propositions and objects are attached to function types in order to describe facts \nabout the result of applying the function.  The next sections translate these ideas into a typed calculus, \n.TR. 4. The Base Calculus We begin our presentation of .TR with the base system, a typed lambda calculus \nwith booleans, numbers, and conditionals. In Sec\u00adtion 5, we extend the system with pairs and local variable \nbinding. The fundamental judgment of the type system is G . e : t ; .+|.- ; o It states that in environment \nG, the expression e has type t, comes with then proposition .+ and else proposition .-, and references \nobject o. That is, if e evaluates to a true value, then proposition .+ holds; conversely, if e evaluates \nto a false value, .- is true. Further, if e evaluates to a value, then looking up o in the runtime environment \nproduces the same value.  d, e ::= x | (ee) | .xt .e | (if eee) | c | #t | #f | n Expressions c ::= \nadd1 | zero? | number? | boolean? | procedure? Primitive Operations -.|. . s, t ::= . | N | #t | #f \n| ( t ) | x:t--.t Types o . ::= tx | t x | . . . | . . . | . . . | .. | .. Propositions o ::= x |\u00d8 Objects \n- . G ::= . Environments Figure 1. Syntax of Terms, Types, Propositions, and Objects 4.1 Syntax The \nsyntax of expressions, types, propositions, and objects is given in .gure 1. The expression syntax is \nstandard, with conditionals, numeric and boolean constants, and primitive operators, in addition to the \nbasics of abstraction, application, and variable reference. Abstractions come with type annotations on \nthe bound variable. The presentation of the standard operational semantics is deferred to section 6, \nin conjunction with the soundness proof. As for types, . is the supertype of all types; N is the type \nof numeric values; #t and #f are the types of the true and false - . constants, respectively; and ( t \n) is the untagged or true union of its components. We abbreviate ( #t #f) as B and () as .. Function \ntypes name their arguments. This name is in scope in the latent propositions and objects of a function \ntype written above and below the arrow, respectively and in the result type. The latent propositions \nare knowledge about the types of variables when the function produces a true or false value, respectively. \nMost propositions come in familiar form, borrowed from propositional logic: implications, disjunctions, \nand conjunctions, plus always-true (..) and always-false (.. ) propositions. Atomic propositions relate \nvariables to their types: tx states that x has type t; tx states that x never assumes a value with type \nt. An object describes a portion of the runtime environment. In the base system, it is either a variable \nor the empty object. For example, the expression (add1 7) has object \u00d8 because it does not access any \nportion of the environment. Environments are simply collections of arbitrary propositions. Types and \nPropositions Unlike many systems that relate type systems and logic, .TR distinguishes types, propositions, \nand terms. Propositions state claims about the runtime environment and thus relate types and variables. \nThis choice allows a simple and decidable logic to be used to derive types from propositions to achieve \nthe desired expressiveness.  4.2 Typing Rules Figures 2 and 3 specify the typing and subtyping rules. \nConstants The simplest rule is T-NUM, which gives all numbers the type N. Since numbers are treated as \ntrue by the evaluation rules for if, numeric constants are assigned the propositions ..|.. , indicating \nthat no new information is acquired when the number evaluates to a true value; if it evaluates to false, \na contradiction is obtained. The rule for function constants, T-CONST, work in similar manner, though \nwe use a dt function to assign types to function constants. The boolean constants are given singleton \ntypes by T-TRUE and T-FALSE, along with propositions that re.ect that #t is always true, and #f is always \nfalse. All of the constants have the object \u00d8, since none refer to any portion of the environment. Variables \nTherulefortypingvariables, T-VAR,exploitstheproof system. If the current environment proves that x has \ntype t, repre\u00adsented by the proposition tx , then the type system assigns x the type t. The object for \na variable is itself. Finally, the propositions for a variable indicates that if x evaluates to a true \nvalue, x cannot have type #f. Similarly, if x evaluates to #f, its type is #f. Abstraction and Application \nThe rule for checking an abstrac\u00adtion, T-ABS, takes the propositions and object from the body and makes \nthem the latent propositions and object in the function type. By taking the bound variable from the abstraction \nand turns it into the name of the argument, references to the variable in the types, propositions, and \nobject remain well-scoped. Correspondingly, in T-APP, the latent propositions and object are used as \nthe result propositions and object, just as with the result type. In all cases, the actual object oa \nis substituted for the name of the formal parameter, x. Consider the abstraction: .y.(number? y) which \ntypechecks as follows. In the body of the abstraction, G= .y . Thus, G . y : . ; #fy|#fy ; y, and number? \nhas the above-mentioned type. To check the application, the typechecker substitutes y for x in the result \ntype, latent propositions, and latent object of number?, which yields G . (number? y):B ; Ny|Ny ; \u00d8. \nFinally, the function is assigned the desired type via T-ABS: Ny |Ny y:.- ---.B \u00d8 In our prior system, \nthis example required multiple special\u00adpurpose rules and the use of several metafunctions, whereas here \nit is a simple matter of scope and substitution. Of course, substitution of an object for a variable \nmust account for the case when the object is \u00d8. When this happens, any references to the variable are \nforgotten, and propositions or objects that refer to it become trivial. Figure 8 de.nes the full substitution \nfunction. Conditionals As far as types and objects are concerned, the T-IF rule is straightforward. The \ntest may have any type and object, and the then and else branches must have identical types and objects, \nwhich then become the type and the object of the entire expression. The key difference between T-IF and \nconventional rules for condi\u00adtionals is due to the differential propagation of knowledge from the test \nto the branches. Speci.cally, the rule uses two distinct environ\u00adments to check the then and else branches, \nbecause .1+ holds in the then branch and .1- holds in the else branch. The resulting propositions follow \nfrom a simple principle about the evaluation of if. If a true value is produced, either the then branch \nor the else branch must have evaluated to a true value, and similarly for a false value. Therefore, in \nthe true case, either the then proposition of the then branch, .2+ , or the then proposition of the else \nbranch, .3+ , must be true, which means .2+ . .3+ is the then proposition of the entire expression and, \ncorrespondingly, .2- . .3- is the else proposition. Subsumption &#38; Subtyping Finally, .TR comes with \nsubtyping. Expressions of type t can be viewed as having a larger type t. . Objects can also be lifted \nto larger objects. The ordering on propo\u00adsitions is simply provability in the current environment.  \nT-NUM T-CONST T-TRUE T-FALSE G . n : N ; ..|.. ; \u00d8 G . c : dt (c); ..|.. ; \u00d8 G . #t : #t ; ..|.. ; \u00d8 \nG . #f : #f ; .. |.. ; \u00d8 T-APP .f+ |.f- G . e : x:s------.t ; .+|.- ; o T-VAR T-ABS of G . tx G,sx . \ne : t ; .+|.- ; o G . e : s ; .+ |.- ; o G . x : t ; #fx |#fx ; x s.+|.-G . (ee .): t[o ./x]; .f+ |.f- \n[o ./x]; of [o ./x] G . .x.e : x:s----.t ; ..|.. ; \u00d8 o T-IF T-SUBSUME G . e1 : t1 ; .1+ |.1- ; o1 G \n. e : t ; .+|.- ; o G,.1+ . e2 : t ; .2+ |.2- ; o G,.+ . .. G,.- . .. + - G,.1- . e3 : t ; .3+ |.3- \n; o . t<: t. . o<: o . G . (if e1 e2 e3): t ; .2+ . .3+ |.2- . .3- ; o G . e : t; .|.- ; o + Figure \n2. Typing Rules S-FUN SO-REFL S-REFL S-UNIONSUB . s. S-UNIONSUPER <: s . t<: t. - ----.i . o<: o . t<: \nt . .. .i. . t<: si . ti <: s.+ . .+ .- . .- . o<: o  -.i -. .i SO-TOP S-TOP . t<:( s ) . ( t ) <: \ns .+|.-. .+ .|.- . . x:s----.t<: x:s- ----.t . o<: \u00d8. t<: . oo. Figure 3. Subtyping Rules Given these \nde.nitions, the rules for subtyping are straightfor\u00adward. All types are subtypes of . and of themselves. \nSubtypes of elements of a union are subtypes of the union, and any type that is a supertype of every \nelement is a supertype of the union. Finally, function types are ordered in the usual fashion.  4.3 \nProof System Figure 4 speci.es the proof rules for our logic. The .rst nine rules L-ATOM through L-ORE \nuse the natural deduction style to express the standard rules of propositional logic. The subsequent \nfour rules relate the atomic propositions. In particular, L-SUB says that if x has type t, then it has \nany larger type.Similarly, L-SUBNOT saysthatif x does not have type t, then it does not have any smaller \ntype. By L-BOT, if x has an empty type, it is possible to conclude anything since this is impossible. \nThe L-UPDATE rule re.nes the type of a variable via a combina\u00adtion of multiple propositions. Roughly \nspeaking, this metafunction satis.es the equations update(t, s)= t n s update(t, s)= t - s See .gure \n9 for the full de.nition.  4.4 A Worked Example At this point, eight of our 14 examples typecheck. To \nillustrate the workings of the type system, let us work example 7: (if (if (number? x)(string? y) #f) \n(+ x (string-length y)) 0) First, assume that the initial environment is G= .x, .y. Now consider the \ninner if expression. The test has then proposition Nx and else proposition Nx . The then branch has propositions \nSy and Sy , or by subsumption Nx . Sy |.., since T-IF adds the then proposition of the test to the environment \nfor checking the then branch. The else branch has propositions .. |.., and by subsump\u00adtion Nx . Sy |.. \nsince .. . Nx . Sy . Therefore, the entire inner if expression has then proposition (Nx . Sy ) . (Nx \n. Sy )= Nx . Sy and else proposition ... Second, we typecheck the then branch of the main if expression \nin the environment G1 = .x, .y, Nx . Sy . Since G1 . Nx and G1 . Sy , we can give x and y the appropriate \ntypes to check the expression (+ x (string-length y)). 5. Extensions The base system of section 4 lacks \nseveral important features, in\u00adcluding support for compound data structures and let. This section shows \nhow to extend the base system with these features. 5.1 Pairs The most signi.cant extension concerns \ncompound data, e.g., pairs. We extend the expression, type, and proposition grammars as shown in .gure \n5.4 Most signi.cantly, in all places where a variable appeared previously in propositions and objects, \nit is now legal to specify a path a sequence of selectors rooted at a variable, writ\u00adten p(x). This allows \nthe system to refer not just to variables in the environment, but to parts of their values. Typing Rules \nFigure 6 shows the extensions to the typing and subtyping rules. Again, the subtyping rule S-PAIR and \ntyping rule for cons are straightforward; all pair values are treated as true. The T-CAR and T-CDR rules \nare versions of the application rule specialized to the appropriate latent propositions and objects, \nwhich here involve non-trivial paths. Substitution of objects for variables is also appropriately extended; \nthe full de.nition is in .gure 8. None of the existing typing rules require changes. 4 In a polymorphic \n.TR, pair operations could be added as primitives.  L-ANDI L-ATOM L-FALSE G . .1 L-ANDE . . G L-TRUE \nG . .. G . .. G . .2 G, .1 . . or G, .2 . . G . . G . . G . .1 . .2 G, .1 . .2 . . L-IMPE L-ORE L-IMPI \nG . .1 L-ORI G, .1 . . G, .1 . .2 G . .1 . .2 G . .1 or G . .2 G, .2 . . G . .1 . .2 G . .2 G . .1 . \n.2 G, .1 . .2 . . L-SUB L-SUBNOT L-BOT L-UPDATE G . tx . t <: s G . sx . t <: s G . .x G . tx G . .x \nG . sx G . tx G . . G . update(t, .)x (The metavariable . ranges over t and t (without variables).) \nFigure 4. Proof System e ::= ... | (cons ee) Expressions c ::= ... | cons? | car | cdr Primitive Operations \ns, t ::= ... |.t, t. Types . ::= ... | tp(x) | t p(x) Propositions o ::= p(x) |\u00d8 Objects - . p ::= pe \nPaths pe ::= car | cdr Path Elements Figure 5. Syntax Extensions for Pairs T-CAR T-CDR G . e : .t1,t2. \n; .0+ |.0- ; o G . e : .t1,t2. ; .0+ |.0- ; o S-PAIR T-CONS . t1 <: t2 G . e1 : t1 ; .1+ |.1- ; o1 .|.= \n#fcar(x)|#fcar(x)[o/x] .|.= #fcdr(x)|#fcdr(x)[o/x] + - + - . s1 <: s2 G . e2 : t2 ; .2+ |.2- ; o2 or \n= car(x)[o/x] or = cdr(x)[o/x] ..t1,s1. <: .t2,s2. G . (cons e1 e2): .t1,t2. ; ..|.. ; \u00d8 G . (car e): \nt1 ; .|.; or G . (cdr e): t2 ; .|.; or + - + - Figure 6. Type and Subtype Extensions L-SUB L-SUBNOT \nL-BOT L-UPDATE G . tp(x) . t<: s G . sp(x) . t<: s G . .p(x) G . tp.(x) G . .p(p.(x)) G . sp(x) G . tp(x) \nG . . G . update(t, ., p)p.(x) Figure 7. Logic Extensions Logic Rules Figure 7 speci.es the changes to \nthe logic for deal\u00ad ing with paths. For the .rst three rules, the only change needed is allowing paths \nin the appropriate syntactic locations. For the L-UPDATE rule, there is an additional change. When the \nenvironment proves both .., ..x and Ncar(x), it must be possible to derive .N, ..x . The new version \nof L-UPDATE allows this inference via a revised version of update. Its third argument speci.es a path \nto follow before re.ning the type. See .gure 9 for details. Of course, none of the rules implementing \nthe standard proof theory of propositional logic change with this extension. With the addition of pairs, \nthe type system can cope with 12 of the 14 examples from section 2.  5.2 Local Binding To add a local \nbinding construct, we again extend the grammar: d, e ::= ... | (let (xe) e) Recall our motivating example \n9. The crucial aspect is to relate the propositions about the initialization expression to the variable \nitself. Logical implication precisely expresses this connection, giv\u00ading us the following rule: T-LET \nG . e0 : t ; .0+ |.0- ; o0 G,tx , #fx . .0+ , #fx . .0- . e1 : s ; .1+ |.1- ; o1 G . (let (xe0) e1): \ns[o0/x]; .1+ |.1- [o0/x]; o1[o0/x] This rule has three components. The .rst antecedent checks the right-hand \nside. The second checks the body with an environment extended both with the type of the bound variable \n(tx ) and with implications stating that if x is not false, e0 must evaluate to true, and similarly if \nx is false, e0 must evaluate to false. The consequence replaces all references to x with the object of \ne0.  5.3 The Final Example With this extension, we are now able to check all the examples from section \n2. To demonstrate the complete system, consider exam\u00ad  ple 14. We begin with G0 =( NS)input, .., ..extra. \nThe two tests, (number? input) and (number? (car extra)), yield the propo\u00adsitions Ninput|Ninput for the \nformer and Ncar(extra)|Ncar(extra) for the latter. Using T-IF, T-SUBSUME, and the de.nition of and  \n.+|.-[o/x]= .+[o/x]|.-[o/x] .p(x)[p.(y)/x] =(.[p.(y)/x]) p(p.(y)) .p(x)[\u00d8/x]+ = .. .p(x)[\u00d8/x]- = .. .p(x)[o/z]= \n.p(x) . x = z and z .. fv(.) .p(x)[o/z]+ = .. . x = z and z . fv(.) .p(x)[o/z]- = .. . x = z and z . \nfv(.) ..[o/x]= .. .. [o/x]= .. (.1 . .2)[o/x]+ = .1[o/x]- . .2[o/x]+ (.1 . .2)[o/x]- = .1[o/x]+ . .2[o/x]- \n(.1 . .2)[o/x]= .1[o/x] . .2[o/x] (.1 . .2)[o/x]= .1[o/x] . .2[o/x] p(x)[p.(y)/x]= p(p.(y)) p(x)[\u00d8/x]= \n\u00d8 p(x)[o/z]= p(x) . x = z \u00d8[o/x]= \u00d8 Substitution on types is capture-avoiding structural recursion. \nFigure 8. Substitution update(.t, s.,.,p :: car)= .update(t, ., p),s. update(.t, s.,.,p :: cdr)= .t, \nupdate(s, ., p). update(t, s, .)= restrict(t, s) update(t, s, .)= remove(t, s) restrict(t, s)= . if ..v. \n. v : t ; .1 ; o1 and . v : s ; .2 ; o2 --------.. restrict((.-t ),s) =(. restrict(t, s)) restrict(t, \ns)= t if . t<: s restrict(t, s)= s otherwise remove(t, s)= . if . t<: s --------.. remove((.-t ),s) =(. \nremove(t, s)) remove(t, s)= t otherwise Figure 9. Type Update (see example 7), we can therefore derive \nthe then proposition Ninput .Ncar(extra) and the else proposition Ninput .Ncar(extra). The then proposition, \nadded to the environment for the right-hand side of the .rst cond clause, also proves .N, ..extra by \nthe L-UPDATE rule, which suf.ces for typechecking the expression (+ input (car extra)). In the second \ncond clause, the test has the then proposition Ncar(extra), and the environment is G0, Ninput .Ncar(extra) \nFrom this, we can derive Ninput since Ncar(extra) and Ncar(extra) are contradictory. Then, using ( NS)input \nfrom G0 and Ninput, we can derive Sinput, which is required to typecheck the application of string-length. \nThis completes the second clause. The third clause is a constant and thus obvious.  5.4 Metafunctions \nEquipped with the full formal system, we can now provide a de\u00adtailed description of the substitution \nand type update metafunc\u00adtions; see .gures 8 and 9. Substitution replaces a variable with an object. \nWhen the object is of the form p(x), this is in general a straightforward structural Nx |Nx dt (number?) \n= x:.- ---.B \u00d8 .-.. |.- .. xx dt (procedure?) = x:.------------.B \u00d8 Bx |Bx dt (boolean?) = x:.- ---.B \n\u00d8 ..,.. |..,.. xx dt (cons?) = x:.------------.B dt (add1 )= N -\u00d8 .N dt (zero?) = N - .B Figure 10. Constant \nTyping d(add1 ,n)= n +1 d(zero?, 0) = #t d(zero?,n)= #f otherwise d(number?,n)= #t d(number?,v)= #f otherwise \nd(boolean?, #t)= #t d(boolean?, #f)= #t d(boolean?,v)= #f otherwise d(procedure?, .xt.e)= #t d(procedure?,c)= \n#t d(procedure?,v)= #f otherwise d(cons?, (cons v1 v2)) = #t d(cons?,v)= #f otherwise d(car, (cons v1 \nv2)) = v1 d(cdr, (cons v1 v2)) = v2 Figure 13. Primitives recursion. There are a few tricky cases to \nconsider, however. First, if the object being substituted is \u00d8, then references to the variable must \nbe erased. In most contexts, such propositions should be erased to .., the trivial proposition. But, \njust as with contravariance of function types, such propositions must be erased to .. when to the left \nof an odd number of implications. Second, if a proposition such as tx references a variable z in t, then \nif z goes out of scope, the entire proposition must be erased. In comparison, the update metafunction \nis simple. It follows a path into its .rst argument and then appropriately replaces the type there with \na type that depends on the second argument. If the sec\u00adond argument is of the form t, update computes \nthe intersection of the two types; if the second argument is of the form t, update computes the difference. \nTo compute the intersection and differ\u00adence, update uses the auxiliary metafunctions restrict and remove, \nrespectively. 6. Semantics, Models, and Soundness To prove type soundness, we introduce an environment-based \noper\u00adational semantics, use the environments to construct a model for the logic, prove the soundness \nof the logic with respect to this model, and conclude the type soundness argument from there. 6.1 Operational \nSemantics Figure 11 de.nes a big-step, environment-based operational se\u00admantics of .TR. The metavariable \n. ranges over value environ\u00adments (or just environments), which are .nite maps from variables  B-DELTA \nB-LET B-VAR . . e . c. . e . . v. . ea . va . B-VAL B-ABS .(x)= vd(c, v)= v.[x .. va] . eb . v tt .. \n. . v . v. . .x.e . [.,.x.e] . . x . v. . (ee ) . v. . (let (xea) eb) . v B-BETA B-IFTRUE . . ef . [.c, \n.xt .eb] B-CONS . . e1 . v1 B-IFFALSE . . ea . va . . e1 . v1 v1 .. . e1 . #f = #f .c[x .. va] . eb \n. v. . e2 . v2 . . e2 . v. . e3 . v . . (ef ea) . v. . (cons e1 e2) . (cons v1 v2) . . (if e1 e2 e3) \n. v. . (if e1 e2 e3) . v Figure 11. Operational Semantics M-OR M-IMP M-AND M-TOP . |= .1 or . |= .2 . \n|= . implies . |= .. . |= .. |= .. . |= .. . |= .1 . .2 . |= . . .. . |= . . .. M-NOTTYPE M-TYPE . .(p(x)) \n: s ; .+ |.- ; o . .(p(x)) : t ; .|.; o there is no v such that . v : t ; .1+ |.1- ; o1 and . v : s ; \n.2+ |.2- ; o2 + - . |= tp(x) . |= tp(x) Figure 12. Satisfaction Relation to closed values. We write \n.(x) for the value of x in ., and .(p(x)) for the value at path p in .(x). The central judgment is . \n. e . v which states that in environment ., the expression e evaluates to the value v. Values are given \nby the following grammar: v ::= c | #t | #f | n | [., .xt .e] | (cons vv) For the interpretation of primitives, \nsee .gure 13.  6.2 Models A model is any value environment, and an environment . satis.es a proposition \n., . |= ., as de.ned in .gure 12 mostly in the usual manner. The satisfaction relation is extended to \nproposition environments in a pointwise manner. To formulate the satisfaction relation, we need a typing \nrule for closures: T-CLOS .G.. |=G and G . .xt .e : s ; .|.- ; o + . [., .xt .e]: s ; .|.; o + - Two \nclauses in .gure 12 M-TYPE and M-NOTTYPE need some explanation. They state that if a value of x in the \nenvironment has the type t, the model satis.es tx , and if x has a type that does not overlap with t, \nthe model satis.es tx . We can see immediately that not all propositions are consistent, such as .. , \nas expected, but also propositions such as Nx . Bx . Our .rst lemma says that the proof theory respects \nmodels. Lemma 1. If . |=G and G . . then . |= .. Proof: Structural induction on G . .. Conversely, we \ncan use this lemma as the guideline that any logical rule that satis.es this lemma is appropriate.  \n6.3 Soundness for .TR 1. either o = \u00d8 or .(o)= v, 2. either v .= .+ or v = .-, and = #f and . |= #f \nand . | 3. . v : t ; .+ .|.- ; o . for some .+ , .-., and o .  Proof: By induction on the derivation \nof the typing judgment. For illustrative purposes, we examine the T-IF case with e = (if e1 e2 e3). Proving \npart 1 is trivial: either o is \u00d8, or both e2 and e3 have an identical object, and e must evaluate to \nthe results of one of them. To prove part 2, we note that if v = #f, either e2 or e3 must evaluate to \n#f. If it is e2, we have . |= .2- , and thus . |= .2- . .3- by M-OR, giving the desired result. The cases \nfor e3 evaluating to false and the whole expression evaluating to true are dealt with in an analogous \nmanner. Finally, part 3 is trivial, since both the then and else branches have the same type. Given this, \nwe can state the desired soundness theorem. Theorem 1 (Type Soundness for .TR). If . e : t ; .+|.- ; \no and . e . v then . v : t ; .+ .|.- ; o . for some .+ , .-., and o . Proof: Corollary of lemma 2. This \ntheorem comes with the standard drawbacks of big-step soundness proofs. It says nothing about diverging \nor stuck terms.5 7. From .TR to Typed Racket As a core calculus, .TR lacks many of the features of a \nprogram\u00adming language such as Racket, which consists of a rich functional core enriched with support \nfor object-oriented and component\u00adoriented programming. Creating an implementation from the cal\u00adculus \ndemands additional research and engineering. This section reports on the most important implementation \nideas. Our current implementation dubbed Typed Racket deals with the functional core of Racket, which \nalso supports mutable 5 To deal with errors, we would need the following additional steps: 1. Add an \nadditional value, wrong, which has every type. 2. Add evaluation rules that propagate wrong.  With \nthe model theory and the operational semantics in place, we 3. Add evaluation rules to generate wrong \nfor each stuck state. can state and prove the second major lemma. 4. Add clauses to the d function to \ngenerate wrong for unde.ned clauses. Lemma 2. If G . e : t ; .+|.- ; o, . |=G, and . . e . v then 5. \nProve that if . e : t ; .+|.- ; o, then .. e . wrong. all of the following hold: data structures, assignable \nvariables and Scheme s multiple value returns. In addition, the section discusses user interface issues \nand the implementation of the logical reasoning system. 7.1 Paths and Mutability The .TR calculus assumes \nimmutable data structures. In Racket, some forms of data are mutable, however. Predicate tests on paths \ninto mutable data cannot soundly re.ne the type environment. Consider an example using Racket s equivalent \nof ref cells: (let*: ([b : (Box .)(box 0)] [b* : (Box .) b]) (if (number? (unbox b)) (begin (set-box! \nb* no)(unbox b)) 0)) A naive implementation might assign this fragment the type Num\u00adber, but its evaluation \nproduces a symbol, because b and b* are aliased. To avoid this unsoundness, the unbox procedure is assigned \ntrivial latent propositions and object. In general, Racket provides structures that are mutable on a \nper-.eld basis and that are accessed with per-.eld selectors. Typed Racket therefore does not assign \nthe selectors of mutable .elds any latent propositions or objects. Assignable variables are a second \nconcern in the same realm. If a variable is the target of an assignment, the L-UPDATE rule is unsound \nfor this variable. Hence, Typed Racket uses a simple anal\u00adysis to .nd all assignment statements and to \ndisable the L-UPDATE rule for those. Since variables are assignable only in the module that declares \nthem, the analysis is modular and straightforward. 7.2 Multiple Arguments, Multiple Values All .TR functions \nconsume one argument and produce one value. In contrast, Racket functions are multi-ary and may produce \nmulti\u00adple values [Flatt and PLT 2010]. For example, the function (de.ne two-val? (. ([x : .][y : .]) \n(values (number? x)(string? y)))) determines both whether its .rst argument is a number, and whether \nits second argument is a string. Expressing this form of reasoning in our type system demands a different \nrepresentation of function types. On the domain side, no additional work is needed because propositions \nand objects refer directly to the names of the parameters. On the range side, each function produces \na sequence of values, each of which comes with a type, two latent propositions, and a latent object. \nIn our running example, the latent propositions for the .rst return value are Nx|Nx. Although test positions \ncannot cope with multiple values, the following idioms exploits multiple values for tests: (let-values \n([(xy)(two-val? e1 e2)]) (if x )) Our new function type representation allows the type system to prove \ne1 is a number in the then branch of the if expression, and to use y in a later test expression for checking \nif e2 is a string. 7.3 User Presentation While the Typed Racket types capture much useful information \nabout the program, they can also be hard for programmers to read and write. Fortunately, in most cases \na simpli.ed type presentation suf.ces, and complex types are reserved for special occasions. First, few \ntype errors involve types with non-trivial propositions directly. In our experience with Typed Scheme, \nalmost all type er\u00adrors are directly explicable with the underlying, non-occurrence typing portion of \nthe system, meaning that users primary expe\u00adrience with occurrence typing is that it just works. Second, \nwhen users need to specify or read types with proposi\u00adtions or objects, these are primarily latent and \nsymmetric between the two propositions. For example, to specify the type of strnum? in Typed Racket syntax, \nthe user writes (: strnum? (. . Boolean : ( String Number))) The syntax states that the latent then \nproposition is ( SN)x, where x is the name of the argument, and the latent else proposition is conversely \n( SN)x , with a latent object of \u00d8. In practice, this syntax suf.ces for capturing the substantial majority \nof the types with latent propositions. Third, Typed Racket uses local type inference and bi-directional \ntypechecking [Pierce and Turner 2000]. Since all top-level de.ni\u00ad tions are annotated in the above fashion, \nthe type system can prop\u00adagate the latent propositions into non-latent propositions for the bodies of \nfunctions such as strnum?. In short, programmers almost never need to write down non-latent propositions. \n 7.4 Implementing the Logical System The type system presented in section 4 is non-algorithmic. For \nan implementation, we must both eliminate the subsumption rule and implement the T-VAR rule. The former \nis accomplished via a distribution of the subtyping obligations among the rules. The latter demands the \nimplementation of a notion of provability. Since propositional satis.ability is decidable, the logical \nsys\u00adtem is straightforward to implement in principle. We employ three strategies to avoid paying the \nfull cost of deciding the logic in al\u00admost all cases. First, we split the type environment from the propo\u00adsition \nenvironment. This separation avoids invoking the logic to typecheck each variable reference. Second, \nTyped Racket eagerly simpli.es logical formulas, signi.cantly decreasing their typical size. Third, it \nalso re.nes the type environment each time a new formula is added to the proposition environment. These \noptimiza\u00adtions mean that most code does not pay the cost of the proof system. These techniques are well-known \nfrom work on SAT solvers. Since deciding the logical inference rules of .TR can be cast as a satis.ability-modulo-theories \nproblem, we plan to investigate ap\u00adplying existing off-the-shelf SMT solvers [Ganzinger et al. 2004]. \n8. Empirical Measurements Numerous encounters with dif.cult-to-type idioms in Racket code triggered the \ndevelopment of our new system. In order to mea\u00adsure its actual effectiveness in comparison with the original \nsys\u00adtem, we inspected the existing Racket code base and measured the frequency of certain idioms in practice. \nSince precise measurement of programming idioms is impossi\u00adble, this section begins with a detailed explanation \nof our empirical approach and its limitations. The following two subsections report on the measurements \nfor the two most important idioms that moti\u00advate the Typed Racket work: those that involve predicates \napplied to selectors, as in example 10, and those that involve combinations of predicates, as in example \n4. In both cases, our results suggest that our new approach to occurrence typing greatly improves our \ncapability to enrich existing Racket code with types. 8.1 Methodology Measuring the usefulness of Typed \nRacket for typing existing code presents both opportunities and challenges. The major opportunity is \nthat the existing Racket code base provides 650,000 lines of code on which to test both our hypotheses \nabout existing code and our type system. The challenge is assessing the use of type system features on \ncode that does not typecheck. Since the purpose of Typed Racket is to convert existing un\u00adtyped Racket \nprograms, it is vital to con.rm its usefulness on exist\u00ading code. Our primary strategy for assessing \nthe usefulness of our type system has been the porting of existing code, which is the ul\u00adtimate test \nof the ability of Typed Racket to follow the reasoning of Racket programmers. However, Typed Racket does \nnot operate on untyped code; it requires type annotations on all functions and user-de.ned structures. \nTherefore, it is not possible to simply apply our new implementation to existing untyped code.  Instead, \nwe have applied less exact techniques to empirically validate the usefulness of our extensions to Typed \nRacket. Starting from the knowledge of particular type predicates, selectors, and patterns of logical \ncombinations, we searched for occurrences of the relevant idioms in the existing code base. We then randomly \nsampled these results and analyzed the code fragments in detail; this allows us to discover whether the \ntechniques of occurrence typing are useful for the fragment under consideration. This approach has two \nmajor drawbacks. First, it only allows us to count a known set of predicates, selectors, idioms, and \nother forms. Whether a function is a selector or a type predicate could only be answered with a semantics-based \nsearch, which is currently not available. Second, our approach does not determine if a pro\u00adgram would \nindeed typecheck under Typed Racket, merely that the features we have outlined are indeed necessary. \nFurther limitations may be discovered in the future, requiring additional extensions. However, despite \nthese drawbacks, we believe that empirical study of the features of Typed Racket is useful. It has already \nalerted us to uses of occurrence typing that we had not predicted.  8.2 Selectors Our .rst measurement \nfocuses on uses of three widely used, built-in selectors: car, cdr, and syntax-e (a selector that extracts \nexpression representations from a AST node). A search for compositions of any predicate-like function \nwith any of these selectors yields: 1. 254 compositions of built-in predicates to uses of car for which \n.TR would assign a non-trivial object; 2. 567 such applications for cdr; and 3. 285 such applications \nfor syntax-e.  Counting only known predicate names means that (number? (car x)) is counted but neither \n(unknown? (car y)) or (string? (car (f ))) are included because (f ) is not known to have a non-trivial \nobject. In sum, this measurement produces a total of at least 1106 useful instances for just three selectors \ncomposed with known predicates. A manual inspection of 20 uses each per selector suggests that the extensions \nto occurrence typing presented in this paper are needed for just under half of all cases. Speci.cally, \nin the case of car, seven of 20 uses require occurrence typing; for cdr, nine of 20 bene.t; and the same \nnumber applies to syntax-e. Additionally, in four cases the type correctness of the code would rely on \n.ow\u00adsensitivity based on predicate tests, but using exceptional control .ow rather than conditionals. \nIn conclusion, our manual inspection suggests that some 40% to 45% of the 1106 cases found can bene.t \nfrom extending occurrence typing to selector expressions, as described in section 5. This mea\u00ad surement \ntogether with the numerous user requests for this feature justi.es the logical extensions for selector-predicate \ncompositions.  8.3 Logical Combinations Since our original system cannot cope with disjunctive combination \nof propositions, typically expressed using or, measuring or expres\u00adsions in the code base is a natural \nway to con.rm the usefulness of general propositional reasoning for Typed Racket. The source of Racket \ncontains approximately 4860 uses of the or macro; also, or expressions are expanded more than 2000 times \nfor the compila\u00adtion of the minimal Racket library, demonstrating that this pattern occurs widely in \nthe code base. The survey of all or expressions in the code base reveals that or is used with 37 different \nprimitive type predicates a total of 474 times, as well as with a wide variety of other functions that \nmay be user-de.ned type predicates. Each of these uses requires the extension for local binding described \nin section 5.2, as well as the more general logical reasoning framework of this paper to generate the \ncorrect .lters. 9. Related Work Intensional Polymorphism Languages with intensional polymor\u00adphism [Crary \net al. 1998] also offer introspective operations, e.g., typecase, allowing programs to dispatch on type \nof the data pro\u00advided to functions. The .TR calculus provides signi.cantly greater .exibility. In particular, \nit is able to use predicates applied to se\u00adlectors, reason about combinations of tests, abstract over \ntype tests, use both the positive and negative results of tests, and use logical formulas to enhance \nthe expressiveness of the system. In terms of our examples, the system of Crary et al. could only handle \nthe .rst. Generalized Algebraic Data Types Generalized algebraic data types [Peyton Jones et al. 2006] \nare an extension to algebraic data types in which pattern matching causes type re.nement. This is sometimes \npresented as a system of type constraints, in addition to the standard type environment, as in the HMG(X) \nand LHM(X) systems [Simonet and Pottier 2007, Vytiniotis et al. 2010]. Such systems are similar to .TR \nin several ways they type\u00adcheck distinct branches of case expressions with enriched static environments \nand support general constraint environments from which new constraints can be derived. The .TR calculus \nand constraint-based such as HMG(X) differ in two fundamental ways, however. First, HMG(X), like other \nGADT systems, relies on pat\u00adtern matching for type re.nement, whereas .TR combines con\u00additional expressions \nand selector applications, allowing forms ab\u00adstractions that patterns prohibit. Second, all of these \nsystems work solely on type variables, whereas .TR re.nes arbitrary types. Types and Logic Considering \ntypes as logical propositions has a long history, going back to Curry and Howard [Curry and Feys 1958, \nHoward 1980]. In a dependently typed language such as Agda [Norell 2007], Coq [Bertot and Cast\u00b4eran 2004], \nor Epi\u00ad gram [McBride and McKinna 2004], the relationships we describe with predicates and objects could \nbe encoded in types, since types can contain arbitrary terms, including terms that reference other variables \nor the expression itself. The innovation in .TR is to consider propositions that relate types and variables. \nThis allows us to express the relationships needed to typecheck existing Racket code, while keeping the \nlogic decidable and easy to understand. Types and Flow Analysis for Untyped Languages Shivers [1991] \ndescribes a type recovery analysis exploited by Wright [1997] and Flanagan [1999] for soft typing systems \nthat includes re.n\u00ad ing the type of variables in type tests. This analysis is only for par\u00adticular predicates, \nhowever, and does not support abstraction over predicates or logical reasoning about combinations of \npredicates. Similarly, Aiken et al. [1994] describe a type inference system using conditional types, \nwhich re.ne the types of variables based on patterns in a case expression. Since this system is built \non the use of patterns, abstracting over tests or combining them, as in examples 12 or 5 is impossible. \nFurther, the system does not account for preceding patterns when typing a right-hand side and thus cannot \nperform logical reasoning as in examples 13 and 14. Types for Untyped Languages There has long been interest \nin static typechecking of untyped code. Thatte [1990] and Henglein [1994] both present systems integrating \nstatic and dynamic types, and Henglein and Rehof [1995] describe a system for automatic translation of \nuntyped Scheme code into ML. These systems did not take into account the information provided by predicate \ntests, as described by Henglein and Rehof in the quote from section 1.  In the past few years, this \nwork has been picked up and applied to existing untyped languages. In addition to Typed Scheme, pro\u00adposals \nhave been made for Ruby [Furr et al. 2009], Thorn [Wrigstad et al. 2010], JavaScript [ECMA 2007], and \nothers, and theoretical studies have been conducted by Siek and Taha [2006] and Wadler and Findler [2009]. \nTo our knowledge, none have yet incorporated occurrence typing or other means of handling predicate tests, \nal\u00adthough the authors of DRuby have stated that occurrence typing is their most signi.cant missing feature \n[priv. comm.]. Semantic Subtyping Bierman et al. [2010] present Dminor, a sys\u00ad tem with a rule for conditionals \nsimilar to T-IF. Their system sup\u00adports extremely expressive re.nement types, with subtyping deter\u00admined \nby an SMT solver. However, while .TR supports higher\u00adorder use of type tests, due to the limitations \nof the semantics sub\u00adtyping framework, Dminor is restricted to .rst order programs. 10. Conclusion This \npaper describes a new framework for occurrence typing. The two key ideas are to derive general propositions \nfrom expressions and to replace the type environment with a propositions environ\u00adment. These ideas increase \nthe type system s expressive power via reasoning tools from propositional logic. Acknowledgements Discussions \nwith Aaron Turon greatly improved this paper. The de\u00advelopment of Typed Racket has been supported by \nStevie Strick\u00adland, Eli Barzilay, Hari Prashanth K R, Vincent St-Amour, Ryan Culpepper and many others. \nJed Davis provided assistance with Coq. References A. Aiken, E. L. Wimmers, and T. K. Lakshman. Soft \ntyping with condi\u00adtional types. In Proc. 21st Symposium on Principles of Programming Languages, pages \n163 173. ACM Press, 1994. Y. Bertot and P. Cast\u00b4eran. Interactive Theorem Proving and Program Development, \nvolume XXV of EATCS Texts in Theoretical Computer Science. Springer-Verlag, 2004. G. M. Bierman, A. D. \nGordon, C. Hricu, and D. Langworthy. Semantic sub\u00adtyping with an SMT solver. In Proc. Fifteenth International \nConference on Functional Programming. ACM Press, 2010. R. Cartwright. User-de.ned data types as an aid \nto verifying LISP pro\u00adgrams. In International Conference on Automata, Languages and Pro\u00adgramming, pages \n228 256, 1976. K. Crary, S. Weirich, and G. Morrisett. Intensional polymorphism in type-erasure semantics. \nIn Proc. Third International Conference on Functional Programming, pages 301 312. ACM Press, 1998. H. \nCurry and R. Feys. Combinatory Logic, volume I. North-Holland, 1958. ECMA. ECMAScript Edition 4 group \nwiki, 2007. URL http://wiki.ecmascript.org/. M. Felleisen, R. B. Findler, M. Flatt, and S. Krishnamurthi. \nHow to Design Programs. MIT Press, 2001. URL http://www.htdp.org/. C. Flanagan and M. Felleisen. Componential \nset-based analysis. ACM Trans. Progr. Lang. Sys., 21(2):370 416, 1999. M. Flatt and PLT. Reference: Racket. \nReference Man\u00adual PLT-TR2010-1, PLT Scheme Inc., June 2010. http://racket-lang.org/techreports/. M. Furr, \nJ.-h. D. An, J. S. Foster, and M. Hicks. Static type inference for ruby. In SAC 09: Proc. 2009 ACM Symposium \non Applied Computing, pages 1859 1866. ACM Press, 2009. H. Ganzinger, G. Hagen, R. Nieuwenhuis, A. Oliveras, \nand C. Tinelli. DPLL(T): Fast Decision Procedures. In 16th International Conference on Computer Aided \nVeri.cation, CAV 04, volume 3114 of Lecture Notes in Computer Science, pages 175 188. Springer-Verlag, \n2004. F. Henglein. Dynamic typing: Syntax and proof theory. Sci. Comput. Programming, 22(3):197 230, \n1994. F. Henglein and J. Rehof. Safe polymorphic type inference for a dynami\u00adcally typed language: translating \nScheme to ML. In Proc. Seventh Inter\u00adnational Conference on Functional Programming Languages and Com\u00adputer \nArchitecture, pages 192 203. ACM Press, 1995. W. A. Howard. The formulas-as-types notion of construction. \nIn J. P. Seldin and J. Hindley, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, \nand Formalism, pages 479 490. Academic Press, 1980. R. Komondoor, G. Ramalingam, S. Chandra, and J. Field. \nDependent types for program understanding. In Tools and Algorithms for the Construction and Analysis \nof Systems, volume 3440 of Lecture Notes in Computer Science, pages 157 173. Springer-Verlag, 2005. J. \nM. Lucassen and D. K. Gifford. Polymorphic effect systems. In Proc. 15th Symposium on Principles of Programming \nLanguages, pages 47 57. ACM Press, 1988. C. McBride and J. McKinna. The view from the left. Journal of \nFunctional Programming, 14(1):69 111, 2004. U. Norell. Towards a practical programming language based \non dependent type theory. PhD thesis, Chalmers University of Technology, 2007. S. Peyton Jones, D. Vytiniotis, \nS. Weirich, and G. Washburn. Simple uni.cation-based type inference for GADTs. In Proc. Eleventh Inter\u00adnational \nConference on Functional Programming, pages 50 61. ACM Press, 2006. B. C. Pierce and D. N. Turner. Local \ntype inference. ACM Trans. Progr. Lang. Sys., 22(1):1 44, 2000. J. C. Reynolds. Automatic computation \nof data set de.nitions. In IFIP Congress (1), pages 456 461, 1968. O. Shivers. Control-Flow Analysis \nof Higher-Order Languages or Taming Lambda. PhD thesis, Carnegie Mellon University, Pittsburgh, Pennsyl\u00advania, \n1991. J. G. Siek and W. Taha. Gradual typing for functional languages. In Sev\u00adenth Workshop on Scheme \nand Functional Programming, University of Chicago Technical Report TR-2006-06, pages 81 92, September \n2006. V. Simonet and F. Pottier. A constraint-based approach to guarded algebraic data types. ACM Trans. \nProgr. Lang. Sys., 29(1):1 54, 2007. S. Thatte. Quasi-static typing. In Proc. 17th Symposium on Principles \nof Programming Languages, pages 367 381. ACM Press, 1990. S. Tobin-Hochstadt and M. Felleisen. The design \nand implementation of Typed Scheme. In Proc. 35th Symposium on Principles of Programming Languages, pages \n395 406. ACM Press, 2008. D. Vytiniotis, S. Peyton Jones, and T. Schrijvers. Let should not be generalized. \nIn TLDI 10: Proc. 5th workshop on Types in language design and implementation, pages 39 50. ACM Press, \n2010. P. Wadler and R. B. Findler. Well-typed programs can t be blamed. In ESOP 09: Proc. Eighteenth \nEuropean Symposium on Programming, volume 5502 of Lecture Notes in Computer Science, pages 1 16. Springer-Verlag, \n2009. A. K. Wright and R. Cartwright. A practical soft type system for Scheme. ACM Trans. Progr. Lang. \nSys., 19(1):87 152, 1997. \u00a8 typed and untyped code in a scripting language. In Proc. 37th Sympo\u00adsium \non Principles of Programming Languages, pages 377 388. ACM Press, 2010. T. Wrigstad, F. Z. Nardelli, \nS. Lebresne, J. Ostlund, and J. Vitek. Integrating     \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Programmers reason about their programs using a wide variety of formal and informal methods. Programmers in untyped languages such as Scheme or Erlang are able to use any such method to reason about the type behavior of their programs. Our type system for Scheme accommodates common reasoning methods by assigning variable occurrences a subtype of their declared type based on the predicates prior to the occurrence, a discipline dubbed <i>occurrence typing</i>. It thus enables programmers to enrich existing Scheme code with types, while requiring few changes to the code itself.</p> <p>Three years of practical experience has revealed serious shortcomings of our type system. In particular, it relied on a system of ad-hoc rules to relate combinations of predicates, it could not reason about subcomponents of data structures, and it could not follow sophisticated reasoning about the relationship among predicate tests, all of which are used in existing code.</p> <p>In this paper, we reformulate occurrence typing to eliminate these shortcomings. The new formulation derives propositional logic formulas that hold when an expression evaluates to true or false, respectively. A simple proof system is then used to determine types of variable occurrences from these propositions. Our implementation of this revised occurrence type system thus copes with many more untyped programming idioms than the original system.</p>", "authors": [{"name": "Sam Tobin-Hochstadt", "author_profile_id": "81319502825", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2338167", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2338168", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863561", "year": "2010", "article_id": "1863561", "conference": "ICFP", "title": "Logical types for untyped languages", "url": "http://dl.acm.org/citation.cfm?id=1863561"}