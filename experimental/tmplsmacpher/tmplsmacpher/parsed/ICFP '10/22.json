{"article_publication_date": "09-27-2010", "fulltext": "\n Fortifying Macros * Ryan Culpepper Matthias Felleisen Northeastern University {ryanc,matthias}@ccs.neu.edu \nAbstract Existing macro systems force programmers to make a choice be\u00adtween clarity of speci.cation and \nrobustness. If they choose clarity, they must forgo validating signi.cant parts of the speci.cation and \nthus produce low-quality language extensions. If they choose ro\u00adbustness, they must write in a style \nthat mingles the implementation with the speci.cation and therefore obscures the latter. This paper introduces \na new language for writing macros. With the new macro system, programmers naturally write robust language \nextensions using easy-to-understand speci.cations. The system translates these speci.cations into validators \nthat detect misuses including violations of context-sensitive constraints and automatically synthesize \nappropriate feedback, eliminating the need for ad hoc validation code. Categories and Subject Descriptors \nD.3.3 [Programming Lan\u00adguages]: Language Constructs and Features General Terms Design, Languages 1. What \nis a macro? Every functional programmer knows that a let expression can be expressed as the immediate \napplication of a . abstraction [Landin 1965]. The let expression s variables become the formal parame\u00adters \nof the . expression, the initialization expressions become the application s arguments, and the body \nbecomes the body of the . expression. Here is a quasi-formal expression of the idea: (let ([var rhs] \n...) body) = ((. (var ...) body) rhs ...) It is understood that each var is an identi.er and each rhs \nand body is an expression; the variables also must be distinct. These constraints might be stated as \nan aside to the above equation, and some might even be a consequence of metavariable conventions. New \nlanguage elements such as let can be implemented via macros, which automate the translation of new language \nforms into simpler ones. Essentially, macros are an API for extending the front end of the compiler. \nUnlike many language extension tools, however, a macro is part of the program whose syntax it extends; \nno separate pre-processor is used. * The research was partially supported by NSF infrastructure grants. \nNew address: School of Computing, 50 Central Campus Drive (Rm 3190), Salt Lake City, UT 84112-9205 Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 10, September \n27 29, 2010, Baltimore, Maryland, USA. Copyright c &#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 \nA macro de.nition associates a name with a compile-time func\u00adtion, i.e., a syntax transformer. When the \ncompiler encounters a use of the macro name, it calls the associated macro transformer to rewrite the \nexpression. Because macros are de.ned by translation, they are often called derived syntactic forms. \nIn the example above, the derived form let is expanded into the primitive forms . and function application. \nDue to the restricted syntax of macro uses the macro name must occur in operator position extensions \nto the language easily compose. Since extensions are anchored to names, extensions can be managed by \ncontrolling the scope of their names. This allows the construction of a tower of languages in layers. \nIntroducing new language elements, dubbed macros, has long been a standard element of every Lisper s \nand Schemer s reper\u00adtoire. Racket [Flatt and PLT 2010], formerly PLT Scheme, is a de\u00adscendent of Lisp \nand Scheme that uses macros pervasively in its standard libraries. Due in part to its pedagogical uses, \nRacket has high standards for error behavior. Languages built with macros are held to the same standards \nas Racket itself. In particular, syntactic mistakes should be reported in terms of the programmer s error, \nnot an error discovered after several rounds of rewriting; and further\u00admore, the mistake should be reported \nin terms documented by the language extension. Sadly, existing systems make it surprisingly dif.cult \nto pro\u00adduce easy-to-understand macros that properly validate their syn\u00adtax. These systems force the programmer \nto mingle the declarative speci.cation of syntax and semantics with highly detailed valida\u00adtion code. \nWithout validation, however, macros aren t true abstrac\u00adtions. Instead, erroneous terms .ow through the \nparsing process until they eventually trip over constraint checks at a low level in the language tower. \nLow-level checking, in turn, yields incoherent er\u00adror messages and leaves programmers searching for explanations. \nIn short, such macros do not create seamless linguistic abstractions but sources of confusion and distraction. \nIn this paper, we present a novel macro system for Racket that enables the creation of true syntactic \nabstractions. Programmers de.ne modular, reusable speci.cations of syntax and use them to validate uses \nof macros. The speci.cations consist of grammars extended with context-sensitive constraints. When a \nmacro is used improperly, the macro system uses the speci.cations to synthesize an error message at the \nproper level of abstraction. 2. Expressing macros To illustrate the problems with existing macro systems, \nlet us ex\u00adamine them in the context of the ubiquitous let example: (let ([var rhs] ...) body) = ((. (var \n...) body) rhs ...) the vars are distinct identi.ers body and the rhss are expressions A macro s syntax \ntransformer is essentially a function from syntax to syntax. Many Lisp dialects take that as the entirety \nof the in\u00adterface: macros are just distinguished functions, introduced with de.ne-macro instead of de.ne, \nthat consume and produce S\u00adexpressions representing terms. Macros in such systems typically use standard \nS-expression functions to parse syntax, and they use quasiquotation to build up the desugared expression: \n (de.ne-macro (let bindings body) ((. ,(map .rst bindings),body) ,@(map second bindings))) A well-organized \nimplementation would extract and name the sub\u00adterms before assembling the result, separating parsing \nfrom code generation: (de.ne-macro (let bindings body) (de.ne vars (map .rst bindings)) (de.ne rhss (map \nsecond bindings)) ((. ,vars ,body) ,@rhss)) These de.nitions do not resemble the speci.cation, however, \nand they do not even properly implement it. The parsing code does not validate the basic syntax of let. \nFor example, the macro simply ignores extra terms in a binding pair: (let ([x 1][y 3 \"what about me?\"]) \n(+ xy)) Macro writers, eager to move on as soon as it works, will continue to write sloppy macros like \nthese unless their tools make it easy to write robust ones. One such tool is the so-called Macro-By-Example \n(MBE) no\u00adtation by Kohlbecker and Wand [1987]. In MBE, macros are spec\u00adi.ed in a notation close to the \ninitial informal equation, and the parsing and transformation code is produced automatically. The generated \nparsing code enforces the declared syntax, rejecting mal\u00adformed uses such as the one above. MBE replaces \nthe procedural code with a sequence of clauses, each consisting of a pattern and a template. The patterns \ndescribe the macro s syntax. A pattern contains syntax pattern variables, and when a pattern matches, \nthe pattern variables are bound to the corresponding sub-terms of the macro occurrence. These sub-terms \nare substituted into the template where the pattern variables occur to produce the macro s expansion \nresult. Here is let expressed with syntax-rules [Sperber et al. 2009], one of many implementations of \nMBE: (de.ne-syntax let (syntax-rules () [(let ([var rhs] ...) body) ((. (var ...) body) rhs . . . )])) \n The pattern variables are var, rhs, and body. The crucial innovation of MBE is the use of ellipses (. \n. .) to describe sequences of sub-terms with homogeneous structure. Such sequences occur frequently in \nS-expression syntax. Some sequences have simple elements, such as the parameters of a . expression, but \noften the sequences have non-trivial structure, such as binding pairs associating let-bound variables \nwith their values. Every pattern variable has an associated ellipsis depth. A depth of 0 means the variable \ncontains a single term, a depth of 1 indicates a list of terms, and so on. Syntax templates are statically \nchecked to make sure the ellipsis depths are consistent. We do not address template checking and transcription \nin this work; see Kohlbecker and Wand [1987] for details. Ellipses do not add expressive power to the \nmacro system but do add expressiveness to patterns. Without ellipses, the let macro can still be expressed \nvia explicit recursion, but in a way that obscures the nature of valid let expressions; instead of residing \nin a single pattern, it would be distributed across multiple clauses of a recursive macro. In short, \nellipses help close the gap between speci.cation and implementation. Yet MBE lacks the power to express \nall of the information in the informal description of let above. The example macros presented so far \nneglect to validate two critical aspects of the let syntax: the .rst term of each binding pair must be \nan identi.er, and those identi.ers must be distinct. Consider these two misuses of let: (let ([x 1][x \n2]) (+ xx)) (let ([(xy)(f 7)]) (gxy)) In neither case does the let macro report that it has been used \nincor\u00adrectly. Both times it inspects the syntax, approves it, and produces an invalid . expression. Then \n., implemented by a careful com\u00adpiler writer, signals an error, such as .: duplicate identi.er in: x \nin Racket for the .rst term and invalid parameter list in (. ((xy)) (gxy)) in Chez Scheme [Cadence Research \nSystems 1994] for the second. Source location tracking [Dybvig et al. 1993] improves the situation somewhat \nin macro systems that offer it. For exam\u00adple, the DrRacket [Findler et al. 2002] programming environment \nhighlights the duplicate identi.er. But this is not a good solution. Macros should report errors on their \nown terms. Worse, a macro might pass through syntax that has an unin\u00adtended meaning. In Racket, the second \nexample above produces the surprising error unbound variable in: y. The pair (xy) is ac\u00adcepted as an \noptional parameter with a default expression, a feature of Racket s . syntax, and the error refers to \nthe free variable y in the latter portion. If y were bound in this context, the second ex\u00adample would \nbe silently accepted. A slight variation demonstrates another pitfall: (let ([(x)(f 7)]) (gxx)) This \ntime, Racket reports the following error: .: not an identi.er, identi.er with default, or keyword at: \n(x). The error message not only leaks the implementation of let, it implicitly obscures the legal syntax \nof let. (de.ne-syntax (let stx) (syntax-case stx () [(let ([var rhs] ...) body) ;; Guard expression \n(and (andmap identi.er? (syntax.list # (var . . . ))) (not (check-duplicate # (var . . . )))) ;; Transformation \nexpression # ((. (var ...) body) rhs . . . )])) Figure 1. let with guards The traditional solution to \nthis problem is to include a guard expression, sometimes called a fender, that is run after the pattern \nmatches but before the transformation expression is evaluated. The guard expression produces true or \nfalse to indicate whether its constraints are satis.ed. If the guard expression fails, the pattern is \nrejected and the next pattern is tried. If all of the patterns fail, the macro raises a generic syntax \nerror, such as bad syntax. Figure 1 shows the implementation of let in syntax-case [Dy\u00adbvig et al. 1993; \nSperber et al. 2009], an implementation of MBE that provides guard expressions. A syntax-case clause \nconsists of a pattern, an optional guard, and a transformation expression. Syntax templates within expressions \nare marked with a # pre.x. Guard expressions suf.ce to prevent macros from accepting invalid syntax, \nbut they suffer from two .aws. First, since guard expressions are separated from transformation expressions, \nwork needed both for validation and transformation must be performed twice and code is often duplicated. \nSecond and more important, guards do not explain why the syntax was invalid. That is, they only control \nmatching; they do not track causes of failure.  (de.ne-syntax (let stx) (syntax-case stx () [(let ([var \nrhs]...) body) (begin ;; Error-checking code (for-each (. (var) (unless (identi.er? var) (syntax-error \n\"expected identi.er\" stx var))) (syntax.list # (var . . . ))) (let ([dup (check-duplicate # (var . . \n. ))]) (when dup (syntax-error \"duplicate variable name\" stx dup))) ;; Result term # ((. (var ...) body) \nrhs . . . ))])) Figure 2. let with hand-coded error checking To provide precise error explanations, explicit \nerror checking is necessary, as shown in .gure 2. Of the ten non-comment lines of the macro s clause, \none is the pattern, one is the template, and eight are dedicated to validation. Furthermore, this macro \nonly reports errors that match the shape of the pattern. If it is given a malformed binding pair with \nextra terms after the right-hand side expression, the clause fails to match, and syntax-case produces \na generic error. Detecting and reporting those sorts of errors would require even more code. Only the \nmost conscientious macro writers are likely to take the time to enumerate all the ways the syntax could \nbe invalid and to issue appropriate error reports. Certainly, the code for let could be simpli.ed. Macro \nwriters could build libraries of common error-checking routines. Such an approach, however, would still \nobscure the natural two-line speci\u00ad.cation of let by mixing the error-checking code with the transfor\u00admation \ncode. Furthermore, abstractions that focus on raising syntax errors would not address the other purpose \nof guards, the selection among multiple valid alternatives. Even ignoring the nuances of error reporting, \nsome syntax is simply dif.cult to parse with MBE patterns. Macro writers cope in two ways: either they \ncompromise on the user s convenience with simpli.ed syntax or they hand-code the parser. (de.ne-struct \nstruct (.eld ...) option ...) where struct, .eld are identi.ers option ::= #:mutable | #:super super-struct-expr \n| #:inspector inspector-expr | #:property property-expr value-expr | #:transparent Figure 3. The syntax \nof de.ne-struct Keyword arguments are one kind of syntax dif.cult to parse using MBE patterns. An example \nof a keyword-enhanced macro is Racket s de.ne-struct form, whose grammar is speci.ed in .gure 3. It has \nseveral keyword options, which can occur in any order. The #:transparent and #:inspector keywords control \nwhen structure values can be inspected via re.ection. The #:mutable option makes the .elds mutable; the \n#:property option allows structure types to override behavior such as how they are printed; and so on. \nDifferent keywords come with different numbers of arguments, e.g., #:mutable has none and #:property \ntakes two. Parsing a de.ne-struct form gracefully is simply beyond the capabilities of MBE s pattern \nlanguage, which focuses on homo\u00adgeneous sequences. A single optional keyword argument can be supported \nby simply writing two clauses one with the argument and one without. At two arguments, calculating out \nthe patterns becomes onerous, and the macro writer is likely to make odd, ex\u00adpedient compromises arguments \nmust appear in some order, or if one argument is given, both must be. Beyond two arguments, the approach \nis unworkable. The alternative is, again, to move part of the parsing into the transformer code. The \nmacro writer sketches the rough structure of the syntax in broad strokes with a pattern, then .lls in \nthe details with procedural parsing code: (de.ne-syntax (de.ne-struct stx) (syntax-case stx () [(de.ne-struct \nname (.eld ...) kw-options ...) # (kw-options ...) ])) In the actual implementation of de.ne-struct, \nthe parsing of key\u00adword options alone takes over one hundred lines of code. In com\u00adparison, when formulated \nin our new system this code is shortened by an order of magnitude. In summary, MBE offers weak syntax \npatterns, forcing the programmer to move the work of validation and error-reporting into guards and transformers. \nFurthermore, guard expressions accept or reject entire clauses, and rejection comes without information \nas to why the guard failed. Finally, MBE lacks the vocabulary to describe a broad range of important \nsyntaxes. Our new domain\u00adspeci.c language for macros eliminates these problems. 3. The design of syntax-parse \nOur system, dubbed syntax-parse, uses a domain-speci.c lan\u00adguage to support parsing, validation, and \nerror reporting. It features three signi.cant improvements over MBE: an expressive language of syntax \npatterns, including pattern variables annotated with the classes of syntax they can match;  a facility \nfor de.ning new syntax classes as abstractions over syntax patterns; and  a matching algorithm that \ntracks progress to rank and report failures and a notion of failure that carries error information. \n Furthermore, guard expressions are replaced with side conditions, which provide rejection messages. \nThe syntax classes of our new system serve a role similar to that of non-terminals in traditional grammars. \nTheir addition allows the disciplined interleaving of declarative speci.cations and hand\u00adcoded checks. \nThis section illustrates the design of syntax-parse with a series of examples based on the let example. \n(syntax-parse stx-expr [pattern side-clause ... expr] ...) where side-clause ::= #:fail-when cond-expr \nmsg-expr | #:with pattern stx-expr Figure 4. Syntax of syntax-parse 3.1 Validating syntax The syntax \nof syntax-parse speci.ed in .gure 4 is similar to syntax-case. As a starting point, here is the let macro \ntransliterated from the syntax-rules version: (de.ne-syntax (let stx) (syntax-parse stx [(let ([var rhs] \n...) body) # ((. (var ...) body) rhs . . . )])) It enforces only the two side conditions in the original \nspeci.cation. To this skeleton we add the constraint that every term labeled var must be an identi.er. \nLikewise, rhs and body are annotated to indicate that they are expressions. For our purposes, an expression \nis any term other than a keyword. The .nal constraint, that the identi.ers are unique, is expressed as \na side condition using a #:fail-when clause. Here is the revised macro:  (de.ne-syntax (let stx) (syntax-parse \nstx [(let ([var:identi.er rhs:expr] ...) body:expr) #:fail-when (check-duplicate # (var . . . )) \"duplicate \nvariable name\" # ((. (var ...) body) rhs . . . )])) Note that a syntax class annotation such as expr \nis not part of the pattern variable name, and it does not appear in the template. The call to check-duplicate \nacts as a condition; if it is false, failure is averted and control .ows to the template expression. \nBut if it returns any other value, parsing fails with a duplicate variable name message; furthermore, \nif the condition value is a syntax object that is, the representation of a term that syntax is included \nas the speci.c site of the failure. In short, side conditions differ from guard expressions in that the \nfailures they generate carry information describing the reasons for the failure. At this point, our let \nmacro properly validates its syntax. It catches the misuses earlier and reports the following errors: \n> (let ([x 1][ x 2]) (hx)) let: duplicate variable name in: x > (let ([ (xy) (f 7)]) (gxy)) let: expected \nidenti.er in: (xy) The boxes indicates the speci.c location of the problem; the Dr-Racket programming \nenvironment highlights these terms in red in addition to printing the error message. For some misuses, \nlet still doesn t provide good error messages. Here is an example that is missing a pair of parentheses: \n> (let (x 5)(add1 x)) let: bad syntax Our let macro rejects this misuse with a generic error message. \nTo get better error messages, the macro writer must supply syntax\u00adparse with additional information. \n 3.2 De.ning syntax classes Syntax classes form the basis of syntax-parse s error-reporting mechanism. \nDe.ning a syntax class for binding pairs gives syntax\u00adparse the vocabulary to explain a new class of \nerrors. The syntax of binding pairs is de.ned as a syntax class thus: (de.ne-syntax-class binding #:description \n\"binding pair\" (pattern [var:identi.er rhs:expr])) The syntax class is named binding, but for the purposes \nof error reporting it is known as binding pair. Since the pattern variables var and rhs have moved out \nof the main pattern into the syntax class, they must be exported as attributes of the syntax class so \nthat their bindings are available to the main pattern. The name of the binding-annotated pattern variable, \nb, is combined with the names of the attributes to form the nested attributes b.var and b.rhs: (de.ne-syntax \n(let stx) (syntax-parse stx [(let (b:binding ...) body:expr) #:fail-when (check-duplicate # (b.var . \n. . )) \"duplicate variable name\" # ((. (b.var ...) body) b.rhs . . . )])) Macros tend to share common \nsyntactic structure. For example, the binding pair syntax, consisting of an identi.er for the variable \nname and an expression for its value, occurs in other variants of let, such as let* and letrec. In addition \nto patterns, syntax classes may contain side condi\u00adtions. For example, both the let and letrec forms \nrequire that their variable bindings be distinct. Here is an appropriate syntax class: (de.ne-syntax-class \ndistinct-bindings #:description \"sequence of binding pairs\" (pattern (b:binding ...) #:fail-when (check-duplicate \n# (var . . . )) \"duplicate variable name\" #:with (var ...) # (b.var ...) #:with (rhs ...) # (b.rhs . \n. . ))) The attributes of distinct-bindings are var and rhs. They are bound by the #:with clauses, each \nof which consists of a pattern followed by an expression, which may refer to previously bound attributes \nsuch as b.var. The expression s result is matched against the pat\u00adtern, and the pattern s attributes \nare available for export or for use by subsequent side clauses. Unlike the var and rhs attributes of \nbinding, the var and rhs attributes of distinct-bindings have an el\u00adlipsis depth of1, so bs.var and bs.rhs \ncan be used within ellipses in the macro s template, even if bs does not occur within ellipses in the \nmacro s pattern: (de.ne-syntax (let stx) (syntax-parse stx [(let bs:distinct-bindings body:expr) # ((. \n(bs.var ...) body) bs.rhs . . . )])) Now that we have speci.ed the syntax of binding and distinct\u00adbindings, \nsyntax-parse can use them to generate good error mes\u00adsage for additional misuses of let: > (let ( x 5)(add1 \nx)) let: expected binding pair in: x > (let 17 ) let: expected sequence of binding pairs in: 17 The \nnext section explains how syntax-parse generates error mes\u00adsages and how de.ning syntax classes affects \nerror reporting. 4. Reporting errors The syntax-parse system uses the declarative speci.cation of a macro \ns syntax to report errors in macro uses. The task of reporting errors is factored into two steps. First, \nthe matching algorithm selects the most appropriate error to report. Second, it reports the error by \npinpointing the faulty term and describing the fault or stating the expected class of syntax. 4.1 Error \nselection Pattern variable annotations and side conditions serve a dual role in our system. As seen, \npattern variable annotations and side condi\u00adtions allow syntax-parse to validate syntax. When validation \nfails, syntax-parse reports the speci.c site and cause of the failure. But annotations and side conditions \ndo not simply behave like the error checks of .gure 2. A macro can have multiple clauses, and a syntax \nclass can have multiple variants. If there are multiple choices, all of them must be attempted before \nan error is raised and explained. To illustrate this process, we must introduce choice into our running \nexample. Serendipitously, Racket inherits Scheme s let syntax, which has another variant a so-called \nnamed let that speci.es a name for the implicit procedure. This notation provides a handy loop-like syntax. \nFor example, the following program determines whether the majority of numbers in a list are positive: \n (de.ne (mostly-positive? nums) (let loop ([nums nums][pos 0][non 0]) (cond [(empty? nums)(> pos non)] \n[(positive? (.rst nums)) (loop (rest nums)(+ 1 pos) non)] [else (loop (rest nums) pos (+ 1 non))]))) \n Implementing the new variant of let is as simple as adding another clause to the macro: (de.ne-syntax \n(let stx) (syntax-parse stx [(let loop:identi.er bs:distinct-bindings body:expr) # (letrec ([Lp (. (bs.var \n...) body)]) (Lp bs.rhs . . . ))] [(let bs:distinct-bindings body:expr) # ((. (bs.var ...) body) bs.rhs \n. . . )])) The macro uses the annotations to pick the applicable pattern; it chooses named-let if the \n.rst argument is an identi.er and normal\u00adlet if it is a binding list. It happens that the two patterns \nare mutually exclusive, so the order of the clauses is irrelevant. The use of annotations to select the \nmatching clause must be reconciled with the role of annotations in error reporting. An an\u00adnotation rejection \nduring pattern-matching clearly cannot immedi\u00adately signal an error. But the annotations must retain \ntheir error\u00adreporting capacity; if the whole parsing process fails, the annota\u00adtions must be used to \ngenerate a speci.c error. The dual role of failure is supported using the following ap\u00adproach. When there \nare multiple alternatives, such as multiple syntax-parse clauses or multiple variants of a syntax class \nde.ni\u00adtion, they are tried in order. When an alternative fails, syntax-parse records the failure and \nbacktracks to the next alternative. As alter\u00adnatives are tried, syntax-parse accumulates a list of failures, \nand each failure contains a measure of the matching progress made. If the whole matching process fails, \nthe attempts that made the most progress are chosen to explain the syntax error. Usually, but not always, \nthere is a unique maximum, resulting in a single error explanation. Otherwise, the maximal failures are \ncombined. Progress p ::= ps * Progress Step ps ::= FIRST | REST | LATE FIRST < REST < LATE p1 <p2 ps1 \n< ps2E< ps \u00b7 p ps \u00b7 p1 < ps \u00b7 p2 ps1 \u00b7 p1 < ps2 \u00b7 p2 Figure 5. Progress Figure 5 de.nes our notion of \nprogress as sequences of progress steps. The progress steps FIRST and REST indicate the .rst and rest \nof a compound term, respectively. Parsing is performed left to right; if the parser is looking at the \nrest of a compound term, the .rst part must have been parsed successfully. Progress is ordered lexicographically. \nSteps are recorded left to right, so for example the second term in a sequence is written REST \u00b7 FIRST; \nthat is, take the rest of the full term and then the .rst part of that. Consider the following erroneous \nlet term: (let ([a 1][2 b]) (* ab)) The named-let clause fails at the second sub-term with the progress \nstring REST \u00b7 FIRST: (let ([a 1][2 b]) (* ab)) The normal-let clause, however, fails deeper within the \nsecond argument, at REST \u00b7 FIRST \u00b7 REST \u00b7 FIRST \u00b7 FIRST: (let ([a 1][ 2 b]) (* ab)) This second sequence \ndenotes strictly more progress than REST \u00b7 FIRST. Thus, the second failure is selected, and the macro \nreports that it expected an identi.er in place of 2. Matching progress is not only a measure of position \nin a term. Consider the following example: (let ([x 1][x 2]) (+ xx)) Both clauses agree on the faulty \nsubterm. But this example is clearly closer to a use of normal-let rather than named-let. The faulty \nterm matches the structure of distinct-bindings, just not the side condition. Pragmatically, we consider \na check for side conditions in con\u00adtrast to an annotation check to occur after traversal of the term. \nA progress step dubbed LATE signals the failure of a side condi\u00adtion. Thus, while the named-let clause \nfails with the progress string REST \u00b7FIRST in the example above, the normal-let clause fails with REST \n\u00b7 FIRST \u00b7 LATE, which is greater progress than the .rst. Sometimes multiple alternatives fail at the \nsame place, e.g., > (let 5 ) let: expected identi.er or sequence of binding pairs in: 5 Both clauses \nmake the same amount of progress with this term: REST \u00b7 FIRST. As a result, both failures are selected, \nand the error message includes both descriptions.  4.2 Error messages In addition to progress, a failure \ncontains a message that indicates the nature of the error and the term where the failure occurred. A \ntypical error message is let: expected binding pair in: x This message consists of the macro s expectations \n(a binding pair) and the speci.c term where parsing failed (x). A syntax error should identify the faulty \nterm and concisely explain what was expected. It should not recapitulate the macro s documentation; rather, \nthe error message should make locating the appropriate documentation easy, e.g., via links and references. \nConsequently, syntax-parse produces messages from a limited set of ingredients. It automatically synthesizes \nmessages for literal and datum patterns; for example, the pattern 5 yields the message expected the literal \n5. As a special case, it also knows how to report when a compound term has too many sub-terms. The only \nother ingredients it uses are provided by the macro developer: descriptions and side-condition messages. \nIn particular, syntax-parse does not synthesize messages to describe compound patterns. We call such \npatterns and the failures they cause ineffable ; our system cannot generate explanations for them. An \nexample is the following pattern: (var:identi.er rhs:expr) If a term such as 5 is matched against this \npattern, it fails to match the compound structure of the pattern. The matching process does not reach \nthe identi.er or expression check. One possible error message is expected a compound term consisting \nof an identi.er and an expression. Another is expected (identi.er expr). In prac\u00adtice, macro writers \noccasionally write error messages of both forms. We have chosen not to generate such messages automatically \nfor two reasons: .rst, they do not scale well to large or sophisticated patterns; and second, we consider \nsuch messages misguided. Generating messages from patterns is feasible when the patterns are simple, \nsuch as the example above. For patterns with deeper nesting and patterns using advanced features, however, \ngenerating an accurate message is tantamount to simply displaying the pattern itself. While showing patterns \nin failures is a useful debugging aid for macro developers, it is a bad way to construct robust linguis\u00adtic \nabstractions. Error reporting should be based on documented concepts, not implementation details.  When \na compound pattern such as the one above fails, the pattern s context is searched and the nearest enclosing \ndescription is used to report the error. Consider the following misuse of let: (let (x 1)(add1 x)) The \nerror selection algorithm from section 4.1 determines that the most speci.c failure arose trying to match \nx against the pattern (var:identi.er rhs:expr). Here is the full context of the failure: matching x \nagainst (var:identi.er rhs:expr) failed  while matching x against b:binding  while matching (x 1) against \nbs:distinct-bindings  while matching (let (x 1)(add1 x)) against the complex pattern (let bs:distinct-bindings \nbody:expr)  The .rst and fourth frames contain ineffable patterns. Discarding them and rephrasing the \nexpected syntax gives us the following context: expected binding pair, given x  expected sequence of \nbinding pairs, given (x 1)  The message and term of the .rst frame are used to formulate the error message \nlet: expected binding pair in: x because it is the closest one. 5. Syntax patterns The power of syntax-parse \nis due to its expressive pattern lan\u00adguage, an extension of the syntax patterns of MBE. Sections 3 and \n4 have introduced some features of our pattern language. This sec\u00adtion describes additional pattern forms \nthat, in our experience, in\u00adcrease the expressive power of our system to the level necessary for developing \nreal syntax speci.cations. Patterns S ::= x | x : class | (S . S) | (S ... . S) | datum | ( literal x) \n| ( var x (class e * )) | ( and S+) | ( or S+) | ( describe expr S) Figure 6. Single-term patterns 5.1 \nSingle-term patterns Figure 6 describes the syntax of syntax patterns, speci.cally single\u00adterm patterns, \nthe kind of pattern that speci.es sets of single terms. The .rst four pattern variables, annotated pattern \nvariables, pair patterns, and ellipsis patterns appear in section 3. So do datum patterns, in the form \nof (), which ends compound patterns.1 In gen\u00aderal, data like numbers, booleans, and strings can be used \nas pat\u00adterns that match themselves. The literal pattern form2 recognizes identi.ers that have the same \nbinding as the enclosed identi.er; this 1 The notation (ab) is shorthand for (a .(b . ())). 2 All pattern \nkeywords start with a tilde ( ). (de.ne-syntax-class distinct-bindings #:description \"sequence of binding \npairs\" (pattern ( var bs (bindings-excluding ())) #:with (var ...)(bs.var ...) #:with (rhs ...)(bs.rhs \n. . . ))) ;; seen is a list of identi.ers (de.ne-syntax-class (bindings-excluding seen) (pattern () \n#:with (var ...) () #:with (rhs ...) ()) (pattern ([( var var0 (id-excluding seen)) rhs0] .( var rest \n(bindings-excluding (cons # var0 seen)))) #:with (var ...) # (var0 rest.var ...) #:with (rhs ...) # (rhs0 \nrest.rhs . . . ))) ;; seen is a list of identi.ers (de.ne-syntax-class (id-excluding seen) (pattern x:identi.er \n#:fail-when (for/or ([id seen]) (bound-identi.er=? # x id)) \"duplicate variable name\")) Figure 7. Parameterized \nsyntax classes is the standard notion of identi.er equality in hygienic macro sys\u00adtems [Dybvig et al. \n1993]. A var pattern constrains a pattern variable to a syntax class. The colon notation is a shorthand \nfor parameterless syntax classes; e.g., x:identi.er is short for ( var x (identi.er)). When the syntax \nclass takes parameters, the explicit var notation is required. A syntax class s parameters may be used \nin its sub-expressions, including its description and any of its side conditions. For exam\u00adple, here \nis a syntax class that recognizes literal natural numbers less than some upper bound: ;; ex.: the pattern \n( var n (nat< 10)) matches ;; any literal natural number less than 10 (de.ne-syntax-class (nat< bound) \n#:description (format \"natural number < s\" bound) (pattern n:nat #:fail-when (not (< (syntax.datum # \nn) bound)) (format \"got a number s or greater\" bound))) Notice how the upper bound is inserted into both \nthe description and the check message using the format procedure. We can use parameterized syntax classes \nto give an alternative de.nition of distinct-bindings, via a syntax class parameterized over the identi.ers \nthat have already been seen. Figure 7 shows the alternative de.nition and the auxiliaries bindings-excluding \nand id-excluding. The pattern bindings-excluding syntax class accepts sequences of distinct bindings \nbut also requires that the bound names not occur in seen. Consider bindings-excluding s second pattern; \nvar0 must be an identi.er not in seen, and the identi.er bound to var0 is added to the blacklisted identi.ers \nfor the rest of the binding sequence. Note that var0 is in scope in the argument to bindings-excluding. \nSince patterns are matched left to right, pattern variable binding also runs left to right, following \nthe principle of scope being determined by control dominance [Shivers 2005]. While it accepts the same \nterms, this alternative de.nition of distinct-bindings reports errors differently from the one in sec\u00adtion \n3.2. The .rst de.nition veri.es the structure of the binding pairs .rst, then checks for a duplicate \nname. The second checks the structure and checks duplicates in the same pass. They thus report different \nerrors for the following term: (let ([a 1][a 2][xyz]) a) In such cases, the macro writer must decide \nthe most suitable order of validation.  The and pattern form provides a way of analyzing a term multiple \nways. Matching order and binding go left to right within an and pattern, so later sub-patterns can rely \non earlier ones. The or form matches if any of its sub-patterns match. Unlike in many pattern matching \nsystems, where disjunction, if it is sup\u00adported at all, requires that the disjuncts bind the same pattern \nvari\u00adables, or patterns are more .exible. An or pattern binds the union of its disjuncts attributes, \nand those attributes that do not occur in the matching disjunct are marked absent. It is illegal to use \nan absent attribute in a syntax template, so syntax-parse provides the attribute form, which accesses \nthe value of the attribute, returning false for absent attributes. Using attribute, a programmer can \ncheck whether it is safe to use an attribute in a template. Here is an auxiliary function for parsing \n.eld declarations for a class macro, where a .eld declaration contains either a single name or distinct \ninternal and external names: (de.ne (parse-.eld-declaration stx) (syntax-parse stx [( or .eld:identi.er \n[internal:identi.er .eld:identi.er]) (make-.eld (if (attribute internal) # internal # .eld) # .eld)])) \nSome uses of or patterns are better expressed as syntax classes, not least because a syntax class can \nuse a #:with clause to bind missing attributes: (de.ne-syntax-class .eld-declaration (pattern .eld:id \n#:with internal # .eld) (pattern [internal:id .eld:id])) The .nal pattern form, describe, pushes a new \ndescription d onto the matching context of its sub-pattern. Hence, if a failure occurs and if there is \nno other description closer to the source of the error, the description d is used to explain the failure. \nThere is no difference between a description attached to a syntax class and one given via describe. Recall \nthe binding and distinct\u00adbindings syntax class de.nitions from section 3.2; the binding syntax class \ncould be inlined into distinct-bindings as follows: (de.ne-syntax-class distinct-bindings #:description \n\"sequence of distinct binding pairs\" (pattern (( describe \"binding pair\" [var:identi.er rhs:expr]) ...) \n#:fail-when )) In fact, distinct-bindings could be inlined into the let macro itself using describe \nand action patterns. Action patterns A ::= ( parse S expr) | ( fail condition message) | ( late A) Patterns \nS ::= \u00b7\u00b7\u00b7 | ( and S {S|A} * ) Figure 8. Action patterns  5.2 Action patterns The action patterns of \n.gure 8 do not describe syntax; instead, they affect the parsing process without consuming input. The \nparse form allows the programmer to divert matching from the current input to a computed term; fail provides \na way of explicitly causing a match failure; and late affects the ordering of failures. The parse form \nevaluates its sub-expression and matches it against the given pattern. One use for the parse form is \nto bind default values within an or pattern, avoiding the need for explicit attribute checks later. Recall \nparse-.eld-declaration. Here internal is bound in both alternatives, simplifying the result template: \n(de.ne (parse-.eld-declaration stx) (syntax-parse stx [( or ( and .eld:identi.er ( parse internal # .eld)) \n[internal:identi.er .eld:identi.er]) (make-.eld # internal # .eld)])) This example also shows the use \nof and to sequence an action pattern after a single-term pattern. Since and propagates attributes bound \nin each of its sub-patterns to subsequent sub-patterns, and can be used to parse a term and then perform \nactions depending on the contents of the term. The fail patterns allow programmers to perform side-constraint \nchecks. Additionally, if the condition evaluates to a syntax value, it is added to the failure as the \nspeci.c term that caused the error. By default, fail performs early checks. For example, the iden\u00adti.er \nsyntax class performs its test as an early check: (de.ne-syntax-class identi.er (pattern ( and x ( fail \n(not (identi.er? # x)) no-msg)))) The late form turns enclosed checks into late checks. In fact, the \n#:fail-when keyword option used in distinct-bindings is just shorthand for a combination of late and \nfail: (de.ne-syntax-class distinct-bindings #:description \"sequence of distinct bindings\" (pattern ( \nand (b:binding ...) ( late ( fail (check-duplicate # (b.var . . . )) \"duplicate variable name\"))))) \n 5.3 Head patterns The patterns of Sections 5.1 and 5.2 do not provide the power needed to parse macros \nlike de.ne-struct from .gure 3. There are elements of de.ne-struct s syntax that comprise multiple consecu\u00adtive \nterms, but single-term patterns describe only single terms, and action patterns do not describe terms \nat all. An occurrence of the super option, for example, consists of two adjacent terms: the key\u00adword \n#:super followed by an expression, e.g., (de.ne-struct point (xy) #:super geometry #:mutable) No single-term \npattern describes the inspector option. In particular, the pattern (#:super sup:expr) does not, because \n#:super and its argument do not appear as a separate parenthesized term, such as (#:super geometry). \nHead patterns H ::= ( seq . L) | ( and H {H |A} * ) | ( or H +) | ( describe expr H ) | S List pattern \nL ::= () | (S . L) | (H . L) | (H ... . L) Patterns S ::= \u00b7\u00b7\u00b7 | (H . S) | (H ... . S) Figure 9. Head \npatterns Our solution is to introduce the head patterns of .gure 9, which describe sequences of terms. \nThe primary head pattern constructor is seq, which is followed by a proper list pattern (L). For example, \n( seq x:identi.er ... y:expr) matches a sequence of any number of identi.ers followed by one expression. \nContrast that pattern with (x:identi.er ... y:expr), which matches a single compound term containing \na sequence of identi.ers followed by an expression.  A head pattern may be combined with a normal single-term \npat\u00adtern to form a single-term pattern. The combined pattern matches a term by attempting to split it \ninto a pre.x sequence of terms that matches the head pattern and a suf.x term that matches the tail. \nThe term need not be a compound term if the pre.x can be empty. For example, the pattern (( seq xyz) \nw:identi.er . . . ) matches the term (123 ab) because the term can be split into the pre.x of three terms \n123 matching ( seq xyz) and the suf.x (ab) matching (w:identi.er . . . ). Of course, (( seq xyz) w:identi.er \n. . . ) is equiv\u00adalent to (x y z w:identi.er ...). The seq pattern is useful primarily when combined \nwith other pattern forms, such as and and or, as in macros with optional keyword arguments: (de.ne-syntax \n(test-case stx) (syntax-parse stx [(test-case ( or ( seq #:around proc)( seq)) e:expr) (attribute proc) \n ])) Head patterns are not intrinsically tied to keywords, of course. We could describe the syntax of \nlet, accommodating both normal-let and named-let syntax, with the following pattern: (let ( or ( seq \nloop:identi.er)( seq)) bs:distinct-bindings body:expr) Splicing syntax classes encapsulate head patterns. \nEach of its variants is a head pattern (H ), most often a seq pattern, although other kinds of head pattern \nare possible. The optional #:around keyword argument could be extracted thus: (de.ne-splicing-syntax-class \noptional-around (pattern ( seq #:around proc)) (pattern ( seq) #:with proc # (. (p)(p)))) A pattern \nvariable annotated with a splicing syntax class can repre\u00adsent multiple terms. In this example, ka matches \ntwo terms: (de.ne-syntax (test-case stx) (syntax-parse stx [(test-case ka:optional-around e) # ka.proc \n ])) (test-case #:around call-with-connection ) Head patterns can also occur in front of ellipses. In \nthose cases, a few additional variants are available that enable macro writers to support multiple optional \narguments occurring in any order. Ellipsis patterns EH ::= ( or EH +) | ( once H #:name expr) | ( optional \nH #:name expr) | H Patterns S ::= \u00b7\u00b7\u00b7 | (EH ... . S) List patterns L ::= \u00b7\u00b7\u00b7 | (EH ... . L) Figure 10. \nEllipsis-head patterns  5.4 Ellipsis-head patterns Ellipsis-head patterns speci.ed in .gure 5.4 are \nthe .nal ingredi\u00adent necessary to specify syntax like the keyword options of de.ne\u00adstruct. An ellipsis-head \npattern may have multiple alternatives combined with or; each alternative is a head pattern. It speci.es \n(de.ne-struct name:identi.er (.eld:identi.er ...) ( or ( optional ( seq #:mutable) #:name \"mutable clause\") \n( optional ( seq #:super super-expr) #:name \"super clause\") ( optional ( or ( seq #:inspector inspector-expr) \n( seq #:transparent)) #:name \"inspector or transparent clause\") ( seq #:property pkey:expr pval:expr)) \n. . . ))) Figure 11. syntax-parse pattern for de.ne-struct sequences consisting of some number of instances \nof the alterna\u00adtives joined together. An alternative may be annotated with one of two repetition constraint \nforms, optional and once, that restrict the number of times that alternative may appear in the sequence. \nThe meaning of an or-pattern changes slightly when it occurs immediately before ellipses. Instead of \nabsent values accruing for every alternative that is not chosen, only the chosen alternative accrues \nattribute values. Consequently, when the term (1 a 2 bc) is matched against the pattern (( or x:identi.er \ny:number) ...), x matches (abc) and y matches (12). These extensions to ellipses and head patterns provide \nenough power to specify de.ne-struct s syntax. Figure 11 shows the com\u00adplete pattern. After the .elds \ncome the keyword options, in any or\u00adder. Keywords and their arguments are grouped together with seq patterns. \nMany of the options can occur at most once, so they are wrapped with optional patterns. The exception \nis the #:property option, which can occur any number of times. The #:inspector and #:transparent options \nare mutually exclusive, so they are grouped together under one optional disjunct. 6. Semantics The syntax-parse \nmatching algorithm is based on two principles:  Errors are selected from all failures based on progress. \n Errors are described using explicitly-provided descriptions.  This section presents the semantics \nof pattern matching in syntax\u00adparse and explains how it implements the two principles. The error selection \nalgorithm is represented by a backtracking monad with a notion of failure that incorporates matching \nprogress. The error description principle is implemented by the semantic functions, which propagate error \ndescriptions as an inherited attribute. 6.1 Tracking failure We model backtracking with failure information \nwith a single\u00adelimination monad, a variant of well-known backtracking mon\u00adads [Hughes 1995]. A single-elimination \n(SE) sequence consists of a .nite list of successes (ai) terminated by at most one failure (f): (a1, \n\u00b7\u00b7\u00b7 ,an; f The monad is parameterized by the type of success elements; see below. The sequences of successes \nmay be empty. For simplicity we always include the failure and use to represent no failure. The important \naspect of this monad is its handling of failures, which models our macro system s error selection algorithm. \nA failure (other than ) consists of a progress (p) together with a set of reasons (e). Each reason consists \nof a term and a message. When sequences are combined, their failures are joined: (1) the failure with \nthe greatest progress (see .gure 5) is selected; (2) if they have the same progress, their message sets \nare combined. The identity element is ; it is considered to have less progress than any other failure. \nFailure is a bounded join-semilattice with least element . Figure 12 de.nes the monad s operations, including \nunit, bind (written *), and disjoin (written ). The unit operation creates a  SE(A) se ::= (a1, \u00b7\u00b7\u00b7 \n,an; f where ai . A Failure f ::= | FAIL(p, {e1, \u00b7\u00b7\u00b7 ,en}) Progress p ::= E | p \u00b7 FIRST | p \u00b7 REST | \np \u00b7 LATE Reason e ::= (z, msg) Message msg unit(a)= (a; fail(p, e)= ( ; FAIL(p, {e}) (a1, \u00b7\u00b7\u00b7 ,an; f \n*f = f(a1) \u00b7\u00b7\u00b7 f(an) ( ; f (a1, \u00b7\u00b7\u00b7 ,ak; f1 (ak+1, \u00b7\u00b7\u00b7 ,an; f2 = (a1, \u00b7\u00b7\u00b7 ,ak,ak+1, \u00b7\u00b7\u00b7 ,an; f1 . f2 \nFigure 12. Single-elimination sequences and operations sequence of one success and no failure. Disjoin \n( ) concatenates successes and joins (.) the failures, and bind (*) applies a function to all successes \nin a sequence and combines the resulting sequences with the original failure. This monad is similar to \nthe standard list monad except for the way it handles failures. One might expect to use the simpler model \nof a list of suc\u00adcesses or a failure. After all, if a pattern succeeds, backtracking typ\u00adically occurs \nonly when triggered by a failure of greater progress, which would make any failure in the prior pattern \nirrelevant. This is not always the case, however. Furthermore, our choice has two advantages over the \nseemingly simpler model. First, ranking fail\u00adures purely by progress is compelling and easy for programmers \nto understand. Second, this monad corresponds neatly to a two\u00adcontinuation implementation [Wand and Vaillancourt \n2004].  6.2 Domains and signatures We explain pattern matching on a core version of the pattern language. \nThe colon shorthand for annotated pattern variables is desugared into the var form. Similarly, all datum \npatterns are given as explicit datum patterns. All and and or patterns are converted to have exactly \ntwo sub-patterns; and patterns must be Term z ::= x | datum | () | (z1 . z2) Substitution s, . ::= {x1 \n. zn, \u00b7\u00b7\u00b7 ,xn . zn} s U(s1, \u00b7\u00b7\u00b7 ,sn; f = (s U s1, \u00b7\u00b7\u00b7 ,s U sn; f S[ S] .. zpe : SE(Substitution) A[ A] \n.. pe : SE(Substitution) H[ H ] .. zpe : SE(Substitution, Term, Progress) Figure 13. Domains, operations, \nsignatures for pattern semantics overload the combination operator notation; when the right-hand side \nis a SE-sequence, it indicates that the left-hand substitution is combined with every substitution in \nthe sequence. The pattern denotation functions are parameterized over a set of syntax de.nitions . and \na substitution . from patterns already matched. In addition to the appropriate patterns, the denotation \nfunctions take up to three additional arguments: a term (z) to parse, a progress string (p), and a failure \nreason (e). The term and progress ( arguments change as the matching algorithm descends into the term. \nThe term argument is not needed, however, for action pat\u00adterns. The reason argument represents the closest \nenclosing de\u00adscription; it changes when matching passes into a describe form. Each of the pattern denotation \nfunction returns a SE-sequence representing successes and failure. The S and A functions return sequences \nwhose success elements are substitutions. The H func\u00adtion additionally includes terms and progress strings, \nwhich indi\u00adcate where to resume matching. S[[( var x)]].. zpe = unit({x . z}) S[[( var x (cS e))]]. zpe \n. {y .eval(e,.)} = S[ S] zpe * .s. pfx(x, s) U unit({x . z}) . where {cS(y)= S}. . S[[( datum d)]]. \nzpe . unit(\u00d8) when z = d = left-associated so that any action patterns in the original and pat\u00ad fail(p, \n(z, expected d )) otherwise tern occur as second sub-patterns of the desugared and patterns. . zpe The \ndisjuncts of core or patterns all bind the same attributes; addi\u00ad tional bindings via and and parse are \nadded as necessary to make absent attributes explicit. 8 >>>< S[[(S1 . S2)]].S[ S1] . .z1(p\u00b7FIRST)e .us \n* .s. sUS[ S2] . z2(p \u00b7 REST)e = We generalize the repetition constraint forms optional and once to a \nbetween form. An unconstrained ellipsis head pattern is >>>: when z = (z1 . z2) otherwisemodeled as a \nbetween pattern with Nmin =0 and Nmax = 8. Each fail(p, e) repetition disjunct has a distinct label \n(R) used to track repetitions and two message expressions, one to report too few repetitions and one \nfor too many. We omit the ellipsis nesting depth of attributes; it is a static property and as such easy \nto compute separately. Syntax classes take a single parameter and references to syn\u00adtax classes are updated \naccordingly. The syntax class s variants are combined into a single or pattern, which is wrapped with \na describe pattern holding the syntax class s description. Finally, we assume an eval function for evaluating \nexpressions. The environment of evaluation is a substitution with mappings for attributes encountered \npreviously in the pattern matching process. For simplicity, we do not model the environment corresponding \nto the program context. It would be easy but tedious to add. Figure 13 de.nes the additional domains \nand operations used by the semantics as well as the signatures of the denotation functions. Terms consist \nof atoms and dotted pairs of terms. Parsing success is represented by a substitution s mapping names \nto terms. Substi\u00adtutions are combined by the U operator, which produces a substi\u00adtution with the union \nof the two arguments attribute bindings. We S[[( and S1 S2)]].. zpe ..us = S[ S1] .zpe * .s. s US[ S2] \n. zpe S[[( and S1 A2)]].. zpe ..us = zpe * .s. s UA[ A2] pe S[ S1] .. S[[( or S1 S2)]].. zpe = S[ S1] \n. zpe S[ S2] . zpe .. S[[( describe e S)]]. zpe . = S[ S] .. zp(z, eval(., e)) S[[(H1 . S2)]].. zpe \n'p' = H[ H1] . zpe * .(s, z',p').s US[ S2] .us ze .. Figure 14. Semantics of S-patterns  6.3 Meaning \nA syntax-parse expression has the following form: (syntax-parse stx [S1 rhs1] ... [Sn rhsn])  The meaning \nof the syntax-parse expression is de.ned via the following denotation: S[ S] \u00d8 .zEe where result is fresh \nwith respect to S, . S = ( or ( and S1 ( parse result rhs1)) \u00b7\u00b7\u00b7 ( and Sn ( parse result rhsn))) z = \neval(stx, \u00d8) e =(z, bad syntax ) If the sequence contains at least one substitution, the result of the \nsyntax-parse expression is the result attribute of the .rst substitu\u00adtion in the sequence. Otherwise, \nthe syntax-parse expression fails with an error message derived from the SE-sequence s failure. Figure \n14 shows the denotations of single-term patterns. A vari\u00adable pattern always matches, and it produces \na substitution mapping the pattern variable to the input term. A class pattern matches ac\u00adcording to \nthe pattern recorded in the syntax class environment .. The resulting substitutions attributes are pre.xed \n(pfx) with the pattern variable, and the pattern variable binding itself is added. When a datum pattern \nfails, it synthesizes an error message based on the expected datum. The other pattern variants use the \ninherited error reason (e), which represents the closest enclosing description around the pattern. That \nis, it represents the nearest explainable frame in the matching context. The pair, head, and and patterns \npropagate the success sub\u00adstitutions from their .rst sub-patterns to their second sub-patterns. This \nallows expressions within patterns to refer to attributes bound by previous patterns. Head patterns also \nproduce a term and progress string in addition to each success substitution; the term and progress indicate \nwhere to resume matching. A[[( parse S e)]].. pe = S[ S] .. (eval(e, .))(p \u00b7 LATE)e . A[[( fail econd \nemsg )]] . H[[( seq . L)]]. zpe . = S[ S] . zpe * .s. (s -{pr, term},s(pr),s(term)) . where S = rewrite-L(L) \nS[[( end-of-head)]].. zpe = unit({pr = p, term = z}) H[[( and H1 H2)]]. zpe . = H[ H1] .. zpe * .(s, \nz ' ,p ' ).s US[ S2] .. (take(z, p, p ' ))pe where S2 =(H2 . ()) H[[( or H1 H2)]]. zpe . = H[ H1] .. \nzpe H[ H2] .. zpe H[[( var x (cH e))]].. zpe {y.eval(e,.)} = H[ H ] . zpe * f where {cH(y)= H }. . \nf(s, z ' ,p ' ) = unit(g(s, p ' ),z ' ,p ' ) g(s, p ' )= {x . take(z, p, p ' )}U pfx(x, s) pr, term do \nnot appear in the pattern rewrite-L(()) = ( end-of-head) rewrite-L((S1 . L2)) = (S1 . rewrite-L(L2)) \nrewrite-L((H1 . L2)) = (H1 . rewrite-L(L2)) rewrite-L((EH 1 ... . L2)) = (EH 1 ... . rewrite-L(L2)) \nFigure 16. Semantics of H-patterns yields a repetition environment mapping a between form to the number \nof times it has occurred in the sequence so far. A between form s lower bound is checked when matching \nproceeds to the tail; its upper bound is checked on every iteration of the head pattern. pe 6.4 Implementation \n8 >< >: fail(p, (v, eval(emsg ,.))) The implementation of syntax-parse uses a two-continuation rep\u00ad if \nv is a true value, where v = eval(econd ,.) = resentation of the backtracking monad. The success continuation \n unit(\u00d8) otherwise is represented as an expression where possible, so that substitu\u00ad. pe tions are represented \nin Racket s environment rather than as a data A[[( late A)]] . structure. Thus, the code is similar to \nthe backtracking-automaton = A[ A] .. (p \u00b7 LATE)e method of compiling pattern matching. We have not yet \nattempted to add known pattern-matching optimizations to our implementa\u00adtion but plan on doing so. Optimizations \nmust be adapted to accom\u00admodate progress tracking. For example, exit optimization [Fessant Figure 15. \nSemantics of A-patterns Action patterns, unlike other kinds of patterns, do not depend and Maranget 2001] \nmay not skip a clause that cannot succeed if on the term being matched. Like single-term patterns, however, \nthe clause may fail with greater progress than the exiting clause. they produce records. Figure 15 displays \nthe denotations of action patterns. The parse pattern evaluates its sub-expression to a term and matches \nthat term against the sub-pattern. The fail pattern 7. Case studies Racket has included syntax-parse \nfor one year. Reformulatingevaluates its condition expression in the context of the previous existing \nmacros with syntax-parse can cut parsing code by severalattributes. Depending on the result, it either \nsucceeds with an empty factors without loss in quality in error reporting. Users con.rm thatrecord or \nfails with the associated label. The late form extends the progress string, marking the enclosed pattern \nas a late check. A seq pattern matches a sequence of terms if the embedded list pattern would match the \ncompound term consisting of those terms. Rather than duplicating and modifying the denotation function \nfor single-term patterns to work with list patterns, we reuse S and add a new variant of single-term \npattern, ( end-of-head), that sneaks the additional information into the substitution. For head and patterns, \nwe perform the opposite transformation; after the .rst conjunct matches a sequence of terms, we convert \nthat sequence into a term (take). We convert the second conjunct from a head pattern to a single-term \npattern and use it to match the new term. We omit the semantics of ellipsis patterns. It is similar to \nthe semantics of head patterns, but an ellipsis-head pattern additionally syntax-parse makes it easy \nto write macros for complex syntax. The primary bene.t, however, is increased clarity and robustness. \nThis section presents two case studies illustrating applications of syntax-parse. The case studies are \nchosen from a large series to span the spectrum of robustness; the .rst case study initially performed \nalmost no error checking, whereas the second case study checked errors aggressively. Each case study \nstarts with a purpose statement, followed by an analysis of the difference in behavior and a comparison \nof the two pieces of code. 7.1 Case: loop The loop macro [Shivers 2005] allows programmers to express \na wide range of iteration constructs via loop clauses. The loop macro is an ideal case study because \nthe existing implementation performs almost no error-checking, and its author makes the following claim: \n It is frequently the case with robust, industrial-strength soft\u00adware systems for error-handling code \nto dominate the line counts; the loop package is no different. Adding the code to provide careful syntax \nchecking and clear error messages is tedious but straightforward implementation work. Olin Shivers, 2005 \nIn other words, adding error-checking to the loop macro is expected to double the size of the code. Using \nsyntax-parse we can do better. The original loop macro performs little error checking; in thirty\u00adtwo \nexported macros there are only three syntax validation checks plus a handful of internal sanity checks. \nThe exported macros con\u00adsist of the loop macro itself plus thirty-one CPS macros [Hilsdale and Friedman \n2000] for loop clauses such as for and do. CPS macros pose challenges for generating good error mes\u00adsages \nbecause the macro s syntax differs from the syntax apparent to the user due to the CPS protocol. When \nthe programmer writes (for x in xs), the loop macro rewrites it as (for (x in xs) k kargs) to accommodate \nthe macro s continuation. Errors in the programmer s use of for should be reported in terms of the original \nsyntax, not the rewritten syntax. We accomplish this by parsing the syntax in two passes. We parse the \nCPS-level syntax and reconstruct the origi\u00adnal term, and then we parse that term. Twenty of the CPS macros \nare expressed using de.ne-simple-syntax, a simpli.ed version of de.ne-syntax. We changed de.ne-simple-syntax \nto automatically rewrite these macros patterns to perform two-stage parsing; we also changed them to \nuse syntax-parse internally so that the simple macros could use annotations and the other features of \nour system. The other eleven CPS macros were transformed by hand. Another hazard of CPS macros is inadvertent \ntransfer of control to a macro that does not use the CPS protocol, resulting in incoher\u00adent errors or \nunexpected behavior. In Racket, this problem can be prevented by registering CPS macros and checking \ntheir applica\u00adtions. We use a syntax class to recognize registered CPS macros. Once the concrete syntax \nis separated from the CPS-introduced syntax, validating it is fairly simple. Many of the loop forms take \nonly expressions, so validation is trivial. Some of the loop forms require identi.er annotations or simple \nside conditions. The initial and bind loop forms have more structured syntax, so we de.ne syntax classes \nfor their sub-terms, including a shared syntax class var/vars; it represents a single variable or a group \nof variables. A loop-clause keyword such as for is implemented by a macro named loop-keyword/for; the \nname is chosen to reduce contention for short names. The loop macro rewrites the loop-clause key\u00adwords, \nexcept that programmers can write the long form in paren\u00adtheses, e.g., ((loop-keyword/for) x in xs), \nto avoid the rewriting. The code to recognize and rewrite both cases and is duplicated, since for enforces \nthe same protocol for its auxiliaries: in becomes for-clause/in. In the syntax-parse version, we de.ne \na loopkw syn\u00adtax class that does the rewriting automatically. The syntax class is parameterized so it \ncan handle both loop and for keywords. The original version of the loop macro consists of 1840 lines \nof code, not counting comments and empty lines. The implementation of the loop keyword macros takes 387 \nlines; the rest includes the implementation of its various intermediate languages and scope inference \nfor loop-bound variables. The syntax-parse version is 1887 lines, an increase of forty-seven lines. The \nincrease is due to the new version of de.ne-simple-syntax. Overall, the increase is 12% of the size of \nthe main body of the macros and merely 2.6% of entire code, which falls far short of the 100% increase \npredicted by the package s highly experienced author. Aside from the new helper macro, the parsing code \nshrank, despite much improved error handling, due to simpli.cations enabled by syntax-parse.  7.2 Case: \nparser The parser macro [Owens et al. 2004] implements a parser genera\u00adtor for LALR(1) grammars. The \nmacro a grammar description and a few con.guration options, and it generates a table-driven parser or \na list of parsers, if multiple start symbols are given. The parser case study represents macros with \naggressive, hand-coded error report\u00ading. The macro checks both shallow properties as well as context\u00addependent \nconstraints. The parser macro takes a sequence of clauses specifying differ\u00adent aspects of the parser. \nSome clauses are mandatory, such as the grammar clause, which contains the list of productions, and the \ntokens clause, which imports terminal descriptions. Others are op\u00adtional, such as the debug clause, which \nspeci.es a .le name where the table descriptions should be printed. In all, there are ten clauses, .ve \nmandatory and .ve optional, and they can occur in any order. The original version used a loop and mutable \nstate to recog\u00adnize clauses; different clauses were parsed at various points later in the macro s processing. \nThe new version uses our improved el\u00adlipses patterns in two well-de.ned passes to resolve dependencies \nbetween clauses. For example, the productions in the grammar clause depend on the terminals imported \nby the tokens clause. The second pass involves syntax classes parameterized over the results gathered \nfrom the .rst pass. The original version of parser explicitly detects thirty-nine dif\u00adferent syntax errors \nbeyond those caught by MBE-style patterns. Repetition constraints ( once and optional) on the different \nclause variants cover thirteen of the original errors plus a few that the original macro failed to check. \nPattern variable annotations cover eleven of the original errors, including simple checks such as De\u00adbugging \n.lename must be a string as well as context-dependent errors such as Start symbol not de.ned as a non-terminal. \nThe latter kind of error is handled by a syntax class that is parameter\u00adized over the declared non-terminals. \nSide-condition checks cover eight errors such as duplicate non-terminal de.nition with the use of #:fail-when. \nThe remaining seven checks performed by the original macro belong to catch-all clauses that explain what \nvalid syntax looks like for the given clause or sub-form. Five of the catch-all checks cover speci.c \nkinds of sub-forms, such as Grammar must be of the form (grammar (non-terminal productions ...)...). \nInafew cases the message is outdated; programmers who revised the parser macro failed to update the error \nmessage. In the syntax-parse version each of these sub-forms is represented as a syntax class, which \nau\u00adtomatically acts as a local catch-all according to our error message generation algorithm (section \n4.2); syntax-parse reports the syntax class s description rather than reciting the macro s documentation. \n(A macro writer could put the same information in the syntax class description, if they wanted to.) The \n.nal two checks are catch-alls for parser clauses and the parser form itself. These are implemented using \nfail and patterns crafted to catch clauses that do not match other clause keywords. In most cases the \nerror messages are rephrased according to syntax-parse conventions. For example, where the original macro \nreported Multiple grammar declarations, the new macro uses too many occurrences of grammar clause ; and \nwhere the original macro reported End token must be a symbol, the new macro produces the terser message \nexpected declared terminal name. The original version devoted 570 lines to parsing and process\u00ading, counting \nthe macro and its auxiliary functions. The line count leaves out separate modules such as the one that \nimplements the LALR(1) algorithm. In the original code, parsing and processing are tightly intertwined, \nand it is impossible to directly count the lines of code dedicated to each. In the new version, parsing \nand processing took a total of 378 lines of code, consisting of 124 lines for parsing (25 for the main \nmacro pattern and 99 for syntax class de.nitions) and 254 lines for processing.  By reasoning that the \nlines dedicated to processing should be roughly equivalent in both versions, we estimate 300 lines for \nprocessing in the original version, leaving 270 for parsing. Thus the syntax-parse version requires less \nthan half the number of lines of code for parsing, and the new parsing code consists of modular, declarative \nspeci.cations. The error reporting remains of comparable quality. 8. Related work Other backtracking \nparsers, such as packrat parsers [Ford 2002], also employ the technique of tracking and ordering failures. \nUnlike shift/reduce parsers, which enjoy the viable-pre.x property, pack\u00adrat parsers cannot immediately \nrecognize when an input stream becomes nonviable that is, where the error occurs. Instead, they maintain \na high-water mark, the failure that occurs furthest into the input along all branches explored so far. \nWhile these string parsers can represent progress as the number of characters or tokens con\u00adsumed, syntax-parse \nuses a notion of progress based on syntax tree traversal. Our ordering of parse failures is also similar \nto the work of Despeyroux [1995] on partial proofs in logic programming. In that work, a set of inference \nrules is extended with recovery rules that prove any proposition. The partial proofs are ordered so that \nuse of a recovery rule has less progress than any real rule and uses of different original rules are \nincomparable; only the maximal proofs are returned. In contrast to the order of that system, which is \nindifferent to the system s rules and propositions, our system uses the pragmatics of parsing syntax \nto de.ne the order. Another line of research in macro speci.cations began with static checking of syntactic \nstructure [Culpepper and Felleisen 2004] and evolved to encompass binding information and hygienic expansion \n[Herman and Wand 2008]. These systems, however, are incapable of fortifying a broad range of widely used \nmacro pro\u00adgramming idioms, and they do not address the issues of error feed\u00adback or of modular syntax \nspeci.cation addressed by our system. 9. Conclusion Our case studies, our other experiences, and reports \nfrom other pro\u00adgrammers con.rm that syntax-parse makes it easy to write easy\u00adto-understand, robust macros. \nOverall syntax-parse macros take less effort to formulate than comparable macros in MBE-based sys\u00adtems \nsuch as syntax-case and syntax-rules or even plain Lisp-style macros. Also in contrast to other macro \nsystems, the syntax-parse style is distinctively declarative, closely resembling grammatical speci.cation \nwith side conditions. Best of all, these language ex\u00adtensions are translated into implementations that \ncomprehensively validate all the constraints and that report errors at the proper level of abstraction. \nEven though syntax-parse has been available for less than a year, it has become clear that it improves \non MBE-style macros to the same degree or perhaps a larger one that MBE improved over Lisp-style macros. \nAcknowledgments We are grateful to Matthew Flatt, Guy Steele, Sam Tobin-Hochstadt, and Jon Rafkind for \nfeedback on the design and implementation of syntax-parse. References Cadence Research Systems. Chez \nScheme Reference Manual, 1994. R. Culpepper and M. Felleisen. Taming macros. In International Confer\u00adence \non Generative Programming and Component Engineering, pages 225 243, 2004. T. Despeyroux. Logical programming \nand error recovery. In Industrial Applications of Prolog, Oct. 1995. R. K. Dybvig, R. Hieb, and C. Bruggeman. \nSyntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295 326, Dec. 1993. F. L. Fessant \nand L. Maranget. Optimizing pattern matching. In Interna\u00adtional Conference on Functional Programming, \npages 26 37, 2001. R. B. Findler, J. Clements, C. Flanagan, M. Flatt, S. Krishnamurthi, P. Steckler, \nand M. Felleisen. DrScheme: A programming environment for Scheme. Journal of Functional Programming, \n12(2):159 182, 2002. M. Flatt and PLT. Reference: Racket. Technical report, PLT Inc., January 2010. http://racket-lang.org/tr1/. \nB. Ford. Packrat parsing: a practical linear-time algorithm with backtrack\u00ading. Master s thesis, Massachusetts \nInstitute of Technology, Sept. 2002. D. Herman and M. Wand. A theory of hygienic macros. In European \nSymposium on Programming, pages 48 62, Mar. 2008. E. Hilsdale and D. P. Friedman. Writing macros in continuation-passing \nstyle. In Workshop on Scheme and Functional Programming, pages 53 59, 2000. J. Hughes. The design of \na pretty-printing library. In Advanced Func\u00adtional Programming, First International Spring School on \nAdvanced Functional Programming Techniques-Tutorial Text, pages 53 96, Lon\u00addon, UK, 1995. Springer-Verlag. \nE. E. Kohlbecker and M. Wand. Macro-by-example: Deriving syntactic transformations from their speci.cations. \nIn Symposium on Principles of Programming Languages, pages 77 84, 1987. P. J. Landin. Correspondence \nbetween ALGOL 60 and Church s lambda\u00adnotation: part i. Commun. ACM, 8(2):89 101, 1965. S. Owens, M. Flatt, \nO. Shivers, and B. McMullan. Lexer and parser gener\u00adators in Scheme. In Workshop on Scheme and Functional \nProgramming, pages 41 52, Sept. 2004. O. Shivers. The anatomy of a loop: a story of scope and control. \nIn Inter\u00adnational Conference on Functional Programming, pages 2 14, 2005. M. Sperber, R. K. Dybvig, M. \nFlatt, A. van Straaten, R. Findler, and J. Matthews. Revised6 report of the algorithmic language Scheme. \nJournal of Functional Programming, 19(S1):1 301, Aug. 2009. M. Wand and D. Vaillancourt. Relating models \nof backtracking. In International Conference on Functional Programming, pages 54 65, 2004.    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Existing macro systems force programmers to make a choice between clarity of specification and robustness. If they choose clarity, they must forgo validating significant parts of the specification and thus produce low-quality language extensions. If they choose robustness, they must write in a style that mingles the implementation with the specification and therefore obscures the latter.</p> <p>This paper introduces a new language for writing macros. With the new macro system, programmers naturally write robust language extensions using easy-to-understand specifications. The system translates these specifications into validators that detect misuses - including violations of context-sensitive constraints - and automatically synthesize appropriate feedback, eliminating the need for ad hoc validation code.</p>", "authors": [{"name": "Ryan Culpepper", "author_profile_id": "81337488807", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2338202", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2338203", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863577", "year": "2010", "article_id": "1863577", "conference": "ICFP", "title": "Fortifying macros", "url": "http://dl.acm.org/citation.cfm?id=1863577"}