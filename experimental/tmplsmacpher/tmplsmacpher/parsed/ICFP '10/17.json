{"article_publication_date": "09-27-2010", "fulltext": "\n Combining Syntactic and Semantic Bidirectionalization Janis Voigtl\u00a8ander * Zhenjiang Hu Kazutaka Matsuda \nMeng Wang University of Bonn National Institute of Informatics Tohoku University University of Oxford \nR\u00a8omerstra\u00dfe 164 2-1-2 Hitotsubashi, Chiyoda-ku 6-3-09 Aramaki aza Aoba, Aoba-ku Wolfson Building, Parks \nRoad 53117 Bonn, Germany Tokyo 101-8430, Japan Sendai 980-8579, Japan Oxford OX1 3QD, United Kingdom \njv@iai.uni-bonn.de hu@nii.ac.jp kztk@kb.ecei.tohoku.ac.jp meng.wang@comlab.ox.ac.uk Abstract Matsuda \net al. [2007, ICFP] and Voigtl\u00a8ander [2009, POPL] intro\u00ad duced two techniques that given a source-to-view \nfunction provide an update propagation function mapping an original source and an updated view back to \nan updated source, subject to standard consis\u00ad tency conditions. Being fundamentally different in approach, \nboth techniques have their respective strengths and weaknesses. Here we develop a synthesis of the two \ntechniques to good effect. On the in\u00ad tersection of their applicability domains we achieve more than \nwhat a simple union of applying the techniques side by side delivers. Categories and Subject Descriptors \nD.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming; D.3.3 [Program\u00adming Languages]: \nLanguage Constructs and Features Data types and structures, Polymorphism; H.2.3 [Database Management]: \nLanguages Data manipulation languages, Query languages General Terms Design, Languages Keywords program \ntransformation, view-update problem 1. Introduction Bidirectionalization is the task to given some function \nget :: t1 . t2 produce a function put :: t1 . t2 . t1 such that if get maps an original source s to an \noriginal view v, and v is somehow ' changed into an updated view v', then put applied to s and vproduces \nan updated source s' in a meaningful way. Such get/put\u00ad pairs, called bidirectional transformations, \nplay an important role in various application areas such as databases, .le synchronization, structured \nediting, and model transformation. A survey of relevant techniques and open problems has recently appeared \n[Czarnecki et al. 2009], and functional programming approaches have had an important impact, with several \nideas and solutions springing from this part of the programming languages .eld in particular [Bohannon \net al. 2006, 2008; Foster et al. 2007, 2008; Hu et al. 2004; Matsuda et al. 2007, 2009; Voigtl\u00a8ander \n2009]. Automatic bidirectionalization is one approach to obtaining suitable get/put-pairs, others are \ndomain-speci.c languages or more ad-hoc programming techniques. Two different .avors of bidirectionalization \nhave been proposed: syntactic and semantic. * The research reported here was performed while this author \nvisited the National Institute of Informatics, Tokyo, under a fellowship by the Japan Society for the \nPromotion of Science, ID No. PE09076. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright \nc &#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 Syntactic bidirectionalization [Matsuda et \nal. 2007] works on a syntactic representation of (somehow restricted) get-functions and synthesizes appropriate \nde.nitions for put-functions algorithmi\u00ad cally. Semantic bidirectionalization [Voigtl\u00a8ander 2009] does \nnot inspect the syntactic de.nitions of get-functions at all, but instead provides a single de.nition \nof put, parameterized over get as a semantic object, that does the job by invoking get in a kind of simulation \nmode . (We will brie.y introduce both techniques in Section 2.) Both syntactic and semantic bidirectionalization \nhave their strengths and weaknesses. Syntactic bidirectionalization heavily depends on syntactic restraints \nexercised when implementing the get-function. Basically, the technique of Matsuda et al. [2007] can only \ndeal with programs in a custom .rst-order language subject to linearity restrictions and absence of intermediate \nresults between function calls. Semantic bidirectionalization, in contrast, provides very easy access \nto bidirectionality within a general-purpose lan\u00adguage, liberated from the syntactic corset as to how \nto write func\u00adtions of interest. The price to pay for this in the case of the approach of Voigtl\u00a8ander \n[2009] is that it works for polymorphic functions only, and at present is unable to deal with view updates \nthat change the shape of a data structure (more on this critical issue below). The syntactic approach, \non the other hand, is successful for many such shape-changing updates, and can deal with non-polymorphic \nfunctions. In this paper we develop an approach for combining syntactic and semantic bidirectionalization. \nThe resulting technique inherits the limitations in program coverage from both techniques. That is, except \nfor some extensions we will consider later on, only functions that are written in the .rst-order language, \nare linear, and treeless in the sense of Wadler [1990], and moreover are polymorphic, can be dealt with. \nWhat we gain by the combination is improved up\u00addatability. Not only do we bring the possibility of shape-changing \nupdates to semantic bidirectionalization, but also will the combined technique be superior to syntactic \nbidirectionalization on its own in many cases. To explain what we mean by improved updatability, we have \nto elaborate on the phrase in a meaningful way in the .rst sentence of this introduction, and on suitable \nat the start of the second paragraph. So, when is a get/put-pair good ? How should s, v, v', and s' in \nget s = v and put sv' = s' be related? One natural requirement is that if v = v', then s = s', or, put \ndifferently, put s (get s) = s . (1) Another requirement to expect is that s' and v' should be related \nin the same way as s and v are, or, again expressed as a round-trip property, '' get (put sv) = v. (2) \nThese are the standard consistency conditions [Bancilhon and Spyratos 1981] known as GetPut and PutGet \n[Foster et al. 2007].  But the latter of the two is often too hard to satisfy in practice. For .xed \nget, it can be impossible to provide a put-function ful.lling equation (2) for every choice of s and \nv ', simply because v ' may not even be in the range of get. One solution is to make the put\u00adfunction \npartial and to only expect the PutGet law to hold in case put sv ' is actually de.ned. Of course, a trivially \nconsistent put\u00adfunction we could then always come up with is the one for which put sv ' is only de.ned \nif get s = v ' and which simply returns s then. Clearly, this choice would satisfy both equations (1) \nand (2), but would be utterly useless in terms of updatability. The very idea that v and v ' can be different \nin the original scenario would be countermanded. So our evaluation criteria for goodness are that get/put \nshould satisfy equation (1), that they should satisfy equation (2) whenever put sv ' is de.ned, and that \nput sv ' should be actually de.ned on a big part of its potential domain, indeed preferably for all s \nand v ' of appropriate type. With this measure in hand, one can compare different bidirectionalization \nmethods. Semantic bidirec\u00ad tionalization as proposed by Voigtl\u00a8ander [2009] has the problem that put \nsv ' can only be de.ned when get s and v ' have the same shape (length of a list, structure of a tree, \n. . . , and in some situa\u00ad tions even with constraints on the equivalence and relative ordering of elements \nin data structures). Syntactic bidirectionalization as proposed by Matsuda et al. [2007] does not suffer \nfrom such a cen\u00ad tral and common (to all invocations) updatability weakness, but in many cases also rejects \nupdates that one would really like to see accepted. The bene.t of our combined technique now is that \non the intersection of the classes of programs to which the original syntactic and semantic techniques \napply, we can do strictly better in terms of updatability than either technique in isolation. We are \nnever worse than the better of the two in a speci.c case. The combination strategy we pursue is essentially \nmotivated by combining the specialties of the two approaches. Semantic bidirec\u00adtionalization s specialty \nis to employ polymorphism to deal with the content elements of data structures in a very lightweight \nway. In fact, in the original technique, the shape and content aspects of a data structure are completely \nseparated, updates affecting the shape are completely outlawed, arbitrary updates to content elements \ncan be simply absorbed, and by recombining original shape with up\u00addated content consistency is guaranteed. \nSyntactic bidirectionaliza\u00adtion s specialty is to have a more re.ned, and case-by-case, notion of what \nupdates, including updates on the shape aspect, can be per\u00admitted. But it turns out that content elements \noften get in the way. In fact, by having to deal with both shape and content, at the same time, in the \nkey step of syntactic bidirectionalization (namely view complement derivation ), updatability is hampered. \nIn our com\u00adbined approach we divide the labor: semantic bidirectionalization deals with content only, \nsyntactic bidirectionalization deals with shape only. As a result, the reach of semantic bidirectionalization \nis expanded beyond shape-preserving updates, and syntactic bidi\u00adrectionalization is invoked on a more \nspecialized kind of programs, on which it can yield better results, bene.tting both. Technically, we \ntreat syntactic bidirectionalization as a black box. Or rather, our eventual combined technique does \nso; for the sake of analyzing examples, we look into the box; but for actually executing the combined \ntechnique the syntactic technique could be a completely external component. Semantic bidirectionalization \nis treated as a glass box; we do look into it, and we refactor it to enable a plugging in of the syntactic \ntechnique. Indeed, our dissection of the semantic bidirectionalization technique is an independent con\u00ad \ntribution of this paper, beyond the speci.c use case of combining the techniques of Matsuda et al. [2007] \nand Voigtl\u00a8ander [2009]. In principle, our refactoring allows also other approaches (than that of Matsuda \net al.) for obtaining bidirectional transformations on shapes to be plugged into the semantic technique. \nSince our purpose here is to focus on the combination of tech\u00ad niques, we concentrate on one speci.c \nkind of functions, namely on functions from lists to lists. The original techniques we com\u00ad bine apply \nto algebraic data types more generally. In particular, Voigtl\u00a8ander [2009, Section 6] employs generic \nprogramming tech\u00ad niques to deal with trees and the like. Something similar should be possible here, \nbut we have not worked out the details. Our key ideas can all be explained, and hopefully appreciated, \nin the setting of lists only, and that explanation is what we seek to do. For the same reason, we do \nnot consider type classes as Voigtl\u00a8ander [2009, Sections 4 and 5] does; again, we think our ideas here \ncould be transferred to those settings, but we refrain from doing so for the sake of focus. Our presentation \nwill be partly example-driven, partly program\u00ad driven as we proceed through the refactoring and discovery \nprocess regarding generalization opportunities. We do state lemmas and theorems, but do not give formal \nproofs. These proofs can all be done similarly to those by Voigtl\u00a8ander [2009], employing free theorems \n[Wadler 1989]. We will comment in a bit more detail where appropriate. As a .nal preparation before diving \nright in, we slightly revise the consistency conditions (1) and (2). Since our emphasis is on the updatability \ninherent in a get/put-pair, we make the partiality of put explicit in the type via optionality of the \nreturn value. The following de.nition formulates the consistency conditions for this setting. De.nition \n1. Let t1 and t2 be types. Let functions get :: t1 . t2 and put :: t1 . t2 . Maybe t1 be given. We say \nthat put is consistent for get if: For every s :: t1, put s (get s) = Just s . '' ' For every s, s :: \nt1 and v :: t2, if put sv = Just s ', then get s ' = v ' . 2. The Original Techniques We brie.y introduce \nthe two techniques we want to combine. Read\u00aders content with considering syntactic bidirectionalization \nas a black box can safely skip the next subsection and directly jump to Section 2.2. The combination \napproach can still be understood then, but it will be more dif.cult to appreciate some of the analysis \nof examples later on. 2.1 Syntactic Bidirectionalization The technique of Matsuda et al. [2007] builds \non the constant\u00ad complement approach of Bancilhon and Spyratos [1981]. The basic idea is that for a function \nget :: t1 . t2 one .nds a function compl :: t1 . t3 such that the pairing of the two, paired :: t1 . \n(t2,t3) paired s =(get s, compl s) is an injective function. Given an inverse inv :: (t2,t3) . t1 of \npaired, one obtains that put :: t1 . t2 . t1 put s v ' = inv (v ' , compl s) makes equations (1) and \n(2) true.  In reality, asking for a full inverse inv of paired is too much. The function paired may \nnot even be surjective. So one relaxes inv to be a partial function, either implicitly as Matsuda et \nal. [2007] do, or explicitly in the type. With inv :: (t2,t3) . Maybe t1 and the requirements that for \nevery s :: t1, inv (paired s) = Just s , and '' '' for every s :: t1, v :: t2, and c :: t3, if inv (v \n,c) = Just s , then paired s ' = (v ' ,c) , we obtain that put :: t1 . t2 . Maybe t1 put s v ' = inv \n(v ' , compl s) is consistent for get in the sense of De.nition 1. The approach of Matsuda et al. [2007] \nis to perform all the above by syntactic program transformations. For a certain class of programs, they \ngive an algorithm that automatically derives compl from get in such a way that paired is indeed injective. \nThen in\u00adstead of the de.nition for paired above they produce one using a tupling transformation [Pettorossi \n1977] that avoids the two inde\u00ad pendent traversals of s with get and compl. They syntactically in\u00advert \npaired to obtain inv, and subsequently fuse the computations of inv and compl in the de.nition of put, \nagain using a syntactic transformation [Wadler 1990]. We illustrate the syntactic approach based on two \nexamples. A generalization over the above picture is that instead of Maybe we will use an arbitrary monad. \nThis allows for more .exible use of the resulting put-function, and also enables us to provide informative \nerror messages if desired. Example 1. Assume our get-function is as follows, sieving a list to keep only \nevery second element: get1 :: [a] . [a] get1 [] =[] get1 [x ] =[] get1 (x : y : zs)= y :(get1 zs) This \nfunction ful.lls the syntactic prerequisites imposed by Mat\u00ad suda et al. [2007]. They are (necessary1 \nand suf.cient): that func\u00adtions must be .rst-order, must be linear (no variable occurs more than once \nin a single right-hand side), and that there must be no function call with anything else than variables \nin its arguments. Given the above, the following complement function is auto\u00admatically derived: data \nCompl a = C1 | C2 a | C3 a (Compl a) compl :: [a] . Compl a compl [] = C1 compl [x ]= C2 x compl (x : \ny : zs)= C3 x (compl zs) (Matsuda et al. work in an untyped language, so they have no need to explicitly \nintroduce the data type Compl, but as we formulate our ideas in Haskell, we will be careful to introduce \nappropriate types as we go along.) The basic ideas for the derivation of compl are that variables dropped \nwhen going from left to right in a de.ning equation of get 1 At least for the original method of Matsuda \net al. [2007]. Later work [Matsuda et al. 2009, in Japanese] relaxes the restrictions somewhat. are collected \nby compl, and that, where necessary, different data constructors (of same arity/type) are used on the \nright-hand sides of compl to disambiguate between overlapping ranges of right\u00adhand sides of get. (In \nthis speci.c example, this is not what causes different data constructors to be used. Instead, the simple \nfact that different arities are required, due to different numbers of dropped variables and recursive \ncalls, leads to different data constructors.) Tupling gives the following de.nition for the paired function: \npaired :: [a] . ([a], Compl a) paired [] =([] , C1) paired [x ] = ([] , C2 x) paired (x : y : zs)=(y \n: v, C3 xc) where (v, c)= paired zs Syntactic inversion, basically just exchanging left-and right-hand \nsides, plus introduction of monadic error propagation, gives: inv :: Monad \u00b5 . ([a], Compl a) . \u00b5 [a] \ninv ([ ] , C1)= return [] inv ([ ] , C2 x)= return [x ] inv (y : v, C3 xc)= do zs . inv (v, c) return \n(x : y : zs) inv = fail \"Update violates complement.\" Finally, put :: Monad \u00b5 . [a] . [a] . \u00b5 [a] put \ns v ' = inv (v ' , compl s) can be fused to: put :: Monad \u00b5 . [a] . [a] . \u00b5 [a] put [] [] = return [] \nput [x ] [] = return [x ] ''' ' put (x : y : zs)(y : v )= do zs . put zs v return (x : y ' : zs ' ) \nput = fail \"Update violates complement.\" Note that for this function, put s v ' fails if and only if \nlength v '= length (get1 s). If it succeeds, it mixes the elements of s and v ' as in, e.g., fromJust \n(put [1 .. 6] [7 .. 9]) = [1, 7, 3, 8, 5, 9]. An implementation of the syntactic bidirectionalization \nmethod is available at http://www.kb.ecei.tohoku.ac.jp/~kztk/ bidirectionalization/. It automatically \nperforms the steps from get to compl and paired. It also performs the syntactic in\u00adversion from paired \nto inv, though without the explicit monadic error propagation we have used here. It is not always the \ncase as in the above example that inv can directly be interpreted as a deterministic program. Instead, \nit can happen that the non-failing equations have overlapping left-hand sides, leading to a nondeter\u00administic \nprogram, in which case a backtracking search becomes necessary. Such a backtracking search is what the \nimplementation then does, though in practice it would of course be preferable to directly obtain a deterministic \nprogram.2 Also, the implementation does not at present realize the .nal fusion step, but instead works \nwith the de.nition of put in terms of inv and compl. Clearly, these de.ciencies of the implementation \nonly affect the ef.ciency of the bidirectional transformation, not its correctness/consistency. For the \nabove and the following example, we continue to per\u00adform ( by hand ) the determinization and fusion steps, \nbecause the put-function thus obtained typically gives a better picture of the achieved updatability. \n2 An alternative would be to run the syntactically inverted program in a functional logic language [Antoy \nand Hanus 2010].  Example 2. Assume our get-function is as follows, keeping every element of a list \nexcept for the last one:3 get2 :: [a] . [a] get2 [] =[] get2 [x ] =[] get2 (x : y : zs)= x :(get ' y \nzs) get ' :: a . [a] . [a] get ' x [] =[] get ' x (y : zs)= x :(get ' y zs) Then the syntactic approach \nproduces the following complement function: data Compl a = C1 | C2 a | C3 a compl :: [a] . Compl a compl \n[] = C1 compl [x ]= C2 x compl (x : y : zs)= compl ' y zs compl ' :: a . [a] . Compl a compl ' x [] = \nC3 x compl ' x (y : zs)= compl ' y zs Note that there are no data constructors around recursive calls. \nThis omission is possible, because no variables are dropped in the respective equations and because automatic \nrange analysis can tell the right-hand sides of those equations never overlap, for any instantiation \nof variables, with any other right-hand sides of the same function. Tupling, inversion, and fusion (not \nspelled out here in detail) ultimately give: put :: Monad \u00b5 . [a] . [a] . \u00b5 [a] put [ ] [ ] = return \n[ ] put [x ] [ ] = return [x ] ' ' ' ' ' ' put (x : y : zs)(x : v )= do (y , zs ) . put yzsv '' ' return \n(x : y : zs ) put = fail \"Update violates complement.\" put ' :: Monad \u00b5 . a . [a] . [a] . \u00b5 (a, [a]) \nput ' y [] [] = return (y, [ ]) put ' y (z : zs)[] = put ' z zs [] ' ''' '' put yzs (x : v )= do (y , \nzs ' ) . put yzsv '' ' return (x , y : zs ) The updatability of these functions is that put s v ' succeeds \nif and only if length v ' and length (get2 s) are equal or both greater than zero. For the latter case, \nthe behavior of put is best understood by observing that the de.nition of put ' is semantically equivalent \n(depending on one of the monad laws) to: put ' :: Monad \u00b5 . a . [a] . [a] . \u00b5 (a, [a]) put ' y zs [] \n= return (last (y : zs), [ ]) ' '' '' put yzs (x : v )= return (x , v + [last (y : zs)]) and thus the \nthird de.ning equation of put is equivalent (again depending on the same monad law) to the following \ntwo: put (x : y : zs)(x ' :[]) = return (x ' :[last (y : zs)]) ''' '' put (x : y : zs)(x : y : v )= return \n(x : y : v ' + [last (y : zs)]) and thus to: ' '' put (x : y : zs)(x : v ' )= return (x : v + [last (y \n: zs)]) 3 A helper function get ' is used to prevent a function call with an argument that is not a variable. \n 2.2 Semantic Bidirectionalization As already mentioned, we will develop our combined bidirection\u00adalization \ntechnique only for lists, and only for fully polymorphic functions to bidirectionalize. So from now on, \nlet get :: [a] . [a] be .xed but arbitrary (except when discussing concrete examples, of course). The \nintuition underlying the method of Voigtl\u00a8ander [2009] is that put can gain information about the get-function \nby applying it to suitable input. The key is that get is polymorphic over the element type a. This entails \nthat its behavior does not depend on any concrete list elements, but only on positional information. \nAnd this positional information can be observed explicitly by applying get to ascending lists over integer \nvalues. Say get is tail, then every list [0 .. n ] is mapped to [1 .. n ], which allows put to see that \nthe head element of the original source is absent from the view, hence cannot be affected by an update \non the view, and hence should remain unchanged when propagating an updated view back into the source. \nAnd this observation can be transferred to other source lists than [0 .. n ] just as well, even to lists \nover non-integer types, thanks to parametric polymorphism [Reynolds 1983; Strachey 1967]. Let us further \nconsider the tail example as in the previous para\u00adgraph. First, put should .nd out to what element in \nan original source s each element in an updated view v ' corresponds. Assume s has length n +1. Then \nby applying tail to the same-length list [0 .. n ], put learns that the original view from which v ' \nwas ob\u00adtained by updating had length n, and also to what element in s each element in that original view \ncorresponded. Being conservative, the current semantic bidirectionalization method will only accept v \n' if it has retained that length n. For then, we also know directly the associations between elements \nin v ' and positions in the original source. Now, to produce the updated source, we can go over all po\u00adsitions \nin [0 .. n ] and .ll them with the associated values from v ' . For positions for which there is no corresponding \nvalue in v ', be\u00adcause these positions were omitted when applying tail to [0 .. n ], we can look up the \ncorrect value in s rather than in v '. For the concrete example, this will only concern position 0, for \nwhich we naturally take over the head element from s. The same strategy works also for general get. In \nshort, given s, produce a kind of template t = [0 .. n ] of the same length, together with an association \ng between integer values in that template and the corresponding values in s. Then apply get to t and \nproduce a further association h by matching this template view versus the updated proper value view v \n'. Combine the two associations into a single one h ', giving precedence to h whenever an integer template \nindex is found in both h and g. Thus, it is guaranteed that we will only resort to values from the original \nsource s when the corresponding position did not make it into the view, and thus there is no way it could \nhave been affected by the update. Finally, produce an updated source by .lling all positions in [0 .. \nn ] with their associated values according to h ' . The above strategy is exactly what Voigtl\u00a8ander [2009] \nimple\u00adments for the special case get :: [a] . [a]. We recall the corre\u00adsponding Haskell de.nitions, reformulating \njust a bit: Instead of presenting a higher-order b. -function that turns get into put, we directly give \na de.nition of put that refers to a top-level-de.ned get.  We write put in monadic style to provide \nfor more convenient error handling.  We de.ne put as follows, using some functions from module Data.IntMap. \nTheir type signatures, which should provide suf.\u00adcient documentation, are given in Figure 1. One detail \nin behavior to mention additionally is that IntMap.union is left-biased for in\u00ad  fromList :: [(Int,a)] \n. IntMap a fromDistinctAscList :: [(Int,a)] . IntMap a empty :: IntMap a insert :: Int . a . IntMap a \n. IntMap a union :: IntMap a . IntMap a . IntMap a lookup :: Int . IntMap a . Maybe a Figure 1. Functions \nfrom module Data.IntMap. tegers occurring as keys in both input maps. This realizes exactly the precedence \nof h over g alluded to in the informal exposition above. put :: (Monad \u00b5, Eq a) . [a] . [a] . \u00b5 [a] put \nsv ' = do let t = [0 .. length s - 1] let g = IntMap.fromDistinctAscList (zip ts) h . assoc (get t) v \n' let h ' = IntMap.union hg return (map (fromJust . .ip IntMap.lookup h ' ) t) assoc :: (Monad \u00b5, Eq \na) . [Int] . [a] . \u00b5 (IntMap a) assoc [] [] = return IntMap.empty assoc (i : is)(b : bs)= do m . assoc \nis bs case IntMap.lookup im of Nothing . return (IntMap.insert ibm) Just c . if b == c then return m \nelse fail \"Update violates equality.\" assoc = fail \"Update changes the length.\" The following theorem \nis essentially (up to the different way of expressing partiality of put) what is proved by Voigtl\u00a8ander \n[2009] in Theorems 1 and 2. Theorem 1. Let t be a type that is an instance of Eq in such a way that the \nde.nition given for == makes it re.exive, symmet\u00adric, and transitive. For every s :: [t ], put s (get \ns) :: Maybe [t ] = Just s . ''' ' For every s,v ,s :: [t ], if put sv :: Maybe [t ] = Just s , then get \ns ' == v ' . Corollary 1. Let t be a type that is an instance of Eq in a way that the de.nition given \nfor == agrees with semantic equality. Then put :: [t ] . [t] . Maybe [t ] is consistent for get :: [t \n] . [t]. The somewhat complicated de.nition of assoc and the refer\u00ad ences to Eq and == in the function \nde.nitions and in Theorem and Corollary 1 are due to the fact that get could duplicate some of its input \nlist elements, which requires special handling. As we are any\u00ad way going to outlaw such copying (driven \nby the utilized syntactic bidirectionalization method s inability to deal with non-linear func\u00ad tions), \nwe do not elaborate on this further here. It is discussed in de\u00ad tail by Voigtl\u00a8ander [2009, end of Section \n2 and start of Section 3]. Applying semantic bidirectionalization is very easy. We simply put the function \nde.nitions of put and assoc side by side with the get-function we want to bidirectionalize. Example 1 \n(continued). Just as was the case for syntactic bidi\u00adrectionalization here, put s v ' fails if and only \nif length v ' = length (get1 s). Indeed, the two versions of put are semantically equivalent (at type \n[t ] . [t] . Maybe [t ], for t that is an instance of Eq). Here are a few representative calls and their \nresults: s v ' syntactic semantic put s v ' put s v ' \"abcd\" \"x\" Nothing Nothing \"abcd\" \"xy\" Just \"axcy\" \nJust \"axcy\" \"abcd\" \"xyz\" Nothing Nothing \"abcde\" \"x\" Nothing Nothing \"abcde\" \"xy\" Just \"axcye\" Just \"axcye\" \n\"abcde\" \"xyz\" Nothing Nothing Example 2 (continued). While, as we have seen, the put-function obtained \nvia syntactic bidirectionalization succeeds whenever length v ' and length (get2 s) are equal or both \ngreater than zero, for the put-function obtained via the semantic technique put sv ' will only be successful \nif length v ' = length (get2 s). Again, a few representative calls and their results: s v ' syntactic \nsemantic put s v ' put s v ' \"\" \"\" Just \"\" Just \"\" \"\" \"x\" Nothing Nothing \"a\" \"\" Just \"a\" Just \"a\" \"a\" \n\"x\" Nothing Nothing \"ab\" \"\" Nothing Nothing \"ab\" \"x\" Just \"xb\" Just \"xb\" \"ab\" \"xy\" Just \"xyb\" Nothing \n\"abc\" \"\" Nothing Nothing \"abc\" \"x\" Just \"xc\" Nothing \"abc\" \"xy\" Just \"xyc\" Just \"xyc\" \"abc\" \"xyz\" Just \n\"xyzc\" Nothing We see that syntactic and semantic bidirectionalization can agree or disagree in terms \nof updatability. Our aim is to combine the two into a technique that will represent a signi.cant improvement \nover both. A reviewer suggested that on the intersection of their applicability domains, the syntactic \ntechnique on its own is never worse than the semantic technique on its own. We believe this to be true. \nSo in a sense, we only try to improve over the syntactic method. Interestingly, the way forward is to \ndefer that method to the role of a plug-in, with the technique of Voigtl\u00a8ander [2009] in the master role. \nAs preparation, we refactor that latter technique. 3. Refactoring Semantic Bidirectionalization From \nnow on, assume that for every n :: Int, get [0 .. n ] con\u00adtains no duplicates. We call this property \nsemantic linearity. It will clearly be ful.lled if get s syntactic de.nition is linear. 3.1 Specialization \nto Semantically Linear get-Functions We de.ne putlinear :: Monad \u00b5 . [a] . [a] . \u00b5 [a] like put (but \nnote the different type), except that the call to assoc is replaced by a call, with the same arguments, \nto the following function: assoc ' :: Monad \u00b5 . [Int] . [a] . \u00b5 (IntMap a) assoc ' [] [] = return IntMap.empty \nassoc ' (i : is)(b : bs)= do m . assoc ' is bs return (IntMap.insert ibm) assoc ' = fail \"Update changes \nthe length.\" The proof of the following theorem is very similar to that of Theo\u00adrem 1, additionally using \nsemantic linearity of get in a straightfor\u00adward way.  Theorem 2. For every type t , :: [t] . [t ] . \nMaybe [t] putlinear is consistent for get :: [t] . [t ] . But semantic linearity gives us more. It rules \nout one important cause for a potential failure of view-update. As a consequence, we can now formulate \na suf.cient condition for a successful update. De.nition 2. We say that a function put :: [t] . [t ] \n. Maybe [t ] (for some type t ) is .xed-shape-friendly for get if for every s, v ' :: ' '' [t ], if length \nv = length (get s), then put sv = Just s for some s ' :: [t ]. Note that the original put :: [t ] . [t \n] . Maybe [t] from Sec\u00adtion 2.2 is not in general .xed-shape-friendly for get-functions that are not \nsemantically linear. On the other hand, putlinear :: [t ] . [t ] . Maybe [t] is not even generally consistent \nfor get-functions that are not semantically linear. But since we have now restricted get-functions to \nbe semantically linear, we have consistency by the above theorem, and can moreover prove the following \none. Theorem 3. For every type t , :: [t] . [t ] . Maybe [t] putlinear is .xed-shape-friendly for get. \nFor the proof, we basically just observe that the last de.ning equation of assoc ' will never be reached \nif the argument lists are of the same length. We can also give a negative statement about updatability \n(which also holds for the put from Section 2.2, of course). Theorem 4. For every type t and s, v ' :: \n[t], if length v ' = length (get s), then putlinear sv ' :: Maybe [t] = Nothing. For the proof, we observe \nthat the last de.ning equation of assoc ' (or assoc) is reached if the argument lists are of different \nlengths.  3.2 Decomposition to Expose the Shape Aspect We refactor putlinear to make the treatment of \nshapes (list lengths) explicit. To that end, we .rst de.ne sputnaive as follows: sputnaive :: Monad \u00b5 \n. Int . Int . \u00b5 Int l = if lvl == length (get [0 ..ls - 1]) sputnaive ls lvthen return ls else fail \"Update \nchanges the length.\" Using that function, we then de.ne putrefac as follows: putrefac :: Monad \u00b5 . [a] \n. [a] . \u00b5 [a] ' = putrefac sv do let ls = length s let g = IntMap.fromDistinctAscList (zip [0 ..ls - \n1] s) l ' ' ls (length v ) let t = [0 .. l ' - 1] let h = fromDistinctList (zip (get t) v ' ) let h ' \n= IntMap.union hg return (map (fromJust . .ip IntMap.lookup h ' ) t) . sputnaive fromDistinctList = IntMap.fromList \nThe refactoring consists of: making the check for equal length of get [0 .. length s -1] and v ', otherwise \nperformed inside assoc ', explicit, and outsourcing it to sputnaive, and  realizing that once this check \nwas successful, the role of assoc ' can be taken over by zip and IntMap.fromList.  The following lemma \nestablishes that the refactoring is indeed cor\u00adrect, and thus transports the (good and bad) properties \nof putlinear, namely Theorems 2 4, to putrefac. Lemma 1. For every type t and s, v ' :: [t ], we have \n' ' :: Maybe [t ] = putrefac sv :: Maybe [t ] . putlinear sv The motivation for our refactoring above \nis that we make ex\u00adplicit, in sputnaive, what happens on the shape level, namely that only updated views \nwith the same length as the original view can be accepted, and that the length of the source will never \nbe changed. By playing with sputnaive, we can change that behavior. For ex\u00adample, it is tempting to change \nthe last line of the above de.nition of sputnaive to: else return (head [lsl | lsl . [0 ..], lvl == length \n(get [0 ..lsl - 1])]) That would correspond to a brute force search for an appropriate new source shape. \nA reviewer pointed out that, thanks to semantic linearity of get, it would be suf.cient to start the \nsearch for lsl at lvl , i.e., that one could replace [0 ..] by [lvl ..] above, and that further optimizations \nlike memoization might be possible to speed up the search. However, our motivation for discarding the \nbrute force approach is not primarily ef.ciency. We are looking for a more effective approach in the \nsense that updates should be meaningful to the user. The kind of perfect updatability that could be achieved \nusing pure search (possibly with some limited guidance by the user via heuristics, expressed as reorderings \nof the candidate list [lvl ..]) could produce quite unintuitive results. As reckoned by the same reviewer, \nwe expect that by replacing sputnaive with a more intelligent or intuition-guided shape-bidirectionalizer, \nsuch as one based on the constant-complement approach, we will get more useful results overall. 4. Combining \nSyntactic and Semantic Bidirectionalization Our key idea is abstraction: from lists to list lengths (generally, \nfrom data structures to their shapes). Since we prefer to work with a more symbolic representation than \nbuilt-in integers provide, we .rst de.ne a new data type and conversion functions as follows: data Nat \n= Z | S Nat toNat :: Int . Nat toNat 0= Z toNat n | n> 0= S (toNat (n - 1)) fromNat :: Nat . Int fromNat \nZ =0 fromNat (S n)=1+ fromNat n and then a function sget as follows: sget :: Nat . Nat sget ls = toNat \n(length (get [0 .. fromNat ls - 1])) The point, later, will be that one can also directly derive a simpli.ed \nsyntactic de.nition for sget from a given de.nition for get. But for the moment, we simply take the above \nde.nition.  Next, we assume that some function sput is given, with the following type: sput :: Nat . \nNat . Maybe Nat , and that sput is consistent for sget. Of course, sput ls lvl (fromNat ls)(fromNat lvl \n) = case sputnaive of Nothing . Nothing Just l . Just (toNat l) is always a valid choice, with any of \nthe versions of sputnaive discussed in Section 3.2, but for many get-functions there will be better alternatives! \nWe now de.ne putcomb as below. There are three differences : we use Nat instead of Int to call out to \nsput instead from putrefac, we generate an error message in case sput fails of sputnaive(previously this \nwas done directly in sputnaive), and we drop the fromJust from the last (return-) line. The latter change \nintroduces an extra Maybe type constructor in the output list type, and is done to deal with list positions \nfor which no data is known, neither from the original source nor from the updated view. putcomb :: Monad \n\u00b5 . [a] . [a] . \u00b5 [Maybe a] ' = putcomb sv do let ls = length s let g = IntMap.fromDistinctAscList (zip \n[0 ..ls - 1] s) l ' . maybe (fail \"Could not handle shape change.\") return (sput (toNat ls)(toNat (length \nv ' ))) let t = [0 .. fromNat l ' - 1] let h = fromDistinctList (zip (get t) v ' ) let h ' = IntMap.union \nhg return (map (.ip IntMap.lookup h ' ) t)  The proof of the following theorem is very similar to that \nby Voigtl\u00a8ander [2009] for his Theorems 1 and 2, but of course ad\u00ad ditionally uses the assumption that \nsput is consistent for sget. Theorem 5. Let t be a type. For every s :: [t ], putcomb s (get s) :: Maybe \n[Maybe t] = Just (map Just s) . '' ' For every s, v :: [t ] and s :: [Maybe t], if putcomb sv :: Maybe \n[Maybe t] = Just s ', then get s ' = map Just v ' . The following theorem can also be shown to hold, \nbasically by observing that if length v ' = length (get s), then sget (toNat (length s)) = toNat (length \nv ' ) , and thus, by consistency of sput for sget, inside the putcomb \u00adde.nition l ' will be successfully \nassigned the value toNat ls, and subsequently every index position from t will lead to a successful lookup \nin h ', because at least g will contain a matching entry. Theorem 6. For every type t and s, v ' :: [t], \nif length v ' = length (get s), then putcomb sv ' :: Maybe [Maybe t ] = Just (map Just s ' ) for some \ns ' :: [t ]. As mentioned above, putcomb uses an extra Maybe type con\u00adstructor to deal with positions \nin the output list for which no data is known, neither from the original source nor from the updated \nview. It is usually more convenient to instead use a default value for such positions, so we de.ne a \nfunction dput as follows:4 dput :: Monad \u00b5 . a . [a] . [a] . \u00b5 [a] dput dsv ' = do s '' . putcomb sv \nreturn (map (maybe d id) s ' ) 4 Concrete examples of using default values appear in the next section. \nThe following two statements are then relatively direct conse\u00adquences of Theorems 5 and 6. Corollary \n2. For every type t and d :: t, dput d :: [t ] . [t] . Maybe [t ] is consistent for get :: [t] . [t ] \n. Corollary 3. For every type t and d :: t, dput d :: [t ] . [t] . Maybe [t ] is .xed-shape-friendly \nfor get. (Moreover, the default value d is not actually used in dput dsv ' if length v ' = length (get \ns).) It is important to note that no general negative statement like Theorem 4 holds for dput (or for \nputcomb). It all depends on the de.nition of sput! Namely, if from a given get, we make an sget, and \n.nd a good sput for it, then dput will also be good for get. This is where we can now plug in the work \nof Matsuda et al. [2007] as a black box. For functions get that are polymorphic and at the same time \nsatisfy the syntactic restrictions imposed by Matsuda et al. s technique, we can use that technique for \nderiving sput from sget. Voila, done. 5. Analysis of Examples We detail the execution of the just introduced \ncombination idea on the two examples considered in Section 2. This leads to some general observations \nabout ways in which, and why, the combined approach improves over both its constituent techniques, and \nalso provides motivation for further extensions we will consider in the two subsequent sections. Example \n1 (continued). We have seen in Sections 2.1 and 2.2 that for get1 both syntactic and semantic bidirectionalization \non their own lead to quite limited updatability. Namely, put s v ' only suc\u00adceeds if length v ' = length \n(get1 s). The same holds for putlinear , of course, as they are only refactorings of the put\u00ad and putrefac \nfunction obtained by semantic bidirectionalization. On the other hand, for the combination of the two \ntechniques, we can proceed as follows. The sget corresponding to get1, as ob\u00adtained via a pretty straightforward \nsyntactic transformation, looks as follows: sget :: Nat . Nat sget Z = Z sget (SZ)= Z sget (S (S zs)) \n= S (sget zs) For it, the syntactic bidirectionalization method of Matsuda et al. [2007] produces the \nfollowing complement function: data SCompl = SC1 | SC2 scompl :: Nat . SCompl scompl Z = SC1 scompl (SZ)= \nSC2 scompl (S (S zs)) = scompl zs Note that the move from [a] to Nat in get1 . sget has obviated the \nneed to collect any dropped variables in the complement func\u00adtion. As a consequence, with the help of \nrange analysis, no data constructor is necessary around the recursive call. (That is a crucial optimization \nembedded in Matsuda et al. s transformation.) For the two non-recursive equations, different data constructors \nare needed, because the ranges of the original right-hand sides overlap.  Tupling of sget and scompl \nleads to: spaired :: Nat . (Nat, SCompl) spaired Z =(Z , SC1) spaired (SZ) =(Z , SC2) spaired (S (S zs)) \n= (S v, c) where (v, c)= spaired zs Inversion gives:5 sinv :: Monad \u00b5 . (Nat, SCompl) . \u00b5 Nat sinv (Z \n, SC1)= return Z sinv (Z , SC2)= return (SZ) sinv (S v, c)= do zs . sinv (v, c) return (S (S zs)) and \n.nally, sput :: Nat . Nat . Maybe Nat sput s v ' = sinv (v ' , scompl s) can be fused to: sput :: Nat \n. Nat . Maybe Nat sput ZZ = return Z sput (SZ) Z = return (SZ) sput (S (S zs)) Z = sput zs Z sput s (S \nv ' )= do zs . sput s v ' return (S (S zs)) The bene.t of the combination of syntactic and semantic \nbidirec\u00adtionalization can be observed by comparing dput as obtained from the above sput-function to the \nfunction put from Example 1 in Section 2.1 (which we have seen is equivalent to put, putlinear, as obtained \nvia semantic bidirectionalization). Here and putrefac are a few representative calls and their results: \n s v ' put s v ' dput  s v ' \"abcd\" \"x\" Nothing Just \"ax\" \"abcd\" \"xy\" Just \"axcy\" Just \"axcy\" \"abcd\" \n\"xyz\" Nothing Just \"axcy z\" \"abcd\" \"xyzv\" Nothing Just \"axcy z v\" \"abcde\" \"x\" Nothing Just \"axc\" \"abcde\" \n\"xy\" Just \"axcye\" Just \"axcye\" \"abcde\" \"xyz\" Nothing Just \"axcyez \" \"abcde\" \"xyzv\" Nothing Just \"axcyez \nv \" Note that when length v ' = length (get1 s), dput sv ' ex\u00adtends, making use of the default value, \nor shrinks the source list by a number of elements that is a multiple of two (to preserve the remainder \nmodulo two, as .xed via scompl). All updates can be successfully handled, in contrast to all the versions \nof put we have considered for this example before! As a lesson from the above example, we could formulate: \nThe move from [a] to Nat can make the get-function con\u00adsiderably simpler. In particular, no data values \nhave to be kept. Here, this has even led (thanks to range analysis) to one constructor in the complement \ncreation becoming su\u00adper.uous completely, which resulted in perfect updatability. Example 2 (continued). \nWe have seen in Sections 2.1 and 2.2 that for get2/get ' the updatability achieved by syntactic bidirec\u00adtionalization \nis that put s v ' succeeds whenever length v ' and 5 Note that there is no need for a fall-back function \nequation sinv = fail \"Update violates complement.\", because in fact the pattern\u00admatch is exhaustive. \nThis eventually means that all updates/cases can be dealt with! length (get2 s) are equal or both greater \nthan zero, while the se\u00admantic technique is only successful if length v ' = length (get2 s). Let us analyze \nhow the combined technique fares. The move from [a] to Nat yields: sget :: Nat . Nat sget Z = Z sget \n(S Z) = Z ' sget (S (S zs)) = S (sget zs) sget ' :: Nat . Nat sget ' Z = Z sget ' (S zs)= S (sget ' \nzs) Note that regarding the helper function get ' one argument becomes super.uous. Indeed, when moving \nfrom [a] to Nat, there is no role to play anymore for content elements of type a. The automatic view \ncomplement generation of Matsuda et al. [2007] yields either of two functions scompl1/scompl2 for sget \n(with data SCompl = SC1 | SC2 | SC3) which differ only in their last de.ning equation: scompl? :: Nat \n. SCompl scompl? Z = SC1 scompl? (SZ)= SC2 scompl? (S (S zs)) = SC? while for sget ', one obtains the \nfollowing complement function: scompl ' :: Nat . SCompl scompl ' Z = SC3 scompl ' (S zs)= SC3 Note that \ninjectivity analysis (of sget ') has enabled the omission of recursive calls, and the use of a constant \nfunction for scompl '. Due to range analysis, we have a choice between SC1 and SC2 in the equation scompl? \n(S (S zs)) = .... Tupling, inversion, and fusion (again not spelled out here in detail) ultimately give: \nsput1 :: Nat . Nat . Maybe Nat sput1 ZZ = return Z sput1 (SZ) Z = return (SZ) sput1 (S (S zs)) Z = return \nZ sput1 Z (S v ' )= return (S (S v ' )) sput1 (S (S zs)) (S v ' )= return (S (S v ' )) sput1 = fail \"...\" \nfor scompl1, and a variant in which the third and fourth equation become: sput2 (S (S zs)) Z = return \n(SZ) sput2 (SZ)(S v ' )= return (S (S v ' )) for scompl2. Let us compare the results of combining syntactic \nand seman\u00adtic bidirectionalization, i.e. the now two possible dput-functions, to the results of either \nonly syntactic or only semantic bidirec\u00adtionalization, i.e. to put from Example 2 in Section 2.1 and \nto from Section 3. We call the dput-function putlinear = putrefac obtained from sput1 above, dput1, the \nother one, obtained from sput2, we call dput2. Figure 2 shows a few representative calls and their results. \nAs a lesson from this example, we could formulate: The move from [a] to Nat can lead to injectivity, \nand hence to considerably simpler (even constant) complement functions. This clearly bene.ts updatability. \n s v ' syntactic semantic combined put s v ' putlinear s v ' dput1  s v ' dput2  s v ' \"\" \"\" Just \n\"\" Just \"\" Just \"\" Just \"\" \"\" \"x\" Nothing Nothing Just \"x \" Nothing \"\" \"xy\" Nothing Nothing Just \"xy \n\" Nothing \"a\" \"\" Just \"a\" Just \"a\" Just \"a\" Just \"a\" \"a\" \"x\" Nothing Nothing Nothing Just \"x \" \"ab\" \"\" \nNothing Nothing Just \"\" Just \"a\" \"ab\" \"x\" Just \"xb\" Just \"xb\" Just \"xb\" Just \"xb\" \"ab\" \"xy\" Just \"xyb\" \nNothing Just \"xy \" Just \"xy \" \"abc\" \"\" Nothing Nothing Just \"\" Just \"a\" \"abc\" \"x\" Just \"xc\" Nothing Just \n\"xb\" Just \"xb\" \"abc\" \"xy\" Just \"xyc\" Just \"xyc\" Just \"xyc\" Just \"xyc\" \"abc\" \"xyz\" Just \"xyzc\" Nothing \nJust \"xyz \" Just \"xyz \" Figure 2. Comparing different bidirectionalization methods for the get-function \nfrom Example 2. 6. Explicit Bias Through the numbering scheme of our template sources via [0 .. l - 1] \nfor a concrete source of length l, there is a certain bias that manifests itself when an update changes \nthe length of the view. For example, while it is nice that for Example 2, as just seen, we have dput1 \n \"\" \"x\" = Just \"x \" and dput1  \"\" \"xy\" = Just \"xy \" (in contrast to the completely syntactically obtained \nput and the completely semantically obtained putlinear, which both give Nothing in both cases), it is \nmaybe a bit disappointing that dput1  \"ab\" \"xy\" = Just \"xy \" (instead of Just \"xyb\"). The reason for \nthis is simple: the use of [0 ..ls - 1] and [0 .. fromNat l ' - 1] in the de.nition of means that when \nthe updated source becomes shorter putcomb than the original source, then it s the elements towards the \nrear of the original source that become discarded; while if the updated source becomes longer, then again \npositions towards the rear of the new source will be considered to be additional and thus will be .lled \nwith the default value. So there is an implicit assumption that shape-changing updates will always happen \nin such a way that the corresponding insertions or deletions affect the end of the source list, rather \nthan its front or other elements. There is an easy remedy for the observed phenomenon. If we simply replace \nthe lines let g = IntMap.fromDistinctAscList (zip [0 ..ls - 1] s) and let t = [0 .. fromNat l ' - 1] \nin the de.nition of putcomb by let g = fromDistinctList (zip (reverse [0 ..ls - 1]) s) and let t = reverse \n[0 .. fromNat l ' - 1] respectively, then Theorems 5 and 6, and thus Corollaries 2 and 3, continue to \nhold, but instead of a rear update (insertion/deletion) bias, there is now a front update bias. For example, \nFigure 2 (the interesting subset thereof; all other entries remain unchanged) now becomes: ' ' ' ' s \nv put s v dput1  s v dput2  s v \"\" \"x\" Nothing Just \"x \" Nothing \"\" \"xy\" Nothing Just \"xy \" Nothing \n\"a\" \"x\" Nothing Nothing Just \"xa\" \"ab\" \"\" Nothing Just \"\" Just \"b\" \"ab\" \"xy\" Just \"xyb\" Just \"xyb\" Just \n\"xyb\" \"abc\" \"\" Nothing Just \"\" Just \"c\" \"abc\" \"x\" Just \"xc\" Just \"xc\" Just \"xc\" \"abc\" \"xyz\" Just \"xyzc\" \nJust \"xyzc\" Just \"xyzc\" The entries that have changed are shaded above. One could argue that in this \nspeci.c case all the changes are for the better, but in general it is desirable to be able to in.uence \nwhat bias is used. Making the bias explicit, and thus putting it under the potential control of the user, \nis easily possible by de.ning a further variation :6 of putcomb type Bias = Int . [Int] putbias :: Monad \n\u00b5 . Bias . [a] . [a] . \u00b5 [Maybe a] bias sv ' = putbias do let ls = length s let g = fromDistinctList \n(zip (bias ls) s) l ' . maybe (fail \"...\") return (sput (toNat ls)(toNat (length v ' ))) let t = bias \n(fromNat l ' ) let h = fromDistinctList (zip (get t) v ' ) let h ' = IntMap.union h g return (map (.ip \nIntMap.lookup h ' ) t) as well as: bdput :: Monad \u00b5 . Bias . a . [a] . [a] . \u00b5 [a] bdput bias d s v ' \n= do s ' bias sv ' . putbias return (map (maybe d id) s ' ) The only formal requirement imposed on a \nproper bias :: Bias, to ensure that analogues of Theorems 5 and 6 and of Corollaries 2 and 3 continue \nto hold, is that for every n ? 0, bias n should return a list of length exactly n and with no duplicate \nelements. Then, we in particular obtain the following two corollaries. 6 No change whatsoever is necessary \nto sput!  Corollary 4. Let bias :: Bias be proper (in the way just de\u00adscribed). For every type t and \nd :: t , bdput bias d :: [t ] . [t] . Maybe [t ] is consistent for get :: [t] . [t ] . Corollary 5. Let \nbias :: Bias be proper. For every type t and d :: t , bdput bias d :: [t ] . [t] . Maybe [t ] is .xed-shape-friendly \nfor get. (Moreover, the default value d is not actually used in bdput bias dsv ' if length v ' = length \n(get s).) For bdput to behave well in practice, it makes sense to (at least) additionally impose that \nwhenever n<m, the elements of the list bias n should form a subset of the elements of bias m. Some good \nexamples are: rear :: Bias rear l = [0 .. l - 1] front :: Bias front l = reverse [0 .. l - 1] middle \n:: Bias middle l = [1, 3 .. l ] + (reverse [2, 4 .. l ]) borders :: Bias borders l =(reverse [1, 3 .. \nl ]) + [2, 4 .. l ] Some examples for the get-function from Example 1 (with sput as given for this example \nin Section 5), illustrating the effects of different bias strategies, are given in Figure 3 (on the next \npage). The bene.cial effects, still for the case of the get-function from Example 1, might become even \nmore apparent when also looking at cases where the data values in the source and view lists are not disjoint, \nas in Figure 4. (When interpreting the results, note that both get1 \"abcd\" and get1 \"abcde\" equal \"bd\".) \nThe simple hints about which bias to apply when re.ecting speci.c updated views back to the source level \nare quite effective. In practice, which bias to choose could be determined on a case-by-case basis, with \ndecisions being made based on a form of diff between the original view and the updated view, or based \non information about performed editing operations, or even something more clever. The possibilities are \nopen, since we have exposed the bias strategy explicitly. 7. Extending Applicability It turns out that \nthe separation of shape and content, through the resultant move from [a] to Nat in the task posed to \nthe syntactic bidirectionalization subsystem, and with the help of some known syntactic program transformations, \nleads to applicability (and good results) of the combined technique in new situations otherwise out of \nreach. We illustrate this with two examples. Example 3. Assume our get-function is as follows, reversing \na list: get3 :: [a] . [a] get3 [] =[] get3 (x : xs)= get ' xs [x ] get ' :: [a] . [a] . [a] get ' [] \nys = ys get ' (x : xs) ys = get ' xs (x : ys) ' ' bias s v bdput bias  s v rear \"abcd\" \"x\" Just \"ax\" \nrear \"abcde\" \"x\" Just \"axc\" front \"abcd\" \"x\" Just \"cx\" front \"abcde\" \"x\" Just \"cxe\" middle \"abcd\" \"x\" \nJust \"ax\" middle \"abcde\" \"x\" Just \"axe\" borders \"abcd\" \"x\" Just \"bx\" borders \"abcde\" \"x\" Just \"bxd\" rear \n\"abcd\" \"bdx\" Just \"abcd x\" rear \"abcd\" \"bdxy\" Just \"abcd x y\" rear \"abcde\" \"bdx\" Just \"abcdex \" rear \n\"abcde\" \"bdxy\" Just \"abcdex y \" front \"abcd\" \"xbd\" Just \" xabcd\" front \"abcd\" \"xybd\" Just \" x yabcd\" \nfront \"abcde\" \"xbd\" Just \" xabcde\" front \"abcde\" \"xybd\" Just \" x yabcde\" middle \"abcd\" \"bxd\" Just \"ab \nxcd\" middle \"abcd\" \"bxyd\" Just \"ab x ycd\" middle \"abcde\" \"bxd\" Just \"abcx de\" middle \"abcde\" \"bxyd\" Just \n\"abcx y de\" borders \"abcd\" \"xbdy\" Just \" xabcd y\" borders \"abcde\" \"xbdy\" Just \" xabcdey \" borders \"abcde\" \n\"xybdzv\" Just \" x yabcdez v \" Figure 4. More update bias examples for get1 from Example 1. Due to the \naccumulating parameter of get ', the technique of Mat\u00ad suda et al. [2007] cannot be applied. The technique \nof Voigtl\u00a8ander [2009] can be applied, but fails to permit any shape-changing up\u00ad dates: ' ' s v put \ns v \"abc\" \"x\" Nothing \"abc\" \"xy\" Nothing \"abc\" \"xyz\" Just \"zyx\" \"abc\" \"xyzv\" Nothing Let us try the \ncombined technique. The move from [a] to Nat yields: sget :: Nat . Nat sget Z = Z sget (S xs)= sget ' \nxs (SZ) sget ' :: Nat . Nat . Nat sget ' Z ys = ys sget ' (S xs) ys = sget ' xs (S ys) Still, an accumulating \nparameter is used, preventing direct appli\u00adcation of the technique of Matsuda et al. to this new subproblem. \nHowever, it is now possible to apply a semantics-preserving pro\u00adgram transformation of Giesl [2000] to \ntransform sget ' as follows: sget ' :: Nat . Nat . Nat sget ' Z ys = ys sget ' (S xs) ys = S (sget ' \nxs ys) and to subsequently propagate the constant element (SZ) from sget to the now never-changed second \nparameter of sget ', .nally yielding: sget :: Nat . Nat sget Z = Z sget (S xs)= sget ' xs sget ' :: Nat \n. Nat sget ' Z = SZ sget ' (S xs)= S (sget ' xs)  s v ' bdput rear  s v ' bdput front  s v ' bdput \nmiddle  s v ' bdput borders  s v ' \"abcd\" \"abcd\" \"abcd\" \"abcde\" \"abcde\" \"abcde\" \"abcde\" \"x\" \"xyz\" \"xyzv\" \n\"x\" \"xyz\" \"xyzv\" \"xyzvw\" Just \"ax\" Just \"axcy z\" Just \"axcy z v\" Just \"axc\" Just \"axcyez \" Just \"axcyez \nv \" Just \"axcyez v w \" Just \"cx\" Just \" xaycz\" Just \" x yazcv\" Just \"cxe\" Just \" xaycze\" Just \" x yazcve\" \nJust \" x y zavcwe\" Just \"ax\" Just \"ax ycz\" Just \"ax y zcv\" Just \"axe\" Just \"axcy ze\" Just \"axcy z ve\" \nJust \"axcy z v we\" Just \"bx\" Just \" xbydz\" Just \" xaycz v\" Just \"bxd\" Just \" xbydz \" Just \" xayczev \" \nJust \" x ybzdv w \" Figure 3. Comparing different bias strategies for our combined technique on the get-function \nfrom Example 1. Now not only has the technique of Matsuda et al. [2007] become applicable, but their \ninjectivity analysis even detects both the above functions to be injective, which leads to the use of \nconstant func\u00adtions for scompl and scompl '. Tupling, inversion, and fusion then give an sput-function \nthat is equivalent to: sput :: Nat . Nat . Maybe Nat sput s v ' = return v ' which leads to perfect updatability \nfor the combined technique (no matter what kind of bias from the previous section is used): ' ' s v dput \n s v \"abc\" \"x\" Just \"x\" \"abc\" \"xy\" Just \"yx\" \"abc\" \"xyz\" Just \"zyx\" \"abc\" \"xyzv\" Just \"vzyx\" While \nreversing a list may appear a bit toy, in particular as it does not omit any information when going from \nthe source to the view, so that the bidirectionalization task essentially becomes one of only inversion, \nthe important point here is that through the move from [a] to Nat the get-function becomes simpler, in \ngeneral, so that additional bene.t can be gained by exploiting readily available syntactic techniques.7 \nWe further demonstrate this with another example (and another syntactic phenomenon). Example 4. Assume \nour get-function is as follows, returning the .rst half of a list: get4 :: [a] . [a] get4 [] =[] get4 \n(x : xs)= x :(get ' xs xs) get ' :: [a] . [a] . [a] ' get xs [ ] = [ ] ' get xs [y ] = [ ] ' ' get (x \n: xs)(y : z : zs)= x :(get xs zs) Since the function de.nition of get4 is not syntactically linear, \nthe technique of Matsuda et al. [2007] is not applicable. The technique of Voigtl\u00a8is indeed se\u00ad ander \n[2009] can be applied, and since get4 mantically linear, even with the strong guarantees from Section \n3.1. Of course, shape-changing updates will fail: ' ' s v putlinear s v \"abc\" \"x\" Nothing \"abc\" \"xyz\" \nNothing For the combined technique, we again .rst move from [a] to Nat: 7 It is also possible to remove \nthe accumulating parameter from the original, list-based get '-function in Example 3 using techniques \nof Giesl [2000] and Giesl et al. [2007], but the resulting program will still not be amenable to the \nmethod of Matsuda et al. [2007]. The move from [a] to Nat is really essential to be successful here. \nsget :: Nat . Nat sget Z = Z sget (S xs)= S (sget ' xs xs) sget ' :: Nat . Nat . Nat ' sget xs Z = Z \n' sget xs (S Z) = Z ' ' sget (S xs)(S (S zs)) = S (sget xs zs) Some straightforward syntactic analysis \nnow shows that, in particu\u00adlar when called with two equal arguments, sget ' never really needs its .rst \nargument (in contrast to the situation with get ', where the .rst argument plays a crucial role for supplying \nthe output list ele\u00adments). So we can simplify to: sget :: Nat . Nat sget Z = Z sget (S xs)= S (sget \n' xs) sget ' :: Nat . Nat sget ' Z = Z sget ' (SZ)= Z sget ' (S (S zs)) = S (sget ' zs) Now this is a \nprogram to which the technique of Matsuda et al. [2007] can be applied. Doing so, and combining the result \nwith the semantic technique of Voigtl\u00a8ander as described at the end of Sec\u00adtion 4, gives very good updatability. \nAn update only fails if either the source or the updated view is empty while the other is not. Of the \ndifferent kinds of update bias available from Section 6, middle and borders are particularly appropriate \n(not surprisingly, on re\u00ad.ection, given the nature of the get-function under consideration here): s v \n' bdput middle . . . bdput borders . . . \"\" \"\" Just \"\" Just \"\" \"abc\" \"x\" Just \"x\" Just \"x\" \"abc\" \"xy\" \nJust \"xyc\" Just \"xyc\" \"abc\" \"xyz\" Just \"xyz c\" Just \"xyzc \" \"abcd\" \"xy\" Just \"xycd\" Just \"xycd\" \"abcd\" \n\"xyzv\" Just \"xyzv cd\" Just \"xyzvcd \" \"abcdefgh\" \"xy\" Just \"xygh\" Just \"xyef\" 8. Conclusion We have developed \nan approach for combining the bidirectionaliza\u00adtion methods of Matsuda et al. [2007] and Voigtl\u00a8ander \n[2009]. By separating shape from content, we exploit the respective strengths of the two previous methods \nmaximally. The key insight is that when we simplify the problem of explicit bidirectionalization by posing \nit only on the shape level (going from get to sget), the ex\u00adisting syntactic technique can give far better \nresults than for the general problem. The existing semantic technique does the rest. The improvements \nachieved on the syntactic level (all caused by the fact that no data values have to be kept) can be classi.ed \nas 1) making the complement smaller, 2) introducing injectivity, 3) enabling additional transformations \nthat may bring programs into the required form in the .rst place, and 4) permitting non-linear programs \nto be made linear. We have seen representative examples for all four phenomena (Examples 1 4, in this \norder), all in the case of lists. We expect to observe the same, even ampli.ed, when considering functions \non other data types.  The move from [a] to Nat might appear somewhat ad-hoc, and very speci.c to lists. \nHowever, actually a very general principle is at work here. We could have equivalently replaced [a] by \n[()], for the unit type ().8 That is indeed a generic way to characterize the shape data type corresponding \nto a polymorphic data type: replace the polymorphic component a by (). It is also a good way to think \nabout implementing the get . sget step. A prototype of such an implementation (for the special case of \nlists) exists and has been packaged with the earlier implementation of the syntactic bidirectionalization \nmethod as well as with the relevant functions from Sections 4 and 6 of this paper, so that it is really \npossible to apply our combined bidirectionalization method automatically. The system is available at \nhttp://www.kb.ecei.tohoku.ac. jp/~kztk/b18n-combined/. Using the observation about the general principle \nabove, it should be clear that the abstraction/combination ideas in this paper can be applied similarly \nto other data types than lists. Dealing with type class polymorphism as Voigtl\u00a8ander [2009] does would \nbe a bit more challenging, because a more re.ned notion of shape is needed then. Also, .nding good pragmatic \nbias strategies as in Section 6 would be more complicated (but also interesting) in the case of non-lists. \nFinally, a few more words about formal properties of get/put\u00adpairs are in order. We have taken laws GetPut \n(1) and PutGet (2), in the form of De.nition 1, as consistency conditions. The literature also knows \nPutPut: ' '' '' put (put sv ) v = put sv , which as one interesting consequence together with GetPut \nimplies undoability: put (put sv ' )(get s) = s . Or, for partial put, the latter is required to hold \nwhenever put sv ' is de.ned, and the former if additionally put (put sv ' ) v '' is in\u00ad deed de.ned. \nThe technique of Matsuda et al. [2007] satis.es these two laws, by virtue of being based on the constant-complement \nap\u00ad proach of Bancilhon and Spyratos [1981]. Although not explicitly proved by Voigtl\u00a8ander [2009], his \ntechnique also satis.es these two additional laws. In fact, it can be reformulated via the constant\u00ad \ncomplement approach as well.9 So the question is natural whether our combined technique can also be so \nbased, and satis.es PutPut and undoability as well. The answer is No, as invocations like dput  \"abcd\" \n\"x\" = Just \"ax\" = dput  \"abyd\" \"x\" for Example 1 show. Clearly, there is no way that dput  \"ax\" \"bd\" \nis both Just \"abcd\" and Just \"abyd\" as undoability would de\u00ad mand; instead: dput  \"ax\" \"bd\" = Just \"ab \nd\". (PutPut fails for a similar reason.) Is that bad news? We would argue that not: any method that successfully \ndeals with insertion and deletion up\u00ad dates for a function like the get1 under consideration here will \nhave to give up PutPut and undoability. Indeed, these two properties are often considered undesirable, \nprecisely because they signi.cantly limit the transformations one can hope to deal with [Foster et al. \n2007; Gottlob et al. 1988; Keller 1987]. 8 Clearly, disregarding partial values like ., Nat and [()] \nare isomorphic. 9 No formal reference is available for this observation, but slides of a re\u00adcent talk \nat the Workshop on Bidirectional Transformation in Architecture-Based Component Composition (http://www.iai.uni-bonn.de/~jv/ \nbt_in_abc2010-slides.pdf). Acknowledgments We thank the anonymous reviewers for their insightful comments \nand suggestions. References S. Antoy and M. Hanus. Functional logic programming. Communications of the \nACM, 53(4):74 85, 2010. F. Bancilhon and N. Spyratos. Update semantics of relational views. ACM Transactions \non Database Systems, 6(3):557 575, 1981. A. Bohannon, B.C. Pierce, and J.A. Vaughan. Relational lenses: \nA language for updatable views. In Principles of Database Systems, Proceedings, pages 338 347. ACM Press, \n2006. A. Bohannon, J.N. Foster, B.C. Pierce, A. Pilkiewicz, and A. Schmitt. Boomerang: Resourceful lenses \nfor string data. In Principles of Pro\u00adgramming Languages, Proceedings, pages 407 419. ACM Press, 2008. \nK. Czarnecki, J.N.Foster, Z. Hu, R.L\u00a8ammel, A.Sch\u00a8urr, and J.F. Terwilliger. Bidirectional transformations: \nA cross-discipline perspective. In Inter\u00adnational Conference on Model Transformation, Proceedings, volume \n5563 of LNCS, pages 260 283. Springer-Verlag, 2009. J.N. Foster, M.B. Greenwald, J.T. Moore, B.C. Pierce, \nand A. Schmitt. Combinators for bidirectional tree transformations: A linguistic ap\u00adproach to the view-update \nproblem. ACM Transactions on Programming Languages and Systems, 29(3):17, 2007. J.N. Foster, A. Pilkiewicz, \nand B.C. Pierce. Quotient lenses. In Inter\u00adnational Conference on Functional Programming, Proceedings, \npages 383 395. ACM Press, 2008. J. Giesl. Context-moving transformations for function veri.cation. In \n Logic-Based Program Synthesis and Transformation 1999, Selected Pa\u00adpers, volume 1817 of LNCS, pages \n293 312. Springer-Verlag, 2000. J. Giesl, A. K\u00a8uhnemann, and J. Voigtl\u00a8ander. Deaccumulation techniques \nfor improving provability. Journal of Logic and Algebraic Programming, 71 (2):79 113, 2007. G. Gottlob, \nP. Paolini, and R. Zicari. Properties and update semantics of consistent views. ACM Transactions on Database \nSystems, 13(4):486 524, 1988. Z. Hu, S.-C. Mu, and M. Takeichi. A programmable editor for developing \nstructured documents based on bidirectional transformations. In Partial Evaluation and Semantics-Based \nProgram Manipulation, Proceedings, pages 178 189. ACM Press, 2004. A.M. Keller. Comments on Bancilhon \nand Spyratos Update semantics and relational views . ACM Transactions on Database Systems, 12(3): 521 \n523, 1987. K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and M. Takeichi. Bidirection\u00adalization transformation \nbased on automatic derivation of view comple\u00adment functions. In International Conference on Functional \nProgram\u00adming, Proceedings, pages 47 58. ACM Press, 2007. K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and \nM. Takeichi. Bidirec\u00adtionalizing programs with duplication through complementary function derivation. \nComputer Software, 26(2):56 75, 2009. A. Pettorossi. Transformation of programs and use of tupling strategy. \nIn Informatica, Proceedings, pages 1 6, 1977.  J.C. Reynolds. Types, abstraction and parametric polymorphism. \nIn Infor\u00admation Processing, Proceedings, pages 513 523. Elsevier, 1983. C. Strachey. Fundamental concepts \nin programming languages. Lecture notes for a course at the International Summer School in Computer Programming, \n1967. Reprint appeared in Higher-Order and Symbolic Computation, 13(1 2):11 49, 2000. J. Voigtl\u00a8ander. \nBidirectionalization for free! In Principles of Programming Languages, Proceedings, pages 165 176. ACM \nPress, 2009. P. Wadler. Theorems for free! In Functional Programming Languages and Computer Architecture, \nProceedings, pages 347 359. ACM Press, 1989. P. Wadler. Deforestation: Transforming programs to eliminate \ntrees. Theo\u00adretical Computer Science, 73(2):231 248, 1990.    \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Matsuda et al. [2007, ICFP] and Voigtl&#228;nder [2009, POPL] introduced two techniques that given a source-to-view function provide an update propagation function mapping an original source and an updated view back to an updated source, subject to standard consistency conditions. Being fundamentally different in approach, both techniques have their respective strengths and weaknesses. Here we develop a synthesis of the two techniques to good effect. On the intersection of their applicability domains we achieve more than what a simple union of applying the techniques side by side delivers.</p>", "authors": [{"name": "Janis Voigtl&#228;nder", "author_profile_id": "81100011863", "affiliation": "University of Bonn, Bonn, Germany", "person_id": "P2338182", "email_address": "", "orcid_id": ""}, {"name": "Zhenjiang Hu", "author_profile_id": "81100253989", "affiliation": "National Institute of Informatics, Tokyo, Japan", "person_id": "P2338183", "email_address": "", "orcid_id": ""}, {"name": "Kazutaka Matsuda", "author_profile_id": "81392597731", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2338184", "email_address": "", "orcid_id": ""}, {"name": "Meng Wang", "author_profile_id": "81351595589", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P2338185", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863571", "year": "2010", "article_id": "1863571", "conference": "ICFP", "title": "Combining syntactic and semantic bidirectionalization", "url": "http://dl.acm.org/citation.cfm?id=1863571"}