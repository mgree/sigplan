{"article_publication_date": "09-27-2010", "fulltext": "\n The Impact of Higher-Order State and Control Effects on Local Relational Reasoning Derek Dreyer Georg \nNeis Lars Birkedal MPI-SWS MPI-SWS IT University of Copenhagen dreyer@mpi-sws.org neis@mpi-sws.org birkedal@itu.dk \n Abstract Reasoning about program equivalence is one of the oldest prob\u00adlems in semantics. In recent \nyears, useful techniques have been developed, based on bisimulations and logical relations, for rea\u00adsoning \nabout equivalence in the setting of increasingly realistic languages languages nearly as complex as ML \nor Haskell. Much of the recent work in this direction has considered the interesting representation independence \nprinciples enabled by the use of local state, but it is also important to understand the principles that \npow\u00aderful features like higher-order state and control effects disable. This latter topic has been broached \nextensively within the frame\u00adwork of game semantics, resulting in what Abramsky dubbed the semantic cube \n: fully abstract game-semantic characterizations of various axes in the design space of ML-like languages. \nBut when it comes to reasoning about many actual examples, game semantics does not yet supply a useful \ntechnique for proving equivalences. In this paper, we marry the aspirations of the semantic cube to the \npowerful proof method of step-indexed Kripke logical relations. Building on recent work of Ahmed, Dreyer, \nand Rossberg, we de\u00ad.ne the .rst fully abstract logical relation for an ML-like language with recursive \ntypes, abstract types, general references and call/cc. We then show how, under orthogonal restrictions \nto the expressive power of our language namely, the restriction to .rst-order state and/or the removal \nof call/cc we can enhance the proving power of our possible-worlds model in correspondingly orthogonal \nways, and we demonstrate this proving power on a range of interesting ex\u00adamples. Central to our story \nis the use of state transition systems to model the way in which properties of local state evolve over \ntime. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; \nD.3.3 [Programming Languages]: Language Constructs and Features; F.3.1 [Logics and Meanings of Programs]: \nSpecifying and Verifying and Rea\u00adsoning about Programs General Terms Languages, Theory, Veri.cation Keywords \nStep-indexed Kripke logical relations, biorthogonality, observational equivalence, higher-order state, \nlocal state, .rst-class continuations, exceptions, state transition systems Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, \nMaryland, USA. Copyright c . 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 1. Introduction Reasoning \nabout program equivalence is one of the oldest problems in semantics, with applications to program veri.cation \n( Is an op\u00adtimized program equivalent to some reference implementation? ), compiler correctness ( Does \na program transformation preserve the semantics of the source program? ), representation independence \n( Can we modify the internal representation of an abstract data type without affecting the behavior of \nclients? ), and more besides. The canonical notion of program equivalence for many applica\u00adtions is observational \n(or contextual) equivalence. Two programs are observationally equivalent if no program context can distin\u00adguish \nthem by getting them to exhibit observably different in\u00adput/output behavior. Reasoning about observational \nequivalence di\u00adrectly is dif.cult, due to the universal quanti.cation over program contexts. Consequently, \nthere has been a huge amount of work on developing useful models and logics for observational equivalence, \nand in recent years this line of work has scaled to handle increas\u00adingly realistic languages languages \nnearly as complex as ML or Haskell, with features like general recursive types, general (higher\u00adorder) \nmutable references, and .rst-class continuations. The focus of much of this recent work e.g., environmental \nbisimulations [36, 17, 32, 35], normal form bisimulations [34, 16], step-indexed Kripke logical relations \n[4, 2, 3] has been on estab\u00adlishing some effective techniques for reasoning about programs that actually \nuse the interesting, semantically complex features (state, continuations, etc.) of the languages being \nmodeled. For instance, most of the work on languages with state concerns the various kinds of representation \nindependence principles that arise due to the use of local state as an abstraction mechanism. But of \ncourse this is only part of the story. When features are added to a language, they also enrich the expressive \npower of pro\u00adgram contexts. Hence, programs that do not use those new features, and that are observationally \nequivalent in the absence of those fea\u00adtures, might not be observationally equivalent in their presence. \nOne well-known example of this is the loss of referential trans\u00adparency in an impure language like ML. \nAnother shows up in the work of Johann and Voigtl\u00a8ander [15], who study the negative im\u00adpact that Haskell \ns strictness operator seq has on the validity of short-cut fusion and other free-theorems-based program \ntransfor\u00admations. In our case, we are interested in relational reasoning about stateful programs, so \nwe will be taking a language with some form of mutable state as our baseline. Nonetheless, we feel it \nis important not only to study the kinds of local reasoning principles that stateful programming can \nenable, but also to understand the principles that powerful features like higher-order state and control \neffects disable. This latter topic has been broached extensively within the framework of game semantics. \nIn the 1990s, Abramsky set forth a research programme (subsequently undertaken by a number of people) \nconcerning what he called the semantic cube [19, 1, 24].  The idea was to develop fully abstract game-semantic \ncharacteriza\u00adtions of various axes in the design space of ML-like languages. For instance, the absence \nof mutable state can be modeled by restricting game strategies to be innocent, and the absence of control \noperators can be modeled by restricting game strategies to be well-bracketed. These restrictions are \northogonal to one another and can be com\u00adposed to form fully abstract models of languages with different \ncombinations of effects. Unfortunately, when it comes to reason\u00ading about many actual examples, these \ngame-semantics models do not yet supply a useful technique for proving programs equivalent, except in \nfairly restricted languages. One possible reason for the comparative lack of attention paid to this issue \nin the setting of relational reasoning is that some key techniques that have been developed for reasoning \nabout local state notably, Pitts and Stark s method of local invariants [28] turn out to work just as \nwell in a language with higher-order state and call/cc as they do in the simpler setting (.rst-order \nstate, no control operators) in which they were originally proposed. Before one can observe the negative \nimpact of certain language features on relational reasoning principles, one must .rst develop a proof \ntechnique that actually exploits the absence of those features! 1.1 Overview In this paper, we marry \nthe aspirations of Abramsky s semantic cube to the powerful proof method of step-indexed Kripke logical \nrelations. Speci.cally, we show how to de.ne a fully abstract logi\u00adcal relation for an ML-like language \nwith recursive types, abstract types, general references and call/cc. Then, we show how, under orthogonal \nrestrictions to the expressive power of our language namely, the restriction to .rst-order state and/or \nthe removal of call/cc we can enhance the proving power of our model in cor\u00adrespondingly orthogonal ways, \nand we demonstrate this proving power on a range of interesting examples. Our work builds closely on \nthat of Ahmed, Dreyer, and Ross\u00adberg (hereafter, ADR) [3], who gave the .rst logical relation for modeling \na language with both abstract types and higher-order state. We take ADR as a starting point because the \nconcepts un\u00adderlying that model provide a rich framework in which to explore the impact of various computational \neffects on relational reasoning. In particular, one of ADR s main contributions was an extension of Pitts \nand Stark s aforementioned local invariants method with the ability to establish properties about local \nstate that evolve over time in some controlled fashion. ADR exploited this ability in order to reason \nabout generative (or state-dependent) ADTs. The central contribution of our present paper is to observe \nthat the degree of freedom with which local state properties may evolve depends directly on which particular \neffects are present in the pro\u00adgramming language under consideration. In order to expound this observation, \nwe .rst recast the ADR model in the more familiar terms of state transition systems (Section 3). The \nbasic idea is that the possible worlds of the ADR model are really state transition systems, wherein \neach state dictates a potentially different prop\u00aderty about the heap, and the transitions between states \ncontrol how the heap properties are allowed to evolve. Aside from being some\u00adwhat simpler than ADR s \nformulation of possible worlds (which relied on various non-standard anthropomorphic notions like pop\u00adulations \nand laws ), our formulation highlights the essential no\u00adtion of a state transition, which plays a crucial \nrole in our story. Next, in Section 4, we explain how to extend the ADR model with support for .rst-class \ncontinuations via the well-studied tech\u00adnique of biorthogonality (aka ..-closure) [18, 28]. The techni\u00adcal \ndetails of this extension are fairly straightforward, with the use of biorthogonality turning out to \nbe completely orthogonal (no pun intended) to the other advanced aspects of the ADR model. That said, \nthis is to our knowledge the .rst logical-relations model for a language with call/cc and state. Moreover, \na side bene.t of biorthogonality is that it renders our model both sound and complete w.r.t. observational \nequivalence (unlike ADR s, which was only sound).1 Interestingly, nearly all of the example program equivalences \nproved in the ADR paper continue to hold in the pres\u00adence of call/cc, and their proofs carry over easily \nto our present formulation. (There is one odd exception, the callback with lock example, for which the \nADR proof was very .ddly and ad hoc. We investigate this example in great detail, as we describe below.) \nThe ADR paper also included several interesting examples that their method was unable to handle. The \nunifying theme of these examples is that they rely on the well-bracketed nature of computation i.e., \nthe assumption that control .ow follows a stack\u00adlike discipline an assumption that is only valid in the \nabsence of call/cc. In Section 5, we consider two simple but novel enhance\u00adments to our state-transition-system \nmodel private transitions and inconsistent states which are only sound in the absence of call/cc and \nwhich correspondingly enable us to prove all of ADR s well-bracketed examples . Conversely, in Section \n6, we consider the additional reasoning power gained by restricting the language to .rst-order state. \nWe observe that this restriction enables backtracking within a state transition system, and we demonstrate \nthe utility of this feature on several examples. The above extensions to our basic state-transition-system \nmodel are orthogonal to each other, and can be used independently or in combination. One notable example \nof this is ADR s callback with lock equivalence (mentioned above), an equivalence that holds in the presence \nof either higher-order state or call/cc but not both. Using private transitions but no backtracking, \nwe can prove this equivalence in the presence of higher-order state but no call/cc; and using backtracking \nbut no private transitions, we can prove it in the presence of call/cc but only .rst-order state. Yet \nanother well-known example, due originally to O Hearn [26], is true only in the absence of both higher-order \nstate and call/cc; hence, it should come as no surprise that our novel proof of this example (presented \nin detail in Section 7.5) involves all three of our model s new features working in tandem. Most of the \npaper is presented in an informal, pedagogical style. Indeed, one advantage of our state transition systems \nis that they lend themselves to clean visual proof sketches. In Section 7, we make our proof method formally \nprecise and state some of the key metatheoretic results. Due to space limitations, we only work through \nthe formal proof of one representative example. Detailed proofs of our full abstraction results, as well \nas all our examples (and more!), appear in the companion technical appendix [8]. In Section 8, we brie.y \nconsider how our Kripke logical rela\u00adtions are affected by the addition of exceptions to the language. \nUnlike call/cc, exceptions do not impose restrictions on our state transition systems, but they do require \nus to account for exceptional behavior in our proofs. Finally, in Section 9, we compare our methods to \nrelated work and suggest some directions for future work.  2. The Language(s) Under Consideration In \nits unrestricted form, the language that we consider is a stan\u00addard polymorphic lambda calculus with \nexistential, pair, and iso\u00adrecursive types, general references (higher-order state), and .rst\u00ad 1 It is \nimportant to note that the completeness result has nothing to do with the particular features present \nin the language, and all to do with the use of biorthogonality. In particular, biorthogonality gives \nus a uniform way of constructing fully abstract models for all of the different languages considered \nin this paper, regardless of whether they contain call/cc, general references, etc. See Section 9 for \nfurther discussion of this point.  class continuations (call/cc). We call this language HOSC. Its syn\u00adtax \nand excerpts of its call-by-value semantics are given in Figure 1. Dots (. . . ) in the syntax cover \nprimitive operations on base types b, such as addition and if-then-else. To ensure unique typing, vari\u00adous \nconstructs have explicit type annotations, which we will typi\u00adcally omit if they are implicit from context. \nEvaluation contexts K, injected into the term language via contt K, represent .rst-class continuations. \nThey are a subset of general contexts C ( terms with a hole ), which are not shown here, but are standard. \nTheir typing judgment . C : (S;.;G;t ). (S ' ;. ' ;G ' ;t ' ) basically says that for any e with S;.;G \n. e : t we have S ' ;. ' ;G ' . C[e]: t ' . The continuation typing judgment S;.;G . K \u00f7t says that K \nis an evaluation context with a hole of type t . Finally, contextual (or observational) approximation, \nwritten S;.;G . e1 .ctx e2 : t , means that in any well-typed program context C, if C[e1]termi\u00adnates, \nthen so does C[e2]. Contextual (or observational) equiva\u00adlence is then de.ned as approximation in both \ndirections. t ::= a |b |t1 \u00d7 t2 |t1 . t2 |.a. t |.a. t | \u00b5a. t |ref t |contt e ::= x |l |.e1,e2.|e.1|e.2|.x:t. \ne |e1 e2 |.a.e |et | pack .t1 ,e. as t2 |unpack e1 as .a, x. in e2 | rollt e |unroll e |ref e |e1 := \ne2 |!e |e1 == e2 | contt K |call/cct (x. e)|throwt e1 to e2 | ... K ::= |.K, e2.|.v1 ,K.|K.1|K.2 |Ke2 \n|v1 K |Kt | pack .t1 ,K. as t2 |unpack K as .a, x.in e2 | rollt K |unroll K |ref K |K := e2 |v1 := K \n|!K | K == e2 |v1 == K | throwt K to e2 |throwt v1 to K | ... v ::= x |l |.v1 ,v2 .|.x:t. e |.a.e |pack \n.t1 ,v. as t2 | rollt v |contt K | ... fragments of interest: By restricting HOSC in two orthogonal ways, \nwe obtain three .h;K[ref v]. .h;K[l := v]. FOSC The result of restricting to .rst-order state. Concretely, \nthis .h;K[!l]. means only permitting reference types ref b, where b represents .h;K[l1 == l2 ]. base \ntypes like int, bool, etc. .h;K[l1 == l2 ]. .]l[K;}v..l.{ h... .]..[K]; v..l[h... .]v[K;h... .]tt[K;h... \n.].[K;h... (l/. dom(h)) (l . dom(h)) (h(l)= v) (l1 = l2 ) (l1 = l2 ) HOS The result of removing call/cc, \ni.e., dropping the type cont t and the corresponding three term-level constructs. FOS The result of making \nboth of the above restrictions.  3. A Model Based on State Transition Systems The Ahmed-Dreyer-Rossberg \n(ADR) model [3], on which our model is based, is a step-indexed Kripke logical relation for the language \nHOS. In this section, we will brie.y review what a step\u00adindexed Kripke logical relation is, what is interesting \nabout the ADR model, and how we can recast the essence of the ADR model in terms of state transition \nsystems. Step-Indexed Kripke Logical Relations Logical relations are one of the best-known methods for \nlocal reasoning about equiv\u00adalence (or, more generally, approximation) in higher-order, typed languages. \nThe basic idea is to de.ne the equivalence or approx\u00adimation relation in question inductively over the \ntype structure of the language, with each type constructor being interpreted by the logical connective \nto which it corresponds. For instance, two func\u00adtions are logically related if relatedness of their arguments \nimplies relatedness of their results; two existential packages are logically related if there exists \na relational interpretation of their hidden type representations that is preserved by their operations; \nand so forth. In order to reason about equivalence in the presence of state, it becomes necessary to \nplace constraints on the heaps under which programs are evaluated. This is where Kripke logical relations \ncome in. Kripke logical relations [28] are logical relations indexed by a possible world W , which codi.es \nsome set of heap constraints. Roughly speaking, e1 is related to e2 under W only if they behave the same \nwhen run under any heaps h1 and h2 that satisfy the constraints of W . When reasoning about programs \nthat maintain some local state, possible worlds allow us to impose whatever invariants on the local state \nwe want, so long as we ensure that those invariants are preserved by the code that accesses the state. \nTo make things concrete, consider the following example: t =(unit . unit). int e1 = let x = ref 1 in \n.f. (f ..;!x) e2 = .f. (f ..;1) We would like to show that e1 and e2 are observationally equivalent at \ntype t . The reason, intuitively, is obvious: the reference x is kept .]]K/x th;K[e[cont.. . .)]x.e(th;K[call/cc. \n.]v[' h;K.. . .] ' K'tv tocontth;K[throw. Heap typings S ::= \u00b7|S,l:t where fv(t )= \u00d8 Type environments \n. ::= \u00b7|.,a Term environments G ::= \u00b7|G,x:t . K :(S;.;G;t). (S;.;G;t ' ) S;.;G . K \u00f7 t S;.;G . K \u00f7 t \nS;.;G . contt K : cont t '' ' S;.;G,x:cont t . e : t S;.;G . e : t S;.;G . e : cont t ' S;.;G . call/cc(x. \ne): t S;.;G . throwt e to e : t t .l:t . S. S;\u00b7;\u00b7. h(l): t . h :S def S;.;G . e1 .ctx e2 : t = S;.;G \n. e1 : t .S;.;G . e2 : t ..C, S ' ,t ' , h. . C :(S;.;G;t ). (S ' ;\u00b7;\u00b7;t ' ).. h :S ' . .h;C[e1 ].. =..h;C[e2 \n].. Figure 1. The Language HOSC private (i.e., it is never leaked to the context), and since it is never \nmodi.ed by the function returned by e1 , it will always point to 1. To prove this using Kripke logical \nrelations, we would set out to prove that e1 and e2 are related under an arbitrary initial world W . \nSo suppose we evaluate the two terms under heaps h1 and h2 that satisfy W . Since the evaluation of e1 \nresults in the allocation of some fresh memory location for x (i.e., x .. dom(h1)), we know that the \ninitial world W cannot already contain any constraints governing the contents of x. (If it contained \nsuch a constraint, h1 would have had to satisfy it, and hence x would have to be in dom(h1 ).) So we \nmay extend W with a new invariant stating that -.).Itthenremainstoshowthatthetwo 1 (i.e., x pointsto \n1.. x abstractions are logically related under this extended world i.e., whichisstraightforward. 1. \n. undertheassumptionthat x Finally, step-indexed logical relations [4, 2] were proposed (originally by \nAppel and McAllester) as a way to account for se\u00admantically problematic features, such as general recursive \ntypes, whose relational interpretations are seemingly cyclic and thus dif.cult to de.ne inductively. \nThe idea is simply to stratify the construction of the logical relation by a natural number (or step \nindex ), representing roughly the number of steps of computation for which the programs in question behave \nin a related manner.  One of the key contributions of the ADR model was to combine the machinery of \nstep-indexed logical relations with that of Kripke logical relations in order to model higher-order state. \nWhile the details of this construction are quite interesting, they are orthogonal to the novel contributions \nof the model we present in this paper. Indeed, our present model follows ADR s very closely in its use \nof step-indexing to resolve circularities in the construction, and so we refer the interested reader \nto the ADR paper for details. ADR and State Transition Systems The other key contribution of the ADR \nmodel was to provide an enhanced notion of possible world, which has the potential to express properties \nof local state that evolve over time. To motivate this feature of ADR, consider a simple variant of the \nexample shown above, in which the .rst program e1 is replaced by e1 = let x = ref 0 in .f. (x := 1;f \n..;!x) Here, x starts out pointing to 0, but if the function that e1 evaluates to is ever called, x will \nbe set to 1and will never change back to 0. In this case, the only invariant one can prove about x is \nthat it points to either 0or 1, but this invariant is insuf.cient to establish that after the call to \nthe callback f, the contents of x have not changed back to 0. For this reason, Pitts and Stark, whose \npossible-worlds model only supported heap invariants, called this example the awkward example (because \nthey could not handle it) [28]. While the awkward example is clearly contrived, it is also a minimal \nrepresentative of a useful class of programs in which changes to local state occur in some monotonic \nfashion. As ADR showed, this includes well-known generative (or state-dependent) ADTs, in which the interpretation \nof an abstract type grows over time in correspondence with changes to some local state. ADR s solution \nwas to generalize possible worlds notion of heap constraint to express heap properties that change in \na con\u00adtrolled fashion. We can understand their possible worlds as essen\u00adtially state transition systems, \nwhere each state determines a par\u00adticular heap property, and where the transitions determine how the \nheap property may evolve. For instance, in the case of the awkward example, ADR would represent the heap \nconstraint on x via the following state transition system (STS):  Initially, x points to 0, and then \nit is set to 1. Since the call to the state,weknowitmust 1. . callback f occurswhenweareinthe x return \nin the same state since there is no transition out of that state. state 1.. xCorrespondingly,itisnecessarytoalsoshowthatthe \nis really .nal i.e., if the function to which e1 evaluates is called in that state, it will not change \nx s contents again but this is obvious. In ADR, states are called populations and state transition systems \nare called laws , but the power of their possible worlds is very similar to that of our STS s (as we \nhave described them thus far), and most of their proofs are straightforwardly presentable in terms of \nSTS s. That said, the two models are not identical. In particular, there is one example we are aware \nof, the callback with lock example, that is provable in ADR s model but not in our basic STS model. As \nwe will see shortly, there are good reasons why this example is not provable in our basic STS model, \nand in Section 5.1, we will show how to extend our STS s in order to prove this very example in a much \nsimpler, cleaner way than ADR s model does.  4. Biorthogonality, Call/cc, and Full Abstraction One point \non which different formulations of Kripke logical re\u00adlations differ is the precise formulation of the \nlogical relation for terms. The ADR model employs a direct-style term relation, which can be described \ninformally as follows: two terms e1 and e2 are logically related under world W iff whenever they are \neval\u00aduated in initial heaps h1 and h2 satisfying W , they either both di\u00adverge or they both converge \nto machine con.gurations .h ' 1;v1 .and .h '' 2;v2 .such that h ' 1and h2 ' satisfy W and v1 and v2 are \nlogically related values under W ', where W ' is some future world of W . (By future world , we mean \nthat W ' extends W with new con\u00adstraints about freshly allocated pieces of the heap, and/or the heap \nconstraints of W may have evolved to different heap constraints in W ' according to the STS s in W .) \nWe call this a direct-style term relation because it involves evaluating the terms directly to values \nand then showing relatedness of those values in some future world. An alternative approach, .rst employed \nin the logical relations setting by Pitts and Stark [28] but subsequently adopted by sev\u00aderal others \n(e.g., [13, 7, 5]), is what one might call a CPS term relation, although it is more commonly known as \na biorthogonal (or ..-closed) term relation. The idea is to de.ne two terms to be related under world \nW if they co-terminate (both converge or both diverge) when evaluated under heaps that satisfy W and \nunder continuations K1 and K2 related under W . The latter (continua\u00adtion relatedness) is then de.ned \nto mean that, for any future world W ' of W , the continuations K1 and K2 co-terminate when applied (under \nheaps that satisfy W ') to values that are related under W '. In this way, the logical relation for values \nis lifted to a logical relation for terms by a kind of CPS transform. The main arguable advantage of \nthe direct-style term relation is that its de.nition is perhaps more intuitive, corresponding closely \nto the proof sketches of the sort that we will present informally in the sections that follow. That said, \nin any language for which a direct-style relation is sound, it is typically possible to start in\u00adstead \nwith a biorthogonal relation and then prove a direct-style proof principle e.g., Pitts and Stark s principle \nof local invari\u00adants [28] as a corollary. The advantages of the biorthogonal approach are clearer. First, \nit automagically renders the logical relation complete with respect to observational equivalence, largely \nirrespective of the particular features in the language under consideration. (Actually, it is not so \nmagical: ..-closure is essentially a kind of closure under obser\u00advational equivalence.) Second, and perhaps \nmore importantly, the biorthogonal approach scales to handle languages with .rst-class continuations, \nsuch as our HOSC and FOSC, which the direct\u00adstyle doesn t. The reason for this is simple: the direct-style \nap\u00adproach is only sound if the evaluation of terms is independent of the continuation under which they \nare evaluated. If the terms behav\u00adior is context-dependent, then it does not suf.ce to consider their \nco-termination under the empty continuation, which is effectively what the direct-style term relation \ndoes. Rather, it becomes neces\u00adsary to consider co-termination of whole programs (terms together with \ntheir continuations), as the biorthogonal relation does. Thus, in this paper we adopt the biorthogonal \napproach. This enables us to easily adapt all the proofs from the ADR paper (save for one) to also work \nfor a language with call/cc. (The one exception is the callback with lock equivalence, which simply doesn \nt hold in the presence of call/cc.) It is worth noting that, although the kinds of example programs we \nfocus on in this paper do not involve abstract types, a number of the ADR examples do. Additionally, \nwe can prove equivalences involving programs that manipulate both call/cc and higher-order state. One \nwell\u00adknown challenging example of such an equivalence is the correct\u00adness of Friedman and Haynes encoding \nof call/cc via one-shot continuations (continuations that can only be invoked once) [11, 34]. The basic \nidea of the encoding is to model an unrestricted continuation using a private (local) ref cell that contains \na one-shot continuation. Every time the continuation is invoked, the ref cell is updated with a fresh \none-shot continuation. With biorthogonal logical relations, the proof of this example is completely straight\u00adforward, \nemploying just a simple invariant on the private ref cell. As far as we know, though, this proof is novel. \nFull details are given in the technical appendix [8].  5. Reasoning in the Absence of Call/cc In this \nsection, we examine some reasoning principles that are enabled by removing call/cc from our language. \nConsider this variant of the awkward example (from ADR): t =(unit . unit). int e1 = let x = ref 0 in \n .f. (x := 0;f ..;x := 1;f ..;!x) e2 = .f. (f ..;f ..;1) What has changed is that now the callback is \nrun twice, and in e1, the .rst call to f is preceded by the assignment of x to 0, not 1. It is easy to \nsee that e1 and e2 are not equivalent in HOSC (or even FOSC). In particular, here is a distinguishing \ncontext C: state even though this situation (x pointing to 0 after that call) cannot actually arise in \nreality. And indeed, if x could point to 0 at that point, our proof would be doomed. In summary, while \nwe would like to add this transition, we also want to keep the context from using it. This is where private \ntransitions come in. 5.1 Private Transitions Private transitions are a new class of transitions in our \nstate tran\u00adsition systems, separate from the ordinary transitions that we have seen so far (and which \nwe henceforth call public transitions). The basic idea is very simple: when reasoning about the relatedness \nof terms, we must show that when viewed extensionally they appear only to be making public transitions, \nand correspondingly we may assume that the context only makes public transitions as well. Internally, \nhowever, within a computation, we may make use of both public and private transitions. Concretely, we \ncan use the following STS to prove our running example (where the dashed arrow denotes a private transition): \n ,thepresenceofthe 1. . v1iscalledinthestartingstate xFirst,if 1 to .. xprivatetransitionallowsusto \nlawfully transitionfrom state 1.. x.Second,weknowthat,becauseweareinthe0.. x let g = in let b = ref \n. in before the second call to f and there is no public transition from let f =(. . if !b then call/cc \n(k. g (. . throw .. to k)) there to any other state, we must still be in that same state when f else \nb := tt)in returns. Hence we know that x points to 1 at that point, as desired. gf Lastly, although the \nbody of v1 makes a private transition internally Exploiting its ability to capture the continuation K \nof the second call to f, the context C is able to set x back to 0 and then immedi\u00adately throw control \nback to K. It is easy to verify that C[e1 ]yields 0, while C[e2 ]yields 1. In the absence of call/cc, \nhowever, computations are well\u00ad bracketed . Here, this means that whenever x is set to 0, it will eventually \nbe set to 1 no matter what the callback function does. Consequently, it seems intuitively clear that \nthese programs are equivalent in HOS (and FOS), but how do we prove it? The STS ),itappearsextensionallyto1.. \nx(whencalledinstartingstate )isobviously1.. xmakeapublictransition,sinceits.nalstate( publicly accessible \nfrom whichever state was the initial one. Private transitions let us prove not only this example, but \nalso several others from the literature that hold exclusively in the ab\u00ad sence of call/cc (including \nPitts and Stark s higher-order pro.ling example [28] see the appendix [8] for details). The intuitive \nrea\u00ad son why private transitions don t work with call/cc is that, in the presence of call/cc, every time \nwe pass control to the context may be the last! Therefore, the requirement that the extensional behav\u00admodel \nwe have developed so far will clearly not do the job, pre\u00ad cisely because that model is compatible with \ncall/cc and this exam\u00ad ple is not. So the question remains: how can we augment the power of our STS s \nso that they take advantage of well-bracketing? To see how to answer this question, let s see what goes \nwrong if ior of a term must appear like a public transition would essentially imply that every internal \ntransition must be public as well. The Callback with Lock Example Here is another equivalence we try \nto give an STS for our well-bracketed equivalence. First, (from ADR) that holds in HOS but not in HOSC. \nInterestingly, this recall the STS (from Section 3) that we used in order to prove example was provable \nin the original ADR model, but only through the original awkward example. To see why this STS is insuf.cient \nsome complex step-index hackery. The proof we are about to sketch is much cleaner and easier to understand. \nfor our present purposes, suppose the function value resulting from The.rst 2state. 1.. x isappliedinthe \n1v callit 1eevaluating thing that happens is that x is set to 0. However, as there is no state,thereisnoway \n0. . 1statetothe x. . transitionfromthe x we can continue the proof. So how about adding that transition? \n 0 clearsthe . . 1 to x.. Whileaddingthetransitionfrom x .rst hurdle, it also erects a new one: according \nto the STS, it is Consider the following two encodings of a counter object with two methods: an increment \nfunction that also takes a callback argument, which it invokes, and a poll function that returns the \ncurrent counter value. C = let b = ref ttinlet x = ref 0 in ..f. if !b then b := .; ;b := tt else .., \n. . !x. t = ((unit . unit). unit)\u00d7 (unit . int) e1 = C[f ..;x := !x + 1] e2 = C[let n = !x in f ..;x \n:= n +1] Note that in the second program the counter x is dereferenced be\u00ad fore the callback is executed, \nand in the .rst program it is deref\u00adnow possible that, after the second call to f, we end up in the left \nerenced after. In both programs, a Boolean lock b guards the in\u00adcrement of the counter, thereby enforcing \nthat running the callback will not result in any change to the counter. 2 When proving functions logically \nrelated, we must consider the possibility  The basic idea is to pass the increment method a callback \nthat captures its current continuation and stores that in a ref cell so it can be invoked later. The \nde.nition of this distinguishing context appears in the appendix [8]. In the absence of call/cc, however, \nthe two programs are equiv\u00adalent. To prove this, we employ the following in.nite STS: will check if y \npoints to tt and, if so, diverge. If the thunk was not applied during the call to f, then e1 will set \nx to tt, thus ensuring that any future attempt to apply the thunk will diverge as well. As in the previous \nexamples, note that this equivalence does not hold in the presence of call/cc. Here is a distinguishing \ncontext: call/cc (k. (.g. throw g .. to k)) To prove the equivalence in HOS, we can split the proof \ninto . . . two directions of approximation. Proving that e2 approximates e1 is actually very easy because \n(1) it is trivial to show that .. .ap\u00adproximates the thunk that e1 passes to f, and (2) if a program \nC[e2 ] terminates (which is the assumption of observational approxima\u00ad ,... ymustinfactmaintaintheinvariantthat \n]1e[Ction),then and using that invariant the proof is totally straightforward. . . . In contrast, the \nother direction of approximation seems at .rst glance impossible to prove using logical relations. The \nissue is that we have to show that the thunks passed to the callback f are related, i.e., that .. if \n!x then . else y := tt approximates .. ., which For each number n there are two states: one (the unlocked \nstate)  saying that b points to tt and x points to n in both programs, and another (the locked state) \nsaying that b points to . and x points to n in both programs. It is thus easy to see that the two poll \nmethods are related (they return the same number). To show the increment methods related, suppose they \nare executed in a state where x points . is . . tosome m and b pointsto tt (theothercasewhere b trivial). \nBefore invoking the callback, b is set to . and, in the second program, n is bound to m. Accordingly, \nwe move downwards in our STS to the locked state and can then call f. Because that state obviously is \nfalse since, when applied (as they may be) in a state where x points to ., the .rst converges while the \nsecond diverges. To solve this conundrum, we do the blindingly obvious thing, which is to introduce falsehood \ninto our model! Speci.cally, we extend our STS s with inconsistent states, in which we can prove false \nthings, such as that a terminating computation approximates a divergent one. How, one may ask, can this \npossibly work? The idea is as follows: when we enter an inconsistent state, we effectively shift the \nproof burden from the logical relation for terms to the does not have any other public successors, we \nwill still be there if and when f returns indeed, this is the essence of what it means to be a locked \nstate. In the .rst program, x is then incremented, i.e., set to m +1. In the second program, x is set \nto n +1 = m +1. Finally, b is set back to tt and we thus move to the matching private .. bsuccessor( \n)intheSTS.Sincethisisapublic +1m. . tt ,x ),ourextensionalm.. x,tt .. bsuccessoroftheinitialstate( transition \nappears public and we are done. logical relation for continuations. That is, while it becomes very easy \nto prove that two terms are related in an inconsistent state, it becomes very hard to prove that two \ncontinuations K1 and K2 are related in such a state in most cases, we will be forced to prove that K1 \ndiverges. Thus, while inconsistent states do allow a limited kind of falsehood inside an approximation \nproof, we can only enter into them if we know that the continuation of the term on the left\u00adhand side \nof the approximation will diverge anyway. Concretely, to show that e1 approximates e2, we construct the \n 5.2 Inconsistent States following STS, where the diamond indicates an inconsistent state: While private \ntransitions are clearly a useful extension to our STS model, there is one kind of well-bracketed example \nwe are aware of that private transitions alone are insuf.cient to account for. We are referring to the \ndeferred divergence example, presented by ADR as an example they could not handle. The original version \nof this equivalence, due to O Hearn [26], was presented in the setting of Idealized Algol, and it does \nnot hold in the presence of higher\u00adorder state. (We will consider a variant of O Hearn s example later \non, in Section 6.) Here, we consider a version of the equivalence that does hold in HOS, based on the \none in Bohr s thesis [7]: t = ((unit . unit). unit). unit e1 = let x = ref . in let y = ref . in For \nthe moment, ignore the top-left state (we explain it below). In .f. f (.. if !x then . else y := tt); \n the proof, we wish to show that the thunks passed to the callback f if !y then . else x := tt are logically \nrelated in the top-right state, which requires showing e2 = .f. f (. . .) that they are related in any \nstate accessible from it. Fortunately, Intuitively, the explanation why e1 and e2 are equivalent goes \nas follows. The functions returned by both programs take a higher\u00adorder callback f as an argument and \napply it to a thunk. In the case of e2 , if that thunk argument (.. ., where . is a divergent term) is \never applied, either during the call to f or at some point in the future (e.g., if the thunk were stored \nby f in a ref cell and then called later), then the program will clearly diverge. Now, e1 implements \nthe same divergence behavior, but in a rather sneaky way. It maintains two private .ags x and y, initially \nset to .. If the thunk that it passes to f is applied during the call to f, then the thunk s body will \nnot immediately diverge (as in the case of e2), but rather merely set y to tt. Then, if and when f returns, \ne1 this is easy. If the thunks are called in the bottom-left state, then they both diverge. If they are \ncalled in the top-right or bottom-right state, then the else-branch is executed (in the .rst program) \nand we move to (or stay in) the bottom-right state since this state is inconsistent, the proof is trivially \ndone. Dually, we must show that the continuations of the callback applications are also related in any \nstate (publicly) accessible from the top-right one. If the continuations are invoked in the top-right \nor the bottom-left state, they will set x to tt, thereby transitioning to the bottom-left. If, on the \nother hand, they are invoked in the inconsistent bottom-right state, then we are required to show that \nthe .rst one diverges, which fortunately it will since y points to tt.  Now about the top-left state, \nwhose heap constraint is identical to the one in the top-right state: the reason for including this state \nhas to do with soundness of the logical relation. In order to ensure soundness, we require that when \nan STS is installed in the possible world, it may not contain any inconsistent states that are publicly \naccessible from its starting state. We say in this case that the starting state is safe. (Without this \nsafety restriction, it would be easy to show, for instance, that tt approximates . in any world W by \nsimply adding an STS to W with a single inconsistent state.) To circumvent this restriction, we use the \ntop-left state as our starting state and connect it to the top-right state by a private transition. (In \nthe proof, the .rst step before invoking the callbacks is to transition into the top-right state.) This \nis .ne so long as the extensional behavior of the functions we are relating makes a public transition, \nand here it does if they are invoked in the top-left state, then either they diverge or they return control \nin the bottom-left state, which is publicly accessible from the top-left.   6. Reasoning With First-Order \nState In this section, we consider an orthogonal restriction to the one examined in the previous section. \nInstead of removing call/cc from the language, what happens if we restrict state to be .rst-order? What \nnew reasoning principles are enabled by this restriction? 6.1 Backtracking Recall the callback with lock \nexample from Section 5.1, which we proved equivalent in HOS. As it turns out, that equivalence also holds \nin FOSC. Of course, we won t be able to prove that using the HOSC model since the equivalence doesn t \nhold in HOSC. But let us see what exactly goes wrong if we try. First of all, recall the use of private \ntransitions in our earlier proof. Due to call/cc, we cannot use any private transitions this time. Clearly, \nmaking them public is not an option, so what if we just drop them entirely? the .rst-order setting, though, \nthere is no way for the callback to store such higher-order data, so backtracking is not a problem. A \nprecise technical explanation of how the model is changed to allow backtracking, and why this is sound, \nwill be given in Section 7.3.  6.2 Putting It Together The example we just looked at might suggest that \nbacktracking is mainly useful as a replacement for private transitions in the presence of call/cc. But \nin fact, they are complementary techniques. In particular, for equivalences that hold only in FOS but \nnot in HOS or FOSC, we can pro.tably employ backtracking, private transitions, and inconsistent states, \nall working together. Consider this simpler version of the deferred divergence ex\u00adample, based closely \non an example of O Hearn [26]: t = ((unit . unit). unit). unit e1 = let y = ref . in .f. f (. .y := tt); \nif !y then . else .. e2 = .f. f (. . .) These programs are not only distinguishable in the setting of \nFOSC (by the same distinguishing context as given in Section 5.2), but also in HOS, as the following \ncontext demonstrates: C = let r = ref (. . ..)in (.g. r := g);!r .. It is easy to verify that C[e1]terminates, \nwhile C[e2 ]diverges. The two programs are, however, equivalent in FOS, which we can prove using the \nfollowing STS: The proof is largely similar to (if a bit simpler than) the one sketched for the higher-order \nversion of this example in Section 5.2. \u00b7\u00b7\u00b7 We start in the left state and transition immediately along \nthe pri\u00advate transition to the middle state. With the help of the inconsistent right state, it is easy \nto show that the thunk arguments passed to the callback are related in the middle state. Hence, when \nthe callback returns, we are either in the right state or the middle state. In the former case, we must \nshow that the continuation in the l.h.s. pro\u00adgram diverges; in the latter, we backtrack to the initial, \nleft state, \u00b7\u00b7\u00b7 which is of course publicly accessible from itself. (We will present this proof in more \ndetail below, in Section 7.5.) Why, one might ask, is it not possible to avoid the use of In the resulting \nSTS, we still know that running the callback in a )willleaveusintheverysamestate m. . ., x.. blockedstate( \nif and when it returns. However, without any outgoing (private) transition from that state, it seems \nthat we are subsequently stuck. Fortunately, we are not. The insight now is that the absence of higher-order \nstate allows us to do backtracking within our STS. backtracking here by adding a private transition back \nfrom the middle state to the left state? (Of course, it must not be possible, or else the equivalence \nwould hold true in HOS, which as we have seen it does not.) The answer is that, if we were to add such \na transition, then we would not be able to prove that the thunk arguments to the callback f were logically \nrelated in the middle Concretely, we can backtrack from the locked state to the unlocked x,tt .. bstatewewereinbefore( \n),andthentransitionm. . .. b(publicly)toitssuccessor( ).Intuitively,this +1m. . tt ,x kind of backtracking \nwould not be sound in the presence of higher\u00adstate. Speci.cally, in order to show the latter, we must \nshow that the thunks are related in any state accessible (by any kind of transition) from the middle \nstate. So if there were any transition from the order state because, in that setting, the callback might \nhave stored middle to the left state, we would have to show that the thunks some higher-order data during \nits execution (such as functions or were related starting in the left state as well but they are not, \ncontinuations) that are only logically related in the locked state and because there is no public transition \nfrom the initial left state to )isnotasuccessorof +1m. . tt ,x. . 3Since( bitssuccessors. the previous \nlocked state, the .nal heaps would then fail to satisfy the .nal world in which the increment functions \nreturn. Here in the inconsistent right state, and adding one would be unsound.  7. Technical Development \nchanges to that yield the models for HOSC, FOS, and FOSC.  HeapAtomn = {(W, h1, h2 )|W . Worldn} HeapReln \ndef = {. . HeapAtomn |.(W, h1 , h2 ). Islandn def = {. = (s, d, ., ., H)|. . State.H . Worldn def = {W \n= (k, S1 , S2 , .)|k < n ..m. . . Islandm ContAtomn[t1 , t2 ] def = {(W, K1, K2 )|W . Worldn .W.S1 ; \nTermAtomn[t1 , t2 ] def = {(W, e1, e2)|W . Worldn .W.S1;\u00b7; ValRel[t1 , t2 ] def = {r . TermAtomval [t1 \n, t2]|.(W, v1 , v2 ). SomeValRel def = {R = (t1, t2, r)|r . ValRel[t1 , t2]} .(.1 , . . . , .m).k def \n= (..1 .k, . . . , ..m.k) .H.k def = .(s, d, ., ., H).k def = (s, d, ., ., .H.k) ...k def = .(k + 1, \nS1 , S2 , .) def = (k, S1 , S2 , ...k) .r def = (k ' , S ' 1 , S ' 2 ,. ' (. ' 1 ,...,. ' ' m (s ' ,d \n' ,. ' , . ' ,H ' (k ' , S ' 1 , S2 ' ,. ' (. ' 1 ,...,. ' ' m (s ' ,d ' ,. ' , . ' ,H ' def safe(W )= \n.. . W... safe(.) . .. ' def def .. .W ' . W. (W ' ,h1 ,h2 ). .} s . State.d . State2 .. . d .d, . re.exive \n.d, . transitive . State . HeapReln} } \u00b7;\u00b7. K1 \u00f7 t1 .W.S2 ;\u00b7;\u00b7. K2 \u00f7 t2} \u00b7. e1 : t1 .W.S2 ;\u00b7;\u00b7. e2 : \nt2 } k r. .W ' . W. (W ' ,v1 ,v2 ). r} def ) . (k, S1 , S2 ,.)= def ) . (.1 ,...,.m)= def ) . (s, d, \n., .,H)= ).pub ).pub ).pub def (k, S1 , S2 ,.)= def (.1 ,...,.m)= def (s, d, ., .,H)= def .s..H(s).k \n{(W, h1 ,h2 ). r |W.k < k} {(W, e1,e2 )|W.k > 0=. (.W, e1,e2). r} safe(.)= .s ' . (..s, s ' ). ... \n=. s ' ./... consistent(W )= .. . W... ..s . ... def = {(W, h1 .h1 ' ,h2 .h ' 2 )|(W, h1 ,h2 ). . .(W, \nh 1 ' ,h ' 2 ). . ' } N|W..| k ' = k .S ' 1 . S1 .S ' 2 . S2 .. ' ....k' m ' = m ..j .{1,...,m}.. ' \nj . .j (d ' ,. ' , . ' ,H ' )=(d, ., .,H).(s, s ' ). d k ' .pub ...k' = k .S ' 1 . S1 .S ' 2 . S2 .. \n' ' j .pub m = m ..j .{1,...,m}.. ' .j . .j .{m +1,...,m ' }. safe(. ' j) (d ' , . '' ' ,. ' ,H )=(d, \n., .,H).(s, s ). . def (h1 ,h2 ): W = . h1 : W.S1 .. h2 : W.S2 .(W.k > 0=. (.W, h1 ,h2 ). i=1 W..(i).H(W..(i).s)) \nFigure 2. Worlds and Auxiliary De.nitions 7.1 HOS As described in Section 3, we employ a step-indexed \nKripke logical relation, which is a kind of possible-worlds model. Worlds Figure 2 displays the construction \nof worlds, along with various related operations and relations.4 Worlds W consist of a step index k, \nheap typings S1 and S2 (for the .rst and second programs, respectively), and an array of islands . = \n.1 ,...,.n. Islands in turn are (possibly in.nite) state transition systems gov\u00aderning disjoint pieces \nof the heap. Each consists of a current state s, a transition relation d, a public transition relation \n., a set of in\u00adconsistent states ., and last but not least, a mapping H from states to heap constraints \n(in the form of world-indexed heap relations more on that below). The public transition relation . must \nbe a subset of the full transition relation d (note: the private transi\u00adtions are obtained by subtracting \n. from d), and we require both d and . to be re.exive and transitive. What exactly states s are i.e., \nhow we de.ne the state space State does not really matter. That is, Stateis essentially a param\u00adeter \nof the model, except that it needs to be at least large enough to encode bijections on memory locations \n(see our relational interpre\u00adtation of ref types below). For our purposes, we .nd it convenient to assume \nthat State contains all terms and all sets of terms. Also, note that while an island s H map is de.ned \non all states in State, we typically only care about how it is de.ned on a particular set of 4 Here and \nin the following development we use the dot-notation to project components out of a structure. As an \nexample, we write W.S1 to extract the .rst heap typing out of a world W. states of interest whether there \nis other junk in the Statespace is irrelevant. Our use of step-indexing to stratify the construction \nof worlds and to de.ne the logical relation by a primary induction on nat\u00adural numbers follows the development \nin ADR quite closely. For space reasons, we therefore omit explanation of the approximation operation \n.\u00b7.k, the later operator ., and other step-related tech\u00adnicalities and refer the interested reader to \nthe literature [3, 9]. One point about notation, though: we sometimes write World to mean S n Worldn, \nand similarly for the other semantic classes. Based on the two transition relations (full and public), \nwe de\u00ad.ne two notions of future worlds (aka world extension). First, we say that W ' extends W , written \nW ' . W , iff it contains the same islands as W (and possibly more), and for each island in W , the new \nstate s ' of that island in W ' which is the only aspect of the island that is permitted to change in \nfuture worlds is accessible from the old state s in W , according to the island s full transition ' .pub \nrelation d. Public extension, written WW , is de.ned anal\u00adogously, except using the public transition \nrelation . instead of d, and with the additional requirement that the new islands (those in W ' but not \nin W ) must be safe. An island is safe iff there is no public transition from its current state to any \ninconsistent state. The reason why our (and ADR s) heap relations are world\u00adindexed is that, when expressing \nheap constraints, we want to be able to say, for instance, that a value in the .rst heap must be logically \nrelated to a value in the second heap. In that case, we need to have some way of talking about the current \nworld under which that logical relation should be considered, and by world-indexing the heap relations \nwe enable the current world to be passed in as a  def V.a.. = .(a).r def V.b.. = {(W, v, v). TermAtom[b, \nb]} def ' ' ' '' '' V.t \u00d7t .. = {(W, .v1 ,v 1 ., .v2 ,v 2 .). TermAtom[.1 (t \u00d7 t ),.2(t \u00d7 t )]|(W, v1 \n,v2 ).V.t .. .(W, v 1 ' ,v 2 ).V.t ..} def ' '' V.t . t.. = {(W, .x:t1.e1 , .x:t2 .e2). TermAtom[.1(t \n. t ),.2(t . t )]| ''' '' .W ,v1 ,v2 .W . W .(W ,v1 ,v2 ).V.t .. =. (W ,e1[v1 /x],e2 [v2 /x]).E.t ..} \ndef V..a. t.. = {(W, .a.e1 , .a.e2 ). TermAtom[.1 (.a. t ),.2(.a. t )]| .W ' . W. .(t1,t2,r). SomeValRel. \n(W ' ,e1 [t1/a],e2 [t2/a]).E.t .., a..(t1 ,t2,r)} def V..a. t.. = {(W, pack .t1,v1 . as t1' , pack \n.t2,v2 . as t2 ' ). TermAtom[.1 (.a. t ),.2(.a. t )]| .r. (t1,t2,r). SomeValRel.(W, v1 ,v2 ).V.t .., \na..(t1,t2 ,r)} def V.\u00b5a. t.. = {(W, rollt1 v1 , rollt2 v2). TermAtom[.1 (\u00b5a. t ),.2(\u00b5a. t )]|(W, v1 \n,v2 ). .V.t [\u00b5a. t/a]..} def V.ref t.. = {(W, l1 ,l2). TermAtom[.1(ref t ),.2(ref t )]|.i. .W ' . W. \n(l1,l2 ). bij(W ' ..(i).s). ... W ' ..(i).H(W ' ..(i).s)= W, {l1 ..v1}, {l2 ..v2 }). HeapAtom|(f . .{(f \nW,v1 ,v2 ).V.t ..}} def : W ..h1 ;e1..<W.k O = {(W, e1,e2)|.h1 ,h2 . (h1 ,h2 ) =. consistent(W )..h2 \n;e2..} def K.t .. = {(W, K1 ,K2 ). ContAtom[.1 (t ),.2(t )]| '' .pub '' .W ,v1 ,v2 .W W .(W ,v1 ,v2 \n).V.t .. =. (W ,K1 [v1 ],K2[v2 ]).O} def E.t .. = {(W, e1,e2). TermAtom[.1(t ),.2(t )]|.K1,K2 . (W, \nK1 ,K2).K.t .. =. (W, K1[e1 ],K2 [e2 ]).O} def def G.\u00b7.. = {(W, \u00d8)|W . World}G.G,x:t.. = {(W, (., x..(v1 \n,v2 )))|(W, .).G.G.. .(W, v1 ,v2 ).V.t ..} def def D.\u00b7. = {\u00d8} D..,a. = {., a..R |. .D... .R . SomeValRel} \ndef def S.\u00b7. = World S.S,l:t. = S.S. n{W . World|(W, l, l).V.ref t.\u00d8} def S;.;G . e1 .log e2 : t = S;.;G \n. e1 : t .S;.;G . e2 : t . .W,.,.. W .S.S. .. .D... .(W, .).G.G.. =. (W, .1.1 e1,.2.2e2 ).E.t .. Figure \n3. A Step-Indexed Biorthogonal Kripke Logical Relation for HOS parameter. These world-indexed heap relations \nare quite restricted, however. Speci.cally, they must be monotone with respect to world extension, meaning \nthat heaps related in one world will continue to be related in any future world. This ensures that adding \na new island to the world, or making (any kind of) transition within an existing island, does not violate \nthe heap constraints of other islands. The last two de.nitions also concern heap relations. Two heaps \nh1 and h2 satisfy a world W , written (h1 ,h2 ): W , iff they can be split into disjoint subheaps such \nthat for each island in W there is a subheap of h1 and a corresponding subheap of h2 that are related \nby that island s current heap relation (the relation associated with the island s current state). A heap \nrelation . is the tensor of . ' and . '', written . ' .. '' , if it contains all (W, h1 ,h2 )that can \nbe split . '' into disjoint parts (W, h ' 1 ,h 2 ' ). . ' and (W, h 1 '' ,h '' 2 ). . Logical Relation \nOur logical relation for HOS is de.ned in Fig\u00adure 3. The value relation V.t .. (where fv(t ) . dom(.)) \nis fairly standard. The only real difference from the ADR model is in V.ref t .., our interpretation \nof reference types. Basically, we say that two references l1 and l2 are logically related at type ref \nt in world W if there exists an island . in W , such that (1) . s heap con\u00adstraint (in any reachable \nstate) requires of l1 and l2 precisely that their contents are related at type t , and (2) the reachable \nstates in . encode a bijection between locations that includes the pair (l1,l2 ). The latter condition, \nwhich employs an auxiliary bij function (de.ned in the appendix [8]), is needed in order to model the \npres\u00adence of reference equality testing l1 == l2 in the language. Our formulation of V.ref t.. is slightly \ndifferent from ADR s and a bit more .exible e.g., ours can be used to prove Bohr s local state release \nexample [7] (see the appendix), whereas ADR s can t but this added .exibility does not affect any of \nour headlining examples from Sections 3 6. We will report on the advantages of our present formulation \nin a future, extended version of this paper. In logical relations proofs, we frequently assume that we \nare given some related values (e.g., as inputs to functions), and we want them to be still related after \nwe have added an island to the world or made a transition. It is therefore crucial that, like heap relations, \nvalue relations are monotone w.r.t. world extension. Since we enforce this property for relational interpretations \nof abstract types (see the de.nition of ValRel in Figure 2), it is easy to show that the value relation \nindeed has this property: Theorem 1 (Monotonicity of the Value Relation). If W ' . W and (W, v1 ,v2 ).V.t \n.., then (W ' ,v1 ,v2 ).V.t ... As explained in Section 4, the value relation is lifted to a term relation \nvia biorthogonality. Concretely, we de.ne the continuation relation K.t .. based on V.t .., and then \nthe term relation E.t .. based on K.t ..: Two continuations are related iff they yield related observations \nwhen applied to related values.  Two terms are related iff they yield related observations when evaluated \nunder related continuations.  Yielding related observations here means (see the de.nition of O) that, \nwhenever two heaps satisfy the world W in question and the .rst program terminates in the .rst heap (within \nW.k steps), then the second program terminates in the second heap and the world is consistent (i.e., \nno island is in an inconsistent state). This corresponds to the intuition given in Section 5.2 that an \ninconsistent world is one in which the .rst program diverges. Notice that the continuation relation quanti.es \nonly over public future worlds. This captures the essential idea (explained in Sec\u00adtion 5.1) that the \ncontext can only make public transitions. In order to see this, it is important to understand how a typical \nproof in a biorthogonal logical relation goes. Roughly, showing the related\u00adness of two programs that \ninvolve a call to an unknown function (e.g., a callback) eventually reduces to showing that the continu\u00adations \nof the function call are related; thanks to the de.nition of K.t .., we will only need to consider the \npossibility that those con\u00adtinuations are invoked in a public future world of the world we were in prior \nto the function call in other words, we can assume that the function call made a public transition. We \nwill see how this works in detail in the example proof in Section 7.5.  Finally, the logical relation \nis lifted to open terms in the usual way, quantifying over related closing substitutions d and . match\u00ading \n.and G, respectively, as well as an initial world in which every location bound in S is related to itself. \nWe write d1 (resp. .1) and d2 (resp. .2) here as shorthand for the .rst and second type (resp. value) \nsubstitutions contained in d (resp. .). Soundness and Completeness The proof that our logical relation \nis sound w.r.t. contextual approximation follows closely that of ADR [3]. It involves proving the usual \ncompatibility lemmas and the construction of a canonical safe world for a given heap typing. Details \ncan be found in the technical appendix [8]. Theorem 2 (Fundamental Property). If S;.;G . e : t , then \nS;.;G . e .log e : t . Theorem 3 (Soundness). .log . .ctx Following Pitts and Stark [28], we show completeness \nof our logical relation w.r.t. contextual approximation with the help of Mason and Talcott s ciu-approximation \n[23] as an intermediate relation. Theorem 4 (Completeness). .ctx . .ciu . .log Proving the inclusion \nof .ctx in .ciu is fairly easy. The inclusion of .ciu in .log follows as an almost immediate consequence \nof the Fundamental Property, together with the logical relation s biorthog\u00adonal de.nition. Again, full \ndetails can be found in the appendix [8].  7.2 HOSC The model for HOSC can be obtained from the one \nfor HOS by making two changes. First of all, in HOSC, we have to account for the presence of .rst-class \ncontinuation values contt K. Fortu\u00adnately, we already have a continuation relation K.t .., so it is easy \nto de.ne the value relation at type contt in terms of it: def V.cont t.. = {(W, cont K1, cont K2 )|(W, \nK1,K2).K.t ..} Now, recall that we need our value relation to be monotone w.r.t. .. Given the extension \nwe have just made to the value relation for cont t , that means we need our continuation relation to \nbe mono\u00adtone w.r.t. . as well. However, as explained above, the continua\u00adtion relation is only monotone \nw.r.t. .pub (in order to ensure that the context can only make public transitions). Of course, what this \nmeans is that in the presence of call/cc, the private and public tran\u00adsition relations must be collapsed \ninto one, and consequently we must disallow inconsistent states, too. This corresponds to the in\u00adtuition \nwe gave in Section 5.1, namely that private transitions and inconsistent states are only sound to use \nin the absence of call/cc. Formally, we disallow them by rede.ning Islandn as follows: def Island ' = \n{. . Islandn |... = ..d .... = \u00d8} n Under this de.nition, the two notions of world extension coincide \nand all worlds are consistent. The rest of the model stays the same. In particular, proofs done in the \nHOS model that do not make use of private transitions or inconsistent states can be transferred without \nany change. The soundness and completeness proofs carry over as well. The former merely needs to be extended \nin a straightforward way to deal with call/cc, throw, and cont. 7.3 FOS In the .rst-order state setting, \nobserve that, for the types of values that can be stored in the heap namely, those of base type our logical \nrelation for values coincides with syntactic equality. Conse\u00adquently, when expressing that two heap values \nare logically related, we no longer need to refer to a world. Obtaining the model for FOS from the one \nfor HOS is therefore very simple all that is needed is to remove the ability of heap relations to be \nworld-dependent: def HeapRel ' = P(Heap\u00d7 Heap) n Our heap relations are now more or less the same as \nin Pitts and Stark [28] that is, they are simply heap relations! Correspond\u00ad : W , . ' .. '' ingly, we \nmust also update the de.nitions of (h1,h2 ), and V.ref t .., all in the obvious manner, to re.ect the \nlack of world indices in heap relations. (For details, see the appendix.) Note that while step-indices \nare no longer needed to stratify our worlds, they are still useful in modeling general recursive types. \nThis simpli.cation of HeapRel enables backtracking (see Sec\u00adtion 6.1) by isolating islands from one another \ncompletely. Whereas before, changing the state of an island . could break the heap con\u00adstraints in other \nislands if we did not strictly follow . s STS, now there is no way for changes to . s state to affect \nthe satisfaction of other islands heap constraints, so we are free to backtrack. 7.4 FOSC The changes \nto the HOS model discussed in Sections 7.2 and 7.3 are completely orthogonal and may be easily combined \nin order to obtain a fully abstract model for FOSC.  7.5 Proof of Deferred Divergence Example (FOS Version) \nWe now present in detail a proof that demonstrates the use of all three of our model s special features \n(private transitions, inconsis\u00adtent states, and backtracking). Concretely, we show the dif.cult di\u00adrection \nof approximation in the FOS version of the deferred diver\u00adgence example from Section 6.2. Formally, our \ngoal is to prove \u00b7;\u00b7;\u00b7. e1 .log e2 : t . Unfolding the de.nition, this reduces to showing (W, e1,e2 ).E.t \n. for W . World. So assume we are given continuations (W, K1,K2) . K.t . and heaps (h1,h2 ): W and .h1 \n;K1 [e1]. terminates in less than W.k steps. We must now show that W is consistent and that .h2;K2[e2 \n].terminates as well. Observe that since .h1;K1[e1 ]. terminates in less than W.k steps, so does .h1 \n.{ly...};K1[eb1 [ly/y]]., where eb1 is the body of the let-expression in e1, and ly is some fresh location. \nFor this new location, we extend the world with an island representing the STS from Section 6.2, with \ns =1, 2, and 3 representing the left, middle, and right states of the STS, respectively: Ws =(W.k, (W.S1 \n,ly:bool), W.S2 , (W.., .s)) .s =(s, d, ., .,H) d = {(1, 2), (2, 3)} * . = {(2, 3)} * . = {3} H(1) = \n{(hf1 ,hf2)|hf1 (ly)= .} H(2) = {(hf1 ,hf2)|hf1 (ly)= .} H(3) = {(hf1 ,hf2)|hf1 (ly)= tt} Here the superscript \n* in the de.nitions of d and . denotes the re.exive, transitive closure over State. .pub Note that .1 \nis safe and therefore W1 W . Given how we de.ned our island, it is easy to see that (h1 .{ly...},h2 ): \nW1 follows from (h1 ,h2): W . Assuming we are able to show (W1,eb1[ly/y],e2 ) .V.t ., we can instantiate \n(W, K1,K2 ) . K.t . and get consistent(W1) and that .h2 ;K2[e2 ]. terminates. The latter is one of the \ntwo things we needed to show. The other one is consistent(W ). Since the only difference between W and \nW1 is our island, this follows from consistent(W1).  It remains to show (W1,eb1[ly/y],e2) .V.t .. So \nsuppose we are given a future world W ' . W1 and related callbacks (W ' ,f1,f2) .V.(unit . unit). unit.. \nWe need to show (W ' ,e 1' ,f2 (. . .)).E.unit., where e1 ' = f1 (. .ly := tt);if !ly then . else ... \n'' ' So suppose we are given continuations (W ,K 1 ,K 2) .K.unit. ' '' and heaps (h ' 1 ,h ' 2 ): W and \n.h1' ;K1 [e1 ]. terminates in less than W ' .k steps. We must now show that W ' is consistent and that \n.h '' 2 ;K2[f2 (. . .)].terminates as well. As a matter of notation, let Ws ' denote the world obtained \nfrom W ' by setting our island s state to s. We only show the case W ' = W1 ' here; the other two are \nsimilar (and simpler). The .rst step is to move to the middle state (state 2) . Formally, since the heap \nconstraints of state 1 and 2 are the same, (h ' 1 ,h ' 2 ): W1 ' implies (h ' 1,h 2' ): W2' . Now, we \nwant to prove the following: 1. (W2' ,f1 (. .ly := tt),f2 (. . .)).E.unit. '' ' 2. (W2,K 1 [ ;if !ly \nthen . else ..],K 2 ).K.unit. If we can prove these two subgoals, then instantiating (1) with (2) yields \nconsistent(W2' ) and that .h2 ' ;K2 ' [f2 (. . .)]. termi\u00adnates. The latter is one of the two things \nwe needed to show. The other one is consistent(W1' ), which obviously follows from consistent(W2' ). \nSo it remains to show (1) and (2). For (1), .rst note that since f1 and f2 are related in W1' , they \n' '' are by monotonicity also related in W2 since W2 . W1. It there\u00adfore suf.ces to show the relatedness \nof their thunk arguments, i.e., (W2' , (. .ly := tt), (. . .)) .V.unit . unit.. To that end, we '' ' \n'' suppose W . W2 and have to show (W ,ly := tt, .) . '' '' '' E.unit.. So assume we are given continuations \n(W ,K 1 ,K 2 ). K.unit. and heaps (h '' 1 ,h 2 '' ): W ''. With the help of the incon\u00adsistent state we \nwill now show that .h '' 1 ;K1 '' [ly := tt]. certainly does not terminate in less than W '' .k steps \n(so there is nothing further to do). Assume it does, implying that .h '' 1 [ly..tt];K1 '' [..]. '' ''' \n'' '' does, too. Since W . W2, W is either W2 or W3 (using the same notational trick as above). Consequently, \nit is easy to see that '' .pub '' W3 W 1 [ly2 ): W3 . Instantiating '', as well as (h '' ..tt],h '' '' \n'' '' (W ,K 1 ,K 2 ) .K.unit. with all this plus the trivial fact that '' '' (W3 , .., ..) .V.unit. \nyields consistent(W3 ), which is clearly in contradiction to 3being an inconsistent state. '' .pub ' \nFor (2), suppose we are given WW2 and heaps (h '' '' ' 1 ,h '' 2 ): W and that .h1 '' ;K1[if !ly then \n. else ..]. termi\u00ad '' ) nates in less than W '' .k steps. We have to show consistent(W and that .h '' \n2 ;K2' [..]. terminates. From the assumptions it is clear that h '' 1 (ly) must be . and thus .h '' 1 \n;K1' [..]. terminates in less '' '' than W '' .k steps. This also implies that W must be W . We now 2 \n''' '' want to instantiate (W1,K 1 ,K 2) .K.unit., but W2 does not publicly extend W ' because there \nis no public transition from state 1 1 to state 2. However, we can now backtrack to state 1: because \nboth states express the same heap constraint and because heap re\u00adlations for FOS are world-independent, \n(h '' 1 ,h 2 '' ): W2 '' implies (h '' '' '' .pub ' '' .pub ' 1 ,h '' 2 ): W1 . Note that W2 W2 implies \nW1 W1. '' ' Finally, we can instantiate (W1,K 1 ,K 2 ) .K.unit. with all this '' '' plus (W1 , .., ..) \n.V.unit., to obtain consistent(W1 )and that .h '' ' 2 ;K2[..]. terminates. Since our state 2 is a consistent \nstate, '' '' consistent(W1 )implies consistent(W2 ), and we are done.  8. Reasoning in the Presence \nof Exceptions In this paper, we have focused attention on .rst-class continuations as our control effect \nof interest, and demonstrated that their ab\u00adsence enables the extension of our STS-based Kripke model \nwith the mechanisms of private transitions and inconsistent states. It is natural, then, to ask about \nthe impact that other control effects have on our model. At least in the case of exceptions, the answer \nis quite simple, as we will now brie.y explain. (Details appear in the tech\u00adnical appendix [8], and we \nintend to elaborate on these in an ex\u00adtended version of this paper. We leave consideration of other con\u00adtrol \neffects, such as delimited continuations, to future work.) First of all, unlike throwing to a continuation, \nraising an excep\u00adtion causes a well-bracketed kind of control effect, in the sense that it passes control \nto the exception handler that was most re\u00adcently pushed onto the control stack. Thus, the presence of \nexcep\u00adtions does not per se restrict our STS model: we are free to use STS s with private transitions \nand inconsistent states. However, the possibility of exceptional behavior means that, when proving two \ncontinuations to be logically related (by K.t ..), we must show that they behave in a related manner \nnot only when they are plugged with related values, but also when they are passed related raised exceptions. \nConcretely, the de.nition of K.t .. be\u00adcomes the following (assuming a new base type exn of exceptions): \n{(W, K1,K2 ). ContAtom[.1(t ),.2 (t )]| '' .pub .W ,v1 ,v2 .W W =. ((W ' ,v1 ,v2 ).V.t .. =. (W ' ,K1[v1 \n],K2 [v2 ]).O). ((W ' ,v1 ,v2 ).V.exn. =. (W ' ,K1 [raise v1 ],K2[raise v2 ]).O)} In essence, this new \nde.nition is equivalent to K.M(t ).., where M is the exception monad i.e., M(t ) t +exn. Each of the \nvarious examples we have considered in this paper involves proving equivalence of two higher-order functions \nthat, when called, will manipulate some local state and invoke their (unknown) callback arguments. Thus, \nfor each of the examples, the new, more restrictive de.nition of K.t .. requires us to consider the possibility \nthat the callback invocation may raise an exception. Since the higher-order function in each example \ndoes not install any exception handler around its callback invocation, any exception raised by that callback \ninvocation will remain uncaught, causing the function to return immediately (raising the same exception). \nWe therefore need to show that any state in which the callback may raise an exception i.e., any state \nthat is publicly accessible from the one in which the callback was invoked is also publicly accessible \nfrom the initial state in which the higher-order function was called. For the callback-with-lock example, \nthis is indeed the case, since the only state publicly accessible from the locked state (in which the \ncallback is invoked) is itself, which is publicly acces\u00adsible from the unlocked starting state. For the \nother examples, on the other hand, this criterion is not met; and indeed, in the presence of exceptions, \nit is not hard to .nd program contexts that distinguish the higher-order functions in those examples. \n 9. Related and Future Work Many techniques have been proposed for reasoning about contex\u00adtual equivalence \nof stateful programs. Using a variety of these tech\u00adniques, most of the examples we discuss in this paper \nhave been proven already (with minor variations) in different language set\u00adtings, but there has not heretofore \nbeen any clear account of how they all .t together. Indeed, our main contribution lies in our uni\u00adfying \nframework of STS s, along with the realization that the ab\u00adsence of call/cc and/or higher-order state \nenables the extension of our STS model in orthogonal ways. That said, some of our exam\u00adples are also \nnew, such as callback with lock in FOSC, and the other ADR examples in HOSC (see the appendix [8] for \nmore). Game Semantics As explained in the introduction, game seman\u00adtics has served as an inspiration \nto us, especially Abramsky s idea of the semantic cube . There are many papers on this topic; per\u00adhaps \nthe two most relevant to our present work are Laird s model of call-by-name PCF extended with a control \noperator [19] and Abramsky, Honda, and McCusker s model of call-by-value PCF extended with general references \n[1]. Unlike our HOSC and its fragments, the language considered by Abramsky et al. does not support pointer \nequality.5  The primary focus of the research on games models has been full abstraction. One of the \nkey motivations for having a fully ab\u00adstract model is, of course, that it allows one to prove two pro\u00adgrams \nobservationally equivalent by proving that their denotations (in games models, strategies ) are the same. \nHowever, the games models do not in general directly facilitate such proofs since the strategies are \nnon-trivial to analyze for equality (and since game categories also involve a non-trivial quotienting). \nHence, proof methods for proving actual program equivalences based on speci.c games models have primarily \nbeen developed only for simple lan\u00adguages with state, namely call-by-name Idealized Algol. For a .ni\u00adtary \nversion of that language (i.e., a version with only .nite ground types and no recursion) there is a full \nclassi.cation of when contex\u00adtual equivalence is decidable (e.g., see [12, 25]). A .nitary version of \na call-by-value variant has also been studied by Murawski [24], and with that model he could show some \n.nitary versions of the examples of Pitts and Stark, e.g., the pro.ling example [24, p. 29]. Another \nfocus of game semantics is on understanding how the presence of different features in a language affects \nthe kinds of in\u00adteractions a program can have with its context. Laird [19] models the presence of control \noperators by relaxing the well-bracketing restriction on strategies. Abramsky et al. [1] model the presence \nof higher-order state by relaxing the visibility restriction. There seems intuitively to be some correspondence \nbetween the former and our private transitions, and between the latter and our back\u00adtracking, but determining \nthe precise nature of this correspondence is left to future work. Operational Game Semantics Another \nline of related work con\u00adcerns what some have called operational game semantics . This work considers \nlabeled transition systems, and either traces or bisimulation relations over those, directly inspired \nby games mod\u00adels. Such so-called normal form bisimulation relations have been developed for an untyped \nlanguage with state and control [34], for a typed language with recursive types (but no state) [21], \nand for a language with impredicative polymorphism (but no state) [22]. Laird [20] gave a fully abstract \ntrace semantics for the language of Abramsky et al. [1] extended with pointer equality. His trace-sets \nmay be viewed as deterministic strategies in the sense of game se\u00admantics. Normal form bisimulations \nhave been used to prove con\u00adtextual equivalence of actual examples, e.g., St\u00f8vring and Lassen s proof \nof correctness [34] for the encoding of call/cc via one-shot continuations that we described at the end \nof Section 4. Koutavas and Lassen have shown, in unpublished work [16], how Laird s trace semantics can \nbe used to prove the HOS version of the de\u00adferred divergence example (Section 5.2), by showing that the \ntwo programs have the same set of traces. To the best of our knowledge, however, no fully abstract games \nmodel (either operational or denotational) has yet been given for the rich language that we consider \nin this paper (call-by-value, im\u00adpredicative polymorphism, general references with pointer equal\u00adity, \ncall/cc, and recursive types). Logical Relations Our work is heavily indebted to the pioneer\u00ading work \nof Pitts and Stark [28], who gave a fully abstract logi\u00adcal relation for a simply-typed functional language \nwith recursion and .rst-order state. In particular, we rely on the basic setup of their biorthogonal \nKripke model, although (like ADR s) ours is also 5 We have not emphasized the fact that we model pointer \nequality in this paper, but some of ADR s examples do make use of it, and it is a feature one generally \nexpects to .nd in real ML-like languages. step-indexed. In the absence of step indices, biorthogonality \nren\u00adders the logical relation admissible (an important property when modeling recursion). In the presence \nof step indices, admissibility is not as important, since the model essentially only consists of .\u00adnite \napproximations, and there is no need to ever talk about their limit. Nevertheless, as we have seen, biorthogonality \nplays a cru\u00adcial role in modeling control and ensuring full abstraction. With respect to the latter, \nit is not clear how useful the full ab\u00adstraction property is for us per se, since it is achieved in a \nlargely feature-independent manner. That is, the proof that biorthogonal\u00adity makes the logical relation \ncomplete is essentially the same for each of the four languages we consider, so full abstraction here \nis perhaps not the most informative criterion. One could for in\u00adstance take Pitts and Stark s original \nmodel, add step-indexing to it, and get out a different fully abstract model for HOSC. Clearly, that \nmodel would not be as practically powerful as our STS-based model, but it would nevertheless be fully \nabstract. Aside from ADR, the closest logical relations to ours are the ones developed by Bohr in her \nthesis [7]. Hers also employ biorthogonality, albeit in a denotational setting. Her possible worlds bear \nsome similarity to ADR s in that they, too, allow one to model heap properties that evolve over time. \nIn addition, they allow one to impose constraints on continuations. Like us, she is also able to handle \nthe HOS version of the deferred divergence example, but the language she considers is not as rich as \nours (it does not support full polymorphism), and she does not consider handling call/cc or the restriction \nto .rst-order state. We can prove all of the examples from her thesis, and we believe that our proofs \nare signi.cantly simpler to understand. Regarding the deferred divergence example: it is originally due \nto O Hearn, who formulated it in the context of Idealized Algol [26, 2.3]. Pitts showed how to prove \nthis example using operational Kripke logical relations, by allowing the parameters of the logical relation \nto relate proper states to unde.ned states (i.e., by phrasing heap relations over lifted heaps) [29]. \nIt is not clear whether this technique generalizes to higher-order state, however. More recently, Johann, \nSimpson, and Voigtl\u00a8ander [14] have pro\u00adposed a generic framework for operational reasoning about alge\u00adbraic \neffects. Their work is complementary to ours: they develop effect-independent proof principles, whereas \nwe develop effect\u00adspeci.c proof principles. They do not consider local state, higher\u00adorder state, or \ncontrol. Lastly, our decision to employ both step-indexing and biorthog\u00adonality was in.uenced directly \nby the work of Benton, together with Tabareau [6] and Hur [5], on compiler correctness. They argue persuasively \nfor the bene.ts of combining the two techniques. Environmental Bisimulations For reasoning about contextual \nequivalences (involving either type abstraction or local state), one of the most successful alternatives \nto logical relations is the coin\u00adductive technique of environmental bisimulations. The current state \nof the art is Sumii s work on type abstraction and general refer\u00adences [35], which builds on work by \nSumii-Pierce [36], Koutavas-Wand [17], and Sangiorgi-Kobayashi-Sumii [32]. Sumii is able to handle all \nthe examples we have presented here in the setting of HOS; he does not consider call/cc or .rst-order \nstate (but does, in the work with Sangiorgi, consider concurrency). In some cases (e.g., for the well-bracketed \nversion of the awkward example see Section 5.1), his approach is somewhat brute-force in the sense that \nit requires explicit reasoning about the intensional struc\u00adture of program contexts. We believe our state \ntransition systems capture the intuitions about well-bracketing at a more abstract level. Anti-Frame \nRule Pottier [30] has proposed an alternative way of reasoning about local state using a rich type system \nwith capabil\u00adities, regions, and linearity. His anti-frame rule allows one to es\u00adtablish a hidden property \nabout a piece of local state, much in the same way that our islands do. In its original form, however, \nthe anti-frame rule was restricted to reasoning about invariants, which we argued in Section 3 are insuf.cient \nfor many examples.  To address this limitation, Pottier has suggested two extensions of his framework. \nFirst, in joint work with Pilkiewicz [27], he proposes the use of fates, which enable reasoning about \nmonotonic state in a manner rather similar to the state transition systems in our Kripke model. Second, \nin a brief unpublished note [31], he sets forth a generalized version of the anti-frame rule that permits \nreasoning about well-bracketed state change. While there are clear analogies between these extensions \nand our public/private state transitions, determining a precise formal correspondence is likely to be \ndif.cult because the methods are tailored to different purposes. On one hand, Pottier s type systems \nare richer than that of ML, and thus his techniques can be used to verify correctness of some interesting \nprograms that exploit the advanced features of his type systems. On the other hand, some equivalences \nlike our deferred divergence example from Sec\u00adtion 5.2 do not seem to be easily expressible as unary \ntype\u00adchecking problems and thus cannot seemingly be handled by Pot\u00adtier s method. Moreover, like Sumii \n[35], Pottier restricts attention to languages that support higher-order state but no control effects. \nFinally, it is important to note that Pottier s anti-frame rule has only been proven sound in a relatively \nidealized setting [33], and its soundness has yet to be established even in the context of the type\u00adand-capability \nsystem in which it was originally proposed [30], let alone the extended systems mentioned above [27, \n31]. Other Related Work Seminal work on operational reasoning about state and control was conducted by \nFelleisen and Hieb [10] and Mason and Talcott [23], but the proof principles they devel\u00adoped are relatively \nweak in comparison to the ones afforded by our model. Thielecke [37] demonstrated an interesting equivalence \nthat holds in the presence of exceptions and state, but not in the presence of continuations and state. \nHis proof method is relatively brute\u00adforce, however, and we can easily prove his example using an STS \nwith private transitions. More recently, Yoshida et al. [38] proposed a Hoare-style logic for reasoning \nabout higher-order programs with local state, but it does not handle abstract types, nor does it permit \nthe kind of reasoning achieved by our STS s. Dreyer et al. [9] have devised a relational modal logic \nthat accounts for the essential as\u00adpects of the ADR model. In the future, we hope to generalize that \nlogic to account for the additional features we have proposed here.  References [1] S. Abramsky, K. \nHonda, and G. McCusker. A fully abstract game semantics for general references. In LICS, 1998. [2] A. \nAhmed. Semantics of Types for Mutable State. PhD thesis, Princeton University, 2004. [3] A. Ahmed, D. \nDreyer, and A. Rossberg. State-dependent representa\u00adtion independence. In POPL, 2009. [4] A. Appel and \nD. McAllester. An indexed model of recursive types for foundational proof-carrying code. TOPLAS, 23(5):657 \n683, 2001. [5] N. Benton and C.-K. Hur. Biorthogonality, step-indexing and com\u00adpiler correctness. In \nICFP, 2009. [6] N. Benton and N. Tabareau. Compiling functional types to relational speci.cations for \nlow level imperative code. In TLDI, 2009. [7] N. Bohr. Advances in Reasoning Principles for Contextual \nEquiv\u00adalence and Termination. PhD thesis, IT University of Copenhagen, 2007. [8] D. Dreyer, G. Neis, \nand L. Birkedal. The impact of higher-order state and control effects on local relational reasoning (Technical \nappendix), 2010. http://www.mpi-sws.org/~dreyer/papers/stslr/. [9] D. Dreyer, G. Neis, A. Rossberg, and \nL. Birkedal. A relational modal logic for higher-order stateful ADTs. In POPL, 2010. [10] M. Felleisen \nand R. Hieb. The revised report on the syntactic theories of sequential control and state. TCS, 103(2):235 \n271, 1992. [11] D. Friedman and C. Haynes. Constraining control. In POPL, 1985. [12] D. R. Ghica and \nG. McCusker. Reasoning about Idealized Algol using regular languages. In ICALP, 2000. [13] P. Johann. \nShort cut fusion is correct. JFP, 13(4):797 814, 2003. [14] P. Johann, A. Simpson, and J. Voigtl\u00a8ander. \nA generic operational metatheory for algebraic effects. In LICS, 2010. [15] P. Johann and J. Voigtl\u00a8ander. \nThe impact of seq on free theorems\u00adbased program transformations. Fundamenta Informaticae, 69(1 2):63 \n102, 2006. [16] V. Koutavas and S. Lassen. Fun with fully abstract operational game semantics for general \nreferences. Unpublished, Feb. 2008. [17] V. Koutavas and M. Wand. Small bisimulations for reasoning about \nhigher-order imperative programs. In POPL, 2006. [18] J.-L. Krivine. Classical logic, storage operators \nand second-order lambda-calculus. Annals of Pure and Applied Logic, 68:53 78, 1994. [19] J. Laird. Full \nabstraction for functional languages with control. In LICS, 1997. [20] J. Laird. A fully abstract trace \nsemantics for general references. In ICALP, 2007. [21] S. B. Lassen and P. B. Levy. Typed normal form \nbisimulation. In CSL, 2007. [22] S. B. Lassen and P. B. Levy. Typed normal form bisimulation for parametric \npolymorphism. In LICS, 2008. [23] I. Mason and C. Talcott. Equivalence in functional languages with effects. \nJFP, 1(3):287 327, 1991. [24] A. S. Murawski. Functions with local state: regularity and undecid\u00adability. \nTCS, 338(1 3):315 349, 2005. [25] A. S. Murawski and I. Walukiewicz. Third-order Idealized Algol with \niteration is decidable. TCS, 390(2 3):214 229, 2008. [26] P. O Hearn and U. Reddy. Objects, interference, \nand the Yoneda embedding. In MFPS, 1995. [27] A. Pilkiewicz and F. Pottier. The essence of monotonic \nstate. Submit\u00adted for publication, 2009. [28] A. Pitts and I. Stark. Operational reasoning for functions \nwith local state. In HOOTS, 1998. [29] A. M. Pitts. Reasoning about local variables with operationally-based \nlogical relations. In LICS, 1996. [30] F. Pottier. Hiding local state in direct style: a higher-order \nanti-frame rule. In LICS, 2008. [31] F. Pottier. Generalizing the higher-order frame and anti-frame rules. \nUnpublished, 2009. [32] D. Sangiorgi, N. Kobayashi, and E. Sumii. Environmental bisimula\u00adtions for higher-order \nlanguages. In LICS, 2007. [33] J. Schwinghammer, H. Yang, L. Birkedal, F. Pottier, and B. Reus. A semantic \nfoundation for hidden state. In FOSSACS, 2010. [34] K. St\u00f8vring and S. B. Lassen. A complete, co-inductive \nsyntactic theory of sequential control and state. In POPL, 2007. [35] E. Sumii. A complete characterization \nof observational equivalence in polymorphic .-calculus with general references. In CSL, 2009. [36] E. \nSumii and B. Pierce. A bisimulation for type abstraction and recursion. Journal of the ACM, 54(5):1 43, \n2007. [37] H. Thielecke. On exceptions versus continuations in the presence of state. In ESOP, 2000. \n[38] N. Yoshida, K. Honda, and M. Berger. Logical reasoning for higher\u00adorder functions with local state. \nLMCS, 4(4:2), 2008.  \n\t\t\t", "proc_id": "1863543", "abstract": "<p>Reasoning about program equivalence is one of the oldest problems in semantics. In recent years, useful techniques have been developed, based on bisimulations and logical relations, for reasoning about equivalence in the setting of increasingly realistic languages - languages nearly as complex as ML or Haskell. Much of the recent work in this direction has considered the interesting representation independence principles <i>enabled</i> by the use of local state, but it is also important to understand the principles that powerful features like higher-order state and control effects <i>disable</i>. This latter topic has been broached extensively within the framework of game semantics, resulting in what Abramsky dubbed the \"semantic cube\": fully abstract game-semantic characterizations of various axes in the design space of ML-like languages. But when it comes to reasoning about many actual examples, game semantics does not yet supply a useful technique for proving equivalences.</p> <p>In this paper, we marry the aspirations of the semantic cube to the powerful proof method of <i>step-indexed Kripke logical relations</i>. Building on recent work of Ahmed, Dreyer, and Rossberg, we define the first fully abstract logical relation for an ML-like language with recursive types, abstract types, general references and call/cc. We then show how, under orthogonal restrictions to the expressive power our language - namely, the restriction to first-order state and/or the removal of call/cc - we can enhance the proving power of our possible-worlds model in correspondingly orthogonal ways, and we demonstrate this proving power on a range of interesting examples. Central to our story is the use of <i>state transition systems</i> to model the way in which properties of local state evolve over time.</p>", "authors": [{"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P2338173", "email_address": "", "orcid_id": ""}, {"name": "Georg Neis", "author_profile_id": "81442619526", "affiliation": "MPI-SWS, Saarbruecken, Germany", "person_id": "P2338174", "email_address": "", "orcid_id": ""}, {"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "IT University of Copenhagen, Copenhagen, Denmark", "person_id": "P2338175", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863566", "year": "2010", "article_id": "1863566", "conference": "ICFP", "title": "The impact of higher-order state and control effects on local relational reasoning", "url": "http://dl.acm.org/citation.cfm?id=1863566"}