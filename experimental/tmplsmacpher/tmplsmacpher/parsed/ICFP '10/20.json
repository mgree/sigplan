{"article_publication_date": "09-27-2010", "fulltext": "\n A Fresh Look at Programming with Names and Binders Nicolas Pouillard Fran\u00e7ois Pottier INRIA {nicolas.pouillard,francois.pottier}&#38;#169;inria.fr \nAbstract A wide range of computer programs, including compilers and the\u00adorem provers, manipulate data \nstructures that involve names and binding. However, the design of programming idioms which allow performing \nthese manipulations in a safe and natural style has, to a large extent, remained elusive. In this paper, \nwe present a novel approach to the problem. Our proposal can be viewed either as a programming language \ndesign or as a library: in fact, it is currently implemented within Agda. It provides a safe and expressive \nmeans of programming with names and binders. It is abstract enough to support multiple concrete implementations: \nwe present one in nominal style and one in de Bruijn style. We use logical relations to prove that well-typed \nprograms do not mix names with different scope . We exhibit an adequate encoding of Pitts-style nominal \nterms into our system. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Data types and struc\u00adtures; Polymorphism General Terms Design, Languages, Theory Keywords \nnames, binders, meta-programming, name abstraction, higher-order abstract syntax 1. Introduction A wide \nrange of computer programs, including compilers and theo\u00adrem provers, manipulate and transform data structures \nthat involve names and bindings. Signi.cant effort has been invested in the de\u00adsign of programming idioms \nor languages that support these tasks in a safe and natural style. Nevertheless, a de.nitive solution \nis yet to be found. One challenge is to abstract away the details of any one particular implementation \ntechnique, such as atoms and permu\u00adtations, or de Bruijn indices and shifting. A greater still challenge \nis to design a lightweight yet expressive static discipline to ensure that names are handled in a sound \nway. One must .rst ask: what does it mean to handle names in a sound way? The question is trickier than \nit seems. There are several informal slogans that attempt to describe what this means: 1. name abstractions \ncannot be violated ; or: the representa\u00adtions of two e-equivalent terms cannot be distinguished ; 2. \nnames do not escape their scope ;  Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 10, September 27 29, 2010, Baltimore, Maryland, USA. Copyright \nc &#38;#169; 2010 ACM 978-1-60558-794-3/10/09. . . $10.00 3. names with different scopes cannot be mixed \n. These slogans are not equivalent; we have listed them in increasing order of strength. A traditional \nrepresentation of names as strings or de Bruijn indices satis.es none of these slogans. A system such \nas FreshML [22] satis.es only the .rst slogan. A strongly-typed representation of names as well-scoped \nde Bruijn indices satis.es the .rst two slogans, but, we argue (\u00a74.5), not the third one. Finally, several \nsystems in the literature [10, 12, 16 18, 21], as well as the one presented in this paper, satisfy all \nthree. Our approach This paper describes a new way of addressing these challenges. We present an interface \ncomposed of a number of types and operations for declaring and manipulating data structures that involve \nnames and binding. This interface can be viewed either as a library or as a programming language design. \nIn support of the library point of view, we provide an imple\u00admentation as a library within Agda. It could \nalso be implemented within another variant of type theory, such as Coq. Our implemen\u00adtation exploits \ndependent types to express internal invariants and to guarantee that certain operations cannot fail. \nIn support of the language point of view, our proposal could also be viewed as an extension of a standard \ncalculus, such as System FW, with new primitive types and operations. The types of our primitive operations \ndo not involve dependency. As far as the programmer is concerned, our types and operations remain abstract. \nIn particular, the nature of names is not revealed. As a result, multiple implementations of our interface \nare possible. We currently have two: one is based on atoms, in the style of FreshML, while the other \nis based on de Bruijn indices. In summary, we propose a novel approach to programming with names and \nbinders. The semantics of the system is elementary: it rests upon a number of explicit, low-level primitive \noperations. No renaming, shifting, or substitution are built into the semantics. The programmer is offered \nan abstract view of names, independent of the chosen implementation scheme. One original feature of our \nproposal is that name abstraction is not primitive: it is built out of more elementary notions. This \nhelps understand the essence of name abstraction, and increases the system s expressiveness by allowing \nprogrammers to build custom forms of name abstractions. Overview of the paper In order to control the \nuse of names, we introduce an abstract notion of world. The type system associates a world with each \nname, and allows two names to be compared for equality only if they inhabit a common world. Names, worlds, \nas well as a number of other types and operations, are introduced in \u00a73. At the same time, the system \nis explained via examples of increasing complexity. In \u00a74, we describe our two implementation schemes. \nIn the nominal scheme, worlds are sets of atoms. In the de Bruijn-index\u00adbased scheme, worlds are integer \nbounds. We then justify the soundness of our interface. We do this twice: once for each im\u00adplementation \nscheme. In each case, we make novel use of logical relations in order to give richer meaning to worlds: \nwe explain how worlds can be viewed as bijections between names. In this setting, the fundamental theorem \nof logical relations corresponds to the three desired slogans. The slogans remain informal, though, because \nour system does not have a notion of e-equivalence , or scope , to begin with. We do prove that nominal \nterms in the style of Pitts are adequately encoded in our system; this yields a formal version of slogan \n1 with respect to Pitts notion of e-equivalence.  In our interface, a number of key primitive operations \nare pro\u00advided only at names, and must be explicitly lifted (by the program\u00admer) to user-de.ned data types. \nIn \u00a75, we show how to do this, and suggest that some of this boilerplate code can be automatically produced \nvia generic programming. We conclude with an advanced example 6 and with discussions of related work \n(\u00a77) and future work (\u00a78). 2. A brief introduction to Agda notation Throughout the paper, our de.nitions \nare presented in the syn\u00adtax of Agda. In Agda, Set is the type of small types like Bool, Maybe (List \nBool), or N. Seth is the type of Set. The function space is written A -B, while the dependent function \nspace is written V (x : A) -B. An implicit parameter, introduced via V{x : A}-B, can be omitted at a \ncall site if its value can be inferred from the context. There are shortcuts for introducing multiple \narguments at once or for omitting a type annotation, as in V{A}{ij : A} x -.... Existential quanti.cation \nis available via the type constructor :, which accepts a type function as its argument, as in :Ae -(e \n-N) x (N -e). A data constructor name can be used in multiple data types. Agda makes use of type annotations \nto resolve ambiguities. As in Haskell, a de.nition consists of a type signature and a sequence of de.ning \nequations, which may involve pattern match\u00ading. The with construct extends a pattern-matching-based de.ni\u00adtion \nwith new columns. An ellipsis ... is used to elide a redundant equation pre.x. Agda is strict about whitespace: \nx+y is an identi.er, whereas x+y is an application. This allows naming a variable after its type (deprived \nof any whitespace). We use mix.x declarations, such as f . We use some de.nitions from Agda s standard \nlibrary: operations over functors (_{$}_), monads (return,_ _), and applicative functors (pure, \u00ae ). \nFor the sake of conciseness, the code fragments presented in the paper are sometimes not perfectly self-contained. \nHowever, a complete Agda development is available online [19]. 3. Working with names and binders We now \npresent the signature (that is, the abstract types and oper\u00adations) that our system offers to programmers. \nFor the sake of pre\u00adsentation, we intersperse fragments of this signature (declarations) with examples \nof their use (code fragments). Worlds We .rst introduce worlds, which names inhabit. There is an empty \nworld, which no names inhabit. There are no other concrete worlds: most of the time, the programmer uses \nworld variables e, f, \", o. World : Set ! : World We often use relations Rel, and in particular relations \nover worlds Rel World. Rel : Set -Seth Rel A = V (af : A) -Set Agda does not have a clear phase distinction, \nthat is, a clear distinc\u00adtion between values and types. Nevertheless, one can also view our system as \nan extension of a calculus that does have this distinction, such as System F W under a type-erasure semantics. \nIn that view, worlds, like types, can be erased at runtime. Names The type of names, Name, is indexed \nwith a world. The idea is that two names can safely be compared only if they inhabit a common world. \nThis is apparent in the type of the name equality test. Name : V (a : World) -Set : _=Name_ : V{a}-Name \na -Name a -Bool To witness the fact that no name inhabits the empty world, we introduce a function which \nproduces a contradiction when applied to a name in the empty world. Its codomain is the empty type .. \nPut differently, this function allows marking some cases as impossible, and instructs the system to statically \ncheck that they are indeed so. ,name! : Name ! -J Weak links Let us go on to our next ingredient: a type \nfor weak links between worlds. L : Rel World If e and f are worlds, then e. f is a type. Roughly speaking, \na name x has type e. f under two conditions: .rst, x inhabits the world f; second, the world that existed \nbefore x was introduced is e. Put another way, e. f is a more precise type for names. It keeps track \nof the worlds just before and just after a name is bound. We usually refer to e as the outer world and \nto f as the inner world. Weak links allow keeping track of connections between worlds: intuitively speaking, \nif x has type e. f, then the worlds e and f assign the same meaning to every name other than x. The name \nx itself may have no meaning at all in e, or it may have some meaning in e and a different meaning in \nf. Our weak links do not require x to be fresh for e: they allow a new binding to shadow an earlier binding. \nLater on, we introduce strong links, which do imply a freshness condition. Since a weak link is just \na more precise type for a name, we offer a way of converting the former into the latter. nameOf. : V{af \n}-aL f -Name f Example: representing A-terms We now have enough elements to declare algebraic data types \nthat involve names and binders. Let us begin with an explicitly typed object-language: the untyped A\u00adcalculus \nwith local (let) de.nitions. data Tm (a : World): Set where V : V (x : Name a) -Tm a : V (tu : Tm a) \n-Tm a  X : V{f } (x : aL f)(t : Tm f) -Tm a Let : V{f } (x : aL f)(t : Tm a)(u : Tm f) -Tm a  The type \nconstructor Tm is indexed with a world. The type Tm e can be thought of as a type of terms whose free \nnames inhabit the world e. Accordingly, the constructor V carries a name that inhabits e, and the constructor \nfor applications carries two sub\u00adterms that inhabit e. The constructor X shows how we build simple name \nabstractions. It carries a weak link (the name to be bound) between the outer world e and some inner \nworld f. The body of the abstraction inhabits this inner world: it has type Tm f. The abstraction itself \ninhabits the outer world: it has type Tm e. Since f does not occur in the latter type, it is really existentially \nquanti.ed: viewed from the outside, an abstraction contains an unknown inner world. In Let, the sub-term \nt inhabits the outer world e: thus, it is not in the scope of the bound name x. On the other hand, the \nsub\u00adterm u inhabits the inner world f: it is in the scope of x. It is easy to see how one would de.ne \nLetRec.  Using worlds, names, and weak links, it is possible to de.ne a wide range of data structures \nwith binders. The above encoding of A-terms is but one instance of a general encoding of Pitts nominal \nterms and nominal signatures. We describe this general encoding and prove it adequate in \u00a74.3. In fact, \nour system is more expressive than Pitts : this is illustrated by several examples in this section. Here \nis a trivial example of a function that traverses a term and measures its size. It is remarkable for \nits simplicity: name abstractions are traversed without fuss. This unaltered induction also tells a bit \nabout the expressiveness of such functions. It is also ef.cient: no renaming, substitution, or shifting \nis involved. Polymorphic recursion is exploited: the call to size t in the X case is at some inner world. \nsize : V{a}-Tm a -N size (V )= 1 size (tu)= 1 +sizet+sizeu size ( t)= 1 + size t size (Let tu)= 1 +sizet+sizeu \nExporting names When two worlds are connected via a weak link, it is desirable to be able to move names \nfrom one world into the other along the link. We introduce the function export for this purpose. export \n: V{af }-aLf -Name f -Maybe (Name a) The function export expects two names x and y, whose types are e.f \nand Name f. It compares (nameOf x) and y for equality. If they are equal, export fails: the name y has \nmeaning in f, but may not have meaning, or may have a different meaning, in e. If they differ, export \nsucceeds and returns y at type Name e: indeed, since y is not x, it has the same meaning in both worlds. \nexport is a partial function: it can fail. It is an injective function: if export x y and export x z \nare equal, then y and z are  equal. Like _ : Name _, export is a name equality test. However, it performs \ntype re.nement: in the event that the names differ, the input name is returned with a more precise type. \nThe reader may wonder whether it is possible to move a name in the other direction, from the outer world \ne into the inner world f. The answer is negative: this would be unsound. (For a justi.ca\u00adtion, see the \ndiscussion of dubious in \u00a74.2.) Later on, we introduce a means of moving in this direction, namely world \ninclusion wit\u00adnesses. Example: working with free and bound names We now have enough tools to present \na more interesting example, namely a function that constructs a list of the free variables of a term. \nAt variables and applications, the code is straightforward. At a name abstraction, one easily collects \nthe free variables of the body via a recursive call. However, this yields a list of names that inhabit \nthe inner world of the abstraction a value of type List (Name f). This list cannot be returned, and this \nis fortunate, since doing so would let the bound variable leak out of its scope! We de.ne an auxiliary \nfunction, rm, which removes all occurrences of a name in a list of names and at the same time performs \ntype re.nement in the style of export . fv : V{a}-Tm a -List (Name a) fv (Vx) =[ x] fv (fct arg)= fv \nfct * fv arg fv ( xt)= rm x (fv t) fv (Let x t u)= fv t * rm x (fv u) rm : V{af }-aLf -List (Name f) \n-List (Name a) rm [] =[] rm x (y :: ys) with export x y I just y = y ::rmxys I nothing = rm x ys The \nfunction rm applies export x to every name y in the list and builds a list of only those that successfully \ncross the link x. It exhibits a typical way of using export to perform a name comparison together with \na type re.nement. This idiom is recurrent in the programs that we have written. The function fv enjoys \na free theorem, that is, a theorem that follows directly from its type: every name in the output list \nmust occur free in the input term. This claim is backed up by the typed models in \u00a74.2 and \u00a74.4. Example: \nworking with environments Here is another example, where we introduce the use of an environment. occurs \n: V{a}-Name a -Tm a -Bool occurs xo = occ (, y -xo : y) =Name where OccEnv : World -Set OccEnv a = Name \na -Bool extend : V{af }-aLf -OccEnv a -OccEnv f extend x r y = maybe r false (export x y) occ : V{a}-OccEnv \na -Tm a -Bool occ r(Vy) =r y occ r(tu)= occ r t V occ r u occ r( xt)= occ (extend x r) t occ r(Let x \nt u)= occ r t V occ (extend x r) u The function occurs tests whether some name x occurs free in a term. \nAn environment r is carried down, augmented when a binder is crossed, and looked up at variables. Here, \nthis environment is represented as a function of type Name e -Bool. Although this is a simple and elegant \nrepresentation, others exist. For instance, we could represent the environment as a linked list of weak \nlinks: the code for this variant is online [19]; see also below. We claim that this code is standard \nand uncluttered. There is no hidden cost: no renaming is involved. Admittedly, linked lists are not the \nmost ef.cient representation of environments. It would be nice to be able to implement environments using, \nsay, balanced binary search trees, while preserving well-typedness. We leave this issue to future study. \nThe type system forces us to use names in a sound way. For in\u00adstance, in the de.nition of occ, forgetting \nto extend the environment when crossing a binder would cause a type error. In the de.nition of extend, \nattempting to check whether y occurs in r without .rst comparing y and x would cause a type error. In \nour nominal im\u00adplementation scheme (\u00a74.1), it is permitted for newer bindings to shadow earlier ones; \nour type discipline guarantees that the code works also in that case. As suggested previously, one may \nwish to represent environ\u00adments as an explicit data structure (a linked list of weak links) rather than \nas an opaque object (a lookup function). While there exists an appropriate abstraction in Agda s standard \nlibrary called Star, we de.ne a custom data type. An environment is a chain of weak links. At runtime, \nit is just a list of names. data _*L_ (T : Rel World): Rel World where \u00a3 : V{a}-a *L a < : V{af,} (x \n: fL,)(r : a *L f) -a *L , The export operation is extended to chains of weak links: export> : V{af \n}-a *L f -Name f -Maybe (Name a) export> \u00a3 y = just y export> (x < r) y = export x y : = export> r where \nopen MaybeMonad The type e *. f is the type of an environment, or environment fragment, whose outer world \nis e and whose inner world is f. The expression export r y looks up the name y in the environment r. \nThe name y must make sense in the scope of r, that is, y must inhabit the world f. If y is found among \nthe bindings, then the information associated with y can be returned. (Here, there is no such information, \nso nothing is returned.) If y is not found among the bindings, then y is returned, with a more precise \ntype: indeed, since y is not among the names introduced by r, it makes sense outside r, that is, in the \nworld e.  We illustrate the use of chains of weak links with an alternative de.nition of the function \nfv. This variant avoids the need to take the bound atoms off the list by not inserting them in the .rst \nplace. At variables, we use exportto check whether the name > is free or bound. At every other node, \nwe simply carry out a recursive traversal. Whenever a name abstraction is entered, the current environment \nr is extended with the bound name x. fv' : V{fa}-a *L f -Tm f -List (Name a) fv' r(Vx)= List fromMaybe \n(exportr x) > fv' r(tu)= fv' r t * fv' r u fv' r( xt)= fv' (x < r) t fv' r(Let x t u)= fv' r t * fv' \n(x < r) u Importing names We now introduce world inclusion witnesses C , whose purpose is to allow moving \nnames from a smaller world into a larger world. In other words, we equip worlds with a system of explicit \nsubtyping. World inclusion is re.exive and transitive; the type constructor Name is covariant; the empty \nworld is the least world. C : Rel World C-ref : V{a}-a C a C-trans : V{af, }-a C f -f C , -a C , importc \n: V{af }-a C f -Name a -Name f !-bottom-C : V{a}-! C a Like links, world inclusion witnesses come with \nan importc func\u00adtion, which moves a name from one world into the other. One major difference with weak \nlinks is that this function is total. While importing names is nice and simple, we . e\" are interested, \nin general, in importing complex terms or data structures from one world into an- C C other. This requires, \nin particular, being able to im\u00adfo port abstractions. Upon close examination, we .nd . that we need this \ncommutative diagram to hold. We make this property available to the programmer by introduc\u00ading the following \nprimitive operation: L-commute-C : V{af, }-aL, -a C f -j ,5 -, C 5 x fL5 At this point, it is probably \nnot clear why this commutative diagram is sound, or why it is useful. Its soundness as well as that \nof every primitive operation presented here is justi.ed in \u00a74. Its usefulness is illustrated in \u00a75.2 \nand \u00a75.3. Strong links Next, we introduce strong links. Again, the type e.f is a precise type for a name: \nit is more precise than e.f - and (therefore) more precise than Name f. If x has type e.f, -then x is \nguaranteed to be fresh for the world e. That is, a strong link represents the introduction of a binding \nfor a fresh name, and (in contrast with a weak link) cannot possibly shadow an earlier binding. As a \nresult, if x has type e.f, then e C f must hold: - out of a strong link, one can produce a world inclusion \nwitness. _L_ : Rel World - weaken : V{af }-aLf --aLf dropName : V{af }-aLf --a C f Technically, a strong \nlink comes with an even stricter guarantee: the name x must not just be fresh for e; it must dominate \nevery atom in e, in a sense to be made precise later on (\u00a74.1). One might wonder why we need both weak \nlinks and strong links. Why not use strong links everywhere, since they offer a stronger guarantee? The \nanswer is: precisely because they are stronger than weak links, strong links are also more dif.cult to \ncon\u00adstruct. In particular, strong links do not enjoy an analogue of the diagram .-commute-C . Such a \ndiagram would be unsound, because a name that is fresh for a smaller world is not necessarily fresh for \na larger world. Yet, a commutative diagram in the style of .-commute-C plays a key role in the de.nition \nof gener\u00adalized import operations (\u00a75.3). This explains why we often use weak links in our term representations, \nsuch as Tm. Generating names The alert reader may have noticed that, up to this point, we have not yet \nintroduced a way of producing names or links! To address this issue, we need a mechanism for producing \nfresh names. We .nd that it is suf.cient to be able to produce strong links, since a strong link can \ndegenerate into a weak link and into a name. We view a fresh name with respect to the world e as a strong \nlink into some unspeci.ed next world f, and de.ne the following abbreviation: Fresh : World -Set Fresh \na = j ,f -a - Lf We introduce two primitive operations for creating fresh names. fresh\u00a2 is an initial \nstrong link a name that is fresh for the empty world. next, accepts two names: one is a weak link between \ntwo worlds e and f; the other is fresh for e. next, produces a name that is fresh for f. fresh! : Fresh \n! next, : V{af, }-aLf -a -, -Fresh f L Together, these two low-level operations allow constructing an \nin\u00ad.nite stream of fresh names, that is, a name generator. Packaging up We are done introducing the abstract \ntypes and operations that we offer to the users of our library (or programming language). In summary, \nwe have four primitive types (names, weak links, strong links, and world inclusion witnesses), and a \nnumber of operations over these types. In the Agda implementation, we .nd it convenient to package each \ntype together with the operations that it offers. An idiomatic way of doing this involves de.ning parameterized \nrecords, like this: module NamePack {f } (x : Name f) where nameOf : Name f nameOf = x module WeakPack \n{af } (x : aLf) where open NamePack (nameOf x) publii weakOf : aLf weakOf = x exportWith : Name f -Maybe \n(Name a) exportWith = export x module CPack {af } (x : a C f) where COf : a C f COf = x importWith : \nName a -Name f importWith = importc x module StrongPack {af } (x : aLf) where - open WeakPack (weaken \nx) publii open CPack (dropName x) publii strongOf : aLf - strongOf = x nextOf : Fresh f nextOf = next, \nweakOf strongOf module FreshPack {a} (x : Fresh a) where open StrongPack (proj2 x) publii The open/public \ndeclarations cause one record to be included within another. This permits a limited form of inheritance \nand overloading. For instance, within the scope of appropriate open declarations, the method nameOf is \napplicable to names of type Name e, e.f, e.f, and Fresh e.  - Constructing terms Once this boilerplate \nis set up, we at last show how to construct a term. For example, let us build a repre\u00adsentation of the \nobject-level term A xy -xy. app : Tm ! app =(weakOf x)( (weakOf y) (V (importWith y (nameOf x)) V (nameOf \ny))) where open FreshPack x = fresh! y = nextOf x We generate two fresh names x and y. Each of these \nnames is viewed as a weak link (via weakOf) when playing the role of a binding occurrence and is viewed \nas a name (via nameOf) when playing the role of a regular occurrence. Furthermore, in order to satisfy \nthe type-checker, the regular occurrence of x must be imported into the scope of y. This is admittedly \nfairly dif.cult to read. If our system was im\u00adplemented as a stand-alone programming language, as opposed \nto a library within Agda, it seems reasonable to think that one would be able to make the invocations \nof weakOf, nameOf, and importWith implicit. The omitted information would be reconstructed by a local \ntype inference algorithm. Towards elaborate uses of worlds The type Tm is just one basic example of an \nalgebraic data type that involves names and binders. As a more challenging example, consider a type C \nof one-hole contexts associated with Tm. The type C is indexed with two worlds, which respectively play \nthe roles of an outer world and an inner world. The idea is, plugging a term of type Tm f into the hole \nof a context of type C ef produces a term of type Tm e. The de.nition of the type C is as follows: module \nContext where data C : World -World -Set where Hole : C aa : V{f } C af -Tm a -C af h : V{f } Tm a -C \naf -C af : V{f, } aLf -C f, -C a, Leth : V{f, } aLf -C a, -Tm f -C a, Let2 : V{f, } aLf -Tm a -C f, -C \na, 2 Contexts bind names: the hole can appear under one or several binders. This is why, in general, \na context has distinct outer and in\u00adner worlds. A context contains a chain of weak links that connects \nthe outer and inner worlds: these links are carried by the construc\u00adtors X and Let2 . Then a context \nand a term can be paired to produced a term in a context: CTm : World -Set CTm a = j ,f -C af x Tm f \nIt is straightforward to de.ne a function plug from CTm e to Tm e, which accepts a pair of a context \nand a term and plugs the latter into the former. Conversely, one can de.ne a family of focusing functions \n(V{e}-Tm e -CTm e), which split a term into a pair of a context and a term. There are several such functions, \naccording to where one wishes to focus. The role played by C ef in this existential type is iden\u00adtical \nto that played by e.f in the single-name abstraction : Af -e.f x Tm f. In other words, the type C ef \ncan be viewed as a new, user-de.ned type of links between worlds, and can be used to build elaborate \nforms of name abstractions. As another instance of this idea, if one wished to extend our ob\u00adject language \nwith ML-style patterns, one would index the type Pat of patterns with an outer world and an inner world, \nand one would use elaborate abstractions of the form : Af -Pat ef x Tm f. Finally, the fact that a type \ncan be indexed with several world parameters can be exploited in other ways. For instance, if one wished \nto extend our object language with polymorphism, one would index the type Tm with two worlds: one for \n(names of) term variables, one for (names of) type variables. In other words, worlds can also serve as \ndisjoint name spaces. 4. Two sound implementations We have axiomatized a number of notions, including \nworlds, names, and links. Now comes the time to give de.nitions of these types and terms. We have two \nversions of these de.nitions, that is, two Agda implementations of our library. One is in nominal style: \nit is based on atoms. The other is based on well-scoped de Bruijn indices. Both implementations can be \nfound online [19]. Either of these implementations is well-typed in Agda: this guarantees that well-typed \nclient programs of our library cannot go wrong. However, type soundness is not the whole story: we also \nwish to prove that well-typed client programs must respect name abstraction. For each of the two models, \nwe establish this property via a logical relations argument. 4.1 The nominal model: implementation We \nposit a countably in.nite set of atoms A, equipped with a notion of equality. In our Agda implementation, \natoms are natural numbers and we make use of ordering of natural numbers for fresh name generation; this \nis apparent in the semantics of strong links below. In the nominal model, a world is a set of atoms. \nIn the Agda im\u00adplementation, such as set is represented as a list without duplicates. A name of type \nName e is an atom a together with a proof that a is a member of the world e. A weak link of type e.f \nis an atom a together with a proof of the equation f = e U{a}. That is, the world f is the union of the \nworld e and of the atom a. It is important to note that a may or may not be a member of e: a weak link \npermits shadowing. Like a weak link, a strong link of type e.f includes -an atom a, as well as a proof \nof the equation f = e U{a}. Furthermore, it contains a proof of the fact that the natural number a is \na strict upper bound for the set e. This condition re.ects the fact that the name a is fresh for the \nworld e. It implies, and is stronger than, a I e. Technically, this extra strength is exploited in the \nde.nition of next,, where we need to guarantee that, if a is fresh for e, then the successors of a form \nan in.nite stream of names that are fresh for e. A world inclusion witness of type e C f has no computational \ncontent: it is just a proof of the set-theoretic inclusion e C f. In the nominal model, the operations \nimport, nameOf , c weaken, dropName and .-commute-C have no computa\u00adtional content. _ : Name _ is an \natom equality test. export also involves an atom equality test: it fails if its arguments are equal and \nreturns its second argument otherwise. The function call next, ab produces the maximum of the two integers \n1+a and b, so that, if b is fresh for some world e, then next, ab is fresh for the world e U{a}.  4.2 \nThe nominal model: logical relations Although the implementation described above guarantees type soundness \nin a traditional sense, this is not suf.cient to guarantee that names are handled in a sound way. Indeed, \nit would be possible to extend this implementation of the library with operations that are well-typed \nbut intuitively do not make sense. For instance, the above interpretation of worlds validates the fact \nthat, out of a weak link of type e.f, one can extract a proof of the inclusion e C f. Yet, extending \nthe system with an operation dubious : V{ef }-e.f -e C f, implemented as the identity, would be intuitively \nunsound. To see this, consider a free atom x and an atom abstraction (X yt), whose respective types are \nName e and Tm e. The bound atom y has type e.f, where f is the inner world of the abstraction. In the \npresence of dubious, it would become possible to use importto cast the atom  c x to the type Name f, \nwith undesirable consequences. First, one would then be able to compare the atoms x and y for equality, \nso that the identity of a bound name would become observable: name abstractions would be violated. Second, \none would be able to build a new name abstraction whose bound atom is y and whose body contains a free \noccurrence of x: this would lead to name capture in the event that x and y happen to be the same atom. \nIn the following, we remedy this problem by prodiving a richer interpretation of worlds in a nominal \nsetting. We interpret a world no longer as a set of atoms, but as a partial bijection between atoms. \nOn top of this, we carry out a standard logical relations construction. These logical relations validate \nall of the operations of \u00a73, as implemented in \u00a74.1, while rejecting dubious. The de.nitions and proofs \nin this section are informal, in the sense that they have not been machine-checked. De.nition 4.1 A relation \nbetween atoms is a subset of A x A. We write ah (e) a2 when the pair (ah ,a2 ) is in the relation e.A \npartial bijection between atoms is a relation such that ah (e) a2 and bh (e) b2 bh a2 b2 ). imply (ah \n.0 The following notions are used in the interpretation of weak links and strong links, respectively. \na De.nition 4.2 The shadowing extension of a partial bijection e with an atom pair (bh ,b2 ), written \n(bh ,b2 ) E e, is the partial bijection such that ah ((bh ,b2 ) E e) a2 holds if and only if either h \n= bh 1 a2 = b2 or ah = bh 1 a2 = b2 1 ah (e) a2 . 0 The domain dom(e) of a relation e is de.ned as the \nset of atoms {ah I:a2 ,ah (e) a2 }. Its codomain codom(e) is de.ned analo\u00adgously. If A is a set of atoms, \nwe write bA to indicate that the atom b is a strict upper bound for the set A. De.nition 4.3 The fresh \nextension of a partial bijection e with an atom pair (bh ,b2 ), written (bh ,b2 )e, is de.ned only if \nbh dom(e) and b2 codom(e). When it is de.ned, (bh ,b2 )e is the partial bijection {(bh ,b2 )}U e. 0 When \nthe fresh extension exists, it coincides with the shadowing extension. We assume that the host language \nof our system supports the construction of logical relations in a standard manner. For instance, the \nhost language may be System F or System F W, where logical relations are well-understood [13]. At every \ntype, two relations are de.ned: a relation between values and a relation between terms. We write v (T) \nW when the values v and W are related at type T; we write t (T) U when the terms t and U are related \nat type T. We assume that the host language provides the de.nition of these re\u00adlations at every standard \ntype-theoretic connective (functions; uni\u00adversal and existential quanti.ers; products, sums, unit). We \nalso assume that equivalence of two terms at type T is de.ned, indepen\u00addently of T, in terms of the operational \nbehavior of these terms and in terms of equivalence of two values at type T. We now extend this construction \nby de.ning what it means for two values to be equivalent at our new primitive types: names, weak links, \nstrong links, and world inclusion witnesses. De.nition 4.4 At base types, the logical relation is de.ned \nby: ah (Name f) a2 (f) a2 .ah ah (e.f) a2 f = (ah ,a2 ) E e . ah (e..f = (ah ,a2 )e -f) a2 () (e C f) \n() .e C f 0 Two atoms ah and a2 are related at type Name f if and only if the pair (ah ,a2 ) is in the \npartial bijection f. They are related at type e.f if and only if f is the shadowing extension of e with \nthe pair (ah ,a2 ). They are related at type e. -f if and only if f is the fresh extension of e with \nthe pair (ah ,a2 ). Last, two unit values are related at type e C f if and only if the relation e is \na subset of the relation f. Note that ah (e.implies ah (e.f) a2 , which itself -f) a2 implies ah (Name \nf) a2 . Thus, it is sound to turn a strong link into a weak one, and a weak link into a name. That is, \nit is sound to implement the operations nameOf and weaken as the identity. In the case of these two operations, \nthe proof of Theorem 4.5 (below) boils down to this simple remark. Similarly, in view of this interpretation, \nthe operation dropName, which produces an inclusion witness out of a strong link, is clearly sound. We \ncan now point out why a binary interpretation (worlds as partial bijections between atoms) is .ner-grained \nthan a unary interpretation (worlds as sets of atoms). Indeed, in order to check that the operation dubious, \nimplemented as the identity, is sound, we would need to check that ah (e.f) a2 implies () (e C f) (). \nThat is, we would need to check that f = (ah ,a2 ) E e implies e C f. However, due to the possibility \nof shadowing, this is not in general the case: this implication is false when ah I dom(e) and a2 I codom(f) \nand when ah I dom(e) and a2 I codom(f). It is worth noting that f = (ah ,a2 ) E e does imply dom(e) C \ndom(f) and codom(e) C codom(f). This explains why dubious seemed safe in a unary interpretation. There \nremains to establish the fundamental theorem of logical relations. The proof of this theorem is provided \nby the host lan\u00adguage; we need only extend it with one new case for each of our primitive operations. \nTheorem 4.5 Every primitive operation p of type T is related to itself at type T. 0 Proof. For the sake \nof brevity, we provide only one representative case, namely the case of export . The goal is to show \nthat export is related to itself at type V{ef }-e.f -Name f -Maybe (Name e). By de.nition of the logical \nrelation at the standard connectives (V, -, Maybe) and at our primitive types (De.nition 4.4), the goal \nboils down to: if f = (ah ,a2 ) E e and bh (f) b2 hold, then the terms (export ah bh ) and (export a2 \nb2 ) are related at type Maybe (Name e). Thus, let us assume that e,f, ah ,a2 ,bh ,b2 are as above. Now, \na key remark is this: the hypotheses f = (ah ,a2 ) E e and bh (f) b2 , together with the fact that f \nis bijective, imply ah bh . a 2 b2 . This remark allows us to distinguish only two cases: o Case ah \nbh 1 a2 b2 . Then, the terms export ah bh and export a2 b2 both reduce to nothing. Because the value \nnothing is related to itself at type Maybe (Name e), the goal holds. o Case ah bh 1 a2 b2 . Then, the \nterms export ah bh and export a2 b2 respectively reduce to just bh and just b2 . We must prove that these \ntwo values are related at type Maybe (Name e). This boils down to proving that bh and b2 are related \nby e. It is easy to check that this goal does follow from the hypotheses bh (f) b2 , f = (ah ,a2 ) E \ne, ah bh and a2 b2 . 0  The intuition behind the above proof case is: the success or failure of an export \noperation does not depend on earlier choices of bound names. More precisely, if we run a single program \ntwice, with different but related inputs, it is impossible for an export operation to succeed in one \nrun and fail in the other. One implication of Theorem 4.5 is that choices of fresh names do not matter \n. Our Agda implementation of the operation next,, which we use to produce fresh names, is of course determinis\u00adtic. \nHowever, one could in principle equip next, with a non\u00addeterministic semantics, whereby next, ab produces \nan arbitrar\u00adily chosen integer that is greater than or equal to the maximum of 1+a and b. Under this \nsemantics, Theorem 4.5 still holds: related programs produce related results. In other words, non-determinism \nin the choice of fresh names is not observable by well-typed pro\u00adgrams. One could in fact abandon next, \nand introduce an expres\u00adsion fresh, of type V{e}-: Af -e.f, which reduces  -to an arbitrary atom that \ndominates the world e. Under this seman\u00adtics, again, Theorem 4.5 holds. In a type-erasure implementation \nof our design, where worlds do not exist at runtime, fresh could be ef.ciently implemented using global \nstate (that is, a gensym). Another implication is that name abstractions cannot be vio\u00adlated . It is \nperhaps not clear, at .rst, what this means, especially in light of the fact that our name abstractions \nare not primitive: they are built out of more elementary constructs. One way of formaliz\u00ading this statement \nis to prove that our system permits an adequate encoding of nominal terms [14]: this guarantees that \nour name ab\u00ad stractions behave as intended. We do so below (\u00a74.3). This adequacy result shows that our \nsystem is able to encode a standard notion of e-equivalence. However, one should keep in mind that our \nsystem is more expressive than Pitts nominal terms and nominal types: it offers many types of data structures \nwith names and binding that do not lie in the image of the encoding. Logical relations tell us what e-equivalence \nmeans at these types.  4.3 Adequacy of an encoding of nominal terms De.nition 4.6 The nominal types \nand nominal terms are: T :: atom I T x T I T + T I{atom}T t :: a I (t, t) I inj; t I{a}t 0 For the sake \nof simplicity, we do not deal with recursive types, but one could extend our argument to do so. Note \nthat the atom a is not considered bound in the nominal term {a}t. De.nition 4.7 The free atoms of a nominal \nterm are de.ned by: fa(a) {a} fa((th ,t2 )) fa(th ) U fa(t2 ) fa(inj; t) fa(t) fa({a}t) fa(t) \\{a}0 De.nition \n4.8 e-equivalence of two nominal terms at a nominal type is de.ned as follows: ''' t h = t2 : Tth = t2 \n: T a = a : atom ''' (th ,th ) = (t2 ,t2 ): T x T (ah c)th = (a2 c)t2 : T t h = t2 : T; c # {ah }th , \n{a2 }t2 inj; th = inj; t2 : Th + T2 {ah }th ={a2 }t2 : {atom}T We use a # t as a short-hand for a I fa(t). \nWe write (ab)t for the result of swapping all occurrences of the atoms a and b through t.0 De.nition \n4.9 The encodings of nominal types into our types, and of nominal terms into our extension of System \nF W, are as follows. [atomDu Name e [Th x T2 Du [Th Du x [T2 Du [Th + T2 Du [Th Du + [T2 Du [{atom}TDu \n:f\u00b7(e.f x [TDp ) Ial a I(th ,t2 )l (Ith l, It2 l) Iinj; tl inj; Itl I{a}tl pack(a, Itl) 0 In order to \nprove that this encoding is adequate, we wish to prove that two nominal terms are e-equivalent if and \nonly if their encodings are in the logical relation. e-equivalence of nominal terms is de.ned in terms \nof total atom permutations, while our worlds are partial atom bijections. The following technical de.ni\u00adtion \nhelps bridge the gap. De.nition 4.10 Let Ah and A2 be sets of atoms. Let 7h and 72 be permutations (that \nis, total, bijective relations over atoms). Let e be a world, that is, a partial, bijective relation \nover atoms. We say that the permutations 7h and 72 correspond to the world e, with respect to the domains \nAh and A2 , if and only if 2h (7h ; 7) n (Ah x A2 ) e n (Ah x A2 ) 0 2 The following technical lemma \nshows how our notion of correspon\u00addence crosses a name abstraction. The proof of the theorem that follows \nis then straightforward. Lemma 4.11 Let 7h and 72 correspond to e with respect to Ah \\ {ah } and A2 \\{a2 \n}. Let c be fresh for 7h (Ah \\{ah }) and 72 (A2 \\ {a2 }). Let f stand for the world (ah ,a2 ) E e. Then, \n(7h ah c) o 7h and (72 a2 c) o 72 correspond to f with respect to Ah and A2 . 0 Theorem 4.12 If 7h and \n72 correspond to e with respect to fa(th ) and fa(t2 ), then the following two propositions are equivalent: \n7h th = 72 t2 : T (e-equivalence of nominal terms) Ith l ([T Du) It2 l (logical relation between terms) \n0 The proofs appears in the extended version of this paper [20]. As a corollary, if a nominal term t \nhas nominal type T, and if e is a set of atoms that includes fa(t), then Itl has type [T Du in our unary \ninterpretation (\u00a74.1). Furthermore, we have: Corollary 4.13 Let th and t2 be nominal terms of nominal \ntype T such that fa(th ) fa(t2 ) 0. Then, th and t2 are e-equivalent if and only if their encodings are \nrelated with respect to the empty world. That is, th = t2 : T holds if and only if Ith l ([TD\u00f8) It2 l \nholds. 0 Corollary 4.14 Let th and t2 be nominal terms of nominal type T such that fa(th ) fa(t2 ) 0. \nIf th = t2 : T holds, then Ith l and It2 l are observationally equivalent at type [TD\u00f8. 0 Corollary 4.14 \nshows that our programming language respects object-level e-equivalence. In other words, our name abstractions \nbehave as intended: the identity of the bound name cannot be observed. The reverse implication if th \nand t2 are not e-equivalent, then their encodings can be distinguished by some well-typed observer can \nbe established by implementing an e-equivalence test within the programming language (see \u00a75.1) and by \nproving that it is correct. We have not yet carried out this proof.  4.4 The de Bruijn model: implementation \nIn the de Bruijn model, a world is just a natural number n, while a name is just a natural number in \nthe interval [0, n). That is, World is N, and Name is Fin, where Fin n is the type of the natural numbers \nthat are less than n. In this model, weak and strong links are the same. Indeed, contrary to the nominal \nmodel, there is no shadowing: it is impossible for a new binding to hide a previous one. A link of type \ne.f or e.f has no computational -content: it is just a proof of the equation f = e +1. On the other hand, \na world inclusion witness of type e C f does have computational content: it is a natural number k such \nthat the equation f = e +k holds. The integer k represents the amount by which one must shift when importing \na name from e into f. Most operations have straightforward semantics: _ : Name_ is an integer equality \ntest (in fact, it is an equality test at type Fin n); export is the predecessor function, which fails \nif applied to the index 0; importand C-trans are integer addition; nameOf is  c the constant function \nzero; and dropName is the constant function one. The functions weaken, next, and .-commute-C have no \ncomputational content. In the de Bruijn model, importing or exporting a term has a cost. Importing requires \ncopying the term to increment its free names, while exporting requires copying and decrementing. (In \nthe nom\u00adinal model, in contrast, importing is the identity, while exporting requires an occurs check \nand is the identity when successful. The price to pay for this is that explicit renamings can be necessary.) \nFortunately, thanks to the expressiveness of the type system, the programmer is in control of the import/export \nmachinery, and has access to many of the classic tricks for dealing ef.ciently with de Bruijn indices. \nIt is possible, for instance, to delay certain imports, and to cheaply combine multiple imports into \none, since C-trans is just integer addition.  4.5 The de Bruijn model: logical relations Like the nominal \nmodel, the de Bruijn model is implemented [19] in Agda. This guarantees that our de Bruijn indices range \nover the expected intervals, and, more generally, that a well-typed client program cannot go wrong. However, \nas in the nominal model, this is not suf.cient to guarantee that our implementation is correct in an \nintuitive sense. Again, there are operations that are well-typed in this unary interpretation of the \nde Bruijn model, yet do not make sense. For instance, imagine importis implemented as A x -x, c instead \nof integer addition. This amounts to forgetting to shift, and is clearly a mistake. Yet, this version \nof importis well-typed, c because if x has type Fin m then, for every n greater than or equal to m, x \nalso has type Fin n. (This argument is slightly over-simpli.ed. In reality, a coercion is needed: see \nData.Fin.inject+ in Agda s standard library.) As another instance, imagine export is implemented as the \nfunction that fails when applied to the index 0 and returns 0 other\u00adwise. Again, this is meaningless: \nthis function is not even injective! Yet, this version of export is well-typed, because if x has type \nFin m then 0 has type Fin m. In light of these examples, we claim that, perhaps contrary to popular belief, \nwell-scopedness of de Bruijn indices is not good enough: it does not guarantee that indices are correctly \nadjusted where needed. Again, our solution lies in the construction of logical relations that validate \nour implementation, while rejecting the incorrect im\u00adplementations mentioned above. At this point, the \nreader may ask: do logical relations have any\u00adthing non-trivial to say about the de Bruijn model? In \nthe nominal model, logical relations were used to compare two program runs and to show that their outcome \nis insensitive to choices in the data representation (in particular, choices of bound names) and in the \nsemantics (choices of fresh names). In the de Bruijn model, how\u00adever, both bound names and fresh names \nare chosen in a canonical manner, so one might think that there is no interesting comparison to be made. \nIn fact, there is. De Bruijn s representation does carry an arbitrary component in its choice of free \nnames. The logical re\u00adlations argument tells us that a well-typed program is insensitive to choices of \nfree names: if one applies some permutation to the free names in its input, one observes the same permutation \nin the free names of its output. This property is stronger than well-scopedness of de Bruijn indices; \nin particular, it is not satis.ed by the incorrect implementations mentioned above. As in the nominal \ncase \u00a74.2, we view a world as a partial bijec\u00ad tion between names. This time, names are de Bruijn indices, \nthat is, natural numbers. In the de Bruijn model, there is no shadowing, so there is no analogue of shadowing \nextension (De.nition 4.2). The analogue of fresh extension (De.nition 4.3) is the following: De.nition \n4.15 The shift of a partial bijection e, written et, is a partial bijection, characterized as follows: \ndef et{(0, 0)}U{(ih + ,i2 + ) I (ih ,i2 ) I e}0 We write etk for the result of shifting the world ek \ntimes. De.nition 4.16 At base types, the logical relation is de.ned by: ih (Name f) i2 ih (f) i2 () (e.f) \n() f = et () (e.-f) () f = et k (e C f) kf = etk 0 Theorem 4.17 Every primitive operation p of type T \nis related to itself at type T. 0 5. Programmable operations Several of our primitive operations, such \nas _ : Name_, export , and import, operate upon names only. This is a good thing, insofar as c it simpli.es \nthe meta-theory of our system. However, it is desirable to lift these operations to user-de.ned data \ntypes, such as Tm, so that user-de.ned terms can be compared for equality (up to e\u00adequivalence) and exported \nor imported from one world into another. Fortunately, this can be done within the system: for a large \nclass of algebraic data types, these generalized forms of the primitive operations can be programmed \nup. We now explain how to do so in the particular case of Tm. Where details are omitted, the reader is \nreferred to the code [19]. 5.1 Deciding e-equivalence We sketch how to implement a function that tests \nwhether two terms are e-equivalent. As before (\u00a73), we use environments repre\u00ad sented as chains of weak \nlinks. We modify the function export > (\u00a73) to obtain a new function, index*., which accepts a name and \nclassi.es it as either free or bound in the environment. In the for\u00admer case, like export, index*. produces \na copy of the name at > a more precise type. In the latter case, it converts the name to a de Bruijn \nindex. index*L : V{af }-a *L f -Name f -Name a l N Thus equipped, it is straightforward to write a recursive \ncomparison function of type V{ef \" }-(e *. f) x (e *. \") -Tm f -Tm \" -Bool. At abstractions, the two \nenvironments are extended with the two bound names at hand. At variables, index*. is used to classify \neach of the two names at hand, and the results produced by index*. are compared for equality which is \npossible because both have type Name e l N. Once applied to two empty environments, the comparison func\u00adtion \nhas type V{e}-Tm e -Tm e.  5.2 A generic traversal function We are interested in several operations \nthat move a term from one world to another. These operations are implemented by traversing the term and \nbuilding a new term. Much of the traversal code can be shared between these operations, and it is bene.cial \nto do so, as this sheds a more abstract light on the traversal. In general, a traversal function has \na type of the following form: Traverse :( . : Rel World)(M : Set -Set) (F : World -Set) -Set Traverse \n. MF = V{af }-a . f -F a -M (F f) The parameter F describes the data structure that is being traversed \nand copied: for instance, F could be Tm. The parameter M is typically either the identity or the Maybe \nmonad. The former is used when implementing an operation that cannot fail; the latter is used when implementing \nan operation that can fail. More generally, M can be an arbitrary applicative functor [11]. The parameter \n . indicates what kind of connection is expected between the world e, which describes the input data \nstructure, and the world f, which the output data structure inhabits. For instance and as a .rst approximation, \nwhen implementing an export operation along a weak link, this parameter could be the type constructor \nfor weak links, reversed, fip . . In reality, the implementation of an export operation needs to maintain \nan environment that keeps track of the binders that have been entered. In general, e . f is the type \nof this environment, so it is more complex than just a single link. Still, it helps to think of it as \nthe type of an abstract link between the input and output worlds. In the implementation of a traversal \nfunction, upon entering a name abstraction, we need this abstract link, whose type is e . f, to commute \nwith the weak link that represents the binding occur\u00adrence of the abstraction, whose type is e.\". The \nfollowing two de.nitions respectively describe a general commutative diagram and the particular diagram \nthat is needed here: ComposeCommute :( .h .2 : Rel World) -Set ComposeCommute .h .2 = V{af, }-a .h f \n-f .2 , -j ,5 -a .2 5 x 5 .h , Comm :( . : Rel World) -Set Comm . = ComposeCommute (fip L ) . We now \npresent a generic traversal function for the type Tm. In addition to the above parameters, it requires \na function onName, which describes what to do at non-binding occurrences of names. The traversal is straightforward. \nThe parameter r is the abstract link between the worlds e and f. At variables, onName is used. At abstractions, \nthe commutative diagram comm is used. This produces a new abstract link r' between e' and f', where e' \nis the inner world of the abstraction that is being deconstructed, and f' is the inner world of the abstraction \nthat is being constructed. This new link is used in the recursive call. The diagram also produces a new \nweak link x', of type f.f', which is used in the construction of the new abstraction. The applicative \nfunctor machinery is used everywhere, so as to perform effect propagation behind the scenes. module TraverseTm \n{M .} (appli : Cat RawApplicative M) (comm : Comm .) (onName : Traverse . M Name) where open Cat RawApplicative \nappli traverseTm : Traverse . M Tm traverseTm r(Vx) = V ($) onName r x traverseTm r(tu) = ($) traverseTm \nr t \u00ae traverseTm r u traverseTm r( xt) with comm x r I ( , r', x') = x' ($) traverseTm r't traverseTm \nr(Let x t u) with comm x r I ( , r', x') = Let x' ($) traverseTm r t \u00ae traverseTm r'u Thanks to the generic \nprogramming facilities of a language with dependent types, it should be possible to implement this generic \ntraversal not just for Tm, but for any algebraic data type that is composed of unit, pairs, sums, names, \nand name abstractions. We have not yet done so.  5.3 Applications of the generic traversal Generalized \nimport Whereas the primitive operation importmoves a single name from one world to another, a generalized \nimport function moves a data structure from one world to an\u00adother. For instance, a generalized import \nfunction for Tm has type V{ef }-e C f -Tm e -Tm f. In other words, this function witnesses the fact that \nTm is covariant in its index. To implement such a function, we instantiate the generic traver\u00adsal function \ntraverseTm. Because importing never fails, an appro\u00adpriate applicative functor is the identity. The type \nof abstract links . is instantiated with C , the type of world inclusion wit\u00adnesses. The parameters comm \nand onName are instantiated with the primitive operations importand .-commute-C . c Generalized export \nA generalized export function for Tm has type V{ef }-e.f -Tm f -Maybe (Tm e). It fails if its .rst argument, \na name, occurs free in its second argument, a term. Otherwise, it returns a copy of its second argument \nat the outer world e. We found generalized export more dif.cult to implement than generalized import. \nThe reason is, the commutative diagram that we would like to use, which involves two weak links and has \ntype Comm (fip . ), appears to be unsound: it is not validated by our logical relations. We do have a \nwork-around, but it involves freshening, that is, replacing the bound names of the input term with fresh \nnames. Again, we instantiate the generic traversal function traverseTm. Because exporting can fail, an \nappropriate applicative functor is Maybe. The type of abstract links e . f is instantiated with Fresh \nf x (Name e -Maybe (Name f)). This means that, during the traversal, we maintain: (i) a fresh name generator \nfor the output world f; and (ii) an environment, that is, a partial mapping of names in the input world \ne to names in the output world f. Upon entering an abstraction that binds some name x, this environment \nis extended by mapping x to a fresh name. (This is enough to imple\u00adment the required commutative diagram, \nof type Comm . , for this particular de.nition of . .) Upon reaching a variable y, the environment is \nconsulted. During this lookup, one of two situa\u00adtions arises. If y is bound in the environment, then \nthe correspond\u00ading fresh name is returned. Otherwise, y is a free name of the term that we are attempting \nto export, so y is submitted to the primitive export operation (which may fail), whose result is returned. \nChecking whether a term is closed A closed term inhabits the empty world, and inhabits every world. That \nis, both of the types Tm \u00a2 and V{e}-Tm e accurately describe closed terms. These types are interconvertible. \nTo convert Tm \u00a2 into V{e}-Tm e, one uses the subtyping axiom \u00a2-bottom-C as well as the fact that Tm is \ncovariant in its index. To convert V{e}-Tm e into Tm \u00a2, one instantiates e with \u00a2. Terms that admit the \nabove types are particularly easy to use, because, thanks to polymorphism, they can be freely moved to \nany world. Of course, the .ip side of the coin is, it is some\u00adwhat dif.cult to create such terms. To \nhelp in this task, a useful tool is a function closeTm that checks at runtime whether a term is closed \nand, when it succeeds, returns a term that is statically known to be closed. Such a function should have \ntype V{e}-Tm e -Maybe (Tm \u00a2), or equivalently, V{ef }-Tm e -Maybe (Tm f). At the base type Name, such \na function is easy to implement. The function const nothing, which always fails, .ts the bill: it has \ntype V{ef }-Name e -Maybe (Name f). Whereas an export link fails at one particular name and lets every \nother name through, this function can be viewed as a link that always fails. With this in mind, implementing \ncloseTm is simple. The con\u00adstruction is identical to that of the generalized export function above, except \nin the setup phase, where an export link is replaced with a link that always fails.  6. Example: normalization \nby evaluation As an advanced example, we show how to express a normalization by evaluation algorithm \nin our system. This algorithm has been previously used as a benchmark by several researchers [10, 14, \n22]. The challenge lies in the way the algorithm mixes computational functions, name abstractions, and \nfresh name generation. The object language of interest is the pure A-calculus. The al\u00adgorithm exploits \ntwo different representations of object-level terms, which are respectively known as syntactic and semantic \nrepresenta\u00adtions. Because these representations differ only in their treatment of name abstractions (we \ndo not ensure normal forms for conciseness reasons), they can be given a common de.nition, which is parame\u00adterized \nover the representation of abstractions: module M (Abs :(World -Set) -World -Set) where data T a : Set \nwhere V : Name a -T a : Abs T a -T a : T a -T a -T a The parameter Abs has kind (World -Set) -(World \n-Set): it is an indexed-type transformer. In order to obtain the syntactic representation, we instantiate \nAbs with the abstractions that we have used throughout this paper: an abstraction is an existential package \nof a weak link and of a term that inhabits the inner world. This yields the type Term of syntactic terms. \nSynAbs :(World -Set) -World -Set SynAbs F a = j ,f -aLf x F f open M SynAbs renaming (T to Term) In order \nto obtain the semantic representation, we instantiate Abs with a different notion of abstraction, in \nthe style of higher-order abstract syntax: an abstraction is a computational function, which substitutes \na term for the bound name of the abstraction. This yields the type Sem of semantic terms. Sem is not \nan inductive data type; fortunately, with -n o-positivity-check Agda accepts this type de.nition, at \nthe cost of breaking strong normalization. SemAbs :(World -Set) -World -Set SemAbs F a = V{f }-a C f \n-F f -F f open M SemAbs renaming (T to Sem) It is important to note that our semantic name abstractions \ninvolve bounded polymorphism in a world: we de.ne SemAbs F e as V{f }-e C f -F f -F f, as opposed to \nthe more na\u00efve F e -F e. This provides a more accurate and more .exible description of the behavior of \nsubstitution. Furthermore, this has the important effect of making SemAbs (and Sem) covariant with respect \nto the parameter e, which would not be the case with the na\u00efve de.nition. In other words, it is possible \nto de.ne a general\u00adized import operation for semantic terms: impSem : V{af }-a C f -Sem a -Sem f impSem \nCw (Va)= V (importCwa) c impSem Cw ( f)= (, Cw' v -f (C-trans Cw Cw') v) impSem Cw (tu)= impSem Cw t \nimpSem Cwu At a semantic abstraction, no recursive call is performed, because the body of the abstraction \nis opaque: it is a computational func\u00adtion f. Instead, we exploit the transitivity of world inclusion \nand build a new semantic abstraction that inhabits the desired world. The normalization by evaluation \nalgorithm is parameterized with a representation of environments. The type of environments takes the \nform Env A ef, where A is the type of the data carried in the environment and e and f are the outer and \ninner worlds of the environment. Environments must offer the following constants and operations: empty \n(emptyEnv), lookup (lookupEnv); exten\u00adsion( , -); map (mapEnv); covariance of Env with respect to its \nparameter e (importEnvC). These requirements are expressed by the type ImportableEnvPack, whose de.nition \nis omitted. open ImportableEnvPack envPack The algorithm uses an environment whose type takes the form \nEnv (Sem e) ef. To a name, such an environment associates a semantic term that lies outside the scope \nof the environment. This type is, again, covariant in e, as witnessed by the following import function: \nimpEnv : V{af, }-a C f -Env (Sem a) a, -Env (Sem f) f, impEnv Cw = importEnvCCw 0 mapEnv (impSem Cw) \nThe .rst part of the algorithm evaluates a syntactic term within an environment to produce a semantic \nterm. When evaluating a X\u00adabstraction, we build a semantic abstraction, which encapsulates a recursive \ncall to eval. The bounded polymorphism required by the de.nition of semantic abstractions forces us to \nimport the environ\u00adment r via impEnv. app : V{a}-Sem a -Sem a -Sem a app ( f) v = f C-ref v appn v = \nnv eval : V{af }-Env (Sem a) af -Term f -Sem a eval r(Vx) =[ V, id](lookupEnv r x) eval r(tu)= app (eval \nr t)(eval r u) eval r( ( , a, t)) =(, Cwv -eval (impEnv Cw r[ a -v]) t) The second part of the algorithm \nrei.es a semantic term back into a term. When reifying a semantic abstraction, we build a syntactic abstraction. \nThis requires generating a fresh name, and leads us to parameterizing reify with a fresh name generator. \nreify : V{a}-Fresh a -Sem a -Term a reify g (Va)= Va reify g (nv)= reifygn reifygv reify g ( f)= ( , \nweakOf g, t) where open FreshPack t = reify (nextOf g)(f (COf g)(V (nameOf g))) Evaluation under an empty \nenvironment, followed with rei.cation, yields a normalization algorithm. This algorithm works with open \nterms: its argument, as well as its result, are terms in an arbitrary world e. nf : V{a}-Fresh a -Term \na -Term a nf g = reify g 0 eval emptyEnv 7. Related work The dif.culty of programming with, or reasoning \nabout, names and binders has been known for a long time. It has recently received a lot of attention, \ndue in part to the POPLMARK challenge [4]. De\u00ad spite this attention, the problem is still largely unsolved: \naccording to Guillemette and Monnier, for instance, none of the existing rep\u00adresentations of bindings \nis suitable [9]. In the following, we review several programming language de\u00adsigns that are intended \nto facilitate the manipulation of names and binders. By lack of space, this review cannot be exhaustive: \nwe fo\u00adcus on relatively recent related work. Distinctions One traditionally distinguishes several broad \nap\u00adproaches to the problem, which employ seemingly different tools, namely: atoms and atom abstractions; \nwell-scoped de Bruijn in\u00addices; higher-order abstract syntax. We believe that this distinction can be \narti.cial. In fact, our work presents strong connections with all three schools of thought. Perhaps more \nimportant are the fol\u00adlowing questions:  What properties are enforced by the system? FreshML [22] offers \nan adequate encoding of nominal terms, but does not prevent a newly generated atom from escaping its \nscope. Sys\u00adtems based on well-scoped de Bruijn indices enforce the invari\u00adant that every name refers \nto some binding site; however, as we have pointed out (\u00a74.5), this alone does not imply that in\u00ad dices \nare correctly adjusted where needed. In systems based on higher-order abstract syntax, and in Pure FreshML \n[18], name manipulation is hygienic by design: this is built in the syntax and semantics of the programming \nlanguage. In the present pa\u00adper, hygiene is not built in. We have used logical relations to .nd out (and \nprove) which properties can be expected of a well\u00adtyped program.  Does the system offer substitution \nfor free , and if so, at which types? Does it have separate data and computation layers? In FreshML, \nPure FreshML [18] and the present work, the answer to both questions is negative. In several systems \nin the tradi\u00adtion of higher-order abstract syntax, including Elphin [21], Del\u00ad phin [16, 17] and Beluga \n[12], the answer to both questions is positive. In Licata and Harper s work [10], substitution is avail\u00ad \nable for free at many types, even though data and computation are not separated.  Do names inhabit a \n.xed type, or do they inhabit every type?  Usually, systems that provide some form of substitution for \nfree [10, 12, 16, 17, 21] allow names to inhabit every type, while so-called nominal systems [18, 22] \nas well as the present work offer a separate type of names. How does the system keep track of the context \nor world in which a name makes sense? In Pure FreshML, there is effectively just one world, within which \nevery name makes sense; the proof obligations guarantee that no confusion can arise. In Elphin, Delphin, \nor in Licata and Harper s system, the meaning of types is relative to a current context , and a number \nof modalities are provided to discard the current context, extend it with one new name, etc. In Beluga, \ncontexts are explicit: a data-layer type, once annotated with a context, becomes a computation-layer \ntype. In the present paper, worlds are explicit, and are built into algebraic data type de.nitions by \nthe programmer.  Which very high-level operations does the semantics of the pro\u00adgramming language involve? \nThe semantics of FreshML and Pure FreshML involve renaming. The semantics of Elphin, Del\u00adphin, and Beluga \ninvolve higher-order matching. In the present work, as well as in Licata and Harper s work, no costly \nopera\u00adtions are built into the semantics; high-level operations, such as our import and export operations, \nare obtained (at many, but not all, types) via generic programming.  FreshML and Pure FreshML FreshML \n[22] extends ML with primitive types for names (known as atoms) and name abstractions. The semantics \nof FreshML dictates that pattern matching against a name abstraction silently replaces the bound atom \nwith a fresh atom. This makes it easy to write programs in a style that matches informal mathematical \npractice. FreshML satis.es a correctness property analogous to our Corollary 4.14 name abstractions \ncan\u00adnot be broken. However, FreshML is unsafe: it is possible for a name to escape its scope. Put another \nway, FreshML is impure: name generation is an observable side effect. Pure FreshML [18] imposes additional \nproof obligations, which ensure that freshly created atoms do not escape their scope, and correspond \nto Pitts freshness condition for binders [14]. Because these proof obligations are expressed in a specialized \nlogic, they can be discharged automatically. Because it is safe, Pure FreshML can be implemented either \nusing atoms (like the original FreshML) or using de Bruijn indices. This is an implementation choice, \nwhich the programmer need not know about. The present paper can be viewed as a different way of construct\u00ading \na safe variant of FreshML. Whereas Pure FreshML supplements ordinary ML types with logical assertions, \nwe explore the use of richer types and do not rely, for the time being, on a separate logic. In Pure \nFreshML, name abstraction is a primitive notion, and the fact that deconstructing an abstraction automatically \nfreshens the bound atom is used to guarantee that all terms effectively live in a single world. Here, \nin contrast, name abstraction is explained in terms of more basic notions; it is possible to deconstruct \na name abstraction without substituting a fresh name for the bound name. This leads to a .ner-grained \nunderstanding of binding, and possibly to greater runtime ef.ciency: because our nominal compilation \nscheme permits shadowing, there is, in some cases, no need to pay a price to enforce the property that \nall names are distinct. Nominal System T [15] follows the tradition of FreshML and so guarantees that \nname abstractions are not violated. However com\u00adpared to Pure FreshML and our system it does not statically \nenforce that names do not escape their scope. Instead the new construct is introduced to represent such \nescaped names, dynamically. This is akin to nan in .oating point computation, they are not numbers but \nthey still have the float type and result of mathematically ill founded operations like dividing by zero. \nSo in some sense names do escape their scope but are dynamically turned into harmless val\u00adues. Whether \nsuch programs should have a semantics or should simply be statically rejected is a matter of design. \nWell-scoped de Bruijn indices It is by now well-known that type\u00adtheoretic machinery (such as nested algebraic \ndata types, general\u00adized algebraic data types, or dependent types) can be used to ensure that every de \nBruijn index remains within range [1, 5]. In fact, de\u00ad pendent types can be used to encode not only the \nlexical scoping discipline, but also the type discipline of an object language: see, for instance, Chen \nand Xi [6] and Chlipala [7]. However, de Bruijn indices are, by nature, very low-level: it is desirable \nto build more abstract representations of top of them. For instance, Donnelly and Xi [8] de.ne an algebraic \ndata type of terms that is based on well\u00ad scoped de Bruijn indices, but is indexed with a higher-order \nabstract syntax representation of terms. Licata and Harper s system [10] is implemented on top of well-scoped \nde Bruijn indices. The sys\u00adtem presented in this paper can be compiled down to de Bruijn indices, and \ncould thus be viewed as an abstraction layer on top of well-scoped de Bruijn indices. However, as we \nhave pointed out (\u00a74.5), our system offers a stronger guarantee than raw well-scoped de Bruijn indices \ndo. It does not just guarantee that every index is within range: it also guarantees that a well-typed \nprogram compo\u00adnent is insensitive to permutations of the free indices in its input. In a scenario where \nprograms are type-checked but not proved correct, this extra guarantee could be welcome. Licata and Harper \ns system [10] differs from ours in several ways. Perhaps most notably, Licata and Harper aim to provide \nsub\u00adstitution for free when possible, whereas we don t; and they expose the use of well-scoped de Bruijn \nindices to the programmer, who must sometimes reason in terms of zero and successor, whereas we do not \nreveal the nature of names, thus permitting multiple compi\u00adlation schemes. This said, there are numerous \nsimilarities between the two sys\u00adtems. Both keep track of the context, or world, within which each name \nmakes sense. Both offer .exible ways of parameterizing or quantifying types over worlds. Both offer ways \nof moving data from one world to another: Licata and Harper s weakening and strengthening respectively \ncorrespond to our import and export op\u00aderations. Both systems support .rst-class computational functions. \n Not all functions can be imported or exported, but some can: for instance, in both systems, the example \nof normalization by evalua\u00adtion [20], which requires importing a function into a larger world, is made \ntype-correct by planning ahead and making this function polymorphic with respect to an arbitrary world \nextension. Elphin, Delphin, Beluga [12, 16, 17, 21] are closely related to one another in several ways. \nThey separate the data and compu\u00adtation layers, which implies that they do not support .rst-class functions. \nAt the data level, they provide substitution and higher\u00adorder matching as primitive operations. This \nambitious approach can eliminate some boilerplate code, at the cost of a complex meta\u00adtheory. By contrast, \nthe meta-theory of our proposal is extremely simple, as it only extends an existing logical relations \nargument with a few new primitive types and operations. Moving across representations It is arguably \ndesirable to be able to offer several choices of representation within a single system, and to be able \nto migrate from one representation to another. For in\u00adstance, our implementation of normalization by \nevaluation (\u00a76) il\u00ad lustrates how to move back and forth between syntactic name ab\u00adstractions and semantic \nname abstractions in the style of higher\u00adorder abstract syntax. Atkey and co-authors [2, 3] investigate \nhow to move back and forth between higher-order abstract syntax and de Bruijn indices. The translation \nout of higher-order abstract syn\u00adtax produces well-scoped de Bruijn indices, but the proof of this fact \nis meta-theoretic. Atkey uses Kripke logical relations to argue that the current world at the time of \napplication of a certain func\u00adtion must be larger than the world at the time of construction of this \nfunction. This seems somewhat related with our use of bounded polymorphism in the de.nition of semantic \nname abstractions (\u00a76). An exact connection remains to be investigated. 8. Future work We have presented \nan abstract programming model, together with two concrete implementations, in nominal style and de Bruijn \nstyle. We have argued separately about the correctness of each imple\u00admentation. In particular, we have \nproved that the nominal imple\u00admentation allows an adequate encoding of nominal terms. Ideally, however, \nthe nominal term encoding should be proved adequate directly with respect to the abstract model, not \nwith respect to its implementations. We do not yet know how to do this, because our abstract model does \nnot have a semantics. A related question is: how to carry out speci.cations and proofs of programs with \nrespect to our abstract programming model? Acknowledgements Thanks to Randy Pollack, Andrew Pitts, Beno\u00eet \nMontagu, Jean-Philippe Bernardy and the anonymous re\u00adviewers for providing us with very valuable feedback. \nReferences [1] Thorsten Altenkirch and Bernhard Reus. Monadic presentations of lambda terms using generalized \ninductive types. In Computer Science Logic, volume 1683 of Lecture Notes in Computer Science, pages 453 \n468. Springer, 1999. [2] Robert Atkey. Syntax for free: representing syntax with binding using parametricity. \nIn International Conference on Typed Lambda Calculi and Applications (TLCA), volume 5608 of Lecture Notes \nin Computer Science, pages 35 49. Springer, July 2009. [3] Robert Atkey, Sam Lindley, and Jeremy Yallop. \nUnembedding domain-speci.c languages. In Haskell symposium, pages 37 48, September 2009. [4] Brian E. \nAydemir, Aaron Bohannon, Matthew Fairbairn, J. Nathan Foster, Benjamin C. Pierce, Peter Sewell, Dimitrios \nVytiniotis, Ge\u00adoffrey Washburn, Stephanie Weirich, and Steve Zdancewic. Mech\u00ad anized metatheory for the \nmasses: The POPLMARK challenge. In International Conference on Theorem Proving in Higher Order Log\u00adics \n(TPHOLs), Lecture Notes in Computer Science. Springer, August 2005. [5] Richard Bird and Ross Paterson. \nde Bruijn notation as a nested datatype. Journal of Functional Programming, 9(1):77 91, January 1999. \n[6] Chiyan Chen and Hongwei Xi. Implementing typeful program trans\u00ad formations. In ACM Workshop on Evaluation \nand Semantics-Based Program Manipulation (PEPM), pages 20 28, June 2003. [7] Adam Chlipala. A certi.ed \ntype-preserving compiler from lambda calculus to assembly language. In ACM Conference on Programming \nLanguage Design and Implementation (PLDI), pages 54 65, June 2007. [8] Kevin Donnelly and Hongwei Xi. \nCombining higher-order abstract syntax with .rst-order abstract syntax in ATS. In ACM Workshop on Mechanized \nReasoning about Languages with Variable Binding, pages 58 63, 2005. [9] Louis-Julien Guillemette and \nStefan Monnier. A type-preserving compiler in Haskell. In ACM International Conference on Functional \nProgramming (ICFP), 2008. [10] Daniel R. Licata and Robert Harper. A universe of binding and compu\u00ad tation. \nIn ACM International Conference on Functional Programming (ICFP), pages 123 134, September 2009. [11] \nConor McBride and Ross Paterson. Applicative programming with effects. Journal of Functional Programming, \n18(1):1 13, 2008. [12] Brigitte Pientka. A type-theoretic foundation for programming with higher-order \nabstract syntax and .rst-class substitutions. In ACM Symposium on Principles of Programming Languages \n(POPL), pages 371 382, January 2008. [13] Andrew M. Pitts. Parametric polymorphism and operational equiv\u00ad \nalence. Mathematical Structures in Computer Science, 10:321 359, 2000. [14] Andrew M. Pitts. Alpha-structural \nrecursion and induction. Journal of the ACM, 53:459 506, 2006. [15] Andrew M. Pitts. Nominal System T. \nIn ACM Symposium on Prin\u00adciples of Programming Languages (POPL), pages 159 170, January 2010. [16] Adam \nPoswolsky and Carsten Sch\u00fcrmann. Practical programming with higher-order encodings and dependent types. \nIn European Sym\u00adposium on Programming (ESOP), volume 4960 of Lecture Notes in Computer Science, pages \n93 107. Springer, March 2008. [17] Adam Poswolsky and Carsten Sch\u00fcrmann. System description: Del\u00ad phin \n A functional programming language for deductive systems. Electronic Notes in Theoretical Computer Science, \n228:113 120, 2009. [18] Fran\u00e7ois Pottier. Static name control for FreshML. In IEEE Sym\u00adposium on Logic \nin Computer Science (LICS), pages 356 365, July 2007. [19] Nicolas Pouillard and Fran\u00e7ois Pottier. A \nfresh look at programming with names and binders (Agda code), March 2010. http://tiny. nicolaspouillard.fr/FreshLookAgda. \n[20] Nicolas Pouillard and Fran\u00e7ois Pottier. A fresh look at program\u00adming with names and binders (extended \nversion). http://tiny. nicolaspouillard.fr/FreshLookExt, March 2010. [21] Carsten Sch\u00fcrmann, Adam Poswolsky, \nand Jeffrey Sarnat. The \\\u00ad calculus: Functional programming with higher-order encodings. In International \nConference on Typed Lambda Calculi and Applications (TLCA), volume 3461 of Lecture Notes in Computer \nScience, pages 339 353. Springer, April 2005. [22] Mark R. Shinwell, Andrew M. Pitts, and Murdoch J. \nGabbay. FreshML: Programming with binders made simple. In ACM Inter\u00adnational Conference on Functional \nProgramming (ICFP), pages 263 274, August 2003.   \n\t\t\t", "proc_id": "1863543", "abstract": "<p>A wide range of computer programs, including compilers and theorem provers, manipulate data structures that involve names and binding. However, the design of programming idioms which allow performing these manipulations in a safe and natural style has, to a large extent, remained elusive.</p> <p>In this paper, we present a novel approach to the problem. Our proposal can be viewed either as a programming language design or as a library: in fact, it is currently implemented within Agda. It provides a safe and expressive means of programming with names and binders. It is abstract enough to support multiple concrete implementations: we present one in nominal style and one in de Bruijn style. We use logical relations to prove that \"well-typed programs do not mix names with different scope\". We exhibit an adequate encoding of Pitts-style nominal terms into our system.</p>", "authors": [{"name": "Nicolas Pouillard", "author_profile_id": "81470654166", "affiliation": "INRIA, Paris - Rocquencourt, France", "person_id": "P2338198", "email_address": "", "orcid_id": ""}, {"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA, Paris - Rocquencourt, France", "person_id": "P2338199", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1863543.1863575", "year": "2010", "article_id": "1863575", "conference": "ICFP", "title": "A fresh look at programming with names and binders", "url": "http://dl.acm.org/citation.cfm?id=1863575"}