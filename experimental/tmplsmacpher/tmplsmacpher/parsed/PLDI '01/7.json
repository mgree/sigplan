{"article_publication_date": "05-01-2001", "fulltext": "\n Principled Scavenging\" Stefan Monnier Bratin Saha Zhong Shao Department of Computer Science Yale University \nNew Haven, CT 06520-8285  {monnier, saha, shao} @cs.yale.edu ABSTRACT Proot=carrying code and typed \nassembly languages aim to mini- mize the trusted computing base by directly certifying the actual machine \ncode. Unfortunately, these systems cannot get rid of the dependency on a trusted garbage collector. Indeed, \nconstructing a provably type-safe garbage collector is one of the major open prob- lems in the area of \ncertifying compilation. Building on an idea by Wang and Appel, we present a series of new techniques \nfor writing type-safe stop-and-copy garbage collec- tors. We show how to use intensional type analysis \nto capture the contract between the mutator and the collector, and how the same method can be applied \nto support forwarding pointers and gener- ations. Unlike Wang and Appel (which requires whole-program \nanalysis), our new framework directly supports higher-order fun- tions and is compatible with separate \ncompilation; our collectors are written in provably type-safe languages with rigorous seman- tics and \nfully formalized soundness proofs. 1. INTRODUCTION The correctness of most type-safe systems relies critically \non the correctness of an underlying garbage collector (GC). This also holds for Proof-Carrying Code (PCC) \n[14] and Typed Assembly Languages (TAL) [13]--both of which aim to minimize the trusted computing base \nby directly certifying the actual machine code. Un- fortunately, these systems cannot get rid of the \ndependency on a trusted garbage collector. Indeed, constructing a verifiably type- safe garbage collector \nis widely considered as one of the major open problems in the area of certifying compilation [12, 3]. \nRecently, Wang and Appel [25] proposed to tackle the problem by building a tracing garbage collector \non top of a region-based calculus. Our work builds on theirs but makes the following new *This research \nwas sponsored in part by the Defense Advanced Research Projects Agency ISO under the title \"Scaling Proof-Carrying \nCode to Pro- duction Compilers and Security Policies,\" ARPA Order No. H559, issued under Contract No. \nF30602-99-1-0519. and in part by NSF Grants CCR- 9901011 and CCR-0081590. The views and conclusions contained \nin this document are those of the authors and should not be interpreted as rep- resenting the official \npolicies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U:S. Government. \nPermission to make digital or hard copies of all or part Of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advan-tage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLD12001 \n6/01 Snowbird, Utah, USA &#38;#169; 2001 ACM ISBN 1-58113-414-2/01/06...$5,00 significant contributions: \nWe show how to use intensional type analysis (ITA) [21, 8] to accurately describe the contract between \nthe mutator and the collector and how the same framework can be applied to construct various different \ntype-safe GCs. Using ITA to typecheck GC may seem to be an obvious idea to some people, however, none \nof the previous work [23, 17, 21] have succeeded in getting it to work. Indeed, Wang and Appel [25] subsequently \ngave up on using ITA. We show why the problem is nontrivial (see Section 2.2) and how to modify the basic \nITA framework to solve the problem. Wang and Appel's collector [25] relies on whole-program analysis \nand code duplication to support higher-order and polymorphic languages; this breaks separate compilation \nand is impractical. We show how to use runtime type analysis to write our GC as a library (thus no code \nduplication) and how to directly support higher-order polymorphic functions. We expose in detail how \nto implement and certify efficient forwarding pointers. Making them type-safe is surprisingly subtle \n(see Section 7). Wang and Appel [25] also claim to support forwarding pointers but their scheme is less \nefficient and it is unclear whether it is sound. We also show how to handle generations with a simple \nex- tension of our base calculus. A garbage collector is type-safe only if it is written in a prov- ably \ntype-safe language. We have complete type-soundness proofs for all our calculi (see the companion technical \nre- port [11]).Wang and Appel's collectors [25, 24], on the other hand, are not fully formalized. Although \nour paper is theoretical in nature, we believe it will be of great interests to the general audience, \nespecially those who are looking to apply new language theory to solve important prac- tical problems \nsuch as mobile-code safety and certifying compila- tion. We have started implementing our type-safe garbage \ncollector in the FLINT system [18], however, making the implementation realistic still involves solving \nseveral problems (e.g., breadth-first copying, remembered sets. and data structures with cycles, which \nwe still cannot support satisfactorily). Thus implementation issues are beyond the scope of this paper. \nNevertheless, we believe our current contributions constitute a significant step towards the goal of \nproviding a practical type-sate garbage collector. 2. MOTIVATION AND APPROACH Why do we want a type-safe \ngarbage collector? The explosive growth of the Internet has induced newfound in- terest in mobile computation \nas well as security. Increasingly, ap- plications are being developed at remote sites and then downloaded \nfor execution A robust mobile code system must allow code from potentially untrusted sources to be executed. \nAt the same time, the system must detect and prevent the execution of malicious code. The safety of such \na system depends not only on the properties of the code being downloaded, but also on the security of \nthe host sys- tem itself, or more specifically, its trusted computing base (TCB). Proof-carrying code \nand typed assembly languages have been proposed to reduce the size of this TCB by bundling the untrusted \ncode with a mechanically checkable proof of safety, where the safety is usually defined as type-safety. \nSuch systems only need to trust their verifier and runtime system rather than their whole compiler suite. \nBut all these certifying-compiler projects (e.g., PCC, TAL) still crucially rely on the correctness of \na tracing garbage collector for their safety. Recently, both Crary [3] and Morrisett [12] have char- \nacterized type-safe garbage collection as one of the major open problems in the area of certifying compilation. \nA type-safe GC is not only desirable for reducing the size of the TCB but also for making it possible \nto ship custom-tailored GC along with mobile code, or to choose between many more GC vari- ants without \nrisking the integrity of the system. Writing GC inside a type-safe language itself also makes it possible \nto achieve princi- pled interoperation between garbage collection and other memory- management mechanisms \n(e.g., those based on malloc-free and re- gions). Indeed, one major software-engineering benefit is that \na type-safe GC must make explicit the contract between the collector and the mutator and it must make \nsure that it is always respected. Without typechecking, such rules can prove difficult to implement correctly \nand bugs can be very difficult to find. 2.1 The problem Recently, Wang and Appel [23] proposed to tackle \nthe problem by layering a stop-and-copy tracing garbage collector [26] on top of a region based calculus, \nthus providing both type safety and com- pletely automatic memory management. A region calculus [19] \nannotates the type of every heap object with the region in which it is allocated (such as or1 \u00d7P ~Y2 \nwhere p is the region), thus allowing to safely reclaim memory by freeing any region that does not appear \nin any of the currently live types. The basic idea in building a type-safe GC is to concentrate on type-safety \nrather than correctness. Rather than try to prove that the copy function faithfully copies all the heap, \nwe just need to show that it has a type looking somewhat like Vo~.(o~~ (o~[T/F])) where (of[T/F]) stands \nfor the type c~ where the region annotation Y is substituted for F (see Fig. 1). Assuming we have such \na function and we don't keep any reference to the region F, the region calculus will allow us to safely \nreclaim F. Clearly, there is no correctness guarantee in sight since the copy function might return a \ncompletely different value or might not faithfully reproduce the original graph, but it ensures type-safe \nexe- cution of the whole mutator-collector system and even offers a form of type-preservation guarantee. \nThe main problem is clearly to write this copy function which needs to trace through arbitrary heap structures \nat runtime. There- fore, the language needs to support some form of runtime type in- formation in order \nto do the actual copy. F T X F \u00d7T   ,/ \\ /\\ int int X F \u00d7T  /\\ /\\ int int int int L .............. \nJ copy: VF.V-I-.Vo~.(o~ --* ~[T/F]) GC = hF.ho~.A(x: ~, k: Vp.o~[p/F] ~ O) let region T in let y = copv[F]F][c~](x)in \nonly T in k[T](2) Figure 1: Stop-and-Copy from region F to region T. GC is written in continuation passing \nstyle (CPS). It takes the current region, the heap and a continuation and begins by allocat- ing a new \nregion T with \"let region Y in e\". It then copies the heap into this new region and frees the old region \nimplicitly with \"only Y in e\" which tells that all regions but T can be reclaimed. This way of freeing \nregions was introduced by Wang and Appel to circumvent problems linked to atiasing of regions, In their \nfollowup paper [25], Wang and Appel suggest to cir- cumvent the problem of runtime type information using \na mix of monomorphization and defunctionalization (a form of closure con- version due to Tolmach [20] \nwhich reduces the language to a mono- morphic first-order calculus). However, this approach suffers from \nseveral major drawbacks: It can introduce a significant code size increase and forces the use of separate \nspecialized GC and copy functions for each type appearing in the program. Instead of the promised flex- \nibility to choose among various GC variants, this approach locks you into a single 100% tailor-made collector. \n\u00ae Monomorphization is not applicable in the presence of recur- sire polymorphism or existential packages, \nso their type-safe GC cannot handle languages with polymorphic recursion or abstract types. o Monomorphization \nand defunctionalization all rely on whole program analysis which are clearly imcompatible with sepa- \nrate compilation. Finally, although their type-safe GC does properly formal- ize the interaction between \nthe mutator and the collector, the formalization is hidden inside the compiler and hence does not allow \nto bring out open the overly intimate relationship between the GC and the compiler. They also try to \npreserve sharing using forwarding pointers. The rough sketch of the solution they propose is similar \nto the one we developed (which was clone independently). It relies mostly on a form of cast which allows \ncovariant subtyping of references. Mak- ing sure that this cast is sufficiently constrained to be safe \nis diffi- cult. Their informal presentation is incomplete and possibly incor- rect, and leaves many important \nquestions unanswered. 2.2 Our solution We want to do away with any form of whole program analysis so \nas to make the mutator and the collector independent in order to reap the promised benefits of more flexibility \nand clearer interac- tion between mutator and GC. In this paper, we present a different approach for \nwriting the copy function, relying on runtime type analysis. The substitution present in the return type \nof cop), as well as the need to observe types at runtime leads one very naturally to use intensional \ntype analysis (ITA) [21, 8]. In fact, an earlier paper of Wang and Appel [23] was titled \"safe garbage \ncollection = regions + intensional type analy- sis\" but they subsequently gave up on using ITA and opted \nfor the solution mentioned above [25]. Saha et al. [17, 21] also tried to use ITA to write the copy function, \nbut their attempt is missing crucial details and didn't really work either. 2.2.1 Intensional type analysis \nA full description of ITA is outside the scope of this paper, but in short, ITA provides a typecase term \nto exmrfine at runtime the actual type with which a type variable was instantiated (using some form of \nruntime type descriptor) and a typerec type to write type functions that do the equivalent of a fold \nto map one type into an- other. You can thus define a type function that replaces all occur- rences of \nInt with Bool. One important property is that typerec functions only analyse type constructors and linger \nwhen faced with a type variable until that variable is instantiated. 2.2.2 A case for symmetry So what \nis the problem? It seems that ITA provides us with just the right tools. We can for example write a simple \ntyperee function ST,F (or) which substitutes region annotations T for F by recursively analyzing the \ntype or. At the term level, in the body of copy, we can similarly use typecaseto determine the actual \ntype of the object we are copying. But that means that the type grows each time we go through the GC, \nfrom cr to ST, F(a) to Sp,T(ST,F(Cr)) .... This may seem unimportant since S should be reduced away anyway. \nBut Sp,T(O 0 cannot be reduced further until a is instantiated: 3ocST,r(o~) is a normal form.. So the \naccumulation of S operators is a real problem, since S o.F(O') is not equal to Sp,T(ST.F(OZ)). We could \narrange for Sp,T(ST,F(O')) to reduce to Sp,F(O'). But then all types become Sp.F(o') (where F is the \n\"initial region\") ex- cept before the first collection. Also it is very ad-hoc and only works if S obeys \nthis kind of idempotency. A better approach is to ensure that the input and output types of copy are \nsymmetric. We first redefine Sp(cr) which simply substi- tutes p for any region annotation (why bother \nwith an initial region) and then redefine copy to have type VF.VT.Va.(SF(cQ ~ ST(a)) which gets us rid \nof the special case before the first collection and does not require any special reduction rule for S \nsince GC does not increase the size of the type any more. 2.2.3 A case for tags The above solution looks \ngood until we try to copy existential packages 3c~ E A.o-, used to encode closures. The A annotation \nis used to bound the set of regions that can appear in the witness type hidden under the type variable \nc~. Opening an existential package of type 3c~ E {F}.SF(a), gives us the value ~r of c~ (i.e. the witness \ntype) and a value of type SF(Cr). Recursively applying copy to that value will return a new value of \ntype ST(a), but how can we construct the new existential package of type 9c~ E {Y}.Sv(c~)? Reusing cr \nfor the witness type will not do since cr is not constrained to {T} but to {F}. A witness of ST(o-) cannot \nwork either; the only correctly typed package we can produce is (c~--ST(a), v:o~) which has type 3aE \n{T}.o~. Clearly, we are again trying to push a new S onto the type rather than replacing an S with another. \nSo we can again arrange for ST(SF(a)) to reduce to ST(<r), but we really do not want to tie our hands \nwith such an ad-hoc and restrictive scheme. Instead, we can pay a bit more attention to what we do and \nob- serve that Sp (c~) makes region annotations on c, completely use- less, so instead of trying to get \nthose annotations right only to see them substituted we can simply define a parallel set of non- annotated \ntypes -r (that we will call tags). Since tags have no re- gion annotations, we can hide them in tag variables \nwithout any A constraint, which side-steps the problem when copying existentials conveniently. Note that \ncontrary to common practice, our tags are not attached to their corresponding objects but are managed \ncom- pletely independently. Such a split between types and tags is not a new concept since it was already \nused in the work on intensional type analysis where tags were called constructors [8, 5]. But here, tags \ntake on more significance since they correspond to a source-level notion of type and will be mapped to \ndifferent actual types with different type functions M (formerly S) which are used to encapsulate all \nthe constraints that mutator data has to satisfy in order for the collec- tor to do its job: As you will \nsee in sections 7 and 8 we wil! use a non-trivial M mapping to force the mutator to provide space for \nforwarding pointers and to enforce the invariant that references do not point from the old generation \nto the new. 3. SOURCE LANGUAGE ACLOS For simplicity of the presentation, the source language we pro- \npose to compile and garbage collect is the simply typed A-calculus. In order to be able to use our region \ncalculus, we need to convert the source program into a continuation passing style form (CPS). And we \nalso need to close our code to make all data manipulation explicit, so we turn all closures into existential \npackages. We will not go into the details of how to do the CPS conver-sion [7] and the closure conversion \nusing existentials [10, 9]. The language used after CPS conversion and closure conversion is the language \n/~CLOSshown below. (types) r ::=lntlt Iq xr2[r~O[3t.r (values) v::=n flzl(vl,v2) l(t=ri,v:r2) (terms) \ne ::=letzc-vine.letx=w~vlne vl(v2)lopen v as !t,x) in e t haltv (programs) p ::= letrec f = A[x:r).em \ne Since functions are in CPS. they never return, which we repre- sent with the arbitrary return type \n0, often pronounced void. (vl, vz) builds a pair while 7r, v selects its i th element. To represent clo, \nsures, the language includes existential packages of type 3t.rz and constructed by (t = \"rl, v : \"r2). \nThe construct open v as (t, z) in e takes an existential package v. binds the witness type to t and \nthe value to x. and then executes e. The complete program letrec f, -A(x, : T~)~~ in e consists of a \nlist of mutually recursive closed function declarations followed by the main term to be executed. (regions) \n  (kinds) (tags) (types) a ::= intt a~ x or21 v[q[\u00a2](~) -, o I at.~ ] ~ at p I Mo(r) (values) -::: \n~ tx I ..e f (v,,,,~) I (t=.:,v:,~) (operations) op ::: v 17roy I put[p]v I get v (terms) e ::= v[~][~(~7) \ni let x = op in e ] halt v I ifgo p el e2 ] open v as (t, ~) in e t let region r in e ] only A in e I \ntypecase T of (el; e.~ ; t~t~.ex ; t~.e~) Figure 2: Syntax of Acc  4. TARGET LANGUAGE AGE We translate \nACLOS programs into our target language AGo The target language is also used to write the garbage collector. \nFig-ure 2 gives the syntax of AGc; the semantics are presented in Sec- tion 6). A\u00a2c extends ACLOS with \nregions [19] and (fully reflexive) intensional type analysis [21]. Functions are also fully closed and \nuse CPS but they can additionally be polymorphic over tags and regions. 4.1 Regions Our region calculus \nuses reference values u.g of type (~z at u). u is the region in which the object is allocated and g is \nthe actual loca- tion within that region. Object allocation and memory accesses are made explicit with \nput and get. In order to trigger GC, ifgc allows us to check whether a region is full. Ensuring timely \ncollection us- ing heap limit checks or other mechanisms is outside the scope of this paper, so put never \nfails, even if the region is \"full\". Region allocation and reclamation is done with let region and only. \nDeallocation of a region is implicit since only lists the regions that should be kept. This neatly works \naround aliasing problems, at the cost of a more expensive deallocation operation (only needs to go through \nthe list of all regions to find which ones need to be reclaimed). In our case, we have very few regions \nand deallocate them only occasionally, so it is a good tradeoff. 4.2 Functions and code Since programs \nin Acc are completely closed, we can separate code from data. The memory configuration enforces this \nby having a separate dedicated region cd for all the code blocks. A value A[t~[~](~TO~).e is only an \narray of instructions (which can contain references to other values in od) and needs to be put into a \nregion to get a function pointer before one can call it. In practice, functions are placed into thecd \nregion when translating code from ACkOS and never directly appear in -Xcc code. The indirection provided \nby memory references allows us to do away with letrec. For convenience, we will use fixf.e in examples, \nbut in reality, e wilt be placed at the location g in the cd region and all occurrences of f will be \nreplaced by cd.g. 4.3 lntensional type analysis As explained earlier, we have split the notion of type \ninto two. Tags represent the runtime type descriptors and map very directly to source-level types without \nany region annotations. The only differ- ~l-ACLOS~ AGC) F ~ ~, n -~ n F F~ f =~ cd.F(f) F F~ x :~ x \nF F. vl ~ v[ F F. v2 ~ v; F Fz (vl,v2) ~ put[r](vi,'v~) F F~ v ~ v ~ F ~-,, (t='q,v:'r2) ~ put[r](t=~l,v':M~O-2)) \nFF. vl~v~ PF~v2~v~ FF.v~v' P % v~(v2) ~ v~[][r](v;) F F~ halt v ~ halt v' FF~e=~e ~ FF,,v~'u ~ F I--~ \nopen v as (t, z) in e ~ open (get v') as (t, x) in e' F F~ e :=~ e ~ F F. v :=~. v ~ F I--~ let x = \nv in e ~ let x = v' in e' Fk~e=v-e' Fk,,v~v' F F~ let z = ~r,v in e ~ let x = 7r,(get v') in e' F F~ \ne =~- e' g : F(f) ~-i (f = ,x(x:~-).e) =-t- A[][r](x: M,,(T)).ifgc r (gek][r](cd.g ,.~)) e' F = {fI \nH gt,... ,f~ H g,~) k- v letrec L = A(x~ :~-~).e~*'In e ({cd ~ {&#38; ~-* f[,...}}, let region r in e') \n Figure 3: Translation of -~CLOSterms. ent between ACLOS types and XGc tags is the addition of tag func- \ntions At.~- and tag applications wit'2, which are needed for type analysis of existentials [21 ]. To \ndo the actual analysis of tags, terms include a refining typecase construct, i.e. a more refined tag \nis substituted for ~- in each arm of the typecase. Finally, instead of a full-blown typerec construct \nwe only provide a bard-coded M, to keep the presentation simpler. Mp(T) is the type corresponding to \nthe tag z complemented with region annotations p: Mp(Int) ~ int Mp0-1 x -r~) =:=> (Mp0- 0 x Mp0-2)) at \np Mp(3t.T) ~ (3t.Mp0-)) at p ap('r -* 0) ~ V[][r](Mr0-)) ~ 0 atcd This definition of M forces the mutator \nto maintain the invariant that all objects are allocated in the same region, which is all our garbage \ncollector requires. 5. TRANSLATING/~CLOS TO AGc The translation of terms from AcLos to Ace shown in \nFig. 3 is mostly directed by the type translation Mp presented earlier: each fix gc[t][r'l](f :V[][r'](M, \n(t)) --, O, x: M~., (t)). let region r'2 in  let y : copy[t] [r,, r2] (x) in only {re} in f[][r2](y) \n fix copy[t] [r t, r21 (x: M,., (t.)) : M,.~ (t.). typecase t. of Int :~ x --+ .:=~.. $ t,, x t,2 ~-let \nXl = co~j[tl] [,r,, r2] (zr, (get ~')) in let x2 = copy[t.2][r,, r2](Tr2(get x)) in put[r2](xl, x2) 3t:~ \n~ open (get x) as (t.,y) in let z = copy[t~t][r,, r~](y) in put[r2l(t =t, z: M.~ 2 (t~t)) Figure 4: The \ngarbage collector proper. function takes the current region as an argument and begins by checking if \na garbage collection is necessary. All operations on data are slightly rewritten to account for the need \nto allocate them in the region or to fetch them from the region. For example a ACkOS function like: fix \nswap(z : Int x Int). let xl :: 7rlx in let x2 = 7r2x in let x' = (x2, xl) in halt 0 will be turned into \nthe following Ace function: cO.g = A~[r](x: (int x int) at r). ifge r (gc[int x Int][rl(cd.g' z)) let \nx = get x in letxl = ~rlz in let x2 = ~2x in let x' = put[r](x2, xl) in halt 0 The mapping between ACLOS \nidentifiers like swap andAcc loca- tion like cd.e is kept in F. The new argument r refers to the current \nregion. It is initially created at the very beginning of the program and is changed after each garbage \ncollection. An important detail here is that the garbage collector receives the tag T rather than the \ntype ~r of the argument. The GC receives the tags for analysis as they were in ACLOS rather than as they \nare translated in Ago This maintains a clear distinction between the types the programmer thinks he manipulates \nand the underlying types they map to. Another interesting detail is that if the region is full, the function \n calls the garbage collector with itself as the return function. I.e. when the collection is finished, \nthe collector will jump back to the function which will then redo the check. We could mstead call the \ngarbage collector with another function as argument. That would save us from redoing the ifgc but would \nrequire many tiny functions which are just not worth bothering with. The translation in Fig. 3 uses AGe \nm a somewhat loose way to keep the presentation concise. More specifically, it will generate terms such \nas let z = 7ri(get v) in e instead of let x' = get v in let z = 7r, x' in e. Turning such code back into \nthe strict Ace is very straightforward. On the other hand, the garbage-collection code In Fig. 4 uses \nnot only some syntactic sugar but even resorts to using a direct- style presentation of the copy function. \nThis is only for clarity of presentation, of course. The companion technical report [11] presents a \nfully CPS- and closure-converted code that is equivalent but more difficult to read. The garbage collector \nitself is very simple: it first allocates the to region, asks copy to move everything into it and then \nfree the from region before jumping to its continuation, using the new region. The copy function is similarly \nstraightforward, recursing over the whole heap and copying in a depth-first way. Clearly, the di- rect \nstyle here hides the stack. When the code is CPS converted and closed, we have to allocate that stack \nof continuations in an additional temporary region and unless our language is extended with some notion \nof stack, none of those continuations would be collected until the end of the whole garbage collection. \nThe size of this temporary region can be bounded by the size of the to re-gion since we can't allocate \nmore than one continuation per copied object, so it is still atgorithmically efficient, although this \nmemory overhead is a considerable shortcoming. 6. A CLOSER LOOK AT AGC Programs in Ace use an allocation \nsemantics which makes the allocation of data in memory explicit. The semantics, defined in Fig. 5, maps \na machine state P to a new machine state P'. A ma- chine state is a pair (M, e) of a memory M and a term \ne being executed. A memory consists of a set of regions; hence, it is de- fined formally as a map between \nregion names r, and regions R. A region, in turn, is a map from offsets g to storable values v. There- \nfore, an address is given by a pair of a region and an offset ~,.g. We assign a type to every location \nallocated in a region with the mem- ory environment ~. Fig. 6 shows the form of environments while Fig. \n7 presents the static semantics. 6.1 Functions and code Since function bodies can contain references \nto other functions in cd but we do not have an easy way for the garbage collector to analyze a function \nbody to trace through those references, cO enjoys a special status. It cannot be freed and can only contain \nfunctions, no other kind of data. An alternative would be to require all functions to be fully closed, \n but that would require the addition of recursive types for the envi- ronment containing pointers to \nall functions and passed around ev- erywhere. It would save us from so many cO special cases, and would \nallow garbage collecting code, but on the other hand, it would be less realistic since it would amount \nto disallowing direct function calls. 6.2 The type calculus The target language must be expressive enough \nto write a tracing garbage collector. Since the garbage collector needs to know the type of values at \nruntime, the language AGe must support the run- time analysis of types. Therefore. conceptually, types \nneed to play a dual role in this language. As in the source language Accos, they are used at compile \ntime to type-check well formed terms. How- ever. they are also used at runtime, as tags, to be inspected \nby the garbage collector (and, in general, by any type analyzing function). To enforce this distinction, \nwe split types into a tag language and a type language. The tags correspond to the runtime entity, while \nthe types correspond to the compile time entity. During the translation from Act.os to Acc, the tag for \na value must be constructed from its type, so the tags in AGc closely resem- ble the type language in \nACLOS. To support tag analysis, we need to add tag-level functions (At.r) and tag-level applications \n(rrl) which in turn requires adding the function kind f2 ~ fL (M, ..e[:'][\u00a2l(~)) where Nl(u.g) :: (~[tT][r~(S:#).e) \n(.54, let m = v in e) (M, let z -rc~(vi, v2) in e) (M, let z = put[u]v in e) (M, let x = get u.g in e) \n(M, open (t=r',v:cr) as (t,z} in e) (M, ifgc p el e2) (M, ifgc p el e2) (M, let region r in e) (M, only \nA in e) (M, typecaselntof(ei;e~;t\u00a22.e\u00d7;t~..es)) (M, typecase r ~ Oof(ei;e~;tltu.ex;t~.es)) (M, typecase \nr~ x r2 of (% e~ ; f;lt>ex ; re.e3))  (M, typecase3t.rof(ei;e~;t~t>ex;t~.ea)) ==# (M, el#,:, ~/</; \nel)  ==> (V, e[~/~]) --=:> (M, e[,~/~:l) (M{u.g ~ v}, e[u.g/z}) where g ~ Do.m(M(u)) (M,e[v/x]) where \nM(u.g) = v =,,. (M, eU, ~,/t, ~]) =::::\u00a2,-(M, el) if pis full ==> (M, e2) if p is not full ==> (M{u ~ \n{}}, e[u/r]) where u \u00a2 Dora(M) (Ml~,e) ==> (M,m) (~Z, e-~) (M, e x [1\"1, \"/-2/t 1, t21) ==> (M, e3[Xt.r/t~]) \nFigure 5: Operational semantics of Acc. tenv) (re,.,) (ren~) (region types) (mem types) (regions) (memories) \n(states) ~3 ::= . [-O,t:~ \u00a3 ::= . [F,z:a A ::-- [ A,p T ::= {gi:~i,...,g.:m~} ::= {od:Ted, Ui:Ti,...,u~:T.} \nM ::= {cd ~ Rcd,Vl ~ Rl,...,v~ ~ Rn} P ::= (M,e) Figure 6: Ace environments Types are used to classify \nterms. The type language includes the existential type for typing closures and the code type V[~[r-](#) \n--+ 0 for fully closed CPS functions. Moreover, types in the target language must include the region \nin which the corresponding value resides. Therefore, we use the notation cr at p for the type of a value \nof type cr in region p. To reason about the safety of programs in this language, we will often need to \nassume that a value resides in a particular region only. For example, after the copy function is finished, \nwe must be able to assume that all the data is contained only in the new region; so that the old region \ncan be safely freed, Therefore, to ensure type safety, we must be able to enforce this invariant at the \ntype level. For this, we use the built-in type operator M. The type Mp(-r) can only contain values that \nare in region p. This should be contrasted with values of type cr at p which can contain references to \nother regions that p. 6.3 The term calculus The term language must support region based memory manage- \nment and runtime type analysis New regions are created through the let region r in e construct which \nallocates a new region u at mntime and binds r to iL A term of the form put[ply allocates a value v in \nthe region p. Data is read from a region in two ways. Functions are read implicitly through a function \ncall. Data may also be read through the get v construct. Operationally, get takes a memory address u.g \nand dereferences it. Since our region calculus does not admit dangling references, and since each reference \nimplicitly carries a region handle, get does not need a region argument, as opposed to put. Deallocation \nis handled implicitly through the only A in e con- struct [23]. It asserts statically that the expression \ne can be evalu- ated using only the set of regions in A' (i.e. A extended with the cd region), which \nis a subset of the regions currently in scope. At runtime, an implementation would treat the set of regions \nin A' as live and reclaim all other regions. A'=A,cd ~[~,;A';@;FI~,,Fe A'cA\" ; A\"; 8; F I-- only A in \ne The construct I~x' restricts an environment to the set of regions in A'. I.e. q2Jzi, is the subset \nof the heap restricted to the regions in A'. Similarly, F[A, eliminates from F all variables whose type \nrefers to regions not mentioned in &#38;'. The use of only was chosen for its simplicity. Other approaches \neither do not work with a CPS language or carry a significant added complexity to handle the problem \nof aliasing whereby the program requests the deletion of region rl while r2 is still in use and might \nrefer to the same region, only side steps this difficulty by making the actual deletion implicit: instead \nof requesting deletion of r l, the program will request to keep r2 which wilt prevent rl from being deleted \nifri and r2 happen to be aliases. The runtime type analysis is handled through a typecase con-struct \n(it should arguably be called tagcase since it analyses tags rather than types). Depending on the head \nof the tag being ana- lyzed, typecase chooses one of the branches for execution. When analyzing a tag \nvariable t, we refine types containing t in each of the branches [6]. ~t:~t '.I'; A;E); F[int/t] F e~[int/t] \n~.,; A; 8; F F typecase t of (ei; e~; tlt2.ex ; t~.ea) In the ei branch, we know that the tag variable \nt is bound to Int and can therefore substitute it away. A similar rule is applied to the other cases. \n O(t)=e~ OFrl :~ OFt2 :~ 7Dtnt ~ OPt : ~ ODrl xr2 :~ ODTz : ~-} O,t:~Dr : OF\u00a2~O:f~ -OF~t.r :f~ O,t:f~Dr \n: ~ OPrl :~2 OFt2 : f2 O b TiT2 : [A;O I- or} A;O F crl &#38;;O D or2 A;Obint A;OFa~x~r2 A;O b cr pEA \nObr:f~ pEA A;O F ~ at p A;O F M~(r) '~;A;O;F b v : G vI,; A;O; P I- op : G} r(x) = %A;O;P F- rz : int \n,I,;A;O;P F- z : ~r ~(u.Q = ~ Dom(',I'); . b ~ at ~, vI,; A; O;P D u.g : ~r at t, \u00a2d,~;\u00a3~ ~ ,,I%d; cd, \n~; t :--~; z:~ D e ;~; e;r D x[t~4[q(~a).e : v[t F,q[fl(~) ~ 0 ;A;O;FFvl :a~ ~;A;O;FFv~ :~2 %A;O;FD (vx,v2) \n: ~ x o2 ~;A;O;FF-v : ~ \u00d7 ~2 ~;A;O;FF-v:~atp ~; A; O; P I-rnv : a, ~; A; O; P I-get v : Ol-r : ~ ~;A;O;Pbv:G[r/t] \n',I,;A;O;F D (t=r,v:a} : ~t:~.cr ~;A;O;P F. v : cr pEA ; A; O; P F- put[p]v : cr at p [-~; A; O; F D \ne) ~;A;O;F D v : v[t 7~][,q(#) + 0atp ;A;O;FDw, :G,[~,\u00a2/rV, t] (-)Fr,:n~ ,o, EA ~,; ~; o; r D ~,[q [,,q(,s) \nvI,;A;O;P ~ op : a ~; A;O; F,z:a }--- e ',I,; A; O; P D letz = opin e ;A;O;PDv : ~t':m.cr %A;O,t:~;P,x:G[t/t']be \n;A;O;Pf-open v as (t, z} in e %A;O;I'De~ ~;A;O;FDe2 pEA % A;O;F D ifgcp ei e2 ;A,r;O;PDe ~;A;O;FDv : \nint  ; A; O; P b let region r in e g'; A; \u00ae; F D halt v A'=A\",cO ~[zx,;A';O;Pla, l-e A'CA ; A; O; F \nI- only A\" in e %A;@;FDe i  ; A; @; P I- typecase Int of (ei; e~; tlt2.e\u00d7 ;t~.e~)  %A;\u00ae;F F e~ ,I'; \nA; O; P F typecase .~ -+ 0 of (el; e~; t~t2.e\u00d7 ; t~.e3) ; A; @; P I--. e\u00d7 [rl, r2/tl, t2]  ;A;O;F F \ntypeoase (r~ x r2) of (ei;e+;qt2.ex;t~.e~) ; A; O; P D e~[At.r/t~]  ; A; O; P ~ typecase 3t.r of (ei; \ne+ ;tlt2.e\u00d7 :t~.e~)  ; A; O; P[int/t] I- ei[int/t ] ;A;O;P I-- e~ ;A:O,t~:ft,t2:f~;F[A x t2/t] D e\u00d7[t~ \nx t2/t] % A; O, t, :~ ~ ~; P[3t.t,t/t] ~ e3[3t.t,t/t] ; A; O; F I- typecase t of (ei; e-: tlt2.e\u00d7 ; te.eg) \nFigure 7: Static semantics of Ace.   6.4 Formal properties of the language In this section, we show \nthat type checking in .aGe is decidable and that the calculus is sound. We omit the proofs due to space \nconstraints. The reader may refer to the companion technical re- port [11] for details. Proposition 6.1 \nReduction of well formed types is strongly nor-malizing. Proposition 6.2 Reduction of well formed types \nis confluent. Definition 6.3 The judgment D ( M, e) says that the machine state (M, e) is well-formed. \nIt is defined by: F M:kI, ~:Dom(~);.;.P e L (M, e) Contrary to the other environments. is not explicitly \nconstructed in any of the static rules, since it reflects dynamic information. In- stead, the soundness \nprooL or more specifically the type preserva- tion proof, needs to construct some witness ~' for the \nnew state (M', e') based on the of the initial state (M, e). Proposition 6.4 (Type Preservation) IfD \n(M, e) and (M, e) ===> (M', e') then I- (1!/1', e'). Proposition 6.5 (Progress) lfF (M, e) then either \ne = halt v or there extsts a (M', e') such that ( M, e) ~ ( M', e'). 87 ~;[\" F v :~ Here, int and inr \n(and their type-level counterparts left and right) q*;A;~;PF v : teftrr ~;A;@;r'Pv : right cr qT;A; (-); \nF ~ strip v : cr iP; A; ~;[\" F strip v : cr ;A;O;FFv : cr ~;A;@;PF v :or Cv;A;O;PFintv:leftcr ~;A;O;P \nF inrv : right c~ '~;A;O;PFv:teftcr~ A;OFrightcr~ ~; A; O;I\" F v : left cr~ + right ~2 ;A;O;FFv : Ct \n+~2 ; A; (9; P I-- ifleft x = v el e,. ~;A;O;P b- e ;A;O;FF'ul :~atp ~;,~;O;PFv2 :c\" ',I,; A;@;F F setv~ \n:= v2 ; e ;A;@;Fbv: Mp(r) ~]od; Cd,,o,p'; Olop, ; x :Op,p,(r) I- e ~; &#38;; e; F F let x = widen[p'][r](v) \nin e Figure 8: Static semantics for Accforw. 7. FORWARDING POINTERS The base algorithm presented before \nis unrealistic in a number of ways. The first is the fact that the copy function does not preserve sharing \nand thus turns any DAG into a tree. We hence need to add some form of forwarding pointers. Wang and Appel \n[25] propose to pair up every object with its forwarding pointer, incurring a significant memory cost. \nThis additional word is not unheard of, since replicating garbage collectors [16, 1] incur a similar \noverhead, justified by the desire to provide concurrent col- lection while avoiding the cost of a read-barrier. \nWe want instead to represent objects as a sum (~ + fwd ~), which requires a sin- gle bit per object and \ncorresponds much more closely to traditional implementations. To this end, ,,,kacfo~wextends Ace with \nnew types and terms for tag bits and sum types as well as memory assignment. We do not need a new fwd \nor ref type since we can use the region calculus' references for that purpose. Another requirement for \na realistic GC is that the mutator should not need to constantly check for the presence of forwarding \npointers since such a read-barrier would only be justified for an incremental GC. In other words, the \ntype as seen by the mutator should not be a sum, although it should still contain the single-bit tag \nthat the GC will use to distinguish between forwarding pointers. Also there should be a way to switch \nfrom the mutator's view of the type of an object to the one of the collector. So we also need to add \na form of cast that we call widen which we will use at the beginning of a collection to give the collector \naccess to the forwarding pointers: c~ :: .... j lefft cr I right ~ f left cq + right or2 [ Cp,p,(r) :: \n.... J inlvl inrv op :: .... [ strip v e :: .... I ifleftx = vez e,. I setv~ := v2 ; e I let x = widen[p][r](v) \nin e Figure 8 shows the relevant new rules of the static semantics. can be thought of as adding a single \ntag bit to an object while strip gets back the untagged object and ifleft checks the tag bit. The idea \nis to represent objects as (left or) to the mutator (mad without the \"right a\" alternative to avoid the \nneed for checks) and cast them with the widen operator to (left o- + right(or at to)) when entering the \ngarbage col lector (here \"to\" denotes the region for the to-space). Since a single source-level type \nnow maps to two different possi- ble types, we need two type operators: Mp(r) to map source types to \nthe mutator's view of the data and Cp. o, (r) to map source types to the collector's view (which adds \nforwarding pointers). M,(r) is the same as before for base types and for code types, but is changed for \nexistentials and pairs by adding the left constructor that con- strains the mutator to provide the tag \nbit needed to distinguish the forwarded pointer from the non-forwarded data. Mp(Int) ..... > int Mp(T \n--~ 0) ==> V[l[r](M~(r)) ~ 0 at cd (left(3t.Mp(r))) at p Mp(T1 x ~2) (left(Mp(rl) x Mo(r2)) ) at p Cp,/(Int) \nint Cp,p, (r ~ 0) Mp(r ~ 0) Cp,/(3t.r) (left(_~t.Op,p, (r)) + right(M/(3t.r))) at p , ,+left(Op,p, (71) \nx Cp,p, (T2))~ Cp/(rl X r~) ==-> ~ right(M\u00a2(q x T2)) jatp It is worth noting again here how the M type \noperators cleanly encapsulate the invariants imposed on the mutator by the collector. In this case, it \nforces the mutator to provide the collector with free bit that the collector can then use to distinguish \nforwarding pointers from non-forwarded data. And we also see how the same mecha- nism can be used to \nexpress the difference between the restricted view offered to the mutator and the full blown access to \ninternal data that the collector needs. The operational semantics of the new operations is straightfor- \nward, especially since we can implement the assignment operator by reusing the indirection through the \nmemory: (M, let x = strip (inl v) in e), ~ (M, ely/x]) (M, let :z = Strip (inr v) in e) ~ (M, e[v/x]) \n(M, ifleff x = (inl v) e, e,-) ~ (M, e,[inl v/x]) (M, ifleft x = (inr v) e~ e,.) ~ (M,e~[inrv/x]) (M, \nset u.g := v ; e) ~ (M{u.g ~ v}, e) (M, let x = widen[p][r](v) in e) ~ (M, ely/x}) The translation from \nz~CLO5to this AGCeorw is not shown since it is basically the same as before except for the insertion \nof all the inl and strip. The garbage collector can be seen in Fig. 9. Compared to the original algorithm, \nthe only difference in the 9c function itself is the widening of the heap from M,.~ to 0~.1,~2 and the \nfact that we have to bundle the f and x arguments into apair in order to pass it through the widen operator \nand unbundte it afterwards. The copy function also needs to be changed of course: when cowing a heap \nobject such as a pair, it now has to check with ifleft whether the object was forwarded, if so it just \nreturns the forwarded object, otherwise it does the copy as before and has to overwrite (using set) the \noriginal object with the forwarding pointer before returning the copied object. Since the copy is still \nfundamentally depth-first, it will loop indefinitely in the presence of a cycle. Our source calculus \ncannot create cycles in the heap, but for more realistic languages, this is a significant restriction. \n fix gc[~][r,l(f : M~., (t -~ 0), x: M,-, (t)). let region ~2 in let w = widen[~.2][(t--~ 0 x t)](put[m](inl \n(f,x)))in ifleft w = get w then let w --strip w in let y :: copy[t] [r,, 'r2}(Tr2w ) in only {r2} in \n(Tqw)[][7-2](y) else halt 0  ity of such an operator is out of the scope of this paper. In Figure 8, \nthe typing rule for widen shows that the expression e is typed in an environment that only contains x. \nIn essence :c rep- resents the entire heap. Further, x is obtained from the value v that has type Mp(r). \nLooking at the definition of M, we can see that all values reachable from v will have a type of the form \nMp(r'). Since both M and (3 are iterators, we can now define a casting op- eration from one type to the \nother as an iterator. This iterator will traverse the entire heap and systematically convert from one \ntype to fix copy[t] It,, r2](x : C,-, .,-~ (t)): M,. 2 (t). typecase t of Int ~ x tl x t2 ~ lety = getx \nin ifleft y = y then let x, = copy[tl][rl, r2](~r,(strip y))in let x2 = eopy[t2][rl, r2]Qr2(strip y))in \nlet z = put[r2](inl (x~,x2))in setx:=inrz; z else strip y 3t~ ~lety=getxin ifleft y = y then open (strip \ny) as (t, y) in let y = copy[t, tl[rl, r2](y) in let z = put[r21(inl (t=t,y: a,. 2 (t,t))) in setx:=inrz; \nz else strip Y Figure 9: GC with forwarding pointers. 7.1 How to widen safely The only non-trivial \nextension is widen which allows the garbage collector to have a different view of the existing memory, \nprovided the two views are somehow compatible. It seems difficult to solve the problem of allowing two \nviews on the same data without such a form of cast. At first, it seems we are just applying a form of \nsub- typing, but this form of subtyping is very powerful since it allows covariant subtyping of references. \nThis means that aliasing issues have to be handled with extreme care. When faced with the same problem, \nWang and Appel came up independently with a similar idea. But their suggested cast leaves many questions \nopen and might need more work to be made type- safe. Also its operational semantics actually does a complete \ncopy of the heap from one region to the other. This might make it easier to prove soundness but makes \nit unclear whether it can really be implemented as a nop. In contrast, the operatmnal semantics of widen \nis a nop and we have a proof of its soundness. In order to handle the problem of aliasing mentioned above, \nit might be possible to rely on some form of linear typing or alias types [22], but given the inherent \ngenerality of a garbage collector, it seems difficult. Our approach is to rely on the consistent ap- \nplication of the same cast over the whole heap, so that aliases are guaranteed to be cast in the same \nway (or discarded, since all fi'ee variables are thrown away). Rather than an ad-hoc widen we could provide \na more general cast that consistently applies a given type transformations (as long as it obeys the notion \nof subtyping extended with covariant subtyp- ing of references) to any particular set of regions, but \nthe complex- the other; this systematic conversion is necessary to avoid ending up with a value that \nhas a particular type along one path, but has a different type along another path. The proof of soundness \nof widen is rather intricate. It starts by ignoring some dead objects from the heap, so that only objects \nof type Mp(r) are left, which get cast to Go, o, (7-). For that reason, we need to loosen our notion \nof a well formed machine state to allow restricting the considered memory M to just a well-typed suffi- \ncient subset M, where \"sufficient\" means that no object outside of ~ is needed to complete execution. \nThis safely permits ill-typed garbage. Definition 7.1 The machine state (M, e) is well ]brmed iff m M \nc M F M:@ \u00a2;Dom(~);.;.;.F e The main stumbling block in the soundness proof is to show type preservation \nfor widen. The proof begins by constructing M which only contains objects whose type matches some Mp(7). \nThe re- sulting state is still well formed since all live data is of such a type when we reach widen. \nWe then cast every heap object from its Mp(-r) type to do, o, (~-) and show, using the subsumption rule \non sum types, that the resulting state is also well-formed and that it corresponds to the state after \nwiden. See the companion TR [11] for the complete soundness proof. 8. GENERATIONAL COLLECTION Another \nimportant aspect of a modern GC is the support for gen- erational garbage collection. If we first restrict \nourselves to a side- effect free language, then we can collect a single generation at a time so long \nas we can express the fact that an object in the old generation cannot point to an object in the young \ngeneration. To that end we need to extend Acc with existential quantification over regions, so that the \nmutator does not need to care whether an object is allocated in the young or the old region. We also \nneed to add some way to check in which region an object is allocated so that GC can detect when an object \nis in the old generation (and hence does not need copying): :: .... I 9rEA.(aat r) v:: .... I (~ ~ A--p,~,:,,) \n e :: .... [ open v as (r,x) in e I ifreg (pl = p~) et e2 .Apart from those new constructs (whose static \nsemantics is pre- sented in Fig. 10), the M type operator also needs to be modified to reflect the new \ninvariant imposed on the mutator. It is now indexed by two regions (the old and the new) and has to enforce \nthe fact that objects in the old region cannot have references to the new region: Mp~,po(Int ) ~ int \nMp~,po(r --~ O) ~ V[][ru,ro](M,.~,,.o(~')) --~ 0 at cd Mp~,po(3t.~\" ) ~ 3rE{p~,po}.((~t.M~,po(~-)) at \nr) Mp,j,po(~'l x T2) ~ ~rE {pv,po}.( (M~:p,,(T1) x M,.,po(~2)) atr) 89 IA;@ F cr ~;A;~;FF v : c7 ~;A;@;FFq \nfix gcit][ry,'r'o}(f: M,>,.o (t --~ 0),z: M.~,, ..... (t)). A'CA A,'r';Ok-cr OFT:t] plEA p~A ~;A;@;Fkv \n: c@/r]atp pEA' A'cA @;A;~O;IF F (r E A' = p,v:cr) : ~r~A'.(c~ at r) ~;A;@;I-'Fv:~r~A'.(cratr) iIJ; &#38;,r;~;I',x:c~at \nr F e ql,; A;@;F F open v as (r,x) ine ~;A;O;Fl-e2 r ~ A '.F; A; @; F P ifreg (rt = r2) el e2 @;A;@;F \nP ifreg (r = u) el ez ;A;O;F I- ifreg (u = r) el ez ~;A;(9; P F e2 ; A; (9; F F ifreg (ul --uz) el e2 \n ;A;(9;F F el  ; A; @; F t-- ifreg (ul = ul) et e2  Figure 10: Static semantics of Accge,. By using \nthe set {r, po} we make sure that if r is the old gen- eration, pointers reachable from it cannot point \nback to the new generation. The operational semantics are again rather simple: (m, open (r E A = u,v:a) \nas (r,x)in e) .==*. (M,e[u,v/r,x]) (M, ifreg (u = u) el e2) :=* (M, el) (M, ifreg (ul= u2) el e2) ==* \n(M, e2) Although the operational semantics do not take advantage of it (in order to simplify the soundness \nproof), we defined the existen- tials over regions in such a way that they can be implemented as nop \nsince the encapsulated reference usually already encodes the region in its bit-pattern (or in its u.e). \nThe new term translation is again not shown since it is so similar to the original one. The new type \nconstraint is trivially always sat- isfied as long as the mutator only allocates from the younger gener- \nation and as long as the memory is immutable. If side-effects were to be necessary, it should be possible \nto extend this scheme with one mutable region (keeping all others immutable) which would be considered \nsimilarly to the older generation but scanned at each collection. Obviously, this would first require \nadding some way to scan a region, but should not present any serious difficulty. The GC itself can be \nseen in figure 11. The main difference with the basic GC of figure 4 is that it does not copy to a new \nregion but to an existing one and stops traversing the tree as soon as we encounter a reference to the \nold generation. When hitting such an external reference, we have to repack it just to help the type-system \nunderstand that this reference is of type Mp,j,po (~-). But those operations are free anyway. let y = \ncopy[t][ry, ~'o](X)in only {to} in let region try in f[][.ry, ro](:~/) fix copy[~l[~'~,~'o](X: M,. ..in \n(t)) : M~. ....... (t). typecase ~ of Int ~ x 11 x t;~ ~ open x as (r, x} in ifreg v = 'r'o then {t- \nC {%} = r'o, x} else let x, = copy[tl] [r v , %] (Tr, (get x)) in let x2 = cop!t[t2l[r,, ro}(Tr2(get \nx)) in (r E {to} := ro,ptlt[rl(Xl,X2)) ~t~ ~ open x as (r,x) in ifreg r = ro then {r E {to} = to,X) else \nopen (get z) as (t,y)in let z = copy[t~t][ry, rol(y)in (r E {ro} = ro,pUt[r]it=t,z:M ..... (t~t))) Figure \n11: Generational GC. Note that another function needs to be written to garbage collect the old generation, \nbut that one is the same as the non-generational one. At first sight, the kccg~, language may seem unsound \nbecause we allow existentials over regions. However, these types are not existentials in a real sense \nsince they do not hide a region within a type. Rather, in the type 3r C A.(a at r), the set A is an upper \nbound on the regions that the variable v may range over. In this sense, our existential is closer to \na bounded quantification. See the companion TR [11] for the proof of soundness. 9. RELATED WORK Wang \nand Appel [23] proposed to build a tracing garbage col- lector on top of a region-based calculus, thus \nproviding both type safety and completely automatic memory management. The main weakness of their proposal \nis that it relies on a closure conversion algorithm due to Tolmach [20] that represents closures as datatypes. \nThis makes closures transparent, making it easier for the copy func- tion to analyze, but it requires \nwhole program analysis and has ma- jor drawbacks in the presence of separate compilation. We believe \nit is more natural to represent closures as existentials [10, 9] and we show how to use intensional type \nanalysis (on quantified types [21 ]) to typecheck the GC-copy function. Intensional type analysis was \nfirst proposed by Harper and Mor- risett [8]. They introduced the idea of having explicit type analysis \noperators which inductively traverse the structure of types. How-ever, to retain decidability of type \nchecking, they restrict the analy- sis to a predicative subset of the type language. Crary et al. [5] \npro- pose a very powerful type analysis framework. They define a rich kind calculus that includes sum \nkinds and inductive kinds. They also provide primitive recursion at the type level. Therefore, they can \ndefine new kinds within their calculus and directly encode type analysis operators within their language, \nThey also include a novel refinement operation at the term level. Saha et al [21] shows how to handle \npolymorphic functions that analyze the quantified type variable--this allows the type analysis to handle \narbitrary quanti- fied types. The typerec operators (e.g., Mo) used in this paper do not require the \nfull power of what is provided in [211 because our source language is only a simply typed lambda calculus. \nTorte and Talpin [19] proposed to use region calculus to type check memory management for higher-order \nfunctional languages. [5] K. Crary and S Weirich. Flexible type analysis. In Proc 1999 ACM Crary et al \n[4] presented a low-level typed intermediate language SIGPLAN lnternattmzal Cot![erence on Functional \nProgramming, pages 233-248 ACM Press, Sept. 1999. that can express explicit region allocation and deallocation. \nOur Ac:c language borrows the basic organization of memories and re- gions from Crary et al [4]. The \nmain difference is that we don't re- quire explicit capabilities--region deallocation is handled through \nthe only primitive. Necula and Lee [14, 15] proposed the idea of proof-carrying code and showed how to \nconstruct a certifying compiler for a type- safe subset of C. Morrisett et al. [13] showed that type-preserving \ncompilation via typed assembly language is a good basis for build- ing certifying compilers. This paper \nshows that low-level runtime services such as garbage collection can also be expressed in a type- safe \nlanguage. 10. CONCLUSIONS AND FUTURE WORK We have presented a type-safe intermediate language with re- \ngions and intensional type analysis and show how it can be used to provide a simple and provably type-safe \nstop-and-copy tracing garbage collector. Our key idea is to use intensional type analy- sis on quantified \ntypes (i.e., existentials) to express the garbage- collection invariants on the mutator data objects. \nWe show how this same idea can be used to express more realistic scavengers with efficient forwarding \npointers and generations. Because in- tensional type analysis is also applicable to polymorphic lambda \ncalculus [21], we believe our type safe collector can be extended to handle polymorphic languages as \nwell. We intend to extend our collector with the following features, which a modern garbage collector \nshould be able to provide: \u00ae Polymorphism Intensional type analysis is a powerful frame- work. Adding \nsupport for polymorphism is straightforward but tedious because the type system becomes a lot heavier. \n\u00ae Cyclic data structures. It might be possible to extend the current depth-first copying approach to \nproperly handle cy- cles, but we are more interested in a Cheney-style breadth- first copy [2]. Side-effects \nand generations. A first approach could be to ex- tend our current generation scheme with a third region \ncon- taining all the mutable data. But ultimately we wilt need to use either card-marking or remembered-sets \n[26]. \u00ae Explicit tag storage. Since tags exist at run time, we need to garbage collect them as well. \nThe most promising approach is to reify them into special terms as was done by Crary et al [6, 5]. This \nwill also allow us to use a simpler closure conversion algorithm for polymorphic code, eliminating the \nneed for translucent types. REFERENCES [1] G.E. Blelloch and P. Cheng. On bounding time and space for \nmultiprocessor garbage coUection. In Proc. ACM SIGPLAN \"99 Conf on Prog. Lang. Design and hnplementation, \npages 104.-117, New York, 1999. ACM Press. [2] C.J. Cheney. A non-recursive list compacting algorithm. \nCotnmun. ACM, 13(11):677-678, 1970. [3] K. Crary. Typed assembly language: Type theory for machine code. \nTalk presented at 2000 PCC Workshop, Santa Barbara, CA, June 2000. [4] K. Crary, D. Walker, and G. Morrisett. \nTyped memory management in a calculus of capabilities. In Proc. Twenty-Sixth Annual ACM SIGPL4N-SIGACT \nSyrup. on Prhwiples of Programming Languages, pages 262-275. ACM Press, 1999. [6] K. Crary, S. Weirich, \nand G Morrisett. lntensional polymorphism in type-erasure semantics. In Proc. 1998 ACM SIGPLAN International \nCm!ference on Functional Programming, pages 301-312. ACM Press, Sept. 1998. [7] O. Danvy and A. Filinski. \nRepresenting control, a study of the cps transformation. Mathematical Structures in Computer Science, \n2(4):361-39 l, 1992. [8] R. Harper and G. Morrisett. Compiling polymorphism using intensionat type analysis. \nIn Twenty-second Anmtal ACM Syrup. on Principles o['Prog. Languages, pages 130-141, New York, Jan 1995. \nACM Press [9] R. Harper and G. Morrisett. Typed closure conversion for recursively-defined functions. \nIn Second b~ternational Workshop on Higher Order Operational 7bchniques in Semantics (HOOTS98, New York, \nSep 1998. ACM Press. [10] Y. Minamide, G Morrisett, and R. Harper. Typed closure conversion. In Proc. \n23rd Amzual ACM SIGPLAN-SIGACT Syrup. on Principles q[Programmhzg Languages, pages 271-283. ACM Press, \n1996. [ 11 ] S. Monnier, B. Saha, and Z. Shao. Principled scavenging. Technical Report YALEU/DCS/TR 1205, \nDept. of Computer Science, Yale University, New Haven, CT, November 2000. [12] G. Morrisett. Open problems \nfor certifying compilers. Talk presented at 2000 PCC Workshop, Santa Barbara, CA, June 2000. [13] G. \nMorrisett, D. Walker, K. Crary, and N Glew. From system F to typed assembly language. In Symposium on \nPrinciples of Programming Languages, pages 85-97, San Diego, CA, Jan. 1998. [14] G. Necula. Proof-carrying \ncode. In Twenty-Fourth Annual ACM Symp. on Principles ~?f Prog. Languages, pages 106-119, New York, Jan \n1997. ACM Press. [15] G. Necula and E Lee. The design and implementation of a certifying compiler. In \nProc. ACM SIGPLAN '98 Conf on Prog. Lang. Design and bnplementation, pages 333-344, New York, 1998. ACM \nPress. [16] S. Nettles and J. O'Toole. Real-time replication garbage collection. In Symposium on Programming \nLanguages Design and Implementation, 1993. [17] B. Saha, V. Trifonov, and Z. Shao. Fully reflexive intensional \ntype analysis. Technical Report YALEU/DCS/TR-1194, Dept. of Computer Science, Yale University, New Haven, \nCT, March 2000. [18] Z. Shao, C. League, and S, Monnier. Implementing typed intermediate languages. In \nProc. 1998 ACM SIGPLAN btternational Conference on Functional Programming (ICFP'98), pages 313-323, September \n1998. [19] M. Tofte and J.-P. Talpin. Implementation of the typed call-by-value A-calculus using a stack \nof regions. In Proc. 21st Annual ACM SIGPLAN-SIGACT Syrup. on Principles of Programming Languages, pages \n188-201. ACM Press, 1994. [20] A. Tolmach and D. R Oliva. From ML to Ada: Strongly-typed language interoperability \nvia source translation. Journal o[\" Functional Programming, 8(4):367-412, July 1998. [21] V. Trifonov, \nB. Saha, and Z. Shao. Fully reflexive intensional type analsysis. In Proc. 2000 ACM SIGPLAN bzternational \nCot!ference on Functional Programming (ICFP'O0), pages 82-93. ACM Press, September 2000. [22] D. Walker \nand G. Morrisett. Alias types for recursive data structures. In International Workshop on Types in Comptlation, \nAug. 2000. [23] D.C. Wang and A. W. Appel. Safe garbage collection = regions + intensional type analysis. \nTechnical Report TR-609-99, Princeton University, 1999. [24] D.C. Wang and A. W. Appel. Type-preserving \ngarbage collectors (extended version). Technical Report TR-624-00, Princeton University, 2000. [25] D.C. \nWang and A. W. Appel. Type-preserving garbage collectors. In Proc. 28th Annual ACM SIGPLAN-SIGACT Syrup. \non Principles of Programming Languages, pages 166-178. ACM Press, 2001: [26] P. Wilson. Uniprocessor \ngarbage collection techniques. In 1992 International Workshop on Memory Management, New York, June 1992. \nACM Press. 91   \n\t\t\t", "proc_id": "378795", "abstract": "<p>Proof-carrying code and typed assembly languages aim to minimize the trusted computing base by directly certifying the actual machine code. Unfortunately, these systems cannot get rid of the dependency on a trusted garbage collector. Indeed, constructing a provably type-safe garbage collector is one of the major open problems in the area of certifying compilation.</p><p>Building on an idea by Wang and Appel, we present a series of new techniques for writing type-safe stop-and-copy garbage collectors. We show how to use intensional type analysis to capture the contract between the mutator and the collector, and how the same method can be applied to support forwarding pointers and generations. Unlike Wang and Appel (which requires whole-program analysis), our new framework directly supports higher-order funtions and is compatible with separate compilation; our collectors are written in provably type-safe languages with rigorous semantics and fully formalized soundness proofs.</p>", "authors": [{"name": "Stefan Monnier", "author_profile_id": "81100545156", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "PP39047899", "email_address": "", "orcid_id": ""}, {"name": "Bratin Saha", "author_profile_id": "81100311903", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "P32179", "email_address": "", "orcid_id": ""}, {"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "PP14127817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378817", "year": "2001", "article_id": "378817", "conference": "PLDI", "title": "Principled scavenging", "url": "http://dl.acm.org/citation.cfm?id=378817"}