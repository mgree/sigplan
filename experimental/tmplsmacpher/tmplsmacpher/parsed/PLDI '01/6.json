{"article_publication_date": "05-01-2001", "fulltext": "\n Language Support for Regions David Gay and Alex Aiken* EECS Department University of California, Berkeley \n {dgay,aiken}~cs.berkeley.edu struct rlist {  ABSTRACT Region-based memory management systems structure \nmem- ory by grouping objects in regions under program control. Memory is reclaimed by deleting regions, \nfreeing all objects stored therein. Our compiler for C with regions, lZC, pre- vents unsafe region deletions \nby keeping a count of refer- ences to each region. Using type annotations that make the structure of \na program's regions more explicit, we reduce the overhead of reference counting from a maximum of 27% \nto a maximum of 11~ on a suite of realistic benchmarks. We generalise these annotations in a region type \nsystem whose main novelty is the use of existentially quantified abstract regions to represent pointers \nto objects whose region is par- tially or totally unknown. A distribution of RC is available at http://www, \ncs. berkeley, edu/~dgay/rc, tar. gz. 1. INTRODUCTION In region-based memory management each allocated \nobject is placed in a program-specified region. Objects cannot be freed individually; instead regions \nare deleted with all their contained objects. Figure l's simple example builds a list and its contents \n(the data field) in a single region, outputs the list, then frees the region and therefore the list. \nThe sameregion type qualifier is discussed below. Traditional region-based systems such as arenas [8] \nare unsafe: deleting a region may leave dangling pointers that are subsequently accessed. In this paper \nwe present RC, a dialect of C with regions that guarantees safety dynanfically. RC maintains for each \nregion r a reference count of the number of external pointers to objects in r, i.e., of pointers not \nstored within r. Calls to deleteregion fall if this count is not zero. Section 3 gives a short introduction \nto RC. RC *This work was supported in part by NASA Contract No. NAG2-1210, NSF CCR-0085949, NSF infrastructure \ngrant ACI-9619020 and DARPA contract F30602-95-C-0136. The information presented here does not necessarily \nreflect the position or the policy of the Government and no official en- dorsement should be inferred. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advan-tage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI2001 \n6/01 Snowbird, Utah, USA &#38;#169; 2001 ACM ISBN 1-58113.414-2/01/0e...$5,00 struct rlist *sameregion \nnext; struct finfo *sameregion data; } *rl, *last = NULL; region r = newregion(); while (...) { /* \nbuild list */ rl = ralloc(r, struct rlist); rl->data = ralloc(r, struct finfo); ... /* 2ili in data \n*/ rl->next = last; last = rl; } output_rlist(last); deleteregion(r); Figure 1: An example of region-based \nallocation. compiles to C, so can be used with any C compiler on any platform. While our results are \npresented in the context of a C dialect, our techniques can be used to add support for regions to other \nlanguages (Section 3). We believe that region-based programming has several ad- vantages over other memory \nmanagement techniques. First, it brings structure to memory management by grouping re- lated objects, \nmaking programs clearer and easier to write and to understand (especially when compared to using raalloe \nand free). Second, regions provide safety with good perfor- mance: on our benchmarks, regions with reference \ncounting are from 7% slower to 58% faster than the same programs using malloc/free or the Boehm-Weiser \nconservative garbage collector, and the overhead of reference counting is at most 11~o of execution time. \nFurthermore, Stoutamire [11] and our earlier study of regions [6] show that regions can be used to improve \ndata locality by providing a mechanism for programmers to specify which values should be colocated in \nmemory, as well as which values should be kept separated. Our paper makes three contributions. First, \nRC is a re- alistic proposal for adding language support for regions to mainstream languages. We have \nused RC in large applica- tions and found programming with regions both straightfor- ward and productive. \nOur second contribution, and the major change in RC over our previous system C@ [6], is the addition \nof static infor- mation in the form of three type annotations: sameregion, traditional and parentptr. \nThese annotations are based on our observations of common programming patterns in large region-based \napplications: \u00ae A pointer declared sameregion is internal, i.e., it is null or points to an object in \nthe same region as the pointer's containing object. Sameregion pointers cap- ture the natural organisation \nthat places all elements of a data structure in one region. A pointer declared traditional never points \nto an ob- ject allocated in a region, e.g., it may be the address of a local variable. The most important \nuse of traditional pointers is in integrating legacy code into region-based applications. , In RC, a \nregion can be created as a subregion of an ex- isting region. A region can only be deleted if it has \nno remaining subregions. A pointer declared parentptr is null or points upwards in the hierarchy of regions. \nThese type annotations both make the structure of an ap- plication's memory management more explicit \nand improve the performance of the reference counting as assignments to sameregion, traditional or parentptr \npointers never up- date reference counts. Excepting one benchmark in which reference counting overhead \nwas negligible, we found that between 39% and 99.98% of pointer assignments executed were to annotated \ntypes. The correctness of assignments to annotated pointers is enforced by runtime checks (Sec- tion \n3.2). Our third contribution is a type system for dynamically checked regions that provides a formal \nframework for anno- tations such as sameregion, traditional and parentptr. Analysis of the translation \nof RC programs into dang, a language based on this type system, allows us to statically eliminate the \nchecks from many runtime assignments to an- notated pointers (Section 4). The combination of type annotations \nand static elimina- tion of runtime checks reduces the largest reference counting overhead from 27% to \n11% of runtime. On two benchmarks, more than 90% of the reference counting cost is eliminated, on three \nother benchmarks between 27% and 75% of the reference counting cost is removed. Two of the three other \nbenchmarks already have very low reference counting over- head (less than 1% of total execution time). \nFor a full dis- cussion of the results, see Section 5.  2. RELATED WORK The statically checked region-based \nsystems proposed by Tofte and Talpin [13] and Crary, Walker and Morrisett [3] include type systems that \nare similar to the one used in rlang: all these systems annotate pointers with a name for the targeted \nregion. Walker and Morrisett [15] have en- riched these region type systems with a form of existentially \nquantified regions. Deline and F~hndrich [4] have designed a programming language, Vault, that incorporates \nWalker and Morrisett's type system and allows static verification of region and other resource usage. \nThere are two important differences between the type system of Walker and Morrisett and rlang's: Walker \nand Morrisett's type system can statically ver- ify the safety of deleteregion, while rlang's cannot. \n rlang can represent the type structure of any existing program. For instance, the following program \ncannot be typechecked in Walker and Morrisett's system:  region r [n] ; struct data *d[m] ; for (i \n= O; i < n; i++) r[i] = newregion(); for (i = O; i < m; i++) d[i] = ralloc(r[random(O, n)] .... ); \nThere is a type for r, but no type for d in Walker and Morrisett's type system. This code is not very \nuse-ful, but similar examples are found in real programs, e.g., one of our benchmarks contains a list \nof nested environments with each environment allocated in its own region. Declarations are looked up \nin these nested environments, with the returned pointers stored in a separate data structure. Our system \npreserves the safety of deleteregion via ref- erence counting. We believe rlang's gain in expressivity, \nwhich allows straightforward porting of existing unsafe re-gion programs to RC (even large ones such \nas the Apache web server) is in most cases worth the loss of static checking of deleteregion. In [6] \nwe found that our previous version of C with safe regions, C@, had performance and space usage competi-tive \n(sometimes better, sometimes slightly worse) with ex-plicit allocation and deallocation and with garbage \ncollec- tion. C~'s overhead due to reference counting was reason- able (from negligible to 17~6 of runtime). \nOur new system, KC, has lower reference count overhead in absolute time and as a percentage of runtime, \nallows use of any C com-piler rather than requiring modification of an existing com- piler (lcc [5] in \n[6]) and incorporates some static information about a program's region structure. Regions were used for \ndecades in practice, well before the current research interest. Ross [10] presents a storage pack- age \nthat allows objects to be allocated in specific zones. Each zone can have a different allocation policy, \nbut deailo- cation is done on an object-by-object basis. Vo's [14] Vmal- loc package is similar: allocations \nare done in regions with specific allocation policies. Some regions allow object-by- object deallocation; \nsome regions can only be freed all at once. Hanson's [8] arenas are freed all at once. Barrett and Zorn \n[1] use profiling to identify allocations that are short- lived, then place these allocations in fixed-size \nregions. A new region is created when the previous one fills up, and regions are deleted when all objects \nthey contain are freed. This provides some of the performance advantages of regions without programmer \nintervention, but does not work for all programs. None of these proposals attempt to provide safe memory \nmanagement. Stoutamire [11] adds zones, which are garbage-collected regions, to Sather [12] to allow \nexplicit programming for locality. His benchmarks compare zones with Sather's stan- dard garbage collector. \nReclamation is still on an object-by- object basis. Bobrow [2] is the first to propose the use of regions \nto make reference counting tolerant of cycles. This idea is taken up by Ichisugi and Yonezawa in [9] \nfor use in distributed systems. Neither of these papers includes any performance measurements. Surveys \nof memory management can be found in [16] for garbage collection and [17] for explicit allocation and \ndeal- location. typedef struct region *region; region newregion(void); region newsubregion(region r); \nvoid deleteregion(region r); /. ralloc, rarrayalloc are not functions (they take a type as last argument) \n*/ type *ralloc(region r, type); type *rarrayalloc(region r, size_t n, type); region regionof(void *x); \n Figure 2: Region API   3. RC From the programmer's point of view, RC is essentially C with a region \nlibrary (Figure 2) and a few type annotations (Section 3.2). RC programs can reuse existing C code, and \neven in most cases object code (this is important as the C runtime library is not always available in \nsource form), as long as the restrictions detailed in Section 3.1 are met. An overview of the implementation \nof RC is given in Section 3.3. We stress that the ideas in RC are portable to other lan- guages. In addition, \ndifferent notions of memory safety can be realised in the RC framework. The option developed in this \npaper has deleteregion abort the program when there remain references to the region. A second option \nis to simply return a failure code from deleteregion when its use would be unsafe. A third choice is \nimplicit region deletion: at var- ious times, e.g., when memory is running out, the system deallocates \nany regions whose reference count has dropped to zero. This last option provides memory safety semantics \nsimilar to traditional garbage collection. We choose to make deletaregion explicit as this makes RC \na dialect of C: if the type annotations are removed (e.g., via the C preprocessor) and a region library \nis provided, any RC program can be compiled with a regular C compiler. Of course, deleteregion is then \nunsafe. RC's reference counting scheme, which keeps a count of external references into each region, \nhas two advantages over traditional reference counting: the space overhead is low (one integer per region) \nand cyclic data structures can be used transparently as long as the cycles are contained within a single \nregion. When a cycle crosses regions, it is the pro- grammer's responsibility to break it before attempting \nto delete any of the regions involved in the cycle. 3.1 RC Restrictions RC imposes a number of restrictions \non some unsafe, low- level features of the C language. None of these would be necessary if regions were \nadded to, e.g., Java: Integers that do not correspond to valid pointers may not be cast to a pointer \ntype.  Region pointers must always be updated explicitly:  - Copying objects containing region pointers \nbyte- by-byte with char * pointers is not allowed. - Unions containing pointers are only partially sup- \nported: RC must be able to track these point- ers, so the programmer must provide functions to copy such \nunions in a type-safe way (i.e., by copying pointers from within the union iff these pointers are valid). \nObject code compiled by compilers other than RC can be used so long as this code does not write or overwrite \nany region pointers in the heap or in global variables. For example, printf can be used with no problems \nwhile memcpy and memset functions can only be used on objects containing no pointers. \u00ae RC does not currently \nsupport setjmp and longjmp. This restriction could be lifted in an implementation where reference-counting \nis integrated into the com- piler. Our current implementation does not detect these situa- tions. 3.2 \nType Annotations Our previous version of C-with-regions, C@ [6] made a type distinction between pointers \nto objects in regions and traditional C pointers (to the stack, global data, or malloc heap). Any conversion \nbetween these two kinds of pointers was potentially unsafe and could lead to incorrect behaviour. We \nnow find this approach too cumbersome: existing code cannot be used with regions without modification, \nand some code must be provided in both traditional pointer and re-gion pointer versions. RC has one basic \nkind of pointer that can hold both region and traditional pointers. Traditional C pointers are viewed \nas pointers to a distinguished \"tra-ditional region\" which contains the code, stack, global data and \nmalloc heap. Examination of our benchmarks shows that some point-ers still have properties of interest \nto both the programmer (to make the intent of the program clearer and to catch vi- olations of this intent) \nand to the RC compiler (to reduce the overhead of maintaining the reference counts). For ex- ample, in \nour moss benchmark 94% of runtime pointer as-signments are of traditional pointers in code produced by \nthe flex lexical analyser generator. RC has a traditional type qualifier (int *traditional x) which declares \nthat a pointer is null or points into the traditional region. Updating a traditional pointer never changes \nany reference counts. The compiler guarantees, by static analysis or by inser-tion of a runtime check \n(whose failure aborts the program), that only pointers to the traditional region are written to traditional \npointers. Pointers declared traditional can be used in any portion of a program where there is a need, \nfor whatever reason, to use conventional C memory man-agement. Also, pointers to functions are traditional. \nIn our lcc benchmark, 56% of runtime pointer assign- ments write a pointer to an object in region r into \nanother object in region r. Similar percentages are found in several other benchmarks. This, combined \nwith examination of our benchmarks' source code; led us to add a sameregion type qualifier for pointers \nthat stay within the same region or are null, The next and data fields of Figure 1 are examples of this \nannotation. We have found that sameregion equates well with \"part of the same data structure\" : data \nstructures that are freed all at once can be allocated within the same region, and therefore all their \ninternal pointers can be de- clared sameregion. As with the traditional annotation, writes to sameregion \npointers do not change any reference counts (they do not create or destroy any external refer- ences). \nThe compiler ensures, as for traditional pointers, that values written to sameregion pointers are either \nnull or belong to the correct region. The Apache web server uses subregions to handle sub- reque:~ts \ncreated to handle an original request. On our test input, 10% of runtime pointer assignments in Apache \nare to pointers that always stay within the same region or point to a parent region. We capture these \npointers with a parentptr type quMifier. Subregions and parentptr pointers are found in several other \nbenchmarks. Pointers from parentptr qual-ified, pointers need not be included in the reference counts \nas RC requires that subregions be deleted before their parent regions. As with the other qualifiers, \nthe compiler enforces by static analysis or a runtime check that all assignments to parentptr fields \nare correct. A final type qualifier, deletes, is used on function types to indicate functions that may \ndelete regions (see Section 3.3.2). 3.3 Implementation The implementation of RC is based on an RC-to-C \ncom- piler and a runtime library that together provide the region API of Figure 2 (Section 3.3./) and \nmaintain the region's reference counts (Section 3.3.2). By compiling to C, we are able to use RC with \nany C compiler, rather than being tied to a particular compiler as in our previous system C@ [6]. 3.3.1 \nRegion Library The implementation of the region library is similar to the one in [6]: a region, defined \nby struct region { int rc, id, nextid; struct allocator normal; struct allocator pointerfree; }; \n is composed of a reference count and two allocators, the pointerfree allocator for objects containing \nonly non-pointer data or annotated pointers, and the normal allocator for all other objects. This distinction \nreduces the cost of updating reference counts when deleting a region (see below). The id and nextid fields \nare described with the parentptr runtime check implementation below. Allocation of memory to regions \nis in blocks whose size is a multiple of the page size (currently 8KB 1) and which are aligned on a page-size \nboundary. Each page belongs to one region only and the library maintains a map from pages to regions. \nThis allows efficient implementation of the regionof function and of reference counting. 3.3.2 Maintaining \nReference Counts Reference count updates may occur on any pointer as-signment 2 and when a region is \ndeleted. Allocation and deallocation occur only once, but a pointer may be assigned many times. The straightforward \nimplementation of ref- erence count updates for pointer assignment (Figure 3(a)) takes 23 SPARC instructions, \nso maintaining reference counts is potentially very expensive. RC reduces this cost through use of the \ntype annotations of Section 3.2 and by eliminating most reference count operations for local variables. \nAssignments to sameregion, parentptr and traditional pointers only need one of the runtime checks of \nFigure 3(b) ~This page size need not be the sarne as the system's page size. 2Copies of structured types \ncontaining pointers can be viewed as copying each field individually. (a) Reference count update for \n*p = newval oldval = *p; if (regionof(oldval) != regionof(newval)) { if (regionof(oldval) != regionof(p)) \nregionof(oldval)->rc----; if (regionof(newval) != regionof(p)) regionof(newval)->rc++; }  (b) Annotation \nruntime checks for *p = newval sameregion: if (neuval &#38;&#38; regionof(neuval) != regionof(p)) abort(); \n parentptr: rn = regionof(newval); rp = regionof(p); if (newval &#38;~ !(rp->id >= rn->id R~ rp->id < \nrn->nextid)) abort(); traditional: if (newval ~ regionof(newval) !ffi traditional_region) abort(); \n Figure 3: Reference counting and annotation check-ing rather than a reference count update. These checks \ntake be- tween 6 and 14 SPARC instructions and do not need to read the value being overwritten. Section \n4.3 discusses how we eliminate a significant fraction of these runtime checks. The runtime check for \nparentptr relies on a depth-first num-bering of the region hierarchy stored in the id and nextid fields \nof each region. Our current implementation updates this numbering every time a region is created, but \nthis could easily be replaced by a more efficient scheme. The references from local variables need only \nbe included in a region's reference count when calling deleteregion. As we are compiling RC to C we cannot \nuse C@'s [6] ap- proach and have deleteregion scan the stack for point- ers to regions from local variables. \nInstead, when calling a function that may delete a region, RC increments the refer- ence count of all \nregions referred to by live local variables and decrements these reference counts on return. This ap- \nproach works well as calls to functions that may delete re- gions are much rarer than pointer assignments \nto local vari- ables. RC thus needs to know which functions may delete a region. While this information \nis easily derived using a simple whole-program analysis, we sought to maintain sepa- rate compilation \nof source files in RC. Therefore RC.requires that the programmer add a deletes keyword to each func- \ntion that may delete a region. This annotation is part of the function's type (so must also be included \nin any prototype for the function). The compiler requires that any function that calls a function qualified \nwith deletes be itself qualified with deletes. We investigated a more elaborate (and optimal) scheme \nfor placing reference count increments and decrements for local variables, but found it had little benefit \n(and sometimes a substantial compile-time cost) over the approach outlined above. Details can be found \nin [7]. When deleting a region, references from the now dead region to other regions are removed by \nscanning all the ob- jects in the region, using type information recorded when 73 program ::: fn* = \np@al3p/6.T (types) = region IT[al,...,c~] (base types) = p I R I T (region expressions) = ~r < c~1-~615 \nV 61(5 ) (region properties) struct T[p~ ..... p,~]{fieldl : ~'l ..... field,~ : ~-,~} (structure declarations) \nT: type names, p: abstract regions, R: region constants Figure 4: Region type language the objects were \nallocated. The pages of the pointerfree allocator need not be scanned as they do not contain point- ers \nto other regions. We have found that the cost of this scan operation remmns reasonable (2% or less on \nall bench- marks). However, we plan to investigate ways of reducing this cost further.  4. A REGION \nTYPE SYSTEM The type mnnotations of Section 3.2 are a simple way for the user to specify types from a \nmore general region type language (Section 4.1) which partially specifies the regions of pointers. This \ntype language is used in a simple region-based language rlang (Section 4.2). By translating RC programs \ninto rlang, our compiler for RC can check the correctness of some annotations and reduce the reference \ncount overheads in some programs (Section 4.3). 4.1 Region Types We first define a simple model for the \nheap of a region- based language. The heap H is divided into regions, each cont~ning a number of objects. \nObjects are named struc-tures with named fields containing pointers. Pointers can be null, point to objects, \nor to regions. We write AH = {T,rl,... ,r~} for the set of regions of H. We define a pax- tial order \non An : r' < r if r' is a subregion of r. The region of an object pointer is the region of the targeted \nobject. The region of a pointer v is T iff v = null. We define r _< T for all regions r. Figure 4 gives \ntypes for pointers reflecting this heap struc- ture: there are pointers to regions (region), and pointers \nto named records with named fields. Each type is anno- tated with a region expression a which specifies \nthe region to which values of that type point (... @o'). Function and non-pointer types could be added \neasily to both the heap model and type language. Region expressions are either abstract regions p or \nele- ments of the set Ca = R t2 {T} of region constants. Region constmnts denote regions that always \nexist and cannot be deleted, such as the \"traditional region\". Abstract regions denote any region in \nAs. Abstract regions are introduced existentially with the 3p/5.~ construct, which means that p is a \nregion in An that respects the property specified by boolean expression 5. For instance, the type 3p/T \n< T.T[...]@p represents an object of type T in any region (as the boolean expression is always true). \nTo simplify nota- tion, we write true as shorthand for T < T and Hp as a shorthand for 3p/true. Structure \ndefinitions are parame- terised over a set pl,...,pm of abstract regions; structure uses instantiate \nstructure declarations with a set of region expressions. Function declarations also introduce abstract \nregions (see Section 4.2). fn ::= f[pl,...,Pm]/5(xl :TX,...,X~:~',~):%5' is [p~,...,pp]Xl' ' :'rl,: ..,Xq' \n: %; s,x 8 ::= [ [ 81;82 if x 81 82 while x s I [ ] ] I X0 = Xl xo = f[al,..., XO = xl.field xl.field \n= x2 xo : null O'~,n](Xl,... ,fEn) [ xo = new T[crl .... ,a,,~](xl,... ,x,~)@x' I chk 5 Some predefined \nfunctions: newregion[]/true 0 : 3p.region@p, true newsubregion[p]/true 0 : 3p'/p' _< p.region@p', true \ndeleteregion[p]/true(r: region~p) : region~T, true regionof_T[p, Pl,...]/true(x : r[pl, . .]~p) : region~p, \ntrue Figure 5: flung, a simple imperative language with regions If two values point to the same abstract \nregion p then the values must specify objects in the same region. As a consequence, if one of the values \nis null then p = T so the other value is null too. Existentially qumntified regions must be used if two \nvalues can be null independently of each other, but point to the same region if non-null. For instance, \nin struct L[p] { v : 3p'.region~p I, next : 3p\"/p\" = T V p\" = p.L[p\"]@p\" } x :L[p]Qp x is a list stored \nin region p of arbitrary regions. Without the existentially quantified type the next field could not \nbe null as it would be in the same region as its parent (which is obviously not null if next exists). \n 4.2 Region Type Checking in rlang We chose to define rlang (Figure 5) as an imperative lan- guage both \nbecause this is closer to C and because the prop- erties of abstract regions axe flow-sensitive: they \nchange as a result of function calls, field accesses and runtime checks and so may be different at every \nprogram point. Functions f have arguments xz,...,Xn, local variables x~,... ,xq,I body s and are parameterised \nover abstract re-gions pl ..... pro. The result of f is found in variable x after s has executed. The \nset of abstract regions valid in the ar- gument and result types of f is {pl,...,pm}. The set of abstract \nregions valid in the types of local variables of f is {pl,..., pro, p~ ..... p~}. The local variables \nx~ ..... x~ must be dead before s. Functions have an input property 6 that expresses requirements that \nmust hold between the abstract region parameters at all calls to f. The output property 6' expresses \nproperties that are known to hold between the abstract region parameters when f returns. The chk 6 statement \nis a runtime check that the prop- erty specified by 6 holds. If the check fails, the program is aborted. \nInstantiation and generalisation of existential types is implicit in the rules for assignment (Figure \n6) rather than being done by explicit instantiate and generalise op- 6, L~ H s, 6' x : 7\" 6' ~ 6\" fv( \n6) U fv( 6\") C {p~ , . . . , Pro} x~ , . . . , x~ are dead before s (fndef) : ~'1 .... p~]x~ ' ! k- f[p~, \n.... pm]/6(x~ . x,~ : T,) : ~',6\" is [p[, .... ' ' : r~ .... . x~ : Tq,s,x xo : re Xl : r~ 5, L k- re \n~ T~, 6', L' 6, L ~- x0 = xl, 5' (assign) xo : TO X~ : l~@a~ x~.field : rr~ 6 A ~'T1 # T, L k\" ~o ~-~'~, \n5', L' ~, (read) 5, L t- xo = x~.field, 5' x~ : t~@a~ xl.field : T{ X2 : r2 6 A a~ # T, L k- 7\"{ ~ \"r2,6 \n,L ' ' (write) 5, L t- x~.field = x:, 5' struct T[p~,..., pm]{field~ : 7\"{,..., fieldr, : ~-~} x~ : ~ \n6~,L~ F 7\"~[o'l/pz ..... Crm/pm] ~ 7\"i,Si+l,Li+l X0 : TO X' : region@a' 5n+l,Ln+1 ~-To ~-- T[a~, .., \namigo ', 5, ' L' new) 61, L1 k- xo = new T[crl,..., Crm](Xl,..., xn)~x', 6' x0 : #0@(ro 6, L k-/he@a0 \n~--/.to@T, 5', L' fv(6') C L 6, L k- xo = null, 6' (null) 6, L k- chk 6',6 A 6'\" (check) 6, L H si,6' \n6',L82 ~\" s2,6\" 6, L~ I ~\" sI,6' 6, L~ ~-s2,6\" 6V6\",L~ ~-s,6\" 5, L ~ s~; s~, 6\" 6, L ~ if x 81 S2, 5' \nV 6\" 5, L ~ while x 8, 5 V 6\" f[p~ , . 5' 7\"', 5\" x~: ~'~ 6~,L~ ~- T~[6rl//pl,... ,Ctm/pra] ~'-Ti,Si+l,Li&#38;l \n5n+1 ~ 5'[ffl/pl ..... \u00a2rm/Pm] 6n+~ A 6\"[al/p~,..., am~pro], L,+i k- vo ~ ~'[o'~/p~,.. ., a~/p,,], 6'\", \nL' (fncall) 61,L1 k\" xo = f[al,... ,a,~](xl ..... x~),6'\" .,Pro]~ (Yl:~-~, ..Yn:<):   Assignment Ptg \nL 5 ~ 6\" fv(5\") C L cd 6 L U Ca fv(6'[cdlp]) C L 6\" A 6'[p/p'],L U {p} ~- ~ ~- ~\"[P/P'], 6'\", L' (3inst.) \n 6~5'[a'lP] 6, Lt-~-[a'/p] ~--~-',5\",L' (3gen.) 5, L i- r ~-- 3p'/5'.7\"', 5'\", L'  6, L t- 2p/6'.1\" \n~--~\", 6\", L' 5, Lk-cr~--a',51,L1 5~,Lik-a~\u00f7--a~,5~+l,Li+1 ...... 6, L t- ~ ~-- cr',6',L' a,~]@a , 6~+1 \nLm+1 6, L t- T[al,...,am]@a ~--T[a~,..., ' ' , 5, L H region~a ~--reglon~cr , 5 , L p \u00a2 L 5 ~ 5' fv(5') \nC L aE LUCR 5~a=a'  5, L F p ~- o-', 5' A p = a', L O {p} 5, L k\" a ~-\" a',5, L Figure 6: Region \nType Checking property 5\" of f describes properties of f's abstract region erations. The rest of the \nlanguage is straightforward: if parameters that hold when the function returns. If these and while statements \nassume null is false and everything parameters could be rebound, then 5\" would describe prop- else is \ntrue; new statements specify values for the structure's erties of some arbitrary regions used inside \nf rather than fields; the program is executed by calling a function called of f's abstract region parameters. \nWe assume that Ls is main with no arguments. Figure 5 also gives signatures precomputed for each statement \ns using a standard liveness for the predefined newregion, newsubregion, deleteregion analysis. and regionof_T \n(one for each structure type T) functions. The judgments 6, L ~-7-1 ~--T2,6', L' of Figure 6 check We \nwrite X[6rl/Pl,..., m/Prn] for substitution of region that a value of type r2 is assignable to a location \nof type ~'1. expressions for (free) abstract regions in region expressions, These judgments take an input \nproperty 6 and live abstract boolean expressions and types: The notation x : ~- and region set L and \nproduce an updated (as a result of binding x.field : ~- asserts that x, or a field of x, has type 7\". \nThe set abstract regions) output property 6' and live abstract region of free abstract regions of a boolean \nexpression 6 is fv(6). set Lq The (3gen.) rule allows assignment as long as ~'2 can Type checking for \nrlang (Figure 6) relies extensively on be existentially quantified to match rl. The (3inst.) ruleboolean \nexpressions specifying properties of abstract regions. allows instant:at:on of an existentially quantified \nregion into Statements of a function f are checked by the judgment a dead abstract region p, and updates \n6 and L to reflect p's 6, Ls k- s, 6'. The input property 6 describes the properties of new properties. \nIt is possible that 6 described properties f's abstract regions before executing s, the output property \nof the old value of p, these properties are removed by us-6' the properties of these abstract regions \nafter executing s. ing a new property 6\", implied by 6, that does not have p Instead of an explicit binding \nconstruct for abstract regions, amongst its free variables. Base types are assignable if their assignments \nmay bind any abstract region of the assignment region expressions match. Two region expressions match \nif target which is not in the live abstract region set LB. This 6 implies they are equal or if the abstract \nregion p of the set Ls contains f's abstract region parameters and the ab- assignment target is dead. \nIn this last case 6 is updated to stract regions used in any live variable's type. The output 75 reflect \np's new properties. The rules for assigning local variables (assign), reading a field (read) or writing \na field (write) check that the source is assignable to the target. Additionally, rea~:ling or writing \na field of x guarantees that x is not null, hence that x's region is not T. Object creation (new) is \nessentially a sequence of assignments from the field values to the fields of the newly created object, \nand of the newly created object to the new statement's target. Initialisation to null (null) requires \nonly that the target variable's region be T. After execution of a runtime check, the checked relation \nholds (check). The rules for statement sequencing, if and while state-ments are standard for a forward \ndata-flow problem. Func-tion definition (fndef) is straightforward: the result vari- able's type must \nmatch the function declaration and the function's output property must be implied by the function body's \noutput property. The most complicated rule is a call to a function f (fncall). All references to elements \nof f's signature must substitute the actual region expressions at a call for f's formal region parameters. \nThe second line checks that the call's arguments are assignable to f's parameters and that the properties \nat the call site imply f's input property. After the call, f's output property holds for the actual region \nexpressions and f's result must be assignable to the call's destination. We have proved the soundness \nof our type system, based on a natural operational semantics for rlang and a definition of consistency \nof typed values with the heap. The det~ls and proof are in [7]. 4.3 Translating RC to the Region Type \nSystem There are severals ways RC can be translated to rlang. For instasace, one could apply a \"region \ninference'-like algo- rithm [13] to RC programs, representing the results in rlaag, in an attempt to \nfind a very precise description of the pro- gram's region structure. Our goal is different: we want to \ntranslate an RC program P into an rlang program P~ that faithfully matches P, then analyse P~ to verify \nthe correct- ness of sameregion, parentptr and traditional annota- tions. We therefore perform a straightforward \ntranslation, while guaranteeing the following properties of P~: There is one region constant, RT, for \nthe \"traditional region\".  For every structured type X in P there is a structured type X[p] in P~. The \nabstract region p represents the region in which the structure is stored. So pointers to X in P' are \nalways of the form X[a]@~.  A field f in X[p] of type T which is not sameregion, parentptz or traditional \nin P can point to any re-gion. So its type in P' is 9p'.T[p']@p'. A traditional f can be null or point \nto the traditional region so its type is 3p'/p' = T v pt = RT.T[#]@pl. A sameregion f can be null or \npoint to an object in p, so its type is 3p'/p' = T V p' = p.T[p']@p'. Finally, a parentptr f can point \nupwards in the region hierarchy (which in- cludes being null as the region of null values is T), so its \ntype is 3p'/p < pt.T[p~]@p~ For example, struct L { region v; L *sameregion n; }; becomes struct LIp] \n{ v : Sp'.region@p', n : 9p'/p' = T V p' = p.L[p']@p } Global variables are represented as fields of \na Global structure, stored in the traditional region, which is passed to every function. o Every local \nvariable and function argument x in P~ is associated with a distinct abstract region p~. If x is of type \nT in P, its type becomes T[p~]@p~ in P'. Func-tion arguments are never assigned or used directly as the \nfunction result, and the destination of an assign-ment is not used elsewhere in the assignment state- \n ment. 3 o Every field assignment xl.f = x2 (with xl, x2 assumed locM) is immediately preceded by an \nappropriate run- time check: chk Px2 = TVp~2 = Pxl if f is sameregion in P; chk Pxt ~ Pz2 if f is parentptr; \nchk Px2 = T V Px2 = /:gT if f is traditional. This matches the model for these annotations given in Section \n3.2: as-signments will abort the program if the requirements of  sameregion, parentptr or traditional \nare not met. o We always represent the result of a function as an ex- istentiM type. Combined with the \nrules above, a func- tion f with one arguments of type T and result of type T ~ always has signature \n.f[p~]/5(x: T[p~l@p~) : 9pl5'.T'[p]@p, 6\" for some boolean expressions 5, 5 ~, 5\". This represen- tation \nallows us to have the same type (ignoring the boolean expressions) for a function returning the re-gion \nof its argument (myregionof) and for a function returning a new region (mynewregion): myregiono~ (P41true(~ \n:Tbq@p~) : 3p/p = px .region~p, true myne~region[pq/true(~ : T[p4~P~) : ~p/true.region@p, true  It \nis easy to verify that san rlang program with these prop- erties can be type checked, under the assumption \nthat all function input, output and result properties sets are true. The implementation of I:{C infers \nbetter properties than this simple approximation by casting the inference of input, out- put and result \nproperties as a dataflow problem: * The set of facts we consider in our analysis of a func- tion f with \nabstract regions {pl ..... Pro} are: ~r = T, cr ~ T, al < or2, ch = TYal = a2 for all a, al,c~2 {Pl,... \n,Pro} U CR. We call each of these facts a con-straint. A constraint set c corresponds to the boolean \nexpression A~ec 5. Our inference system replaces all boolean expressions by these constraint sets. We \nconservatively approximate the type checking rules for if and while by constraint set intersection. This \nis safe as  (As)v( A A 5 5EC 6EC ~ ,~E(C,'UC~) Constraint sets form a finite-height lattice under set \nin- clusion. The operations in the type checking rules are all monotonic when expressed in terms of constraint \nsets and there is a least solution (all properties set to 3This last restriction is due to the rules \nfor handling liveness in Figure 6. cfrac grobner mudlle [CC mOSS tile rc apache 6 4 3 2 !ill II!1 Ill[illi \n10 '11111  0 C@ kea GCnofoFtC C@ Ioa GC~RC C~ ~ Gcnorel:lC C@ I~ GCnorcRC :e I~a GC~mRC C@ k~a GCnomRC \nC@ lea GCnomRC Figure 7: Execution time Name Lines Number Memalloc Max use allocs (kB) (kB) cfrac 4203 \n3812425 56076 102 grSbner 3219 5971710 312992 474 mudlle 5078 1594372 22354 210 lcc 12430 1002210 55637 \n4121 moss 2675 553986 6312 2185 tile 926 10459 309 153 rc 22823 81093 4714 4214 apache 62289 164296 30806 \n78 Table 1: Benchmark characteristics. true, i.e., all constraint sets empty). Therefore it is possible \nto find the best collection of constraint sets using a greatest-fixed-point-seeking dataflow analysis \nof the whole program. This greatest-fixed-point for constraint sets is also the most precise typing possible \n(using these constraint sets). \u00ae RC restricts this dataflow analysis to a single source file by assuming \nthat any non-static C function and any function called via a function pointer has empty input, output \nand result constraint sets. The complex- ity of this analysis is O(kSn4),where k is the number of functions \nin a file, S the number of statements, and n the largest number of local variables in a single func- \ntion. We keep the analysis tractable by ignoring local variables that are effectively temporaries (all \nuses have a single reaching definition). The largest analysis time on any file in our benchmarks is 30s, \nwith all other times being less than 10s. The analysis completes in less than ls for 96% of files. Once \nthe inference is complete, we can safely eliminate any chk statement that asserts a property that is \nimplied by its input constraint set. Results of this analysis are pre- sented in Section 5.2. 5. RESULTS \nWe use a set of eight small to large C benchmarks to analyse the performance of RC: c~rac and gr~bner \nper-form numeric computations using large integers, mudlle, 1co and rc are compilers, tile and moss process \ntext and apache is a web server, Half of these programs (mudlle, lcc, rc, apache) were already region-based \n(using simple region libraries with no safety guarantees); the other half were converted to use regions \n(details can be found in [6]). The cfrac benchmark was written with explicit reference- counting; this \nhand-written reference counting is disabled Name C@ RC Region (s) (%) (s) (%) unscan (s) cfrac 0.48 6% \n0.02 0.4% .01 grSbner 0.88 7% 0.07 0.7% I .02 mudlle 0.56 13% 0.23 6%' .01 ]cc 1.14 17% 0.56 11% .07 \nmoss 0.11 2% -0.02 <0% <.01 tile 0.02 0.4% 0.00 0% <.01 rc 0.12 4% <.01 apache 0.43 8% .10 Table 2: \nReference counting overhead in RC and C~ when running cfrac with RC and conservative garbage col- lection. \nTable 1 reports the benchmarks' sizes (in lines of code) and summarises their memory allocation behaviour: \n\"number allocs\" is the number of objects allocated, \"mem alloc\" is the total amount of memory allocated \nduring exe- cution of the program, \"max use\" is the maximum amount of memory in use at any time. 5.1 \nPerformance We compared the performance of RC with our old system, C~, with conventional malloc/free-based \nmemory manage- ment and with conservative garbage collection. Measure-ments were made on a Sun Ultra \n10 with a 333Mhz Ultra-Spare II processor, a 2MB L2 cache and 256MB of memory. Figure 7 reports elapsed \ntime (from the best of five runs) for each benchmark for five compiler/allocator combinations: \"C@\" is \nour previous region compiler (we did not convert rc or apache to run under C@ as this would have required \nsubstantial effort); \"lea\" is gcc 2.95.2 with Doug Lea's mal- loc/free replacement library v2.6.64 (which \nhas much bet-ter performance than Sun's default malloc library); \"GC\" is gcc 2.95.2 with the Boehm-Weiser \nconservative garbage collector v5.3; \"norc\" is gcc 2.95.2 with our RC compiler and reference counting \ndisabled; \"RC\" is gcc 2.95.2 with our RC compiler and reference counting enabled. For the benchmarks \nwhich were originally not region-based (cfrac, gr6bner, tile, moss), the \"lea\" column is the execution \ntime obtained when running the original code. For those bench- marks which were region-based, the \"lea\" \ncolumn uses a sim- ple region-emulation library that uses raalloc and free to allocate and free each \nindividual object. The \"GC\" column uses the same code as \"lea\", except that calls to malloc are replaced \nby calls to garbage collected allocation and calls to :free are removed. RC with reference counting always \nper- 4Obtainable at ftp://g.oswego.edu/pub/misc/malloc.c cfrac grobner mudlle Icc moss tile FC 4,05 3.2 \n 5.5 -- , .............. l ,.~ i 5.5 SSl. 5 75 S.4 ~ 4 3 ~5 5.7 i s.3 5.55 5.66 3A 5.6 3.9 ~ : 3,05 \n555  5.5 , j 4.9 5,s5 3.8 5.45 45 3 5.4 4.7 3.75 2.95 5.a5 4,6 nq qsmf no nq qs Inf nc nq qs mf ~ \nnq qsml nqq$ inf no nq qa m, n\u00a2 nq q\u00a2 ~nf nc Figure 8: Execution time with sameregion~ parentptr and \ntraditional (non-zero time forms better than C@ and is faster than malloc/free or the Boehm-Weiser garbage \ncollector on cfrac, grSbner, mudlle, moss, and tile (up to 58%). At worst, RC is 7% slower (on re). Table \n2 shows the reference counting cost for C@ and RC. This cost is presented as absolute time in seconds, \nand as a percentage of execution time. For RC, we also show time spent removing references from deleted \nregions (\"Region un- scan\"). The largest reference counting overhead is for lcc at 11% of execution time. \nThe region unscan accounts for 2% or less of execution time on all other benchmarks. This table also \nshows that the better performance of RC over C@ is due not only to a better base compiler (gcc vs lcc) \nbut also to a reduction in the reference counting overhead (which is not affected by the C compiler used). \nWe discuss the per- formance anomalies (negative time for reference counting) below. 5.2 Region Type \nSystem Results We added sameregion, parentptr and traditional an-notations to all our benchmarks. Table \n3 reports the number of annotations we added, the number of lines of code we had to change to allow annotations \n(excluding the lines with the annotations themselves) and the percentage of assignment statements of \nannotated types whose safety we were able to check statically. On most benchmarks the only changes were \nthe addition of the sameregion, parentptr and traditional keywords. In grSbner, which represents large \nintegers as a structure with a pointer to a~ array, we allocated some of these struc- tures in a region \nrather than on the stack and explicitly al- located the array in the same region as the structure. This \nallowed us to declare the pointer to the array as saraeregion. We perform a similar change in lcc. In \nmoss and lcc we improve the results of constraint inference by replacing some uses of global variables \n(whose region is not tracked in our region type system) by parameters, local variables and calls to regionof \n(whose region is tracked). tO0: \"~ 20 cfrac grobnermudlle lcc moss tile tc apache Figure 9: Details of \nreference count operations Name Keywords Lines added changed cfrac grSbner mudlle Icc moss tile \n rc apache  Table 3: sameregion, static statistics 8 0 4 217 75 0 81 62 20 22 21 0 331 0 64 0 apache \n5,77 5.6 S.S 5,4 S,3 s,2 n-4 q~ ~n\u00a2 nc origin) ~o safe assigns 5O 80 88 31 89 84 11 31 parentptr and \ntraditional:  The effects on execution time of sameregion, parentptr and traditional annotations and \nof our constraint infer-ence system are shown in Figure 8. In the \"nq\" column, the annotations are ignored; \nin \"qs\" the annotations are used and checked at runtime; in \"in,\" the constraint infer- ence system has \nremoved provably safe runtime checks; in \"nc\" all runtime checks are (unsafely) removed (\"nc\" thus bounds \nthe maximum improvement our inference system can provide). Some of these results are anomalous, showing \nin- creases in execution time as less work is performed. This is particularly obvious in apache (\"in,\" \nand \"nc\" columns), but is also visible in moss and rc (\"nc\" column). Our conclu- sion is that our performance \nmeasurements are affected by noise (due to minor changes in Code and the process's envi- ronment) whose \namplitude is hard to quantify, but that this noise does not affect overall conclusions when examining \na sufficiently large set of benchmarks. The negative reference count time above is another instance of \nthis phenomenon. Figure 9 presents the runtime frequencies of several cate- gories of pointer assignments \n(excluding assignments to lo- cal variables) in our benchmarks. The \"safe\" category is the percentage \nof pointer assignments to sameregion, parentptr or traditional pointers that were shown to be statically \nsafe by our constraint inference. These require no runtime work. The next category, \"checked\", is the \npercentage of as- signments to sameregion, parentptr or traditional point-ers that required a runtime \ncheck. The final category is the difference between the top of the bar and 100% is the percentage of \nassignments that required reference counting work. The goal of our annotations is to reduce this percent- \nage; the goal of our constraint inference system is to reduce the number of \"checked\" pointer assignments. \nD\u00a5om figures 8 and 9 we conclude that our type annota- tions are important to the performance of gr5bner, \nmudlle, lcc, moss and to a lesser extent rc. The constraint infer- ence system provides useful reductions \nin reference count overhead in grSbner, mudlle, lcc and moss. For instance, without any qualifiers the \nreference count overhead of lcc would be 27% instead of 11%, and the overhead of mudlle would be 23% \ninstead of 6%. The anomalous performance results for apache prevent any useful conclusion. In all these \nbenchmarks at least 39% of pointer assignments are of anno- tated types. The programs (grSbner, mudlle, \ntile, moss) where the percentage of annotated assignments is highest are dominated by one or two data \nstructures which use an- notated types for their internal pointers (large integers in grSbner, an instruction \nlist in mudlle and the input buffer used by code produced by the flex lexical analyser generator in tile, \nmoss and mudlle). In cfrac essentially il pointer assignments are of pointers to local variables used \nfor by- reference parameters in functions with signatures such as int *pdivmod(int *U, int *v, int **qp, \nint **rp) We do not think this is representative of typical programs. The effectiveness of our constraint \ninference system in ver- ifying the safety assignments to samsregion and traditional pointers, and hence \neliminating runtime checks, is also vari- able. Most checks remain in Icc, while virtually all are eliminated \nin gr~bner, tile aIld moss. We illustrate here~ using the linked list type of Figure I, the kinds of \ncode whose safety our system successfully or unsuccessfully veri- fies. The examples will assume the \nfollowing local variables are declared: struct rlist { struct rlist *sameregion next; struct finfo *sameregion \ndata; } *x, *y; region r; struct rlist **objects[100]; A simple idiom that is successfully verified \nis the creation of the contents of x after x itself exists: x = ralloc(r, ...); x->next = ralloe(regionof(x), \n. . .) ; Similar situations often arise with imperative data struc-tures such as hash tables (as in \nmoss). The large integers in grSbner also follow this pattern. Our constraint inference system remains \nsuccessful on fairly complex loops as long as all the variables are locals or func- tion parameters. \nFor instance, we can successfully verify all the assignments in Figure 1. A more elaborate version of \nthis loop (involving inter-procedural analysis) is found in moss and is also verified. The sameregion, \nparentptr and traditional annota-tions allow verification of some code that accesses data from the heap \n(or from global variables), e.g.: x = ralloc (regionof (y) .... ) ; x->next = y->next; The traditional \nannotations in the code generated by the flex lexical analyser generator used by tile, moss and mudlle \nare more complex examples (also involving inter-procedural analysis) of this. Other constructions do \nnot work so well. Nothing is known about objects accessed from arbitrary arrays, e.g.: x = ralloc(r, \n...); x->next = objects[23] ; The parse stack used in the code generated by ttle bison parser generator \nis like the objects array and prevents ver- ification of the construction of parse trees in mudlle and \nrc (which use sameregion pointers). Most of the benchmarks allocate memory in a region stored in a global \nvariable, partly as an artifact of converting the programs to use regions (adding a region argument to \nevery function would have been painful), and partly as a result of using bison generated parsers (the \nparsing actions only have access to the parsing state and to global variables). Our region type system \ndoes not represent the region of global variables, so verification of annotations often fails in these \nprograms. Where possible, we changed these programs to keep regions in local variables, or used regionof \nto find the appropriate region in which to allocate objects. The final case which our system does not \nhandle well is hand-written constructors such as: rlist *new_rlist(region r, rlist *next) { rlist *new \n= ralloc(r .... ) ; new->next = next ; return new; }  To verify the assignment to next, our system must \nverify that at every call to new_rlist, next is null or in the same region as r. This is often not possible, \ne.g., in rc where these functions are called from a bison generated parser. It is not possible to apply \na technique similar to the first idiom and replace the allocation with: rlisz *new = ralloc(regionof \n(next), . .. ) ; because next may be null. 5  6. CONCLUSION AND FUTURE WORK We have designed and implemented \nRC, a dialect of C extended with safe regions. RC programs perform Competi- tively with malloc/free or \ngarbage collection based programs (from 7~0 slower to 58% faster) on our benchmarks. The overhead of \nsafety is low (11% or less) on all benchmarks. This overhead is achieved with the help of type annotations \nthat allow the programmer to easily declare some aspects of the program's region structure. We generalise \nthese an-notations into a type system for reference-counted region systems. Analysis of RC programs rewritten \nwith these types allows us to eliminate a substantial fraction of the runtime checks implied by the type \nannotations (from 21% to 99.99%). The current translation from RC into our region type sys- tem is very \nsimple. There is scope for both a more elaborate translation and for more annotations in RC to make a \npro- gram's region structure more explicit. ~In a new language it would be possible to have a separate \nnull value for each region, which would allow this idiom to work. It is not clear whether this would \nbe otherwise desirable. 79 7. REFERENCES [9] Y. ichisugi and A. Yonezawa. Distributed Garbage [1] D. \nA. Barrett and B. G. Zorn. Using Lifetime Predictors to Improve Memory Allocation Performance. In Proceedings \nof the ACM SIGPLAN '93 Conference on Programming Languages Design and Implementation, pages 187-196, \nAlbuquerque, New Mexico, June 1993. [2] D. G. Bobrow. Managing Re-entrant Structures using Reference \nCounts. A CM Transactions on Programming Languages and Systems, 2(3):269-273, July 1980. [3] K. Craw, \nD. Walker, and C. Morrisett. Typed Memory Management in a Calculus of Capabilities. In Conference Record \nof POPL 'gg: The 26th A CM SIGPLA N-SIGA CT Symposium on Principles of Programming Languages, pages 262-275, \nSan Antonio, Texas, Jan. 1999. [4] R. Deline and M. F~ihndrich. Enforcing High-Level Protocols in Low-Level \nSoftware. In Proceedings of the A CM SIGPLAN '01 Conference on Programming Language Design and Implementation, \nSnowbird, Utah, June 2001. [51 C. W. Fraser and D. R. Hanson. A Retargetable C Compiler: Design and Implementation. \nBenjamin/Cummings Pub. Co., Redwood City, CA, USA, 1995. [6] D. Gay and A. Aiken. Memory Management with \nExplicit Regions. In Proceedings of the A CM SIGPLAN '98 Conference on Programming Language Design and \nImplementation, pages 313-323, Montreal, Canada, June 1998. [7] D. Gay and A. Aiken. Language Support \nand Compilation Techniques for Regions. Technical Report UCB//CSD-00-1115, EECS Department, University \nof California, Berkeley, Nov. 2000. [8] D. R. Hanson. Fast Allocation and Deallocation of Memory Based \non Object Lifetimes. Software Practice and Experience, 20(1):5-12, Jan. 1990. Collection Using Group \nReference Counting. In OOPSLA/ECOOP '90 Workshop on Garbage Collection in Object-Oriented Systems, Oct. \n1990. [10] D. T. Ross. The AED Free Storage Package. Communications of the ACM, 10(8):481-492, Aug. \n1967. [11] D. Stoutamire. Portable, Modular Expression of Locality. PhD thesis, University of California \nat Berkeley, 1997. [12] D. Stoutamire and S. Omohundro. The Sather 1.1 Specification. Technical Report \nTR-96-012, International Computer Science Institute, Berkeley, CA, August 1996. [13] M. Torte and J.-P. \nTalpin. Region-Based Memory Management. Information and Computation, 132(2):109-176, Feb. 1997. [14] \nK.-P. Vo. Vmalloc: A General and Efficient Memory Allocator. Software Practice and Experience, 26(3):357-374, \nMar. 1996. [15] D. Walker and G. Morrisett. Alias Types for Recursive Data Structures. Technical Report \nTR2000-1787, Cornell University, Mar. 2000. [16] P. R. Wilson. Uniprocessor Garbage Collection Techniques. \nIn Proceedings of International Workshop on Memory Management, volume 637 of Lecture Notes in Computer \nScience, St Malo, France, Sept. 1992. Springer-Verlag. [17] P. R. Wilson, M. S. Johnstone, M. Neely, \nand D. Boles. Dynamic Storage Allocation: A Survey and Critical Review. In Proceedings of International \nWorkshop on Memory Management, volume 986 of Lecture Notes in Computer Science, Kinross, Scotland, Sept. \n1995. Springer-Verlag.  \n\t\t\t", "proc_id": "378795", "abstract": "<p>Region-based memory management systems structure memory by grouping objects in regions under program control. Memory is reclaimed by deleting regions, freeing all objects stored therein. Our compiler for C with regions, RC, prevents unsafe region deletions by keeping a count of references to each region. Using type annotations that make the structure of a program's regions more explicit, we reduce the overhead of reference counting from a maximum of 27% to a maximum of 11% on a suite of realistic benchmarks. We generalise these annotations in a region type system whose main novelty is the use of existentially quantified abstract regions to represent pointers to objects whose region is partially or totally unknown. A distribution of RC is available at http://www.cs.berkeley.edu/~dgay/rc.tar.gz.</p>", "authors": [{"name": "David Gay", "author_profile_id": "81100039538", "affiliation": "EECS Department, University of California, Berkeley", "person_id": "PP39024398", "email_address": "", "orcid_id": ""}, {"name": "Alex Aiken", "author_profile_id": "81100399954", "affiliation": "EECS Department, University of California, Berkeley", "person_id": "PP39041079", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378815", "year": "2001", "article_id": "378815", "conference": "PLDI", "title": "Language support for regions", "url": "http://dl.acm.org/citation.cfm?id=378815"}