{"article_publication_date": "05-01-2001", "fulltext": "\n Related Field Analysis Aneesh Aggarwal Keith H. Randall University of Maryland Systems Research Center \nCompaq Computer Corp. aneesh@glue, umd. edu randall @pa. dec. tom  Abstract We present an extension \nof field analysis (see [4]) called re- lated fieM analysis which is a general technique for prov- ing \nrelationships between two or more fields of an object. We demonstrate the feasibility and applicability \nof related field analysis by applying it to the problem of removing ar- ray bounds checks. For array \nbounds check removal, we de- fine a pair of related fields to be an integer field and an array field \nfor which the integer field has a known relationship to the length of the array. This related field information \ncan then be used to remove array bounds checks from accesses to the array field. Our results show that \nrelated field analysis can remove an average of 50% of the dynamic array bounds checks on a wide range \nof applications. We describe the implementation of related field analysis in the Swift optimizing compiler \nfor Java, as well as the op- timizations that exploit the results of related field analysis.  Introduction \nModem programming languages like Java are becoming popular because they provide features like type safety, \nporta- bility, object-oriented type dispatch, and automatic memory management which improve programmer \nproductivity, re-duce bugs, and improve security. These features, however, often add additional ran-time \noverhead to a program which would not be required of an equivalent C or C++ program. In order to improve \nthe feasibility of these modem languages for high-performance programming, compiler optimizations must \nremove as much of this run-time overhead as possible. This paper concentrates on removing the overhead \nof array bounds checks using a novel technique called related fieM analysts. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advan-tage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. PLD12001 6/01 Snowbird, Utah, \nUSA &#38;#169; 2001 ACM ISBN 1-58113-414-2/01/06._$5.00 Array bounds checks are required in type-safe \nlanguages to make sure that applications don't inadvertently (or mali- ciously) write data outside the \nallocated portion of an array. In Java, bounds checks throw an exception if the index of an array reference \nis negative or greater than or equal to the length of the array. Each bounds check requires only a few \ninstructions, but in tight loops which access arrays, bounds checks can add a significant overhead to \nthe program. The overheads of bounds checks can be eliminated, however, if at compile time we can prove \nthat the index of the array ref- erence will always be in bounds. The task of removing bounds checks \nfrom Java programs is well-studied [5, 8, 12, 7, 6, 9, 13, 10, 1 ]. A simple exam- ple of the type of \nbounds check that can be removed using existing techniques is the code below: int addup(int[] a) [ int \nx = 0 ; for(int i = O; i < a.length; i++) x += a[i]; return x; ] In this case, information local \nto the method is enough to deduce that the array accesses will always be in bounds. In more complicated \ncases, however, traditional techniques break down because there is no obvious relationship between the \nloop bound and the array bound. To motivate the need for related field analysis, consider the following \ncode: class IntVector [ int size; int [ ] elements; int length() [ return size; } int elementAt(int \ni) [ return elements [ i ] ; } ] int addup(IntVector v) [ int x = O; for(int i = O; i < v.length(); \ni++) x += v.elementAt(i); return x;  214 This new version of addup follows the same programming idiom \nas in the previous example, but the integer array has been abstracted to an IntVector and the array accesses \nare hidden inside the elementAt method. How might we prove that the bounds checks inside el- ementAt \nnever fail? A first step is to inline the imple- mentations of the length and elementAt methods of I \nntVector: int addup(IntVector v) [ int x = O; for(int i = O; i < v.size; i++) x += v.elements[i]; \n return x; Even after inlining, proving that no array bounds excep- tions will occur is difficult. In \norder to prove that the ac- cesses to the array v. elements are in-bounds, we need to know something \nabout the relationship between v. si z e and v. elements, length, in particular, that v. size is at most \nv. elements, length. Establishing this relation- ship is the job of related field analysis. In our example, \nif related field analysis is able to prove that the size field of an IntVector is never greater than \nthe length of the ar- ray in the elements field of the same IntVector, then we can remove the bounds \ncheck in our inlined version of addup. Using this technique, we are able to reduce by half the number \nof bounds checks executed in the SpecJVM98 benchmarks. These numbers include as a starting point only \nthose bounds checks that were not eliminated through any other means, including standard optimizations \nand field analysis [4] which akeady have removed many of the simple cases. Interestingly, our technique \ncan re-move bounds checks from complex collection classes like java. util .Vector. Thus, we think our \nanalysis pro- vides a good step towards removing the remaining unneces- sary bounds checks from Java \nprograms. In this paper, we describe our implementation of related field analysis in the Swift compiler. \nIn Section 2 we give an invariant we try to prove about two related fields, and de- scribe how we prove \nthis invariant. In Section 3 we show how to use this invariant to remove bounds checks from pro- grams. \nSection 4 discusses modifications to the basic tech- nique to handle multithreaded programs. Then, in \nSection 5 we give some examples that show where our analysis tech- nique succeeds and where it breaks \ndown. Section 6 details our performance analysis, Section 7 describes some related work, and Section \n8 concludes. Related field analysis In this section, we describe our implementation of related field \nanalysis. Related field analysis can be viewed as prov- ing an invariant about the related fields. The \ngeneral frame- work for related field analysis allows for many different types of invariants, depending \non their usefulness in opti- mization. We concentrate in this paper on proving an invari- ant that is \nuseful for removing array bounds checks. 2.1 The Invariant The invariant we use for removing array bounds \nchecks is parameterized by two fields, called a and b. We require the field a to be an instance field \nof array type, and the field b to be an instance field of integer type. The invariant we prove is the \nfollowing: Invariant 1 Let a be an instance field of class c of array type, and let b be an instance \nfield of class c of integral type. Then a = null or 0 _< b _< a.length for every instance of class c. \nThis invariant captures the situation where the array a con- tains elements of a set, list, or other \ndata structure, and the integer 13 contains the number of elements which are valid in the array a. For \nsingle-threaded programs, we require that Invariant 1 hold on entry and exit from every method in the \nprogram. The requirement for multithreaded programs is somewhat more complicated - see Section 4 for \ndetails. To provide intuition for why Invariant 1 is useful, we demonstrate how we use it to remove bounds \nchecks. Con- sider the removeLastElement method of a list abstrac- tion which might look like the following: \nObject removeLastElement( ) { if (b >= i) return a[--b] ; else return null ; ] The list abstraction \nmaintains the field b as the number of el- ements of the array a which belong to the list. If we are \nable to prove Invariant 1, then we know upon entry to this method that either a is null, or 0 _< b < \na.length. In the former case, a NullPointerException will be thrown and the bounds check is unnecessary. \n* In the latter case, combining Invariant 1 with the branch condition b > 1 proves that the access a \n[ - - b ] will always pass its bounds check. In either case the bounds check is unnecessary and can be \nremoved. 2.2 Finding related fields Our compiler performs related field analysis by trying to find a \nrelationship between every potential pair of related fields. We run our analysis for every pair of fields \na and b such that a and b are instance fields of the same object, where a has an tThe field analysis \ntechnique from [4] can be used to prove that a is always non-null and hence the null pointer check will \nnever throw an ex- ception. Class Field Code to scan public private containing class public package containing \npackage public protected containing package and subclasses non-public private containing class non-public \nnon-private containing package Table 1: Field Access Regions array type and b is an integer. We record \neach pair of fields for which we are successful in proving Invariant 1. In order to prove Invariant 1, \nit is necessary to find all accesses in the program to the fields in question. We use the same technique \nas is described in [4], where field access control modifiers are used to limit the scope of the search. \nThe mechanism is summarized in Table 1. 2.3 Computing Related Fields We prove that two fields satisfy \nInvariant 1 by looking at all assignments to the two fields. In this section, we assume a single-threaded \nprogram. We defer discussion of multi- threaded programs to Section 4. We check Invariant 1 by examining \neach method which contains an assignment to either field. We use assume-guarantee inductive reasoning \nto check Invariant 1. We as- sume Invariant 1 holds on method entry and at the return point of every \ninvocation, and prove that it holds at the call point of every invocation and on method exit. Note that \nnewly allocated, but not yet constructed, objects are initial- ized to a state that satisfies Invariant \n1. Analysis of a single method proceeds by case analysis. We analyze two types of assignments, those \nthat assign to the ar- ray field a and those that assign to the integer field b. We first examine all \nassignments to the array field a. We check that the invariant is maintained by each assignment. If a \nis assigned a null pointer, then the invariant is trivially main- tained. Otherwise, we must ensure that \nthe length of the new array is at least b. Typically, code will allocate a new array with a length that \nis a non-decreasing function of either b or the old length. Our analysis currently detects non-decreasing \nfunctions of the form f(z) = elz + e2, with el _> 1 and c2 >_ 0. We also handle the cases where a is \nassigned some- thing other than a newly allocated array, and b is assigned either 0 or a. length immediately \nbefore or after the as- signment to a. Finally, let us define dependent reads as the reads of a and b \nthat are used to calculate the new size for a or value for b. We require that no assignments to a or \nb or any method calls which might modify a or b occur be- tween any of the dependent reads and the subsequent \nwrite to a. This requirement ensures that the state of the object observed by the reads has not changed \nby the time that a is written. Next, we examine all assignments to the integer field b. For each assignment, \nwe attempt to find a preceding assign- ment to a or a preceding conditional branct~ (or both) that will \nhelp us prove that the invariant is maintained by the as- signment to b. If the assignment to b decrements \nb by k, then we require the assignment to b to be on the taken branch of a conditional instruction of \nthe form b _> k. Similarly, if the assignment increments b by k, then we require the as- signment to \nb to be on the taken branch of a conditional in- struction of the form b < a.length + k. Alternatively, \nif we find an assignment to a preceding the assignment to b, then we prove the invariant by ensuring \nthat that assignment to a increases the size of a by at least k. As in the previous case, we also have \nto ensure that no assignments to a or b or method calls which might modify a or b occur between the dependent \nreads and the write to b. Related field analysis is a fairly inexpensive analysis to perform. It requires \nonly a single pass over the methods in a program. For each method, we build the SSA graph for the method \nand perform the above analysis on it, for each a or b field accessed by the method.   3 Removing array \nbounds checks In this section, we describe how the related field analysis re- suits are used to remove \narray bounds checks in the program. Again, we assume a single-threaded program. We defer dis- cussion \nof multithreaded programs to Section 4. The related field analysis from Section 2 generates a list of \nfields which are known to be related by Invariant 1. In the optimization phase, for every array access \nin the code, we an- alyze the access to see if its associated bounds check can be removed. First, we \nconsider only array accesses whose array is directly loaded from an instance field a for which we have \na related field b. Then, we check that the index i used in the array access is non-negative and less \nthan b (any one of the b's, if there happen to be more than one associated with a). Although the techniques \nfor proving these two facts are out- side the scope of this paper, typically they will be checked using \ntraditional value-range techniques, augmented with the information contained in Invariant 1. In our compiler, \nwe use a simple intraprocedural dataflow analysis [11] to check these inequalities. For example, consider \nthe following simple loop: for(int i = O; i < b; i++) x += a[i];.  To prove that the bounds check is \nunnecessary, we ob- serve that the inequality i < b together with the inequal- ity b < a.length (from \nInvariant 1) imply the inequality \u00a3 < a.length. This fact, together with the inequality i > 0, is enough \nto prove that the array index is in bounds, so no bounds check is required. The associated bounds check \nfor that access is then removed. 4 Handling multithreaded programs The analysis from Section 2 assumes \na single-threaded pro- gram, which is an invalid assumption for many Java pro- grams. This section describes \nhow the analysis can be ex- tended to handle multithreaded programs. Although this por- tion of related \nfield analysis has not yet been implemented in our compiler, we expect that it will be straightforward \nto in- corporate. The difficulty encountered with multithreaded programs is that several threads may \nbe accessing an object at once. This interference presents two problems. First, two threads might be \nmodifying the same object at once, destroying Invariant 1 for that object. Second, the optimization phase \ndescribed in Section 3 may observe the state of an object when Invariant 1 is not satisfied (remember, \nInvariant 1 is only proved to hold on method entry and exit). We handle both of the above difficulties \nby relying on syn- chronization declarations in the user's program. We require that Invariant 1 not only \nhold on method entry and exit, but also that it hold for every object whose lock is not held by any thread. \nFurthermore, we require that all modifications of the a and b fields, as well as their dependent reads, \nare contained in a synchronized block that synchronizes on the object containing a and b. Typically, \napplication code will enforce this requirement by putting the code that accesses a and b in a synchronized \nstatement or a synchro- nized method.  Similarly, when performing the optimization phase de- scribed \nin Section 3, we must ensure that the reads of a and b are both contained in a single synchronized block \nwhich is synchronized on the object containing a and b. This rule guarantees that the optimization phase \ncan rely on Invariant 1 holding for the accessed object. Several relaxations of this requirement are \npossible. If the object containing a and b can be proved thread-local, then these extra multithreaded \nrequirements are not neces- sary. Similarly, well-behaved constructors which do not leak a reference \nto object being constructed (called leak-free con- structors in [4]) do not need synchronization. None \nof the modifications described require any more complicated analysis than the analysis required for the \nsingle-threaded case. 5 Example applications In this section, we take a closer look at some interesting \ncases where we can prove Invariant 1. In addition, we also explore cases where Invariant 1 is false, \nand where Invariant 1 is true but related field analysis is unable to prove it. These cases are examples \nwhich occur in or are derived from either the SpecJVM98 applications or the j eva. utiZ library classes. \n5.1 Helper methods A common idiom in many codes is to use a helper function to change the length of the \narray field. A typical example of this idiom is where the integer field is compared with the length of \nthe array, and if it is greater than or equal to the array length, a helper method is invoked to increase \nthe array length. The following piece of code illustrates this idiom: public class PointSet { private \nPoint[] a; private int b; public PointSet(int size) [ a = new Point[size]; b = O; } public void add(Point \nx) { if(b == a.length) increase(); a[b++] = x; ] private void increase() [ int[] d = new int[b * 2 \n+ I]; System.arraycopy(a, 0, d, 0, b); a = d;  To handle this case, we modify our analysis rules so \nthat when we find a method invocation while searching for an as- signment to a backward from an assignment \nto b, then the invoked method (if it can be determined statically) is checked for a write to a. If such \na method is found, then that method is inlined 2 and the write to a inside the helper method is used \nto check Invariant 1. In the example above, when analyzing the method add, we need to inline the method \nincrease to ensure that Invariant 1 is maintained. Currently, we only inline a single method invocation \nand disallow recursive calls or calls to other methods. Thus, we might miss more compli- cated cases \nwhere the inlined method in turn invokes another method to change the array length. A related idiom, \nwhich is also very common, is to have a constructor call another constructor to initialize the array. \nThis case is handled similarly. 5.2 Limitations of Related Field Analysis In this section, we describe \nsome of the difficulties which arise when attempting to prove Invariant I about two related fields. Some \nof these difficulties derive from the fact that Invariant 1 is simply not true. Others difficulties derive \nfrom the limitations of our analysis and could be overcome with more sophisticated analyses. We give \nan example of each. 2This inlining occurs for analysis purposes only, and has no effect on the inlining \nperformed by the rest of the compiler, problem domain run time Our first example comes from the compress \nprogram in  the SpecJVM98 benchmark. The following code appears in RFA a buffer abstraction: compress \ntext compression 9.38s jess expert system public void putbyte(byte c) db database retrieval ---102~--i3~7U \nOutBuff[OutCnt++] = c; javac Java compiler 11.56s mpeg audio deeompr. ~36Qg_L_ 6s 5.28_E jack parser \ngenerator N7500 1_ 5.77s --55j__s_ In this method, the programmer is adding another element to the array \nwithout first checking for overflow. Our related field analysis fails to remove this bounds check. However, \nit may turn out that the programmer knows some a priori bound on how many bytes will ever be written \nto the buffer, so the bounds check may be unnecessary. In fact, comments in the code indicate that the \nbuffer will overflow, but only if the compressed version of a file is larger than its uncom- pressed \nversion. The second case we examine is a situation where Invari- ant 1 is true, but is difficult to prove. \nConsider the following code: public void removeAllElements() while (count > 0) removeElement(); ] private \nvoid removeElement() { count--; } We cannot prove Invariant 1 using related field analysis, because \nwe notice that the method removeElement does an unprotected decrement of the count field (the b field \nin our analysis). To prove Invariant 1 in this case, we would have to notice that all callers of removeElement \nensure that count is not zero before calling removeElement. A more sophisticated analysis which includes \nan interprocedu- ral component would be required to handle this case.  6 Performance results In this \nsection, we demonstrate the benefits of related field analysis. We first describe the experimental setup \nand then give some performance results for the SpecJVM98 applica- tions. 6.1 Experimental setup Our \nperformance results are for the Swift compiler [11] run- ning under Tru64 Unix (formerly known as Digital \nUnix) on an XP1000 Alpha workstation. The workstation has one 667 MHz Alpha 21264 out-of-order processor, \nwhich has 64 Kbyte on-chip instruction and data caches, and a 4 Mbyte combined board-level cache. Swift \nis a complete Java opti- mizing compiler that implements numerous optimizations in addition to those \ndescribed in this paper, including: method inlining, method splitting, global common subexpression Table \n2: Experimental results for related field analysis. For each application, we give its problem domain, \nan estimated line count, and the running time using three different ver- sions of the Swift compiler. \nThe first running time is for Swift-compiled code with no related field analysis. The sec- ond running \ntime is Swift-compiled code with related field analysis tumed on. The last column shows the running time \nwhen all bounds checks in the program have been removed. E 1\u00b0\u00b0i o 90 80 0. 70 60 50 30 20 10 compr \njess javac mpeg jack Figure 1: Percentage of dynamic bounds checks removed elimination, global code \nmotion, conditional constant prop- agation, interprocedural alias analysis, exact type analysis, peephole \noptimizations, and trace scheduling. It also in- cludes an effective register allocator based on biased \ngraph coloring. Swift is written in Java and translates Java byte- codes to Alpha machine code. The generated \ncode is in- stalled into a high-performance JVM for Java 1.2 that has a mostly-copying garbage collector \nand extremely fast syn- chronization [2]. All results are for applications running with the Java 1.2 \nstandard library. Our implementation of related field analysis currently handles only single-threaded \napplications. Although more work would be required to implement the multithreaded ex- tensions described \nin Section 4, we do not expect the perfor- mance results to change significantly when this extension \nis implemented. 6.2 Performance Results We ran our compiler on a number of SpecJVM98 applica- tions to \ndetermine the effectiveness of related field analysis. 10- N -Actual perf. Q. 8- M -Max. perf. 6- N \nM N M N M N M N compr jess db javac mpeg jack Figure 2: Percentage improvement in running time. The \"N\" \nbars represent the improvement with related field analysis. The \"M\" bars represent the maximum possible \nimprovement if all bounds checks in the program are removed. The results are listed in Table 2. Figure \n2 displays the result- ing performance improvements graphically. For each appli- cation, we show the \nrunning-time improvement generated by related field analysis, as well as the running-time improve- ment \nwhen all bounds checks are removed. Figure 2 demonstrates that related field analysis achieves an average \nperformance improvement of ap-proximately 2.5%. Compared to the maximum possible average performance \nimprovement of 5%, we can see that related field analysis is able to obtain approximately 50% of the \nmaximum possible speedup. Because runtime measurements contain noise and are difficult to repeat experimentally, \nwe also show in Figure 1 the percentage of dynamically executed bounds checks removed in each application, \nmeasured by instrumenting the generated code. The general improvements seen in the timing measurements \nare echoed by the execution counts.  6.3 Analysis Apart from the applications, related field analysis \nalso ap- plies to the java. ut\u00b1l library, because this particular li- brary consists of many classes \non which related field analy- sis performs well. These classes tend to be used frequently in applications \nand hence overall performance could be im- proved with faster versions of these classes. The majority \nof the performance improvements for javac and db are due to optimization of the java. utS_l classes. \nOptimization of java. ut\u00b1l classes also helped jack and mpeg. In contrast, almost all of the improvements \nfor jess and compress are due to optimizations of the programs themselves. Related field analysis performed \npoorly on both compress and mpeg. We believe this failure is caused by these applica- tions using more \ncomplicated invariants to ensure in-bounds array accesses than our related field analysis is capable \nof discovenng. 7 Related work The problem of removing array bounds checks is well- studied, precluding \na comprehensive overview of the area. Originally, removal of bounds checks was done using genetic optimizations \nlike code motion [7]. Recently, there has been a renaissance in bounds check removal as Java has become \npopular. Techniques can be divided by the use of their underlying technology, for example theorem provers \n[13, 8, 12], linear program solvers [10], or value range propagators [5, 9]. We believe related field \nanalysis, although limited to removing bounds checks which conform to a particular invariant, is nonetheless \nan inexpensive tech- nique for achieving similar bounds-check removal rates to these other more expensive \ntechniques. Program checkers such as ESC-Java [3] allow annotations that specify properties of related \nfields that are verified as part of the checking process. In particular, ESC-Java allows the programmer \nto specify explicitly invariants like Invari- ant 1. Our compiler attempts to discover these properties \nautomatically, rather than using programmer annotations. A precursor to this work called field analysis \n[4] proves properties about individual fields, and can be used to remove many Java overheads, including \nbounds checks on fields which contain arrays of constant size. Regular field analy- sis, however, cannot \nremove bounds checks from array fields which change size. As far as we know, no systems have been proposed \nwhich perform related field analysis. 8 Conclusion We described related field analysis, an interprocedural \nanal- ysis that determines useful properties relating fields of ob- jects. We demonstrated that related \nfield analysis can be used to remove a substantial fraction of array bounds checks from application programs. \nLike field analysis [4], related field analysis does not require analysis of an entire program to be \neffective. Its strength lies in removing array bounds checks when field properties of individual fields \ndo not pro- vide enough information to do so. We implemented a working version of related field anal~ \nysis in the Swift compiler. The overall speedup obtained using this optimization ranges from 0.5% to \naround 4%, whereas the maximum performance improvement that can be obtained by removing all the bounds \nchecks ranges from 2% to around 10%. We showed that in many cases almost all of the performance improvement \ncould be exploited by our im- plementation, while in most of the other cases a considerable improvement \nwas noted. On average, about 50% of the dy- namic array bounds checks were removed by our technique. \nWe observe that with a more sophisticated interprocedural analysis, more related field information could \nbe extracted. Nevertheless, related field analysis is widely applicable and performs well, especially \nwhen applied to modular code like the Java libraries. Finally, we believe that other relations between \nfields would be useful for optimization. A similar invariant to the one we used could prove that an integer \nfield represents an index into an array field, as is often used in enumerations. Also, our technique \ncould be generalized to relate an integer field to the size of any abstract collection class, not just \nar- rays. Other types of relations that might prove useful include alias relations, type relations, and \nlifetime relations. For in- stance, if we could prove that two reference fields are never equal, then \nmemory operations on the objects contained in those fields would be reorderable. [7] V. Markstein, J. \nCocke, and E Markstein. Optimization of Range Checking. In Proceedings of the SIGPLAN '82 Sym- posium \non Compiler Construction, June 1982. [8] G. C. Necuta. Compiling with Proofs. PhD thesis, Carnegie Mellon \nUniversity, Oct. 1998. Available as tech report CMU- CS-98-154. [9] J. R. Patterson. Accurate Static \nBranch Prediction by Value Range Propagation. In Proceedings of the SIGPLAN '95 Con- ference on Program \nLanguage Design and Implementation, pages 67-78, June 1995. [10] R. Rugina and M. Rinard. Symbolic Bounds \nAnalysis of Pointers, Array Indices, and Accessed Memory Regions. In Proceedings of the ACM S1GPLAN '00 \nConference on Pro- gramming Language Design and Implementation (PLDI), pages 182-195, June 2000. [11] \nD. J. Scales, K. H. Randall, S. Ghemawat, and J. Dean. The Swift Java Compiler: Design and Implementation. \nTechnical Report 2000/2, Compaq Westem Research Laboratory, Apr. 2000. [12] N. Suzuki and K. Ishihata. \nImplementation of an array bound checker. In Conference Record of the Fourth ACM Sympo- sium on Principles \nof Programming Languages, pages 132- 143, Jan. 1977. [13] Z. Xu, B. P. Miller, and T. Reps. Safety Checking \nof Ma- chine Code. In Proceedings of the ACM SIGPLAN '00 Con- ference on Programming Language Design \nand Implementa- tion (PLDI), pages 70-82, June 2000. References [1] R. Bodik, R. Gupta, and V. Sarkar. \nABCD: Eliminating Ar- ray Bounds Checks on Demand. In Proceedings of the ACM SIGPLAN \"00 Conference on \nProgramming Language Design and Implementation (PLDI), pages 321-333, June 2000. [2] Compaq Computer \nCorporation. Compaq Fast Virtual Machine V1.2.2-4 for Alpha. At URL http ://www. compaq, com/j ava. \n[3] D. L. Detlefs, K. R. M. Leino, G. Nelson, and J. B. Saxe. Extended Static Checking. Technical Report \n159, Compaq, 1998. [4] S. Ghemawat, K. H. Randall, and D. J. Scales. Field Anal- ysis: Getting Useful \nand Low-cost Interprocedural Informa- tion. In Proceedings of the ACM SIGPLAN '00 Conference on Programming \nLanguage Design and Implementation (PLD1), pages 334-344, June 2000. [5] W. Harrison. Compiler analysis \nfor the value ranges of vari- ables. IEEE Transactions on Software Engineering, 3(3):243-250, May 1977. \n[6] P. Kolte and M. Wolfe. Elimination of Redundant Array Sub- script Range Checks. In Proceedings of \nthe SIGPLAN '95 Conference on Program Language Design and Implementa- tion, June 1995. 220   \n\t\t\t", "proc_id": "378795", "abstract": "<p>We present an extension of field analysis (sec [4]) called <i>related field analysis</i> which is a general technique for proving relationships between two or more fields of an object. We demonstrate the feasibility and applicability of related field analysis by applying it to the problem of removing array bounds checks. For array bounds check removal, we define a pair of related fields to be an integer field and an array field for which the integer field has a known relationship to the length of the array. This related field information can then be used to remove array bounds checks from accesses to the array field. Our results show that related field analysis can remove an average of 50% of the dynamic array bounds checks on a wide range of applications.</p><p>We describe the implementation of related field analysis in the Swift optimizing compiler for Java, as well as the optimizations that exploit the results of related field analysis.</p>", "authors": [{"name": "Aneesh Aggarwal", "author_profile_id": "81100022148", "affiliation": "University of Maryland", "person_id": "PP39023604", "email_address": "", "orcid_id": ""}, {"name": "Keith H. Randall", "author_profile_id": "81100063247", "affiliation": "Systems Research Center, Compaq Computer Corp.", "person_id": "P159129", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378850", "year": "2001", "article_id": "378850", "conference": "PLDI", "title": "Related field analysis", "url": "http://dl.acm.org/citation.cfm?id=378850"}