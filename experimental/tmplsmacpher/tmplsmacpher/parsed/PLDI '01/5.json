{"article_publication_date": "05-01-2001", "fulltext": "\n Enforcing High-Level Protocols in Low-Level Software Robert DeLine Manuel F&#38;hndrich Microsoft Research \nMicrosoft Corporation One Microsoft Way Redmond, WA 98052-6399  vault @ microsoft com ABSTRACT The reliability \nof infrastructure software, such as operating sys- tems and web servers, is often hampered by the mismanagement \nof resources, such as memory and network connections. The Vault programming language allows a programmer \nto describe resource management protocols that the compiler can statically enforce. Such a protocol can \nspecify that operations must be performed in a certain order and that certain operations must be performed \nbefore accessing a given data object. Furthermore, Vault enforces stati- cally that resources cannot \nbe leaked. We validate the utility of our approach by enforcing protocols present in the interface between \nthe Windows 2000 kernel and its device drivers. 1. INTRODUCTION The past several years have witnessed \nthe wide-spread acceptance of safe programming languages, due mostly to the popularity of Java. A safe \nlanguage uses a combination of exhaustive static anal- ysis and run-time checks and management to ensure \nthat a pro- gram is free from entire classes of errors, like type errors and memory management errors. \nIronically, one class of software in which the safe language movement has not made many inroads is low-level \n\"infrastructure\" software that needs to be highly reliable, like operating systems, database management \nsystems, and Inter- net servers. The exhaustive analysis that a safe language provides seems a promising \nway to increase the reliability of this class of software, for which inexhaustive methods, like testing, \nhave previ- ously proved useful but incapable by themselves of achieving the goal of high reliability. \nSuch infrastructure software manipulates many resources, like memory blocks, files, network connections, \ndatabase transactions and graphics contexts. The correctness of such software depends both on correctly \nmanaging references to these resources (no dan- gling references, no leaks, no race conditions) and on \nobeying re- source specific usage rules (for example, the order in which opera- tions on the resource \nmust be applied). Together, we refer to these as resource management protocols. Today, such protocols \nare typi- cally recorded in documentation and enforced through testing. The Permission to make digital \nor hard copies of all or part ol this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advan- tage and that copies bear this \nnotice and the full citation on the first page. To copy otherwise, to republish, to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. PLDI2001 6/01 Snowbird, Utah, \nUSA &#38;#169; 2001 ACM ISBN 1-58113-414-2/01/06...~5.00 Vault programming language provides a new feature \ncalled type guards, with which a programmer can specify domain-specific re- source management protocols. \nSuch a protocol can specify that operations must be performed in a certain order, that certain op- erations \nmust be performed before accessing a given data object, and that an operation must be in a thread's computational \nfuture ~ . Vault's type checker exhaustively seeks and reports any violation of such a protocol. In short, \nwe move the description of resource management protocols from a software project's documentation to its \nsource code, where it can be automatically enforced at compile time. To validate the utility of type \nguards, we have used them to describe and enforce resource management protocols in the ex- isting interface \nbetween the Windows 2000 kernel and its device drivers. This paper describes the resource management \nfeatures of Vault, keys and type guards, and their application to Windows 2000 de- vice drivers. In Section \n2, we discuss the general framework of type guards and its instantiation in Vault's current design. We \ninformally introduce keys through two widely known examples: memory re- gions and Unix sockets. Section \n3 explains how Vault's type system enforces resource management protocols. Section 4 describes some of \nthe protocols in the interface between the Window 2000 kernel and its drivers and how we enforce them. \nSection 5 discusses re- lated work, and Section 6 concludes.  2. DESCRIBING RESOURCE PROTOCOLS To check \nresource management protocols, Vault uses an extended notion of type checking. A typical type checker \nuses types to dis- criminate the values that the program manipulates to ensure that each operation is \napplied only to appropriate values. Vault's type system extends a type with a predicate called a type \nguard, which is an auxiliary condition on the use of a value of a given type. The Vault type checker \ntracks an abstraction of the computation's global state at each program point. For a program to access \n2 a value at a gwen program point, the value's type guard must be true in the computation's global state \nat that point. In this light, we say that a type describes which operations are valid and a type guard \nde- scribes when operations are valid. 2.1 Using Keys to Track Resources In the current design of Vault, \nthe abstract global state of the com- putation and the predicate language of type guards are intentionally \n1Statically checking whether a thread actually reaches a given op- eration is clearly undecidable. 2Accessing \na value means applying a primitive operation such as reading or writing through a pointer, or using an \narithmetic opera- tion on a numerical value. 59 kept simple to enable an efficient decision procedure. \nThe global state, called the held-key set, consists of a set of keys, which are simply compile-time tokens \nrepresenting run-time resources. Each distinct key represents a unique run-time resource in each context, \nie., two distinct keys represent two distinct resources. Keys can be neither duplicated nor lost, thereby \nproviding the fundamen- tal mechanism for tracking resource management at compile-time. Keys are purely \ncompile-time entities that have no impact on run- time representations or execution time. The atomic \npredicate of type guards is whether a given key is in the held-key set. A type guard is either true or \na conjunction of one or more of these atomic predicates. Thus, a data object is guarded by zero or more \nkeys; at a given program point, all the object's keys must be in the held-key set in order for the program \nto access the data object at that point. The type checker evaluates these predicates at compile-time. \nType guards have no impact on run-time representation or execution time. Vault's statement and expression \nsyntax is based on the C pro- gramming language [11], hence the declaration FILE input ; declares the \nvariable input to be of type FILE. The declaration K :FILE input ; declares the variable input to be \nof the guarded type K:FILE, which means that the variable has type FILE and that the key K must be in \nthe held-key set at any point in the program at which the variable input is accessed. For further expressiveness, \nthe held-key set actually tracks a lo- cal state called a key state for each key. Key states are simply \nnames. For instance, the programmer may choose to describe files as having two local states, \"open\" and \n\"closed\". A variation on the previous declaration K~open: FILE input ; declares that a key K in local \nstate open guards the variable input. In order to access this variable, the key K must be in the held-key \nset and K's local state must be open. In examples where local key states are of no importance we simply \nomit them. Depending on syntactic context, omitted key states default to a fixed unique state or represent \nany possible state. In summary, keys model two properties of resources: (1) whether a resource is accessible \n(whether the key is in the held-key set), and (2) what conceptual state a resource is in (the key's local \nstate). There are four features in Vault that are used to manipulate keys: tracked types associate keys \nwith resources; functions filter keys in the held-key set; types with key parameters specialize types \nto particular keys; and keyed variants turn keys into values and static checks into dynamic checks. Tracked \ntypes, Since Vault keeps track of the availability and state of individual run-time objects, the Vault \ntype checker needs a way to distinguish the identities of run-time objects (that is, not to confuse one \nfor another). The challenge is that the program text may contain many names for the same ran-time object \n(aliases). In Vault, a key provides a symbolic name for an object's iden- tity, and a tracked type provides \na one-to-one correspondence be- tween a compile-time key and a run-time object. The declaration tracked(R) \nT x states, as usual, that the variable x names some run-time object of type T (call it 0). Further, \nthe declaration pro- vides alias information that the type-checker checks: within the scope of the key \nR, all program names of type tracked(R) T refer to the same object 0, and no other program names refer \nto the ob- ject 0. Vault's type rules guarantee that calls to other functions that manipulate the object \n0 reflect state changes through key R as well. In short, the benefit of giving an object a tracked type \nis that the Vault type checker can trace the availability and state of that object throughout the program's \ntext; the cost is that there axe limitations on how program names may alias that object. Tracked allocation \nacts as the primitive key granting mechanism: tracked(K) point p = new tracked point {x=3; y=4;}; K:int \nx = 4; At run time, the new operation allocates a fresh point object on the heap. At compile time, the \ncompiler generates a fresh key (named K here 3) associated with the fresh data object, and adds this \nkey to the held-key set. The key K represents the availability of a mem- ory resource, namely a heap-allocated \npoint data structure. The example above also uses key K to guard the integer x; that is, the programmer \nhas chosen to tie the availability of the variable x to the availability of p. At those program points \nat which key K is in the held-key set, the program may access both p and x; at those points at which \nthe key is not in the set, the program may access neither. Sometimes, the local name of a key is not \nimportant. In those cases, the programmer may let the compiler manage the key names. tracked point p \n= new tracked point {x=3; y=4;}; This code is similar to the one above except that we can't refer to \nthe key name in this scope directly. However, since we can pass the value of p to other functions, the \nkey may be named in other scopes. The primitive key revoking mechanism in Vault is the free op-eration. \ntracked(K) point p = new tracked point {x=3;y=4;}; free (p) ; In this example, the free operation takes \nan argument of type tracked(K) T 4 and requires that key K be in the held-key set. At compile-time, after \nthe operation, key K is no longer in the held- key set. At run-time, the operation deletes the given \nheap-allocated data structure. Functions. In Vault, a function's type has a pre- andpostcon- dition, \nwhich respectively state which keys must be in the held-key set to call the function and which keys are \nin the held-key set when the function returns. For brevity's sake, the pre- and postconditions are written \ntogether as an effect clause, which states how the func- tion changes the key set. An effect clause is \nwritten within square brackets. For a given key K, the effect clause [K~a->b] states that the key must \nbe held before (in state a) and is held when the func- tion returns (in state b). The effect clause [-Kea] \nstates that the key must be held before in state a but won't be held when the func- tion returns. The \neffect clause [+K@b] states that the key is not held before but is held after the function call. Finally, \nthe effect clause [new K~b] states that on return, a fresh key (unknown to the con- text) is held in \nstate b. As a shorthand, we write [K%a] for the common case [K~a->a], and we omit key states altogether \nwhen they are of no importance. For example, the following function signature (akin to a function prototype \nin C) void felose(tracked(F) FILE f) t-F]; describes a function that takes a tracked file parameter \nwhose key 3Key names such as K are bound when first referenced and have the same scope as a program variable \nbound at that point. 4There are some restrictions on the type T, such as T must not be abstract in the \ncontext of the operation. Other restrictions have to do with keys embedded within T. is consumed by \ncalling the function. Types with key parameters. Vault supports parameterized types. The familiar case \nis to parameterize types by other types. For instance, a two-dimensional array that can be used at many \ntypes of data is declared as followsS: type array2d<type T> = T[] []; Given this type definition, array2d<float> \nis the type of a two- dimension array of floating-point numbers. Less familiarly, a Vault type may be \nparameterized by a key set. (Currently, we restrict key set parameters to singleton sets.) For instance, \nthe type declaration type guarded_int<key K> = K:int; declares a type abbreviation for a single integer \nthat is guarded with the key on which the type is instantiated. For example, the signature void foo(tracked(F) \nFILE f, guarded_int<F> gi) [F]; describes a function that takes two parameters: a tracked file f, whose \nkey is called F; and a record gi whose field x is guarded by the same key F. Since guards and keys are \npurely compile-time entities, the function foe will be compiled into a function taking an ordinary FILE \nparameter and an ordinary int parameter. Keyed variants. Vault supports algebraic data types, called \nvariants, as found in most functional languages. For example, an optional integer is described with the \nfollowing type declaration variant opt_Jar [ 'Nolnt I 'Somelnt(int) ]; This variant has two constructors, \nthe constant constructor 'Nolnt (called \"constant\" because it takes no parameters) and the construc- \ntor ' SomeInt which takes an integer parameter. The values of type opt_int are 'Nolnt and <Int(n) for \nany value n of type int. Vault's switch statement supports pattern matching over variants. Variants are \nimportant for key management in Vault because con- structors may have key parameters (written in braces). \nFor exam- ple, given the variant declaration variant opt_key<key K> [ 'NoKey [ 'SomeKey {E} ]; constructing \na value of type opt_key<K> with the constructor ' SomeKey both requires that the key K be in the held-key \nset and re- moves the key from the set. Pattern matching against a value of type opt.key<K> restores \nthe key to the held-key set in the ' SomeKey case. For example, given the following code template void \nfoo(tracked(F) FILE f) I-F] { tracked opt_key<F> flag; // F he~d on ent~jjj if (close_early) { fclose(f); \n// F not held flag = 'NoKey; // don't need F here } else { ,flag = 'SomeKey{F}; // need F, consume F \n} // whate~Jev branch was tahen, F is 9one here // code .4 switch (flag) { case <NoKey: // we don't \nget F in this case // code B case 'SomeKey: // we 9et F 4n thgs ease I/ code C fclose(f) ; // consume \nF } } 5The default bit-width of a type parameter is 32bits. Other widths must be explicitly declared \nin Vault. interface REGION { type region; tracked(R) region create() [new R]; void delete(tracked(R) \nregion) [-R]; } Figure 1: A Vault interface describing a region abstraction. the key F would appear \nin the held-key set as follows. The key is held on entry to foe. The code then determines using close_early \nwhether or not to close the file early. After the fclose in the tree branch, key F is no longer held, \nand we record this fact in the flag variable. In the false branch, we record the fact that we still hold \nthe key. Note that creating the value ' SomeKey{F} removes key F from the held-key set by conceptually \nattaching it to the flag value (there is no run-time representation for keys). Thus in code section A, \nkey F is not in the held-key set. But we can recover it by testing the value of flag. In the CNoKey case, \ncode section B still does not hold key F. In the 'SomeKey case however, the type checker knows that during \ncode section C, key F is held again. Assuming code section C does not consume key F, the call to fclose \nafter section C is valid, and all code paths of foe end in the state where key F is not held, which corresponds \nto foe's declared effect. A detail we glossed over in the code above is that the opt. key type of the \nflag variable is itself tracked. This is necessary, since the variant type may hold a key. If we allowed \nthe flag variable to be copied without tracking aliases, then key F might be extracted multiple times \nfrom flag, or worse, it might never be extracted and thus lost. The code above does not show the key \nassociated with the flag variable, but forgetting to test the flag would manifest itself by an extra \nkey at the end of the function. Using keyed variants, the programmer can turn static knowledge (whether \na particular key is held) into a dynamic value (the vari- ant). Pattern matching on keyed variants enables \nthe programmer to help the compiler recover static knowledge (whether a particular key is held) from \ndynamic values. The variant type acts as an in- variant that enables the type checker to safely move \nbetween static and dynamic knowledge regarding the held-key set. Variant types are also useful for expressing \ncorrelations between different state changes and return values of functions. This aspect of variants \nis illustrated in Section 2.3 to encode failure conditions. Together, these four features allow the programmer \nto describe a useful variety of resource management protocols. To provide fur- ther introduction to these \nfeatures, the remainder of this section applies them to two simple examples. Section 4 later shows how \nwe used these features to check some of the resource protocols in the interface between a Windows 2000 \ndevice driver and the kernel.  2.2 Checking Memory Regions With Keys A typical C program uses the functions \nmalloc and free to allo- cate and deallocate individual heap objects. An alternative is to use regions \n[18, 8], also called arenas or heaps. A region is a named subset of the heap. A program individually \nallocates objects from a region, but it deallocates the region as a whole rather than deallo- eating \nindividual objects. Based on the Work of Crary, Walker, and Morrisett [3], we can create a safe region \nabstraction in Vault, as shown in Figure 1. This interface declares an abstract type 6, called region. \nThe 6An abstract type is one whose representation is private to the mod- ule that implements the interface. \n61 extern module Region : REGION; interface SOCKET { void okay() { tracked(R) region rgn = Region.create(); \n R:point pt = new(rgn) point {x=l; y=2;}; pt.x++; Region.delete(rgn);  } void dangling() { tracked(R) \nregion rgn = Region.create(); R:point pt = new(rgn) point {x=l; y=2;}; Region.delete(rgn); pt.x++; // \nerror: ~ey R not in held-hey set } void leaky() { tracked(R) region rgn = Region.create(); R:point pt \n= new(rgn) point {x=l; y=2;}; pt.x++; // ew,ro~: e~t~a ~ey a in held-key set } Figure 2: A Vault program \nthat uses the region abstraction. The function okay correctly uses it; the function dangle ac-cesses \na dangling reference; and the function leaky contains a region memory leak. function create creates a \nnew region, which is individually tracked. The function delete deletes the region and removes its key \nfrom the key set. To allocate an object in a region, Vault pro- vides a primitive new operation taking \nthe following form: new(rgn) T [init] Given a tracked region rgn with key R, the new construct returns \nan object of type R:T, that is, an object guarded by key R. 7 Thus, this object is accessible as long \nas the region is accessible. After a call to delete, all objects allocated within a region are inaccessible. \nFigure 2 shows three functions that use this region abstraction, two of which have errors. The function \nokay correctly uses the region abstraction. Calling Region. create creates a new region whose key we \nlabel R. The point object pt is allocated from this region and is guarded with the key R. The increment \nto pt's field x requires pt's guarding key R to be in the held-key set, which it is. Finally, the call \nto Region. delete deletes the region and removes its key from the held-key set, thereby invalidating \naccess to the variables rgn and pt. The function dangling reverses the region delete operation and the \nincrement of pt's field x. Because the effect of calling Region. delete removes the key R from the held- \nkey set, the increment expression is incorrect since it requires the key R. The function leaky contains \na more subtle error. Because this function has no explicit effect clause, it promises that the pre and \npost key set will be the same (no keys added, no keys removed). Because there is no call to Region.delete, \nthe function has one extra key (R) in the held-key set at the end of the function than it did at the \nbeginning. Hence the function's implementation violates its (implicit) effect clause, which is an error. \nThis region interface thus catches both dangling references and memory leaks. 7We ignore the possibility \nof allocation failure here. In practice, new returns a variant indicating success or failure. type sock; \n variant domain [ 'UNIX l 'INET ]; variant comm_style [ 'STREAM I 'DGRAM ]; tracked(@raw) sock socket(domain, \ncomm style, int); struct sockaddr { ... }; void bind(tracked(S) sock, sockaddr) [S@raw->named]; void \nlisten(tracked(S) sock, int) [S@named->listening]; tracked(N) sock accept(tracked(S) sock, sockaddr) \n[S@listening, new N&#38;#169;ready]; void receive(tracked(S) sock, byte[]) [S@ready];  void close(tracked(S) \nsock) I-S]; } Figure 3: A Vault interface that describes a socket abstraction. 2.3 Checking Sockets \nWith Keys Connection-oriented sockets are a popular software abstraction for inter-process and inter-machine \ncommunication in client/server ar- chitectures. Developing a server for such an architecture can be error-prone \nbecause setting up the socket to accept connections and communicate through them involves several steps---omitting \none or more of these steps is a common beginner's mistake. To prevent such mistakes, we can create a \nVault interface to a socket library like that in Figure 3. This interface uses the ability for keys to \nhave states to enforce the necessary steps to create a connection-oriented socket that is ready to receive \nmessages. The function socket cre-ates a new socket whose key is in the \"raw\" state. We can see that \nin order to receive a message on a socket, its key must be in the \"ready\" state. The effect clauses for \nthe functions bind and listen show how these functions change the state of the key from \"raw', to \"named\" \nand from \"named\" to \"listening;' respectively. Finally, the function accept takes a tracked socket whose \nkey S is in the \"listening\" state and returns a new tracked socket whose key N is in the \"ready\" state, \nthe state needed to receive a message. This interface to sockets is somewhat naive, in that it ignores \nthe possibility of failure. To describe, for example, the fact that the bind operation can fail, we can \nchange its function signature to the following: variant status<key K> [ 'Ok {K~named} I 'Error(error_code){K&#38;#169;raw} \n] ; tracked status<S> bind(tracked(S) sock, sockaddr) [-S~raw] ; The bind function now consumes the tracked \nsocket's key in the \"raw\" state and returns a variant. This variant has two constructors: the ' Error \nconstructor describes the failure case and its parameter provides an error code that explains the error; \nthe ' Ok constructor describes the success case. Both constructors have attached the key K, but in different \nstates. In the ' Ok case, the socket has correctly changed to the \"named\" state, whereas in the 'Error \ncase, the socket remains in the \"raw\" state. The use of this variant type forces the programmer to check \nthe status result of calling bind. Consider a program that forgets to check the status result: tracked(&#38;#169;raw) \nsock mysocket = socket('UNIX, 'INET,O) ;  62 bind(mysockez ,mysockaddr) ; listen(mysocket,O) ; // error,! \n Here, the call to bind removes the socket's key from the held-key set, hence the precondition for listen \nis violated. In order to call listen, the programmer must first check the status result from bind: tracked(@raw) \nsock mysocket = socket('UNIX,'INET,O) ; switch (bind(mysocket,mysockaddr)) { case 'Ok: listen(mysocket,O) \n; // Ok%/ now. case 'Error(code) : // Report an error.  } By checking the return status, the 'Ok case \nputs the socket's key back in the held-key set in state \"named\", which makes the call to listen legal. \nIn the 'Error case, we have the key in the \"raw\" state and can for example try another bind operation \n 2.4 Limitations of the Approach Extending a type system to track compile-time names for resources has \ntwo limitations to consider: resources kept in collections be- come \"anonymous;\" and the types of values \nmust agree at program join points. Tracking arbitrary numbers of resources. Given that Vault uses compile-time \nnames to track resources, how can Vault statically track an unbounded number of resources? In previous \nex- amples, the programs dealt with fixed numbers of resources whose keys were given names statically \nbound in the program's text A programmer obviously cannot write down static names for an un- known number \nof resources. Using anonymous tracked types gets around this problem. For instance, we can declare the \ntype of a list that contains an unbounded number of tracked regions: variant reglist ['Nill COons(tracked \nregion, tracked reglist)] ; The type reglist allows the program to store an unbounded num- ber of regions. \nHowever, placing a region on such a list makes it \"anonymous\"-that is, we lose track of exactly which \nkey guards which region. For example, the program in Figure 4 creates a region and allo- cates a point \ndata structure out of the region. To access this point, its guarding key R must be in the held-key set. \nOnce we put the region in the list, we lose the key K. (Since keys cannot be dupli- cated, we cannot \nboth put the region with its key on the list and retain the key.) We then take the same region back out \nof the list by pattern matching. However, by placing the region on the list, its key becomes \"anonymous\" \n- the type checker knows that some key is associated with the tracked region but does not know that this \nkey is the same as the key K. Hence, incrementing pt's x field is illegal since this requires the key \nK and instead the held-key set contains some fresh key. (To fix the error in this program, we could use \na list of pairs of regions and points, that is a list of type type regptpair = (tracked(R) region, g:point); \nvariant regptlist ['Nill 'Cons(tracked regptpair, tracked regptlist)] ; which maintains the correlation \nbetween the region's key and the point's key guard ) In short, the Vault type checker can track both \na fixed number of resources whose keys have statically bound names and an arbitrary number of resources \nwhose keys are anonymous. void main() { tracked(R) region rgn = Region.create(); R:point pt = new(rgn) \npoint {x=4;y=2;}; tracked reglist list = 'Cons(rgn,'Nil); II ~e ~ost ~ey R. switch(list) { case 'Cons(rgn2,_): \n// We got some ~e~ bae~, pt.x++; // Buy! We need ~e~ R. } Figure 4: An illegal Vault program that illustrates \nthe \"anonymizing\" aspect of tracked collections. void main() { tracked(R) region rgn = Region.create(); \n It:point pt = new(rgn) point {x=4;y=2;}; if (pt.x > O) { pt.y = O; Region. delete (rgn) ; } else \n p~.y = pt.x; // Bug! jo'~n point ~ncons~stent if (p'e.x <= 0) Region. delete (rgn) ;  Figure 5: An \nillegal Vault program that uses data correlation to encode a region's availability. The type theory behind \nthis \"anonymity\" is discussed in the next section. Type agreement at loin points. Consider the program \nin Figure 5, which correlates the value of the variable pt. z and the region rgn's deletion status. Although \nthis program is, in fact, memory-safe, the Vault type checker will reject it. At the com- mented join \npoint, the held-key set either does or does not contain the key R, depending on which branch is taken. \nAs a result, the type checker cannot know whether the precondition for the subse- quent call to Region. \ndelete is satisfied. The limitation that types must agree at program join points is a common limitation \nof the type checking approach to program verification In order to make the example acceptable to Vault. \nthe corelation between the sign of pt. x and whether or not we hold key 1~ needs to be made explieit \nusing a keyed variant, similarly to the example in Section 2.1. In- stead of correlating the two tests \nwith the condition on pt. x, the second branch would switch on a variant initialized in the branches \nof the first test. 3. VAULT'S TYPE SYSTEM Vault's type system is based on the Capability Calculus [3] \nand alias types [15, 20]. The language's complete typing rules are lengthy. Here we only sketch how tracked \ntypes and type guards are repre- sented in the underlying type language and the overall structure of \nthe type checker Because Vault's typing rules are very similar to the Capability Calculus, we rely on \ntheir soundness proof to ensure the soundness of Vault's type checking. The type checker's job is to \ntranslate the Vault surface syntax kinds ::= Type [ Key ] KeySet I State variables 12 contexts N ::= \n\"IN, v:~IN key set C ::= e key set variable [ 0 empty key set [ {r@st ~ or} key mapping I C1 @ C2 key \nset union key T ::= p key token state st ::= 5 state variable I 6 < shame bounded variable [ shame state \ntoken ] T default state existentials ::= 3[NIC].a existential type types V[N].v universal type C t> r \nguarded type p named type s(r) singleton type (7-1 .... , ~r~) tuple type a type variable (C, a) ~ (C', \no') function type [ Vl(al)l... IV~(a~) ] variant type Figure 6: Underlying type language types to the \ninternal type language in Figure 6 and to assign internal types to the program's terms (statements and \nexpressions). We dis- cuss the roles that these various types play below. Part of the type checking is \nstandard: for each lexical scope, the type checker keeps an environment that maps program names to types, \nkeys, etc., and checks inductively that each program term is applied to subterms of the correct type. \nIn addition, the type checker ensures that no type guards are vi- olated. To do this, the type checker \nforms a control flow graph for each function and computes the held-key set before and after each node \nin the graph. The held-key set before the function's entry node is the precondition key set from the \nfunction's effect clause. The type checker ensures that the held-key set at each of the func- tion's \nexit nodes is the postcondition key set from the function's effect clause. On control-flow join points, \nwe abstract over the actual names of local keys in incoming key sets so as to analyze the remainder of \nthe control-flow graph only for distinct alias relationships of local variables. Imperative loops may \nrequire declared loop invafiants, unless the invariant can be inferred in a fixed number of iterations. \nLoop invariants take the form of a function type with multiple out- comes, one for each possible loop \nexit. Inputs to the function are the variables that are used within the loop. For all of the loops in \nour device driver case study, the type checker automatically infers the loop invariants, since they are \ntrivial. 3.1 Tracking aliases The key to ensuring that a program does not reference a resource after \nthat resource has been released is to keep track of the various names by which the program refers to \nthe resource. Without track- ing aliases, a program could delete a resource through one name and then \nreference it through another. In Vault, a key s serves as a unique name for a resource; the type checker \nuses the same key to refer to the resource, no matter how many aliases for this resource the program's \ntext contains. A type tracked T in the surface syntax, which gives rise to a key, is translated to a \nsingleton type s(r) in the internal type lan- guage. Such a singleton type represents the run-time value \n(handle) used to manipulate the unique resource whose key is r. Every alias for the resource in the program \ntext is given the same singleton type s(r). Hence, given the pair of assignments tracked region rgnl \n= Region.create(); tracked region rgn2 = rgnl; Both the variables rgnl and rgn2 are assigned the same \nsingleton type s(r) for some fresh r. Calling Region. delete on either rgnl or rgn2 deletes the key r \nfrom the held-key set, which prevents the region from being referenced under either name after the deletion. \nAnother important aspect of tracking aliases is ensuring that keys are never duplicated. For instance, \nif the type system were to allow a region's key to end up twice in the held-key set, then a program that \ndeletes the region twice would type check correctly, but would cause an error at run time. 3.2 Functions \nWhereas Vault's surface syntax for functions combines a function's pre- and postcondition into a single \neffect clause, the internal func- tion type (C, a) ~ (C', a') separates them into the key set C that \nmust be held to call the function and the key set 6\" that is held after the function returns. Functions \nin Vault are always polymor- phic. First a function is polymorphic in the keys of its arguments. For \nexample, the function signature void fclose(tracked(F) FILE) [-F] ; can be called on any tracked file, \nregardless of its particular key. Second, since the state of key F is omitted here, the function is polymorphic \nin the state 6 of F. Third, a function affects only those keys mentioned in its signature; other keys \nin the held-key set are irrelevant. To make a Vault function callable from many different contexts, we \nmake its type polymorphic over the \"rest\" of the held- key set not mentioned in the function's signature. \nGiven these three forms of polymorphism, the function fcloee above is assigned the type VpF.Vt.Ve.(e \n~ {pF~t~ ~ FILE}, S(pF)) ~ (e, void). The variable e refers to the \"rest\" of the held-key set that the \nfunc- tion does not affect, the variable pF refers to key F, and the variable 6 refers to the state of \nthat key. This function can be called on any value of type s(p) at any program point whose held-key set \nincludes some key p associated with type FILE.  3.3 Existential types Existential types are useful for \nencoding that certain values carry capabilities with them. The existential type 3[NIC].r represents a \nvalue of type v, holding on to capabilities C. The existentially bound variables N provide a way to abstract \nthe actual names used for keys, states, and types in C and r. For instance, consider a function whose \nsignature is tracked region create() ; Calling this function returns a tracked region, that is, it returns \nboth Sin the Capability Calculus, a key is called a resource and a key set is called a capability. a \nnew resource and the key needed to access that resource. This function is assigned the type Ve.(e, void) \n--> (e, Sir: Keyl{rQT ~ region}], s(r)). The returned existential type binds together both the new region \n(the singleton type) and the key needed to access that region. To access a value of an existential type, \nthe type must first be un-packed. Unpacking means creating fresh names for the existentially bound variables \nand acquiring the capability carried by the value. Clearly, since unpacking yields a capability, values \nof existential types cannot be freely copied by a program, for otherwise capabil- ities could be duplicated. \nTo control the duplication of existential types which carry capabilities, we maintain the invariant that \nenvi- ronments map program variables to unpacked types v only. Thus, existential types must be unpacked \nbefore they are bound in the environment. For example, function parameters are unpacked on entry to a \nfunction. Existential types are the basis for keeping \"anonymous\" tracked resources in collections. For \ninstance, the type reglist in the pre- vious section has the following type in the internal type language: \n[ 'Nill 'Cons(3[pl : Key, p2 : Key I {pi@T ~ region} {p~T ~ reglist}].    <s(p~), s(p2))) ] Each \nelement in this list is of existential type. To use an element from this list, it must first be unpacked, \nwhich generates a fresh name for the existentially bound key. This is the technical sense in which these \nkeys are \"anonymous.\" Our use of existential types is related to the unique types of the programming \nlanguage Concu~ent Clean. In Clean, a unique type is written ~-'. Its equivalent Vault type is 3[p : \nKey I {p@T ~-}]. s(p), i.e., an anonymous tracked type. However, Clean does not support named tracked \ntypes and is thus unable to express alias relationships. 4. CASE STUDY: WINDOWS 2000 DRIVERS Device drivers \npose an important reliability risk to operating sys- tems, since drivers generally execute in the kernel's \nprotected mode. Because a device driver is used in many different machine configurations and sits within \na multithreaded kernel, reproducing erroneous behavior in a driver is very difficult. Hence, testing \nhas not proven to be a good way to achieve high reliability in drivers. In this section, we describe \nhow Vault's type checker catches at com- pile time many of the errors that are difficult to reproduce \nat mn time. What is the difficulty in writing a correct device driver? Typi- cally, the company that \nmanufactures a device also provides the de- vice driver for it. Because the developer creating the device \ndriver is very familiar with the device itself, the interface between the driver and the hardware, though \ncomplex, is not often the source of e~ors. Instead, faults often lie in the interface between the device \ndriver and the kernel. This interface is quite complex, in part due to the variety of devices that interact \nwith the kernel and in part due to the need for good performance. One source of complexity in the interface \nbetween the kernel and a driver is its asynchronous nature. A driver provides a collection of services \nto the kernel, like starting the device, reading from the device, writing to the device, and shutting \ndown the device. The driver is implemented as a module with one function per service. However, the lifetime \nof a request to the driver is not the same as the lifetime of a call to the corresponding service function. \nTo keep the \" ' \" ' kernel from blocking on a driver request, a driver s serwce functm n is expected \nto return quickly, regardless of whether the driver has completed the request. To achieve the desired \nasynchronous interface in Windows 2000, each request is encapsulated in a data structure, called an I/O \nRe- quest Packet (IRP). The kernel passes this data structure to the driver when it calls one of its \nservice functions, and the driver handles the request by updating this data structure over time. Whenever \nthe driver completes a request, it calls the function IoCompleteRequeston the IRP to signal the completion \nto the kernel and to return the IRP. As a further complication, a driver does not work in isolation, \nbut instead sits within a driver stack For example, in between the ker- nel and a floppy disk drive would \ntypically sit the following drivers, in order: a file system driver; a driver for a generic storage device; \na floppy disk driver; and a bus driver. Each driver in the stack may choose to handle a request itself, \nto pass the request down to the next driver in the stack, or to pass a new request (or set of requests) \ndown to the next driver in the stack. Finally, as part of the kernel, a device driver must deal with \nthe contingencies of kernel-level programming. For instance, at any given moment, the processor can be \nat one of several interrupt lev- els. The processor's current interrupt level governs both which ker- \nnel functions can be called and what memory is available. The kernel's memory space is divided into those \npages that the virtual memory system manages and those that are locked down and there- fore always accessible. \nA pointer to a block of paged memory can only be accessed if the particular page is known to be resident \nor if the current interrupt level is such that the virtual memory sys- tem can handle a page fault to \nmake the page resident If a driver dereferences a pointer to a non-resident paged block when the in- \nterrupt level prevents the the virtual memory system from running, the entire operating system deadlocks. \nThis section shows how each of these aspects of device drivers can be described in Vault. To test our \nideas, we wrote a Vault de- scription of the interface between the Windows 2000 kernel and a device driver. \nWe then translated an existing driver for a floppy disk device from C (4900 lines) into Vault (5200 lines). \n9 This Vault driver uses the Vault interface to interact with the kernel and is therefore subject to \nthe checking we describe in this section. We then used the Vault compiler to compile the driver's source \ncode into C. In some cases we chose to deviate from the original kernel interface, for example, by choosing \nto represent a status code with a variant rather than an integer in order to allow static checking. As \nsuch. our driver could not be directly linked against the origi- nal kernel. Instead, we wrote a thin \nwrapper in C to make up for these differences in data representation The driver linked with the wrapper \nruns successfully under Windows 2000, although it is not of production quality due to incomplete modeling \nof memory allo- cations and deallocations. We also have not run any performance measurements on the resulting \ncode. 4.1 I/O Requests Packets The Windows 2000 documentation describes an \"ownership\" model for the \nI/O Request Packets (IRPs). Initially, the IRP \"be- longs\" to the kernel. When the kernel calls a driver's \nservice func- tion, it gives ownership of the IRP to the driver. The driver can then take one of three \nactions: it can complete the request by calling IoCompleteRequese, which gives ownership of the IRP back \nto the kernel; it can call IoCallVriver to pass ownership of the IRP down to the next driver in the stack; \nor it can call 9So far, we have not concentrated on keeping Vault as syntacti- cally close as possible \nto C. Hence these numbers do not reflect an inherent blow-up in using Vault's type system. Evaluating \nthe programming burden of Vault's annotations is future work. IoMarkIrpPending to retain ownership of \nthe IRP after the call to the service function. A driver may only legally access an IRP when it has ownership \nof it. This IRP ownership model corresponds naturally to tracked types. In Vault, a typical driver service \nroutine is given the fol- lowing signature: DSTATUS<I> Read(DEVICE_0BJECT, tracked(I) IRP) [-I];  The \nsignature states that a service routine obtains the ownership of the parameter IRP and does not pass \nthe ownership back to the caller. Furthermore, the service routine must return a value of type DSTATUS<I>, \nwhich we use to enforce that one of the three possible functions mentioned above are called: DSTATUS<I> \nIoCompleteReqnest(traeked(I) IRP, NTSTATUS) I-I] ; DSTATUS<I> IoCaliDriver(DEVICE_0BJECT, tracked(I) \nIRP) [-I]; DSTItTUS<I> IoMarkIrpPending(traeked(I) IRP) [I]; Since we keep the type DSTATUS<I> abstract \nfrom the service rou- tine, and since the type of the return status is parameterized by the key I of \nthe IRP request, the only way a service routine can gen- erate a DSTATUS<I> value is by calling one of \nthe above functions in the context of that particular invocation. This avoids the com- mon error that \nsome drivers exhibit code paths on which IRPs are neither completed, passed on, nor pended. We leave \nit up to the driver to manage queues of pending IRP requests, thus IoMarkIrpPending does not consume \nthe IRP key. A driver consumes the key by storing the IRP on a pending list, thus anonymizing and packaging \nthe key with the IRP.  4.2 Thread Coordination The Windows 2000 kernel provides several thread coordination \nmechanisms, one of which is events. An event allows one thread to block until another thread takes some \naction. Our Vault descrip- tion of events can be used to pass a key from one thread to another, thereby \ncoordinating access to whatever data that key protects: type KEVENT<key K>; KEVENT<K> KeIntializeEvent<type \nT>(tracked(K) T) [K]; void KeSignalEvent(KEVENT<K>) [-K] ; void KeWaitEvent (KEVENT<K>) [+K] ; The initialization \nfunction takes a tracked object whose key is to be transferred from one thread to another. In a multithreaded \nprogram, there is one key set per thread. To pass the key between threads, the first thread calls KeWaitEven~ \nand blocks until the second thread calls KeSignalEvent. After the call to KeSignalEvent, the sec- ond \nthread no longer has the key in its held-key set, while the first thread unbloeks and gains the key in \nits held-key set. As is typical of Windows 2000 drivers, the floppy driver uses this event mecha- nism \nto pass IRP ownership from one driver to another, as described in the next section. We can similarly \ndescribe kernel spin locks in Vault: type KSPIN_LOCK<key K>; KSPIN_LOCK<K> KeInitializeSpinLock<type \nT>(tracked(K) T) [-K] ; void KeAcquireSpinLoek(KSPIN_L0CK<K>) [+K] ; void KeReleaseSpinLock(KSPIN_LOCK<K>) \nI-K] ; This interface protects against common locking errors. First, once a lock has been created on \na tracked data object, the only way to ac- cess the object is first to acquire the lock. Second, in the \nsame way that Vault can detect memory leaks (by finding keys in a function's final held-key set that \nwere not promised in its signature's post key set), Vault can similarly detect missing lock releases. \nThird, since a key cannot appear in the held-key set multiple times, Vault will detect when a program \nacquires a lock that it already holds, since the second acquire will introduce a key into the held-key \nset that is already present. This approach however is inadequate to model reentrant locks.  4.3 I/0 \nRequest Completion Routines As mentioned earlier, when a driver passes an IRP down to the next driver \nin the stack (by calling IoCallDriver), it loses ownership of the IRP. However, a driver often needs \nfirst to pass an IRP to the next lower driver and then to regain ownership of the IRP after the lower \ndriver has completed it. To do this, a driver attaches a completion routine to the IRP, which is a function \nthat is called on the IRP when the lower driver completes it. If a driver's comple- tion routine returns \na status of \"more processing required\" then the driver once again gains ownership of the IRP. We describe \ncompletion routines in Vault with the following def- initions: variant C0MPLETION_RESULT<key I> [ 'MoreProees \nsingRequired I 'Finished(NTSTATUS) {I} ] ; type COMPLETION_ROUTINE<key K> = tracked COMPLETION_RESULT<K> \nRoutine( DEVICE_0BJECT, tracked(K) IRP) [-K]; void I oSetComplet ionKout ine ( tracked(I) IRP, COMPLETION_ROUTINE<I>) \n; The function IoSetCompletionRoutine sets an IRP's comple- tion routine, which is a function that takes \na device object and a tracked IRP and consumes the IRP's key. The code in Figure 7 shows shows a common \nidiom for regain- ing ownership of an IRP after it is passed to a lower driver. The code uses a completion \nroutine to learn when the lower driver has finished and an event to resume processing where it left off \nbefore calling the lower driver. The figure shows a service function for a \"plug and play\" re- quest, \nlike a request to shut down the device. The function first de- clares an event, IrpIsBaek, which is parameterized \nby the IRP's key, and declares the local function RegainIrp. The function PnpRequest then sets the IRP's \ncompletion routine to the func- tion RegainIrp and passes the IRP down to the next driver with a call \nto IoCallDriver. After this call, ownership of the IRP has been passed to the next driver, which is reflected \nin the fact that the key I is no longer in the held-key set. The function then waits for the event IrpIsBack. \nWhen the lower driver com- pletes the IRP, the kernel owns the IRP until it calls the com- pletion routine \nRegainIrp. The completion routine in turn sig- nals the event IrpIsBaek, thereby passing ownership back \nto the PnpRequest function. The completion routine returns the sta- tus 'MoreProcessingRequired to tell \nthe kernel that this driver has once again accepted ownership of the IRP.~\u00b0 When the call to l\u00b0A careful \nreader might be concerned that the completion rou- tine could signal that the driver owns the IRP, but \nthen for- get to return 'MoreProcessingRequired-a situation that would lead to a dangling reference. \nThis in fact cannot happen since the only other constructor for this variant ('Finished) takes the IRP's \nkey as a parameter, a key which is no longer in the held-key set after the call to KeSignalEvent. Given \nthe deft- 66 NTSTATUS PnpRequest(DEVICE_0BJECT Dev, tracked(I) IRP Irp) [-I] { KEVENT<I> IrpIsBack \n= KeInitializeEvent(Irp); COMPLETION_RESULT<I> Regainlrp(DEVICE_0BJECT Dev, tracked(I) IRP Irp) [-I] \n{ KeSignalEvent(IrpIsBack); return ~MoreProcessing~equired; } IoSetCompletionRoutine(Irp, RegainIrp); \n status = IoCallDriver(nextDriver, Irp); // key I no longer in heZd-key set KeWaitForEvent(IrplsBack); \n // ~e~ I ~s bach ~n he~d-~e~ set } Figure 7: A driver uses an event and a completion routine to regain \nownership of an IRP after passing it to a lower driver. KeWaitForEvent returns, key I again appears in \nthe held key set. The code after the call to KeWaitForEvent is therefore free to ac- cess the variable \nIrp.  4.4 Interrupt Levels and Paging To represent the processor interrupt level (or IRQL, in Windows \n2000 tenninology), we use two details of Vault that were previously unmentioned. First, although keys \ntypically arise from tracked types, a programmer can also statically declare a key. Second, we can optionally \ndefine a partial order over the states of a key and constrain state variables by states. Using both these \nfeatures, we represent the current processor interrupt level as a global key IKQL: s%ateset IRq_LEVEL \n= [ PASSIVE_LEVEL < APe_LEVEL < DISPATCH_LEVEL < DIRQL ]; key IRQL @ IRQ.LEVEL; Given these definitions, \nwe can describe the preconditions of var- ious kernel functions. The function KeSetPriorityThread re-quires \nthe interrupt level to be at PASSIVE_LEVEL: KPRIORITY KeSetPriorityThread (KTHREAD, KPRIORITY) [ IRQL \n~ PASSIVE_LEVEL ]; The kernel function KeReleaseSemaphore is more flexible. It requires the interrupt \nlevel to be less than or equal to DISPATCH_LEVEL: long KeReleaseSemaphore (KSEMAPHORE, KPKIORITY ,long) \n[ IRQL @ (level <= DISPATCH_LEVEL) ]; This function is polymorphic in the local state of the key IRQL \nas captured by the explicit state variable level, which is upper- bounded by state DISPATCH_LEVEL. Finally, \nthe function Ke- AequireSpinLock is more complicated. It requires that the in- terrupt level be less \nthan or equal to DISPATCH.LEVEL on entry nition of the variant COMPLETION..KESULT, if a completion rou- \ntine consumes its IRP parameter, it has no choice but to re-turn 'MoreProcessingRequired, since no other \noption will type check. and raises the interrupt level to DISPATCH_LEVEL on exit. It also returns as \nits result a value that represents whatever the interrupt level was on entry. Given the definitions above \nand a type KIRQL that is parameterized by a state (which is similar to having a type parameterized by \na key), we can describe this complex behavior: type KIRQL<state S>; KIRQL<IeveI> KeAcquireSpinLock (KSPIN_LOCK) \n[ IRQL @ (level <= DISPATCH_LEVEL) -> DISPATCH_LEVEL ] ; Like the previous kernel function, this function \nuses bounded poly- morphism over the local state of the key IRQL. Further, it uses the state variable \nlevel to refer to the state of key IRQL at the call site in order to reflect this level in the result \ntype. Finally it uses the ar- row notation to state that the function changes the key IRQL's state from \nthe state represented by level to the state DISPATCH_LEVEL. The examples above thus make use of constrained \nstate variables of the form sv <= st. The type checker uses the partial order specified in stateset \ndeclarations to determine when such con- straints are satisfied. Using constrained states, we can describe \ntypes TT in paged mem- ory by introducing a type guard on the interrupt level. type paged<type T> = \n(IR~L ~ (ieveI<=APC_LEVEL)):T; A value of a paged type may thus only be accessed at program points where \nthe interrupt request level is at or below APO_LEVEL, ensuring that the page handler can service possible \npage faults. In-ternally, a paged type paged<T> is represented as V[5 : State].{IRQL~(6 < APC_LEVEL) \n~-> void} t> T If a driver accesses data in paged kernel memory at an interrupt level that prevents \nthe virtual memory system from running, the result is unpredictable behavior: if the data's page happens \nto be resident, then :the access is fine; otherwise, the kernel deadlocks when it tries to run the virtual \nmemory system. Such a subtle error is very difficult is reproduce and correct. By using the interrupt \nlevel to guard data in paged memory, the Vault type checker finds such errors at compile time. 5, RELATED \nWORK Our work is inspired in part by the typestate approach provided in the programming language NIL \n[ 17, 16]. In NIL, states are attached to objects along with their types. NIL does not allow any aliasing \nof objects, thus severely restricting the class of programs that can be expressed in NIL. The work involving \nthe calculus of capabilities by Crary, Walker, Smith, and Morrisett [3, 19, 15, 20] shows how to track \nstates of objects in the presence of aliasing. The essential improvement over the typestate approach \nis to add a level of indirection between ob- jeets and their state through keys. Now the non-aliasing \nrequire- ment is confined to keys whereas the aliasing relationships among objects are made explicit. \nThis work provides the theoretical basis for Vault's type system. Our system differs in minor details \nsuch as using direct pre/post conditions of functions instead of continu- ation-passing style, which \nleads us to infer join-point abstractions or reanalyzing path fragments under different key sets. A more \nfundamental difference introducing a number of complications is exposing this rich type language to the \nprogrammer in an intuitive way. In order to allow general graph structures, objects cannot always be \ntracked individually, but must be tracked as groups. The canon- ical example of such group tracking are \nmemory regions for safe explicit deallocation [3, 19]. Region annotations on types are one particular \nkind of predicate, stating that the named region must not be freed in order to access the data. A related \napproach to tracking individual objects is present in the programming language Concurrent Clean [2]. \nConcurrent Clean uses unique types to represent unaliased objects. Operations such as array updates may \nbe performed destructively on objects of unique type even in a purely functional language, since the \nmod- ification cannot be distinguished from a copy. Clean's unique types correspond to Vault's anonymous \ntracked types, where the key re- mains unnamed. More technically, unique types correspond to sin- gleton \ntypes where the key is existentially bound [20]. Sagiv, Reps, and Wilhelm provide a framework for intraproce- \ndural shape analysis via 3-valued logic [14]. Their t2amework can express more detailed alias relations \nnot currently expressible in Vault, as for example a function returning a pointer to the last ele- ment \nof a list, while leaving the list intact. H At first glance, type guards are similar to type qualifiers \n[7]. However, type qualifiers refine the type (how the object can be manipulated) rather than guarding \nthe access (when the object can be accessed). Furthermore, type qualifiers are constant and cannot change \nstate. Guarded types can be viewed as a form of qualified types [9, 10] VS.P ~ r, where the qualification \nquantifies over the abstract store S. At each use, the type must be instantiable to the current store \nSi and the predicate P must be satisfied Si b P. However, the framework of qualified types lacks a notion \nof state. Vault shares much of the motivation with the work on Extended Static Checking (ESC) [12]. ESC \nhowever starts with a memory safe language (Module-3/Java) and thus precludes its use in low- level system \ncode such as device drivers. Furthermore, ESC takes a pragmatic approach to aliasing, tracking aliasing \ncorrectly within a procedure, but it does not consider all possible aliasing relation- ships created \nby procedure calls [4]. ESC is based on first-order logic with arithmetic pre and post-conditions. The \npresence of specification or ghost variables allows for tracking the state of an object, similarly to \nour local key states. However, this is not enough to describe the creation and disappearance of resources \nas is pos- sible with keys and key sets, since there is no object available to attach presence information \nto. On the other hand, Vault's formal- ism is much less ambitious in terms of expressible pre and post \nconditions, since it cannot for example express arithmetic relation- ships. Thus, the techniques described \nhere complement those of ESC. Flanagan et. al. propose a type system for Java to statically detect data \nraces [6]. In their approach, the compiler tracks held lock sets and checks lock guards on class fields. \nAlthough similar to keys and type guards, their system differs from ours in that lock acquire and releases \nhave to be syntactically scoped using a synchronize expression. Thus, a method call cannot change the \nlock set. Fur- thermore, locks are not first class values, but a restricted form of syntactic expressions. \nThus it is not possible in their system to pass an object and a separate lock protecting that object \nto a method. Like the Vault project, the SLAM project at Microsoft Research is also focussed on using \nexhaustive static analysis to enforce pro- tocols of tow-level software [1]. Unlike Vault however, SLAM \nfo- cusses on existing software written in C: The SLAM tools use an iterative approach: the SLAM tools \ncreate an ever more precise ab- 11Walker [20] shows how to express lists with pointers to the last element \nexplicitly, but the point here is that such alias relationships would need to be anticipated, whereas \nthey don't in Sagiv et. al.'s work. straction of the C program and use a model checker to search this \nabstraction for protocol violations. This interative refinement stops when either a violation is found, \nor no violation is present in the abstration, or a limitation of the tools has been reached. In the context \nof the Metal project, Engler et. al. use programmer written compiler extensions to check properties of \ncode at compile time [5]. The properties their system is able to check are similar to the ones described \nhere, e.g., proper matching of lock acquire and release. In contrast to Vault, the Metal approach relies \non syntacti- cally recognizing state transitions, such as lock acquire and release, by matching against \nthe names of specific functions. While suffi- cient for checking stylized properties such as acquiring \nand releas- ing a lock within the same function, the approach would require annotations similar to the \nones proposed here to check invariants that are established inter-procedurally. 6. CONCLUSIONS AND FUTURE \nWORK Our case study on Windows 2000 drivers gives us an initial confi- dence that the resource management \nfeatures of Vault are sufficient to model \"real world\" interfaces. Nevertheless, we need to continue \nvalidating these features in other domains, like graphic interfaces and other parts of the kernel interface. \nProviding resource management features in a new language rather than an existing one allows us to design \nthe language to make type checking tractable. The downside of a new language is the in- vestment in existing \nlanguages, both in terms of legacy code and in terms of training. We hope that by basing our syntax on \nthe popular language C, we can leverage some of the training cost. Wrapping Vault interfaces around existing \nC code allows that legacy code to be reused. However, the wrapper code can be a new source of er- rors, \nand we are looking into tool support in this area as well. We are also considering adding keys to the \nnew language CII currently being deployed within Microsoft. Finally, the device driver, while complex, \nis only a single compi- lation unit. To ensure that Vault's typing rules are not so restrictive as to \nprevent useful programs, we are writing a front-end for Vault in Vault. This system is a multi-stage \npipeline where each stage's results are stored in its own region. This experience will allow us to evaluate \nthe burden of Vault's annotations and typing restrictions.  7. REFERENCES [1] T. Ball and S. Rajamani. \nAutomatically validating temporal safety properties of software. In Proceedings of the 2001 ACM SIGPLAN \nConference on Programming Language Design and Implementation, June 2001, [2] E. Barendsen and J. Smetsers. \nConventional and uniqueness typing in graph rewrite systems. In 13th Conference on Foundations of Software \nTechnology and Theoretical Computer Science, LNCS 761, pages 41-51, Dec. 1993. [3] K. Crary, D. Walker, \nand G. Morrisett. Typed memory management in a calculus of capabilities. In POPL'99 [13]. [4] D. L. \nDetlefs, K. R. M. Leino, and G. Nelson. Wrestling with rep exposure. Technical Report 156, Compaq SRC, \njul 1998. [5] D. Engler, B. Chelf, A, Chou, and S. Hallem. Checking system roles using system-specific, \nprogrammer-written compiler extensions. In Symposium on Operating Systems Design and Implementation ( \nOSD12000), Oct. 2000. [6] C. Flanagan and S. N. Freund. Type-based race detection for java. In Proceedings \nof the 2000 ACM SIGPLAN Conference on Programming Language Design and Implementation, June 2000. 68 \n[7] J. S. Foster, M. Fahndrich, and A. Aiken. A theory of type qualifiers\u00b0 In Proceedings of the 1999 \nACM S1GPLAN Conference on Programming Language Design and Implementation, pages 192-203, May 1999. [8] \nD. Gay and A. Aiken. Memory management with explicit regions. In Proceedings of the 1998 ACM SIGPLAN \nConference on Programming Language Design and Implementation, number 33:5 in SIGPLAN notices, pages 313-323, \nJune 1998. [9] M. P. Jones. A theory of qualified types. Science of Computer Programming, 22(3):231-256, \nJune 1994. Selected papers of the Fourth European Symposium on Programming (Rennes, 1992). [10] M. P. \nJones. Simplifying and improving qualified types. In Proceedings of the 1995 Conference on Functional \nProgramming Languages and Computer Architecture, pages 160-169, June 1995. [11] B. W. Kernighan and D. \nM. Ritchie. The CProgramming Language. Prentice Hall, 2nd edition, 1988. [12] K. R. M. Leino and G. Nelson. \nAn extended static checker for Modula-3. In K. Koskimies, editor, Compiler Construction (CC'98), pages \n302-305, Lisbon, 1998. Springer LNCS 1383. [13] Conference Record of the 26th Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages. ACM Press, Jan. 1999. [14] M. Sagiv, T. Reps, and \nR. Wilhelm. Parametric shape analysis via 3-valued logic. In POPL'99 [13], pages 105-118. [15] E Smith, \nD. Walker, and G. Morrisett. Alias types. In Proceedings of the 2000 European Symposium on Programming, \nMar. 2000.  [16] R. E. Strom and D. M. Yellin. Extending typestate checking using conditional liveness \nanalysis; IEEE Transactions on Software Engineering, 19(5):478--485, May 1993. [17] R.E. Strom and S. \nYemini. Typestate: A programming language concept for enhancing software reliability, rose, SE-12(1):157-171, \nJan. 1986. [18] M. Tofte and J.-P. Talpin. Implementation of the typed call-by-value A-calculus using \na stack of regions. In Conference Record of the 21st Annual ACM SSymposium on Principles of Programming \nLanguages, pages 188-201, Jan. 1994. [19] D. Walker, K. Crary, and G. Morrrisett. Typed memory management \nin a calculus of capabilities. Transactions on Programming Languages and Systems, 2001. [20] D. Walker \nand G. Morrisett. Alias types for recursive data structures. In Proceedings of the 4th Workshop on Types \nin Compilation, Sept. 2000.   \n\t\t\t", "proc_id": "378795", "abstract": "", "authors": [{"name": "Robert DeLine", "author_profile_id": "81350602833", "affiliation": "Microsoft Research, Microsoft Corporation, One Microsoft Way, Redmond, WA", "person_id": "PP14215505", "email_address": "", "orcid_id": ""}, {"name": "Manuel F&#228;hndrich", "author_profile_id": "81100288438", "affiliation": "Microsoft Research, Microsoft Corporation, One Microsoft Way, Redmond, WA", "person_id": "P187043", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378811", "year": "2001", "article_id": "378811", "conference": "PLDI", "title": "Enforcing high-level protocols in low-level software", "url": "http://dl.acm.org/citation.cfm?id=378811"}