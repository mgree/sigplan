{"article_publication_date": "05-01-2001", "fulltext": "\n SafeTSA: A Type Safe and Referentially Secure MobileoCode Representation Based on Static Single Assignment \nForm Wolfram Amme Niall Dalton Jeffery von Ronne wolfram @ ics.uci.edu ndalton @ ics.uci.edu jronne \n@ ics.uci.edu Michael Franz franz@ uci.edu Department of Information and Computer Science University \nof California Irvine, CA 92697-3425 ABSTRACT We introduce SafeTSA, a type-safe mobile code representa- \ntion based on static single assignment form. We are devel- oping SafeTSA as an alternative to the Java \nVirtual Ma- chine, over which it has several advantages: (1) SafeTSA is better suited as input to optimizing \ndynamic code genera- tors and allows CSE to be performed at the code producer's site. (2) SafeTSA provides \nincorruptible referential integrity and uses \"type separation\" to achieve intrinsic type safety. These \nproperties reduce the code verification effort at the code consumer's site considerably. (3) SafeTSA \ncan trans- port the results of type and bounds-check elimination in a tamper-proof manner. Despite these \nadvantages, SafeTSA is more compact than Java bytecode. 1. INTRODUCTION The Java Virtual Machine's bytecode \nformat (\"Java byte- code\") has become the de facto standard for transporting mobile code across the Internet. \nHowever, it is generally acknowledged that Java bytecode is far from being an ideal mobile code representation--a \nconsiderable amount of pre- processing is required to convert Java bytecode into a repre- sentation more \namenable to an optimizing compiler, and in a dynamic compilation context this preprocessing takes place \nwhile the user is waiting. In addition, it has been shown that the rules for bytecode verification don't \nexactly match those of the Java Language Specification, so that there are certain classes of perfectly \nlegal Java programs that are rejected by all compliant bytecode verifiers[29]. Further, due to the need \nto verify the code's safety upon arrival at the target machine, and also due to the specific Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advan- tage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior specific permission and/or a fee. PLD/2001 6101 Snowbird, \nUtah, USA &#38;#169; 2001 ACM ISBN 1-58113.414.2/01/06...$5.00  semantics of JVM's particular security \nscheme, many possi- ble optimizations cannot be performed in the source-to-Java bytecode compiler, but \ncan only be done at the eventual tar- get machine---or at least they would be very cumbersome to perform \nat the code producer's site. For example, information about the redundancy of a type check may often \nbe present in the front-end (because the compiler can prove that the value in question is of the correct \ntype on every path leading to the check), but this fact cannot be communicated safely in the Java bytecode \nstream and hence needs to be re-discovered in the just-in-time compiler. By \"communicated safely\", we \nmean in such a way that a malicious third party cannot construct a mobile program that falsely claims \nthat such a check is redundant. Or take common subexpression elimination: a compiler generating Java \nbytecode could in principle perform CSE and store the resulting expressions in additional, compiler-created \nlocal variables, but this approach is clumsy. The approach taken with SafeTSA 1 is radically different \nfrom Java's stack-based virtual machine. The SafeTSA rep- resentation is a genuine static single assignment \nvariant in that it differentiates not between variables of the original program, but only between unique \nvalues of these variables. SafeTSA contains no explicit assignments to local and tem- porary variables, \nbut encodes the equivalent information in phi-instructions that model dataflow. Unlike straight- forward \nSSA representations, however, SafeTSA provides intrinsic and tamper-proof referential integrity as a \nwell-formedness property of the encoding itself. Another key idea of SafeTSA is \"type separation\": values \nof different types are kept separate in such a manner that even a hand-crafted malicious program cannot \nundermine type safety and concomitant memory integrity. Interestingly enough, type separation also enables \nthe elimination of type and range checks on the code producer's side in a manner that cannot be falsified. \n1SafeTSA stands for Safe Typed Single Assignment Form i i+l; / 6 .~_q_.add (i) 1 j =j+l; if (i<=j) 7 \n.~__add 0) 1 8-~--~--cmp (6) (7) i=i+!; 9 ' 'gt(8) else i=i-1; j =j+i; 10~_add (6) 1 i b4-~-sub (6) \n1 / 12 ~_4_phi (10) (11) 13.4-d--add (7) (12) | Figure 1: Program in SSA Form Finally, SafeTSA programs \nare transmitted after high-level common subexpression elimination (address calculations are not explicit \nat this stage), which removes redundancies and thereby often leads to smaller and more efficient programs. \nThe following sections introduce various aspects of the SafeTSA encoding, discuss the current status \nof our imple- mentation, present preliminary results, and give some refer- ences to related work. 2. \nREFERENTIAL INTEGRITY A program in SSA form contains no explicit assignments or register moves; instead, \neach instruction operand refers di- rectly to the definition or to a \"phi\" function which models the \nmerging of multiple values based on the control flow. However, straightforward SSA is unsuitable for \napplication domains that require verification of referential integrity in a context of possibly malicious \ncode suppliers. This is because SSA contains an unusually large amount of references need- ing to be \nverified, far more than the original source program, making the verification process very expensive. \nAs an example, consider the program in Figure 1. The left side shows a source program fragment and the \nright side a sketch of how this might look translated into SSA form. Each line in the SSA representation \ncorresponds to an in- struction that produces a value. The individual instructions (and thereby implicitly \nthe values they generate) are labeled by integer numbers assigned consecutively; in this illustra- tion, \nan arrow to the left of each instruction points to a label that designates the specific target register \nimplicitly speci- fied by each instruction. References to previously computed values in other instructions \nare denoted by enclosing the label of the previous value in parentheses - in our depiction, we have used \n(i) and (j) as plaeeholders for the instructions that compute the initial values of i and j. Since there \nare no uses of uninitialized variables in Java, such instructions must always exist--in most cases, these \nwould correspond to values propagated from the constant pool. The problem with this representation lies \nin verifying the correctness of all the references. For example, value (10) must not be referenced anywhere \nfollowing the phi-function A-6~-~U add (i) l A-7.~--add (j) 1 A-8~_~_cmp (0-6) (0-7) A-9 ~--~-bgt (0-8) \nFigure 2: Reference-Safe SSA in (12), and may only be used as the first parameter but not as the second \nparameter of this phi-function. A malicious code supplier might want to provide us with an illegal pro- \ngram in which instruction (13) references instruction (10) while the program takes the path through (ll)--this \nwould undermine referential integrity and must be prevented. The solution is based on the insight that \nin SSA, an instruc- tion may only reference values that dominate it, i.e., that lie on the path leading \nfrom the entry point to the referencing instruction. This leads to a representation in which refer- ences \nto prior instructions are represented by a pair (l-r), in which I denotes a basic block expressed in \nthe number of levels that it is removed from the current basic block in the dominator tree hierarchy, \nand in which r denotes a relative instruction number in that basic block. For phi-instructions, an 1-index \nof 0 denotes the appropriate preceding block along the control flow graph (with the nth argument of the \nphi function corresponding to the nth incoming branch), and higher numbers refer to that block's dominators. \nThe cor-responding transformation of the program from Figure 1 is given in Figure 2. The resulting representation \nusing such (l-r) value-references provides referential integrity intrinsically without requiring any \nadditional verification besides the trivial one of ensur- ing that each relative instruction number r \ndoesn't exceed the permissible maximum. The latter fact can actually be exploited when encoding the (l-r) \npair space-efficiently.  3. TYPE SEPARATION The second major idea of our representation is type sep- \naration. While the \"implied machine model\" of ordinary SSA is one with an unlimited number of registers \n(=val- ues), SafeTSA uses a model in which there is a separate register plane for every type (disregarding, \nfor a moment, the added complication of using a two-part (l-r) naming for the individual registers, and \nalso temporarily disregarding type polymorphism in the Java language--both of these are supported by \nour format, as explained below). The register planes are created implicitly, taking into account the \npre- defined types, imported types, and local types occurring in the mobile program (Figure 3). 138 \nint float boolean - - - 10 2.0 false 3 t' true Type Table I i 0 integer ' t Constant Pool 1 float 2 boolean \n 0 imposed types 1 ~ ~/pes local types I L--J[ register types I I I numbers Figure 3: Implied Machine \nModel of SafeTSA Type safety is achieved by turning the selection of the ap- propriate register plane \ninto an implied part of the operation rather than making it explicit (and thereby corruptible). In SafeTSA, \nevery instruction automatically selects the appropriate plane for the source and destination reg-isters; \nthe operands of the instruction merely specify the particular register numbers on the thereby selected \nplanes. Moreover, the destination register on the appropriate des- tination register plane is also chosen \nimplicitly--on each plane, registers are simply filled in ascending order. For example, the operation \ninteger-addition takes two regis- ter numbers as its parameters, srel and sreR It will implic- itly fetch \nits two source operands from register integer-srcl, integer-src2, and deposit its result in the next \navailable in- teger register (i.e., the register on the integer plane, having an 1-index of zero and \nan r-index that is 1 greater than the last integer result produced in this basic block). There is no \nway a malicious adversary can change integer addition to operate on operands other than integers, or \ngenerate a result other than an integer, or even cause \"holes\" in the naming scheme for any basic block \n(a contiguous number- ing facilitates compact externalization). To give a second example, the operation \ninteger-compare takes its two source operands from the integer register plane and will deposit its result \nin the next available register on the Boolean register plane. SafeTSA combines this type separation with \nthe concept of referential integrity discussed in the previous section. Hence, beyond having a separate \nregister plane for every type, we additionally have one such complete two-dimensional regis- ter set \nfor every basic block. The results of applying both type separation and reference safe numbering to the \nprogram fragment of Figure I are shown in Figure 4.  4. CONSTRUCTION OF MEMORY SAFETY For every reference \ntype ref, our \"machine model\" provides a matching type safe-tel that implies that the corresponding value \nhas been null-checked. Similarly, for every array arr we provide a matching type safe-index-art whose \ninstances int-A-0 +int add (i) (const-1) int-A-1 ~ l int add (j) (const-l) bool-A-0.4+---int cmp (0-6) \n(0-7) (void) ~---bool bgt (0-0) [ int-B-0+int add (1-6) (const- 1) .... int_C_0 +nt sub (1-6) (const- \n1) t D-int-0 ~ int phi (0-0) (0-0) D-int-1 ~-~-int add (1-7) (0-0)  Figure 4: Type-Separated Reference-Safe \nSSA may assume only values that are index values within legal range 2 . Null-checking then becomes an \noperation that takes an ex- plicit ref source type and an explicit register number on the corresponding \nregister plane. If the check succeeds, the ref value is copied to an implicitly given register (the next \navailable) on the plane of the corresponding safc-ref type, otherwise an exception will be generated. \nThis is always translated into an explicit runtime null-check on the target machine and is the only way \nto convert a normal ref value into a saferef value. Similarly, the index-check operation takes an array \nand the number of an integer register, checks that the integer value is within bounds (with a concomitant \nruntime check), and if the check succeeds, copies the integer value to the appropriate safe-index register \nplane. The beauty of this approach is that it enables the transport of null-checked and index-checked \nvalues across phi-joins. Phi-functions are strictly type-separated: all operands of a phi-function, as \nwell as its result, always reside on the same register plane. Whenever it is necessary to combine a re \nf-type and the corresponding safe-tel type in a single phi-operation, the safe-tel type needs to be downcast \nto the corresponding unsafe ref type first. The downcast operation is a modeling function of SafeTSA \nand will not result in any actual code on the eventual target machine. Null-checking and index-checking \ncan be generalized to in- clude all type-cast operations: an upcast operation involves a dynamic check \nand will cause an exception if it fails. In the case of success, it will copy the value being cast to \nthe next available free register on the plane of the target type (the dynamic check will always result \nin actual target ma- chine code; the copy operation will disappear if the register allocator manages \nto coalesce the affected live ranges). The downcast operation, however, is only allowed where the type \ncast is known to be statically safe (e.g. casts from a class's safe-tel type to its ref type, or from \na class's ref type to 2Because of the need to support dynamically-sized arrays, safe-index types are \nactually bound to array values rather than to their static types. A more detailed discussion of this \nissue can be found in Appendix A. its supercIass's safe-ref), and therefore has no runtime over- head. \nAll memory operations in SafeTSA require that the storage designator is already in the safe state; i.e., \nthese operations will take operands only from the register plane of a safe-ref or safe-index type, but \nnot from the corresponding unsafe types. There are four different primitives for memory access: getfield \nref-type object field setfield ref-type object field value getelt array-type object index setelt array-type \nobject index value where tel-type denotes a reference type in the type table, object designates a register \nnumber on the plane of the corre- sponding safe-ref type, field is a symbolic reference to a data member \nof tel-type, and value designates a register number on the plane corresponding to the type of field. \nSim-ilarly, for array references, object designates a register on the plane of the array type that contains \nthe array's base address and index designates a register on the array's safe- index plane that contains \nthe index. The setfield and setelt operations are the only ones that may modify memory, and they do this \nin accordance with the type declarations in the type table. This is the key to type safety: most of the \nentries in this type table are not actually taken from the mobile program itself and hence cannot be \ncorrupted by a malicious code provider. While the pertinent information may be included in a mobile code \ndistribution unit to ensure safe linking, those parts of the type table that refer to primitive types \nof the underlying language or to types imported from the host environment's libraries are always generated \nimplicitly and are thereby tamper-proof. This suffices in guaranteeing memory-safety of the host in the \npresence of malicious mobile code. In particular, in the case of Java programs, SafeTSA is able to provide \nthe identical safety semantics as if Java source code were being transported to the target machine and \ncompiled and linked locally. 5. PRIMITIVE OPERATIONS The preceding discussion mentioned built-in operations \nsuch as integer-add and integer-compare, bringing up the ques- tion of which primitives are actually \nbuilt into our machine model. In fact, primitive operations in SafeTSA are subor- dinate to types and \nthere are only two generic instructions: primitive base-type operation operandl operand2... xprimitive \nbase-type operation operandl operand2... where base-type is a symbolic reference into the type table, \noperation is a symbolic reference to an operation defined on this type, and operandi.., operandN designate \nregister numbers on the respective planes corresponding to the pa- rameter types of the operation. In \neach case, the result is deposited into the next available register on the plane cot. responding to the \nresult type of the operation. The only difference between primitive and xprimitive con-cerns exceptions. \nOperations that may potentially cause an exception (such as integer divide) must be referenced using \nthe xprimitive instruction. Each occurrence of an xprimi- tive instruction in a basic block automatically \nleads to an additional incoming branch to the phi-functions in the ap- propriate exception-handling join-blocks. \nNote that it is entirely up to the type system of the language being transported by SafeTSA to specify \nwhat operations on which types may actually cause exceptions. For example, the type Java.lung.primitive-integer \nprovides add, subtract, and multiply among its primitives and divide among its xprimitives, but another \nlanguage that is less lenient about arithmetic overflow conditions might define all four opera- tions \nadd, subtract, multiply, and divide only as xprimitives for its particular integer type. There are no \nprimitive operations for accessing constants and parameters. Instead, these are implicitly \"pre-loaded\" \ninto registers of the appropriate types in the initial basic block of each procedure. Note that this \n\"pre-loading\" is yet another example of an operation that merely occurs on the SafeTSA level and that \ndoesn't correspond to any actual code being generated on the target machine.  6. METHOD INVOCATION Just \nas a set of operations is associated with each primitive type, a table of methods can be associated with \na reference type. This table is a built from local method definitions and from a list of imported methods. \nTwo primitives provide method invocation with and without dynamic dispatch: xcall base-type receiver \nmethod operandl operand2... xdispatch base-type receiver method operandl operand2... where base-type \nidentifies the static type of the receiver ob- ject, receiver designates the register number of the actual \nreceiver object on the corresponding plane, method is a sym- bolic reference to the method being invoked, \nand operandl ... operandN designate register numbers on the respective planes corresponding to the parameter \ntypes of the method. The result will be deposited into the next available register on the plane corresponding \nto the result type of the method. The symbolic method may reference any method which can be invoked on \nthe static type denoted by base-type. For xcall, this determines the actual code that will be executed, \nbut for xdispatch, it only determines a slot in the static type's dispatch table that will be polymorphically \nassociated with a method by the dynamic type of the instance referenced by receiver. For Java programs, \nthe code producer is required to resolve overloaded methods and insert explicit downcast op-erations \nfor any operands whose static type does not match the type of a method's corresponding formal parameter. \n 7. IMPLEMENTATION STATUS We have been building a system consisting of a compiler that takes Java source \nflies and translates them to the SafeTSA representation, and a dynamic class loader that takes SafeTSA \ncode distribution units and executes them using on-the-fly code generation. Currently our compiler can \nprocess programs written in the Java language and produce SafeTSA intermediate code. Work is progressing \non JIT compilers targeting the SPAlttC and Intel platforms, and we are confident that our approach will \nyield a competitive runtime system. Our front-end is based on the Pizza[25] compiler. The front-end of \nthe compiler takes as input either Java classes or packages in source form and for each class in the \ninput, produces a file containing a compressed version of the SafeTSA representation of that class. The \ntransformation of a Java class to its SafeTSA representation is performed in three main steps. After \nsuccessful syntactic and semantic analysis, the program is transformed into a Unified Abstract Syntax \nTree (UAST). Next, an SSA generator transforms the UAST into a SafeTSA graph, which is finally encoded \ninto a binary stream and written to a file. The motivation for the use of an UAST is the future exten- \nsibility of the system to handle input languages other than Java. In the current implementation, the \nUAST combines the structural elements of Java, Fortran95, and Ada95 in a single data structure. Therefore, \nit will be easy to support the compilation of Fortran95 and Ada95 programs in the future. The principles \nbehind the UAST structure can be seen as a generalization of the Abstract Syntax Tree used in Crelier's \nOP219] compiler. The essential idea in this type of Abstract Syntax Tree is to integrate the dominator \nand control flow information in the same structure: The use of a binary tree simplifies code generation \nand optimization. Many algorithms exist for the transformation of a high level program into its corresponding \nSSA form and for the de- termination of the dominator relation[10, 11, 28, 21]. Our compiler takes the \nmethod of Brandis and MSssenb~ck [6], which constructs the SSA form and the dominator relation of the \nprogram in a single pass from the source code, and adapts this method to work on the UAST. Furthermore, \nwe improved the handling of return, continue and break in-structions to avoid inserting phi nodes where \nthere are fewer than two infeasible paths. To eliminate superfluous phi in- structions, we perform dead \ncode elimination based on the calculation of live variables as suggested by Briggs et al. [7] leading \nto a reduction of 31% on average in the number of phi instructions. In our implementation, transformation \nfrom the UAST into SafeTSA form is limited to expressions and assignments. This leads to the partitioning \nof the SafeTSA graph into a Control Structure Tree, i.e. the structural part of the UAST, and the SafeTSA \npart s. From the Control Structure Tree a coherent control flow graph and dominator tree can be dee- \nrived efficiently, facilitating high quality code generation by ~Java has short-circuit operators that \nalter control-flow. These are handled by translation into if-else statements and allowing these if-else \nstatements in all expression contexts. providing high level program and blocks of SafeTSA code. This, \nfor example, eases the determination of induction vari- ables for use in software pipelining [30]. To \nenforce correct semantics of Java threads, only local vari- ables can be considered as values, in contrast \nto global vari- ables which must be accessed via getfield or set field instruc- tions as the contents \nof such variables may be changed at any time. A problematic feature of translating Java to SSA form is \nthe encoding of the try-catch-finally construct[13]. In our approach, at any point where an exception \nmay occur, we split basic blocks into linked subblocks where each of the subblocks has only a single \nentry and exit point. An im- plicit control-flow edge is created from each potential point of exception \nto a special exception-handling phi-node that is the predecessor of all of the catch blocks. Because \nSafeTSA always has a default, possibly empty, catch block, the finally block is a successor of the catch \nblocks and also any break, continue, or return nodes inside the try block. SafeTSA has been designed \nso that it can be externalized as a sequence of symbols, where each symbol is chosen from a finite set \ndetermined only by the preceding context. The encoder transmits these symbols in three phases. First, \nit encodes the Control Structure Tree (CST) as a sequence of productions of its grammar. Second, it transmits \nthe SafeTSA blocks in a fixed order, derived from the CST, cor- responding to a pre-order traversal of \nthe dominator tree. Each instruction is encoded as opcodes, types, and operands as were discussed earlier, \nbut only the type information of phi-nodes is encoded during this stage. Third, it transmits the phi-node \noperands. Phi-node operands are postponed, because they may reference instructions that do not pre-cede \nthem in the pre-order traversal, Since each of these symbols is chosen from a finite set, any dictionary \nencoding scheme can be used to convert the symbol sequence into a binary stream. Our present prototype \nuses a simple prefix encoding, which is similar to what would result from using Huffman[17] encoding \nwith fixed equal probabilities for all symbols. 8. PRELIMINARY RESULTS SafeTSA provides a safe mechanism \nfor the transportation of optimized code. We take advantage of this fact to perform optimizations that \nwill reduce the size and eventually the execution time of the transmitted code. As a proof of con- cept, \nwe currently implement constant propagation, com-mon subexpression elimination and dead code elimination \nat a local level. Unfortunately, in general, some data dependencies are hid- den within the SSA form \nof a program due to memory ac- cesses, i.e. field and array operations. For example, a store operation \nmay write into a field that will later be read by a load operation. Although the SSA form will not express \nthe data dependence between these operations explicitly, the original program's semantics must be enforced \n4. To guar- antee that all data dependencies are maintained during the optimization phase, the compiler \nhas to trace the memory accesses of the program. 4Note that type safety is not the issue here, only read- \nwrite ordering of data items that all have the same type. In SafeTSA, type safety is enforced by type \nseparation. Class Name File Size ] Number of Instructions sun.tools.javae BatchEnvironment BatchParser \nCompilerMember ErrorMessage M ain SourceMember sun.tools.java AmbiguousClass AmbiguousMember ArrayType \n BinaryAttribute BinaryClass BinaryCode Parser Scanner sun.math BigDecimal BigInteger BitSieve MutableBiglnteger \nSignedMutableBigInt eger Linpack Linpack Java Bytecode 18399 4939 1192 305 11363 13809 422 751 837 \n1716 8156 2292 23945 10540 6140 19309 1557 9667 896  II 3336 SafeTSA SafeTSA i Bytecode SafeTSA \nSafeTSA optimized optimized 14605 13931 2516 1640 1462 3832 3796 394 286 276 401 397 50 29 28 90 90 14 \n3 3 11265 10813 1734 1410 1281 11888 11246 1735 1333 1169 147 147 18 5 5 217 214 46 13 12 260 260 35 \n15 15 944 854 121 77 64 6008 5727 873 617 527 1536 1479 133 77 62 23678 22901 2578 1732 1614 11695 11222 \n4240 2912 2779 5309 4926 935 702 612 20009 18393 5638 3463 3080 1155 1080 277 153 140 10757 9823 3415 \n2223 1925 427 424 116 53 52 3512 3042 li 1097 638 1524 Figure 5: SafeTSA class files compared to Java \nclass files. There are many ways in which to solve this problem, we use the approach of introducing a \nspecial variable Mera which describes the state of the memory. During the optimization phase, a store \nto memory will produce a new value for Mere, reflecting the fact that the memory has been updated. Ad-ditionally, \nload operations take an extra parameter which is the current value of the Mere variable. As the current \nimple- mentation does not include inter-procedural optimizations, global updating of the memory will \nbe approximated by hav- ing each function call return an updated value of the Mere variable. Furthermore, \nif the current value of Mere is differ- ent on two incoming edges of a block, then a phi node must be \ninserted in the join block to merge the values into a new current value for Mere. This artificial mechanism \nexpresses all data dependencies, formerly implicit in the SSA form, in an approximated, conservative \nmanner. 5 This mechanism is used solely during the optimization phase and is not part of the transmitted \ncode, and it allows common subexpression elimination while respecting the semantics of the original program \nand the typing rules of SafeTSA. In our measurements we compare the size and number of instructions for \nprograms compiled to Java bytecode, SafeTSA, and optimized SafeTSA. As benchmarks, we use programs from \nthe Sun Java Development Kit. These in- clude classes from the Java compiler, javac, the Java in- SA \nmore sophisticated alias analysis, for example, could dis- ambiguate between two references a[i] and \na[j] wherever it could prove that i ~ j, thereby finding more common subex- pressions and leading to \nan even denser encoding. terpreter, java, as well as some classes from the Math and Linpack packages. \nThe latter classes are used to demon-strate reductions of array checking instructions. Where we compare \nto Java, we refer to bytecode produced using ver- sion 1.2.2 of Sun javac using options to generate no \ndebug information (javac -g:none). Figure 5 shows the sizes and numbers of instructions in SafeTSA files \nas compared to Java class files--in most cases SafeTSA has less than 40% of the number of instructions \nthat Java bytecode requires. The above-mentioned opti- mizations can reduce significantly the number \nof instruc- tions in SafeTSA form, by more than 10% in most cases, and up to 19% for some programs. Constant \npropagation leads to an improvement of only 1% or 2% in the program size. Dead code elimination generally \nis most effective in reducing the number of phi instructions -between 3% and 7% of the number of instructions \nat most. The majority of the instruction count reduction is due to common subex- pression elimination. \nIn our measurements the reduction due to this was between 5% and -14%. The size of the SafeTSA files \nis usually smaller than the respective Java bytecode files and sometimes substantially so. We know of \ntwo reasons contributing to the failure of file sizes to show as much of an improvement as instruction \ncount: a substantial amount of each file consists of symbolic linking information and constants, and \nmany SafeTSA instructions have multi- ple operands where the corresponding bytecode would utilize separate \nstack manipulation instructions. 142 Class Name  sun.tools.javac BatchEnvironment BatchParser Main \nSourceClass SourceMember sun.tools.java BinaryAttribute BinaryClass BinaryCode Scanner Parser sun.math \nBigDecimal BigInteger BitSieve LinpackMUtableBiglnteger Linpack  Phi Instructions Null-Checks Before \nAfter A% Before After lA% 131 75 -43 425 206 -51 19 16 -16 53 46 -13 330 301 -9 246 155 -37 356 200 -44 \n926 605 -35 221 123 -44 327 261 -20 12 7 -42 19 12 -37 56 35 -37 131 62 -52 6 3 -50 15 4 -73 58 47 -19 \n101 58 -42 351 263 -25 196 151 -23 54 35 -35 119 73 -39 382 296 -23 451 257 -43 18 15 -17 15 11 -26 205 \n169 -18 400 172 -52 Array-Checks Before I After I A% 11 9 18 N/A N/A N/A 53 49 8 N/A N/A N/A 12 12 N/A \nN/A N/A N/A 2 2 N/A 1 1 N/A 8 8 N/A 11 11 N/A 26 16 38 188 169 10 3 3 N/A 136 132 139 It 138 188 I -36 \n1[ 70 ]43 I -39 II 67 I 54 I Figure 6: Number of Phi-, Null-Check and Array-Check instructions before \nand after optimization. Figure 6 gives more detail on the practical influence of op- timizations performed \nprior to transmission of the code. It contains information on the reduction of phi instructions, null-checks, \nand array checks. These are of particular inter- est as they lead to less information that needs be transmitted \nas well as eventually to faster execution. As can be seen, the number of phi instructions was reduced \nby more than 30% in most cases. Surprisingly, we can eliminate and safely trans- port a program with, \nin most cases, 30% fewer null-checks, and in some cases up to 70% reduction is achieved, using the conservative \nCSE mechanism described above. Most of our benchmarks do not include a lot of array manipulation. However, \nfor those that do, we see a reduction of up to 38% in the number of array check instructions. Note that \nall of our SafeTSA sizes contain explicit null-checks, type-checks, and index checks, while these need \nnot be transported in Java bytecode, but also cannot be removed as a consequence. Although these are \nencouraging results, we can identify much scope for improvement. A dramatic improvement would be the \nintegration of Mias information into the mem- ory handling. This can be done, for example, with a simple \nform of field analysis as described in [!5], partitioning Mere by field name, An alternative is the integration \nof more pre- cise alias analysis techniques, e.g. [12, 3], which will lead to a typed partition of the \nmemory. Naturally, the use of inter- procedural analyses would lead to even better results. Note that \nall of these alias analyses could be performed safely due to our construction of memory safety.   9. \nRELATED WORK Because of the simplicity of code generation, 0-address ar- chitectures have been a popular \nintermediate target archi- tecture in compiler design. A well known exampl e of such a stack-based intermediate \nlanguage is pCode [24], used for code generation in the earlier Pascal compilers, pCode has recently \nreceived renewed attention because of its influence on the Java Virtual Machine. Java's platform independent \nbytecode format is either in- terpreted by a virtual machine (resulting in unacceptable performance) \nor compiled by a just-in-time compiler at the target site. Unfortunately, such just-in-time compilation \nmust occur in real time, while an interactive user is waiting. The JVM's particular design leads to quite \nexpensive ver- ification and initial bytecode analysis phases, often leaving insufficient time to perform \ngood code generation, or forcing the use of optimization algorithms that favor speed over the best achievable \ncode quality; for example, the use of linear scan register allocation instead of graph coloring [26]. \nThe difficulty of processing Java bytecode partly results from the underlying stack model, as well as \nthe fact that many bytecode operations intrinsically include sub- operations, e.g. iaload includes the \naddress computation, array checks and the actual load of the array element. The stack-based model which \nlimits the access to the top ele- ment of the stack, prevents the reuse of operands and code reordering \n[18]. In our SafeTSA approach we have split these composed bytecode operations into elementary units, \nwhich--after performing some standard optimizations--leads to a significant reduction in code size and \neventually in execution time. Further, SafeTSA's is more appropriate for structural optimizations at \nthe consumer side. A further significant performance problem with the Java virtual machine is the time \nconsuming verification phase. In particular, checking that all operand accesses to the stack are valid \n-which requires a data flow analysis -decreases the runtime of applications significantly. In SafeTSA \nthis verification phase is done by checking if a value has already been defined, which can be implemented \nusing simple counters holding the numbers of defined values for each type in each basic block. There \nare many JIT compilers for Java; two examples are HotSpot and Jalapeno. The HotSpot Server compiler [16] \ndeveloped at Sun uses an $SA-based internal representation similar to the one described in Click's dissertation \n[8]. It turns Java exceptions into explicit control flow in its IR and uses a full flow pass to discover \ntypes from the Java bytecode. In contrast our representation always explicitly marks all types~ and therefore \nno type inference is required. Jalapeno [5, 1, 2] is an extensive Java virtual machine/dynamic compilation \nsystem from IBM research that is itself written in Java and indeed even uses its own services. Jalapeno \nis an- other compiler that uses SSA internally, but unlike HotSpot, it is not entirely based on SSA but \nuses SSA only for flow sensitive optimizations. Jalapeno uses three different levels of IR, a high-level \nform that is essentially equivalent to byte- code, an intermediat~level form that exposes the underlying \nobject model, and a low-level form that is very close to the target machine. In the last few years, several \nnative code optimizing Java compilers that use an intermediate representation based on SSA form have \nbeen developed. Each of them requires either Java source code or Java bytecode as input and produces \nna- tive machine code as output. However, there is no compiler that conserves the information of the \nSSA based intermedi- ate representation in any kind of class file that could support a dynamic code generation \nprocess. Below we will discuss in more detail two optimizing compilers of particular interest. The Swift \ncompiler [27] has been designed and implemented at the Western Research Laboratory of Compaq Computer \nCorporation. Swift translates Java bytecode to optimized machine code for the Alpha architecture and \nuses SSA form for its intermediate representation. The intermediate lan- guage used by the compiler is \nrelatively simple, but allows for straightforward implementation of all standard scalar op- timizations \nand other advanced optimization techniques, i.e. method resolution and inlining, interprocedural alias \nanal- ysis, elimination of run time checks, object inlining, stack allocation of objects, and synchronization \nremoval. Each value in the SSA graph also has a program type. Com-parable with our approach, the type \nsystem of Swift can represent all of the types present in Java program. In con- trast to our approach \nthe Swift intermediate representation contains no structural information, i.e. the control structure \ntree of our SafeTSA graphs. Also, compared to the instruc- tion set of our SafeTSA, the instructions \nused by Swift are very specialized and adapted to its target architecture. Marmot [13] is a research \ncompiler from Microsoft that transforms Java bytecode into native machine code. The organization of the \ncompiler can be divided into three parts: conversion of Java class files to a typed high level intermedi- \nate representation based on SSA form, high level optimiza- tion, and code generation. Type information \nin the high level representation of the Marmot compiler (there is also a low-level II:t) is derived by \ntype elaboration. This pro- cess produces a strongly-typed intermediate representation in which all variables \nare typed, all coercion and conversions are explicit, and all overloading of operators is resolved. Marmot \ndoesn't support Java's essential facility of dynamic class loading. The intermediate representation for \nMicrosoft's recently an- nounced \".NET\" platform is a further improvement of the stack based virtual \nmachine. It has a provision for includ- ing a second description based on SSA form. This approach assumes \nan external authentication-based security mecha- nism because it is not safe: First, there is no guarantee \nthat the program represented as a virtual-machine program corresponds to the one represented in SSA form--the \ntwo representations are completely independent of each other and it appears that the loader on the target \nplatform may elect to use either format if both are present. Second, the SSA part of the representation \nhas no provisions for safety and is apparently never verified. The Architecture Neutral Distribution \nFormat (ANDF[4]), originally developed by the Defence Research Agency in the UK (DRA) is also a tree \nbased representation, the TDF intermediate language. TDF is a tree structured language, defined as a \nmulti-sorted abstract algebra, which preserves more program structure information that other languages. \nHowever/it has a weaker type system than typical high level languages. It was originally designed for \nthe compilation of sequential languages such as C and Lisp. Indeed the over-all level of the language \nis similar to C but also includes support for other features such as for garbage collection. Programs \nrepresented in ANDF are compiled to native code at installation time. As such, ANDF was designed solely \nas a distribution format rather than a mobile code format. Slim Binaries, an intermediate representation \ndeveloped by b-Yanz and Kistler[14, 20] are also based on a tree structured language. In contrast to \nANDF, Slim Binaries were designed with mobile code applications in mind and to be suitable for dynamic \ncode generation on target machines. Slim Binaries have been shown to be much smaller than ANDF and Java \nbytecode files - an important feature for mobile code appli- cations. Slim Binaries have been used successfully \nin study- ing continuous program optimization[19]. Unlike SafeTSA, Slim Binaries are based on encoding \nthe source-level abstract syntax tree of a program. As a consequence of being so far removed from the \ninternal representations typically used in compilers, Slim Binaries cannot communicate the results of \nprogram analyses and target machine independent optimiza- tions as well as SafeTSA can. Proof carrying \ncode[23] is a new subject of research aimed at the safe execution of untrusted, possibly mobile, code. \nThere is a burden of proof on the code to be executed, to obey the target site's security policy. Typically \nthis is in the form of an attached proof. Upon validation of the proof at the target site, the code is \nassumed safe to run and no dynamic checks need be performed. Proof carrying code provides memory and \ntype safety similar to SafeTSA, how- ever, we do not need to generate, transport and verify proofs. SafeTSA \nis safe by construction, and cannot be manipulated to give unsafe programs. TAL (Typed Assembly Language) \n[22] uses an approach to type safety that is semantically equivalent to our concept 144 ...... of type \nseparation. TAL annotates assembly language or object code with type information, memory management primitives, \nand a sound set of typing rules. The type an- notations can be checked before assembly or execution of \nthe code to verify its memory, control flow and type safety. A particular aim of the TAL project is the \ncompilation of type-safe functional languages based on the polymorphicaUy typed second order lambda calculus--known \nas System F-- to a typed target language via a sequence of type-preserving transformations. This aids \nin verifying correct compilation, as well as verifying that compiled code is well-behaved. Un- like TAL, \nSafeTSA provides cross-platform portability, since it defers code generation to the target machine, while \nstill allowing rapid verification and code generation. Due to their high-level representation and suitability \nfor compres- sion, SafeTSA programs are likely to be more compact than TAL's assembly or object code \nwith annotations. 10. CONCLUSION AND OUTLOOK The Java Virtual Machine's instruction format is not very \ncapable in transporting the results of program analyses and optimizations. As a consequence, when Java \nbytecode is transmitted to another site, each recipient must repeat most of the analyses and optimizations \nthat could have been per- formed just once at the origin. The main reason why Java bytecode has these \ndeficiencies is to allow verification by the recipient. We have designed an alternative mobile-code representation \nthat overcomes these limitations of the Java bytecode lan- guage. Our representation, SafeTSA, can provide \nthe iden- tical security guarantees as the Java Virtual Machine, but it can express most of them statically \nas a well-formedness property of the encoding itself. SafeTSA thereby obviates the need for an expensive \ndataflow analysis at the code re- cipienCs site. Further, SafeTSA preserves control and dataflow informa- \ntion as well as full typing information for each intermediate result. It is based on Static Single Assignment \nform, a repre- sentation that is also used internally by several state-of-the- art research compilers \nfor Java. As a consequence, SafeTSA it is far easier to parse into a form useful for code optimiza- tion \nthan Java bytecode. Also, SafeTSA removes the need to perform type/range check elimination at the code \nreceiver's side, genuinely enabling shifting this workload to the code's producer without jeopardizing \nsafety. Surprisingly, despite its advantages, SafeTSA is no more voluminous than JVM code. It is probably \nonly a matter of time until the Java Vir- tual Machine will be displaced by alternative mobile-code transportation \nformats that better support optimization at the code receiver's site. Programmers will still be writing \nmobile programs using the Java source language (and alter- native languages such as C~), but rather than \ncompiling them into Java bytecode, they will be using these better alternatives. The authors believe \nto have identified such an alternative in SafeTSA.  11. ACKNOWLEDGEMENTS The authors would like to \nthank Peter Housel and the anony- mous reviewers for their helpful comments on this paper. We also thank \nMichael Phillipsen for providing the source code of the Pizza compiler. Parts of this effort are sponsored \nby the National Science Foundation under grant CCR-9901689, and by the Defense Advanced Research Projects \nAgency (DARPA) and Air Force Research Laboratory, Air Force Materiel Command, USAF, under agreement number \nF30602-99-1-0536. This paper is dedicated to the memory of Bratan Kostov. 12. REFERENCES [1] B. Alpern, \nC. R. Attanasio, et al. The Jalapeno virtual machine. IBM System Journal, 39(1), February 2000. [2] B. \nAlpern, A. Cocchi, D. Lieber, M. Mergen, and V. Sarkar. Jalapeno - a compiler-supported java virtual \nmachine for servers. Workshop on Compiler Support for Software System (WCSSS 99), May 1999. [3] W. Amme \nand E. Zehendner. Data dependence analysis in programs with pointers. Parallel Computing, 24(3-4):505-525, \nMay 1998. [4] Architecture Neutral Distribution Format (XANDF) Specification. Open Group Specification \nP527, January 1996. [5] M. Arnold, S. Fink, et al. Adaptive optimization in the Jalapeno JVM. ACM OOPLSA \n2000, 2000. [6] M. M. Brandis and H. MfssenbSck. Single-pass generation of static single-assignment form \nfor structured languages. A CM Trans. Prog. Lang. and Sys., 16(6):1684-1698, Nov. 1994. [7] P. Briggs, \nK. D. Cooper, T. J. Harvey, and L. T, Simpson. Practical improvements to the construction and destruction \nof static single assignment form. Software Practice and Experience, 28(8):859-881, July 1998. [8] C. \nClick. Combining Analyses, Combining Optimizations. PhD thesis, Rice University, Houston, Texas. [9] \nIt. Crelier. OP2: A Portable Oberon Compiler. Technical Report 1990TR-125, Swiss Federal Institute of \nTechnology, Zurich, Feb., 1990. [10] R. Cytron, J. Ferrante, B. K. Rosen, M. K. Wegrnan, and F. K. Zadeck. \nAn efficient method of computing static single assignment form. In POPL '89, 1989. [11] R. Cytron, J. \nFerrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. Efficiently computing static single assignment \nform and the control dependence graph. ACM Trans. Prog. Lang. and Sys., 13(4):451-490, Oct. 1990. [12] \nA. Diwan, K. S. McKinley, and J. E. B. Moss. Type-based alias analysis. A CM SIGPLAN Notices, 33(5):106-117, \nMay 1998. [13] R. Fitzgerald, T. B. Knoblock, et al. Marmot: An optimizing compiler for Java. Microsoft \nTechnical Report 3, Microsoft Research, March 2000.  [14] M. Franz and T. Kistler. Slim Binaries. Communications \nof the ACM, 40(12):87-94, Dec. 1997. [15] S. Ghemawat, K. H. Randall, and D. J. Scales. Field analysis: \nGetting useful and low-cost interprocedural information. In PLDI '00, 2000. [16] Sun Hotspot compiler \nfor Java. http://java.sun.com/products/hotspot/. [17] D. A. Huffman. A method for the construction of \nminimum redundancy codes. In Proceedings of the IRE, 40, pages 1098-1101, 1951. [18] J. Hummel, A. Azevedo, \nD. Kolson, and A. Nicolau. Annotating the Java bytecodes in support of optimization. Concurrency: Practice \nand Experience, 9(11):1003-1016, Nov. 1997. Special Issue: Java for computational science and engineering \n--simulation and modeling II. [19] T. Kistler. Continuous Program Optimization. Phd Dissertation, University \nof California, Irvine, 1999. [20] T. Kistler and M. Franz. A Tree-Based alternative to Java byte-codes. \nInternational Journal of Parallel Programming, 27(1):21-34, Feb. 1999. [21] T. Lengauer mad R. E. Tarjan. \nA fast algorithm for finding dominators in a flowgraph. A CM Trans. Pro9. Lang. and Sys., 1(1):121-141, \nJuly 1979. [22] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to Typed Assembly Language. \nACM Trans. Prog. Lang. and Sys., 23(3):528-569, May 1999. [23] G. C. Necula. Proof-Carrying Code. In \nPOPL '97, Paris, France, Jan. 1997. [24] K. V. Nori, U. Ammann, et al. Pascal-P implementation notes. \nIn D. W. Barron, editor, Pascal - The Language and its Implementation, pages 125-170. John Wiley and \nSons, Ltd., 1981. [25] M. Odersky and P. Wadler. Pizza into Java: Translating theory into practice. In \nConference Record of POPL '97, pages 146-159, Paris, France, 15-17 Jan. 1997. [26] M. Poletto and V. \nSarkar. Linear scan register allocation. ACM Trans. Prog. Lang. and Sys., 21(5):895-913, September 1999. \n[27] D. J. Scales, K. H. Randall, S. Ghemawat, and J. Dean. The Swift Java Compiler: Design and Implementation. \nWRL Research l:teport 2000/2, Compaq Research, April 2000. [28] V. C. Sreedhar and G. 1~. Gao. A linear \ntime algorithm for placing [phi]-nodes. In ACM, editor, Conference record of POPL '95, pages 62-73, New \nYork, NY 10036, USA, 1995. ACM Press. [29] R. F. StArk and J. Schmid. Java bytecode verification is not \npossible. Technical report, ETH Zfirich, Nov. 2000. [30] J. Wang, C. Eisenbeis, M. Jourdan, and B. Su. \nDecomposed software pipelining: A new perspective and a new approach. International Journal of Parallel \nProgramming, 22(3)'.351-373, June 1994. APPENDIX  A. JAVA ARRAY REFERENCES In Java, the size of an array \nmay often not be known stat- ically, but once that an array object has been created, its size remains \nconstant. As a consequence, an index that is safe to use with a given array reference will remain safe \nthroughout the lifetime of that SSA array reference (which is not necessarily the same as the lifetime \nof the underlying array variable). SafeTSA approaches type safety in a conservative manner: for each \narray-ref value, we create a safe-index type that signifies a \"value that can safely be used as an index \nfor this array-ref value\". As a further consequence of the approach used with SafeTSA, a safe-index value \ncan only pass though phi nodes that are dominated by the corresponding safe-ref value for the un-derlying \narray (the safe-type must cease to exist when the value ceases to exist). This results in the need to \ngive types a limited scope based on the dominator relationship, just like SSA values, which however doesn't \npresent any major implementation challenges.  B. A MORE DETAILED EXAMPLE f= x*2.0; (11): mul x 2 0 i \n= i'3; A (12): mul t 3 If (i>10) (13): le (12), 10 i++; (14): cbra (13) C else B etse ffO!=O) f=i+f; \nB C (20): F ((15),(12)) E (21): F ((11),(19)) (22): 2float (20) (23): add (22), (21) Figure 7: Program \nFragment in SSA Form A-0 .~_.____~___ mul x 2.0 A-3 .a_--_--J-m_ cbra (0~2) C else B \\/ E.0 ~___-~_-- \nF ((0-0),(2-1 )) E-I ~_____t___ F (( b-0),(0--1 )) E-2 .~._.__4__ 2float (0-0) E-3 ~___add (0-2), (1-1) \n Figure 8: Referentially Secure SSA Form / float-A-0 .~L__prim float mul const-0, x int-A-I ~_.prim \nint mul t, const-2 boolean-A-2 prim mt le (0.0), const-1 (void) ~cbta (0-0) C else B  ,ot_B.0 ~.min.o~(,-0)l \n'\u00b0'~-0\"t--'rim'nt\u00b0q\".0' ..... 0 I --~ ' (void) ~_--- cbra (0-0) F else D ] y ~ ~ float-D-I ~__ prim int \ndiv (2.0) (0.0) I \u00ae\u00ae int-E-0 ~_F int ((0.0),(2-10)) float-E--0 .dc-F float ((1.0),(0-1)) ~_prim hat 2float \n(0.0) float-E-2fi\u00b0at-E-I~_pfimfloatadd(0-2),(l-l) Figure 9: SafeTSA Form  \n\t\t\t", "proc_id": "378795", "abstract": "", "authors": [{"name": "Wolfram Amme", "author_profile_id": "81100352012", "affiliation": "Department of Information and Computer Science, University of California, Irvine, CA", "person_id": "P301083", "email_address": "", "orcid_id": ""}, {"name": "Niall Dalton", "author_profile_id": "81100572220", "affiliation": "Department of Information and Computer Science, University of California, Irvine, CA", "person_id": "P335014", "email_address": "", "orcid_id": ""}, {"name": "Jeffery von Ronne", "author_profile_id": "81100202243", "affiliation": "Department of Information and Computer Science, University of California, Irvine, CA", "person_id": "P334849", "email_address": "", "orcid_id": ""}, {"name": "Michael Franz", "author_profile_id": "81100089579", "affiliation": "Department of Information and Computer Science, University of California, Irvine, CA", "person_id": "PP39026706", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378825", "year": "2001", "article_id": "378825", "conference": "PLDI", "title": "SafeTSA: a type safe and referentially secure mobile-code representation based on static single assignment form", "url": "http://dl.acm.org/citation.cfm?id=378825"}