{"article_publication_date": "05-01-2001", "fulltext": "\n Automatic Predicate Abstraction of C Programs Thomas Ball tballOmicrosoft, com Microsoft Research \nTodd Millstein toddOcs, washington, edu Univ. of Washington  Rupak Majumdar rupakOc s. berkeley, edu \nU.C. Berkeley Sriram K. Rajamani sriram@microsoft, com Microsoft Research http://research.microsoft.com/slam/ \n Abstract Model checking has been widely successful in validating and debugging designs in the hardware \nand protocol domains. However, state-space explosion limits the applicability of model checking tools, \nso model checkers typically operate on abstractions of systems. Recently, there has been significant \ninterest in applying model checking to software. For infinite-state systems like software, abstraction \nis even more critical. Techniques for abstracting software are a prerequisite to making software model \nchecking a reality. We present the first algorithm to automatically construct a predicate abstraction \nof programs written in am industrial programming language such as C, and its implementation in a tool \n-- C2BP. The C2BP tool is part of the SLAM toolkit, which uses a combination of predicate abstraction, \nmodel checking, symbolic reasoning, and iterative refinement to statically check temporal safety properties \nof programs. Predicate abstraction of software has many applications, including detecting program errors, \nsynthesizing program invariants, and improving the precision of program analy- ses through predicate \nsensitivity. We discuss our experience applying the C2BP predicate abstraction tool to a variety of problems, \nranging from checking that list-manipulating code preserves heap invariants to finding errors in Windows \nNT device drivers. Introduction In the hardware and protocol domains, model checking has been used to \nvalidate and debug systems by algorithmic ex- ploration of their state spaces. State-space explosion \nis a major limitation, and typically model checkers explore the state space of an abstracted system. \nFor software, which Permission to make digital or hard c6pies of all or part of this work for personal \nor qlessroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advan- tage end that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission \nand/or a fee. PLD12001 6/01 Snowbird, Utah, USA &#38;#169; 2001 ACM ISBN 1-58113-414-2/01/06..$5.00 \nis typically infinite-state, abstraction is even more critical. Any effort to model check software must \nfirst construct an abstract model of the software. A promising approach to construct abstractions auto-matically, \ncalled predicate abstraction, was first proposed by Graf and Sa~di [19]. With predicate abstraction, \nthe con-crete states of a system are mapped to abstract states ac-cording to their evaluation under a \nfinite set of predicates. Automatic predicate abstraction algorithms have been de- signed and implemented \nbefore for finite-state systems and for infinite-state systems specified as guarded commands. However, \nno one has demonstrated automatic predicate ab- straction on a programming language such as C. We present \na tool called C2Br, that performs automatic predicate abstraction of C programs. Given a C program P \nand a set E of predicates (pure C boolean expressions containing no function calls), C2BP automatically \ncreates a boolean program BP(P, E), which is an abstraction of P. A boolean program is essentially a \nC program in which the only type available is boolean (the boolean program language has some additional \nconstructs that will be presented later). The boolean program has the same control-flow structure as \nP but contains only IEI boolean variables, each representing a predicate in E. For example, if the predicate \n(x < y) is in E, where x and y are integer variables in P, then there is a boolean variable in BTa(P, \nE) whose truth at a program point pimplies that (x < y) is true at pin P. For each statement s of P, \nC2BP automatically constructs the cor-responding boolean transfer functions that conservatively represent \nthe effect of s on the predicates in E. The re-sulting boolean program can be analyzed precisely using \na tool called BEBOP [5] that performs interprocedural dataflow analysis [31, 28] using binary decision \ndiagrams. We present the details of the C2BP algorithm, as well as results from applying C2BP to a variety \nof problems and programs: We have applied C2BP and BEBOP to pointer-manipulating programs to identify \ninvariants involving pointers. In one example, these invariants lead to more precise aliasing information \nthan is possible with a flow- sensitive alias analysis. In another example, we show that list-manipulating \ncode preserves various structural properties of the heap, as has been done with shape analysis [30]. \nThis is noteworthy because our predicate language is a quantifier-free logic, rather than the more powerful \nlogic of [30]. \u00ae We have applied C2BP and BEBOP to examples fi'om Necula's work on proof-carrying code \n[26] to automati- cally identify loop invariants in these examples that the PCC compiler was required \nto generate. We have used C2BP in the SLAM toolkit to check tem- poral safety properties of Windows NT \ndevice drivers. The SLAM toolkit uses C2BP and BEBOP to statically determine whether or not an assertion \nviolation can take place in C code. A unique part of the toolkit is its use of a demand-driven iterative \nprocess to automati- cally find predicates that are relevant to the particular assertion under examination. \nWhen the current set of predicates and the boolean program abstraction that it induces are insufficient \nto show that an assertion does/doesn't fail, new predicates are found to refine the abstraction. Although \nthe SLAM process may not converge in theory, due to the undecidability of the as- sertion violation problem, \nit has converged on all NT device drivers we have analyzed (even though they con- tain loops). For a \ndetailed proof of soundness of the abstraction al- gorithm presented in this paper, the interested reader \nis re- ferred to our technical report [3]. In work with Andreas Podelski [4] we have used the framework \nof abstraction in- terpretation to formalize the precision of the C2BP algo- rithm for single procedure \nprograms with no pointers. Sec- tion 4.6 reviews the soundness theorem for C2BP that we have proved and \ndescribes our precision results. The rest of this paper is organized as follows. Sec- tion 2 gives an \nexample of applying C2sP to a pointer- manipulating C procedure. Section 3 lists the challenges in performing \npredicate abstraction on C programs. Section 4 describes our predicate abstraction algorithm in detail. \nSec- tion 5 describes extensions and optimizations to the C2BP tool. Section 6 presents results on applying \nthe C2BP tool to a variety of C programs. Section 7 reviews related work and Section 8 concludes the \npaper. 2 Example: Invariant Detection in Pointer-manipulating Programs This section presents the application \nof C2BP and the BE- BOP model checker to a pointer-manipulating procedure. The combination of the two \ntools determines program-point- specific invariants about the procedure, which can be used to refine \npointer aliasing information.  2.1 C2bp Consider the partition function of Figure l(a). This pro- cedure \ntakes a pointer to a list of integers l and an integer v and partitions the list into two lists: one \ncontaining the cells with value greater than v (returned by the function) and the other containing the \ncells with value less than or equal to v (the original list, destructively updated). We input the program \nin Figure l(a) along with the fol- lowing predicate input file to C2BP: partition { curt == mULL, prev \n== mULL, curr->val > v, prev->val > v } The predicate input file specifies a set of four predicates, \nlocal to the procedure partition. Figure l(b) shows the boolean program resulting from the abstraction \nof the pro- cedure partition with respect to these predicatesJ The boolean program declares four variables \nof type bool in pro- cedure partition, each corresponding to one of the four predicates from the predicate \ninput file. 2 The variables' ini- tial values are unconstrained. The boolean program is guaranteed to \nbe an abstraction of the C program in the following sense: any feasible exe- cution path of the C program \nis a feasible execution path of the boolean program. Of course, there may be feasible execution paths \nof the boolean program that are infeasible in the C program. Such paths can lead to imprecision in subsequent \nmodel checking. We now informally describe how the C2BP tool translates each statement of the C program \ninto a corresponding set of statements in the boolean program. An assignment state- ment in the C program \nis translated to a set of assignments that capture the effect of the original assignment statement on \nthe input predicates. For example, the assignment state- ment \"prey=NULL;\" in the C program is translated \nto two assignment statements in the boolean program. The first, \"{prev==NULL}=true;\", reflects the truth \nof the predicate (prey = NULL) after the assignment. The value of the predicate (prey ~ val > v) is undefined \nafter this assign- ment and is thus invalidated by the assignment statement \"{prev->val>v} = unknown();\". \nThe unknown function is defined as:  bool unknown() { if (*) { return true; } else { return false; } \n} The unknown function uses the control expression \"*\", which non-deterministieally chooses the then \nor the else branch, to return either true or false. The C2BP tool determines that the other two predi-cates \nare unaffected by the assignment \"prey=NULL;\", so they need not be updated. The C2BP tool uses a flow-insensitive \npoints-to analysis [12] to resolve aliases between pointers. In this program, since none of the pointer \nvariables in the set { curt, prey, next, newl } has its address taken, none of these variables can be \naliased by any other expres- sion in the procedure. As a result, C2BP resolves that the only predicates \nthat the assignment \"prey=NULL;\" affects are (prey = NULL) and (prey ~ val > v). As another example, \nthe assignment \"prey=curt;\" is also abstracted to assignments to the two predicates in- volving prey. \nThese predicates are assigned the values of the corresponding predicates on curr, as expected. Finally, \nC2BP determines that the assignment \"newl=NULL;\" cannot affect any of the four input predicates, so the \nassignment is translated to the skip statement, the boolean program's \"no-op\". In the above examples, \nmost of the input predicates are updated accurately. For example, the assignment IThe boolean program \nshown is not the exact output of C2BP-- it  has been simplified to aid readability. 2In boolean programs, \nvariable identifiers can be regular C identi- fiers or an arbitrary string enclosed between \"{\" and \"}'. \ntypedef struct cell {  void partition() { int val; bool {curr==NULL}, {prev==NULL}; struct cell* next; \n bool {curr->val>v}, {prev->val>v}; } *list; {curr==NULL} = unknown(); // curt = *I; {curr->val>v} \n= unknown(); list partition(list *l, int v) { {prev==NULL} = true; // prey = NULL; list curt, prey, \nnewl, nextCurr; {prev->val>v} = unknown(); skip; // newl = NULL; curr = *i; while(*) { // while(curr!=NULL) \nprey = NULL; assume(!{curr==NULL}); // newl = NULL; skip; // nextCurr = curr->next while (curr != NULL) \n{ if (*) { // if (curr->val > v) { nextCurr = curr->next; aseume({curr->val>v}); // if (curr->val > \nv) { if (*) { // if (prev != NULL) { if (prey != NULL) { assume(!{prev==NULL}); // prev->next = nextCurr; \n skip; // prev->next = nextCurr; }  } II } if (curr == *l) {  if (*) { // if (curr == *i) { *l = \nnextCurr; skip; // *I = nsxtCurr;} } // } curr->next = newl; skip; // curr->next = newl; L: newl = \ncurr; L: skip; // newl = curt } else { } else { // } else { prey =curr; assume(!{curr->val>v}); // \n}  {prev==NULL} = {curr==NULL}; // prey = curt; curt = nextCurr; {prev->val>v} = {curr->val>v}; // \n}  } II } return newl; {curr==NULL} = unknown(); // curr = nextCurr; {curr->val>v} = unknown(); } assume({curr==NULL}); \n (a) (b) Figure 1: (a) List partition example; (b) The boolean program of the list partition example, \nabstracted with respect to the set of input predicates { curr==NOLL, prev==NOLL, curr->val > v, prev->val \n> v }. The unknown function is used to generate the value true or false non-deterministically (see body \ntext for an explanation). \"{prev==NULL}={curr==NOLL};\" in the boolean program 2.2 Bebop exactly represents \nthe effect of the assignment \"prev=curr\" The boolean program output by C2BP is input to the BE- on the \npredicate (prey = NULL). However, it is possi- BOP model checker [5], which computes the set of reachable \nble for such exact information to be unavailable, because states for each statement of a boolean program \nusing an some of the necessary predicates have not been input to interprocedural datMtow analysis algorithm \nin the spirit of C2BP. In that case, we must replace exact information Sharir-Pnueli and Reps-Horwitz-Sagiv \n[31, 28]. A state of with a conservative approximation. For example, the as-a boolean program at a statement \ns is simply a valuationsignment \"curr=nextCurr;\" can affect the two predicates to the boolean variables \nthat are in scope at statement sinvolving curr. However, because there are no predicates (in other words, \na bit vector, with one bit for each variable about nextCurr in the predicate input file, there is no \nway in scope). The set of reachable states (or invariant) of a to deduce the correct truth value of these \npredicates. This boolean program at s is thus a set of bit vectors (equiva- represents a worst case of \nsorts, as the input predicates pro- lently, a boolean function over the set of variables in scope vide \nabsolutely no information about the appropriate truth at 8), values for the two predicates to be updated. \nAs a result, the BEBOr' differs from typical implementations of dataflow two predicates are \"invalidated\" \nusing the unknown function, algorithms in two crucial ways. First, it computes over sets as defined above. \nof bit vectors at each statement rather than single bit vec- The C2BP tool translates conditional statements \nin the tors. This is necessary to capture correlations between vari- C program into non-deterministic \nconditional statements ables. Second, it uses binary decision diagrams [9] (BDDs) in the boolean program, \nusing the control expression \"*\" to implicitly represent the set of reachable states of a pro- However, \nit also inserts \"assume\" statements to capture the gram, as well as the transfer functions for each statement \nsemantics of conditionals with respect to the input pred- in a boolean program. However, BEBOP uses an \nexpliciticates. For example, the first statement inside the while control-flow graph representation, \nas in a compiler, rather loop is \"assume(!{curr==NULL}) ;'. The assume acts as a than encoding the control-flow \nwith BDDs, as done in most filter on the state space of the boolean program: in this symbolic model checkers. \ncase, it is impossible to reach the program point after the For our example, BEBOP outputs the following \ninvariant assume if the variable {curr==NULL} is true. In this way, we representing the reachable states \nat label L of the boolean faithfully model the guard of the original while loop. call only occurs at \nthe top-most level of an expression (for example, \"z=x+f (y) ;\" is replaced by \"t=f (y) ; z=x+t ;\"). \n4.1 Weakest Preconditions and Cubes For a statement s and a predicate ~o, let WP(s, ~o) denote the weakest \nliberal precondition [16, 20] of ~o with respect to statement s. WP(s, ~o) is defined as the weakest \npredicate whose truth before s entails the truth of ~o after s terminates (if it terminates). Let \"x \n= e\" be an assignment, where x is a scalar variable and e is an expression of the appropriate type. Let \n~ be a predicate. By definition WP(x = ,, 7~) is ~p with all occurrences of x replaced with e, denoted \n~o[e/x]. For example: WP(x=x+l,x<5) = (x+l)<5 = (x<4) The weakest precondition computation is central \nto the predicate abstraction process. Suppose statement s occurs between program points p and p'. If \n~o is a predicate in E with corresponding boolean variable b then it is safe to assign b the value true \nin BT~(P, E) between program points p and p' if the boolean variable b ~ corresponding to WP(s, ~o) is \ntrue at program point p. However, no such variable b ~ may exist if WP(s, ~o) is not in E. For example, \nsuppose E = {(x < 5), (x = 2)}. We have seen that WP(x=x+l, x < 5) = (x < 4), but the predicate (x < \n4) is not in E. In this case, C2BP uses decision procedures (i.e., a theorem prover) to strengthen the \nweakest precondition to an expression over the predicates in E. In our example, we can show that (x = \n2) =~ (x < 4). Therefore if (x = 2) is true before \"x=x+l;\", then (x < 5) is true afterwards. We formalize \nthis strengthening of a predicate as follows. A cube over V is a conjunction cq A ... A ci~, where each \nc~j E {b~,-~b~} for some b~ E V. For a variable bl 6 V, let \u00a3(bi) denote the corresponding predicate \n~o~, and let g(-~bi) denote the predicate -~oi. Extend g to cubes and disjunctions of cubes in the natural \nway. For any predicate ~o and set of boolean variables V, let .7\"v (\u00a2p) denote the largest disjunction \nof cubes c over V such that \u00a3(c) implies ~o. The predicate E(.T'v(~p)) represents the weakest predicate \nover g(V) that implies ~o. In our example, g(.Y'v(x < 4)) = (x = 2). It will also be useful to define \na corresponding weakening of a predicate. Define gv(~o) as -~Srv(-~o). The predicate g(Gy(~p)) represents \nthe strongest predicate over \u00a3(V) that is implied by ~o. For each cube, the implication check involves \na call to a theorem prover implementing the required decision pro- cedures. Our implementation of C2BP \nuses two theorem provers: Simplify [15] and Vampyre [7], both Nelson-Oppen style provers [27]. A naive \ncomputation of 9Vy(.) and ~y(') requires exponentially many calls to the theorem prover in the worst \ncase. Section 5 describes several optimizations that make the .Y'v and ~v computations practical.  4.2 \nPointers and aliasing In the presence of pointers, WP(xffie, ~o) is not necessarily role~x]. As an example, \nWP(x = 3, *p > 5) is not (*p > 5) because if x and *p are aliases, then (*p > 5) cannot be true after \nthe assignment to x. A similar problem occurs when a pointer dereference is on the left-hand side of \nthe assignment. To handle these problems, we adapt Morris' general ax- iom of assignment [25]. A location \nis either a variable, a int bar(int* q, int y) { bar { ink ii, 12; y >= O, .. *q <= y, return ii; y \n== ii, } y > 12 } void foo(int* p, int x) { foo { ink r; *p <= 0, if (*p <= X) X == O, *p = X; r == \n0 else } *p = *p + x; r = bar(p, x); Figure 2: An example input to C2BP. On the left are two simple \nC procedures (bar is not shown in its entirety). On the right is the set of predicates to model. structure \nfield access from a location, or a dereference of a location. Consider the computation of WP(x=e,~o), \nwhere x is a location, and let y be a location mentioned in the predicate 7~. Then there are two cases \nto consider: either x and y are aliases, and hence the assignment of e to x will cause the value of y \nto become e; or they are not aliases, and the assignment to x leaves y unchanged. Define &#38;x = &#38;y \nA ~o[e/y])V~[x, e, y] = I &#38;x # &#38;y A ~) Let yl,y2,... ,y~ be the locations mentioned in 7~. Then \nWP(x=e, ~) is defined to be ~o[x, e, yl][x, e, y2]... [x, e, yn]. In the example above, we have wP(x \n= 3, *v > 5) = (&#38;x=pA3>5) V(&#38;xtpA*p>5) In the absence of alias information, if the predicate \n~o has k locations occurring in it, the weakest precondition will have 2 k syntactic disjuncts, each \ndisjunct considering a possible alias scenario of the k locations with x. C2BP uses a pointer analysis \nto improve the precision of the weakest precondi- tion computation. If the pointer analysis says that \nx and y cannot be aliased at the program point before x=e, then we can prune the disjuncts representing \na scenario where x is aliased to y, and we can partially evaluate the disjuncts representing a scenario \nwhere x is not aliased to y. This has the effect of improving the precision of the resulting boolean \nprogram BP(P, E) produced by C2Bp. Our implementation uses Dee's points-to algorithm [12] to obtain flow-insensitive, \ncontext-insensitive may-alias information. 4.3 Predicate Abstraction of Assignments Consider an assignment \nstatement \"x = e;\" at label g in P. The boolean program BT~(P, E) produced by C2BP will contain at label \ng a parallel assignment to the boolean vari- ables in scope at g. A boolean variable bi in BTP(P, E) \ncan have the value true after g if .7\"w(WP(x = e,~oi)) holds before g. Similarly, bi can have the value \nfalse after g if Uv(WP(x = e,-~ol)) holds before ~. Note that these two predicates cannot be simultaneously \ntrue. Finally, if nei- ther of these predicates holds before g, then bl should be set non-deterministically. \nThis can happen because the predi- cates in E are not strong enough to provide the appropriate information, \nor because the theorem prover is incomplete. Therefore, BP(P, E) contains the following parallel assign- \nme.at at label ~: bl,... ,b~ = choose (JC'v (WP(x=e, ~1) ), .T'v (W P(x=e, -~1 ))), choose (.~v (WP(x=e, \n~n)), Iv (WP(x=e, ~))) where the choose function is always part of BP(P,E) and is defined as follows: \nheel choose(bool pos, heel neg) ( if (pos) { return true; } if (neg) { return false; } return unknown() \n; } For example, consider abstracting the statement \"*p=*p+x\" in procedure foo of Figure 2 with respect \nto the three predicates declared to be local to foo. Let us call this statement s. In this example, a \nmay-alias analysis reveals that ,p cannot alias x or r. The weakest precondition WP(s,*p _< 0) is (*p \n+ x) _< 0, since *p cannot alias x. We have $(~y(*p + x _< 0)) = (*p _< O) A (x = 0). Similarly, WP(s,-~(*p \n< 0)) is ~((*p + x) _< 0), and $(.Tv(-~(*p+x _< 0))) = -~(*p < 0)A (x = 0). The weakest preconditions \nof s with respect to the predicates (x = 0) and (r = 0) are the respective predicates them-selves, since \n,p cannot alias x or r. Thus, I3P(P,E) will contain the following statement in place of the given assign- \nment statement, where we use {e} to denote the boolean variable representing predicate e: {*p<=O}, {x==0}, \n{r==0} = choose({*p<=0} ~&#38; {x==0}, !{*p<=0} &#38;&#38; {x==0}), choose ({x==0} , ! {x==O}), choose({r==0} \n, !{r==0}) ; Note that the abstraction process for assignment state- ments is based on weakest precondition \ncomputations that are localto each assignment and can be computed by &#38; purely syntactic manipulation \nof predicates. C2BP does not compute compositions of weakest preconditions over paths with complex control \nflow. In particular, C2BP does not re- quire programs to be annotated with function pre-or post-conditions, \nor with loop invariants. 4.4 Predicate Abstraction of Gotos and Condition- als Every goto statement in \nthe C program is simply copied to the boolean program. Translating conditionals is more involved. Consider \nsome conditional if (eft) {...} else {... } in program P. At the beginning of the then branch in P, the \npredicate ~ holds. Therefore, at the beginning of the then branch in the cor-responding conditional in \nBP(P, E), the condition Gy(~o) is known to hold. Similarly, at the beginning of the elsebranch in P, \nwe know that ~ holds, so ~y('~) is known to hold at that program point in BTo(P, E). Therefore, 137)(P, \nE) will contain the following abstraction of the above conditional: i~(,){ assume (QV (~o))  assumo(~v(-~)) \n ) Note that the test in the abstracted conditional is *, so both paths through the conditional are possible. \nWithin the then and else branches, we use the assume statement to retain the semantics of the original \nconditional test. The assume statement is the dual of assert: assume(g) never fails. Exe- cutions on \nwhich ~, does not hold at the point of the assume are simply ignored [16]. As an example, consider the \nconditional in procedure foe of Figure 2. The abstraction of this conditional with respect to the three \npredicates local to foe is: if (*) { // if (*p <= x) assume ({x == O} ~ {*p <= 0});  } else { ass=e \n({x := 0} ~ !{*p <: 0}); } 4.5 Predicate Abstraction of Procedure Calls We now describe how C2BP handles \nmulti-procedure pro- grams. 4.5.1 Notation Recall that the input to C2BP is the program P and a set E \nof predicates. Let Gp be the global variables of the program P. Each predicate in E is annotated as being \neither global to BP(P, E) or local to a particular procedure in BP(P, E) (see Figure 2, in which predicates \nare local to bar or foe -there are no global predicates in this example), thereby determining the scope \nof the corresponding boolean vari- able in B'P(P, E). A global predicate can refer only to vari- ables \nin Gp. Let E~ denote the global predicates of E and let Vc denote the corresponding global boolean variables \nof BP (P, E). For a procedure R, let ER denote the subset of predicates in E that are local to R, and \nlet VR denote the corresponding local boolean variables of R in B'P(P, E). In the following, we do not \ndistinguish between a boolean variable b and its corresponding predicate \u00a3(b) when unambiguous from the \ncontext (that is, in the context of B79(P, E) we always mean b and in the context of P we always mean \n\u00a3(b)). Let FR be the formal parameters of R, and let LR be the local variables of R. Let r E LR t3 FR \nbe the return variable of R (we assume, without loss of generality, that there is only one return statement \nin R, and it has the form \"return r\"). Let vats (e) be the set of variables referenced in expres- sion \ne. Let drfs(e) be the set of variables dereferenced in expression e. 4.5.2 Determining signatures A key \nfeature of our approach is modularity: each proce- dure can be abstracted by C2BP given only the signatures \nof procedures that it calls. The signature of procedure R can be determined in isolation from the rest \nof the program, given ER. C2BP operates in two passes. In the first pass it determines the signature \nof each procedure. It uses these signatures to abstract procedure calls (along with all other statements) \nin the second pass. Let R be a procedure in P and let R ~ be its abstraction in BoP(P, E). The signature \nof procedure ~R is a four-tuple (FR, r, E/, E~), where: * Fn is the set of formal parameters of R, , \nr is the return variable of R, \u00ae El is the set of formal parameter predicates of R', de- fined as {e \n6 ER ]pars(e) n LR = @}, and * E~ is the set of return predicates of R', defined as: {e E ER I (r e pars(e) \nA (pars(e) \\ {r} n L~ = @))V (e 6 E/A (pars(e) n Gp # $ Vdrfs(e) n F, # O))}. E l is the set of formal \nparameter predicates of R'. This is the subset of predicates in ER that do not refer to any lo- cal variables \nof R. All predicates in ER - E/will be locals of R ~. E~ is the set of predicates to be returned by R' \n(boolean programs allow procedures to have multiple return values). Such return predicates serve two \npurposes. One is to pro- vide callers with information about r, the return value of R. The other purpose \nis to provide callers with information about any global variables and call-by-reference parameters, so \nthat local predicates of callers can be updated precisely. To handle the first concern, E~ contains those \npredicates in ER that mention r but do not mention any (other) locals of R in P, as callers will not \nknow about these locals. To handle the second concern, E~ contains those predicates in Ef that reference \na global variable or dereference a formal parameter of R. As an example, consider procedure bar in Figure \n2. In the signature of bar, E/ is {*q <_ y, y _> 0) and Er is {y = ll, *q _< y}. 4.5.3 Handling procedure \ncalls Consider a call v = R(al, ... ,aj) to procedure R at label of some procedure S in P. The abstraction \nBP(P, E) contains a call to R' at label g. Let the signature of R be (FR, r, Ey, E~). For each formal \nparameter predicate e 6 E/, C2BP computes an actual value to pass into the call. Let e' = e[all f,, a21f2, \n. . . , a~ I fj]  where FR = {fl, f2 ..... fj }. The expression e' represents the predicate e translated \nto the calling context. The actual parameter computed for the formal e is caoos~(.rvs ~v~ (e'), :rv~v~ \n(-~e')). We now explain how C2BP handles the return values  from the call to R'. Assume Er = {el,... \n,ep}. C2BP cre- ates p fresh local variables T = {tl,... , tp} in procedure S' and assigns to them, in \nparallel, the return values of R': tl,... ,tp =R'(...); The final step is to update each local predicate \nof S whose value may have changed as a result of the call. Any predi- cate in Es that mentions v must \nbe updated. In addition, we must update any predicate in Es that mentions a global variable, a (possibly \ntransitive) dereference of an actual pa- rameter to the call, or an alias of either of these kinds of \nlocations. C2BP uses the pointer alias analysis to determine a conservative over-approximation E~ to \nthis set of predi- cates to update. Let E' = (EsUEG)-Eu. The predicates in E' along with the predicates \nin Er are used to update the predicates in E~. Let V' C Vs U VG be the boolean variables in BP(P, E) \ncorresponding to E'. First C2BP translates the predicates in E~ to the calling context. In particular, \nfor each ei E E~, let ~ = ~i[vlr, all/l, a~l:~,... , a~l/j] {e~,... ,ep}.4 ti fi T. For each e 6 E~, \nthe corresponding boolean variable b E Vs is assigned the following value: and let E'~ = ' Define \u00a3(ti) \n= ei, for each choose (,T'V, uT (e), .,T'V,uT(~e)). For example, consider the call \"bar(p,x)\" in Figure \n2. Recall that in the signature of bar, the formal parameter predicates (El) are {,q _< y,y >_ 0} and \nthe return predi- cates (Er) are {y = ll, ,g < y}. The abstraction of this call in the boolean program \nis as follows: prml = choose({*p<=O}~{x==O}, // for formal {*q<=y} ! {*p<=O}~{x==O}) ;  prm2 = choose({x==O}, \nfalse); // for formal {y>=O} tl, t2 = bar(prml, prm2); // tl for {*q<=y} // t2 for {y==ll} {*p<=O} \n= choose(tla&#38;{x==O}, !tl&#38;&#38;{x==O}); {r==O} = choose(t2~&#38;{x==O}, !t2~&#38;{x==O}; 4.6 \nFormal properties We give two properties that relate P and BT~(P, E). The first property, soundness, \nstates that B is an abstraction of P --every feasible path in P is feasible in B as well. Since a boolean \nprogram that allows all paths to be feasible is sound as well, we also need to state the sense in which \nB is precise. We do that via the terminology of abstract interpretation [11]. Soundness. For any path \np feasible in P, it is guaranteed that p is feasible in BP(P, E) as well. Further, if ~ is the state \nof the C program P after executing path p, then there exists an execution of p in the boolean program \nB ending in a state F such that for every 1 < i < n, ~i holds in fl iff bi is true in F. A proof of the \nsoundness of C2BP can be found in [3]. Precision. The framework of abstract interpretation can be used \nto specify abstractions declaratively. A boolean ab- straction maps concrete states to abstract states \naccording to their evaluation under a finite set of predicates. A carte-sian abstraction maps a set of \nboolean vectors to a three- valued vector obtained by ignoring dependencies between the components of \nthe vectors (see, for example, the work on set-based analysis [21]). For example, the set of boolean \nvectors {(0, 1), (1, 0)} is mapped by the cartesian abstrac- tion to the three-valued vector (?, ?), \nwhere ? represents the \"don't know\" value. For single procedures without pointers, 4For simplicity, we \nassume that each formal still refers to the same value as its corresponding actual at the end of the \ncall. This can be checked using a standard modification side-effect analysis [24]. If a formal cannot \nbe proven to refer to the same value as its correspond-ing actual at the end of the call, then any predicates \nthat mention the formal must be removed from Er in the signature of R. 209 the abstraction computed by \nC2BP is equivalent to a com- position of the boolean and cartesian abstractions [4]. We improve precision \nby using disjunctive completion and focus operations, both of which are implemented in BEBOP using BDDs \n[4]. 5 Extensions This section describes various techniques we have applied to increase the precision \nand efficiency of C2BP. 5.1 The enforce construct Often the predicates in E are correlated in some way. \nFor example, consider the predicates (x = 1) and (x = 2). The semantics associated with these predicates \nforbids the pred- icates from being simultaneously true. However, when we use uninterpreted boolean variables \nbl and b2 for the pred- icates in BT~(P, E), we do not preclude an execution of the boolean program in \nwhich both variables evaluate true in some state. In order to rule out abstract executions contain- ing \nsuch spurious situations, we add an enforce construct to boolean programs: the statement enforce 0 in \na procedure has the effect of putting assume 0 between every statement in the procedure. This ensures \nthat 0 is a data invariant maintained throughout the procedure's execution. We com- pute 0 for each procedure \nR simply as YvRova (false). For example, given only predicates (x = 1) and (x = 2), g(O) is -~((~= i) \nA (~ = 2)). 5.2 Optimizations The method described above for constructing abstract mod- els of C programs \nis impractical without several important optimizations. Profiling shows that the running time of C2BP \nis dominated by the cost of theorem proving, as we are making an exponential number of calls to the prover \nat each program point. Therefore, our optimization efforts have fo- cused on cutting down the number \nof calls to the theorem prover. First, when computing jrv (~o), cubes are considered in increasing order \nby length. If a cube c is shown to imply ~o, then we know that any cube that contains c as a subset will \nalso imply qp, is redundant with c, and can therefore be safely pruned. In this way, the .T computation \nactually produces a disjunction of only the prime implicants of 5ry(~o). If a cube c does not imply ~ \nbut it implies -~, then any cube that contains c as a subset also will not imply ~, and can therefore \nbe safely pruned. Second, for every assignment statement, rather than up- dating the values of every \nboolean variable in scope, we do not update those variables whose truth value will definitely not change \nas a result of the assignment. The truth value of a variable b will definitely not change as a result \nof an assignment x=e if WP(x=e, g(b)) = g(b). Third, for each computation .Ty(~o), we perform an anal- \nysis to produce a set V' C V, such that \u00a3(V') contains all predicates from g(V) that can possibly be \npart of a cube that implies ~. Therefore, ~v (~o) can safely be replaced by ~y' (9o), reducing the number \nof cubes to explore. This set V' is determined by a syntactic cone-of-influence computa- tion. Starting \nwith an empty set E' we find predicates in g(V) that mention a location or an alias of a location in \ncp, add these predicates to E', determine the set of locations mentioned in these predicates, and iterate \nuntil reaching a Table 1: The device drivers run through C2BP. program iine~ predicates thm. prover cNls \n(s__e.conds2 floppy 6500 23 5509 gg~ ioctl 1250 5 500 -/5- openclos 544 5 132 srdriver log 350 236-- \n30 6 3034 98 -Z------- fixpoint. V' C. V is the set of boolean variables such that \u00a3(V') = E'. Fourth, \nwe try several syntactic heuristics to construct 9Cy(~o) directly from 7~. As a simple example, if there \nexists a boolean variable b such that g(b) = ~, then we return b, without requiring any calls to the \ntheorem prover. Fifth, we cache all computations by the theorem prover and the alias analysis, so that \nwork is not repeated. While the worst-case complexity of computing the ab- straction is exponential in \nthe number of predicates, the above optimizations dramatically reduce the number of calls made to the \ntheorem prover in most examples. More-over, the above optimizations all have the property that they leave \nthe resulting I37~(P, E) semantically equivalent to the boolean program produced without these optimizations. \nSome of the optimizations described rely on the existence of the enforce data invariant for soundness. \nIf we are willing to sacrifice some precision, there are other optimization opportunities. For example, \nwe can limit the length of cubes considered in the .T\" computation to some constant k, lowering the 9 \nv function's complexity from expo- nential to O(nk). In practice, we have found that setting k to 3 provides \nthe needed precision in most cases. As another optimization, we can compute the Y function only on atomic \npredicates. That is, we recursively convert .T'(~i A 7~2) to .?'(7~0 A 5c(~2) and Y(~ol V ~2) to f(~l) \nV ~(~2). This allows us to make use of all of the existing optimizations of the Y function described \nabove in a finer-grained man-ner. Distribution of .T\" through A loses no precision, while distribution \nof .T\" through V can lose precision. 6 Experience We have implemented C2BP in OCaml, on top of the AST \ntoolkit (a modified version of Microsoft's C/C++ compiler that exports an abstract syntax tree interface \nto clients), the Simplify [15, 27] and Vampyre [7] theorem provers, and Das's points-to analysis [12]. \nWe have applied C2BP to two problem areas: (1) check- ing safety properties of Windows NT device drivers, \nin the context of the SLAM project and the SLAM toolkit; (2) discovering invariants regarding array bounds \nchecking and list-manipulating code. 6.1 The SLAM Toolkit and its Application to NT Device Drivers The \ngoal of the SLAM project is to automatically check that a program respects a set of temporal safety properties \nof the interfaces it uses. Safety properties are the class of properties that state that \"something bad \ndoes not happen\". An example is requiring that a lock is never released without first being acquired \n(see [23] for a formal definition). Given a program and a safety property, we wish to either validate \nthat the code respects the property, or find an execution path that shows how the code violates the property. \nGiven a safety property to check on a C program, the SLAM process has the following phases: (1) abstraction, \n(2) model checking, and (3) predicate discovery. We have developed the SLAM toolkit to support each of \nthese phases: C2BP, which is the topic of this paper; o BEBOP, a tool for model checking boolean programs \n[5]; o NEWTON, a tool that discovers additional predicates to refine the boolean program, by analyzing \nthe feasibil- ity of paths in the C program (the subject of a future paper).  The SLAM toolkit provides \na fully automatic way of check- ing temporal safety properties of system software. Viola- tions are reported \nby the SLAM toolkit as paths over the program P. The toolkit never reports spurious error paths. Instead, \nit detects such paths and uses them to automati- cally refine the boolean program abstraction (to eliminate \nthese paths from consideration). Since property checking is undecidable, the SLAM refinement algorithm \nmay not con- verge. In addition~ it may terminate with a \"don't know\" answer due to the incompleteness \nof the underlying theorem provers. However, in our experience, it usually converges in a few iterations \nwith a definite answer. One reason for this is that the properties we checked are very control-intensive, \nand have relatively simple dependencies on data. We ran the SLAM toolkit on four drivers from the Win- \n dows 2000 Driver Development Kit 5, as well as an internally developed floppy device driver, to check \nfor proper usage of locks and proper handling of interrupt request packets (see [6] for the details of \nthe properties checked). The de- vice drivers in the DDK are supposed to be exemplars for others to base \ntheir device drivers on. For the two properties we checked, the SLAM toolkit validated these drivers \n(i.e., found no errors). For the floppy driver under development, the SLAM toolkit found an error in \nhow interrupt request packets are handled. Table 1 shows the sizes of these drivers, the number of predicates \nin the predicate input file, the number of theorem prover queries that C2BP made, and the run time for \nC2BP. For all these examples (and those of the next section), BE- BOP ran in under 10 seconds on the \nboolean program output by C2BP. 6.2 Array Bounds Checking and Heap Invarlants Table 2 shows the results \nof running C2Bp on a set of toy illustrative examples. The program Imp is a Knuth-Morris- Pratt string \nmatcher and qsort is an array implementation of quicksort, both examples used by Necula [26]. The pro- \ngram partition is the list partition example from Figure 1, listfind is a list search example, and reverse \nis an exam- ple that reverses a list twice. In most cases, the cone-of- influence heuristics in C2BP \nwere able to reduce the number of theorem prover calls to a manageable number. In the case of the reverse \nexample, every pair of pointers could potentially alias, and the cone-of-influence heuristics could not \navoid the exponential number of calls to the theorem prover. 5freely available from http://www.microsoft, \ncom/ddk/ Table 2: The array and heap intensive programs analyzed with C2BP. program lines predicates \nthm. prover runtime calls (seconds) kmp [ 75 286 7 qsort 45 199 partition 55 263 9 listfind 37 4412 172 \nreverse 73 26769 747 struct node { int mark; struct node *next; }; void mark(struct node *list) { struct \nnode *this, *tmp, *prey; prey = O; this = list; /* traverse list and mark, setting back pointers */ while( \nthis != 0 ) { if(this->mark==l) break; this->mark = 1; imp = prey; prey = this; this = this->next; \nprev->next = tmp;  } /* traverse back, resetting the pointers */ while( prev!=O ){ imp = this; this \n= prey; prev= prev->next; this->next = trap; } } Figure 3: List traversal using back pointers In our \nexperiments, we were able to construct useful in- variants in the code by modeling only a few predicates \nthat occurred in the program. For example, in the array bounds checking examples (kmp and qsort), where \nan array a was indexed in a loop by a variable index, we simply had to model the bounds index > 0 and \nindex < length(a) in or- der to produce the appropriate loop invariant. We found that in most cases, \nthe component predicates of the invari- ant were easy to guess by looking at the conditionals in the \nprograms. The list reversal example reverse is a simplified version of a mark-and-sweep garbage collector. \nWe show the pro- gram in Figure 3. In the first while loop, the list is traversed in the forward direction, \nwhile maintaining back pointers to the previous nodes. In the second loop, the pointers are re- versed \nto get the original list. We wish to verify that the procedure mark leaves the shape of the structure \nunchanged: i.e., for every node h in the list, h ~ next points to the same node before and after the \nprocedure mark. To check this, we introduced auxiliary variables h and hnext into the C code. The variable \nh is chosen non-deterministically to point at any (non-null) element of the list, and hnext is initialized \nwith h->next. We input the following predicates to C2BP (along with the program of Figure 3): mark { \n h== 0, prey == h, this == h, this->next == hnext, prev == this, h->next == hnaxt, hl%ext->next \n== h } With this choice of predicates, C2BP constructs an abstract program which is analyzed using \nBEBOP. BEBOP shows that at the end of the mark procedure, h --~ next --hnext holds. 7 Related Work Our \nwork is inspired by the predicate abstraction work of Gra\u00a3 and Saidi [19]. Predicate abstraction has \nbeen used in the verification of cache coherence protocols [13]. However, these efforts work at the specification \nlevel, on a language with guarded commands. Doing predicate abstraction on a general-purpose programming \nlanguage is the novel as-pect of our work. A method for constructing abstract mod- els from Java programs \nhas been developed in the Bandera project [17]. Their tool requires the user to provide finite- domain \nabstractions of data types. Predicate abstraction as implemented in C2BP is more genera/, as it allows \nthe finite partitioning of a variable's possible values and addi- tionally allows relationships between \nvariables to be defined. Another approach is to use richer type systems to model finite-state abstractions \nof programs [14]. Shape analysis [30] also uses a form of predicate abstrac- tion, where the predicate \nlanguage is a first-order logic aug- mented with transitive closure. In contrast, our predicates are \nquantifier-free. Shape analysis requires the user to spec- ify how each statement affects each predicate \nof interest, whereas the C2BP tool computes the abstract transition sys- tem automatically using a theorem \nprover. Predicate abstraction is a general technique that can be used to add predicate (read \"path\") \nsensitivity to program analyses. Ammons and Larus use code duplication followed by a traditional data.flow \nanalysis to achieve path-sensitive results [1]. Bodik and Anik use symbolic back-substitution (i.e., \nweakest preconditions) followed by value numbering to improve the results of a subsequent three-valued \ndatafiow analysis [8]. The combination of predicate abstraction by C2BP and path-sensitive dataflow analyses \nin BEBOP could be used to achieve similar results. Prior work for generating loop invariants has used \nsym- bolic execution on the concrete semantics, augmented with widening heuristics [32, 33]. The Houdini \ntool guesses a candidate set of annotations (invariants) and uses the ESC/Java checker to refute inconsistent \nannotations until convergence [18]. In contrast, the tools C2BP and BEBOP use a combination of abstraction \n(from C program to boolean program) and iterative analysis of the abstracted C program to find loop invariants \nexpressible as boolean functions over a given set of predicates. 8 Conclusions We summarize our main \ncontributions: o C2BP is the first predicate abstraction tool that works on a general-purpose programming \nlanguage.  We have taken efforts to handle features such as pro- cedures and pointers in a sound and \nprecise way.  We have explored several optimizations to reduce the number of calls made to the theorem \nprover by C2BP.  We have demonstrated the use of C2BP on pro- grains from varying domains --device \ndrivers, array- manipulating programs, and pointer-manipulating pro- grams.  Though we fully support \npointers in C2BP, our predi- cates are quantifier-free. Stating certain properties of un- bounded data \nstructures may require a more expressive logic. For this purpose, it would be interesting to enrich the \npredicate language with dependent types and recursive types. Among other things, the aliasing problem \nbecomes more complicated in this setting. For example, if T is a type  that denotes lists of even length, \nthen the predicate (p 6 T) is true if p points to an object of type T. Consider an as- signment of the \nform q->next = NULL. To update (p 6 T), we have to consider the possibility that q can point any- where \ninside the list pointed to by pfi One way around this difficulty is to use linear types to encode that \nthere are no external pointers to the list other than p. It would also be interesting to investigate \nthe use of predicates expressible in some recent pointer logics [29, 22]. We have focused on predicate \nabstraction of single- threaded programs, and it would be interesting to extend C2BP to work for multi-threaded \ncode. Several issues need to be resolved here. First, one needs to establish an ap-propriate notion of \natomicity of execution. Next, while ab- stracting any statement one has to account for the possibility \nof interference from another thread. Even if such an abstrac- tion were possible, model checking boolean \nprograms with even two threads is undecidable. One possible solution is to further abstract boolean programs \nto finite-state machines, and then use traditional model checking algorithms to ex- plore interleaving \nexecutions of the finite-state machines. A further problem is that in certain situations, it is not possi- \nble to know the number of threads in advance. If we were to first abstract boolean programs to finite-state \nmachines, then it is possible to use parameterized model checking to handle an arbitrary number of threads \n[2]. It is not clear if these abstractions can be performed automatically. We have chosen C as our source \nlanguage for predicate abstraction. However, our fundamental contribution is a set of techniques to handle \nprocedure calls and pointers dur- ing predicate abstraction. The techniques in this paper can be adapted \nto construct predicate abstractions of programs written in other imperative languages such as Java. We \nplan to improve some inefficiencies we have in the implementation. The theorem prover is currently started \nas a separate process each time it is used, which is very inefficient. A more fundamental issue is that \nwe currently use theorem provers as black boxes. We plan to investigate if opening up the internals of \nthe theorem prover can improve the efficiency of the abstraction process. Generating predicates for a \npredicate abstraction tool like C2BP is another open research problem. We are cur- rently building a \ntool called NEWTON in the SLAM toolkit to 6We thank Frank Pfenning for this observation. generate predicates \nh'om the model checker's counterexam- [14] R. DeLine and M. F~hndrich. Enforcing high-level protocols \nples, using path simulation. We are also exploring predicate in low-level software. In PLDI 01: Programming \nLanguage generation using value flow analysis on the program, with Design and Implementation. ACM, 2001, \nrespect to the properties of interest. Our current approach seems to work as long as the properties of \ninterest have relatively simple dependencies on data. For data-intensive properties, predicate generation \nmay have to use widening heuristics as in [32, 331 . Acknowledgements. We thank Andreas Podelski for \nhelp- ing us describe the C2BP tool in terms of abstract interpre- tation. We thank Manuvir Das for providing \nus his one- level flow analysis tool. We thank the developers of the AST toolkit at Microsoft Research, \nand Manuel F/ihndrich for providing us his OCaml interface to the AST toolkit. We thank Craig Chambers \nfor several interesting discus- sions about C2BP. Thanks also to the members of the Soft- ware Productivity \nTools research group at Microsoft Re- search for many enlightening discussions on program anal- ysis, \nprogramming languages and device drivers, as well as their numerous contributions to the SLAM toolkit. \nReferences [1] G. Ammons and J. R. Larus. Improving data-flow analysis with path profiles. In PLDI 98: \nProgramming Language Design and Implementation, pages 72-84. ACM, 1998. [2] T. Ball, S. Chaki, and S. \nK. Rajamani. Parameterized ver- ification of multithreaded software libraries. In TACAS 01: Tools and \nAlgorithms/or Construction and Analysis of Sys- tems, LNCS 2031. Springer-Verlag, 2001. [3] T. Ball, \nT. Millstein, and S. K. Rajamani. Polymorphic pred- icate abstraction. Technical Report MSR Technical \nReport 2001-10, Microsoft Research, 2000. [4] T. Ball, A. Podelski, and S. K. Rajamani. Boolean and carte- \nsian abstractions for model checking C programs. In TA GAS OI: Tools and Algorithms for Construction \nand Analysis of Systems, LNCS 2031. Springer-Verlag, 2001. [5] T. Ball and S. K. Rajamani. Bebop: A symbolic \nmodel checker for Boolean programs. In SPIN 00: SPIN Workshop, IJNCS 1885, pages 113-130. Springer-Verlag, \n2000. [6] T. Ball and S. K. Rajamani. Automatically validating tem- poral safety properties of interfaces. \nIn SPIN 2001: SPIN Workshop, LNCS 2057, May 2001. [7] D. Blei and et al. Vampyre: A proof generating \ntheorem prover --http://www.eecs.berkeley.edu/\" rupak/vampyre. [8] R. Bodik and S. Anik. Path-sensitive \nvalue-flow analysis. in POPL 98: Principles o/Programming Languages, pages 237-251. ACM, 1998. [9] R. \nBryant. Graph-based algorithms for boolean function ma- nipulation. IEEE Transactions on Computers, C-35(8):677-691, \n1986. [10] J. Corbett, M. Dwyer, J. Hatcliff, C. Pasareanu, Robby, S. Laubach, and H. Zheng. Bandera \n: Extracting finite- state models from Java source code. In ICSE 00: Software Engineering, 2000. [11] \nP. Cousot and R. Cousot. Abstract interpretation: a unified lattice model for the static analysis of \nprograms by construc- tion or approximation of fixpoints. In POPL 77: Principles of Programming Languages, \npages 238-252. ACM, 1977. [12] M. Das. Unification-based pointer analysis with directional assignments. \nIn PLDI 00: Programming Language Design and Implementation, pages 35-46. ACM, 2000. [13] S. Das, D. L. \nDill, and S. Park. Experience with predicate ab- straction. In CAV 00: Computer-Aided Verification, LNCS \n1633, pages 160-171. Springer-Verlag, 1999. [15] D. Detlefs, G. Nelson, and J. Saxe. Simplify theorem \nprover -http://research.compaq.com/src/esc/simplify.html. [16] E. Dijkstra. A Discipline of Programming. \nPrentice-Hall, 1976. [17] M. Dwyer, J. Hatcliff, R. Joehanes, S. Laubach, C. Pasare- anu, Robby, W. Visser, \nand H. Zheng. Tool-supported pro- gram abstraction for finite-state verification. In ICSE 01: Software \nEngineering (to appear), 2001. [18] C. Flanagan, R. Joshi, and K. R. M. Leino. Annotation in- ference \nfor modular checkers. Information Processing Letters (to appear), 2001. [19] S. Graf and H. Sa'idi. Construction \nof abstract state graphs with PVS. In CA V 97: Computer-aided Verification, LNCS 1254, pages 72-83. Springer-Verlag, \n1997. [20] D. Gries. The Science of Programming. Springer-Verlag, 1981. [21] N. Heintze. Set-based analysis \nof ML programs. In LFP 94: LISP and Functional Programming, pages 306-317. ACM, 1994. [22] S. Ishtiaq \nand P. O'Hearn. BI as an assertion language for mutable data structures. In POPL 01: Principles of Pro- \ngramming Languages, pages 14-26. ACM, 2001. [23] L. Lamport. Proving the correctness of multiprocess \npro- grams. IEEE Transactions on Software Engineering, SE-3(2):125-143, 1977. [24] W. Landi, B. G. Ryder, \nand S. Zhang. Interprocedural side effect analysis with pointer aliasing. In PLDI 93: Program- ming Language \nDesign and Implementation, pages 56-67. ACM, 1993. [25] J. M. Morris. A general axiom of assignment. \nIn Theoretical Foundations of Programming Methodology, Lecture Notes of an International Summer School, \npages 25-34. D. Reidel Publishing Company, 1982, [26] G. Necula. Proof carrying code. In POPL 97: Principles \nof Programming Languages, pages 106-119. ACM, 1997. [27] G. Nelson. Techniques for program verification. \nTechnical Report CSL81-10, Xerox Palo Alto Research Center, 1981. [28] T. Reps, S. Horwitz, and M. Sagiv. \nPrecise interprocedu- ral dataflow analysis via graph reachability. In POPL 95: Principles of Programming \nLanguages, pages 49-61. ACM, 1995. [29] J. C. Reynolds. Intuitionistic reasoning about shared muta- ble \ndata structure. In Millenial Perspectives in Computer Science, pages 303-321. Palgrave, 2001. [30] M. \nSagiv, T. Reps, and R. Wilhelm. Parametric shape anal- ysis via 3-valued logic. In POPL 99: Principles \nof Program- ming Languages, pages 105-118. ACM, 1999. [31] M. Sharir and A. Pnueli. Two approaches to \niaterprocedural data dalow analysis. In Program Flow Analysis: Theory and Applications, pages 189-233. \nPrentice-Hall, 1981. [32] N. Suzuki and K. Ishihata. Implementation of an array bound checker. In POPL \n77: Principles of Programming Languages, pages 132-143. ACM, 1977. [33] Z. Xu, B. P. Miller, and T. Reps. \nSafety checking of ma- chine code. In PLDI 00: Programming Language Design and Implementation, pages \n70-82. ACM~ 2000.   \n\t\t\t", "proc_id": "378795", "abstract": "<p>Model checking has been widely successful in validating and debugging designs in the hardware and protocol domains. However, state-space explosion limits the applicability of model checking tools, so model checkers typically operate on abstractions of systems.</p><p>Recently, there has been significant interest in applying model checking to software. For infinite-state systems like software, abstraction is even more critical. Techniques for abstracting software are a prerequisite to making software model checking a reality.</p><p>We present the first algorithm to automatically construct a <i>predicate abstraction</i> of programs written in an industrial programming language such as C, and its implementation in a tool &#8212; C2BP. The C2BP tool is part of the SLAM toolkit, which uses a combination of predicate abstraction, model checking, symbolic reasoning, and iterative refinement to statically check temporal safety properties of programs.</p><p>Predicate abstraction of software has many applications, including detecting program errors, synthesizing program invariants, and improving the precision of program analyses through predicate sensitivity. We discuss our experience applying the C2BP predicate abstraction tool to a variety of problems, ranging from checking that list-manipulating code preserves heap invariants to finding errors in Windows NT device drivers.</p>", "authors": [{"name": "Thomas Ball", "author_profile_id": "81100472343", "affiliation": "Microsoft Research", "person_id": "PP39044398", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "U.C. Berkeley", "person_id": "P335105", "email_address": "", "orcid_id": ""}, {"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "Univ. of Washington", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}, {"name": "Sriram K. Rajamani", "author_profile_id": "81100468626", "affiliation": "Microsoft Research", "person_id": "P266638", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/378795.378846", "year": "2001", "article_id": "378846", "conference": "PLDI", "title": "Automatic predicate abstraction of C programs", "url": "http://dl.acm.org/citation.cfm?id=378846"}