{"article_publication_date": "09-01-2000", "fulltext": "\n Invited Talk: Advanced Module Systems: A Guide for the Perplexed Robert Harper Benjamin C. Pierce Carnegie \nMellon University of Pennsylvania The past three decades have seen a plethora of language features for \nlarge-scale software composition. Some of these are fairly simple, others quite sophisticated. Each embodies \nan implicit claim that its particular combination of features is both necessary and sufficient for some \nproblem domain. But there have been few attempts to compare module systems, or to explain the practical \nand theoretical issues that motivate the choices they embody. This can make it difficult to evaluate \nwhich features are really needed for a given setting, and which may be overkill. We offer here an overview \nof the design space of module systems, with reference to those of some well\u00adknown languages (especially \nthe ML family and Java), and record the motivating examples and crucial design choices underlying some \ncentral features. In particular: we identify a fundamental distinction between unresolved, resolved, \nand generic references between modules;  we compare different ways of handling families of interfaces \n(in particular, abstracted vs. augmented interfaces);  we investigate the need for coherence (or sharing \n) constraints and consider different ways of expressing them;  we confirm a folk theorem that sharing \nby parameterization doesn t scale as well as sharing by specification; and  we explain the significance \nof the phase distinction for the design of first- and second-class module systems, and the distinctions \nbetween first-order and higher-order variants of second-class systems.  130 \n\t\t\t", "proc_id": "351240", "abstract": "The past three decades have seen a plethora of language features for large-scale software composition. Some of these are fairly simple, others quite sophisticated. Each embodies an implicit claim that its particular combination of features is both necessary and sufficient for some problem domain. But there have been few attempts to <i>compare</i> module systems, or to explain the practical and theoretical issues that motivate the choices they embody. This can make it difficult to evaluate which features are really needed for a given setting, and which may be overkill.", "authors": [{"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "Carnegie Mellon", "person_id": "PP39029370", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351252", "year": "2000", "article_id": "351252", "conference": "ICFP", "title": "Advanced module systems (invited talk): a guide for the perplexed", "url": "http://dl.acm.org/citation.cfm?id=351252"}