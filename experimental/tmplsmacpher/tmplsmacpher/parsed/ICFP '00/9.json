{"article_publication_date": "09-01-2000", "fulltext": "\n Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. ICFP \n00, Montr\u00e9al, Canada. Copyright 2000 ACM 1-58113-202-6/00/0009 $5.00. animation should look like, not \nhow it should be implemented. The key notions are the use of behaviors and events. Behaviors are time\u00advarying, \nreactive values, while events are streams of values that occur over time. This paper presents FranTk, \nan extension of Fran to take it from graphics programming to the construction of complex user interfaces. \nThe major new contributions in FranTk are as follows: . FranTk lifts Fran s behaviors and events to widgets. \nThis is the key to the declarative style of programming. The appearance of a widget can be defined for \nall time in terms of FranTk combinators (Section 3). This declarative style is supported when programming \nboth static and dynamic interfaces (Section 7,8). The construction of systems with dynamically changing \nnumber of components can be difficult in many GUI systems, and frequently requires a very imperative \nand sometimes cumbersome style of programming. . FranTk extends Fran with support for hierarchical interactive \ndisplays, allowing access to input from individual components rather from one monolithic window. (Section \n3) . FranTk separates visual composition from semantic wiring. (Section 3.3). These two concepts are \nfundamental to GUI programming. The first involves geometric composition. For instance, placing one widget \nabove another. The second involves connecting user input from a widget to the application code. This \nseparation is made possible by the introduction of listeners, consumers that respond to user input (Section \n4). FranTk provides an algebra to compose these listeners in a functional style (Section 5). . FranTk \nprovides a more efficient implementation of the core Fran combinators. This implementation improves on \nFran s data-driven model and use of weak references (Section 10).  2. FRAN AN INTRODUCTION Fran is \na high level language for constructing reactive animations. 2.1 Fran benefits There are five key aspects \nthat makes it a good candidate for forming the basis of a User Interface development language. 1. Behavioral \nModelling. Fran uses first-class behavior values to model changing values in an animation. A behavior \nvalue is a value that changes over time. It can be thought of as type Behavior a = Time -> a. As an example \nwe can make a circle that follows the wave path shown in figure 1. Its position is a function of time; \nit moves along the screen as time passes, and up and down as the sin of time. Figure 1 A wave motion \nball moveXY time (sin time) circle moveXY :: Behavior Double-> Behavior Double -> ImageB -> ImageB time \n:: Behavior Double  2. Event Modelling. Events, like behaviors, are first-class values. An event is \na stream of values that occurs at discrete points in time. It can be thought of as type Event a = [(Time,a)]. \nWe can use events to model happening in the real world, such as button presses, and predicates based \non behavior values, such as collisions between objects. For instance, a left button press is simply lbp \nu, where u is a User argument. An event that occurs once, when the time is greater than 5, is onceE (predicate \n(time > 5)). They can be combined as lbp u .|. onceE (predicate (time > 5)). The type signatures for \nthe functions we have used are shown below. lbp ::User -> Event () predicate :: Behavior Bool -> Event \n() onceE :: Event a -> Event a (.!.) :: Event a -> Event a -> Event a  3. Declarative Reactivity. \nMuch of the power of Fran comes from the interaction of behaviors and events. We can define reactive \nbehaviors , that change as events occur. We can therefore give a declarative rather than an imperative \nsemantics to state changes [3]. For instance, we can describe a color-valued behavior that starts out \nblue, and then changes to red when the left button is pressed, and changes to green when the right button \nis pressed. blue `stepper` lbp u -=> red .|. rbp u -=> green stepper :: a -> Event a -> Behavior a \n 4. Declarative Composition. Animations can be constructed compositionally. We can create two balls following \nwave motions, one that moves as the sin and one as the cos of time. Note that these two animations evolve \nconcurrently, and yet are described in a simple, deterministic manner. moveXY time (sin time) circle \n`over` moveXY time (cos time) circle  5. Models and Views. We can define a behavior to represent the \nstate of an animation and then define a function that transforms this state into an image. For instance, \nwe can describe a moving object abstractly in terms of a data type with behaviors. It has a colour and \na location. data Obj = Obj (Behavior Color) (Behavior Point2) We can then define a function that turns \nthis colour and location into an image. view (Obj pos col) = move pos (withColor col circle) move :: \nBehavior Point2 -> ImageB -> ImageB withColor :: Behavior Color->ImageB->ImageB The features discussed \nabove provide a powerful approach to building interactive systems. We could describe the state of an \ninteractive system as a behavior, reacting to user input events. These components could be easily composed \nin a declarative manner. We could also support a Model-View style of programming where the state of the \napplication is described abstractly and the appearance described as a function of that state.  2.2 \nFran problems Fran as it exists in its basic form has two serious conceptual restrictions that must be \novercome to extend it to interactive systems design. 1. Hierarchical input. The most significant problem \nwith Fran is that it does not provide any support for constructing hierarchical interactive displays. \nAll user input is accessed through the User argument passed to the animation. This represents input at \nthe level of the entire graphics window. There is no way to access interaction from only a single component, \nsuch as an individual button on the screen. The only conceivable mechanism would be to use global mouse \ncoordinates and calculate whether they were within the bounding box of a given object. This approach \ndoes not lend itself at all to building hierarchical collections of components, each with their own coordinate \nsystems. This is not usually a major problem in animations; however, the notion of individual interaction \nobjects is critical to the development of standard user interfaces. 2. Dynamic collections. Fran provides \nbehavioral values. These could be used to represent behavior collections of objects. For instance, we \ncould display a dynamic list of objects. However if we were to render such a behavior collection, each \ntime an element were to be added the entire collection would have to be redrawn. This would be prohibitively \nexpensive if we needed to continually recreate complex compound collections. Fran requires some notion \nof a incremental behavioral collection that could be both viewed as a behavior and efficiently and incrementally \nrendered.  In developing FranTk we have overcome both these problems. We demonstrate through a series \nof examples how this was done. These examples are elements of a prototype Air Traffic Control (ATC) simulator. \nAfter presenting the individual elements, we will discuss (in Section 9), how well FranTk scaled to handling \nthe complete application.  3. A SIMPLE TIMER We begin with a simple example to introduce some basic \nconcepts. The ATC system contains a timer showing the time, in seconds, that have elapsed since the start \nof the simulation (see Figure 2). The concepts necessary to produce this interface will be presented \nin this section. Figure 2 A simple example 3.1 Introducing Components The basic conceptual notion in \nFranTk for handling interaction objects is the Component. For instance, in our example we have two label \ncomponents displayed one beside the other. They appear in a window component. A Component is an action \nthat produces a WidgetB. The action will be performed once, when the widget is to be displayed. type \nComponent = GUI WidgetB This definition uses the GUI monad, which is an extension of the standard IO \nmonad. Values of type GUI a represent actions that may have some side effect on the user interface, such \nas creating a label, and return a value of type a. A WidgetB is an abstract data type representing a \nWidget Behavior. It is similar to Fran's ImageB type representing Image Behaviors. An Image Behavior \nmodels both geometric composition of different images and temporal compositions, as the image changes \nover time. In the same way a Widget Behavior represents both geometric compositions of different widgets \nand temporal compositions, as the appearance may also be dynamic. As with Fran's ImageB, defining WidgetB \nas an abstract data type allows for an efficient implementation. These basic components can be composed \ngeometrically using simple, functional combinators. For instance, our example is made of two labels, \nthe title label and the timevalue label. We can place them using beside. timer :: Component timer = \ntitle `beside` timevalue above :: Component -> Component-> Component Though components represent imperative \nactions that will each produce a widget, we can treat them as an abstract value and so compose them declaratively. \nThis satisfies our aim of supporting a compositional style of programming in FranTk. FranTk distinguishes \nbetween three different types of user interface component, based on how they can be displayed. We have \nbasic components (Component), such as labels and buttons, which can be composed using combinators such \nas beside. Secondly, we have graphical components (CComponent), such as lines and circles, which can \nbe placed in canvases, and manipulated using animation combinators, based on those provided in Fran. \nFinally, we have toplevel window components (WComponent), which will contain basic components. These \ncan be composed by piling them into groups and can be placed at different locations on the screen. For \nthe purposes of graphical and temporal composition, there is no difference between a button and a label. \nThey can both be placed in the same way, and so need only be represented by a single component type. \nMany previous systems have used different types to distinguish between them. This typing was required \nto allow access to user input from the component, and to apply changes to the component, such as resetting \nthe label, later on. This approach makes it more difficult to geometrically compose a list of widgets \nas they must be transformed to an untyped display object first. As we will see in the next section, in \nFranTk all the information necessary to define a component is passed in as a set of parameters so this \nsort of extra transformation can be avoided. This approach is very significant and is discussed further \nin Section 4.3.  3.2 Configuring Components In our example we have two labels with different appearances. \nOne has a static appearance; one a dynamic appearance. We create a label using the mkLabel function and \nconfigure it using the text and textB functions. mkLabel :: [Conf Label] -> Component text :: Has_text \nw => String -> Conf w We use mkLabel to make a label. It takes a list of configuration information, \nin this case, some text to display. As with TkGofer [14] we use type classes to guarantee that only the \ncorrect configuration information can be applied to any widget. The text function takes a String and \nreturns a configuration option that can be applied to any object that is a member of the Has_text class. \nThis class includes labels, as they are capable of displaying text. We therefore define the static title \nlabel as follows. title :: Component title = mkLabel [text Time Elapsed: ] In FranTk, we extend basic \nconfiguration with dynamic configuration options. Instead of taking a static value a widget can be given \na dynamic behavior value. This approach is the key to the declarative nature of FranTk. Rather than having \nto carry out imperative updates to change a component s appearance, we can define, using a behavior, \nwhat it will look like for all time. Given a behavioral model of an application, we can therefore define \nthe appearance of the interface simply as a function of the application's state. We can define the timer \nlabel as follows. timevalue :: Component timevalue = do time <- timeTick 1 mkLabel [textB (lift1 show \ntime)] textB ::Has_text w=>Behavior String->Conf w timeTick :: Time -> GUI (Behavior Time) lift1 :: \n(a -> b) ->Behavior a->Behavior b The function timeTick creates a behavior that represents the time, \nand changes at a given frequency. In our example, the time value changes every second. The function lift1 \nmaps a function over a behavior, to yield a new behavior. This shows the benefit of the GUI representation \nof a Component. We can create some local state for a component while still thinking of it as a value. \n 3.3 Rendering Components When we have defined an interface in terms of a Window Component, to render \nit onto the screen we use render. This will perform the action necessary to produce the window widget \nbehavior, and then display it. render :: WComponent -> GUI () Finally, to run the GUI actions that we \nhave produced we use start. This runs the action and then starts up the tcl-tk event loop. This event \nloop will run until the graphical user interface quits, at which point it will return. start :: GUI () \n-> IO () As start and render are often used together there is a composite function display. display \n:: WComponent -> IO () display = start . render To test the timer component on its own, we would place \nit in a window, and so define main as follows. main :: IO () main = display (mkWindow [] timer) mkWindow \n:: [Conf Window] -> Component -> WComponent  4. AN INTERACTIVE EXAMPLE So far we ve dealt with an interface \nwith a dynamic appearance but with no interaction. This section demonstrates how interaction is handled \nin FranTk. Figure 3 An interactive example Consider the interface shown in Figure 3. It shows a simplified \nversion of the tactical data entry widget from the ATC system, which allows the controller to tell the \naircraft to change flight level. The proposed level can each be altered, by either typing a value or \nusing the slider. If an invalid value is typed into the text field, it will have no effect. Once the \nlevel has been set the controller presses send to fire off the message. The entry and scale widgets must \nmaintain a consistent view of one underlying value. The send button will have to sample it to generate \na value. We therefore have multiple views of some data. 4.1 Representing State in FranTk To represent \nthe state in the example we use a BVar. A value of type BVar a represents some abstract mutable state \nof type a. data BVar a We can create a new BVar within the GUI or the IO monad. Most commonly we use \nthem within the GUI monad. newBVar :: a -> IO (BVar a) mkBVar :: a -> GUI (BVar a) It is possible to \nget a behavior from a BVar. bvarBehavior :: BVar a -> Behavior a The behavior therefore represents the \nflight level value at any give point in time. It is possible to get an event from a BVar bvarEvent :: \nBVar a -> Event a The event from a BVar generates an occurrence every time the value of the BVar is updated. \nIn our example we would therefore represent the state of the flight level editor as a value of type BVar \nInt. The use of BVars is therefore a fundamental and important feature of FranTk. They provide us with \na mechanism to represent state, but to use it in a functional style.  4.2 Using State in FranTk What \ncan we do with a behavior? We can tell the slider and edit widget to display the behavior values that \nwe get from the BVar. We can tell the slider to use the value of the BVar with scaleValB. This sets the \nvalue of the slider to that of an integer behavior. (We will fill in the rest of the definition later.) \nscale :: BVar Int -> Component scale bv = mkHScale [scaleValB (bvarBehavior bv)] (...) scaleValB :: \nBehavior Int -> Conf w As shown in section 3.2 we can tell a widget to show a string behavior using textB, \nand we transform the integer behavior into a string behavior using lift1. (We will fill in the rest of \nthe definition later.) entry :: BVar Int -> ... -> Component entry bv = mkEntryRtrn [textB (lift1 \nshow (bvarBehavior bv))] (...) We can therefore easily provide multiple views of the state of an application. \n 4.3 Listeners - Updating State in FranTk We can set the value of a BVar using its Listener. bvarInput \n:: BVar a -> Listener a bvarUpdInput :: BVar a -> Listener (a -> a) A listener is an abstract type, \nbut it can be thought of as Listener a = a -> IO (). A value of type Listener a, is a function, that \ngiven a value of type a, performs a side\u00adeffecting IO action with it. Listeners are therefore consumers \nof values. The listener accessed by bvarInput updates the BVar with its given value. This will alter \nthe value of the BVar s behavior and generate an event occurrence. The listener accessed by bvarUpdInput \nupdates the BVar by applying the given function to its current value. We can therefore complete the definition \nof the slider as follows. scale bv = mkHScale [..] (bvarInput m) mkHScale :: [Conf Scale] -> Listener \nInt -> Component The function mkHScale takes a listener argument, which is passed the current value \nevery time the slider updates the BVar with its changed value. The slider simply updates the value of \nthe BVar with its changed value. The introduction of listeners is a very important design choice. Initially \nthis choice may seem strange. The use of behaviors and events encourages a more functional style of programming. \nHowever, the use of listeners introduces an imperative concept into this functional approach. The introduction \nof listeners brings an important benefit. We give component-making functions a consumer (listener) argument \nwhich allows them just to yield their visual aspect in the form of a Component. This approach makes geometric \ncomposition simple. The alternative would be to return a pair of visual and semantic handles, in the \nform of a Widget and an Event providing access to all user input on that widget. This alternative makes \ncomponent composition more complex. To compose two components we would now require to compose their Widget \nand Event parts. This style can become tiresome when composing complex collections of components, as \nprogrammers are forced to continually compose and break down compound events. 4.4 Composing Complex \nListeners FranTk introduces combinators that allow listeners to be composed in a functional style. As \nan example, consider the definition of the text entry widget in our example. entry :: BVar Int -> (String \n-> Maybe Int) -> Component entry bv parse = mkEntry [...] (comapMaybeL parse (bvarInput bv)) mkEntryRtrn \n:: [Conf Entry] -> Listener String -> Component The function mkEntryRtrn takes a listener argument, \nwhich is passed a String representing the state of the entry widget, every time the return key is pressed. \nWe therefore need to make the entry talk to the listener provided by the BVar. We do this using comapMaybeL. \ncomapMaybeL :: (b -> Maybe a) -> Listener a -> Listener b Figure 4 shows how comapMaybeL works. It is \na version of the standard mapMaybe function; however, it applies what appears to be an inverse function \nto a listener. This is because listeners are consumers, not producers, of values. It creates a new listener \nthat consumes values of type b. When it hears a value, it applies the mapping function, and if this returns \na value of type Just a, it passes it to its argument listener. Listener expects values of type a comapMaybeL \n Value of type Listener b Figure 4 The tellL listener In the definition of entry we therefore produce \na listener that parses the entry String, and only updates the application's state, if it is valid.  \n4.5 Sampling the State When the \"send\" button is pressed, we must sample the state of the BVar and generate \na message. sendB :: BVar Int->Listener Int-> Component sendB bv send = mkButton [text \"send\"] (snapshotL_ \nbv send) We can make a listener snapshot a behavior and consume its current value using snapshotL_. \nsnapshotL_ :: BVar a -> Listener a -> Listener b As shown in Figure 6, every time the new listener is \nfired it samples the behavior and passes its current value to its argument listener. a Figure 5 The \nsnapshot listener This is therefore a very useful combinator, as it is often necessary to sample the \nstate of the application when some user input occurs. We can now complete the definition of the tactical \ndata entry widget. It takes as parameters a callsign to display as the title of a window, an initial \nvalue to use for the level, and a listener to pass the generated message to. It creates a BVar to model \nthe state of the proposed level, and then creates a window containing the given components. levEditor \n:: String -> Int -> Listener Int -> WComponent levEditor callsign init send = do bv <- mkBVar init \n mkWindow [title callsign] (nabove [beside (mkLabel [text \"Lev\"]) (entry bv parse), scale bv, sendB \nbv send]) title :: String -> Conf Window nabove :: [Component] -> Component   5. THE LISTENER ALGEBRA \nFranTk provides an algebra of listener combinators. Though a listener is essentially an imperative callback, \nthis algebra allows us to treat and compose them in a functional manner. This algebra is dual to the \nevent algebra provided in Fran. Each operation in the event algebra has a corresponding operation in \nthe listener algebra. We will first present the most significant operations in the listener algebra, \nand then define formally how these relate to the event algebra. 5.1 The Listener Combinators The null \nlistener is neverL, which does nothing with any value it receives. neverL :: Listener a To merge two \nlisteners we use mergeL, which that takes two listeners and produces a new listener that consumes values \nand passes them to both its argument listeners. mergeL :: Listener a -> Listener a -> Listener a Listener \n1 Listener 2 Figure 6 - The merge listener We can therefore define, allL, a combinator that merges a \nlist of listeners. allL :: [Listener a] -> Listener a allL xs = foldr mergeL neverL xs There is a comap \nfunction on listeners. In contrast to the standard map function, this applies what appears to be an inverse \nfunction to a listener. It produces a listener that consumes values, and applies the given function to \nthese values before passing them on to the given listener. comapL :: (b -> a) -> Listener a -> Listener \nb A commonly used variant of comapL is tellL, which simply overrides the value a listener is passed. \ntellL :: Listener a -> a -> Listener b tellL l a = comapL (const a) l There is a filter function on \nlisteners. This consumes values and passes them on to the given listener, if they satisfy the given predicate. \nfilterL :: (a -> Bool) -> Listener a -> Listener a We can create a one shot listener that consumes one \nvalue and then behaves as neverL using onceL. onceL :: Listener a -> Listener a For instance, we might \nrequire a button that could only ever be pressed once. We could define this using onceL. mkOnceButton \n:: [ConfB Button] -> Listener a -> Component mkOnceButton cs l = mkButton cs (onceL l) As seen in \nSection 4.5, we can make a listener snapshot a behavior and consume its current value. The more general \nversion of the snapshot function is snapshotL. Every time the new listener consumes a value it samples \nthe behavior and passes the pair of values to its argument listener. snapshotL :: Behavior b -> Listener \n(a,b) -> Listener a There is a listener equivalent of the scanl function. scanlL :: (a > b -> a) -> \na -> Listener a -> Listener b This works as shown in Figure 7. The listener s current value starts with \nthe initial value provided. Every time the listener consumes a value b, it applies its update function \nf to its current value a and the new value, b. It passes (f a b) to the argument listener, and updates \nits current value as well. b This combinator can be very useful when we require to accumulate a value \nevery time a listener is fired. For instance, we could make a listener count up, and pass on, the number \nof times it had been fired using this function. countL :: Listener Int -> Listener a countL l = scanL \ninc 0 l where inc :: Int -> a -> Int inc n _ = n + 1 Previous functional toolkits would require a programmer \nto write this sort of code in terms of an IO action that sampled a mutable variable. In conclusion, while \nprogrammers must still use imperative callbacks in FranTk, they can manipulate them succinctly with a \nset of functional combinators, instead of being forced to write longer and more cumbersome imperative \ncode.  5.2 Event-Listener Duality The event and listener algebras in Fran are duals of each other. We \ncan therefore formally define a set of relationships between them. The primitive combination operation \nfor events and listeners is addListener. This adds a listener to an event such that the listener is fired \nevery time there is an event occurrence. This function returns a remove action that can be called to \nunregister the listener s interest. addListener :: Event a -> Listener a -> IO (IO ()) The relationship \nbetween events and listeners can be defined in terms of the addListener function. For any e :: Event \na, l :: Listener a, l1 :: Listener b, f ::a -> b,p :: a -> Bool, b :: Behavior b, l2 :: Listener (a,b), \ne1 :: Event b, n :: a, op :: a -> b -> a addListener neverE l <==> addListener e neverL neverE :: \nEvent a addListener (mapE f e) l1 <==> addListener e (comapL f l1) mapE :: (a -> b) -> Event a -> \nEvent b addListener (filterE p e) l <==> addListener e (filterL p l) filterE :: (a -> Bool) -> Event \na -> Event a addListener (onceE e) l <==> addListener e (onceL l) onceE :: Event a -> Event a addListener \n(snapshotE b e) l2 <==> addListener e (snapshotL b l2) snapshotE :: Behavior a -> Event a -> Event \n(a,b) addListener (scanlE op n e1) l <==> addListener el (scanlL op n l) scanlE :: (a -> b -> a) -> \na -> Event b -> Event a If we imagine a wire1 connecting a listener to an event, the event and listener \ncombinators can be interpreted as mechanisms to transform user input code at either end of the wire (Figure \n8). Apply Apply event listener combinators combinators Event Figure 8 A Wire  6. INTRODUCING WIRES \nSometimes we need to connect output from one component into another component. For instance, consider \na button and entry widget. When enter is pressed the current text is sampled and passed to a listener. \n1 Fran introduced the notions of listeners, events and wires in version 2. However, it did not provide \nany of the listener combinators discussed in this paper. Figure 9 Entry and Button We can define this \nas follows. mkEntryWithButton :: String -> Listener String -> Component mkEntryWithButton bname inputL \n= do wire <- mkWire let button = mkButton [text bname] (tellL (input wire) ()) entry = mkEntry [] (event \nwire) inputL beside entry button  This uses a new concept called a Wire. A Wire is a limited version \nof a BVar. In particular, it is stateless and has no behavior. It has only an input listener and an event. \nmkWire :: GUI (Wire a) newWire :: IO (Wire a) wireInput :: Wire a -> Listener a wireEvent :: Wire a -> \nEvent a  We therefore have the following structure in our example (see Figure 10) The button talks \nto the wire when it is clicked  When the entry hears something on the wire it sends its current value \nto the BVar.  Wires and the mkWire functions are primitive in FranTk. We can define a BVar in terms \nof a wire. data BVar a = BVar { bvarUpdInput :: Listener (a -> a), bvarEvent :: Event a, bvarBehavior \n:: Behavior a } newBVar :: a -> IO (BVar a) newBVar a = do (l,e) <-newWire let e' = a `accumE` e let \nb = a `stepper` e' return (BVar l e' b)  The definition of a BVar relies on two Fran combinators. The \nBVar hears update function values on the wire. These updates will modify its state. It accumulates an \nevent based value using accumE. This will therefore form an event that produces an occurrence on every \nupdate, by applying the update function to the current BVar value. accumE :: a -> Event (a -> a) -> Event \na  The function accumE is defined in terms of scanlE. accumE x0 change = scanlE (flip ($)) x0 change \n The BVar s behavior is formed by stepping through, changing on every event occurrence. stepper :: a \n-> Event a -> Behavior a We can use this approach to define other types of BVar, such as BVar collections \ndiscussed in Section 8.  7. DYNAMIC EXAMPLES PART I The previous examples have shown how to implement \nsimple interfaces in FranTk. However, they have involved only a static set of widgets on screen. That \nis, though the appearance of individual labels has changed, the number of labels has not. The ability \nto handle dynamically changing collections of components in FranTk is one of its major benefits. There \nare two sorts of dynamic display we could have. The first is a simple conditional display. Here we can \ndisplay one of two components depending on some state. The second sort of dynamism is the introduction \nof new components on to a screen. We will introduce a conditional display in this section, and then a \nfull dynamic display in Section 8. 7.1 Conditional Displays As an example consider the tactical data \nentry widget from Figure 3. It will only be displayed some of the time. It will be popped up when requested. \n(There are a number of different aircraft views, each which can raise the data entry window). When the \n\"send\" button is pressed it will disappear. To handle this we provide a BVar to model the state of the \nwindow. When the \"send\" button is pressed the window should close, so we merge the send listener with \nthe BVar's listener. levWindow :: BVar Bool -> String -> Int -> Listener Int -> WComponent levWindow \nbv callsign init send = let sendAndOpen = mergeL send (tellL (bvarUpdInput a) False) in ifB (bvarBehavior \nbv) (levEditor callsign init sendAndOpen) emptyComponent We conditionally display a component using \nifB. class GBehavior w where ifB :: GBehavior w => Behavior Bool -> w -> w -> w instance GBehavior Component \n When applied to components ifB b w1 w2 produces a component which behaves as w1 when b is True and w2 \notherwise. (Other members of the GBehavior class include Behaviors and Events.) In this example we display \nthe levWindow when the BVar has the value True and an empty component otherwise. emptyComponent :: Component \n This provides us with our first mechanism for dynamically altering the number of widgets on screen at \nany given time.  8. DYNAMIC EXAMPLES - PART II We will now consider a dynamic example with a variable \nnumber of components on screen at any given time. The ATC system must model the state of all the aircraft \nin a given airspace sector. This set of aircraft will clearly change over time. We therefore need to \nmaintain some model of a dynamic collection of aircraft. The ATC simulator uses three different views \nof the set of aircraft (see Figure 11). It displays a radar view with a dot and some flight data for \neach aircraft. It displays an electronic strip for each aircraft in the Aircraft Display Window. Finally, \nit displays details of the selected aircraft in the Flight Data Plan window. It is therefore very important \nthat we have one abstract model of the data that can be viewed in several ways. 8.1 Introducing Behavioral \nCollections We need to define the collection of objects that are displayed on the screen. In most previous \nGUI systems, we would do this by performing update actions that add and delete widgets from the screen. \nIn FranTk, we define the appearance of an interface based on some state for all time. We therefore need \nto be able to define the display as a function of some abstract collection type. We do this using a behavioral \ncollection, in this case a list. For instance, the radar view consists of canvas components, with one \naircraftView for each aircraft. Similarly, we have one strip in the aircraft display window for each \naircraft. aircrafts :: ListB Aircraft -> CComponent aircrafts ls = pile (fmap aircraftView ls) aircraftView \n:: Aircraft -> Ccomponent aircraftDisplay :: ListB Aircraft -> Component aircraftDisplay ls = nabove \n(fmap strip ls) strip :: Aircraft -> Component type ListB a fmap :: (a -> b) -> ListB a -> ListB \npile :: ListB CComponent -> CComponent nabove :: ListB Component -> Component In FranTk we represent \na dynamic list of objects as a ListB. We can map functions across this list. For instance, we map the \nstrip function over the list to generate a strip for each aircraft. We use nabove to compose a dynamic \ncollection of components above each other. We use pile to compose a dynamic collection of canvas components \ninto a complex view. In both cases, when rendered the ListB will incrementally update the screen only \nmaking necessary changes, rather than redisplaying everything.  8.2 Making list collections To make \na list collection we use a special type of BVar, a ListBVar. We can create a ListB from an initial list \nand an update event. It begins by behaving as the initial list, and then on every event occurrence, changes \nby applying the update function from the occurrence. mkListB :: IList a -> Event (IList a -> IList a) \n -> ListB a data IList a  This is therefore similar to the Fran behavior combinator, stepAccum, which \ncreates a piecewise constant behavior that is updated by event occurrences. stepAccum :: a ->Event (a \n-> a)->Behavior a stepAccum a e = stepper a (accumE a e) The IList type is a special incremental list \ntype that maintains incremental updates. The Haskell Edison library [8], defines a general interface \nfor dealing with functional data structures such as Sequences and Sets. The IList type implements the \nSequence interface, allowing us to treat them in the same way as standard lists. This therefore provides \na powerful, and familiar set of operators for constructing dynamic lists. We can therefore generate values \nof type IList using Sequence functions such as empty, single, cons and append. FranTk also supports the \nnotion of a list behavior variable, or ListBVar. type ListBVar a mkListBVar :: [a] -> GUI (ListBVar \na) newListBVar :: [a] -> IO (ListVar a) When creating a ListBVar we give it an initial list of values. \nWe have standard functions to extract the value, input listener, and update-input listener from a ListBVar. \nHere updates are also defined using the IList type. collection :: ListBVar a -> ListB a bvUpdInput :: \nListBVar a -> Listener (IList a -> IList a) bvInput :: ListBVar a -> Listener (IList a) These behavioral \ncollections are powerful. They allow us to declaratively handle dynamic collections of data. In the next \nsection we demonstrate how to filter a dynamic collection.  8.3 Sorting list collections It is often \nnecessary to apply functions such as sort and filter across lists. FranTk provides the ability to sort \na dynamic list based on some dynamic predicate. For instance, in our example the strips in the Aircraft \nDisplay window can be sorted in a range Aircraft Display Window Flight Data Plan Windowof ways, such \nas by flight level. We can do this using sortByB. sortByB :: (a -> Behavior b) -> Behavior (b -> b -> \nOrdering) -> ListB a -> ListB a This takes a function to extract a behavior from a list element, and \na predicate valued behavior and applies these to filter the list. In our example, the predicate would \nbe set by the \"Sort by\" menu. The extraction function is needed because the elements of a dynamic list \nmay themselves be dynamic. The Aircraft type consists of a set of individual behaviors representing the \nparameters of the plane. data Aircraft = Aircraft { flightLevB :: Behavior Int, ... } From these we \nneed to extract a single behavior representing the relevant parameters needed for sorting. extract :: \nAircraft -> Behavior Extract data Extract = Extract { flightLev :: Int, ...} This style is very important \nand represents a common pattern for many FranTk programs. 8.4 Summary In FranTk we can therefore treat \ndynamic collections in a similar manner to static collections, modeling them as values. This allows us \nto easily manipulate them, and create multiple views of the same collection. For instance, in our current \nexample we have one sorted view of the dynamic list. In FranTk, we can easily construct dynamic interfaces \nin a declarative programming style. This makes it particularly easy to implement multi-user interfaces; \nhowever, it is important in many other styles of application.  9. LARGE EXAMPLES FranTk has been applied \nto a range of examples including the prototype Air Traffic Control simulator discussed in this paper \n(and shown in Figure 11), and a structured program editor. Message Windows Tactical Data Entry Aircraft \n Figure 11 - The Prototype Air Traffic Control Simulator 9.1 The ATC System In general, the development \nof a large, complex case study was relatively easy in FranTk. We were able to construct the system using \na consistent programming approach. The system was designed in terms of a set of components, which were \nintegrated in a compositional manner. The simulation is described as a collection of behaviours (representing \naircraft and sectors) that communicate via events. Each adjacent sector and aircraft is modelled as a \nfunction which accepts messages via an event stream, and produces an event stream generating a set of \nresponse messages. Each aircraft maintains an abstract trajectory model. The use of Fran behaviors proved \nvery useful when developing the ATC system. Using behaviours, we were able to provide a simple, elegant \nmodel of an aircraft s trajectory. The aircraft model then simply snapshots the appropriate flight parameters \nwhen it needs to generate a flight\u00adparameter downlink message (which tells the controller where the aircraft \nis). The active aircraft are then modelled as a dynamic set. New aircraft are created on the basis of \nan alarm event, which goes off according to a plan (read in from an input file). Aircraft are deleted \naccording to a predicate, which specifies when the aircraft leaves the user's screen, and therefore ceases \nto be useful. FranTk s support for real-time predicates therefore proved particularly useful when developing \nthe prototype. Predicates are also used, for instance, to define time outs on messages. The use of dynamic \ncollections to model the collection of aircraft, and datalink messages was again important. (A Datalink \nmessage is an electronic messages sent from a controller to an aircraft to inform it to change trajectory). \nThe system provides a number of different views of an aircraft s data and of the datalink message collection. \nFor instance, the \"Message In\", \"Message Out\" and \"Datalink Msgs\" windows each show a separate filtered \nview of the sector's datalink message set. The ability to provide multiple views of a dynamic collection \nwas therefore very important. The ATC system was a large case study consisting of several thousand lines \nof code. It runs at a usable speed, simulating several aircraft, when compiled under GHC. It was developed \nas a prototyping exercise in co-operation with a \"human factors\" specialist at the UK's National Air \nTraffic service. The resulting interface proved useful for him, and he requested a copy of the final \nsystem. 9.2 A Structured Editor FranTk has been used to develop a simple declarative implementation of \na structure editor for a small imperative language2. Bernard Sufrin and Oege De Moor have developed a \nsimple, purely functional, model of a structured editor. This model was developed as an executable formal \nspecification. They model the editor as a Tree, which accepts update operations. The FranTk implementation \nmaintains their simple, declarative model of the editor. It models the state of the editor using two \nparts, a Behavior Tree, modelling the current state, and a wire, upon which the Behavior is based. The \nwire hears about tree updates. This is therefore a special form of BVar used to represent the tree status. \nThe status of a text editor is itself represented by a document behavior. We therefore provided a simple \nmapping 2 This was joint work with Oege De Moor from Oxford University. between the Tree updates, and \ndeclarative structured document updates. We were therefore able to develop a relatively simple, very \nhigh level implementation of a structured editor. Though high level, the implementation is still efficient. \nIt runs at a usable speed, even when only run with Hugs, the Haskell interpreter. 10. IMPLEMENTATION \nDETAILS The efficient implementation of FranTk relies on three key features. It uses a data driven programming \nmodel. It uses weak references to limit the amount of work needing done. It uses an incremental implementation \nfor behavioral collections. In this section we will briefly summarize these key features. 10.1 Data driven \nimplementation A simple implementation of events and behaviors requires that behaviors and events are \nsampled every time interval. This would be prohibitively expensive in a large user interface, as every \naspect of the interface would need to be redisplayed every time any input was received. Instead FranTk, \nuses a data driven model. Events and behaviors have invalidation actions associated with them. When the \nlistener talking to the event or behavior is fired the invalidation action is performed. After any user \ninput only those components that rely on behaviors or events that have been invalidated need to be redrawn. \n10.2 Finalisers &#38; Weak References Once a BVar has been created, the listener will begin talking to \nthe BVar, passing on every value it hears. This is useful only so long as the event or behavior from \nthe BVar is in use. However, often these will only be used for a fraction of the lifetime of a program. \nFor instance, if a component were later removed from the screen and the behavior it relied upon was no \nlonger used it would be useful to remove the listener as well, to prevent unnecessary work. For this \npurpose, we use weak references and finalisers [11]. Weak references enable listeners to talk to events \nwithout keeping them alive in the heap. Finalisers are actions which can be added to an object, and which \nwill run when the object is garbage collected. This mechanism is used to delete listeners. When the clients \n(the events and behaviors) that a listener can talk to are all garbage collected, a finaliser will be \nrun to delete the listener. 10.3 Incremental behavior collections The implementation of efficient dynamic \ncollections requires some extra work. A collection behavior is considered to consist of two parts, a \nsimple behavior representing its value at any given time, and an event generating individual incremental \nchanges. For instance, a ListB consists of the following parts. data ListB a = ListB (Behavior [Entry \na]) (Event (ListUpdates a)) data ListUpdates a = LUpds [ListUpdate] | ResetL [Entry a] data ListUpdate \na = InsertL [Entry a] Pos | DeleteL Ident | MoveL Ident Pos data Entry = Entry Ident a data Ident \nThe Ident data type represents unique values. Each element in the list has a unique value associated \nwith it. Incremental changes involve inserting an element at a given point in a list, moving an element \nto another position in the list, deleting an element or resetting the list. Recall that updates to a \nList behavior are made using functions of type IList a -> IList a. These updates can clearly be based \non far more sophisticated notions that simple equality. The notion of unique identity is therefore very \nimportant. The IList type deals with generating unique names for entries, and for generating these updates. \nAn IList consists of a list of tagged entries, a name generator to make new named entries and a set of \ncurrent updates. Combinators such as cons require to generate a name for their new element, add the new \nelement to the list, and generate an appropriate update. data IList a = IList [Entry a] NameGenerator \n(ListUpdates a) type NameGenerator = a -> (Entry a,NameGenerator) To render the list on to an interface \nwe therefore make changes corresponding to each incremental update. 11. RELATED WORK There have been \na number of previous approaches to functional GUI toolkits. The TkGofer [14] toolkit is also built on \ntop of Tcl-Tk. As with FranTk, components are given lists of configuration information, and type classes \nare use to restrict which configuration options can be given to which components. We have extended this \napproach with dynamic configuration options. TkGofer provides a much lower level interface to GUI programming, \nrelying on callbacks. This results in a more imperative style of programming with all state being stored \nin mutable variables. Toolkits based around concurrency, such as Haggis [4], have been developed that \navoid the need for callbacks. Haggis provided a structured declarative approach to specifying pictures. \nHowever, this only worked for static images. Haggis treated dynamic widgets separately in a more imperative \nmanner. Haggis separated a widget into a typed value that could be used to update it, and an untyped \nhandle that could be used to display it. In contrast, we have one representation of a widget, the Component \nand pass all configuration information as parameters when creating the component. By passing in a listener \nas a parameter to the component, we avoid the need for a handle to access user input. The Fudgets toolkit \n[1] attempted to support a more declarative approach to building user interfaces. A Fudget is a value \nof type F a b that receives messages of type a and sends messages of type b. Fudgets can be composed \nto make more complex fudgets in a functional style. However, there is only limited support for creating \ninterfaces with a dynamic number of components on screen. Fudgets also makes it difficult to support \napplication and interface separation, making it difficult to have multiple views of the same data [5]. \nThe Clock [5] and Pidgets [12] toolkits are the most similar to our own. Clock is based on the well-known \nMVC [7] architecture. Clock programs are structured as a tree of components. Each component has a model \nwhich represents its state, and which can accept updates (similar to our listeners), and requests (similar \nto our behaviors). The component has a view function which describes its appearance. This is defined \nas a function of the state (using requests). A component can take updates which represent user input. \nThe tree structure represents the hierarchical decomposition of the interface. Components may have sub\u00adcomponents \nwhich they use when defining their view. The state in the model is visible to its component and all its \nchildren. Clock therefore allows dynamic views to be defined in terms of dynamic collections. However, \nthe Clock architecture is overly restrictive making it difficult to construct interfaces with complex \napplication behavior. The structure also makes it very difficult to define parameterised components with \nlocal state. Pidgets is a toolkit based around a monad of imperative streams . An imperative streams \nprogram is represented as a term of type St a. When run this will produce a value of type a at repeated \npoints during its execution. A stream produces values. However, it also has a current value, which is \nthe last value it produced. A stream may also perform IO actions while producing its value. An imperative \nstream therefore unifies our separate concepts of Behaviors, Listeners and Events. This conceptual combination \ncan make Pidgets difficult to deal with. For instance, it requires two new operators start and next to \nbe introduced into the language. start :: St a -> St (St a) next :: St a -> St a The next operator \ntakes a stream and returns one that ignores any values before the next time step. Starting a stream conceptually \nstarts it off as concurrent process. The start function returns a new stream which outputs a value every \ntime the concurrent stream produces one. This concept is important when IO actions are concerned as these \nwill be performed by the concurrent process and not by the returned stream. These two new operators can \nrapidly become difficult to handle. To give an impression of how FranTk compares to Object Oriented approaches \nwe will compare it to Java's Swing [6]. To provide support for application/interface separation, Swing \nhas embraced the Model-View-Controller paradigm. User Interface components can be associated with abstract \nmodels. For instance, there is a ListModel which defines the methods which components such as Swing listboxes \nuse to access lists. These models support the concept of Listeners. Java's Listeners, in fact, inspired \nthe notion of listener in Fran/FranTk. For instance, we can add a ListDataListener to a ListModel to \nfind out about any changes to its state. This is therefore similar to use of the primitive addListener \nfunction in FranTk. However, the notion of listener in FranTk is more general and more powerful. Java \ndistinguishes listeners based on what they can be added to. This means that it is sometimes difficult \nto add a listener in two places. For instance, Java distinguishes between MouseListener's which hear \nmouse clicks and ActionListener's which hear action events. FranTk, however, would consider both to be \nof type Listener ().We would therefore need to duplicate code in Java. In addition, in Java, to consume \nvalues of new types we must define new Listener classes. In contrast, FranTk listeners can be parameterised \nover any type. Conversion between listeners is also more cumbersome in Java. For instance, if we had \nan item listener (which hears about selected objects), and wanted it to be fired every time a button \nwas pressed, we would require to write the following code. It creates a new Action listener, which fires \nthe item change listener. ActionListener l = new ActionListener () {  public void actionPerformed(ActionEvent \ne) {i.itemStateChanged (new ItemEvent (e.getSource(), ItemEvent.ITEM_STATE_CHANGED, obj, ItemEvent.SELECTED))}}; \n In contrast, in FranTk we would simply use tellL to convert the listener: tellL itemListener obj. Java's \nmodels suffer from a similar restriction. Again they are less generic than BVars, which can be used to \nhold values of any type. Java's ListModels are also less powerful than FranTk's. To write the equivalent \nof FranTk's dynamic sorting function would take significantly more code. In conclusion, Java's Swing \ndoes provide more capabilities than FranTk. It also, like all imperative approaches, provides more low-level \ncontrol. This makes it easier to ensure efficiency. However, for many applications FranTk's combinators \nmake it more succinct. 12. CONCLUSIONS We have presented FranTk, a toolkit for developing graphical user \ninterfaces in Haskell. It concentrates on providing a programming model that is both declarative in the \nlarge and in the small . The state of an application can be defined as a behavior value. These values \ncan be easily composed. Unusually this extends to the ability to handle dynamic collections of objects \nas values, treating them in a functional manner. FranTk introduces the concept of a listener as an abstract \nvalue. Listeners allow imperative actions to be handled, but composed in terms of a functional algebra. \nFranTk defines an interface in terms of components. These are constructed by passing in configuration \noptions, including dynamic options. This allows us to define a component s appearance for all time. A \nListener argument is also passed in when creating a component, thereby separating the semantic wiring \nfrom the visual Component. These components can therefore be geometrically composed using simple, pure \nfunctions. However, a Component represents an action that produces a widget. This allows it to have its \nown internal state. FranTk therefore allows a compositional, declarative style of programming with both \nstatic and dynamic user interfaces. It has been developed on top of Tcl/Tk providing a set of platform \nindependent, powerful widgets. However, it has been implemented in a very toolkit independent manner, \nmaking it easier to port to other GUI toolkits. It has been released as a publicly available toolkit \n(http://www.haskell.org/FranTk). Finally, it has been applied to a range of large examples, including \na structured text editor, and an air-traffic control simulator. 13. ACKNOWLEDGMENTS Thanks to Conal Elliott \nand Simon Peyton Jones for valuable comments on this paper. Thanks also to Conal for helping me work \non the Fran core implementation, and to Simon Peyton Jones and the GHC group at Microsoft Research where \nI was employed as an intern to complete work on FranTk. Finally, thanks go to the UK's National Air Traffic \nServices for co\u00adoperating with the ATC case study. 14. REFERENCES [1] M Carlsson, T Hallgren: FUDGETS \n A Graphical User Interface in a Lazy Functional Language, Conference on Functional Programming Languages \nand Computer Architectures, 1993. [2] J Coplien, D Schmidt: Pattern Languages of Program Design, Addison-Wesley \n1995. [3] C Elliott, P Hudak: Functional Reactive Animation, International Conference on Functional Programming \n1997 (ICFP 97). [4] S Finne, SL Peyton Jones: Composing the User Interface with HAGGIS, Summer School \non Advanced Functional Programming, Olympia, WA, Aug 25-30, Springer Verlag LNCS, 1996. [5] TCN Graham, \nDeclarative Development of Interactive Systems. Volume 243 of Berichte der GMD. Munich: R. Oldenbourg \nVerlag, July 1995. [6] Sun Microsystems, The Java Swing Connection, available at http://java.sun.com/ \n[7] GE Krasner and ST Pope, A cookbook for using the Model\u00adView-Controller interface paradigm. Journal \nof Object-Oriented Programming, 1 (3):26-49. [8] BA Myers, DA Giuse, RB Dannenberg, BV Zanden, DS Kosbie, \nE Pervin, A Mickish, P Marchal, Garnet: Comprehensive Support for Graphical, Highly Interactive User \nInterfaces. In IEEE Computing, pages 71-85, November 1990. [9] Chris Okasaki, Edison User s Manual, available \nat http://www.haskell.org/. [10] J Ousterhout: Tcl and the Tk Toilkit, Addison-Wesley, 1992. [11] S Peyton \nJones, S Marlow, C Elliott: Stretching the Storage Manager: weak pointers and stable names in Haskell, \nin Implementing Functional Languages 1999. [12] E Scholz: Imperative Streams A Monadic Combinator Library \nfor Synchronous Programming, International Conference on Functional Programming 1998 (ICFP 98). [13] \nB. A. Sufrin and O. de Moor. Modeless structure editing. In: J. Davies, A. W. Roscoe and J.C.P. Woodcock \n(editors), Proceedings of the Oxford-Microsoft symposium in Celebration of the work of Tony Hoare, September \n13-15, 1999. [14] T Vullinghs, D Tuijnman, W Schulte: Lightweight GUIs for functional programming, Programming \nLanguages: Implementations, Logics and Programs, 7th International Symposium, Springer Verlag LNCS, 1999. \n  \n\t\t\t", "proc_id": "351240", "abstract": "FranTk is a new high level library for programming Graphical User Interfaces (GUIs) in Haskell. It is based on Fran (Functional Reactive Animation), and uses the notions of <i>Behaviors</i> and <i>Events</i> to structure code. Behaviors are time-varying, reactive values. They can be used to represent the state of an application. Events are streams of values that occur at discrete points in time. They can be used, for instance, to represent user input. FranTk allows user interfaces to be structured in a more declarative manner than has been possible with previous functional GUI libraries. We demonstrate, through a series of examples, how this is achieved, and why it is important. These examples are elements of a prototype, Air Traffic Control simulator. FranTk uses a binding to the popular Tcl/Tk toolkit to provide a powerful set of platform independent set of widgets. It has been released as a Haskell library that runs under Hugs and GHC.", "authors": [{"name": "Meurig Sage", "author_profile_id": "81100091280", "affiliation": "University of Glasgow, Dept of Computing Science, Glasgow, United Kingdom", "person_id": "P196068", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351250", "year": "2000", "article_id": "351250", "conference": "ICFP", "title": "FranTk - a declarative GUI language for Haskell", "url": "http://dl.acm.org/citation.cfm?id=351250"}