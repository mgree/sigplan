{"article_publication_date": "09-01-2000", "fulltext": "\n oa ,w who o w b ol N o. e in SM L ,w m a e t , his un ion is o t Ifwewerelookingupanint,thelistpassedtofindould \nonlyontainpairsofstringsandints.Wewouldnotbe abletostorevaluesofanyothertypethanintinoursymbol table. \nTheproblemisthat,inastatiallytypedlanguage,allel\u00adementsofalistneedtohavethesametype:Itwouldbe inorrettoformanassoiationlist[(\"x\",1);(\"y\", \n(2,3))].Aswedonotwanttoonstrainthesymboltable toontainonlyonetype,weneedtohidethetypeofthe valueforeahentryinthelist.Onepossibilityistousean \nexistentialtype[12].Theinstrution pakvas:;.ThidingT. oeresavalueoftypeTwithT. substitutedfor;intoone \noftype:;.T.Conversely,theinstrution unpak(;,x)=eine' destrutsanexistentialpakageeoftype:;.T,bindinga \nnewtypevariable;andanewtermvariablexoftypeT withintheexpressione'. Therefore,weanreateasymboltableoftype(stringX \n:;.;)listwiththeexpression [(\"x\",pak1as:;.;hidingint); (\"y\",pak(2,3)as:;.;hidingintXint] Sotheodeforinsertshouldjustpakageupitsargument \nandonsittotherestofthetable. valinsert= Aa.fntable=>fn(symbol,obj)=> (symbol,pakobjas:;.;hidinga)::table \nHowever,theexistentialtypehasnotreallysolvedtheprob\u00adlem.Weanreatethelist,butwhatdowedowhenwelook upasymbol \nItwillhavetype:;.;,butfindmustreturn avalueoftypea.Ifweusethesymboltableorretly,then aand;willabstratthesametype,butweneedtoverify \nthispropertybeforeweanonvertsomethingoftype;to typea.Weannotompareaand;andstillremainpara\u00admetriinaand;.Therefore,itseemsasthoughweneed \nalanguagethatsupportssomesortofnon\u00adparametripoly\u00admorphism(alsoalledrun\u00adtimetypeanalysis,overloading, \nor\"adho\"polymorphism).Formulationsofthisfeature inludeHaskelltypelasses[16],typeDynami[1,7,9],ex\u00adtensionalpolymorphism[3],andintensionalpolymorphism \n[6]. Fornow,wewillonsiderthelast,inHarperandMorrisett's language)...ThislanguageontainstheoreofSMLplus \nf anadditionaltypereoperatortoreursivelyexamineun\u00adknowntypesatruntime.Forsimpliity,wewillseparate reursionfromtypeanalysisandusetheoperatortypease \ntodisriminatebetweentypes,andretoomputetheleast fxedpointofareursiveequation. Thislanguageisinterpretedbyatype\u00adpassingsemantis. \nInotherwords,atruntimeatypeargumentispassedto atypeabstrationoftype'a.T,andanbeanalyzedby typease.Dually,whenwereateanobjetofanexisten\u00adtialtype,:a.T,thehiddentypeisinludedinthepakage, \nandwhenthepakageisopened,amayalsobeexamined. ).. Inf,universalandexistentialtypeshavediferentprop\u00adertiesfromasystemwithatype\u00aderasuresemantis,suhas \nthepolymorphilambdaalulus.Inatype\u00aderasuresystem, typesmayhavenoefetonrun\u00adtimeexeutionandthere\u00adforemaybeerasedaftertypeheking.There,'a.aisan \nemptytype(suhasvoid),and:;.;isequivalenttothe in).. singletontypeunit.However,f,'a.aisnotempty,as weanusetypeasetodefneanappropriatevalueforeah \ntype,and:;.;istheimplementationoftypeDynami,as weanusetypeasetoreoverthehiddentype. ).. Inf,asimplefuntion,sametype,toomparetwotypes \nandreturntrueiftheymath,anbeimplementedwith nestedtypeases.Theoutertypeasedisoversthehead normalformofthefrsttype,andthentheinnertypease \nomparesittotheheadnormalformoftheseond.1For produtandfuntiontypes,sametypeallsitselfreursively onthesubomponentsofthetype.Eahofthesebranhes \nbindstypevariables(suhasa1anda2)tothesubompo\u00adnentsofthetypessothattheymaybeusedinthereursive all. letresametype= \nAa.A;. typease(a)of int=> typease(;)of int=>true =>false (a1Xa2)=> typease(;)of (;1X;2)=> sametype[a1][;1] \nandalsosametype[a2][;2] =>false (a1-a2)=> typease(;)of (;1-;2)=> sametype[a1][;1] andalsosametype[a2][;2] \n =>false Asthesenestedtypeasesaretedioustowrite,weborrow fromthepatternmathingsyntaxofStandardML,andab\u00adbreviatethisfuntionas: \n1 Forbrevity,weonlyinludeint,produttypes,andfun\u00adtiontypesintheexamples. letresametype= Aa.A;. typease(a,;)of \n(int,int)=>true (a1Xa2,;1X;2)=> sametype[a1][;1] andalsosametype[a2][;2] (a1 -a2,;1 -;2)=> sametype[a1][;1] \nandalsosametype[a2][;2] ( , )=>false However,thoughthisfuntiondoesallowustodetermine iftwotypesareequal,itdoesnotsolveourproblem.In \nfat,itisjustaboutuseless.Ifwetrytouseitinour implementationoffind letrefind= Aa.fntable=>fnsymbol=> asetableof \n[]=>raiseNotFound ((name,pakage)::rest)=> unpak(;,value)=pakagein ifsymbol=name andalsosametype[a][;] \nthenvalue elsefind[a]restsymbol wedisoverthatthisusedoesnottypehek.Thereturn typeforfindistheexistentiallybound;whihesapesits \nsope.Eventhoughwehaveaddedadynamihekthat aisequivalentto;,thehekdoesnothangethetypeof valuefrom;toa. \nOurproblemisthatwedidnotusethefullpowerofthe typesystem.Inastandardaseexpression(asopposedtoa typease),eahbranhmustbeofthesametype.However, \n).. infthetypeofeahbranhofatypeaseandepend ontheanalyzedtype. typeaseTof int=>fn(x:int)=>x+3 a-;=> fn(x:a-;)=>x \naX;=> fn(x:aX;)=>x Forexample,althoughthefrstbranhaboveisoftype int-int,theseondoftype(;-,)-(;-,),and \nthethirdoftype(;X,)-(;X,),allthreebranhesare instanesofthetypeshema,-,,when,isreplaed withtheidentityofTforthatbranh.Therefore,thisentire \ntypeaseexpressionanbesafelyassignedthetypeT-T. Withthisfaility,inordertomaketypehekingatypease termsyntax\u00addireted,itisannotatedwithatypevariable \nandatypeshemawherethatvariablemayourfree.For exampleweannotatethepreviousexampleas ast:'a.';.a-; letreast= \nAa.A;. typease[\u00c61,\u00c62.\u00c61 -\u00c62](a,;)of (int,int)=> fn(x:int)=>x (a1Xa2,;1X;2)=> letvalf=ast[a1][;1] valg=ast[a2][;2] \nin fn(x:a1Xa2)=> (f(fstx),g(sndx)) end (a1 -a2,;1 -;2)=> letvalf=ast[;1][a1] valg=ast[a2][;2] in fn(x:a1 \n-a2)=> g\u00c6x\u00c6f end ( , )=>raiseCantCast Figure1:FirstSolution typease[,.,-,]Tof int=>fn(x:int)=>x+3 ... \nInlaterexamples,whenweusethepatternmathingsyntax fortwonestedtypeases,wewillneedtheshematohave twofreetypevariables. \nWenowhaveeverythingweneedtowriteaversionof sametypethathangesthetypeofatermandallowsus towritefind.Intherestofthispaperwewilldevelopthis \nfuntion,suggestivelyalledast,oftype'a.';.a-;. Thisfuntionwilljustreturnitsargument(atthenewtype) ifthetypeargumentsmath,andraiseanexeptionother\u00adwise.2 \nAninitialimplementationappearsinSetion2.Thoughor\u00adret,itsoperationrequiresundesirableoverheadforwhatis \nessentiallyanidentityfuntion.Weimproveit,inSetion3, throughtheaidofanadditionaltypeonstrutorargument \ntoast.Todemonstratetheappliabilityofthissolutionto othernon\u00adparametriframeworks,inSetion4,wedevelop theanalogoustwosolutionsinHaskellusingtypelasses. \nInSetion5,weomparethesesolutionswithseveralim\u00adplementationsoftypeDynami.Finally,inSetion6,we onludebyeliminatingthetypelassesfromtheHaskell \nsolutiontoprodueasymboltableimplementationusing onlyparametripolymorphism.Assuh,thetypesofthe funtionsinsertandfindmustbemodifed. \n2. FIRST SOLUTION ).. Aninitialimplementationofastusingthefailitiesof f appearsinFigure1.Inthefrstbranhofthetypease,a \n2Itwouldalsobereasonabletoprodueafuntionoftype a-(;option),buthekingthereturnvaluesofreursive allsforNONEonlylengthenstheexample. \nand;havebeendeterminedtobothbetoint.Castingan inttoanintiseasy;justanidentityfuntion. Intheseondbranhofthetypease,bothaand;are \nproduttypes(a1Xa2and;1X;2respetively).Through reursion,weanastthesubomponentsofthetype(a1 to;1anda2to;2).Therefore,toastaprodut,webreak \nitapart,asteahomponentseparately,andthenreatea newpair. Theodeisalittlediferentforthenextbranh,whena \nand;arebothfuntiontypes,duetoontravariane.Here, givenx,afuntionfroma1toa2,wewanttoreturna funtionfrom;1to;2.Weanapplyasttoa2and;2to \ngetafuntion,g,thataststheresulttype,andomposeg withtheargumentxtogetafuntionfroma1to;2.Then weanomposethatresultingfuntionwithareverseast \nfrom;1toa1togetafuntionfrom;1to;2. Finallyifthetypesdonotmathweraisetheexeption CantCast. However,thereisaproblemwiththissolution.Intuitively, \nallaastfuntionshoulddoatruntimeisreursivelyom\u00adparethetwotypes.ButunlessthetypesT1andT2areboth int,theresultofast[T1][T2]doesmuhmore.Every \npairintheargumentisbrokenapartandremade,andev\u00aderyfuntioniswrappedbetweentwoinstantiationsofast. Thisoperationresemblesavirus,infetingeveryfuntionit \nomesinontatwithandausingneedlessworkforevery produt. Thereasonwehadtobreakapartthepairinformingtheo\u00aderionfuntionforproduttypesisthatallwehadavailable \nwasafuntion(froma1 -;1)tooerethefrstomponent ofthepair.Ifweouldsomehowreateafuntionthato\u00aderesthisomponentwhileitwasstillapartofthepair,we \nouldhaveappliedittothepairasawhole.Inotherwords, wewanttwofuntions,onefrom(a1Xa2)-(;1Xa2)and onefrom(;1Xa2)-(;1X;2). \n 3. SECOND SOLUTION Motivatedbythelastexample,wewanttowriteafuntion thatanoerethetypeofpartofitsargument.Thiswill \nallowustopassthesamevalueasthexargumentforeah reursiveallandonlyrefnepartofitstype.Weannot eliminatexompletely,aswearehangingitstype.Sine \nwewanttoastmanypartsofthetypeofx,weneedto abstrattherelationshipbetweenthetypeargumenttobe analyzedandthetypeofx. \nThesolutioninFigure2defnesahelperfuntionast' thatabstratsnotjustthetypesaand;foranalysis,butan additionaltypeonstrutor3argument,.When,isapplied \ntothetypeawegetthetypeofx,whenitisappliedto ;wegetthereturntypeoftheast.Forexample,if,is )\u00c6:*.\u00c6Xa2,wegetafuntionfromtypeaXa2to;Xa2. \nWereatetypeonstrutorswith)\u00adnotation,andannotate theboundvariablewithitskind.Kindslassifytypesand typeonstrutors:*isthekindoftypes,andif.1and.2 \narekinds,.1 -.2isthethekindoftypeonstrutorsfrom .1to.2. ast':'a,;:*.',:*-*.(,a)-(,;) letreast'= Aa:*.A;:*.A,:*-*. \ntypease[\u00c61,\u00c62.(,\u00c61)-(,\u00c62)](a,;)of (int,int)=> fn(x:,int)=>x (a1Xa2,;1X;2)=> letvalf=ast'[a1][;1][)\u00c6:*.,(\u00c6Xa2)] \nvalg=ast'[a2][;2][)\u00c6:*.,(;1X\u00c6)] in fn(x:,(a1Xa2))=> g(fx) end (a1 -a2,;1 -;2)=> letvalf=ast'[a1][;1][)\u00c6:*.,(\u00c6-a2)] \nvalg=ast'[a2][;2][)\u00c6:*.,(;1 -\u00c6)] in fn(x:,(a1 -a2))=> g(fx) end ( , )=>raiseCantCast Figure2:SeondSolution \n Sineweabstratbothtypesandtypeonstrutors,inthe defnitionofastweannotatea,;,and,withtheirkinds. Asaand;aretypes,theyareannotatedwithkind*,but \n,isafuntionfromtypestotypes,andsohaskind*-*. Weinitiallyallast'withtheidentityfuntion. letast= Aa:*.A;:*.ast'[a][;][)\u00c6:*.\u00c6] \n Withthereursivealltoast',inthebranhforprodut typeswereateafuntiontoastthefrstomponentofthe tuple(onvertinga1to;1)bysupplyingthetypeonstru\u00adtor)\u00c6:*.,(\u00c6Xa2)for,.Asxisoftype,(a1Xa2),this \nappliationresultsinsomethingoftype,(;1Xa2).Inthe nextreursiveall,fortheseondomponentofthepair,the frstomponentisalreadyoftype;2,sothetypeonstrutor \nargumentrefetsthatfat. Surprisingly,thebranhforomparingfuntiontypesis analogoustothatofproduts.Weoeretheargument \ntypeofthefuntioninthesamemannerasweoeredthe frstomponentofthetuple;allingast'reursivelyto produeafuntiontoastfromtype,(a1 \n-a2)totype ,(;1 -a2).Aseondreursiveallhandlestheresulttype ofthefuntion. 4. HASKELL ThelanguageHaskell[13]providesadiferentformofad \nhopolymorphism,throughtheuseoftypelasses.Instead ofdefningonefuntionthatbehavesdiferentlyfordiferent \ntypes,Haskellallowsyoutodefneseveralfuntionswiththe samenamethatdiferintheirtypes. Forexample,theHaskellstandardpreludedefnesthelass \noftypesthatsupportaonversiontoastringrepresentation. Thislassisdelaredby lassShowawhere show::a-string \nThisdelarationstatesthatthetypeaisinthelassShow ifthereissomefuntionnamedshowdefnedfortypea -string.Weandefneshowforintegerswithabuilt\u00adin \nprimitiveby instaneShowintwhere showx=primlntToStringx Weanalsodefneshowfortypeonstrutorslikeprodut. \nInordertoonvertaproduttoastringweneedtobeable toshoweahomponentoftheprodut.Haskellallowsyou toexpresstheseonditionsintheinstantiationofatype \nonstrutor: instane(Showa,Show;)=>Show(a,;)where show(a,b)=\"(\"++showa++\",\"++showb\")\". Thisodedelaresthataslongasaand;aremembersof \nthelassShow,thentheirprodut(Haskelluses,insteadof Xforprodut)isamemberoflassShow.Consequently, thefuntionshowforprodutsisdefnedintermsofthe \nshowfuntionsforitssubomponents. 4.1 First Solution in Haskell CodingtheastexampleinHaskellisalittletrikybeause \nofthetwonestedtypeaseterms(hiddenbythepattern\u00admathingsyntax).Forthisreasonwewilldefnetwotype lassesonealledCF(forCastFrom)thatorresponds \ntotheoutertypease,andtheotheralledCT(forCast To)thatwillimplementalloftheinnertypeases.The frstlassjustdefnestheastfuntion,buttheseondlass \nneedstoinludethreefuntions,desribinghowtoomplete theastusingtheknowledgethatthefrsttypewasanin\u00adteger,produt,orfuntion.Notetheontravarianeinthe \ntypeofdoFnbelow:Beausewewillhavetoastfrom;1 toa1,weneeda1tobeinthelassCTinsteadofCF. lassCFawhere ast::CT;=>a-; \nlassCT;where dolnt::lnt-; doProd::(CFa1,CFa2)=>(a1,a2)-; doFn::(CTa1,CFa2)=>(a1 -a2)-; ).. Justasin,wheretheoutertypeaseledtoaninner \nf typeaseineahbranh,theseparateinstanesofthefrst lassjustdispathtotheseond,markingtheheadonstru\u00adtorofthefrsttypebythefuntionalled: \ninstaneCFlntwhere ast=dolnt instane(CFa,CF;)=>CF(a,;)where ast=doProd instane(CTa,CF;)=>CF(a-;)where \nast=doFn Theinstanesoftheseondtypelasseitherimplementthe branh(ifthetypesmath)orsignalanerror.Inthelnt \ninstaneofCT,thedolntfuntionisanidentityfuntionas before,whiletheothersproduetheerror\"CantCast\". instaneCTlntwhere \ndolntx=x doProdx=error\"CantCast\" doFnx=error\"CantCast\" ThedoProdfuntionoftheprodutinstaneshouldbeof type(CFa1,CFa2)=>(a1,a2)-(;1,;2).This \nfuntionallsastreursivelyonxandy,thesubompo\u00adnentsoftheprodut(takenapartviapatternmathing). Asthetypesofxandyarea1anda2,andweareallowed \ntoassumetheyareinthelassCF,weanallast.The delarationofastrequiresthatitsresulttypebeinthe lassCT,sowerequirethat;1and;2beinthelassCTfor \nthisinstantiation. instane(CT;1,CT;2)=>CT(;1,;2)where dolntx=error\"CantCast\" doProd(x,y)=(astx,asty) \ndoFnx=error\"CantCast\" Finally,intheinstaneforthefuntiontypeonstrutor, doFnneedstowrapitsargumentinreursiveallstoast,as \ninthefrst)..solution.Asthetypeofthisfuntionshould f be(CTa1,CFa2)=>(a1 -a2)-(;1 -;2),the typeoftheargumentxisofafuntionoftypea1 \n-a2. Toasttheresultofthisfuntion,weneedthea2instane ofCF,thatrequiresthat;2beinthelassCT.However,we wouldalsoliketoasttheargumentofthefuntioninthe \noppositediretion,from;1toa1.Thereforeweneed;1to beinthelassCF,anda1tobeinthelassCT.Theinstane forfuntiontypesisthen(Haskellusesf.gforfuntion \nomposition) instane(CF;1,CT;2)=>CT(;1 -;2)where dolntx=error\"CantCast\" doProdx=error\"CantCast\" doFnx=ast.x.ast \nNowwiththesedefnitionsweandefnethesymboltable usinganexistentialtypetohidethetypeoftheelement inthetable.Thoughnotintheurrentlanguagedefnition, \nseveralimplementationsofHaskellsupportexistentialtypes. ExistentialtypesinHaskellaredenotedwiththeforall \nkeywordasthedataonstrutorsthatarrythemmaybe instantiatedwithanytype. dataEntryT=foralla.CFa=>EntryStringa \ntypetable=[EntryT] Thefindfuntionisverysimilartobefore,exeptthat Haskellinfersthattheexistentialtypeshouldbeunpaked. \nfind::CTa=>table-String-a find((Entrys2val):rest)s1= ifs1==s2then astval elsefindrests1 find[]s=error\"NotinList\" \n 4.2 Second Solution in Haskell ToimplementtheseondversioninHaskell,weneedto hangethetypeofasttoabstratthetypeonstrutor,as \nwellasaand;.Thisadditionleadstothenewdefnitions ofCTandCF.NotethatinthetypeofdoFn,a1shouldbein thelassCFinsteadofthelassCT,refetingthatwearego\u00adingtoavoidtheontravariantastofthefuntionargument \nthatweneededintheprevioussolution. lassCFawhere ast'::CT;=>,a-,; lassCT;where dolnt::,lnt-,; doProd::(CFa1,CFa2)=> \n,(a1,a2)-,; doFn::(CFa1,CFa2)=> ,(a1 -a2)-,; TheinstanesforCFremainthesameasbefore,dispathing totheappropriatefuntions.AlsotheinstaneCTlntis \nstilltheidentityfuntion.Butreallthebranhforprod\u00aduts: typease(a,;)of ... (a1Xa2,;1X;2)=> letvalf=ast'[a1][;1][)\u00c6:*.,(\u00c6Xa2)] \nvalg=ast'[a2][;2][)\u00c6:*.,(;1X\u00c6)] in fn(x:,(a1Xa2))=> g(fx) end Thestrategywastoasttheleftsideoftheprodutfrstand \nthentoasttherightside,usingthetype\u00adonstrutorargu\u00admenttorelatethetypeofthetermargumenttothetypes beingexamineded.InHaskellweannotexpliitlyinstanti\u00ad \n).. atethetypeonstrutorargumentaswedidinf,butwe 4 angiveHaskellenoughhintstoinfertheorretone.To representthetwotypeonstrutorargumentsaboveweuse \nthedataonstrutorsLPandRP,defnedbelow. newtypeLProda,\u00c6=LP(,(\u00c6,a)) newtypeRProda,\u00c6=RP(,(a,\u00c6)) instane(CT;1,CT;2)=>CT(;1,;2)where \ndolntx=error\"CantCast\" doProdz=x whereLPy=ast'(LPz) RPx=ast'(RPy) doFnx=error\"CantCast\" 4 Jones[8]desribesthissortofimpliithigher\u00adorderpoly\u00admorphisminHaskell. \nHowdoesthisodetypehek Inthisinstane,doProd shouldbeoftype (CFa1,CFa2)=>,(a1,a2)-,(;1,;2). Thereforezisoftype,(a1,a2)soLPzisoftypeLProd \na2,a1.Atfrstglane,itseemslikeweannotallast' onthisargumentbeausewehavenotdelaredaninstane ofCFforthetypeonstrutorLProd.However,theinstanes \nofast'arealloftype', ..(CT;)=>, . a-, . ;,soto typehektheallast'(LPz),weonlyneedtofndana inthelassCTanda, \n. suhthat, . aisequaltothetypeof LPz.AsHaskelldoesnotpermitthereationoftype\u00adlevel typeabstrations[8],thetypeofLPzmustexpliitlybe \natypeonstrutorappliedtoatypeinordertotypehek. Thereforedetermining, . andaisasimplemath, . is thepartialappliationLProda2,andaisa1.Thus,the \nresultofast'isoftype(LProda2,);,forsome;in CT,andyisoftype,(;,a2). NowRPyisoftypeRProd;,a2,soweneedthea2in\u00adstaneofast'fortheseondall.Thisinstaneisoftype \n.. ... ... .. ',.CT;=>,a2 -,;.This,unifeswiththe partialappliation(RProd;,)sothereturntypeofthis astisRProd;,; \n. ,thetypeofRPx.Thatmakesxof type,(;,; .).Comparingthistypetothereturntypeof doProd,weunify;with;1and; \n. with;2.Thisunifation satisfesouronstraintsforthetwoallstoast',aswe assumedthatboth;1and;2areinthelassCT. \n).. Justasintheseondsolution,funtiontypesworkin f exatlythesamewayasproduttypes,usingsimilardela\u00adrationsofLArrowandRArrow. \nnewtypeLArrowa,\u00c6=LA(,(\u00c6-a)) newtypeRArrowa,\u00c6=RA(,(a-\u00c6)) Toenapsulateast',weprovidetheidentitytypeonstru\u00adtor: \nnewtypelda=la ast::(CFa,CT;)=>a-; astx=ywhere(ly)=ast'(lx) TheompleteHaskellodeforthissolutionappearsinAp\u00adpendixA. \n 5. IMPLEMENTING TYPE DYNAMIC ).. Justas:a.aimplementsadynamitypeinf,:a.CFa =>aisadynamitypeinHaskell.AddingtypeDynamito \nastatiallytypedlanguageisnothingnew,soitisinteresting toomparethisimplementationtopreviouswork. OnewaytoimplementtypeDynami(exploredbyHenglein \n[7])istouseauniversaldatatype. dataDynami=Baselnt Pair(Dynami,Dynami) Fn(Dynami-Dynami) Here,inreatingavalueoftypeDynami,atermistagged \nwithonlytheheadonstrutorofitstype.However,before atermmaybeinjetedintothistype,ifitisapair,its subomponentsmustbeoered,andifitisafuntion,it \nmustbeonvertedtoafuntionfromDynami-Dynami. Weouldimplementthisinjetion(anditsassoiatedpro\u00adjetion)withHaskelltypelassesasfollows: \nlassUDawhere toD::a-Dynami fromD::Dynami-a instaneUDlntwhere toDx=Basex fromD(Basex)=x instane(UDa,UD;)=>UD(a,;)where \ntoD(x1,x2)=Pair(toDx1,toDx2) fromD(Pair(d1,d2))=(fromDd1,fromDd2) instane(UDa,UD;)=>UD(a-;)where toDf=Fn(toD.f.fromD) \nfromD(Fnf)=fromD.f.toD Thisimplementationresemblesourfrstastsolutions,in thatitmustdestruttheargumenttoreoveritstype.Also, \nprojetingafuntionfromtypeDynamiresultsinawrapped version.Henglein,inordertomakethisstrategye\u00c6ient, designsanalgorithmtoproduewell\u00adtypedodewithasfew \noerionstoandfromthedynamitypeaspossible. AnotherwaytoimplementtypeDynamiistopairanex\u00adpressionwiththefulldesriptionofitstype[1,9].The \nimplementationsGHCandHugsusethisstrategytopro\u00advidealibrarysupportingtypeDynamiinHaskell.This libraryusestypelassestodefnetermrepresentationsfor \neahtype.InjetingavalueintotypeDynamiinvolvestag\u00adgingitwithitsrepresentation,andprojetingitompares therepresentationwithagivenrepresentationtohekthat \nthetypesmath.Atfrstglanethisshemeissurprisingly similartoanimplementationofastusingtypeasein)R ).. [2],aversionofinwhihtypesareexpliitlyrepre\u00ad \nf sentedbydependentlytypedterms.Howeverthereisan importantdistintion:Thoughtypelassesanreateap\u00adpropriatetermrepresentationsforeahtype,thereisno \nsupportfordependeny,sothelaststepoftheprojetion requiresanunsafetypeoerion. Althoughtheastsolutionismoree\u00c6ientthantheuniver\u00adsaldatatypeandmoretype\u00adsafethantheGHC/Hugslibrary \nimplementation,itsufersintermsofextensibility.Theex\u00adampleimplementationsofastonlyonsiderthreetypeon\u00adstrutors,forintegers,produtsandfuntions.Othersmay \nbeadded,bothprimitive(suhasChar,lO,or[])anduser defned(suhasfromdatatypeandnewtypedelarations), butonlythroughmodifationoftheCTtypelass.Further\u00admore,allurrentinstantiationsofCTneedtobeextended \nwitherrorfuntionsforeahadditionaltypeonstrutor. Inontrast,thelibraryimplementationanbeextendedto supportnewtypeonstrutorswithoutmodifyingprevious \node. AthirdimplementationoftypeDynamithatistypesafe, e\u00c6ientandeasilyextensibleusesreferenes(seeWeeks[17] \nfortheoriginalSMLversion).Thoughtheuseofmutable referenesisnottypiallyenouraged(orevenpossible)in apurelyfuntionallanguage,GHCandHugssupporttheir \nusebyenapsulationintheIOmonad.Whiletheprevious implementationsoftypeDynamidefnedthedesription ofatypeatompiletime,referenesallowthereationof \nadesriptionforanytypeatruntime,andsoareeasily extendabletonewtypes.Beauseeahreferenereated bynewlORefisunique,aunitrefereneanbeusedto \nimplementauniquetagforagiventype.Amemberoftype Dynamiisthenapairofatagandaomputationthat hidesthestoredvalueinitslosure.5 \ndataDyn=Dyn{tag::lORef(),get::lO()} Toreoverthevaluehiddeninthelosure,thegetompu\u00adtationwritesthatvaluetoareferenestoredinthelosure \noftheprojetionfromthedynamitype.Theomputation makebelowreatesinjetionandprojetionfuntionsforany type. \nmake::lO(a->Dyn,Dyn->lOa) make=do{newtag<-newlORef() ;r<-newlORefNothing ;return (\\a->Dyn{tag=newtag, \nget=writelORefr(Justa)}, \\d->if(newtag==tagd) then do{getd ;Justx<-readlORefr ;returnx } elseerror\"llltyped\") \n} Thisimplementationoftypedynamiismoredi\u00c6ulttouse, asitmustbethreadedthroughtheIOmonad.Furthermore, beausethetagisreateddynamially,itannotbeusedin \nanimplementationformarshallingandunmarshalling.Also, theusermustbearefultoallmakeonlyoneforeahtype, lestsheonfusethem.(Conversely,theuserisfreetoreate \nmoredistintionsbetweentypes,inmuhthesamemanner asthenewtypemehanism).Unlikethepreviousversions thatouldnothandletypeswithbindingstruture(suhas \nforalla.a->a),thissolutionanhideanytype.Ad\u00additionally,theomplexityofprojetionfromadynamitype doesnotdependonthetypeitself.However,theaboveso\u00adlutionhasaredundantomparisonifthetagsmaththen \nthepatternmathJustxwillneverfail,buttheimple\u00admentationmuststillhekthatthatthereferenedoesnot ontainNothing. \nIfwewanderoutsideofthelanguageHaskell,wefndlan\u00adguagesupportforamorenaturalimplementationoftagging, therebyeliminatingthisredundanthek.Forexample,if \nthelanguagesupportsanextensiblesumtype(suhasthe exeptiontypeinSML)thenthattypeanbeviewedas 5 Whihanbeviewedashidingthevaluewithinanexis\u00adtentialtype[11]. \ntypeDynami[17].Thedelarationofanewexeptionon\u00adstrutor,E,arryingsometypeTprovidesaninjetionfrom Tintotheexeptiontype.Coeringavaluefromthedy\u00adnamitypetoTismathingtheexeptiononstrutorwith \nE. Alternatively,ifthelanguagesupportssubtypinganddown\u00adasting,thenamaximalsupertypeservesasadynamitype. \nIgnoringtheprimitivetypes(suhasint),Java[5]isanex\u00adampleofsuhalanguage.Anyreferenetypemaybeo\u00aderedtotypeObjet,withoutanyruntimeoverhead.Coer\u00adingfromtypeObjetrequireshekingwhetherthevalue's \nlass(taggedwiththevalue)isasubtypeofthegivenlass. 6. PARAMETRIC POLYMORPHISM Thepurposeofthispaperisnottofndthebestimple\u00admentationofdynamityping,butinsteadtoexplorewhat \nlanguagesupportisneessarytoimplementitandatwhat ost.Withtheadditionoffrst\u00adlasspolymorphism(suhas supportedbyGHCorHugs),Haskelltypelassesmaybe \nompletelyompiledaway[16].Therefore,thefnalHaskell typelasssolutionanbeonvertedtoaframeworkforim\u00adplementingheterogeneoussymboltablesinasystemofpara\u00admetripolymorphism.AppendixBshowstheresultofa \nstandardtranslationtoditionary\u00adpassingstyle,plusasam\u00adplerun. Theoriginalproblemwehadwiththefuntionfindwas \nwithitstype;thoughawasuniversallyquantifed,itdidnot appearnegatively.ThetranslationoftheHaskellsolution \nshowsusexatlywhatadditionalargumentweneedtopass tofind(theCTditionaryfortheresulttype),andexatly whatadditionalinformationweneedtostorewitheahentry \ninthesymboltable(theCFditionaryfortheentry'stype) inordertoreoverthetype. 7. ACKNOWLEDGEMENTS ThankstoKarlCrary,FergusHenderson,ChrisOkasaki, \nGregMorrisett,DaveWalker,SteveZdanewi,andthe ICFPreviewersfortheirmanyommentsonearlierdrafts ofthispaper. \n 8. REFERENCES [1]M.Abadi,L.Cardelli,B.Piere,andG.Plotkin. Dynamitypinginastatially\u00adtypedlanguage.ACM \nTransationsonProgrammingLanguagesand Systems,13(2):237 268,April1991. [2]K.Crary,S.Weirih,andG.Morrisett.Intensional \npolymorphismintype\u00aderasuresemantis.In1998 ACMInternationalConfereneonFuntional Programming,pages301 312,Baltimore,Sept.1998. \nExtendedversionpublishedasCornellUniversity tehnialreportTR98\u00ad1721. [3]C.Dubois,F.Rouaix,andP.Weis.Extensional \npolymorphism.InTwenty\u00adSeondACMSymposium onPriniplesofProgrammingLanguages,pages 118 129,SanFraniso,Jan.1995. \n [4]J.\u00adY.Girard.Interpreetationfontionelleeteelimination desoupuresdel'arithmeetiqued'ordresupeerieur.PhD \nthesis,UniversiteeParisVII,1972. [5]J.Gosling,B.Joy,andG.Steele.TheJavaLanguage Speifation.Addison\u00adWesley,1996. \n[6]R.HarperandG.Morrisett.Compilingpolymorphism usingintensionaltypeanalysis.InTwenty\u00adSeond ACMSymposiumonPriniplesofProgramming \nLanguages,pages130 141,SanFraniso,Jan.1995. [7]F.Henglein.Dynamityping.InB.Krieg\u00adBru kner, editor,FourthEuropeanSymposiumonProgramming, \nnumber582inLetureNotesinComputerSiene, pages233 253.Springer\u00adVerlag,Feb.1992. [8]M.P.Jones.Asystemofonstrutorlasses: \noverloadingandimpliithigher\u00adorderpolymorphism. JournalofFuntionalProgramming,5(1),Jan.1995. [9]X.LeroyandM.Mauny.DynamisinML.In \nJ.Hughes,editor,FuntionalProgrammingLanguages andComputerArhiteture,number523inLeture NotesinComputerSiene,pages406 \n426. Springer\u00adVerlag,Aug.1991. [10]R.Milner,M.Tofte,R.Harper,andD.MaQueen. TheDefnitionofStandardML \n(evised).TheMIT Press,Cambridge,Massahusetts,1997. [11]Y.Minamide,G.Morrisett,andR.Harper.Typed losureonversion.InTwenty\u00adThirdACMSymposium \nonPriniplesofProgrammingLanguages,pages 271 283,St.Petersburg,Florida,Jan.1996. [12]J.C.MithellandG.D.Plotkin.Abstrattypeshave \nexistentialtype.ACMTransationsonProgramming LanguagesandSystems,10(3):470 502,July1988. [13]S.PeytonJonesandJ.Hughes(editors).Reporton \ntheprogramminglanguageHaskell98,anon\u00adstrit purelyfuntionallanguage.TehnialReport YALEU/DCS/RR\u00ad1106,YaleUniversity,Department \nofComputerSiene,Feb.1999.Availablefrom http://www.haskell.org/defnition/. [14]J.C.Reynolds.Towardsatheoryoftypestruture.In \nProgrammingSymposium,volume19ofLetureNotes inComputerSiene,pages408 425,1974. [15]P.Wadler.Theoremsforfree!InFourthConferene \nonFuntionalProgrammingLanguagesandComputer Arhiteture,London,Sept.1989. [16]P.WadlerandS.Blott.Howtomakead\u00adho \npolymorphismlessad\u00adho.InSixteenthACM SymposiumonPriniplesofProgrammingLanguages, pages60 76.ACM,1989. \n[17]S.Weeks.NJPearLSdynamiallyextensibledata struturesinStandardML.TalkpresentedatNew JerseyProgrammingLanguagesandSystemsSeminar, \nSept.1998.Transpareniesavailableat http://www.star\u00adlab.om/sweeks/talks.html. APPENDIX A. HASKELL LISTING \nFOR SOLUTION 2 newtypeLProdagd=LP(g(d,a)) newtypeRProdagd=RP(g(a,d)) newtypeLArrowagd=LA(g(d->a)) newtypeRArrowagd=RA(g(a->d)) \nnewtypelda=la lassCFawhere ast'::CTb=>ga->gb instaneCFlntwhere ast'=dolnt instane(CFa,CFb)=>CF(a,b)where \nast'=doProd instane(CFa,CFb)=>CF(a->b)where ast'=doFn lassCTbwhere dolnt::glnt->gb doProd::(CFa1,CFa2)=> \ng(a1,a2)->gb doFn::(CFa1,CFa2)=> g(a1->a2)->gb instaneCTlntwhere dolntx=x doProdx=error\"CantCF\" doFnx=error\"CantCast\" \ninstane(CTb1,CTb2)=>CT(b1,b2)where dolntx=error\"CantCast\" doProdz=x whereLPy=ast'(LPz) whereRPx=ast'(RPy) \ndoFnx=error\"CantCast\" instane(CTb1,CTb2)=>CT(b1->b2)where dolntx=error\"CantCast\" doProdx=error\"CantCast\" \ndoFnz=x whereLAy=ast'(LAz) whereRAx=ast'(RAy) ast::(CFa,CTb)=>a->b astx=ywherely=ast'(lx) B. PARAMETRIC \nSYMBOL TABLE B.1 Dictionary-passing Implementation newtypeLProdagd=LP(g(d,a)) newtypeRProdagd=RP(g(a,d)) \nnewtypeLArrowagd=LA(g(d->a)) newtypeRArrowagd=RA(g(a->d)) newtypelda=la dataCFa=CastFromDit {ast'::forallbg.CTb->ga->gb} \ndataCTb= CastToDit {dolnt::(forallg.glnt->gb), doProd::(foralla1a2g. CFa1->CFa2->g(a1,a2)->gb), doFn::(foralla1a2g.CFa1-> \nCFa2->g(a1->a2)->gb)} --CFditionaryonstrutors flnt::CFlnt flnt=CastFromDit{ast'=dolnt} fProd::CFa->CFb->CF(a,b) \nfProd=\\x->\\y->CastFromDit {ast'=(\\t->(doProdtxy))} fFn::CFa->CFb->CF(a->b) fFn=\\x->\\y->CastFromDit {ast'=(\\t->(doFntxy))} \n--CTditionaryonstrutors tlnt::CTlnt tlnt=CastToDit {dolnt=(\\x->x), doProd=(\\x->error\"CantCast\"), doFn=(\\x->error\"CantCast\")} \n tProd::CTb1->CTb2->CT(b1,b2) tProd=\\tb1->\\tb2->CastToDit {dolnt=(\\x->error\"CantCast\"), doProd=(\\fa1->\\fa2->\\z-> \nletLPy=ast'fa1tb1(LPz) RPx=ast'fa2tb2(RPy) inx), doFn=(\\x->error\"CantCast\")} tFn::CTb1->CTb2->CT(b1->b2) \ntFn=\\tb1->\\tb2->CastToDit {dolnt=(\\x->error\"CantCast\"), doProd=(\\x->error\"CantCast\"), doFn=(\\fa1->\\fa2->\\z-> \n letLAy=ast'fa1tb1(LAz) RAx=ast'fa2tb2(RAy) inx)} --Wrappingupast' ast::CFa->CTb->a->b astfatbx=y where(ly)=ast'fatb(lx) \n B.2 Symbol Table Implementation dataEntryT=forallb.EntryStringb(CFb) typeTable=[EntryT] empty::Table \nempty=[] --lnsertionrequirestheorretCFditionary insert::CFa->Table->(String,a)->Table insertft(s,a)=(Entrysaf):t \n--ThefirstargumenttofindisaCastTo --ditionary find::CTa->Table->String->a findt[]s=error\"NotinList\" findt((Entrys2valf):rest)s1= \nifs1==s2thenastftval elsefindtrests1 B.3 Sample Run -- Create a symbol table by providing the -- CF ditionary \nfor eah entry Main> (find (tFn int int) table \"add1\") 7 8 table :: Table Main> find (tProd int int) table \n\"bar\" t1 = insert tlnt empty ( foo'', 6) (6,6) t2 = insert (fProd flnt flnt) t1 (\"bar\", (6,6)) Main> \nfind (tProd int (tProd int int)) table \"bar\" table = insert (fFn flnt flnt) t2 (\"add1\" (\\x->x+1) Program \nerror: CantCast \n\t\t\t", "proc_id": "351240", "abstract": "In a language with non-parametric or ad-hoc polymorphism, it is possible to determine the identity of a type variable at run-time. With this facility, we can write a function to convert a term from one abstract type to another, if the two hidden types are identical. However, the naive implementation of this function requires that the term be destructed and rebuilt. In this paper, we show how to eliminate this overhead using higher-order type abstraction. We demonstrate this solution in two frameworks for ad-hoc polymorphism: intensional type analysis and type classes.", "authors": [{"name": "Stephanie Weirich", "author_profile_id": "81100093135", "affiliation": "Department of Computer Science, Cornell University, Ithaca, NY", "person_id": "P267927", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351246", "year": "2000", "article_id": "351246", "conference": "ICFP", "title": "Type-safe cast: (functional pearl)", "url": "http://dl.acm.org/citation.cfm?id=351246"}