{"article_publication_date": "09-01-2000", "fulltext": "\n be ehaecehaede\u00adtanberof berofealsoascehaec ehaec be hisbe ehaealsowrit\u00adtonan eha ICFP 00, Montr\u00e9al, \nCanada. Copyright 2000 A C M 1-58113-202-6/00/0009 $ 5.00. imentstorealsystems,andwehavefoundittoworkwell \ninpractice.Wereportonsomeofthisexperienceinthis paper,andpointoutpitfallstoavoid. Therestofthispaperisstructuredasfollows.Section \n2introducestheconceptofwritingpropertiesandchecking themusingQuickCheck.Section3showshowtodefnetest datageneratorsforuser-defnedtypes.Section4briefydis\u00adcussestheimplementation.Section5presentsanumberof \ncasestudiesthatshowtheusefulnessofthetool.Section6 concludes. 2. DEFINING PROPERTIES 2.1 A Simple Example \nAsafrstexample,wetakethestandardfunctionreverse whichreversesalist.Thissatisfesanumberofusefullaws, suchas \nreverse[x] [x] reverse(xs++ys) reverseys++reversexs reverse(reversexs) xs Infact,thefrsttwoofthesecharacterisereverseuniquely. \nNotethattheselawsholdonlyforfnite,totalvalues.In thispaper,unlessspecifcallystatedotherwise,wealways \nquantifyovercompletelydefnedfnitevalues.Thisisto makeitmorelikelythatthepropertiesarecomputable. InordertochecktheselawsusingQuickCheck,werepre\u00adsentthemasHaskellfunctions.Thuswedefne \nprop_RevUnitx= reverse[x]==[x] prop_RevAppxsys= reverse(xs++ys)==reverseys++reversexs prop_RevRevxs= \nreverse(reversexs)==xs Now,ifthesefunctionsreturnTrueforeverypossibleargu-ment,thenthepropertieshold.WeloadthemintotheHugs \ninteractiveHaskellinterpreter[14],andcallforexample Main>quickCheckprop_RevApp OK:passed100tests. ThefunctionquickChecktakesalawasaparameterandap\u00adpliesittoalargenumberofrandomlygeneratedarguments \n|infact1001|reporting\\OK\"iftheresultisTruein everycase. Ifthelawfails,thenquickCheckreportsthecounter\u00adexample.Forexample,ifwemistakenlydefne \nprop_RevAppxsys= reverse(xs++ys)==reversexs++reverseys thencheckingthelawmightproduce Main>quickCheckprop_RevApp \nFalsifiable,after1tests: [2] [-2,1] wherethecountermodelcanbeextractedbytaking[2]for xs,and[-2,1]forys. \n1100isaratherarbitrarynumber,soourlibraryprovidesa waytospecifythisasaparameter. Infacttheprogrammermustprovidealittlemoreinfor\u00admation:thefunctionquickCheckisactuallyoverloaded,in \nordertobeablehandlelawswithavaryingnumberofvari\u00adables,andtheoverloadingcannotberesolvedifthelawitself \nhasapolymorphictype,asintheseexamples.Thusthepro\u00adgrammermustspecifyafxedtypeatwhichthelawistobe tested.Sowesimplygiveatypesignatureforeachlaw,for \nexample prop_RevApp::[Int]->[Int]->Bool Ofcourse,thepropertyprop_RevAppholdspolymorphically, butwemustspecifywhichmonomorphicinstancetotest \nitat,sothatwecangeneratetestcases.Thisturnsout tobequiteimportantinthecaseofoverloadedfunctions. Forexample,+isassociativeforthetypeInt,butnotfor \nDouble!Insomecases,wecanuseparametricity[17]to arguethatapropertyholdspolymorphically. 2.2 Functions \nWearealsoabletoformulatepropertiesthatquantifyover functions.Tocheckforexamplethatfunctioncomposition \nisassociative,wefrstdefneextensionalequality(===)by (f===g)x=fx==gx,andthenwrite: prop_CompAssoc::(Int->Int)->(Int->Int) \n->(Int->Int)->Int->Bool prop_CompAssocfgh= f.(g.h)===(f.g).h Theonlydifcultythatfunctiontypescauseisthat,ifa \ncounter-exampleisfound(forexampleifwetrytocheck thatfunctioncompositioniscommutative),thenthefunc\u00adtionvaluesareprintedjustas\\<<function>>\".Inthiscase \nwediscoverthatthe`law'wearecheckingisfalse,butnot why. 2.3 Conditional Laws Lawswhicharesimpleequationsareconvenientlyrepre\u00adsentedbybooleanfunctionaswehaveseen,butingeneral \nmanylawsholdonlyundercertainconditions.QuickCheck providesanimplicationcombinatortorepresentsuchcondi\u00adtionallaws.Forexample,thelaw \nx<=y )maxxy==y canberepresentedbythedefnition prop_MaxLe::Int->Int->Property prop_MaxLexy=x<=y==>maxxy==y \nLikewise,theinsertionfunctionintoorderedlistssatisfes thelaw prop_Insert::Int->[Int]->Property prop_Insertxxs= \norderedxs==>ordered(insertxxs) Notethattheresulttypeofthepropertyischangedfrom BooltoProperty.Thisisbecausethetestingsemantics \nisdiferentforconditionallaws.Insteadofcheckingthe propertyfor100randomtestcases,wetrycheckingitfor 100testcasessatisfyingthecondition.Ifacandidatetest \ncasedoesnotsatifythecondition,itisdiscarded,andanew testcaseistried. Checkingthelawsprop_MaxLeandprop_Insertsucceed \nasusual,butsometimes,checkingaconditionallawproduces theoutput Argumentsexhaustedafter64tests. Ifthepreconditionofalawisseldomsatisfed,thenwemight \ngeneratemanytestcaseswithoutfndinganywhereitholds. Insuchcasesitishopelesstosearchfor100casesinwhich \nthepreconditionholds.Ratherthanallowtestcasegener\u00adationtorunforever,wegenerateonlyalimitednumberof candidatetestcases(thedefaultis1000).Ifwedonotfnd \n100validtestcasesamongthosecandidates,thenwesim\u00adplyreportthenumberofsuccessfultestswewereableto perform. \nIntheexample,weknowthatthelawpassedthetestin64 cases.Itisthenuptotheprogrammertodecidewhetherthis isenough,orwhetheritshouldbetestedmorethoroughly. \n 2.4 Monitoring Test Data Perhapsitseemsthatwehavetestedthelawforinsert thoroughlyenoughtoestablishitscredibility.However,we \nmustbecareful.Letusmodifyprop_Insertasfollows2 prop_Insert::Int->[Int]->Property prop_Insertxxs= orderedxs==> \nclassify(nullxs)\"trivial\"$ ordered(insertxxs) Checkingthelawnowproducesthemessage OK,passed100tests(43%trivial). \nTheclassifycombinatordoesnotchangethemeaningofa law,butitclassifessomeofthetestcases,inthiscasethose \nwherexsistheemptylistwereclassifedas\\trivial\".Thus weseethatalargeproportionofthetestcasesonlytested \ninsertionintoanemptylist. Wecangetmoreinformationthanjustlabellingsometest cases.Thecombinatorcollectwillgatherallvaluesthat \narepassedtoit,andprintoutahistogramofthesevalues. Forexample,ifwewrite: prop_Insert::Int->[Int]->Property \nprop_Insertxxs= orderedxs==> collect(lengthxs)$ ordered(insertxxs) wemightgetasaresult: OK,passed100tests. \n49%0. 32%1. 12%2. 4%3. 2%4. 1%5. Soweseethatonly19casestestedinsertionintoalistwith morethanoneelement.Whilethisisenoughtoprovide \nfairlystrongevidencethatthelawholds,itisworryingthat veryshortlistsdominatethetestcasessostrongly.After \nall,itiseasytodefneanerroneousversionofinsertwhich neverthelessworksforlistswithatmostoneelement. Thereasonforthisbehaviour,ofcourse,isthatthepre\u00adconditionorderedxsskewsthedistributionoftestcases \ntowardsshortlists.Everygeneratedlistoflength0or1 isordered,butonly50%ofthelistsoflength2are.Thus testcaseswithlongerlistsaremorelikelytoberejectedby \n2$isHaskell'sinfxfunctionapplication. theprecondition.Thereisariskofthiskindofproblemev\u00aderytimeweuseconditionallaws,soitisalwaysimportant \ntoinvestigatetheproportionoftrivialcasesamongthose actuallytested. Thebestsolution,though,istoreplacetheconditionwith \nacustomtestdatageneratorfororderedlists.Wewrite prop_Insert::Int->Property prop_Insertx= forAllorderedList$\\xs-> \nordered(insertxxs) whichspecifesthatvaluesforxsshouldbegeneratedby thetestdatageneratororderedList.Checkingthelawnow \ngives\\OK:passed100tests\",aswewouldexpect. QuickCheckprovidessupportfortheprogrammertodefne hisorherowntestdatagenerators,withcontroloverthe \ndistributionoftestdata,whichwewilllookatinthenext section.  2.5 In.nite Structures TheHaskellfunctioncycletakesanon-emptylist,and \nreturnsalistthatrepeatsthecontentsofthatlistinfnitely. Now,takealookatthefollowinglaw,formulatedinQuick-Checkas \n3: prop_DoubleCycle::[Int]->Property prop_DoubleCyclexs= not(nullxs)==> cyclexs==cycle(xs++xs) Althoughintuitivelythelawistrue,itcannotbechecked \nsincewearecomparingtwoinfnitelistsusingcomputable equality==,whichdoesnotterminate.Instead,wecanrefor\u00admulatethepropertyasalogicallyequivalentone,byusing \nthefactthattwoinfnitelistsareequalifallfniteinitial segmentsareequal. prop_DoubleCycle::[Int]->Int->Property \nprop_DoubleCyclexsn= not(nullxs)&#38;&#38;n>=0==> taken(cyclexs)==taken(cycle(xs++xs)) Anotherissuerelatedtoinfnitestructuresisquantifcation \noverthem.Wewilllaterseehowtodealwithproperties thatforexampleholdforallinfnitelists,butingeneralit isnotclearhowtoformulateandexecutepropertiesabout \nstructurescontainingbottom.  3. DEFINING GENERATORS 3.1 Arbitrary Thewaywegeneraterandomtestdataofcoursedepends \nonthetype.Therefore,wehaveintroducedatypeclass Arbitrary,ofwhichatypeisaninstanceifwecangenerate arbitraryelementsinit. \nclassArbitraryawhere arbitrary::Gena Genaisanabstracttyperepresentingageneratorfortype a.Theprogrammercaneitherusethegeneratorsbuiltin \ntoQuickCheckasinstancesofthisclass,orsupplyacustom generatorusingtheforAllcombinator,whichwesawinthe \nprevioussection.Fornow,wedefnethetypeGenas 3Notethatleavingtheconditionnot(nullxs)outresults inanerror,becausecycleisnotdefnedforemptylists. \nnewtypeGena=Gen(Rand->a) HereRandisarandomnumberseed;ageneratorisjusta functionwhichcanmanufactureanainapseudorandom \nway.ButwewilltreatGenasanabstracttype,sowedefne aprimitivegenerator choose::(Int,Int)->GenInt tochoosearandomnumberinaninterval,andweprogram \nothergeneratorsintermsofit. Wealsoneedcombinatorstobuildcomplexgenerators fromsimplerones;todoso,wedeclareGentobeaninstance \nofHaskell'sclassMonad.Thisinvolvesimplementingthe methodsoftheMonadclass return::a->Gena (>>=)::Gena->(a->Genb)->Genb \nthefrstoneofwhichcontructsaconstantgenerator,and thesecondonebeingthemonadicsequencingoperatorwhich generatesana,andpassesittoitssecondargumenttogen\u00aderateab.Thedefnitionof(>>=)needstopassindepen\u00addentrandomnumberseedstoitstwoarguments,andisonly \npassedoneseed,butluckilytheHaskellrandomnumberli\u00adbraryprovidesanoperationtosplitoneseedintotwo. Defninggeneratorsformanytypesisnowstraightfor\u00adward.Asexamples,wegivegeneratorsforintegersand \npairs: instanceArbitraryIntwhere arbitrary=choose(-20,20) instance(Arbitrarya,Arbitraryb)=> Arbitrary(a,b)where \narbitrary=liftM2(,)arbitraryarbitrary Inthesecondcaseweuseastandardmonadicfunction, liftM2,whichisdefnedintermsofreturnand(>>=),to \nmakeageneratorthatappliesthepairingoperator(,)to theresultsoftwoothergenerators.QuickCheckcontains suchdeclarationsformostofHaskell'spredefnedtypes. \n 3.2 Generators for User-De.ned Types Sincewedefnetestdatagenerationviaaninstanceof classArbitraryforeachtype,thenwemustrelyontheuser \ntoprovideinstancesforuser-defnedtypes.Inprinciplewe couldtrytogeneratetheseautomatically,inapre-processor \norviapolytypicprogramming[2],butwehavechosenin\u00adsteadtoleavethistasktotheuser.Thisispartlybecause wewantQuickChecktobealightweighttool,easytoimple\u00admentandeasytouseinastandardprogrammingenviron\u00adment;wedon'twanttoobligeuserstoruntheirprograms \nthroughapre-processorbetweeneditingthemandtesting them.Butanotherstrongreasonisthatitseemstobevery hardtoconstructageneratorforatype,withoutknowing \nsomethingaboutthedesireddistributionoftestcases. Insteadofproducinggeneratorsautomatically,wepro\u00advidecombinatorstoenableaprogrammertodefnehisown \ngeneratorseasily.Thesimplest,calledoneof,justmakesa choiceamongalistofalternativegeneratorswithauniform \ndistribution.forexample,ifthetypeColourisdefnedby dataColour=Red|Blue|Green thenasuitablegeneratorcanbedefnedby \ninstanceArbitraryColourwhere arbitrary=oneof [returnRed,returnBlue,returnGreen] Asanotherexample,wecouldgeneratearbitrarylistsusing \ninstanceArbitrarya=>Arbitrary[a]where arbitrary=oneof [return[],liftM2(:)arbitraryarbitrary] whereweuseliftM2toapplytheconsoperator(:)toan \narbitraryheadandtail.However,thisdefnitionisnotreally satisfactory,sinceitproduceslistswithanaveragelength \nofoneelement.Wecanadjusttheaveragelengthoflist producedbyusingfrequencyinstead,whichallowsusto specifythefrequencywithwhicheachalternativeischosen. \nWedefne instanceArbitrarya=>Arbitrary[a]where arbitrary=frequency [(1,return[]) ,(4,liftM2(:)arbitraryarbitrary)] \ntochoosetheconscasefourtimesasoftenasthenilcase, leadingtoanaveragelistlengthoffourelements. However,formoregeneraldatatypes,itturnsoutthat \nweneedevenfnercontroloverthedistributionofgenerated values.Supposewedefneatypeofbinarytrees,anda generator: \ndataTreea=Leafa|Branch(Treea)(Treea) instanceArbitrarya=>Arbitrary(Treea)where arbitrary=frequency [(1,liftMLeafarbitrary) \n,(2,liftM2Brancharbitraryarbitrary)] WewanttoavoidchoosingaLeaftoooften,hencetheuse offrequency. However,thisdefnitiononlyhasa50%chanceoftermi\u00adnating!ThereasonisthatforthegenerationofaBranchto \nterminate,tworecursivegenerationsmustterminate.Ifthe frstfewrecursionschooseBranches,thengenerationtermi\u00adnatesonlyifverymanyrecursivegenerationsallterminate, \nandthechanceofthisissmall.Evenwhengenerationter\u00adminates,thegeneratedtestdataissometimesverylarge. Wewanttoavoidthis:sinceweperformalargenumberof \ntests,wewanteachtesttobesmallandquick. Oursolutionistolimitthesizeofgeneratedtestdata. Butthenotionofasizeishardeventodefneingeneralfor \nanarbitraryrecursivedatatype(whichmayincludefunc\u00adtiontypesanywhere).Wethereforegivetheresponsibility \nforlimitingsizestotheprogrammerdefningthetestdata generator.Wechangetherepresentationofgeneratorsto newtypeGena=Gen(Int->Rand->a) \nwherethenewparameteristobeinterpretedassomekind ofsizebound.Wedefneanewcombinator sized::(Int->Gena)->Gena \nwhichtheprogrammercanusetoaccessthesizebound: sizedgeneratesanabypassingthecurrentsizeboundto itsparameter.Itisthenuptotheprogrammertointer\u00adpretthesizeboundinsomereasonablewayduringtestdata \ngeneration.Forexample,wemightgeneratebinarytrees using instanceArbitrarya=>Arbitrary(Treea)where arbitrary=sizedarbTree \narbTree0=liftMLeafarbitrary arbTreen=frequency [(1,liftMLeafarbitrary) ,(4,liftM2Branch(arbTree(n`div`2)) \n(arbtree(n`div`2)))] Withthisdefnition,thesizeboundlimitsthenumberof nodesinthegeneratedtrees,whichisquitereasonable. \nNowthatwehaveintroducedthenotionofasizebound, wecanuseitsensiblyinthegeneratorsforothertypessuch asintegersandlists(sothattheabsolutevaluerespective \nlengthisboundedbythesize).Sothedefnitionswepre\u00adsentedearlierneedtobemodifedaccordingly. Westressthatthesizeboundissimplyanextra,global \nparameterwhicheverytestdatageneratormayaccess;ev\u00aderyuseofsizedseesthesamebound4 .Wedonotattempt to`dividethesizeboundamongthegenerators',sothatfor \nexamplealongergeneratedlistwouldhavesmallerelements, keepingtheoverallsizeofthestructurethesame.Therea\u00adsonisthatwewishtoavoidcorrelationsbetweenthesizes \nofdiferentpartsofthetestdata,whichmightdistortthe testresults. Wedovarythesizebetweendiferenttestcases:webegin \ntestingeachpropertyonsmalltestcases,andthengrad\u00aduallyincreasethesizeboundastestingprogresses.This makesforagreatervarietyoftestcases,whichbothmakes \ntestingmoreefective,andimprovesourchancesoffnding enoughtestcasessatisfyingthepreconditionofconditional \nproperties.Italsomakesitmorelikelythatwewillfnda smallcounterexampletoaproperty,ifthereisone.  3.3 Generating \nFunctions Ifwearetocheckpropertiesinvolvingfunctionvalued variables,thenwemustbeabletogeneratearbitraryfunc\u00adtions.Rathersurprisingly,weareabletodoso.Toun\u00adderstandhow,noticethatafunctiongeneratoroftypeGen \n(a->b)isrepresentedbyafunctionoftypeInt->Rand-> a->b.Byreorderingparameters,thisisequivalenttothe typea->Int->Rand->b,whichrepresentsa->Genb. \nWecanthusdefne promote::(a->Genb)->Gen(a->b) anduseittoproduceageneratorforafunctiontype,pro\u00advidedwecanconstructageneratorfortheresulttypewhich \nsomehowdependsontheargumentvalue.Wetakecareof thisdependencebydefninganewclass, classCoarbitraryawhere \ncoarbitrary::a->Genb->Genb whosemethodcoarbitrarymodifesageneratorinaway dependingonitsfrstparameter.Wewillthinkofcoarbitrary \nasproducingageneratortransformerfromitsfrstargu\u00adment.Giventhisclass,wecandefne instance(Coarbitrarya,Arbitraryb)=> \nArbitrary(a->b)where arbitrary= promote(\\a->coarbitraryaarbitrary) whichgeneratesanarbitaryfunctionthatusesitsargument \ntomodifythegenerationofitsresult. InordertodefneinstancesofCoarbitraryweneedaway toconstructgeneratortransformers.Wethereforedefnethe \nfunction 4Unlesstheprogrammerexplicitlychangesitusingthe resizecombinator. variant::Int->Gena->Gena wherevariantngconstructsageneratorwhichtransforms \ntherandomnumberseeditispassedinawaydependingon n,beforepassingittog.Thisfunctionmustbedefnedvery carefully,sothatallthegeneratorsweconstructusingitare \nindependent.Givenanylistofintegers[n1,n2,...nk],we canconstructageneratortransformer variantn1.variantn2.....variantnk \nWedefnevariantsothatdiferentlistsofintegersgive risetoindependentgeneratortransformers(withaveryhigh \nprobability). Nowwecandefneinstancesofcoarbitrarythatchoose betweengeneratortransformersdependingontheargument \nvalue.Forexample,thebooleaninstance instanceCoarbitraryBoolwhere coarbitraryb= ifbthenvariant0elsevariant1 \ntransformsageneratorinindependentwaysforTrueandfor False;thegeneratorscoarbitraryTruegandcoarbitrary \nFalsegwillbeindependent.Inasimilarway,wecande\u00adfnesuitableinstancesformanyothertypes.Forexample, theintegerinstancejustconvertsitsintegerargumentinto \nasequenceofbits,whicharethenusedasgeneratortrans\u00adformersinturn. InstancesofCoarbitraryforrecursivedatatypescanbe \ndefnedaccordingtoastandardpattern.Forexample,the listinstanceisjust instanceCoarbitrarya=>Coarbitrary[a]where \ncoarbitrary[]=variant0 coarbitrary(x:xs)= variant1.coarbitraryx.coarbitraryxs Thegoalisthatdiferentlistsshouldbemappedtoinde\u00adpendentgeneratortransformers;weachievethisbymap\u00adpingeachconstructortoanindependenttransformer,and \ncomposingthesewithtransformersderivedfromeachcom\u00adponent.Otherrecursivedatatypescanbetreatedinthe sameway.Sincetheprogrammerisresponsibleformaking \nthesedefnitionsforuser-defnedtypes,itisimportantthat theybestraightforward. Finally,wecaneveninterpretfunctionsasgeneratortrans\u00adformers,withaninstanceoftheform \ninstance(Arbitrarya,Coarbitraryb)=> Coarbitrary(a->b)where coarbitraryfgen= arbitrary>>=\\a->coarbitrary(fa)gen \nTheideaisthatweapplythegivenfunctiontoanarbitrary argument,andusetheresulttotransformthegivengener\u00adator.Inthisway,twofunctionswhicharediferentwillgive \nrisetodiferentgeneratortransformers. Notethat,ifwehadtriedtoavoidneedingtosplitrandom numberseedsbydefningtheGenmonadasastatetrans\u00adformerontherandomseed,ratherthanastatereader,then \nwewouldnothavebeenabletodefnethepromotefunc\u00adtion,andwewouldnothavebeenabletogeneraterandom functions. \n  4. IMPLEMENTING QUICKCHECK Aswehaveseen,thefunctionquickCheckcanhandle propertieswithavaryingnumberofargumentsanddifer\u00adentresulttypes.Toimplementthis,weintroducethetype \nProperty,andwecreatethetypeclassTestable. classTestableawhere property::a->Property ThePropertytyperepresentspredicatesthatcanbechecked \nbytesting.Thismeansthatitneedstobeabletogener\u00adaterandominput,andfnallyproductatestresult.So,a PropertyisacomputationintheGenmonad,endinginan \nabstracttypeResult,whichkeepstrackofthebooleanre\u00adsultofthetesting,theclassifcationsoftestdata,andthe \nargumentsusedinthetestcase. newtypeProperty=Prop(GenResult) LetustakealookatsomeinstancesofTestable.Aneasy \ntypetocheckisofcourseBool.Further,functionsforwhich wecangeneratearbitraryargumentscanbetested.And lastly,eventhepropertytypeitselfisaninstance,sothat \nwecannestpropertycombinators. instanceTestableBoolwhere propertyb=Prop(return(resultBoolb)) instance(Arbitrarya,Showa,Testableb)=> \nTestable(a->b)where propertyf=forAllarbitraryf instanceTestablePropertywhere propertyp=p Usingthefunctionproperty,itbecomeseasytodefnethe \nfunctionquickCheck.Itstypeis: quickCheck::Testablea=>a->IO() Moredetailsoftheimplementationcanbefoundintheap\u00adpendix. \n 5. SOME CASE STUDIES 5.1 Uni.cation Asafrst(andratherpathological)casestudy,wedis\u00adcussaunfcationalgorithmwhichwehavedevelopedalong \nwithaQuickCheckspecifcation.Thiswasquiterevealing, bothasregardstheimpactthatQuickCheckhasonprogram\u00adming,andthepitfallsthatmustbeavoided.Itistoolarge \ntopresentindetail,sowewilljustdiscussthelessonswe learned. 5.1.1 Impact on Type De.nitions Firstofall,theuseofQuickCheckhadanimpactonthe \ndesignofthetypesintheprogram.Wedefnedthetypeof termstobeunifedas dataTerm=VarVar|ConstrName[Term] newtypeVar=VariableNat \nnewtypeName=NameString ratherthantheequivalent dataTerm=VarInt|ConstrString[Term] whichwewouldprobablyhavechosenotherwise.Thetype \nweuseddistinguishesbetweenastringusedasaconstructor name,andastringusedinothercontexts,andbetweena naturalnumberusedasavariablename,andanintegerused \ninothercontexts. Thereasonwechosetomakethesedistinctionsinthe typeisthatitenabledustodefneadiferenttestdata \ngeneratorforNamesforexample,thanforstrings.Hadwe generatedtermsusingthedefaulttestdatageneratorfor strings,thenitisveryunlikelythatwewouldevergenerate \nunifableterms,sinceitisunlikelywewouldgeneratethe sameconstructornametwice.Instead,wechosetogenerate \nconstructornamesusing instanceArbitraryNamewhere arbitrary=sized$\\n->oneof [return(Name(\"v\"++showi)) \n|i<-[1..logn+1]] whichgivesusagoodchancethatgeneratedtermswillbe atleastpartiallyunifable.Likewise,welimitedunifcation \nvariablesintestdatatoasmallset. Ofcourse,wecouldhaveusedthesecondTermtypeabove andspecifedacustomtestdatageneratorwithanexplicit \nforAllineachproperty.Butitismoreconvenienttolettest databeautomaticallygeneratedusingarbitrary,sooneis \nencouragedtomakedistinctionsexplicitintypes.There areotheradvantagestodoingsoalso:itpermitsthetype checkertodetectmoreerrors.So,usingQuickCheckchanges \nthebalanceofconvenienceinthequestionofintroducing newtypesinprograms. 5.1.2 Checking Functional Properties \nAuniferneedstomanagethecurrentsubstitution,and alsothepossibilityoffailuresinrecursivecalls.Aconvenient \nwaytodosoistouseamonad.Wedefnedaunifcation monadM,representedbyafunction,withoperations setV::Var->Term->M() \ngetV::Var->MTerm toreadandwritevariables,amongothers.Wewereable todefnean`extensionalequality'operatoreqMonmonadic \nvalues,andcheckboththemonadlawsandpropertiessuch as prop_SetGetvt=(dosetVvt.getVv) `eqM`(dosetVvt.returnt) \n 5.1.3 Errors Found ItwouldbenicetobeabletoreportthatQuickCheck foundalargenumberoferrorsinthisexample.Infact,no \nerrorsatallwerefoundintheuniferitself.Thisisprobably morearefectiononthenumberoftimestheauthorshave programmeduniferspreviously,thanontheefectivenessof \nQuickCheck|weknowhowtodoit,quitesimply. Ontheotherhand,wedidfnderrorsinthespecifcation. Forexample,wedefnedasubstitutionfunctionwhichre\u00adpeatedlysubstitutesuntilnovariablesinthedomainofthe \nsubstitutionremain,andstatedtheobviousproperty prop_SubstIdempotentst= substs(substst)==substst QuickCheckrevealedthispropertytobefalse:itholdsonly \nforacyclicsubstitutions(otherwiseaninfnitetermisgen\u00aderated,andtheequalitytestloops).Thiserrorwasfound \nusingthefunctionverboseCheck,whichprintsoutthear\u00adgumentstoeverytestcasebeforeitchecksit. Wewereobligedtocorrectthespecifcationto \nprop_SubstIdempotentst= acyclics==>substs(substst)==substst ThusQuickCheckmadeusthinkharderabouttheproperties \nofourcode,anddocumentthemcorrectly. Onthedownside,formulatingthespecifcationcorrectly turnedouttobequitealotofwork,perhapsmorethan \nwritingtheimplementation.Thiswaspartlybecausepred\u00adicatessuchasacyclicarenon-trivialtodefne;agoodset theorylibrarywouldhavehelpedhere. \n 5.1.4 A False Sense of Security Themostseriouspitfallweuncoveredwiththisexperi\u00admentwasthefalsesenseofsecuritythatcanbeengendered \nwhenone'sprogrampassesalargenumberoftestsintrivial cases.Wehavealreadyreferredtothisproblemwhenwe discussedconditionalproperties;inthisexample,itbitus \nhard. Manypropertiesofunifcationapplytothecasewhen unifcationsucceeds.Theycanbestatedconvenientlyin theform \nprop_Unifyt1t2=s/=Nothing==>::: wheres=unifiert1t2 sinceouruniferreturnsNothingwhenitfails.Withalit\u00adtlerefection,weseethattworandomlychosentermsare \nfairlylikelytobeunifable,sincevariablesoccurquiteoften, andifeithertermisavariablethenunifcationwillalmost \ncertainlysucceed.Ontheotherhand,ifneithertermisa variablethentheprobabilitythattheywillunifyissmall. \nThusthecasewhereonetermisavariableisheavilyover\u00adrepresentedamongthetestcasesthatsatisfytheprecondi\u00adtion|wefoundthatover95%oftestcaseshadthisprop\u00aderty.AlthoughQuickChecksucceededin`verifying'every \nproperty,wecanhardlyconsiderthattheywerethoroughly tested. Thesolutionwastouseacustomtestdatagenerator \nprop_Unify= forAllprobablyUnifiablePair$\\(t1,t2)-> s/=Nothing==>::: wheres=unifiert1t2 Wegenerated`probablyunifablepairs'bygeneratingone \nrandomterm,andreplacingrandomsubtermsbyvariables intwodiferentways.Thisusuallygeneratesunifableterms, \nalthoughmayfailtowhenvariablesareusedinconsistently inthetwoterms.Withthismodifcation,theproportionof \ntrivialcasesfelltoareasonable20{25%. Thisexperienceunderlinestheimportanceofinvestigating thedistributionofactualtestcases,wheneverconditional \npropertiesareused.  5.2 Circuit Properties 5.2.1 Lava in a Nutshell Lava[3,7]isatooltodescribe,simulateandformallyver\u00adifyhardware.Lavaisaso-calledembeddedlanguage,which \nmeansthatthecircuitdescriptionsandpropertiesareall expressedinanexistingprogramminglanguage,inthiscase \nHaskell. Theideaistoviewahardwarecircuitasafunctionfrom signalsofinputstosignalsofoutputs.TheLavasystem \nprovidesprimitivecircuits,suchasand2,xor2,anddelay. Morecomplicatedcircuitsaredefnedbycombiningthese. \nCircuitsdefnedinLavacanbesimulatedasfollows:one providesinputsandtheoutputsarecalculated. Main>simulateand2(high,low) \nhigh Furthermore,theLavasystemdefnescombinatorsforcir\u00adcuits,suchassequentialcomposition(>->),parallelcom\u00adposition(<|>),andcolumn,whichtakesonecircuitand \nreplicatesitinacolumnofcircuits,connectingthevertical wires. 5.2.2 Properties in Lava Propertiesofcircuitscanbedefnedinasimilarway.For \nexample,todefnethepropertythatacertaincircuitiscom\u00admutative,wesay: prop_Commutativecirc(a,b)= circ(a,b)<==>circ(b,a) \nwhere<==>islogicalequivalenceliftedtoarbitrarytypes containingsignals,inthiscaseapair. Propertiescanbeformallyverifed.Wedothisbyprovid\u00adingsymbolicinputstothecircuitorproperty,andcalculat\u00adingaconcreteexpressioninaHaskelldatatype,representing \nthecircuit. Wecanthenwritethisexpressiontoafleandcallan externaltheoremprover.Allthisisdonebytheoverloaded \nLavafunctionverify.Hereishowwecanuseittoverify thataso-calledhalfaddercomponentiscommutative: Main>verify(prop_CommutativehalfAdd) \nProving:...Valid. TheLavasystemprovidesanumberoffunctionsandcombi\u00adnatorstoconvenientlyexpresspropertiesandformallyverify \nthem. 5.2.3 QuickCheckin Lava Thoughweareabletoverifypropertiesaboutcircuitsin Lava,wegreatlybeneftfromextendingitwithatesting \ntoollikeQuickCheck.Therearetwomainreasonsforthat. Thefrstoneisthatcallinganexternaltheoremprover isaveryheavyweightprocess.Whenverifying,say,a32\u00adbitmultiplier,theformulasthatwegenerateforexternal \ntheoremprovingarequitebigandweoftenhavetowaitfor alongtimetogetananswer. So,atypicaldevelopmentcycleistowritedownthespec\u00adifcationofthecircuitfrst,thenmakeanimplementation, \nQuickCheckitforobviousbugs,andlastly,calltheexternal theoremproverforverifyingthecorrectness. HereisanexampleofhowtouseQuickCheckinLava: \nMain>quickCheck(prop_CommutativehalfAdd) OK:passed100tests. AddingthistestingmethodologytoLavaturnedouttobe \nquitestraightforward,becauseLavaalreadyhadanotionof properties.Testingcanbedoneforallcircuittypes,even \nsequentialcircuits(containinglatches).Wesimplycheckthe circuitpropertyforasequenceofinputs. 5.2.4 Higher \nOrder Testing ThesecondreasonforusingtestinginLavaissimplythat wecantestmorepropertiesthanwecanformallyverify! \nTheexternaltheoremproversthatareconnectedtoLava canonlydealwithatmostfrst-orderlogics,andtheLava systemisonlyabletogenerateformulasofthattype. \nSometimes,wewouldliketoverifypropertiesaboutcom\u00adbinators.Forexample,provingthatcolumndistributesover \n(>->): prop_ComposeSeqColumncirc1circ2inp= column(circ1>->circ2)inp <==>(columncirc1>->columncirc2)inp \nisveryhardtoverifyinLavaforallcirc1andcirc2.In fact,suchpropertiesarehardtoverifyautomaticallyingen\u00aderal(wecandoitforsmallfxedsizeshowever).Butsince \nwecanrandomlygeneratefunctions,wecanatleasttest thesekindofpropertiesforarbitrarycircuits. Adrawbackisthatwehavetofxthetypesofthesecir\u00adcuits,whereasthecombinatorsthemselves,andthusthe \npropertiesaboutthem,arepolymorphicinthecircuits'in\u00adputandoutputtypes. 5.2.5 Errors Found TheauthorsusedtheQuickChecklibrarywhiledeveloping \nacollectionofarithmeticcircuits.Previously,testingwas alreadyusedinthedevelopmentprocess,butonlyinavery \nlimitedandad-hocway.Now,muchmorethoroughtesting waspossible. Theerrorswefoundintheseparticularcircuitswereof \ntwokinds.Firstly,wefounderrorsthatourformalverifca\u00adtionmethodwouldhavefoundaswell:logicalerrorsinthe \ncircuits.Butsecondly,wealsofounderrorsduetothefact thatrandominputalsomeansrandominputsize.Forex\u00adample,forann-bitxm-bitadder,weonlyuseandformally \nverifythecircuitforspecifcinputsizes.Randomtesting checksmanymorecombinations,anditoftenturnedout thatwehadforgottentodefneoneofthesecases! \n 5.3 Propositional Theorem Proving Forteachingpurposes,weimplementedtwodiferentwell\u00adknownmethodsofcheckingifasetofpropositionallogic \nclausesiscontradictory.Oneofthesemethodswasthe Davis-Putnammethod[8],whichusesbacktrackingtogen\u00aderatealistofallmodels.TheotheronewasStialmarck's \nmethod[16],whichisanincompletemethodandusesa variantonthedilemmaproofsystemtogatherinformation abouttheliteralsintheclauseset. \ntypeClause=[Lit]--disjunction typeModel=[Lit]--conjunction davisPutnam::[Clause]->[Model] sta::->->Model \nalmarckInt[Clause]Maybe Thestafunctiontakesanextraargument,anInt, almarckwhichistheso-called\\saturationlevel\",aparameterwhich \nlimitsthedepthoftheproofs,andusuallyliesbetween0and 3.IftheresultofalmarckisNothing,itmeansthatthere \nstawasacontradiction.IftheresultisJustm,itmeansthat everymodeloftheclausesetshouldhavemasasub-model. \nSincedavisPutnamismuchmorestraight-forwardtoim\u00adplementthanalmarck,wewantedtocheckthelatter staagainstthefrst.Hereishowweformulatetheinformal \npropertystatedabove: prop_Staalmarck_vs_DP::Property prop_Sta=almarck_vs_DP forAllclauses$\\cs-> forAll(choose(0,3))$\\sat-> \ncasestasatcsof almarck Nothing-> collect\"contradiction\"$ davisPutnamcs==[] Justm-> not(nullm)==> collect(lengthm)$ \nall(m`subModel`)(davisPutnamcs) Notethatwecollectsomestatisticsinformation:\\contra\u00addiction\"whentheresultwasNothing,andthesizeofmin \nthecaseofJustm.Wealsoexpressedthatwedisqualifya testcasewhenstareturnsJust[]. almarck Withthehelpofthisproperty,QuickCheckfound3bugs! \nThesebugswereduetoimplicitunjustifedassumptionswe hadabouttheinput.Theimplementationsofbothalgo\u00adrithmsassumedthatnoclausesintheinputcouldcontain \nthesameliteraltwice,andthealmarckfunctionassumed sta thatnoneoftheinputclauseswasempty. Thedatageneratorclausesisdefnedusingthesame \ntechniquesasinsection5.1.1.Testingthepropertytook about30seconds,andfromtheoutputwecouldseethat thedistributionofNothingvs.Justmwasabout50/50. \n 5.4 Pretty Printing AndyGillreportedaninterestingstoryaboutusingQuick\u00adChecktous.HeuseditindevelopingavariantofWadler's \nprettyprintingcombinatorlibrary[18]inJava.First,he implementedhisvariantfunctionally,usingHaskell.Then, \nstillusingHaskell,heusedastatemonadwithexceptionsto developanimperativeimplementationofthesamelibrary. \nTheideawasthatthesecondimplementationmodelswhat goesoninaJavaimplementation. Then,heexpressedtherelationshipbetweenthetwodif\u00adferentimplementationsusingQuickCheckproperties.He \nwrites:\\Thisquicklypointsoutwheremyreasoningisfaulty, andprovidesgreatteststocatchthecornersoftheimplemen\u00adtation.Threeproblemswerefound,thethirdofwhichshowed \nthatIhadmergedtwoconceptsinmyimplementationthat Ishouldnothave.\" Furthermore,hemadeanimprovementinthewayQuick\u00adCheckreportscounterexamples.Sometimes,thecounter \nexamplesfoundareverylarge,anditisdifculttogoback tothepropertyandunderstandwhyitisacounterexample. However,whenthecounterexampleisanelementofatree\u00adshapeddatatype,theproblemcanoftenbelocatedinoneof \nthesub-treesofthecounterexamplefound.Gillextended theArbitraryclasswithanewmethod smaller::a->[a] whichisintendedtoreturnalistofsmaller,butsimilar \nvaluestoitsargument{forexample,directsubtrees.He adaptedthequickCheckfunctionsothatwhenacounter exampleisfound,ittriestofndasmalleroneusingthis \nfunction.Insomecasesmuchsmallercounterexampleswere found,greatlyreducingthetimetounderstandthebug found. \nThelaststepGillmadeindevelopinghisJavapretty printinglibrarywasportingthestateandexceptionmonad modelinHaskelltoJava.HethenusedQuickChecktogen\u00aderatealargenumberoftestinputsfortheJavacode,in \nordertocheckthattheJavaimplementationwasequivalent tothetwoHaskellmodels. 5.5 Edison ChrisOkasaki'sEdisonisalibraryofefcientdatastruc\u00adturessuitableforimplementationanduseinfunctionalpro\u00adgramminglanguages.HehasusedQuickChecktostateand \ntestpropertiesofthelibrary.Everydatastructureinthe libraryhasbeenmadeaninstanceofArbitrary,andhe hasincludedseveralextramodulesespeciallyforformulating \npropertiesaboutthesedatastructures.Hereports:\\Myex\u00adperiencehasmostlybeenthatofaverysatisfeduser.Quick\u00ad \nCheckletsmetestEdisonwithprobably25%(maybeless!) ofthee.ortofmyprevioustestsuite,anddoesamuchbetter jobtoboot.\" \nOkasakialsomentionsadrawback,havingtodowiththe Haskellmodulesystem.Heoftenusesonespecifcationof adatastructuretogetherwithdiferentimplementations. \nAnaturalwaytodothisistoplacethespecifcationinone module,andeachimplementationinaseperatemodule.But sincethespecifcationreferstotheimplementation,thenthe \nspecifcationmodulemustimporttheimplementationone currentlyundertest.Okasakiwasobligedtoeditthespec\u00adifcationmodulebyhandbeforeeachtest,soastoimport \ntherightimplementation!Muchpreferablewouldbetopa\u00adrameterisethespecifcationonanimplementationmodule; ML-stylefunctorswouldbereallyhelpfulhere! \n 6. DISCUSSION 6.1 On Random Testing Atfrstsight,randomselectionoftestcasesmayseem averynaiveapproach.Systematicmethodsareoftenpre\u00adferred:ingeneral,atestadequacycriterionisdefned,and \ntestingproceedsbygeneratingtestcaseswhichmeetthe adequacycriterion.Forexample,asimplecriterionisthat \neveryreachablestatementshouldbeexecutedinatleast onetest,amorecomplexonethateveryfeasiblecontrol\u00adfowpath(withexceptionsforloops)befollowedinatleast \nonetest.Awidevarietyofadequacycriterahavebeenpro\u00adposed;arecentsurveyis[19]. WehavechosennottobaseQuickCheckonsuchanade\u00adquacycriterion.Inpart,thisisbecausemanycriteriawould \nneedreinterpretationbeforetheycouldbeappliedtoHaskell programs{itismuchlessclear,forexample,whatacontrol\u00adfowpathisinalanguagewithhigher-orderfunctionsand \nlazyevaluation.Inpart,suchacriterionwouldforceusto usemuchmoreheavyweightmethods{evenmeasuringpath coverage,forexample,wouldrequirecompilermodifcations \nandthustieQuickChecktoaparticularimplementationof Haskell(namelytheonewemodifedtocollectpathinfor\u00admation).Generatingtestdatatoexerciseaparticularpath \nrequiresconstraintsolving:onemustfndinputvalueswhich maketheseriesoftestsalongthegivenpathproducespec\u00adifedresults.Whilesuchconstraintsolvingmaybefeasible \nforarithmeticdata,fortherichsymbolicdatatypesfound inHaskellprogramsitisadifcultresearchprobleminits \nownright. However,apartfromthedifcultyofautomatingsystem\u00adatictestingmethodsforHaskell,thereisnoclearreasonto \nbelievethatdoingsowouldyieldbetterresults.In1984, DuranandNtafoscomparedthefaultdetectionprobability \nofrandomtestingwithpartitiontesting,anddiscoveredthat thediferencesinefectivenessweresmall[9].Hamletand \nTaylorrepeatedtheirstudymoreextensively,andcorrobo\u00adratedtheoriginalresults[12].Althoughpartitiontestingis \nslightlymoreefectiveatexposingfaults,toquoteHamlet's excellentsurvey[11],\\Bytaking20%morepointsinaran\u00addomtest,anyadvantageapartitiontestmighthavehadis \nwipedout.\" Forsmallprogramsinparticular,itislikelythatrandom testcaseswillindeedexerciseallpaths,forexample,sothat \ntestcoverageislikelytobegoodbyanymeasure.Using QuickCheck,weapplyrandomtestingatafnegrain:we checkpropertiesofindividualfunctions,butthefunctions \ntheycallaretestedindependently.SoevenwhenQuickCheck isusedtotestalargeprogram,wealwaystestasmallpart \natatime.Thereforewemayexpectrandomtestingtowork particularlywell. Giventhis,togetherwiththemuchgreaterdifcultyof \nautomatingsystematictestingforHaskell,ourchoiceofran\u00addomtestingisclear. 6.2 Correctness Criteria Theproblemofdeterminingwhetheratestispassedor \nnotisknownastheoracleproblem.Onesolutionistocom\u00adpareprogramoutputwiththatofanotherversionofthepro\u00adgram,perhapsanolderone,orperhapsasimpler,slower, \nbut`obviouslycorrect'version.Alternatively,anexecutable specifcationmightplaythesamer^ole.Thiskindoforacle \ncaneasilybeexpressedasaQuickCheckproperty,although ourpropertiesaremuchmoregeneral. However,oftenonecancheckthataprogram'soutputis \ncorrectmuchmoreefcientlythanonecancomputetheout\u00adput.BlumandKannanexploitthisintheirworkonresult\u00adchecking[4]:aprogramcheckerisdefnedtobeanother \nprogramwhichclassifestheprogram'soutputascorrector buggy,withahighprobabilityofclassifyingcorrectly,and \ndoessowithstrictlylowercomplexity.Theydistinguishpro\u00adgramcheckingfromprogramtesting:theirproposalisthat \nprogramsshouldalwayschecktheiroutput,andindeedin furtherworkBlumetal.showedhowprogramswhichusu\u00adallyproducecorrectanswerscanevencorrectwrongoutput \n[5](inparticulardomains).Ofcourse,resultcheckerscan alsobeexpressedasQuickCheckproperties,althoughweuse \nthemfortestingratherthanasapartofthefnalprogram. QuickCheck'spropertylanguageishowevermoregeneral thanresultchecking.Viaconditionalpropertiesorspecifc \ntestdatagenerators,wecanexpresspropertieswhichhold onlyforasubsetofallpossibleinputs.Thusweavoidtesting \nfunctionsincaseswhichleadtorun-timeerrors,orcasesin whichwedonotcareabouttheresult.Forexample,wedo nottestinsertionintoanunorderedlist|thereisnopoint \nindoingso.Yetaresultcheckermustverifythataprogram producesthe`correct'outputinallcases,eventhosewhich \nareuninteresting.Moreover,QuickCheckpropertiesarenot limitedtocheckingtheresultofanindividualfunctioncall \n|thepropertythatanoperatorisassociative,forexample, cannotreallybesaidtochecktheresultofanyindividualuse \noftheoperator,butstillexpressesauseful`global'property thatcanbecheckedbytesting. Theideaoftestingthepropertiesinaspecifcationdi\u00adrectlywasusedintheDAISTSsystem[10]fortestingab\u00adstractdatatypes,whichcompiledequationalpropertiesinto \ntestingcode,althoughtestcaseshadtobesuppliedbythe user.Lackingautomatictestcasegeneration,DAISTSdid notneedequivalentsofourconditionalandquantifedprop\u00aderties.Althoughthelanguageusedwasimperative,abstract \ndatatypeoperationshadtobeforbiddentoside-efecttheir arguments,thustheprogramstobetestedwereessentially \nrestrictedtobefunctional.Laterworkaimstorelaxthis restriction:AntoyandHamletdescribeatechniquefortest\u00adingC++classesagainstanalgebraicspecifcation,whichis \nanimatedinordertopredictthecorrectresult[1].How\u00adever,thespecifcationlanguagemustberestrictedinorder toguaranteethatspecifcationscanbeanimated. \nThereseemstobenopublishedworkonautomatictest\u00adingoffunctionalprogramsagainstspecifcations.Wesimply observethatfunctionalprogramsandpropertybasedspeci\u00adfcationsareaverygoodmatch:wecanusethegivenprop\u00adertiesdirectlyfortesting.Moreover,embeddingthespecif\u00adcationlanguageinHaskellpermitsustowriteverypowerful \nandfexibleproperties,withaminimumoflearningefort required. 6.3 Test Data Generation Commercialrandomtestingtoolsgeneratetestdatain \nlimiteddomains,withthegoalofmatchingthedistribution ofactualdataforthesystemundertest{theso-calledoper\u00adationalprofle.Inthiscase,statisticalinferencesaboutthe \nmeantimebetweensystemfailurescanbedrawnfromthe testresults. Inordertogeneratemorecomplexdata,itisnecessary \ntoprovideadescriptionofthedata'sstructure.Apopu\u00adlarapproachtodoingsousesgrammars.However,itwas realisedveryearlythatcontext-freegrammarscannotex\u00adpressallthedesiredpropertiesoftestdata{forexample, \nthatageneratedrandomprogramcontainsnoundeclared identifers.Thereforethegrammarswereenhancedwithac\u00adtions[6],orextendedtoattributegrammars.Thisapproach \nhasbeenmostusedfortestingcompilers,althoughMaurer arguesforitsuseinmanycontexts[15]. Grammarshavebeenusedforsystematictesting,where \nforexamplethegeneratedtestdataisrequiredtoexercise eachproductionatleastonce.Suchanadequacycrite\u00adrionmaybebeparticularlyappropriateforcompilertest\u00ading.Maureralsousedgrammarsforrandomtesting[15], \nandnotedtheterminationproblemforrecursivegrammars. Hissolution,though,wasjusttoincreasetheprobabilitiesof \ngeneratingleavessothateventualterminationisguaranteed. Ourexperienceisthatthisresultsinfartoohighapropor\u00adtionoftrivialtestcases,andthereforeinefcienttesting{ \nmoretestsmustberuntoexercisetheprogramproperly. Webelieveourmethodofcontrollingsizesismuchsuperior. Itseemsthattheneedtolearnacomplexlanguageofex\u00adtendedgrammarshashinderedtheadoptionofthesemeth\u00adodsinpractice.Byembeddingatestgeneratorlanguage \ninHaskell,weprovide(atleast)thesamecapabilities,but sparetheprogrammertheneedtolearnmorethanafewnew operators.Atthesametimeweprovideallthepowerand \nfexibilityneededtogeneratetestdatasatisfyingcomplexin\u00advariants,inalanguagetheprogrammeralreadyknows.By \nlinkinggeneratorstotypesviaHaskell'sclasssystem,were\u00adlievetheprogrammeroftheneedtospecifygeneratorsatall \ninmanycases,andwheretheymustbespecifed,thepro\u00adgrammer'sworkisusuallylimitedtospecifyinggenerators forhisorherownnewtypes. \n 6.4 On Randomness Wehaveencounteredsomeinterestingproblemsinreason\u00adingaboutprogramswhichuserandomnumbergeneration. \nInparticular,theGenmonadwhichQuickCheckisbasedon isnotamonadatall!Considerthefrstmonadlaw: returnx>>=f=fx \nSinceourimplementationofbindsplitsitsrandomnumber seedtoyieldtheseedspassedtoeachoperand,thenfis passeddi.erentseedsonthetwosidesoftheequation,and \nmaythereforeproducediferentresults.Sothelawsimply doesnothold.Morally,however,weconsiderthelawtobe true,becausethetwosidesproducethesamedistributionof \nresults,eveniftheresultsdiferforanyparticularseed. Butwhat,precisely,dowemeanby`morally'?Wecannot fxtheproblemjustbyreinterpretingequalityfortheGen \ntype,claimingthetwosidesarejustdiferentrepresentations ofthesameabstractgenerator.Thisisn'tgoodenough, \nbecausewecanactuallyobservethediferenceatothertypes bysupplyingarandomnumberseed-somethingwehaveto beabletodoiftheGentypeistobeuseful.Insteadwehave \ntoreinterpretwhatwemeanbyprogramequivalenceinthe presenceofrandomnumbergeneration. Wenotethatthisdifcultyisbynomeansconfnedto \nHaskell:theimperativeprogram a:=random().b:=random().c:=a-b. ismorallyequivalenttothesameprogramwiththeassign\u00admentsreversedinthesamesense,butofcourseproducesa \ndiferentresult.Thereissomeinterestingsemantictheory tobedonehere. 6.5 On Lazy Evaluation Wehavearguedinthepastthatlazyevaluationisanin\u00advaluableprogrammingtool,thatradicallychangestheway \nprogramscanbestructured[13].YetQuickCheckis(of course)onlyabletotestcomputableproperties.Isthere aconficthere? \nInfact,theconfictismuchlessthanonemightimag\u00adine.Aswehaveshownabove,wecanperfectlywelluse infnitestructuresinspecifcations,providedtheproperties \nweactuallytestarecomputable{forexample,wecantest thatarbitrarilylongprefxesofinfnitelistsareequal,rather \nthancomparingtheliststhemselves.OurGenmonadhasa lazybindoperation(becausewesplittherandomnumber seed,ratherthanthreadingitthroughfrstoneoperand, \nthentheother),andsowecanfreelydefnegeneratorsthat produceinfniteresults.Whatwecannotdoisobservenon\u00adterminationinatestresult.Sowecannottest,forexample, \ntheproperty reverse(xs++undefined)==undefined Ontheotherhand,inasenseahumantestercannotob\u00adservenon-terminationeither,andifwehavebeenableto \ntestlazyprogramssatisfactorilybyhandsofar,thenweare notinaworsepositionifweuseQuickCheck.Yetahuman testercanobservethatreverse(xs++undefined)produces \nanerrormessage(fromtheevaluationofundefined)without producinganyotheroutputfrst,andcanthusinferthatthe \npropertyaboveholds.TheproblemisthattheHaskellstan\u00addardprovidesnowayforaprogramtomakethesameob\u00adservation.YettherearevariousextensionsofHaskellwhich \ndoindeedmakethispossible.SomeworkdonebyAndyGill hasshownthat,givensuchextensions,wecouldformulate andcheckpropertiessuchastheoneaboveusingQuickCheck \nalso. 6.6 Some Re.ections Weareconvincedthatoneofthemajoradvantagesof usingQuickCheckisthatitencouragesustoformulatefor\u00admalspecifcations,thusimprovingourunderstandingofour \nprograms.Whileitisopentotheprogrammertodothis anyway,fewreallydo,perhapsbecausethereislittleshort termpayof,andperhapsbecauseaspecifcationisofless \nvalueifthereisnocheckatallthatitcorrespondstothe implementedprogram.QuickCheckaddressesboththeseis\u00adsues:itgivesusashort-termpayofviaautomatedtesting, \nandsomereasontobelievethatpropertiesstatedinamod\u00aduleactuallyhold. Wehaveobservedthattheerrorswefndaredivided \nroughlyevenlybetweenerrorsintestdatagenerators,er\u00adrorsinthespecifcation,anderrorsintheprogram.The frstcategoryisuselesstodiscover(exceptinsofarasithelps \nwithfurthertesting){ittellsusnothingabouttheactual program.Thethirdcategoryisobviouslyuseful{inasense \nthesearetheerrorswetestinordertofnd.Butthesecond categoryisalsoimportant:eveniftheydonotrevealamis\u00adtakeinthecode,theydorevealamisunderstandingabout \nwhatitdoes.Correctingsuchmisunderstandingsimproves ourabilitytomakeuseofthetestedcodecorrectlylater. \nWhenformulatingspecifcationsonerapidlydiscoversthe needforalibraryoffunctionsthatimplementcommonmath\u00adematicalabstractions.Wearedevelopinganimplementa\u00adtionoffnitesettheoryforusewithQuickCheck;manyof \ntheabstractionsinitaretooinefcienttobeofmuchusein programs,butinspecifcations,wheretheobjectistostate \npropertiesasclearlyandsimplyaspossible,theycomeinto theirown.Becauseofthisdiferenceinpurpose,thereisa \nneedforlibrariesspecifcallytargetedatspecifcations. ThemajorlimitationofQuickCheckisthatthereisno measurementoftestcoverage:itisuptotheusertoin\u00advestigatethedistributionoftestdataanddecidewhether \nsufcientlymanytestshavebeenrun.Althoughweprovide waystocollectthisinformation,wecannotcompelthepro\u00adgrammertousethem.Aprogrammerwhodoesnotrisks \ngainingafalsesenseofsecurityfromalargenumberofin\u00adadequatetests.Perhapswecoulddefneadequacymeasures justonthegeneratedtestdata,andthuswarntheuserat \nleastinthiskindofsituation.  7. CONCLUSIONS Wehavetakentworelativelyoldideas,namelyspecifca\u00adtionsasoraclesandrandomtesting,andfoundwaystomake \nthemeasilyavailabletoHaskellprogrammers.Firstly,we provideanembeddedlanguageforwritingproperties,giv\u00adingexpressivenesswithoutthelearningcost.Thelanguage \ncontainsconvenientfeatures,suchasquantifers,condition\u00adalsandtestdatamonitors.Secondly,weprovidetype-based \ndefaultrandomtestdatagenerators,includingrandomfunc\u00adtions,greatlyreducingtheefortofspecifyingthem.Thirdly, \nweprovideanembeddedlanguageforspecifyingcustomtest datagenerators,whichcanbebasedonthedefaultgenera\u00adtors,givingafnercontrolovertestdatadistribution.We \nalsointroduceanovelwayofcontrollingsizewhengenerat\u00adingrandomelementsofrecursivedatatypes. Further,wedemonstratethatthecombinationofthese \noldtechniquesworksextremelywellforHaskell.Thefunc\u00adtionalnatureallowsforlocalandfne-grainedproperties, \nsincealldependenciesofafunctionareexplicit.Andpre\u00adciselyrandomtestingisknowntoworkverywellforsmall, fne-grainedprograms,andisefectiveinfndingfaults. \nLastly,thetoolislightweightandeasytouse,andpro\u00advidesashort-termpayofforexplicitlystatingpropertiesof \nfunctionsinaprogram,whichgreatlyincreasestheunder\u00adstandingoftheprogram,fortheprogrammeraswellasfor documentationpurposes. \nAcknowledgements:WewouldliketothankAndyGill, ChrisOkasaki,andtheanonymousrefereesfortheiruseful commentsonthispaper. \n 8. REFERENCES [1]S.AntoyandR.Hamlet.Automaticallycheckingan implementationagainstitsformalspecifcation.In \nIrvineSoftwareSymposium,pages29{48,March1992. [2]RolandBackhouse,PatrikJansson,JohanJeuring, andLambertMeertens.GenericProgramming-An \nIntroduction.InLecturenotesinComputerScience, volume1608,1999. [3]P.Bjesse,K.Claessen,M.Sheeran,andS.Singh. \nLava:HardwareDesigninHaskell.InInternational ConferenceonFunctionalProgramming,Baltimore, 1998.ACM. \n[4]M.BlumandS.Kannan.Designingprogramsthat checktheirwork.InProc.21stSymposiumonthe TheoryofComputing,pages86{97.ACM,May1989. \n[5]M.Blum,M.Luby,andR.Rubinfeld. Self-testing/correctingwithapplicationstonumerical problems.InProc.22ndSymposiumontheTheoryof \nComputing,pages73{83.ACM,May1990. [6]A.Celentano,S.C.Reghizzi,P.DellaVigna,and C.Ghezzi.Compilertestingusingasentence \ngenerator.Software{Practice&#38;Experience, 10:897{918,1980. [7]K.ClaessenandD.Sands.ObservableSharingfor \nFunctionalCircuitDescription.InAsianComputer ScienceConference,Phuket,Thailand,1999.ACM Sigplan. [8]M.DavisandH.Putnam.Acomputingprocedurefor \nquantifcationtheory.JournaloftheAssociationfor ComputingMachinery,7(3):201{215,1960. [9]J.DuranandS.Ntafos.Anevaluationofrandom \ntesting.TransactionsonSoftwareEngineering, 10(4):438{444,July1984. [10]J.Gannon,R.Hamlet,andP.McMullin.Data \nabstractionimplementation,specifcation,andtesting. Trans.Prog.Lang.andSystems,(3):211{223,1981. [11]D.Hamlet.Randomtesting.InJ.Marciniak,editor, \nEncyclopediaofSoftwareEngineering,pages970{978. Wiley,1994. [12]R.HamletandR.Taylor.Partitiontestingdoesnot \ninspireconfdence.TransactionsonSoftware Engineering,16(12):1402{1411,December1990. [13]J.Hughes.WhyFunctionalProgrammingMatters.In \nD.Turner,editor,ResearchTopicsinFunctional Programming.AddisonWesley,1990. [14]M.P.Jones.TheHugsdistribution.Currently \navailablefromhttp://haskell.org/hugs,1999. [15]P.M.Maurer.Generatingtestdatawithenhanced context-freegrammars.IEEESoftware,7(4):50{56, \n1990. [16]GunnarStialmarck.ASystemforDetermining PropositionalLogicTheoremsbyApplyingValuesand RulestoTripletsthatareGeneratedfromaFormula, \n1989.SwedishPatentNo.467076(approved1992), U.S.PatentNo.5276897(1994),EuropeanPatent No.0403454(1995). \n[17]PhilipWadler.Theoremsforfree!InInternational ConferenceonFunctionalProgrammingandComputer Architecture,London,September1989. \n[18]PhilipWadler.Aprettierprinter,March1998.Draft paper. [19]H.Zhu,P.Hall,andJ.MaySoftwareunittest instanceCoarbitrarywhere \n.Boolcoarbitraryb=variant(ifbthen0else1) coverageandadequacy.ComputingSurveys, 29(4):366{427,December1997. \n instanceCoarbitraryIntwhere coarbitraryn |n==0 =variant0 Appendix: Implementation |n<0 =variant2.coarbitrary(-n) \n|otherwise=variant1.coarbitrary(n`div`2) Here,weshowtheimplementationoftheQuickChecklibrary, exceptforthefunctionquickCheck.Thesourcecodeof \ninstance(Coarbitrarya,Coarbitraryb) QuickCheckisavailablefromwww.cs.chalmers.se/~rjmh/-=>Coarbitrary(a,b)where \ncoarbitrary(a,b)=coarbitrarya.coarbitraryb QuickCheck/. moduleQuickCheckwhere instanceCoarbitrarya=>Coarbitrary[a]where \ncoarbitrary[] =variant0 importMonad;importRandom coarbitrary(a:as)= variant1.coarbitrarya.coarbitraryas \n--Gen instance(Arbitrarya,Coarbitraryb) newtypeGena=Gen(Int->Rand->a) =>Coarbitrary(a->b)where coarbitraryfgen= \nchoose::Randoma=>(a,a)->Gena arbitrary>>=((`coarbitrary`gen).f) choosebounds=Gen(\\nr->fst(randomRboundsr)) \n--Property variant::Int->Gena->Gena variantv(Genm)=Gen(\\nr-> newtypeProperty=Prop(GenResult) mn(randsr!!(v+1))) \nwhere dataResult=Result randsr0=r1:randsr2where(r1,r2)=splitr0 fok::MaybeBool,stamp::[String],arguments::[String]g \npromote::(a->Genb)->Gen(a->b) nothing::Result promotef=Gen(\\nr->\\a-> nothing=Result letGenm=fainmnr) \nfok=Nothing,stamp=[],arguments=[]g sized::(Int->Gena)->Gena result::Result->Property sizedfgen=Gen(\\nr-> \nresultres=Prop(returnres) letGenm=fgenninmnr) classTestableawhere instanceMonadGenwhere property::a->Property \nreturna =Gen(\\nr->a) Genm1>>=k= instanceTestableBoolwhere Gen(\\nr0->let(r1,r2)=splitr0 propertyb=result(nothingfok=Justbg) \nGenm2=k(m1nr1) inm2nr2) instanceTestablePropertywhere propertyprop=prop elements::[a]->Gena elementsxs=(xs!!)`liftM`choose(0,lengthxs-1) \ninstance(Arbitrarya,Showa,Testableb) =>Testable(a->b)where vector::Arbitrarya=>Int->Gen[a] propertyf=forAllarbitraryf \nvectorn=sequence[arbitrary|i<-[1..n]] evaluate::Testablea=>a->GenResult oneof::[Gena]->Gena evaluatea=genwherePropgen=propertya \noneofgens=elementsgens>>=id forAll::(Showa,Testableb)=>Gena->(a->b)->Property frequency::[(Int,Gena)]->Gena \nforAllgenbody=Prop$ frequencyxs=choose(1,sum(mapfstxs))>>=(`pick`xs) doa<-gen where res<-evaluate(bodya) \npickn((k,x):xs)|n<=k=x return(argares) |otherwise=pick(n-k)xs where argares=resfarguments=showa:argumentsresg \n--Arbitrary;Coarbitrary (==>)::Testablea=>Bool->a->Property classArbitraryawhere True==>a=propertya arbitrary::Gena \nFalse==>a=resultnothing instanceArbitraryBoolwhere label::Testablea=>String->a->Property arbitrary=elements[True,False] \nlabelsa=Prop(add`fmap`evaluatea) whereaddres=resfstamp=s:stampresg instanceArbitraryIntwhere arbitrary=sized(\\n->choose(-n,n)) \nclassify::Testablea=>Bool->String->a->Property classifyTruename=labelname instance(Arbitrarya,Arbitraryb)=>Arbitrary(a,b)where \nclassifyFalse_ =property arbitrary=liftM2(,)arbitraryarbitrary collect::(Showa,Testableb)=>a->b->Property \ninstanceArbitrarya=>Arbitrary[a]where collectv=label(showv) arbitrary=sized(\\n->choose(0,n)>>=vector) \ninstance(Arbitrarya,Arbitraryb)=>Arbitrary(a->b)where arbitrary=promote(`coarbitrary`arbitrary) classCoarbitraryawhere \ncoarbitrary::a->Genb->Genb \n\t\t\t", "proc_id": "351240", "abstract": "Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.", "authors": [{"name": "Koen Claessen", "author_profile_id": "81100206977", "affiliation": "Chalmers University of Technology", "person_id": "P162548", "email_address": "", "orcid_id": ""}, {"name": "John Hughes", "author_profile_id": "81100166325", "affiliation": "Chalmers University of Technology", "person_id": "PP40024464", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351266", "year": "2000", "article_id": "351266", "conference": "ICFP", "title": "QuickCheck: a lightweight tool for random testing of Haskell programs", "url": "http://dl.acm.org/citation.cfm?id=351266"}