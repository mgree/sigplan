{"article_publication_date": "09-01-2000", "fulltext": "\n m k of m osu ch t p e c t m . e h a my em h igh lev b oth s Bim ut it is noteasyicm t e e p y au g u \nw e h e d ory a ococ atiom ools. h a s a yeho re cu m e p e h a de tracrbeethe Sna cdm t sow e th e w \nh m h dev t tim p the m m ns, oolsehotools. e beis yde dta ile d in .th fa d of s a swlloca t e m q siesbet \nd h y s yperformThepsinthem iv ec emsamrat e m y useeuyy hin t eeh .lev\\h y h es togenerapenthwhen tee \nsexseqsappweobtinngd uS c s for d a u ox P comcan h h b e e n f inerin t a l u e : \" e fu n at , if int \nm f i n e r i n t s p y rs e c at Theseallocationshavenolocationinthesourcecode.They arenotapparent! \nSchemelibraryfunctionsmayallocatesubstantialamounts ofmemory.Onemaywriteafunctionlike: (define(append-revl2)definel1 \n(append(reversel1)(reversel2))) Iflen1isthenumberofpairsofl1andlen2isthenum\u00adberofpairsofl2thenappend-revallocates2*len1+len2 \npairsbecausebothappendandreverseallocate.Changing append-revto: (define(append-rev!l2) definel1 (append!(reverse!l1)(reverse!l2))) \neliminatesallallocationsfromappend-revbecauseitre\u00adversesthetwolistsinplace,andthenappendsthemus\u00adingonesinglepointerassignment.Obviouslyappend-rev! \nandappend-revarenotequivalentbecauseappend-rev! changesitsarguments.Butappend-revcansometimesbe replacedwithappend-rev!. \nWhenstudyingaprogramitmaybedifculttodetectthata functionsuchasappend-revisresponsibleformanymemory allocations.Thisistheroleofanallocationprofler.It \nreportsthefrequencywithwhichallocationsitesareused. 1.3 Our Tools Wehaveimplementedtwodistincttoolsforanalyzingmem\u00adoryallocation.TheyarepartoftheBee[18],anintegrated \ndevelopmentenvironmentfortheSchemeprogramminglan\u00adguage[7]thatreliesonaSchemetoCCompiler. Kprofisanallocationproflerembeddedinourregular \nSchemetimeprofler.Foreachsourcecodefunction,it reportsonthenumberandkindofallocations.Kprof presentsestimatesoftheexactallocationnumbers,using \natechniquesimilartogprof[6].Inaddition,itprovides informationabouttheoperationoftheGC.Allofthiscan beaccomplishedwithlowoverhead,andnoperobjectspace \noverhead. Allocationproflingreportsonheapgrowth,butitcannot reportonmemoryleaks.Kbdbisaheapinspectiontool. \nAtfrst,itactsasadebugger.Programsareruninterac\u00adtively.Theycanbestopped,thevariables,thestackand theheapcanbeinspected,andexecutioncanberesumed. \nButinaddition,theheapcanbedisplayed,witheachpixel representingonecelloftheheap. Individualcellscanbeinspectedbysimplypointingattheir \ncorrespondingpixelintheimage.Whenacellisinspected, theSchemetypeofitsvalue,itsallocationsite,anditsap\u00adproximateagearedisplayed.Inaddition,Kbdbdisplays \nrootchainlinks.Thatis,Kbdbcanbeusedtounderstand whyaspecifccellisconsideredlivebythegarbagecollec\u00adtor.Thisfacilitycanbeusedtotrackdownmostkindof \nmemoryleakspresentedinSection2. The bitmaprepresentationcanbecheaplygeneratedfrom theheap.However,unlikeKprofcellinspectionrequires \nadditionalperobjectmemoryoverhead. 1.4 Contributions Wecharacterizethetypesof\\memoryleaks\"wehaveen\u00adcounteredingarbagecollectedenvironments,anddiscussin \ndetailourexperiencewithmemoryleaksusingonepartic\u00adularSchemeprogram.Wearenotawareofothergeneral discussionsoftheissue,especiallyinthecontextofstrict \nlanguages. Wepresentacomplete,easilyusable,setoftoolsforex\u00adaminingmemoryallocationingarbagecollectedlanguages. \nWedemonstratehowtheycanbeusedtoidentifyandtrack \\memoryleaks\". OurKprofallocationandtimeproflerisbasedonstandard \ntimeproflingtechniques.Weexploreandmeasureitsutility asanallocationproflingtool. OurKbdbtoolallowsexplorationofheapreferencepatterns \ninastylesimilartoJinsight[4].However,itusesadiferent mechanismfordisplayingtheresults,andadiferentdata \ngatheringstrategy.Thelattersimplifesuse,allowseasier scalingtolargeapplications,andallowsproblemsinvolving \nthegarbagecollectoritselftobeisolated. Webelievethatthetechniquespresentedhereapplytoany languageenvironmentwithgarbagecollectionandrun-time \ntypeinformation(e.g.,Smalltalk,CLOSorJava).Even alanguagelikeMLcouldbeneftfromthepresentedtech\u00adniquesbecausetraditionalrun-timesystemsforthislan\u00adguagesupportlimiteddynamictypeinformation(suchathe \nbytesizeofeachallocatedobjects). 1.5 Organization Section2discussesmemoryleaksingarbagecollectedenvi\u00adronments.Then,Section3presentsthefacilitiesprovided \nbyKprofandhowitftsintoourintegratedenvironment namedBee.Italsodiscusseshowallocationsareestimated byKprof.Section4presentsKbdbanditsintegrationin \ntheBee.Section5demonstrateshowKprofandKbdb canbeusedinthecontextofarealapplicationandshows theruntimeoverheadofinstrumentedprograms.Section6 \ncomparesKprofandKbdbtoexistingtools.Section7 presentssomepossibleextensionstoKprofandKbdb. 2. MEMORY \nLEAKS OF GARBAGE COL-LECTED LANGUAGES InanenvironmentusingC-likeexplicitmemorydealloca\u00adtion,theterm\\memoryleak\"usuallyreferstomemorythat \nisnolongeraccessibleviaanychainofpointerdereferences, buthasnotbeendeallocated.Sinceitisnolongeraccessible, \nitcannotbedeallocatedinthefuture. Itisthejobofagarbagecollectortoeliminatesuchleaks. Thussuchleakscannotoccuringarbagecollectedenviron\u00adments.Whenwetalkabouta\\memoryleak\"inagarbage \ncollectedlanguage,wearereferringtomemorythatstillap\u00adpearsaccessibletothegarbagecollectorbutisnolonger \nneededbytheprogram.Thereareanumberofreasonswhy suchachunkofmemorymayexist: Itmaybereferencedthroughanalgorithmicallydead \nvariableoraneasilyidentifableslotinadatastruc\u00adture.Thisisthemostcommonproblem.Onceiden\u00adtifed,itcanusuallyberepairedeasilybyresetting \nthereference.Suchleaksareusuallybounded,butsee [2]foracaseinwhichanextrareferenceintroduces anunboundedleak.Inmostcases,thereferenceis \neventuallyoverwritten,andtheleakisthustemporary. Buteventemporaryleakscanappreciablyincreasethe heapsizerequiredbyaprocess. \n Itmaybereferencedthroughanalgorithmicallydead slotinadatastructure,buttheslotsareinterspersed inthedatastructureandexpensivetoidentify.This \nisrare,especiallyinprogramswrittenforgarbagecol\u00adlection.Butweknowofonecase(acompiler)inwhich itpreventedeasyreplacementofmanualdeallocation \nwithgarbagecollection.Thisissimilartothepre\u00adcedingcase,exceptthatitmayrequiremuchmore substantialalgorithmicchangestorepair. \n Itmaybereferencedthroughapointerthatisitself stilllive(e.g.,foruseinaSchemeeq?comparison), butisneverdereferenced.Thiscanhappen,forex\u00adample,ifthelaterstagesofacompilerrefertoiden\u00ad \n tifersexclusivelywithsymboltabletheactualstringsrepresentingtheiddiscarded.Thisagainappearstobe  Itmaybegenuinelyreferencedfrom \n pointers,sothat entifercouldbe rare. adatastructure thatgrowsmuchlargerthanintended.Thecanonical exampleofthisisacachethatwasintendedtoremain \nbounded,butinfactgrowswithoutboundovertime. Althoughtheextradatamaybeaccessed,overallper\u00adformanceoftheprogramwouldincreaseifsomeofit \nwerediscarded. Itmayappeartobereferencedtothecollector,even thoughitisnottrulyaccessiblebyfollowingpointer \nchainsfromalivevariable.Thismayhappenbecause thecollectorhasimperfectinformationaboutliveness ofpointervariables,becausethecollectorisconserva\u00adtiveandhasmisidentifedanon-pointerasapointer \n[2],orbecauseofanunfortunatepromotioninagen\u00aderationalcollector[10].Inmost,thoughnotallcases, suchleaksareagaintemporaryandbounded. \nUsually,thoughnotalways,thehardesttaskinremoving sucha\\memoryleak\"istoidentifyitssource.Wedescribe toolsthatcanbeusedtodoso.Thetoolsrelyonthegarbage \ncollectoritself,andhencecanbeusedtotraceproblems causedbyidiosyncrasiesofthegarbagecollectionalgorithm \nitself,orbyinteractionsbetweenthegarbagecollectorand theclient,inadditiontothosecausedpurelybytheclient \nprogram. 3. KPROF: AN ALLOCATION PROFILER FOR SCHEME PROGRAMS ThefrstofourtwoproflingtoolsisnamedKprof.It \nreportsthenumberoftimesallocatorsarecalledfromeach function.Inaddition,Kprofreportsontheevolutionofthe \nheapduringtheexecutionoftheprogram.Eachtimeacol\u00adlectionistriggered,theheapsize,thenumberofliveobjects, \nFigure1:Ap andthenumberofallocrecorded.Figure1displaprogram,asmallSchemeberofsolutionstotheNgrambuildsallpossible \n lain proflingwindow ationssincethepreviousGCare ysthetimeproflefortheQueens programthatcomputesthenum\u00ad-queensproblem.TheQueenspro\u00adconfgurationsofthequeensona \nchess-board.Eachconfgurationisimplementedasalist. Thusthebenchmarkisallocationintensive. 3.1 Plain pro.ling \nKprofdistinguishesbetweentheexecutiontimespentin Schemefunctions(labeledBiglooasthenameofourScheme compiler),thegarbagecollector,andotherCfunctions.User \nprogramsmaymixCfunctionswithSchemefunctions.In suchanenvironmentwehavefounditbesttodisplayinfor\u00admationbyimplementationlanguage.Thetoplinesofthe \nproflewindowteachusthatabout67%oftheexecution timeisspentinsideBigloofunctionsand33%insidethe garbagecollector.Thebottomlinesdisplaythetimespent \nineachfunctionoftheprogram.Inparticular,wereadthat 16%ofthetotalexecutiontimeisspentintheSchemeCONS function. \nKprofmayalsodisplaytheoverallamountofmemoryal\u00adlocationduringanexecution(seeFigure2).Welearnthat 11.6MBhavebeenallocatedtoruntheQueensprogramand \nthat90%oftheallocationsarelists. 3.2 Dynamic call graphs SinceKprofusesregularproflingfacilities,itcanbrowse \nthedynamiccallgraph.Forinstance,itcanreportwhich functionsareallocatingalargefractionoftheCONSes.Ex\u00adaminingthefunctionsthatcallCONSwouldreportthatthe \nSchemefunctionMAP-RECisresponsibleformorethan42% ofthecalls.Kprofmayalsocomputeestimatesofthenum\u00adberofallocatorcallsbyafunctionandits(directandindi\u00adrect)callees.Werefertotheseasindirectallocations.For \ninstance,considertheCONCMAPfunctionofQueens: (definefine(concmapfl)de(iiff(null?l) '() (append(f(carl))(concmapf(cdrl))))) \n Figure2:Queens'sallocations Figure3:CONCMAPprofling Thisfunctiondoesnotdirectlycallanyallocator,butobvi\u00adouslythefunctionsitcalls(itscallees,notablyAPPEND)call \nCONS.Figure3presentstheprofleinformationcomputedby Kprof.TheDirectallocssectionisempty,asexpected. ButwediscoverthattheCONCMAPcalleesareresponsible \nfor99%ofthecallstoCONS(Indirectallocs,%called column).Thesecallsaccountfor90.3%oftheoverallallo-cationsinvokedfromCONCMAP(Indirectallocs,%allocs \ncolumn). Kprofcandisplaythedynamicpathsthatexistfromone functiontoanother,forinstance,thepathsthatgofrom \nCONCMAPtoCONSaspresentedinFigure4.Eachedgelabel standsforthepercentageofthecallercallsdevotedtothat callee.Forinstance,20%ofthecallsmadebyTESTCOLare \ncallstoFILTERand8.47%ofFILTERcallsarecallstoCONS. 3.3 Memory pro.ling Kprofcanthendisplaytheheapconfgurationsrecorded \nbyeachgarbagecollectionduringprogramexecution,asin Figure5.Here,executiontimeismeasuredinGCs.We learnthateighteenGCswererequiredtoexecuteQueens. \n Figure4:CONCMAPcallstoCONS ForeachGC,welearntheheapsize(thatvariesherefrom 1.05MBto1.20MB).Kprofalsodisplaysthestacksize(the \nmaximumisreachedonGC9withabout0.25MB).The otherlowcurverepresentsthenumberofliveobjectsaf\u00adtereachcollection.Thatonegoesfromabout0.13MBto \nabout0.30MBwithamaximumreachedatGC6withabout 0.30MBofliveobjects.Thefourthcurvetakesintoaccount thenumberofobjectsthathavebeenallocatedsincethe \npreviousGC(about1.0MBofallocationstoGC12). Duringthestudyofsuchaprofleitmaybeconvenienttofo\u00adcusonsomespecifcpartsoftheprogram.Forinstance,our \nQueensexampleincludestwodiferentimplementationsof thesamestrategy.Itcouldbeinterestingtocomparethese \ndiferentimplementationsataglance.Thisispermittedby ourSchemeextension:theprofileform.Itssyntaxis: (profileprofile<label><s-expr>) \nItsevaluationisequivalentto(begins-expr)butitwill forceKproftoreportdataforapseudo-functionnamed lbl,withallcostsassociatedwiththeevaluationofs-expr \nreportedaspartoftheexecutionoflbl.Itwillthusbepos\u00adsibletodeterminethenumberofallocationsexecutedduring \ntheevaluationofs-expr.Inaddition,theevaluationperiod forlblisdisplayedonKprofSsmemoryprofle.Figure5 includestheresultofseveralprofileforms,labelledSOL1, \nSOL2,andPOS-L,indicatedimmediatelyabovethememory usagegraph. 3.4 Kprof implementation Bigloo,ourSchemecompiler,translatesfromSchemetoC. \nThegeneratedCcodeconformstothestandardCcoding style[3].Inshort,SchemefunctionsarecompiledintoC functionsandSchemevariablesarecompiledintoCvari\u00adables.Becauseadirectcorrespondenceexistsbetweenthe \nproducedCcodeandtheinitialSchemesourcefle,itispos\u00adsibletoreusestandardCtoolstoprofleSchemesourcepro\u00ad \n Figure5:Queens'smemoryconfgurations grams.Kprofisdesignedasalayersurroundingthestan\u00addardUnixGproftool[6,5].Thistechniqueisdescribedin \naforthcomingpaper[18].KprofdecodesGprofinforma\u00adtion(inparticular,KprofdemanglesGprofsymbols)and usestheresulttocomputeallocationprofles. \n3.4.1 Inherited features SinceKprofisafront-endtoGprofitinheritssomeofits facilitiesand,alas,someofitsinaccuracies.Thesearede\u00adscribedinsomedetailsintheGNU-gprofdocumentation[5]. \nWeshortlysummarizetheminthissection. Run-timefguresarebasedonasamplingprocess.To determinethetimespentineachfunctionGprofsam\u00adplesthehardwareprogramcounteratregularintervals \n(e.g.,every0.01seconds).Theentiretimeintervalis chargedtothecorrespondingfunction.Toproducere\u00adliableexecutiontimeestimates,theoverallexecution \ntimeoftheapplicationmustbemuchlargerthanthe samplingperiod.  Thenumberofcallsareexact.Theyarecomputedby \ninsertinganadditionalcalltoanaccountingfunction intothepreludeofeveryprofledfunction.Thisfunc\u00adtionisresponsibleforrecordinginanin-memorycall \ngraphtablebothitsparentroutineanditsparent's parent.  Calleesruntimespresentedinthecallgraphreports \nareprobabilistic.Therecordmadeofanexecution doesnotcontainanyinformationrelativetothedy\u00adnamiccallgraph.HereisanexcerptoftheGprof \ndocumentationdescribingthetechnique:  \\Theassumptionmadeisthattheaveragetimespentin eachcalltoanyfunctionfooisnotcorrelatedwithwho \ncalledfoo.Iffooused5secondsinall,and2/5ofthe callstofoocamefrom,thenfoocontributes2secondsto a ascalleestime,byassumption. \n Thisassumptionisusuallytrueenough,butforsomepro\u00adgramsitisfarfromtrue.Supposethatfooreturnsvery quicklywhenitsargumentiszero;supposethataalways \npasseszeroasanargument,whileothercallersoffoopass otherarguments.Inthisprogram,allthetimespentinfoo isinthecallsfromcallersotherthana.ButGprofhasno \nwayofknowingthis;itwillblindlyandincorrectlycharge 2secondsoftimeinfootothechildrenofa.\" 3.4.2 Allocation \nestimates Kprofreportsonthenumberofdirectandindirectcalls toallocators.Thedirectcallsarerestrictedtothosemade \nbythefunctionsthemselves.Theindirectcallsarethecalls madebythefunctionsthemselvesandtheircallees.The \ndirectcallsareexactvaluesbuttheindirectonesareesti\u00admated. Theassumptionmadetocomputeindirectallocationsissim\u00adilartotheoneusedtocomputecalleesruntimes.Theindi\u00adrectallocationsofafunctionFarethedirectallocationsof \nthatfunctionplusapercentageoftheallocationsperformed byitscallees.ForeachcalleeC,thispercentageiscalcu\u00adlatedbydividingthetimespentinCwhencalledbyFby \ntheoveralltimespentinC.Forinstance,letussupposethat afunctionF1callsanallocatorA1ntimesandalsocallsa \nfunctionF2.F2callstheallocatorA1mtimesandnoother functions.Nowletussupposethat30%oftheruntimeof F2isspentwhenitisinvokedbyF1.Kprofreportsthat \nthenumberofindirectcallstoA1fromF1isn+0:3xm. ThealgorithmispartiallyvalidatedbythefactthatKprof correctlyreportsthattheentrypointofaSchemeprogram \nindirectlycalls100%oftheallocators(awhiskerawaybe\u00adcauseoffoatingpointerrors).However,aswewillseein Section5.2theseestimatesmaybeimprecise.Nevertheless, \nsincetheyarefasttocompute,theycanbeusedasafrst indicationthatthoroughinvestigationisneeded.Inmany caseseventheseestimatesmayunveilobviouslywrongbe\u00adhaviors.WewillshowinSection5.1.1thattheestimates \nhavepermitteddrasticreductionsinthememoryconsump\u00adtionoftheBigloocompileritself.  3.5 Kprof and code \ngeneration To\\record\"anexecution,thesourcecodehastobecompiled in\\profle\"mode.Thatis,thecompilerhastointroduce \nsomeextrainstructionsforproducingprofleoutputfleused byKprof.Inthissectionwedescribethatcode. 3.5.1 Pro.ling \nand optimizations Optimizationsthatchangetheinitialstructureofthesource codehavetobedisabledinordertomakeprofleinformation \naccurate.Inliningisoneoftheseoptimizations,sinceitre\u00adplacesfunctioncallswiththebodiesofthecalledfunctions. \nSincefunctionsarethesmallestentitiestheproflerreports on,itisimportantthatuserfunctionsarenotinlinedwhen \ninproflemode.Howeverithasbeendemonstratedthatin\u00adliningisanimportantoptimization,especiallyforfunctional \nlanguages[9].Wearethusfacingadilemma:shouldthepro\u00adflecompilationmodeenableaggressiveoptimizationssuch \nasinliningevenifthisreducestheaccuracyoftheproflerre\u00adports,orshoulditdisableoptimizations?Oneshouldnotice \nthatthesecondsolutionalsoefectivelyreducestheaccu\u00adracyoftheprofler,sincethemeasuredprogramislikelyto \nbehavediferentlyfromthefnalversion. Wedon'tthinkthereisa\\best\"solutionforthisproblem, andinsteadweprovidetheuserwithtwodiferentprofling \nmodes.Oneenablesaggressiveoptimizations,thesecond disablesallofthem.Figure1presentstheproflewithopti\u00admizationsenabled.Notethatinthecurrentversion,Bigloo \nneverinlinesCONSsincethecodeduplicationintroducesby thisinlininghasnotshownanyexecutionspeedup. 3.5.2 \nPro.ling with local functions and macros Asinmostfunctionallanguages,Schemehaslocal,possibly anonymous,functions.Kprofreportsontheseasitdoes \nonglobalfunctions.Becauseseverallocalfunctionsmay havethesamenameandresideinsidethesamemodule,the proflerprefxestheirnamewiththenameoftheenclosing \nfunction. Foranonymousfunctions,thecompilergeneratesaname fromthesourceflelocation.Forinstance,letussuppose \nanexcerptofafleF.scm: 150:(define(foo definex) 151:...(map(lambda(y)(+xy))...)...) lambda Thefunctionofline151willbenamedF.scm:151:7347, \nwhere7347isastampthatavoidsnamecollision.When theuserinvokestheeditoronthatfunction,theprofler invokestheeditoronthecorrectfle. \nMacronamesarenotusedintheexpandedcodesomacros arenotpresentinKprofSsoutput.Thatis,theexpanded codeistakenintoaccountbutnameofthemacrosaredis\u00adcardedduringcompilation. \n 3.6 Kprof limitations Allocationproflesarenotsufcienttotrackdownmemory leaks.Forinstance,inFigure1the\\liveobjects\"curve \nseemstorevealanincreaseofliveobjectsinthesol1stage. Whensol1completestherearestillsomeliveobjectsand \nthediferencebetweenthenumberofliveobjectsatthebe\u00adginningandattheendofsol1ispositive.Kprofprovides noinformationastowhetherthisincreaseisnormalorifit \nisduetoamemoryleak.Itreportsonallocationswhereas memoryleaksconcerndeallocations.Toaddressthisprob\u00adlem,wehavedesignedandimplementedasecondtoolnamed \nKbdb.  4. KBDB: A HEAP INSPECTOR FOR SCHEME PROGRAMS Kbdbisaninteractiveheapinspector.Itdisplaysthelive \nobjectsandthechainsofpointersthatlinktheseobjectsin theheap.KbdbisembeddedintoourregularSchemede\u00adbugger.Eachtimeanexecutionissuspended(forinstance, \nwhenabreakpointisreached)theheapmaybeinspected. WhenKprofrevealsasuspectincreaseofliveobjectsKbdb Figure6:Anheapviewaccordingtoobjecttypes \ncanbeusedtodiscoverifthisisduetoamemoryleak.Obvi\u00adouslythisrequiresthoroughknowledgeofthesourcecode. Tosuspectthatacomputationleaksmemory,itmustbe \nknownthatthiscomputationshouldnotincreasethenum\u00adberofliveobjects.Kbdbcanonlyanswerthequestion \\whatistheamountofmemorystillinuseafterevaluating \nthatparticularexpressionofthesourcecode?\". 4.1 Plain heap inspection Tostartwith,KbdbactsasaregularSchemedebugger.It \nenablessuspensionandresumptionofexecution.Whenan executionissuspendedthevariablesandthestackofthe computationmaybeinspected.Inadditiontothesetradi\u00adtionalfeatures,Kbdbcanalsodisplayasnapshotoftheheap \nasa2dimensionalpictureinwhicheachpixelisassociated withamemorylocation.Unusedmemorylocationsareleft blank.Objectsaredistinguishedbytheircolor.Currently \ntwocolorschemeshavebeenimplemented.Inthefrst,ob\u00adjectsarecoloredaccordingtotheirtype.Forinstance,all stringsaredisplayedinblue,thepairsinred,andsoon.The \nsecondclassifcationusestheageoftheobjectstodetermine theircolor.Figure6isasnapshotofKbdbdisplayingaheap \nduringtheexecutionofthequeensprogram,withobjects classifedbytypes. Objectsarerepresentedbyhorizontalstripesendedwitha \nwhitepixel.Thelargeranobjectis,thelongerisitsassoci\u00adatedstripe.Sectionsoftheheapcanbemagnifedtomake selectionofspecifcobjectsaccurate.Detailedinformation \naboutaclickedobjectisthenreported.Forinstance,click\u00adingonaPAIRstripecoulddisplay: Holder :FILTER,frame4(localL)::Thevalueholder \ntype :PAIR(0) ::Theobjecttype Producer:CONCMAP ::Theproducer Age :1 ::TheGCbirthdate Size :12 ::Thebytesize \n[PAIR] (1) ::Theholderchainlinks [PAIR] (2) (bdb:MAIN)display(0) $63_(8) (bdb:MAIN)display(2) $63_(678) \nThePAIRwehaveclickedonhasbeenallocatedinthefunc\u00adtionFILTERbeforethesixthcollectionanditssizeis12 bytes.Theproduceristhe\\frst\"userfunctionthatcalls \ntheallocator.Thatis,librarydefnedfunctionsarenotre\u00adportedasproducers.Forinstance,theproducerofthepairs \nallocatedbyAPPENDintheCONCMAPfunctionofSection3.2 willbereportedasallocatedbyCONCMAP,notAPPEND.The PAIRwasheldbythelocalvariableLofthefunctionFILTER. \nAn\\holder\"iseitheraglobalvariable,alocalvariable,or simplyastackframe(whenthevalueisnotstoredinany localvariablebutsimplypassedtoanotherfunction).In \ntheremainderofthepaper,wewillindistinguishlynamean holder,aGCroot.ThestackframeoftheFILTERinvoca\u00adtionthatholdsListhefourthoneinthestack(frame4). \nTheholderchainlinksrepresentthepointerschainfromthe holder(i.e.,FILTER'sLlocalvariable)totheinspectedob\u00adject(hereaPAIR).Thelabelsoftheholderchainlinkscan \nbeusedtoexploreordisplaytheobjectsofthatchain. 4.2 Memory leaks Providedwithaheapinspector,memoryleakdetectionis \neasy.Theframeworkforfndingleaksinasuspectexpression Eisthefollowing: 1.StoptheexecutionbeforetheevaluationofE.Thenumber \nofalreadycompletedcollectionsisGCn. 2.Triggeragarbagecollection. 3.Resumetheexecution. 4.StoptheexecutionwhenevaluationofEiscompleted. \n5.Triggeranewgarbagecollection. ThecurrentcollectionnumberisnowGCm.Leakingobjects arethosethathavebeenallocatedduringtheevaluationof \nEthatarestilllive,i.e.liveobjectsthathavebeenallocated afterGCnandbeforeGCm. TofndamemoryleakusingthecurrentKbdbinterface, \ntwobreakpointshavetobeset.Onebeforethesuspected expressionandoneafter.Whentheexecutionreachesthe frstbreakpoint,asimpleclickontheleaksicontriggers \nthepreviouslydescribedsteps2to5.Apictureconsisting onlyoftheliveobjectsisthendisplayedasinFigure7.In \nthissnapshotoftheheaponlythe\\leaking\"objects,i.e. newlyallocatedandstillliveobjects,aredisplayed.The \nrootscausingtheleaksaredisplayedinadiferentcolorthan theleakingobjects.AsreportedontheleftsideofFigure7, \ntheentireleaksizeisof8480bytesinthiscase.Leaking objectsmaybeselectedasbefore.Clickingononeofthese objectscouldproduce: \nHolder :COUNT Type :PAIR (0) Producer:NSOLN Age :2 Size :12 [PAIR] (1) [CELL] (2) [PROCEDURE](3) Thisobjectcanbedisplayed: \n(bdb:MAIN)display(0) (2345678) Evenifthisisnotobviousinthegrayscaledisplay,thereis onlyoneGCrootthatisculpritfortheentireleak.That \nrootistheendoftherootchainoftheobjectwehavese\u00adlected.Itcanalsobeselected: Figure7:Memoryleaksunveiled \n(bdb:MAIN)explore(5) Holder :COUNT Type :PROCEDURE (0) Producer:COUNT Age :2 Size :20 Wecannowdrawsomeconclusionsfromthisinspectionof \ntheQueensprogram:i)Aswesuspected,theevaluationof theSOL1formleaksmemory.ii)Thatleakiscomposedof smalllists(theentireleaksizeis8.3KB).iii)Alllistsare \naccessiblefromthesameroot.iv)Therootistheanonymous closure(aPROCEDUREtype)thathasbeenallocatedinthe COUNTfunction. \nActually,theCOUNTfunctionisamemofunction.Itallo\u00adcateslistsandstorestheminatablethatisneverreset.In Section3wesuspectedamemoryleak.Kbdbhasdemon\u00adstratedthatthisleakreallyexists. \n 4.3 Kbdb implementation WemodifedtheBoehm-Demers-Weisergarbagecollector toprovideback-pointerinformation,aspartofthedebug \ninformationthatcouldalreadybeassociatedwithindividual objects.Eachallocatedobjectisprovidedwithadditional \nslotstostorethesourcecodelocationoftheallocationand onebackpointerslotthatisflledbythecollectorduringthe \nmarkingprocess. Thecontentsofthebackpointerslotpointtothelocationof thepointerthatcausedtheobjectinquestiontobemarked. \nIftheobjectisreachablebymorethanonepath,theone thathappenedtobefollowedbythecollectorwillbere\u00adfectedintheKbdboutput.Inthe,usuallyinfrequent,cases \nwheretheconservativecollectorfollowsastalestackpointer, oramisidentifedpointer,thatfactwillalsobeaccurately \nrefectedinthechainofbackpointers.Thusevensuchprob\u00adlemsbecomedebuggable. Asdiscussedintherelatedworksection,thereareother \nwaystodisplaybackwardreferencechains.Thistechnique isthesecondonewehaveimplemented,andbyfarthesim\u00adplest.ItwassuggestedbyAlanDemers. \nDetailsofthecollectorbacktracinginterfacecanbefound inthecollectordistribution.Inthissection,wefocusonthe \nimplementationoftheheappictureconstructionandthe Kbdbarchitecture. 4.3.1 The debugged applications Debuggableapplicationsembedspeciallibraryfunctionsthat \nareinchargeofconstructingtheheapdisplay.WhenKbdb istodisplayaheap,itrequeststhatthedebuggedappli\u00adcationproducesafleondiskcontainingthepicture.The \npicturefleisconstructedwithoutadditionalmemorycon\u00adsumptionbymeansofsimplelinearscansoftheheap.The garbagecollectorisabletoreport,foreachaddressofthe \nheap,ifitispartofaliveobject,andtoretrievethesizeof thatobject.Thealgorithmtobuildaheappictureis: 1:make-picture(F)= \n2:letmin-addr=Theheapminaddress 3:max-addr=Theheapmaxaddress 4:i=0 5:pic=create-picture() 6:whilei+min-addr<max-addrdo \n7:ifi+min-addristheaddressofaliveobject? 8:thenletsize=GC-object-size(i+min-addr) 9:stop=size+i 10:type=SCM-type(i+min-addr) \n11:whilei<stopdo 12:set-pixel-color(pic,i,F(type)) 13:i=i+1 14:elseset-pixel-color(pic,i,\"white\") 15:i=i+1 \n16:returnpic TheargumentFisaparameterofthepictureconstruction. ItisafunctionthatmapsSchemeobjectstocolors.Iten\u00adablesvariouscoloringschemestobeappliedtotheheap \nconstruction(suchasthetypebasedortheagebasedones). Thekeypointofthisalgorithmisthatapicturefleisdi\u00adrectlydumpedduringaheaptraversal.Thereisnoneedto \nallocateamemoryareaofthesizeoftheinspectedheapbe\u00adcauseofthedirectmappingfromheapaddressestopicture pixels.Thisispossibleonlyifthegarbagecollectorisable \ntoreportinformationaboutrandomaddressesintheheap. Itisnotclearhowexactcollectorscouldimplementthis. Filegenerationisstraightforward.Leakdetectionandage\u00adbasedcoloringdonotrequirepre-computation.Ontheother \nhand,associationbetweentypesandcolorrequiresanad\u00additionalfrstlineartraversaloftheheapinordertoallo\u00adcatecolorstothemostfrequentlyusedtypes(onlythose \nareallocatedspecifccolors,infrequenttypesarealldis-playedwithoneuniquecolor).Then,duringasecondlinear \ntraversal,thepictureisbuiltaccordingtothemake-picture algorithm. 4.3.2 Kbdb display generation Whenadebuggedapplicationhasgeneratedapicturefle, \nKbdbreadsthatfle.Notethatapicturefleisoftenmuch smallerthantheinspectedheapbecauseonepixelrepre\u00adsentsamemoryword(i.e.,4or8bytes).Foramonochrome \npicture,8pixelscanbestoredinasinglebyte,makinga monochromepictureabout32timessmallerthanthein\u00adspectedheap.Afourcolorpictureis16timessmallerthan \ntheheap.Fourcolorsaresufcientformemoryleakdisplays. Wehaveconcentratedonthecompactnessoftheheaprep\u00adresentation.Wethinkthisisacentralissue.Iftherepre\u00adsentationrequirestoomuchmemory,thesystemcannotbe \nusedtoinspectlargeheaps.Wehavesuccessfullyapplied KbdbtoourSchemecompiler,demonstratingthatitcan beusedonheapslargerthan8MB. \n  5. APPLYING KPROF AND KBDB Thissectionpresentstheresultsofourfrstattempttoapply KprofandKbdbtoarealapplication:ourSchemecom\u00adpiler.TheaimofthissectionistoshowthatKprofand \nKbdbareusefulinpractice.Forthisexperimentwehave lookedatbootstrappingthecompiler,thatis,compilinga partofthecompilerwithaninstrumentedversionofthe \ncompiler.Wehavearbitrarilytimeboundedthatefortby allocatingonlytwodaystoprofling.Thissectionreports onwhatwehavelearnedaboutthecompilerduringthese \ntwodaysandconcludeswithsomemeasurementsthatshow theexecutionoverheadofproflinganddebugging. 5.1 The \nBigloo compiler BigloocompilesSchemeintoC.ItiswritteninSchemeand compiledbyitself.Biglooconsistsof47,000linesofcode. \nItreadstheprogramtobecompiledandbuildsanabstract syntaxtree(henceforthAst)torepresenttheprogram.This \ntreecontainsastructureof23diferentnodetypes.There arenodesforconstants,variableassignments,conditionals, \nfunctioncalls,etc.Thecompilerismadeupofstages,each ofwhichcanbeseenasaprocessthatmodifestheAst. ThedriverisaSchemefunctionthatlookslike: \n(definedefine(compilersrc) (lleett((ast(build-astsrc))) 1st (macro-expand!ast) ;;stage 2nd (function-inline!ast) \n;;stag e ... (code-generate!ast))) ;;20thstage Thisrigidstructure,inwhicheachstageactsasastand aloneprogram,helpstheimplementationandmaintenance \nofthecompiler.Italsohelpswithproflingthecompiler. BecauseofthatstructureitiseasytoletKprofreporton allocationsstagebystage.Itonlyrequiresinstrumenting \nthecompilerdriverwithprofleformssuchas (profileast(build-astsrc)). 5.1.1 Reducing compiler memory allocation \nFigure8presentstheheapprofleasreportedbyKprof whenbootstrappingamoduleofthecompiler.Theflecho\u00adsenforthatexperimentistheonethatcompilesintothe \nlargestCfle.Thatflecontainsmostoftheclassesrepre\u00adsentingBigloo'sAst.InBigloo'sobjectsystem,classin\u00adstanceslotsarefetchedandchangedviagetterandsetter \nfunctions.Thesefunctionsareautomaticallygeneratedby thecompiler.Themodulewearestudyingproducesalarge \nCflebecauseitcontainsmostofthegettersandsettersof theAst. Theoverallallocationforcompilingthatmoduleis17.3MB \namongstwhich,56%areCONSes.Thiswasasurprisetous. TheAstofthecompilerisrepresentedbyaclasshierarchy andwethoughtwehavesuccessfullyavoidedCONSinginthe \ncodeofthecompiler.Actually,variablesizedatastructures areimplementedusingCONSes.Forinstance,thelistoffor\u00admalparametersofafunctionisrepresentedbyaSchemelist, \n Figure8:ProflingBigloo andsequencesofexpressionsarealsostoredinlists(thatis thesequencenodeoftheAstholdsseveralvalues,oneof \nwhichisalistofexpressions).Kprofshowsthattheselists aremuchmorenumerousthanwesuspected.Itispossible toreduceallocationforsuchlists.Itwould,forinstancebe \npossibletousevectorsinstead.Thiswouldreducememory requirementssincevectorsaremorecompactthanlists(at \nleastwhentheycontainmorethantwoelements). Kprofpointsoutseveralothersurprisingallocations.We focushereonthemostsignifcantones.Thelastcompiler \nstage(namelyCGEN)writestheCcodeonadiskfle.This stageonlydumpstheAst.Itisnotsupposedtoallocate memory.However,KprofdemonstratesthatCGENactually \ndoesallocate!InspectingCGENallocationsusingtheallo\u00adcatorproflershowsthatCGENisresponsibleformorethan \n13%ofthecallstoCONS.Studyingthedynamicpathsthat gofromCGENtoCONSshowsthatnearlyalltheCONSesallo\u00adcatedduringtheevaluationofCGENarecalledbyfunctions \nthatwriteonthedisk.Thatis,theCONSesareallocated whenthecompilerusesthestandardSchemeoutputfunc\u00adtions(DISPLAY,NEWLINE,...).TheseCONSesareallocated \nbecause,asreportedinSection1.2,variablearityfunctions allocate,andstandardSchemeoutputfunctionsacceptan \noptionaloutputport.Inordertoremovetheseallocations, wehaveimplementedasimplesource-to-sourcetransforma\u00adtion.WhenacalltoaregularSchemeoutputfunctionis \ndetected,itisreplacedwithacalltoaspecializedfunction acceptingoneortwoarguments,dependingonthenature \nofthecall.Wedon'tclaimthatthisoptimizationis\\gen\u00aderalpurpose\",weonlyclaimthatwithaone-hourefort,we havebeenabletoreducethememoryallocationto14.3MB, \nwhichisareductionof21%.TheproportionofCONSesfor thecompilationofthecompilerdroppedto47%.  5.1.2 Chasing \nbootstrap memory leaks Somestagesofthecompilerareexpectedtoincreasethelive memory(suchastheASTstagethatconstructstheAst,or \nINLthatimplementsinliningoptimization).Ontheother hand,somestagesimplementoptimizationsoranalysesthat \nshouldreducethesizeoftheAst.Amongstthesestagesis EFF(GC10toGC11)whichisapassthatcomputesthe sideefectpropertyforeachfunctionoftheAst.Theresults \nofEFFarelaterusedtoimplementregularoptimizations suchasdataoptimizations(REDstage).SurprisinglyKprof \nreportsthatEFFslightlyincreasesthenumberofliveobjects (2.45MBto2.55MB).WeusedKbdbtoinspectmemory leaksoftheEFFstage.KbdbreportedthatEFFisresponsible \nfor210KBofleaksduetoonlytwoGCroots.Oneislocated inafunctioncalledMAKE-SIDE-EFFECT!andtheotherin afunctioncalledFUN-CALL-GRAPH!.Inspectingthesource \ncodeofthesefunctionshasrevealedthenatureofthetwo leaks:bothfunctionsuseatablethatisnotresetwhenEFF iscompleted. \n 5.2 Impact of pro.ling and debugging Theperformancediferenceofprogramscompiledinpro\u00adflemode,debugmodeoroptimizationmodeshouldbeas \nsmallaspossible.Ifthediferenceisverynoticeable,the proflerordebuggerwouldbetedioustouse.Evenmore seriously,iftheperformancedegradationistoosubstantial, \nlargeprogramscansimplynotbeprofledordebugged.In thissectionwepresentsometimeandallocationmeasure\u00admentsforthediferentversions.Wehaveusedthreedif\u00adferentprograms:asmallone(Queens,a100lineslong \nprogramwepreviouslydiscussed),amid-sizeone(Evalthe 500lineslongBiglooSchemeinterpreter),andalargeone \n(Bootstrap,the46,000lineslongSchemecompileritself). Figure9comparesthecompilationtime,executiontimeand \ntheheapsizeofthesethreeprogramsusingdiferentcompi\u00adlationfags,allotherthingsbeingequal. Compisthecompilationtime,Sizethesizeofthebinaryfle. \nInordertopresenttheimpactofprofledcompilationonthe executablesize,wehavedecidednottostrip(thatisnotto \nremovethesymbolstable)thebinaryflesinoptimization mode.However,oneshouldbeawarethatonourworking architecturestrippinganexecutableshrinksitbyabouta \n Queens Eval Bootstrap Comp.modes Comp. Size Run Alloc Comp. Size Run Alloc Comp. Size Run Alloc Optimized \n2.3s 185k 1.3s 15.5MB 3.6s 167k 1.8s 7M B 6.6s. 898k 5.3s. 9.3M B . Profled 2.2s 494k 5.5s 15.5MB 3.41s \n500k 6.11s 7M B 4.1s. 4643k 8.2s. 9.3M B . Debugged 3.4s 620k 11.7s 55.2MB 7.4s 209k 6.8s 34.7MB 5.8s. \n15929k 15.6s. 38.4M B . Figure9:Impactoftheproflinganddebuggingcompilations.Hardwareconfguration:K6/200,Linux2.0.x,64MB. \nThecompilationtime,runtimeandallocationsizefguresforthecompilerBootstrap(.)havebeengatheredwhen compilingonlyonemoduleofthesourcecodeofthecompiler. \nfactorofthree.Inaddition,allbinariesarelinkedagainst staticBigloolibraries.(Thereisnoissueherebecauseall \nmodessupportsharedlibraries.)Runistheexecutiontime (theminimumofuserplussystemtimeforthreeconsecutive \nruns).Allocistheamountofmemoryallocatedduringthe execution. Thediferencesinsizeoftheexecutablesareimportant.Pro\u00adfledexecutablesareaboutfourtimeslarger.Debuggableex\u00adecutablesareupto10timesbigger(forBootstrap).There \nisnowaytoavoidthisincreasebecauseitdoesnotdepend ontheBiglooCgeneratedcodebutontheassemblycode generatedbytheCcompiler.Forinstance,app.scmisone \nofthecompilersourcefles.ThegeneratedCfleapp.cis 56KBlong.WhencompiledwithCoptimizationenabled, theobjectfleapp.ois10KBinsizeWhencompiledinC \ndebugmode,itenlargesto51KB! Debuggedandprofledprogramsrunslowerthanoptimized programs.Independentofinstrumentation,disablingopti\u00admizationslowsdownprogramsbyaratioof1.5to2.For \nsmallprograms,thediferenceinperformanceforinstru\u00admentedprogramsisimportant(afactorof9forQueens). Experienceseemstoshowthatthelargertheprogramsare, \nthesmallerarethegapsbetweenoptimizedandinstrumented applications:Afactor3.8forEvalandafactor2.9for Bootstrap. \nAswehavepreviouslystated,Kprofdoesnotincrease memoryconsumption.IncontrastKbdbdoes!Theallo\u00ad cationgrowthfactorsare:Evaland4.1forBootstraheadintroducedbyKbdbcurrentimplementationofthoverheadforeachallocatedpointer,1forproducerinform \n3.6timesforQueens,4.9for p.Thatis,thememoryover\u00adcannotbeneglected.Forour ecurrentruntimesystem,the cellisof4words:1foraback \nation,1forage,andoneother wordsusedinternallybythecollector,primarilytosupport Cdebugging.These4additionalwordsexplainwhythe \nallocationsizegrowssomuch.Withoutdebugginginforma\u00adtion,aBiglooCONSistwowords.Thatis,theruntimetype informationisstoredinthepointertothepair(i.e.,there \nisnoheaderwordforpairs).Thistechniqueisnolonger availableindebugmodebecauseallobjectsmusthavethe verysamedatalayout.Asaconsequence,indebugmode,a \npairis7wordslarge.Becauseofhardwarealignmentcon\u00adstraintsthisturnedto8words,thatis,4timeslarger.As reportedbyKprofCONSallocationsaredominant,itisthus \nnotsurprisingthattheoverallheapusageincreasesbyabout afactorof4.  5.3 Pro.ling validation KprofisimplementedontopofGprof.Thatis,Kprof \nre-targetstheGprofCsamplingtechniqueforScheme.Itis usuallyacceptedthattheaccuracyoftheCapproximations \ndeliveredbyGprofissufcient.However,itisconceivable that,duetodiferencesinprogrammingstyle,theGprof techniqueappliedtoSchemedeliversinaccurateresults.For \ninstance,ifSchemeprogramsmakeuseofnumeroussmaller functions,highersamplingratescouldbeneededthanforC. \nInordertoshowthatitappliesequallywelltoCandScheme wehaveconductedanotherexperiment.Wehavemeasured thenumberofcallspersecondforoptimizedSchemeand \nCprograms.Thenumberofcallshavebeengatheredus\u00adingexactGproffunctioncallcounting.Weusethethree SchemeprogramsfromSection5.2.Itisextremelydifcult \ntocompareSchemeandCprograms,especiallybecauseitis nearlyimpossibletoestablishasetofrepresentativebench\u00admarkprograms.Asmuchaspossiblewehavetriedtouse \nCprogramsthatperformthesamekindofcomputationas ourSchemeprograms.Thefrstone,Amdisatestreleased byAMD,whichusesittoestimatethespeedofitsproces\u00adsors.Thesecond,LiisaLispinterpreterimplementedin \nC, w h ic h is par t of t h e S p e c 9 5 b e n c hmar k s u it . The last one, Gcc is the special version \nof the GNU-C compile r t h at is also included in the Spec 95 suite. Prgm Functioncallpersecon d Amd(c) \n2,787,920cs -1 Queens(scm) 3,524,345cs -1 Spec95Li(c) 5,280,070cs -1 Eval(scm) 1,581,905cs -1 Spec95Gcc \n(c) 1,445,991cs -1 Bootstrap(scm) 1,453,832cs -1 Thesetimefguresshowthatthefunctioncallfrequencyis similarforSchemeandC.Inparticular,thefrequencyisas\u00adtonishinglycloseforBootstrapandGcc,bothofwhichare \ncompilers.Consequently,theexecutiontimespentineach Schemefunctionisproportionallyclosetothetimespentin \neachCfunction.Thus,thereisnoapriorireasontobelieve thatSchemerequiresdiferentsamplingtechniquesthanC. \nThesecondstepofourvalidationwasmeasurementofthe accuracyofKprof'sallocationprofler.Forthis,wehave builtaspecialversionoftheBiglooruntimesystemthatre\u00adportsexactlyonheapallocationperformedbyeachfunction. \nInthatversion,eachtimeanallocatoraiscalled,everyac\u00adtivefunctionontheexecutionstackismarkedascallinga. \nWhenexecutioncompletes,allthisinformationisdumped intoafle.Thisexperimentalruntimesystemisunrealistic \nbecauseitisfartooslow.Withthisversion,executionof theBootstrapbenchmarkrequiresabout8hoursonour hardwareconfguration.However,thisslowimplementation \nisstillsufcientforestimatingtheaccuracyoftheindirect allocationsreportedbyKprof. Forthesmallandmediumsizedprogramswehavetested \n(includingQueensandEval),Kprofallocationproflingis veryprecise.Weobservedthatfunctionallocationestimates \ncomputedbythealgorithmpresentedinSection3.4.2have anerrorrateoflessthan5%. Forlargerprograms,theaccuracyoftheestimatesvaries.If \nweinspectafunctionfthatindirectlycallsanallocatora, thequalityoftheestimateishighlydependentonthelength \nofthepathfromftoa,thatis,howmanyfunctionscalls areneededtoreachafromf.Forinstance,inFigure4the longestpathfromCONCMAPtoCONSis6,theshortestis2.If \nshortestpathsfromftoacountalot,thatisshortestpaths aremorefrequentlytraversed(inFigure4theshortestpath \nisimportantbecausethevertexfromCONCMAPtoAPPEND-2 represents33.3%ofallthecallsmadebyCONCMAP)then theestimateforfisreliable.Otherwise,itisimprecise.In \nthecompilerbootstrapbenchmarkthepathsarerelatively small,Kprofreportsthatthecontrolfowanalysis(cfa stageonFigure8)allocates1%ofallclosuresand1.2%of \ntheCONScells,whileactuallyitisresponsiblefor1.25%of proceduresand2%oftheCONScells.Ontheotherhand, whenpathsarelongertheestimatesareimprecise.Forthe \nASTconstruction(theastlabelonFigure8),Kprofesti\u00admatesthenumberofCONScellstobe4.5%andthenumber ofprocedurestobe7.1%,whileexactmeasuresreport16% \nofCONScellsand12%ofprocedures.TheerrorsinKprof's estimatesareinherenttothelackofexactinformationabout \nthedynamicpaths.UsingGprof,wedon'tthinkitispos\u00adsibletoproducemorereliableresults.However,inaddition tothecurrentestimates,Kprofcouldreportontheirac\u00adcuracy.Thisnewinformationcouldbecomputedfromthe \nnumberofpathsandtheirlengthfromafunctiontoanal\u00adlocatoranditcouldbepresentedonthesamewindowas theestimates,oritcouldbebasedonacallstacksampling \ntechnique.  6. RELATED WORK KprofisimplementedontopofGprof[6,5].Thus,Kprof inheritsGprof'srun-timeinstrumentationanditscomputa-tionofthedynamiccallgraph.Inthepast,alternativetech\u00adniquestogatherprofleinformationhavebeenproposed[1]; \nhoweverthesetechniquesseemlessaccuratethanGprof's ones. Mprof[20]isanallocationprofler.Itreliesontechniques \nwhicharesimilartothoseofKprofbutwithadiferent implementation.Insteadofre-usingGprofresults,mprof implementsitsownmonitoringandtextualdisplayer.In\u00adstrumentedapplicationsrecordallthecallchainsthatlead \ntoallocationsites.Inordertoavoidoverlylargerecordfles, mprofcompactsitsrecordswithatechniqueslightlymore \naccuratethantheGprof'sone. TheHaskellcommunityhasbeenfairlyactiveatexploring heapproflingforlazyfunctionallanguages.Someofthis \nworkconcentratesonstudyingthegraphicalmeanstodis\u00adplayproflinginformation[14].Otherresearchconcentrates \nonprovidingasemanticstotheevaluationoflazylanguages withprofling[17].Yetotherworkfocusesonissuescloseto \nmemoryleakdetection[13,12]. ThegraphicaldisplayadvocatedinanearlypaperbyRunci-manandWakeling[14]isusedinallotherHaskellstudies. \nThisrepresentationistotallydiferentfromtheoneweuse. Itdisplays,overthewholeexecutionofaprogram,theheap \ncomposition.Thatis,theheapsizeandthepercentageof pairs,strings,vectors,etc.Itcouldbethatsuchanice representationenablesfasterunderstandingofthememory \nallocationsofaprogram,inparticularwhenitisusedto displayaproducerview.Aproducerisafunctionthatcalls someallocators.Thisviewdefnitivelyhelpsinunderstand\u00adingwho'sresponsiblefortheallocationsofaprogramand, \nmoreimportantly,howlongtheobjectslive.Wethinkthis representationcouldpointoutmemoryleaks.However,we don'tthinkithelpsmuchwithfxingtheseleaks.Tofxa \nleak,onehastounderstandwhyobjectsfailtobereclaimed, whichisnotreportedbyheapprofling. AmorerecentpaperbyRojem \noandRunciman[11]presents astudythatcouldhelpinunderstandingmemoryleaks. Theypresenttheso-calledlag,drag,voidandusephases. \nTheycharacterizewastedspaceasthatoccupiedbyobjects thathavepassedtheirlastuse,orhavebeenallocatedbut \narenotyetinuse.Theypresenttoolstoanalyzethepres\u00adenceofsuchobjects.Executionhastobecompletedbefore anyproflinginformationcanbereported.Thisapproachis \northogonaltotheonepresentedhereandcouldbeusefully combinedwithit. ProfileformsareclosetotheghcHaskellimplementation's \n\\setcostcenter\"construction(sccinshort)[16,15,17]. CostcentersaremorecentraltoHaskellbecausetheyform \nthebasisofproflingforthislazyprogramminglanguage. ToKprof,profileisonlyaconveniencethatenhancesthe presentationofthegeneratedprofles.Inaddition,bothcost \ncenterconstructandprofileformsallowfnegraintuning. Themoretheyareintroduced,themoreoptimizationisin\u00adhibited.Thesetwoformsrequiresourcecodechanges,but \ntheyallowexactcontrolofprofling. KbdbhasbeeninspiredbytheworkofDePauwandSe\u00advitski[4],inwhichtheauthorspresentJinsight,atoolfor \nvisualizingreferencepatternsandtracingmemoryleaksin Javaprograms.JinsightoperatesonaninstrumentedJVM \nthatkeepstrackofbackpointers,linkingalltheliveobjects oftheheap.Toavoiddisplayingindividualobjectsthey \nclassifyobjectsusingtheirtype(theirJavaclass).Bysuc\u00adcessivelyrefnedrequests,itispossibletodeterminewhich \nobjectsareresponsibleformemoryleaks.Kbdbowesmuch toJinsight:thedefnitionofamemoryleakandtheba\u00adsicframeworkforusingitcomesfromthatwork.However, \nKbdbdifersgreatlyinitsrepresentationofobjectsandin itsruntimeoverhead.Jinsightcreatesrecordsdescribingthe \nprofledheap.Theserecordsareverylarge.Threeexamples arepresentedforwhichtherecordsarerespectively32,46 \nand49timeslargerthantheprofledheaps(110Kbheap isrecordedina3.5Mbrecordfle,20Kbina0.9Mbrecord and25Kbina1.2Mb).Evenworse,thememoryneededby \nJinsightismuchlargerthantherecordedfles(inthebetter case,Jinsightuses370timesmorememorythantheheap profled).Tovisualizeour17Mbheap(theheapsizeofthe \nBootstrapofSection5.1.1)wewouldhaverequireda6Gb heap! Averyprimitivepointerbacktracingfacilityforleakde\u00adtectionwasincorporatedintheXeroxPortableCommon \nRuntimebythesecondauthoraround1995.Althoughit requirednoperobjectspaceoverhead,thisreliedonafull searchoftheheaptotracebackonepointerlevelinthe \nreferencechain.Inspiteoftheobviousperformanceissues, itprovedusefulintrackingdownrealproblemsinalarge \nsystem.Howevertheimplementationwastricky,inthatit tendedtosuferfrom\\accidentalrefection\":Itwaseasy tomistreatthelocalvariablesusedbythebacktracingcode \nitselfasroots. 7. FUTURE WORK Aswehavereported,forlargeprogramssuchasBiglooitself, Kprofsuppliesroughestimates.Wearecurrentlyexploring \nanotherstrategyforallocationprofling.Wearedeveloping atechniquethatcomputesexactfgures.Becauseitwillbe \nslowerthanthecurrentoneitwon'treplaceit.Itwillbe anadditionaltoolthatcouldbedeployedwhenthecurrent Kproffails. \nKbdbisaheapvisualizationtool.Itdisplayslivecellsin theheap.Currently,threediferentvisualizationsareim\u00adplemented:atypebasedclassifcation,anagebasedclas\u00adsifcationandaleakdetectionview.Kbdbcouldbeused \ntodisplayinformationa laHaskell.Thatis,wecouldim\u00adplementanewKbdbmodulethatdisplaysproducergraphs suchastheonepresentedin[14].Ourruntimeprovides \nenoughinformationforthis.Inaddition,wethinkitcould beinterestingtoprovidetheuserwithastatisticalinfor\u00admationabouttheheap,suchastheaveragenumberofGCs \nsurvivedbycertainobjects.WethinkaGCisawonderful toolforproflinganddebuggingbecauseaGCkeepstrackof allpointers.SinceaGCisabletoscananentireheap,itcan \nanswerquestionssuchas\\howmanyobjectsarepointingto thatotherobject\".Thiscouldbeusedbythedebuggerto exhibit,onanon-demandbasis,sharingproperties. \n  Conclusion Inthatpaperwehavepresentedtwomemoryproflersfor theSchemeprogramminglanguage.ThefrstoneKprof, \nreportsonallocationsthattakeplaceinprogramexecu\u00adtions.Itactsasaregularprofler.Asamplingexecution isrecordedand,afterwards,allocationproflinginformation \nisreported.Kprofcanpointoutwhichfunctionsconsume memory.Kprofimposesalowruntimeoverheadandin particularitdoesnotenlargememoryconsumptionofpro\u00adfledexecutions.Thesecondtool,Kbdbactsasadebugger. \nProgramsaresteppedand,onaon-demandbasis,heapscan bevisualized.Theheapsarethenrepresentedby2dimen\u00adsionalpicturesinwhicheachlivecellofaheapisrepresented \nbypixels.Zoominginthatpictureenablescellsselection. Kbdbisusedtofxmemoryleaks.Itslowsdownexecutions ofabout10timesanditenlargesheapsizeofabout5times. \nHowever,Kbdbisstillefcientenoughtobepracticalat inspectingthe17MBheapofthebootstrapofourScheme compiler. \n Acknowledgments ManythankstoSimonPeyton-Jones,ErickGallesio,CSeline andtoBrianLynnfortheirhelpfulfeedbacksonthiswork \nandtoAlDemersforhissuggestionabouttheback-pointers implementation. 8. REFERENCES [1]A.Appel,F.Duba,D.MacQueen,andATomach.Profling \ninthePresenceofOptimizationandGarbageCollection. TechnicalReportCS-TR-197-88,PrincetonUniversity, November1988. \n[2]H.J.Boehm.Spaceefcientconservativegarbagecollection. InConferenceonProgrammingLanguageDesignand Implementation,number28,6inSigplanNotices,pages \n197{206,1993. [3]L.Cannon,R.Elliot,L.Kirchof,J.Miller,J.Milner, R.Mitze,E.Schan,N.Whittinton,D.Spencer,H.Keppel, \nandM.Brader.RecommendedCStyleandCoding Standards,June1990. [4]W.DePauwandG.Sevitski.VisualizingReference \nPatternsforSolvingMemoryLeaksinJava.InProceedings ECOOP'99,pages116{134,Lisbon,Portugal,June1999. [5]J.FenlasonandB.Baccala.GNU-gprof:usermanual. \nTechnicalreport,FreeSoftwareFoundation,Inc.,59Temple Place-Suite330,Boston,MA02111-1307,USA,1997. [6]S.Graham,P.Kessler,andMcKusikM.gprof:acallgraph \nexecutionprofler.InCompilerConstruction,SIGPLAN Notices17(4),pages120{126,1982. [7]R.Kelsey,W.Clinger,andJ.Rees.TheRevised5Report \nontheAlgorithmicLanguageScheme.Higher-Orderand SymbolicComputation,11(1),September1998. [8]D.PattersonandJ.Hennessy.ComputerOrganizationand \nDesignThehardware/softwareinterface.Morgan Kaufmann,2ndedition,1998. [9]S.PeytonJonesandS.Marlow.SecretsoftheGlasgow \nHaskellCompilerInliner.InImplementationofDeclarative Languages,Paris,France,September1999. [10]N.Roojemo.GenerationalGarbageCollectionwithout \nTemporarySpaceLeaks.InInt'lWorkshoponMemory Management,1995. [11]N.RoojemoandC.Runciman.Lag,drag,voidanduse{ \nheapproflingandspace-efcientcompilationrevised.In 1fstInt'lConf.onFunctionalProgramming,pages34{41, Philadelphia,Penn,USA,May1996. \n[12]C.RuncimanandN.Rojemoo.Heapproflingforspace efciency.InE.MeijerJ.LaunchburyandT.Sheard, editors,LNCSVol.1129,2ndIntl.SchoolonAdvanced \nFunctionalProgramming,pages159{183,August1996. [13]C.RuncimanandN.Rojemoo.Newdimensionsinheap profling.JournalofFunctionalProgramming,6,1996. \n[14]C.RuncimanandD.Wakeling.Heapproflingoflazy functionalprograms.JournalofFunctionalProgramming, 3(2):217{245,1993. \n[15]P.Sansom.TimeProflingaLazyFunctionalCompiler.In FunctionalProgramming,Glasgow1993,Workshopin Computing,Glasgow,1994.SpringerVerlag. \n[16]P.SansomandS.PeytonJones.ProflingLazyFunctional Programs.InFunctionalProgramming,Glasgow1992, WorkshopinComputing,Glasgow,1993.SpringerVerlag. \n[17]P.SansomandS.PeytonJones.Timeandspaceprofling fornon-strict,higher-orderfunctionallanguages.In22nd \nACMSymposiumonPrinciplesofProgrammingLanguages, SanFrancisco,USA,January1995. [18]M.Serrano.Bee:anIntegratedDevelopmentEnvironment \nfortheSchemeProgrammingLanguage.Journalof FunctionalProgramming,10(2):1{43,May2000. [19]B.Zorn.TheMeasuredCostofConservativeGarbage \nCollection.Software|PracticeandExperience, 23(7):733{756,July1993. [20]B.ZornandP.Hilfnger.AMemoryAllocationProflerfor \nCandLispPrograms.InUsenixconference,pages223{237, 1998. \n\t\t\t", "proc_id": "351240", "abstract": "Memory is the performance bottleneck of modern architectures. Keeping memory consumption as low as possible enables fast and unobtrusive applications. But it is not easy to estimate the memory use of programs implemented in functional languages, due to both the complex translations of some high level constructs, and the use of automatic memory managers.To help understand memory allocation behavior of Scheme programs, we have designed two complementary tools. The first one reports on frequency of allocation, heap configurations and on memory reclamation. The second tracks down memory leaks<sup>1</sup>. We have applied these tools to our Scheme compiler, the largest Scheme program we have been developing. This has allowed us to drastically reduce the amount of memory consumed during its bootstrap process, without requiring much development time.Development tools will be neglected unless they are both conveniently accessible and easy to use. In order to avoid this pitfall, we have carefully designed the user interface of these two tools. Their integration into a real programming environment for Scheme is detailed in the paper.", "authors": [{"name": "Manuel Serrano", "author_profile_id": "81100128092", "affiliation": "Universit&#233; de Nice Sophia-Antipolis, Route des Colles, B.P. 145, F-06903 Sophia-Antipolis, CEDEX", "person_id": "PP39083110", "email_address": "", "orcid_id": ""}, {"name": "Hans-J. Boehm", "author_profile_id": "81423595101", "affiliation": "Hewlett-Packard Company, 1501 Page Mill Road, MS 1U-17, Palo Alto, CA", "person_id": "PP39051269", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351264", "year": "2000", "article_id": "351264", "conference": "ICFP", "title": "Understanding memory allocation of scheme programs", "url": "http://dl.acm.org/citation.cfm?id=351264"}