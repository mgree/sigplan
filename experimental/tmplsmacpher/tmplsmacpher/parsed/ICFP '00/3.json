{"article_publication_date": "09-01-2000", "fulltext": "\n ICFP 00, Montr\u00e9al, Canada. Copyright 2000 A C M 1-58113-202-6/00/0009 $ 5.00. p2Princ (principals) \n72Privs (privileges) x2Var (variables) v::=pAx:ejsecfail (values) e::=vje e jletpriv7inej checkpriv7fore \n(expressions) P::=f71,::: ,7 jg (privilege sets) A::=fp17! P 1,::: ,p k7! P kg (access credentials) S::= \nnil j hp,P i ::S (secstacks) Figure 1: Grammar for Asec be untrusted for some privilege; if such an \nowner is encountered before success, the check fails. See [6] for a concise description of stack inspection \nand how it may be used to enforce security prop\u00aderties. A simpli.ed model of the JDK 1.2 security architecture \nand the stack inspection algorithm is presented below (section 2). The Java security architecture is \na solid proposal which is being applied in practice, but it has signi.cant .aws. There is a perfor\u00admance \npenalty to pay due to the need for run-time stack inspection though a technique called security-passing \nstyle [15] has been pro\u00adposed to lessen the need to literally inspect every stack frame. How\u00adever, even \nthis solution does not address the ad hoc nature of the architecture; all security properties are enforced \nby method calls, a highly non-declarative form of speci.cation. This makes the access control speci.cation \nvery dif.cult to read it is all buried in the code and the implicit control .ow structure of that code. \nSpeci.ca\u00adtions that are dif.cult to read are easy to get wrong, and a security speci.cation is the last \nthing you want to get wrong. This paper begins to explore some solutions to these problems through the \nuse of static type systems. The structure of our presentation is as follows: in Section 2, we formalize \nthe Java Stack Inspection security enforcement mecha\u00adnism within a small functional calculus. In Section \n3, we de.ne our new security type system which statically enforces all the prop\u00aderties of stack inspection, \nand thus obviates the need for run-time stack inspection. In Section 4 we de.ne and prove correct a type \ninference algorithm, meaning that types can replace stack inspec\u00adtion transparently in our functional \ncalculus. In Section 5, some related work is cited and described. We conclude in Section 6, with remarks \non future work. 2. FORMALIZING JAVA STACK INSPEC-TION In this section, we develop simple model of the \nJava JDK 1.2 security architecture, by de.ning a small language containing basic access control features, \nand by formalizing stack inspection for that language. 2.1 The language Asec For our analysis we de.ne \nthe language Asec, a small functional language with constructs for ownership, access credential lists, \nand enabling and checking privileges. The language is a simpli.ed model of the JDK 1.2 security architecture. \nAs the initial security discipline, we de.ne a stack inspection algorithm which is a for\u00admalization of \nJava stack inspection. We then use this formalization to prove soundness properties of our type system. \nAlthough the lan\u00ad guage model is simple, it covers signi.cant ground, and more com\u00adplex features can \nbe added to this core. The addition of records and objects to the language, for example, can be added \nwithout serious additional challenge; the per-function security de.ned here trans\u00adlates to per-method \nsecurity in an object-oriented language. Mod\u00adules, on the other hand, are a greater challenge because \ncomponent linking occurs at the module level and authentication of principals will be needed; adding \nmodules is a topic of future work. The language contains the usual lambda expressions, and also notions \nof privilege and function ownership. Privileges, denoted as 7and ranging over the set of identi.ers Privs, \nmodel rights such as PrintPriv, FileReadPriv, etc., that a system might specify. They are activated and \nchecked by letprivand checkprivexpressions our version of the do privileged and check privilege commands \nand every function has a speci.ed owner p, which is the identity of a principal (a similar annotation \nof expressions with owner names is described in [8]). In any given system, every principal pis authorized \nfor a par\u00adticular set of privileges 7; this is expressed via the access creden\u00adtials mapping A, where \nfor any principal p, A(p)is the .nite set of valid privileges for p. We assume as given a possibly in.nite \nset of privileges PTthat the system draws upon i.e., for all p, A(p).PT. We say that a program is unsafe \niff it reduces to the value secfail; this value exists precisely to represent an opera\u00adtional security \nfailure. The full grammar for language expressions and constructs used in the operational semantics are \ngiven in Figure 1, where Princ, Privsand Varare disjoint sets of identi.ers. The language includes letprivand \ncheckprivexpressions, as well as pAx:ewhich indicates a function owned by p, and secfailwhich is a state \nindicating a security violation occurred; this would be an exception in a language with exceptions but \nwe simplify here and abort in the case of failure. 2.2 Language examples Before precisely de.ning the \nstack inspection and reduction se\u00admantics, we informally illustrate the operational nature of the sys\u00adtem \nwith some simple examples. The behavior asserted in these examples may be rigorously veri.ed by the operational \nsemantics that follows. Note that for the moment we ignore function owner\u00adship and access credentials \nfor ease of presentation. Let: id=Ax:x lp=Af:Ax:letpriv7infx cp=Ax:checkpriv7forx Each of these expressions \nare safe in a top-level environment; the only term that could cause problems is cp, but the security \ncheck is frozen by the lambda abstraction. If it is unfrozen by the applica\u00adtion cpidin an environment \nwith the privilege 7not enabled, then a security error will occur: cpidreduces to secfail. However, it \nis possible to wrap cpwith lp, yielding a function which is equiva\u00adlent to cp, but which can be safely \napplied in an environment with\u00adout 7enabled: for example, (lpcp)idis safe in any environment, because \nlpenables 7before it is checked in the body of cp. Privileges exist on the stack only as long as the \nstack frame in which they were granted exists. This means that in the expression letpriv7ine, 7is enabled \nonly for eat the time of evaluation. A somewhat strange consequence of this can be demonstrated with \nthe following relationships, where fx=Af:Ax:fxand with ' meaning operational equivalence: (letpriv7infx)6lp \n' (letpriv7infx)'fx These relationships hold because the letprivis frozen by lambda abstraction in lp, \nbut not in (letpriv7infx). As a demonstration, observe that the expression ((letpriv7infx)cp)idis not \nsafe. hp,P7i::S,A`e!v (letpriv) hp,Pi::S,A`letpriv7ine!v inspect(S,7,A)=trueS,A`e!v (checkpriv) S,A`checkpriv7fore!v \nS,A`e1!pAx:eS,A`e2!v 0hp,fgi::S,A`e[v 0/x]!v (appl) S,A`e1e2!v (val) S,A`v!v inspect(S,7,A)=f (checkprivf) \n S,A`checkpriv7fore!secfail S,A`e2!secfail (applfr) S,A`e1e2!secfail S,A`e1!secfailS,A`e2!v (appl.) \n S,A`e1e2!secfail Figure 2: Operational semantics for Asec Now, we introduce the notion of function ownership. \nLet cpbe rede.ned as follows, in the full Asec syntax: cp=pAx:checkpriv7forx This de.nition speci.es \nthat the owner of cpis the principal p.In conjunction with ownership, the access credential list Abecomes \nrelevant to the safety of the language. For example, suppose that the local access control list A1speci.es \nthat pis completely untrusted that is, that phas no privileges: A1=f,p7!,g Then the function cpis useless \nlocally, since the checkprivex\u00adpression in it will fail stack inspection in every security context the \noperational semantics require that the owner of a function be entitled to the privileges necessary for \nits use. Informally, we may say that cpis useless because it needs 7, which pis not authorized for. Further, \nif cpwere de.ned to call a function which needs 7, then it would also fail. On the other hand, if the \nlocal access control list is A2, which entitles pto the privilege 7: A2=f ,p7!f7g,g then cpcould safely \nbe applied in certain environments in partic\u00adular, environments with 7enabled by a preceding letpriv.In \nan environment of mixed local and outsider code, this system will prevent outside code from accessing \nunauthorized local resources. For example, suppose in the local system we wish to make print\u00ading a privileged \nresource, available to some trusted non-local par\u00adties. In this case, where we assume the Printfunction \nis avail\u00adable only to the local system, a secured print function safePrint could be made available to \nexternal code: system safePrint=Ax:checkprivPrintPrivforPrint(x) Then, code owned by some outsider pcould \ntry to use safePrint: foreignProg=pAx::::safePrint(text)::: Letting 7=PrintPriv, we see that if A1as \nde.ned above is the local access credential list, implying that pis not trusted for PrintPriv, then foreignProgis \nuseless. But if A2de.nes the local policy, foreignProgcan be used in certain contexts (i.e., with PrintPrivenabled). \n 2.3 The stack inspection algorithm We now give the formal de.nition of stack inspection, which makes \nrigorous the informal assertions in the previous examples. Security stacks Sare used in the operational \nsemantics to dy\u00adnamically check security properties. Each element of the stack rep\u00adresents the security \ninformation for a given stack frame, notated hp,Pi, which indicates a stack frame owned by pand containing \nactivated privileges P. The inspectfunction inspects the stack and returns whether the stack is legal \nor not: inspect(nil,7,A)=false inspect(hp,Pi::S,7,A)= if762A(p)thenfalseelse if72Pthentrueelseinspect(S,7,A) \nThis algorithm implements the Java stack inspection algorithm: given a privilege 7, the stack is searched \nframe by frame from the current frame until the privilege is found on the stack (return true), or the \nowner of the frame lacks that credential (return false), or we ran off the top of the stack (return false). \nThe set of privileges which are enabled on a particular stack S, given some access cre\u00addential list A, \nis denoted privs(S); i.e., privs(S,A)=f7jinspect(S,7,A)=trueg: Using the stack inspection algorithm, \nwe can de.ne the opera\u00adtional semantics of Asec. The key differences from a standard oper\u00adational semantics \nare that function application adds a new frame to the security stack,  letprivadds a privilege to the \ntop frame on the stack,  t::=t1jt2j (type variables) p::=p1jp2j (privstruct variables) I::=PjItIjIPjp \n(privstructs) I T::=tjT;!T (types) PC::= fI1vI10 ,:::,InvIn0 g(privstruct constraints) TC::=fT1<:T10 \n,:::,Tn<:Tn0 g(type constraints) ;::=7,:::,xn!7Tng fx1!T1 (type mappings) &#38;::=;,I,p` Ae:T/PC,TC(type \njudgements) Figure 3: Security Type Grammar checkprivinspects the stack via inspectto make sure the \nneeded privilege 7is found,  if a needed privilege is not found by checkpriv, the entire computation \naborts with result secfail.  A judgment in the operational semantics is written S,A`e! v, meaning ereduces \nto value vin environment S,A. The rules for the operational semantics are given in Figure 2. Note that \nthe letpriv reduction rule requires that any stack Sused in a judgement be non-empty. Since elements \ncan only be added to the stack, this means that any evaluation must be initiated with a non-empty stack. \nThis captures the notion of a top-level owner of the program. In our model, we assume some top-level \nuser 5pwith A(p5)=P5, and de.ne the stack S5 =hp5,P5i::nilas the initial evaluation stack. The top-level \nenvironment is then S5,A, and if S5,A`e!vwe write e!vfor brevity. With this formalization, we can give \na precise account of the examples in subsection 2.2; e.g. with arbitrary A, we deduce the following using \ncheckprivf, appl and val: inspect(hp,fgi::S5,7,A)=f hp,fgi::S5,A`checkpriv7forid!secfail S5,A`id!idS5,A`cp!cp \nS5,A`cp(id)!secfail 3. SECURITY TYPES FOR Asec In this section we present our type system for Asec, and \nestab\u00adlish a type safety result for the system via subject reduction. Type safety in this context means \nthat no well-typed programs will ever have any stack inspection failures during run-time execution; we \ncall this property security stack safety. This then obviates the need to perform stack inspection at \nrun-time. The type system serves an important additional purpose: security information for programs is \nclearly advertised in their types, rather than being buried in function calls which the programmer must \ndiscover either through security failure, or painstaking analysis of source code. We formulate the types \nhere as a constrained type system; for background on these systems the reader is referred to any of [1, \n5, 9]. Our presentation here, especially our proof method, most closely follows Henglein s presentation \nin [9]. The question of whether to use a constrained or constraint-free system as a basis for this work \nis largely one of style; we chose the former mainly because of our previous experience with such formalisms \n[5]. The general ideas should be applicable across a wide range of type sys\u00adtems. The security type grammar \nis de.ned in .gure 3. 3.1 Security types overview The most novel feature of security types are the privstructs \nI that decorate function types. The general idea is that if a function I fhas type T;!T, then Iexpresses \nthe privileges necessary to execute f. A simpli.ed example is: f1g pAx:checkpriv7forx:t;;!t Note that \nprivstruct expressions I, de.ned in Figure 3, include ground privilege sets P, privilege set variables \np, and operators thereupon. A security type judgement is of the form ;,I,p` Ae:T/PC,TC This judgement \nasserts that under type environment ;(a mapping from expression variables to types), with Irepresenting \nthe cur\u00adrently enabled privileges, then the code e, owned by principal p, has type Twith constraints \nPC,TC. PCcontains the set constraints that are imposed by function ownership; for any subtermp 0 Ax:e0of \nethat needs I0, the constraint I0 vA(p 0)is in PC. This ensures that the security requirements of functions \ndo not exceed the priv\u00adileges granted to the owner. TCis the usual type constraint set, containing elements \nof the form T1<:T2. 3.2 Security type examples In this subsection, we develop an understanding of our \ntype sys\u00adtem by introducing its features piece by piece. Each example is really a simpli.ed type, with \nsome formal features left out for the sake of clarity. Let idbe de.ned as follows: id=pAx:x fg Then we \nmay give idthe type Tid =t;!t, noting that it requires no privileges to execute. Such a valid type judgment \nwith regard to a particular access control list Acan be written as: fg ` Aid:t;!t Privileges start showing \nup in types when letpriv s and checkpriv s are used. When privileges are enabled or checked, either action \nis made with respect to the current security environent. For example, a privilege may be safely checked \nif it is in the current environment: f7g` Acheckpriv7forid:Tid But no privileges need be in the current \nenvironment if the checkpriv is nested within a valid letprivfor the same privilege: fg` Aletpriv7incheckpriv7forid:Tid \nThese ideas are formalized in the letpriv and checkpriv typing rules in .gure 5. The current needs Iof \nan expression are generally de.ned by the set of un-enabled privileges that are checked in the expression. \nFunction application requires special consideration in the type system, since if a function fapplies \nanother function g, then the needs of gmust be considered in determining the needs of f. Let f be de.ned \nas follows: f=pAg:g(id) In the body of f, gis applied, but the needs of gare abstract. This can be re.ected \nin the type, through the use of a set variable p: .. ` Af:(Tid;!t 0);!t 0/fpvA(p)g (coerce <:) TC[ f \nT < :T0 g ` T < :T0 (ref<:) TC`T < :T (trans<:) TC`T1<:T2TC`T2<:T3 TC`T1<:T3 (!<:) TC`T0 1<:T1TC`T2<:T0 \n2ITC`T1 I ;!T2<:T0 1 I0 ;!T0 2 I0 Figure 4: Subtype Judgement Rules Note that to the right of the /symbol \nis a constraint set containing pvA(p); this imposes the requirement that whatever pis, it must be a subset \nof the privileges entitled to paccording to A. Soifwe assume that 72A(p), then pcan be instantiated to \nf7g, and t0 can be instantiated to Tidto yield: f1gf1g ` Af:(Tid;;!Tid);;!Tid And with cpde.ned as in \nsubsection 2.2: f1g ` Acp:Tid;;!Tid Therefore, the application f(cp)can be typed, as long as the cur\u00adrent \nsecurity environment contains 7, since fneeds 7. In general, all types have a current security environment \nIand current owner p, with the requirement that IvA(p)is satis.able in addition to the other constraints; \nthis Iand pare written to the left of the ` A in any type judgement. So for example: f7g,p 0` Af(cp):Tid \nwhere we stipulate that f7g.A(p 0)must hold for the judgement to be valid. We now give a formal treatment \nof satisfying privstruct substi\u00adtutions, which are substitutions that induce a set interpretation of \nprivstructs associated with a type, which is consistent with the set constraints in the type.  3.3 Satis.ability \nand type validity Since privstructs Imay contain set variables p, they are not sets per se, but rather \ndatatypes that are mapped to privilege sets via substitution and a set interpretation function. For example, \nif we take I=f7gtp, then by applying the substitution ff70 g/pg to Iwe obtain the privstruct f7gtf70 \ng, which is mapped to the set f7,70 gunder our set interpretation. In general, the privstruct datatype \nconstructors tand are interpreted as the set operations [and ;. We state this formally as follows: DEFINITION \n3.1. A substitution is a set Sof the form fP1/p1, :::,Pn/png, with substitution application S(I)de.ned \nin the ob\u00advious manner. The privstruct meaning function is de.ned as fol\u00adlows: [ P]]=P [[I1tI2]]=[[I1] \n[[[I2] [[IP]]=[[I]];[ P] [ p] is unde.ned If [ SI]]is de.ned, we say that I2Dom(S). The usual set re\u00adlations \nmay be applied to sets [ SI]], e.g. [ SI]][ S0I0] .For brevity, we say that II0iff for all Swith I,I02Dom(S), \n[ SI]][ SI0] , and 72Iiff 72[ SI]]for all Sfor which I2Dom(S). We also de.ne an ordering :on substitutions, \nwhere S1:S2iff [ S1I]][ S2I]]for all Isuch that I2 Dom(S1)\\Dom(S2). As described in the previous subsection, \nthe set PCin a type judgement de.nes constraints on privstructs imposed by function ownership. That is, \nif a function fis owned by p, then the privi\u00adleges required to execute fmust be a subset of the privileges \nA(p) which pis entitled to. Thus, a substitution that satis.es PCis a substitution that maps all privstructs \nin PCto ground privstructs such that the constraints in PChold under our set interpretation. In other \nwords, Ssatis.es PCiff for all I1cI22PC, [ SI1] [ SI2] . In addition to PC, the type constraint set TCcan \nalso include privstruct constraints. Security types include a subtyping judge\u00adment TC`T1<:T2, de.ned \nin .gure 4. We let TC`TC0 abbreviate TC`T<:for all T<:2TC0 . Note that `is T0T0 transitive over constraint \nsets: PROPOSITION 3.2. If TC`TC0and TC0`TC00, then TC`. TC00 PROOF. By induction on the derivation of \nTC0`T<:T0 , T02TC00 where T <:. Thus, the subtyping relations in any TCimpose constraints on privstructs \nbecause in order for the type system to be sound, TC` I0I T1;!T2<:T1 0;!T202TCmust imply II0 . Intuitively, \nthis is because it is safe to overestimate the security requirements of a function, but it is not safe \nto underestimate them. Privstruct constraint satisfaction is de.ned via a standard clo\u00adsure operation \nwhich is the transitive and functional closure of type constraint sets TC. First, we give a de.nition \nof closure for any set TC: DEFINITION 3.3 (TCCLOSURE). The closure of TC, de\u00adnoted close(TC), is the \nleast set TC0satisfying the following properties: TC TC0 I T0!T0 If T1;!T2<:1;I0 22TC0, then T10<:T12TC0 \nand T2<:T202TC0(fn closure).  If T1<:T22TC0and T2<:T32TC0, then T1<:T32 TC0 . (transitive closure) \n close(TC)is easily shown to be computable by iteration. Now, satis.ability of set, type constraint pairs \nPC,TCmay be de.ned. DEFINITION 3.4 (PRIVSTRUCT SATISFIABILITY). Let I0 I I0T0!T0 scs(TC)=IvjT1;!T2<:1;22TC \nand let TPC=scs(close(TC)). Then the set, type constraint pair PC,TCis satis.able iff there exists some \nSsuch that for all I1vI22PC[TPCit is the case that [ SI1] [ SI2] . The function name scsstands for set \nconstraints , because it gleans set constraints imposed by the type coercions in TC. ;(x)=T (var) ;,I,p` \nAx:T/PC,TC 8 ;,I0 ,p` Ae:T/PC,TC{Itf1gif 12A(p) (letpriv) I0= : ;,I,p` Aletpriv7ine:T/PC,TCIotherwise \n;,I,p` Ae:T/PC,TC72I (checkpriv) ;,I,p` Acheckpriv7fore:T/PC,TC ;x!7T,,p 0` Ae:/PC,TCvA(p 0)2PC I0 T0I0 \n(fn) 0 I0 p ;,I,p` AAx:e:T;!T0/PC,TC T0I0 T0I0 ;,I,p`e1:;!T/PC,TC;,I,p`e2:/PC,TCI (appl) AA ;,I,p` Ae1e2:T/PC,TC \n;,I,p` Ae:/PC,TCTC`<:T T0T0 (sub) ;,I,p` Ae:T/PC,TC Figure 5: Type Judgement Rules The above de.nition \nof satis.able is elegant, but needs a stronger characterization, csatis.able, for use in subject reduction. \nDEFINITION 3.5 (TC-CONSISTENCY). The type constraint I set TCis consistent iff for all derivations TC`T1;!T2<: \nI0 T1 0;!T20 , there exists a derivation with the same conclusion and with the .nal step an instance \nof !<:. DEFINITION 3.6 (SATISFIABILITY CHARACTERIZATION). The set, type constraint set pair PC,TCis csatis.able \niff there exists some Ssuch that for all I1vI22PCit is the case that [ SI1] [ SI2] , and there exists \na consistent TC0such that TC0`S(TC). Abusing terminology, we may also speak of S satisfying PCor TCalone, \nwith the obvious meaning. The following lemma establishes the interchangeability of satis\u00ad.ability and \nits characterization: LEMMA 3.7. Ssatis.es PC,TCiff Scsatis.es PC,TC. Subtyping judgements are closed \nunder satisfying substitutions, a fact demonstrated by the following proposition: PROPOSITION 3.8. If \nSsatis.es TCand TC`T<:T0, then S(TC)`ST<:ST0 . PROOF. By rule induction on TC`T<:T0 . With this notion \nof constraint satis.ability, we can formally de\u00ad.ne type validity as follows: DEFINITION 3.9 (TYPE VALIDITY). \nThe typing ;,I,` Ae: T/PC,TCis valid iff there exists a derivation with this conclu\u00adsion, and an Sthat \nsatis.es PC[fIvA(p)g,TC. If fg,I,p5 ` Ae:T/TC,PCand PC0 =PC[fI.A(p5)g then we write ` Ae:T/PC0 ,TCfor \nbrevity, and we write e:T if Ais understood from context and PC, TCand Iare empty. If a type contains \nno set variables p, we say that it is concrete; the following result establishes that if ehas a type, \nthen it has a concrete type: PROPOSITION 3.10. If ;,I,p` Ae:T/PC,TCis satis\u00ad.ed by S, then S;,SI,p` Ae:ST/S(PC),S(TC)which \nis concrete. PROOF. Since Sgenerates a concrete type by de.nition, the re\u00adsult is implied by the validity \nof the generated type, which follows by induction on the length of the type derivation.  3.4 Type safety \nand subject reduction Our goal for security types is to prove that any well-typed pro\u00adgram is operationally \nsafe according to the Java stack inspection model de.ned in section 1. To characterize the desired theorem, \nwe use the notion of security failure speci.ed in the operational semantics: any unsafe program reduces \nto secfail. THEOREM 3.11 (SECURITY TYPE SAFETY). If the type ` A e:T/PC,TCis valid, then it is not the \ncase that S5,A`e! secfail. The theorem is proved by a standard subject reduction argument. Note that \nwe phrase subject reduction in terms of concrete types, since operational judgements are always concrete \nin the sense that privs(S,A)is always a ground set Pfor any stack S. THEOREM 3.12 (SUBJECT REDUCTION). \nIf ;,I,p` Ae: T/PC,TCis concrete, and S,A`e!vwith [[I]]privs(S, A)and pin the head of S, then ;,I,p` \nAv:T/PC,TC. To prove subject reduction, we .rst demonstrate two lemmas re\u00adlated to subtyping which allow \nus to deal almost exclusively with the non-subsumption rules in the induction for subject reduction; \nwe also demonstrate the usual substitution lemma in a form ap\u00adpropriate for security types. LEMMA 3.13. \nIf ;,I,p` Ae:T/PC,TC, then there exists a subderivation of ;,I,p` Ae:T0/PC,TC, where TC`T0<:T, such that \nif e=x, then the last step in the sub\u00adderivation is an instance of var,if e=pAx:ethen the last step in \nthe subderivation is an instance of fn, etc. for each term type and the corresponding type rule. PROOF. \nEach term form clearly must have an instance of its corresponding type rule in the type derivation. And \nsince only in\u00adstances of sub can be interposed between the derivations of ;,I,p` A e:T0/PC,TCand ;,I,p` \nAe:T/PC,TC, the lemma fol\u00adlows via a straightforward induction on the number of interposed e[v 0/x]:Tr/PC,TCby \nlemma 3.14 and sub. And since Idr Iand [[I0] [[Idr] therefore [[I0] [[I]]. Further, I0 v drdrdr A(p 0)2PCso \nthat [[I0] A(p 0), since PCis concrete and dr satis.ed; therefore [[I0] privs(hp 0 ,fgi::S,A)by the de.ni\u00ad \ndr tion of privs. Thus, by the induction hypothesis ;,I0 ,p 0` Av: dr  LEMMA 3.14 (SUBSTITUTION). Supposing \nTC`T10<:T1, if ;x7!T10 ,I,p` Ae:T2/PC,TCand ;,I0 ,p 0` Av: T1/PC,TC, then ;,I,p,` Ae[v/x]:T2/PC,TC. PROOF. \nBy structural induction on eand case analysis. Here we give only the application case, letting ;0 =;x71: \n!T0 (e=e1e2) By lemma 3.13, there exists the following step in the derivation of the type of ein this \ncase, where Tr<:T2: 0 Idr ;,I,p` Ae1:Td;;!Tr/PC,TC ;0 ,I,p` Ae2:Td/PC,TC IdrI ;0 ,I,p` Ae1e2:Tr/PC,TC \nIdr By the induction hypothesis, ;,I,p` Ae1[v/x]:Td;;!Tr/ PC,TCand ;,I,p` Ae2[v/x]:Td/PC,TC. Thus, ;,I,p` \nA e[v/x]:Tr/PC,TCby the de.nition of substitution and appl, so the lemma holds in this case by sub. The \nfollowing is another utility lemma for subject reduction, showing that a value is safe in any current \nsecurity context: LEMMA 3.15. If ;,I,p`v:T/PC,TCand TC`T<: 0T0 T0, then ;,I0 ,p`v:/PC,TC. Now, we can \nprove the necessary subject reduction result: PROOF OF THEOREM 3.12 By induction on the derivation of \nS,A`e!v. Here we show only the appication case: (e=e1e2) By lemma 3.13, there exists the following step \nin the derivation of the type of ein this case, where TC`Tr<:T: Idr ;,I,p` Ae1:Td;;!Tr/PC,TC ;,I,p` Ae2:Td/PC,TC \nIdrI ;,I,p` Ae1e2:Tr/PC,TC p By the operational semantics in this case, S,A`e1!0 Ax:e0 and S,A`ve2!v \n0, and hp 0 ,fgi::S,A`e[v/x]!v. p Idr Thus, by the induction hypothesis, ;,I,p` A0 Ax:e0:Td;;! Tr/PC,TCand \n;,I,p` Av 0:Td/PC,TC. Now, by lemma 3.13 there exists the following step in the derivation of the type \nof p 0 Ax:e0: !Td0 ,I0 T0 ;x7dr,p 0` Ae 0:r/C I0 drvA(p 0)2PC,TC 0 I0 p T0dr ;,I,p` AAx:e0:d;;!Tr0/PC,TC \nwhere TC`<:Td0 , TC`T0<:and [[I0] [[Idr] TdrTrdr by the concreteness of PC,TCand satis.ability. But \n;7x! T0000 d,I0 ,p`e:/PC,TCby sub, so that ;,I0 ,p` drATrdrA Having established subject reduction, it \nis easy to demonstrate se\u00adcurity type safety: PROOF OF THEOREM 3.11 By proposition 3.10, if ehas a type \nthen ehas a concrete type. Therefore the theorem follows by theo\u00adrem 3.12, since secfailhas no type. \n 3.5 Incompleteness of the type system There are a few sources of inconsistency in the security type \nsystem that is, instances in which operationally safe programs do not have a type. Some are inherent \nin the approach, while some re.ect choices that were made in the design of the system. For example, assuming \nthat 726A(p), the program: pAx:checkpriv7forx does not have a type, but is operationally safe, since \nthe program de.nes but does not use the function. However, while it is possible to construct the type \nsystem so that these sorts of programs are ac\u00adcepted, we argue that such useless functions should not \nbe allowed, since they are just that useless. There are of course the standard sources of incompleteness \nthat cannot be avoided. For example, assuming a standard encoding of conditional expressions, application \nof the following function in a current environment (i.e., without 7activated) is not well typed, though \nit is always operationally safe: pAx:iffalsethencheckpriv7forxelsex Even though the checkprivbranch is \nnever taken, this sort of prop\u00aderty cannot in general be established by our type system. Never\u00adtheless, \nthis kind of incompleteness should not have a signi.cant effect on the usefulness of security types. \nA third sort of incompleteness points to the need for polymor\u00adphism, which we left out of this paper \nto allow us to focus on the core security issues. Assuming the standard encoding for sequenc\u00ading and \nletexpressions, let ebe de.ned as follows: let id=pAx:x cp=pAx:checkpriv7forx f=pAf:pAx:f(x) in f(cp).f(id) \n f1g Then e:t;;!tfails, since our monomorphic type system can\u00adnot distinguish between the two different \napplication points of f, but uni.es them. This example demonstrates a need for at least let-polymorphism. \nIn addition to issues related to the current language, branching on privileges may be a desirable idiom \nfor a secure language. That is, suppose testprivis a predicate on privileges, which holds iff a checkprivof \nthe same privilege suceeds (note, in a language with exceptions, testprivcould be de.ned using checkprivand \nan ex\u00adception handler). Then expressions such as iftestpriv(7)thene1elsee2 isecty(;,p ,x)=(fg,;(x),fg,fg) \nisecty(;,p,letpriv7ine)= let (I,T,PC,TC)=isecty(;,p,e) and I0 =if72A(p)thenI7elseI in (I0 ,T,PC,TC) isecty(;,p,checkpriv7fore)= \nlet (I,T,PC,TC)=isecty(;,p,e) in (Itf7g,T,PC,TC) 0 isecty(;,p, pAx:e)= let (I,T,PC,TC)=isecty(;x70 ,e), \n!t,p where tis fresh I in (fg,t;!T,PC[fIvA(p 0)g,TC) isecty(;,p,e1e2)= let (I1,T1,PC1,TC1)=isecty(;,p,e1) \nand (I2,T2,PC2,TC2)=isecty(;,p,e2) and I=I1tI2tp no and TC=TC1[TC2[T1<:T2;!t, where tand pare fresh in \n(I,t,PC1[PC2,TC) Figure 6: The isectyAlgorithm could be useful, and indeed this sort of expression is \nfound in Java JDK 1.2 programs. However, our system as currently conceived does not include types that \ndepend on the dynamic security level of the execution context. But, there is a practical need to perform \nsuch a case analysis to allow for rollback behavior in the event some higher access right is unavailable \nbut a weaker alternative is avail\u00adable. So, in future work we plan to extend our type system in this \ndirection.  4. SECURITY TYPE INFERENCE Some form of type inference is an essential component of static \nsecurity typing, since we do not want to burden users with the need to modify most types in their programs. \nIn the following presenta\u00adtion, type inference requires no input from the user so is optimal in that \nsense, but does not always produce easily readable types. So we do not claim the .nal solution has been \nachieved. Our type inference algorithm, infersectyde.ned in .gure 7, resembles the standard constraint \ntype inference algorithms (e.g., see [5]), with the addition of an algorithm for inferring a satisfying \nsubstitution Sfor any constraint sets PC,TCgenerated by type inference. As usual, the correctness of \ntype inference is stated in terms of soundness and completeness that is, that any inferred type &#38;is \nvalid, and if a term has a type &#38;0then a type &#38;will be inferred that is most general , in the \nsense that &#38;0is an instance of &#38;.We follow Henglein s syntactic halbstark relation, described \nin [9], in characterizing our instance relation. Note that the de.nition does not require that either \ntyping in a relation &#38;:&#38;0be valid: 0 DEFINITION 4.1 (INSTANCE RELATION). The type &#38;0 =;, \nI0 ,p` Ae:T0/PC0 ,TC0is an instance of &#38;=;,I,p` Ae: T/PC,TC, written &#38;:&#38;0, iff there exist \n8and S^such that 1. ;=8 ; ^ 2. TC0`S(8TC) ^T0 3. TC0`S(8T)<: 4. S^II0and S^(PC0):PC  In the above, \n8is a security type substitution de.ned in the obvious ^ manner, and Sis a privstruct substitution de.ned \nsimilarly as in de.nition 3.1, except that any pmay be mapped to a privstruct containing other set variables \n(i.e., it is not a ground substitution). For clause 4, the relation PC1:PC2holds iff for all I2v A(p)2PC2there \nexists I1vA(p)2PC1such that I1I2. For the purposes of our proofs, we must at least establish that if \n&#38;:&#38;0and &#38;is valid, then so is &#38;0 . We do this with the following lemmas. LEMMA 4.2. If \nSsatis.es PC,TCand TC`S(TC0)and PC0:PC, then Ssatis.es PC0 ,TC0 . PROOF. By de.nition 3.4, and transitivity \nof and `. LEMMA 4.3. If &#38;is a valid type and &#38;0:&#38;, then &#38;0is valid. PROOF. By lemma 4.2 \nand rule induction on &#38;. With this characterization of :, our main result for type infer\u00adence may \nbe stated as follows. THEOREM 4.4 (CORRECTNESS OF TYPE INFERENCE). The type inference algorithm infersectyreturns \nT/PC,TCfor eiff &#38;=` Ae:T/PC,TCis a valid type judgement, and for all valid type judgements &#38;0 \n=` Ae:T0/PC0 ,TC0it is the case that &#38;:&#38;0 . This theorem is proven in the following subsections. \nInspection of the infersectyreveals that the real work of the algorithm is done by the auxiliary functions \nisecty, which infers the type struc\u00adture, and satisfy, which veri.es the existence of a satisfying sub\u00adstitution \nfor the type. Hence, the correctness proof of infersecty is accomplished by way of correctness proofs \nfor isecty(in par\u00adticular, we prove soundness and completeness results for this algo\u00adrithm), and satisfy. \nFirst, we give a brief example to illustrate the workings of the inference algorithm. 4.1 Type inference \nexample Let idand cpbe de.ned as in subsection 3.1. Suppose we are inferring the type of cp(id); then \nisectywill infer the following types for these functions separately: f1g fg,fg,p`cp:t1;;!t1/ff7gvA(p)g,fg \n5A fg fg,fg,p`id:t2;!t2/ffgvA(p)g,fg 5A Now, let: PC=ff7gvA(p),fgvA(p)g f1gfg TC=ft1;;!t1<:(t2;!t2);!t3g \nThen the top-level type inferred for the expression cp(id)will be fg,fpg,p`cp(id):t3/PC,TC 5A Note that \nTCimposes the constraint f7gvpby de.nition 3.4, so that in order for this type to be valid, the constraints \nf7gvp,pvA(p5),f7gvA(p),fgvA(p) satisfy(PC,TPC)= let glb(P,rr)=P glb(I1tI2,rr)=glb(I1,rr)[glb(I2,rr) glb(IP,rr)=glb(I1,rr);P \nglb(p,rr)= if p2rrthen fg S else glb(I,rr[fpg) .vp2TPC in trueiff for all IvA(p)2PC, glb(I,).A(p) infersecty(e)= \nlet (I,T,PC,TC)=isecty(fg,p5,e) and cTC=close(TC) and TPC=scs(cTC) and PC0 =PC[fIvA(p5)g in if satisfy(PC0 \n,TPC)then T/PC0 ,TC else raise sectyfail Figure 7: The infersectyand satisfyAlgorithms must all be satis.able. \nOf course, this is possible only if 72A(p) and 72A(p5), in which case e.g. ff7g/pgsatis.es these con\u00adstraints. \nIn any case, satisfyaddresses the problem of set constraint satis.ability. 4.2 Soundness of isecty The \nsoundness result for isectyestablishes that any type returned is indeed valid, modulo the satis.ability \nof the constraint sets gen\u00aderated; this is because the issue of satis.ability is handled not by isecty, \nbut by satisfy. To assist in the soundness proof, we demon\u00ad strate the following lemma, which shows that \ntype judgements are preserved by pumping up the constraint sets: LEMMA 4.5. If ;,I,p` Ae:T/PC,TCand II0 \n, PCPC0and TCTC0, where PC0[fI0 vA(p)g,TC0 is satis.able, then ;,I0 ,p` Ae:T/PC0 ,TC0 . PROOF. The lemma \nfollows by de.nition of the typing and <: rules. Now it is easy to state and prove the appropriate soundness \nre\u00adsult: LEMMA 4.6 (SOUNDNESS OF isecty). If isecty(;,e,p)re\u00adturns (I,T,PC,TC)and PC[IvA(p),TCis satis.able, \nthen ;,I,p` Ae:T/PC,TC. PROOF. The lemma follows by structural induction on e. Here we demonstrate only \nthe case (e=e1e2). Let isecty(;,e1,p)re\u00adturn (I1,T1,PC1,TC1)and isecty(;,e2,p)return (I2,T2,PC2, TC2); \nthen by the de.nition of the algorithm: T=t PC=PC1[PC2 no TC=TC1[TC2[T1<:T2;!t I =I1tI2tp By the induction \nhypothesis, ;,I1,p` Ae1:T1/TC1,PC1 and ;,I2,p` Ae2:T2/TC2,PC2, therefore ;,I,p` Ae2: T2/TC,PCand ;,I,p` \nAe1:T1/TC,PCby lemma 4.5. Thus ;,I,p` Ae1:T2;!t/TC,PCby sub, and clearly pI, therefore ;,I,p` Ae:t/TC,PCby \nappl. 4.3 Completeness of isecty Our isectycompleteness result shows that the algorithm returns a most \ngeneral type, in the sense formalized by the :relation. For the purposes of the proof we informally note \nthat any type mapping ;used by isectymaps expression variables xto type variables t, and observe that \nthis invariant is maintained throughout execution of isectyby de.nition of the algorithm. LEMMA 4.7 (COMPLETENESS \nOF isecty). If the type &#38;= 8(;),I,p` Ae:T/PC,TCis valid, then isecty(;,p,e)re\u00ad 0 T0 turns (I0 ,T,PC0 \n,TC0)such that ;,I0 ,p` Ae:/PC0 ,TC0 is valid and :&#38;. PROOF. By lemma 4.3, the proof follows by showing \nthat the type returned by isectyis most general according to :. We es\u00adtablish this property by induction \non the type judgement; here we show only the case (e=e1e2). By lemma 3.13, there exists the following \nstep in the derivation of the type of e, where Tr<:T: Idr 8;,I,p` Ae1:Td;;!Tr/PC,TC 8;,I,p` Ae2:Td/PC,TC \nIdrI 8;,I,p` Ae1e2:Tr/PC,TC Let isecty(;,e1,p)return (I1,T1,PC1,TC1)and let isecty(;, e2,p)return (I2,T2,PC2,TC2); \nthen by the de.nition of the al\u00adgorithm: T0 =t PC0 =PC1[PC2 no TC0 =TC1[TC2[T1<:T2;!t I0 = I1tI2tp ^ \nBy the induction hypothesis, there exist substitutions 81, S1, 82and S^2such that for i2f1,2git case \nthat S^i(Ii)I, ^ TC`Si(8i(TCi)), etc. for each condition of the appropriate :relations. We note that \nin objects Xand Yreturned by dis\u00adtinct recursive calls to isecty, any set variables will be fresh, so \n^^ that S1and S2have disjoint domains. Furthemore, by construc\u00adtion of the proof, 81and 82need differ \nfrom 8only in terms of those type variables generated for the application case, which are fresh. Thus, \nthere exist 80 =81082=82081and ^^^^^ ^ S=S10S2=S20S1such that S^(I1tI2)I, S(PC0):PC ^ and TC`S^(80(TC1[TC2), \nand also TC`S(80T1)<: Idr^0 Td;;!Trand TC`S(80T2)<:Td. Let 800 =8[fTr/tgand S^0 =S^[fIdr/pg; since tand \npare fresh, therefore S^0(800(T2;! Idr t))=S^0(800T2);;!Trand TC`S^0(800T2)<:Td, so that Idr TC`S^0(800T1)<:S^0(800T2);;!Trby \n!<:. And there\u00adS^0(800S^0I0 fore TC`TC0), and clearly I, etc., so this case holds by sub and de.nition \n4.1, since S^0(800t)=Trand TC`Tr<:T. 4.4 Correctness of satisfyand infersecty The .nal step in establishing \nthe correctness of type inference is the proof of corretness for satisfy, which we state as follows: \nmt TPC(r,S)P=P mt rTPC(rr,S)I1tI2= mt mt (mtTPC(rr,S)I1)[(mtTPC(rr,S)I2) TPC(rr,S)IP=(mtTPC(rr,S)I);P \nTPC(rr,S)p= if p2rrthen S(p) S else let P= mtTPC(rr[fpg,S)Ii Iiv2TPC in P[S(p) MTfP=P MTfI1tI2=f(I1)[f(I2) \nMTfIP=f(I);P S MTfp= f(Ii) Iiv2TPC Figure 8: The mtTPCalgorithm and MToperator THEOREM 4.8. If PCand \nTCare generated by isecty, then satisfy(PC,TC)holds iff PC,TCis satis.able. We determine whether PC,TCis \nsatis.able by providing the least solution to TCand checking it against the constraints in PC. The least \nsolution of TCis the .xpoint of an appropriately de.ned operator MT, de.ned in .gure 8. However, it is \nnot immediately obvious that this operator has a .xed point at !, so we de.ne a function glbin .gure \n7 that clearly terminates, and show that it is the least .xpoint of MT. In theorem 4.8 the stipulation \nthat PCand TCare returned by isectyis important; the form of the constraints in such sets shapes our \nsolution method. The following lemmas demonstrate that all set constraints imposed by TCare of the form \nIvp. Thus, the least soluction of these constraints de.ne a system of lower bounds on the size of each \np. LEMMA 4.9. If TCis returned by isecty, then for all T<: I T1;!T22close(TC), Iis some set variable \npand T2is some type variable t. PROOF. By induction on the number of closure rounds neces\u00adsary to close \nTC. LEMMA 4.10. If cTC=close(TC)for some TCreturned by isecty, then for all I1vI22scs(cTC), I2is a variable \np. PROOF. Immediate by lemma 4.9 and the de.nition of scs. Now, we note further that any constraint in \nPCwill be of the form IvP, so that to satisfy PCwe want to .nd a smallest possible substitution; see \nlemma 4.18. Since the previous lemma establishes that TCimposes a system of lower bounds on set vari\u00adables, \nthe problem of satisfying PC,TCreduces to one of .nding the glb of set variables pgiven TC, and then \nchecking these bounds against the constraints imposed by PC. The function glbde.ned in .gure 7 solves \nthis problem, so the heart of the correctness proof of isectyexamines its de.nition. More precisely, \nwe analyze glbby way of the more general function mtTPCde.ned in .gure 8, which has features more amenable \nto our proof. The essential steps in our proof use the functional operator MT given in .gure 8; MTis \nde.ned in an environment with TPC bound to scs(close(TC))where TCis returned by isecty.In particular, \nwe demonstrate that any .xpoint of MTis a solution to the problem of .nding a satisfying substitution \nfor TPC(lemma 4.11), and then show that mtTPCis a least .xpoint of MT(lemma 4.15). Our technique is inspired \nby the notion of an inductive def\u00adinitions as described in [10], but is quite simple and requires none \nof the deeper theoretical results from that paper. LEMMA 4.11. If fis a .xpoint of MT, there exists a \nsubstition Sthat satis.es TPCsuch that f=bSc. PROOF. Let fbe such that MT(f)=f; then it is easy to show \nthat the .rst three clauses of MTensure that there exists Ssuch that bSc=f. And, by the fourth clause \nof MTit is the case that [ S(Ii)]][ S(p)]]for all pand Iivp2TPC, so that Ssatis.es TPCby lemma 4.9 and \nde.nition 3.4. Now we need to show that mtTPCis a .xpoint of MT. The biggest issue to be dealt with here \nregards cycles in TPC. The following lemma establishes that if a recursive occurence of any p is encountered, \nwe may substitute any value Pfor pat this point in computation, and the top-level evaluation grows monotonically \nin P. LEMMA 4.12. Let mtTPC(rr,S0fP/pg)I=P1and mtTPC (rr,S0fP[P0/pg)I=P2; then P1.P2.P1[P0 . PROOF. By \ninduction on the call tree of mtTPC(rr,S0fP/pg) I. COROLLARY 4.13. If S1:S2and bS10 c=mtTPC(,S1)and bS20 \nc=mtTPC(,S2), then S10:S20 . At this point we demonstrate the following lemma, which is es\u00adsential for \nproving that mtTPCis a .xpoint of MT: LEMMA 4.14. Let rr 0 =rr;fpg, P1=mtTPC(rr,S)I and P2=mtTPC(rr 0 \n,S)I, and let P=mtTPC(rr 0 ,S)p; then P1.P2.P1[P. PROOF. By induction on the call tree of mtTPC(rr,S)I. \nmt Having established the previous results, it is easy to prove that TPCis a .xpoint of MT: mt LEMMA \n4.15. Let S. =f/pjp2Vars(TPC[PC)g. Then TPC(,S.)is a .xpoint of MT. PROOF. The proof proceeds by case \nanalysis of arbitrary I.In case that I=P, I1tI2or I0P, the lemma follows imme\u00addiately by the de.nitions \nof mtTPCand MT. Suppose on the other hand that I=p; then by the de.nition of MT: [ MTmtTPC(,S.)p=mtTPC(,S.)Ii \nIiv2TPC and since S.(p)=, therefore by the de.nition of mtTPC: [ mt TPC(,S.)p=mtTPC(fpg,S.)Ii Iiv2TPC \nNow, for each Iilet Pi =mtTPC(,S.)Ii, let Pi 0 =mtTPC (fpg,S.)Ii, and let P=[iPiand P0 =[iPi0 . By lemma \n4.14, Pi0.Pi.Pi0[P0for each i, so that P0.P.P0, i.e. P0 =P. Therefore, the lemma follows. The following \nlemma implies that mtTPCis a least .xpoint of MT, as explicated in lemma 4.17: LEMMA 4.16. If Ssatis.es \nTPC, then mtTPC(,S)=bSc. PROOF. The proof proceeds by the claim that for all Iand rrit is the case that \nmtTPC(rr,S)I=[[S(I)]], which follows by in\u00adduction on the call tree of mtTPC(rr,S)I. Here we demonstrate \nonly the case (I=p2rr). In this case, mtTPC(rr,S)I= S (mtTPC(rr[fpg,S)Pi)[S(p)over all Iivp2TPC. But \ni by the induction hypothesis, mtTPC(rr[fpg,S)Pi =[[S(Ii)]]; and since Ssatis.es TPCby assumption, therefore \n[ S(Ii)]] [ S(p)]]for each Ii, so the lemma holds. Finally, we can show that mtTPC, given the appropriate \nargu\u00adments, generates the glb of the privstructs in TPC: LEMMA 4.17. There exists Ssuch that bSc=mtTPC(,S.), \nand also Sis the least substitution that satis.es TPC. mt PROOF. Bylemmas4.11and4.15,thereexists Ssuch \nthat bSc= TPC(,S.)which satis.es TPC. Furthermore, suppose some S0satis.es TPC. By lemma 4.16, bS0 c=mtTPC(,S0), \nand by corrolary 4.13, S:S0, since clearly S.:S0 . Therefore, the lemma holds. The following lemma implies \nthat if PC,TCis satis.able, then the glb of TCmust satisfy PC,TC: LEMMA 4.18. If Ssatis.es PCand S0:S, \nthen S0satis.es PC. PROOF. By the de.nition of isecty, each constraint in PCis of the form IvP. Thus, \nif Ssatis.es PC, then [ S(I)]].Pfor each constraint in PC, so clearly if S0:Sthen [ S0(I)]].Pfor each \nconstraint, by transitivity of . Now we piece the preceding lemmas together to establish the correctness \nresult for satisfy, and then the correctness result for type inference: PROOF OF THEOREM 4.8 (CORRECTNESS \nOF satisfy) By def\u00adinition of the algorithms, glb(I,)=mtTPC(,S.)Iwith glb executing in an environment \ncontaining TPC. Thus, the result fol\u00adlows by the de.nition of satisfyand lemmas 4.17 and 4.18. PROOF \nOF THEOREM 4.4 (CORRECTNESS OF infersecty) Im\u00admediate by the de.nition of infersecty, de.nition 3.4, \nlemmas 4.6 and 4.7 and theorem 4.8.  5. RELATED WORK The use of static type systems to enforce or check \nsecurity prop\u00aderties is a research area that has recently blossomed. None of the existing work applies \nto the context of .ne-grained access con\u00adtrol, as this paper does, but it shows that type-based techniques \nare emerging as a new methodology for securing information systems. Type systems for analyzing the security \nlevel of data via informa\u00adtion .ow have been developed [13, 11, 8], which are based on the earlier static \nanalysis of [4]. This work is using a fundamentally different security model, the information .ow model. \nThe static in\u00adformation .ow model of data security is derived from the classic Bell-LaPadula security \nmodel [2] which is a dynamic information .ow model that ignores covert channels. Our proposed type system \nis analogous in that it is a static version of a dynamic model. Another approach, related to the type \napproach, is proof-carrying code (PCC) [12]. In this paradigm, code is passed on the network along with \na formal proof of a property of the code; the proof can then be mechanically checked at the server to \nverify that the prop\u00aderty holds of the code. Type systems in this certi.ed code frame\u00adwork can be viewed \nas compressed proofs from the types it is possible to construct a typing proof, and program properties \nare implied by the proof. Walker in [14] has developed another sort of secure certi.ed code, by describing \nsecurity automata which can specify and enforce highly expressive security policies. How\u00adever, certi.ed \ncode is in fact more general than our type-based approach note that we focus on properties that can be \ninferred, whereas certi.ed code approaches are often concerned with more complex ones. Our type system \ndesign was inspired by Crary, Walker and Mor\u00adrisett s static type system for memory region inference \n[3]. They share the commonality of addressing stack-based properties which are traditionally computed \nat run-time. Their paper does not use constraints or inference and instead de.nes an explicitly-typed \nsys\u00adtem, an approach we also expect would work in this setting. 6. CONCLUSION AND FUTURE WORK In this \npaper we have de.ned a type system which statically enforces security in a model of the Java JDK 1.2 \nsecurity archi\u00adtecture. In the JDK, these properties are enforced by a dynamic stack inspection process. \nBut the dynamic nature of stack inspec\u00adtion has several drawbacks, including the presence of a new class \nof run-time errors, a performance penalty, and lack of code readabil\u00adity due to the non-declarative nature \nof dynamic checks in code. A static, type-based approach eliminates these problems. Further\u00admore, the \noutermost types of functions or methods re.ect their top\u00adlevel needs, the privileges they need to execute. \nThis means that security types are helpful in declaring the security policies of pro\u00adgrams, since security \nrequirements can be placed directly in the type signature. We have proven a type safety result for our \nsystem, demonstrat\u00ading that security types guarantee soundness with respect to stack inspection: run-time \nstack inspection will never fail on well-typed programs. Additionally, we have de.ned a type inference \nalgo\u00adrithm, meaning that the programmer need not explicitly declare se\u00adcurity types. Our type inference \nalgorithm is similar in function and complexity to standard constraint type inference algorithms. We \nhave also proven our type inference algorithm correct, showing that it returns a most general type for \nany expression. In this paper we have focused directly on the Java stack inspec\u00adtion model, as a well-understood \npoint of departure. We have shown that a realistic model can be captured in a statically-typed frame\u00adwork. \nAs future work, we intend to explore extensions to our sys\u00adtem, including a security model which may \nimprove on the JDK 1.2 model. In addition to simply adding more sophisticated features to the type system \n(e.g. polymorphism as discussed in subsection 3.5), we hope to develop a realistic language and type \nsystem to express, and enforce, the most effective security policies. Acknowledgements We would like \nto acknowledge Karl Crary for helpful discussions and Franc\u00b8ois Pottier, Ran Rinat, and the ICFP referees \nfor helpful comments on drafts of this paper. 7. REFERENCES [1] A. Aiken and E. L. Wimmers. Type inclusion \nconstraints and type inference.z In Proceedings of the International Conference on Functional Programming \nLanguages and Computer Architecture, pages 31 41, 1993. [2] D. E. Bell and L. J. LaPadula. Secure computer \nsystems: Mathematical foundations and model. Technical Report M74-244, The MITRE Corp., Bedford MA, May \n1973. [3] K. Crary, D. Walker, and G. Morrisett. Typed memory management in a calculus of capabilities. \nIn Conference Record of the Twenty-sixth Annual ACM Symposium on Principles of Programming Languages, \nACM SIGPLAN Notices. ACM Press, 1999. [4] D. Denning. A lattice model of secure information .ow. In \nCommunications of the ACM, pages 236 243. ACM, May 1976. [5] J. Eifrig, S. Smith, and V. Trifonov. Type \ninference for recursively constrained types and its application to OOP. In Proceedings of the 1995 Mathematical \nFoundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer \nScience. Elsevier, 1995. http://www.elsevier.nl/locate/entcs/volume1.html. [6] L. Gong. Java Security \nArchitecture (JDK1.2) . http://java.sun.com/products/jdk/1.2/docs/guide/security/spec/ security-spec.doc.html, \n1998. [7] L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers. Going beyond the sandbox: An overview \nof the new security architecture in the Java Development Kit 1.2. In USENIX Symposium on Internet Technologies \nand Systems, pages 103 112, Monterey, CA, Dec. 1997. [8] N. Heintze and J. G. Riecke. The SLam calculus: \nProgramming with secrecy and integrity. In Conference Record of POPL 98: The 25TH ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, San Diego, California, pages 365 377, New York, N.Y., \nJan. 1998. ACM. [9] F. Henglein. Syntactic properties of polymorphic subtyping. TOPPS Technical Report \n(D-report series) D-293, DIKU, University of Copenhagen, Universitetsparken 1, DK-2100 Copenhagen, Denmark, \nMay 1996. [10] A. S. Kechris and Y. N. Moschovakis. Recursion in higher types. In J. Barwise, editor, \nHandbook of Mathematical Logic, volume 90 of Studies in Logic and the Foundation of Mathematics, chapter \nC.6, pages 681 737. North-Holland Publishing Company, 1977. [11] X. Leroy and F. Rouaix. Security properties \nof typed applets. In ACM, editor, Conference record of POPL 98: the 25th ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages: papers presented at the Symposium, San Diego, California, 19 \n21 January 1998, pages 391 403, New York, NY 10036, USA, 1998. ACM Press. [12] G. C. Necula and P. Lee. \nSafe kernel extensions without run-time checking. In USENIX, editor, 2nd Symposium on Operating Systems \nDesign and Implementation (OSDI 96), October 28 31, 1996. Seattle, WA, pages 229 243, Berkeley, CA, USA, \nOct. 1996. USENIX. [13] D. Volpano, G. Smith, and C. Irvine. A sound type system for secure .ow analysis. \nJournal of Computer Security, 4(3):167 187, Dec. 1996. [14] D. Walker. A type system for expressive security \npolicies. In Twenty-seventh Symposium on Principles of Programming Languages, pages 254 267, Boston, \nMA, January 2000. ACM SIGPLAN. [15] D. S. Wallach. A new Approach to Mobile Code Security. PhD thesis, \nPrinceton University, 1999. \n\t\t\t", "proc_id": "351240", "abstract": "A number of security systems for programming languages have recently appeared, including systems for enforcing some form of <i>access control</i>. The Java JDK 1.2 security architecture is one such system that is widely studied and used. While the architecture has many appealing features, access control checks are all implemented via dynamic method calls. This is a highly non-declarative form of specification which is hard to read, and which leads to additional run-time overhead. In this paper, we present a novel <i>security type system</i> that enforces the same security guarantees as Java Stack Inspection, but via a static type system with no additional run-time checks. The system allows security properties of programs to be clearly expressed within the types themselves. We also define and prove correct an inference algorithm for security types, meaning that the system has the potential to be layered on top of the existing Java architecture, without requiring new syntax.", "authors": [{"name": "Christian Skalka", "author_profile_id": "81100662052", "affiliation": "The Johns Hopkins University", "person_id": "PP14227255", "email_address": "", "orcid_id": ""}, {"name": "Scott Smith", "author_profile_id": "81381593469", "affiliation": "The Johns Hopkins University", "person_id": "PP39079149", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351244", "year": "2000", "article_id": "351244", "conference": "ICFP", "title": "Static enforcement of security with types", "url": "http://dl.acm.org/citation.cfm?id=351244"}