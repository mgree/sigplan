{"article_publication_date": "09-01-2000", "fulltext": "\n ICFP 00, Montr\u00e9al, Canada. Copyright 2000 A C M 1-58113-202-6/00/0009 $5.00. Finally, in polymorphic \nlanguages like ML, the type of a value may not be known statically; therefore, compilers have traditionally \nused inef.cient, uniformly boxed data represen\u00adtation. To avoid this, several modern compilers [23, 19, \n25] use runtime type information to support unboxed data repre\u00adsentation. When compiling code which uses \nruntime type inspections, most existing compilers use untyped intermediate languages, and reify runtime \ntypes into values at some early stage. However, discarding type information during compilation puts this \napproach at a serious disadvantage when it comes to generating certi.ed code [13]. Code certi.cation \nis appealing for a number of reasons. One need not trust the correctness of a compiler generating certi.ed \ncode; instead, one can verify the correctness of the generated code. Checking the correctness of a compiler-generated \nproof (of a pro\u00adgram property) is much easier than proving the correctness of the compiler. Secondly, \nwith the growth of web-based computing, pro\u00adgrams are increasingly being developed at remote sites and \nshipped to clients for execution. Client programs may also download mod\u00adules dynamically as they need \nthem. For such a system to be prac\u00adtical, a client should be able to accept code from untrusted sources, \nbut have a means of verifying it before execution. This again re\u00adquires compilers that generate certi.ed \ncode. A necessary step in building a certifying compiler is to have the compiler generate code that can \nbe type-checked before execution. The type system ensures that the code accesses only the provided resources, \nmakes legal function calls, etc. A certifying compiler can support runtime type analysis only in a typed \nframework. The safety of such a system depends not only on the downloaded code, but also on the correctness \nof all the code that is executed by the system after type checking. This typically includes the runtime \nservices like garbage collection, linking, etc. This code constitutes the trusted computing base of the \nsystem. Reducing the trusted computing base makes the system more reliable; for this, we must independently \nverify the correctness of this code. This implies that as many of the runtime services as possible should \nbe written in a type-safe language, which requires support for runtime type analy\u00adsis in a typed framework. \nFinally, why is it important to have fully re.exive type analy\u00adsis? Why do we want to analyze quanti.ed \ntypes? Many type\u00adanalyzing applications mentioned above must handle arbitrary run\u00adtime values. For example, \na pickler must be able to pickle any value, including closures (which have existential types), polymor\u00adphic \nfunctions, or recursive data structures. A garbage collector has to be able to traverse all data structures \nin the heap to track live ob\u00adjects. Therefore the language must support type analysis over any runtime \nvalue in the language. 2.1 Background Harper and Morrisett [8] proposed intensional type analysis and \npresented a type-theoretic framework for expressing computations that analyze types at runtime. They \nintroduced two explicit type\u00adanalysis operators: one at the term level (typecase) and another at the \ntype level (Typerec); both use induction over the structure of types. Type-dependent primitive functions \nuse these operators to analyze types and select the appropriate code. For example, a polymorphic subscript \nfunction for arrays might be written as the following pseudo-code: sub =.a. typecase a of int .intsub \nreal .realsub \u00df .boxedsub [\u00df] (kinds) . ::= . |. ... (cons) t ::= int |t .t . |a |.a : .. t |tt . | Typerec \nt of (tint; t.) (types) s ::= t |.a : .. s Figure 1: The type language of Harper and Morrisett Here \nsub analyzes the type a of the array elements and returns the appropriate subscript function. We assume \nthat arrays of type int and real have specialized representations (de.ned by types, say, intarray and \nrealarray), and therefore special subscript functions, while all other arrays use the default boxed representation. \nTyping this subscript function is more interesting, because it must have all of the types intarray .int \n.int, realarray . int .real, and .a. boxedarray (a) .int .a. To assign a type to the subscript function, \nwe need a construct at the type level that parallels the typecase analysis at the term level. In general, \nthis facility is crucial since many type-analyzing operations like .atten\u00ading and marshalling transform \ntypes in a non-uniform way. The subscript operation would then be typed as sub : .a. Array (a) .int .a \nwhere Array = .a. Typecase a of int .intarray real .realarray \u00df .boxedarray \u00df The Typecase construct \nin the above example is a special case of the Typerec construct in [8], which also supports primitive \nrecur\u00adsion over types. 2.2 The problem The language of Harper and Morrisett only allows the analysis \nof monotypes; it does not support analysis of types with binding struc\u00adture (e.g., polymorphic, existential \nor recursive types). Therefore, type analyzing primitives that handle polymorphic code blocks, closures \n(since closures are represented as existentials [11]), or re\u00adcursive structures, cannot be written in \ntheir language. The types in their language (in essence shown in Figure 1) are separated into two universes, \nconstructors and types. The constructor calculus is a simply typed lambda calculus, with no polymorphic \ntypes. The Typerec operator analyzes only constructors of base kind .: int :. . :. .. .. The kinds of \nthese constructors arguments do not contain any neg\u00adative occurrence of the kind .,so int and .can be \nused to de.ne . inductively. The Typerec operator is essentially an iterator over this inductive de.nition; \nits reduction rules can be written as: Typerec int of (tint; t.) . tint Typerec (t1 .t2) of (tint; t.) \n. t. t1 t2 (Typerec t1 of (tint; t.)) (Typerec t2 of (tint; t.)) Here the Typerec operator examines the \nhead constructor of the type being analyzed and chooses a branch accordingly. If the type is int, it \nreduces to the tint branch. If the type is t1 .t2, the analysis proceeds recursively on the subtypes \nt1 and t2. The Typerec op\u00aderator then applies the t. branch to the original component types, and to the \nresult of analyzing the components; thus providing a form of primitive recursion. Types with binding \nstructure can be constructed using higher\u00adorder abstract syntax. For example, the polymorphic type con\u00adstructor \n. can be given the kind (. . .) . ., so that the type .a:..a . ais represented as . (.a:..a. a). It would \nseem plausible to de.ne an iterator with the reduction rule: Typerec (. t) of (tint; t.; t.) . t. t (.a:..Typerec \ntaof (tint; t.; t.)) However the negative occurrence of . in the kind of the argument of . poses a problem: \nthis iterator may fail to terminate! Consider the following example, assuming t = .a:..a and t. = .\u00df1 \n:. . ...\u00df2 :. . ..\u00df2 (. \u00df1) the following reduction sequence will go on inde.nitely: Typerec (. t) of \n(tint; t. ; t.) . t. t (.a:..Typerec taof (tint; t.; t.)) . Typerec (t(. t)) of (tint; t.; t.) . Typerec \n(. t) of (tint; t. ; t.) . ...  Clearly this makes typechecking Typerec undecidable. Another serious \nproblem in analyzing quanti.ed types involves both the type-level and the term-level operators. Typed \ninterme\u00addiate languages like FLINT [20] and TIL [24] are based on the calculus F. [5, 17], which has \nhigher order type constructors. In a quanti.ed type, say .a:..t, the quanti.ed variable ais no longer \nrestricted to a base kind ., but can have an arbitrary kind .. Con\u00adsider the term-level typecase in such \na scenario: sub =.a.typecase aof int . eint ... .a:..t . e. To do anything useful in the e. branch, even \nto open a package of this type, we need to know the kind .. We can get around this by having an in.nite \nnumber of branches in the typecase, one for each kind; or by restricting type analysis to a .nite set \nof kinds. Both of these approaches are clearly impractical. Recent work on typed compilation of ML and \nJava has shown that both would require an F.-like calculus with arbitrarily complex kinds [21, 22, 9]. \n 2.3 Requirements for a solution Before we discuss our solution, let us look at the properties we want \nit to have. First, our language must support type analysis in the manner of Harper/Morrisett. That is, \nwe want to include type analysis prim\u00aditives that will analyze the entire syntax tree representing a \ntype. Second, we want the analysis to continue inside the body of a quan\u00adti.ed type; handling quanti.ed \ntypes parametrically, or in a uniform way by providing a default case, is insuf.cient. As we will see \nlater, many interesting type-directed operations require these two prop\u00aderties. Third, we do not want \nto restrict the kind of the (quanti.ed) type variable in a quanti.ed type; we want to analyze types where \nthe quanti.cation is over a variable of arbitrary kind. Consider a type-directed pickler that converts \na value of arbitrary type into an external representation. Suppose we want to pickle a closure. With \na type-preserving compiler, the type of a closure would be represented as an existential with the environment \nheld abstract. Even if the code is handled uniformly, the function must inspect the type of the environment \n(which is also the witness type of the existential package) to pickle it. This shows that at the term \nlevel, the analysis must proceed inside a quanti.ed type. In Sec\u00adtion 3.2, we show the encoding of a \npolymorphic equality function in our calculus; the comparison of existential values requires a sim\u00adilar \ntechnique. The reason for not restricting the quanti.ed type variable to a .nite set of kinds is twofold. \nRestricting type analysis to a .nite number of kinds would be ad hoc and there is no way of satisfacto\u00adrily \npredetermining this .nite set (this is even more the case when we compile Java into a typed intermediate \nlanguage [9]). More importantly, if the kind of the bound variable is a known constant in the corresponding \nbranch of the Typerec construct, it is easy to generalize the non-termination example of the previous \nsection and break the decidability of the type system. 2.4 Our solution The key problem in analyzing \nquanti.ed types such as the poly\u00admorphic type .a:..a . a is to determine what happens when the iteration \nreaches the quanti.ed type variable a, or (in the gen\u00aderal case of type variables of higher kinds) a \nnormal form which is an application with a type variable in the head. One approach would be to leave \nthe type variable untouched while analyzing the body of the quanti.ed type. The equational theory of \nthe type language then includes a reduction of the form (Typerec a of ...) . a so that the iterator vanishes \nwhen it reaches a type variable. However this would break the con.uence of the type language the application \nof .a:..Typerec aof ... to t would reduce in general to different types if we perform the \u00df-reduction \nstep .rst or eliminate the iterator .rst. Crary and Weirich [1] propose another method for solving this \nproblem. Their language LX allows the representation of terms with bound variables using deBruijn notation \nand an encoding of natural numbers as types. To analyze quanti.ed types, the iterator carries an environment \nmapping indices to types; when the iterator reaches a type variable, it returns the corresponding type \nfrom the environment. This method has several disadvantages. It is not fully re.exive, since it does \nnot allow analysis of all quanti.ed types their analysis is restricted to types with quanti.cation only \nover variables of kind ..  The technique is limited to parametrically polymorphic functions, and cannot \naccount for functions that perform in\u00adtensional type analysis [1, Section 4.1]. For example poly\u00admorphic \ntypes such as .a:..Typerec aof ...are not ana\u00adlyzable in their framework.  The correctness of the structure \nof a type encoded using de-Bruijn notation cannot be veri.ed by the kind language (in\u00addices not corresponding \nto bound variables go undetected, so the environment must provide a default type for them), which does \nnot break the type soundness but opens the door for programmer mistakes.  To account for non-parametrically \npolymorphic functions, we must analyze the quanti.ed type variable. Moreover, we want to have con.uence \nof the type language, so \u00df-reduction should be transparent to the iterator. This is possible only if \nthe analysis gets suspended when it reaches a type variable, or its application, of kind ., and resumes \nwhen the variable gets substituted. Therefore, we consider (Typerec aof ...)to be a normal form. For \nexample, the result of analyzing the body (a. int) of the polymorphic type .a:..a. int is Typerec (a \n. int) of (tint; t.; t.) . t. aint (Typerec aof (tint; t.; t.))(tint) We formalize the analysis of quanti.ed \ntypes when we present the (kinds) . ::= . |. ..' |. |... . type reduction rules of the Typerec construct \n(Figure 5). The other problem is to analyze quanti.ed types when the quan\u00ad (types) t .|.. + ::= int |..|. \n ti.ed variable can be of an arbitrary kind. In our language the so\u00ad | a |... t |.a : .. t |t [.] |tt \n' lution is similar at both the type and the term levels: we use kind | Typerec[.] t of (tint; t.; t.; \nt+) polymorphism! We introduce kind abstractions at the type level .(... t ) and at the term level (. \n+ .. e) to bind the kind of the quan\u00ad (values) v ::= i |. + .. e |.a : .. e |.x : t. e |.x x : t. v ti.ed \nvariable. (See Section 3 for details.) Kind polymorphism also ensures the termination of the Typerec \n+ ' (terms) e ::= v |x |e [.] |e [t ] |ee constructor. Consider again the analysis of the polymorphic \ntype: | typecase[t ] t ' of (eint; e.; e.; e+) . Typerec (. t ) of (tint; t.; t.) Figure 2: Syntax of \nthe . Pi language . t. t (.a :.. Typerec ta of (tint; t.; t.)) Informally, we must ensure that the type \nbeing analyzed decreases in size at every iteration. That is ta is smaller than . t . (Note that t .t \n' =((. ) t ) t ' the previous non-terminating example violates this requirement). This will be true \nif we can ensure that a is always substituted by a .a : .. t =(. [.]) (.a : .. t ) . + .. t =.. + (... \nt ) single variable. Therefore, we make the kind of a abstract by using kind polymorphism; a now has \nthe kind bound in the t. branch. The only way to construct another type of this kind is to bind a type \nvariable of the same kind in the t. branch. This ensures that a can only be substituted by another type \nvariable. It is important to note that our language provides no facilities for Pi  Figure 3: Syntactic \nsugar for .types following environments:kind analysis. Analyzing the kind . of the bound variable a \nin the type . (.a : .. t ) would let us synthesize a type argument of the kind environment E ::= e |E,. \nsame kind, for every kind .. The synthesized type can then be used type environment . ::= in the style \nof the non-termination example of the previous section. e |.,a :. term environment G ::= e |G,x : t \nIntuitively, we would not be able to guarantee that the type being analyzed decreases at every step. \nThe Typerec operator analyzes polymorphic types with bound vari\u00adables of arbitrary kind. The corresponding \nbranch of the operator The rest of the paper is organized as follows. Section 3 describes must bind the \nkind of the quanti.ed type variable; for that purpose the language provides kind abstraction (... t ) \nand kind application (t [.]) at the type level. The formation rules for these constructs, the language \n. Qi tial types. Section 4 presents the language .support for analysis of recursive types. In the companion \ntechnical Pi supporting analysis of polymorphic and existen\u00ad that also includes report [18] we also \nshow a translation into a language with type erasure semantics [2].  3. ANALYZING POLYMORPHIC TYPES \nIn the impredicative F. calculus, the polymorphic types .a:.. t can be viewed as generated by an in.nite \nset of type constructors .. of kind (. ..) .., one for each kind .. The type .a : .. t is then represented \nas .. (.a : .. t ). The kinds of constructors that can generate types of kind . then would be int :. \n. :. .. .. .. :(. ..) .. ... excerpted from Figure 4, are E,.;. ft : . E;. ft : ... . Ef.' E;. f... t \n: ... . E;. ft [.']: .{/.} .' Similarly, while analyzing a polymorphic type, the term-level con\u00adstruct \ntypecase must bind the kind of the quanti.ed type variable. Therefore, we introduce kind abstraction \n(. + .. e) and kind appli\u00ad cation (e [.] + ) at the term level. To type the term-level kind abstrac\u00adtion, \nwe need a type construct . + .. t that binds the kind variable . in the type t . The formation rules \nare shown below. E,.;.;G fv : t E;.; G fe : . + .. t Ef. ++ + E;.; G f. .. v : ... t E;.; G fe [.]: t \n{./.} :(. ..) .. However, since our goal is fully re.exive type analysis, we need . . ... We can avoid \nthe in.nite number of .. constructors by de.ning a single constructor . of polymorphic kind ... (. ..) \n.. and then instantiating it to a speci.c kind before forming polymorphic types. More importantly, this \ntechnique also removes the negative occurrence of . from the kind of the argument of the constructor \nto analyze kind-polymorphic types as well. As with polymorphic types, we can represent the type . + .. \nt as the application of a type constructor . + of kind (... .) .. to a kind abstraction ... t . Thus \nthe kinds of the constructors for types of kind . are int :. . :. .. .. Pi Hence in our .kinds and add \na type constant . of kind ... (. ..) .. to the + calculus we extend F. with polymorphic ... . : ... (. \n..) .. . :(... .) .. type language. The polymorphic type .a : .. t is now represented as . [.](.a:.. \nt ). None of these constructors arguments have the kind . in a negative calculus in Figure 2, and some \n Pi Pi We de.ne the syntax of the . derived forms of types in Figure 3. The static semantics of . shown \nin Figures 4 and 5 as a set of rules for judgments using the over this kind. The formation rule for Typerec \nfollows naturally position; hence the kind . can now be de.ned inductively in terms is of these constructors. \nThe Typerec construct is then the iterator Kind formation Ef. Term formation E;.;G fe : t . .E Ef. Ef. \n' E,. f. E;.;G fe : t E;. ft . t ' :. E;. fG Ef. Ef. Ef. .. ' Ef... . E;.;G fe : t ' E;.;G fi : int E,.;.;G \nfv : t Type environment formation Ef. E;. fG x:t in G E;.;G fx : t E;.;G f. + .. v : . + .. t Ef. Ef. \nEfe Ef.,a:. ' E;.,a:.;G fv : t E;.;G,x:t fe : t E;.;G f.a:.. v : .a:..t E;.;G f.x:t.e : t .t ' Type formation \nE;. ft : . E;.;G,x:t fv : t Ef. + t = ..1 ....n. .a1 :.1 ...am :.m :t1 .t2. E;. fint :. n =0,m =0 Ef. \na:. in . E;. f(. ): . .. .. E;. f.. : ... (. ..) .. E;. fa : .  E;.;G f.x x:t.v : t E;. f.. + :(... \n.) .. + E;.;G fe : . t Ef. E,.;. ft : . E;. ft : .... Ef. ' + E;.;G fe [.]: t [.] E;. f... t : ... \n. E;. ft [. ' ]: .{/.} . ' E;.;G fe : . [.]t E;. ft ' : . E;.,a:. ft : . ' E;. ft : . ' .. E;. ft ' \n: . ' '' E;.;G fe[t ]: tt E;. f.a:.. t : . .. ' E;. ftt ' : . ' '' E;.;G fe : t .t E;.;G fe : t E;. \nft :. ' E;.;G fee : t E;. ftint : . E;. ft. :. .. .. .. .. E;. ft :. .. E;. ft. : ... (. ..) .(. ..) \n.. E;. ft ' :. E;. ft+ :(....) .(... .) .. .E;.;G feint : t int E;. fTyperec[.] t of (tint; t.; t.; \nt.+): . E;.;G fe. : .a:.. .:..t (a .a ' ) a ' E;.;G fe. : . + .. .a:. ...t (. [.]a) Term environment \nformation E;. fG + E;.;G fe+ : .a:(....).t (. a) . Ef. E;. fG E;. ft :. E;.;G ftypecase[t] t ' of (eint; \ne.; e.; e+): tt ' . E;. fe E;. fG,x:t Figure 4: Formation rules of .Pi Type reduction E;. ft1 . t2 : \n. E;.,a:. ' ft : . E;. ft ' : . ' E;. f(.a:. ' .t)t ' . t{t ' /a}: . E,.;. ft : ... . Ef. ' . ' . ' \nE;. ft : . .. ' a/.ftv(t) E;. f.a:..t a . t : . .. ' E;. ft : .. ' .. ./.fkv(t) E;. f(... t)[. ' ] . \nt{/.}: .{/.} E;. fTyperec[.]int of (tint; t.; t.; t+): . . E;. fTyperec[.]int of (tint; t.; t.; t+) \n. tint : . . E;. fTyperec[.] t1 of (tint; t.; t.; t+) . t1 ' : . E;. fTyperec[.] t2 of (tint; t.; t.; \nt.+) . t2 ' : . . E;. fTyperec[.] ((. )t1 t2)of (tint; t.; t.; t.+) . t. t1 t2 t1 ' t2 ' : . E;.,a:. \n' fTyperec[.] (ta)of (tint; t.; t.; t.+) . t ' : . E;. fTyperec[.] (. [. ' ]t)of (tint; t.; t.; t+) ' \n . t. [. ' ]t (.a:. ' .t ): . .E,.;. fTyperec[.] (t [.])of (tint; t.; t.; t+) . t ' : . . . ' +E;. f... \nt [.] . t : ... E;. fTyperec[.] (. t)of (tint; t.; t.; t.+) . t.+ t (... t ' ): . Figure 5: Selected \n.Pi type reduction rules from the type reduction rules (Figure 5). Depending on the head constructor \nof the type being analyzed, Typerec chooses one of the branches. At the int type, it returns the tint \nbranch. At the function type t .t ' , it applies the t. branch to the components t and t ' and to the \nresult of the iteration over t and t ' . When analyzing a polymorphic type, the reduction rule is Typerec[.] \n(.a :. ' .t ) of (tint; t.; t.; t.+) . t. [. ' ](.a :. ' .t )(.a :. ' . Typerec[.] t of (tint; t.; t.; \nt.+)) Thus the .-branch of Typerec receives as arguments the kind of the bound variable, the abstraction \nrepresenting the quanti.ed type, and a type function encapsulating the result of the iteration on the \nbody of the quanti.ed type. Since t. must be parametric in the kind . ' (there are no facilities for \nkind analysis in the language), it can only apply its second and third arguments to locally introduced \ntype variables of kind . ' . We believe this restriction, which is crucial for preserving strong normalization \nof the type language, is quite reasonable in practice. For instance t. can yield a quanti.ed type based \non the result of the iteration. The reduction rule for analyzing a kind-polymorphic type is + (.x :t. \ne)v . e{v/x} (.x x :t. v)v ' . (v{.x x :t. v/x})v ' (.a :.. v)[t ]. v{t/a} (.x x :t. v)[t ]. (v{.x x \n:t. v/x})[t ] ++ ++ (. .. v)[.] . v{./.}(.x x :t. v)[.] . (v{.x x :t. v/x})[.] ''' e . e e . ee . ee \n. e ' ''' ' ee1 . ee1 ve . ve e[t ] . e [t ] e[.] + . e [.] + typecase[t ]int of (eint; e.; e.; e+) . \neint . typecase[t ] (t1 .t2) of (eint; e.; e.; e+) . e. [t1][t2] . typecase[t ] (. [.]t ) of (eint; e.; \ne.; e+) . e. [.] + [t ] . typecase[t ] (. + t ) of (eint; e.; e.; e+) . e+ [t ] ..'' ' e;e ft . * . :. \n. is a normal form typecase[t ] t ' of (eint; e.; e.; e.+) . typecase[t ] . ' of (eint; e.; e.; e+) . \nTyperec[.] (... t ) of (tint; t.; t.; t+) . .Figure 6: Operational semantics of . t+ (... t )(... Typerec[.] \nt of (tint; t.; t.; t+)) ..The arguments of the t.+ are the kind abstraction underlying the kind-polymorphic \ntype and a kind abstraction encapsulating the re- Pi The property is enforced even on hidden types in \nan existentiallysult of the iteration on the body of the quanti.ed type. For ease of presentation, we \nwill use ML-style pattern matching typed package by the reduction rule for Typerec which suspends its \naction on normal forms with variable head. For instance a term syntax to de.ne a type involving Typerec. \nInstead of t = .a :.. Typerec[.] a of (tint; t.; t.; t+) ' where t. = .a1 :...a2 :...a ' 1 :.. .a2 '.:.. \nt. t. =... .a :. ....a ' :. ... t.' t.+ = .a :(... .)..a ' :(... .).t .' + we will write t (int)= tint \n' t (a1 .a2)= t.{t (a1),t (a2)/a1' ,a2' }t (. [.]a1)= t.' {.a :.. t (a1 a)/a ' }' t (. + a1)= t +{... \nt (a1 [.])/a ' } . To illustrate the type-level analysis we will use the Typerec opera\u00adtor to de.ne the \nclass of types admitting equality comparisons. To make the example non-trivial we extend the language \nwith a prod\u00aduct type constructor \u00d7 of the same kind as . , and with existential e can only be given type \nEq (.a :..a \u00d7a)= .a :.. Eq a \u00d7Eq a if it can be shown that e is a pair of terms of type Eq t for some \nt , i.e., terms of equality type. Note that Eq ((Bool .Bool)\u00d7 (Bool .Bool)) reduces to (Void \u00d7Void); \na more complicated de.nition is necessary to map this type to Void. At the term level type analysis is \ncarried out by the typecase construct; however, it is not iterative since the term language has a recursion \nprimitive, .x. The e. branch of typecase binds the kind and the type abstraction carried by the type \nconstructor . , while the e.+ branch binds the kind abstraction carried by . + . typecase[t ] (. [.]t \n' ) of (eint; e.; e.; e.+) . e. [.] + [t ' ] '' typecase[t ] (. + t ) of (eint; e.; e.; e+) . e+ [t ] \n.. types with type constructor . of kind identical to that of . , writing Pi Pi The operational semantics \nof the term language of . .a :.. t for . [.](.a:.. t ). Correspondingly we extend Typerec in Figure 6. \nwith a product branch t\u00d7 and an existential branch t. which be- The language . is presented has the following \nimportant properties (for de\u00adhave in exactly the same way as the t. branch and the t. branch tailed proofs \nwe refer the reader to the companion technical re\u00adrespectively. We will use Bool instead of int. port \n[18]). THEOREM 3.1. Reduction of well-formed types is strongly nor\u00ad malizing. We prove strong normalization \nof the type language following A polymorphic function eq comparing two objects for equality is not de.ned \non values of function or polymorphic types. We can enforce this restriction statically if we de.ne a \ntype operator Eq of kind . .., which maps function and polymorphic types to the type Void =.a :..a (a \ntype with no values), and require the arguments of eq to be of type Eq t for some type t . Thus, given \nany type t , the function Eq serves to verify that a non-equality type Girard s method of candidates \n[6], using his de.nition of a candi\u00ad date. The standard set of neutral types is extended to include typesdoes \nnot occur inside t . constructed by Typerec. We de.ne R. as the set of types t of Eq (Bool)= Bool Eq \n(a1 .a2)= Void Eq (a1 \u00d7a2)= Eq (a1)\u00d7Eq (a2) Eq (. [.]a)= Void Eq (. + a)= Void Eq (. [.]a)= . [.](.a1 \n:.. Eq (aa1)) kind . such that the type Typerec[.] t of (tint; t.; t.; t.+) be\u00adlongs to a candidate \nfor kind . whenever the branches belong to candidates of the corresponding kinds from the Typerec formation \nrule. We then prove that this set is a candidate. Next we de.ne the set S.[C/.] of types of kind . (for \ngiven candidates Ccorre\u00adsponding to the free kind variables . of .), equal to R. for kind ., and de.ned \ninductively as in [6] for function, polymorphic, and variable kinds. We show that S.[C/.] is a candidate. \nFinally we prove that S [C/.] is closed under substitution of types for free type variables; strong normalization \nis an immediate corollary. THEOREM 3.2. Reduction of well-formed types is con.uent. Con.uence of type \nreduction is a corollary of local con.uence, which we prove by case analysis of the type reduction relation \n(.). We consider type contexts with two holes and show that the reduc\u00adtion is locally con.uent in each \ncase. We say that a term e is stuck if e is not a value and e . e ' for no term e ' . THEOREM 3.3 (SOUNDNESS \nOF .P FOR TYPE SAFETY). i If e; e; e fe :t and e . * e ' i , then e ' in .P is not stuck. We prove soundness \nof the system using a contextual semantics in Wright/Felleisen style [26] using the standard progress, \nsubject reduction, and substitution lemmas as well as the con.uence and strong normalization properties \nof the .Pi type system. 3.1 Example: Marshalling One of the examples that Harper and Morrisett [8] use \nto illus\u00adtrate the power of intensional type analysis is based on the exten\u00adsion of ML for distributed \ncomputing proposed by Ohori and Kato [14]. The idea is to convert values into a form which can be used \nfor transmission over a network. An integer value may be transmitted directly, but a function may not; \ninstead, a globally unique identi\u00ad.er is transmitted that serves as a proxy at the remote site. These \nidenti.ers are associated with their functions by a name server that may be contacted through a primitive \naddressing scheme. The re\u00admote sites use the identi.ers to make remote calls to the function. Harper \nand Morrisett show how to de.ne types of transmissible val\u00adues as well as functions for marshalling to \nand unmarshalling from these types using intensional type analysis. However, the predica\u00adtivity of their \ncalculus prevents them from handling the full calculus of Ohori and Kato, which also includes the remote \nrepresentation of polymorphic functions and remote type application. In .Pi marshalling of polymorphic \nvalues is straightforward; in fact it offers more .exibility than the calculus of Ohori and Kato needs, \nsince polymorphic functions become .rst-class values, and polymorphic types can be used in remote type \napplications. Adapt\u00ading the constructs of [8] to .Pi , we introduce a type constructor Id :. ... A value \nof type t has a global identi.er of type Id t . The Typerec and typecase operators are extended in an \nobvious way. For example, the following type reduction relation is added: Typerec[.] (Id t )of (tint; \nt.; t. ; t+; tId) . . tId t (Typerec[.] t of (tint; t.; t. ; t+; tId)) . The type of the remote representation \nof values of type t is Tran t , de.ned in [8] using intensional analysis of t . Values of type Tran t \ndo not contain any abstractions; all the abstractions are wrapped inside an Id constructor. We can extend \nthe Harper/Morrisett de.\u00adnition of Tran to handle the quanti.ed types of .Pi as follows: Tran (int)= \nint Tran (a1 .a2)= Id (Tran a1 .Tran a2) Tran (. [.]a)= Id (.a ' :.. (.a1 :.. Tran (aa1))a ' ) ++ . ' \nTran (. a)= Id (. . (... Tran (a [.]))[. ' ]) Tran (Id a)= Id a At the term level the system provides \nprimitives for creating global identi.ers and performing remote invocations:1 newid : .a1 :.. .a2 :.. \n(Tran a1.Tran a2).Tran (a1.a2) rapp : .a1 :.. .a2 :.. Tran (a1.a2).Tran a1.Tran a2 newpid : . + .. .a \n:. ... (.a ' :.. Tran (aa ' )).Tran (. [.]a) rtapp : . + .. .a :. ... Tran (. [.]a) ..a ' :.. Tran (aa \n' ) For completeness in our system we also need to handle kind poly\u00admorphism and remote kind applications: \nnewkid : .a :(... .). (. + .. Tran (a [.])) .Tran (. + a) rkapp : .a :(... .). Tran (. + a) .. + .. Tran \n(a [.]) Operationally, the newid s take a function between transmissible values and generate a new, globally \nunique identi.er and tell the name server to associate that identi.er with the function on the lo\u00adcal \nmachine. The remote applications take a proxy identi.er of a remote function and a transmissible argument \nvalue. The name server is contacted to get the site where the remote value exists; the argument is sent \nto this machine, and the result of the function transmitted back as the result of the operation. Marshalling \nand unmarshalling of values from transmissible rep\u00adresentations are performed by the mutually recursive \nfunctions M : .a :..a .Tran a and U :.a :.. Tran a .a. They are de.ned below by a pattern-matching syntax \nand implicit recursion instead of typecase and .x. We assume that a type or a kind does not need to be \ntransformed in order to be transmitted. M [int]= .x :int.x M [a1 .a2]= .x :a1 .a2. newid [a1][a2] (.x \n' :Tran a1. M [a2](x (U [a1]x ' ))) M [. [.]a]= .x :. [.]a. newpid [.] + [a](.a ' :.. M [aa ' ](x [a \n' ])) +++ + M [. a]= .x :. a. newkid [a](. .. M [a [.]](x [.] )) M [Id a]= .x :Id a. x U [int]= .x :Tran \n(int).x U [a1 .a2]= .x :Tran (a1 .a2)..x ' :a1. U [a2](rapp [a1][a2]x (M [a1]x ' )) U [. [.]a]= .x :Tran \n(. [.]a). .a ' :.. U [aa ' ](rtapp [.] + [a]x [a ' ]) +++ + U [. a]= .x :Tran (. a). . .. U [a [.]](rkapp \n[a]x [.]) U [Id a]= .x :Tran (Id a).x  3.2 Example: Polymorphic equality Another view at the term-level \nanalysis of quanti.ed types is pro\u00advided by an example involving the comparison of values of existen\u00adtial \ntype. The term constructs for introduction and elimination of existential types have the following formation \nrules. E;.;G fe :(.a :.. t )t ' E;.;G f.a :. = t ' ,e :t . : .a :.. t E;.;G fe : . [.]t E;. ft ' :. E;.,a \n:.;G,x :ta fe ' : t ' E;.;G fopen e as .a :., x :ta.in e ' : t ' The polymorphic equality function eq \nis de.ned in Figure 7 (we use a letrec construct derived from our .x). The domain type of the function \nis restricted to types of the form Eq t to ensure that only values of types admitting equality are compared. \n1Ohori and Kato [14] de.ne one primitive for creating identi.ers for both term and type abstraction. \nletrec heq:.a:...a ' :..Eq a . Eq a ' . Bool =.a:...a ' :.. typecase[..:..Eq . . Eq a ' . Bool] aof Bool \n. .x:Bool. typecase[..:..Eq . . Bool] a ' of Bool . .y:Bool.primEqBool x y ... . ...false \u00df1 \u00d7\u00df2 . .x:Eq \n\u00df1 \u00d7Eq \u00df2. typecase[..:..Eq . . Bool] a ' of '' '' \u00df1 \u00d7\u00df2 . .y:Eq \u00df1 \u00d7Eq \u00df2. which reduces to heq [Bool][Bool]true \ntrue and thus to true. However this result is justi.ed, since the above two packages of type .a :..a \nwill indeed behave identically in all contexts. An informal argument in support of this claim is that \nthe most any context could do with such a package is open it and inspect the type of its value using \ntypecase, but this will only provide access to a type function t representing the inner existential type. \nSince the kind .of the domain of t is unknown statically, the only non-trivial operation on t is its \napplication to the witness type of the package, which is the only available type of kind .. As we saw \nabove, this operation will produce the same result (namely Bool) in both cases. Pi Pi ' heq [\u00df1][\u00df1](x.1)(y.1) \nand Thus, since the two arguments to eq are indistinguishable by . ' heq [\u00df2][\u00df2](x.2)(y.2) contexts, \nthe above result is perfectly sensible. ... . ...false  3.3 Discussion . [.]\u00df . .x:(.\u00df1 :..Eq (\u00df\u00df1)). \ntypecase[..:..Eq . . Bool] a ' of Before we move on, it would be worthwhile to analyze the . '' '''' \n. [. ]\u00df . .y:(.\u00df1 :..Eq (\u00df\u00df1)). open x as .\u00df1 :., xc :Eq (\u00df\u00df1). in '' ' ' \u00df heq [\u00df\u00df1][\u00df 1' ]xc yc open \ny as .\u00df1 :., yc :Eq (\u00df 1). in ' \u00df ... . ...false ... in let eq = .a:...x:Eq a..y:Eq a.heq [a][a]xy in \n... language. Speci.cally, what is the price in terms of complexity of the type theory that can be attributed \nto the requirements that we imposed? In Section 2.3 we saw that an iterative type operator is essen\u00adtial \nto typechecking many type-directed operations. Even when re\u00adstricted to compiling ML we still have to \nconsider analysis of poly\u00admorphic types of the form .a:..t, and their ad hoc inclusion in kind .makes \nthe latter non-inductive. Therefore, even for this sim\u00adple case, we need kind polymorphism in an essential \nway to handle the negative occurrence of . in the domain of . . In turn, kind polymorphism allows us \nto analyze at the type level types quanti\u00ad.ed over any kind; hence the extra expressiveness comes for \nfree. Moreover, adding kind polymorphism does not entail any heavy Figure 7: Polymorphic equality in \n. Pi Pi type-theoretic machinery the kind and type language of .= .a:. = Bool \u00d7Bool, .true, true. : \na.. Both are of type minor extension (with primitive recursion) of the well-studied cal- Consider the \ntwo packages v = .a:. = Bool, false : a. and ' is a v .a:..a, which makes the invocation eq [.a:..a]vv \n' legal. But culus F2; we use the basic techniques developed for F2 [6] to prove when the packages are \nopen, the types of the packaged values may properties of our type language. (as in this example) turn \nout to be different. Therefore we need the auxiliary function heq to compare values of possibly different \ntypes by comparing their types .rst. The function corresponds to a ma\u00adtrix on the types of the two arguments, \nwhere the diagonal elements compare recursively the constituent values, while off-diagonal ele\u00adments \nreturn false and are abbreviated in the .gure. The only interesting case is that of values of an existential \ntype. Opening the packages provides access to the witness types \u00df1 and \u00df1 ' of the arguments x and y. \nAs shown in the typing rules, the ac\u00adtual types of the packaged values, x and y, are obtained by applying \nthe corresponding type functions \u00df and \u00df ' to the respective wit\u00adness types. This yields a perhaps unexpected \nsemantics of equality. Consider this invocation of the eq function which evaluates to true: eq [.a:..a] \n.a:. = .\u00df:..\u00df, .\u00df:. = Bool, true :Eq \u00df.:Eq a. .a:. = .\u00df:. . ..\u00dfBool, .\u00df:. . .= ..:..., true:Eq (\u00dfBool).:Eq \na. At runtime, after the two packages are opened, the call to heq is Pi The kind polymorphism of .not \npossible. This property prevents in particular the construction of non-terminating types based on variants \nof Girard s J operator using a kind-comparing operator [7]. For analysis of quanti.ed types at the term \nlevel we have the new construct . + ..e. This does not result in any additional complexity at the type \nlevel although we introduce a new type constructor . + , the kind of this construct is de.ned completely \nby the original kind calculus, and the kind and type calculus is still essentially F2. The term calculus \nbecomes an extension of Girard s .U calculus [5], hence it is not normalizing; however it already includes \nthe gen\u00aderal recursion construct .x, necessary in a realistic programming language. Restricting the type \nanalysis at the term level to a .nite set of kinds would help avoid the term-level kind abstraction. \nHowever, even in this case, we would still need kind abstraction to imple\u00adment a type erasure semantics, \nwhich can simplify certain phases of the compiler (for details see the extended report [18]). On the \nis parametric, i.e., kind analysis is adds no heq [.\u00df:..\u00df][.\u00df:. . ..\u00dfBool] .\u00df:. = Bool, true:Eq \u00df. .\u00df:. \n. .= ..:..., true:Eq (\u00dfBool). This term evaluates to true even though the type arguments are different. \nThe reason is that what is being compared are the actual types of the values before hiding their witness \ntypes. Tracing the reduction of this term to the recursive call heq [\u00df\u00df1][\u00df ' \u00df1' ]xc yc we .nd out it \nis instantiated to heq [(.\u00df:..\u00df)Bool][(.\u00df:. . ..\u00dfBool)(..:...)]true true Pi4.ANALYZINGRECURSIVETYPES \nother hand, having kind abstraction at the term level of .complications to the transition to type erasure \nsemantics. Next we turn our attention to the problem of analyzing recur\u00adsive types. Following the general \nscheme described in the previous section, we need to introduce a type constructor ulyielding a type isomorphic \nto the least .xpoint of a given type function. Since the types we analyze are of kind ., the kind of \nlu of interest is u:(. . .) . . l Unfortunately there is a negative occurrence of . in the domain of \nthis kind, which as it was with universally-quanti.ed types in Section 3 prevents de.ning an iterator \nover this kind while main\u00adtaining strong normalization of the type language. In the case of quanti.ed \ntypes we were able to resolve this problem by general\u00adizing the negative occurrence of . to an arbitrary \nkind; however such an approach is doomed in the case of recursive types since the argument of lu must \nhave identical domain and range. One possibility is to follow the approach outlined by Crary and Weirich \nin [1] for quanti.ed types; since type variables bound by the .xpoint operator must be of kind ., an \nenvironment can be used to map them to types of kind . without kind mismatches. While plausible and perhaps \nef.cient, this approach (as pointed out in Section 2.4) gives no protection against some programming \ner\u00adrors, and it is unclear how to combine it with .Pi .  4.1 A restricted Typerec To handle recursive \ntypes, we introduce a new constructor Place that acts as the right inverse of the Typerec. We will .rst \ngive an informal explanation of how the Place constructor is used in our solution by considering a restricted \nform of the Typerec. This ap\u00adproach does not guarantee termination; we use it to ease the pre- Q sentation \nof the .i calculus. Consider the iteration Typerec[.] t of (tint; t.; t.; t+; t\u00b5) in the case when t \nis a recursive type, say lu (.a :.. int ..a).In many cases, the desired result will be another recursive \ntype, say u (.a :..t ' ) where t ' is the result of analyzing the body. If we followed the approach we \nused in the case of polymorphic types (i.e., if the iterator s action on the type variable is suspended \nuntil the variable is replaced by a type upon unfolding the .xpoint), then the result would be: lu (.a \n:..t. int atint (Typerec[.] a of ... )) l In this case, the iterator ends up being applied n times to \nthe nth unfolding of the .xpoint, which does not correspond to the de\u00adsired .xpoint. Instead the iterator \nmust be applied to the body of the type function, but in contrast with the behavior in the case of a \nquanti.ed type the iterator should disappear when applied to the type variable a. Since the .xpoint notation \nrepresents a type isomorphic to an in.nite unfolding of the body, the traver\u00adsal of the entire in.nite \ntree is complete with one iteration over the body. In other words the iterator must satisfy an equation \nlike Typerec[.] a of ... = a so that the result of analyzing the body is .a :..t. int atint a. Therefore, \nwe need to distinguish between type variables bound by a polymorphic or existential quanti.er and those \nbound in a re\u00adcursive type. This reasoning leads us to a solution based on the work of Fegaras and Sheard \non catamorphisms over non-inductive datatypes [4]. The main idea is to introduce an auxiliary type con\u00adstructor \nPlace of kind . . . which is the right inverse of the iterator, i.e., it holds that Typerec[.] (Place \nt ) of (tint; t.; t.; t+; t\u00b5) . t . The iterator processes the body of a recursive type with the lu-bound \ntype variable protected under Place. While processing the body, the iterator eventually reduces to instances \nof the form Typerec[.] (Place a) of ... , which reduce to a. The reduction rule for the iterator over \na recur\u00ad (kinds) . ::= . | . | . .. ' |... . (types) t ... + u | Place ::= a | int | .|\u00b0\u00b0.| \u00b0|\u00b0 l | .a \n: .. t | tt ' | ... t | t [.] | Typerec[.] t of (tint; t.; t.; t+; t\u00b5) . (values) v ::= i | . + .. v \n| .a : .. v | .x : t. e | .x x : t. v | fold v as t ' (terms) e ::= v | x | e [.] + | e [t ] | ee | fold \ne as t | unfold e as t | typecase[t ] t ' of (eint; e.; e.; e+; e\u00b5) . Figure 8: The .Qi language . =... \n. t $t ' =... t [.](t ' [.]) for ./.fkv(t ) .fkv(t ' ) t .t ' =(. ) tt ' .a : .. t =..[.](.a : .. t ) \n. + .. t =.. + (... t ) (. ):. .. ..= .a :...a ' . )$a)$a ' :.. (( \u00b0. : ... (. ..) ..=... .a : . ... \n.. ' . \u00b0. [. ' ][.](.a ' : .. a a ' [. ' ]) . + :(... .) ..= .a :(... .). .. ' . \u00b0. + [. ' ](... a [.][. \n' ]) u :(... . ..) ..= .a :(... . ..).\u00b0u$a ll Q Figure 9: Syntactic sugar for .i sive type is Typerec[.] \n(lu t ' ) of (tint; t.; t.; t.+; t\u00b5) . t\u00b5 t ' (.a :.. Typerec[.] (t ' (Place a)) of (tint; t.; t.; t.+; \nt\u00b5))  4.2 The general case The previous approach does not generalize to the case when the result of \nthe Typerec may be of an arbitrary kind. In the general case, the type reductions are: Typerec[.] (Place \nt ) of (tint; t.; t.; t+; t\u00b5) . t . Typerec[.] (lu t ' ) of (tint; t.; t.; t+; t\u00b5) . t\u00b5 t '. (.a : .. \nTyperec[.] (t ' (Place a)) of (tint; t.; t.; t.+; t\u00b5)) The constructor Place can now be applied to a \ntype of arbitrary kind, but its return result must be .. This implies that Place has the kind ... . ... \nBut this is unsound since we can not constrain the kind of t above (the argument of Place) to match the \nresult kind . of the Typerec. Adopting the solution given by Fegaras and Sheard, we modify the domain \nof intensional analysis: in place of . we introduce a parameterized kind , and require that the type \nt being analyzed in Typerec[.] t of (tint; t.; t.; t.+; t\u00b5) is of kind .. The con\u00adstructor Place must \nthen have the polymorphic kind ... . . ., and the .x-point constructor\u00b0u the kind ... (. ..) ... l Q \nWe de.ne the .i calculus in Figures 8 and 9. Figures 10, 11, Kind formation Ef. . .E Ef. Ef.1 Ef.2 E,. \nf. Ef. Ef. Ef.1 ..2 Ef... . Type formation E;. ft : . Ef. E;. fint : ... . E;. f(\u00b0): ... . .. .. . Ef. \na :. in . E;. f\u00b0. : ... .. ' . (. ' ..) .. E;. fa : . + . ' E;. f\u00b0. : ... (...) .. E;. f\u00b0u : ... (. ..) \n.. lE;. fPlace : ... . .. E;.,a :. ft : . ' E;. ft : . ' .. E;. ft ' : . ' : . .. '' E;. f.a :.. t E;. \nftt : . E,.;. ft : . E;. ft : ... . Ef. ' E;. f... t : ... . E;. ft [. ' ]: .{/.} . ' E;. ft : . E;. \nftint : . E;. ft. : . .. .. .. .. E;. ft. : ... (. ..) .(. ..) .. E;. ft+ :(... .) .(... .) .. . E;. \nft\u00b5 :(. ..) .(. ..) .. E;. fTyperec[.] t of (tint; t.; t.; t+; t\u00b5): . . Q Figure 10: .i type formation \nrules and 12 show the static semantics. Figure 13 shows the dynamic semantics. Types which had kind . \nin .Pi could be analyzed by a Typerec with an arbitrary result kind . ' . In our new language .Qi , a \ntype that can be analyzed by an arbitrary Typerec construct must have the kind . for all possible .. \nThus the kind .of .Pi is represented Q by the kind ... . in .i . To be able to analyze function and polymorphic \ntypes, we now have to modify their kinds as well; to avoid confusion with the \u00b0 constructors based on \n., we denote the new constructors by \u00b0,, . . and \u00b0. + (Figure 8). The kind rules for these constructors \nare shown in Figure 10. We can de.ne equivalents of the .Pi types (. ), . , + \u00b0+ and . starting from \n\u00b0, , and \u00b0. respectively. The key intuition . . in the de.nition (Figure 9) is that we thread the same \nkind through all components of kind .. For example, expanding the de.nition of t .t ' we obtain its equivalent, \n... \u00b0' [.]). Ex\u00ad . [.](t [.])(t pressed in terms of these derived types, the typing rules for most Q \n.i terms (Figure 11) are identical to those of .Pi . Compared with .Pi , the term language of .Qi has \ntwo new constructs fold e as t and unfold e as t to implement the isomorphism between a re\u00adcursive \ntype and its unfolding. Each of these constructors must .rst be applied to kind . before being analyzed, \nwhere . is the kind of the result of the analysis. In all other aspects the type-level analysis proceeds \nas in .Pi by iter\u00adating over the components of the type and then passing the results of the iteration \nand the original components to the corresponding Term formation E;.;G fe : t ' E;. fG E;.;G fe : t E;. \nft . t :. E;.;G fi : int E;.;G fe : t ' E;. ft : ... . .. E;.;G fe : ult E;.;G funfold e as t : t $(lut \n) E;. ft : ... . .. E;.;G fe : t $(ult ) E;.;G ffold e as t : ult E,.;.;G fv : t E;.;G fe : . + t Ef. \n++ + E;.;G f. .. v : ... t E;.;G fe [.]: t [.] E;.,a :.;G fe : t E;.;G,x :t fe : t ' E;.;G f.a :.. e \n: .a :.. t E;.;G f.x :t. e : t .t ' E;.;G fe : . [.]t E;. ft ' : . E;.;G fe [t ' ]: tt ' E;.;G fe1 : \nt2 .t1 E;.;G fe2 : t2 E;.;G fe1 e2 : t1 E;.;G,x :t fv : t t = . + .1 ....n. .a1 :.1 ...am :.m :t1 .t2. \nn =0,m =0 E;.;G f.x x :t. v : t E;. ft :. .. E;. ft ' :. E;.;G feint : t int a ' E;.;G fe. : .a :.. \n.:..t (a1 .a2) E;.;G fe. : . + .. .a :. ...t (. [.]a) E;.;G fe+ : .a :(... .).t (. + a) . E;.;G fe\u00b5 : \n.a :(... . ..).t (ula) E;.;G ftypecase[t ] t ' of (eint; e.; e.; e.+; e\u00b5): tt ' Figure 11: .Qi term formation \nrules branch of the iterator. For example, consider the analysis of the int and \u00b0. constructors (Figure \n12) : Typerec[.] (int [.])of (tint; t.; t.; t.+; t\u00b5) . tint Typerec[.] (\u00b0. [.][. ' ]t )of (tint; t.; \nt.; t.+; t\u00b5) . t. [. ' ]t (.a :. ' . Typerec[.] (ta)of (tint; t.; t.; t.+; t\u00b5)) The reduction rules for \ntypecase are similar to those in .Pi , with the recursive type handled in an obvious way (Figure 13). \nHow\u00adever, there is one subtlety in the typecase reduction rules. Since typecase does not iterate over \nthe structure of a type, its reductions do not introduce the Place constructor; thus the type analyzed \nby Typerec[.] must be of kind ., but a typecase can only analyze types of kind ., i.e., ... .. It is \neasy to see that there are no closed types of this kind constructed using Place. Thus there are no reduction \nrules for typecase analyzing the Place constructor. We show this (in the companion technical report [18]) \nwhen proving Q the soundness of .i . Type reduction E;. ft1 . t2 : . E;. fTyperec[.] (int [.])of (tint; \nt.; t.; t+; t\u00b5): . . E;. fTyperec[.] (int [.])of (tint; t.; t.; t+; t\u00b5) . tint : . . E;. fTyperec[.] \nt1 of (tint; t.; t.; t+; t\u00b5) . t ' : . E;.,a :. ' ft : . E;. ft ' : . ' 1 E;. fTyperec[.] t2 of (tint; \nt.; t.; t..+; t\u00b5) . t2 ' : . E;. f(.a :. ' .t )t ' . t {t ' /a}: . '' E;. fTyperec[.] ((\u00b0. )[.]t1 t2)of \n(tint; t.; t.; t+; t\u00b5) . t. t1 t2 t1 t2 : . . E,.;. ft : ... . Ef. '' E;.,a :. ' fTyperec[.] (ta)of \n(tint; t.; t.; t.+; t\u00b5) . t : . E;. f(... t )[. ' ] . t {/.}: .{/.} . ' . '' E;. fTyperec[.] (\u00b0. [.][. \n' ]t )of (tint; t.; t.; t.+; t\u00b5) . t. [. ' ]t (.a :. ' .t ): . E;. ft : . .. ' a/.ftv(t ) E,.;. fTyperec[.] \n(t [.])of (tint; t.; t.; t+; t\u00b5) . t ' : . E;. f.a :..t a . t : . .. ' + .E;. fTyperec[.] (\u00b0. [.]t )of \n(tint; t.; t.; t.+; t\u00b5) . t.+ t (... t ' ): . E;. ft : ... ./.fkv(t ) . ' E;.,a :. fTyperec[.] (t (Place \n[.]a))of (tint; t.; t.; t+; t\u00b5) . t ' : . . '. E;. f... t [.] . t : ... E;. fTyperec[.] (\u00b0ul[.]t )of \n(tint; t.; t.; t.+; t\u00b5) . t\u00b5 t (.a :.. t ' ): . E;. fTyperec[.] (Place [.]t )of (tint; t.; t.; t+; t\u00b5): \n. . E;. fTyperec[.] (Place [.]t )of (tint; t.; t.; t+; t\u00b5) . t : . . Q Figure 12: Selected .i type \nreduction rules unfold (fold v as t )as t . v e . e ' e . e ' fold e as t . fold e ' as t unfold e as \nt . unfold e ' as t typecase[t ]int of (eint; e.; e.; e+; e\u00b5) . eint . typecase[t ] (t1 .t2)of (eint; \ne.; e.; e+; e\u00b5) . e. [t1][t2] . typecase[t ] (. [.]t ' )of (eint; e.; e.; e.+; e\u00b5) . e. [.] + [t ' ] \ntypecase[t ] (. + t ' )of (eint; e.; e.; e.+; e\u00b5) . e.+ [t ' ] typecase[t ] (lut ' )of (eint; e.; e.; \ne.+; e\u00b5) . e\u00b5 [t ' ] '' ' e;e ft . * . :. . is a normal form typecase[t ] t ' of (eint; e.; e.; e+; e\u00b5) \n. typecase[t ] . ' of (eint; e.; e..; e+; e\u00b5) . Q Figure 13: Selected .i term reduction rules The language \n.Qi enjoys the properties of .Pi listed in Section 3, detailed proofs of which can be found in the companion \ntechnical report [18]. For instance, we prove strong normalization using Gi\u00adrard s method of candidates \n[6] as for .Pi , with a few adjustments: Since our base kind . is parametric, we de.ne RC. as the set \nof types t of kind . for which Typerec[.] t ... belongs to a candi\u00addate C. of kind . whenever the branches \nbelong to candidates of the respective kinds, and the set S.[C/.]is de.ned as R(S.[C/.]).  4.3 Limitations \nThe approach outlined in this section allows the analysis of re\u00adcursive types within the term language \nand the type language, but imposes severe limitations on combining these analyses. While one can write \na polymorphic equality function of type .a :..a . a .Bool, and one can write a type operator Eq as in \nSection 3, it is not possible to write polymorphic equality of type .a :.. Eq a . Eq a .Bool. The reason \nis that although Eq (lu t ) reduces to a recursive type, its unfolding is not Eq (t $(lu t )), the type \nneeded for the recursive invocation of the equality function. Indeed the types t ' (ult ) and t ' (t \n$(ult )) are not bisimilar in general, since t ' may analyze its argument and produce different results \ndepend\u00ading on whether it is a recursive type or not. Thus the problem can be traced back to our decision \nto de.ne\u00b0u as a constructor for kind , l which makes recursive types observably distinct from their unfold\u00adings. \nAlternatives are to limit the result kind of Typerec to .,orto regain transparency of \u00b0u by eliminating \nthe t\u00b5 branch of Typerec l and providing a reduction rule which always maps recursive types to recursive \ntypes; since the analogous transformation at the term level in the latter case will require combining \ntypecase with recur\u00adsion, the resulting language exceeds the scope of the current paper.  5. RELATED \nWORK The work of Harper and Morrisett [8] introduced intensional type analysis and pointed out the necessity \nfor type-level type analysis operators which inductively traverse the structure of types. The do\u00admain \nof their analysis is restricted to a predicative subset of the type language, which prevents its use \nin programs which must support all types of values, including polymorphic functions, closures, and objects. \nThis paper builds on their work by extending type analysis to include the full type language. Crary et \nal. [1] propose a very powerful type analysis framework. They de.ne a rich kind calcu\u00adlus that includes \nsum kinds and inductive kinds. They also provide primitive recursion at the type level. Therefore, they \ncan de.ne new kinds within their calculus and directly encode type analysis oper\u00adators within their language. \nThey also include a novel re.nement operation at the term level. However, their type analysis is limited \nto parametrically polymorphic functions, and cannot account for functions that perform intensional type \nanalysis [1, Section 4.1]. Our type analysis can also handle polymorphic functions that an\u00adalyze the \nquanti.ed type variable. Moreover, their type analysis is not fully re.exive since they can not handle \narbitrary quanti.ed types; quanti.cation must be restricted to type variables of kind .. Duggan [3] proposes \nanother framework for intensional type anal\u00adysis; however, he allows the analysis of types only at the \nterm level and not at the type level. Yang [27] presents some approaches to enable type-safe programming \nof type-indexed values in ML which is similar to term-level analysis of types. Our solution for recursive \ntypes is based on the idea proposed by Fegaras and Sheard [4] for extending the fold operation to non-inductive \ndatatypes. Meijer and Hutton [10] also propose a method for extending catamorphisms to datatypes with \nembedded functions; however, their method re\u00adquires the de.nition of an anamorphism for every such catamor\u00adphism. \nNecula [13] proposed the ideas of a certifying compiler and im\u00adplemented a certifying compiler for a \ntype-safe subset of C. Mor\u00adrisett et al. [12] showed that a fully type-preserving compiler gen\u00aderating \ntype-safe assembly code is a practical basis for a certifying compiler. The idea of programming with \niterators is explained in Pierce s notes [16]. Pfenning and Mohring [15] show how inductively de\u00ad.ned \ntypes can be represented by closed types. They also construct representations of all primitive recursive \nfunctions over inductively de.ned types. 6. CONCLUSIONS We presented a type-theoretic framework for \nfully re.exive in\u00adtensional analysis of types which includes analysis of polymorphic, existential, and \nrecursive types. We can analyze arbitrary types both at the type level and at the term level. Moreover, \nwe are not restricted to analyzing only parametrically polymorphic functions; we can also handle polymorphic \nfunctions that analyze the quan\u00adti.ed type variable. We proved the calculus sound and showed that type \nchecking still remains decidable. Since we can analyze arbitrary types, we can now use these constructs \nto write type\u00addependent runtime services that can operate on values of any type; as an example we showed \nhow to use re.exive type analysis to sup\u00adport type-safe marshalling. Acknowledgments We are grateful \nto the anonymous referees for their insightful com\u00adments and suggestions on improving the presentation. \n REFERENCES [1] K. Crary and S. Weirich. Flexible type analysis. In Proc. 1999 ACM SIGPLAN International \nConf. on Functional Programming, pages 233 248. ACM Press, Sept. 1999. [2] K. Crary, S. Weirich, and \nG. Morrisett. Intensional polymorphism in type-erasure semantics. In Proc. 1998 ACM SIGPLAN International \nConf. on Functional Programming, pages 301 312. ACM Press, Sept. 1998. [3] D. Duggan. A type-based semantics \nfor user-de.ned marshalling in polymorphic languages. In X. Leroy and A. Ohori, editors, Proc. 1998 International \nWorkshop on Types in Compilation, volume 1473 of LNCS, pages 273 298, Kyoto, Japan, Mar. 1998. Springer-Verlag. \n[4] L. Fegaras and T. Sheard. Revisiting catamorphism over datatypes with embedded functions. In 23rd \nAnnual ACM Symp. on Principles of Programming Languages, pages 284 294. ACM Press, Jan. 1996. [5] J. \nY. Girard. Interpr\u00b4etation Fonctionnelle et \u00b4 Elimination des Coupures dans l Arithm\u00b4etique d Ordre Sup\u00b4erieur. \nPhD thesis, University of Paris VII, 1972. [6] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types. \nCambridge University Press, 1989. [7] R. Harper and J. C. Mitchell. Parametricity and variants of Girard \ns J operator. Information Processing Letters, 70(1):1 5, April 1999. [8] R. Harper and G. Morrisett. \nCompiling polymorphism using intensional type analysis. In Proc. 22nd Annual ACM Symp. on Principles \nof Programming Languages, pages 130 141. ACM Press, Jan. 1995. [9] C. League, Z. Shao, and V. Trifonov. \nRepresenting Java classes in a typed intermediate language. In Proc. 1999 ACM SIGPLAN International Conf. \non Functional Programming (ICFP 99), pages 183 196. ACM Press, September 1999. [10] E. Meijer and G. \nHutton. Bananas in space: Extending fold and unfold to exponential types. In Functional Programming and \nComputer Architecture, 1995. [11] Y. Minamide, G. Morrisett, and R. Harper. Typed closure conversion. \nIn Proc. 23rd Annual ACM Symp. on Principles of Programming Languages, pages 271 283. ACM Press, 1996. \n[12] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to typed assembly language. In Proc. \n25th Annual ACM Symp. on Principles of Programming Languages, pages 85 97. ACM Press, Jan. 1998. [13] \nG. C. Necula. Compiling with Proofs. PhD thesis, School of Computer Science, Carnegie Mellon University, \nPittsburgh, PA, Sept. 1998. [14] A. Ohori and K. Kato. Semantics for communication primitives in a polymorphic \nlanguage. In Proc. 20th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, pages \n99 112. ACM Press, 1993. [15] F. Pfenning and C. Paulin-Mohring. Inductively de.ned types in the calculus \nof constructions. In Proc. Fifth Conf. on the Mathematical Foundations of Programming Semantics, pages \n209 228, New Orleans, Louisiana, Mar. 1989. Springer-Verlag. [16] B. Pierce, S. Dietzen, and S. Michaylov. \nProgramming in higher-order typed lambda-calculi. Technical Report CMU-CS-89-111, Carnegie Mellon University, \n1989. [17] J. C. Reynolds. Towards a theory of type structure. In Proceedings, Colloque sur la Programmation, \nLecture Notes in Computer Science, volume 19, pages 408 425. Springer-Verlag, Berlin, 1974. [18] B. Saha, \nV. Trifonov, and Z. Shao. Fully re.exive intensional type analysis. Technical Report YALEU/DCS/TR-1194, \nDept. of Computer Science, Yale University, New Haven, CT, March 2000. Available at URL flint.cs.yale.edu/flint/publications. \n[19] Z. Shao. Flexible representation analysis. In Proc. 1997 ACM SIGPLAN International Conf. on Functional \nProgramming, pages 85 98. ACM Press, June 1997. [20] Z. Shao. An overview of the FLINT/ML compiler. In \nProc. 1997 ACM SIGPLAN Workshop on Types in Compilation, June 1997. [21] Z. Shao. Typed cross-module \ncompilation. In Proc. 1998 ACM SIGPLAN International Conf. on Functional Programming.ACM Press, 1998. \n[22] Z. Shao. Transparent modules with fully syntactic signatures. In Proc. 1999 ACM SIGPLAN International \nConf. on Functional Programming (ICFP 99), pages 220 232. ACM Press, September 1999. [23] Z. Shao and \nA. W. Appel. A type-based compiler for Standard ML. In Proc. ACM SIGPLAN 95 Conf. on Programming Language \nDesign and Implementation, pages 116 129, New York, 1995. ACM Press. [24] D. Tarditi. Design and Implementation \nof Code Optimizations for a Type-Directed Compiler for Standard ML. PhD thesis, School of Computer Science, \nCarnegie Mellon University, Pittsburgh, PA, Dec. 1996. Tech Report CMU-CS-97-108. [25] D. Tarditi, G. \nMorrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. TIL: A type-directed optimizing compiler for ML. \nIn Proc. ACM SIGPLAN 96 Conf. on Programming Language Design and Implementation, pages 181 192. ACM Press, \n1996. [26] A. Wright and M. Felleisen. A syntactic approach to type soundness. Technical report, Dept. \nof Computer Science, Rice University, June 1992. [27] Z. Yang. Encoding types in ML-like languages. In \nProc. 1998 ACM SIGPLAN International Conf. on Functional Programming, pages 289 300. ACM Press, 1998. \n\t\t\t", "proc_id": "351240", "abstract": "Compilers for polymorphic languages can use runtime type inspection to support advanced implementation techniques such as tagless garbage collection, polymorphic marshalling, and flattened data structures. Intensional type analysis is a type-theoretic framework for expressing and certifying such type-analyzing computations. Unfortunately, existing approaches to intensional analysis do not work well on types with universal, existential, or fixpoint quantifiers. This makes it impossible to code applications such as garbage collection, persistence, or marshalling which must be able to examine the type of any runtime value.We present a typed intermediate language that supports <i>fully reflexive</i> intensional type analysis. By fully reflexive, we mean that type-analyzing operations are applicable to the type of any runtime value in the language. In particular, we provide both type-level and term-level constructs for analyzing quantified types. Our system supports structural induction on quantified types yet type checking remains decidable. We show how to use reflexive type analysis to support type-safe marshalling and how to generate certified type-analyzing object code.", "authors": [{"name": "Valery Trifonov", "author_profile_id": "81100016457", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "P290011", "email_address": "", "orcid_id": ""}, {"name": "Bratin Saha", "author_profile_id": "81100311903", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "P32179", "email_address": "", "orcid_id": ""}, {"name": "Zhong Shao", "author_profile_id": "81351597965", "affiliation": "Department of Computer Science, Yale University, New Haven, CT", "person_id": "PP14127817", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351248", "year": "2000", "article_id": "351248", "conference": "ICFP", "title": "Fully reflexive intensional type analysis", "url": "http://dl.acm.org/citation.cfm?id=351248"}