{"article_publication_date": "09-01-2000", "fulltext": "\n IC FP 00, Montr\u00e9al, Canada. Copyright 2000 ACM 1-58113-202-6/00/0009 $5.00. needed. Instead, we are \nrelying on an innovative use of C++ type inference. Effectively, our framework maintains its own type \nsys\u00adtem, in which polymorphic functions can be speci.ed and other polymorphic functions can recognize \nthem as such. (Important note: Since C++ type inference is in the core of our technique, a disclaimer \nis in order: C++ type inference is a uni.ca\u00adtion process matching the types of actual arguments of a \nfunction template to the declared polymorphic types (which may contain type variables, whose value is \ndetermined by the inference pro\u00adcess). C++ type inference does not solve a system of type equa\u00adtions \nand does not relieve the programmer from the obligation to specify type signatures for functions. Thus, \nthe term C++ type inference should not be confused with type inference as employed in functional languages \nlike ML or Haskell. The over\u00adloading is unfortunate but unavoidable as use of both terms is widespread. \nWe will always use the pre.x C++ when we refer to C++ type inference .) The result of our approach is \na convenient and powerful paramet\u00adric polymorphism scheme that is well integrated in the language: with \nour library, C++ offers as much support for higher-order poly\u00admorphic functions as it does for native \ntypes (e.g., integers and pointers). Apart from the above novelty, FC++ also offers two more new ele\u00adments: \n First, we de.ne a subtyping policy for functions of FC++, thus supporting subtype polymorphism. The \ndefault policy is hardly unexpected: a function A is a subtype of function B, iff A and B have the same \nnumber of arguments, all arguments of B are sub\u00adtypes of the corresponding arguments of A, and the return \nvalue of A is a subtype of the return value of B. (Using OO typing ter\u00adminology, we say that our policy \nis covariant with respect to return types and contravariant with respect to argument types.) Subtype \nsubstitutability is guaranteed; a function double -> char can be used where a function int -> int is \nexpected.  Second, FC++ has a high level of technical maturity. For instance, compared to L\u00e4ufer s approach, \nwe achieve an equally safe but more ef.cient implementation of the basic framework for higher order functions. \nThis is done by allowing function objects to be multiply referenced (aliased), albeit only through garbage \ncollected pointers . The difference in performance is  substantial: compared to L\u00e4ufer s framework,2 \nand running with the same client code (the main example implemented by L\u00e4ufer) we achieve a 4- to 8-fold \nspeedup. 1. The Standard Library offers Class template versions of these operators (unary_compose for \ncompose1 and binder1st for bind1st) but these suffer from the .rst problem (high complexity of parameterization). \n 2. In the object oriented community, the term framework usu\u00adally refers to an applications framework \n[4]: a set of reusable classes that can be re.ned through subclassing and de.nition of dynamic methods. \nL\u00e4ufer s framework is a minimal applica\u00adtions framework. FC++ is based on an applications framework (slightly \ndifferent from L\u00e4ufer s) but also employs other mech\u00adanisms (e.g., C++ method templates). In this paper, \nthe word framework will not always refer to an applications frame\u00adwork.  Additionally, FC++ builds signi.cant \nfunctionality on top of the basic framework. We export a fairly mature reference-counting pointer class \nto library users, so that use of C++ pointers can be completely eliminated at the user level. We de.ne \na wealth of useful functions (a large part of the Haskell Standard Prelude) to enhance the usability \nof FC++ and demonstrate the expressive\u00adness of our framework. It should be noted that de.ning these functions \nin a convenient, reusable form is possible exactly because of the support for polymorphic functions offered \nby FC++. It is no accident that such higher-order library functions are missing from other C++ libraries: \nsupplying explicit types would be tedious and would render the functions virtually unus\u00adable. The rest \nof the paper is organized as follows. Section 2 describes our representation of monomorphic and polymorphic \nfunctions. Section 3 shows some representative examples using our frame\u00ad work. Section 4 analyzes the \nexpressiveness and limitations of FC++. Section 5 discusses aspects of our implementation. Section 6 \npresents related work. Section 7 contains our conclusions. 2 REPRESENTING FUNCTIONS To clarify our goal \nof embedding a functional language in C++, a quick example is useful. In Haskell [10]: take 5 (map odd \n[1..]) evaluates to [True,False,True,False,True]. With FC++, we can do the same in C++: take( 5, map( \nodd, enumFrom(1) ) ) Note some aspects of the above example: enumFrom creates an in.nite list. map demonstrates \nthe support for higher order func\u00adtions. take is one of many standard Haskell functions supported by \nFC++. The differences between the C++ and Haskell code are limited to syntax details: the C++ version \nhas extra parentheses and commas, and lacks the syntactic sugar for common operations (e.g. \"[1..]\"). \nPrevious C++ libraries that supported functional idioms could also express something resembling the above \nexample. The biggest dif\u00adference, however, is that in FC++ all the elements of our example are fully \npolymorphic. FC++ is the .rst C++ library to support rank-2 polymorphism: passing polymorphic entities \nas parameters to other polymorphic entities. Support for rank-2 polymorphism is much more useful in C++ \nthan in functional languages like Haskell or ML, because of the limited capabilities of C++ type inference. \nSince C++ type inference only uni.es function arguments, without rank-2 polymorphism the above example \nwould need to either a) use a monomorphic function odd, or b) explicitly instantiate a class template \nOdd, e.g., take( 5, map( Odd<int>, enumFrom(1) ) ). The problem with approach (a) is that odd would not \nbe general enough to be used with, say, complex numbers. The problem with approach (b) is that it is \ninconvenient due to the explicit type signa\u00adtures and because it requires maintaining class template \nversions as well as function template versions for the same concepts. Following a convention also used \nby L\u00e4ufer, we use the term func\u00adtoid to refer to our abstraction of the familiar concept of func\u00adtion \n. For clarity, we will distinguish between two kinds of functoids in FC++: indirect functoids, and direct \nfunctoids. Indirect functoids are .rst-class entities in FC++. That is, one can de.ne variables ranging \nover all indirect functoids with the same type signature. Indirect functoids can only represent monomorphic \nfunctions, however. In contrast, direct functoids can represent either monomorphic or polymorphic functions \nbut they are not .rst-class entities. Direct functoids allow us to exploit C++ type inference. Conversion \noperators from direct functoids (for a mono\u00admorphic type signature) to indirect functoids are provided \nin the library. We will .rst describe the special case of monomorphic direct func\u00adtoids, because they \nare simpler and serve as a good introduction for readers not familiar with C++. 2.1 Monomorphic Direct \nFunctoids C++ is a class-based object-oriented language. Classes are de.ned statically using the keywords \nstruct or class.3 C++ provides a way to overload the function call operator (written as a matching pair \nof parentheses: () ) for classes. This enables the creation of objects which look and behave like functions \n(function objects). For instance, we show below the creation and use of function objects to double and \nadd one to a number: struct Twice { int operator()( int x ) { return 2*x; } } twice; struct Inc { \nint operator()( int x ) { return x+1; } } inc; twice(5) // returns 10 inc(5) // returns 6 The problem \nwith function objects is that their C++ types do not re.ect their function types. For example, both twice \nand inc represent functions from integers to integers. To distinguish from the C++ language type, we \nsay that the signature of these objects is int -> int (the usual functional notation is used to represent \nsignatures). As far as the C++ language is concerned, however, the types of these objects are Twice and \nInc. (Note our convention of using an upper-case .rst letter for class names, and a lower-case .rst letter \nfor class instance names.) Knowing the signature of a function object is valuable for further manipulation \n(e.g., for enabling para\u00admetric polymorphism, as will be discussed in Section 2.3). Thus, we would like \nto encapsulate some representation of the type sig\u00adnature of Twice in its de.nition. The details of this \nrepresentation will be .lled in Section 2.3, but for now it suf.ces to say that each direct functoid \nhas a member called Sig (e.g., Twice::Sig) that represents its type signature. Sig is not de.ned explicitly \nby the authors of monomorphic direct functoids instead it is inherited from classes that hide all the \ndetails of the type representation. For instance, Twice would be de.ned as: struct Twice : public CFun1Type<int, \nint> { int operator()( int x ) { return 2*x; } } twice; 3. The difference between the two keywords \nis that members of a struct are by default accessible to non-class code (public), whereas members of \na class are not (they default to pri\u00advate). That is, CFun1Type is a C++ class template whose only purpose \nis to de.ne signatures. A class inheriting from CFun1Type<A,B>is a 1-argument monomorphic direct functoid \nthat encodes a function from type A to type B. In general, the template CFunNType is used to de.ne signatures \nfor monomorphic direct functoids of N argu\u00adments. Note that in the above de.nition of Twice we specify \nthe type sig\u00adnature information (int -> int) twice: once in the de.nition of operator() (for compiler \nuse) and once in CFun1Type<int, int> (for use by FC++). There seems to be no way to avoid this duplication \nwith standard C++, but non-standard extensions, like the GNU C++ compiler s typeof, address this issue. \nMonomorphic direct functoids have a number of advantages over normal C++ functions: they can be passed \nas parameters, they can have state, they can be given aliases using typedef , etc. Native C++ functions \ncan be converted into monomorphic direct func\u00adtoids using the operator ptr_to_fun of FC++. It is worth \nnoting that the C++ Standard Template Library (STL) also represents functions using classes with an operator(). \nFC++ provides con\u00adversion operations to promote STL function classes into monomor\u00adphic direct functoids. \n 2.2 Indirect Functoids Direct functoids are not .rst class entities in the C++ language. Most notably, \none cannot de.ne a (run-time) variable ranging over all direct functoids with the same signature. We \ncan overcome this by using a C++ subtype hierarchy with a common root for all func\u00adtoids with the same \nsignature and declaring the function applica\u00adtion operator, () , to be virtual (i.e., dynamically dispatched). \nIn this way, the appropriate code is called based on the run-time type of the functoid to which a variable \nrefers. On the other hand, to enable dynamic dispatch, the user needs to refer to functions indi\u00adrectly \n(through pointers). Because memory management (alloca\u00ad tion and deallocation) becomes an issue when pointers \nare used,4 we encapsulate references to function objects using a reference counting mechanism. This mechanism \nis completely transparent to users of FC++: from the perspective of the user, function objects can be \npassed around by value. It is worth noting that our encapsu\u00adlation of these pointers prevents the creation \nof cyclical data struc\u00adtures, thus avoiding the usual pitfalls of reference-counting garbage collection. \nIndirect functoids are classes that follow the above design. An indirect functoid representing a function \nwith N arguments of types A1, ..., AN and return type R, is a subtype of class FunN<A1,A2...,AN,R>. For \ninstance, one-argument indirect functoids with signature P -> R are subtypes of class Fun1<P,R>. This \nclass is the reference\u00adcounting wrapper of class Fun1Impl<P,R>. Both classes are pro\u00adduced by instantiating \nthe templates shown below: template <class Arg1, class Result> class Fun1 : public CFun1Type<Arg1,Result> \n{ Ref<Fun1Impl<Arg1,Result> > ref; ... public: 4. In C++, memory deallocation is explicit; objects \ncreated with new must be explicitly freed with delete. typedef Fun1Impl<Arg1,Result>* Impl; Fun1( Impl \ni ) : ref(i) {} Result operator()( const Arg1&#38; x ) const { return ref->operator()(x); } ... }; \n template <class Arg1, class Result> struct Fun1Impl : public CFun1Type<Arg1,Result> { virtual Result \noperator()(const Arg1&#38;) const=0; virtual ~Fun1Impl() {} }; (Notes on the code: The ellipsis (...) \nsymbol in the above code is used to denote that parts of the implementation have been omitted for brevity. \nThese parts implement our subtype polymorphism pol\u00adicy and will be discussed in Section 2.5. The Ref \nclass template implements our reference-counted pointers and will be discussed in Section 5.3. For this \ninternal use, any simple reference counting mechanism would be suf.cient.) Concrete indirect functoids \ncan be de.ned by subclassing a class Fun1Impl<P, R> and using instances of the subclass to construct \ninstances of class Fun1<P,R>. Variables can be de.ned to range over all functions with signature P -> \nR. For instance, if Inc is de.ned as a subclass of Fun1Impl<int, int>, the following de.nes an indirect \nfunctoid variable f and ini\u00adtializes it to an instance of Inc: Fun1<int, int> f (new Inc); In practice, \nhowever, this de.nition would be rare because it would require that Incbe de.ned as a monomorphic function. \nAs we will see in Section 2.3, the most convenient representation of functions is that of polymorphic \ndirect functoids. Monomorphic direct functoids can be converted to indirect func\u00adtoids, using operations \nmakeFunN (provided by FC++). For instance, consider direct functoids Twice and Inc from Section 2.1 (the \nde.nition of Inc was not shown). The following example is illustrative: Fun1<int,int> f = makeFun1( twice \n); f( 5 ); // returns 10 f = makeFun1( inc ); f( 5 ); // returns 6 It should be noted here that our \nindirect functoids are very similar to the functoids presented in L\u00e4ufer s work [6]. Indeed, the only \ndifference is in the wrapper classes, FunN<A1,A2,...,AN,R>. Whereas we use a reference counting mechanism, \nL\u00e4ufer s imple\u00admentation allowed no aliasing: different instances of FunN<A1,A2...,AN,R> had to refer \nto different instances of FunNImpl<A1,A2,...,AN,R>. To maintain this property, objects had to be copied \nevery time they were about to be aliased. This copying results in an implementation that is signi.cantly \nslower than ours, often by an order of magnitude, as we will see in Section 5.1. Also, unlike L\u00e4ufer \ns functoids, our indirect functoids will rarely be de.ned explicitly by clients of FC++. Instead, they \nwill commonly only be produced by .xing the type signature of a direct functoid.  2.3 Polymorphic Direct \nFunctoids Polymorphic direct functoids support parametric polymorphism. Consider the Haskell function \ntail, which discards the .rst ele\u00adment of a list. Its type would be described in Haskell as tail :: [a] \n-> [a] Here adenotes any type; tailapplied to a list of integers returns a list of integers, for example. \nOne way to represent a similar function in C++ is through member templates: struct Tail { template <class \nT> List<T> operator()( const List<T>&#38; l ); } tail; Note that we still have an operator() but it \nis now a member function template. This means that there are multiple such opera\u00adtors one for each type. \nC++ type inference is used to produce concrete instances of operator() for every type inferred by a use \nof the Tail functoid. Recall that C++ type inference is a uni.ca\u00adtion process matching the types of actual \narguments of a function template to the declared polymorphic types. In this example, the type List<T> \ncontains type variable T, whose type value is deter\u00admined as a result of the C++ type inference process. \nFor instance, we can refer to tail for both lists of integers and lists of strings, instead of explicitly \nreferring to tail<int> or tail<string>. For each use of tail, the language will infer the type of element \nstored in the list, based on tail s operand. As discussed earlier, a major problem with the above idiom \nis that the C++ type of the function representation does not re.ect the function type signature. For \ninstance, we will write the type signa\u00adture of the tail function as: List<T> -> List<T> but the C++ type \nof variable tail is just Tail. The solution is to de.ne a member, called Sig, that represents the type \nsignature of the polymorphic function. That is, Sigis our way of representing arrow types. Sig is a template \nclass parameter\u00adized by the argument types of the polymorphic function. For exam\u00adple, the actual de.nition \nof Tail is: struct Tail { template <class L> struct Sig : public Fun1Type<L,L> {}; template <class \nT> List<T> operator()(const List<T>&#38; l) const { return l.tail(); } } tail; where Fun1Type is used \nfor convenience, as a reusable mecha\u00adnism for naming arguments and results.5 5. Its de.nition is just: \ntemplate <class A1, class R> struct Fun1Type { typedef R ResultType; typedef A1 Arg1Type; };  In \nreality, the Sig member of Tail, above, does not have to repre\u00adsent the most speci.c type signature of \nfunction tail. Instead it is used as a compile-time function that computes the return type of function \ntail, given its argument type. This is easy to see: the Sig for Tail just speci.es that if L is the argument \ntype of Tail, then the return type will also be L. The requirement that L be an instance of the List \ntemplate does not appear in the de.nition of Sig (although it could). The above de.nition of Tail is \nan example of a polymorphic direct functoid. In general, a direct functoid is a class with a mem\u00adber \noperator() (possibly a template operator), and a template member class Sig that can be used to compute \nthe return type of the functoid given its argument types. Thus the convention is that the Sig class template \ntakes the types of the arguments of the operator() as template parameters. As described in Section 2.1, \nfor monomorphic direct functoids, the member class Sig is hidden inside the CFunNType classes, but in \nessence it is just a template computing a constant compile-time function (i.e., returning the same result \nfor each instantiation). The presence of Sig in direct functoids is essential for any sophis\u00adticated \nmanipulation of function objects (e.g., most higher-order functoids need it). For example, in Haskell \nwe can compose func\u00adtions using . : (tail . tail) [1,2,3] -- evaluates to [3] In C++ we can similarly \nde.ne the direct functoid compose1 to act like . , enabling us to create functoids like compose1(tail,tail). \nThe de.nition of compose1 uses type information from tail as captured in its Sig structure. Using this \ninformation, the type of compose1(tail, tail) is inferred and does not need to be speci.ed explicitly. \nMore speci.cally, the result of a composition of two functoids F and G is a functoid that takes an argument \nof type T and returns a value of type: F::Sig<G::Sig<T>::ResultType>::ResultType , that is, the type \nthat F would yield if its argument had the type that G would yield if its argument had type T. This example \nis typical of the kind of type computation performed at compile-time using the Sig members of direct \nfunctoids. In essence, FC++ de.nes its own type system which is quite inde\u00adpendent from C++ types. The \nSig member of a direct functoid de.nes a compile-time function computing the functoid s return type from \ngiven argument types. The compile-time computations de.ned by the Sig members of direct functoids allow \nus to per\u00adform type inference with fully polymorphic functions without spe\u00adcial compiler support. Type \nerrors arise when the Sig member of a functoid attempts to perform an illegal manipulation of the Sig \nmember of another functoid. All such errors will be detected stati\u00adcally when the compile-time type computation \ntakes place that is, when the compiler tries to instantiate the polymorphic opera\u00adtor(). Polymorphic \ndirect functoids can be converted into monomorphic ones by specifying a concrete type signature via the \noperator monomorphize. For instance: monomorphize1<List<int>, int> (head) produces a monomorphic version \nof the head list operation for integer lists.  2.4 Use of Direct Functoids In this section we will demonstrate \nthe use of FC++ direct func\u00adtoids and try to show how much they simplify programming with polymorphic \nfunctions. The comparison will be to the two alterna\u00adtives: templatized indirect functoids, and C++ function \ntemplates. Section 3.2 also shows the bene.ts of direct functoids in a more realistic, and hence more \ncomplex, example. To avoid confusion we will show here a toy example where the difference is, hope\u00adfully, \nmuch clearer. Consider a polymorphic function twice that returns twice the value of its numeric argument. \nIts type signature would be a -> a. (In Haskell one would say Num a => a -> a. It is possible to specify \nthis type bound in C++, albeit in a round\u00adabout way we will not concern ourselves with the issue in this \npaper.) Consider also the familiar higher-order polymorphic function map, which applies its .rst argument \n(a unary function) to each element of its second argument (a list) and returns a new list of the results. \nOne can specify both twice and map as collections of indirect functoids. Doing so generically would mean \nde.ning a C++ tem\u00adplate over indirect functoids. This is equivalent to the standard way of imitating \npolymorphism in L\u00e4ufer s framework. Figure 1 shows the implementations of map and twice using indirect \nfunctoids: // N: Number type template <class N> struct Twice : public Fun1Impl<N, N> { N operator()(const \nN &#38;n) const { return 2*n; } }; // E: element type in original list // R: element type in returned \nlist template <class E, class R> struct Map : public Fun2Impl<Fun1<E, R>, List<E>, List<R> > { List<R> \n operator()(Fun1<E,R> f, List<E> l) const {...} }; Figure 1: Polymorphic functions as templates over \nindirect functoids. (For brevity, the implementation of operator() in Map is omit\u00adted. The implementation \nis similar in all the alternatives we will examine.) Alternatively, one can specify both twice and map \nusing direct functoids (Figure 2). Direct functoids can be converted to indirect functoids for a .xed \ntype signature, hence there is no loss of expressiveness. (In fact, the code for Map shown in Figure \n2 is sim\u00ad pler than the real code, but only very slightly. In reality, the C++ keyword typename needs \nto precede the reference to RT1 and L::EleType, so that the compiler knows that their nested mem\u00adbers \nEleType and ResultType are types.) The direct functoid implementation is only a little more complex than \nthe indirect functoid implementation. The complexity is due to the de.nition of Sig. Sig encodes the \ntype signature of the struct Twice { template <class N> struct Sig : public Fun1Type<N,N> {}; template \n<class N> N operator()(const N &#38;n) const { return 2*n; } } twice; // F: function type // L: list \ntype struct Map { template <class F, class L> struct Sig : public Fun2Type<F,L, List<RT1<F, L::EleType>::ResultType> \n> {}; template <class F, class L> typename Sig<F,L>::ResultType operator()(F f, L l) const {...} } \nmap; Figure 2: Polymorphic functions as direct functoids. direct functoid in a form that can be utilized \nby all other higher order functions in our framework. According to the convention of our framework, Sig \nhas to be a class template over the types of the arguments of Map. Recall also that Fun2Type is just \na simple tem\u00adplate for creating function signatures see footnote 5. To express the (polymorphic) type \nsignature of Map, we need to recover types from the Sig structures of its function argument and its list \nargument. The RT1 type is just a shorthand for reading the return type of a 1-argument function. Since \nthat type may be a function of the input type, RT1 is parameterized both by the func\u00adtion and by the \ninput type. That is, the type computation RT1<F, L::EleType>::ResultType means result type of function \nF, when its argument type is the ele\u00adment type of list L . In essence, using Sig we export type information \nfrom a functoid so that it can be used by other functoids. Recall that the Sig mem\u00adbers are really compile-time \nfunctions: they are used as type com\u00adputers by the FC++ type system. The computation performed at compile \ntime using all the Sig members of direct functoids is essentially the same type computation that a conventional \ntype inference mechanism in a functional language would perform. Of course, there is potential for an \nincorrect signature speci.cation of a polymorphic function but the same is true in the indirect functoid \nsolution. To see why the direct functoid speci.cation is bene.cial, consider the uses of map and twice. \nIn Haskell, we can say map twice [1..] to produce a list of even numbers. With direct functoids (Figure \n2) we can similarly say map( twice, enumFrom(1) ). This succinctness is a direct consequence of using \nC++ type infer\u00adence. With the indirect functoid solution (Figure 1) the code would be much more complex, \nbecause all intermediate values would need to be explicitly typed as in Map<int,int>()( Fun1<int, int> \n(new Twice <int>()), enumFrom(1) ). Clearly this alternative would have made every expression terribly \nburdensome, introducing much redundancy (int appears 5 times in the previous example, when it could be \ninferred everywhere from the value 1). Note that this expression has a single function application. Using \nmore complex expressions or higher-order functions makes matters even worse. For instance, using the \ncompose1 functoid mentioned in Section 2.3, we can create a list of multiples of four by writing map(compose1(twice, \ntwice), enumFrom(1)). The same using indirect functoids would be written as Fun1<int, int> twice (new \nTwice <int>()); Map <int, int>() (Compose1<int, int, int>() (twice, twice), enumFrom(1) ) We have found \neven the simplest realistic examples to be very tedious to encode using templates over indirect functoids \n(or, equivalently, L\u00e4ufer s framework [6]). In short, direct functoids allow us to simplify the use of \npolymor\u00adphic functions substantially, with only little extra complexity in the functoid de.nition. The \nidiom of using template member functions coordinated with the nested template class Sig to maintain our \nown type system is the linchpin in our framework for supporting higher-order parametrically polymorphic \nfunctions. Finally, note that twice could have been implemented as a C++ function template: template \n<class N> N twice (const N &#38;n) { return 2*n; } This is the most widespread C++ idiom for approximating \npoly\u00admorphic functions (e.g., [8][11]). C++ type inference is still used in this case. Unfortunately, \nas noted earlier, C++ function tem\u00adplates cannot be passed as arguments to other functions (or func\u00adtion \ntemplates). That is, function templates can be used to express polymorphic functions but these cannot \ntake other function tem\u00adplates as arguments. Thus, this idiom is not expressive enough. For instance, \nour example where twice is passed as an argument to map is not realizable if twice is implemented as \na function tem\u00adplate. What both of the above alternatives to direct functoids lack is the ability to \nexpress polymorphic functions that can accept other polymorphic functions as arguments. This rank-2 polymorphism \ncapability of FC++ direct functoids is unique among C++ libraries for functional programming. The closest \napproximation of this functionality before FC++ was with the use of a hybrid of class templates, like \nin Figure 1, and function templates. In the hybrid case, each function has two representations: one using \na template class (so that the function can be passed to other functions) and one using a function template \n(so that type inference can be used when arguments are passed to the function). The C++ Standard Library \nuses this hybrid approach for some polymorphic, higher\u00adorder functions. This alternative is quite inconvenient \nbecause class templates still need to be turned into monomorphic function instances explicitly (e.g., \none would write Twice<int> instead of twice in the examples above), and because two separate represen\u00adtations \nneed to be maintained for each function. The user will have to remember which representation to use when \nthe function is called and which to use when the function is passed as an argu\u00adment.  2.5 Subtype Polymorphism \nAnother innovation of our framework is that it implements a policy of subtype polymorphism for functoids. \nOur policy is contravariant with respect to argument types and covariant with respect to result types. \nA contrived example: Suppose we have two type hierarchies, where Dog is a subtype of Animal and Car is \na subtype of Vehicle . This means that a Dog is an Animal (i.e., a reference to Dog can be used where \na reference to Animal is expected) and a Car is a Vehicle. If we de.ne a functoid which takes an Animal \nas a parameter and returns a Car, then this functoid is a subtype of one that takes a Dog and returns \na Vehicle. For instance: Fun1<Ref<Animal>, Ref<Car> > fa; Fun1<Ref<Dog>, Ref<Vehicle> > fb = fa; // \nlegal: fa is a subtype of fb (Note the use of our Ref class template which implements refer\u00adences a \ngeneral purpose replacement of C++ pointers. The exam\u00adple would work identically with native C++ pointers \ne.g. Car* rather than Ref<Car>.) That is, fa is a subtype of fb since the argument of fbis a subtype \nof the argument of fa (contravariance) and the return type of fa is a subtype of the return type of fb \n(covariance). We cannot go the other way, though (assign fb to fa). This means that we can sub\u00adstitute \na speci.c functoid in the place of a general functoid. Since subtyping only matters for variables ranging \nover functions, it is implemented only for indirect functoids. Subtype polymorphism is implemented by \nde.ning an implicit conversion operator between functoids that satisfy our subtyping policy. This affects \nthe implementation of class templates FunNof Section 2.2. For instance, the de.nition of Fun1 has the \nform: template <class Arg1, class Result> class Fun1 : public CFun1Type<Arg1,Result> { ... // private \nmembers same as before public: ... // same as before template <class A1s,class Rs> Fun1( const Fun1<A1s,Rs>&#38; \nf ) : ref(convert1<Arg1,Result>(f.ref)) {} }; (The new part is italicized.) Without getting into all \nthe details of the implementation, the key idea is to de.ne a template implicit conversion operator from \nFun1<A1s, Rs> to Fun1<Arg1, Result>, if and only if A1s is a supertype of Arg1 and Rs is a subtype of \nResult. The latter check is the responsibility of direct functoid convert1 (not shown). In particular, \nconvert1 de.nes code that will explicitly test (at compile time) to ensure that an Arg1 is a subtype \nof A1s and that Rs is a subtype of Result.In this way, the implicit conversion of functoids will fail \nif and only if either of the above two conversions fails. Since the operator is tem\u00adplatized, it can \nbe used for any types A1s and Rs. We should note that, although the above technique is correct and suf.cient \nfor the majority of conversions, there are some slight problems. First, C++ has inherited from C some \nunsafe conver\u00adsions between native types (e.g., implicit conversions from .oating point numbers to integers \nor characters are legal). There is no good way to address this problem (which was inherited from C despite \nthe intentions of the C++ language designer; see [13] p. 710). Sec\u00ad ond, we cannot overload (or otherwise \nextend) the C++ operator dynamic_cast. Instead, we have provided our own operation that imitates dynamic_cast \nfor indirect functoids. The incompatibil\u00adity is unfortunate, but should hardly matter for actual use: \nnot only do we provide an alternative, but also down-casting functoid refer\u00adences does not seem to be \nmeaningful, except in truly contrived examples. More details on our implementation of subtype poly\u00admorphism \ncan be found in the documentation of FC++ [7]. Subtype polymorphism is important, because it is a familiar \ncon\u00adcept in object orientation. It ensures that indirect functoids can be used like any C++ object reference \nin real C++ programs.  3 USAGE EXAMPLES In this section, we show some complete functional programs writ\u00adten \nusing FC++. For reference, we compare to implementations of the same examples in Haskell, with the type \nsignatures speci.ed explicitly for easy reference. 3.1 Primes A simple algorithm for determining if a \nnumber x is prime is to compute all of its factors, and see if the resulting list of factors is just \nthe list [1,x]. Figure 3 shows the Haskell code to compute the .rst n prime numbers (the code is slightly \nmodi.ed version of that on p. 29 of [2]) and the corresponding implementation in C++. This example illustrates \nthat the mapping from Haskell to C++ is straightforward and exact.  3.2 Tree Fringe As another sample \nprogram, consider computing the fringe of a binary tree. We de.ne a Tree to be either a Node, which comprises \na piece of data and references to two other Trees, or Nil. For con\u00advenience, we say that a Tree meets \nthe predicate leaf() if it is a Node whose subtrees are both Nil. The code for Trees in Haskell is: data \nTree a = Node a (Tree a) (Tree a) | Nil leaf (Node _ Nil Nil) = True leaf (Node _ _ _) = False We can \nde.ne a similar data type in C++ as: template <class T> struct Tree { typedef T WrappedType; T data; \n Ref<Tree<T> > left, right; Tree( T x ): data(x), left(0), right(0) {} bool leaf() const { return \n(left==0) &#38;&#38; (right==0); } }; Let us de.ne the fringe of the tree to be a list of all the data \nvalues stored in the leaves of the tree, in left-to-right order. Figure 4 shows the Haskell and C++ code \nto compute the fringe. The C++ version has the usual extra noise to declare the type of a direct functoid, \nbut the body is exactly analogous to the Haskell version: If we reach nil, we return an empty list; else \nif we .nd a leaf, we return a one-element list; otherwise we lazily catenate the results divisible :: \nInt -> Int -> Bool divisible t n = t rem n == 0 factors :: Int -> [Int] factors x = filter (divisible \nx) [1..x] prime :: Int -> Bool prime x = factors x == [1,x] primes :: Int -> [Int] primes n = take \nn (filter prime [1..])  struct Divisible : public CFun2Type<int,int,bool> { bool operator()( int x, \nint y ) const { return x%y==0; } } divisible; struct Factors : public CFun1Type<int,List<int> > { \nList<int> operator()( int x ) const { return filter( bind1of2(divisible,x), enumFromTo(1,x) ); } } factors; \n struct Prime : public CFun1Type<int,bool> { bool operator()( int x ) const { return factors(x)==list_with(1,x); \n} } prime; struct Primes : public CFun1Type<int,List<int> > { List<int> operator()( int n ) const { \nreturn take(n,filter(prime,enumFrom(1))); } } primes; Figure 3: Haskell and C++ code for computing the \n.rst n prime numbers. fringe :: Tree a -> [a] fringe Nil = [] fringe n@(Node d l r) | leaf n = [d] \n | otherwise = fringe l ++ fringe r  struct Fringe { template <class RTT> struct Sig : public Fun1Type<RTT,List<typename \n RTT::WrappedType::WrappedType> > {};  template <class T> List<T> operator()(Ref<Tree<T> > t)const{ \nif( t==0 ) return List<T>(); else if( t->leaf() ) return one_element(t->data); else return cat( bind1of1(Fringe(),t->left), \nbind1of1(Fringe(),t->right)); } } fringe; Figure 4: Haskell and C++ code for computing the fringe of \na polymorphic tree. of recursive calls on the left and right subtrees. (Note that bind1of1 is used here \nto effect laziness; bind1of1 curries the only argument of a unary function to yield a 0-arg functoid \nwhich does not actually do work until it is needed and explicitly invoked.) Clients can then compare \nthe fringes of two trees with fringe tree1 == fringe tree2 -- Haskell fringe(tree1) == fringe(tree2) \n// C++ which again demonstrates that using functoids is easy, even if implementing them is somewhat \ntedious due to the Sig member. The fringe functoid is both polymorphic (it works on trees of integers, \nstrings, etc.) and lazy (if two large trees fringes differ in the .rst element, the rest of the trees \nwill not be traversed, since the result of the equality comparison is guaranteed to be false after the \n.rst mismatch). To see the importance of our implementation of parametric poly\u00admorphism via direct functoids, \nFigure 5 shows what the code would look like if we instead had chosen to implement fringe using templatized \nversions of indirect functoids. The last return statement (italicized) in the function exempli.es the \ncomplexity one repeatedly encounters when trying to express polymorphic functions using the framework \nof [6]. In reality, the code segment of Figure 5 masks much of the com\u00adplexity, because it uses makeFun0 \nand makeFun1, which are func\u00adtion templates and employ C++ type inference. If we had also expressed makeFun0 \nand makeFun1 using exclusively indirect functoids, the example would be even longer. We believe that \nFig\u00ad ure 5 demonstrates convincingly why we consider our framework to be the .rst usable attempt at incorporating \nboth higher-order functions and polymorphism in C++. It is not surprising that previ\u00adous approaches using \nhigher-order functions in C++ (e.g, [5]) have shied away from polymorphism. template <class T> struct \nFringe : public CFun1Type<Ref<Tree<T> >,List<T> > { List<T> operator()( Ref<Tree<T> > t ) const { if( \nt==0 ) return List<T>(); else if( t->leaf() ) return OneElement<T>()(t->data); else // take a deep breath! \n return Cat<T>()( makeFun0( Bind1of1< Fun1<Ref<Tree<T> >,List<T> >, Ref<Tree<T> > >() (makeFun1(Fringe<T>()), \nt->left), Bind1of1<Fun1<Ref<Tree<T> >,List<T> >, Ref<Tree<T> > >() (makeFun1(Fringe<T>()), t->right)); \n} }; Figure 5: Tree fringe computation using templates over indi\u00adrect functoids. This example demonstrates \nwhy templates over indirect functoids are undesirable.  4 DISCUSSION: SUPPORT AND LIMITA-TIONS At this \npoint we can summarize the level of support for functional programming that FC++ offers, as well as its \nlimitations. Complexity of type signature speci.cations: FC++ allows higher-order polymorphic function \ntypes to be expressed and used. Type signatures are explicitly declared in our framework, unlike in ML \nor Haskell, where types can be inferred. Further\u00admore, our language for specifying type computations \n(i.e., our building blocks for Sig template classes) is a little awkward. We used our framework to de.ne \na large number (over 50) of com\u00admon functional operators and have not found our type language to be a \nproblem learning to use it only required minimal effort. The real advantage of FC++ is that, although \nfunction de.ni\u00adtions need to be explicitly typed, function uses do not (even for polymorphic functions). \nIn short, with our framework, C++ has as good support for higher-order and polymorphic functions as it \ndoes for any other .rst-class C++ type (e.g., pointers and num\u00adbers, but not C++ native functions, which \nare not .rst-class enti\u00adties).  Limitations in the number of functoid arguments: There is a bound in \nthe number of arguments that our functoids can sup\u00adport. This bound can be made arbitrarily high (templates \nwith more parameters can be added to the framework) but it will always be .nite. We do not expect this \nto be a problem in prac\u00adtice.  A closely related issue is that of naming. We saw base classes like Fun1 \nand Fun1Impl in FC++, as well as operators like makeFun1 and monomorphize1. These entities encode in \ntheir names the number of arguments of the functions they manipu\u00adlate. Using C++ template specialization, \nthis can be avoided, at least in the case of class templates. Thus, we can have templates Fun and FunImpl \nwith a variable number of arguments. If tem\u00adplate Fun is used with two arguments, then it is assumed \nto refer to a one-argument function (the second template argument is the return type). We have experimented \nwith this idea, and it is a candidate for inclusion in the next version of FC++. Another desirable capability \nis that of implicit currying when\u00adever a function is used with fewer actual arguments than formal arguments. \nThe challenge is to implement this functionality in a reusable way, instead of adding it to the de.nition \nof individual functoids. This is straightforward for monomorphic functoids, but not for polymorphic direct \nfunctoids. Therefore, for unifor\u00admity reasons, we have not yet included this feature in FC++.  Compiler \nerror messages: C++ compilers are notoriously ver\u00adbose when it comes to errors in template code. Indeed, \nour expe\u00adrience is that when a user of FC++ makes a type error, the compiler typically reports the full \ntemplate instantiation stack, resulting in many lines of error messages. In some cases this information \nis useful, but in others it is not. We can distinguish two kinds of type errors: errors in the Sig de.nition \nof a new functoid and errors in the use of functoids. Both kinds of errors are usually diagnosed well \nand reported as wrong number of parameters , type mismatch in the set of parameters , etc. In the case \nof Sig errors, however, inspection of the template instantiation stack is necessary to pinpoint the location \nof the problem. Fortunately, the casual user of the library is likely to only encounter errors in the \nuse of functoids. Reporting of type errors is further hindered by non-local instan\u00adtiations of FC++ \nfunctoids. Polymorphic functoids can be passed around in contexts that do not make sense, but the error \nwill not be discovered until their subsequent invocation. In that case, it is not immediately clear whether \nthe problem is in the .nal invocation site or the point where the polymorphic functoid was passed as \na parameter. Fundamentally, this problem cannot be addressed without type constraints in template instantiations, \nsomething that C++ does not offer. Overall, however, type error reporting in FC++ is quite adequate, \nand, with some experience, users have little dif.culty with it.  Creating closures: Our functoid objects \ncorrespond to the func\u00adtional notion of closures: they can encapsulate state together with an operation \non that state. Note, however, that, unlike in functional languages, closing the state is not automatic \nin our framework. Instead, the state values have to be explicitly passed during construction of the functoid \nobject. Of course, this is a limitation in every approach to functional programming in C++. The reader \nmay have noticed our claim in Section 2.2 that our (internal) reference-counted functoid pointers cannot \nform cycles. This implies that our closures (i.e., functoid objects) can\u00adnot be self-referential. Indeed, \nthis is a limitation in FC++, albeit not an important one: since our closures cannot be anonymous, and \nsince the closing of state is explicit, it is convenient to replace self-referential closures with closures \nthat create a copy of themselves. This approach is slightly inef.cient, but the ef.\u00adciency gains of using \na fast reference counting technique for functoid objects far outweigh this small cost.  Pure functional \ncode vs. code with side-effects: In C++, any method is allowed to make system calls (e.g., to perform \nI/O, access a random number generator, etc.) or to change the state of global variables. Thus, there \nis no way to fully prevent side\u00ad  effects in user code. Nevertheless, by declaring a method to be const, \nwe can prevent it from modifying the state of the enclos\u00ading object (this property is enforced by the \ncompiler). This is the kind of side-effect freedom that we try to enforce in FC++. Our indirect functoids \n(as shown in Section 2.2) are explicitly side-effect free any class inheriting from our FunNImpl classes \nhas to have a const operator (). Nevertheless, users of the library could decide to add other methods \nwith side\u00adeffects to a subclass of FunNImpl. We strongly discourage this practice but cannot prevent \nit. It is a good convention to always declare methods of indirect functoids to be const. For direct functoids, \nguarantees are even weaker. We cannot even ensure that operator () will be const, although this is, again, \na good practice. Certainly functoids with side effects can be implemented in our framework, but this \nseems both unneces\u00adsary and dangerous. Other opportunities for code with side effects abound in C++. \nOur recommendation is that code with side effects be implemented outside the FC++ framework. For instance, \nsuch code could be expressed through native C++ functions. The purist can even de.ne monads [14] using \nFC++.  5 TECHNICAL ISSUES 5.1 Library Performance As explained in Section 2.2, our basic framework \nfor indirect func\u00ad toids is quite ef.cient due to its fast memory management through reference counted \npointers. L\u00e4ufer s framework for functional pro\u00adgramming in C++ [6] de.nes functoids that are very similar \nto our indirect functoids. L\u00e4ufer s implementation ensures that no func\u00adtoid is accessible through multiple \nreferences, by copying func\u00adtoids at aliasing time (i.e., when a reference is assigned to another). Since \nindirect functoid objects do not hold mutable state (they can\u00adnot, as they only have const methods), \nreference-counting is as safe as copying. To measure the consequences of our optimization, we performed \na simple experiment. We used L\u00e4ufer s implementation of a lazy tree fringe computation, with practically \nno modi.cations to his code (to ensure that no bias is introduced). This program comprises the main example \nin L\u00e4ufer s library and consists of a monomorphic tree fringe computation (Figure 5 suggests that a polymorphic \nimplementation would be unmanageable). We attached to the main implementation a client program that requests \na tree fringe compu\u00adtation on a randomly produced tree of a given size. In Table 1, we show timings in \nmilliseconds on a Sun Ultra 5 (Sparc 300MHz processor), with both programs compiled using egcs-2.91.66 \n(the GNU C++ compiler) at optimization level 3. Different optimiza\u00adtion levels did not change the results \nqualitatively. The timings are only for the fringe computation (i.e., after tree construction). We .rst \ndetermined that the variation across different executions was not signi.cant, and then ran a single experiment \nfor each problem size (with a warm cache, as the tree was created right before the fringe computation). \nThe .rst column of Table 1 shows the number of nodes in the tree. The second shows the time taken when \nthe tree fringe client used L\u00e4ufer s functoid implementation. The third column shows the execution time \nof the same program with our indirect functoid implementation. The fourth column shows the ratio of the \ntwo for easy reference. The .fth column shows the performance of a refer\u00adence implementation: a strict \ntree fringe computation, using regu- Table 1: Performance of FC++ in the tree fringe problem (msec) Tree \nSize (nodes) L\u00e4ufer Library Indirect Functoids Ratio Strict Fringe 1000 121 28 4.32 - 2000 273 63 4.33 \n- 4000 716 132 5.42 - 8000 1320 256 5.16 16 16000 3590 600 5.98 33 32000 7611 1182 6.44 71 64000 17816 \n2449 7.27 157 128000 38758 6122 6.33 327 256000 96789 12995 7.45 816 512000 195091 23195 8.41 1361 lar \nC++ functions (no functoids, no lazy evaluation) but still free of side-effects. As can be seen, our \nindirect functoids perform 4 to 8 times faster than the implementation in [6]. Some small variation in \nperfor\u00ad mance can be observed, and this is expected, since the trees are generated from random data. \nNevertheless, overall the trend is very clear.6 The reason for the superlinear running times of both \nlazy imple\u00admentations is that for n nodes, a list of approximately logn functoid objects is kept as the \nstate of the lazy list. Since the implementa\u00adtion is purely functional, this list needs to be copied \nwhen the state is updated, making the overall asymptotic complexity O(n logn). Since copying is very \nfast with our implementation (a reference count is incremented) the performance of our code is dominated \nby a linear component, and thus the speedup relative to L\u00e4ufer s implementation increases for larger \ntrees. The superlinear scaling of the strict tree fringe computation is also due to copying the fringe \nfor subtrees at each node. That is, the strict computation is also side-effect free and has asymptotic \ncom\u00adplexity of O(n logn). We chose this to closely match the lazy implementation so that a comparison \nis meaningful. The perfor\u00admance of the strict version is signi.cantly faster than both lazy ver\u00adsions, \nbut this is hardly unexpected. The main overheads are due to the creation of functoid objects and to \ndynamic dispatch. We sus\u00adpect (but have yet to verify) that the former is much more taxing than the latter. \nThe conclusion from our simple experiment is that our mechanism for avoiding aliased referencing is at \nleast 8 times faster than copy\u00ading functoids, for realistic kinds of functoids (the more data a func\u00adtoid \nobject encapsulates, the higher the overhead of copying). 6. Clear enough that we did not consider a \nmore detailed experi\u00adment (e.g., one that will quantify the variance between runs) to be needed. Since \nmany functional programs will involve passing a lot of func\u00adtoid objects around, as this example amply \ndemonstrates, the con\u00adsequences for overall performance can be signi.cant.  5.2 Library Members Our \nimplementation is not merely a framework for functional pro\u00adgramming in C++, but an actual usable and \nextensible library. This section describes the library, which currently consists of a few thousand lines \nof code. The entire library is free of side-effects, in that every method is a const method, and all \nparameters are passed by constant refer\u00adence. This was merely a design choice based on our desire to \ndem\u00adonstrate pure functional programming in C++. The library code conceptually comprises three parts. \n5.2.1 Functoids and the List class This portion of the library implements the backbone for functional \nprogramming in C++. The FunNand FunNImplclasses are de.ned here, as well as the inheritable signature-helper \nclasses like Fun1Type. List is de.ned in a way so that elements of a list are evaluated lazily, thus \nsupporting structures like in.nite lists. 5.2.2 Standard Prelude Here we de.ne about 50 functions that \nappear in the Haskell Stan\u00addard Prelude (see [10], Section 5.6 and Appendix A), including map, filter, \ntake, foldl, zipWith, any, and elem. These func\u00adtions serve a dual purpose: .rst, they convinced us that \nit was pos\u00adsible (and easy!) to convert arbitrary functional code into C++ code using our framework; \nsecond, they provide a large and useful library to clients, just as the Haskell Standard Prelude does \nfor Haskell programmers. We chose the exact names and behaviors of Haskell functions whenever possible.7 \nIt is worth noting that this portion of the library was implemented in less than a week8 even though \nthis section is nearly half of the entire library! Once our general framework was in place and we became \nfamiliar with it, implementing a large number of functoids was very easy. 5.2.3 Other utilities FC++ \nhas a number of utility functoids. We create functoids to rep\u00adresent C++ operators, such as plus and \nequal_to, which roughly correspond to operator sections in Haskell. We have functoids for various conversions, \nsuch as monomorphize, which converts a direct functoid into an indirect functoid by .xing a type signature, \nand stl_to_fun1, which promotes a unary STL-style functoid into one of our functoids. We also provide \nfunctoids for currying function arguments. For example, rather than supplying both arguments to map as \nin map(odd,int_list) // returns List<bool> one could use bind1of2 to curry the .rst parameter bind1of2(map,odd) \n//List<int> -> List<bool> 7. Some Haskell functions, like break, have names that con.ict with C++ keywords, \nso we were forced to rename them. 8. In fact, a portion of that week was wasted tracking down a template \nbug in the g++ compiler, and .nding a legal workaround.  or instead curry the second via bind2of2(map,int_list) \n//(int->T)-> List<T>. Finally, this portion of the library also implements Ref, our refer\u00adence-counting \nclass, which is described next.  5.3 Ref There are many smart pointer implementations in C++. For FC++, \nwe use a simple reference-counting scheme, as that is suf.\u00adcient for our functoids. Each Ref contains \nthe actual pointer that it wraps up, as well as a pointer to an integer count, which may be shared among \nRefs. template<class T> class Ref { protected: T* ptr; unsigned int* count; void inc() { ++(*count); \n} ... // continued next A key for FC++ is that the Refs are subtype polymorphic; that is, Ref<U> should \nbehave as a subtype of Ref<T> if U is a subtype of T. We create an implicit conversion via a templatized \nconstructor, which exists in addition to the normal copy constructor. public: ... // implementation \ntechnicalities Ref(const Ref<T>&#38; other)//copy constructor : ptr(other.ptr), count(0) { if(ptr) \n{ count = other.count; inc(); } } template <class U> // implicit conversion Ref(const Ref<U>&#38; \nother) : ptr(implicit_cast<T*>(other.ptr)), count(0) { if(ptr) { count = other.count; inc(); } } }; \n We are assured that U is a subtype of T by implicit_cast (a common C++ idiom), which is de.ned as: template<class \nT, class U> T implicit_cast( const U&#38; x ) { return x; } Ref is a fairly mature smart pointer class \nand can be used as a complete replacement of C++ pointers. A common criticism of smart pointer classes \n(e.g., [3]) is that they do not support the same conversions as native C++ pointers (e.g., a smart pointer \nto a derived class cannot be converted into a smart pointer to a base class). Ref supports such conversions \nif and only if they would be supported for native C++ pointers. We encourage use of the Ref class for \nall functional tasks in C++.  6 RELATED WORK L\u00e4ufer s paper [6] contains a good survey of the 1995 \nstate of the art regarding functionally-inspired C++ constructs. Here we will only review more recent \nor closely related pieces of work. Dami [1] implements currying in C/C++/Objective-C and shows the utility \nin applications. His implementation requires modi.ca\u00adtion of the compiler, though. The utility comes \nmostly in C; in C++, more sophisticated approaches (such as ours) can achieve the same goals and more. \nKiselyov [5] implements some macros that allow for the creation of simple mock-closures in C++. These \nmerely provide syntactic sugar for C++ s intrinsic support for basic function-objects. We chose not to \nincorporate such sugar in FC++, as we feel the dan\u00adgers inherent in C-preprocessor macros outweigh the \nminor bene\u00ad.ts of syntax. FC++ users can de.ne their own syntactic helpers, if desired. An interesting \nrecent approach is that of Striegnitz s FACT! library [12]. FACT! provides a functional sublanguage inside \nC++ by extensive use of templates and operator overloading. FACT! emphasizes the front-end, with lambda \nexpressions and support for functions with arbitrarily many arguments. FC++, on the other hand, provides \nsophisticated type system support for higher-order and polymorphic functions. Hence, the two approaches \nare com\u00adplementary. The FACT! front-end support for expression templates can be added to FC++. At the \nsame time, most of the type system innovations of FC++ can be integrated into FACT! s back-end (enabling \nfull support for higher-order polymoprhic functions and rank-2 polymorphism). Lazy lists are to be included \nin the next version of FACT! [Striegnitz, personal communication]. The C++ Standard Template Library \n(STL) [11] includes a library called <functional>. It supports a very limited set of operations for creating \nand composing functoids that are usable with algo\u00adrithms from the <algorithm> library. While it serves \na useful purpose for many C++ tasks, it is inadequate as a basis for building higher-order polymorphic \nfunctoids. L\u00e4ufer [6] has the most sophisticated framework for supporting functional programming in C++. \nHis approach supports lazy evalu\u00adation, higher-order functions, and binding variables to different function \nvalues. His implementation does not include polymorphic functions, though, and also uses an inef.cient \nmeans for represent\u00ading function objects. In many ways, our work can be viewed as an extension to L\u00e4ufer \ns; our framework improves on his by adding both parametric and subtype polymorphism, improving ef.ciency, \nand contributing a large functional library. L\u00e4ufer also examines topics that we did not touch upon in \nthis paper, like architecture\u00adspeci.c mechanisms for converting higher-order functions into regular C++ \nfunctions. 7 IMPACT AND CONCLUSIONS We have described our implementation of a functional program\u00adming \nlibrary for C++. Our work improves upon previous work in the literature in two key ways: we add better \nsupport for polymor\u00adphism, and we improve the run-time ef.ciency of functoids. We believe these improvements \nmake our framework the .rst that is actually usable and scalable for doing real functional programming \nin C++. In particular, our novel way to support parametric poly\u00admorphism using direct functoids allows \nour functoids to be used without having to explicitly specify intermediate types; our frame\u00adwork enables \nthe compiler to infer these types and the .nal type of an expression is checked against its declared \ntype, similarly to C++ expressions on native types (e.g., numbers). Thus, we demon\u00adstrated that C++-style \npolymorphism, coupled with classes can be used to express higher-order, polymorphic functions a surprising, \nand therefore interesting, result. Our work has the potential for impact on a number of different communities: \n For C++ programmers, our framework opens new opportunities for functional programming using C++. The \nreusability bene.ts of higher-order polymorphic functions are well-known. Addi\u00adtionally, there are problems \n(e.g., callbacks within a speci.c context, delayed evaluation, dynamic function specialization) to which \nFC++ offers more concise solutions than any of the alter\u00adnatives.  For functional programmers, our framework \nenables an alterna\u00adtive platform for implementing functional programs. C++ may be an interesting platform, \nexactly because it is very different.  For language researchers, our work shows that C++ type infer\u00adence \nis a promising mechanism. The results are surprising even to experts, indicating that the C++ type system \nis still not well understood.  8 REFERENCES [1] L. Dami, More Functional Reusability in C/C++/ Objective-C \nwith Curried Functions , Object Composition, Centre Universitaire d Informatique, University of Geneva, \npp. 85-98, June 1991. [2] J. Fokker, Functional Programming, http://haskell.org/bookshelf/ functional-programming.dvi \n [3] J. Hamilton, Montana Smart Pointers: They re Smart, and They re Pointers , Proc. Conf. Object-Oriented \nTechnologies and Systems (COOTS), Portland, June 1997. [4] R. Johnson and B. Foote, Designing Reusable \nClasses , Journal of Object-Oriented Programming, 1(2): June/July 1988, 22-35. [5] O. Kiselyov, Functional \nStyle in C++: Closures, Late Binding, and Lambda Abstractions , poster presentation, Int. Conf. on Functional \nProgramming, 1998. See also: http://www.lh.com/~oleg/ftp/ . [6] K. L\u00e4ufer, A Framework for Higher-Order \nFunctions in C++ , Proc. Conf. Object-Oriented Technologies (COOTS), Monterey, CA, June 1995. [7] B. \nMcNamara and Y. Smaragdakis, FC++: The Functional C++ Library , http://www.cc.gatech.edu/~yannis/fc++ \n. [8] E. Meijer and L. Kettner, C++ as a Functional Language , discussion in Dagstuhl Seminar 99081. \nSee: http:// www.cs.unc.edu/~kettner/pieces/flatten.html . [9] M. Odersky and P. Wadler, Pizza into Java: \nTranslating theory into practice , ACM Symposium on Principles of Programming Languages, 1997 (PoPL 97). \n[10] S. Peyton Jones and J. Hughes (eds.), Report on the Programming Language Haskell 98, available from \nwww.haskell.org, February 1999. [11] A. Stepanov and M. Lee, The Standard Template Library , 1995. Incorporated \nin ANSI/ISO Committee C++ Standard. [12] J. Striegnitz, FACT! The Functional Side of C++ , http://www.fz-juelich.de/zam/FACT \n [13] B. Stroustrup, A History of C++: 1979-1991 , in T. Bergin, and R. Gibson (eds), Proc. 2nd ACM History \nof Programming Languages Conference, pp. 699-752. ACM Press, New York, 1996. [14] P. Wadler, Comprehending \nMonads , Proc. ACM Conf. on Lisp and Functional Programming, p. 61-78, 1990. \n\t\t\t", "proc_id": "351240", "abstract": "This paper describes FC++: a rich library supporting functional programming in C++. Prior approaches to encoding higher order functions in C++ have suffered with respect to polymorphic functions from either lack of expressiveness or high complexity. In contrast, FC++ offers full and concise support for higher-order polymorphic functions through a novel use of C++ type inference.Another new element in FC++ is that it implements a subtype polymorphism policy for functions, in addition to the more common parametric polymorphism facilities. Subtype polymorphism is common in object oriented languages and ensures that functions in FC++ fit well within the C++ object model.Apart from these conceptual differences, FC++ is also an improvement in technical terms over previous efforts in the literature. Our function objects are reference-counted and can be aliased without needing to be copied, resulting in an efficient implementation. The reference-counting mechanism is also exported to the user as a general-purpose replacement of native C++ pointers. Finally, we supply a number of useful functional operators (a large part of the Haskell Standard Prelude) to facilitate programming with FC++. The end result is a library that is usable and efficient, while requiring no extensions to the base C++ language.", "authors": [{"name": "Brian McNamara", "author_profile_id": "81100069068", "affiliation": "College of Computing, Georgia Institute of Technology, Atlanta, GA", "person_id": "P32825", "email_address": "", "orcid_id": ""}, {"name": "Yannis Smaragdakis", "author_profile_id": "81100614708", "affiliation": "College of Computing, Georgia Institute of Technology, Atlanta, GA", "person_id": "P304712", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/351240.351251", "year": "2000", "article_id": "351251", "conference": "ICFP", "title": "Functional programming in C++", "url": "http://dl.acm.org/citation.cfm?id=351251"}