{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 Problem-specific questions are, of course, much harder to characterize. \nYet, they seem to be the more important type of question.as, In case of a system crash, is the data Suchquestions \nbase left ina consistent state? are fheheart ofacareful review ofa design. It is our hope that though \nthese questions will be different forcach design, we will be able to discover somegeneral techniques \nthat will prove useful in formulating problem-specific questions. We hope to discover these principles \nby studying individual designs, formulating questions that we consider appropriate, and finally abstracting \nfrom these questions. A necessary prerequisite to this study is a suiktble specification language in \nwhich to express designs and questions about designs and a set of non-trivial examples. The rest of this \nmemo describes a preliminary version of a specification language for expressing designs, a non-trivial \ndesign expressed in that language, and a discussions of some of the questions we chose to ask (and answer) \nabout the design. The specification technique One can view a system as consisting of a state and a set \nof mechanisms (which we shall call routines) for changing and extracting information from that state. \nActions of the external world will also be modclled as routines, so that the current state of a system \nis always the result of routines previously performed. Any state can, however, be discussed and even \nfully understood without reference to these routines. That is to say, one can deal with the information \ncontained in the state without any reference to how that information was created or how it will be used. \nIn our specification technique we do. f)ttrspccifications consist oftwo parts. In the tirst we specify \nthe possible system states (or a supcrset of those states), and in the second the routines that deal \nwith those states. Information (i.e., a state) is static and timeless; that is to say, it involves only \nconstants. This is exactly the kind of thing that algebra traditionally deals with, and the kind of thing \nthat can be handled straightforwardly by the algebraic axiom approach to specifications as discussed \nin [Guttag 77], [Liskov 77], and [Goguen 78], among orher places. In this method, onc first presents \na set of function (operator) namcsand associated domains and ranges. These can be looked at as defining \na set of names that can be used to refer to system states, and a set of questions that can be asked about \nthese states. One next presents a set of equations designed to imply answers to the questions one can \npose about states. The information contained in each named state is thus indirectly defined in terms \nof answers to the questions that may be asked about it. Inmost ofour previous work, the function sused \ntoname states and to pose questions were identified with the set of mechanisms that would actually be \nused to interface with the system (or type) being specified. Here, as intimated above, we depart radically \nfrom that view. We choose to view the operators defined by the algebraic specification as purely mathematical \nabstractions. They may appear in specifications of programs or in reasoning about programs, but they \narc notavailable tousers ofprogr ams-bc fhesehuman users or other programs. What is available to users \nis the set of routines. The routines deal with the dynamic behavior of the system being specified. They \ninclude mechanisms far establishing initial states, for transforming one state into another, and for \nextracting information from the current state of the system. The specification of these routines follows \nand depends upon the specification of the operators. If the routine is a function, it is defined by an \nequation relating it dlrectfy to the operators. If theroutine is a statement, i.e., a declaration ora \nprocedure, it is defined using a generalization of Dijkstra s weakest precondition [Dijkstra 76] in which \nthe assertion language for expressing the predicates to be transformed and the transformation of these \npredicates includes the operators defined in the first part of the specification. As an example, we consider \ntype SimpleDisplay.l Type SimpleDisplay Operators Empty: ~ SirnpleDispiay AddLine: SimpleDisplay X Line \nX LineNumber -+ SimpleDisplay ScrollUp: SimpleDisplay + SimpleDisplay Contents: Simp[eDisplay X LineNuntber \nX CharNumber + Character Last: SimpleDisplay + LineNunrber Axioms 1) ScrollUp(Empty) = Empty 2) ScrollUp(AddLine(sd, \nline, In)) = AddLine(ScrollUp(sd), line, in-l) 3) Last(Empty) = O 4) Last(AddLine(sd, line, In)) = LineNumber.Mm(ln, \nLast(sd)) 5) Contents(AddLlne(sd, line, In), In , cn) = if LineNumber.equal(ln, In ) then Line. Read(iine, \ncn) else Coutents(sd, h , cn) {Conlent@mp@ In cn) in[ertlionally not specfiedl 2 Routines procedure \nClcm (var SimpleDisplay) such that wp(Clcar(sd), Q) = QIEmptylsd] 3 procedure Append(var Sin~pleDisp/ay, \nLine) such that wp(Appcnd(sd, lin), Q) = [Last(sd) <24 * Q[AddLine(sd, lin, Last(sd)+l)fsd] A Last(sd) \n= 24* QIAddLine(ScrollUp(sd), lin, 24)Ad]] function GetChar(SimpleDisplay, LineNumber, CharNumber) such \nthat pre(GetChar. <sol, In, en>) = 1 ~In~244 Yahrc GetChar(sd, In, cn) = Contcnts(sd, ln, cn) procedure \nReplace(var SimpleDisplay, LineNumber, Line) such that wp(Replace(sd, la, lin), Q) = 1< hrs 24 A Q[AddLinc(scf, \nb Wsd cnd Type SimpleDisplay Reasoning about a program that uses routines is a two-step process. First \nonc uses the specification of the routines to construct a predicate in which the routines do not occur. \nOne then simplifies lIntroductions to reading and writing this style of algebraic specification are contained \nin [Grrttag 77] and [Guttag 78], Briefly, an algebraic specification consists of two parts: a syntactic \nspecification and a set of axioms. The syntactic specification provides the syntactic and type checking \ninformation: tie names. domains and ranges of Ore operators associated with the type. The axioms are \nequations that cam be used to simplify expressions involving the operators. On occasion, our algebraic \nspecifications will also include a precondition specification. For a discussion of these see [Guttag \n79]. 2 Formally, this line is merely a comment, i.e.. it adds nclhing to the proof theory ,associated \nwith type SinrplcD1splay. This implies that our set of axioms is not w fflciently-complete [Guttag 78] \nsince such groulld tetms as Contents(Empty, 2, 2) cannot be furtier simphfied. As pan or oar methodology \nwe insist that the author of a specithtion explicitly indicate that such irzcompletcnesses are irdentionst \n3Q[x/y] stands for the predicate Q with x substituted for all free occurrences Of y. 4 We will, for lbc \nmost pafi, assOciaLe precondhions and failure specifications [Guttag 79] with routines rather Lhan with \noperators, this predicate using the axioms of the operators. Similarly, reading and understanding the \nspecification itself is a two step process. By separating the specification of the essential properties \nof the operators from the specification of exceptional conditions and the details of the exact user interface \n(the routines) the specification is cleanly factored. Consider, for example, trying to understand the \nvagaries of machine arithmetic. Clearly, one should begin by first understanding the operators of ideal \narithmetic. The routines implemented by a particular machine are then understood in terms of their relation \nto these operators. Introduction to the Example The body of this paper describes a partially completed \nexperiment in the application of our design techniques to a reasonably complex problem. We begin by defining, \nin a typically imprecise way, the problcm to be addressed. We then proceed (part way) through the first \ntwo steps outlined at the start of this paper: developing an intuitive understanding of the problem to \nbe solved and designing a solution to that problem. Finally, we review the design. A complete design \nreview would involve: 1) An informal introduction to the system being designed, 2) A presentation of \nthe first stage of the design: the formal specification of the operators, 3) The formulation of questions \n(or accusations) about this part of the design, 4) An examination of the design to find answers to the \nquestions, 5) A discussion of the suitability of the answers and of the virtues of alternative answers, \n6) A presentation of the second stage of the design: the routines, 7) A repetition of steps 3, 4, and \n5 for this stage of the design,s One might well question why one should devote significant effort to \nanalyzing the specification of the operators independently of that of the routines. It is, after all, \nthe routines, not the operators, that will actually be used. If our specification technique is applied \nas we intend, the spcciftcation of the routines will, for the most part, be based on the substitution \nof expressions built from operators into predicates (cf. the SimplcDisplay example above). If this is \nthe case, proving interesting properties about the operators should enhance greatly our ability to analyze \nthe predicate transformers specifying the routines simply by dividing the analysis into separate components. \nA second reason for devoting considerable effort to the in vacuo study of the specification of the operators \nis that the operators are, in a sense, more fundamental than the routines. It is our intent that the \nspecification of the operators capture the important abstractions that come out of the design experience. \nWe expect that it is this portion of the design that is tnost likely to prove reuseable. It is quite \nlikely, for example, that somewhat different sets of routines may be designed for various users. These \ndifferent user interfaces would all be related through the common set of operators on which they are \nbased. The example problem We hypothesize the arrival of a new generation of personal computers with \npowerful display devices attached to thcm. Once they arrive, we will have to write a large variety of \nprograms to run on thcm. These will inchlde such things as text ed]tors, calendar programs, circuit design \naids, debuggers, etc. Our problem is to design a standard interface to the display that can be used for \nall of these programs. Fortunately, this new display will not be terribly different from the device we \nare current!y using. Therefore, we are able to develop the ncccssary intuition about the problem area \nby studying what we consider to be some of the better interfaces to our current dkplay device. In particular, \nwe decide to create abstractions incorporating what we perceive to be the common viewpoints embodied \nin a text edhor, a message system, and a programming language environment. Ike details of the display \ninterface vary considerably among these three systems. Yet, we feel that if we can successfully abstract \nfrom these three we can construct a specification that will capture the essence of the knowledge gained \nrlrrough a number of years of experience with the old display device. An informal overview of the design \nWe make no attempt here to describe the design in significant detail. Previous attempts to provide a \ndetailed discussion of the design independently of the formal specification did not prove successful. \nWc therefore leave a careful description of the design to the formal specification, and content ourselves \nhere with presenting a few preliminary comments for the reader. Additional comments accompany the formal \nspecification. 1) A fundamental assumption underlying the viewpoint our design attempts to capture is \nthat the user of the display will wish to have several disjoint blocks of displayable information available \nat the same time. These blocks are called piclures. 2) A view is a spatial arrangement of pictures. Any \narrangement, including those in which pictures overlap one another, is allowed. 3) A picture may be thought \nof as consisting of three parts: a boundary, a corrlerrts, and a spatial (coordinate) transformation \nto be applied in viewing the contents. By changing the transformation, one can change the size of the \ncontents, and the portion that falls within the boundary. 4) Pictures have explicit boundaries that correspond \nto visible areas on the display. The boundaries associated with the contents of a picture are implicit, \narising from the intrinsic structure of the information to be displayed. I.e., pictures are clipped and \ncontents are not. 5) Examples of pictures are the entire area of a CRT display, and the interior of a \nfixed rcctanglc on the CRT; examples of contents are text documents, figures, and views. 6) Figures 1-4 \nshow examples of major types. No real gentleman speaks the naked truth in the presence of ladies. .. \nMark Twain srn this ~apcr ~vedo ~ot deal with steps 6 or 7 of tie design review prOce~. We Figure 1. \nText are still in the process of forrnallting a set of routines that wc find acceptable, The Formal \nSpecification of the Operators Some remarks on notation real gentleman speaks In the process of creating \nthe specification presented ed truth in the present found ourselves inventing and using a number adies. \n --Mark Twain shorthands. We found these to be a great help. presenting this specification to others \nwe found these conventions to be something of a hindrance. We inferences from this experience. The first \nis that if spend considerable time writing or reading i.____lworthwhile to invest some time in becoming \nFigure 2. Picture  gentleman speaks in the presence -Mark Twain ----J nE No real gentleman speaks the \nnaked trutll in the presence of ladies. -. Mark Twain I I I Figure 3. View gentleman speaks in the \npresence Mark Twain of I No real gentleman speaks the naked truth in the presence of ladies. --Mark \nTwain m in this paper we of notational Paradoxically, in same notational have drawn two one is going \nto specifications, it is clearly comfortable with a compact notation. Since these notations present a \nconsiderable hurdle to the uninitiated, wc have largely refrained from using them in this paper. The \nsecond, and more interesting, inference is that it seems to be useful to maintain semantically consistent, \nbut rotationally distinct versions of the same specification. When we wished an overview of the whole \ndesign, we used a notation (similar to the graph of Figure 5) intended to clearly expose some of the \nrelationships among the types, e.g., which types were used in the specification of other types. When \nwe wished an overview of the type, we made extensive use of syntax to get an overview of the structure \ngettiug bogged down in details. When groups of axioms, we found it macros thus making the axioms more \nwe wished to modify the axioms, wc specification for an individual macros. This made it possible of the \nspecification without studying individual or small convenient to expand the self-contained. Finally, \nwhen found it convenient to use a notation with as little redundancy as possible. No examples of this \nnotation, which is not well-developed, appear in this paper. Piciu re ~ \\ Contents Boundary Transform \n[Coordinate + Boolean] [Coordinate + Coordinate] I CompGnent P\\ View Text J Paragraph II Line I Character \n/\\ Figure Code Figure 5. Relations Among Types Figure 4. Picture One notational convention we have retained \nin this paper is the Lei clause. This is used to define nonrecursive textual macros whose scope is a \nsingle type definition. It adds no power to the specification technique, but it can structure and shorten \nthe text of a specification. The primary role of a Let clause, however, is to record the decision that \ncertain subexpressions are to be the same. This is particularly important when understanding or modifying \na specification, since it is all too easy to overlook an intended equivalence (or fail to spot pertinent \ndifferences) between textually distinct subexpressions. The abstractions (types) We separate the design \nof the display interface into two groups of abstractions, each of which involves a number of interrelated \nconcepts. The first group is primarily concerned with the structure of areas of the dkplay, and involves \nthe types Picture, Corrterrt~ Component, and View. The second group is primarily concerned with the structure \nof the data to be displayed, and involves the types Text (with subordinate types Paragraph, EnglishSfring, \nLine, Characler, and Disfance) and Figure. The interface between these two groups is comparatively narrow. \nTo be acceptable as a component (of a contents), a type must supply an Appearance function, which maps \na coordhtate into an illumination, and an In predicate on coordinates. View, Text, and Figure are each \nacceptable component types. The recursion on View and Picture permits the structuring of a particular \ndisplay into any number of levels of views. Figure 5 portrays the hierarchical structure of the specification. \nWe present it as a road map to be used while reading the specification itself. It is not actually part \nof the specification, i.e., it plays no role in the formal analysis of the design. The generic functions \nAppearance and In These functions are generic, in that the same names are used in different types to \nidentify distinct, but similar, functions. The precise meaning of these functions is contained in the \nformal specifications of the relevant types. In each type for which they are defined, however, these \nfunctions have meanings consistent with the following informal descriptions. To avoid confusion, we precede \neach use of a generic function name with its type name, except within its type s specification (e.g., \nFict~mAppearance will be shortened to Appearance within the specification of Piclure). Appearance plays \na central role in this design: It takes a displayable object and a Coordinate, and returns the Illumination \nof the object at that point. Most of this design is independent of the nature of types -Coordinate and \nIllumination. Abstractly, we thk of Appearance as mapping from a point in space to a light intensity. \nAny given implementation will bc an approximation to this abstract mapping; for example, it might map \ndiscrete two-dimensional Cartesian coordhtates into any of elements of {Black, White}, n-bit gray-level \nintensity values, or <hue, saturation, brightness> triples. In is a binary predicate applicable to many \n<displayable object, coordinate> pairs. It is true if the coordinate falls within the object, false otherwise. \nMany of our statements about the structure of displays involve this predicate. Although we indicate how \nits vahrc for composite objects depends on its value for components, we are not concerned here with its \ncomputation; indeed, some implementations might never compute it explicitly at all. Types Picture, Contents, \nComponent and View Fach picture has a contents, a boundary predicate (defining the area it occupies), \nand a transformation function relating the coordinate system of the picture to that of its contents. \nFor a picture, In is determined entirely by its boundary; Appearance, by its contents after coordinate \ntransformation. The contents of a picture is composed of some number (possibly zero) of components, each \nwith a coordinate which is its position within the contents. Every component is either a tex~ a figure \nor a view. View is perhaps ths most Iinteresting type of component. A view consists of a numbqr (possibly \nzero) of pictures, each with a coordinate (used to determine its position) and a picture id. The size \nand shape of each picture are defined by the picture s boundary, not by the yiew. AddPlcttrre places \na new picture at the front of a view. Appearance at an~ given coordinate is determined by the frontmost \npicture that contains the coordinate. This implies that at points of overlap, only the frontmost picture \ns contents will be displayed (a 2%-D diyplay). FindPictures produces a sequence of picture ids of all \nthe pictures in coordinate. DeletcPicttme removes bound to the specified picture id. a view that the \nfrontrnost contain picture a (if given any) Type Picture Operators MakePicture: Con~errls X [Coordinate \n+ Boolean] [Coordinate + CoordinaleJ + Picture Appearance: Piclure X Coordinate + Illumination In: Picture \nX Coordinate+ Boolean X Axioms 1) Appearance(MakcPicture(cont, bound, trans), coord) = rhmn~s.Appearance(trans(coord)) \noont, 2) In(MakcPicturc(cont, bound, trans), coord) = bound(coord) cnd type PicWre 1) Thk axiom specifies \nthat the appearance of a picture depends only upon the appearance of its contents and the picture s transformation \nfunction. Note that no clipping, based on the boundary, is done here. 2) This axiom states that whether \nor not a coordinate is in a picture is determined SOICIY by the picture s boundary. Type Conlents Operators \nEmpty: * Contents AddComponent: Contents X Component X Coordinate+ Contents Appearance: Conlents X Coordinate \n@ Illumination In: Corrlents X Coordinate + Boolean Axioms 1) Appearancc(AddComponent(cont, comp, coord \n), coord) = if Component.ln(comp, Minus(coord, coord )) then if In(cont, coord) then Combine(rlmponermAppearance(comp, \nMinus(coord, coord)), Appearance(cont, coord)) else conpomnt.Appearance(comp, Minus(coord, coord )) else \nAppearance(cont, coord) {Appearance(Empty, coord) intentionally not specified} 2) In(Empty, coord) = \nFalse 3) In(AddComponent(cont, comp, coord ), coord) = ComPonem.In(comp, Minus(coord, coord )) V In(cont, \ncoord) cnd type Contents 1) This axiom specifics that the appearance of a contents at a coordinate is \na function, Combine, of the appearance of the top component at that coordinate and the appearance of \nall the other components at that coordinate (if there are any). 2-3) These axioms specify that whether \nor not a coordinate is within a contents is based upon whether or not it is contained in one of the contents \ncomponents. Type Componem Operators ViewAsComponent: View+ Componem TextAsComponent Texf -+ Comporrent \nFlgureAsComponent: Figure+ Component Appearance: Componem X Coordinate+ Illumination In: Component X \nCoordinate+ Boolean Axioms 1) Appearance(ViewAsComponent(v), coord) = ro,,v.Appearance(v, coord) 2) Appearancc(TextAsComponent(t), \ncoord) = ~w.Appearance(t, coord) 3) Appearance(FigureAsCotnponent(t), coord) = ~igw..Appearance(f, coord) \n4) In(ViewAsComponent( v), coord) = Yiew.In(v, coord) 5) In(TextAsComponcnt( t), coord) = nx[.In(t, coord) \n6) In(FigureAsComponent( f), coord) = Figure.ln(f, coord) cnd type Component 1 6) These axioms specify \nthat Component is merely a disjoint union type. Type View Operators Empty: ~ View AddPicture: View X \nCoordinate X PictureId X Picture + View Appearance: View X Coordinate+ Illumination In: View X Coordinate+ \nBoolean FlndPictures: View X Coordinate + IdList DeletePicture: View X PiciureId + View Axioms 1) Appearance(AddPicture(v, \ncoord , id, p), coord) = if ?icmre.ln(p, Minus(coord, coord )) then ~icrw-e.Appearancc(p, Minus(coord, \ncoord )) else Appearance(v, coord) {Appearance(Ernply, coord) irrleniionally nol specijled] 2) In(Empty, \ncoord) = False 3) In(AddPicture(v, coorrf , id, p), coord) = mrudrr(p, Minus(coord, coord )) V In(v, \ncoord) 4) FindPictures(Empty, coord) = ~~~i,rl.Empty 5) FindPictures(AddPicture(v, coord , id, p), coord) \n= if Pjc(ure.[n(p, Minus(coord, coord )) then MLisf. Insert(id, FindPictures(v, coord)) else FindPictures(v, \ncoord) 6) DeletePlcture(Empty, id) = Empty 7) DeletePicture(AddPicture(v, coord, id , p), id) = if ~icwreld.Equal(id, \nid ) then v else AddPicture(DeletePicture(v, id), coord, id , p) end type View 1) This axiom specifies \nthat the appearance of a view at a coordinate depends entirely upon the appearance of the topmost picture \ncontaining that coordinate. The test in the conditional effects clipping for pictures in views. 2-3) \nThese axioms specify that a coordinate is within a view only if it is within one of the pictures placed \nin the view. 4-5) These axioms specify that the value of FlndPictures applied to a view and a coordinate \nis the sequence of picture ids associated with pictures that contain that coordinate. 67) These axioms \nspecify that pictures associated with the same picture id are deleted in a LIFO fashion. Type IdList \nOperators Empty: ~ IdList Insert Pic(ure[d X IdList ~ IdList First: IdList + Pic{ureId Null: IdLisl + \nBoolean Axioms 1) First(Insert(p, ii)) = p {fi irs[(Enrpty) intentionally not spec~ed~ 2) Null(Empty) \n= True 3) Null(hsert(p, ii)) = False end type IdList 1-3) These are standard axioms for a sequence type. \nText and its subsidiary types Text is structured as a sequence of paragraphs; each paragraph consists \nof paragraph looks and an English string, which is a sequence of characters. ~ewAppearance is determined \nby ParagraPhAppcarance of the first paragraph containing the given coordinate. Each paragraph is offset \ndown by the height of the preceding paragraph. ~amgrapfi.Appearance is, in turn, determined by Li.e.Appearance \nof the first line containing the coordinate, after the paragraph s string has been broken into lines \nin accordance with the maximum width specified by the paragraph s looks; each line is offset down by \nthe height of the preceding line. ~im.Appearance is determined by c~awcm,.Appearance of the tirst character \nin the line that contains the coordinate.6 6Given cemin restrictions on the relationship of Characfer.Asr.enk \nCharacfer.Descent, and Ckunrc[er.Width to Chzrac/erJn, one can prove that a coordinate can be in at most \none paragraph, one line, and one character. When it is displayed, a paragraph is broken into as few \nlines as possible, consistent with the following intentions: Lines should not be wider than the paragraph \ns maximum width, Each carriage return should terminate a line. Words should not be broken across lines. \n A more precise statement of how a paragraph is to be dkplayed is contained in the specifications of \ntypes EnglishString and Line aPPcaring in the appendix. Operators Empty: -Text Insert Paragraph X Text+ \nText Appearance: Text X Coordinate* Illumination hr: Text X Coordinate+ Boolean Axioms Let Down(d) be \nMinus(coord, Times(d, UnitVectorDown)) in 1) Appearance(hlsert(p, t), coord) = if Rrnrgnrph.h(p, coord) \nthen ~aragmP)l.Appcarance(p, coord) else Appcarance(g Down(~amgwrph.Height(p))) {Appearance(Empty, coord) \ninlentional[y not specijed] 2) In(Empty, coord) = False 3) In(Insert(p, t), coord) = ~ aragraPh,In(p, \ncoord) V In(t, Down(Paragraph.Height(p))) end type Tex( 1) This axiom specifies that if a coordinate \nis in the most recentfy inserted paragraph, then the appearance of the text at that coordinate is equal \nto the appearance of the paragraph at that coordinate. It also implies that the inserted paragraph appears \nabove the rest of the text, and that the paragraphs in the rest ,of the text are offset down by the height \nof the inserted paragraph. 2-3) These axioms specify that whether or not a coordinate is in a text depends \nupon whether or not it is in one of the text s paragraphs. Again we see it implied that the remaining \ntext is displayed below the inserted paragraph. Type Paragraph Operators MakeParagraph: ParagraphLooks \nX EnglishString ~ Paragraph FkstLine: Paragraph + Line Balance: Paragraph + Paragraph Null: Paragraph \n+ Boolean Space: Paragraph + Distance Height: Paragraph + Dislance In: Paragraph X Coordinate+ Boolean \nAppearance: Paragraph X Coordinate+ Illumination Axioms tit Down(d) bc Minus(coord, Times(d, UnitVectorDown)) \nin 1) FirstI.ine(MakcParagraph(look, s)) = ~~tg[/sflstri~g.Fi~tLillc(s, ~arag,aphhd~. Width(look)) 2) \nBalance(MakeParagraph(look, s)) = MakeParagraph(look, E.glishStri.g.Balance(s, ParagraphLook..Width(look))) \n 3) Null(MakcParagraph(look, s)) = ~rring.Null(s) 4) Space(MakcParagraph(Iook, s)) = PmrgnrphLooks.Space(look) \n5) Height(p)= if Nu1l(D) .. , then Space(p) else ~in..Height(FirstLlne(p)) + Height(Balance(p)) 6) \nIn(u. coord) = .. -Null(r)) . A [~inAr(FirstLine(p), Down(Space(p)+ ~im.Ascent(FirstLine(p)))) V In(Balance(p), \nDown(~ine.Height(FirstLine(p))))] 7) Appearance(p, coord) = if ~m..In(FlrstLine[~), Down(Space(p) + \n~im.Ascent(FirstLine(p)))) then ~imJAppearan;c(FirstLine(p), Down(Space(p)+ ,ci.,.Ascent(FirstUne(p)))) \nelse Appearance(Balance(p), Down(~im.Height(FhstLine(p)))) end type Paragraph 1) The operator FirstLine \nmaps a paragraph to its first displayable fine. The width of that line is based upon the looks of the \nparagraph and conventions for breaking a line of English text. The latter is specified in type EnglishSlr-ing, \n2) The operator Balance maps a paragraph to a paragraph whose first displayable line has been removed. \n3) This axiom specifies that a paragraph is null if and only if the English string associated with it \nis null. 4) This axiom specifies that the (Icading) space associated with a paragraph is a function of \nthe paragraph s looks. 5) This axiom specifies that the height of a paragraph is the sum of its (leading) \nspace and the heights of all of its lines. Notice that no mention is made of the space between lines. \nThat is accounted for in the specification of Line.Height. 6) This axiom specifies that whether or not \na coordinate is within a paragraph depends upon whether it is in one of the paragraph s displayable lines. \nThe complicated second argument to Line.In specifies that the origin of a displayable line is offset \ndownwards by the (leading) space of the paragraph and the ascenders of that fine. Informally, ~ine.Ascent \nis the distance the tallest character in the line extends above its base line. 7) This axiom specifies \nthat the appearance of a paragraph at a coordinate is based upon the appearance of the dkplayable fine \ncontaining that coordinate. (If a coordinate is not contained in any fine, the appearance is not specified.) \nThe remainder of this specification raises few interesting issues of design or specification methodology, \nand is therefore relegated to the appendix. The only thing worth noting here is that the specification \nof type EnglishSlring is unfortunately somewhat complicated. We feel, however, that this reflects the \ncomplexity of the conventions oscd in displaying English text, rather than any property of our specification \ntechnique. (Earlier, simpler, specifications were shown to violate those conventions in some cases.) \nAn Abridged Analysis of the Operators We have spent a great deal of time analyzing this specification \nand several earlier versions. A complete discussion of this analysis is well beyond the scope of this \npaper. We therefore limit ourselves here to a presentation of a few representative questions. The presentation \nof each question mirrors our analysis. We begin by formulating in English a question about the design. \nSome of these are questions that we first posed ourselves, but most are re\u00adformulations of questions \nfirst asked of us by others. As one might suspect, this latter class of questions tended to be the more \nrevealing of peculiarities in our design. Next we present a formal statement designed to get at the issues \nraised by the informal question. We formulated all of these formal questions ourselves, i.e., wc did \nnot ask those who supplied L[S with informal questions to translate them. Rather, we asked them to examine \nour translation, and tell us whether or not it was appropriate. Finally, we present the answer to the \nformal question, an explanation of how we arrived at that answer, and a brief discussion of the question \nand its answer. Infonmd question: Is it the case that pictures are not transparent or even translucent? \nI.e., if two pictures overlap does the bottom one have no effect on what one sees through the top one? \nFormal question: Is it true that (V c, c , w, id, v1, v2) [ricnire.In(w, Minus(c, c )) =+ [J@w.Appcarance(AddPicture(vl, \nc , id, w), c)= v,e,,.Appearance( AddPicture(v2, c , id, w), c)]] ? Answer: Yes. This theorem follows \ndirectly from the first alternative in the second axiom of type View. Discussion: The formal question \nposed and answered is somewhat more general than the informal one. It tells us that the appearance of \na picture is independent of the context in which the picture is used. In making the step from the informal \nto the formal we have often ended up posing a more general question. Sometimes we have done so merely \nbecause the more genera] question was easier to pose or to answer. Often, however, we have done so to \nreflect the fact that in formalizing the initial question we discovered a number of related questions \nthat struck us as equally interesting. Informal question: Is it true that the appearance of a contents \nis determined at each coordinate by the frontmost component containing the coordinate? Formal question: \nIs it true tiat (~ cp, C, c , cnl, cn2) [cmrpmen~.In(cp, Minus(c, c )) * [Appearance(AddComponent(cnl, \ncp, c ), c) = Appearance(AddComponent(cn2, cp, c ), c)]] ? Answer: Perhaps. The question reduces to whether \nwe can prove (V il, i2, i3) [Combine(il, i2) = Combine(il, i3)]. This question is not answered by our \nspecification. Discussion: A significant number of the questions we dealt with had perhaps answer. This \nmeant that the answer depended astheir upon design decisions that had yet to bc made, e.g., the properties \nof Combine,. These questions, and their answers, sLIpply us with information that can guide us in continuing \nthe design. In this case, we decided that the answer to the question should be no. Consequently, Combine(il, \ni2) will not be identically il. Notice, by the way, that this question is quite similar to the first \nquestion, and our decision about Combine establishes a critical difference between pictures and components. \nInformal question: If I add the same component to the contents of two pictures that appear to be identical, \nwill the the resulting pictures also appear to be identical? Formal question: Is it true that (V CU1, \ncn2, bd, trl, tr2) [(V c)[Appearance(MakePicture(cnL bd, trl), C) = Appearance(MakePicture(cn2, bd, tr2), \nc)] *(V cp, c, c ) [Appearancc(MakeP1cture( AddComponent(cnl, cp, c ), bd, trl), c) = Appcarance(MakePicture( \nAddComponent(cn2, cp, c ), bd, tr2), c)]] ? Answer: No. Since the coordinate transformation is associated \nwith the picture, rather than the contents, the new component may undergo quite different transformations \nin the two pictures. Discussion: When the informal question was posed about an earlier design, it was \nobvious to us that the answer was no. We then changed the design with the intent of making the answer \nyes. It was several weeks later when we formalized the question and attempted a formal proof and discovered \nthat the answer to the informal question was still no. The informal question that can be answered yes \nis: If I add the same component to two contents that appear to be identical, will the resulting contents \nalso appear to be identical? Formally: Is it true that (V cnl, cn2) [(V c)[Appearancc(cnl, c) = Appearance(cn2, \nc)] -(V cp, c, c ) [Appcarance(AddComponcnt(cnl, cp, c ), c) = Appcarancc(AddComponenl(cn2, cp, c ), \nc)]]? Conclusions The most difficult part of this exercise was deciding on the abstractions we wished \nto have and on the functionalities of the operators associated with these abstractions. This is not surprising. \nAnyone who has spent time designing software knows that dividing it into appropriate modules is a difficult \ntask. Fortunately, the process of trying to a~iomatize the abstractions we had provisionally chosen proved \nto be a great help. Whenever we discovered that the axioms specifying a type were getting overly complex, \nwe took this to mean that we had not achieved a proper separation of concerns, and consequently revised \nour choice of abstractions. Since we proceeded in a largely top-down manner, this kept LIS from spending \ntoo much time following unprofitable paths. Writing the axioms also helped to prevent LIS from making \nsome premature decisions. In our initial specification, for example, we specified type Coordinate to \nbe Cartesian coordinate and type illumination to be {Black, Whi~e}, i-n writing tic axioms, we noticed \nthat we nowhere depended upon these choices. This prompted us to change our design, leaving them unbound \nat this stage. Many readers will doubtless take exception to some of the decisions embodied in our design. \n(In fact, we hope that our specification is clear enough that they can understand precisely what they \ndon t like about it.) We are not experts on the subject of display interfaces, and our goal was not to \ndesign an excellent display interface. It was to develop a tool which, with the help of an expert in \nthe application area, could be used to derive, document, and analyze an excellent design. Wc feel that \nthus far our experiment has been a success. While from time to time we had considerable difficulty in \ndeciding how to design various aspects of the display, we had little troub]c expressing our decisions \nonce they were made. Furthermore, we found our formalism useful in clarifying when a decision had to \nbe (or had been) made, what the alternatives were, and what the ramifications of each choice would be, \nThe formal specification also proved to be a useful communication medium. We were able to use it in precise \ndiscussions of the design not only between ourselves, but also with others. We found the latter particularly \nencouraging. Fhtally, we were able to modify various portions of the design in a number of significant \nways over a considerable period of time. Oor experimentation with this tool is incomplete. We have only \njust begun to specify the routines for displays, While we do not anticipate any problems, we will doubtless \nrun into unanticipated ones. We also lack significant experience of combining independently constructed \ndesigns into the design of a larger system. The ease or difficulty of doing this will have a major effect \non the practical utifity of these techniques. Acknowledgments f We received helpful suggestions from \nmany people in the course of doing this design and writing this paper. Our colleagues at the Xerox Palo \nAlto Research Center, as well as members of IFIP Working Group 2.3 (Programming Methodology) and the \ninformal ARPA working group on Quality Software for Complex Tasks, were particularly helpful. We owe \nspecial thanks to Bill McKeeman and Jeannette Wing for their tenacity in sticking with us over many versions. \nReferences [Dijkstra 76] E. W. Dijkstra, A Discipline of Programming, Prentice-Hall. 1976. [Goguen 7S] \nJ. A. Gogucn, J.W. Thatcher, and E. G. Wagner, An Initial Algebra Approach to the Specification, Correctness, \nand implementation of Abstract Data Types, Curren/ Trends in Programming Methodology Volume IV (cd, Raymond \nT. Yeh), Prentice-Hall, 1978. [Guttag 77] J. V. Guttag, Abstract Data Types and the Development of Data \nStructures, Comm, ACM 20,6, pp. 396-404, June 1977. [Guttag 78] J. V. Guttag and J. J. Horning, The Algebraic \nSpecification of Abstract Data Types, ACM Informatica 10, 1, pp. 27-52, 1978. [Guttag 79] J, V. Guttag, \nNotes on Type Abstraction, Proc. Specljicalions of Reliable Sojiware Conference, IEEE Cat. No. 79 CH1401-9C, \npp. 36-46, April 1979. [1-iskov 77] B. H. Liskov and S. N. Zilles, An Introduction to Formal Specifications \nof Data Abstractions, Curren[ Trends in Programming Methodology Volume I, (cd. Raymond Yeh), Prentice-Hail, \n1977. ?Supported in pan by tbe National Science Foundation under grmt MCS78-01798 and by an Office of \nNaval Research Conlract with DAltPA fundins # NOOO14-7S\u00adC-0661. Appendix Collected Formal Specifications \n Type Picture Operators MakePicture: Confents X [Coordinate + Boolean] X [Coordinate + Coordinate]+ Picture \nAppearance: Picture X Coordinate+ Illumination In: Picture X Coordinate+ Boolean Axioms Appearance(MakePicture(cont, \nbound, trans), coord) = cmrrems.Appearance(cont, trans(coord)) In(MakcPicturc(cont, bound, trans), coord) \n= bound(coord) end type Picture Type Contenls Operators Empty: * Contents AddComponenC Contents X Componeni \nX Coordinate + Contents Appearance: Contents X Coordinate+ Illumination In: Contents X Coordinate -+ \nBoolean Axioms Appearance(AddComponent(cont, comp, coord ), coord) = if c~rnp~~em.hr(comp, Minus(coord, \ncoord )) then if In(cont, coord) then Combine(c~mpo~g~[. Appearance(comp, Minus(coord, coord)), Appearance(cont, \ncoord)) else cmpmzmu.Appearance(comp, Minus(coord, coord )) else Appearance(cont, coord) {Appearance(Empty, \ncoord) intentionally not specfiedj In(Empty, coord) = False In(AddComponent(cont, comp, coord ), coord) \n= Comp.nem.In(comp, Minus(coord, coord )) V In(cont, coord) end type Conlents Type Component union of \nView, Text, Figure end type Component Type View Operators Empty: -+ View AddF7cture: View X Coordinate \nX PictureId X picture + View Appearance: View X Coordinate+ Illumination In: View X Coordinate+ Boolean \nFindPictures: View X Coordinate + IdList DeletePicture: View X PictureId + View Axioms Appearance(AtklPlcture(v, \ncoord , id, p), coord) = if ~icaue.In(p, Mirrus(coord, coord )) then ~rcwre~ppearance(p, Minus(coord, \ncoord )) else Appearance(v, coord) {Appearance(Ernply, coord) intentionally rrol specijiedj In(Empty, \ncoord) = False In(AddPicture(v, coord , id, p), coord) = mnm,In(p, Minus(coord, coord )) V In(v, coord) \nFhrdPictures(Empty, coord) = rdrwEmpty FMdPictures(AddPicture(v, coord , id, p), coord) = if Pictuw.ln(p, \nMinus(coord, coord )) then fdLkf.Insert(id, FtndPictures(v, coord)) else FindPictures(v, coord) DeletePicture(Empty, \nid) = Empty DeletcPicturc(AddPicture(v, coord, id , p), id) = if ~icnm~&#38;Equal(id, id ) then v else \nAddPicture(DeleteFlcttu c(v, id), coord, id , p) end type View Type IdList sequence of Pictureld cnd \ntype IdLisl Type Tex( Operators Empty: d Text Insert: Paragraph X Texl -+ Text Appearance: Texl X Coordinate+ \nIllumination In: Texl X Coordinate+ Boolean Axioms Let Down(d) be Minus(coord, Times(d, UnitVectorDown)) \nin Appearance(Insert(p, t), coord) = if ~ara8nrP/dn(p, coord) then ~arugraph.Appcarance(p, coord) CISCAppearance(t, \nDowrl(Paragra@.Height(p))) {Appearance(Entp(y, coord) intentionally not spec$edj In(Empty, coord) = False \nIn(Insert(p, t), coord) = Rzragrap}dtt(p, coord) V In(t, Down(paragr@,Height( p))) end type Tex[ Type \nParagraph Operators MakeParagraph: ParagraphLooks X EnglishString + Paragraph FkstLlne: Paragraph + Line \nIlalancc: Paragraph+ Paragraph Null: Paragraph + Boolean Space: Paragraph + Distance Height: Paragraph \n+ Distance In: Paragraph X Coordinate+ Boolean Appearance: Paragraph X Coordinate+ Illumination Axioms \nLet Down(d) be Minus(coord, Times(d, UnitVectorDown)) in FirstLine(MakcParagraph(look. s)) = &#38;@ish~rring.FirstLine(s, \n~arag,-apk~o.ks.Widti( look)) Balance(MakcParagraph(look, s)) = MakeParagraph(look, zng/ishS~ring.BaIance(s, \npuragraph~mk..Width(look))) Null(MakeParagraph(look, s)) = S[ring.Null(S) Space(MakeParagraph(look, s)) \n= ~ar.gr.ph~ooks. Space(look) Height(p) = if NLdl(p) then Space(p) else ~ine.Height(FirstLhc(p)) + Hcight(Balance(p)) \nIn(p, coord) = 7 NLdl(p) A [~i.e.In(FirstLine(p), Down(Space(p)+ z.itre.Asc@FirstLine(p)))) V In(Balance(p), \nDown(~im.Iieight(FirstLinc(p))))] Appcarancc(p, coord) = if ~.in,.ln(FirstL,inc(p), Down(Space(p) + Line. \nAscent(FirstI.ine(p)))) then ~,ine.Appcarance(FirstLine(p), Down(Space(p)+ LimAscent(FirstLine(p)))) \nelse Appearance(Balance(p), Down(Li.e.Height(FlrstLine(p)))) errrf type Paragraph Type EnglishString \nOpemtors Empty: + EnglishString Insert: Character X EnglishString + EnglishString FLrstLinc: EnglishString \nX Distance + Line Balance: EnglishString X Distance + EnglishString SplitHere; EnglishS[ring X Character \nX Distance + Boolean WordFits: EnglishString X Character X Distance + Boolean Null: EnglishString + Boolean \nLet LexicalBreak(current, next) be [[cmnzcw.Equal(currenc, quoteSpace) A 7 chmrc[w.Equal(crcxt, quoteSpace)] \nV [C hrracrer.Equal(currcnt, quotcHyphen) A T c/~a,~,re,.Equal(next, quoteHyphen) A = chracrer.Equal(ncxt, \nquoteSpace)]]  in FirstI.ine(Empty, d) = ~i~..Empty FirstLine(Insert(c, s), d) = if SplitHere(s, c, \nd) then c else he.Insert(c, FirstLine(s, d Chmrcter.Width(c))) Balance(Empty, d) = Empty Balance(Insert(c, \ns), d) = if SplitHere(s, c, d) thens else Balance(s, d Charmw.Width(c)) SplitHere(Empty, c, d) = True \nSplitHere(Insert(c , s), c, d) = Characw.ECtual(c, quoteCR) V [-Cha~~cter.Equal(c , quotespace) Ad< r \nharacter.width(c) + Charmrw.Width(c )] V [Lexical Break(c, c ) A v WordFits(s, c , d Cha,acfer.width(c))] \n WordFits(Empty, c, d) = True WordFits(Insert(c , s), c, d) = Charac/cr.Equal(c, quoteCR) V Ckmrc[er.Equal(c, \nquoteSpace) V [LexicalBreak(c, c ) A 7 d < C&#38;acter.Width(c)] V [1 d < Chmrcfer.Width(c) + chmtc,er.Width(c \n) A WordFits(s, c , d Chmrctci-.Width(c))] Null(Empty) = True Null(Insert(c, s)) = False cad typo Sfrirrg \nType Line Operators Empty: ~ Line Insert Character X Line+ Line Appearance: Line X Coordinate+ Illumination \nIn: Line X Coordinate+ Boolean Height Line + Distance Ascerm Line ~ Dislance Descent: Line + Distance \nAxioms I.et Right(d) be Minus(coord, Times(d, UnitVectorRight) in Appearancc(Insert(c, in), coord) = \nif Charcrc[er.ht(c, coord) then cham.mr.Appcarance(c, coord) else Appearance(In, Right(Characrer. Width(c))) \n {Appearance(Emply, coord) intentionally not spec~edj In(Empty, d) = False In(Insert(c, In), coord) = \nc%mcrer.hr(c, coord) V In(In, Right(Chmzcter.Width(c))) Height(ln) = Ascent(In) + Descent Asccnt(Empty) \n= O Ascent(Insert(c, in)) = Max(Cbaracter.Ascent(c), Ascent) Dcscent(Empty) = O Desccnt(Insert(c, in)) \n= Max(chanw[w.Descent(c), Dewen@@) end type Line Type Character record of Code: CharacterCode, Fig: Figure, \nAscent: Distant< Descent: Distance, Width: Distance Operators E@ral: Charac!er X Characler + Boolean \nAppearance: Character X Coordinate+ Illumination In: Characler X Coordinate + Boolean Axioms Equal(c, \nc ) = CharacterCode.Equal(COde(c), Code(c )) Appearance(c, coord) = Figw-e,Appearance( Fig(c), coord) \nIn(c, coord) = ~igwe.In(Fig(c), coord) A -Ascent(c) f Proj~ct(coord, UnitVectorDown) < Descent(c) A 0< \nProject(coord, fJ nitVectorRight) ~ Width(c) end type Character Type Figure The major task in completing \nthe first stage of this spccitication would be supplying a definition for this type, which will probably \nbe richer (more complex) than Texf. f he specification thus far relies only on the existence of two operators \non figures (see the definitions of Component and Character). Operators Appcarancc: Figure X Coordinate \n+ Illumination [n: Figure X Coordinate ~ Boolean end type Figure Type Coordinate This type is not fully \ndefined in this specification, It clearly must supply the operators we use. We intend that it be either \na general vector space, or some specific vector space, but do not seem to need all the axioms of a vector \nspace. Operators Minus: Coordinate X Coordinate* Coordinate Times: Distance X Coordinate+ Coordinate \nProjecc Coordinate X Coordinate + Distance cnd type Coordinate Type Dislance This type has the ordinary \nproperties of a (scalar) number, which we do not axiomatize here. In particular, we choose not to specify \nwhether the arithmetic is to be integer, real, floating point or .... Operators +: Distance X Distance \n+ Distance : Distance X Dislance + Distance Max: Dis@nce X Distance+ Distance <: Dis/ante X Distance \n+ Boolean end type Distance \n\t\t\t", "proc_id": "567446", "abstract": "The formulation and analysis of a design specification is almost always of more utility than the verification of the consistency of a program with its specification. Good specification tools can assist in this process, but have generally not been proposed and evaluated in this light. In this paper we outline a specification language combining algebraic axioms and predicate transformers, present part of a non-trivial example (the specification of a high-level interface to a display), and finally discuss the analysis of this specification.", "authors": [{"name": "John Guttag", "author_profile_id": "81100171020", "affiliation": "MIT Laboratory for Computer Science, Cambridge, MA", "person_id": "PP43125618", "email_address": "", "orcid_id": ""}, {"name": "J. J. Horning", "author_profile_id": "81100419927", "affiliation": "Xerox Palo Alto Research Center, Palo Alto, CA", "person_id": "PP43139741", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567471", "year": "1980", "article_id": "567471", "conference": "POPL", "title": "Formal specification as a design tool", "url": "http://dl.acm.org/citation.cfm?id=567471"}