{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 operations can only deliver a value, but others can potentially fail. If \nan expres\u00adsion fails, the evaluation of the expres\u00adsion in which that operation occurs is aborted immediately \nand failure is sig\u00adnalled to the construct in which the fail\u00ad ing expression occurs. Such a failure is \na transient entity and must be captured at the moment it occurs. Three cases arise: a. The syntactically \nenclosing construct is capable of handling the failure itself. This is the case if the failing expres\u00adsion \nE occurs in contexts like: b. The syntactically enclosing construct is not capable of handling the failure \nit\u00adself, but is (perhaps dynamically) en\u00adclosed in a construct with that capabil\u00adity, like:  ifE then \n. . . else . . . fi while E do . . . od E ! . . . (logical or operator) E&#38; . . . (logical and operator) \nreturn(E) (value from a procedure) In this way failure can be passed to the caller of the procedure in \nwhich the failing expression occurs (see below) . c. Neither of the above two cases applies. This results \nin abnormal program termi\u00adnation with the error message Undetect\u00aded failure . In x := read(input); print(X); \nthe call to the read procedure may fail (on end of file). This failure will not be detected by the program \nitself and hence execution of the program will be aborted. This expression evaluation scheme was designed \nto be concise and powerful, but at the same time an attempt was made to pro\u00adtect the programmer against \nundetected or unwanted failure. Conciseness is obtained in two ways. Firstr by computing a value and \na failure signal in the same expression. This al\u00adlows , for example while line := read(input) do . . \n. od instead of while not eof(input) do line := read(input); if io_errors(input) then . . . fi; ... \nod ; Second, by disregarding the source of failure and focussing attention on the absence of failure \n(i.e. success) during the evaluation of the expression. Consid\u00ader: if (read(input) I I read(input) # \nexpected then error ( Bad input ) fi where expected has the expected input string as value. Three sources \nof failure can be identified here: the two read opera\u00adtions and the inequality test. The pro\u00adgrammer, \nhowever, is in most cases only in\u00adterested in the fact that the input file does not conform to his expectations. \nThe above formulation makes this more clear than L1 := read(input) ; if eof(input) then error ( Bad input \n) else L!2 := read(input) ; if eof(input) I (Ll I I L2 # expected) then error ( Bad input ) fi fi In \nprinciple, this argument works in two directions: since the source of failure may be lost, the programmer \nmay be misled about the actual source of failure. It is our experience that this seldom happens and in \nall cases where the distinction ~ impor\u00adtant it can be expressed easily. Protection is achieved by prohibiting \nundetected failure. This turns out to be a frequent source of run-time errors, which always corresponds \nto forgotten or im\u00adpossible failure conditions. A direct consequence of this protection scheme is that \none can write assertions (i.e. expres\u00adsions which should never fail) in a pro\u00adgram. A run-time error \noccurs if such an assertion is violated. Another noteworthy consequence of this evaluation mechanism \nis its ability to let a procedure report failure to any procedure which called it (indirectly. This effect \nis obtained by adhering to the programming convention that procedures have the form El &#38; . . . &#38;En. \nIf one of the expressions Ei fails, this failure is passed to the caller of the current procedure. If \nthat calling procedure has the same form, it will not handle the failure itself but will pass it on to \nits caller. In this way, low-level procedures need not be aware of failure at all and high-level procedures \ncan detect the failure and take appropriate measures. Some programming languages have special facilities \nfor handling exceptions of this kind; in SUMMER they can be handled by the standard expression evaluation \nmechanism. 3. RECOVERY CACHES For the solution of problems such as parsing languages with context-sensitive \nor non-LL(l) grammars and heuristic searching, it is often necessary to attempt a poten\u00adtial solution \nand to undo the effects of that attempt if it is not successful. Many schemes have been proposed for \nthe formula\u00adtion of such backtracking algorithms, but most involve either opaque control struc\u00ad tures \nor provide unsatisfactory control over modifications of the program environ\u00adment (i.e. global variables). \nThe recovery cache [RANDELL75], which was invented to increase software reliabil\u00adity has been adapted \nto act as a device for monitoring environment modifications in backtrack-liable situations. Recovery \ncaches are used both at the conceptual and at the implementational level. A cache consists of (name, \nvalue) pairs. The name part may refer to simple variables, array elements and class components (see section \n4). When backtracking may be necessary a new cache is created and from that moment on all assignments \nto variables and input/output operations are monitored. Whenever an assignment is about to be made to \na variable whose name does not yet occur in the cache, its name and value before the assignment are entered \nin the cache. Modifications of input/output streams are registered similarly. If the attempt is successful \nand no backtracking is neces\u00adsary, the information in the cache is dis\u00adcarded but in case of failure, \nthe informa\u00adtion in the cache is used to restore the environment to the state as it was at the moment \nthat the cache was created. Since recovery caches may be nested, discarding may mean: merging the information \nin the current cache with that in the previous cache. In this manner, the information in the previous \ncache is still sufficient to describe all modifications which were made since that cache was created. \nThere are two exceptions to these rules: Input/output operations on the standard input/output stream \nare not recovered. In many situations it is not desired to recover these streams and in some cases the \nmeaning of such a recovery may be non-obvious or confusing. In SUMMER these streams can be used to control \nand monitor the backtracking process in\u00adteractively. The local variables of the procedure in which the \ncache was created are not recovered. In this way information about the reason of failure can survive \nthe failure itself. At the programming language level, caches are introduced by the construct try El, \nE2, .... En until ED endtry . In a first approximation this expression is equivalent to (El &#38; EO) \nI ... I (En&#38;Ea Before the evaluation of e.. ch (Ei &#38; ED) starts, a new cache is created. If the \nevaluation of this subexpression succeeds, the cache is discarded and the whole ex\u00adpression succeeds. \nIf the evaluation fails, the environment is restored from the cache and evaluation of (Ei+l &#38; Eti) \nis at\u00ad tempted in the same manner. The whole ex\u00adpression fails if none of the subexpres\u00adsions succeeds. \nCompletely automatic back\u00adtracking is achieved by nested try con\u00adstructs. This simple scheme is very \nwell suited for the formulation of problems oc\u00adcurring in pattern matching as will be seen in section \n5. 4. PROCEDURES, OPERATORS AND CLASSES The remaining features of the SUMMER kernel are now summarized. \nProcedures have a fixed number of parameters, which are passed by value. Procedures may either fail or \nreturn zero or more values. Hence it is possible to return more then one result value. An operator is \ndefined by associating a user-defined operator symbol with a pro\u00adcedure with one or two parameters. Classes \nare the only available data structuring mechanism and are a generaliza\u00adtion of the SIMULA [DAHL743] class. \nA class declaration consists of: A class name and formal parameters. The class name is used as name for \nthe crea\u00ad tion procedure for objects belonging to this class. The formal parameters are used to provide \ninitial values for that object. Fields, which are either used to store information related to the object \n(e.g. the real and imaginary parts of a com\u00ad plex number class object) , or informa\u00ad tion local to the \nclass object (the stack pointer in a stack class ob\u00ad ject) . Fetch and store access to fields can be \ncontrolled completely by associ\u00ad ating fetch and store procedures with each field. -Access procedures \nand operators defining the operations that can be performed on objects of this class. The components \nof a class are accessed by means of the dot notation. The operators which are defined in a class can \nbe used in infix notation. The type of the left operand. of an operator is used to disambi\u00adguate overloaded \noperators, i.e. operators which are defined in more than one class. One, final, concept must be introduced \nbefore we can turn our attention to some pattern matching applications. One of the advantages of string \npattern matching languages is that they liberate programmers from the necessity to repeat a current sub\u00adject \nstring and cursor position in each pattern matching operation. In SUMMER an attempt is made to provide \nsuch a facility in general. In sequences of the form: a := S.x; b := S.y; c := S.z(lil) ,,s.,, the prefix \ncould be factored out. Pscal uses the construct with S do begin ... end for this purpose. All field references \nthat occur inside begin . . . end are au\u00ad tomatically prefixed with 11~.1,. In this notation the example \nwould read: with S do begin a:= x; b:=y; c:= z(10) end But this is not sufficient for the applica\u00ad tions \nwe have in mind, where it is not unusual that many procedures operate on the same class object. This \nis illustrated by a set of parsing procedures that operate on one subject string. The Pascal approach \nhas the disadvantage that this common class object must be passed as argument to all pocedures (or must \nbe assigned to a global variable) and that all procedure bodies must be surrounded by a with construct. \nThis problem can be circumvented as fol\u00ad lows. The construct (1) scan S for E rof declares a completely \nnew variable each time the construct is encountered at run\u00adtime and assigns the class object S to that \nnew variable. All occurrences of fields from the class to which S belongs are now prefixed with this \nnew global variable in the same way as is done i n Pascal. The san construct is more general since it \naf\u00ad fects all expressions and procedures which can be evaluated directly or indirectly from the body \nof the scan construct. In Pascal this effect is restricted to the ex\u00adpressions which are statically enclosed \nin (1) Inspired by the scan S using E construct in Icon [GRISWOLD791. the body of the with construct. \nIf the scan construct is used in a nested fashion, then the previous value of the new global variable \nis saved and restored properly on exit from the current scan construct. This also applies to the case \nthat the scan con\u00ad struct is left prematurely by means of a return statement. 5. A PATTERN MATCHING \nEXTENSION 5.1. String Pattern Matching Now we will show how a string pattern matching system can be build \non top of the SUMMER kernel. Pattern matching is done on a string subject which is indexed by an in\u00adteger \ncursor. For the sake of this discus\u00adsion a very simple system will be defined, which only supports the \nfollowing three functions: lit(S): literally recognize the string S. If S occurs as substring in the \nsubject at the current cursor position, then deliver S as value and move the cursor beyond S. Otherwise \nreport failure. break(S): recognize a string of characters not occurring in S followed by one ter\u00adminating \ncharacter which does occur in s. If such a string can be found start\u00ading at the current cursor position \nthen deliver that string (wfthout the ter\u00adminating character) as value and move the cursor to the terminating \ncharacter. Otherwise report failure. span(S): recognize a non-empty string of characters all of which \nmust occur in S. If such a string occurs as substring in the subject at the current cursor posi\u00adtion, \nthen deliver that string as value and move the cursor beyond it. Other\u00adwise report failure. (Span is \nadded to allow more interesting examples, its im\u00adplementation will not be shown here.) The following \nclass definition implements this pattern matcher: class scan_string (subject) begin var cursor := 0; \n proc lit(s) ( if cursor + size(s) > s ze subject) I s# substr(subject,cursor ,cursor+size (s)) then \nfreturn # failure return # else cursor := cursor + size(s); return(s) fi ): proc break(s) ( var newcursor \n:= cursor, result; for newcursor in [cursor : size(subject)] do for cin sdo if c = subject [newcursor] \nthen result := substr(subject,cursor ,newcursor) ; cursor := newcursor; return(result) fi od od ; freturn \n ); proc span(s) (# similar to break #); end class scan string; The following example illustrates how \niden\u00ad tifiers starting with the letter X can be recognized: proc X_identifier(s) ( var t := scan_string(s) \n; t.lit( X ) &#38; (t.span(letgit) I t.lit( )) ) (In all examples we assume that letter , digit and \n letgit have appropriate values.) Note that the normal logical operators &#38; and l are used for \ncombina\u00ad tion. Hence there will be no backtracking, reversal of effects or whatsoever. This example \ncan be written in a more concise form if we use the scan construct: proc X_identifier (s) scan scan_string(s) \nfor lit( X ) &#38; (span(letgit) I lit( )) rof A final example may illustrate the use of the value delivered \nby the pattern matching procedures. The problem is to ex\u00adtract all letters from a given string. For example \na,b,c gives abc : proc extract_letter(s) ( var result := ; scan scan_string(s) for while break(letter) \n&#38; result := result I I span(letter) do # empty statement # od rof; return(result) ) In SUMMER pattern \nmatching and back\u00adtracking have been separated completely. It came as a shock &#38;E___ that the vast \n. - majority of pattern matching problems, we  had previously solved ~ means of implicit backtracking, \ncould be solved without ~ backtracking at all! This suggests that the close interaction between pattern \nmatching and backtracking, as can be found in many languages, should be reconsidered. Now we will address \nthe question how pattern matching with automatic backtrack\u00ading can be obtained. Consider the expres\u00adsion: \n(lit ( ab ) I lit( a )) &#38; lit( bc ) In the pattern matcher developed above, the alternative lit( \na ) is discarded as soon as a subject string starting with ah is encountered. The string abc can not \nbe recognized in this way. But if we rewrite this expression as try lit( ab ), lit( a ) until lit( bc \n) endtry then the recovery cache mechanism restores the initial cursor value automatically and tries \nthe second alternative if lit( bc ) fails. No special attention needs to be given to the cursor: it is \nan ordinary variable which is saved and restored by the recovery cache mechanism! 5.2. Generalized Pattern \nMatching In most pattern matching systems there is only one subject string involved in the pattern match. \nThis restriction can be re\u00admoved without introducing any new concepts as an example will show. The following \n(rather artificial) problem is to ensure that two strings S1 and S2 conform to the following rules: a. \nS1 is of the form cl;c2; . . ..cn. where ci is a (perhaps empty) sequence of arbi\u00adtrary characters other \nthan the charac\u00ad 1;1 ter . Some examples are: a;b; , #21!;7a;# and lab;cde;f; r. b. For a given S1, S2 \nhas the form dld2. ..dn, and either di = ci or di = reverse holds. Acceptable values for S2 with S1 equal \nto ab;cde;f; are abcdef , abedcf , bacdef and baedcf . The following program performs this check: S1 \n:= scan_string (S1) ; S2 := scan_string(S2); scan sl for while (c := break ; )) &#38; lit( ; ) do if \nnot scan S2 for lit c) I lit reverse c)) rof then error( check fai~ s ) fi od rof; if sl.cursor # size(Sl) \nI s2.cursor # size(S2) then error( check fails ) fi Each scan_string object maintains its own cursor. \nNote how the cursor value of S2 survives each evaluation of the inner\u00ad most scan construct. This allows \nthe in\u00adnermost pattern match to continue where it left of the previous time. From the preceding paragraphs \nit will be clear that pattern matching as presented here, does not depend on the fact that strings are \nused as the basic unit of recognition. One can, for example, easily imagine pattern matching in an array \nof strings. The cursor must then be re\u00adplaced by a pair of values to maintain the current position and \nbasic scanning pro\u00adcedures like xlit, ylit, xspan and yspan must be defined. It may be expected that \na system for the recogn tion of two\u00addimensional line-drawings like ESP3 [SHAPIR074], can be defined in \na straight\u00ad forward manner using the primitives from the SUMMER kernel. matching in domains other than \nstrings. 6. IMPLEMENTATION An implementation of SUMMER is near com\u00adpletion and runs under the UNIX (1) \noperat\u00ading system [RITCHIE74]. This implementa\u00adtion consists of a two pass compiler (writ\u00adten in SUMMER) \nwhich transforms source pro\u00adgrams into a rather high level abstract machine code. This abstract machine \ncode is then executed by an interpreter written in C [KERNIGHAN781. Extensive facilities are provided \nfor program profiling and sym\u00adbolic debugging. 7. RELATED WORK SUMMER is the successor of SPRING [KLINT781, \na language which had the same design goals, but lacked the simplicity and generality achieved in SUMMER. \nBoth languages were inspired by and profited from ideas in SNOBOL4 [GRISWOLD71] and SL5 [GRISWOLD76]. \nSUMMER was also influenced by Icon [GRISWOLD791. We had already for\u00ad mulated several ideas for the integration \nof pattern matching and expression evalua\u00adtion, but the solution finally adopted in SUMMER was influenced \nby Icon. There are important differences too. For example, in Icon most pattern matching procedures deliver \ninteger values corresponding to the position to which they can move the cursor. Next the cursor has to \nbe moved explicitly. This operation delivers the substring between successive cursor positions as value. \nIn SUMMER all pattern matching pro\u00ad cedures deliver the recognized substring as value and move the cursor. \nIn this way the cursor needs hardly ever be manipulated by the programmer. The pattern matching model \nin SUMMER is more general, since it allows simultaneous pattern matches and pattern (1) UNIX is a Trademark \nof Bell Labora\u00adtories. The evaluation model which prohibits un\u00ad detected failure, the use of recovery \ncaches and the separation of pattern match\u00ading and backtracking are new. ACKNOWLEDGEMENT Design and implementation \nof SUMMER were realized in close cooperation with Marleen Sint. REFERENCES [DAHL701 Dahl, O-J, Myhrhaug, \nB. &#38; Nygaard, K .r SIMULA Information, Common Base Languager Norwegian Computing Centre, S-22, 1970. \n [GRISW0LD711 Griswold, R.E., Poage, J.F. &#38; Polonsky, I.P., The SNOBOL4 program\u00adming language, Second \nedition, Prentice Hall, Englewood Cliffs, N.J., 1971. [GRISW0LD761 Griswold, R.E. &#38; Hanson, D.R., \nAn overview of the SL5 programming language, SL5 project document S5LDlbr The University of Arizona, \nTucson, Ar izona, October 9, 1976. [GRISWOLD79] Griswold, R.E. &#38; Hanson, D.R., Reference Manual for \nthe Icon Program\u00adming Language, TR 79-1, The University of Arizona, Tucson, Arizonar 1979. [KERNIGHAN78] \nKernighan, B.R. &#38; Ritchier D.M., The C Programming Languager Prentice-Hall, 1978. [KLINT78] Klint, \nP., Pattern Matching in SPRING, ~ Van Vliet, J.C. (cd), Col\u00adloquium Capita Datastructuren, MC syl\u00adlabus \n37, 1978, 65-83. [RANDELL751 Randell, i3., System structure for software fault tolerance, in Proceedings \nof an International conference on reliable software, SIG-PLAN notices, 10(1975)6, 437-449. [RITCHIE74] \nRitchie, D.M. &#38; Thompson, K., The UNIX time-sharing system, Communi\u00adcations of the ACM , 17(1974)7, \n 365-375. [SHAPIR074] Shapiro, L.G., ESP3: a language for the generation, recognition and manipulation \nof line drawings, (thesis), TR 74-04, University of Iowa, 1974. .  \n\t\t\t", "proc_id": "567446", "abstract": "The language SUMMER is intended for the solution of problems in text processing and string manipulation. The language consists of a small kernel which supports success-directed evaluation, control structures, recovery caches and a data abstraction mechanism. It is shown how this kernel can be extended to support simultaneous pattern matching in arbitrary domains.", "authors": [{"name": "Paul Klint", "author_profile_id": "81332509287", "affiliation": "Mathematisch Centrum, The Netherlands", "person_id": "PP43126539", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567451", "year": "1980", "article_id": "567451", "conference": "POPL", "title": "An overview of the SUMMER programming language", "url": "http://dl.acm.org/citation.cfm?id=567451"}