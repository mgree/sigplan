{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 Here, n,n are variables ranging over Int, and ,s are variables ranging over \nSetofInt. Now, the implementation : data type SetofInt-UN (* Sets are represented by Unordered, Non-repeating \nlists *) rep ListofInt endrep ; ~NULL returns SetofInt ; return (NIL) end ; op~D(n:Int,s:SetofInt) returns \nSetofInt ; if MEMBER?(n,s) then return(s) else return(APPEND(n,s)) &#38;; w MEMBER? (n:Int>s:SetOfInt) \nreturns BCIO1 ; if S=NIL then return(FALSE) e~if FIRST(s)=n then return(TRUE) else return(MEMBER?(n,REST(s) \n)) end ; op~ION(s, s :SetofInt) returns SetofInt ; if s=NIL. then return(s ) e~e return(UNION(REST(s),ADD(FIRST \n(s),s ))) end ; end Set~nt ; Notice that certain ListofInt s are not repre sensations of SetofInt s. \nFor example, the list tions-cannot occur. Those representations which actually do occur comprise what \nwe call the raz\u00adehab%e set of the implementation. (Throughout this paper, the term data type refers to \nany particular mathematical structure (set and functions) which implements a certain da\u00adta abstraction \n. Thus, the (reachable set of the) implementation above, and the initial algebra of the axioms [ADJI, \nare both data types which imple\u00adment the (intuitive) data abstraction sets of integers. ) Certain axioms \nabout sets are implied by the above axiomatization without actually being provable from it. For example, \nADD(n,ADD(n ,s)) = ADD(n ,ADD(n,s). Similarly, this is implicit in the implementation, but is not true. \n(That is, the two expressions lead, in general, to distinct representations.) my do we call this axiom \ntrue ? Obviously, it is because the two expressions represent the same set. But we can state this, without \nrelying on our prior knowledge of sets, as follows : for all m, MEMBER?(m,ADD(n,ADD(n ,s))) = MEMBER7(m,ADD(n \n,ADD(n,s))). Indeed, we take the view that elements of new data types are abstractly identical if their \ndistinctness cannot be inferred from the results of output operations. Call a data type j%ncz% if it \nhas no two ele ments which are abstractly identical. Final data type are small in that they make as many \nidenti fications as possible. Thus, our implementation of SetofInt is not final, as indicated above : \nand !n!~ . .. ..+.n ; ~-~: ,~~-- are distinct, reachable representations which are abstractly identical. \nThe initial algebra of our axioms is likewire not final, the congruence classes of ADD(n,ADD(n ,NULL)) \nand ADD(n ,ADD(n,NULL)) being distinct but abstractly identical. To each data abstraction, however, does \ncorrespond a final data type implementing it. This paper presents a method of specifying data types which \nis capable of expressing only final data types. As a result of the smallness just mentioned, these specifications \nhave particu larly satisfying mathematical properties vis-ii-vis other specifications or implementations \nof the data abstraction. III -EXAMPLES OF FINAL DATA TYPE SPECIFICATIONS The specification method is \nbased upon a close examination of those operations which are witnesses to the distinctness of elements \nof a data type. Thus, define a distinguishing term for a new data type D to be any expression over the \nopera tions of D which has exactly one variable of type D (which we write as .), and whose value is in \nan old type. For example, for any ncInt, MEMBER?(n, .) is a distinguishing term for SetofInt. For StackofInt, \nTOP(.) and TOP(POP(.)) are two distin\u00adguishing terms. Distinguishing terms may be used to compare two \nelements of D to try to demonstrate their distinctness. For a data type D, a set of distinguishing terms \nis called a distinguishing set (DS) if it is capable of demonstrating the difference between any two \nelements of D. That is, if d,d cD are not abstractly identical, then there is some distin\u00adguishing term \nt in the given set such that tat. A DS for SetofInt is {MEMBER?(n,.)/ ncInt} ; for any two different \nsets, some operation PfEMBER?(n, .) has a different value for the two sets. For StackofInt, a DS is {TOP(. \n),TOP(POP(.)), TOP(POP(.))) ,...}. Note that DS S really belong to data abstractions -a DS for a data \ntype is also a DS for any other data type implementing the same data abstraction. A DS for a data abstraction, \nproperty stated and interpreted, leads to a representation and operations having the property of finality, \nAddi tional operations may then be defined over the representation without endangering this property. \nThus , a final data type specification has three parts : 1. A list of operations and their arities ; \n 2. A DS, which is interpreted (according to a rule given in section V) to give a re presentation and \ncertain operations ; and 3. Definitions of the remaining operations.  Exemple 1 The intuition behind \nthe method is very simple, as this first example will show. The data type is NEM-CELL, with operations \nCREATE : + MEM-CELL STORE : MEM CELL x VALUES + MEM CELL CONTENT : MEM CELL + VALUES Let CONTENT(CREATE) \n= error, some special element of the data type VALUES. Obviously, if two MEM-CELL S m and m are not abstractly \nidentical, then CONTENT(m)#CONTENT(m ). We write DS(MEM-CELL) = {COIVTENT(.)}. So CONTENT is a 1-1 function \non MEM-CELL. We can therefore take the representation of MKM-CELL to be VALUES, representing each MEM-CELL \nby its CONTENT, and define CONTENT to be the identity func\u00adtion. Clearly, this representation is big \nencugh (if we were correct in our statement about CONTENT being l-l) ; and the definition of CONTENT \nshows that the specification, when completed, will be final : if two elements of the representation (VALUES) \nare distinct CONTENT will certainly distin\u00adguish them. It remains to define the other two functions, \nCREATE : + (vALUES) STORE : (VALUES) x VALUES +(vALuES). Defining CREATE means finding that element \nvof VALUES such that CONTENT(v) = error. But the defi\u00adnition of CONTENT leaves no choice, so CREATE : \n+ f2PPOP. STORE(m,v) is a MEM-CELL whose CONTENT is v, so STORE : V ,V + v. (In this, as in all examples, \nthe specification is typed in italic to separate it from the explanation.) Example 2 : StackofInt, with \nthe usual operations : CREATE : + StaekofInt PUSH : StackofInt x Int + StaekofInt POP : StackofInt + \nStaekofInt TOP : StaekofInt + Int. It is possible to distinguish between any two stacks by TOP s and \nPOP S. Thus, DS(StaekofInt) = {TOP(.)} u {POP(.)]. By considering the ranges of the two operations in \nthe DS, we arrive at the representation Int x StackofInt, and operation TOP:<n,s> +n POP : <n,s> + s. \nWe now define CREATE and PUSH. CREATE returns a stack whose TOP is error, and whose POP is CREATE (i.e. \nPOPping an empty stack has no effect). Thus, CREATE : + <wPoY,CREATE>. PUSH(s,t) has, obviously, top \nt, and, when popped, returns s, so PUSH : .s,t + <t, s>. Notice that the axiom POP(PUSH(s,t)) = s is \ntrue, although we made no special effort to ensure this. It is, of course, a direct result of finality. \nExample 3 : SetofInt, with the operations already given. As previously mentioned, DS(SetofInt) = {MEMBER?(n,.)/ncInt}. \n This DS has a slightly different form from the previous ones. In this case, the representation gi\u00adven \nis (Int + Bool), the set of (total) functions from Int to Bool. Furthermore, MEMBER? is defined by MEMBER? \n: n,s + s(n). We now define the remaining operations. The empty set has value FALSE for all elements \nof Int, so NULL : + in : Int.FALSE. ADD modifies the results of MEMBER? to answer TRUE for its argument, \nso ADD : n,s + s[TRUE/n]. Finally, UAJION : S,S + An : Int. iJ a(n) then TRUE else s (n). Example 4 : \nSymbolTable [GHM,LSWI, with operations INIT : + SymbolTable ENTERBLOCK : Symbo%.Tab%e + Symbol!Table \nLEAVEBLOCK : Symbol.Table + Symbo%!rable ADDID : SymboZ.Tab%e x Var x Attr + SymbolTable RETRIEVE : Symbol.Tab%e \nx VaP + Atty ISINBLOCK : SymboLTab%e x Var + BOOL. The RETRIEVE c,peration finds any occurrence of the \nvariable in the symbol table, starting with the current block, while ISINBLOCK looks only at the current \nblock. It is easy to see that a DS for SymbolTable is DS(SymbolTablti! = {ISINBLOCK(.,V) /veVar} u {RETRIEVE(.,v)/vcVar} \nu {LEAVEBLOCK(.)}, which gives representation (Var+ Bool) x (Var +Attr) x SymbolTable and operations \nISINBLOCK : <f,g,s>,v + f(v) RETRIEVE : <f,g,s>,v + g(v:) LEAVEBLOCK : cf,g,s> + s.  INIT is a symboltable \nwhose ISINBLOCK function is uniformly FALSE, whose RETRIEVE function is error, and on which LEAVEBLOCK \nhas no effect. So, + <Av:Var.FALSE, iv:Var.error, INIT>. INIT : ENTERBLOCK(s) has an ISINBLOCK function \nwhich is FALSE, a RETRIEVE function which is the same as that of s, and LEAVEBLOCK will, of course, return \ns. ENTERBLOCK : <f, g,s 1> + <kv:Var. FALSE, g, <f, g,s 1>>. Finally, ADDID modifies the I;SINBLOCK and \nRE-TRIEVE portions of a symbol table,, but leaves the LEAVEBLOCK portion as is. Thus, ADDID : f>9>s>~V,a \n+ <f[TRUE/v], g[a/vl,s>. The reader may verify that the symbol table axioms given in EGHMI are verified \nin this speci fication. IV FINAL DATA TYPES  We now present the algebraic ideas needed to understand \nwhat is special about our specifications. These will already be familiar to readers of [W] and [GGMI. \nRelated ideas appear in [AH,B,SK]. Def : Two data types are comparable if they have we same operations \n(with the same arities) and start from the same set of old types. Def : A ?zomomorphism h:D+E between \ncomparable data ~es is a map taking elements of D to elements of E such that if f:D x.,.x Dn + Dn+l, \nthen for all 1 dleD1, . . ..d~ Dn, h*(fD(dl, ..., dn)) = fE(h*(dJ, . . ..h*(~)). where h* is for each \ni, either h or the identity function, depending upon whether Di=D or not. For example, considerthe data \ntype SetofInt UR in which sets are represented by Unordered, Repea\u00adting lists (just change ADD in SetofInt-UN \nto APPEND(n,s)). The function which removes repetitions from these lists is a homomorphism from SetofInt-UR \nto SetofInt-UN. If a homomorphism exists, D and E behave very similarly, although they may be different \nsets. In fact, a user observing only the results of output operations will not be able tc tell D from \nE.Intui\u00adtively, D and E are implementations of the same data abstraction and may be used interchangeably. \nThis may be the case, however, even when no homo\u00admorphism exists in either direction. Def : Comparable \ndata types D and E imp%ement the me data ab.straetion iff there is a (comparable) data type F with homomorphisms \nhD:D+F and hE:E+F. Consider two more implementations of SetofInt, SetofInt-OR (Using Ordered, Repeating \nlists) and SetofInt-ON (Ordered, Non-repeating lists). These four data types form the following picture \n(the arrows representing homomorphisms) : /u$\\ UN OR \\ / {N Thus, OR and UN are not related by any homo\u00ad \nmorphism. ON is, in fact, final. Def : Two elements d,d of data type D are abstrae\u00adt%y -&#38;?enz%a% \n(dzDd ) if for any parameterized term t(,) whose result is in an old type, tat, It is easy to show that \n= is a congruence relation, and the following ob ? ains : Theorem : In the class of all implementations \nof a =ata abstraction, there is (up to isomor\u00adphism) one data type F such that, from any other data type \nD in the class, there is a homomorphism hD:D+F. (Thus, F is the categorical final object. ) Moreover, \nF&#38;D/z D Among the consequences of F s being final are these : 1 -F satisfies all the axioms of the \ndata abstraction. That any data type D satisfies a set of axioms A (without using equality interpretations \nLGHM]) is equivalent to the existence of a homomor\u00adphism from the initial algebra [ADJ] of A to D. But \nsuch a homomorphism must exist for F. For exam\u00adple, the axiom ADD(n,ADD(n ,s)) = ADD(n ,ADD(n,s)), not \ntrue in UN, is true in ON and in the specifi\u00ad cation given in section III. (ln fact, F could be defined \nas the initial algebra of the maximum con\u00adsistent extension of any consistent, sufficiently\u00adcomplete \naxiomatization of the type.) 2 -Implementations can always be proved with respect to F by the method \nof abstraction [HI or rep [WLS] functions. No other implementation of the data abstraction guarantees \nthis, It means that it is never necessary to modify the specification to handle a new implementation. \n3 Two terms are unequal iff they evaluate to unequal elements of F. The axioms for SetofInt fail to \nidentify many terms, but it would be folly to conclude that these terms are therefore unequal. It is, \nunfortunately, also true that the final data type may not be computable even if a computa ble implementation \nof the data abstraction exists. In fact, Theorem : If a data abstraction has some computable - Implementation \nD, then the final data type F is computable iff the relation abstractly identical in D is decidable. \nProof : See Appendix 1. An example of such a data type appears in Appendix2. It may be argued that data \nabstractions whose final data types are not computable are too complicated ; the theorem says that it \nis impos\u00adsible to define an equality operation which is implementation-independent. It turns out that \nsuch data types are nonetheless specifiable using our method-although it is certainly difficult to prove \nequality of expressions in such specifications. Appendix 3 gives a specification of the data type of \nAppendix 2. V -FINAL DATA TYPE SPECIFICATIONS As already mentioned, a final data type spe\u00adcification \nhas three parts : -Signature -that is, the names and arities of the operations of the data type. Distinguishing \nset. -Definition of the remaining operations.  The signature is common to all specifications. This section \ncontains a detailed discussion of the second and third parts of a specification. A distinguishing set \n(DS) is some set of dis tinguishing terms capable of distinguishing between any two elements of a data \ntype. The choice of a DS is entirely creative and is based upon the speci fier s intuition about the \ndata abstraction. The syntax of a DS for data abstraction D is : DS(D) = {fl(. ,dl, . . ..dk)/dlcDl . \n. . ..dkeDk} u ... u {fn(. ,el, . . ..em)/elcEl . . . . ,emcEm}.  The result type of any of the fi may \nbe D, so long as D is not the result type of all the f.. Furthermore, none of Dl, . . ..DkE17..Em. ,Em \nmkY be D (they all must be old types). (~.fore generaIIY, the DS may contain derived operators, which \nlead to more complications, but are unnecessary in most cases. In particular they are needed only when \nthe DS must contain a binary function symbol.) The DS leads to a representation and to defi nitions of \nf Namely, the specified repre sentation 0f]6 i; fn- D= (Dl X.. .X Dk+Cl) x!.. x (El X.. .X Em+Cn), where \nCl, . . ..Cn are the result types of fl, . . ..f , respectively. x stands for cross product as usual, \nand + represents function space. The operations f are specified by l  n : d,dl, . . ..dk+pl (d)(dl \n. . . ..dk) 1 fn : d,el, ,. .,em+pn(d)(el, . . . ,em) where pi is the ith projection of the specified \nre presentation. If the list of parameters of fi is empty, then fi: d + pi(d). Because any of C1, .,.,Cn \nmay be D, the eqUatiOn giving the specified representation may involve a circularity.This technical \nproblem is discussed in Appendix h. Having given a DS for the data type, the spe\u00adcifier must define the \nremaining operations of the type as functions over the specified representation. these are given as recursive \nfunctions over the following primitive operations : -Operations of the old types -Operations on tuples \n: < ., . ..>.tuplingng -projections P,>P2, ... -Operations on functions : Ax.t -abstraction .(.) application \n .[./.1 function modification -if th~n-else -equallty on all types. Additionally, the specifier may \ndefine auxi\u00adliary functions of any functionality. It is well to go back and recall the intuition behind \nthe method, The specified representation is the largest set for which the fi can distinguish every element, \nThus, if the DS is well-chosen, this set will be large enough to represent the data type type ; but the \ndefinitions of fl, . . ..fn guarantee that this representation, with these functions, is final. Addition \nof other operations over this set will not endanger the finality property. Thus, Theorem : Final data \ntype specifications specify final data types. To the properties of final data types given in the last \nsection, we may add this observation about our method : it is the first method which is -in a mathematical \nsense -free from imple\u00ad mentation bias [J,LsI. Surprisingly, any data abstraction having some computable \nimplementation is specifiable, even if its final data type is not computable. To see this, suppose we \nwish to define data type D with DS(D) as above, and that an implementation exists having representation \ntype R. Denoting the implemented version of fi by fimpl we can define ~ function from R tO the is specified \nrepresentation as follows : ABS:R+(DIX. ..XDk+Cl)X. . . X(EIX. ..XEm+C ) n * lmpl(r,dl, .,. ,dk)), r+<ldl \n:DI  A%:Dk ABs f] .  lem:Em.ABS*(flmpl(r,el ,,,.,e ))>, nm imp 1  ael:EI where t~e f. are regarded \nas auxiliary functions, and ABS is: for each i , either ABS or the identi\u00adfy, depending upon whether \nCi=D. ABS is, in fact, the unique homomorphism from the reachable set of R to the specified representation. \nIts name recalls Hoare s abstraction function [H]. Now, any remaining operation f:D+E can be specified \nby fspec(d)=ABS *(f mpl (FINDCONC (d) )), where FINDCONC(d):=some reR such that d=ABS(r), FINDCONC may \nbe coded as a search through the terms whose result type is D. Then, every reacha\u00adble concrete representation \nr is checked, and since d is reachable, some such r must eventually satisfy d=ABS(r). The ability to \ntest for equality in the spe\u00adcified representai:ion is critical here. However, this equality is not, \nin general, decidable (since i-l abstractly identical to r2\u00b0 is equivalent to ABS(rl)=ABS(r2)). The power \nof the specification method when equality tests are prohibited is, at present, an Opeli problem. VI -APPLICATIONS \nThe specification of a data type provides in\u00adformation to its users as well as its implementors, Of primary \ninterest to the users are the axioms of the type. We have shown that the speci\u00adfication necessarily satisfies \nthe axioms, so that the specification is, mathematically speaking, a reliable source far this information. \nHowever, it is still necessary to prove the axioms, using the following kinds of knowledge : -Facts about \nold types -Facts about tuples, functions, and if-then\u00ad . else -~itional proof methods for recursively\u00ad \ndefined functions [M,VI. It is also necessary, in general, to be aware of the distinction between reachable \nand non\u00adteachable elements of the specified representation\u00adto give what amounts to a representation invariant \n[H] for it. We can readily prove, for example, the axioms for SetofInt (section 2) from its specification \n(section 3, example 3) : MEMBER?spec(n,NULLspec) = (An:Int.FALSE) (n) (spec. of MEMBER?,NULL) = FALSE \n(proEh of abstraction, application) MENBER?spec(n , ADDsp (n,s)) = (s[TRUE/n)(n ) (suet. of ADD) = if \nn=n then TRUE ~lse s(n ) (pr=of fn. modification) = ~ n=n then TRUE else MEMBER?spec(n ,s)  (spec. \nof MEMBER?) ~~ER?spec(n.uNI~Nspec(s .s )) = i&#38; NEMRER?spec(n,s) then TRUE ~MEMBER?spec(n,s ) UNIONspec(s,s \n) = if s(n) then TRUE else s (n) = ~ s (n)~l~n (if s(n) then TP.UE ~ TRUR) ~l~(if s(n) t~TRUR else FALSE) \n=~s (n) ~~T~~~s(n) = UNION pec(:s ,s) Naturally, mi:ssing axioms such as ADD(n,ADD(n ,s)) = ADD(n ,ADD(n,s)) \nare just as easily shown. The obvious question is whether a complete set of inference rules can be given \nfor deducing axioms. Computability considerations make it clear that no such set exists (confining ourselves \nto effective rules). As a practical matter, however, the proofs which arise are well within the power \nof LCF[M]. Looking ahead to an implementation of this method, then, the contraat with a system like \nDTVS[GHM] is interesting. In DTVS, the system is perfect -can extract all possible information from the \nspecifications-but individtial specifi\u00ad cations may be incomplete ; any system we design will necessarily \nbe incomplete, but the specifi\u00ad cation are always perfect in a certain sense. Implementations of data \ntypes can be proved by the method of abstraction functions, That is, one gives a map from concrete representations \nto specified represen tations. Furthermore, answering one objection to this method of proof, the abstrac\u00adtion \nfunction i.s derivable without creative effort -it is, in fact, the map ABS of section V, We illustrate \nagain using the data type Setof- Int, and attempt to prove the implementation Setof\u00ad Int-UN. The homomorphism \nconditions ate : -MSMBER? mpl(n,s) = MEMBER?spec(n,ABS($)) -ABS(NULL1mpl) = NULLspec -ABS(ADDimpl (n,s)) \n= ADDspec(n,ABS(s)) -ABS(UNIONLmpl (s,s )) = UNIONspec(ABS(s),ABS(s )), with ABS : List of Int + (Int+Bool) \n: % + ~n:Int,~MBER?impl (n, Z)6 The definition of ABS makes the homomorphism condition for MEMBER? obvious. \nWe prove the other three operations : -ABS(NULLLmpl) impl(n,NuLLimpl) = ln:Int.NEMBER? = kn:Int.MEMEER?impl( \nn,NIL) = kn:Int. if NIL=NIL then FALSE else . . . = An:Int.FALSE . NULLspec. -ABS(ADD mpl(n.s)) = \nin :Int.MEMBER? mpl(n , if MEMBER?impl(ri,s) then= else APPEND(n,s)) imp 1 = An :Int. if MEMBER? (n,s) \n~ MRMBER?impl(n ,s) else MEMBER? mpl(n ,APPEND(n,s)) ~ER~impl = An :Int, if MEMB (n,s) then i TZI !BER? \nmpl(n ,s) else (if n=n then TRUE # else MEMBER? lmpl(n ,s)) = An :Int, ~ n=n then (if MEMBER?lmpl(n,s) \n\u00ad= MEMBER? impl(rl ,s) else TRUR) _ else (if IfEMBER? mpl(n,s) . then MEMBER? lmpl(n ,s) else MEE?BER? \nmpl(n ,s)) = in :Int. if n=n then TRUE else MEMBER? mpl(n ,s) = An :Into if n=n then TRUE else ABS(s) \n(n ) = ABS(S) [TRUE/n] . ADDspec(n,ABS(s)) For UNION, we use induction on lists in the first argument \n: -ABS(UNIONLmpl(NIL,s )) = ABS(S ) = An:Int, QFALSE ~TRUE else ABS(s ) (n) = kn:Int. QABS(NIL) (n) \nthen TRUE ~ABS(s ) (n) . UNIONspec(ABS(NIL) ,ABS(S )) impl(AppEND(n)s) >s ) -ABS(UNION = ABS(UNION1mpl(s,ADD \nmpl(n, s )))  (i.h.)= UNIONspec(ABS(s),ABS(ADDimpl(n,s )) = lJNIONspec(ABS(s),ADDspec(n,ABS(s ))) . \nUNIONspec(ABS(S),ABS(S ) [TRUE/n]) = An :Int, ~ABS(s) (n ) ~ TRUE else ABS(s )[TRUE/n](n ) = kn :Int. \n~ n =n then TRUE elsif ABS(s) (n ) then TRUE else ADS = An :Int. if ABS(s)[TRUE/n](n ) then TRUE else \nADS = An :Int. if ABS(APPEND(n,s) )(n ) then TRUE ~se ADS = uNIoNspec(ABS(APPEND(n,s)),ABS(s )). VII \n-CONCLUSION W e have presented a new method for data type specification and its mathematical basis. The \nma\u00adthematics tells us that all questions about a data abstraction can be referred to its final specifi\u00adcation. \nThis is, we believe, a good start. what remains to be shown is that a practical system can be built around \nthese ideas ; that is the subject of our current research. Acknowledgements It is a pleasure to acknowledge \nthe help of my advisor at Stony Brook, John Cherniavsky, and. also of my former fellow student, Paul \nHarter. [ADJ ] J. Goguen, J, Thatcher, E. Wagner, An Ini\u00adtial Algebra Approach to the Specification, \nCorrectness and Impl.ementation of Abstract Data Types , in Current Trends in Program\u00adming Methodology \nIV,-R. Yeh (cd.), Prentice-Hall, ]979, pp. 80-149. [AH I M, Ardis, R, Hamlet, The Structure of Spe\u00ad \ncifications and Impl.ementations of Data Abstractions , University of Maryland, Compu\u00ad ter Science Dept., \n1 R-801, Sept., 1979. [B] Broy, Dosch, Partsch., Pepper, Wirsing, Exis\u00adtential Quantifiers in Abstract \nData Types , in Automata, Languagea and Programming, 6th Colloq. , 1979, Pp. 73-87. [E] J. Earley, Toward \nan Understanding of Data Structures , CACM 14, 1971, pp. 617-627, [G] J.V. Guttag, The Specification \nand Applica\u00adtion to Programming of Abstract Data Types , University of Toronto, Comp, Sci. Research Group \nT.R. 59, Sept,, 1975. [GGMI V. Giarratana, F. Gimona, U. Montanari, Observability Concepts in Abstract \nDsta Type Specifications , Math. Found. Comp. Sci. 76, pp. 576-587. [ GHM] J; Guttag, D. &#38;fusser, \nE. Horowitz, Abstract Data Types and Software Validation , CACM 21 1978, pp. 1048-1064, [CT] J. Goguen, \nJ, Tardo, An Introduction to OBJ : A Language for Writing and Testing Formal Algebraic Program Specifications \n, Proc. IEEE Conf. on Specifications of Relia\u00ad ble Software, May, 1979, pp. 170-189.  [H] C.A.R. Hoare, \n!Iproof of Correctness of Data Representations , Acts Informatica 1, 1972, pp. 271-281. [J] C,B. Jones, \nImplementation Bias in Cons\u00ad tructive Specifications of Abstract Objects , IBM Vienna, Sept., 1977. \n[K] G. Kahn, The Semantics of a Simple Language for Parallel Programming , PROC. IFIP Congress 74$ North-Holland \nPubl. Co., 1974. [LZ] B. Liskov, S. Zilles, Specification Tech\u00ad niques for Data Abstractions , IEEE \nTrana. on Software Engg. SE-1, 1975, pp. 7-19. [M] R. Milner, Implementation and Application of Scott \ns Logic for Computable Functions , Proc. ACM Conf. on Proving Assertions about Programs, 1972. [ SK] \nP, Subrahmanyam, R. Kieburtz, Toward Auto\u00ad matic Program Synthesis : Obtaining Implemen\u00adtations from \nFormal Specifications , SUNY at Stony Brook, Comp. Sci. Dept. TR-80, Sept., 1977. [v] J. Vuillemin, \nProof Techniques for Recursive Programs , Ph.D. Thesis, Stanford Univ., ]973. [WI M. Wanol, Final Algebra \nSemantics and Data Type Extensions , Univ. of Indiana, Comp. Sci. Dept. rR-65, July, 1977. [WLS 1 W. \nWulf, R, London, M. Shaw, An Introduction to the Construfition and Verification of AL- IEEE Trans. on \nSoftware %g g~~~;afi?b , pp. 253-265. &#38;pendix 1 Theorem For a data abstraction having some compu\u00ad \ntable implementation D, the final data type F is computable iff the relation abstractly identical in \nD is decidable. Proof Assume an ordering of terms whose result ty\u00ad fi D. (~) Given two elements d,d cD, \nfind the terms t,t which evaluate to them$ then evaluate t and t in F. If the results are identical I \nthen d is abstractly identical to d . (~) Take the representation of F to be the same as that of D, \nTo compute an output operation in F, compute it as in D. To compute an input operation f, again proceed \nas in D, then take the result and find the first representation in D which is abstractly identical to \nit. First refers to the ordering of terms. Appendix 2 Suppose M is a Turing machine whose halting behavior \nis undecidable. Then, write the following data type : data ty~ Run(M) ; =Inp : ~at~ st : M-state endre~ \n ~ START (n:Nat) returns Run(M) ; return(<n,INIT-CONFIG (n)>) &#38;O~E-STEP(r:Run(M)) returns Run(M) \n; ~ HALTING-S TATE?(r _ then return(r) ~ return(<r..inp)NEXT-STATE(r .st)>) end ; ~INPUT-VALUE(r:Run(M)) \nreturns Nat ; return(r$inp) 9; op IS-FINISHED? (r:Run(M) ) returns Bool ; return(HALTINC-STATE? (rr \nend ;  end =(M) (The data type M-state, with operations INIT-CONFI~ HALTING-STATE? and NEXT-STATE, \nis assumed availa\u00ad ble ; it is concerned with the details of the machine M, which need not occupy US.) \n The only way t hat two distinct, reachable representation can be abstractly identical is if they represent \ndifferent points in a non-termina\u00adting computation from the same input : -if they represent different \ninputs, the operation INPUT-VALUE distinguishes then. if they represent different points in a terminating \ncomputation, it is only neces\u00ad sary to appl:y ONE-STEP until one of them terminates, then apply IS-FINISHED?. \n Thus , START(n) is abstractly identical to ONE- STEP(START(n)) iff 1!4 fails to terminate on n. Ds(Rwt(M)) \n= {INPUT-VALUE(.)} u{ LS -FIiVLSHED ? (. ) } U{oiw s!nw( . ) } for example, of.~ arise This is the paper. \nwhen only as elements case in all totally-defined of the specified the examples of elements data type. \nthis STAR2 :n +wa, FALSE, COMpUTE(n, IUIT-COflFIG(n))> Whav COMPUTE : . Nat n,s x M-stat@ + Run(M) + \ni HALTING-STATE?(S) -7$t en W, TRUE, COWUTE(n, s)~ ~ Zn, FALSE, COMPU1 E(n, NEXT-STATE(s)) Y Appendix \n4 simple We solve case. the defining Assume that equation for D in a where DS(D) f : g: = {f(.,a)/aeA} \nD x A + B, DxC+D, u {g(.,c)/ceC}, Then tion the of equation D is for the specified representa D = (A+B) \nx (C+D), which we specified solve as an representation isOmorphism. to be Thus, take the ~ = C* + (A+B). \nC* Oft; and is, ~2 Q as c : s : usual, all finite sequences is the empty sequence. NOW, [c*+(A+B)] + \n(A+B) d+d(~), of elements define ~1 Q s : [~ d + (A+B)]*+ +Xc:C,~c ~c+[c + (A+B)JI :C .~(APPEND(c,c )), \nTo show functions that D - ~ (A+B) X (C+~), define the two and h : D + (A+B) : T -=@, h-l: (A+B) x : \nf,g +Ic x (c+D)&#38;J ~C+D) +D . Yf C%c then ~se g(FI~c*) f )(REST(c*)). It is quite straight-forward \nto show that h and h -1 are, in fact, inverses, as well as being homomorphisms with respect to the projection \nope-rations,Finally, the generalization to arbitrary DS S is easy. In order to give the usual fixed-point \nsemantics to functions specified recursively, we must regard the set D as having the usual function\u00adspace*or~ering. \nThat is, for ~,d!s~, d [ d! if for all c cC, d(c ) [ d (c ) in (A-%), Th~s-o~dering can be use~ to d~f~ne \nthe least fixed-uoint semantics of specified functions (such-as ABS), and, in turn, to justify the computation \ninduc\u00adtion proof rule, See [K] for a related, but simpler, case in stream processing. It may be added \nthat ring even when A,B and C possible that the reachable ~ is not a are. However, set of ~ flat orde\u00adit \nis is flat - \n\t\t\t", "proc_id": "567446", "abstract": "A new specification method for data types is presented, which is distinguished by the semantic objects it specifies. In particular, only final data types [GGM,W] are specifiable. A final data type is one in which no two elements are \"input-output equivalent\". It is argued that the mathematical properties of final data types characterize abstractness on the semantic level.Examples are given to show that final data type specifications are easy to construct and use.", "authors": [{"name": "Samuel Kamin", "author_profile_id": "81100030799", "affiliation": "IRIA-Laboria, Domaine de Voluceau, 78150 Le Chesnay, France", "person_id": "PP39024046", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567459", "year": "1980", "article_id": "567459", "conference": "POPL", "title": "Final data type specifications: a new data type specification method", "url": "http://dl.acm.org/citation.cfm?id=567459"}