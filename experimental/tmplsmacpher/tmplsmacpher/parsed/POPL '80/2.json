{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 in comparison with existing programs, and partly because we had no access \nto interactive terminals that were comparable in quality to our printing devices. 3. Design Strategy \nIn designing a better document formatting system, it behooves us to look at the best such system (a good \nsecretary) to learn what we can and mimic what we can. The author provides text to the secretary, who \nvisually parses the text into its components and makes some decisions about the nature and required format \nof the document. The secretary then selects an appropriate format and performs the necessary typing. \nNote well what is not communicated from author to secretary: any information about indentation, margins, \nspacing, and so on. All such typographic details are provided by the secretary, and in fact they differ \nfrom one format to the next even if the text is the same: a business letter and an internal memorandum \ntyped from the same dictated text would have greatly differing appearances. Since our requirements suggest \nthat the author should not be permitted to specify low-level formatting detail, and since we know of \nat least one successful document formatting system (our secretary) in which the author does not specify \nsuch details, we choose to restrict the specification language so that the author cannot specify such \ndetails. But those details are necessary to produce the final document, so some equivalent must be provided. \nOur goal is to put the expertise in the program, in much the same style as Shortliffe s MYCIN puts bacteriological \nexpertise into the program [9]. The formatting program will have access to a data base of formatting \nknowledge that it uses to achieve quality typography. We shall require that each document produced by \nScribe be of a specific declared document type, for example, a business letter or a technical report \nor a journal article. Each document type will have variant forms a CMU letterhead, a journal article \nin ACM proceedings format. Scribe retrieves from its database the definitions appropriate to produce \nthat document type on the intended printing device. Document type definitions are created by a format \ndesigner, a person with typographic expertise and knowledge of the format requirements of different documents. \nThey are not usually created by an author. 4. Design of a New C)ocument Formatter We enumerated a set \nof requirements, some made of the system as a whole and some made of the specification language, then \nformulated a design to try to meet those requirements. 4.1. System Requirements The design of the Scribe \nformatting language and its compiler was shaped by a number of specific requirements for the character \nof the resulting system. In this and following sections, we use the term manuscript jile to describe \ntext prepared by the user for input to the compiler, and jnished document for the result produced by \ncompiling that manuscript file. DEVICE PORTABILITY. Manuscript tiles should be independent of any particular \nprinting device; the document specification language should therefore contain no constructs that will \npermit a user to put device dependencies in his file. Since the format of the document must vary from \none printing device to another, this implies that the compiler must be able to supply the details, SITE \nPORTABILITY. The manuscript form of a document should contain nothing that implicitly restricts it to \na particular installation, which is to say that explicit file names and directory names and other local \nsystem names should not appear in the manuscript tile. Where the manuscript must refer to the file system, \nit should be through indirect symbolic names and not direct tile names. SEPARATION OF CONTENT AND FORMAT. \nThe text should contain no explicit formatting instructions, in order that it may be re-used in a different \nformat or context. Since the explicit formatting must occur before paper output can be produced, the \ncompiler must be able to supply. the details. A corollary to this requirement is that the author should \nsupply only the text, and a person more knowledgeable in typographic matters should provide the typographic \ndetail. Obviously a typographer cannot edit every manuscript tile or provide the information explicitly \neach time, which means that there must be a mechanism for storing, retrieving, and using typographic \nknowledge. INCREMENTAL CHANGE. Given that the format of a document is determined not by commands placed \nin the manuscript file but by the contents of a database, it should be possible to specify systematic \nchanges to that format by placing suitable modification commands at the beginning of a manuscript file. \nThose modification commands must be incremental: the user need specify only those properties that he \nwants to change, rather than respecifying the entire definition. We will restrict all modification commands \nto the beginning of a manuscript file to make it easier to remove them for purposes of re-use and portability. \nRESTRICTED GOALS. Formatting problems whose solution is too difilcult or whose specification is not possible \nin the specification language will be declared to be beyond the scope of the system , and no attempt \nwill be made to provide loopholes for them. We want to maintain the conceptual purity of the system at \nthe expense of completeness, to make it easier to evaluate the finished product. 4,2. Specification Language \nRequirements Rather than viewing the non-text parts of a manuscript file as commands to the formatting \nprogram, we view them as statements in a high-level non-procedural document specification language [12]. \nThe author indicat~s the formatting effect desired, strictly non-procedurally, and leaves to the compiler \nthe details of how to achieve that effect within the constraints of the selected printing device and \ndocument type. Certain requirements were placed on the language design. DISCRIMINATION OF TEXT FROM SPECIFICATION. \nThe major syntactic requirement of this specification language is that it not be confused with the text \nor interfere with it in any way. There should never be any ambiguity as to whether a particular lexeme \nis text. If multiple colors were available, we could mark the commands in colors, much as a proofreader \ndoes when proofreading a galley. If multiple fonts were available we could place all commands in some \nspecial font, such as script. Representation IN PRiNTiNG Ascu. We intend to use the manuscript form of \nthe document as the communications form which is transmitted to another site. We therefore require that \na manuscript file, with text and specifications present in it, be representable using only the 95 printing \nAscii characters. NOT A PROGRAMMING LANGUAGE. The language in which an author communicates his needs \nabout the format of his document is not to be a programming language. Procedural thinking does not come \neasily to non-technical people, and the system should be able to handle most of the formatting requirements \nof an undemanding user with simple nonprocedural specifications. 5, The Document Specification Language \n(Command Language) A Scribe manuscr@ jile is an unstructured stream of Ascii characters. It contains \nan interleaved mixture of text and statements that specify desired properties of the final format of \nthat text. Although these statements in the specification language are not commands in the ordinary sense \nof the word (they do not directly command anything), we shall nevertheless call them commands as a matter \nof convenience. The W? character was chosen as the sentinel to appear in text to flag the beginnings \nof commands: It is distinctive and is rarely used in normal prose, mathematical text, or program text. \nEach instance of an @ character denotes the beginning of a command. To get an @ character in text, two \nare used in the manuscript file: @@. Every command has one of these forms: c!?> a single character @Index(text) \nname and text @Set (Page=O) list of keywords and values If the text or list of keywords and values is \nempty, it may be elided along with its delimiters, provided that there is no ambiguity: @name 26 Although \nparentheses are used in the description of the commands, any of Scribe s delimiter pairs, described below, \ncan be used. Some sample commands: @i(Word) @Heading[Table of Contents] @Section <The Compiler> @: @\\ \n@2! @Style {References CACM, Footnotes * , Doublesided} @Newpage  Each command has a name, and most \napply to a specific delimited piece of text. The text may be delimited in a begin/end form: @beg in(quotation) \nA @i[non-procedural] program is a prescription . . some machine organization, @end(quotation)  or in \nan abbreviated form: @Quotation[A @i[non-procedural] program is a prescription ... some machine organization.] \n Any delimiter pair from the set (...), [...], <...>, {...), ... , ... , and ... may be used, and the \ndelimiters may be nested freely. Semantically, most statements in the specification language are labels \nmarking text in specific formatting environments. Each environment places certain requirements on the \nappearance of its text in the final document, without giving specific details. For example, an Italics \nenvironment (@I) requests that its text be set in an italic font appropriate to the surrounding text, \nor be underlined if there is no such font. A quotation environment (@Quotation), suitable for displayed \nquotations, requests that its text be set in a manner betitting quoted material, which in most document \ndesigns means that the left and right margins are adjusted inwards and the line spacing is made closer \ntoge,ther: A non-procedural program is a prescription for solving a problem without regard to the details \nof how it is solved. That is, solutions should be specified implicitly in terms of structures or abstractions \nwhich are relevant to the problem rather than those operations, data, and control structures that are \nconvenient for some machine organization [6]. There are about a hundred scalar variables whose values \ntogether define the environmental state, and therefore the details of the resulting format. Each environment \nis a partial specification of the state vector. The italics environment doesn t affect the state cells \nthat determine margins, and the quotation environment doesn t normally affect the type face in used, \nso that italic and quotation are orthogonal. Italic and Roman , however, both specify different values \nfor the same state variable, When environments are nested, the unspecified properties are simply inherited \nfrom the surrounding environment. Some environments, such as chapter heading , specify almost everything: \na particular font, boldness, size, spacing, margin, and so forth, Others, such as italics , specify almost \nnothing, leaving everything but the face code attribute to be inherited. It is perfectly meaningful to \nspecify a theorem inside a footnote or a footnote inside a theorem, though it is up to the document type \ndesigner to ensure that both are typeset reasonably. A few actual commands exist in the document specification \nlanguage; they correspond roughly to declarations in a programming language. For example, the @Device \ncommand declares the printing device, and the (?Pageheading command declares a page heading to be used \nfrom that point on. 6. The Compiler A Scribe compiler has been written in Bliss for a PDP-10; it compiles \nmanuscript files into finished documents. Each manuscript tiles contains a (possibly implicit) specification \nof a device type (line printer, phototypesetter, etc.) and a document type (letter, thesis, journal article, \netc.), The compiler loads from its database the definition of the printing device and the definition \nof the document format, then processes the manuscript file accordingly. The essence of the compiler is \nits environment-processing mechanism. Whenever an environment transition occurs-entry or exit the state \nchanges are examined to see if they imply some sort of non-trivial processing. If so, the processing \nis performed. For example, if an environment entry is found to contain a request to use a large font \non the phototypesetter, then the appropriate rotate lens turret code will be generated; when that environment \nis ended and the containing environment is resumed, another turret-rotation code will be generated to \nposition it back again. An environment definition can specify, for each cell in the state vector, an \nabsolute value (set the left margin to one inch), a relative value (widen the left margin by three centimeters), \nor no value at all (don t touch the left margin). The environment is represented internally as a list \nof (variable, value) pairs, and at the lowest level the environment-entry code just iterates over that \nlist, making the appropriate changes to a copy of the old state vector. The kind of change to be made \nis represented by the type of the value in the compiler. The modification facility required in section \n4.1 is implemented by providing a mechan ism to edit these lists. Although the compiler is strictly \none-pass, it provides a full cross reference capability by means of an auxiliary file that is generated \nas a byproduct of the compilation. The auxiliary file is essentially an extract of the symbol table. \nEach time a manuscript file is processed, the compiler checks for the presence of an auxiliary tile left \nbehind by the previous compilation. The auxiliary file contains all of the cross-reference label definitions \nfrom the previous compilation, and usually they haven t changed much. If the compiler discovers that \na definition of a label has changed (and hence the value used in a cross reference was wrong), it will \nprint a warning message; if the manuscript file is recompiled without change, the cross references will \nall be correct. 7. The Database Each time the Scribe compiler processes a manuscript file, it retrieves \nfrom its data base the information defining the relevant device properties, text formats, fonts, numbering \nschemes, and so forth. The contents of each database entry is just a sequence of Scribe commands; they \nare reparsed and re-evaluated in every compiler run. The device files in the database provide device \nparameters (paper size, font size, spacing resolution, etc.) and also provide device-dependent implementations \nof the standard basic environments. For example,, the italic environment is implemented separately in \neach device tile, The device tile for the line printer implements italic by turning it into underline \n; the device file for a photocomposer implements italic by changing the font code, The document tjpe \nfiles in the database provide device-specific environment format definitions for various document types. \nEach document-type file is partitioned into segments; each segment defines that format for a particular \nprinting device or group of devices. Environment definitions do not necessarily occur in all document \ntypes there is no need for a return address environment in a thesis or a table of contents in a letter \nbut careful attention is paid to making the names of environments that are conceptually similar be the \nsame from one document type to another. Bibliography format files in the database define the bibliography \nformats that are required by various journals. The font family files define various font combinations \nthat have been selected by graphics designers to look harmonious when used together. The character width \nfiles define individual width and kern values for specific fonts. We intend that the database files be \ncreated and maintained by persons with a higher level of expertise than that required simply to use the \nsystem. The device definition files are assembled by people with a relatively sophisticated knowledge \nof the workings of the compiler, and the document type tiles are intended to be created by persons with \nartistic talent (although the initial document type designs were all created by the compiler writer). \n8. Scribe as a Writer% Workbench Although its ultimate job is to format a printed document, the Scribe \nsystem is strongly oriented towards providing support to writers while a document is under construction. \nThe name Writer s Workbench is borrowed from the Programmer s Workbench [2]. Many of these writer s tools \nare made possible or made simpler because of the high-level nonprocedural nature of the specification \nlanguage. 28 The Scribe compiler will automatically generate numbers for pages, chapters, footnotes, \ntheorems, examples, or what have you, One of the attributes that an environment may specify is numbering \nstyle, which includes a specification of how to number, how and when to increment the number, and how \nto display the number in the user s text, The cross-referencing mechanism allows references to be made \nto generated numbers by binding symbolic names to them, and all cross references are specified in terms \nof those symbolic identifier names. The compiler will print out charts, in sort by manuscript position \nand also alphabetically by identifier name, of the location of the symbolic labels, their values, and \nthe references made to them. Portions of a document that are essentially derivative-index, table of contents, \nglossary, table of figures-can be generated automatically. They are generated as manuscript files and \nthen read back in as if they were part of the original document. The document may be divided into a tree \nstructure of subfiles; when a compilation is begun from the root the complete document is produced. Because \nof the existence of the auxiliary tile (see section 6), it is possible to compile any subtree or leaf \nfile separately and have all of the numbering and cross referencing come out right. When a non-root compilation \nis begun the compiler refers to the auxiliary file, in which it has saved enough information to enable \nit to restore its state to what it would have been had the compiler reached the same spot 1. At the end \nof a non-root compilation, the auxiliary file is updated as necessary. 9. Experience and Conclusions \nThe Scribe compiler has been operational at Carnegie-Mellon since February 1978; manuals were available \nby summer 1978 [81, and the system was fairly stable by early fall. It is now at use at a number of other \ninstallations. As a production software system, it has been an unqualified success, which to a certain \nextent obscures our ability to learn about the success or failure of the ideas that were the essence \nof the research. 9.1. Successes The specification language has turned out to be genuinely site-portable. \nIt is commonplace to move files from one Scribe site to another and recompile them without incident. \nThe goal of device independence has been met well enough that people regularly make proof copies of a \ndocument on one device and the final copy on another. People who have never used any device but a line \nprinter and never seen a photocomposer can change the @Device command in their manuscript files and produce \nhandsome typeset output. The language is simple enough that people with no programming background can \nlearn it in a few hours of instruction, yet powerful enough that an 800-page textbook with fairly stringent \nformatting requirements has been typeset with Scribe [131. A freshman class in computer tools for humanities \nmajors is now taught at Carnegie-Mellon; the students learn Scribe in the first few weeks of class and \nuse it for class assignments. The goal of separation of content and format was met well enough that we \nwere able to produce thk year s edition of our annual Research Review by merging the five papers as formatted \nby the authors with various tabular material, changing the document type, and producing a typeset copy. \nNone of the papers contained any commands or environments that required any change before the five papers \ncould be merged into a single journal. 9.2. Failures The quality of typography, especially page layout, \nfigure placement and widow elimination, is not good. This could be improved by writing a better compiler; \nthere seems to be nothing intrinsic to the ] lt k worth noting that the representation of environments \nas 21n ~ub~shlng parlance, a wkiow is the laSt Or first line of a attribute/value pairs rather than \nas macros makes this process paragraph that falls by hself at the beginning or end of a page. fairly \nsimple. specification language that limits typographic quality. Knuth s Tex has demonstrated that superb-quality \ntypography can be obtained from computer-origin text [41. We would like not to require as high a ratio \nof commands to text as does TCX, The original specification language design did not include any facility \nfor tabular material or mathematics, and it has proved difficult to add them gracefully after the fact, \nbecause it would require incompatible changes to the existing syntax to accommodate the extended specification \nlanguage. It is not clear whethe~ or not the essential notions of abstract non-procedural specification \ncan be extended to mathematical text; it is quite certain that they can be extended to tabular material. \nThe EQN and TBL preprocessor systems for TROFF [3, 71 demonstrate the feasibility of such a scheme, but \nneither system is entirely portable or complete. The separation of content and format has made it difficult \nfor users to circumvent errors or weaknesses in the compiler. The compiler needs to be fairly well debugged \n(which it often wasn t) for it to be usable at all, The flexibility of. the system, whale a blessing \nfor those who understand it, made it a nightmare to document. Almost no statement about the behavior \nof the, compiler or the semantics of an environment can be universally true, because the definition of \nalmost anything can be changed. This sort of flexibility needs to be imbedded in an interactive program \nhaving an extensive help facility in order that a user can find out not what an environment might do, \nbut what it will do. The flexibility morass has the characteristic that novice users and expert users \nhave no trouble; the intermediate-level users, who are knowledgeable enough to know how to change a definition, \noften don t understand the full nature of the change they are making and become very confused by the \nresults. The compiler is relatively slow; it processes only about 50 to 80 output pages per minute of \nCPU time on a DEC KL-10. Although this is an order of magnitude slower than simpler conventional programs \nlike RUNOFF, the total amount of CPU time expended during the course of developing a document is often \nless, because the tile need not be compiled as often.  9.3. Future Work We are certain that the overall \napproach that shaped the design of the Scribe system is sound, but the compiler and database have grown \nto be fairly complex. Future efforts should be more interactive, should be more closely tied to the editor \nand tile system, and should provide a more complete specification language before acquiring a user community, \nWith proper cooperation of file system, editor, and display device, and with careful design of the manuscript \ntile specification language, it should be possible to design an interactive system that can maintain \na BRAVO-like graphic display of the finished document while actually storing the commands that were used \nto generate that display. Acknowledgements Bill Wulf, Mary Shaw, and David Lamb inspired the Scribe project \nand performed the studies that made us believe it was feasible. Paul Hiltlnger has managed to maintain \nthe conceptual purity of the specification language in the face of hundreds of demanding users. Ivor \nDurham was the pilot user of the compiler, and Craig Everhart, David Lamb, Bruce Leverett, Paul Knueven, \nPhilip Lehman, James Adams, Loretta Guarino, Elaine Rich, and Mike Kazar all helped the implementation \nin various ways. Larry Tesler s PUB provided a sandbox in which to test many ideas before beginning an \nimplementation. Janet Walker made the User s Manual readable and finite. A speeial thanks to the whole \ncomputer science community at CMU, who lived with a changing system for two years as I continually redefined \nit out from under them.  References 1. Gorlick, M.; Manis, V.; Rushworth, T.; van den Bosch, P. and \nVenema, T: Texture User s Manual. Department of Computer Science, University of British Columbia, Vancouver, \nB.C. V6T 1W5, 1975. 2. Evan L. Ivie. The Programmer s Workbench -A Machine for Software Development. \nComm. ACM 20, 10 (October 1977),  30 3. Kernighan, Brian W. and Cherry, Lorinda L. A System for Typesetting \nMathematics. Comm. ACM 18, 3 (March 1975), 182-193. 4. Knuth, Donald E. TEX: A System for Technical \nText. Tech. Rept. AIM-217, Stanford University, November, 1978.  5, Lampson, Butler. Bravo Manual. Xerox \nCorporation, Palo Alto, CA, 1978. 6. Leavenworth, Burt M. and Sammet, Jean E. An Overview of Nonprocedural \nLanguages. Proceedings of a Symposium on Very High Level Languages, ACM-SIGPLAN, April, 1974. Published \nas Volume 9, Number 4, of SIGPLAN Notices 7. Ossanna, J. F. TROFF User s Manual, Tech. Rept. 54, Bell \nLaboratories, 1977.  8, Reid, Brian K. Scribe Users Manual. CMU Computer Science Department, 1978. 9. \nShortliffe, Edward Hance. Computer-Based $7~ Consultations: MYCIN. American Elsevier, 10. Sibbald, Kern \nE. DPS User s Guide, Tech, Rept. CN-16,0, University of Maryland, April, 1976. 11. Tesler, Larry. PUB: \nThe Document Compiler. Tech. Rept. ON-70, Stanford University Artifical Intelligence Project, September, \n1972. 12. Winograd, T. Beyond Programming Languages. Comm. ACM 22, 7 (July 1979), 391ff. 13. W. Wulf, \nM. Shaw, P. Hilfinger, and L, Flon. Fundamental Structures of Computer Science. Addison-Wesley, 1980. \n \n\t\t\t", "proc_id": "567446", "abstract": "The very best document-formatting system is a good secretary. He can be given scrawled handwritten text in no particular format, and without further instruction produce a flawless finished document. Nevertheless, we believe that document formatting should be done by computers, because so much of it is the tedium that computers handle so well. Existing computer document formatting programs have met with some success; indeed, most computer systems offer some sort of text formatting capability. These programs are often difficult to use, and are almost invariably tied to a particular kind of printing device.The document-formatting language <i>Scribe</i> was designed to provide a simple, portable language in which document formatting could be specified; the Scribe compiler was written to process that language into finished documents. In following sections we describe the design goals, the implementation, and report on experience with the completed system.", "authors": [{"name": "Brian K. Reid", "author_profile_id": "81100284251", "affiliation": "Carnegie-Mellon University, Pittsburgh, PA", "person_id": "PP309930200", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567449", "year": "1980", "article_id": "567449", "conference": "POPL", "title": "A high-level approach to computer document formatting", "url": "http://dl.acm.org/citation.cfm?id=567449"}