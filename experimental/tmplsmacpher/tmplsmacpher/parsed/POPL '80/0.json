{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 we define the safety of pointel rotation when applied to linear lists and \ntrees. Then, we extend this definition to arbitmry pointer data structures and show a decision procedure \nto check safety. In section 7 we show two examples, list marking and list copying programs written using \nrotations and slides. We examine how we can directly code the algorithms using these operations and safety \nchecking algorithms are useful. passing parameters by VAR parameters is crucial to the definition. This \nensures that all the arguments are evaluated in parallel, before any assignments take place. Therefore, \nthese operations can also be defined by multiple assignments: Rotate: procedure(var xl, x2, ... . xn:T) \n= begin x1+x2, x2+x3, ... . Xn+-xl end Slide: procedure(var xl, x2, ... . xn:T) = begin X1+X2, x2+x3, \n... . Xn.,l+xn end. 2. History The first time I was exposed to pointer rotation was when Jefferson told \nme [Jefferson] that pointer swapping is a nice opemtion for structuring complex operations. Flon [Flon] \nshowed me an example of a priority queue, where insertion and deletion are implemented by a set of pointer \nswaps. Later I wrote a program for the Deutsch-Schorr-Waite algorithm [Schorr&#38;Waite] in 1978 and \ndiscovered that the pointer manipulations in the program can be fully described by three-way pointer \nrotation, a generalization of pointer swapping. I asked Peter Deutsch whether he knew this, and he told \nme that he realized this fact when he invented the marking algorithm but he never published it. Since \nrotation is a kind of permutation, the question arises whether rotation should really be defined as a \ncomposition of swaps. (There is a well-known theorem that any permutation can be represented by a composition \nof swaps.) However, Rotate(x, x?.Next, y) is not equal to Swap(x, xt.Next); Swap(xT.Next, y) as shown \nin Fig. 1. This is because the value of x in the first Swap is not the same as the value of x in the \nsecond Swap, In a recent conversation, Jim Horning told me that Gries [Gries] and Dijkstra had been studying \nmultiple assignments, but almost all of their examples can be described by rotations. The results in \nthis paper are, therefore, applicable to their examples, 4, Deutsch%chorr~Waite marking algorithm We \nwill observe how these operations make this marking algorithm compact. The original algorithm using pointer \nassignments is (comments are placed between bmces): 3. Definition We which will are analyze defined the \nfollowing in terms of two pointer operations, equivalent procedures: Romte: procedure(var xl, x2, ... \n. xn:T) = begin ~ar w:T; w: =x1; xl: =x2; ,.. ; Xn: =W end Slide: procedure(var xl, x2, ... . xn:T) begin \nXl: =X2; X2: =X3; ... ; Xn-l:=xn = end where locations of variables xl, X2, ... , Xn are all distinct \nfrom each other for both operations. We note here that 2 { Deutsch-Schorr-Waitealgorithm ] begin z:=aO;x: \n=NIL; whiletrue dobegin { left descend} while z#NIL A zt.m= Odo beginz?.m:= 1;w:= z?.hd;z?.hd:=x; x: \n=z; Z:=W end; { right ascend} while x#NIL A x?.fl= 1do beginw:=x?.tl; xt.tl:=z; z:=x; x:=Wend; if x = \nNIL thenexit; { lcft$~=h: } .:; W: =x?.hd; x?.hd:= Z; Z: =xT.tl; xT.tl: = W end; end. The version written \nusing pointer rotations is: { Improved D-S-W algorithm} begin z:=aO:x: =NI~. whiletrue dobegin while \nz#NIL A zt.m=O do beginmm: =1; Rotate(z?.hd,x, z) end; while x#NIL A xt,fl= 1doRotate(x,xt.tl, z); if \nx = NIL thenexit; xt.fl: = 1;Rotate(xr.hd,z,x?,tl) end; end. Twelve pointer assignments are replaced \nby three pointer rotations. Each node is visited three times corresponding to: top-to-left scan, left-to-right \nscan, right-to-top scan of preorder traversing. In the abi ve program each rotation accomplishes one \nscan of a node. The first rotation is the top-to-left scan, the second rotation is the right-to-top scan, \nand the third rotation is the left-to-right scan. This example is reviewed again in section 6. 5. Properties \nof Rotations I wondered why pointer rotation is convenient in writing algorithms such as list marking. \nI conjectured that there must be some measures associated with the graph structures of pointers that \nremain invariant over rotation operations. obviously, a single pointer assignment will change most such \nmeasures. If I could find such measures, and show that their invariance would guarantee the safety of \na class of prograins like marking algorithms and balanced wee algorithms, this would be strong mathematical \nevidence of the safety of pointer rotation. The first conjecture was that the number of loops in the \ngraph would remain invariant under rotation, Even though this conjecture looks promising and attractive, \na counter-example was quickly found. Suppose y points to a linear list, then Rotate(y, y?.lyext) will \nintroduce a loop such that the previous pointer yt.Next will point to itself (Fi:g. 1). 3 )0  C/ $ \nFig. 1 Effect of Rotate(y, yt.Next) However, some properties that do hold are; Property 1: (Invariance \nof reference counts) The number of pointers to a record will remain the same no matter how many rotations \nare performed. Therefore, if every record has a reference count field, the value of which remains constant. \nProperty 2: (Non-circularity of trees) Rotations are often applied to linear lists and trees. What is \nunique about these structures is that the reference counts of all the records are always one. Therefore, \nfrom property 1, after any number of rotations, the reference count of each record is still one. Hence, \nthe structures reachable from the roots remain non-circular and non\u00adsharing. What will happen is that \nsome records will form loops and become unreachable from roots (see the example of Fig. 1). (It is easy \nto show that if the reference counts of all records are one and there is a loop, no records in the loop \nare reachable from outside pointers.) A moral here is that always u:serotations when yoL~are manipulating \nlinear lists and tr~. Sketch of proofi We will prove here that if all the records reachable from a pointer \nx have reference counts of one, then the data structure is a tree. Suppose it is not a tree, then there \nis a cycle or a sharing. If there is a cycle then either any member of the cycle is not reachable from \nx or there is a record with reference count more than one. We will enumerate the values of pointers (address \nof records) along all the possible paths. This enumeration may terminate because we took the path on \nwhich we hit a record from which no pointers are emanating. in this case there is no circularity. If \nit does not terminate, there are addresses which appear more than once. Then the first address in this \nenumeration which appears more than once is the record with reference count more than one. I EM.!QLM \nConsider two linear lists which are pointed to by x and y. To move one record from the head pointed \nby x and to the list pointed by y is var w; w : = xt.Next; xt.Next : = y; y ;= x; x := w;  but the program \nwith rotation is Rotate(x, xT.Next, y). Similarly, reversing a linear list is succinctly written as: \nY := NIL; while x#NIL do Rotate(x, xT.Next, y) { y points to the reverse of the original list } Property \n3: (Rotatability of arguments) Furthermore, the arguments can be rotated without changing the effect, \nFor example, in 3-way rotations, Rotate(x,y,z), Rotate(y,z,x), and Rotate(z,x,y) all have the same effect. \nAs you can see, we can partition n-way rotations into equivalence classes according to their effects. \nFor n-way rotations there are n! syntactically different rotations and (n-l)! equivalence classes, each \nof which consists of n rotations. Therefore, even though there are 6 syntactically different rotations \nof three arguments, there are only two distinct classes of 3-way rotat m. Once we decide that we can \ncreate an algorithm by rotation, there is very little chance of introducing bugs. We will see why this \nis particularly useful in the case of the D-S-W marking algorithm in section 7. Property 4: (Closure) \nHere we mean by closure that some number of applications of rotations will restore the original data \nstructures. If all the arguments of rotations are simple variables, it is easy to show that this property \nis true using simple facts from combinatorics. However, the application of Rotate(y, yt.Next) to a linear \nlist damages the data structure permanently and no rotations will restore the original data structures. \nTherefore, we need some premise about kinds of rotations which we can operate, in order to assert that \nthere are applications of rotations to restore the original data structures. We need some more definitions \nin order to express the closure property, In particular the safety property to be introduced in section \n6 is closely related. We state the theorem without the definition of safety and prove it in the appendix. \n(This property was conjectured and suggested to me for investigation by Al Perlis.) Theorem Suppose we \nhave operated rotations on some data structures, and they are all safe rotations. Then, there is a sequence \nof rotations, such that the applications of them will restore the original data structures. Property \n5: (Completeness of pointer rotation) Finally, we would like to know what can be done by pointer rotation \nand what cannot be done. Facts essential to this question are: If a straight-line part of an algorithm \nreciuires that the reference counts be the same at the entry and at the exit, and no new records are \nintroduced, the part is implemented by one n-way rotation. Furthermore, if the number of records reachable \nfrom pointer variables is the same at the beginning and at the end of computation, and if the reference \ncount of each record is the same, then there is an equivalent program which uses only pointer rotations. \n Pointer rotations, however, cannot do all pointer manipulations. Using pointer assignments to augment \nthe power is not desirable. For example, X:=y; y:=z; z;=w; w;=u cannot be written using rotations unless \none compromises efficiency and writes Rotate(x,y,z,w); w:= u, An operation which is both universal and \ncompact is the pointer slide operation. The above example can be written as Slide(x,y,z,w,u). This is \nas powerful as primitive pointer assignment, since x:= y is equivalent to Slide(x,y). 6.Safety of Rotations \nProperties investigated in the previous section are mostly facts invariant under rotations. What we will \nsee in this section are facts not necessarily be invariant, but facts easily checkable whether it holds \nor not and furthermore they will increase the reliability of programs. As we observed in the previous \nsection, if rotations are applied to trees, some records previously reachable from the roots will become \nunreachable. In most of the cases losing a record in such a manner is a bad practice. These unreachable \nrecords have to be eventually reclaimed by garbage collector, and in many reference counting garbage \ncollection schema they are simply forever lost. Both of them add to the cost of computation. In the case \nsuch as Rotate(y, yt.Next), a conscious programmer will write Rotate(y, yt.Next, FreeList) instead to \nfree the record explicitly. Since losing a record by rotation over trees is a bad practice, other caused \nby some program errors, we call rotations to be @ if no records are lost. There is also a simple method \nto check whether a given rotation is safe simply write a graph representing pointers. This method does \nnot work unless every pointer operation is a rotation, since it is impossible to check whether a given \nstructure is a tree. Let us analyze what we meant by safety of rotations on arbitrary data structures. \nConsider the operation Rotate(x, z, xt.tl) on an arbitrary data structure. In the case where x#z#x?.tl#x, \nthe data structures before and after the rotation are shown in Fig. 2. Note that only the pointers and \nrecords appearing in the arguments of Rotate(x, z, xt.tl) are shown in this figure, If there are no other \npointers, this operation is unsafe since the record A is lost. Fig. 2 Effect of Rotate(X, Z, X*.tl) \nIn arbitrary data structures there may be many other pointers to A, B, and C. Therefore, it may be possible \nto still reach A from some other pointers. However, checking whether there is a pointer to a certain \nrecord in an arbitrary data structure is intractable. Therefore, we will only consider pointers and records \nexplicitly mentioned in the arguments of rotation. We define that a record is lost in rotation if it \nis not reachable from any program variable appearing in the arguments through pointers mentioned in the \narguments. We say a rotation is safe if it does not lose a record in the above sense. We will observe \nin the next section whether this definition of safety is a useful one. We will see that all the rotations \nare safe, and all the mistakes by rearranging arguments are unsafe. Therefore, simple errors are detectable. \n7. Verification Method of Safety We will show in this section an algorithm to decide whether a pointer \nrotation is safe. This corresponds to research in array bound overflow checking [Suzuki&#38;Ishihata]. \nThese data structures require some invariant to be maintained over operations on them, which gives rise \nto semantic checking-verification of the correctness of operations without user supplied assertions. \n 7.1 Notation Graphical representation used in Fig. 2 is a very convenient way to capture two important \nattributes of pointers values of pointer expressions and locations where these values are stored. In \nthis paper all the pointer values are addresses of records, and locations of these values are ag~in addresses \nof records or of program variables. Therefore, we will give tmique names to records (denoting addresses \nof records) and invent notations to capture the meaning of pointers. We use capital letters for these \nnames of records. The following notation is used to represent a pointer variable x: x-B which states \nthat the pointer variable x points to record B. If the value of x is NIL, it is represented as x+NIL. \n When B denotes a record which has two fields hd and tl, we can use B.hd+C /l B.tl-iD which states that \nthe value of hd field is C and the value of tl field is D. Combined with x-+B, we can infer that x~.hd \nhas value C. The following facts are direct consequence of the notation: 1) x-iB = (3C)[X+B A B.s+C] \nfor all valid selectors .s of xt. 2) x-tBAy+D?x=y*B=D 3) A.s+B A C.S+D /l A=C ==) B=D We are not going \nto address expressibility of this notation for arbitrary programs. However, this notation is sufficient \nfor describing the effect of one rotation on finite number of poiriters and records. We say that record \nB is reachable from a program identifier x if x+B is true, or there is a sequence of records Al, A2, \n... , Ai such that x--iA~ A .Il~.s~+A2 A A2.s2+A3 A ... A Ai.si~B. 7.2 Representation of Rotation Using \nthis notation, we can represent data structures before and after rotations. Consider the application \nof Rotate(xt.hd, z, xt.tl). Pointers involved are: x, z, x~.hd, and x?,tl. We introduce record names, \nB, C, D, and F, and can describe a state before the rotation: x-tB A B.hd+C A B.tl+D A ZAF. Then the \nresult state of the rotation is: x+B A B.hd+F /l B.ti+C A z-tD. We say that the rotation is safe if \nall the records are reachable from program identifiers, or the rtcord is the origin of a program identifier. \nIn the above example we assumed that all the pointers have distinct values; that is x#z ~ x#xt.tl A x#z \nA z#x?.hd A z+x t ,tl A xT.hd#xA.tl. In order to say that this Pointer rotation does not lose a record \nwe have to show that it does not lose a record for all the cases. For example, if we assume X#Z A x#xT.tl \nA z#x~,hd A z+x~.tl /? x?.hd#x~.tl but x=x~.hd, then the state before the rotation is: x+B A B.hd+A A \nB.tl+D A z+F. The result state of the rotation is: x+B A B.hd+F /f B.tl >A A z-+D and again this is \nsafe. 7.3 The Decision Procedure The example in the previous section suggests an afgorithm, which check \nwhether the rotation is safe using the notation for all the cases of equality and inequality relations \namong pointers. The number of distinct cases can be defined by all the different partitions of pointer \nvalues. The number of partitions of n objects is Bn, the Bell number of n, which is asymptotically close \nto the factorial of n. The algorithm is shown below: Step 1: Enumerate all the pointer expressions appearing \nin the arguments of rotation. Assume there are n expressions. Step 2: Obtain all the partdions of n \nexpressions. For each partition do the following steps 3 to 7, Step 3: Obtain the conjunction of equalities \nand inequalities among expressions according to the partition. If two expressions are in the same set \nmake them equal, if they are in different set make them unequal. Step 4: Because pointer expressions \nare not independent (x and xt.hd are examples of dependent expressions), some of the conjunctions of \nthese equalities and inequalities are unsatisfiable. For example, x = y A xt.hd#y$.hd is unsatisfiable. \nCheck to see if the obtained conjunction is unsatisfiable. If so, go to step 3 and repeat with the new \npartition. Step 5: Construct the conjunction representing reachability like the one at the end of section \n6.2. Step 6: Operate rotation on this conjunction and obtain the result conjunction. Step 7: Check if \nthe formula indicates safety of rotation. If safe and exhausted all the partitions, terminate with the \nresult safe. Othelwise go to step 3 and repeat with the new partition, If it is not safe, terminate with \nthe result w-@e. There are two simplifications of this algorithm. First, it is not necessary to consider \nthe partition where all the pointers take the same value. Since any rotations will keep the values of \npointers the same, they are always safe. The other simplification is observed by the fact that if all \nthe arguments are simple variables the change of the value of any pointer expression does not affect \nthe values of the other pointers. However, it is possible that some variable x is an alias of another \nvariable y, the change of x will affect y even though they are syntactical] y distinct. This is avoided \nby the fact that all the locations of pointers must be distinct. Actually, we can state a little stronger \nfact. For the rotation Rotate(el, e2, ... . en) if any argument ei is not an initial section of all the \nother arguments and there are no aliasing, the rotation is safe. For example, Rotate(xt.hd, xt.tl, z) \nis a safe rotation, assuming x is not an alias of z.  7.4 Application of Safety Check We will examine \nhow these definitions of safety are useful in actual example. The following is the D-S-W marking algorithm. \nLet us look at ibis example again and see how the decidability results we obtained can be applied: begin \nz:=aO;x:=NIL; 100D while z#NIL A z,m=O (to begin zt.m: = 1; Rotatc(zr.hd, x, z) end: whilex#NII. Ax.fl=1doRotate(x,x?.tl,z); \nif x = NIL then exit; xt.fl: = 1; Rotate(xT.hd,z,:v.tl) endloop; end. For the first rotation Rotate(z*.hd, \nx, z), there are five cases to consider depending 0[1 partitions of x, z, and z~,hd. Case 1. <x>, <z>, \n<z~.hd> x+A A z+B /l B.hd+C The result is x+B A z-c A B.hd-+C Case 2. <X>, <Z, z?,hd> x+A A z-B A B,hd~13 \nThe result is x*B A z+B A B.hd.+A Case 3. <Z>, <X, z~.hd> x+B A z+A A A.hd-.)B The result is x+A A z+B \nA A.hd-+B Case 4. <zt.hd>, <x, z> x+B A z+B A B.hd+A The result is x+B A z+A A B.hd--iB Therefore, in \nall cases all the records are reachable from x or z and the rotation is safe. Another advantage of using \nrotation here is that the only different rotation is Rotate(z~,hd, z, x), which is unsafe. Therefore, \nthere is very little freedom of what one can do to make the algorithm work. Furthermore, verification \nbecomes simple, Each record is scanned three times by rotations in the order: Rotate(z~,hd, x, z), Rotate(x, \nxt.tl, z), Rotate(xt.hd, z, xt.tl). But it is very easy to see that successive applications of these \nthree operations will restore the values of x, z, z$,hd, and z~.tl. Therefore, it is not difficult to \nshow that all the pointers have the same values as at the beginning when the program terminates, Finally \nwe see that the definition of safety is actually very useful in locating bugs. Consider all the rotations \nof the above example: Rotate(zt.hd, x, z), Rotate(x, xt,tl, z), and Rotate(xt.hd, z, x?.tl). Kinds of \nbugs which might occur are wrong ordering of arguments. Because of rotatability of arguments, there are \nonly two cases for each rotation. They are Rotate(zt,hd, z, x), Rotate(x, z, x~.tl), and Rotate(xt.hd, \nX 1 .tl,z). Except for the last case, which is safe no matter what is the order of arguments, they are \nall unsafe. 8. Example (Robson s List Copying Algorithm) We will show how a more complex algorithm than \nmarking algorithm can be written using rotations and slides, The algorithm we examine is a list copying \nalgorithm invented by Robson [Robson]. The major characteristics of this algorithm are that no extra \nstorage is the computation time is linear. The algorithm consists of two phases: left-to-right scan phase \nand right-to-left scan phase. The first phase creates a copy cell for each cell and divides cells into \nfour classes according to kinds of pointers they have, f!his information is stored in the right pointer \nfield of the original cell. The classification of cells according to types of cells is as follows: O \n-> L: back pointer, R: back pointer 1-> L: back pointer, R: forward pointer 2-> L: forward pointer, R: \nback pointer 3-> L: forward pointer, R: forward pointer The second phase scans the tree right-to-left \nand rewrites pointers to the correct values. Therefore, each cell is scanned six times three times in \nthe first phase and three times in the second phase. The program for this algorithm is shown below. A \nphenomenal fact is that, just like D-S-W marking algorithm, pointer operations for scanning once cell \non one direction are described by one rotation or one slide, except when a new copy cell is created. \n{ Robson salgorithm } type node = record l,r: T node end; var markO, markl, mark2, mark3: tnode; function \nmarkof = (n: ? node): integer; { ~&#38;ns 4 if its unmarked, otherwise returns the mark } markof: = \n4; if n = markO then markof: = O else if n =-markl then rnarkof: = 1 else if n = mark2 then markof: = \n2 else if n=mark3 then markof: = 3  end; function marked = (n:tnode): Boolemr; { returns true if and \nonly if n is mark.-d } begin marked: = markof(n)<4 end; function copyof = (n:vmode): *node begin if n=nil \nthen copyof: = nil else copyof: = nt.1 end; procedure mark = (n: Tnode, I: integer); begin case markof(n) \n+ I of O:n?.r: = markO; 1: n?.r: = markl; 2: rm,r: = mark2; 3: n?.r: = mark3 end end; procedure copy \n= (n: Tnode): ?node; begin newf, gf, f, s:mode; down: Boolean; gf:= nil; f:= n; copy := nil; { gf, c \nands correspond to grandfather, father, and son } if f= nil then return; {Phase 1} down: = trne; do \ndown and f#nil and not marked(f) -> new(new~; Slide(newf?.r, ft.r, mark2); Rotate(newft.l, gf, f, f?.l, \nnewo jl { top to left } down and (f= nil Or marked(f)) and even(markof(gf)) -> mark(gf,-1): Rotate(gf?.l?.1, \nf, gfT.l?.r) D { top to right } down and (f= nil Or marked(t)) and odd(markof(gf)) -> down : = false; \nmark(gf,-l); Rotate(f, gf, gf?.lt.r) D { left to top } not down mrd cvcn(marko~g~) -> down : = true; \nmark(gf,l); Rotate(gfr.lT.1, t gfi.1 r.r) U { left to right } no~down and odd(marko[gf)) -> Rotate(f, \ng~ gfT.lT,r) { right to top ] od; { Phase 2 } down : = true; do down and odd(marko~~) -> Rotatc(gf, \nL gf?.l?.r) II { top to right } down and markof(t)= 2-> Slide(f?.r, ft.lt.r, copyof(ft.lt.r)); Rotate(gf, \n~ ft.l?.1) o { top to right to left} down and marftof(f)= 0-> Slide(f?.r, f?.lT.r, copyof(f?.lt.r)); \nSlide(s, fT.], ft.lT.i, copyof(fT.lT.l)); down: = false D { top to right to top} not down and gf# nil \nand marked(gf) -> Slidc(gfT,r, f, gf?.l?,l, gf?.lt.r, f?.l); down: = true B { right to left ] not down \nand gf#nil and not marked(gt) -> Rotate(gf, gft.l?.l, s, gft.1, f) { left to top } od; copy := s; end; \n ncw(markO); new(markl); ncw(mark2); lnew(mark3); { body of the program} end 9. Conclusion We reviewed \nmethods to increase reliability and readability of pointer operations, We analyzed pointer rotations \nand slides as operations to implement tricky pointer manipulations such as lisl: marking, list copying, \nand balanced tree manipulations. We found several properties are invariant under rotations, In particular \nthe number of pointers to each record remains constant. We then defined the safety of rotation to be \nnot losing a record amd showed that there is a decision procedure for finding out whether a rotation \nloses a record. We finally examined carefully how rotations and slides can be used in list copying algorithm. \nIIere are several other advantages of rotations over assignments. One is that we can execute rotation \nmore efficiently than pointer assignment. In particular, for a system using a reference counting memory \nmanagement, rotation can avoid most housekeeping associated with reference counting [Deutsch&#38;Bobrow]. \nAnother advantage is that the Rotate operation can be executed fast, For example, Rotate(x,y,z) can be \nrealized by a multiple assignment x ~ y, y~z, z~x. It will be a challenge to ~lnd other structuring \noperations and checkable properties so that we can write more reliable and efficient programs without \nusing expensive optimizers and verifiers. Acknowledgements I appreciate comments from Peter Deutsch, \nEd Fiala, Jim Horning, and Alan Perlis. Appendix: Closure of Rotations We will prove the theorem about \nclosure property introduced in section 5. qleorem (The same as the one in section 5) Suppose we have \noperated rotations on some data structures, and they are all safe rotations. Then, there is a sequence \nof rotations, such that the applications of them will restore the original data structures. We first \nneed a couple of lemmas. Lemma 1 Let el, ... , en be program expressions such that their values are Bl, \n... , Bn. If we apply a safe rotation which takes only the subset of el, .,. , en as its arguments, then \nwe can still reach Bl, ... . Bn from some program variables in el, ... , em -f Without loss of generality, \nwe assume that we apply Rotate(el, ... . ei) (i<n) and this is a safe rotation. Then, Bl, ... . Bi are \nreachable from some program variables in el, ,.. , ei from the definition of safety. We will consider \nhow Bj (i+ l~~n) is still reachable from some program variable. Before the rotation, Bj is pointed by \ntj, whose explicit form is X~.sl~.s2 ... Sk. Therefore, there are k+ 1 pointers x, xt.sl, X t.Slt.s2, \n. . . . xt.slt.sz C.) Sk. which form a chain leading from x to Bj. There are k+ 1 pairs of locations \nand values to represent these pointers: x: location Cl, value D1 X?.sl: location C2, value D2 X?. S1?.S2 \n... Sk: location Ck + 1, valLle Dk + 1 If none of these pointers change value, then Bj is still reachable \nfrom x. Suppose some of these pointers change values. Let Cl (l<l~k + 1) be the location, which has the \nlargest subscript among all locations whose contents changed. Since D1 is one of Bl, ... , Bi, we can \nassume without loss of generality, that D1 = Bm. Since the rotation is safe, tAere is an expression f \nsuch that f= Bm after the rotation. Since there is a path from D1 to Bj, ft.sl + l-? ... sk is pointing \nto Dk + 1 or Bj after the rotation. H Lemma 2 If Rotate(el, ... . ei) is a safe rotation, tk ere is another \nrotation P~otate(fl, .. , fi) such that the data structure after the applications of Rotate(el, ... . \nei); Rotate(fl, .. . fi) is the same as the data structure before the rotation. In other words, every \nsafe rotation has an inverse. -f Suppose ej (l<<i) is stored at location Aj and its value is Bj. After \nthe rotation the value contained at the location Aj is Bj + 1 (l~<i) and B1 is contained at the location \nAi. Because the rotation is safe, there are pointer expressions which denote pointers at the locations \nAl, ... , Ai. We name these pointers fi, fi.1, ... . fl. In other words fl is stored at Ai and its value \nis Bl, f2 is stored at Ail and its value is Bi, ,.. , and fi is stored at Al and its value is B2, Then \nRotate(fl, ,.. , fi) will certainly restore the values at locations Al, ... . Ai. Furthermore, this operation \nis safe since all the data structure is exactly the same as the original and all the records Bl, ... \n. B1 have to be reachable from some program variables. I Proof of the theorem Now, the proof of the theorem \nshould be easy. Suppose we have applied safe rotations. Let us name these rotations as rl, r2, ... . \nrm. From the lemmas 1, the data structure after these applications is still safe. Then apply the inverses \nof these rotations in the reverse order: -1 -1 namely, apply rm , . ,q . Then after each application, \nthe data structure is safe and inverse cancel with the original from lemma 2. Therefore, we obtain the \nexactly the same data structure at the end. I References [Deutsch] Private communication, 1978. [Deutsch \n&#38; Bobrow] Deutsch, L,P., and Bobrow, D. G,, An efficient, incremental, automatic g~bage collector. \nComm.ACM 19, 9(Sept, 1976), 522-526. [Flon] FIon, L., On the Design and Verification of Operating Systems \nPh.D. Th. Carnegie-Mellon U., May 1977. [Gries] Gries, D., The multiple assignment statement. IEEE Trans. \non Software Eng. SE-4, 2(March 1978), 89\u00ad 93. [Jefferson] Private communication, 1977, [Robson] Robson, \nJ.M., A bounded storage algorithm for copying cyclic structures. Comm.ACM 20, (1977), 431\u00ad 433. [Schorr&#38;Waite] \nSchorr, H., and Waite, W. M., An efficient machine-independent procedure for garbage collection in various \nlist structures. Comm.ACM 10, (1967), 501\u00ad506, [Suzuki&#38;Ishihata] Suzuki, N., and lshihata, K., Implementation \nof an array bound checker. Conf. Rec. of the Fourth ACM Symp. on Print. of Prog. Lang. (Jan. 1977), 132-143. \n \n\t\t\t", "proc_id": "567446", "abstract": "Pointer manipulation is one of the trickiest operations in programming and is a major source of programming errors. A great deal of research effort has been dedicated to making programs with pointers more reliable. In this paper we will present pointer operations which reduce conceptual difficulties when writing pointer programs, and increase reliability of programs. We will analyze theoretically as well as empirically why these operations are more convenient. Finally, we will define the safety of rotations, and show that it is decidable to check whether the rotation is safe and also show that it is a good measure of the correctness of programs. (That is, if the rotation is safe it is highly probable that the program is correct, and if it is unsafe it is highly probable that the program is incorrect.)Probably the most successful effort to eliminate difficulties associated with pointer manipulation is the invention of abstract data types and the use of implementation modules. Pointers are often used to implement complex data structures, which in turn represent abstract data types. We can textually localize relevant pointer manipulations using abstract data types. Thus, we can easily check correctness of pointer programs. This approach is successful when the structure of abstract data types is simple, or efficiency is not seriously required. However, programs like garbage collection, list marking and copying, and balanced tree manipulations have not been well specified by abstract types.The approach taken in this paper is complementary to abstract data types, and makes programs like list marking and copying more reliable and easy to write. The idea behind this approach is to introduce higher-level pointer manipulation primitives instead of pointer assignments. Since most pointer assignments do not appear isolated, we can group several assignments together and replace them by one of these new primitives. We also show some theoretical evidence why these operations are nicer.Two primitives are introduced in this paper. One is the n-way pointer rotation, which is defined as being equivalent to the following procedure:Rotate: <b>procedure</b>(<b>var</b> x<inf>1</inf>, x<inf>2</inf>, &#8230; , x<inf>n</inf>:T) = <b>begin var</b> w:T; w:=x<inf>1</inf>; x<inf>1</inf>:=x<inf>2</inf>; &#8230; ;x<inf>n</inf>:=w <b>end</b>where all the locations of arguments x<inf>1</inf>, x<inf>2</inf>, &#8230; , x<inf>n</inf> are distinct. The other operation is n-way pointer slide, which is as powerful as pointer assignment yet keeps the elegance of rotation.Section 2 of this paper reviews previous work related to this subject. We give definitions of pointer operations analyzed in this paper in section 3. Using these operations, Deutsch-Schorr-Waite algorithm is rewritten in section 4. In section 5 we analyze pointer rotations extensively and obtain several properties which are not attainable by ordinary pointer assignments. In section 6 we define the safety of pointer rotation when applied to linear list and trees. Then, we extend this definition to arbitrary pointer data structures and show a decision procedure to check safety. In section 7 we show two examples, list marking and list copying programs written using rotations and slides. We examine how we can directly code the algorithms using these operations and safety checking algorithms are useful.", "authors": [{"name": "Norihisa Suzuki", "author_profile_id": "81332530584", "affiliation": "Xerox Palo Alto Research Center, Palo Alto, CA", "person_id": "PP43124867", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567447", "year": "1980", "article_id": "567447", "conference": "POPL", "title": "Analysis of pointer rotation", "url": "http://dl.acm.org/citation.cfm?id=567447"}