{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 *car;s = el; car;<>+; cdr:s = <(22 . k>; cdr:<>+; * Cons:<e s> = <e el e2 \n... ek>; cons:<e <>> = <e>; null:s = ~akbe; null:<> = taut; atom:s = ~athe; atom:null:s = thue; eq:<atom:null:fj \nnull:s> = t,t :<null:s banana car:~> = i{ null:s -then banana clhe car:s = el. In the followlng a modern \nperspective for the constructor function is essential. The first two lines of Table 1 elucidate the difference \nbetween McCarthy s tradi\u00adtional conb [151 whose arguments are called-by-value and OUr !suspending!J Conb \n[5] whose arguments are called-by-need or called-by-delayed-value 119,181. The difference arises from \nthe independence the two axioms: Car:Cons:Cx y> = X; and cd.r:cons:<x y> = y. Contents Permutation Contents \nDetermined Determined Evaluated construction construction construction time time time construction construction \npr;bi;g time time construction probing probing frons [71 time time time Table 1: Record Constructors. \nUnder this semantics the expression which specifies any element or any suffix of a sequence is not evaluated \nuntil that part\u00adicular value is accessed or p~obed. That fs, the content of any newly constructed sequence \n(and thus any argument in an argument sequence) is called-by-delayed\u00advalue. Operational semantics necessary \nto fulfill this crfterfon is available [6, 103. This allows the conditional .i~ to be defined as an ordfnary \nfunction without worrying about troublesome evalua\u00ad tion of irrelevant arguments (like banana which is \nundefined above). Under this semantfcs cons:cx y>+ For any x an~ Y; Rather than use Ilambdaf? conventions \nto define other functions, we shall de?fne new functions from old ones using a pattern equivalent to \na prototype invoca\u00adtion: or:disjuncts = id null:disjuncts Zhen ~a.llbc t~be id car:disjuncts than kfiue \nt~b~ or:cdr:disjuncts. Thus , or:<atom:s null:s> = dal~c; Or:<atom:s null:s atom:null:s> = ~fiug,; but \nor:<atom:s car:<> null:<> >+ because evaluation of the second argument precludes evaluation of the third. \n2, Multisets The prev~ous function is reveallng, because the order of arguments need not matter for commutative \nfunct~ons with annihilators like ok, (True, false, and zero are ann.Lh.LLatoh&#38; for disjunction, conjunction, \nand integer product, respect\u00adively) . Let us concentrate upon the structure of the argument. A muJWLhct, \nlike a sequence, is composed of k > 0 elements but whose order is not spec~fied upon construction. Braces \nare used Lnstead of the angle b~ackets, m= {el e2 ... cl}. Like a sequence, a multiset evaluates to a \nlist of the evaluations of fts elements, but unless it Is probed those elements are never evaluated. \nIf it iS probed completely then its value manifesks itself as one of the permutations of the evaluations \nof its elements. Instances where one or more elements yield divergent evaluations (precluding a complete \nprobe) are of particular interest. We develop an operational semantics * e+ indicates that the evaluation \nof the for caa and cdn extended to multisets expression e does. not terminate which requires that the \nCUh of any multi\u00ad(diverges). If not e+ then e+ set be the convergent evaluation of one (Evaluation of \ne terminates or con\u00adof its elements (if such an element verges). exists) and that the cdt be the multiset \nwith that convergent element excluded. Such an interpretation will require that evaluations of elements \nwithin a multi\u00ad set proceed together. With this semantics the desired behavior results from the form \nor:{atom:s car:<> null:<>] = Otue with no change to the definition of oa; either sequential [16] or symmetric \ndisjunction L171 is obtained merely by changing the argument structure.* Just as semantics for sequences \nmay be obtained simply by defining the primitive COIL4, the semantics for multisets may be obtained by \ndefining semantics for the multiset constructor ~konh: Let m = {et e2 ,.. ek} then frons:<e m> = {e \nel e2 ... ek}; m= frons:<el f%ons:<e2 . . . f%ons:<ek {]>.,.>>; null:{} = -Owe; null:frons:<x y> = {a14e. \nThe properties of the new constructo~, ihovt~, are summarized in the last line of Table 1. As in our \nperspective on conh, contents are determined at construction time, but not evaluated until the struct\u00adure \nis probed. (F 2-ons:<x y>+ for all x,Y.) The sfgnf.ficant difference is that deter\u00admination of the permutation \nof a structure buflt using @on&#38; is postponed until it is probed, the permutation of a structure built \nwfth conb is precisely that of its construction. The existence of two const\u00adructors ~ai.ses questions \nof their intera\u00adction in heterogeneously built struct\u00adures. Such a structu~e, a generalization of both \na sequence and a multiset, is called a iehn [7], whose leaves! are associated with the constructor ikon&#38;, \njustifying its Latin name. In order to explain the definition of ikonh we shall refine it from conh ~~~dthree \ntePs) because, once constru\u00ad , a multiset manifests itself as a list . Indeterminacy is introduced through \nMcCarthy s ambiguity operator [151. Evaluation of amb:<x y> yields the value of x when y+, yields the \nvalue of y when x+, and either one of the two values when both x+ and y+. * An alternative for this particular \nexample is to adopt multiprocessing semantics for conditional expressions r<~ LVJ. Consider fronsl:<x \ny> = cons:<amb:<x car:y> amb:<y fronsl:cx cdr:y>> >. Each l.nstance of amb is evaluated once under the \ncall-by-delayed-value scheme which we have already associated with eonh. This results in a call-time-choice \n[111 (suitably postponed) which is unsatisfactory because the choices may be inconsistent with respect \nto one another; we would not want one amb to choose its second alternative while the other amb chose \nits first, lest (for example) never appear in the resulting list. This problem is eliminated if we have \nonly one instance of amb, making a single choice for eacp instance of ikonb. In order to make this step \nwe must define the bkhkct.iiy primitive: strictify:<a b>+ whenever a+; Strictify:<a b> = b whenever a+. \nIt is necessary that bkhictiiq be strict in both its parameters L181. Then frons2:<x y> = amb:< stri.ctify:<x \ncons:<x y>> strictify:ccar:y cons:ccar:y frons2:<x cdr :Y>> > >. This definition yields the desired consistency, \nbut it does not postpone evaluation of its arguments as did the preceding versfon; we do not want evaluation \nof x or y to proceed until later when the multiset is probed. The solution requires what appears to be \nan identity function to prevent evaluation of amb until the multiset is actually probed. Insulate:<z> \n= cons:ccar:z cdr:z>; frons:<x y> = insulate:<amb:< strictify:<x cons:<x y>> strictify:<car:y cons:<car:y \n~rons:<x cdr:y>> > >>. 3. Examples The preceding definition provides a data structure whose content is \nspecified when it is constructed but whose order depends on the convergence of computa\u00adtions which were \nonly specified then. Such computations might be of complexi\u00adties unknown to the programmer or they might \nbe simple computations dependent on external events whfch occur in an unforeseeable order. In the example \nbelow we are dealing with a multiset of 1/0 sequences. Each sequence is to be treated as a stream [2, \n141 which should be ignored until Its first element has converged. Every element of this multi\u00adset would \nconverge tr~vially, like any data structure under a delayed evaluation scheme, unless we preprocessedtt \nevery sequence using htkeamiiy. streamify:seq = k~ null:seq ihcn <> C.LA&#38; strfctffy:< car:seq cons:<car:seq \nstreamify: cdr:seq>> The appropriate qualifi.catfon of the content of multisets depends on the structure \nand convergence propert~es desired of its elements; but ft allows the selection of complex results based \non simple convergence. This then is the essential use of the bOLkCLL~y primftive, which violates call-by-need \nprotocol and req,ufres sequential evaluation of lts arguments. In order to demonstrate the facility of \nindeterminate programming with the new constructor ~konh, we present an indeter\u00adminate mehge operation \nin an applicative style. Since the indeterminism is Isolated Into the data structure, the program is \nrather simple. The problem is that of flattening a multiset M= {Sf S2 . . . Sk] of AZheamL~ged sequences \nsl into one sequence. In this example the argument is much like a matrix except that we allow for arbitrary \nbounds (i.e. the number of rows and the number of elements in each row may be unbounded), In which case \nthe first two alternatlvea of makga are meaningless. merge:M = id null:M Zhen M eLAC id null:car:M .tkW \nmerge:cdr:M e~bt? cons:<car:car:M merge:frons :<cdr car:M cdr M>> . lie inter~ret the four Dossibl( substttutlo~s \nof the two ~onstructors in mehge. If both were conh, then mekge would append [16] all the rows of M In \nthe order they are presented in M; if the first row of M is unbounded then that row is copied. When the \nconst\u00adructors are as in the definition of mekge, the effect 1S to interleave the various rows of M; so \nthe order of each one is presezved, but elements from other rows may be Interspersed In the Final result. \nIf both constructors were 6EonA, the effect would be to allow any rnfxture of all the elements of the \narray as an ordering In the result. In the unusual case that the first constructor were ~honb and the \nsecond were con4, a Sfmllar mfxture would result but elements in the result would-be restricted to rows \nonly up through the first unbounde~ one In M. If we had deftned &#38;kte&#38;mi6Y to take a port number \ni as streamlfy:<s i> = .L6 null:s Zhtn <> Qi!Ac strictffy:< car:s cons:<<car:s i> streamify:<cdr:s i>>> \n$ then the merge would produce a sequence of ordered pairs as the product of an fnterrupt handler. The \nfinal example is a particular kind of process scheduler, which takes as its two arguments a sequence \nof (unevaluated) expressions and an integer measuring time, and returns as its value a list of those \nexpressions (still not completely evaluated) which do not converge after that amount OF time. This problem \ncan be expanded to a more complete scheduler [81 which also returns a second result, the list of values \nwhich dfd converge within the slotted time. Two utflity functions are necessary. The ffrst takes the \noriginal sequence of expressions and scrambles it Into a multiset. scramblers = id null:s tlzen {1 el~e \nfrons:<car:s scramble:cdr:s> . A second function 5.s c~ock which is constant-valued. Its implementation, \nlike that of h.tJL.icZi6g, cannot be optimized lest It not behave as intended. Its purpose is to delay \nIts inevitable convergence by an amount of time ~opor\u00adtional to its integer argument. Like an interval \ntimer an argument twice as large will cause it to delay about twice as long. Upon convergence Its value \nis ALAF!M, a value assumed to be different from those of the scheduled expressions. clock:t = .L6 zero:t \n-then ALARM eLbe clock:predecessor:t . Then the solution to our scheduler problem may be defined as unfinished:cexps \ntime> = unalarmed: frons:<clock: time scramble:exps> where 4. Relation to Other Work unalarmed:s = ~d \neq:<car:s ALARM> then cdr:s ~~bk? unalarmed:cdr:s . There have been many other attempts to Introduce \nintermediate behavior in a controlled way into programming languages and models of computation. The amb \noperator [151 implements mindless in\u00addeterminate behavior; results are not necessarily reproducible. \nIts failing is that there is no way of knowing which argument was chosen and/or recovering the unchosen \none in order to resume its compu\u00adtation later. Others have developed variations on amh (e.g Ward [213 \ndeveloped a function a.i.thrzt which allowed for amb with a finite number of choices) and Hennessey and \nAshcroft [111 introduced call-time choice and run-time choice). Kosinski [131 introduced an atb.tfek \ninto the data flow approach [31 which produces a tagged merge of streams. The arbiter is behaviorally \nsimilar to the interrupt handler given earlier; but since it is postulated as a hardware primitive, it \nmay only have a finite number of input streams. Using the arbiter, Dennis [43 fabricates an airline reservation \nsystem. Waldinger and Levitt [20] have developed an unordered structure called a bag, but a bag contains \nonly convergent elements making it unsuitable for our purposes. We have encapsulated all indeterminism \nin data structures [91 where the pro\u00adgrammer may ignore it after he has speci\u00adfied his multiset. A significant \ncontri\u00adbution of the applicative style to this development is the experience with an applicative regimen \nwhich allows the 4ZMp&#38; introduction of indeterminate behavior as a trivial twist in progr\u00adamming \nstyle. A good programmer follows a few simple rules: don~t compute the same thing twice; never build \nthe same structure twice; etc. The use of the second rule is applied when a good programmer borrows a \nreference to a shared structure rather than copying it. The point here is that the mani\u00adpulation of data \nstructures has engendered precisely the same pro\u00adgramming practice which is required of properly controlled \nindeterminate behavtor in an applicative programming language, so that the marriage makes stylistic sense. \nREFERENCES 1. J. Backus. ated from Can the programming von Neumann be liber\u00adstyle? A functional style \nand its algebra of programs. Comm. ACM 21, 8 (August,. 1978), 613-641. 2. 3. 4. 5. 6. 7. 8. \n9. 10. 11. 12. 13.  W. H. Burge, Recukbkve phoghammLng Technique, Reading, Massachusetts, Addison-Wesley \n(1975). J. B. Dennis. First version of data\u00adflow language. In Phoghammkng Sympo6Zum, B. Robinet (cd.), \nBerlin, Springer (1974), ,362-376. J. B. Dennis. A language desLgn for structured concurrency. In ?hMigfl \nand Implemen,ttiion o{ PkogkammLng language~, J. H. Williams and D. A. Fisher (eds.), Berlin, Springer \n(1977), 231-212. D. P. Friedman and D. S. Wise. CONS should not evaluate Its arguments. In Automata, \nLanguageh and P?Log\u00adkamming, S. Michelson and R. Milner (eds.), Edinburgh, Edinburgh Unfverstty Press \n(1976), 257-284. D. P. Friedman and D. S. Wise. A note on conditional expressions. Comm. ACM 21, 11 (November, \n1978), 931-933. D. P. Friedman and D. S. Wise. Applicative multiprogramming. Technical Report No. 72, \nComputer Science Department, Indiana University (1979). D. P. Friedman and D. S. Wise. An approach to \nfair applicative multiprogramming. In ScmanXLcA 06 COI ICUhheRk computation, G. Kahn (cd.), Berlin, Springer \n(1979), 203-226. D. T. Good, R. M. Cohen, and J. Keeton-Williams . Principles of proving concurrent programs \nin Gypsy . Recokd LZh ACM Symp. on Principled o~ P&#38;ogAammLng Languagt4, (1979), 42-52. P. Henderson \nand J. H. Morris, Jr. A lazy evaluator. Re~&#38;d 3kd ACM Symp. on Ptinc.Lp&#38;4 0{ Phogtamtnifig LunguagaA \n(1976), 95-103. M. C. B. Hennessy and E. A. Ashcroft. Parameter-passing mechanisms and nondeterminism. \nPAOC. 9zh ACM Symp. on Theofiy O{ CompuZLtg (1977), 306-311. Keller, R. M. Denotational models for parallel \nprograms with in\u00addeterminant operators. In Fokmat Dehchip.tion 06 Pkoghamming ConcepZA, E. J. Neuhold \n(cd.). Amsterdam, North-Holland (1978), 337-366. P. R. Kosinski. A data flow language for operating \nsystems programming. P&#38;oc. A(!M STGPLAN-SIGOPS In.tek{ace MeeZLng, SIGPLAN Notices 8, 9 (September, \n1973), 89-94. 14. P. J. LandIn. A correspondence 18. J, Vuillemfn. Correct and optimal between ALGOL \n60 and Churchts implementation of recursion i! a lambda notation. Comm. ACM 8, 2 simple programming language. \n. (February, 1965), 89-I.01. Comp. Sys. Sci. 9, (June, 1974), 332-354. 15. J. McCarthy. A basis for a \nmathe\u00ad matical theory of computation. In 19. C. Wadsworth. Seman-tLcb and Computek ?fioghamm.ing and \nFoama.t pkagmaticb o~ Lambda-ca.hu-tu4, Sgb-temb, P. Braffort and D, Ph.D. dissertation, Oxford, (1971). \nHirschberg (eds,), Amsterdam, North-Holland (1963), 33-70. 20. R. J. Waldinger and K. N. Levitt. Reasontng \nabout programs. 16. J. McCarthy, P. W. Abrahams, D. J. Artificial Intelligence 5, 3 Edwards, Levin. T. \nLISP P. Hart, and M. 1.5 Ptoghammefi ~ E. (Fall, 1974), 235-316. kkWuU~, Cambridge, Massachusetts, 21. \nS. A. Ward. Functional Voma.inh o~ M.I.T. Press (1962). AppLicaX.tve Languageb, Ph.D. dissertation, M.I.T. \n(1974). 17. Z. Manna. MaZhcma&#38;icaL Theomg o~ Compu.tatLon, New York, McGraw-Hill (1974), Chapter \n5. \n\t\t\t", "proc_id": "567446", "abstract": "This paper proposes the encapsulization and control of contending parallel processes within data structures. The advantage of embedding the contention within data is that the contention, itself, thereby becomes an object which can be handled by the program at a level above the actions of the processes themselves. This means that an indeterminate behavior, never precisely specified by the programmer or by the input, may be shared in the same way that an argument to a function is shared by every use of the corresponding parameter, an ability which is of particular importance to applicative-style programming.", "authors": [{"name": "Daniel P. Friedman", "author_profile_id": "81100636522", "affiliation": "Indiana University, Bloomington, Indiana", "person_id": "PP39051860", "email_address": "", "orcid_id": ""}, {"name": "David S. Wise", "author_profile_id": "81100462823", "affiliation": "Indiana University, Bloomington, Indiana", "person_id": "PP39043901", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567470", "year": "1980", "article_id": "567470", "conference": "POPL", "title": "An indeterminate constructor for applicative programming", "url": "http://dl.acm.org/citation.cfm?id=567470"}