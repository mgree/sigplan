{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 of accumulated information is unbounded, and therefore the process of unwinding \nand emnotating a general scheme to form an equivalent free scheme may not terminate. Thus, the only solvable \ncases are fsmiliee of schemes which are restricted in a way guaranteeing that the amount of accumu\u00adlated \ninformation is bounded. Such boundedness can be obtained if we are allowed to discard already gathered \ninformation, being assured that the discarded information would never be celled for again. In this work, \nwe define and study a class of schemes, called synchronous schemes, which is a generalization of Ianov \nschemes as well as of progressive schemes ([P], [~P]). Synchronous schemes allow for many variables, \nbut require that the values of these variables during a Herbrand computation are kept synchronized, in \nthe sense that the differences between their heights are bounded. This enables us to discard information \nconcerning values of height lower than the current values, and. hence suggests that finite ann&#38;cation \nwill be applicable. Terminology and Definitions. The general class of schemes that we consi\u00ad der are \nrepresented by flowcharts with the following types of basic statements (boxes): Initialization: START \nQ (Y1). ..)Yn) +l).. .,Tn)l ... where each Ti is an expression containing only constant symbols Assignments: \nI~(Yl,...,yn) -(q;),..., Tn(wl Jd Jf Termination: where each Ti(;) is an expression that may contain \nconstant symbols as well as the variables i= (Y1). ..JYn) . These boxes are interconnected by edges which \nare labeled by conditions. A condition is a boolean combination of atomic formulas of the formP(~l(~),...,~j(~)) \n. For example, P(f(Y1,a),g(Y2)) A-q(g(Y1),f(b,y2)) is a condition. We impose a determinism stipulation: \nIf the edges leaving a given box are respectively labeled by the conditions C1, . . ..CP , then these \nconditions must be (a) Exclusive --i+ j implies ~(CiA Cj) , i.e., no two conditions can coexist. (b) \nExhaustive --C1VC2V . . . vCp= true, i.e., at least one condition must hold, (a) and (b) together imply \nthat exactly one exit condition must always hold.  On the following page is an example of a scheme (Scheme \nS1) in a conventional form and its representation (Scheme S2) in our transition graph style. A scheme \nis said to be simple (non-nested) if all its expressions T are of the form f(~, . ..)ur) and all its \ntests are literals of the form P(ul>. ..>ur) or -P(u~)... /ur) ) where each u.is a variable or am individual \n1 constant. By the results in [LPP] it is sufficient to consider the behavior of schemes under the class \nof all Herbrand interpretations. ~ the sequel we consider only Herbrand domains constructed from the \nindividual constants and function symbols of the given schemes. For a Herbrand term t , we define its \nheightj Itl , as themsximal nesting depth of the function symbols in t . Thus, for exarple, 1, Ial=O, \nlf(a)l= \\g(a,b)l= lh(a,g(a,b)) I = 2, etc. Consider a Herbrand computation of a scheme s. At any stage \ns = 0,1,... in the computa\u00adtion, each program variable yi holds some Herbrand value, which we denote \nby Yi(s) . Let hi(s) = Iyi(s)l be the height of this value. Define also M(s) = msx{hl(s), . . ..hn(s)] \n, i.e., * ,_ I Yp I_,/7( oT F P(Y1) F.. T T v Y f(Yp) + -< l(Y,)> \\ / -<q.(Y,) FLL o ) Y~ -dYl) T \nT &#38;HALT % -- A scheme in conventional 1 4? oHALT form. I?(Y1) ANq(y2) A-dY2) II HALT HALT d b \n--Transformation graph form of 2 1 the maximum of the heights of the variables A scheme is called synchronous \nif it is Yl). ..jyn at state s . Let A(s) denote the k-synchronous for some k > 0 . cumulative maximum \nof M(j) for j = 0,1,... A somewhat different approach is to define up to the current state s , i.e., \na scheme to be k-monotonic if after every A(s) =max{M(j) 10<j < s] . assigmnent step s assigning values \nto we have that J1A scheme is called k-synchronous for an Y. )...)Yj r integer k ~ O ~ if, in every Herbrand \ncomputa\u00ad (a) hjl(s+l), . ..)hj (S+1) ~ I(s)-k, tion, after each assignment step of the form r (Yjl> \n. . ..y. ~ ) +(~l,..., ~r) ~ going from state or r s to state s+l , the heights of the recently (b) M(s+l) \n~ k as above. assigned values satisfy either Here, A(s) is the cumulative maximum since . . ..hj (S+1) \n~ M(s)-k, the last reset. Thus, we relate the heights of (a) hjl(s+l)) . r recently computed values \nto the cumulative or maximum A(s) rather than to the 10CSJ. maximum (b) M(s+l) ~ k. M(s) , That is, either \nall the newly assigned values A scheme is called monotonic if it is have height not less than k below \nthe previous k-monotonic for some k~ O . maximum, or all variables are reset to heights These two concepts \nare closely related: not exceeding k . A step of the t~e (b) is Claim: A scheme is monotonic iff it \nis called a reset step. synchronous. Obviously if a scheme is k-monotonic it is also k-synchronous. This \nis a direct consequence of the fact that A(s) >M(s) since it is a cumulative maximum. On the other hand \nit can be shown that a k-synchronous scheme is always n. (k+l) -monotonic. Here n is the rm.mber of progrmn \nvariables and 1 is the maxirmn height of any of the expressions c appearing in the s theme. Consider \nthe implications of a monotonic computation. At any state of the computation some of the variables are \nactive in the sense that they hold values of heights k-close to the cumulative maximum. After a finite \namownt of computation, unless we enter into an endless loop, the maximum must rise and some of the variables \nrise with it. All active computations must occur within a distance k of the maximum. Some other variables \nmay drop behind and become dead , A dead variable may participate in an assigned expression provided \nthere is some live variable together with it in the sane expression. A dead variable may be revitalized \nby assinging to it a value of height k-close to the maximum. Alternately, in a reset, all variables are \nreinitialized to values of height < k . Main Results. The class of synchronous schemes contains, special \ncases: The class of Ianov schemes with resets. The more general class of one-variable schemes with resets. \nThe class of progressive schemes. These are the main classes for which equivalence is known to be decidable. \nwe derive the following results for synchronous schemes: 1. Every synchrewws scheme S C-be effectively \ntransformed into an equivalent scheme S which is simple, free and synchronous. This transformation is \ncarried out by am algorithm which will be discussed later. The elgoritbm checks that the scheme under \ntransfor\u00admation is actually k-synchronous smd reports . failure otherwise. Hence we have: 2. For a given \nk > 0 , it is decidable whether a scheme is k-synchronous. However: 3. It is undecidable (though partially \ndecida\u00adble due to (2)) whether a scheme is synchronous, that is, whether there exists a k > 0 such that \nthe scheme is k-synchronous. The following property enables us to formu\u00adlate &#38;Lgoritlmns concerning \nsynchronous schemes within the schemata framework without reduction to automata. 4. The class of synchronous \nschemes is closed under cross product , i.e., if and S2 1 are synchronous, so is SlXS2 , properly defined. \nAs a consequence of the transformation (1) we have: 5. Convergence and divergence problemq, both for \nsome interpretation emd for all inter\u00ad pretations, are decidable for synchronous schemes. 6. In comparing \ntwo synchronous schemes % and S2 , the inclusion problem S1~ S2 and the equivalence problem S1= S 2= \nboth decidable. Outline of the Algorithm. The main technique used in establishing these results is the \nalgorithm for transforming a synchronous scheme S into a simple, freej synchronous scheme S as described \nin (1) above. Roughly, this algorithm operates on an arbitrary scheme in the following way: (a) Consider \na synchronous scheme with no resets. We introduce first auxiliary variables and intermediate computations \nto make all terms simple. Next, we analyze the scheme by associating with each box in the scheme the \nfollowing lists of bounded size: (i) A list of the known truth values of To decide the equivalence of \nkwo synchronous tests. schemes, we first study the problem of inner (ii) Interrelations between variables. \nequality. Since the result of the preceding These will be equalities such as algorithm tags each box \nwith the interrelations Y~ = f(!4(Y2JY3)lYq) Note that we between the variables, we only have to inspect \nthe only have to retain such relations of tag on all exit statements and check whether it depth not exceeding \na bovnd dependent contains (or implies) the statement Z1 = Z2 . on k. Hence there are only finitely Now \nin order to test equivalence of 1 and S2 many such possible relations. we have only to consider the \ninner equality (iii) The difference in depth of each problem for S1XS2 , variable from the maximal depth. \nThese will be numbers not exceeding k . Acknowledgements. Obviously these lists can contain only a We \nare indebted to Richard Waldinger and bounded amount of information, md corres- Pierre Wolper for their \ndetailed reading of this pondingly only finitely many different paper. combinations of these lists exists. \nWe use these lists as tags to the nodes in the References. scheme. We may now unwind the original [c] \nChsndra, Applications A. K.~ of On the Program Properties Schemas, emd Ph.D. scheme, tagging each box \nwith the accumulated Thesis, stanford University, March 1973. information. A node in the original scheme \n[ CM] Chandra, A. K. and Z. Manna, Program may correspond to several nodes in the new Schemas Fourth \nwith ACM Eqmlity, Symposium on Proceedings the Theory of of the scheme, each tagged with its own annotation, \nComputing, Denver, Colorado, May 1972. providing full information about the inter\u00ad [G] Greibach, S, A.J \n Theory of Program relations between the variables. The Structures: tion, Springer Schemes, Verlag, Semantics, \nlecture Verifica\u00adnotes in resulting scheme will be simple, free, and Computer Science, 1975. synchronous. \n[1] Iemov, Y.I., The Logical Schemes of Algorithms, u problems of cybernetics> (b) Next we consider \na synchronous scheme with Vol. 1, Pergemon Press, New York (English resets. Our task here is to eliminate \nthe treas~ation), 1960. resets. Let us partition the scheme S into [LPP] D. C. Luckham, M. S. Paterson, \nD. r!on M. R. Park Fo@ized and Cmpwter subschemes, S1,..., Sn , each of which con- Programs, Jcss h, \n3 (June 1970), 220-249. tains a reset instruction as its first [M] Manna, Z., Mathematical Theory of \nComputa\u00ad instruction, but no other instances of resets. tion m. (Chapter h) , McGraw-Hill, New York, \nTheTe mey be exits frcrn any Si to any Sj ~ [P] Paterson, M. S., Equivalence Problems in a which must \ngo We apply through the main entry of (a) above to each of the S. . J Si s. Model of Cambridge, Computation, \nEngland, Ph.D. 1967. Thesis, Then we form the cross product scheme [RI Rutledge, Schemata, J. D., JACM \n On IMOV S 11, 1 (January Progrw 1964), 1-9. s = s1xs2x. ..xsn which jointl-y simulates Sl, . . ..sn \n. s allocates disjoint sets of variables.to each component Si and Perfomns in parallel the operations \nrequired by each of the components. A special tracing mechanism is provided for representing the situation \nthat Si exits to Sj . 0 \n\t\t\t", "proc_id": "567446", "abstract": "A class of schemes called synchronous schemes is defined. A synchronous scheme can have several variables, but all the active ones are required to keep a synchronized rate of computation as measured by the height of their respective Herbrand values. A \"reset\" statement, which causes all the variables to restart a new computation, is admitted. It is shown that equivalence, convergence, and other properties are decidable for schemes in this class. The class of synchronous schemes contains, as special cases, the known decidable classes of Ianov schemes, one-variable schemes with resets, and progressive schemes.", "authors": [{"name": "Zohar Manna", "author_profile_id": "81100089034", "affiliation": "Stanford University and Weizmann Institute of Science", "person_id": "PP15021756", "email_address": "", "orcid_id": ""}, {"name": "Amir Pnueli", "author_profile_id": "81100648459", "affiliation": "Tel Aviv University", "person_id": "PP15038449", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567453", "year": "1980", "article_id": "567453", "conference": "POPL", "title": "Synchronous schemes and their decision problems", "url": "http://dl.acm.org/citation.cfm?id=567453"}