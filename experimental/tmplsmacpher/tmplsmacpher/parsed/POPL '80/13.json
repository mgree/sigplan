{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 inconvenient and unnatural that the design is uninteresting from a practical \npoint of view. How can one characterize this notion of expressiveness of the operation set of a data \nabstraction? How does one determine if the operations of a data abstraction form a fully expressive set \nor not ? Can one distinguish between the expressiveness of the operation sets of different designs of \nthe same data abstraction, such as designs (1) and (3) ? Morris [13] is the first one to have posed some \nof these questions. He proposed that a new data type should be tmrs~eruble in the sense that the primitives \n(i.e., the operations) are adequate to translate between the new type and any other existing type, such \nas integers. He introduced wrire and read transfer functions from the new type to integers. The difficulty \nof implementing the primitive operations of the new type in terms of the existing type using the transfer \nfunctions gives an indication of how expressive the operations of the new type are, His characterization \nis very informal, and it does not distinguish between situations such as design (1) and design (3) in \nthe above example, In this paper, we formally characterize what it means to say the operation set of \na data abstraction is fully expressive. We define two properties of a data abstraction related to the \nexpressiveness of its operation set -expressive completeness and expressive richness. The second property \nis stronger than the first, We will be able to distinguish among the three designs of set [N] mentioned \nearlier using the above two properties. We will see that the second design is not even expressively complete, \nwhile designs (1) and (3) are. However, design (1) is expressively rich, but design (3) is not. The purpose \nof introducing the notion of a design is to compare the expressiveness of. subsets of the operation set \nof a data abstraction. A design of a data abstraction is defined so that it has the same behavior of \nthe data abstraction, while its operation set is a subset of that of the data abstraction. The properties \nof expressiveness discussed in the paper are, strictly speaking, the properties of a particular design \nof a data abstraction. However, at several places in the paper, the reader may find the properties being \nassociated with a data abstraction. When we do this, we actually mean the expressiveness of the design \nwhose operation set is identical with that of the data abstraction, 1. This notion of completeness should \nnot be confused with the completeness property of a specification of a data abstraction. The properties \ndiscussed in the paper are properties of data abstractions, and are independent of the specification \ntechnique used to specify data abstractions. 1.1 An Extended Overview In the next chapter, we discuss \na few preliminary concepts and state the assumptions made in the paper about the behavior of a data abstraction. \nWe precisely define the value set of a data abstraction, and describe what we mean by different designs \nof a data abstraction. In the third chapter, we formalize the notion of expressive completeness. We wish \nthat the operation set of an expressively complete data abstraction allow us to discover all interesting \nproperties of the values. Since programmers are going to be interested only in computable properties, \nwe require that the operation set of an expressively complete abstraction be expressive enough to implement \nall computable functions over the value set of the data abstraction. We specify what it means for a function \nto be implementable by stipulating the mechanisms from which the function ought to be built. The remaining \nstep in the process of formalization, therefore, is to define computability and computable functions \nover the value set of a data abstraction. We do this by reducing the computability over an abstract domain \nto computability over the set of natural numbers. For this we use a scheme to encode the values of the \ndata abstraction as natural numbers. Every function on the abstract value set can then be mapped to a \ncorresponding function on natural numbers. A function over the abstract value set is considered to be \ncomputable if its image function is computable over the set of natural numbers. The main result of this \nchapter is Theorem 2, which states that if the operation set of a data abstraction D consists of computable \noperations only, and the equal predicate on D, which computes the identity relation on the value set \nof D, can be implemented in terms of the operation set, then D is expressively complete. The theorem \nenables us to define a minimal set of operations that makes an abstraction expressively complete. In \nthe fourth chapter we introduce the notion of expressive richness of the operation set of a data abstraction. \nThe motivation for this arises because of the existence of several expressively complete data abstractions \nwhose operation sets are not versatile enough to be of any practical use. We wish that an expressively \nrich data abstraction be expressively complete with an operation set that is rich enough to extract all \nrelevant information from a value conveniently. To formalize this notion of richness, we identify a set \nof functions, called distinguished functions, associated with every abstraction. The distinguished functions \npermit one to extract from any given value, all information required to reconstruct it. There are two \nkinds of information that one needs to know how to construct a value. Firstly, we need to have a set \nof values of other types which is used in the construction of the value. Secondly, we need to know 140 \nthe constructors and the order in which they should be used in creating the value,, We define two kinds \nof distinguished functions -the d-functions and the p-functions -to extract the above two pieces of information, \nrespectively. An expressively rich data abstraction is defined as one in which every distinguished function \ncan be implemented in terms of the operation set using only composition and conditional expressions. \nWe believe that if the distinguished functions can be conveniently implemented in terms of the operation \nset, then so can most of the other useful functions on the data abstraction, We show that a data abstraction \nthat is expressive~y rich has the desired logical power by proving that it is also expressively complete. \nThe final chapter discusses a few practical applications of data abstractions that are expressively rich \naccording to our characterization. 2. Assumptions and Preliminary Concepts 2.1 Assumptions Informally \nspeaking, we view a data abstraction (abstract data type, data type, type) D as consisting of a set of \nvalues, and a finite set of operations to create and manipulate those vahres. In this paper, we consider \nonly immutable [10] data types, We denote the operation set of D by 0. Normally, the definition of D \ninvolves other data types; these data types appear as the domains and/or range of the operations of D, \nWe call these types the defining /ypes of D, and denote their collection by A. We refer to D itself as \nthe defined rype. We assume that every operation in Q yields exactly one value. The operations that yield \nvalues of type D are called comkuc(ors ; the remaining operations are called observers. Constructors \nwhich do not take any arguments of the defined type are called basic cons(ruc(ors ; the remaining constructors \nare called non-basic cons(rucfors. We assume that every operation of D is total and does not signal any \nexception [11]. This assumption is made only for convenience, since the properties proposed in the paper \ncan be extended to handle exceptions once a suitable model for characterizing the exceptional behavior \nof a data type is adopted In the examples discussed in the paper, we have arbitrarily decided on some \nnormal behavior for an operation on certain inputs on which the operation would otherwise have signalled \nan exception. 2.2 Definition ofa Data Abstraction Heterogeneous algebras are a natural way to model \nthe behavior of a data type [l!3,2, 3]. A heterogeneous algebra fora data type D consists of (i) adomain \ncorresponding to D and a domain corresponding to every defining type in &#38; and (ii) a function corresponding \nto every operation in il. We take a behavioral view for defining the semantics of a data type, first \nadvocated by Guttag [3], and later developed by Kapur [8]. According to this view, every value of D is \ncreated by finitely many applications of the constructors of D, arid the values are distinguishable only \nbymeans of theoperationsof D. Adatatype is defined as a set of behavioral/y equivalent heterogeneous \nalgebras.z Every algebra in the set is called a nrodelof the data type. Two algebras are, informally \nspeaking, behaviorally equivalent if they have the same observable behavior as expressed by their observers, \nThedomain corresponding to D in a model defines a vahre set of D. In the context of a model, by a value \nof D we mean an element of the value set. The observable behavior of a model is characterized in terms \nof the disfirrguishabili(y relation on values. The distinguishability relation is defined inductively \nin terms of the distinguishability of the values of the defining types. (The basis of this induction \nis the data type bool that does not have any defining types; the only two values, true and false, of \nbool are assumed to be distinguishable.) Two values of a model are distinguishable if and only if there \nis a sequence of operations of D with an observer as the outermost operation, that produces distinguishable \nresults when applie,d separately on the values, If two values are not distinguishable, they are observably \nequivalent. Observable equivalence isanequivalence relation, and hence can be used to define a quotient \nset (a set of equivalence classes) on every domain of a model; furthermore, the observable equivalence \nrelations are preserved by the functions in the mc~del. Two models are behaviorally equivalent if the \nquotient models induced by the observable equivalence relations are isomorphic to each other. Wecan specify \nthe behavior of a data type by presenting a model for it, Data types used as examples in the paper are \nall defined in Appendix I in this fashion. 2.3 AStandard Wdue Set In this paper, when we discuss an \narbitrary data type D, we use a standard model for it whose value set is constructed in terms of sequences \nof constructors of D. The advantage in using this value set is that its method of construction is generally \napplicable amd better suited to the formalization of computability on data types. The construction of \nthis value set is explained below. Every sequence (composition) of constructors of D creates a value \nof D, and hence can be used to denote that value, Wecalla sequence of constructorsa word; several different \n2. This view isafurther abstraction ontheview of ADJ[2]and Ziiles [ 18] which merely abstracts from the \nrepresentations of the values in an algebra a data type in their view is defined as a set of k.omorphtc \nheterogeneous algebras. The behavioral view is closer to the view taken in programming languages supporting \ndata types. words may create observably equivalent values. Let WD denote the set of all finite words \nof D (we drop the index whenever it is evident from the context). W is constructed inductively by assuming \nthat the word set is given for each of the defining types; a data type with no defining types serves \nas the basis. Let E stand for the observable equivalence relation on W, We use the quotient set W/E as \nthe standard value set3 (also denoted as V), Except in case of the models given in Appendix I, whenever \nwe refer to the value set of D, we mean its standard value set. By a function of D, we mean a function \non the word set W that preserves the equivalence relation E. So a function f cm W that preserves E can \nbe viewed as a function f on V (= W/E) such that f ([w])= [f(w)], where [w] is the equivalence class \ncontaining w. ([w] is a value of D.) The same view can be extended to functions with several arguments, \nFor example, the equivalence relation E : W X W -> bool can be viewed as the equality predicate on V \nthat tests whether two values are identical. Henceforth, we denote the equality predicate on D by equal, \nor =. 2.4 Different Designs of a Data Type Given a definition of D, a design of D is a variant of D \nwhose operation set Q is a subset of Q; the operations in 0 should be such that they can create and distinguish \nall the values in W/E. We will present a design by giving its operation set. For example, for set[N] \nwith Q = {null, insert, remove, has, empty, max, equal), the following are some of the possible designs. \nQ is itself a design O, = {null, insert, has] 02 = {null, insert, equal] However, !23 = {null, insert, \nremove, max} is not a design because it cannot distinguish all the values of W/E. For instance, two different \nsets with identical maximal elements are not distinguishable by $13. The idea behind the definition of \nthe design of a data type is to capture the evolutionary nature of the designing process of the data \ntype. When a designer designs a data type, he normally starts out by visualizing a value set for it and \na set of constructors to generate the values; then he starts designing other operations, Since operations \nare the only means of creating and observing the values, the 3. In ADJ and Zilles s view, the distinguishability \nof values is not defined in terms of the behavior of the operations, instead an equivalence relation \non words is independently defined if two words are not related, they are distinguishable irrespective \nof whether they can be distinguished by the operations in the behavioral sense. The discussion and the \nresults of the paper can be applied to this view es well by usingthegivenequivalencerelationinplaceoftheobservable \nequivalence relation E. 142 designer at the least needs to provide enough operations to distinguish \namong the values. Later, with increasing experience, the designer enriches the operation set by adding \nmore operations. All along his initial conception of the value set remains unchanged. We study the expressiveness \nof various operation sets by comparing the expressiveness property of different designs of a data type. \nAs pointed out earlier, the properties of expressiveness are properties of a particular design of a data \ntype, At several places in the paper, when we are not comparing the expressiveness of subsets of. the \noperation set of a data type, we simply associate the property with the data type and make references, \nsuch as an expressively complete data type , etc. When we do this we actually mean the expressiveness \nof the design whose operation set includes all the operations of the data type. 3. Expressive Completeness \nIn this chapter, we discuss the expressive completeness of the operation set of a data type. In the first \nsection, we formally define expressive completeness in terms of computability over the value set of a \ndata type. In the second section, we characterize computability over an abstract domain by reducing it \nto computability over the set of natural numbers. The third section proves a useful result about expressive \ncompleteness. The last section illustrates the definitions and results by discussing several examples. \n3.1 Definition of Expressive completeness We wish an expressively complete data type D to permit all \ncomputable functions of D to be implementable in terms of its operations. Following McCarthy [12], we \nonly use the simple mechanisms of functional composition, conditional expression, and recursion to implement \na function on D in terms of a given set of functions. Auxiliary functions are also allowed as helping \nfunctions. Let U(F) denote the collection of functions implementable in terms of a set F of functions \non a data type. It is important to notice a subtle difference in the method of definition for functions \nused by us and the one widely used in the literature on computability. In the latter, functions are defined \nusing a scheme that assumes a pattern matching mechanism to reveal the top level structure of the argument \nvalue. For example, the addition function, denoted by +, on N is defined as : (R) X+o &#38;x x +s(y) \ns S(x +y) We instead take an abstract view, which indeed is the view taken by a programming system supporting \ndata types, The internal structure of a value is not explicit; any information about a value must be \nobtained through its operations. Every operation we use has to be either an explicit part of the operation \nset of D, or be implementable in terms of the operation set. In our approach, for example, + would be \nimplemented in a programming-language-like manner as : +(x, y) e if y = O then x wise S(+(x, P(Y))), \nwhere p(x) = if x = Othen Oelse P (x, O) p (x, z) ~ if x = S(z) then z else P (x, S(z)) Notice that \nthe above implementation of + is given in terms of O, S, =, and p; p is defined as an auxiliary function \nin terms of O, S, and =. However, it seems that the definition (*) of + above did not need = and p. These \nfunctions are implicit in the pattern matching mechanism used by the definition (*). Let Comp(D) denote \nthe class of all computable functions on the value set of D, (Computability on D is defined in the next \nsection.) Then we have Definition 1 A data type D is expressively complete if Comp(D) = C(Q) For example, \nit is known that Comp(N) = C({O, S, =}) [9,12]. Thus Corollary 1 The data type N whose operation set \nil = { O, S, = } is expressively complete. Using the definition of computability over s_expression (of \nnils) [12], we also get the following : Corollary 2 Thedata type s.-expression whose operation set il \n= { nil, car, cdr, cons, null?] is expressively complete. We were able to obtain the resuits in the corollaries \nreadily because computability over N and s_expression has been formally characterized in the literature. \nHowever, the notion of computability has not been formally characterized for an arbitrary datatype D. \nThe next section addresses this issue. 3.2 Computability over Abstract Domains If the value set V is \nfinite, the notion of computability is trivial since every function on.Dcan be specified asa finite table, \nand is thus computable. Below, we shall concentrate on a D whose V is infinite. Our strategy is to reduce \ncomputability on D to computability over natural numbers [14]. We define computability on W; a computable \nfunction on W that preserves E is a computable function on D. We define computability on W by means of \nan effective bijective function q : W -> N that encodes every word into a natural number. We call q an \nencoding function for D; and q-l a decoding function for D. Every function on W can be viewed via n as \na function on N. An q for D is constructed inductively using an n for each of its defining types. The \nbasis of this induction is a data type having no defining types for which an v can be constructed in \na straight forward manner. Definition 2 Given a func~ion f : W -> W, its image ~ : N -> N via q is defined \nas f(n) = q(f(?-l(n))). The concept of an image of a function on D can be extended to functions defined \nover several domains by similariy making use of an encoding-decoding scheme for each of the domains involved \nin the definition. Using Church s thesis, we have Definition 3 A function f : W -> W is computable if \nthere exists an encoding v such that the image ~ of f via o is computable over N. The above definition \nof computability on W has the following desirable property. Theorem 1 The set ctf all computable functions \non W is invariant with respect to the encoding function chosen. Proof We show that any two different \nencoding functions define the same set of computable functions on W. We show that for every pair of encodings \no, and qz there exist computable functions T, ~ and T21 on N which behave as follows: T, ~ maps the code \nof a word associated by ~1 to that associated by ?2; Tzl does the mapping in the opposite direction, \nIt can be shown that the image of a function f via q, can be constructed from the image of f via ?2 and \nvice versa using T, z and T21. Definition 4 A function f of D is computable if f on W is computable and \nf preserves the equivalence relation E. Weihrauch [16] defines computability on V directly; his abstract \ncompu&#38;dbility thesis can be shown to be equivalent to our definition of computability. We believe \nour approach is simpler and more natural. Henceforth, we concern ourselves only with data types having \ncomputable operations, as the ones with noncomputable operations are of no practical interest. Furthermore, \nif a data type has noncomputable operations, it cannot be expressively complete, Since the word set of \na data type is always recursive, having all the operations computable makes the value set recursively \nenumerable.4 3.3 A Useful Result Here, we prove a useful result about the expressive completeness of \nthe operation set of a subclass of data types for which equai is decidable, 4. A set S is recursiveif \nits characteristic function, which checks whether ass arbkrary element is in S or not, is total computable. \nS i$ recursively enumerable (r.e.) if it is the range of a total computable function. In other words, \nan r.e. set S can be generated by a total computable function. 143 Theorem 2 Assuming that (i) for D \nand for each of its defining types the equal predicate is decidable, and (ii) every defining type of \nD is expressively complete, D is expressively complete if the equal predicate on D is implementable in \nterms of its operation set fl. The proof of the above theorem follows immediately from the following \nTheorem, which states that if equal is an operation of D, then D is expressively complete. This is so \nbecause if equal 6 6($2), then (f(ft) = &#38;(fl u { equal ]) = Comp(D). Theorem 3 Assuming that (i) \nfor each of the defining types of D the equal predicate is decidable, and (ii) every defining type of \nD is expressively complete, D is expressively complete if the operation set of D includes the equal predicate \non D. Proof See Appendix II. Theorem 3 can be used to show the following : Corollary 3 A minimal set \nof operations that makes a data type D expressively complete is O = flc u { equal }, where flc is a minimal \nset of constructors sufficient to generate the value set of D. 3.4 Examples In the following examples \nwe investigate the expressive completeness of different designs of stack [N] and set [N] data types. \n(See Appendix-I for definitions of these data types.) The operation set of each of them includes only \ncomputable operations. This can be inferred by intuition, as well as shown formally using the method \ndiscussed above. In each of the following cases, we just need to see if it is possible to implement the \nequal predicate for the type or not, The following designs are expressively complete. (1) stack [N] is \nnull, push, POP, top, empty equal(vl, VZ) = if empty(vl ) then empty(v2) else if empty(v2) then false \n else (top(vl) = top(v2) &#38; equal(pop(vl), p0p(V2)D  (2) set [N] is null, insert, remove, has, empty \nequal(vl, v2) = check-in-order(vl, v2, O) check-in-order(vl, v2, i) =  if empty(vl ) then empty(v2) \nelse if empty(v2) then false else if (has(vl, i) = has(v2, i)) then check_in_order( remove(vl, i), remove(v2, \ni), i+l) else false The following designs are not expressively complete because equal is not implementable \nin terms of their operations, In both the following cases it is possible to apply the above algorithm \nto find an answer when the two sets are unequal; however, when the sets are equal, the algorithm does \nnot terminate because of the absence of the operation empty in the first case, and the absence of the \noperation remove in the second case. (3) set [N] is null, insert, remove, has (4) set [N] is nuli, insert, \nhas, empty  4. Expressive Richness In this chapter we introduce the notion of expressive richness. The \nmotivation for this stems from the existence of several expressively complete data types whose operation \nsets are not rich enough to be of any practical use. For such types, implementation of even simple and \nuseful functions that are not provided as operations of the types can turn out to be extremely tedious \nand unnatural. For instance, consider the following design of set [N]. set [N] is null, insert, remove, \nhas, empty This design has been widely used in the literature. It is an expressively complete design, \nas was shown in section 3.4 above, since the equal predicate is implementable in terms of the operations. \nNote that the implementation of equal required enumeration of N upto the minimum of the maximal elements \nof the two sets. The following is an implementation of the function size that computes the size of a \nset, This implementation also needs an enumeration of N. The auxiliary function count in the implementation \ndoes this job; every time it finds a number that belongs to the set it removes the number from the set, \nand increments the count (accumulated in the variable cnt) by 1. size(v) ~ count(v, O, O) count(v, i, \ncnt) s if empty(v) then cnt eise if has(v, i) then count(remove(v,i), i+l,cnt+l) else count(v, i+l, cnt) \n The enumeration in the above example would be more complicated if the elements of the set were of an \narbitrary type that does not have a natural ordering defined on it. In that case we would need to encode \nthe values of the element type to perform the enumeration. The enumeration was necessary in the above \nimplementation because the data type set [N] does not provide any operation to pick an element of a set \nconveniently. In general, this problem arises when the operation set is not rich enough to extract all \nrelevant information from a value conveniently. We would like an expressively rich data type to avoid \nthe need for such enumeration while extracting all relevant information from a value, To characterize \nthis aspect of richness of the operation set, we first introduce the concept of distinguished functions. \nWe later formulate a definition for 1.44 expressive richness in terms of them. 4.1 Distinguished Functions \nThe distinguished function,$ for every data type D are defined corresponding to a minimal subset flc \nof constructors of D that can generate the whole value set of D. A family of distinguished functions \ndefines a set of manipulations sufficient to extract all relevant information from a given value, necessary \nto reconstruct the value back from scratch. In general, there can be more than one minimal subset of \nconstructors, i.e., flc, for D. So D can have more than one family of distinguished functions, with every \nfamily being associated with a particular $lC. Furthermore, D can have more than one family of distinguished \nfunctions corresponding to the same Oc. We will illustrate this point by means of an example later. There \nare two kinds of information that one needs to know to construct a value, Firstly, we need to have a \nset of values of the defining types which is used in the construction of the value. Secondly, we need \nto know the constructors, and the order in which they should be used in creating. the value. Basedou \nwhich of the above two kinds of information they extract, the distinguished functions are classified \ninto two kinds -the d-func(ions and the p-functions. 4.1.1 Thed-functions The d-functions permit us to \nextract from an arbitrary value of D, a set of values of the defining types necessary to reconstruct \nthe value using the constructors in llc. The d-functions are such that every such value of the defining \ntype can be extracted by means of a finite composition of the d-functions, 4.1.1.1 Definition Letui bean \nnary (n> O) Operationof D inftc such that ui:DIX. . . XDn->D~. Dl, . . .. Dnareeither D or the defining \ntypes of D. Associated with ai there are n d-functions, d!, , . . . ,d~ , such that for every I s k < \nn, d! : D -> D~ and df satisfies the following property: (Pi) For every value of D, there exists a family \nof finite compositions of d~ s, denoted by G = {S,, . . . , S@, where every Sj is of the form Si = d$; \n. ... . d$j , such that (i) S,(v) = aj is a value of one of the defining types of D, and (ii) it is \npossible to construct v from {al,..., a~] using the constructors of 0 ~.  If Ui is O-ary, then it dc~es \nnot have any associated d-functions. 4.1.1.2 Explanation To keep the exposition simple, we first explain \nthe definition of d-functions for the simple case of a data type where every constructor in its flc takes \nat most one argument of a definecl type. (We discuss the general case in a subsequent section.) In the \nsimple case, every value of the defined type can be constructed using a sequence of constructors from \nOc; we call such a sequence a constructing sequencefor the value. The first constructor in every constructing \nsequence is a basic constructor, and the rest of them are all non-basic constructors. Every constructor \nin the sequence uses a set of values of the defining types as arguments to it. For instance, con sider \nthe following design of stack [N]. stack [t#l is null, push, pop, top, empty For stack [N], 0= = @rlI, \npush}. A stack value with n elements has the (unique) constructing sequence that has the form (push)n \n. null. ((push) denotes a srquence of n push operations.) The d-functions associated with a constructor \nCi can be viewed as functions acting as inverses for Ui; they can be considered as functions that undo \nthe effects of a particular instance of the constructor ai in a constructing sequence for the given value. \nThe d-functions for every constructor are designed by fixing the instance of the constructor (in the \nconstructing sequence) one wishes to undo by a single application of the d-functions. The design should \nbe such that all instances of the constructor are undone after a finitely many applications of the d-functions \non the value. For siack [N], there are no d-functions associated with null, since null is a zero-ary \nconstructor. The operation push has two associated d-functions -d~u$~and d~U$~. By selecting the d-functions \nto undo the effects of the latest instance of push in the constructing sequence, we require the two d-functions \nto satisfy the following properties. dju,~(push(v, e)) = v d$u,~(push(v, e)) = e Note that pop and top \nsatisfy these properties, and hence can be used as the d-functions. To see how the d-functions can be \nused to extract all the values of the defining types, we classify the d-functions into decomposes and \nextractor a decompose yields a value of the defined type, and an extractor yields a value of a defining \ntype. In the case of stack [N], djU,~ is the decompose and d$u,, is the extractor for push. To extract \nthe values of the defining types we go through a reverse process using the decomposes and extractors \ninstead of the constructors. We first find a sequence of decomposes to decompose the given value to a \nbasic value (i.e., a value constructed by a basic constructor in fIc); we call such a sequence a decomposing \nsequencefor the value. A decomposing sequence can be easily derived from a constructing sequence for \nthe value: it is the reverse of the sequence of decomposes that is obtained by substituting every constructor \nin the constructing sequence by its corresponding decompose. Every initial subsegment of the decomposing \nsequence (when applied on the value under question) yields a value of the defined type that was generated \nat some point during the construction of the value under question. The values of the defining types are \nobtained by applying appropriate extractors to each of these values. For instance, for stack [N], there \nis only one way of decomposing a stack value using pop; the decomposing sequence for a stack of depth \nn is POP . The following set of sequences of d-functions extracts all the numbers used in the construction \nof the stack : { top , top pop, . . . . top (pop) - }. The set of d-functions associated with a particular \n0= need not be unique. For instance, for stack [N], a function remove_Iast that removes the last element \nof a stack, and a function get_last that fetches the deepest element of a stack could just as well have \nacted as d-functions for push. Notice that these d-functions undo the effect of the earliest instance \nof push in the constructing sequence. 4.1.1.3 The File Example We further elucidate the definition of \nd-functions by designing a set of d-functions for a reasonably sophisticated file [t] example, The definition \nof file [t] appears in Appendix I; the following is an informal description of it. file [t] is null, \ninsert, rewind, skip, delete, read, POS, emp~y, eof, length A file value can be considered to be a sequence \nof records with an imaginary pointer, where every record is of type t. The pointer could be pointing \nto one of the records in the fiie, or to an imaginary position, called efl~-o~fi~e~ beyond the last record \nin the file; the pointer in an empty fiie is always at the end_ofJle. skip moves the pointer forward \nby a specified number of records. rewind resets the pointer to the first record. insert inserts a record \ninto the file immediately before the record to which the pointer is pointing (it leaves the pointer pointing \nto the same record.); if the pointer is at the end_of_file, the record is inserted at the end. delete \ndeletes the record (if any) pointed to by the pointer. read fetches the record pointed to by the pointer. \npos returns the current position of the imaginary pointer. empty and eof are predicates which have the \nbehavior naturally implied by their name. length returns the number of records in the file. For file \n[t], $lC = { null, insert, rewind, skip }. In this case, it is not very obvious what the d-functions \ncan be. The difficulty arises because the constructors in tlc can, in general, be used in several different \nways to create a file value. (In contrast, for stack [N], there is exactly one constructing sequence \nfor every value.) In such cases it is useful to select a canonical constructing sequence for the values, \nand then design d-functions to undo the effects of specific instances of the constructors inside the \ncanonical sequence. Every non-empty file value with n records can always be constructed by a constructing \nsequence of the form skip . rewind (insert) null. The integer argument to skip is the position of the \npointer in the file. Based on this canonical sequence, we propose the following design for the d-functions. \n(i) The d-functions corresponding to skip are chosen to undo the effects of the single instance of skip \nin the canonical sequence. So the d-functions have to satisfy the following properties. d~~iP(skip(rewind( \nv), n)) = rewind(v) d~~ip(skip(rewind(v), n)) = n It is easy to see that the operations rewind andpos \nsatisfy the above properties; hence they can serve as the d-functions. (ii) Assuming that the effects \nof skip are already undone, the d-function of rewind can expect to receive only values that have a constructing \nsequence of the form rewind o insert , i.e., the file is rewound. The operation rewind is many-to-onq \nit resets the pointer no matter where the pointer was (even if the file is already reset) prior to its \napplication. d!,Wim~should redesigned such that it acts as an inverse of rewind. We choose to design \nit as an identity function since that leads to a more natural set of distinguished functions. So we have \nthe following trivial definition for d~,Win~. dj~Wind(rewind(v)) = rewind(v) (iii) Assuming that the \neffects of skip and rewind are already undone as explained above, the d-functions of insert can expect \nonly values that have a constructing sequence d the form rewind o insert . We choose the d-functions \nto undo the effects of the rightmost instance of insert in the above constructing sequence. Informally, \nwe want d-functions for insert to behave as follows: insert n-l(insert(null, rl),...rn))) = d~n,,,t(rewind( \nrewind (insert -l(null, ... m)) d~n,.,t(rewind( insertn-l(insert( null, rl), ... m))) = rl. The above \nproperties can be expressed algebraically as follows : d!nseri(rewind( insert(rewind(v)t r))) = rewind(v) \nd~n,,r,(rewind( insert(rewind(v), r))) =r The operations delete and read can serve as the two d-functions, \nrespectively. The decomposes we have chosen for the file [t] type are such that there are, in general, \nseveral decomposing sequences for a file value, IFor instance, since d!ewin~is an identity function, \nit can be applied an arbitrary number of times at any point in the decomposition. However, the canonical \nform we have chosen suggests an obvious decomposing sequence. This is to undo the effects of the constructors \nin the order in which they appear in the canonical form; this strategy will decompose a file starting \nfrom the leftmost record, Since d!awi ~ is deliberately chosen to be an identity function it need not \nbe used in the decomposition process at all. A possible set ofsequencesof d-functions that extracts all \nthe records from a non-empty file of length n is { d~ti, , d;,,,,, . dj~ip , . . . . d?nswt (dlnmrt)n-l~ \nd~tip} The design of the d-functions above was guided by the particular canonical form of a file value \nwe chose. If we had chosen a different canonical form for a file for a different application, it wcwld \nhave perhaps led to a different set of d-functions. Note that the definition of d-functions does not \nrequire that they have to be designed with respect to any canonical form of a valus however, the methodology \nbased on a canonical form simplifies the design process for d-functions, as illustrated above. 4.1.1.4 \nDiscussion In the general case of a data type, where the constructors can take more than one arg,ument \nof the defined type, a value might have to be constructed starting from arbitrarily many basic values. \nA binary tree is an example of such a situation. Then we need a set of decomposing sequences to decompose \na value; every decomposing sequence in the set will be generating one of the several basic values needed \nto construct the given value. We have to use each of these decomposing sequences ina manner explained \nbefore to get all the sequences of d-functions that extract the values of the defining types. In the \nabove definition of d-functions, we associate n d-functions for every n-ary constructor in flc; however, \nthis association is not essential, The only requirement needed is that the set of d-functions satisfy \nthe property PI. The advantage of having this association is that it encourages the methodology for designing \nd-functions that was discussed in the preceding sections. We believe that the methodology is simple and \nelegant.  4.1.2 The p-functions The property (Pi) in section 4.1.1.1 that defines the d-functions guarantees \nthe existence of a set of sequences of d-functions that extracts all the values of the defining types \nfrom a given value. Given the information about the structure (i.e., a constructing sequence) of a value, \nwe saw how the values of the definin~; types can be extracted from it. But, for the d-functions to be \nuseful in implementing other functions on the defined type, we should be able to extract the values of \nthe defining types without any a priori knowledge about the structure of the value of the defined type. \nFor this, we need a device that can help us extract the structural information of a value. We introduce \na set of functions, called p-func(ions, as a part of the set of distinguished functions for this purpose. \nP-functions take the form of predicates. They are defined so as to guide us in the decomposition procesy \nthey help us pick the appropriate d-functions in an appropriate order to decompose any given value to \na basic value, For this, the p-functions have to satisfy the following two properties: (a) They should \nhelp us terminate the decomposition process. That is, they should help us determine whether we have decomposed \nthe given value to a basic value. (b) At every step in the decomposition process, they should help us \npick a decompose which makes us move closer to a basic value. Note that in the absence of this information, \nthe decomposition process cannot be guaranteed to terminate.  The first requirement can be handled \neasily by having predicates to test if a value is a basic value. So we have : (P2) Associated with every \nbasic constructor ui in flc , there exists a p-function, pi., such that ~(v) iff v is the value constructed \nby (ri To formalize the second requirement, we need to define a relation on the value set of the data \ntype that reflects how close a particular value is to a basic value. We call this relation is_closer_than, \nFor ease of exposition, we first define the relation for the simple case where every constructor in flc \nof the data type takes at most one argument of the defined type. We extend the definition to the general \ncase later. For the simple case, we need only a single decomposing sequence to decompose a value to a \nbasic value. We define the dislance of a value to be the least number of decomposes necessary to decompose \na value to a basic value, i.e., the length of a shortest decomposing sequence for the value. Then, v \nis_closerJhan v iff the distance of v is less than the distance of v . We define a set of p-functions \nthat helps to pick the appropriate decompose. (P3) Associated with every nonbasic constructor Ul, there \nexists a p-function, Pj , such that Pi(v) iff dj(v) is_closer_than v Assuming that stack [N] and file \n[t] have d-functions as chosen earlier, we define p-functions for them below. For stack [N], the p-function \nassociated with null should test if a value is the one created by null, i.e., if a stack is empty. The \ndecompose associated with push, i.e., pop, reduces the distance of a stack value if it is non.empt~ so \nPPWh has to determine if a stack is non-empty. We have the following implementations. p,ull(v) Q empty(v) \np~ $h(v) ~ not(empty(v))  For file [t], there are several decomposing sequences based on the d-functions \nwe have proposed in section 4.1.1.2 Let us design a set of p-functions that guides us through a decomposing \nsequence of the form d&#38; . (d Ins,,Jn. According to this strategy, we want d&#38;iP to be applied \nright at the beginning but only when the file is not rewound, i.e., when the position of the pointer \nis greater than one. Secondly, we do not intend to apply d!eWiti at all; so Prewind can always be false. \nLastly, our intention is to decompose the file starting from the leftmost record; so d! .$,,, should \nbe applied if the file is non-empty and the file is rewound. p$kip(v) e (Pos(v) > 1) P,nswt(v) Q not(emptY(v)) \n&#38; (Pos(v) = 1) pr~wimj(v) ~ false  For the general case, we need a set of decomposing sequences \nto decompose a value, since a value could be constructed from a set of zero or more basic values. Every \nvalue may have several such sets of decomposing sequences. So, we have to change the definition of the \ndistance of a value. The length of a longest decomposing sequence inside a set of decomposing sequences \nfor a value is called a relative dis[ance for the value. We then define the distance to be the minimum \nof all relative distances for the value. (Note that the definition of distance in the general case reduces \nto the definition given before in the simple case.) The rest of the definitions for p-functions remain \nas before. So (P3) above would be interpreted as follows if pi(v) is true then the set of decomposes \nassociated with uj could be applied to v successfully.  4.2 Definition of Expressive Richness Based \non the notions of d-functions and p-functions, we capture the informal notion of richness of the operation \nset of D by means of the following definition for expressive richness. Definition 5 The operation set \nof a data type D is expressively rich if every function in a set of distinguished functions with respect \nto a minimal subset of constructors, Q~ , can be implemented in terms of the operations in fl using only \nthe mechanisms of composition and conditional expressions. The above definition satisfies both the goals \nthat motivated the extension of the notion of expressive completeness. The theorem to follow shows that \nthe definition maintains the logical power of a type as before. The richness aspect is taken care of \nby the distinguished functions. The distinguished functions characterize all desirable basic manipulations \nthat one might want to perform on values. All useful functions on values can be implemented conveniently \nin terms of them, since they permit one to extract all relevant information from a value easily. The \nrequirement that the distinguished functions be implementable in terms of the operation set without the \nuse of recursion avoids the use of enumeration in the implementation of the distinguished functions. \nTheorem 4 Assuming that every defining type of D has a decidable equal predicate, and is expressively \ncomplete, if D is expressively rich, then D isalso expressively complete. Proof We show that the equal \npredicate for D can be defined in terms of the distinguished functions of D, and the equal predicates \non the defining types of.D. Then the required result follows from Theorem 2. Let us suppose the following: \nfl== {Cl, . . . ,UN}; n(i) is the arity of u, ; al, . . . ,uK are the basic constructors (i.e., constructors \nthat do not take arguments Of type D); 6K,I, . . , UNare the non-basic constructors. For convenience, \nin the following implementation, we use = to denote the equal predicate on all types inside the body \nof the code. The first k main clauses constitute the basis condition. The remaining clauses form the \nrecursive step, since they involve recursive invocations of equal on D. equal(vl, v2) Q if pl(vl)then \npl(v2)&#38;d~(vl) =d~(v2)&#38;. . . &#38; d~(i)(vl) = d~( )(v2) else if p2(vl} then P2(v2) &#38; d+(vl) \n= dj(vz) &#38; . . . &#38;d;(2)(vl) = d;(2)(vz) else if p~(vt) then p#v2) &#38; d~(vl) z d~(vz) &#38; \n... &#38;d;(k)(vl) = d~(k)(v2) else if p~+l(vl) then pk+l(v2) &#38; dk+~(vl) = dk+~(vz) i%,.. &#38; dk4~(k+ \n)(Vl) = dk.~(k )(V2) etsepN(v2) &#38;d~(vl)=d~(v2)&#38;. . , &#38; d;(N) [Vi) = dfi(N) (v2)  4.3 Examples \nIn this section we investigate the expressive richness of the designs of the data types we have discussed \nso far. The method we use is to design a set of distinguished functions for the type, and then see if \nthe functions are implementable in terms of the operations of the type without the use of recursion. \n(1) stack [N] is null. push, poP, toP, eIttPtY (2) file [t] is null, insert, rewind, skip, delete, read, \nPOS, empty, eof, length  The above two designs are expressively rich; for each of them we designed a \nfamily of clistinguished functions in the preceding sections which were demonstrated to be implementable \nas simple compositions of the operations the type. (3) set[Nl is null, insert, remove, has, empty, equal \n!-lC = {null, insert> One possible set of distinguished functions is : d~n,,rt(s) &#38; m.ax(s) d~n,ert(s) \ns remove(s, max(s)), where max returns the maximum element in the set. Pnu$s) ~ empty(s) pin$~r,(s) 42 \nnot(empty(s)) Another possible set of distinguished functions is : d~n$e,$s) s rein(s), where min returns \nthe least element of the set. d~n,e,t(s) s remove(s,min(sl) P,.11 and Pins.rt are the same as before. \nset [Nl is not expressively rich as it is, because it is not poss~bl~ to implement without using recursion \na function to extract some element from a set. However, if we include max or min as an additional operation \nof set [N], then the modified design is expressively rich. 5. Concluding Remarks In a strongly typed \nsystem with abstract data types, the designer of a type ought to be careful in choosing the operations \nfor the type. If the operation set chosen is not rich enough, it might be impossible or inconvenient \nto discover certain useful properties about the values of the type. In this paper, we have provided a \nformal characterization of the expressive power of the operation set of a data type. We defined t wo \nproperties related to the expressiveness of a data type -expressive completeness and expressive richness. \nWe believe that such a characterization can help one gain a better insight into the intuitive aspects \nof the design of a data type. In the following, we discuss a few situations in which requiring a data \ntype to be expressively rich proves to be beneficial. An important advantage of a data type is that it \ndelineates the use of the type from its implementation. This enables, among other things, one to provide \nseveral versions (implementations) of the same data types; each version can be made suitable for a particular \nclass of applications. In such a context, the user might often want to convert among the values belonging \nto different versions. Having the data type expressively rich (or, at least expressively complete) can \nbe very helpful for the user in such a situation. The user will be able to easily write conversion routines \nhimself, since the operations of an expressively rich type can be conveniently used to extract ail the \ninformation needed to reconstruct any given value; there is no need to divulge any information about \nthe representation for this purpose. The property of expressive richness of a data type also enables \nits user to convert any of its values to an external representation of his choice. This makes it possible \nto write output routines to either store a vahre efficiently in a backup store or to dis]play the value \nin a suitable format on a peripheral device. An elegant way to incorporate protection [6] for data objects \nin a system that supports abstract data types is to control the set of operations that is made available \nto the user. Based on the kind of information that needs to be protected from the user some operations \nare made inaccessible to him. In such a context, comparison of expressive power of different sets of \noperations of a data type becomes immiwmt. The expressiveness properties discussed in the paper are of \nhelp here. For instance, one should make sure that the subset of operations that is accessible to the \nuser is not expressively complete. The distinguished functions can be used as a guide to determine which \noperations of the data type ought to be made inaccessible to the user. Another interesting situation \nwhere the property of expressive richness plays a useful role is in automatic synthesis of an implementation \nof a data type in terms of another data type (rep type) from their algebraic specifications. The synthesis \nprocedure under investigation in [15] derives implementations for the operations by transforming the \naxioms of the type in two stages. In the first stage, the axioms are transformed into a form in which \nthey are expressed as formulas on the values of rep type. In the second stage, the axioms are converted \ninto implementations involving the operations of the rep type. The concept of distinguished functions \nare helpful in the second stage. The axioms in the intermediate form can be systematically converted \ninto implementations involving the distinguished functions of the rep type, This is because the distinguished \nfunctions provide the information that is implicit in the pattern matching mechanism used by algebraic \naxioms. So the job of the synthesis procedure is reduced to one of finding implementations for the distinguished \nfunctions of the rep type. Although this is a non-trivial task, it turns out that the task can be automated \nwith relative ease for expressively rich data types. In this paper, we have only concentrated on immutable \ndata types. It would be interesting to conduct a similar analysis for mutable data types also. We imagine \nthat the requirement in the mutable case has to be stronger since the ability to distinguish object identity \nalso ought to be taken into consideration. Acknowledgements We are thankful to Carl Seaquist for his \ninsightful suggestions throughout the development of this paper, and to Craig Schaffert for bringing \nto our notice a mistake in an earlier draft of the paper. We are also thankful to Prof. Valdis Berzins, \nProf. John Guttag, Prof. Barbara Liskov, Eliot Moss, and N, Natarajan for their helpful comments. REFERENCES \n1. Greif, I.G., ~rrducdon in Proofs about Programs. MAC TR-93, M,I,T., Cambridge, MA, Feb,, 1972.  2. \nGoguen, J.A., Thatcher, J.W., Wagner, E.G., Initial Algebra Approach to the Specification, Correctness, \nand Implementation of Abstract Data Types/ Current Trends in Programming Methodology, Vol. IV, Data Structuring, \n(Ed, Yeh, R.T.), Prentice Hall (Automatic Computation Series), Englewood Cliffs, New Jersey, 1978.  \n3. Guttag, J.V., The specification and  Application to Programming of Abstract Data Types. Ph. D. Thesis, \nUniversity of Toronto, CSRG-59, 1975. 4. Guttag, J.V., Horowitz, E., Musser, D.R., Abstract Data Types \nand Software Validation: Comm, ACM Vol. 21 No. 12, 1048-1064, Dec. 1978.  5. Hoare, C.A.R., Proof of \nCorrectness of Data Representations: Acts Irrforma(ica Vol. 1, No. 4, pp 271-281, 1972.  6. Jones, A.K., \nLiskov, B,H. A Language Extension for Controlling Access to Shared Data, IEEE Tran. on Software Engg \nVol. SE-2 No. 4, pp. 277-285, Dee, 1976.  7. Kapur, D., Srivas, M. K., Expressivenessof the Opera(ion \nSet of A Data Abstraction. Computation Structures Group Memo 179-1, Lab. for Computer Science, M.I.T., \nCambridge, MA, June, 1979, Revised Nov., 1979.  8. Kapur, D., Towards a Theory for Abstract Data Types \nForthcoming Ph.D. Thesis, Dept. of  E.E. &#38; C.S., M. I. T.,Cambridge, Mass., Jan., 1980. 9. Kleene, \nS.C., General Recursive Functions of Natural Numbers, Mathematical Annals 212, pp. 727-742 (1936).  \n10. Liskov, B.H., Snyder, A., Atkinson, R., Schaffert, C,, Abstraction Mechanisms in CLU~ CACM Vol. 20 \nNo. 8, pp. 564-576, 1977.  11. Liskov, B.L., Snyder, A,S., Exception  Handling In CL U. Computation \nStructures Group Memo 155-2, Lab. for Computer Science, M. I. T.,Cambridge, MA, Dec., 1977, Revised \nMarch 1979. To appear in IEEE Trans. on Software Engineering. 12. McCarthy, J., A Basis for a Mathematical \nTheory of Computation in Computer Programming and Formal Sys[ems, (Eds. Braffort and Hirschberg), North \nHolland Publishing Co., Amsterdam -London, pp 33-70, 1963. 13. Morris, J.H., Jr., Towards More Flexible \nSystems, Lecture Notes in Computer Science 19, Springer-Verlag, pp. 377-383, 1974. 14. Rogers, H., Jr., \nTheory of Recursive Functions and Effective Computability. McGraw-Hill Series in Higher Mathematics, \nMcGraw-Hill, Inc., 1967. 15. Srivas, M. K., Draft of a Thesis Proposal on Automatic Synthesis of Abstract \nData Types/ LCS, M.I.T., December 1978. 16. Weihrauch, K., A Generalized Computability Thesis, Lecture \nNotes in Computer Science 56, Springer-verlag, pp. 538-542, 1977. 17. Wulf, W., London, R.L., and Shaw, \nM., Abstraction and Verification in ALPHARD: Introduction to Language and Methodology. Carnegie-Mellon \nUniversity Technical Report, also USC Information Sciences Institute Research Report, 1976. 18. Zilles, \nS.N., An Introduction to Data A/gebra Draft Working Paper, IBM San Jose Research Lab., Sept. 1975.  \n Appendix I -Definitions of Data Types We present the definitions of various data types discussed in \nthe body of the paper. For a lack of space, we have not included their algebraic specifications; they \ncan be found in the expanded version of this paper [7]. We first give the syntactic specifications of \nthe operations of a data type, and then we give a model of the data type. We usually use the first two \nletters of an operation name to stand for its interpretation in the model. The definitions of the functions \nare presented in any convenient mathematical notation. A data type is the set of all algebras behaviorally \nequivalent to the given model. set [N] is null, insert, remove, has, empty, max, equal null : --> set \n[N] insert : set [N] X N --: set [N] remove : set [N] X N --:* set [N] has : set[N] XN --> bool empty \n: set [N] --> bool max : set[N] -.> N equal : set [N] X set [N] --> bool The model ilf~n is a natural \nmodel of set [N] in the sense that its value set is the set of all finite sets of natural numbers, and \nthe interpretations of its operations are defined in terms of the standlard set operations. QJ~n=[{StN, \nN,B};{nu,in, re,ha,em,ma,eq)], where B = { true, false ), a value set of bool, N= { 0,1, 2,3,... }, a \nvalue set of N, and StN = { *, {0), {1]1,{4, {O,1]){o,2)){L 4 {3},{o,3},{1$,3], {2, 3), {o,1, 2], ., \n. }, a value set of set [N]. @ R(s,=i) = s u {i} re(s, i) =s -{i} ; -is the difference operator ha(s, \ni) =ics em(S) = true ifs is the empty set false otherwise ma(s) = o if s is the empty set n]ncs A(Vi)ics==>i \nS n otherwise eq(sl, 52) = true if S1 and 52 are the same set false otherwise stack [N] is null, push, \npop,, top, empty, equal null : --> stack [N] push : stack [N] X N --> stack [N] pop : stack [N] --> stack \n[N] top : stack [N] --> N empty : stack [N] --> bool equal : stack [N] X stack [N] --> bool The model \nw~tk of stack [N] h= sequencesnatural of numbers as the values of stack [N). a~tk = [ { SqN, N, B ); \n{ nu, PU,PO,to, em, q )], where SqN is the set of sequences of natural numbers. SqN = C <>, <O>, <1>, \n(2), (0, 0>, <0, 1>, <0, 2>. <1, W, <1, 1!>, <1, 2>, <z 0>$ <2s 1>$ <2, 2>, (3>, <0, 3>, ... ). The interpretations \nof the operation names are defined as follows (Kei, . . . . ej> is the empty sequence if j K i) : nu \n=<> pu(<el, . . . , em>,e) = <el~ . . . ~em,e> po(<>) = <> po(<el, . . . . e~~) = <cl,...,el>l> ifm>O. \nto(<>) = o to(<el, . . . , e~z) = em ifm>O. em(<>) = T em(<el, . . . , >)=F emz ifm>O eq(<ell, . . \n., elm>, <e21, . . . . e2n>) = T if m = n and for each 1,eli = ezi F otherwise. file [t] is null, insert, \nrewind, skip, delete, read, pos, empty, eof, length null : --> file [t] insert : file [t] X t --> file \n[t] rewind : file [t] --> file [t] skip : file [t] X N --> file [t] delete : file [t] --> file [t] read \n: file [t] --> t pos : file [t) --> N empty : file [t] --> bool eof : file [t] --> bool length : file \n[t] -> N The model !$l has a set of 2-tuple$ whose first element is a sequence of records and the second \nelement is a natural number, as the value set. We assume that the function corresponding to read returns \nthe element r. when the pointer is at the end of file. The functions corresponding to rewind and read \nare denoted as re and rd respectively. 9+I=[{F1,N,B]; { nu, in, re, sk, de, rd, Po, em, eo, le ] 1 where \nFI is a subset of 6qT, N>, where SqT is the set of sequences of elements of type t, such that every member \nf =z<rl, ....m>,k> of F1has1s k s n+l. Let sstand for a sequence zrl, . . . . r,> of n records. nu = \nC> in(f, r) = <<r,, . . ., rk.l! r, rk! . . . ~rn>t k+l> sk(f, m) = <s, k+m> if k+m s n+l <s, n+l> otherwise \nrw(f) = G, 1> de(f) = <<r], .... rk-l? h+tt .... rt?r k> f k ~ n f otherwise re(f) = r~ ifk~n t-. otherwise \npo(f) = k em(f) =(n=O) co(f) = (k = n+l) le(f) = n Appendix 11-Proof of Theorem 3 Theorem 3 Assuming \nthat (i) for each of the defining types of D the equal predicate is decidable, and (ii) every defining \ntype of D is expressively complete, D is expressively complete if the operation set of D includes the \nequal predicate on D. Proof A function f in Comp(D) is a function on W preserving E; as explained in \nchapter 2, f can also be viewed as a function on V, i.e., W/E, In the following we take this latter view \nof f, so that we do not have to continually consider the equivalence relation E. We already know that \nfor any D it is possible to construct an encoding function q that can be used to map every function of \nD to a function on natural numbers. Because of our change of view of functions of D, it is convenient \nto come up with a similar scheme that encodes values as numbers. The two premises of the theorem guarantee \nthe existence of a computable bijective function 8 : N -> V. We call IS a numbering for D; let @ be the \ninverse of t . We show later how one such numbering scheme can be constructed from a pair of encoding-decoding \nfunctions (q and 8) for D. We use n . f . ii as the image of f. For convenience, we define the inverse \nimage of a function ~ on N as the function h o%+q . Note that if f is computable (i.e., f c Comp(D)) \nthen so is its image (via <v , 8 >), and if ~ on N is computable, so is its inverse image. To prove \nthat D is-sxpressivcly complete, we have to show that Comp(D) = C(Q). We do this in two parts Part I \nC(fl) G Comp(D) Every operation in Q is computable and the mechanisms of composition, recursion, and \nconditional expression preserve computability; so it is obvious that 6(0) G Comp(D). Part 11 Comp(D) \ns C(O) Let the functions OD, Sn, and D on D be the inverse images of the natural number functions O, \nS, and =, respectively. The proof of Comp(D) G C(O) follows from the following two claims: (i) Comp(D) \nG U({ OD , SD , =D ]) (ii) (f{{ OD , SD , =D ]) G a(~) To prove (i), let f 6 Comp(D). So there ex~ts \na computable function ~ on N such that f = 8 . f V ; ? E 6({ O , S, = )). Let ~(x) s Def(~)(x), where \nDef(~)(x) is the implementation of f, expressed using composition, recursion, and conditional expression, \npos$ibly using a set of auxiliary functions. Now consider the function f :D -> D whose implementation \nis obtained by replacing every occu~rence of ~, O, S, =, and the auxiliary functions in Def(f) by their \ncorresponding inverse images. f obviously belongs to ff({ OD , SD, =D }). Lem~_l belOw hews that f is \nindeed the inverse image of f, and hence is functionally equivalent to f. Lemma 1 f (x) = 8 .-F. tf (x).s \nProof We prove the equivalence of the two recursively defined functions using Morris s truncation induction \nrule [1]. We augment the value set of every data abstraction D by the undefined element, denoted by J-D, \nand order the augmented domain such that D < V\\ where v is any non-lD vahre, and the nOn-LD values are \nnon-comparable. The functions on D are assumed to be defined on the augmented domains. The numbering \nfunction 6 is also extended so that 6 (lN) = ID. Let ID denote the constant function on thatreturns D \nlD)andIN denotetheconstant function on N that returns lN. Then we have lD=#.lN.q: Let gi stand for the \nith truncation function of g. We can show the lemma by proving that (i) f o(x) = $ ~os ~(x), (ii) if \n(V i < j) f ,(x) = 8 T oq (x),  then f j = $ . ~ Qr) (x), where f ~(x) = lD(X), f~(x ) = lN(X ), and \nfor i > 0, f i(x) = Def (f i.l)(x), and fi(x ) = Def(fi-l)(x ). The proof of (i) is trivial. (ii) can \nbe proved by induction on the structure of the definition Def, where Def being O, S, or = serves as the \nbasis. The inductive step involves two cases -(a) when Def is a composition, and (b) when Def is a conditional \nexpression. Q.E.D. We prove claim (ii) constructively by giving implementations for fJD , SD , and D \nin terms of he equal operation of D in conjunction with a minimal set of constructors of D, Note that \nthe latter is the least we can assume about 0. Let i2C denote a minimal subset of constructors of D; \nso flcu{equai)=fl. Without any loss of generality, we assume that every constructor in flc takes (i) \nat most one argument from D, and 5. In order to simplify the proof, we have not considered the case \nwhen f is defined mutually recursively using a system of recursive definitions. For this case also, the \nproof can be worked out along the similar lines. (ii) at most one argument from the value set of a data \ntype other than D, We classify !lC into the following four subsets. Oy= {c,,... , Cj } , where Ci : -> \nD. n: ={ql, . . ..q~}. whereq: D,-> Dand D, different from D. ft~ ={rl, . . ..rl}. whereri: D->D. Q;l \n={sl, ..., sin], where si:DXD, ->D, where Di is different from D. We define a numbering scheme that induces \na total ordering on the value set of D. The least element of this ordering is chosen to be OD. The function \nSD is defined so that when SD is passed a value v of D, it returns the value whose number is one greater \nthan that of v. So SD can be easily implemented in terms of q and 8 as : SD(V) s 8 (#(v) + 1). The predicate \n=D is the same as the predicate equal of D. Below we briefly sketch how a numbering can be constructed \nfrom an encodingdecoding of D, The implementation of the numbering in terms of equal and the constructors \nin flc involves complex enumeration techniques. For details of a complete implementation see [7]. Q.E.D. \n Construction of a Numbering for D In order to simplify the presentation, we assume that the cardinality \nof each of the sets tl~ , 0$1 , il~ , fl~} is 1; the approach discussed below easily extends to the general \ncase where the cardinalities are arbitrary, f-p =C c}, c:->D l-g ={rt}, q: D] -> D fl$ = {r), r: D->D \nQ:] ={ s>, S: DXD2->D Let <irl, 61> and <q2, 82> denote the encoding-decoding pairs for D, and D2, respectively. \nThe following table depicts the encoding function for D. An implementation of q maintains a counter; \nit increments the counter while enumerating the words formecl out of the constructors in Q= in the order \nindicated below until it hits the word which is to be encoded; the value of the counter at this point \nis the code for the given word. v ?)(v) co q(al(o)) 1 r(&#38;O)) 2 5(6(O), 82(0)) 3 Cl(#l(l)) 4 r(8(l)) \n5 s(b(l), 62(0)) 6 $(8(O), 82(1)) 7 s(6(1 ), ~2(1)) 8 q(i+(2)) 9 r(N2)) 10  A numbering for D can be \nderived from the above table by grouping together all words that yield equivalent values. For exarqple, \nlet us suppose that among the first 10 words, the following set of yords represent the same value. c, \nq(a1(2)), 5(8(O), 82(1)) q(J1(0)), r(NO)), s(c$(o), &#38;2(o)) q(tl(l)), 5(8(I), 82(0)) r(i)(l)), r(N2)), \n5(6(1), $2(1))  Then the first 4 values are encoded as depicted in the following table. An implementation \nof t) is also based on the enumeration of all the words formed out of the constructors in flc. It enumerates \nthe words in the same order as an implementation of q would, but it increments the counter selectively; \nit increments the counter if and only if the next word generated in the enumeration is the first word \nto be generated from the equivalence class to which the word belongs. l) (v) ;Cl o W,(o))] 1 [q(dl(l))l \n2 [r(ii(l ))] 3   \n\t\t\t", "proc_id": "567446", "abstract": "In a strongly typed system supporting user defined data abstractions, the designer of a data abstraction ought to be careful in choosing the operations for the abstraction. If the operation set chosen is not expressive enough, it might be impossible or inconvenient to implement certain useful functions on the values of the data abstraction. In this paper, we characterize the expressive power of the operation set by defining two properties for data abstractions - <i>expressive completeness</i> and <i>expressive richness.</i> The operation set of an expressively complete data abstraction is adequate enough to implement all computable functions on its values. An expressively rich data abstraction is expressively complete with an operation set that is rich enough to conveniently extract from a value, all relevant information required to reconstruct the value from scratch. Practical applications of the properties of expressiveness introduced are also discussed.", "authors": [{"name": "Deepak Kapur", "author_profile_id": "81100427488", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA", "person_id": "PP14150581", "email_address": "", "orcid_id": ""}, {"name": "Srivas Mandayam", "author_profile_id": "81100113225", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA", "person_id": "P383056", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567460", "year": "1980", "article_id": "567460", "conference": "POPL", "title": "Expressiveness of the operation set of a data abstraction", "url": "http://dl.acm.org/citation.cfm?id=567460"}