{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 literature (see for example [sto77]), only brief remarks about the semantics \nof statements and expressions appear in sections 3 and 4. A few language issues relevant to declarations \nare mentioned in section 5, and the final section 6 con\u00adtains some notes on the project. 1.4. Literature. \nLittle of the folklore of the denotational method is available in print. Stoy [sto77] is a general introductory \nreference. The best reference I have found for describing languages is the unpublished set of lecture \nnotes by Gordon [gor78]. As I progressed, I used [ten77] as a primary reference. The several sources \nwhere the semantics of an actual language is given tend to contain little discussion of why the partic\u00adular \npresentation was chosen. The discussion of declarations in section 2 draws heavily on the folklore of \ndenotational semantics. If there is anything original in the section, it is in the way the material leads \nup to the semantics of data declarations in a real language. 2. Declarations  By declarations we mean \nthe part of a programming language that allows meaning to be associated with identifiers. Identifiers \nare used not only to refer to basic values like characters, and data structures like arrays, but also \nto executable functions , which take parameters and return values. A discussion of the meaning of declarations \nmust therefore address issues suggested by the following phrases: basic and derived types; data declarations; \ntype determination; block structure; storage allocation; function declarations. 2.1. Discussion of declarations. \nRather than assume familiarity with C [ker78], we will introduce declarations in the language through \na sequence of examples. For the moment, the terms type and location will be used informally. Think of \nthere being a set Ty, whose elements are called types. Included in Ty are basic types like integer, and \nderived types like array of 8 integers. One of the purposes of a data declaration is to associate a type \nwith an identifier. The term location corresponds to a storage cell in a machine, except that a location \ncan hold any basic value. A loca\u00adtion will be associated with each identifier representing a basic value. \nThis basic value will be determined from the identifier in two stages: first the location for the identifier \nwill be determined, and then the value held in the location will be looked up. Syn[ax. The following \nprogram fragment suggests the syntax of declarations in C. int n= 3; char select(xrc,d) int x; char c; \nchar d; ( char e; if(x>n) e=c; else e=d; return (e); We take a program in C to consist of a sequence \nof data declarations like int n= 3; followed by a sequence of one or more function declarations. C-functions \nlike select are similar to functions and subroutines in Fortran, or to procedures in Pascal, except that \nfunction declarations cannot be nested. As in Algol 60, the char in char select(x,c,d) specifies that \nselect is a C-function that returns a character. Declarations of the formal parameters x, c, and d precede \nthe body of the C-function. The identifier n is external to all function declarations. External identifiers \ncan be referenced inside any function without being explicitly redeclared. We assume that inside a C-function \nany declarations, like that of e, precede all statements within the function. Declaratory. The syntax \nof an identifier declaration in C mimics the syntax of expressions in which the identifier might appear. \nFor example, float xyz[3][5]; says that, in an expression, xy.z[m][n] represents a value of type float. \nThen, xyz[m] must represent an array of five elements of type float. xyz is therefore declared to be \nan array of three subarrays; each subarray being an array of five elements of type float. The declaration \nint *px; says that the construction *px represents an integer. The * operator dereferences a pointer, \nso px is declared to be a pointer to an integer. The constructions xyz[3][5] and px in the above declarations \nare instances of declurators. Structures. The essential difference between an array and a structllre \nis that an array contains a fixed number of members of the same type, while a structure contains a fixed \nnumber of members of possi\u00adbly different types. There is another, more subtle, difference: a structure \nmay contain a pointer to its own type so we must deal with recursively defined types. A structure contains \na fixed number of members. Each member has u name, and may have any type. We illustrate structures by \ndeclaring a complex number z and a pointer to a complex number zp. The identifier com p Iex in the following \ndeclarations is referred to as a srruct ure tag. struct complex {float re; float ire;}; The declaration \nof a structure tag and its use to declare another identifier can be combined in C, so z and zp can also \nbe declared by struct complex {float re; float ire;] z, *zp; Declarations like the above not only reserve \nstorage for z and zp, they have the side effect c~f associating a type with the structure tag complex. \n2.2. Simple data declarations. A number of programming Ianguagc concepts must be understood before we \ncan give the semantics of even a simple declaration like char ab[7]; In this section we will consider \ndeclarations that declare identifiers to be: integers, characters, or some other basic type; arrays of \na fixed number of elements of some type; or, pointers to some type. The syntax is as follows declaration: \nbasic--specl~ier declaratory ; We will not specify the syntax of basic~pecl~er any further. A declaratory \n(e.g. *PX and XYZ[3][5]) contains the identifier being declared. Declaratory have the syn\u00adtax: declaratory: \nidentl~ier ( declaratory ) declaratory [ constant ] declaratory The * operator in a declaratory has \nlower precedence than all other operators, so *ap~7] will be parsed as *(apc[7]). Semantic domains. All \nthe semantic domains we will refer to here are defined in Figure 2.1. We will take a very simplistic \nview of the term type . Informally speaking, a type will be just an abstract entity that permits us to \ndistinguish between identifiers that are declared differently eg, distinguish between an integer and \na pointer to an integer. The domain Ty of types will be the sum of the domain Tb of basic types and domains \neorresponding to each way of constructing derived types. For example, the element of Ty corresponding \nto array of seven characters will be a triple (array,7, character): array, the only element of the domain \n{array}, serves as a keyword and is included for clarity; 7 is an element of the domain N of integers; \nand, chararter is an ele\u00adment of Ty, The association of types with identifiers will be performed by elements \nof the domain Ent of type environments. The term environment applies to any function that maps an identifier \nto something Semantic Domains Tb basic types le Ty = Tb + {array] x N x Ty + {pointer} x Ty types ent \ne Ent = Ide -Ty type environments [e L locations [6 VI= L+ [N-W] lvalues enl e Enl = Ide -W lvalue environments \nVb basic values Vs=Vb+Vl storable values Ve V= VS+ [N-V] values se S = L -[Vs + {grb) + {unused}] states \nFigure 2.1: Semantic domains for simple data declarations. associated with the identifier. Since the \nsame identifier may have a type and also some storage associated with it, there will be more than one \nkind of environment. The value of an identifier y can be changed either by an explicit assignment to \ny, or by an indirect assignment through a pointer to y. The presence of pointers makes it convenient \nto have a two-stage map\u00adping from identifiers to their values, An identifier in a data declaration will \nbe mapped by an lvalue environment enl to an lvalue . For an identifier of basic or pointer type, this \nlvalue will be a location . Locations are analogous to storage cells. Every location is included in the \nclass of lvalues, but the lvalue for an array will not be a location. For example, after the declaration \nchar pair[2]; locations will be reserved for pa ir[o] and pa ir[ 1 ]. Let these locations be 10 and 11. \nThe lvalue corresponding to the identifier pair, by itself, is a function mapping 0 to 10 and 1 to 11, \nand is not a location. In general, the members of an array may themselves be arrays, so there will be \nIvalues rather than locations for the members. Making the lvalue of an array identifier a function from \nintegers to lvalues makes it easy to determine the lvalues of the array members e.g. if the lvalue for \nab is /, then the lvalue for ab[5] will be 1(5). Following Strachey [str72], a useful distinction is \noften made between values that can be stored, denoted by identifiers, expressed by expressions, passed \nas parameters, can appear on right hand sides of assignments, can appear on left hand sides of assignments, \nand so on. For example, in most languages, even if an identifier like xyz in float XYZ[3][5]; has a value, \nthe value cannot be stored. What is stored are the values of xyzIO][O], XYZIOIII 1, ~ . One situation \nin which the identifier XyZ by itself will have a value is if array values are returned by procedures \nin the language. Corresponding to each basic type is a domain of basic values of that type. We sum all \nthese domains together into the domain Vb of basic values. Included in Vb is the domain N of integers. \nIn addition to basic values there are values associated with pointers and arrays. Since the assignment \npx=&#38;x; assigns the lvalue of x to px, the value of an identifier may sometimes be an lvalue. We therefore \ninclude W in the domain V of values. An array value in V will be a function from integers to values. \nArray values are not be storable, A state maps a location to a storable value. In addition there will \nbe two special values: grb a gar\u00adbage value corresponding to an uninitialized location, and unused corresponding \nto a location that is Semantic Rules Udeclaratorllt c IdexTy I identifier $ (ident2j7er,l ) I ( declaratory \n) ~ Udeclarator](t) I declaratory [ constant ] ~ letn=[cons/ant n; t = arr(n J ); in Udeclaratorn(t ) \n1 * declaratory ~ let r =poin~ (t ); in [declaraforn(t ) dtudeclarafion ](ent )6 Ent ~ basic~pecfier \ndeclaratory ; $ let t=~basic-spec~iern; (id,t ) = ~declarator]t; in err?[t /id] dsudeclararion ](enl,s \n)C Enl x S I basic-specfier declaratory ; ~ let t= ubasic~peczjlerJ: (id,t ) = [decfarator nt; (1,s ) \n= new (t ,s); enl = errl[l/id]; in (errl ,s ) Figure 2.2: Semantic rules fordeclarators and declarations \ninthe language of simple data declarations. Lines beginning with ``l'' specify thesyntactic rules, andarefollowed \nbylines beginning with ``]'' which give thecorresponding semantic rules. Wewrite en/[l/id] forthe new \nenvironment erd satisfying enl (x ) = if x=id then / else enl(x ) unallocated. Semantic rules. The meaning \nof declaratory can be explained by considering the declarations char *( apd7] ); int ( *pai )[7]; From \nthe discussion earlier in this section, a construction like *( apc[m] ) can appear in any context where \na character is expected, and a construction like ( *pa i )[ n] can appear in any context where an integer \nis expected. Reading the declaratory inside-out, apc is declared to be an array of seven pointers to \n from the type specifier char characters. Similarly, pa i is a pointer to an array of seven integers. \nAfter a declaratory has been examined, in addition to uncovering the embedded identifier, the type of \nthis identifier will also be known. The meaning of a declaratory will therefore be a function from a \ntype to an identifier and its type. In Figure 2.2, the meaning of the nonterminal declaratory is represented \nby ~declara\u00adtor m. Similarly, the meaning of basic_specif ier, is represented by ~basic_specifier ], \nand will be a type. Since the semantic rules associated with syntactic rules, we must follow the syntax \nand read declara\u00adtory outside-in rather than inside-out as in the discussion above. Proceeding outside-in, \nwe start with the type tfrom the type specifier and build up the type associated with the embedded identifier. \nNew types are built from old using the functions point and arr: arr maps an integer n and a type tto \na ncw type r corresponding to array of n members of type r; poiru maps a type r to f corresponding to \npointer to type t. Having considered declaratory we now turn to declarations. There are two kinds of \nmeanings for declarations: one associates a type and the other an lvalue with an identifier. We distinguish \nbetween these two types of meanings by writing dt~declaration ] for the first and dsudeclaration n for \nthe second. dt and ds are actually functions which map the semantic object declaration to appropriate \nsemantic objects. Such functions are called valuations. According to the semantic rules in Figure 2.2, \nunder valuation dt, each declaration modifies the type environment by associating a type with the declared \nidentifier. Under valuation ds a declaration associates an lvalue with an identifier. Before explaining \nvaluation ds we need to clarify the handling of storage alloca\u00ad tion. Auxiliary Function rrew(f,s) 6 \nVlx S new (t,s) = scalar (1) \u00ad let s (l)= unused; s = s[grb/l]; in (1,s ) t= arr(n, t ) \u00ad let (lo,so)=new \n(t ,s); . . . (L-l, s-l) =new(l , sn-z); f =Ai. 1; fo=f[lo/o]; ~ ~ f.-l=f.-2[Ln/l];]; in (J~-l,s.-r) \nFigure 2.3: The auxiliary function new allocates an lvalue for a given type. Allocation, Given a type \nt and a state s, the auxiliary function new in Figure 2.3 returns an lvalue, and changes the state to \ns . In the changed state, all locations in the returned lvalue are initialized to the special garbage \nvalue grb. A type t is said to be scalar if t is basic i.e. t cTb, or if t is a pointer i.e. t=point \n(t ) for some t . We use the auxiliary function scalar (t) which yields true if t is scalar, and false \notherwise. If a type t is scalar, then new (t ,s ) will return an lvalue that is a location. If the type \nt is an array type, then new is invoked recursively to determine lvalues for each member of the array. \nIf these lvalues are 10,1I,. ~ ~ ,/H-I, then the lvalue for the array will be a function that yields \n1, when applied to i, for (EZ=n 1. This function is constructed by starting with a function ~ that maps \nevery integer to an unde\u00adfined value 1. ~ is successively modified to yield -fo,~ 1,. . ~ ,~~-1, where \nj~-l(i) is 1, for &#38;i<n-l and is 1 otherwise. fn Z and an appropriate state are returned by the new \nfunction. 2.3. Recursively defined types. We will be concerned only with type determination in this section \nsince the storage aspects of structure declarations are just like those of array declarations. The determination \nof types here is a good illustration of the extraction of recursively defined information from a program. \n(Other examples of recursively defined meanings are those of recursive procedures and statement labels.) \nSyruax. The syntax and semantics of declaratory are as in section 2.2, The only purpose of the non\u00adterminal \naU_decl is to collect all the declarations together. all_decl: declaration declaration: swuct ident~ier \n{ member_decl ); type_specl~ier declaratory ; declaration declaration member..decl: type-specifier declaratory \n; member_decl memberdecl type-specz~ier: basic~pecl~ier struct identl~ier Semantic domains. In addition \nto the basic, pointer, and array types of section 2.2 we now need a structure type. The structure tag, \nthe names and types of the members, and the order in which the members appear, are all significant. A \nstructure type will therefore include the structure tag and the sequence of member names and types. Ty= \nTb+{array] xNxTy+{pointer] xTy + {struct} x Ide X [Ide X Ty]+ Furthermore, associated types, yields example, \nassociated the operator srr, applied to a type t corresponding with the tag complex is the a structure \nto a structtype tag ure and with a the list of appr pairs of opriate member tag and identifiers meknbers. \nand For str (complex, (re,Jloat ).(im,~loat )) After the declarations struct complex {float re; float \nire;); struct complex z; both complex and z have the type structure with tag complex containing members \nnamed re and im of type float. But there is a difference. complex is a tag, while z is a structure. We \nwill need to distinguish between these two ways of associating types with identifiers by suitably defining \nthe type environment Ent = Ide -[Ty + {tag} x Ty] type environments Meaning of member declarations. A \ntype specifier must clearly yield a type. In order to determine this type, we may need to refer to the \nenvironment for the types associated with previously declared structure tags. Thus the meaning of a type \nspecifier is a function from an environment to a type. ~type-specfier~ent E Ty I basic-xpec+er ~ ~basicspecijier~ \nI struct identfier ~ t where (tag,t ) = ent (identifier) In the above rule, identfier is a structure \ntag, which is mapped by the environment to a pair consisting of a special marker tag and a type t. The \nmarker tag is ignored here. Later in this section we discuss what happens if the structure tag has not \nalready been declared, From the member declarations in a structure we need to extract the member names \nand their associ\u00adated types. The meaning of member>ecl is a function from a type environment to a sequence, \npairlis~, con\u00adtaining the pairs of member names and types. ~member-dec[ lent E [IdexTy] + 123 \\ type~pecifier \ndeclaratory ; $ \\et t = ~typelpeclj_ierJent; pair = udeclarator ](t ); in pair ~ memberdecl I memberdeclz \n~ let pairlist 1 = fmember-decl ~Jent; pairlist 2 = ~memberJeclsJent ; in pairlist 1. pairlist 2 The \nmeaning of a basic specifier is assumed to be an appropriate element of the domain Tb of basic types, \nand will not be specified any further. so the Recursively dej?ned types. The type of z is recursively \ndefined. structure tag z below, is used to declare one of the structure members struct z { int count; \nstruct z *p; }; Informally, the type t associated with tag z will be structure with tag z containing \nmember count of type integer and member p of type pointer to t. We therefore have the following recursive \ndefinition of 1: t= str (z, (count, integer )(p,point (t )) ) A slightly more complex case is that of \nthe types of x and y in: struct x { int count; struct y *py; ); struct y { int count; struct x *px; ]; \nThis time we get a pair of mutually recursive definitions: tx = str (x, (count, integer )(py,point (ly \n)) ) ty = str (y, (cou nt,irrteger )(px,poirrt (tx )) ) The key problem in determining types is that \nof setting up the mutually recursive equations for these types. Actually, instead of setting up equations \nfor types, we will recursively determine the environment that will map identifiers to types. Updating \nenvironments. Valuation de enters the type of the declared identifier into the environment. The first \nrule that follows is for a data declaration similar to the ones in section 2.2, and this rule for valua\u00adtion \nde is very similar to the corresponding rule for valuation dt in Figure 2.2. deudeclaration ]ent E Ent \n~ type~pecijier declaratory ; ~ let t= utypedpecz~ier] ent; (id,t ) = Udeclaratorn(t ); in ent[t /id] \n~ declaration I declaration 2 ~ deudeclaration 21( de~declaration I]ent ) If the declared identifier \nis a structure tag, then an ordered pair (tag,t ), where t is the type associated with the tag, is entered \ninto the environment. I struct iderm ?er { member~ecl } ; $ let pairlist = ~member-decl Jent; t = str \n(identljler,pairlist ); t = (tag,r ); in em t /identl~ier] 124 Let us consider what happens when the \nabove rule is applied to the declaration: struct z { int count; struct z *P; }; Suppose that the environment \nent is such that ent (z)=/z. Using the environment ent, the valuation for member declarations will yield \nthe pairlist: (count, integer )(p,poinl(tz)) Then, the following type will be constructed: t= str (z, \n(count, integer )(p,poinl ([z)) ) If tz is an approximation to the type of z, then tabove is a better \napproximation tcl the type of z. In fact, if to=1, and ii+] = srr(z, (count, inleger)(p,point (ti ))) \n then the least upper bound of the chain to, . . ,ti, . . . is the desired type of z. Rather than setting \nup a recursive definition that allows ti+l to be determined from t;,valuation de is used to construct \na sequence of environments ent o,ent 1,. . in which enti (z) = ti. The starting environment ento will \nmap all declared identifiers to 1, the least defined type. * A valuation dz will be used to construct \nento. There is another use for a valuation like dz: the iden\u00adtifier z may be used for some other purpose \noutside the current C-function and we need to ensure that on entering a function, the types of any identifiers \ndeclared in the current function are reset . Initial environments in a [block . For each identifier with \nwhich a type is associated in the current set of declarations valuation dz will enter 1 as the type of \nthe identifier. dzudeclaration lent e Ent ~ type~pecijier declaratory ; $ let t= Utype-spec2~iernent; \n(id,t ) = ~declaratorll(t ); in ent [l/id] I struct identifier{ memberdecl ) ; $ ent [1/identijler] I \ndeclaration 1 declaration 2 ~ dzudeclaration 21( dzudeclaration tnent ) Sequence of environments. The \ningredients for determining the types of structure tags have idl been assembled. On collecting all the \ndeclarations under alldecl the valuation dz is applied to the starting environment ent, to reset the \ntypes for all declared identifiers. The valuation de is theri used repeatedly to construct the sequence \nof environments ento, ent I, . 0 . mentioned above. The desired environment is the least upper bound \nof thesequence ento,enti, . . . : ento = dz~all_decl Jent, i~oenti+l = d~declaration l_J(enti) entf =Ll{enti \nI i>O] Fix closure. The above least upper bound issimilar enough to the least upper bounds while determin\u00ad \ning least fixed points that the reader might be tempted to equate entf with the least fixed point of \ndeudeclara~ionll, Note however that entois not l(in a more general setting enrowill contain valuable \ninfer\u00ad mation about external identifiers). * The usual approach (see for example the treatment of statement \nlabels in Milne and Stmchey [mi176,pp. 52,54] or[gor7S]) is to first determine the identifiers declared \nin a block. Once the identifiers have been determined, a k-tuple is constructed from these identifiers. \nThen. using a valuation like de, we determine the type associated with each identifier. But instead of \nentering the type in the environment as done by valuation de a k-tuple of types associated with the \nk-tuple c)f identifiers is con\u00adstructed. We start with with ak-tuple giving las the type of each identified \nthe valuation successively determinest uplesoftypes that are better approximations to the final types. \n We therefore introduce a new operator C1O(from fix closure)* such that given a function nD -D and XCD, \nCIO(X)(T)=IJ{ Ti(x) / i21) Using cloweget the semantic rule: Uall>ecllent, c Ent I declaration ~ clo(errto)(deudeclarationl) \nwhere ento=dzudeclaration ]ent, 2.4. Data declarations. The approach of the last two sections suffices \nto treat all data declarations in C. Types can be determined as In section 2.3 even if the declaration \nof structure tags is nested, or if the declaration of a structure tag is combined with the use of the \ntag to declare another identifier. Some of the rules change because a type specifier may contain the \ndeclaration of a structure tag so a type specifier can have the side effect of changing the environment. \n3. Statements Since C contains goto s, the semantics of statements were given using continuations [abd75, \nmor70, stw74]. The section containing the semantics of statements was written by editing section 9 of \nthe C refer\u00adence manual [ker78]. English descriptions of the various constructs were retained, and subsections \ncontain\u00ading semantic rules were added, The reader can easily reconstruct the semantics of statements \nafter reading [gor78] or [sto77]. Alternatives tocontinuations forhandling goto statements have been \nproposed intion78] and[ros77]. The basic idea of the exit approach ~on78, pp.285] is to associate with \neach statement a function from a state to a state-label pair. If evaluation proceeds normally, then the \nlabel is NIL and is ignored; otherwise the label gives the target of the jump. In [ros77, pp.41], entries \n(embedded labels within a statement that can be jumped to) and exits (targets ofjumps from within the \nstatement) are explicitly identified, and rather than the meaning of a statement, the meaning of an entry-statement-exit \ntriple is considered. We have not explored the use of these alternatives to continuations. 4. Expressions \nC has a rich set of operators. In addition to the expected operators are a class of assignment opera\u00adtors \nof the form op=. The behaviour of expi op= exp2 is roughly equivalent to exp[ = expl op exp~, except \nthat expl is evaluated just once. The semantics of expressions are relatively straightforward. Some points \nof interest are noted below. 4.1. Side effects and order of evaluation. The C reference manual leaves \nunspecified the order of evaluation, and the same expression may be evaluated differently on different \nmachines. Since assignments may be embedded within expressions, the value of an expression depends on \nthe evaluation order. In prac\u00adtice, this does not present a problem, since programmers tend to stay away \nfrom such expressions. The principle we have used is: only those expressions that are not sensitive to \nthe order ofevahration are legal. Unfortunately there is no way of checking if a given expression conforms \nto this principle. So we have picked a particular order of evaluation in the semantic specification. \nFor all legal expressions any order of evaluation gives the right value, so the semantic specification \nwill clearly give the right value. There remains the problem of ruling out non-legal expressions. The \nbest we can do is to devise a heuristic in the spirit of lint fioh79], which will complain if the value \nof an expression is likely to depend on the order of evaluation. 4.2. Checks: error, type, ... This point \nactually applies to the whole language, but this isa good place to discuss it. * For the unsophisticated \nreader it is just as easy to explain the CIO operator as it is the least fixed point operator. Use of \nthe CIO operator simplifies some of the rules. The alternative, using least fixed points, employed by \nTennent in hls Pascal specifica\u00adtion [ten77], requires the initial envmonment to be supplied as an extra \nargument, so the rules contain two environments at the same time. However. care mmt be exercised in using \nthe cio operator: before writing clo(.Y )(~) it is important to show that .x~T(.Y). By inserting Jfor \nthe type of each identifier declared in the current block, valuation dz ensures that ento is weaker that \nde[d<ckrafion] ozftl. Welater learnt that the theoretical properties of clohave been studied in[cou79]. \nSpeaking operationally, it is convenient to take the view that an error causes execution to terminate \nwith an appropriate message. (This remark applies only to the semantic specification: the compiler certainly \ndoes not have to work this way.) The ahernative to terminating execution is to propagate errors i.e. \nany operator applied to an error value yields an error value, so when the program fina]lycnds, the rror \nvalue is f produced. The disadvantage with propagating errors is that the various operators have to be \nextended to apply to error vahtes, and this may complicate the specifications for the operators. As in \n[gor78, ten77], it is more convenient to separate thesemantics ofchecks from thesemantic:~ that assumes \nthat nothing goes wrong, It is then possible to use different methods for these two kinds of seman\u00adtics. \nIn particular, treating errors as jumps to the end of the program, we use continuations in the semantics \nthat performs checks; but it is not necessary to use continuations inthe normal semantics. A more concrete \nexample is as follows. With one minor exception the sizec)f operator it is not necessary to carry around \nthe type of each identifier when nothing goes wrong. (Structure tags will continue to be mapped to types \nby the environment, but all other identifiers will be mapped to locations or lvalues.) When type checking \nis performed, we need to know the types of identifiers, but the storage aspects need not reconsidered. \nThus modularizing checking andrun-time semantics isquite natural in this case. The sizeof operator maps \nan identifier to an integer equal to the size of the storage for the identifier. (We can for\u00admalize size \nby defining it to be the number of locations in the lvalue for the identifier. ) Since the size is determined \nby the type of an identifier, the semantics of the sizeof operator are given separately from the run-time \nsemantics. Since continuations are not needed for the semantics of the sizeof operator, its seman\u00adtics \ncan beseparated from the semantics of type checks as well. Exception: since the types of the arguments \nof a function need not bedeclared fully, the checking for compatibility between the types of formal and \nactual parameters cannot be separated from the run-time semantics. 5. Language issues Much of the time \ndevoted to specifying C was spent in learning the language. Here we mention:some of the considerations \nthat arose in the process. (The compiler writers were most helpful in volunteering information about \nknown troublespots.) 5.1. Blocks versus unrestricted jumps. The C reference manual [ker78] allows a goto \nto jump any\u00adwhere within the current function, even if the jump is into the middle of a compound statement \ncontaining declarations. The compilers for C fioh78, rit79] resolve the issue of jumps into blocks by \npreprocessing blocks away: declarations of local identifiers are moved to the head of the function in \nwhich the declarations appear, after suitably renaming identifiers and converting initializations into \nexplicit assignments. Several drafts of the semantics of statements attempted to stay close to the language \nas it is innple\u00admented by preprocessing blocks away. However, we later discovered that the compilers \noverlay storage for independent nested blocks. Thus preprocessing declarations by assigning distinct \nnew names to distinct uses of an identifier was also not consistent with the implementations. We have \ntherefore specified semantics assuming that the language has blocks in the usual sense. Even if goto \ns are restricted from jumping into blocks, this is not quite accurate, since the compilers presently \ndisallow a label from being redeclared in an inner block. 5.2. ~vpes oj structures. Structure members \nwere originally implemented as offsets from the address of a strudture, and there is a description of \nthe restrictions on member names in the reference manual [ker78]. The first attempt at specifying the \nsemantics of structure references was an abstraction of the description in [ker78], The attempt shared \na problem with the compilers. Suppose thai in an outer block we have a structure declaration: struct \ntnode { int header; int count; ] fat; and in an inner block there is a declaration struct confuse { int \ncount; char info[37]; }; Since count refers to a different offset in the inner block (from the offset \nin the outer block), all references to fat.count in the inner block will incorrectly refer to the first \ncomponent of the structure fat. The compilers now keep member names with the structure, and member names \ncan be redeclared in inner blocks without running into the problem mentioned above. 5.3. One pass nature. \nExcept in structure declarations, all identifiers must be declared before they are used. This is also \ntrue of identifiers that are declared to be synonyms for types by typedef declarations. (In the typedef \ndeclaration that follows, PX is declared to be a synonym for the type corresponding to: pointer to to \nstructure combine with them tag into x.) Thus the following one declaration is not declarations allowed. \nare legal, but reordering the declarations, or trying typedef struct x *PX; struct x { Int count; PX \npoint; ]; The semantic specification does not attempt to be faithful to the compilers and would allow \nthe order of the above declarations to be changed. The one pass nature of the compilers also shows up \nin the fact that the scope of a declared identifier seems to be from the point of declaration to the \nend of the block. Thus if x is a structure tag in an outer block, it can still be used to declare structures \nin and inner block until it is redeclared to be something else. We chose to take the scope of an identifier \nto be the entire block in which the declaration of the identifier appears. 6. Notes 6.1. Metalanguage. \nA subsidiary goal was to study the metalanguage needed to specify a language like C. Recent work on the \nautomatic construction of interpreters from semantic specifications has used denotational semantics as \na starting point [mos78, bjo78, don78]. We therefore decided to construct a deno\u00adtational specification \nof C, and wanted to see where in the specification the various features of the metalanguage were needed. \nThe style of the semantic rules was motivated by the translator generator yacc ~oh75]. Except for the \navoidance of Greek letters, the metalanguage is essentially that of the Oxford school. Using the same \nnonterminal names, with essentially the same meaning, as in the reference manual [ker78] contributed \nmaterially to thez6readability of the semantic Specification. 6.2. Supporting documents. Since no prior \nknowledge of denotational semantics was assumed, a detailed introduction to denotational semantics was \ncirculated. The need for a formal notation was motivated by mentioning a familiar construct whose meaning \nis hard to specify in English: the reference manual [ker78] deliberately bows to readability when it \ngives the meaning of the for statement in terms of a code fragment; this code fragment misrepresents \nthe meaning of the for when the body of the for has a con\u00adt Inue statement in it. In retrospect, it would \nhave been better to have focused on declarations before launching into state\u00adments. The simple data declarations \ndiscussed in section 2.2 are an excellent vehicle for introducing the notations and conventions. With \nstatements on the other hand, continuations were used because of goto, break, and contl n ue statements, \nand fixed points were used for while statements. 6.3. Sublanguages for declarations. The order of presentation \nof the semantics of declarations (sec\u00adtion 2) was selected after the early draft doing the semantics \nof all declarations together was taken on faith by all who read it. 6.4. static or own identifiers. The \ndenotational semantics of own identifiers [gor78] is inelegant. Such Identifiers were therefore preprocessed \naway by making them external to all C-functions, and suitably renaming identifiers to separate scopes. \nThis is essentially what the denotational semantics does, but it is cleaner to algorithmically specify \na preprocessor. 6.4. Expressions. The finiteness of machine arithmetic and the order of evaluation in \nthe presence of side effects led to more discussions than we care to recall. Once we began to understand \ndeclarations and get a feel for the whole language these problems faded in prominence, although they \ndid not go away. Acknowledgements It is a pleasure to acknowledge the support and assistance of my many \ncolleagues at Bell Laboratories where much of the work described here was done. S. R. Bourne, F. T. Grampp, \nS. C, Johnson, B, W. Ker\u00adnighan, A. R. Koenig, M. D. McIlroy, and D. M. Ritchie at Bell Labs were all \nvery patient and helpful. R. D. Tennent of Queens University fielded a number of questions about his \ndenotational semantics of Pascal [ten77]. But for Cary Coutant s ministrations to the typesetter at Arizona \nthis paper would not have been typeset. References abd75 S. K. Abdali, A lambda calculus model of programming \nlanguages: I. simple constructs; H. jumps and procedures, Cornpuier Languages 1, 4 (1975) 287-301,303-320. \nbjo78 D. Bjorner and C. B. Jones, The Vienna Development Method: The Mets-Language, Lecture Notes in \nComputer Science 61, Springer Verlag, Berlin, (1978). con79 R. L. Constable and J. E. Donahue, A hierarchal \napproach to formal semantics with application to the definition of PL/CS, TOPLAS 1, 1 (July 1979) 98-114, \nCOU79 P. Cousot and R. Cousot, Constructive versions of Tarski s fixed point theorems, Pacljlc J. Math \nto appear. don78 V. Donzeau-Gouge, G. Kahn, and B, Lang, A complete machine-checked clefinition of a \nsimple pro\u00adgramming language using denotational semantics, Rapport de Recherche No 330, lRIA Laboria, \nROC\u00adquencourt France, (October 1978). gor78 M. Gordon, Notes on the descriptive techniques of denotational \nsemantics, University of Edinburgh (February 1978). gre79 I. Greif and A. Meyer, Specifying programming \nlanguage semantics: a tutorial and critique of a paper by Hoare and Lauer, Sixth Annual ACM Symposium \non Principles of Programming Languages, San Antonio, Texas (January 1979) 180-189. hen78 W. Henhapl and \nC. B. Jones, A formal definition of Algol 60 as described in the 1975 modified report, in D. Bjorner \nand C. B. Jones (eds. ), The Vienna Development Method: The Mets-Language, Lecture Notes in Computer \nScience 61, Springer Verlag, Berlin, (1978) 305-336. hoa78 C. A. R. Hoare, Some properties of predicate \ntransformers, J, ,4 CM 25, 3 (July 1978) 461-480. joh75 S. C. Johnson, YACC Yet another compiler-compiler, \nComputing Science Technical Report No 32, Bell Laboratories, Murray Hill, New Jersey, (July 1975). joh78 \nS. C. Johnson, A portable compiler: theory and practice, Fifth Annual ACM Symposium on Princi\u00adples of \nProgramming Languages, Tucson, Arizona (January 1978) 97-104. joh79 S. C. Johnson, Lint, a C program \nchecker, in UNIX Time Sharing System: UNIX Programmers Manual, Volume 2,4, Bell Laboratories, Murray \nHill NJ (January 1979). jon78 C. B. Jones, Denotational semantics of goto: an exit formulation and its \nrelation to continuations, in D. Bjorner and C. B. Jones (eds.), The Vienna Development Method: The Mets-Language, \nLec\u00adture Notes in Computer Science 61, Springer Verlag, Berlin, (1978) 278-304. ker78 B. W. Kernighan \nand D. M. Ritchie, The C Programming Language Prentice-Hall, Englewood Cliffs, New Jersey, (1978). Iuc70 \nP. Lucas and K. Walk, On the formal description of PL/1, Annual Review in Automatic Program\u00adming 6, 3 \n(1970) 105-182. mi172 R. E. Milne, The mathematical semantics of Algol 68, unpublished manuscript, Programming \nResearch Group, Oxford University, (1972). mi176 R. E. Milne and C. Strachey, A Theory of Programming \nLanguage Semantics, 2 Vols. Chapman and Hall, London and John Wiley, New York, (1976). mor70 F. L. Morris, \nThe next 700 programming language descriptions, unpublished manuscript, (November 1970). mos74 P. D. \nMosses, The mathematical semantics of Algol 60, Technical Monograph PRG-12, Program\u00adming Research Group, \nOxford University, (1974). mos78 P. D. Mosses, SIS: A compiler-generator system using denotational semantics \n(Reference h4anual), Draft, ref. nr. 78-4-3, Department of Computer Science, University of Aarhus, Denmark, \n(June 1978). rit 78 D. M. Ritchie, S. C. Johnson, M. E. Lesk, and B. W. Kernighan, The C programming \nlanguage, BSTJ 57, 6 part 2 (July-August 1978) 1991-2020. rit 79 D. M. Ritchie, A tour through the UNIX \nC compiler, in UNIX Time Sharing System: UNIX Program\u00admers Manual, Volume 2B, Bell Laboratories, Murray \nHill NJ (January 1979). r-os77 B. K. Rosen, Applications of high level control flow, Fourth ACM Symposium \non Principles of Pro\u00adgramming Languages, Los Angeles, California (January 1977) 38-47. SCS71 D. S. Scott \nand C. Strachey, Towards a mathematical semantics for computer languages, Proceed\u00adings of the Symposium \non Computers and Automata Polytechnic Press, Brooklyn, New York, (April 1971) 19-46. St077 J. E. Stoy, \nDenotational Semantics The Scott-Strachey Approach to Programming Language Theor~, MIT Press, Cambridge \nMAand London (1977). str72 C. Strachey, Varieties of programming language, Proceedings, International \nComputing Symposium, Cini Foundation, Venice (April 1972) 222-233. stw74 C. Strachey and C. Wadsworth, \nContinuations: a mathematical semantics which can deal with full jumps, Technical Monograph PRG-11, Programming \nResearch Group, Oxford University, ( 1974). ten73 R. D. Tennent, Mathematical semantics of Snobol 4, \nACM Symposium of Principles of Programming Languages (October 1973) 95-107. ten76 R. D. Tennent, The \ndenotational semantics of programming languages, Comm. ACM 19, 8 (August 1976) 437-453. ten77 R. D. Tennent, \nA denotational definition of the programming language Pascal, Technical Report 77-47, Department of Computing \nand Information Science, Queen s University, Kingston, Canada, (July 1977). \n\t\t\t", "proc_id": "567446", "abstract": "On and off over the period of about a year I have worked on a semantic specification for the C programming language My objective was to construct a readable and precise specification of C, aimed at compiler writers, maintainers, and language pundits. This paper is a report on the project.", "authors": [{"name": "Ravi Sethi", "author_profile_id": "81100354362", "affiliation": "The University of Arizona, Tucson, Arizona", "person_id": "PP39039094", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567458", "year": "1980", "article_id": "567458", "conference": "POPL", "title": "A case study in specifying the semantics of a programming language", "url": "http://dl.acm.org/citation.cfm?id=567458"}