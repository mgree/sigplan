{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 The assertion +A represents the statement that A is true now or will become \ntrue sometime in the future. (After becoming true, it could then become false again.) We read 0 as henceforth \nor talwayslt, and + as !Ieventually!! or Sometime!!. The dual O to the operator 0 is defined by OA>-O-A \n. Since 0 -A states that A will never become true, we can read O as !Inot nevertt. If it is not the case \nthat A is never true, can we conclude that A must eventually become true? In other words, is sometime \nthe same as JInot never!!? The answer depends upon one s conception of the nature of time. In a nondeterministic \nsystem, the present does not determine a unique future, but rather a (perhaps infinite) set of possible \nfutures. There are two radically different ways of viewing these possible futures: the theories of branchinq.t~ \nand linear time \u00ad ln the branching time theory, all of the possible futures are equally real and must \nbe considered. The assertion that a statement is henceforth (or always ) true means that it is true now \nand will remain true during all possible futures. A statement is Ieventuallytt true if it is true now \nor else during every possible future it will be true at some time. !4 statement is not always not!v true \nif there is -possible future in which it becomes true. This does not mean that it becomes true during \neverv possible future, as required for it to be teventuallyft (or ~tsometime!t) true. Hence, !Isometimel! \nand IInot never~t are nOt equivalent in branching time. In the theory of linear time, at each instant \nthere is only one future that will actually occur. All assertions are interpreted as statements about \nthat one real future. The assertion that a statement is Ialwayst! true means that it is true now and \nwill remain true during the one real future. Similarly, it is !Ieventuallyt! true if it is true now or \nwill become true at some time during the real future. Since only the one real future is considered, any \nstatement either is IInever!t true or else it is eventuallytt true. Hence, ~tsometimett is equivalent \nto Inot never!! in the linear time theory. 2.2. Exrmessins! Properties &#38; Pro6!rams ~ TemDoral !A2!&#38;2 \nhe now indicate how temporal logic is used to express properties of a program --particularly properties \nof a concurrent program. We have found that there are two fundamental types of properties one wants to \nprove of a program: safetv poverties, which assert that 81something bad never happens!!; and liveness \n~roDerties, which assert that something good must eventually happenl . For a sequential program, partial \ncorrectness is an example of a safety property --it asserts that the program never halts with the wrong \nanswer; termination is a liveness property --it asserts that the program must eventually halt. To state \na safety property, we need a predicate GOGD which represents the statement that the system is in an \nacceptable state. The property that something bad never happens is expressed by the assertion 0 GOOD \n. We do not assume any special starting state, sn the initial conditions must be explicitly specified. \nLetting lNIT be the predicate which means that the system is in a proper initial state, our desired safety \nproperty is expressed by the following assertion: INIT ~ a GOOD . (2-1) Safety properties can be expressed \nusing only the concept of always , but one needs the additional concept of !Ieventually 1 in order to \nexpress liveness properties. Manna and Waldinger [12] introduced the temporal operator+, which they called \nIsometimeit, for deterministic sequential programs. In [9], we introduced the operator -.+ -\u00adread !Ileads \ntoll --for concurrent programs. lt can be defined in terms of+ by A liveness property is of the form \nsomething which should happen eventually does happentt. To express it formally, we need a predicate REQUESTED \nwhich expresses the statement that the system is in a state in which Something should happen , and a \npredicate DONE which expresses the statement that the required event has happened. The liveness property \nis then expressed by the assertion REQUESTED @ DONE , where -+ is defined by (2-2). As before, we want \nthis property always to hold if the system is started in a proper initial state. The desired liveness \nproperty is then formally expressed by the assertion INIT ~ 0 [ REQUESTED .+ DONE ] , (2-3) where INIT \nis as above. Because we are not assuming any preferred initial states, properties about the system must \nbe stated in the form INIT 3 . . . . It might seem more convenient to specify the starting states as \npart of the system instead of always writing the initial predicate. However, in proving correctness properties, \none must often reason about the behavior of the program when started in other states. We have found it \neasier to write an explicit initial predicate in our assertions than to introduce preferred initial states \nand have to keep track of what initial state is being assumed when. Safety and liveness properties seem \nadequate to describe the desired behavior of most complete programs. However, one sometimes needs to \nexpress more complicated concepts when proving these properties. One such concept is that of something \nhappening !Iinfinitely oftentv. The assertion 0 + P represents the statement that property P is true \ninfinitely often. Examples of statement requiring even more complex combinations of temporal operators \ncan be found in the work of Francez arrd Pnueli [5J. 3. THE SEMANTICS 3.1. Models The assertions of temporal \nlogic are defined as combinations of atomic predicates, logical connective, and the temporal operators \nEl and +. To define tine semantics of temporal logio, we must formally define how these assertions are \nto be interpreted as statements about an underlying model. The type of model we uae is quite general, \nand includes almost all formal models of program 175 execution that we KIIOW of. (The one exception is \nthe model implicitly used in [11]. ) however, our class of models is restrictive enough so we can avoid \nmany of the philosophical difficulties discussed in [18], which plague more general theories of temporal \nlogic. We define a state to be a truth-valued function on the set of atomic predicates. To see why such \na function represents what we ordinarily think of as a state, recall that an atomic predicate is an uninterpreted \nsymbol --for example, the string of IIa > ot!\u00ad characters For a program having a variable a , a state \nx can be interpreted as one in which a has the value 1 if x(!!a > Oil) = true , x(ita > 1!!) . false \n, x(!!a > 211) = false etc. Thus, the state of the program is defined b; the truth or falsity of each \natomic predicate. Since any predicate is a logical combination of atomic predicates, there is a natural \nway to define a state x to be a truth-valued function on predicates. For example, for any atomic predicates \nP and L) , we define x(-P A Q) to equal -x(P) A x(Q) . The generalization to arbitrary logical combinations \nshould be obvious. AL@@ M is aPair (S, z) ,where S is a set of states and 1 is a set of sequences of \nstates satisfying property E below. The set of states can be thought of as the set of all conceivable \nstates of a program; i.e., all possible combinations of values of variables and program countertt values. \nA sequence so, s,, s2, . . . in ~ represents an execution that starts in state so , performs the first \nprogram step to reach state S1 , Performs the next program step to reach state The execution terminates \nif and S2 tc only if the sequence is finite. The set z represents all possible executions of the program, \nstarting in any possible state. The one assumption we make about a model, expressed formally by property \nE below, is that the future behavior depends only upon the current state, and not upon how that state \nwas reached. Before formally stating this property, we introduce some notation. For any element s of \n~, we write where the Si S=so! Sl! S2! . . . . are elements of s. lf s is a finite sequence, so s . so! \n... , Sn for some n , then we define Sm to equal Sn for all m>n. Intuitively, Si represents the state \nof the program at ttime!~ i . The finite sequence so! . . . ! Sn represents an execution in which the \nprogram halted at time n in state At all later times, it is still in n state Sn . If S is a sequence \nof length greater than one, then we define s+ to equal s,, S2 , . . . -\u00ad the sequence obtained by deleting \nthe first element s+ is Ofs. If S is of length one, then defined to equal s . The equality (S+)i = (3-1) \ni+ 1 holds for all sequences s and nonnegative integers i . he can now state our condition which the \nset ~ must satisfy as follows: This condition means that after the program reaches state s, , its subsequent \nbehavior is not affected by how that state was reached. We now define some more notation for later use. \nFor any element x in S, we let denote the 2X set of all sequences in ~ which begin with x ; so Zx={sez:so=xl. \n(3-2) If S is the sequence so, s,, . . . ; then we define s+n to be the sequence Sn, Sri+,, . . . . More \nprecisely, for any sequence s in z, we define s+n inductively by: S+o= s s+n . (s+(n-1))+, for n > 0 \n. (3-3) In almost all models of programs, one defines a nnext state!t relation next on pairs of states, \nwhere y next x means that starting in state x and executing one program step can put the program into \nstate y . For a nondeterministic program, there may be several possible next states y . In some models \nof programs, the set 1 of possible executions is the set of all sequences of states such that next Si \n. This set so) S1 . . i+l Z satisfies property E. In concurrent programs, the next state relation is \nusually defined in terms of arbitrarily choosing an active process and executing one step of that process. \nHowever, some restriction is often placed on how that choice can be made in order to guarantee some sort \nof fair scheduling!! of process execution. The following are three possible scheduling requirements. \n-Eventual Fairness A process cannot remain active forever without ever being chosen. Strong Eventual \nFairness A process cannot be active infinitely often without ever being chosen. Short-Term Fairneaa There \nis an integer N --which may be a function of the state --such that a process cannot be active for N consecutive \nsteps without being chosen. (If N is the number of processes, then this is round-robin scheduling. ) \nOne can then define the set z to consist of all sequences of states so, such that (i) sl~ ... next Si \nfor all i, and (ii) the i+ I appropriate scheduling requirement holds. For each of the above three scheduling \nrequirements, the resulting set Z satisfies property E. 3.2. Intertn etation of the Assertions The semantics \nof a temporal logic system are specified by defining how a temporal logic assertion is to be interpreted \nas a statement about an underlying model. This is done in two ways: one for the logic of branching time, \nand one for the logic of linear time. 176 3.2.}. Branching Time in the logic of branching time, an assertion \nA represents a statement about the current state. Hence, we interpret A as a truth-valued function on \nstates. We let the branching I@lei interpretation of an assertion A in the model M = (S, 2) be the mapping \n*M : S ~ [true<, false} B defined inductively as follows. -If A is an atomic predicate, then for any \nstate x : A~(x) = X(A) . (Recall that a state is by definition a truth-valued function on atomic predicates. \n) -If A is the logical combination of simpler assertions, then its interpretation is defined in the obvious \nway in terms of the interpretations of its components. For example, we have: (CVD)~(X) s C:(x) V D;(X) \n(3-4) for any x in S. (Note that the V on the left side of (3-4) 1S an oPerator on temporal logic formulas; \nthe one on the right side is the ordinary logical operation on truth values. ) I he interpretations of \nDA and ~A are defined as follows in terms of the interpretation of A , where x is any element of S. (Recall \nthe definition of &#38; given by (3-2).) (U@jX) E Vsezx: (V nLO: A~(sn)I (3-5) (>A)#(x) a VSE2X: [,anLO: \nA~(sn)l (3-6) Since all assertions are obtained from atomic predicates, logical connective and the temPoral \nM for any assertion A operators, this defines AB We say that the assertion A is M-valid in the logic \nof branching time, written M*BA , if A~(x) is true for all x in S . In other words, we have: (M~A) = \nvxIGS: A~(x). (3-7) Using the definition OA z -O-A , one easily obtains the following from (3-5): (oA)~(x)s~s&#38;Zx:[snL \nO: A#(sn)]. Comparing this with (3-6), we see that the interpretations of +A and OA in general are not \nequal. The former involves a universal quantification over all possible futures, and the latter involves \nan existential quantification. For any assertion A , it is easy to find models in which one of the assertions \nOA and ~A is valid and the other is not. This formalizes our previous observation that Eventually!! means \neventually happening in every possible future, while not nevertt means eventually happening in some possible \nfuture. Hence, IIsometime!! and lltlOk tl&#38;IW are nOt equivalent in the branching time theory. A \ndeterministic system is one in which for every state x there is at most one possible next state y . In \nthis case, 2X consists of a single element, so universal and existential quantification over it are the \nsame. Hence, ,,not nevero are equivalent for a IIeventually!t and deterministic system. In fact, the \ntheories of branching time and linear time are equivalent for a deterministic system, since the only \nImpossible ! future is the single real one. 3.2.2. Linear Time In the temporal logic of linear time, \nan assertion represents a statement about the actual current and future behavior of the Drojzram. Hence, \nwe let the linear time interDret;tion of an assertion A in the model M = (s, 2) be the mapping A: : I \n~ {true, false] defined inductively as follows. lf A is an atomic predicate, then for any state x : \n= x(A) (3-8) . fl(x~s the combination of If A ~ogical simpler assertions, then its interpretation is \ndefined in the obvious way in terms of the interpretations of its components. For example, (CVD)~(x) \nz c!(x) V D!(x) 3-9 ) for any x inS. For any assertion the interpretations of OA andA ~A are defined \nas follows, where x is any element of S. (Recall the definition of s(+n) given by (3-3).) (nA)~(s) z \nV nLO: A~(s+n) (3-10) (~A)f(s) = an20: A~(s+n) (3-11) We say that an assertion A is M-valid in the logic \nof linear time, written M~A , if A!(s) is true for every sequence s in 2 . In other words, we have: (M~A) \ns V SE ,2: Au(s) . (3-12) Using the definition OA z -O-A , it follows easily from (3-10) and (3-11) \nthat (~A)~ ~ (OA)~ for any assertion A . Hence, the linear time assertion ~A z OA is M-valid for every \nmodel M,so tsometime!r is the same as !Inot never in the theory of linear time. 4. EXPRESSIVENESS We \nnow consider the expressiveness of the branching and linear time temporal 10gicS --i.e., what statements \nabout the underlying models can be expressed by assertions in these logics. Not all statements about \nan underlying model are expressible. For example, the statement that a model satisfies the short-term \nfairness condition described in Section 3.1 is not expressible in either of our two temporal logics. \nIn this section, we compare the expressiveness of the temporal logic systems of branching time and linear \ntime. We prove that neither is more expressive than the other --each can express things that the other \ncannot. We also argue that the expressive power of the logic of branching time indicates that it is better \nfor reasoning about nondeterministic programs, while the logic of linear time is better for reasoning \nabout concurrent programs. 4.1.~ To discuss formally the expressive power of our temporal logics, we \nmust define what it means for an assertion of t he branching time logic to have the same meaning as an \nassertion of the linear time logic. We can do this because we have defined the semantics of both temporal \nlogics in terms of the same underlying models. We make the following obvious definition: an assertion \nA in a logic X is &#38;eauivalent to an assertion B in a logic Y if either A and B are both M-valid (in \ntheir respective logics), or if neither one is M-valid. In other words, A and B are M-equivalent if \n(M&#38;XA) = (M~B) . M-equivalence for a single model M is not an interesting concept, because any assertion \nis M-equivalent to one of the trivial assertions ~ or ~. (We can define ~ to equal P V -P and false to \nequal PA-P, for some atomic predicate P .) In other words, every assertion is simply true or false for \na particular model. The interesting concepts of equivalence are ones in which the two assertions are \nequivalent for some class of models. The strongest form of equivalence is when two assertions are equivalent \nfor all models. he therefore say that two assertions are stronglv equivalent if they are M-equivalent \nfor all models M. For example, any predicate P in branching time logic is strongly equivalent to the \nassertion 0 P in linear time logic. To prove this, note that for a model M=(S, Z), P is M-valid in branching \ntime logic if and only if VxES: tfs&#38;Ix: s(P) is true, 0 P is M-valid in linear time logic if and \nanly if v SE Z V n.2_0 : s+n(P) is true, and property E implies that these two conditions are equivalent. \nStrong equivalence implies that the two assertions have the same meaning regardless of the meaning of \ntheir camponent atomic predicates. It is natural to define a weaker form of equivalence -. one in which \ntwo assertions are the same for a particular meaning of their atomic predicates. For example, we might \nbe interested only in models for which atomic predicates such as a > 0 can be interpreted as statements \nabout a program variable named tall, so that the truth of !ta > l!! implies the truth of la > O1!. This \nmeans that we want to restrict ourselves to a particular set of states. For a set of states S , we define \nan assertion in one logic to be S-equivalent to an assertion in another logic if the two assertions are \nM-equivalent for every model M having S as-its set of states. Strong equivalence obviously implies S-equivalence. \n4.2. Ineauivalence Results We now show that the two temporal logics have different expressive powers, \nand that neither is strictly more expressive than the other --each can express statements that the other \ncannot. We do this by showing that for any nontrivial set of states S , there is an assertion in each \nlogic that is not S-equivalent to any assertion in the other logic. Note that this is a stronger result \nthan proving the nonexistence of any strongly equivalent assertion. We say that a predicate P is trivially \ntrue for a set of states S if x(P) = true for all x inS. Trivially false is similarly defined. A predicate \nis said to be trivial for a set of states if it is trivially true or false. Our inequivalence results \nare contained in the following two theorems. Theorem 1: For any set of states S , if P is a nontrivial \npredicate for S , then the assertion OP in the branching time logic is not S-equivalent to any assertion \nin the linear time logic. Proof: We first define two models 1 0 (S, 21) and M2 0 (S,~2) , with the given \nset of states. Since P is nontrivial, there are states p and q in S such that p(P) . true and q(P) = \nfalse . Let z, consist of all infinite sequences of the form x, p, p, p, . . . with x different from \nq9 together with the sequence q~q, q9 ... . Let 22 be the set containing all the elements of ~, together \nwith the sequence q, P*P9 ... . From equations (3-5) and (3-7) and the definition of O, it is easy to \nsee that for both of these models Mi , OP is Mi-valid in branching time logic if and only if the following \nexpression is true: VxES:3sEZx:2nXO: sn(P). From this, we see that op is M2 valid, but it is not Ml \nvalid. However, ~, is a subset of 22, and it is an immediate consequence of the definition of lY-validity \nfor the linear time logic (equation (3-12)) that any assertion which is M-valid for one model must be \nM-valid for a model having fewer execution sequences. Any linear time assertion that is M.-valid must \ntherefore be M,-valid. Hence, ther~ is no assertion of the line~r time logic which is S-equivalent to \nthe assertion OP of the branching time logic. D Theorem 2: For any set S of states, if P is a nontrivial \npredicate, then the assertion ~lJP of the linear time logic is not S-equivalent to any assertion of the \nbranching time logic. Proof: Let PP denote the set of all states p such that p(P) equals true. Let M, \n0 (S, ~1) and 0 (S, 22) , where 21 consists of all M2 sequences which end with an infinite sequence of \nelements all in PP, ar!d 22 consists of all sequences containing an infinite number of elements of PP. \nSince P is not trivially true, it is easy to verify from (3-12) that the assertion >CIP is Ml-valid but \nis not M2-valid in the linear time logic. Now let A be any assertion. lie first show that when M is either \nof the models 1 r M2: (tl A)~(x) s # YE S: A~(y) (4-1) (+A)~(x) = A~(x) V d pE PP: A:(p) . (4-2) By \n(3-5) of Section 3.2, to prove (4-1) we have to show that VSE2X: [ d nLO: A~(sn) 1 s V YES: A~(y) This \nfollows easily from the observation that in both models, for any states x and y , Zx contains a sequence \nof the form x, y , . . . . To prove (4-2), it follows from (3-6) that we must show that for both models: \nVSE2X: [an~O: A~(sn)] z A~(x) V [V PEPP: AH(P)] . The right side implies the left side because in both \nmodels, every sequence in 2X contains x and some element of PP . The left side implies the right side \nbecause in both models, &#38; contains the sequence x, p, p, p, . . . for every p in PP. This completes \nthe proof of (4-1) and (4-2) for both models. Let x beany element of S. If Q is a predicate, then Q~(x) \nhas the same truth value in both models. If A is any assertion such that A~(x) has the same truth value \nfor both models, then: (i) since (4-1) holds in both models, (DA):(x) must also have the same truth value \nfor both models; and (ii) since (4-2) holds for both models, (~A)#(x) must also have the same truth value \nfor both models. Any assertion is built up from predicates using only ordinary logical operators and \nthe temporal operators l and ~, so a simple induction argument shows that for any assertion A , A;(x) \nhas the same truth values for both models. Since this is true for any state x , it follows from the definition \nof M-validity for the branching time logic (3-7 of Section 3.2) that any assertion A of branching time \nlogic is Ml-valid if and only if it iS M2-valid. However, the assertion +nP of linear time logic is Ml-valid \nand not M2-valid. Hence, it is not S-equivalent to any assertion in branching time logic. II 4.3. Nondeterminism \nversus Concurrence In almost all formal models of concurrent processing, a concurrent system is represented \nby a nondeterministic sequential one. The concurrent execution of two operations that takes place in \nthe real system appears in the model as the nondeterminism of which one occurs first. This use of nondeterminism \nto model concurrency has caused some confusion, since the type of nondeterminism involved is conceptually \nquite different from the nondeterminism studied in automata theory and in the theory of nondeterministic \nalgorithms. 4.3.1. Nondeterminism In automata theory, a nondeterministic machine is thought of as one \nthat simultaneously pursues all possibilities. The machine is considered to complete its computation \nsuccessfully if one of these possibilities succeeds. This has led to the study of nondeterministic algorithms, \nimplemented by concurrently executing all possibilities and stopping the entire computation if one succeeds. \nThe theory of branching time is appropriate for reasoning about this type of nondeterminacy. If H is \na predicate which represents the statement that the machine has reached a successful completion, then \nthe assertion OH in the logic of branching time states that some computation will succeed. Theorem I \nshows that this cannot be expressed in the temporal logic of linear time, so there is no choice about \nwhich type of temporal logic is appropriate here. Pratt [16] has developed the elegant formalism of dynamic \nlogio for discussing nondeterminism of this kind. To express his system in terms of our model, we must \ndivide the set of halting states -\u00adthose with no possible next states --into two classes: failed states, \nand successful states. Let H be the predicate that is true only for successful halted states. The dynamic \nlogic assertion lalP corresponds to the temporal logic assertion D(H ~ P) for the model defined by the \nprogram a . Harel and Pratt [7] extended the original dynamic logic to the system DL+ in order to consider \nnondeterminiatic algorithms for which all the possible cnoices lead to terminating computations. From \nour point of view, we see that an extension was needed because this new type of termination cannot be \nexpressed with only the temporal operator 0 , but requires the additional operator ~. All the formulas \nof DL+ can be obtained by adding formulas of the form [a]+ true to the original dynamic logic of [16]. \nThis formula can be expressed in the branching time logic defined by the program a as +H . The meaning \nof termination for nondeterministic programs is discussed at length in [8]. Dynamic logic only allows \none to reason about the states before and after program execution. In [17], Pratt extended dynamic logic \nto process logic which allows reasoning about the states entered during execution. Process logic is a \nform of branching time temporal logic. 4.3.2. Concurrency Our view of concurrent programs is that the \nnondeterminism represents different possibilities, only one which actually occurs. This suggests that \nthe linear time tempoval logic should be more appropriate for reasoning about concurrent programs. Althcmgh \nnappropriateness!t is not a provable property, we will give what we feel to be strong arguments that \nthis is indeed the case. Recall that the two basic properties one proves about concurrent programs --safety \nand liveness -\u00adare expressed by the assertions (2-1) and (2-3). It can be shown that each of those assertions \nin the linear time logic is strongly equivalent to the identical assertion in the branching time logic. \nHence , both logics can express the required correctness properties. The superiority of linear time logic \nmanifests itself only in the attempt to prove these properties. The correctness of a concurrent program \nusually depends upon the fairness properties assumed for scheduling the execution of operations in different \nprocesses. One type of fairness that is often assumed is the strong eventual fairness condition described \nin Section 3.1. This condition can be expressed in the temporal logic of linear time by the assertion \n(>O -ACTIVE) V + CHOSEN , where ACTIVE and CHOSEN represent appropriate predicates. lt follows from Theorem \n2 that this cannot be expressed in the logic of branching time. I.e., this assertion is not S-equivalent \nto any branching time assertion for a nontrivial set of states S . (If it were, then it would have to \nbe equivalent for the subset of states in which CHOSEN is trivially false, contradicting Theorem 2 for \nP . -ACTIVE .) This strongly suggests that the linear time logic is more appropriate than the branching \ntime logic. Another argument in favor of the linear time logic comes from our experience in proving liveness \nproperties of concurrent programs. We find ourselves continually using the following type of reasoning \nto prove that P eventually becomes true. We show that if P is always false during the program execution, \nthen the program will cause P bo become true. Hence, P cannot remain false forever, so it must eventually \nbecome true. This reasoning is based upon the hypothesis that either P is eventually true, or it is \nalways false. In other words, it assumes an axiom of the form ~P V Cl(-P) . in the linear time theory, \nthis assertion is M-valid for all models M . However, it is easy to construct a model for which the assertion \nis not M-valid in the branching time logic, so this reasoning cannot be used in branching time logic. \nThe logic of linear time corresponds to the way one tends to reason informally about concurrent program \nexecution. We have therefore found it easy to use the linear time logic to formalize the proof techniques \ndescribed in [9] and [14]. We do not know if it is always possible to prove the same properties of concurrent \nprogramg by reasoning within the branching time logic. However, our experience has convinced us that \neven if it is possible, the resulting proofs will not be as simple and natural as the ones using the \nlinear time logic. It might be argued that one should have a system powerful enough to subsume both the \nbranching and linear time logics. Such systems can be constructed. However, that approach is based upon \nthe misguided notion that the more expressive a system is, the better it is. We could get a very expressive \nsystem by simply reasoning about the underlying models. However, one uses temporal logic to hide the \nirrelevant details of the models. The ideal logic would be one in which we could express all the relevant \nproperties of the models and none of the irrelevant ones. We have not considered temporal logics having \nan explicit Inext instant!! operator, such as the one studied in [61, because we feel that they are too \nexpressive. Since what is relevant depends upon the application, different logics should be better for \ndifferent applications. We believe that the temporal logic of linear time (as generalized in Section \n6 has precisely the expressiveness that one needs for reasoning about concurrent programs. 5. THE THEOREMS \nOF TJH4PORAL LOGIC 5.1. Validitv An assertion is M-valid in a temporal logic if its interpretation is \ntrue for the model M . We are also interested in assertions whose interpretations are true for more than \njust a single model. We define an assertion A to be stronRlv valid if it is M-valid for all models M \n. We say that A is S-valid for a set S of states if it is M-valid for every model M having S as its \nset of states. A strongly valid assertion is one that is true for any interpretation of its atomic predicates. \nFor example, it is easy to check that the following assertion is strongly valid for the logics of both \nbranching and linear time. This assertion is a true statement about any model, regardless of how the \natomic predicates P and Q are interpreted in that model. Strongly valid assertions are the tautologies \nof temporal logic. Now consider the assertion 0 l a> l 3 0 a>O , where a > O and a > If! are atomic \nformulas. This assertion is not valid for all models, since there are models having states in which !!a \n> Ill is true and is false. However , such IIa > 0!1 models are of no interest if we are trying to reason \nabout a program variable named tat!. In this case, we are interested in S-validity, where S is the set \nof possible program states. The above assertion will be S-valid for such a set S of states in both the \nbranching and linear time theories. 5.2. Deductive Svstems Thus far, we have discussed the validity of \ntemporal logic assertions, but have said nothing about proving things. A temporal logic deductive system \nconsists of a formal method for deriving theorems. We write FA to denote that the assertion A is a theorem \nof a deductive system. A deductive system generally consists of a collection of axioms --assertions that \nare assumed to be theorems --and a collection of inference rules for deriving theorems from other theorems. \nFor example, the following might be taken as a temporal logic axiom (in either a branching or linear \ntime logic): FO(AAB)SOAAUB. (5-1) In this formula, A and B are formal parameters that represent any \nassertion. It may be viewed either as an infinite set of axioms --one for each choice of the assertions \nA and B ; or else as a single axiom --in which case there must be a rule of inference that permits one \nto obtain new theorems by substituting arbitrary assertions for A and B in (5-l). The following is an \nexample of an inference rule: If~A then ~aA . (5-2) Note that this is not the same as ~A = DA , which \nis not a valid theorem. Rule (5-2) is the !Inecessitation!l rule of modal logic. A deductive system is \nsaid to be valid if all its theorems are valid. It is said to be comulete if every valid assertion is \na theorem. There are three types of validity that are of interest: strong validity, S-validity and M-validity. \nThey lead to three classes of theorems: theorems true for all models, theorems true for all models with \na specific set of states, and theorems true for a model representing a particular program. 5.3. Tautologies \nA strongly valid assertion is one that is trivially true, in the sense that its truth does not depend \nin any way upon the model under consideration. We therefore call such an assertion a tautoloxv. A temporal \nlogic deductive system should be able to prove such trivial theorems, so it should contain a subcollection \nof axioms and rules of inference for proving tautologies. For example, it might contain the axiom (5-1) \nand the rule of inference (5-2). We now consider the deductive system formed by this subcollection of \naxioms and inference rules for deriving tautologies. A deductive system is called tautologicallv J@J@ \nif all of its theorems are tautologies. TO prove that a system is tautologically valid, one must prove \nthat each axiom is a tautology, and that each inference rule can generate only tautologies. This is a \nstraightforward task. A deductive system is said to be tautoloRicallv comolete if every tautology is \na theorem. Finding a complete logical system is more difficult than finding a valid one. in [18], Rescher \nand Urquhart give axioms and inference rules that are sufficient to prove every tautology for the tense \nlogics b and K1 , which are closely related to our temporal logics of branching time and 1 inear time, \nrespectively. lt should be possible to adapt their axioms and inference rules to obtain ones that are \nsufficient to ensure tautc)logical completeness for temporal logic systems of branching and linear time. \nHowever, such an exercise is beyond the 2 scope of this paper. 5.Q. S-Valid Formulas An S-valid assertion \nis one that is true when its atomic predicates are given the meanings implied by the set S of states. \nTo prove S-valid theorems, a deductive system must be able to prove tautologies, and it must also be \nable to derive theorems about predicates. The following theorem shows that this is sufficient, because \nany S-valid assertion can be derived from a tautology and an S-valid predicate. Questions of validity \nand completeness are reduced to the corresponding questions for tautologies and for predicates, To see \nthat the following theorem does what we claim, observe that by using the valid inference rule (5-2), \nsubstitution, and !J@JQ ponens (deducing *B from FA and ~A ~ B ), we can deduce FA from *P and ~UP 2A \n. fheorem~: For the logics of both branching and linear time: if S is a set of states and A is an S-valid \nassertion, then there exists an S-valid predicate P such that 0 P 3 A is strongly valid. w: Let PI! . \n. . , Pn be the predicates appearing in the assertion A . Define a boolean-valued function F of n boolean \narguments by letting F(al, . . . , an) equal true if and only if there is a state x in S such that x(Pi) \n. ai for all i . Such a function can always be expressed as a logical combination of its arguments. We \ncan then define P to be F(P1, . . . , pn) , where the latter expression is the predicate obtained in \nthe obvious way from the expression of F as a logical combination of its arguments. Note that for any \nstate x (not necessarily in S ): x(P) 23x1 ES: V i: x(Pi) =x (Pi). (5-3) This clearly implies that P \nis S-valid. To complete the proof, we must show that the assertion 0 P ~ A is M-valid for all models \nM . We prove this for the linear time logic. The proof for the branching time logic is very similar and \nis omitted. It follows from the definitions of Section 3.2 that for any model M and any sequence of states \ns : (DP ~ A)!(s) s (V n20: sn(P)) ~ A!(s) . (5-4) For anY model M = (S , ~) , define a new model M = \n(s , z ) by letting {XE s : x(P) = ttrueti} and z: : {SE2 :snESt for all n}. It follows easily from (5-4) \nand (3-12) that the assertion DP = A is M-valid if and only if it is M -valid. Moreover, this assertion \nis M -valid if and only if the following is true: VSEZ : AL (s) (5-5) Hence, we need only prove (5-5). \n2Such a completeness result is claimed by Pnueli in [151. However, he based his temporal logic of linear \ntime on the tense logic of branching b time (plus the identification of ~ and O), so it is difficult \nto evaluate his claim. Let $: S * S be any mapping such that for 0 every xEsf: +( X)(pi) X( Pi) for all \ni . It follows from (5-3) that such a mapping exists. We extend $ to be a mapping on sequences in the \nobvious way so that ~(s)n . l(sn) . We next define a model M!! = (S, ~ ) , where S is our original state \nspace, by letting 2 = {$(s) :Sez!}. Since the Pi are the only atomic predicates in the assertion A , \nit is easy to verify that for all s E ~ : At (s) s A~ ($(s)) . Since A is S-valid, it is M -valid. Hence, \nthis equality and (3-12) imply (5-5), completing our proof of the M-validity of 0 P ~ A for any model \nM.H 5.5. &#38;Validitv To prove theorems that are valid only for an individual model, there must be some \nway to prove properties of that model. For a temporal logic of programs, this means a way of proving \nproperties of a particular program. In practice, one begins with certain elementary theorems about a \nprogram, and then manipulates them to prove more complex theorems. For example, consider the following \nportion of a sequential program without gotos. y@r J:=l label: ... We should be able to deduce the following \ntheorem about this program: i (control at~) 3 (~= 1) . Given this type of elementary theorem, the axioms \nand deduct~~.. . ~~es for deriving tautologies and state valid theorems may be used to deduce more complex \ntheorems about the specific program. A deductive system for proving properties of programs must therefore \nhave a method for deducing these elementary properties. Such a method provides a formal definition of \nthe semantics of a programming language. For concurrent programs, we believe that the only types of elementary \nproperties that are needed are safety properties and liveness properties. 5.5.1. Safety Properties The \nusual method of deducing safety properties rests upon the following induction DrinciDle, where nextr \ndenotes the Itnext state!! relation for a program IT , and M(W) is the model defined by this program. \nFor any predicate P : If vx,yEs: ( x(P) A ynextwx ) ~y(P) then M(7T)~ P = IJP . Observe that the hypothesis \nis a statement about the model and the conclusion asserts the validity of a temporal logic assertion. \nThus, it leads to an inference rule for deducing temporal logic theorems from theorems about the underlying \nmodel. This induction principle is the basis of all the inductive methods that have been proposed for \nproving safety properties of programs -\u00adstarting from FloydJs original inductive assertion method for \nproving partial correctness [4]. To prove the safety property (2-1) of Section 2.2, one proves three \ntheorems: (i) ~INIT ~ P ; (ii) ~P ~ UP ; and (iii) j-P 3 GOOD--for some suitable predicate P . The first \nand last of these are theorems about predicates, and are usually easy to prove. The difficult part of \nconstructing a proof is choosing the appropriate predicate P so that (ii) can be proved from the induction \nprinciple. To apply this induction principle, we need a formal method of proving theorems about the model \ns next relation. This requires developing a formal semantics of the safety properties of the programming \nlanguage. We have recently developed a method of doing this for concurrent programs, which is described \nin [10]. It is based upon a method for proving formulas of the form {P} W {Q} , where P and Q are predicates \nand W is a program statement. This formula is interpreted to mean that if execution is begun anywhere \ninside T in a state such that P is true, then P will stay true while control remains in T , and Q will \nbe true if and when W terminates. We can then restate the induction principle as follows. For any predicate \nP : if {P} if {P} then M(W)!=P ~ 0 P. 5.5.2. Liveness Properties General methods for deducing elementary \nliveness properties have not yet been developed. Liveness properties for programs written in the simple \nflowchart language used in E9] and [15] can be proved by introducing thz following axiom for each flowchart \nbox of each process: b (control on arc leading into box) ~ ~ (control on one of the arcs leading from \nbox) . These axioms describe a system satisfying the eventual fairness properties described in Section \n3.1. (In these simple flowchart programs, a process is always active, so weak and strong eventual fairness \nare equivalent. Waiting is represented by a loop.) More sophisticated axioms are needed for concurrent \nprograms written in languages with explicit synchronization primitives. For example, consider programs \nusing a semaphore s . There are several types of liveness assumptions we can make for semaphore operations. \nA common assumption is that if the value of the semaphore s becomes positive infinitely often, then every \nprocess waiting on a P(s) operation must eventually complete that operation. (This is a strong eventual \nfairness assumption. ) It can be expressed in linear time logic by adding the following axiom for each \noccurrence of a semaphore operation P(s) . \\ [ (control at the P(s) operation) Acl+(s>o)l n  ~ (control \nafter the P(s) operation). Now consider a weaker form of semaphore which simply guarantees that if s \nbecomes positive, then eventually some pending P(s) operation must be executed. (This is weaker because \nit allows an individual process to wait forever if other processes are repeatedly executing P(s) operations. \n) To express the liveness property of such a semaphore, one must introduce a single, complicated axiom \nthat depends upon all the P(s) operations of the entire program. Further work ie needed in the formal \nspecification of liveness properties for synchronization primitives. One can, of course, define these \nprimitives in terms Of flowchart programs, tnus basing the semantics of the language on the semantics \nof flowchart programs. However, this does not solve the practical problem of proving the global liveness \nproperties that are achieved by these primitives; it merely pushes the problem back one level. 5.5.3. \nCompleteness We now consider the question of completeness -\u00adthe ability of a deductive system to prove \nall valid assertions about individual programs. We cannot in general expect this type of completeness, \nsince we can construct an assertion which states that the given program halts. instead, one can try to \nconstruct a deductive system for whicn a result analogous to Theorem 3 of Section 5.4 holds: any assertion \nthat is valid for a given program can be deduced from a tautology and a valid theorem about predicates. \nIf the system were tautologically complete, any incompleteness would then be due to an incompleteness \nin the system for reasoning about predicates. This concept of !frelative completeness was introduced \nby Cook [2] for sequential programs. Such completeness results have been obtained for particular types \nof assertions. For example, Owicki [131 and Flon and Suzuki [3] have shown that proving a valid safety \nproperty can be reduced to the problem of proving valid theorems about predicates. however, Owicicits \nproof requires the addition of !Tdummytf variables to tbe program, while Flon and Suzuki s result requires \nthe use of nonrecursive predicates. Apt [lj has shown that this is unavoidable: if dummy variables are \nnot allowed (other than for describing the state of program control), then nonrecursive predicates are \nrequired. Certain relative completeness results for liveness properties have also been obtained for models \nwith no fair scheduling requirements. Flon and Suzuki [31 showed that if the set of predicates is rich \nenough, then the problem of proving certain types of simple liveness properties can be reduced to the \nproblem of proving valid predicates. They considered programs written in a flowchart language in which \na waiting condition can be added to delay the execution of an operation. Pnueli [15] has proved a similar \nresult for more general liveness properties of simple flowchart programs. Although such relative completeness \nresults are of interest, they do not answer what we feel to be the most important question: is any deductive \npower lost by using temporal logic instead of reasoning directly about the underlying model? Let TL \nbe a deductive system for linear time temporal logic, and let ML be a deductive system for proving theorems \nabout the model M z (S, ~) . We say that TL is complete relative to ML if for every assertion A : if \nVSEZ: A?(s) is provable in ML , then A is provable in TL . (A similar definition can be made for a branching \ntime temporal logic.) No deductive power is lost by using the temporal logic system TL instead of reasoning \ndirectly about the model with ML if and only if TL is complete relative to ML . If we are allowed to \nintroduce dummy variables for reasoning about programs, then for any ML we can construct a temporal logic \ndeductive system TL which is complete relative to ML . This is done by adding a variable that records \na complete lltrace}~ of the programts eXeCUtiOn. Any reasoning in ML about execution sequences can be \nmirrored in TL by reasoriing about the value of this dummy variable. (This approach was used in [13].) \nIntroducing such a dummy variable obviously defeats the whole purpose of using temporal logic, since \nit brings us back to reasoning directly about the model. Given a system ML for reasoning about program \nexecution sequences, we would like to find a temporal logic deductive system TL that does not use dummy \nvariables and is complete relative to ML . We suspect that this is not always possible. For example, \nif a multiprocess program uses a short term fairness scheduling discipline, then the set of execution \nsequences 2 would satisfy an important scheduling property that cannot be expressed in our temporal logics, \nso reasoning about the model should enable one to prove properties that cannot be proved with a temporal \nlogic deductive system. However, we conjecture that one can construct such a relatively complete temporal \nlogic deductive system for a useful class of programs and an interesting class of systems ML . We regard \nthe study of this type of relative completeness to be a useful area for further research. 6. llAS LONG \nAs!! Thus far, we have restricted the discussion to temporal logics that use only the temporal operators \nJalways f (0) and eventually (~) . We now show that these operators cannot express certain important \nproperties of concurrent programs, and briefly describe a more general operator. We consider only the \nlinear time theory, since we are concerned with describing properties of concurrent programs. More general \noperators can also be defined for the branching time theory. In the linear time theory, ~ is equivalent \nto o, which is equivalent to -0-; so we have to consider only the single temporal operator n. The assertion \nUB represents the statement that B is Ialways!! true in the single (real) future. We can generalize this \nto an assertion A 0 B which asserts that B is true Ias long as the, assertion A remains true. Formally, \nthe meaning of A 0 B is defined by extending the interpretation defined in Section 3.2.2 as follows. \n(A D B)fl(s) = V nzO:[Vi~ {O, . . . ,n}: A~(si)] 3 B~(s+n) (6-1) A temporal logic using assertions \nconstructed with the dyadic operator 0 will be a called a generalized temporal logic, and the logic we \nhave been discussing up to now will be called ordinary temporal logic. It is easy to check the strong \nvalidity of the following equivalence, which shows that the generalized temporal logic is at least as \nexpressive as the ordinary one: true nBs 0 B. The following theorem shows that the generalized logic \nis actually more expressive than the ordinary one. Theorem 4: Fon anY set of states S J if p ! Q and \nR are any predicates such that none of the three predicates P AQ A R, -Q , -P A Q A -R is trivially false \nfor S , then the assertion P 2 (Q 0 R) is not S-equivalent to any ordinary temporal logic formula. Proof: \nThe idea is the same as for the proofs in Section 4.2: we construct two models M = (s, z) and M = (s, \n2 ) which cannot be distinguished by any ordinary temporal logic formula, such that the assertion P = \n(Q a R) is valid for one model and false for the other. Let a, b and be states such that a(P A QA R) \n, :(-Q) and C(-P A QA -R) are true. Let ~ consist of the following three infinite sequences: s[l] =a,b, \nc,a,b, c, . . . s[2]=b, c,a, b,c,a, . . . s[31 =c,a,b, c,a,b, . . . ; and let Z! consist of the following \nthree infinite sequences: st[l] 0 a, c, b,atc> b, ... s![2] =b, a, c, b, a, C, ... st[31 = c, b, a, C, \nb,a, ... . It is easy to verify that P~(QUR)is M-valid but is not M -valid. We now prove that any assertion \nconstructed using predicates, logical connective, and the unary operator 0 cannot be valid for one model \nand invalid for the other. To do this, we show that for any such assertion A , and each i z 1, 29 3 : \nA~(s[i])} = A~ (s![i]) . (6-2) The proof is by induction. It is obviouslY true f A is a predicate, since \nthe first element of the sequence s[il is the same as the first element of the sequence s![il . It is \neasy to see that if (6-2) holds for a collection of assertions A , then it holds for any logical combination \nof those assertions. TO complete the proof, we need onlY show that if (6-2) holds for all i , then: (UA)~(s[i]) \na (UA)~ (s [i]) . But this follows easily from (3-1O). From (6-2).we conclude that any ordinary linear \ntime assertion A that is M-valid must also be M -valid, completing the proof. 11 Assertions of the form \nA 0 B can be used to express a more general class of safety properties. ,,first-come-first-served ~ \nOne such property is which can be expressed as follows: !if process p requests service befcre process \nq does, then process q cannot be served before process P . This is not a liveness property, since it \ndoes not state that any process eventually does get served. It is expressed formally by the assertion \nP.FIRST n (P.WAi TING 0 Q.NOT-SERVED), where the predicates are defined to have the following meanings. \nP.Fl?lS I : P is waiting for service and q is neither waiting for service nor being served. P.WAITING: \np is waiting for service. Q.NOT.SERVED: q is not being served. The above theorem shows that this assertion \n expresses a property that cannot be expressed with only the unary operator a. One can define a dual \nO tc the dyadic operator 0 as follows: AOBE -(-A 0 -B) . (This makes 0 and O duals in the same sense \nthat A and V are.) The assertion A O B represents the statement that B eventually becomes true. and it \nbecomes true before A does. This is equivalent to the following assertion: OB A (-B n -A) . We have thus \nfar found no need for the dyadic operator O. 7. CONCLUSION Temporal logic provides a very convenient \nlanguage for stating and proving proPerties of concurrent programs, and we believe that it will also \nprovide an important logical foundation for the semantics of concurrent programs. The linear time temporal \nlogic originally used by Pnueli in [15] is very ~imple, involving the addition of the single temporal \noperator 0 to ordinary logic. It allows one to hide many irrelevant concepts that appear in the ordinary \ncomputational models used to describe concurrent programs. We believe that when generalized as in Section \n6, it is adequate for expressing all the relevant properties of concurrent pro.&#38;ams, but more experience \nis needed before-we can be certain of this. We still do not know if a temporal logic deductive system \ncan prove all of the relevant properties that could be proved directly from the models. We have found \nthat when thinking informally about such concepts as thenceforth and Ieventually!l, most computer scientists \nseem to adopt the branching time theory. This is one reason for our interest in branching time logic. \nBranching time logic is important for studying nondeterministic programs, and comparing the two types \nof temporal logic has helped us to understand better the relationship between concurrency and nondeterminism. \n ACKNOWLEDGMENTS 17. V.R. Pratt. Process Logic: Preliminary Report . Proc. 6th Ann. ACM Symp. on Principles \nof We wish to thank Albert Meyer and David Harel Programming Languages, ACM, January, 1979, pp. for \ntheir critical comments on an earlier version 93-1oo. of this paper. We also benefited from numerous \ndiscussions with Susan Owicki. 18. N. Rescher and A. Urquhart. Tenmo ral Loxic. Springer-Verlag, New \nYork, 1971. REFERENCES 1. Krzystof R. Apt. Recursive Assertions and Parallel Progams, 2 October 1979. \n 2. Stephen A. Cook. Soundness and Completeness of an Axiom System for Program Verification. ~ ~. ComDut. \n1, 1 (February 1978), 70-90. 3. L. Flon and N. Suzuki. Consistent and Complete Proof Rules for the Total \nCorrectness of Parallel Programs. Proceedings of 19th Annual Symp. on Found, of Comp. Sci., IEEE, October, \n1978.  8. R. W. Floyd. Assigning Meanings to Programs. Proc. Symposium on Applied Math., Vol. 19, Amer. \nMath. Sot., 1967, pp. 19-32. 5. N. Francez and A. Pnueli. A Proof Method for Cyclic Programs. Proceedings \nof the 1976 International Conference on Parallel Processing, IEEE, 1976, pp. 235-245. 6. D. Gabbay, \nA.l?nueli, S. Shelah and Y. Stavi. Completeness Results for the Future Fragment of Temporal Logic.  \n-i. D. Harel and V, R. Pratt. Nondeterminism in Logics of Programs, Proceedings of a Symposium on Principles \nof Programming Languages, ACM-Sigplan, January, 1978. 8. David Harel. On the Total Correctness of Nondeterministic \nPrograms. RC 7691, IBM T.J. Watson Research Center, 1979. To appear in Theoretical ComDuter Science. \n 9. L. Lamport. Proving the Correctness of Multiprocess Programs. IEI%E Trans. Q Software Engineering \n%&#38;Z-S, 2 (March 1977), 125-143. 10. L, Lamport. The Hoare Logic of Concurrent  Programs. CSL-79, \nSRI International, October, 1978. 11, L. Lamport. A New Approach to Proving the Correctness of Multiprocess \nPrograms. AGkl-.. QQ Programming Lanzuas?es ~ Svstems 1, I (JuIY 1979), 84-97. 12. Z. Manna and R. Waldinger. \n1s Sometime Sometimes Better than lAlways ?. Comm. ACM 21, 2 (February 1978), 159-172.  13. S. Owicki. \nAxiomatic = Techniques m Parallel Proarams. Ph.D. Th., Cornell University, August 1975.  14. S. Owicki \nand D. Gries. An Axiomatic Proof Technique for Parallel Programs. A&#38;a Informatica ~, 4 ( 1976), 319-340. \n 15. A. Pnueli. The Temporal Logic of Programs.  18th Annual Symposium on the Foundations of Computer \nScience, IEEE, November, 1977. 16. V. R. Pratt. Semantical Considerations on Floyd-Hoare Logic. 17th \nSymposium on Foundations of Computer Science, IEEE, October, 1976.  \n\t\t\t", "proc_id": "567446", "abstract": "Pnueli [15] has recently introduced the idea of using temporal logic [18] as the logical basis for proving correctness properties of concurrent programs. This has permitted an elegant unifying formulation of previous proof methods. In this paper, we attempt to clarify the logical foundations of the application of temporal logic to concurrent programs. In doing so, we will also clarify the relation between concurrency and nondeterminism, and identify some problems for further research.In this paper, we consider logics containing the temporal operators \"henceforth\" (or \"always\") and \"eventually\" (or \"sometime\"). We define the semantics of such a temporal logic in terms of an underlying model that abstracts the fundamental concepts common to almost all the models of computation which have been used. We are concerned mainly with the semantics of temporal logic, and will not discuss in any detail the actual rules for deducing theorems.We will describe two different temporal logics for reasoning about a computational model. The same formulas appear in both logics, but they are interpreted differently. The two interpretations correspond to two different ways of viewing time: as a continually branching set of possibilities, or as a single linear sequence of actual events. The temporal concepts of \"sometime\" and \"not never\" (\"not always not\") are equivalent in the theory of linear time, but not in the theory of branching time -- hence, our title. We will argue that the logic of linear time is better for reasoning about concurrent programs, and the logic of branching time is better for reasoning about nondeterministic programs.The logic of linear time was used by Pnueli in [15], while the logic of branching time seems to be the one used by most computer scientists for reasoning about temporal concepts. We have found this to cause some confusion among our colleagues, so one of our goals has been to clarify the formal foundations of Pnueli's work.The following section gives an intuitive discussion of temporal logic, and Section 3 formally defines the semantics of the two temporal logics. In Section 4, we prove that the two temporal logics are not equivalent, and discuss their differences. Section 5 discusses the problems of validity and completeness for the temporal logics. In Section 6, we show that there are some important properties of the computational model that cannot be expressed with the temporal operators \"henceforth\" and \"eventually\", and define more general operators.", "authors": [{"name": "Leslie Lamport", "author_profile_id": "81100244989", "affiliation": "SRI International", "person_id": "PP39034239", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567463", "year": "1980", "article_id": "567463", "conference": "POPL", "title": "Sometime is sometimes not never: on the temporal logic of programs", "url": "http://dl.acm.org/citation.cfm?id=567463"}