{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 The above applications: Securityr Reliabilityr Distributed Multiprocessing \nmotivate our logic which can express system correctness in situations of in\u00adcomplete information. The \nnext subsection defines games, which seem a robust model for computing syst=n which incom\u00adplete information \narises. 1.2 Game Definitions A game G consists of: 1) players {0,1,.. ., k} partitioned into dis\u00adjoint \nteams TlrT2 2) a set of positions Pi for each player i. 3) a next move relation + Pi (uPj) i j specifying \npossible next moves for each player i. A position is losing for a given player if he has no next move. \nA play is a sequence of moves II+ 111+ 112 +IIk 0 ... 1 2 k Games are assumed to be reasonable: the,posi \ntions, encoded as strings in a fixed alphabet, do not grow in size during plays; and the next move relation \nis in polynomial time. To introduce incomplete information to games, each position is partitioned into \na fixed number of elements called resources; each player i e {0,1,. . . ,k} is allowed to view and modify \nonly a restricted set visiblei of these resources. A strategy T of a player i is a mapping from plays \nof G ending in a position in Pi to a le9al next move for i. We require that strategies of player i be \nindependent of these resources in positions not in visiblei. The outcome problem for game G given initial \nposition II. is defined: Is therea strategy for each player of T1 such that in all resulting plays from \nII result in a losing position for a player of T2? (i~regardless of the moves by players of T2). A strategy \nT is Markov if T depends only on the last position of any play to derive the next move. Note that Markov \nstrate\u00adgies suffice in games of perfect information; where as in games of incomplete information non-Markov \nstrategies are required for players to infer por\u00adtions of positions and visible to them. (This will be \nan important consideration in our design of a multiprocess logic with incomplete information.) It is \ninteresting to note that the outcome of G is not effected if we consider team T2 to be an omniscient \n(able to view all portions Qf positions) single player, since the strategy Of T1 must SUC\u00adceed against \nall counter moves of T2. In the case of perfect information, T1 can similarly be con\u00adsidered a single \nplayer; thus all games of perfect information are essentially two-person-games. HOw\u00adever, in the general \ncase of incomplete information, the team T1 can not always be contracted to a a single player; the lack \nof complete information of players of T1 about each other s pOSitlOn iS essential to the game. Players \ncan only be con\u00adtracted to one if they view the same resources and are on the same team. In general, \nthe outcome of games of incomplete information with 3 or more players is undecidable [Peterson and Reif, \n19791 but the outcome of two player games is decidable ([Reif, 1979] shows this problem complete in doubly \nexponential time). Also in the case of hierarchical games: visible o ~ visiblel ~ . . . n visible k \nthe outcome is decidable for any number of players  {0,1 ,.. -,k}. 1.3 Games that Processors Play It \nis our thesis that games of incomplete in\u00adformation are good models for distributed multi\u00adprocessing. \nThis motivates the logic proposed in this paper. Games of perfect information have been pre\u00adviously used \nas models for computations. Note that nondeterminism is essentially a solitaire (l-person) game of perfect \ninformation. The notion of alter\u00adnation [Chandra, Kozen, Stockmeyer, 1979] , intro\u00adduced to model parallel \nsystems, corresponds essen\u00adtially to two-person games of perfect information. Recently, multi-player \nalternation has been proposed by [Peterson and Reif, 1979] and corres ponds essentially to multiple-person \ngames of in\u00adcomplete information. A restriction, called private alternation corresponds to multiple per\u00ad \nson hierarchical games. Devillers [1977] and, more recently, Ladner [1979] have observed that total correctness \nproper\u00ad ties of multiprocess systems can be formulated as games. For example, lockout can be stated: \nFrom some initial state of the system, can processes 1,2 ,...,k conspire so that process O cannot reach \na given state? Devillers and Ladner only considered these total correctness properties in situations \nof perfect information and from our previous discussion of games of perfect information, we can always \nreduce such games to 2-processor problems. In this paper we consider the more general case when each \nprocess has only incomplete information about the state and inemory of other processors. To model correctness \nproperties of a system of distributed processes by a game of incomplete information we of course equate \nprocesses ~ players of the games. A key point is that we make no lower bound assumptions about the computing \npower of indi\u00advidual processors. The positions of an induced game consisks of only certain fixed portions \nof the skate and memory of the processors; other portions of the memory of processors (most likely, the \nmajority of their memory if the processes are nontrivial) may not be contained in positions. As usual \nin games of incomplete information, each position is subdi\u00advided into portions visible to various processes \nand legal next moves for processes are determined only from visible portions of positions. However. strategies \nof processes may be arbitrarily complex, since we have assumed no lower bound on the size of the portion \nof processes memory not represented by positions. (Similarly, the relatively simple bidding rules of \na game of poker are dependent only on the fixed sets of chips and cards in the hands of the players or \non the table; however, the complexity of bid&#38;in~ strategies are bounded only by the intelligence \nor imagination of the players. A related issue occurs for the security applications in data base and \nope\u00ad rating systems discussed in Section 1.1; here the process controllers must determine a winning \nstra\u00adtegy (guaranteed security) irregardless of the com\u00ad puting power of the processors. Another possible \n(but somewhat too restrictive, we believe), model for distributed multiprocessing is Markov games; Here \nwe require that the positions of the induced game include all the state and memory of the processors. \nConsequently, process strategies are Markov (dependent only in the current position; see Section 1.2). \nThe outcome of games restricted to Markov strategies is decidable ([Peterson and Reif, 1979]). (Within \nsection 1.5 we provide an alternate Markov semantics for our proposed multi\u00ad process logic). 1.4 Previous \nLogics and Their Power of Encode Games We have seen that correctness properties of distributed multiprocess \nsystems can be posed as the outcome of games; it is natural therefore to consider the ability of previous \nprocess logics to succinctly encode games. More formally, for the logic L and a class of W games, we \nwish to determine if there is a log-space reduction from each game G E @7 and initial position II. to \na formula pG ~ of L such. that pG ~ is satis to o fiable iff the outcome of G from II. is a win. For \nsimplicity we consider only logics whose varia\u00ad bles are propositional. (a) Quantified Boolean Formulas \n(QBF) have only the power to succinctly encode the outcome of polyno\u00admial time bounded games of perfect \ninformation [Stockmeyer and Meyer, 1973]. Recently, [Peterson and Reif, 1979] have proposed a class \nof quantified boolean formulas with dependencies (DQBF) , which can succinctly encode games of incomplete \ninformation with polynomial time bounds. (b) Model Logics. Various model logics contain\u00ad ing a single \nmodel operator were shown by Ladner [19771 to have precisely the power to succinctly encode games of \nperfect information with polynomial time bounds. Variants of these logics have appeared in: (i) a temporal \nprocess logic [Pnueli, 1977] containing a model operator eventually , with an extended logic containing \nalso a model operator nexttime [Manna and Pnueli, 1979]. (ii) a logic for Data Bases with Incomplete \n Information [Lipski, 1979] (iii) a logic for knowledge inference [McCarthy, et al., 1978]. Although \nthese last two logics involve incomplete or hidden information, they seem much to weak for process logics \nsince they can not succinctly encode even two-person games of incomplete information. Pnueli s model \noperator eventually seems essential to any process logic and a similar model operator in our logic MPL \nand Pratt s. Pnueli has observed that his temporal logic is inherently endogenous; a single program must \nbe provided to the logic via some fixed semantics; where as the follow\u00ad ing dynamic logics (and ours) \nare exogenous; various programs are provided within the formulas of the logic rather than by a fixed \nsemantics. (c) Dynamic Logics. Pratt s dynamic logic [Pratt 1976] features model operators which contain \npro\u00ad grams; a thorough investigation of this logic ap\u00ad pears in [Harel, 1979]. The propositional dynamic \nlogic (PDL) was shown by [Fischer and Ladner, 1979] to succinctly encode games of perfect information \n(thus PDL can in theory express correctness proper\u00ad ties of multiprocessed systems with perfect infor\u00ad \nmation, as well as correctness properties of the nondeterministic (single process) systems for which \nPDL was intended to express) . The process logic recently proposed by Pratt [1979a] is a propositional \ndynamic logic with model operators ~ ( afterwards ), ~ ( durin9 ) , J_ ( preserves ) which we generalized \nin our proposed logic MPL. (Pratt s ~ ( throughout ) may be defined in terms of ~.) Parikh [1978] has \nalso proposed a powerful logic L-which allows quantification over sequences. In summary we note that \nno previous process logic can directly express incomplete information, which we find is a key element \nof distributed multi\u00ad processing. Furthermore, the previous model logics incorporating incomplete information \nfeatured only a very restricted class of model operators and can not succinctly encode even decidable \nclasses of games of incomplete information. 1.5 Innovative Features of our Logic MPL Although the syntax \nof our logic MPL is essen\u00adtially that of the process logic of Pratt [1979a], the semantics of our logic \nis unique in the inclu\u00adsion of incomplete information. (We present only the innovative features of our \nlogic here; a formal definition of our process logic is given in Section 2.) The programs found within \nmodalities in our logic are called actors. w actor A is basic if it consists of an indivisible program \nfragment. To include incomplete information, each basic actor A is allowed to view and modify the values \nof only a restricted set of visible propositional variables. Furthermore, we subdivide each state into \nstate elements and restrict each basic actor to view and modify only certain of these state elements. \nThus, in general, each state contains elements public to all basic actors, certain state elements visible \nonly to restricted sets of basic actors, and also state elements private to individ\u00adual basic actors. \nThe semantics of a basic actor A are to extend a trajectory T (a sequence of previous states) to a new \ntrajectory T = T-s consisting of T fOl\u00ad lowed by a new state s. A pair (T,T ) is an action.t We require \nthat actions of basic actors =ependent of those portions of the old trajec\u00adtory not visible to basic \nactor A; furthermore, the new state s may differ from the previous state only on those portions of s \nvisible to A. 1 In the case of perfect ~nformation and Al = Q,As a consequence of these semantic restric\u00ad~ \n&#38;, ~, are identical to the our model operators tions, relative to each basic actor A there is an \nT@@ equivalence relation over trajectories which A can not distinguish. model operators of Pratt s process \nlogic: J, L The induced computation tree con\u00ad~ respectively. tains nodes indistinguishable by various \nbasic actors; as a consequence this semantics of incom\u00ad1.6 Applications of MPLplete information is not \ndirectly expressable in  previous process logics, even in L-of Parikh Here we sketch some general domains \nof applica\u00ad[1978] . tions for MPL. Actors (the programs of our logic) are con\u00ad (a) Various Synchronization \nprimitives: structed from basic actors by sequencing (0;$) , (i) Boolean Semaphoresnondeterministic choice \n(al~) , nondeterministic looping (a*), and parallel execution (al\\(3). ~-MPL can be viewed as a natural \nlogic mulas are constructed from propositional variables,, for multiprocessing with shared variables \nas syn\u00adlogical connective, and model expressions contain-chornization primitives (these shared variables \ng,&#38; _y+ ing operators are the propositional variables of MPL formulas viewed commonly by various \nbasic actors). Given an actor a, let do(a) be the basic actors of a. The &#38;O(a) are considered to \nbe (ii) Synchronization by Communication players in a game, with the legal next-moves re-MPL can also \neasily describe total cor\u00adstricted by a considered actions of the &#38;o(a) , rectness properties of \na multiprocess language and plays corresponding to trajectories. A parti-with communication primitives \nsend and receiver  tioning til, @Z2 of u@o(a) are considered teams of such as described in [Hoar, 1978]. \nthe game. We assume a set C of communication Given a formula p channels; each channel Cec allows coxmnunica \ntion between two fixed processes transmitter(c), a ~ p denotes team AZl have receiver(c) &#38; {0,1,. \n..,k}. The state of each channel c &#38; C is either empty or full, and a full channel c contains value \nV(c) over a fixed, finite domain. program statement send(c,v) a strategy yielding only trajectories where \np holds afterwards (i.e., p must hold on the last is executed by process transmitter(c) only if c state \nof all trajectories, irregardless of the actions of team 42). is initially empty; and innnediately afterward \nc is full, with value v. Program statement &#38; X+receive(c) is executed by process receiver(c) p denotes \nteam Al have a Al only if c is initially full; X is set to the current value V(c), and immediately afterward \nc a strategy yielding pnly trajectories during which is empty. p holds somewhere (i.e., p holds on some \nstate of all (Note that these semantics require a trajectories). handshake between transmitter and receiver; \nno queueing of messages is allowed.) a ~ p denotes team Al have a &#38;z~ Programs including these \ncommunication primitives send and receive can be translated to strategy yielding trajectories which \npreserve p programs with only shared variables as primitives (i.e., once p holds on a given state of \na trajec\u00ad (thus their total correctness properties can be tory, p holds on all later states). described \nin MPL by introducing for each c E C a set of propositional variables encoding the value of C; these \nvariables are viewed only by the transmitter and receiver of c. The program statements, X+receive(c) \nand send(c,v) can then ----..- ---be substituted by equivalent program segments containing the introduced \nvariables.) iNote also that the semantics of a basic program of Pratt s process logic (which corresponds \nto a basic  (b) Local vs. Distributed Control actor of our logic MPL) is a mapping from the cur- An \nMPL actor a containing no instance ofrent state (rather than from the entire old trajec\u00ad tory as in \nour logic) to a new trajecton. It is the interweaving operator II, corresponds to the case of a set of \nlocal processes sequentially execut\u00adpossible to similarly restrict the semantics of our ing a single \nprogram. logic. In Markov semantics, we require the actions of basic actors to be dependent only on the \nfinal The interweaving operator I I (introduced also state of the trajectory. The resulting logic is \nto PDL by [Abrahamson and Fischer, 1978]*) allows able only to describe Markov games (where players can \nonly remember the current position and cannot infer about the private positions of their oppo\u00adnents from \nprevious plays; see section 1.3) . As we have noted, this Markov semantics is applicable to *we view \nour use of the interweaving operator as multiprocessing with incomplete information only if essentially \nonly a syntactic device; any formula p we assume the propositional variables of the logic of M!? can \nbe substituted by an equivalent formula encode all the memory of the processes; this assump-of MF with \nno instance of I I , by addition of P tion seems reasonable only in the case of very Boolean variables \nas described in Abrahamson and simple processes. Fischer [1978]. for distributed control. For example, \nin a distrib\u00aduted multiprocess system where each process i e {O, . . ..k} executes a distinct program \nai (an actor), then O\\lall!o..l]uk denotes their parallel execution. (c) Multiprocess Games We noted \nearlier that multiprocess correct\u00adness properties could be formulated as games of incomplete information. \nMPL formulas have the power to directly and succinctly express such games. This is proved in section \n3; we give some examples below. Consider a distributed multiprocess system with processor 0,1,... ,k \nand corresponding programs (actors) ao,a, ,...,ak as above-We assume for each i E {0,1 ,...,E] all the \nbasic actors of ai view the same set of propositional variables; (thus by the discussion in Section 1.2 \nthe basic actors of O. can be coalessed to a singular player i in OU$ multiprocess game) . We consider \nprocess O to be distinguished, say a controller or scheduler. Our multiprocess games will have teams \nT1 = {1,. ..,k] and T2 = {01 . Letdl be the basic actors Of al,..., IXk and &#38;2 be the basic actors \nof ao. Also let PO be a formula which holds precisely at the initial state of the multiprocess system, \nand let q be a formula. (a) Total correctness: The formula expresses that process O can guarantee that \nthe correctness property q holds on termination. (b) Accessibility: The formula express that 1,...k \ncan conspire to guarantee that q is accessible (eventually holds). (For example, if q holds unless process \no is in a dis\u00adtinguished state, the above formula expresses gua\u00adranteed lockout of process O from this \nstate,) (C) Avoidance: The formula lqApoA (aollal.. . I I ak) ~-(Po+true) V 1 q 092 expresses that process \nO can guarantee that formula q never holds. (For example, the above formula can express lockout avoidance \nby process O.) 2. Formal Definition of &#38;fpL The distinguishing features of our logic were informally \npresented in the Introduction; we air, here for a rigorous definition.  2.1 The Syntax. We recursively \ndefine a set O={p,q, . . . } of~OI%?UZaS and a set d={a,(3r ...} of actors. (These actors are similar \nto the pro\u00adgrams of previous process logics of [Pratt, 1979a] and [Abrahamson and Fischer, 1979]; although \nas noted in Section 1.6 our tactors,, have a somewhat more powerful semantics.) For our basis we assume \na set 00 ~ o of basic formulas which are simply prepositional variables P,Q,..: . ALSO, we assume a set \nof basic aetorw do ~d which are symbols A,B,... . There is a distinguished nu~l aetop OEA O. Let ~,~ \nbe asters, let p,q be fomulas and let Al be a set of basic actors of a. Induc\u00adtively, we may (i) apply \nZogieaZ eonnectives 1( negation! ) and A( conjunctionlr) to construct formulas TP and pAq. (ii) apply \npPOgYtun COYZstYW?ts;( sequencing,,) I ( nondeterministic Choicett) , * (t,nondeteministic looping \n), II ( parallel execution ), ?( test ) to construct the actors (a;8), (alB), (a*), (131/(3), p? (p \nmust be propositional.) (iii) apply modal operators ~~ ( after ), ) < ( preserves ) tolconstruct the \n~r::ing ) -%; cldp, aAp, .lP. &#38;l 41 Ail1 (Informally, we augment our syntax with booleon connective \nV,+r++ defined as usual from ~ and A) . We associate with each basic actor A~~o a ~xed et isibleA ~ \n00 efining hose basic fOrmulas whose value A may view. (We assume that for each ~ C ~o, there is an infinity \nof AEdo such that vis~ble @,.) = A  2.2 A Kripki-Like Semantics. A model d for MPL consists of 4? (i) \na set S of states, (ii) a ~~. l=d C S4 X @o providing  basic facts; denot~s proposi ional variable \nPe@o holds in state SW J. (iii) For each basic actor A~~o, a relation d% .AZXSM MS, ~cs providing basic \nact{cxzs; s ~ denotes that basic actor A may take state s into state s . (We will drop the superscript \n.4 for a fixed model M. ) Let visible be those basic facts s ~ P (iii) If a = (~11~2) then such that \nP Evis~ble (intuitively, visible are those basic fact$ visible to basic actor A in state s ) -Likewise, \nlet invisibles(s) be those basic facts s~P such that P$?vlslble A We require for any model Al that if \nS.+st is a basic action then invisible = invisible (thus basic actions of A only modify those portions \nof states visible to A) . Let a trajectory C be a finite sequence of states in S (in Section 2.3 we extend \nour semantics to allow for infinite trajectories). Let ~(S) be the set of all such trajectories. Give \na trajectory T~r(S)r let visible be the sequence derived from T by (a) substituting visible in place \nof each sin T. (b) substituting a single element x for maximal substrings of identical elements X,x, \n. . ..x.  Intuitively by (a), visible is that portion of the basic facts associated with trajectory \nwhich basic vector A may view, and by (b) we re\u00ad quire that A be oblivious to modifications to basic \nfacts not visible to A. Let a stPat@gy of basic actor A~#O be a partial mapping O:r(S) +r(s) such that \n(a) for each trajectory T in the domain of 0, such that T ends in some state SES, g~u(r). (b) If r is \nalso in the domain of o and visible = visible , then visibleA(O(T )) = visibleA(O(T)). We consider a \nset of basic actors dr@ O a tGmm . A tavn stpategj a of .+ is a r+l~tion consisting of a union of strategies \nfor each AC .&#38;l. A team strategy a restriets the bas<e act-ions available to the members of All, \nas follows. For each basic actor AE&#38;l, let s~e iff , (s ~ s and Af~) or ((s,s )CU and A~@tl) (Thus \nthe actions of basic actors not in &#38;l are not restricted.) Given this fixed team strategy O for Al \n the actions of actors aE&#38; are defined by the relation ~~ r(s) xr(s). , (i) If U is a basic actor \nA, then T ~T iff T ends in state S, T1 =T.s and J s = fS(T) (ii) If a=~l;~2 then ~ = ----+ cOm\u00ad, E lro \nposed with ~.   T7?=B1,5 up (iv) If a = (B*) then ~ is the re\u00adflexive, transition closure of *. (v) \nIf a = P? then T= iff Tl=p is a basic action. ., (The semantics of a = (611162),can be defined from the \nabove by adding Boolean variables to the expres\u00adsions, see [Abrahamson and Fischer, 19791.) Note that \nif T~ T then t is a prefix of T . We wish now to extend ~ to a relation c r(S) x@ giving ~acts about \nall formulas. For each propositional variable PEOO, let T~P iff s~P, where s is the last state T. T -P \niff not (T ~fp) . PT pAq iff (T ~ P) and (T ~ q). Finally, we define the semantics of the modal 3 team \nstrategy 0 for Al with T ~P for all T Er(s) such that T~T . r 3 team strategy O for &#38;l such that \nVT 6r(S) T!#<T, with T~ T r wehave T ~p for some , (< denotes the (nonstrict) prefix relation). Let \n-f\u00ad T~Cl~piff (-) 1 3 team strategy o of &#38; l such that v T E r(S) with T= T , t if T ~p then T \n*P fOr T ~T < T . Let a formula pE@ be Sat tsfiabb if there exists a model &#38;l with state s E s= ~ \nsuch that (s) l=~p. 3. En~Oding Games of Incomplete Information intO MPL Formulae. The complexity of \nsatisfiability of classes of MPL formulas is related here to the complexity of the outcome of various \nclasses of games of incom\u00adplete information considered in [Reif, 1979] and [Peterson and Reif, 1979]. \n3,1 The Visibility Structure of Games and Formulas of MPL Let G be a game (see the game definitions of \nSection 1.2) with players {O,lr. ..rk} and each player i e{O,l, . . ..k) allowed to view just the resources \nof the set visiblei. We assume each re\u00adsource takes a value from a finite domain of constant size. Let \nthe visibility structure Z of G be the directed bipartite graph with vertices consisting of (i) minimal \nsets of players with the same visible resources (ii) minimal sets of resources of G which are viewed \nby the same players. For each vertex x of type (i) , let the edges departing x enter precisely the resources \nviewed by players of X and let there be no other edges. Let p be a formula of MPL. The visibility structure \n of p is defined as in a game with the basic actors of p corresponding to players and the propositional \nvariables of p corresp=to the resources of a We also introduce an additional omniscientgame. player which \ncan view all resources. In Section 1.2 we noted various restrictions on the visibility structure which \nresults in games with decidable outcomes. It is interesting to re\u00adlate the outcome of games to the satisfiability \nof formuals of MPL with similar visibility structures. Theorem 1: For each game of G of incomplete infor\u00admation, \nand initial position Ho , we can construct in log-space a formula of f MPL with a visibility structure \nGr~o 0 isomorphic to that of G and such that G has positive outcome iff pG no is satis\u00adr fiable. To prove \nthis theorem, we need only consider computation games, in which the positions are con\u00ad figurations of \nthe multi-player alternation Turing machines of [Peterson and Reif, 1979]. we extend (to incomplete information) \na proof technique of [Fischer and Ladner, 1978] which provided a log\u00ad space reduction from the acceptance \nproblem of li\u00adnear-space bounded alternating Turing machines (or equivalently, games of perfect information) \nto the satisfiability of PDL formulas. 3.2 Computation Games A multiple-person alternating machine (see \nalso [Peterson and Reif, 1979]) is essentially a Turing Machine consisting of: (i) a state set Q with \ninitial state ql and aCCeptlng state qA E Q (ii) -tape named o and work tdL>es 1,.., to with type alphabet \n(iii) next move relatimc$ < (AtO+l x Q) defined asx (AtO+l x Q {left,right}tO+l) usual for multitape \nTuring Machines. Fix on input string u G An. We assume M is linear space bounded. Furthermore, M is considered \na game GM with (iv) Q partitioned into sets Qo,Q1,. ..,Qk correspondingly to players 0,1, . . . ,k (v) \nthe teams are T1 = {l, . ..rk} and . {0} 2 (vi) the positions are configurations of M, with initial \nposition the configuration with the input.tape containing u, all work tapes empty, and all heads on the \nleftmost cell of each tape. A position is losing for T~ if it contains the accepting state q. (vii) the \nlegal next moves of players are defined by 6, (viii) eacl. state q &#38; Q is considered a boo\u00adlean \nsequence of final length d and resources are negative integers -1,. ..d-d (indicating position of state) \nplus position integers O,...to indicating the types. M accepts ~ iff the outcome for G is a win for M \n1. is universal for a class of gamee A game Gu if (i) G c% and (ii) there is a log-space reduction fro$ \neach G Eff?dnd initial position II. of G, to initial position II of Gu and such-that G,HO the outcome \nof G from II is identical to the out\u00ad come of Gu from IIG ~ 0 f 0. If Vis a visibility structure and \n$?? is the v class of games with visibility structure w then we can show (using the results of [Peterson \nand Reif, 1979]) there is a computation game universal to%% 1 . Thus, we need only consider computation \ngames in the proof of Theorem 1. 3.3 Encoding Computation Games as Formulas of wL. Given a computation \ngame as in Section M 3.2, we now provide a log-space construction of a formula p of MpL with visibility \nstructure isomor\u00adphic to t K at of GM and such that p is satisfiable M iff M accepts u. We require propositional \nvariables Pu 1 < u < d (informally, PU is the boolean variable giving the Bth portion of a state ) O<t<t \nl<u<d, a&#38;A ct,u,a  O (informally, the head of the tape t is scanning the Uth cell which has contents \na ). We shall require basic actors O,fil, ..., ~ and we let visible to be those propositional Fi variables \nPu with -u E visiblei, plus those c such that t E visible, . t,ura 1 It is also useful to define s \n~ AP = Xu where q=(X1,. ..TXd) is a q L<u<d u state in Q (informally, the current state is q ) H (informally, \nthe head t,u = v Ct,u,a acA of the tape u is scanning cell u ) . TURNi~ V S (informally, it is player \nq qEQi i s turn to move! ) . We let PM Z PO A @~p1AP2AP3 where 1 B S (TtlRNo? *o) I . . . I (TtJRNk?~k) \nWe can define formulae PO,.. .,p3for which informally: ,,M i$ in its initial configuration P. IIthere \niS exactly one state anti one PI * symbol per cell = the cells not currently scanned by a type head are \nnot modified by a move of any player P2 Ilthe p~~yers mOVe correct~~ P3 = The formulae po,pl, and p2 \nare easy to construct; we given here cm~y p3 (which is the only nontrivial formula).   AAAA 3 ~ O<i<k \nq&#38;Qi ~EAtO+l SE{l), . . ..cn}tO+l . ( -lrA t\u00ad i,d T+ q ,a i d 1) (%=rq ,s ,fi) E 6 where /\\A r \nq o:t~to Dt = ~+ Htr 1$1 A ct,u~lia; V(Dt = right +lit ~ +1 ACt,ut+l,a~) t 4. Testing Satisfiability \nfor Formulas with a Hierarchical Visibility Structure Let G be a game of incomplete information with \nplayers 0,1, . . ..k. If ,. lslbleO visiblel ~ .. isiblek then G has a hierarchical visibility structure, \nand the outcome is decidable. We can show: Theorem 2. Satisfiability is decidable for the class of MPL \nformulae PO with a hierarchical visi\u00adbility structure: ~visible ~... visible vlslbleAk o-% for basic \nactors A ,A1, . ..r\\ of p (This corres\u00ad ponds to the. natura$! case where a single process, AO , spawns \na linear chain of processeS Al, . . . ,Ak and Ai knows everything about A j for i~j.) For simplicity, \nwe assume (a) P. contains no instance of the \\ \\ operator and no model operator but =! and (b) the basic \nactors in P. are partitioned into disjoint sets~, G@l where (i) do is a set of basic actors which can \nview all resources. (ii) the elements of #L have the same visible resources. Note that this visibility \nstructure is hierarchical and corresponds to a two person game. (These assump\u00adtions (a) and (b) are dropped \nin our full algorithm, but in the above simple situation our algorithm is considerably easier to understand. \n) We provide a brief sketch of our algorithm. We shall require the closure Cl(po) of formula P. (see \n[Fischer and Ladner, 1978]) which is the minimal set of formulas such that (i) p E Cl(po) (ii) all formula \nsubexpressions of elements of cl (p) are in cl(po)  (iii) For a~q E C1(PO) Al if a = 61;02 then ~1~ \nQ(B2~~) c .1 (PO) 1 ~ = (~llB2) then (62161) and if J if a = (6*) then S =! Qazlq &#38; Cl(po) c.%z~ \nThe Qp are new propositional variables which can be viewed by just those basic actors that can view all \npropositional variables in p. It can be easily verified that PM is satisfiable iff M accepts U. Thus \nwe have Theorem 1. D Let X={ X~Cl(po)lp Ex - 7ptix pAqsx+p, qcx pVqsx+pcx or q&#38;x (P?)# qsx and P \nEx 1 +qex (C+3)JPEX4 pcx 1 til We define an initial model ~. with Ix[(a) states S ~ X  (i.e., sequences \nof length IX] containing elements of x) (b) let S ~ S be a basic action of~iff (A 4P E S(i) for some \n41 not containing A, Al implies p c s (i) forl~i~lXl)  (c) let S= Pbe a basic fact iff  PEs(i) for \nall l~i~lxl . (Intuitively, each s E S contains elements s(i) E X which could be formulas that hold at \ns. In general the basic actors of d can not disting\u00ad uish which p e s(i) holds o: s, unless p c s(j) \nforalll~j~lXl ). We can show that if PO is satisfiable, then there is a substructure of~ that satisfies \npo. We now proceed as in Pratt s [1979a] algorithm for testing satisfiability of PDL formulas, repeatedly \ndeleting inconsistent states of S until conver\u00ad gence. (This phase of the algorithm is also similar to \nthe game tree labeling algorithms of [Chandra, Kozen, Stockmeyer, 1978], [Reif, 1979] for determi\u00ad ning \na winning strategy of a two-person game. In the resulting model A, there is some SES such that PO E s(i) \nfor is {1,... IXI} iff p. is satisfiable. In the case PO is a general formula of MPL with a hierarchical \nvisibility structure, we take the states s = Xlxlfl xl /kt times (when k is nun@er of basic actors A \nwith distinct visibleA) and the rest of the construction may be suitably generalized. 6. Conclusion 6.1 \nSummary We have (a) introduced a logic MPL for multi\u00adprocessing with incomplete information, (b) shown \nthat games of incomplete information may be succinc\u00adtly encoded into formulas of MPL with the same visi\u00ad \nbility st~cture, (c) developed an algorithm for testing satisfiability of formulas with a hierarchi\u00adcal \nvisibility structure.  6.2 Extensions to MPL We have attempted to define M!?L with as few as possible \nprogram constructs, logical operations and model operators, without sacrificing the expressi\u00adbility and \npower of the logic. Various extensions may be made, for example: (a) Syntatic Modifications. We could \nintroduce the while-loop and if-then-else program constructs as basic; as has been done previously in \nPDL. Another possible extension is to introduce message connnuni\u00adcation as the fundamental process synchronization \nprimitive; this is again actually only a syntactic modification as noted in Section 1.6.  (b) Infinite \nTrajectories. we can easily allow for trajectories which are initial sequences of states. Here we could \n(as in [Pratt, 1979a]) introduce a special abOrt state $2 from which no action may be taken. Failing \ntrajectories are those which contain Q; we require that a trajectory can only contain Q as the last state. \n(This restriction requires some tedious redefinition of the program constructs such as  (c) A First \nOrder Logic. MPL may be extended to allow quantification fo variables. We are consi\u00addering the dependency \nquantification of variables defined in [Peterson and Reif, 1979] since these restricted quantifications \nallow expression of stra\u00adtegies which are independent of given private variables.   6.3 Open Problems. \n(a) Harel [197912] has shown that the model ope\u00adrations _J, A , ~ of Pratt s process logic are independent \nand there is a further model opera\u00adtor independent of these; are the model operators -l,J-,~ similarly \nindependent? (b) Are there natural restrictions to visibility structures, besides hierarchical, for which \ngames and formulas of MPL are decidable? (c) Most importantly, provide a consistent and complete axiomization \nfor a decidable class of MPL formulas.  6.4 Acknowledgments We wish to thank Albert Meyer and David \nHarel for their careful reading and enlightening comments on a preliminary draft of this paper. Bibliography \nAbrahamson, K. and M.J. Fischer, Applications of Boolean Variables to Automata Theory and Dyna mic Logic, \n Computer Science Department, Uni\u00adversity of Washingtonr Seattle, May 1978. Chandra, A.K., D.C. Kozen, \nand L.J. Stockmeyer, Alternation , IBM Research Report RC 7489, Yorktown Heights, N.Y., January 1978. \nDevillers, R., Game Interpretation of the Deadlock Avoidance Problem, Communications of the ACM 20:10 \n(1977), pp. 741-745. Dobkinr D., A.K. Jonesr and R.J. Lipton, SeCUre Databases: Protection against User \nInterfer\u00adence, ACM Trans. on Database Systems 4:1 (1979), pp. 97-106. Fischer, M.J. and R.E. Ladner, \nPropositional Dyna\u00admic Logic of Regular Programs, Journal of Computer and System Sciences 18 (1979), \npp. 194-211. Harel, D., First-Order Dynamic Logic, Lecture Notes in Computer Science 68, Springer-Verlag, \nNew York, 1979. Harel, D., Two Results in Proces s Logic, Informa\u00adtion Processing Letters 8:4 (1979), \npp. 195\u00ad 198. Harel, D. and V-R. Pratt, Nondeterminism in Logics of Progrmw, Proceedings of the 5th ACM \nSympo\u00adsium on Principles of Programming Languages, Tucson, Arizona, January 1978. Hoare, C.A.R., Communicating \nSequential Processesr Communications of the ACM 21:8 (1978), pp. 666\u00ad 677. Ladner, R.E., The Computational \nComplexity of Prova\u00adbility in Systems of Modal Propositional Logic, SIAM Journal of Computing 6:3 (1977), \npp. 467\u00ad 480. Ladner, R.E., The Complexity of Problems in Systems of Conmmnicating Sequential Processes, \nllth ACM Symposium on Theory of Computing, April 1979 Lipski, W.r Jr., On Semantic Issues Connected \nwith Incomplete Information Data Bases, ACM Trans. on Database Systems, September 1979.  Manna, ,. Z. \n, and A. Pnueli, The Model Loqic of Pro\u00adgrams , Technical Reportr Computer Science Dept. , Stanford \nUniversity, 1979. McCarthy, J., M. Sate, T. Hayashi, and S. 19arashi, On the Model Theory of Knowledge, \nAI Memo 312, Computer Science Dept., Stanford Univer\u00adsity, April 1978. Parikhr R., A Decidability Result \nfor a Second Order Process Logic, Proceedings of the 19th IEEE Symposium on Foundations of Computer Science, \nAnn Arbor, Michigan, October 1978. Peterson, G.L., and J.H. Reif, Multiple-Person Alternation , 20th \nSymposium on Foundations of Computer Science, Puerto Rico, 1979. Pnueli, A. , The Temporal Logic of \nPrograms, 18th IEEE Symposium on Foundations of Computer Sci\u00adence, October 1977. Pratt, V.R., Semantical \nConsiderations on Floyd-Hoare Logic, Proceedings 17th IEEE Symposim on Foundations of Computer Science, \n1976. Pratt, V.R., Process Logic, Proceedings 6th ACM symposium on Principles of Progrming Lan\u00adguages, \nSan Antonio, Texas, JanuarY 197g- Pratt, V.R., Models of Program Logics, 12th FOCS, San Juan, Puerto \nRico, 1979. Reif, J.H., Universal Games of Incomplete Informa\u00adti on, llth ACM Symposim on Theory of Comput\u00ading, \nAtlanta, Georgia, 1979. Stockmeyer, L-J., and A-R. Meyer, word prOblems Requiring Exponential Time, \nProceedings 5th ACM Symposium on Theory of Computing (1973) , pp. 1-9. stockmeyer, L.J., and A.K. Chandra, \nProvably Diffi\u00adcult Combinatorial Games, SIAM Journal Of Com\u00adputing 8:2 (1979), PP. 151-173.  \n\t\t\t", "proc_id": "567446", "abstract": "A crucial property of distributed multiprocessing systems is the lack of complete information by any given process about the states of other processes. The contribution of this paper is a fundamental modal logic, MPL, for multiprocessing with incomplete information. (Section 1.5 gives an informal introduction to MPL; the formal definitions are in Section 2.)By way of this logic, we develop a solid (practical and theoretical) correspondence between distributed multiprocessing and multiplayer games of incomplete information.Fischer and Ladner, [1979] have shown a logspace reduction from the outcome problem for two person games of perfect information to satisfiability of formulas in their propositional dynamic logic (PDL). We provide in Section 3 a log-space reduction from the outcome problem for multiplayer games of incomplete information to satisfiability of formulas in our logic MPL. Although in general satisfiability in out logic is undecidable, the satisfiability problem of formulae with hierarchical visibility structure is shown decidable (using the methods for solving hierarchical games developed in Reif [1979] and Peterson and Reif [1979], and also the model theoretic techniques of Fischer and Ladner [1979] and Pratt [1979b]).At a more practical level, we argue that the game-like semantics of our logic provides a robust paradigm in which to view distributed multiprocessing problems. We apply our logic to describe total correctness properties of multi-process programs with shared variables as well as communicating processes with \"handshake\"-type message passing.", "authors": [{"name": "John H. Reif", "author_profile_id": "81100567232", "affiliation": "Harvard University, Cambridge, Mass.", "person_id": "PP14196622", "email_address": "", "orcid_id": ""}, {"name": "Gary L. Peterson", "author_profile_id": "81332520632", "affiliation": "University of Rochester, Rochester, New York", "person_id": "PP39046084", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567465", "year": "1980", "article_id": "567465", "conference": "POPL", "title": "A dynamic logic of multiprocessing with incomplete information", "url": "http://dl.acm.org/citation.cfm?id=567465"}