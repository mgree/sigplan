{"article_publication_date": "01-28-1980", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; \n1980 ACM 0-89791-011-7 $5.00 2. Partial Correctness, Termination, and Equivalence 2.1 Dcflnitions frotn \nfirst order logic. A type (or signafure) is a set of objects called sylnbo/s. Each symbol k either a \nfurrc[ion symbol or a predicate symbol and has an associated nonnegative integer ari(y. A st(it( S, consists \nof a type r(s), a domain D, and an assignment to each function (resp,, predicate) symbol in r(s) c)f \na function (resp., predicate) on D of the associated arity. (Variables are simply treated as zeroary \nfunction symbols.) The type of formula F, denoted T(F), is the set of function and predicate symbols \nappearing free in F. A formula F of the first order predicate calculus ~vith equality is defined to be \ntrue or false in a state s (such that 7(s) ~ T(F)) in the usual way; we write SI=F iff 1: is true in \nstate s. We write kF to indicate that F is v:llid, i.e., true in all states. We extend the class of first \norder formu]a< as folloWs: Let R denote some binary relation on state<, ancl let Fbeaoyformula. Then \n[R]Fis a formula andskl R]F iff t*F for fill t such that (s,t) c R. Also, <R>) i~, ii formula equivalent \nby definition to -T[R]~F. (This is just Pratt s notation for dynamic logic (cf. [Harel, 1978]). A relation \nR is tidy pro} iciing [R]F is equiva]eqt to ;I first order formula of predicate calculus with equ; tlity \nwhenever F is such a formula. [cf. Pratt, 1976] 2.2 Our results depend on the class of program schc]nes \nwe consider. The richer the class, the larger ihe semantics to be specified, and therefore our p~witi~re \nresults take their strongest form when we allow eten more powerful program schemes than are reasonably \nrealistic. We consider four classes of schemes which are listed indecreasing order of generality. a) \nAr$iirary schetrrcs are nondqterminiqtic, possibly infinite, flowcharts (finite, deterministic schcmcs \nare regarded as a special case) whose icsts m:ty be arbitrary first order formulas and }vhose b:l<ic \ninstructions consist of sitnple awignmenrs of the f~)rrn x := term , array a.wignmrerr[s of the more \ngenera] f ~jrlrl f(x) := term and random assign mcnfs of the form x := ? . (The random assignment x := \n? means sc 1 x to :uiy value in the domain (Cf. [liarel, 1978] ).) (b) An arbitr;iry scheme is rcc~lr.rjl,,{}~ \ncnutnerable if there is an effective procedure to gc~ler;ite the labels, boxes, aod ec!ges of the flo~vchart, \nVii rious weakening of recursively enumerable schemes are possible by disallowing array assignments, \nriin~]oln :issignments$ etc. (c) Effec[ive schenres are recursiwly enumerable schemes wil h open tests \n(i.e. tests consis[ ing of quantifier-free formulas of predicate calcu]us ~~-ith equality) and simple \nassignments only (i.e. no randonl or array assignments). (cf. [Friedman, 197 1]: [Bergstra, Tiuryn, Tucker, \n1979].) (d) A special case of effective schemes are I he familiar while-program schemes, with the following \nllYF\u00addescription:  <program>::= <simple assignment>]< program> ;<program>l if<open formuia>then<program> \nelse< progr:im>fil while <open formula> (10 <program> od. The type ~(a) of an arbitrary scheme a is the \nset of function find predicate symbols appearing in the instructions and tests of the scheme. 2.3 Definition \nIf a is an ~rbitrary scheme, then 1{(1 is the initial state -final state relation defined by K i.e. Ra \n= {(s,t)l t is :i state which is a possible res~ilt of performing a starting in state s). Let Ra(s) = \n{t] (s,t) e Ra]. When there can be no confu~icm, we will use a instead of Ra; e.g. we will say [a]F ilisttiad \nof [Ra]F. 2.4 Definition: Arbitrxry schemes a and b are equivalent iff Ra = RI; that is, they always \ntake an initi:il stall to equal sets of final st:ites. 2.5 Partial Correc[tress and Termination: A partial \ncorrectness (resp., teftninulion) asser{ion consists of a p:iir of formulas F,G and a program a, and \nis written J:{o}G (resj~., F(a)G). The assertion is frue iff F * ~R(,]G (resp., F * <R#3) is a valid \nformula. Thus F{a}( i is true iff, whenever sfate s sntisfies F and state t is a possible result of performing \na starting in state s, t hcn t satisfies G. Similarly, F(a)G is true iff, whenever s~F there exists a \nt such that (s,t) c Ra and t~-G. The par[iol correctness (resp., (erminatiorr) [Ilttory of a, deaote(i \nPC(a) (resp., T(a)) is {(F,G) I F,G are first order formukis of prcdic:~te caicuius with equality and \nF{a}G (resp., F(a) CT) is true] For any type r, we let PC ~(u) cienote {(F,G) ~ PC(a) [ T(F) c T and \n7(G) c r]. We observe triviaily that 2.6 Lemma. If a and b are equivalent schemes, then PC(a) = PC(b) \nand T(a) = T(b). 2.7 Lemma [Pratt, 1976] If a is a finite lool)-free scheme, then u is tidy. kforeover, \nif a has only simpic assignments and F is quantifier-free, t hcn [~/]1: is equivalent to a quantifier-free \nformula. 2.8 Dejitri/ion If ui, i = 1, 2, 3 ... is a set of sch~[lles, then Uiai denotes the scheme which \nis the ncmdetervninistic union of the aj i.e., RUiai is equal to UR1 Qi It is now easy to see that 2.9 \nLmtna Any (recursively enumerable) wheme (I is equiwdent to a (recursively enumerable) union of filiite, \nloop-free (and hence, by Lemma 2.7, tidy) schemes, ~ilch that eiich finite scheme uses only the instructions \ni)lld tests which appear in a. Moreover, if a is recursit ely enumerable, we can effectively generate \nthe flrlite schemes from (an index for) a. 3. Axiomatic Definitions of Language  3.1 The axionmtic \ndefinitions of programming Ianf!u;!$es proposed in the literature consist of systems for deriving i]sscrtklls \nahout classes of program schemes involving subrou.tirw calls with parmneter passing to other schemes. \nIn nearly all cases (kmgutrges with a poinlcr d:it:iure t}pe  fin exception; cf. [.lanssen and win Emdc \nBoas, 1977]), the programs iire equivalent to arbitrary schemes of various types. We interpret the claim \nthat such an :islmn SJstem rkfims the programming language sernani ics as meilning that enough assertions \nxre provable to distinguish between inequivalent programs. (By Lemm:! 2.6, we cannot expect to make distinctions \namong equivalent programs using partial correctness or termination assertions) More exactly, \\ve offer \nthe following Definition Let .7) be a set of trxle portial crwrcctness assertions, and ./ bc a set of \narhitr:wy schenres. Then / defillpsr/ providihg that for 011 inequivalent schemes a, b e . J there is \nan assertion in . ~ about one of a or b which k not true of the other. That k, let PC .z(~) = {(F,G) \nI F{a}G e :? ]. Then (PC ,/{a) -PC(b)) U (PC ,7X6) -PC(a)) ~ ~.~ 3.2 Exatnpk Let A OF be the program \nwhich halts without ch:lnying unything, and let a. be the following program scheme: if (y #x vz# f(x)) \nthen A OP else while y # z do z :==f(f(z)); y := f(Y) od; y := X:z := f(x) fi It is easy to see that \nam when it halts, behavm like A OP, n{tmely, it has no effect. However, under some interpretations a. \ndoes not halt, for exmnple if x = y 0, z = 1, and f is the successor function on the integers, so NOP \nand Co have different meanings, Trrke :? to be the set of all true quan!ificr-free partial correctness \nassertions and .1 to be the set of all true partial correctness assertions. Then it is easy to show that \n(see Appendix A). Thus it follows that quantifier-free, partial correctness assertions do nof define \nwhile-program schemes, On the other hand, if we HI1OW quantifiers we can distinguish a. and ATOP. Indeed, \nthe i>nir of formulas Vz(f(z) # x) A VtVy(t # y =$ f(t) # f(y)) and w*w  is in PC ,.l (ao) but not in \nPC,; (A OP), as the reitfler may verify. In fact, Theorem 4,1 shows that .~ defines the semantics of \nwhile-programs. 4. Defining Semantics By Partial Correctness Assertions In this Section we prove our \nmain results :ilmut partial correctness assertions. We show in Thcorenl 4.1 that despite the genervil \ninadequacies of first older predicate calculus, the set of true partial correctness assertions defines \nthe semantics of recursively enurncr:iblc schemes. In the Them-em 4.5 we show thilt for cftcct ivc schemes, \nwe c:m find a recursively enumerable set of I irst order p[irti;il correctness assertions which v ill \ndefirw the semantics. 4.1 T/fcorcm: For recursively enumerable schemes h, c of finite type, PC(b) = PC(c) \nimplies b and c are equiv;ilent. The proof of Theorem 4.1 rests on two Iemlrms. The first is purely \nmodel theoretic, and reveals th:lt in ii certain sense first-order formulas are closed under iltfinite \nrecursively enumerable conjunctions. (This lemma, discovered independently by the authors, turns out \nto be refinement of a classical result of Kleene.3) (See ~Kieene, 1952].) 4.2 Lemma Let FO, F,, .... \nbe any recursively enumerable sequence of first order formulas of finite t} pe r. Then one can effectively \nconstruct a first order formula G such that Moreover, if s t= [c]H and s has an infinite dom:iin, Lemma \n4.2(b) says we can find an expansion of s to s such that s ~-=G. Then (G,H) c (PC(C) -PC(b)). b) if s \nis a state with infinite domain and s ~= Al~i, serve to distinguish the partial correctness theories \nof b If s has finite domain our task is even e:isier. I orand c. The only difficulty comes from the fact \nthat [c]H if T = 7(b) u 7(c) then we can find a first order forlilulamay not be equivalent to a first \norder formula. ISf)~ such that s = 1S0s iff s 1~ is isomorphic to SI~. (So s t=ISOs iff s and s look \nIhe same as far as b and c :ireHowe\\ er, by Lemmas 2.7 and 2.9, c is equivalent to l-rici, where each \nci is tidy. Hence [c]H is equivalent concerned.) Then clearly we have (1S0s, --Mot, c PC(c) to Ai[ci]il. \nTaking Fi to be [~i]H (which is first orcier -PC(b), since (s, t) E Rb -RC 0 since ci is tidy), by Lemma \n4.2(a) we can effectively 4.4 Remark: The hyimtheses that b, c be recursivelyconstruct a first order \nG such that eni]merable and of finite type are both necessary, ;is we silow in Api]endix C. 0 * G == \n[c]H then there is an expansion t s of s1, (the restriction of s Theorem 4.1 invoives the set of :iii \ntrue imrt ial correctness assertions, which is not recursively enumerable to type 7) such that s *G. \neven in the the cme of while-program schemes (in I:lct, it is II 0 comi]lete, cf. [Harel, Meyer, Pratt; \n1977]), I-his The itiea of the proof is to introduce new s}-rnimls ie:i~es %pen the question of whether \nsome, necewr ily +, . and include in G axioms involving these new sytni.)ols recursively enumerable set \nof parti:il correctness :isscrt ions which define a (possibly nonstandard) copy of the rin.r; of cierivable \nfrom an effective axiom system can cicfine integers. Then we implicitly define a predicate T Ivhich semantics. \nWith a slight restriction on the c.l:~ss of acts like a truth predicate, and make sure (the C~tidel recursively \nenumerable schemes, for exampie restrictin~ to number of) each Fi stitisfies T. The proof is deferreci \nto effective schemes will suffice, we can give an :iffirmative Api>endix B. answer. 4.3 Lemma If b and \nc are arbitrary schemes of finite &#38;5 Theorem: There is a recursively enumerable set of type and such \nth:it Rb -Rc # Z, then there is n first first order i)artis! correctness assertions Y# which {icfines \norder formula H such that [c]H A ~[b]H is satisfiable. the semantics of effective schemes and, a fortiori, \nof while. program schemes. Prooj Suppose (s,t) E Rb -RC Let xl, xl,, f,, .... fln be the free variables \nand functions ment ioncci Proof All the essential ideas of this proof fire in b and c. Choose fresh \nvariables and functions already in the proof of Theorem 4.1. For any pro~ra III c x, , .... X1l , f] \n, .... fin and define a state s in which x}, .... and sentence H, let GH,C be the formula frotn the prtmf \nXn, fl, .... fI1l have the same respective values as they cio of Theorem 4.1 such that in s, while x, \n, .... Xn , f] , .... fin have the same respective viilues they do in t. Let H be the formula (where \n:i.giiin c is equivalent to Uici$ and each Ci is tidy.) l(XI = XI A ~~~A ~n= Xn A hn cji,c {c}H is always \ntrue, Vz(fl (z) = f] (z) A... A fro(z) = fro (z)) T:ike Y= {GH,C {c}H I H is a first orxier formui:i, \nThen s = [c]H A +b]H, as the reader may verify. u c is an effective schelne]. Then P is recursively enumerable, \nsince the proof of Lemma 4.2 actli;illy shows Proof of 4.2: Suppose b and c are inequi~:i]ent. how to \nconstruct GH,C effectively from H ~ind c. Without loss of generality we may assume R~ -Rc + ;j. Moreover, \n:7) defines the semmrtics of effective schemes. To see this suppose b and c are inequi~w]ent, and By \nLemma 4.3, we have a formula H and an s such th:lt (s,t) < R/j -RC W ithout loss of generality wc can \nassimre s has an infinite domain. (Otherwise t:ike s ;Z s S K [c]H A Y[6]H. so that s has an infinite \ndomain. Then there is a corresponding (s , t ) e Rb -RC The cruci:il point here Notice that this is \nequiwdent to the :issertion t ilat \u00adis that since b and c are effective they only h:ive ry)en [c]H{6}H \nis false. Of course [c]H{c}H is trivi~iliy true for tests and simple assignments, so adding new eiements \nICI ;i rrll c nrrd H. Thils the pair of predicates ([r-]H,H) \\vill domain will not affect the trtith \nvalue of the tests). Take the H from Lemma 4.3 such that s i= [c]H A -+b]H. Then the Proof of Theorem \n4.1 shows 4.6 Remwk WC can extend Theorem 4.s to hirger wbclasscs of recursive y enumerable schemes, \nin p:irticulw to while-program schemes with random and array trssignments as well m first order tests \nallowed. A technical complication arises with the introduction of first order tests and random assignments. \n.Namely, we can no longer assume, iis we did above, that we can find an s with in i~lfini(e domain such \nthat s &#38; -[b]H A [c]H. The details are left to Appendix D. u 1[] Theorem 4.1 wc showed th:it if h \nand c ;Ire inequivolent then PC(IJ) ~ PC(C). Ill the proof w ~l..c(I the formnlm CJ am] H from Lemmas \n4.2 and 4.3, ~rhich nm(le use of symbols such srs +, , T, f] , xl , etc. wI] ich did not iipjmir ;II \neither b or c. Can we still fiii(l a distinguishing partial correctness assertion if we rt st rict ourselves \nto r(b) U T(c)? h general the anstvcr k II( r, ;is the following theorem shows. 4,7 l%orem: Let 7 bc \na type with only finitely m:1 ny function symbols of positive arity and predicate symbol<, infinitely \nmany variable symbols, and at least t \\vo function symbols of tirity J 1. Then there :trc inequivalent \nrecursi~,ely enumerable schemes b, c s[lch that 7(b) u 7(c) G 7 and PC7(b) = PC,(c). Cotr.r/rm-tirm: \nLet f, g, fl .... fin, PI, .... P{] IW the function and predicate symbols of T with m, n .? O , t~h~re \nfi is ri-;lry, I>j is Sj-firy. For crmrenicnce, let us assume f {lnd g are unary functions. Let Trivial \n(xl ,.,.,x~ ) be the following predic:ite (where N = max [rl,...,rm, Sl,...,s,,]): p,(xl,...,x~}) A ... \nA Pr,,(xl,...,x,m) A fl(xl,...,xr, ) = xl A ... A f,,,(xl,...,x,n,) = X, A f(g(xl )) = Xl A g(f(x, )) \n= xl Then let b = ATOP and let c be defined as follows ifxlxy v... v XX # y ~herl h OP else (Xl := ?; \n.... xx := ?; if -=Trivial(xl, ,.., XN) then xl := y; .... XN := y else (X2:= f(xl); while X2 # x, do \nX2:= f(xz) od; x, := y; .... xlpJ:= y) fi) fi The program scheme c nondeterministically checks to make \nsure that xl = X2 = ... = XN = y, Pl, .... Pln are all tri~ ial predicates, fl, .... fln are all projection \non the first coordinate, f and g are inverse functions, and f has no loops (i.e. fk(x) z x for any x). \nIf any of these conditions are not met, c acts like A 0~ if they arc all met c diverges. Hence Kc g R~ \nBut Rc * R~ since if we take s to be the integers, with f successor and g predecessor, and xl = ... = \nXN = y = O, then (s,s) c R6 -RC Finally, it is not hard to show (see Appendix E) that pCT(b) = PC ~ (c), \nh Section 7 we will take a more detailed look at the whole qnestion of extr;i symbols. ~] 5. Defining \nSemantics By Termination Assertions Termination assertions can also be used to define a class of program \nschemes, and they are, in gencrnl, a more powerful tool for doing so than partial correctness assertions, \nas the following theorems show. %1 Theorem: The set of all true termination assertions clefines the semantics \nof arbitrary schemes of finite type. Proof Suppose b, and c are inequivalent schcnms of finite type. \nWithout loss of generality, suppose (s,t) ~ Rb -KC By Lemma 2.9, b is equivalent to I-libi, where each \nbi is tidy. Hence thkre must be SOITIC b.10 such that (s,t) e Rb. -RC By Lemma 4.3, there is a In state \ns and a formula H such that S I= ~[~jo]~I A [cIM or equivalently s ~ <bio>~H A m<c>TH. 5.2 Remark The \nhypothesis of finite type is necess:wy. The programs b and c of Appendix C. 1 demonstrate this:~ As the \nexample in 3.2 showed, the set of true quantifier-free partial correctness assertions dots not define \nthe sem[intics of the class of while-programs. But termination assertions will do the job. 5.3 T//eorcnr: \nThe set of all true quantifier-f ree termination assertions defines the semantics of the class of arbitrary \nschemes of finite type with quantifier-free tests :md simple assignments oflly (i.e. no :trray assignments \nor random assignments), and, ~ ~orf!orj~ defines the semantics of effective schemes and W1l I le\u00adprogrmrr \nschemes. Proofi Let X}, .... x , be the ~ariables of ~(b) U 7(c). As in Theorem 5.1, we can assume ~vithout \nloss of generality that we have (s,t) c Rb. -RC Since t) o uses only smple :w+mments, only xl, .... x,,, \ncould h:lvc been changed by b in going from s to t (no functions could h:ive been changed since there \nare no nrroy assignments), Thus, H from Lemma 4.3 can be simplified to H , where H is (XI = xI A .. A \nx,n = x,,, ), and we still have, as in Theorem 6.1, (<bio>~H , YH ) c T(b) -T(c). But by Lemma 2.7, <@io>~H \nis quantifier-free, so ~vc arc done. 0 6. A Complete Axiomatization For First-Order Termination Assertions \nConsider the following deductive system for terlnination assertionsabout while-program schemes. Axiom* \nTAl(a). F(N@F TAl(b). F ~ (X := y)F (where F; is the f~rnl~ll~i obtained from F l~y uniformly renaming \nall bound occurrences of y in F find then replacing all fi-ce occurrences of x in F by Y.) TA2. YFAG(whiie \nF do a od)G. Itulex TA3 F(a)G, G(b)H + F(q6)H. TA4(a) G(a)H I-FAG(if F then u else b fi)H. TA4(b) G(a)H \nI-7FAG(if F then b e!Se a fi)H. TA5. F(a)G, G(while E do a od)H * FAE(while E do a o(i)H. TA6 (substitutirity \nof equivalent formulas) F(~I)G + II({I)G whenever W=II) TA7. (restricted rule of consequence) F(@+FAH(a)G. \nTA8q F(a)H, G(a)H*FvG(a)H. 6.2 Theorcw: The quantifier-free terininatirm assert ions derivable from \nquantifier-free instances of the ax ion] schemes TA1-8 are precisely the qwintificr-f r ee termination \nassertions true for while-program schcmm. That is, the axioms TA1-8 are complete for quantifier\u00adfree \ntermination assertions. Proof The soundness of TA 1-8 should ,be Clcitr. We now prove completeness by \ninduction oil the structure of while-program schemes. a) Suppose F(NOP)CT is true. Then ~ E * (3, so \n&#38; (F A (j) = F. Hence we have: 1. I-G(NOP)G TA1(a)  2. I-(FAG) (NOP)G 7 A7 3  . . I-F(NOP)G (since \n+ (F A G) = F) TA6 (b) Suppose F(x := y)G is true. Then ~FaG~,so *( FAG:)=F, Using TAI (b), TA7, and \nTA6, we get K=F(x := y]Ci. (c) Suppose F(wb)G is true. Since a and b :ire effective, they are respectively \nequivalent to iai 1 .il i xnd each ~i (resp. b~) is tidy. Since F(~b)G is trwc wc have t= vj,j(F * <ai;b~G). \n By compactness it follows that there exist finite sets I, J such that ~ ViCI, jeJ(F ~ <ui;b~~r). Thus \nF(fl)(VjeJ(<b~G)) is true, And clearly (VjcJ(<b~G))(b)G is also true. So, by the irrduc t ion assumption \n F(fl)(vjEJ(<~~G)) ii nr.1 * (Vj.=J(<b~G))($)G. Then using TA3 we get I-F(~b)G. (d) Suppose G(if F then \na else b fi)H ii true. Then FAG(a)H and TFAG(6)H must both bc true, so, by the induction assumption, \nderivable from TA 1-8. Using TA4(a) and TA4(b), we get + FAG(if F then a ekie b fi)H and + ~FAG(jf F \nthen a else b fi)H. 208 Using TA8, we get *((FAG) V (~FAG))(if F then a eke b fi)JI and hence (since \n((FAG) v (-. FAG)) E G), using TA6 ~ve have * G(if F then a else b fi)l I. (e) Suppose G(while F dO u \noII)H is 1I ~le+ For irny formula of first order predicate calculus 1 , let F ? denote the program if \nF then A OP else (while x = x do A OP o(I) fi lNoteRF,? = {(t}t) [ t t= F} and F ? is tidy; in fact \n<F ?>G is equivalent to F AG. Again, we can awunic i~ k+ equivalent to uja~, where ai is tidy. Let / \nbe the W.-I of all finite sequences of natural numbers, and for s = <sl, .... Sn> e ~ define a(s) = F?; \na$l; . . . . F?; o ~F?a f hc s,, ~ program scheme a(s) is tidy since F?, 7F? are, and c:;ch aj is. By \nhypothesis * G = Vst,/<#hH. By compactness there is a finite set S c ~ such that Let Isl denote the length \nof the sequence s. \\\\re prove by induction on Isl that + <a~f)>13 (while F dO a od) H If [sI = (i, then \n* <a~s)>H = <~F?>H = -IFAH, and I-(-IFAH) (while F do a od) H by TA2. If S = <S1, .... s >, n ~ 1 let \ns = <s2, .... s,,>. (s) .Now <a >H (fl) <a(s ~>H is true, so by the rn; iin induction assumption, L-<a($)>H \n(a) <a~$ &#38;H. And by our induction on Isl, I-<~s )>H (~hil~ F (10 a od) II Hence by TA5, and TA6 using \nthe fact t hat k FA<a(s)>fI = <o(s)>H, we have * <u($)>H (while F do a od) H. Now using TA8, we get 1-(vs,yds~>H) \n(while F do a od)ll, SO by (*), TA6, TA7, + G(while F do a od)H. 1 It is now immediate from Theorem 5<3 \nthat 6.3 Coro//ary The quantifier-free theorems of the axiom system TA 1-8 define the semantics of while-program \nschemes. .Note that the proof of Theorem 6.2 also goes through in the case of the full first order language, \nSo we get 6.4 Theormt: The first order termination asscrtj(}ns derivable from first order instances of \nthe axiom sckwmes TA1 -8 are precisely the first order termination assertions true for tvhile-prograrn \nschemes. That is, TA1 -8 are complete for first order termination assertions. 6.5 Remark Theorem 6.4 \ncontinues to hold if we enrich the class of primitive instructions to include I lot h random and army \nassignments, and indeed, any tidy pritnitive instruction, with the :ippropriate strengthening of TA l(b), \n(namely, to now read <RA>F(A)F for A primitive) We may also allow first order tcsfs in the while-statement. \nNote that by allowing random assigntncnts }VC are dealing with a highly nondeterministic class of progr;lm \nschemes, which illustrates the point that completeness of the iibove axiom system does not depend on \nthe property of determinism. 0 7. The Role of Extra Symbols Although Theoretn 4.1 showed that it is al~v:tys \npossible to distinguish inequivalent recursively enumcf ,ibh schetnes by parti:il correctness assertions, \nTheorem 4.7 showed that in gener;il one must use symbols that appe:ir in neither scheme in order to do \nso. In this scctirm ive investigate the role of extra symbols more carefully, both in pinlhl correctness \nand termination assertions. Basically we observe that no extra symbols, not even extra variable symbols, \nare needed as iong as first order tests and random assignments do not appe{lr in programs (Theorem 7.2). \nTwo further resuits of pureiy technicai interest are given. Aiiowing random assignments or first order \ntests nmkes extra symbois of posi(ire arity necessary; es t ra variabies do not soffice (Theorem 7.5). \nFinally, if array assignments are disaiiowed, then termination assertimi~ cio not require extra symbols \naside from variables (Thtmrem 7.6), :ilthough in contrast partiai correctness assertions cio. 7.1 Lkfini[iorrr \nWe will say r is a sufficienl(v rich similarity type if it contains at least one function or predicate \nsj miJol of arity ~ 2 or at least two unary function symbols. The type r is a weak [>.rlcnsr on of T \nif 7 = T u [a finite number of variable symbols). Fin:tllyr T has enougk variab/es if it has at least \nonc more v:lri:lble symbol than the maximum arity of the function syml]ols and predicate symbols api]earing \nin it. Our major result is a positive one. 7.2 T/leoretn: For inequiwdent effective schemes a, b, even \nallowing array assignments as primitives, if 7(a) u T(b) = T k sufficiently rich, then PC ~(c) # PC ~(h) \nand T7(a) # T~(6). That is we do not need extra symbok in order for either partial correctness assertions \nor termination assertions to distinguish inequivaient programs~ Outline of Proof We show that under \nour hypotheses we c~in replace the G and H of Lemmas 4.2 and 4.3 by new formulas, say G and H , that \nperform the same function without using extra symbols. ~lsing this G and H instead of G and H in the \nproofs of 4.1 and 5.1 we get our desired result. Replacing the extra symbols in G and H is carried out \nas follows: It is easy to show that we can replace all the extra symbols occurring in G and by one predictive \nsymbol of sufficiently Lirge arity. Since 7 is sufficiently rich, Ivc cnn assume without loss of generality \nthat it crrnt aills a binary predicate symbol, say R. Then using R, it is possible to write a first order \nformula which implies the existence of new elements which are not the values of terms of type ?. The \nformula asserts thot the reklticrn giyen by R between these new elements and the old ones serves to encode \nthe large arity predicate on the old values. This idea then le:ids to the following refinement of Lemmo \n4.2. 7.3 Lemma Let Fo, F], .... be any recursiwly enumerable sequence of open formul;!s of finite t ! \nj m T. Then one can effectively construct a first order fornlula G such that (b) ~G ~ AiFi, and (c) \nif s is a state with infinite  domain and s * Ai~i, then there is an expansion s of sl ~ such that s \n~G. The details of the proof are omitted. 0 ?.4 Retnarks Lemma 7.3 may be of independent ilitrrest since \nit implies that the theory of any rccursiwly enumerable set of quantifier-free sentences of finite type \nis finitely axiomatizable. The finite :ixiorns in gcnerai must have additional quantifiers but are of \nthe s:lrne finite type ;is the set of sentences (cf. Note 3). As we :ilready noted, Theorem 4.7 shows \nth;[t if we allow either r:indom assignment or first order t~,its, Theorem 7.2 ffiils in fhe case of \nparti:ii correcl lless assertions, In facf, for schemes using random assigl)rll~nt or first order tests \nit is the case that extra symbols of posi[ipe arity are required for termination assertions W, well as \npartial correctness assertions, as the follrnving strengthening of Theorem 4.7 shows. 7.5 Tkortwr: For \nany finite tyi]e r ~vith ci]ough variables and at Icast one function symbol of positive arity, there \nexist inequivalent recursivc]y enumcr;ib]c schemes a, b such that ~(a) u r(b) = T and for any Wt-;ik \nextension ~ of T, Pc#((7)= Pc/(b); ii nd Tti(a) = T~,(b). Or//line of Conslructiorr; The construction \nis an amalgam of the constructions used in Theorem 4.7 and Appendix F, We can assume without loss of \ngenerality that we have a unary function symbol f in 7. We dct ine a flowchart swi[c/1 which generates \nPI(x) and PI( x ) for some nrmdeterministical]y chosen integers m z n :tnd then, using array assignments, \nswitches the values of ttlese twrr terms. Using random assignments as in I he proof of Theorem 4.7, we \nalso define a finite flo~vchart /rilia/ which diverges On states in which every prcdicatc and every function \nbesides f is trivial, and :icts like ;YOP otherwise. Then let a be swilch u NOP and b be swi[ch U [ribVial. \nAgain, we omit the remainder of the proof. o Curiously, if array assignments are dis:illrm cd, then termination \nassertions without any extra s~-rnhols aside from variables can distinguish inequivalent schenles .. \neven arbitrary schrmres with random assigyrrncnts, etc. 7.6 Theorem: Suppose a, b are inequivalent arbitrary \nschemes without array assignments. Then we can find a weak extension T of ~(a) u 7(b) such lhat T~,(a) \nz T, (b). Proo~ The proof is just that of Theorem 5.3, except that since bio might now have ran<lom assignments, \n<bio>~H is not irr general quantifier-free (note that <x := ?>F is equivalent to 3xF). 210 Note that \nthe proof of Theorem 4.7 shows that partial correctness assertions do not share the proper-i! of termination \nassertions given shove in Theorem 7.6. I his provides :inother instance illustrating the somewhat nicer \ntheoretical properties of termination as opposed to par! ial correctness assertions. 8. Conclusion We \nhave given a technical formulation of t hc thesis that progrtnnming languages can be spwificd aximrmtically \nusin~ brfore-after assertions. We exami [led this thesis in detail in the context of first order assertions \nabout program schemes, and concluded th:~t in t heory there is an miomatic system for effectively deriving \nenough assertions to define the behavior of any effective scheme. We interpret the technical complication \nof the proofs of these positive results for the c:isc of p:]rt i:il correctness assertions :is suggesting \nthat hl~U+!C specification by such :issertions is likely to be a\\vk\\varcl ill pr:ictice. Termimrtion \nassertions fare somewhat bet tcr in that the proofs are straightforward and these asscr{ ions have a \nsimple complete axiomat ization for Jvh i lC\u00adprogrmrs. Another significant advantage of termination in \ncontrast to partial correctness assertions is thilt the former can be viewed as a kind of operational \nspecification --with the proof of a termination asscri ion about a pro.yam corresponding to steps in \na comput at ion of the program. W e shall not elaborate on this observation here, but wc expect this \npropert~-would n)oke a specification using termination assertions much mt)re useful to programming language \nimplementors. (It Jvould be interesting to examine extensions of the termination axioms to more realistic \nkinds of program schemes th:tn while-schemes.) The property of completeness plays a smaller wole in this \npaper than in many others on proving assert ions about progr:ims, The reason is simple --the property \nof completeness of an axiom system and the property of its yielding enough assertions to define semantics \narc incirpendent. As we noted just before stating Thcorenl 4,5, no c~mplete effective axiom system for \np:ti-tiai correctness assertions even about while-progr:inw is possible, yet a recursively enumerable \nset of such assertions does define semantics. There are idso c:l~es, e.g., using open formulas, where \nthe complete set of true assertions about some ckiss of programs does not drfinc semantics, Some comments \nrcgar(iing our use of first orflcr predicate calculus must be made here. A reas,,n:lble rejoinder to \nour concern about the technical subtleties arising from predicate calculus is that one could choose instead \nsome richer logical l:mgwsge such :1s we:lk second order predicate calculus ,or first order arithm(,tic \naugmented with the uninterpreted function and prcdic:}te SSmbOk :qy~caring in programs. For these richer \njogic:ii languages the subt Ieties disappear; it is easy to show t hiit partial correctness and/or termination \n:issertirms invillving formulas from these languages define input-out put semantics. Indeed these richer \nlogical liit]~uiig~s are the ones implicitly used in most of the literature on axiomatic definitions \nof programming languages. But on aciopting richer logical languages, one pays x high price in terms of \neffective proof procedures. I he t:intoiogies of weak second order predicate calculus and first order \narithmetic augmented with uninterprcfed function symbols are of quite high degree of nndecidability (H \n~ ). Since one of the central aiins of axiomatic programming language definitions is to ea~e I he generation \nof proofs about programs, it is obviously important to ret:fin constructive proof properties such ;is \nthose of predicate calculus. Further, we observe that with minor exceptions the use of arithmetic formulas \nin the literature on axiomatic programming languages arises only in the specification of arithmetic primitive \noperations in programs. Above the level of primitive operations (for example in the specifications of \nsequencing constructs or subroutine calls) the arithmetic properties of the primitives are not used. \nThus the specifications fit wit hin the framework of predicate calculus and uninterpreted flowchart schemes \nconsidered above. APPENDICES A -F To appear. Notes 1. Input-output semantics do not reflect the full \noperational behavior of programs, e.g., information about looping or failing is lost, but dealing with \nsuch extended semantics and the kind of sveakcs/ prc-cotldi/ion assertions proposed by 13ijkstra capable \nof defining this extended semantics is technically more complicated and does not appear to raise any \nnew issues about the n:it nre of zxiomatic definitions of programs, 2. In the terminology of [Greif and \nMeyer,l 9791, determines the standard relational semantics of .c/ -iICleene s for first predic:ite . \n. result pure order calculus (without equality) was formulated in terms of finite axiomatizability, namely, \nthe theory of any recursively enumerable set of axioms of finite type equals the theory restricted to \nthe same finite type of some finite set of axioms. In general, however, the finite set of axioms must \ninvolve extra symbols. 211 Lemmz 4.2 immediately implies Kleene s rc~ult, Harel, D. Logics of Programs: \nAxiomatic :1nd since without equality a first order formula is satisfi:il~le Descriptive Power. M. I. \nT., Laboratory for Comlnlter iff it is satisfiable in an infinite domain. Conversely, Science, TR-200. \nM.LT., Cambridge, Mass. 02139. \\f:iy, IWene s proof of his result is quite similar to the a~lthors 1978. \nindependent proof given. in Appendix B. 4. Given WO t~pt?S T, T with T g T , s a structure Of type ~, \ns a structure of type 7 , then s is an c.rpansion of s if don](s) = dom(s ) and S 17= S. . iIt is not \ntoo difficult to show that the set of ail true termination assertions defines the semantics of nrbitrary \ndeterministic schemes, even those of inf irlite type. 6. If we disallow array assignments, we can even \nhandle the case where 7 is not sufficiently rich, but t hcn we must use a weak extension of 7 in order \nto achieve the desired septiration. REFERENCES Apt, K. R., J. A. Bergstra, L. G. L. T. Mecrt, ns. Recursive \nAssertions Are Not Enough -C)r Are I-hey? Theoretical Conrputer Science, invoL 8, pp. 73-87, ]979. Ikrgstra, \nJ. A., J. Tiuryn, and J. V. Tucker. Correctness Theories and Program Equivalence. Frcprint. Stichting \nM<ithcmatisch Centrum,Amsterd: im, 1979. Cook, S. A. Soundness and Completeness of an Axiom System for \nProgram Verification. NAM Journa/ on Completing, vol. 7, no. 1, February, 1978. Dijkstra, E. W. Guarded \nComnlnfids, ~Nondeterminacy and Formal Derivation of Profy iilns. Comm. of the A.C.M. vol 18, no. 8, \n1975. Dijkstra, E. W. .4 Discipline of Program ming. Prentice-Hall, 1976, Floyd, R. W. Assigning Meaning \nto Progran]s. In i}{athetna(ico[ A.vpects of Cotnpu (er Science. Proceedit[g c of Symposium in Applied \n~~athivnafics (cd. J. T. Sch\\v:irt z). (pp. 19-33) American Math. Society, Pro~idence, R hodc Island, \n1967. Friedman, H. Algorithmic Procedures, Gener:iliT,ed Turing Algorithms, and Elementary Recursion \nTheory, In Logic co//oqoiut/m, 1969 (cd, R, O. Ganciy and C. kl. E. Yates) (pp. 316-389). lNorth Holland, \nAmsterdam, 1971. Greif, I. and A. R. Meyer. Specifying the Semantics of While-programs. M.LT., Laboratory \nfor Computer Science, TM-1 30. M. I. T., Cambridge, \\l:Iss. 02139, April, 1979. Harei, D., A. R, Meyer, \nand V. R, P[-ltt. Computability and Completeness in Logics of Propratns. Proceedings of Ninth Anrrtta/ \nA. CM. Sympositlm on Theory of Computing. Boulder, Color:ido. Miiy, 1977. Hoare, C A. R. and P. I.aoer. \nConsistent and Complementary Formal Theories of the Semantics of Programming Languages. At/a Irrforma/ica \n.+ , pp 135-155, 1974. Hoare, C. A. R. and N. Wirth. An Axiomatic Definition of the Programming Language \nPASCAL. Ac(a Informatico 2, pp. 335-355, 1973. Janssen, T. il. V. and P. vnn Erode Boas. ~ he Expressive \nPower of Intensirmal Logic in the Semarrt ic. of Programming Languages. Preprint. Sti,hling Mathematisch \nCentrum, Amsterdam, May, 1977. Kleene, S. C. Two Papers on [fle Pr,]dica(e Calculus. Memoirs of (he American \nMaIh. Sot., A (I. I (). (pp. 27-66). American Math. Society Providence, Rhode Island, 1952. London, Ralph \nL. Program Verification In Researcit Directions in Software Technology. ed. Pet cr }J egner. (pp. 302-3} \n5). M.l,T. Press, Cambridge, \\l:\\m., 1978. Machtey, M. anti P, Young. An Introduction to [he Genera/ \nTheory of A/gori[hms. North } Iolland, lq78, Pratt, V. R. Semiotical Considerations of I l,>yd-Hoare \nLogic, 17[/7 Annual IEEE S~vnpo.~ittm or7 [he Fonnda[ions of Cotnpuier Science. pp. 109-121, octobcr, \n1976. Schwartz, R. An Axiomatic Semantic De finit iml of Algol 68. UCLA-ENG-7838; UCLA-MP2 i 4-75, University \nof California at Los Angeles, Los Ang<,les, Calif. 1978. 212   \n\t\t\t", "proc_id": "567446", "abstract": "A precise definition is given of how partial correctness or termination assertions serve to specify the semantics of classes of program schemes. Assertions involving only formulas of first order predicate calculus are proved capable of specifying program scheme semantics, and effective axiom systems for deriving such assertions are described. Such axiomatic specifications are possible despite the limited expressive power of predicate calculus.", "authors": [{"name": "Albert R. Meyer", "author_profile_id": "81100572937", "affiliation": "", "person_id": "PP15036546", "email_address": "", "orcid_id": ""}, {"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "", "person_id": "P149011", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/567446.567466", "year": "1980", "article_id": "567466", "conference": "POPL", "title": "Axiomatic definitions of programming languages: a theoretical assessment (preliminary report)", "url": "http://dl.acm.org/citation.cfm?id=567466"}