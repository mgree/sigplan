{"article_publication_date": "01-17-2007", "fulltext": "\n Cork: Dynamic Memory Leak Detection . for Garbage-Collected Languages MariaJumpandKathrynS.McKinley \nDparomputerSciences,TheUniversityofTexasaS etmentofCtAustin,Austin,Texas78712,UA {mjump,mckinley}@cs.utexas.edu \nAbstract Amemory leak inagarbage-collectedprogramoccurswhentheprograminadvertentlymaintainsreferencestoobjectsthatitnolongerneeds.Memoryleakscausesystematicheapgrowth,de\u00adgradingperformanceandresultinginprogramcrashesafterper\u00adhapsdaysorweeksofexecution.Priorapproachesfordetectingmemoryleaksrelyonheapdifferencingordetailedobjectstatis\u00adticswhichstorestateproportionaltothenumberofobjectsintheheap.Theseoverheadsprecludetheiruseonthesameprocessorfordeployedlong-runningapplications. \nThispaperintroducesadynamicheap-summarizationtechniquebasedontypethataccuratelyidenti.esleaks,isspaceef.cient(addinglessthan1%totheheap),andistimeef.cient(adding2.3%onaveragetototalexecutiontime).WeimplementthisapproachinCork \nwhichutilizesdynamictypeinformationandgarbagecol\u00adlectiontosummarizetheliveobjectsinatype points-from \ngraph (TPFG)whosenodes(types)andedges(referencesbetweentypes)areannotatedwithvolume.Cork comparesTPFGsacrossmultiplecollections,identi.esgrowingdatastructures,andcomputesatype \nslice fortheuser.Corkisaccurate:itidenti.essystematicheapgrowthwithnofalsepositivesin4of15benchmarkswetested.Cork \nsslicereportenabledus(non-experts)toquicklyeliminategrowingdatastructuresinSPECjbb2000 andEclipse,somethingtheirdevelopershadnotpreviouslydone.Corkisaccurate,scal\u00adable,andef.cientenoughtoconsiderusingonline. \nCategories and Subject Descriptors D.2.5[Software Engineer\u00ading]:TestingandDebugging Debuggingaids General \nTerms MemoryLeakDetection Keywords memoryleaks,runtimeanalysis,dynamic,garbagecollection 1. Introduction \nMemory-relatedbugsareasubstantialsourceoferrors,andareespeciallyproblematicforlanguageswithexplicitmemoryman\u00ad \n.ThisworkissupportedbyNSFCCR-0311829,NSFITRCCR-0085792,NSFCCF-0429859,NSFEIA-0303609,DARPAF33615-03-C-4106,DARPANBCH30390004,Intel,andIBM.Anyopinions,.ndingsandcon\u00adclusionsexpressedhereinaretheauthors \nanddonotnecessarilyre.ectthoseofthesponsors. Permissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedforpro.torcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationonthe.rstpage.Tocopyotherwise,torepublish,topostonserversortoredistributetolists,requirespriorspeci.cpermissionand/orafee. \nPOPL 07January17-19,2007,Nice,France. C M1-59593-575-4/07/0001. . . $5. 00. c opyright2007AC agement.Forexample,CandC++memory-relatederrorsinclude \n(1)dangling pointers dereferencingpointerstoobjectsthattheprogrampreviouslyfreed,(2)lost pointers losingallpointerstoobjectsthattheprogramneglectstofree,and(3)unnecessary \nref\u00aderences keepingpointerstoobjectstheprogramneverusesagain. Garbagecollectioncorrectsthe.rsttwoerrors,butnotthelast.Sincegarbagecollectionisconservative,itcannotdetectorreclaimobjectsreferredtobyunnecessaryreferences.Thus,amemory \nleak inagarbage-collectedlanguageoccurswhenaprogrammaintainsreferencestoobjectsthatitnolongerneeds,preventingthegarbagecollectorfromreclaimingspace.Inthebestcase,unnecessaryref\u00aderencesdegradeprogramperformancebyincreasingmemoryre\u00adquirementsandconsequentlycollectorworkload.Intheworstcase,agrowingdatastructurewithunusedpartswillcausetheprogramtorunoutofmemoryandcrash.Evenifagrowingdatastructureisnotatrueleak,applicationreliabilityandperformancecansuffer.Inlong-runningapplications,smallleakscantakedaysorweekstomanifest.Thesebugsarenotoriouslydif.cultto.ndbecausetheallocationthat.nallyexhaustsmemoryisnotnecessarilyrelatedtothesourceoftheheapgrowth. \nPreviousapproachesfor.ndingleaksuseheapdiagnosistoolsthatrelyonacombinationofheapdifferencing[10,11,20]andallocationand/or.ne-grainobjecttracking[7,8,9,13,19,24,25,28,29].Thesetechniquesdegradeperformancebyafactoroftwoormore,incursubstantialmemoryoverheads,relyonmultipleex\u00adecutions,and/orof.oadworktoaseparateprocessor.Additionally,theyyieldlargeamountsoflow-leveldetailsaboutindividualob\u00adjects.Thesereportsrequirealotoftimeandexpertisetointerpret.Thus,priorworklacksprecisionandef.ciency. \nThispaperintroducesCork,anaccurate,scalable,online,andlow-overheadmemoryleakdetectiontoolfortypedgarbage\u00adcollectedlanguages.Corkusesanovelapproachtosummarize,identify,andreportdatastructureswithsystematicheapgrowth.Weshowthatitprovidesbothef.ciencyandprecision.Corkpig\u00adgybacksonfull-heapgarbagecollections.Asthecollectorscanstheheap,Corksummarizesthedynamicobjectgraphbytype(class)inasummarytype \npoints-from graph (TPFG).Thenodesofthegraphrepresentthevolumeofliveobjectsofeachtype.Theedgesrepresentthepoints-fromrelationshipbetweentypesweightedbyvolume.Attheendofeachcollection,theTPFG \ncompletelysum\u00admarizesthelnts-fromrelationshipsintheheap. ive-objectpoi Forspaceef.ciency,Corkstorestypenodestogetherwithglobaltype \ninformation block (TIB).TheTIB,orequivalent,isarequiredimplementationelementforlanguagessuchasJavaandC#thatinstructsthecompileronhowtogeneratecorrectcodeandinstructsthegarbagecollectoronhowtoscanobjects.Thenum\u00adberofnodesintheTPFG \nscaleswiththetypesystem.Whilethenumberofedgesbetweentypesarequadraticintheory,programsimplementsimplertyperelationsinpractice;we.ndthattheedges \nTypeSymbolSizeHashTableH256QueueN256QueueB256CompanyC64PeopleP32 (a)Objectstatistics H1 C1 C2 C3 N1 \n(b)Objectpoints-tograph B:256 H:256 N:256 (c)Typepoints-fromgraph Figure 1. Thetypepoints-fromgraphsummarizestheobjectpoints-tograph \narelinearinthenumberoftypes.TheTPFG neveraddsmorethan0.5%toheapmemory. CorkstoresandcomparesTPGFsfrommultiplecollectionstodetectandreportadynamictype \nslice withsystematicheapgrowth.Westorepoints-frominsteadofpoints-toinformationtoef.cientlycomputethecandidatetypeslice.Wedemonstratethattheconstruc\u00adtionandcomparisonofTPFGsacrossmultiplecollectionsaddsonaverage2.3%tototaltimetoasystemwithagenerationalcollector. \nWeapplyCorkto14popularbenchmarksfromDaCapo b.050224 [5]andSPECjvm [26,27]benchmarksuites.Corkidenti.esandreportsunboundedheapgrowthinthreeofthem.Wecon.rmnoadditionalmemoryleaksintheother11benchmarksbyexaminingtheirheapcompositiongraphs[6].AdditionallyweapplyCorktoaknownmemoryleakinEclipse \nbug#115789.Inthispaper,wereportdetailedresultsforthetwolargestprograms: (1)SPECjbb2000 whichgrowsatarateof128KBevery64MBofallocation,and(2)Eclipse \nbug#115789 whichgrowsatarateof2.97MBevery64MBofallocation.Usingagenerationalcollection,Corkpreciselypinpointedthesingledatastructureresponsibleforthegrowthaftersixfull-heapcollections.Weusedthisprecisiontoquicklyidentifyandeliminatethememoryleaks. \nInpractice,Cork snovelsummarizationtechniqueisef.cientandpreciselyreportsdatastructuresresponsibleforsystematicheapgrowth.Itslowspaceandtimeoverheadmakesitappealingforperiodicorconsistentuseindeployedproductionsystems. \n2. Finding Leaks with Cork ThissectionoverviewshowCorkidenti.espotentiallygrowingtypenodes(candidate \nleaks)andreportstheircorrespondingtype 1 void scanObject(TraceLocal trace, 2 ObjectReference object) \n{ 3 MMType type = ObjectModel.getObjectType(object); 4 type.incVolumeTraced(object); // added 5 if (!type.isDelegated()) \n{ 6 int references = type.getReferences(object); 7 for (int i = 0; i < references; i++) { 8 Address slot \n= type.getSlot(object, i); 9 type.pointsTo(object, slot); // added 10 trace.traceObjectLocation(slot); \n 11 }} else { 12 Scanning.scanObject(trace, object); 13 }} Figure 2. ObjectScanning totheuseralongwiththedatastructurewhichcontainsthemandtheallocationsitesthatgeneratethem.Forclarityofexposition,wedescribeCorkinthecontextofafull-heapcollectorusinganexampleprogramwhosetypesarede.nedinFigure1(a). \n 2.1 Building the Type Points-From Graph Todetectgrowth,Corksummarizestheheapinatype points\u00adfrom graph \n(TPFG)annotatedwithinstanceandreferencevolumes.TheTPFG consistsoftype nodes andreference edges.Thetypenodesrepresentthetotalvolumeofobjectsoftypet \n(Vt ).Thereferenceedgesaredirectededgesfromtypenodet'totypenodet andrepresentthevolumeofobjectsoftypet'thatarereferredtobyobjectsoftypet \n(Vt.qt ).TominimizethecostsassociatedwithbuildingtheTPFG,Corkpiggybacksitsconstructiononthescanningphaseofgarbagecollectionwhichdetectsliveobjectsbystartingwiththeroots(statics,stacks,andregisters)andperformingatransitiveclosurethroughalltheliveobjectreferencesintheheap.Foreachreachable(live)objecto \nvisited,Corkdeterminestheobject stypet andincrementsthecorrespondingtypenodebytheobject ssize.Thenforeachreferencefromo \ntoobjecto',itincrementsthereferenceedgefromt'tot bythesizeofo'.Attheendofthecollection,theTPFG completelysummarizesthevolumeofalltypesandreferencesthatareliveatthetimeofthecollection. \nFigure1(b)showsanobjectpoints-tograph(i.e.,theheapit\u00adself).Eachvertexrepresentsadifferentobjectintheheapandeacharrowrepresentsareferencebetweentwoobjects.Figure2showsthemodi.edscanningcodefromMMTkinJikesRVM:Corkre\u00adquirestwosimpleadditionsthatappearaslines4and9.AssumescanObject \nisprocessinganobjectoftypeB thatreferstoanob\u00adjectoftypeC (fromFigure1(b)).Ittakesthetracingroutineandobjectasparametersand.ndstheobjecttype.Line4incrementsthevolumeoftypeB \n(VB)inthenodeforthisinstance.Sincethecollectorscans(detectslivenessof)anobjectonlyonce,Corkin\u00adcrementsthetotalvolumeofthistypeonlyonceperobjectinstance.Next,scanObject \nmustdetermineifeachreferentoftheobjecthasalreadybeenscanned.Asititeratesthroughthe.elds(slots),theaddedline9resolvesthereferenttypeofeachoutgoingreference(B \n-C)andincrementsthevolumealongtheappropriateedge(B +C)inthegraph(VCqB).Thus,thisstepincrementstheedgevolumeforallreferencestoanobject(notjustthe.rstone).Be\u00adcausethisstepaddsanadditionaltypelookupforeachreference,italsointroducesthemostoverhead.Finally,scanObject \nenqueuesthoseobjectsthathavenotyetbeenscannedinline10.Theaddi\u00adtionalworkofthegarbagecollectordependsonwhetheritismov\u00adingobjectsornot,andisorthogonaltoCork. \nAttheendofscanning,theTPFG completelysummarizestheliveobjectsintheheap.Figure1(c)showstheTPFG forourexample.NoticethatthereferenceedgesintheTPFG \npointintheoppositedirectionofthereferencesintheheap.Alsonoticethat,intheheap,objectsoftypeC arereferencedbyH,B,andN \nrepresentedbytheoutgoingreferenceedgesofC intheTPFG. Object Points-to Graphs  Type Points-From Graphs \n (a)Aftercollection1(b)Aftercollection2(c)Aftercollection3 Figure 3. ComparingTypePoints-FromGraphstoFindHeapGrowth \nSinceC hasmultiplereferencestoitintheheap,thesumoftheweightsofitsoutgoingreferenceedgesisgreaterthanitstypenodeweight.CorkdifferencestheTPFG \nvolumesfromdistinctcollectionstodeterminewheregrowthisoccurringintheheap. Corkusesvolumeratherthanasimplecounttodetectarraygrowthwhenthenumberofarraysremainsconstantbuttheirsizesgrow.Additionally,volumegivesaheavierweighttolargertypeswhichtendtomaketheheapgrowfasterthansmallertypes. \n 2.2 Finding Heap Growth Attheendofeachcollection,CorkdifferencestheTPFG forthecurrentcollectionwithpreviouscollectionsreportingthosetypesnodeswhosevolumesincreaseacrossseveralcollectionsascandidateleaks.Foreachtypenodethatisgrowing,CorkfollowsgrowingreferenceedgesthroughtheTPFG \ntopinpointthegrowth. Forexample,Figure3showsthefullTPFG createdduringthreecollectionsofourexampleprogram.NoticethatobjectsC \nandP areaddedtoboththehashtableandqueues.Whentheyare.nishedbeingused,theyareremovedfromallofthequeuesbutnotfromthehashtable,causingamemoryleak.ComparingtheTPFG \nfromthe.rsttwocollectionsshowsbothC andP objectsarepotentiallygrowing(depictedwithboldarrows).Weneedmorehistorytobesure.Figure3(c)representsthestateatthenextcollection,atwhichpointitbecomesclearerthatthevolumeofP \nobjectsismonotonicallyincreasing,whereasthevolumeofC objectsissimply.uctuating.Inpractice,we.ndthattypevolumejitters \n.uctuateswithhighfrequency thoughtheoveralltrendmayshowgrowth.Thus,Corkmustlookformorethanmonotonicallynon\u00addecreasingtypegrowthbetweentwoconsecutivecollections. \nCorkdifferencestheTPFG fromthecurrentcollectionwiththatofpreviouscollectionslookingforgrowingtypesandranksthem.Weexaminetwodifferentmethodsforrankingtypes[16].Becauseofspaceconstraints,weonlypresentthemorerobustofthesetechniques:theRatioRankingTechnique. \nTheRatioRankingTechnique(RRT)rankstypenodesaccord\u00adingtotheratioofvolumesQ betweentwoconsecutiveTPFG,.ndsthetypenodeswithranksabovearankthreshold(rt \n>Rt thres),andreportsthecorrespondingtypesascandidates.Additionally,RRTusesadecay factor f ,where0<f \n<1toadjustforjitter.Tobeconsideredapotentialleak,RRTconsidersonlythosetypenodeswhosevolumessatisfyVTi \n>(1-f )*VTi.1onconsecutivecollec\u00adtionsaspotentialcandidates.Thedecayfactorkeepstypenodesthatshrinkalittleinthiscollection,butwhichmayultimatelybegrowing.We.ndthatthedecayfactorisincreasinglyimportantasthesizeoftheleakdecreases.Choosingtheleakdecayfactorbalancesbetweentoomuchinformationandnotenough. \n Toranktypenodes,RRT.rstcalculatesthephase growth factor (g)ofeachtypenodeasgti =pti *(Q-1),wherep isthenumberofphases(orcollections)thatt \nhasbeenpotentiallygrowingandQ istheratioofvolumesofthisphaseandthepreviousphasesuchthatQ >1.SinceQ >1,g \n>0.Eachtypenode srankrt iscalculatedbyaccumulatingphasegrowthfactorsg overseveralcollectionssuchthatabsolutegrowthisrewarded(rti \n=rti.1+gti )anddecayispe\u00adnalized(rti =rti.1-gti ).Higherranksrepresentahigherlikelihoodthatthecorrespondingvolumeofthetypegrowswithoutbound.SinceRRTonlyreportstypesthathavebeenpotentiallygrowingforsomeminimumnumberofphases,the.rsttimeatypeappearsinagraph,RRTdoesnotreportit.Corkranksreferenceedges(re)usingthesamecalculation. \n 2.3 Correlating to Data Structures and Allocation Sites Reportingalow-leveltypesuchasString asapotentialcandidateisnotveryuseful.Corkidenti.esthegrowingdatastructurethatcontainsthecandidategrowthbyconstructingaslice \nintheTPFG.Wede.neaslice throughtheTPFG tobethesetofallpathsoriginatingfromtypenodet0suchthattherankofeachreferenceedgertk \n-tk+1onthepathispositive.Thus,aslicede.nesthegrowthoriginatingattypenodet0followingasequenceoftypenodes{t0,t1,,tn}andasequenceofreferenceedges(tk,tk+1)wheretypenodetk \npointstotk+1intheTPFG. Corkidenti.esaslicebystartingatacandidatetypenodeandtracinggrowingreferenceedgesthroughthegraphuntilitencoun\u00adtersanon-growingtypenodewithnon-growingreferenceedges.Thisslicecontainsnotonlycandidates,butalsothedynamicdatastructurecontainingthem.Additionally,Corkreportstypealloca\u00adtionsites.However,unlikesomemoreexpensivetechniques,itdoesnot.ndthespeci.callocationsite(s)responsibleforthegrowth.In\u00adstead,itreportsallallocationssiteforthecandidatetype.Aseach \nType Information Block object L Header Data Figure 4. TypeInformationBlock(TIB) allocationsiteiscompiled,Corkassignsitauniqueidenti.er,andconstructsamap(aSiteMap)toitfromtheappropriatetype.Foreachleakingtype,Corksearchesthemapto.ndallocationssitesforthattype.Foreachtype,theSiteMapincludesthemethodandbyte-codeindex(bcidx)orlineforeachallocationsite. \n 2.4 Implementation Ef.ciency and Scalability WeimplementseveraloptimizationstomakeCork simplementa\u00adtionscalableandef.cientinbothtimeandspace.First,we.ndCorkcanaccuratelydetectheapgrowthkeepingahistoryofonlyfourTPGFs:TPFGi,TPFGi.1,TPFGi.2,andTPFGi.3.CorkpiggybackstypenodesontheVM \nsglobaltype information block (TIB).Thisstructureoranequivalentisrequiredforacorrectim\u00adplementationofJavaorC#.Figure4showsthemodi.edTIBfromJikesRVM.Noticethateveryliveobjectofatype(ob \njectL)pointstotheTIBcorrespondingtoitstype.TheTIBconsistsofthreedifferentparts.The.rstisthemethodtablewhichstorespoint\u00aderstocodeformethoddispatch.Themethodtablepointstoacor\u00adrespondingVM \nType whichstoresinformationusedbytheVMforef.cienttypecheckingandusedbythecompilerforgenerat\u00adingcorrectcode.Finally,theVM \nType pointstoacorrespondingMMType usedbythememorymanagementsystemtodocorrectallocationandgarbagecollection.RecallfromFigure2thatobjectscanningresolvestheMMType \nofeachobject(line3).Thus,CorkstoresTPFG typenodedataforeachTPFG inthecorrespondingMMType addingonlyfourextrawords.Oneadditionalwordstoresthenumberofconsecutivecollectionsthatatypepotentiallygrows.Thus,thetypenodesscalewiththetypesystemoftheVM. \nWhilethenumberofreferenceedgesintheTPFG arequadraticintheory,oneclassdoesnotgenerallyreferenceallotherclasses.Programsimplementamuchsimplertypehierarchy,andwe.ndthatthereferenceedgesarelinearwithrespecttothetypenodes.Thisobservationmodi.essimplyedgeimplementationconsistingofapoolofavailableedges(edge \npool).Eachtimeaclass(type)isloaded,theedgepoolgrows.Additionally,theedgepoolcangrowdynamicallywheneveritrunsoutofedges.NewedgesareaddedtotheTPFG \nbyremovingthemfromtheedgepoolandaddingthemtothelistofreferenceedgeskeptwithnodedata.WeencodeapointertotheedgelistwiththenodedatatopreventfromaddinganyextrawordstotheMMType \nstructure.Wefurtherreducethespacerequiredforreferenceedgesbypruningthosethatdonotgrow.  2.5 Cork in \nOther Collectors SinceCork simplementationpiggybacksonlive-heapscanningduringgarbagecollection,itiscompatiblewithanymark-sweeporcopyingcollector(i.e.,ascanning \ncollector).Corkcanalsobeaddedasdescribedtoanyscanningcollectorthatdoesperi\u00adodicwhole-heapcollections.Inthesecon.gurations,Corkper\u00adformstheanalysisonlyduringfull-heapcollections.To.ndleaksinourbenchmarks,Corkneededapproximatelysixcollectionsdur\u00adingwhichheapgrowthoccurs.AscanningincrementalcollectorthatnevercollectstheentireheapmayaddCorkbyde.ningin\u00adtervalsthatcombinestatisticsfrommultiplecollectionsuntilthecollectorhasconsideredtheentireheap.Corkwouldthencomputedifferencestatisticsbetweenintervalstodetectleaks. \n  2.6 Cork in Other Languages Cork sheapsummarization,theTPFG,reliesonthegarbagecol\u00adlector sabilitytodeterminethetypeofanobject.Weexploittheobjectmodelofpolymorphicallytypedlanguages(suchasJavaandC#)bypiggybackingontheirrequiredglobaltypeinforma\u00adtiontokeepspaceoverheadstoaminimum.Thereare,however,otherimplementationoptions.Forgarbage-collectedlanguagesthatlackglobaltypeinformation(suchasStandardML),othermecha\u00adnismmaybeabletoprovideequivalentinformation.Previousworkforprovidesomesuggestionsforfunctionallanguagesthattagob\u00adjects[21,22,23].Forexample,type-speci.ctagscouldbeusedtoindexintoahashtableforstoringtypenodes.Alternatively,ob\u00adjectscouldbetaggedwithallocationandcontextinformational\u00adlowingCorktosummarizetheheapinanallocation-site \npoints\u00adfrom graph.Thesetechniques,however,wouldcomeatahigherspaceandtimeoverhead. 3. Results ThissectionpresentsoverheadandqualitativeresultsforCork.Section3.1describesourmethodology,Section3.2reportsCork \nsspaceoverhead,andSection3.3reportsitsperformance.Sec\u00adtion3.4showstheaccuracyoftheSlopeRankingTechniqueandshowshowavarietyofreasonablevaluesforthedecayfactorandtherankthresholdgiveshighlyaccurateresultsusingtheRatioRankingTechnique.Afterapplyingandidentifyingunboundedheapgrowthinfourcommonlyusedbenchmarks,Section3.5de\u00adtailsthetwolargest:SPECjbb2000 \nandEclipse. 3.1 Methodology WeimplementCorkinMMTk,amemorymanagementtoolkitinJikesRVMversion2.3.7.MMTkimplementsanumberofhigh\u00adperformancecollectors[3,4]andJikesRVMisahigh-performanceVMwritteninJavawithanaggressiveoptimizingcompiler[1,2].Weusecon.gurationsthatprecompileasmuchaspossible,includ\u00adingkeylibrariesandtheoptimizingcompiler(theFast \nbuild-timecon.guration),andturnoffassertionchecking.Additionally,weremovethenondeterministicbehavioroftheadaptivecompilationsystembyapplyingreplaycompilation[15]. \nWeevaluateourtechniquesusingtheSPECjvm [26],DaCapo b.050224 [5],SPECjbb2000 [27],andEclipse [30].Table1(a)showsbenchmarkstatisticsincludingthetotalvolumeallocated(column1)andnumberoffull-heapcollectionsinbothawhole\u00adheap(column2)andagenerational(column3)collectorinaheapthatis2.5Xtheminimumsizeinwhichthebenchmarkcanrun.Column4reportsthenumberoftypes(bm)ineachbenchmark.HoweversinceJikesRVMisaJava-in-Javavirtualmachine,Corkanalyzesthevirtualmachinealongwiththebenchmarkduringeveryrun.Thuscolumn5(+VM)istheactualnumberoftypespotentiallyanalyzedateachcollection. \nForperformanceresults,weexplorethetime-spacetrade-offbyexecutingeachprogramonmoderatetolargeheapsizes,rangingfrom2.5Xto6Xthesmallestsizepossiblefortheexecutionoftheprogram.Weexecutetimingruns.vetimesineachcon.gurationandchoosethebestexecutiontime(i.e.,theoneleastdisturbedbyothereffectsinthesystem).Weperformseparaterunstogatheroverallandindividualcollectionstatistics.Weperformallofourperformanceexperimentsona3.2GHzIntelPentium4withhyper\u00adthreadingenabled,an8KB4-waysetassociativeL1datacache,a12K\u00b5opsL1instructiontracecache,a512KBuni.ed8-waysetassociativeL2on-chipcache,and1GBofmainmemory,runningLinux2.6.0. \n(a)BenchmarkStatistics (b)TypePoints-FromStatistics (c)SpaceOverhead #of #of #of #edges #edges % Alloc \nColltn types types pertype perTPFG pru- TIB TIB+Cork Benchmark MB whlgen bm +VM avg max avgmax avgmax \nned MB %H MB %H Diff Eclipse 3839 7311 1773 3365 667 775 2203 40907585 42.2 0.53 0.011 0.70 0.015 0.167 \nfop 137 90 700 2292 423 435 3406 15592623 45.2 0.36 0.160 0.55 0.655 0.495 pmd 518 361 340 1932 360 415 \n3121 9671297 66.0 0.30 0.031 0.44 0.186 0.155 ps 470 890 188 1780 314 317 293 813824 66.3 0.28 0.029 \n0.39 0.082 0.053 javac 192 150 161 1753 347 378 399 11182126 45.8 0.28 0.071 0.43 0.222 0.151 jython \n341 390 157 1749 351 368 2114 928940 66.2 0.28 0.041 0.39 0.112 0.071 jess 268 410 152 1744 318 319 289 \n844861 66.0 0.27 0.049 0.38 0.143 0.094 antlr 793 1196 112 1704 320 356 2123 8601398 55.8 0.27 0.016 \n0.39 0.282 0.266 bloat 710 295 71 1663 345 347 2101 8921329 50.6 0.26 0.017 0.38 0.064 0.047 jbb2000 \n** **** 71 1663 318 319 2110 9041122 59.0 0.26 ** 0.38 ** ** jack 279 470 61 1653 309 318 2107 838878 \n66.2 0.26 0.042 0.37 0.131 0.089 mtrt 142 170 37 1629 307 307 291 8201047 57.5 0.26 0.081 0.37 0.258 \n0.177 raytrace 135 200 36 1628 305 306 291 8141074 56.1 0.26 0.085 0.37 0.272 0.187 compress 106 63 16 \n1608 286 288 289 763898 60.9 0.25 0.105 0.36 0.336 0.231 db 75 80 8 1600 289 289 291 773787 66.1 0.25 \n0.160 0.35 0.467 0.307 Geomean30327n/a104181334235721161000130357.40.290.0480.410.1680.145  Table 1. \nBenchmarkCharacteristics.**VolumesforSPECjbb2000 dependonhowlongweallowthewarehousetorun. ForSPECjvm \nandDaCapo benchmarks,weusethestan\u00addardlargeinputs.SinceSPECjbb2000 measuresthroughputasoperationspersecondforadurationof2minutesforanin\u00adcreasingnumberofwarehouses(1to8)andeachwarehouseisstrictlyindependent,wechangethedefaultbehavior.Toperformaperformance-overheadcomparison,weusepseudojbb,avari\u00adantofSPECjbb2000 \nthatexecutesa.xednumberoftransac\u00adtions.Formemory-leakanalysis,wecon.gureSPECjbb2000 torunonlyonewarehouseforonehour.ForEclipse,weusetheDaCapo \nbenchmarkforgeneralstatisticsandperformance\u00adoverheadcomparisonsandversion 3.1.2 toreproduceadocu\u00admentedmemoryleakbyrepeatedlycomparingtwodirectorystruc\u00adtures(Eclipse \nbug#115789).  3.2 Space Overhead Table1(b)reportsTPFG spaceoverheadstatistics.Columnsoneandtwo(# of \ntypes)reporttheaverageandmaximumnumberoftypesintheheapduringanyparticulargarbagecollection.Wenoticethatwhilemanymoretypesexistinthesystem,anaverageof44%ofthemarepresentintheheapatatime.ThisfeaturereducesthenumberofpotentialcandidatesthatCorkmustanalyze. \nTable1(b)showstheaverage(column3)andmaximum(col\u00adumn4)numberofreferenceedgespertypenodeintheTPFG.We.ndthatmosttypenodeshaveaverysmallnumberofoutgoingreferenceedges(2onaverage).Themoreproli.catypeisintheheap,thegreaterthenumberofreferenceedgesinitsnode(upto406).WemeasuretheaverageandmaximumnumberofreferenceedgesinanyTPFG \n(columns5and6)andthepercentofthoseourheuristicsprunebecausetheirranksdropbelowzero(re <0)(col\u00adumn7).Theseresultsdemonstratethatthenumberofreferencesedgesislinearinthenumberoftypenodesinpractice. \nFinally,Table1(c)showsthespacerequirementsforthetypeinformationblockbefore(TIB)andtheoverheadaddedbyCork(TIB+Cork).WhileCorkaddssigni.cantlytotheTIBinformation,itaddsonlymodestlytotheoverallheap(0.145%onaverageandnevermorethan0.5%(column5)).Forthelongest-runningandlargestprogram,Eclipse,Corkhasatinyspaceoverhead(0.004%).ThusCorkisbothscalableandspace-ef.cientinpractice. \n 3.3 Performance Overhead Results Cork soverheadresultsfromconstructingtheTPFG duringscan\u00adningandfromdifferencingbetweenTPGFsto.ndgrowthattheendofeachcollectionphase.Figure5graphsthenormalizedgeo\u00admetricmeanoverallbenchmarkstoshowoverheadinscantime, \n(b)Rank (a)DecayFactorThresholdBenchmark 0%15%25%0100200 Eclipse bug#115789 fop pmd ps javac jython jess \nantlr bloat jbb2000 jack mtrt raytrace compress db 06 6126 622 2352 100 0110 000 030 000 0710 000 130 \n001 291 100 090 000 0330 004 4104 400 090 000 030 000 040 000 040 000 020 0 Table 2. Numberoftypesreportedinatleast25%ofgarbagecollectionreports:(a)Varyingthedecay \nfactor fromRatioRankingTechnique(Rt =100).Wechooseadecayfactorf =15%. thres (b)Varyingtherank threshold \nfromRatioRankingTechnique(f =15%).WechooserankthresholdRt =100. thres collector(GC)time,andtotaltime.Ineachgraph,they-axisrep\u00adresentstimenormalizedtotheunmodi.edJikesRVMusingthesamecollector,andthex-axisgraphsheapsizerelativetothemini\u00admumsizeeachbenchmarkcanruninamark-sweepcollector.Eachx \nrepresentsoneprogram.ItshowsCork saverageoverheadinagenerationalcollectortobe11.1%to13.2%forscantime;12.3%to14.9%forcollectortime;and1.9%to4.0%fortotaltime.Indi\u00advidualoverheadresultsrangehigher,butCork \nsaverageoverheadislowenoughtoconsiderusingitonlineinaproductionsystem. 3.4 Achieving Accuracy Cork saccuracydependsonitsabilityrankandreportgrowingtypes.Weexperimentwithdifferentsensitivitiesforboththedecayfactorf \nandtherankthresholdRthres.Table2showshowchangingthedecayfactorchangesthenumberofreportedtypes.We.ndthatthedetectionofgrowingtypesisnotverysensitivetosmallchangesinthedecayfactor.Wechooseamoderatedecayfactor(f \n= 15%)forwhichCorkaccuratelyidenti.estheonlygrowingdatastructuresinourbenchmarkswithoutanyfalsepositives.Table2(b)showshowincreasingtherankthresholdeliminatesfalsepositives \n2.51.2   Normalized Scanning Time 1.0 (a)ScanTime(b)GCTime(c)TotalTime Normalized Total Time 2.01.1 \n1.51.0 Figure 5. GeometricMeanOverheadGraphsoverallbenchmarksforgenerationalcollector fromourreports.Additionallyweexperimentwithdifferentrankthresholdsand.ndthatamoderaterankthreshold(Rthres \n=100)issuf.cienttoeliminateanyfalsepositives.Anextendedtechnicalreportcontainsmoreanalysisofboththedecayfactorandtherankthreshold[16]. \n3.5 Finding and Fixing Leaks Corkidenti.esheapgrowthinfourofourbenchmarks:fop,jess,SPECjbb2000 andEclipse.Forspaceconstraints,wedescribeSPECjbb2000 \nandEclipse indetail.Descriptionsofallbench\u00admarkscanbefoundinanextendedtechnicalreport[16]. SPECjbb2000 \n (a)SliceDiagram TheSPECjbb2000 benchmarkmodelsawholesalecompanywithseveralwarehouses(ordistricts).Eachwarehousehasoneterminalwherecustomerscangeneraterequests:e.g.,placenewordersor40requestthestatusofanexistingorder.Thewarehouseexecutesop\u00ad \n erationsinsequence,witheachoperationselectedfromthelistof operationsusingaprobabilitydistribution.Itimplementsthissys\u00adtementirelyinsoftwareusingJavaclassesfordatabasetablesandJavaobjectsfordatarecords(roughly25MBofdata).Theobjects \narestoredinmemoryusingBTree andotherdatastructures.RRTanalysisreportsfourcandidates:Order, Date, New- \nHeap occupancy (MB) 30 20 10 Order, andOrderLine.Therankofthefourcorrespondingtypenodesoscillatesbetweencollectionsmakingitdif.culttode\u00adterminetheirrelativeimportance.Examiningtheslicesofthefourreportedtypenodesrevealsthereason.Thereisaninterrelation\u00adshipbetweenallofthecandidatesandifoneisleakingthentherestareaswell.ThetopofFigure6(a)graphicallyshowsthesliceCorkreported(theshadedtypesaregrowing).Noticethatdespitetheproli.cuseofObject[] \ninSPECjbb2000,itstypenodevol\u00adumejitterstosuchadegreethatitnevershowssuf.cientgrowthtobereportedasleaking.Sincethesliceincludesalltypenodeswithrt \n>Rthres t andreferenceedgeswithre >0,thesliceseesbeyondtheObject[] tothecontainingdatastructures. WecorrelateCork \nsresultswithSPECjbb2000 simplementa\u00adtion.We.ndthatordersareplacedinanorderTable,imple\u00admentedasaBTree,whentheyarecreated.Whentheyarecom\u00adpletedduringaDeliveryTransaction,theyarenotproperlyremovedfromtheorderTable.ByaddingcodetoremovetheordersfromtheorderTable \n,weeliminatethismemoryleak.Figure6(b)showstheheapoccupancy,beforeandafterthebug.x,runningSPECjbb2000 \nwithonewarehouseforonehour.Ittookusonlyadayto.ndand.xthisbuginthislargeprogramthatwehadneverstudiedpreviously. \n0 Time (MB of allocation) (b)Heapoccupancygraph Figure 6. FixingSPECjbb2000 Eclipse Eclipse version \n3.1.2 isawidely-usedintegrateddevelopmenten\u00advironment(IDE)writteninJava[30].Eclipse isagoodbenchmarkbecauseitisbig,complex,andopen-source.Eclipse \nbug#115789 documentsanunresolvedmemoryleakintheEclipse bugreposi\u00adtoryfromSeptember2005.Werecreatethisbugbyrepeatedlycom\u00adparingthecontentsoftwodirectoriesstructures. \nCorkreportssixcandidates:File, Folder, Path, Ar\u00adrayList, Object[], andResourceCompareInput$-FilteredBufferedResourceNode \n.Figure7(a)showsthe Heap occupancy (MB) 30000 20000 10000 0 Before After 0100000200000300000400000500000 \nTime (MB of allocation) (b)Heapoccupancygraph Figure 7. FixingEclipse bug#115789 slicesforthecandidates,thecloseinterrelationshipbetweenthem,andseveralpossiblerootsoftheheapgrowth.Uponanalysis,weeliminatedseveralroots(indicatedbydottededgesinFig\u00adure7(a))reducingthepossiblerootstoone:alinkedlistcreatedbyResourceCompareInput$MyDiffNode. \nCorrelatingCork sresultswiththeEclipse implementationshowedthatuponcompletion,thedifferencesbetweenthetwodi\u00adrectorystructuresaredisplayedintheCompareEditorInput \nwhichisadialogthatisaddedtotheNavigationHistory .FurtherscrutinyshowedthattheNavigationHistoryEntry managedbyareferencecountingmechanismwastoblame.Whenadialogwasclosed,theNavigationHistoryEntry \nreferencecountwasnotdecrementedcorrectlyresultinginthedialogneverbeingremovedfromtheNavigationHistory \n.Figure7(b)showstheheapoccupancygraphsbeforeandafter.xingthemem\u00adoryleak.Thisbugtookusaboutthreeandahalfdaysto.x,thelongestofanyofourbenchmarks,duetothesizeandcomplexityofEclipse \nandourlackofexpertiseontheimplementationde\u00adtails.Whilewe.xedthemajorsourcegrowthintheheap,thereremainsasmallgrowthwhichatthetimeofthiswritingwehavenotinvestigated. \n4. Related Work Theproblemofdetectingmemoryleaksiswellstudied.Compile\u00adtimeanalysiscan.nddoublefreeandmissingfrees[14]andiscomplimentarytoourwork.Of.inediagnostictoolsaccuratelyde\u00adtectleaksusingacombinationofheapdifferencing[10,11,20]and.ned-grainedallocation/usagetracking[8,13,24,25,28,29].Theseapproachesareexpensiveandoftenrequiremultipleexe\u00adcutionsand/orseparateanalysistogeneratecomplexreportsfulloflow-leveldetailsaboutindividualobjects.Incontrast,Cork \nscompletelyonlineanalysisreportssummariesofobjectsbytypewhileconciselyidentifyingthedynamicdatastructurecontainingthegrowth.Onlinediagnostictoolsreliesondetectingwhenob\u00adjectsexceedtheirexpectedlifetimes[19]and/ordetectingwhenanobjectbecomesstale \n[7,9].Weimproveontheef.ciencyofthesetechniques.However,theydifferentiatein-useobjectsfromthosenot-inuse,addingadditionalinformationtotheirreports. \n TheclosestrelatedworkisLeakbot[12,17,18]whichcom\u00adbinesof.ineanalysiswithonlinediagnosisto.nddatastructureswithmemoryleaks.LeakbotusesJVMPItotakeheapsnapshotsof\u00ad.oadedtoanotherprocessorforanalysis(wecallthisof.ine \nanaly\u00adsissinceitisnotusingthesameresourcesastheprogramalthoughitmayoccurconcurrentlywithprogramexecution).Byof.oadingtheexpensivepartifitsanalysistoanotherprocessor(heapdiffer\u00adencingandrankingpartsoftheobject \ngraphwhichmaybeleaking),Leakbotminimizestheimpactontheapplicationandtheperceivedoverheadoftheanalysis.Thus,Leakbotreliesonanadditionalpro\u00adcessorandmultiplecopiesoftheheap \namemoryoverheadpoten\u00adtially200%ormorethatisproportionaltotheheap toperformheapdifferencingandreportobjectlevelstatistics.Cork,ontheotherhand,summarizesobjectinstancesinaTPFG \ngraphwhileminimizingthememoryoverhead(lessthan1%)andallowingittoruncontinuouslyandconcurrentlywiththeapplication. \n5. Conclusion Thispaperintroducesanovelandef.cientwaytosummarizetheheaptoidentifytypeswhichcausesystematicheapgrowth,thedatastructureswhichcontainsthem,andtheallocationsite(s)whichal\u00adlocatethem.WeimplementthisapproachinCork,atoolthatiden\u00adti.esgrowthintheheapandreportsslicesofasummarizingtypepoints-fromgraph.Corkcalculatesthisinformationbypiggyback\u00adingonfull-heapgarbagecollections.WeshowthatCorkaddsonly2.3%tototaltimeonmoderatetolargeheapsinagenerationalcollector.Corkpreciselyidenti.esdatastructureswithunboundedheapgrowthinfourpopularbenchmarks:fop,jess,jbb2000,andEclipse \nandweuseitsreportstoanalyzeandeliminatememoryleaks.Corkishighly-accurate,low-overhead,scalable,andisthe.rsttoolto.ndmemoryleakswithlowenoughoverheadtocon\u00adsiderusinginproductionVMdeployments. \nAcknowledgments WewouldliketothankSteveBlackburn,RobinGarner,XianglongHuang,andJenniferSartorfortheirhelp,input,anddiscussionsonthepreliminaryversionsofthiswork.AdditionalthanksgotoRicardoMorinandElenaIlyina(IntelCorporation),andAdamAdamson(IBM)fortheirassistancewithcon.rmingthememoryleakinjbb2000,andMikeBondforhisassistancewithEclipse.Finally,wewouldliketothankMicrosoftforprovidingfundingforthisandfuturework. \nReferences [1]B.Alpern,C.R.Attanasio,A.Cocchi,D.Lieber,S.Smith,T.Ngo,J.J.Barton,S.F.Hummel,J.C.Sheperd,andM.Mergen.ImplementingJalape \nnoinJava.InOOPSLA 99: Proceeding of the 14th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, \nLanguages, and Applications,pages314 324,Denver,Colorado,USA,November1999. [2]M. Arnold,S.Fink,D.Grove,M.Hind,andP.F.Sweeney. \nAdaptiveOptimizationintheJalape noJVM.InOOPSLA 00: Proceedings of the 15th ACM SIGPLAN Conference on \nObject\u00ad Oriented Programming, Systems, Languages, and Applications,pages47 65,Minneapolis,Minnesota,USA,October2000. \n[3]S.M.Blackburn,P.Cheng,andK.S.McKinley. MythsandRealities:ThePerformanceImpactonGarbageCollection.InProceedings \nof the International Conference on Measurement and Modeling of Computer Systems,pages25 36,NewYork,NewYork,USA,June2004. \n[4]S.M.Blackburn,P.Cheng,andK.S.McKinley. OilandWater?HighPerformanceGarbageCollectioninJavawithJMTk.InICSE \n04: Proceedings of the 26th International Conference on Software Engineering,pages137 146,Scotland,UnitedKingdom,May2004.IEEEComputerSociety. \n[5]S.M.Blackburn,R.Garner,C.Hoffman,A.M.Khan,K.S.McKinley, R.Bentzur,A.Diwan,D.Feinberg,D.Frampton,S.Z.Guyer, \nM.Hirzel,A.Hosking,M.Jump,H.Lee,J.E.B.Moss,D.Stefanovi\u00b4c, T.VanDrunen,D.vonDincklage,andB.Wiedermann.TheDaCapoBenchmarks:JavaBenchmarkingDevelopmentandAnalysis.In \nOOPSLA 06: Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programing, Systems, Languages, \nand Applications,Portland,Oregon,USA,October2006.http://www.dacapobench.org. [6]S.M.Blackburn,R.Garner,C.Hoffman,A.M.Khan,K.S.McKinley, \nR.Bentzur,A.Diwan,D.Feinberg,D.Frampton,S.Z.Guyer, M.Hirzel,A.Hosking,M.Jump,H.Lee,J.E.B.Moss,D.Stefanovi\u00b4c, \nT.VanDrunen,D.vonDincklage,andB.Wiedermann.TheDaCapoBenchmarks:JavaBenchmarkingDevelopmentandAnalysis.Technicalreport,October2006.http://www.dacapobench.org. \n[7]M.D.BondandK.S.McKinley. Bell:Bit-EncodingOnlineMemoryLeakDetection.InASPLOS XII: Proceedings of the \n12th International Conference on Architectural Support for Programming Languages and Operating Systems,SanJose,California,USA,October2006. \n[8]J.CampanandE.Muller.PerformanceTuningEssentialforJ2SEandJ2EE:MinimizeMemoryLeakswithBorlandOptimizeitSuite.WhitePaper,BorlandSoftwareCorporation,March2002. \n[9]T.M.ChilimbiandM.Hauswirth. Low-OverheadMemoryLeakDetectionusingAdaptiveStatisticalPro.ling.InASPLOS-XI: \nProceedings of the 11th International Conference on Architectural Support for Programming Languages and \nOperating Systems,pages156 164,Boston,Massachusetts,USA,October2004. [10]W.DePauw,D.Lorenz,J.Vlissides,andM.Wegman. \nExecutionPatternsinObject-OrientedVisualization.InProceedings of the 4th USENIX Conference on Object-Oriented \nTechnologies and Systems (COOTS),pages219 234,SantaFe,NewMexico,USA,April1998. [11]W. DePauwandG.Sevitsky.VisualizingReferencePatternsforSolvingMemoryLeaksinJava.Concurrency: \nPractice and Experience,12(12):1431 1454,November2000. [12]S.C.GuptaandR.Palanki.JavaMemoryLeaks CatchMeIfYouCan:DetectingJavaLeaksusingIBMRationalApplicationDeveloper \n6.0.Technicalreport,IBM,August2005. [13]R.HastingsandB.Joyce. Purify:AToolforDetectingMemoryLeaksandAccessErrorsinCandC++Programs.InProceedings \nof the Winter 1992 USENIX Conference,pages125 138,Berkley,California,USA,January1992. [14]D. L.HeineandM.S.Lam.APracticalFlow-SensitiveandContext-SensitiveCandC++MemoryLeakDetector.InPLDI \n03: Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation,pages168 \n181,SanDiego,California,USA,June2003. [15]X.Huang,S.M.Blackburn,K.S.McKinley,J.E.B.Moss,Z.Wang,andP.Cheng.TheGarbageCollectionAdvantage:ImprovingProgramLocality.InOOPSLA \n04: Proceedings of the 19th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, \nand Applications,pages69 80,Vancouver,BC,Canada,October2004. [16]M. JumpandK.S.McKinley.Cork:DynamicMemoryLeakDetectionforJava.TechnicalReportTR-06-07,DepartmentofComputerSciences,TheUniversityofTexasatAustin,Austin,Texas78712,January2006. \n[17]N.Mitchell,May2006.Personalcommunication. [18]N.MitchellandG.Sevitzky.LeakBot:AnAutomatedandLightweightToolforDiagnosingMemoryLeaksinLargeJavaApplications.InECOOP \n2003 Object Oriented Programming: 17th European Conference,volume2743ofLecture Notes in Computer Science,pages351 \n377,Darmstadt,Germany,July2003.Springer-Verlag. [19]F.Qin,S.Lu,andY.Zhou. SafeMem:ExploitingECC-MemoryforDetectingMemoryLeaksandMemoryCorruptionDuringProductionRuns.InHPCA-11: \nProceedings of the 11th International Symposium on High-Performance Computer Architecture,pages291 302,Cambridge,Massachusetts,USA,February2002.IEEEComputerSociety. \n[20]QuestSoftware.JProbeMemoryDebugger:EliminateMemoryLeaksandExcessiveGarbageCollection.http://www.quest.com/jprobe/pro.ler.asp. \n[21]N.R\u00a8ojemo.GenerationalGarbageCollectionwithoutTemporarySpaceLeaks.InIWMM 95: Proceeding of the International \nWorkshop on Memory Management,1995. [22]N.R\u00a8ojemoandC.Runciman.Lag,Drag,VoidandUse HeapPro.lingandSpace-Ef.cientCompilationRevised.InICFP \n96: Proceedings of the First ACM SIGPLAN International Conference on Functional Programming,pages34 41,Philadelphia,Pennsylvania,USA,May1996. \n[23]C.RuncimanandN.R\u00a8ojemo.HeapPro.lingforSpaceEf.ciency.InE.M.J.LaunchburyandT.Sheard,editors,Advanced \nFunctional Programming, Second International School-Tutorial Text,pages159 183,London,UnitedKingdome,August1996.Springer-Verlag. \n[24]M.SerranoandH.-J.Boehm. UnderstandingMemoryAllocationofSchemePrograms.InICFP 00: Proceedings of the \nFifth ACM SIGPLAN International Conference on Functional Programming,pages245 256,Montr\u00b4eal,Qu\u00b4ebec,Canada,September2000. \n[25]R.Shaham,E.K.Kolodner,andM.Sagiv. AutomaticRemovalofArrayMemoryLeaksinJava.InCC 00: Proceedings of \nthe 9th International Conference on Compiler Construction,volume1781ofLecture Notes in Computer Science,pages50 \n66,London,UnitedKingdom,2000.Springer-Verlag. [26]StandardPerformanceEvaluationCorporation. SPECjvm98 \nDocu\u00admentation,release1.03edition,March1999. [27]StandardPerformanceEvaluationCorporation. SPECjbb2000 \n(Java Business Benchmark) Documentation,release1.01edition,2001. [28]SunMicrosystems.HeapAnalysisTool.https://hat.dev.java.net/. \n[29]SunMicrosystems. HPROFPro.lerAgent.http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html. [30]TheEclipseFoundation.EclipseHomepage.http://www.eclipse.org. \n \n\t\t\t", "proc_id": "1190216", "abstract": "A <i>memory leak</i> in a garbage-collected program occurs when the program inadvertently maintains references to objects that it no longer needs. Memory leaks cause systematic heap growth, degrading performance and resulting in program crashes after perhaps days or weeks of execution. Prior approaches for detecting memory leaks rely on heap differencing or detailed object statistics which store state proportional to the number of objects in the heap. These overheads preclude their use on the same processor for deployed long-running applications.This paper introduces a dynamic heap-summarization technique based on type that accurately identifies leaks, is space efficient (adding less than 1% to the heap), and is time efficient (adding 2.3% on average to total execution time). We implement this approach in <i>Cork</i> which utilizes dynamic type information and garbage collection to summarize the live objects in a <i>type points-from graph</i> (<i>TPFG</i>) whose nodes (types) and edges (references between types) are annotated with volume. <i>Cork</i> compares <i>TPFG</i>s across multiple collections, identifies growing data structures, and computes a <i>type slice</i> for the user. Cork is accurate: it identifies systematic heap growth with no false positives in 4 of 15 benchmarks we tested. Cork's slice report enabled us (non-experts) to quickly eliminate growing data structures in SPECjbb2000 and Elipse, something their developers had not previously done. Cork is accurate, scalable, and efficient enough to consider using online.", "authors": [{"name": "Maria Jump", "author_profile_id": "81100432998", "affiliation": "The University of Texas at Austin, Austin, Texas", "person_id": "P699720", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "The University of Texas at Austin, Austin, Texas", "person_id": "P157900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190224", "year": "2007", "article_id": "1190224", "conference": "POPL", "title": "Cork: dynamic memory leak detection for garbage-collected languages", "url": "http://dl.acm.org/citation.cfm?id=1190224"}