{"article_publication_date": "01-17-2007", "fulltext": "\n Context Logic as Modal Logic: Completeness and Parametric Inexpressivity Cristiano Calcagno Philippa \nGardner Uri Zarfaty Department of Computing, Imperial College London {ccris,pg,udz}@doc.ic.ac.uk Abstract \nSeparation Logic, Ambient Logic and Context Logic are based on a similar style of reasoning about structured \ndata. They each consist of a structural (separating) composition for reasoning about dis\u00adjoint subdata, \nand corresponding structural adjoint(s) for reasoning hypothetically about data. We show how to interpret \nthese struc\u00adtural connectives as modalities in Modal Logic and prove complete\u00adness results. The structural \nconnectives are essential for describing properties of the underlying data, such as weakest preconditions \nfor Hoare reasoning for Separation and Context Logic, and secu\u00adrity properties for Ambient Logic. In \nfact, we introduced Context Logic to reason about tree update, precisely because the structural connectives \nof the Ambient Logic did not have enough expressive power. Despite these connectives being essential, \n.rst Lozes then Dawar, Gardner and Ghelli proved elimination results for Separa\u00adtion Logic and Ambient \nLogic (without quanti.ers). In this paper, we solve this apparent contradiction. We study parametric \ninexpres\u00adsivity results, which demonstrate that the structural connectives are indeed fundamental for \nthis style of reasoning. Categories and Subject Descriptors D.2.4 [Software/Program veri.cation]: Correctness \nproofs, Formal methods, Validation General Terms Languages, Theory, Veri.cation Keywords Logic, Expressivity, \nStructured Data, Contexts 1. Introduction Separation Logic (SL) and Ambient Logic (AL) are related log\u00adics \nfor reasoning about heaps and trees respectively. O Hearn, Reynolds and Yang introduced SL [8, 11, 13] \nto develop local Hoare reasoning about heap update, based on the general theory of Bunched Logic (BL) \ndue to O Hearn and Pym [10]. Cardelli and Gordon independently introduced AL [5] for reasoning about \nstatic trees. AL has been used to reason about security properties of .rewalls and structural properties \nof XML [6]. We have integrated these two lines of research. In [3], we showed that it is not possible \nto use AL to reason about tree update (XML update). Instead, we introduced the general theory of Context \nLogic (CL) for reasoning about structured data, which generalises BL. We demonstrated that the application \nof CL-reasoning to trees can be used as a basis for Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; \n2007 ACM 1-59593-575-4/07/0001. . . $5.00 local Hoare reasoning about tree update, whilst the application \nof CL-reasoning to heaps exactly corresponds to SL-reasoning. These logics are based on a similar style \nof reasoning about structured data. They each extend propositional connectives with a structural (separating) \ncomposition for reasoning about disjoint subdata, and the corresponding structural adjoint(s).1 We show \nhow to interpret the structural connectives of BL and CL as modalities in modal logic (ML). We present \nadditional axioms for these modali\u00adties to give a precise correspondence between the original presenta\u00adtion \nof BL and CL, and their ML-interpretations. These axioms are well-behaved, in that they satisfy the conditions \nnecessary for us to apply a general completeness result about ML (Sahlqvist s the\u00adorem). We thus prove \nthat the CL-proof theory is sound and com\u00adplete with respect to the set of CL-models (and analogously \nfor BL). This work follows previous unpublished work by Calcagno and Yang, who proved completeness for \nCL from .rst principles. The structural connectives are essential for modular reason\u00ading about programs, \nand for describing weakest preconditions and safety properties. However, recent expressivity results \nfor SL and AL due to Lozes [9] appear to contradict this fundamental claim. Lozes concentrates on expressivity \nfor closed formulae, determin\u00ading whether an arbitrary closed formula specifying a set of data in one \nlogic can be expressed by a formula in the other logic speci\u00adfying the same set of data. For example, \nLozes has shown that SL and Propositional Logic (PL) with simple atomic heap formulae are equally expressive \nusing this de.nition of expressivity. How\u00adever, our experience says that SL is more expressive than PL, \nsince for example we can reason directly about disjointness and dynamic update of linked lists. We solve \nthis apparent mismatch between the theoretical results and our practical experience by proving in\u00adexpressivity \nresults for stronger de.nitions of expressivity. SL forms the basis of local Hoare reasoning about heap \nupdate. An important part of the reasoning is to be able to express the weakest preconditions, which \nprovide completeness for straight\u00adline code and have a key role in some veri.cation tools (to verify \na Hoare triple, .rst .nd the weakest precondition of a given postcon\u00addition and then prove that the given \nprecondition implies the weak\u00adest precondition). Our results show that the weakest preconditions cannot \nbe expressed in PL for heaps. To illustrate this, consider the weakest precondition of allocation (n*p, \nspecifying that .0) -whenever a cell with address n and value 0 is added to the given heap then the resulting \nheap satis.es post-condition p. Lozes result says that, for every interpretation of p as a set of data \ndetermined by a closed formula, there is a corresponding PL-formula. How\u00adever, these PL-formulae are \nhighly non-uniform with respect to the post-condition p, and Lozes result says nothing about whether \nthe weakest precondition itself can be speci.ed in PL. We show that it is not possible, by studying expressivity \nfor open formulae con\u00ad 1 In this paper, we do not consider quanti.cation. taining propositional variables. \nThis notion of expressivity deter\u00admines whether an arbitrary open formula in one logic, specifying a \nfunction from sets to data to sets of data, can be expressed by a formula in the other logic. There are \ntwo choices for the domain of this function, either as sets of data speci.ed by closed formulae or as \narbitrary sets of data. The .rst option is enough to determine whether the weakest precondition can be \nspeci.ed in PL. It does not however allow for natural extensions to SL, such as the addition of inductive \npredicates. We therefore study the second option. We call this type of expressivity parametric expressivity,and \nshow that SL is parametrically more expressive than PL for heaps by demonstrat\u00ading that (n.0) -*pcannot \nbe expressed in PL. Although the SL-adjoint -*is important for the weakest pre\u00adconditions and has a key \nrole in some proofs [12], it is not typi\u00adcally used for specifying safety properties. For example, it \nplays no role in the veri.cation tool Smallfoot [1], which combines in\u00adductive predicates with a cut-down \ndecidable fragment of SL (with quanti.cation). A more fundamental SL-formula is p*qspecifying that the \nheap can be split into two disjoint parts, one satisfying p and the other q. Lozes results imply that, \nfor every interpretation of p and q as sets of data corresponding to closed formulae, there is a corresponding \nPL-formula. Again, the PL-formulae are highly non-uniform. We show that it is not possible to express \nparametri\u00adcally this formula in PL. However, with the Smallfoot application in mind, it is perhaps more \ninteresting to determine a speci.c in\u00adexpressivity result, that it is not possible to express p *q in \nPL with the interpretation of p as list(3), denoting the existence of a 0-terminated linked list starting \nat address 3,and q as list(4).To do this, we study the notion of strong expressivity which states that, \nfor a speci.c interpretation of the propositional variables as arbi\u00adtrary sets of data, every formula \nwith propositional variables in one logic can be expressed in the other logic. To prove our strong inexpressivity \nresults, we use a standard bisimulation technique from ML. For example, consider the heaps ' ''' '' h1 \n=[3 .n,4 .n,n.0,n.0] ' '' '' h2 =[3 .n,4 .n,n.0,n.0]. These heaps are distinguished by SL-formula p *q, \nwith the in\u00adterpretation of pand q as the lists list(3) and list(4) respectively, since h1 can be split \ninto the appropriate disjoint lists whereas h2 cannot due to the sharing at address n'. Our proof shows \nthat there is a PL-bisimulation relation relating h1 and h2. Bisimulation has the well-known property \nthat it is contained in logical equivalence. Thus, the heaps h1 and h2 are indistinguishable using PL. \nOur original motivation for studying parametric inexpressivity results came from studying CL for trees \nand AL. We introduced CL to provide local Hoare reasoning about tree update [3], demon\u00adstrating that \nit was not possible to base our Hoare reasoning on AL since it had a missing adjoint. Whilst we believe \nthat our argument was convincing, it was an argument given by example rather than by a formal inexpressivity \nresult. Lozes expressivity results, fo\u00adcussing on the closed formulae, show that the argument is subtle \nsince AL (without quanti.ers) is as expressive as the logic without the structural adjoints [9, 6]. We \nprove that CL for trees is paramet\u00adrically more expressive than AL. Unlike the results for SL, we do \nnot know how to prove this directly. Instead, we prove a strong in\u00adexpressivity result using an analogous \nproof method to that outlined above. Since strong inexpressivity implies parametric inexpressiv\u00adity, \nwe have the result. In addition, we prove that CL for trees minus the extra adjoint is parametrically \nas expressive as AL, thus show\u00ading that the additional strength of the CL-reasoning does indeed come \nfrom this additional adjoint. We also prove similar results for CL for sequences and a variation of BL \napplied to sequences (*is non-commutative). Sequences provide the simplest example of the differences \nbetween CL-and BL-reasoning. Again, we prove our parametric inexpressivity result via strong inexpressivity. \n 2. Context Logic and Bunched Logic We review the general theory of CL and BL. 2.1 Context Logic We introduced \nCL to reason about data update [3]. Local data up\u00addate typically identi.es the portion of data to be \nreplaced, removes it, and inserts the new data in the same place.With CL,we reason about both data and \nthis place of insertion (contexts). CL consists of data formula denoted by P, and context formulae denoted \nby K. In each case, these include standard formulae from propositional logic, and less familiar structural \nformulae for directly analysing the data and context structure. De.nition 1 (CL-Formulae). The set of \nCL-formulae consists of disjoint sets of data formulae Pand context formulae K, con\u00adstructed from a set \nof propositional variables V= VP .VK where VP and VK are disjoint, countably in.nite sets of propositional \ndata variables and context variables respectively. The formulae are given by the grammars: data formulae \nP ::= K(P) |K < P structural formulae P .P |\u00acP |false additive formulae p,p1,p2,... prop vars in VP context \nformulae K ::= I |P C P structural formulae K .K |\u00acK |False additive formulae k,k1,k2,... prop vars in \nVK The key formulae are the structural formulae K(P), K < P, P1 C P2 and I.The application formula K(P) \nspeci.es that the given data element can be split into a context satisfying K applied to data satisfying \nP. For example, if we de.ne the context formula True \" \u00acFalse, then the formula True(P) states that some \nsubdata satis.es property P. The next two formulae are both (right) adjoints of application. The formula \nK< P is satis.ed by the given data if, whenever we insert the data into a context satisfying K,then the \nresult satis.es P. For example, the formula (True <P) states that, when the data is put in any context, \nthe resulting data satis.es property P. The analogous connectives for AL have been used to describe security \nproperties of trees (ambients). Meanwhile, P1 C P2 is a statement on contexts. It is satis.ed by a given \ncontext if, whenever we insert in the context some data satisfying P1, then the result satis.es P2. Given \nthe derived data formula true \" \u00acfalse, the context formula (truecP2) states that, regardless of what \ndata is put in the context hole, the resulting data satis.es property P2.This adjoint is essential for \nexpressing weakest preconditions for update commands, as we demonstrated in [3], and has no counterpart \nin AL. The context formula I speci.es the empty context. De.nition 2 (CL-Model). A CL-model Mis a tuple \n(D,C,ap,I) such that 1. Dand Care sets; 2. ap.(C\u00d7D) \u00d7Dis a relation, called application:we use the notation \nap(c,d1)= d2 for ((c,d1),d2) .ap; 3. I .Cacts as a left identity to ap: that is,  .d.D,.i.I,d' .D.ap(i,d)= \nd';  .d,d' .D,.i.I.ap(i,d)= d' implies d= d'.   We often call Dthe data set and Cthe context set, \nbecause of the form of our motivating examples. Of course, there are mod\u00adels which do not .t this structured \ndata intuition. We prove com\u00adpleteness for these CL-models (theorem 23) and the analogous BL\u00admodels (section \n3.2). Example 3. MonD =(D,D,\u00b7,{e}) where Dis a partial monoid with binary operation \u00b7:(D\u00d7D)-Dand unit \ne .D.  Heap is an example of MonD where D=N+ -fin N is the set of .nite partial functions denoting the \nheaps and e denotes the empty heap. The domain N+ =N-{0}does not include 0as it is reserved for the null \nlocation. Given heaps h,h ' ,the heap composition h \u00b7h ' is function union which is only de.ned when \ndom(h)ndom(h ' )=\u00d8. TermS =(DS,CS,ap,{ }) where DS is the data set of terms constructed from the n-ary \nfunction symbols in signature S, CS is the corresponding set of contexts, ap denotes the standard application \nof contexts to terms, and  denotes the empty context. SeqA =(DA,CA,ap,{ })where DA is the set of sequences \nconstructed from the elements in alphabet A, CA is the corre\u00adsponding set of contexts, and ap and  are \nas for TermS.  TreeA is an example of TermS with an additional equality relation on terms. The terms \nare generated by the signature S constructed from the sets S0 ={0}, S1 =A and S2 ={|}, where Si denotes \nthe function symbols of arity i.We use the notation t |t ' for |(t,t ' )and a[t]for a(t). Terms are considered \nmodulo an equality relation generated by the axioms 0|t =t,  ' ' ''' ''' t |t =t |t, (t |t )|t =t |(t \n|t ), and closed by the obvious structural rules for the function symbols. RelD =(D,P(D\u00d7D),ap,{i}) where \nDis an arbitrary set, P(D\u00d7D)denotes the set of binary relations on D, ap is relational application, and \ni is the identity relation. De.nition 4 (CL-Satisfaction Relation). GivenaCL-model M= (D,C,ap,I), the \nCL-satisfaction relation FCL consists of two re\u00adlations s, M,d FP P and s, M,c FK K where d .D, c .Cand \ninterpretation function s :V.P(D.K)maps data proposi\u00adtional variables to sets of data, and context propositional \nvariables to sets of contexts. The two relations are de.ned by induction on the structure of the formulae: \nthe cases for the propositional variables and the boolean additive connectives are standard; the cases \nfor the structural connectives are s, M,d FP K(P) iff .c .C,d ' .D. ap(c,d ' )=d .s,M,c FK K .s,M,d ' \nFP P s, M,d FP K < P iff .c .C,d ' .D. s,M,c FK K .ap(c,d)=d ' .s, M,d ' FP P s, M,c FK I iff c .I s, \nM,c FK P1 C P2 iff .d,d ' .D. s,M,d FP P1 .ap(c,d)=d ' .s, M,d ' FP P2 We sometimes omit the subscripts \nPand K. In section 4, we study applications of CL to heaps, sequences and trees, which extend CL with \nsimple atomic formulae speci.c to these models. Here, we use the SeqA model and the additional zero formula \n0, denoting the empty sequence, to illustrate our CL\u00adreasoning. Consider the derived formula 1 \" \u00ac0.\u00ac(\u00acI)(\u00ac0), \nwhich states that the sequence only contains one element: that is, it is non-empty and cannot be split \ninto a non-empty context and non-empty data. Now consider the judgement s,SeqA,s F (0C p)(1), where s(p)denotes \nthe set of sequences with equal elements and s denotes a sequence. This judgement only holds if s is \nnon-empty and all the elements in sare equal except possibly one: for example, it holds when s is b \u00b7a \n\u00b7b, but not when s is b \u00b7a \u00b7c. We use the standard derived classical formulae for both data and context \nformulae: true, P .P and P .P; similarly for contexts, writing True for the context formula that is always \nsatis.ed. We shall also use the following derived formulae: oP \" True(P)speci.es that somewhere property \nP holds; P1 . P2 \" \u00ac(P1 C \u00acP2)speci.es that there exists some data element satisfying property P1 such \nthat, when it is put in the hole of the given context, the resulting data satis.es P2;  K . P2 \" \u00ac(K \n< \u00acP2)speci.es that there exists a context satisfying property K such that, when the given data element \nis put in the hole, the resulting data satis.es P2.  We give a Hilbert-style proof theory, following \nthe style for BL in [10]. The axioms and rules for the structural operators state that K<P2 and P1 cP2 \nare right adjoints of K(P1),and I is the identity of application. De.nition 5 (CL-Proof Theory). The \nHilbert-style CL-proof the\u00adory consists of the standard axioms and rules for the boolean addi\u00adtive connectives, \nand the following axioms and rules for the struc\u00adtural connectives: K1 fK K2 P1 fP P2 P -fP I(P) K1(P1)fP \nK2(P2) K(P1)fP P2 K fK P1 C P2 P fP P1 K fK P1 C P2 K(P)fP P2 K(P1)fP P2 P1 fP K < P2 K1 fK K P1 fP K \n< P2 K1(P1)fP P2 We sometimes omit the subscripts in fP and fK, and sometimes write fCL to refer explicitly \nto this CL-proof theory. The proof theory given here emphasises the right adjoint proper\u00adties of < and \nC. In the next section, we show that this proof theory is equivalent to the standard ML-proof theory \nplus an additional set of axioms speci.c to CL. This alternative formulation emphasises the derived connectives \n. and . instead. 2.2 Bunched Logic We also present (a variant of) BL [10], its models and satisfaction \nrelation, and compare it to CL. We use the notation .and -., instead of the standard *and -*for the multiplicative \nconjunction and its adjoint. Our variation of standard BL does not require .to be commutative, since \none of our key example models is sequences where .denotes concatenation. De.nition 6 (BL-Formulae). The \nset of BL formulae Pis con\u00adstructed from a countably in.nite set of propositional variables VP , and \nde.ned by the grammar: P ::= 0|P .P |P .-P |P -.P structural formulae P .P |\u00acP |false additive formulae \np,p1,p2,... prop vars in VP The key formulae are the structural formulae 0, P1 .P2, P1 .-P2 and P1 -.P2.The \nzero formula 0speci.es empty data. The compo\u00adsition formula splits the given data into two parts, the \n.rst satisfying P1 and the second P2. For example, the formula \u00ac0.\u00ac0speci.es that the given data can \nbe split into two disjoint, non-empty parts. Unlike the original BL, we have two right adjoints, due \nto .be\u00ading non-commutative: P1 .-P2 speci.es that, whenever some data satisfying P1 is placed to the \nleft of the given data, then the result satis.es P2; the other adjoint P1 -.P2 places data to the right. \nThis distinction has no effect in the heap model, but is important in the sequence model. As in CL, we \nde.ne the negation duals of the ad\u00adjoints as P1 - P2 \" \u00ac(P1 -.\u00acP2)and P1 -P2 \" \u00ac(P1 .-\u00acP2). De.nition \n7 (BL-Model). A BL-model Mis a tuple (D,\u00b7,e)such that 1. Dis a set; 2. \u00b7.(D\u00d7D)\u00d7Dis an associative relation: \nwe use the notation d1 \u00b7d2 =d3 for ((d1,d2),d3).\u00b7; 3. e .Dacts as a left and right identity to \u00b7: that \nis,  .d.D,.e.e,d ' .D.e\u00b7d=d '  .d.D,.e.e,d ' .D.d\u00b7e=d '   ' ''' .d,d .D,.e.e.e\u00b7d=d or d\u00b7e=d implies \nd=d . Any BL-model M=(D,\u00b7,e)can be transformed into a CL-model MBL =(D,D,\u00b7,e). We highlight speci.c BL-models \nfor heaps, sequences and trees, since we will use them throughout this paper. Example 8. Heap=(D,\u00b7,{e})where \nD, \u00b7and eare as in Example 3.  SeqA =(DA,\u00b7,{0})where DA is the set of sequences con\u00adstructed from the \nelements in set A, \u00b7is sequence concatenation, and 0is the empty sequence.  TreeA =(DA,|,{0})where DA \nis the set of trees in Exam\u00adple 3, |is horizontal tree composition, and 0is the empty tree.  Contrast \nthese BL-models with the analogous CL-models given in Example 3, which also emphasise the context structure. \nThe heap model is essentially the same, with the context set being the same as the data set. However, \nthe sequence and tree models are different, since the context set is more complex than the data set. \nDe.nition 9 (BL-Satisfaction Relation). GivenaBL-model M= (D,\u00b7,e), the BL-satisfaction relation is of \nthe form s,M,d FBL P where d .D, and s : VP .P(D). As before, it is de.ned by induction on the structure \nof formulae. We only give the cases for the structural connectives: s,M,d FBL P1 .P2 iff .d1,d2 .D. d1 \n\u00b7d2 =d.s,M,d1 FBL P1 .s,M,d2 FBL P2 s,M,d FBL 0 iff d.e s,M,d FBL P1 -.P2 iff .d1,d2 .D. s,M,d1 FBL P1 \n.d\u00b7d1 =d2 .s,M,d2 FBL P2 s,M,d FBL P1 .-P2 iff .d1,d2 .D. s,M,d1 FBL P1 .d1 \u00b7d=d2 .s,M,d2 FBL P2 Consider \nthe BL-model SeqA, the derived BL-formula 1\" \u00ac0.\u00ac(\u00ac0.\u00ac0)specifying sequences of length one, and the BL-relation \ns,SeqA,s FBL (0-.p).1, where s(p)again denotes the set of sequences with equal elements. This relation \nonly holds if s is a non-empty sequence consisting of equal elements except the last one which can be \nanything: for example, the relation holds when sis b\u00b7b\u00b7a, but does not hold when sis b\u00b7a\u00b7band b\u00b7a\u00b7c. \nThis simple example illustrates the difference between BL-and CL-reasoning: BL-reasoning analyses the \nends of the sequences, whereas CL-reasoning also analyses the middle. However, when the CL-model arises \nfrom a BL-model, there is a strong relationship between BL-reasoning and and CL-reasoning. We give this \ncorrespondence explicitly for heaps in Proposition 26. The Hilbert-style BL-proof theory consists of \nanalogous rules to those given for the CL-proof theory (De.nition 5), with an additional axiom for the \nassociativity of ..  3. Connection to Modal Logic We recall some general theory of ML, and show how \nCL and BL .t within this formalism. We prove completeness results relating the CL-and BL-proof theories \nwith their respective models, by appealing to a general theorem of ML due to Sahlqvist. De.nition 10 \n(ML-Signature). A ML-signature is a triple S= (S,O,. : O .T),where Sis a set of sorts ranged over by \nS, O is a set of modalities ranged over by ., Tis a set of types of the form (S1,...,Sn).S for Si,S .S, \nand .is a function. We write .:T when .(.)=T. De.nition 11 (ML-Model2). Given a ML-signature S=(S,O,.), \na ML-model MS generated from Sconsists of a set MS for each S .S, and an interpretation M. .(MS1 \u00d7\u00b7\u00b7\u00b7\u00d7MSn)\u00d7MS \nfor each modality .of type (S1,...,Sn).S. Example 12 (ML-signature for CL). Consider the ML-signature \nSCL consisting of two sorts D, C with modalities ap:(C,D).D, I :().C, :(D,D).C and .:(C,D) .D. Given \na CL\u00admodel M=(D,C,ap,I), we can view it as a ML-model M, SCL where MD = D, MC = C, the interpretations \nMap and MI are inherited from the CL-model, and M. and M. are given '' ' by (c,d,d ) .Map iff (d,d ,c) \n.M. iff (c,d ,d) .M.. Hence, every CL-model can be interpreted as a ML-model. Notice that not all ML-models \nover signature SCL are CL-models, since the I modality need not have any relationship to the apmodality. \nDe.nition 13 (ML-Formulae). Given ML-signature S=(S,O,.) and disjoint, countably in.nite sets VS of propositional \nvariables for each sort S,the set PS of ML-formulae over Sis given by P ::=pS |P1 .P2 |\u00acP |falseS |.(P1,...,Pn) \nwhere pS .VS and, for each .:(S1,...,Sn).S, the formula .(P1,...,Pn)has sort S provided the Pi have sort \nSi. We write PSS forthe setofformulae ofsort S generated from signature S. De.nition 14 (ML-Satisfaction \nRelation). Given ML-signature S=(S,O,.)and ML-model MS, the ML-satisfaction relation FML consists of \nrelations of the form s,M,m FS P for each sort S .S,where m .MS,formula P has sort S and, for each propositional \nvariable pS' , s(pS' ).MS. It is de.ned by induction on the structure of ML-formulae, with the modality \ncase given by s,M,m FS .(P1,...,Pn)..i .{1,...,n}..mi. s,M,mi FSi Pi .((m1,...,mn),m).M.. The other cases \nare evident. Example 15. Given CL-model Mand corresponding ML-model Mfrom example 12, the CL-and ML-satisfaction \nrelations SCL are equal in the following sense. De.ne a translation function | |:P.K.Pfrom CL-formulae \nto ML-formulae over SCL, SCL by induction on the structure of the CL-formulae such that each case follows \nthe structure of the formulae except that |P1 < P2|\" \u00ac(|P1|. \u00ac|P2|)and |P1 C P2|\" \u00ac(|P1|\u00ac|P2|). We have \ns,M,d FCL P .s,MSCL,d FML |P| s,M,cFCL K .s,MSCL,c FML |K| Recall that not all ML-models over signature \nSCL correspond to CL-models. To get a precise correspondence with CL, we will restrict the class of ML-models \nto those satisfying a certain set of CL-axioms. We .rst describe the general theory. De.nition 16 (AX-Model). \nGiven a ML-signature Sand a set of axioms AX .PS,an AX-model generated from Sis a ML-model Mgenerated \nfrom Swhich also satis.es s,M,m FS P for all m.MS,P .AX and s. 2 Note that what we call a ML-model is \ntypically called a frame in e.g. [2]. De.nition 17 (AX-Proof Theory). Given a ML-signature S and a set \nof axioms AX .PS, the ML-proof theory 3 generated by AX consists of the following axioms and rules: fP \n.Q fPP .AX P tautology fQ fP fP fP .:(S1,...,Sn) .S fP[P ' /p] f.(p1,...,falseSi,...,pn) .falseS P()= \n.(p1,..., ,...,pn) fP(pi .pi' ) .P(pi) .P(pi' ) We sometimes write fAX to emphasise the set AX. There \nis a well-known general completeness result for ML due to Sahlqvist, which relates the AX-satisfaction \nrelation and the AX\u00adproof theory as long as the axioms have a certain form. We state the result here, \nsince we use it to show completeness for CL. De.nition 18 (Very Simple Sahlqvist Formulae). Given ML\u00adsignature \nS=(S,O,.), a very simple Sahlqvist antecedent A is a formula given by the grammar: A::= trueS |falseS \n|pS |A.A|.(A1,...,An) for pS .VS and .:(S1,...,Sn) .S. A very simple Sahlqvist formula is an implication \nof the form A .P+,where P+ is a positive formula, in that every propositional letter pS appears under \nan even number of negations. Theorem 19 (Sahlqvist (see [2])). For every axiom set AX con\u00adsisting of \nvery simple Sahlqvist formulae, the ML-proof theory gen\u00aderated by AX is complete with respect to the \nclass of AX-models. 3.1 Context Logic as ML We have shown that a CL-model can be viewed as a ML-model \nover signature SCL (example 12), and that the corresponding sat\u00adisfaction relations agree (example 15). \nNow we identify an axiom set AXCL over signature SCL, such that the AXCL-models cor\u00adrespond exactly to \nthe CL-models and the proof theories coincide. Since the AXCL-axioms are Sahlqvist axioms, the general \ncom\u00adpleteness result for ML (Theorem 19) implies completeness for CL. De.nition 20 (CL-Axioms). Given \nML-signature SCL, the axiom set AXCL over SCL consists of the following formulae, where p,q .VD and k \n.VC : 1. I(p) .p 2. p.I(p) 3. q.k(p) .True(p.(k . q)) 4. q.k(p) .(k.(pq))(true) 5. p.(k . q) .True \n. (q.k(p)) 6. k.(pq) .true (q.k(p))  The axioms in AXCL are very simple Sahlqvist formulae. The .rst \ntwo axioms correspond directly to the identity axiom of CL. The other axioms capture the relationship \nbetween Map, M.,and M, which simply permutes elements (Example 12). For example, the third axiom species \nthat, if the given data satis.es q and can be split into a context satisfying k and subdata satisfying \np,then there exists subdata satisfying p and k . q (think of the same subdata). This axiom shifts the \nemphasis from the given data to the subdata. The .fth axiom is a sort of converse. It states that, if \nthe given data satis.es p and k . q, then it is possible to enclose it in a context (actually one satisfying \nk), such that q and k(p) are satis.ed. The third and .fth axiom together describe the exact connection \nbetween Map and M.. Similarly, the fourth and sixth axiom describe the exact connection between Map and \nM. 3 This is called the normal modal proof theory in [2]. We have already illustrated how a CL-model \ncan be interpreted as a ML-model (Example 12). This ML-model is indeed a AXSCL \u00admodel. Conversely, every \nAXSCL-model gives rise to a CL-model. Lemma 21. 1. Every CL-Model Mgives rise to an AXCL-model M. SCL \n2. Every AXCL-model Mgives rise to a CL-model MAXCL. 3. The CL-model Mequals the CL-model (M.  SCL)AXCL \n4. The AXCL-model Mequals the AXCL-model (MAXCL. )SCL 5. The satisfaction relations agree. Proof. Part \n1 follows from Example 12 by observing that the AX\u00adaxioms are satis.ed by M. The construction of Mand \nSCL AXCL the proof of part 2 is given below. Parts 3 and 4 follow from the constructions of the models. \nPart 5 is stated in more detail and proved in Example 15. For part 2, let Mbe a AXCL-model, with sets \nMD and MC, and interpretations Map, MI , M. and M. The tuple MAXCL =(MD,MC,Map,MI ) is a CL-model. In \nparticular, axioms 1 and 2 give the condition that MI is a left unit of Map. Axioms 3 to 6 give the condition \n(c,d,d ' ) .Map .(c,d ' ,d) .M. .(d,d ' ,c) .M, which captures exactly the relationship between connectives \nap,., . Finally, we connect the proof theory of CL and AXCL. Lemma 22. Given arbitrary P1,P2 .Pand K1,K2 \n.K, P1 fCL P2 iff fAXCL |P1|.|P2| K1 fCL K2 iff fAXCL |K1|.|K2| Proof. For simplicity of notation we \nomit the explicit conversion |P|. The proof consists of two parts: 1. the rules of fCL are derivable \nin fAXCL; 2. the axioms in AXCL are derivable in fCL.  For each part we give one case in detail, the \nother cases follow similarly. For the .rst part, we show that the following is derivable fAXCL K(P1) \n.P2 fAXCL K .(P1 C P2) First observe that fAXCL K .(P1 C P2) iff fAXCL \u00ac((P1 \u00acP2) .K). Using AXCL-axiom \n5, we obtain : fAXCL K .(P1 \u00acP2) .true (\u00acP2 .K(P1)) From the assumption fAXCL K(P1) .P2 we have fAXCL \ntrue (\u00acP2 .K(P1)) .true (\u00acP2 .P2) Since fAXCL true (\u00acP2 .P2) .false, we have proved fAXCL \u00ac((P1 \u00acP2) \n.K) For the second part, we show that axiom 3 is derivable, by proving the following stronger version: \nfCL q.k(p) .k(p.(k . q)) Note that, for propositional variable r,we have: fCL k(p) .k(p.(r.\u00acr)) .k(p.r) \n.k(p.\u00acr) If we replace r by \u00ac(k . q), then our stronger version of axiom 3 follows from proving that \nfCL q.k(p.\u00ac(k . q)) .false Since fCL p .\u00ac(k . q) .\u00ac(k . q) and fCL \u00ac(k . q) .k < \u00acq by de.nition, we \nderive fCL q .k(p .\u00ac(k . q)) .q .k(k < \u00acq) Finally, since fCL k(k < \u00acq)) .\u00acq, we conclude that fCL q \n.k(k < \u00acq) .q .\u00acq .false Theorem 23 (Soundness and Completeness). The proof theory of CL (De.nition 5) \nis sound and complete with respect to the class of CL-models (De.nition 2). Proof. Immediate from Theorem \n19, using lemmas 21 and 22. Using this result, it is also possible to prove completeness for the restricted \nclass of functional CL-models: that is, those CL-models where ap is a function. For each relational model, \nit is possible to construct a functional model which satis.es the same formulae. This proof is given \nin Zarfaty s forthcoming thesis. In [3], we also study CL with an additional zero formula 0, since it \nhas interesting logical structure. It is possible to give additional axioms for 0,and provide an analogous \ncompleteness result. 3.2 Bunched Logic as ML We show how BL can be expressed in ML, by analogy with \nCL. The ML-signature SBL consists of one sort D with the modalities .:(D,D) .D, 0:() .D, -:(D,D) .Dand \n- :(D,D) .D. The axiom set AXBL is: 1. 0 .p .p 2. p .0 .p 3. (p .q) .r .p .(q .r) 4. p .(q .r) .(p \n.q) .r 5. q .(r .p) .true .(p .(r -q)) 6. q .(r .p) .(r .(p - q)) .true 7. p .(r -q) .true -(q .(r \n.p)) 8. r .(p - q) .true - (q .(r .p))  The set AXBL is a set of very simple Sahlqvist formulae, and \nhence we have an analogous completeness result to CL. We do not know how to prove completeness for the \nfunctional BL-models, because the construction of a functional model from a relational model does not \npreserve associativity.  4. Applications of Context Logic We shall study three applications of CL: heaps \nto give an example where CL-and BL-reasoning are the same; sequences to give an example where CL-and \nBL-reasoning is different; trees to provide a more substantial example where the reasoning is different. \n4.1 Heaps CL for heaps is CL extended by speci.c modalities which can be interpreted in the CL-model \nHeap (Example 3). The extra modalities specify the empty heap and heaps containing a speci.c cell. De.nition \n24 (CL for Heap). CL for heaps, denoted CLHeap,is given by the ML-signature SCL+Heap consisting of SCL \nextended by the modalities: 0: () .D,n'.m :() .D for every n .N+ and m .N. The CL-model Heap is a model \nof CLHeap with the the additional modalities interpreted as: M0 = {e}where e denotes the empty heap Mnc.m \n= {h .D|h(n)= m} We have the following derived formulae: P1 .P2 \" (0 cP1)(P2) specifying that a heap \ncan be split into two disjoint parts, one satisfying P1 and the other P2;  n .m \" (n'.m) .\u00ac(\u00ac0 .\u00ac0) \nspecifying that the given heap h contains just one cell with h(n)= m;  P1 -.P2 \" (0 cP1) <P2 specifying \nthat, whenever a heap satisfying P1 can be composed with the given heap, the result satis.es P2.  To \nillustrate the difference between .and ., notice that the formula (n .m) .(n .m) is not satis.ed by any \nheap, whereas the formula (n .m) .(n .m) speci.es a one-cell heap. Also, notice that logical equivalence \nof CLHeap is heap equality. This strength of analysis is typical for this style of logical reasoning. \nBL for heaps is Separation Logic [11]. It is de.ned similarly to CLHeap, by extending the signature SBL \nto include modalities for specifying the existence of heap cells. De.nition 25 (BL for Heap). BL for \nheaps, denoted BLHeap,is given by the ML-signature SBL+Heap =SBL .{n'.m :() .D|n .N+ ,m .N}. The BL-model \nHeapis a model of BLHeap, with the interpretation of the additional modalities de.ned in De.nition 24. \nAgain, we can derive the BL-formula n .m denoting a one\u00adcell heap. In SL, this formula is primitive. \nWe choose n'.m as primitive here, because of a comparison with propositional logic giveninSection5, where \nn'.m is the natural atomic formula. From the derived CL-formulae given previously, we know that BLHeap \nis a sublogic of CLHeap. In fact, there is a collapse of the CL-structure for the heap case, in that \nCLHeap and BLHeap are equivalent logics on data (Proposition 26). This result is strong, in that it implies \nthat the logics are parametrically as expressive as each other on data (De.nition 31). Proposition 26. \nLet PSCL+Heap,VP denote the restriction of set to those formulae with propositional variables in VP , \nPSCL+Heap and similarly for BL. There exists a bijectionb : PSCL+Heap,VP . which preserves the satisfaction \nrelation: that is, PSBL+Heap,VP s,d FCL P .s,d FBL Pb s,c FCL K .s,c(0) FBL Kb Proof. The translation \nis de.ned inductively on the structure of data and context formulae. We give the cases for the modalities: \nKbb K(P) \" K .PbI \" 0 Kb\" c K . P \" K - PbPK1 P2 P1 - Pc2 bK 0 \" 0 n'.m \" n'.m The proof follows by induction. \n 4.2 Sequences CL for sequences generated by alphabet A is CL extended by spe\u00adci.c modalities which can \nbe interpreted in the CL-model SeqA presented in Example 3. The additional modalities specify the empty \nsequence, sequences with just one element a .A,and modalities for analysing sequence contexts. De.nition \n27 (CL for SeqA). CL for Sequences generated by al\u00adphabet A, denoted CLSeqA , is given by the ML-signature \nSCL+SeqA consisting of SCL extended by the modalities: 0: () .D,a :() .D, .r :(C,D) .C .l :(D,C) .C for \na .A. The CL-model SeqA is a model of CLSeqA with the interpretation of the additional modalities given \nby: M0 = {0}where 0 denotes the empty sequence Ma = {a}for each a .A M.r = {(c,s,c\u00b7s) |c .CA,s .DA} M.l \n= {(s,c,s\u00b7c) |s .DA,c .CA} We will use the notation K .P for .r(K,P) and P .K for .l(P,K), overloading \n.as the subscripts can be inferred. We require the additional modalities .r and .l for analysing se\u00adquence \ncontexts, since unlike the heap case these cannot be derived from application. We can derive a formula \nfor sequence compo\u00adsition P1 .P2 \" (P1 .I)(P2) which speci.es that a sequence can be split into two sequences, \nthe left one satisfying P1 and the right one P2. This is logically equivalent to (I .P2)(P1). We also \nderive the two corresponding right adjoints: the formula P1 .-P2 \" (P1 .I) <P2 speci.es that, whenever \na sequence sat\u00adisfying property P1 is joined to the left of the given sequence, then the result satis.es \nP2; similarly for P1 -.P2 \" (I .P1) <P2.For example, the formula a-.P speci.es that joining ato the right \nof the sequence results in a sequence satisfying P. In contrast, notice that the formula (a C P)(0) speci.es \nthat, whenever an a is put somewhere in the given sequence, then the result satis.es property P. Again, \nlogical equivalence of CLSeqA is sequence equality. De.nition 28 (BL for SeqA). BL for sequences generated \nfrom alphabet A, denoted BLSeqA , is given by the ML-signature SBL+Heap =SBL .{a |a .A}. The BL-model \nSeqA is a model of BLSeqA with the interpretation of the additional modalities de.ned as given in De.nition \n27. BLSeqA is a sublogic of CLSeqA . Unlike the heap case, there is no collapse of the CL-reasoning, \nand the question of whether CLSeqA is more expressive than BLSeqA is subtle. Consider the CL-formula \n(0 C b.c)(a). It is logically equivalent to the formula a .b .c .b .a .c .b .c .a. Now consider the CL-formula \n(0 C True(b))(a). It is equivalent to true .b.true .a.true .true .a.true .b.true, which has very different \nstructure to the previous example. We shall see in section 5.2 that CLSeqA and BLSeqA are equality expressive \nin the sense that every CL-formula without propositional variables has an equivalent BL-formula. However, \nthey are not parametrically as expressive, in the sense that the CL\u00adformula (0 C p)(a), for propositional \ndata variable p, cannot be expressed in BLSeqA . By contrast, CLSeqA without the modality is parametrically \nas expressive as BLSeqA . 4.3 Trees CL for trees generated by alphabet A is CL extended by speci.c modalities \nwhich can be interpreted in the CL-model TreeA pre\u00adsented in Example 3. The additional modalities correspond \nto the empty tree, and modalities for analysing tree contexts. De.nition 29 (CL for TreeA). CL for trees, \ndenoted CLTreeA , is given by the ML-signature SCL+TreeA consisting of SCL ex\u00adtended by the additional \nmodalities: 0:() .D,\u00b5 :(C) .C, .:(D,C) .C where \u00b5 ::= a |a . for a .A. The CL-model TreeA is a model \nof CLTreeA with the interpretation of the additional modalities given by: M0 = {0}where 0 denotes the \nempty tree Ma = {(c,a[c]) |c .C} M. = {(c,a ' [c]) |c .C,a ' .A-{a}} a M. = {(t,c,t |c) |t .D,c .C} We \nwrite \u00b5[K] for \u00b5(K), and P .K for .(P,K). Apart from the 0, the additional modalities describe ways of \nanalysing tree contexts: either tree contexts consist of a root \u00b5with a subcontext underneath, or they \ncan be split at the top level into data and a context. The root \u00b5 can either be the node label a .A, \nor a . denoting any label which is not a.The a . modalities are not given explicitly in [3], since they \nare derivable with existential quanti.cation and label equality. They are important for our com\u00adparison \nwith BL-reasoning, and also play a prominent role in logic\u00adbased query languages for XML (see XDUCE [7]). \nWe only require one modality .for splitting contexts, since our tree composition is commutative. Analogous \nto the heap case, we have the derived for\u00admulae P1 .P2 \" (P1 .I)(P2) and P1 -.P2 \" (P1 .I) <P2. De.nition \n30 (BL for TreeA). BL for trees generated from alphabet A, denoted BLTreeA , is given by the ML-signature \nSBL+TreeA consisting of SBL extended by the modalities: \u00b5 :(D) .D,\u00b5b:(D) .D, o:(D) .D bo:(D) .D The BL-model \nTreeA is a model of BLTreeA with the interpreta\u00adtion of the additional modalities given by: Ma = {(t,a[t]) \n|t .D} M. = {(t,a ' [t]) |t .D,a ' .A-{a}} Ma\u00b5b= {(a ' [t],t) |(t,a ' [t]) .M\u00b5} M. = {(t,c(t)) |t .D,c \n.C} Mb. = {(c(t),t) |(t,c(t)) .M.} BLTreeA is a sublogic of CLTreeA . The BL-formula \u00b5[P] speci.es a \ntree with top node described by \u00b5. It is derivable in CLTreeA as (\u00b5[P .I])(0). The modalities a . are \nessential to express deep properties of trees in BL. For example, let 1 denote all the trees with one \nnode. In CLTreeA , this can be expressed as \u00ac(\u00acI(\u00ac0)) .\u00ac0. It is expressed in BLTreeA as a[0] .a .[0],and \nis not expressible without the a . modality. The BL-formula \u00b5b[P] is the adjoint. It speci.es that, whenever \na top node is added to the given tree with label speci.ed by \u00b5, the resulting tree satis.es P. It corresponds \nto the CL-formula \u00b5[I] <P. AL has the formula c ba[P], with a.[P] derivable using existential quanti.cation \nand label equality. The BL-formula o(P) denotes that there is a subtree satisfying P. Recall that this \nis expressible in CL as True(P). Finally, the BL-formula bo(P) is the corresponding adjoint. It states \nthat the given tree can be put in a context such that the result satis.es P, and is expressible in CL \nas True <P.ALhas the formulae o(P), but surprisingly not the corresponding adjoint. We will see that \nboplays an important role in an expressivity result linking BL-and CL-reasoning without (Theorem 40). \nJust as for sequences, the CL-reasoning does not collapse for trees, and the comparison between CLTreeA \nand BLTreeA is sub\u00adtle. Consider the CL-formula (0 C b[0])(a[true]), which speci.es that we can remove \na subtree with root label ato obtain a tree with one node labelled b. It corresponds to the BL-formula \na[true].b[0].b[a[true]]. Now consider the CL-formula (0 C ob[true])(a[true]). It corresponds to the BL-formula \no(b[oa[true]]) .o(o(b[true]) .o(a[true])). Notice that the structure of the CL-formulae is sim\u00adilar, \nbut the structure of the derivable BL-formulae is quite dif\u00adferent. In Section 5.3, we shall see that \nCLTreeA and BLTreeA are not parametrically as expressive, in the sense that CL-formula (0 C p)(a[true]) \ncannot be expressed in BLTreeA . CLTreeA with\u00adout the modality is as expressive as BLTreeA .  5. Parametric \nExpressivity We present our expressivity results. We prove parametric inexpres\u00adsivity results comparing \nBL for heaps with and without the struc\u00adtural connectives, using a direct proof method. We prove strong \ninexpressivity results for speci.c interpretations s, corresponding to the extension of BL with list \npredicates. We also study para\u00admetric inexpressivity results comparing CL and BL for sequences and trees. \nWe cannot prove the parametric results directly for these applications. Instead, we prove strong inexpressivity \nresults, and hence by implication the parametric results. In addition, we study BL for bounded heaps, \npresenting logics which have the same strong expressivity for every interpretation s, but different para\u00admetric \nexpressivity. First some notation. Given ML-signature S=(S,O, .)and AX-model MS,we let LMS,V denote the \nmodal logic determined by Sand MS with propositional variables in V.We use LMS,VS to denote the restriction \nto propositional variables of sort S,and LMS,{p} for the restriction to propositional variable p. We \nwrite LMS,V (-.) for the logic without modality .. For example, CLSeqA,VD (-{})denotes CLSeqA without \nmodality and with the propositional variables restricted to sort D. De.nition 31 (Parametric Expressivity). \nLet S=(S,O, .)and '' ' S =(S,O ' ,. ' )be two ML-signatures with sort S .SnS. Consider two models M, \nM' over the respective signatures such that MS =MS' . Consider the logics LM,VS and LM',VS . 1. Logic \nLM',VS is as expressive as LM,VS with respect to sort S, written LM,VS .S LM',VS , if and only if .P \n.LM,VS ..P ' .LM',VS . .s..m .MS. s, M,m FS P .s, M' ,m FS P ' . We often write LM,VS .LM',VS since the \nsort S is apparent. 2. Given s,logic LM',VS is as s-expressive as LM,VS with respect to sort S, written \nLM,VS .S,s LM',VS , if and only if .P .LM,VS ..P ' .LM',VS . .m .MS. s, M,m FS P .s, M' ,m FS P ' . Again, \nwe write LM,VS .s LM',VS since S is apparent. We write LM,VS = LM',VS when LM,VS .LM',VS and LM,VS .LM',VS \n, and LM,VS =s LM',VS analogously. In fact, we concentrate on inexpressivity results, asking when a logic \nis strictly more expressive than another. We say that LM',VS is parametrically more expressive than LM,VS \niff LM,VS S LM',VS . We say that LM',VS is strongly more expressive than LM,VS iff there exists a s such \nthat LM,VS Ss LM',VS . To prove our strong inexpressivity results we rely heavily on the notion of bisimulation. \nBisimulation has the property that, if two elements of the models are bisimilar, then they cannot be \ndis\u00adtinguished from each other in the logic, and hence can be directly used to prove strong inexpressivity. \nDe.nition 32 (Bisimulation). A symmetric binary relation ~= S S.S ~S with ~S.MS \u00d7MS is a bisimulation \nfor ML-model MS if and only if, whenever ((m1,...,mn),m) .M. and m ~m ' , then there exist mi ' .MSi \nsuch that mi ~Si mi ' for i =1...n and ((m ' 1,...,m ' n),m ' ) .M.. A bisimulation ~is compatible with \ninterpretation s if and only if, for all m, p, m .s(p).m ~m ' .m ' .s(p). Proposition 33. Let ~be a bisimulation \ncompatible with s for ML-model MS.Then m1 ~S m2 implies s, M,m1 FS P iff s, M,m2 FS P for all P .PSS \n. To show that LM,VS Ss LM',VS , our proof method consists of .nding a formula P .LM',VS of sort S and \na bisimulation ~for Mcompatible with s, such that P distinguishes two elements which are identi.ed by \n~. Inexpressivity then follows from Propo\u00adsition 33 that no formula in PS can distinguish the two elements. \n5.1 Heaps We have the following results about heaps: BLHeap,VD =CLHeap,VD BLHeap,\u00d8(-{- }+{n'.-})=BLHeap,\u00d8 \nBLHeap,{p}(-{- }+{n'.-})S BLHeap,{p} The .rst result is a parametric expressivity result, showing that \nthe structure of CL collapses to BL in the heap case. This result follows from Proposition 26. The second \nresult is a non-parametric expres\u00adsivity result due to Lozes [9], which compares the expressivity of \nclosed formulae. It states that the adjunct - can be eliminated if we add formulae n'.-to specify that \naddress n is allocated: n'.-speci.es that there exists m such that n'.m. It is expressible using - as \n\u00ac((n'.0)- true); the current heap cannot be extended with cell n,so n must already be allocated. Lozes \nresult was initially quite a surprise, since the adjuncts are used in an essential way to describe the \nweakest preconditions for Hoare reasoning based on BL for heaps. We address this apparent contradiction \nhere, by proving the third result. The third result is a parametric inexpressivity result, which we prove \nby showing that formula (n.0)-.p cannot be expressed in BL for heaps without - . This formula is interesting \nbecause it expresses the weakest precondition of allocation. This inexpres\u00adsivity result says nothing \nabout whether the formula is expressible for a particular interpretation of p. By Lozes results, we know \nthat it is expressible for every interpretation of p as a closed formula. We also prove a strong inexpressivity \nresult using the same formula and a natural interpretation slist which interprets p as list(m):that is, \nthe heap contains a 0-terminated linked list starting at m.This result is interesting because lists are \none of the typical inductive predicates used in BL-reasoning. Theorem 34 (Parametric Inexpressivity). \nBLHeap,{p}(-{- }+{n'.-})S BLHeap,{p} Proof. We de.ne the notion of heap-reducing formulae, and prove \nthat all the formulae in BLHeap,{p}(-{- }+{n'.-})are heap\u00adreducing, whereas formula (n.0)-.p is not. \nThis captures our intuition is that, without - , the BL-modalities either leave the heap alone or make \nit smaller, whereas formula (n.0)-.p crucially tests p on an extension of the initial heap with cell \nn. Given heap h, de.ne a binary relation on interpretations by ''' '' s ~h s iff .h =h. h .s(p).h .s \n(p) where h ' =h means dom(h ' ) .dom(h)and .n .dom(h ' ). h ' (n)= h(n). We say that a formula P is \nheap-reducing if and only if, whenever s ~h s ' , it follows that s, h |=P .s ' ,h |=P . Given formula \nP in BLHeap,{p}(-{- }+{n'.-}),we show that P is heap-reducing by induction on the structure of P .Case \np is immediate from the de.nition of s ~h s ' . The only other interesting case is P1 .P2. Suppose s \n~h s ' and s, h |=P1 .P2. There exists hi for i =1, 2such that h =h1 \u00b7h2 and s, hi |=Pi. s ' Since hi \n=h,we have s ~hi for i =1, 2and hence s ' ,hi |= Pi by the induction hypothesis. We conclude that s ' \n,h |=P . Let P ' be (n.0)-.p. We show that P ' is not heap-reducing. De.ne s(p)={h |h :N+ -fin N}and \ns ' (p)={e}where e is the empty heap. Then s ~e s ' and s, e |=P ' ,but s ' ,e| =P ' . We now prove our \nstrong inexpressivity result, that - cannot be eliminated with interpretation slist(p)= list(m).Withthis \ninterpretation, the formula (n.0)-.p is satis.ed by a list segment starting at m and stopping with dangling \npointer n. This cannot be expressed without -., since only whole lists can be observed. Theorem 35 (Strong \nInexpressivity). BLHeap,{p}(-{- }+{n'.-})Sslist BLHeap,{p} Proof. Consider the BL-formula P \" (n.0)-.p, \nand interpre\u00adtation slist(p)= list(m)for m = n. We show that there is no formula P ' in BLHeap,{p}(-{- \n}+{n'.-})that is equivalent to P using slist. Expecting a contradiction, suppose that such a P ' exists, \nand let L .N be the .nite number of constants mentioned in P ' . Consider the restriction of BLHeap to \nconstants in L, written BLHeapL . We choose a bisimulation ~which identi.es two heaps when they have \nthe same domain, coincide on values in L,and are identical if one of them contains a list starting at \nm: h1 ~h2 iff dom(h1)=dom(h2)and .i, j .L. h1(i)=j iff h2(i)=j and if h1 |=list(m)or h2 |=list(m)then \nh1 =h2. Notice that slist(p) is compatible with ~, since if h1~h2 and h1 |= list(m)then h2 |= list(m). \nAssume for the moment that ~is indeed a bisimulation. With this assumption, we show that we do indeed \nobtain a contradiction. Take m ' ./L .{n, m}and consider the heaps h1 =[m .m ' ,m ' .n]and h2 =[m . '' \n' m ,m .m ]. Note that h1~h2 and s, h1 |=(n.0)-.p but s, h2 |=(n.0)-.p. Assuming that ~is a bisimulation \nfor BLHeapL,{p}(-{- }+{n'.-}), Proposition 33 implies that slist,h1|=BLP ' iff slist,h2|=BLP ' . We have \ntherefore proved that there cannot be a BL-formula P ' which is equivalent to P . Finally, we must prove \nour assumption that ~is a bisimulation for the modalities {0, .}.{i'.j, i'.-|i, j .L}. We only look \u00b7h \n'' at the .modality; the other cases are trivial. Assume h1 =h ' 11 \u00b7h '' and h1~h2. We must show that \n.h ' 2,h '' 2 such that h2 = h ' 22 1 ~h '' 2,h '' and h ' 1~h2 ' and h '' 2 . Choose h ' 2 as the unique \nsplitting of h '' h '' h2 such that dom(h ' 2)=dom(h ' 1)and dom(2 )=dom(1 ).We 1 ~h '' show h ' 1~h2' \n; the case h '' 2 is identical by symmetry. The .rst and second conditions in the de.nition of ~are immediate. \nFor the third condition, assume h1 ' |=list(m), which implies h1 |=list(m) since h ' 1 is a sublist of \nh1. By de.nition of h1~h2,we have h1 =h2, hence h ' 1 =h2 ' which is the desired conclusion. Lozes also \nshows that, with an additional modality sizer for determining the size of heaps, the .-modality can be \nremoved. We show that .is essential for parametric reasoning. The results are: BLHeap,\u00d8(-{., - }+{sizer})=BLHeap,\u00d8(-{- \n}) BLHeap,{p,q}(-{., - }+{sizer})S BLHeap,{p,q}(-{- }). The results also hold with modality n'.-. Thus, \nBL is as ex\u00adpressive as PL with atomic formulae 0, sizer and n'.-, but not parametrically so. We believe \nthis parametric inexpressivity result demonstrates what has been always known intuitively, but by ex\u00adample \nonly, that the .-modality is essential for modular reasoning. We give a direct proof of our parametric \ninexpressivity result for .based on the trivial observation that, without .and - , all the modalities \nleave the current heap unchanged. The modality sizer, for each r .N+, is interpreted by h |=sizer iff \n|dom(h)|=r. We do not require size0 as it corresponds to the zero formula 0. Theorem 36 (Parametric Inexpressivity). \nBLHeap,{p,q}(-{., - }+{sizer})S BLHeap,{p,q}(-{- }) Proof. The proof is analogous to that of Thm. 34. \nA formula P is heap-invariant iff, when h .s(p) .h .s ' (p)for all p,then s, h |=P .s ' ,h |=P . The \nformulae in BLHeap,{p,q}(-{., - }+ {sizer})are heap-invariant, but p .q is not. We also prove a second \nstrong inexpressivity result, that .cannot be eliminated with .xed interpretation slist, which interprets \np and q as list(m1)and list(m2)respectively for m1 = m2.The .modality is essential for specifying the \nproperty that the two lists are in the heap and their tails never meet. Theorem 37 (Strong Inexpressivity). \nBLHeap,{p,q}(-{., - }+{sizer})Sslist BLHeap,{p,q}(-{- }) Proof. The structure of the proof is analogous \nto Theorem 35. Consider the BL-formula p .q. As in Theorem 35, we restrict our attention to BL-formulae \nmentioning at most a .nite set L .N of constants and the propositional variables p, q. Consider the interpretation \nh .slist(p)iff h satis.es list(m1), and h .slist(q)iff h satis.es list(m2). De.ne relation ~by: h1 ~h2 \niff |dom(h1)|=|dom(h2)|and s, h1 |=P .s, h2 |=P for P .{p, q}.{i'.j |i, j .L} ~is compatible with s and \nis a bisimulation for the modalities {0,sizer}.{i'.j |i, j .L}.Take h1 =[m1 .n ' ,m2 . ''''' ' '' n ,n \n.0,n .0]and h2 =[m1 .n ,m2 .n ,n . '' ''' 0,n .0]for distinct n ,n ./L .{m1,m2}.Then h1 ~h2 and s, h1 \n|=p .q,but s, h2 |=p .q. From the previous examples, one might be tempted to conclude that whenever a \nparametric inexpressivity result holds, a corresponding strong inexpressivity result holds too. In fact, \nthis is not the case as we demonstrate using bounded heaps. In bounded heaps, - cannot be eliminated \nparametrically for reasons identical to the unbounded case. However, given a speci.c interpretation s, \nany formula is equivalent to a disjunction of characteristic formulae without - . Theorem 38. Let Heapk \ndenote the restriction of heaps, and correspondingly formulae, to locations =k. The following hold: 1. \nBLHeapk,{p}(-{- }+{n'.-})S BLHeapk,{p} 2. BLHeapk,{p}(-{- }+{n'.-})=s BLHeapk,{p} for all s.  Proof. \nThe proof of part 1 is identical to the proof of The\u00adorem 34. For part 2, we in fact prove a stronger \nclaim: for any set of heaps H .Heapk, there exists a formula PH .BLHeapk,\u00d8(-{0, ., - }) such that h |= \nPH .h .H.We show that the conclusion then follows from the claim. Given any s and P .BLHeapk,{p},let \nH = {h |s, h |= P }.Then P is equivalent to PH, by de.nition. To prove the claim, we .rst de.ne, given \nheap h, the characteristic formula Ph as ^ ^ n'.m .\u00ac(n'.m) n,m=k.h(n)=m n,m=k.h(n). =m) Clearly h ' |=Ph \n.h =h ' ,and Ph .BLHeapk,\u00d8(-{0, ., - }). W To conclude, we de.ne PH = h.H Ph.  5.2 Sequences We have \nthe following results for sequences for alphabet A: BLSeqA,\u00d8(-{- , -})=BLSeqA,\u00d8 =CLSeqA,\u00d8 BLSeqA,VD (-{- \n, -})=CLSeqA,VD (-{, .}) BLSeqA,VD =CLSeqA,VD (-{}) BLSeqA,{p} S CLSeqA,{p} if A is in.nite. The .rst \nresult is a standard expressivity result showing that BL and CL for sequences without propositional variables \nare equally expressive. The proof will appear in a forthcoming paper. The sec\u00adond result is a parametric \nexpressivity result. It shows that, without adjuncts, BL for sequences is as expressive as CL for sequences. \nThe third result shows that full BL is parametrically as expressive as CL without the modality. The fourth \nresult illustrates that the importance of CL-reasoning lies in the modality, by showing that CL for sequences \nis parametrically more expressive than BL for se\u00adquences. Unlike the heap case, we are unable to give \na direct proof of the parametric result. We give a proof of strong inexpressivity, and hence prove parametric \ninexpressivity. Our .rst parametric expressivity result for sequences shows that, without adjuncts, CL-application \ncan be speci.ed by BL\u00adcomposition. The proof shows that any context formula can be expressed as the disjunction \nof formulae of the form P1 .I .P2, and the application (P1 .I .P2)(P ) corresponds to P1 .P .P2. Theorem \n39 (Parametric Expressivity). BLSeqA,VD (-{- , -})= CLSeqA,VD (-{, .}) Proof. Note that propositional \nvariables are restricted to sort D, so the context formulae of CLSeqA,VD (-{, .}) are K ::= I |K .K |\u00acK \n|False |K .P |P .K. We de.ne a canonical subset K ::= K .K |P .I .P and show that (1) every CL-formula \nK is equivalent to a canonical formula K; (2) every application formula K(P ) is equivalent to the substitu\u00adtion \nformula K[P/I].  The result follows. Given an arbitrary CL-formula, .rst replace the context subformulae \nby canonical formulae, then replace the application subformulae by the equivalent substitution formulae. \nThe resulting formula is a BL-formula equivalent to the original CL-formula. To show (1), we de.ne a \ntranslation tr from context formulae to the canonical formulae by: \" tr(I) 0 .I .0 tr(K1 .K2) \" tr(K1) \n.tr(K2) tr(\u00acK) \" Not(tr(K)) tr(False) \" false .I .false tr(K .P ) \" Addl(tr(K),P ) tr(P .K) \" Addr(P, \ntr(K)) where Not(K), Addr(P, K) and Addl(K,P ) are de.ned below by induction on the structure of the \ncanonical formulae. Before de.ning Not, we de.ne a function And on canonical formulae such that And(K1,K2) \nis equivalent to K1 .K2: And(K1 .K2,K3) \" And(K1,K3).And(K2,K3) And(P1.I.P2,P3.I.P4) \" (P1 .P3) .I .(P2 \n.P4) We now de.ne function Not: Not(K1 .K2) \" And(Not(K1), Not(K2)) Not(P1 .I .P2) \" (\u00acP1) .I .true .true \n.I .(\u00acP2) Addr(P, K) and Addl(K,P ) are de.ned similarly to And. (2) is proved by induction on K. For \ncase K1 .K2, note that (K1 .K2)(P ) is equivalent to K1(P ) .K2(P ) and, by the induction hypothesis, \nit is equivalent to K1[P/I] .K2[P/I].Case P1 .I .P2 is immediate since (P1 .I .P2)(P ) is equivalent \nto P1 .P .P2. As an example, consider the CL-formula (\u00acI)(P ) satis.ed by any sequence having a strictly \nsmaller subsequence satisfying P . We have tr(\u00acI)= Not(tr(I)) = Not(0 .I .0) =(\u00ac0) .I .true .true .I \n.(\u00ac0). Therefore (\u00acI)(P ) is equivalent to (\u00ac0) .P .true .true .P .(\u00ac0), which is satis.ed by any sequence \ncontaining a subsequence satisfying P composed with a nonempty sequence on at least one side. Our next \nresult shows that CL for sequences minus . is para\u00admetrically as expressive as BL for sequences. Theorem \n40 (Parametric Expressivity). BLSeqA,VD = CLSeqA,VD (-{}) Proof. As in the proof of Theorem 39, we de.ne \na canonical subset: K ::= K .K |P .I .P The only difference compared with Theorem 39 is that now data \nformulae may contain the adjoint formulae K . P . Given an arbi\u00adtrary CL-formula, .rst replace the context \nsubformulae by canon\u00adical formulae, as in (1) of Theorem 39, then replace the applica\u00adtion subformulae \nby the equivalent substitution formulae as in (2). We must show how to eliminate the adjoint formulae \nK . P , by induction on the structure of K.When K is P1 .I .P2, then (P1 .I .P2) . P is equivalent to \nP1 -(P2 - P ). When K is K1 .K2,then (K1 .K2) . P is equivalent to (K1 . P ) .(K2 . P ). Finally, we \nshow that CL for sequences is parametrically more expressive than BL for sequences. This additional expressivity \nfor CL must lie in the use of the modality. Intuitively, BL can only add elements to either side of a \ngiven sequence, whilst can add elements wherever the hole happens to be. We initially searched for a \ndirect proof of this result, trying to identify a property analo\u00adgous to the heap-reducing formulae of \ntheorem 34 which captured this difference between adding elements to the side or the middle of sequences. \nBL-formulae can however affect the middle of the sequence, by using .and - to remove the whole sequence \nand adding any desired sequence. We do not know if such a direct re\u00adsult is possible. Here, we prove \nour parametric expressivity result via a strong inexpressivity result using bisimulation. Theorem 41 \n(Parametric Inexpressivity). Let A be an in.nite al\u00adphabet. Then BLSeqA,{p} S CLSeqA,{p}. Proof. We consider \nBL and CL for sequences containing formulae with at most one propositional variable p. Consider CL-formula \nP \" (0 cp)(a) for some a .A. Expecting a contradiction, assume that P is equivalent to data formula P \n' ,and let A ' .A be the .nite set of letters occurring in P ' .Formula P says that p holds after removing \nan element a somewhere from the current sequence. By contrast, BL can only observe subsequences obtained \nby removing letters from either side, not from the middle. With BL, we can only compare adjacent pairs \nof elements. With CL, we can compare arbitrary pairs of elements. We must .nd an interpretation function \ns, and a bisimulation relation ~which is compatible with s and captures this intuitive difference in \nexpressivity. We choose an interpretation s which states that the interpreta\u00adtion of p is the set of \nall sequences with equal elements. To express this formally, we .rst introduce some notation. Let a, \n\u00df denote se\u00adquences, let ai denote the i-th element of sequence a,and let |a|denote the length of the \nsequence. We de.ne s by s(p) \" {a |.i .1..|a|-1.ai = ai+1} In addition, we de.ne a bisimulation relation \nwhich observes ele\u00adments in the set A ' and equality of adjacent elements: a ~\u00df iff .n. |a|= |\u00df|= n ..i \n.1 ...n -1.ai = ai+1 .\u00dfi = \u00dfi+1 . ' '' .i .1 ...n, a .A ' .ai = a .\u00dfi = a Clearly ~is compatible with \ns. Assume for the moment that it is indeed a BL-bisimulation. With this assumption, we prove the inexpressivity \nresult we seek. Consider two sequences a1 = ''' ''' a \u00b7a \u00b7a and a2 = a \u00b7a \u00b7a '' ,where a = a are not \nin A ' . Observe that a1 ~a2, as adjacent letters are distinct in both sequences, s, a1 |=(0 C p)(a) \nbut s, a2 |=(0 C p)(a). Assuming ~is a bisimulation for BLSeqA ' ,{p}, Proposition 33 implies that s, \na1|=BLP ' iff s, a2|=BLP ' for all BL-formulae P ' .We have therefore proved that there cannot be a BL-formula \nP ' which is equivalent to P . Note that our proof depends on A being an in.nite set, since we need to \npick new elements a ' and a '' not in A ' . Finally, we must show that ~is indeed a bisimulation for \nall the modalities of BLSeq,{p}. We only look at the .and A ' - modalities; the other cases are analogous \nor trivial. For the .modality, assume a\u00b7\u00df = . and . ~. ' . We must show that .a ' ,\u00df ' such that a ' \n\u00b7\u00df ' = . ' and a ~a ' and \u00df ~\u00df ' . Choose a ' ,\u00df ' as the unique splitting of . ' such that |a ' |= |a|and \n|\u00df ' |= |\u00df|. Clearly a ~a ' and \u00df ~\u00df ' , since adjacent elements in a ' and \u00df ' are also adjacent in \n. ' .For the - modality, assume a \u00b7\u00df = . and a ~a ' . ' . ' We need to show that .\u00df ' ,. such that a \n' \u00b7\u00df ' = and \u00df ~\u00df ' and . ~. ' .Since a and a ' might end in different letters, we must construct a \u00df \n' such that its .rst element relates to the last element of a ' in the same way as the .rst element of \n\u00df relates to the last element of a.Let f : A .A be a bijection such that f(ai)= a ' i. Such an f exists \nsince a ~a ' .We de.ne \u00df ' as the unique sequence such that |\u00df ' |= |\u00df|, \u00dfi ' = f(\u00dfi) and . ' \" a ' \u00b7\u00df \n' . It is easy to see that \u00df ~\u00df ' and . ~. ' .  5.3 Trees We have the following results for trees for \nalphabet A: BLTreeA,VD (-{- , bo})= CLTreeA,VD (-{, .}) \u00b5, b BLTreeA,VD = CLTreeA,VD (-{}) BLTreeA,{p} \nS CLTreeA,{p} if A is in.nite. The .rst result states that CL and BL for trees without adjoints have \nthe same parametric expressive power. The second result states that adding the . modality to CL gives \nthe same expressivity as BL. This formalises our intuition that the . modality is a compact way to express \nthe adjoints of AL (plus o). The third result is a para\u00admetric inexpressivity result, showing that CL \nfor trees is parametri\u00adcally more expressive than BL for trees. This result illustrates that is the key \nmodality for giving CL its additional expressive power. In [3], we observed that it was important for \nexpressing the weak\u00adest preconditions of update commands. Our inexpressivity result formalises this intuition, \nwhich we had previously motivated by ex\u00adample. Our .rst parametric expressivity result is that BL and \nCL for trees without adjoints are equally expressive. The proof shows that context formulae can be reduced \nto a canonical form, allowing con\u00adtext application to be eliminated by a form of syntactic substitution. \nTheorem 42 (Parametric Expressivity). BLTreeA,VD (-{- , \u00b5,bbo})= CLTreeA,VD (-{, .}) Proof. Note that \npropositional variables are restricted to sort D, so the context formulae of CLTreeA,VD (-{, .}) are: \nK ::= I |K .K |\u00acK |False |\u00b5[K] |P .K We de.ne a canonical subset, similar to that given in Theorem 39: \nK ::= K .K |True |False |P .I |P ..[K] . ::= {a1,...,an}|{a1,...,an}. The composition formulae analyse \nwhether the hole is at the top level or under a node label. The formulae {a1,...,an}[K] and WV . {a1,...,an}.[K] \nare syntactic sugar for ai[K] and ai [K] ii respectively. Just as for Theorem 39, it is enough to show \nthe following results: (1) every CL-formula K is equivalent to a canonical formula K; (2) every application \nK(P ) is equivalent to the substitution for\u00admula K[P/I, oP/True].  To prove (1), we de.ne a translation \ntr from context formulae to the canonical subset by: tr(I) \" 0 .I tr(K1 .K2) \" tr(K1) .tr(K2) tr(\u00acK) \n\" Not(tr(K)) tr(False) \" False tr(\u00b5[K]) \" 0 .\u00b5[tr(K)] tr(P .K) \" Add(P, tr(K)) where Not(K) and Add(P, \nK) are de.ned by induction on the structure of the canonical formulae. Before de.ning Not, we de.ne a \nfunction And on canonical formulae such that And(K1,K2) is equivalent to K1 .K2: And(K1 .K2,K3) \" And(K1,K3) \n.And(K2,K3) And(True,K) \" K And(False,K) \" False And(P1 .I,P2 .I) \" (P1 .P2) .I And(P1 .I,P2 ..[K]) \" \nFalse And(P1 ..1[K1],P2 ..2[K2]) \" (P1 .P2) .(.1..2)[And(K1,K2)] where, for sets Si,we de.ne S1.S2 = \nS1nS2, S1.S2 . = S1-S2, and S1 ..S2 . =(S1.S2).. We now de.ne the function Not such that Not(K) is equivalent \nto \u00ac(K): Not(K1 .K2) \" And(Not(K1), Not(K2)) Not(True) \" False Not(False) \" True Not(P .I) \" (\u00acP ) .I \n.true .\u00d8.[True] Not(P ..[K]) \" true .I .true ...[True] . (\u00acP ) ..[True] .true ..[Not(K)] We .nally de.ne \nAdd such that Add(P, K) is equivalent to P .K: Add(P, K1 .K2) \" Add(P, K1) .Add(P, K2) Add(P, True) \" \n(P .true) .I .(P .true) .\u00d8.[True] Add(P, False) \" False Add(P1,P2 .I) \" (P1 .P2) .I Add(P1,P2 ..[K]) \n\" (P1 .P2) ..[K] To prove (2), we proceed by induction on K. For case K1 .K2, note that (K1 .K2)(P ) \nis equivalent to K1(P ) .K2(P ) and hence, by induction, is equivalent to K1[P/I, oP/True] .K2[P/I, oP/True]. \nFor case True, observe that True(P ) is equiv\u00adalent to oP . Case False is immediate. Case P1 .I is also \nim\u00admediate since (P1 .I)(P2) is equivalent to P1 .P2. For case P1 ..[K], .rst observe that (P1 ..[K])(P2) \nis equivalent to P1 ..[K(P2)] which, by the induction hypothesis, is equivalent to (P1 ..[K[P2/I, oP/True]]). \nConsider CL formula (\u00acI)(P ), satis.ed by any tree hav\u00ading a strictly smaller subtree satisfying P .We \nhave tr(\u00acI)= Not(tr(I)) = Not(0 .I)=(\u00ac0) .I .true .\u00d8.[True]. Therefore (\u00acI)(P ) is equivalent to (\u00ac0) \n.P .true .\u00d8.[oP ],satis.ed byany tree with either a subtree satisfying P at the top level composed with \na non-empty tree, or a subtree satisfying P under a tree node. Our second parametric expressivity result \nfor trees shows that CL for trees minus . corresponds to BL. Theorem 43 (Parametric Expressivity). BLTreeA,VD \n= CLTreeA,VD (-{}) Proof. The proof extends the proof of Theorem 42, just as the proof of Theorem 39 \nextends that of Theorem 40. We use the same canonical forms as in Theorem 42, and just need to show that \nK . P can be eliminated by induction on K. For case K1 .K2, we have (K1 .K2) . P equivalent to (K1 . \nP) .(K2 . P). For case True, we have True . P equivalent to boP. Case False is immediate, since False \n. P is equivalent to false. Case P .I is also immediate, since (P1 .I) . P is equivalent to P1 - P. For \ncase P ..[K],we have (P1 ..[K]) . P equivalent to K . (.b(P1 - P)) where, if S = {a1,...,an},then Sb(P) \nis c. a.  ab1(P) .\u00b7\u00b7\u00b7.acn(P) and S.(P) is ac1 (P) .\u00b7\u00b7\u00b7.cn(P).The result follows by the induction hypothesis. \nFinally, we show that CL for trees is parametrically more expres\u00adsive than BL. We are unable to give \na direct proof. We instead show a strong inexpressivity result based on interpretation seq,which in\u00adterprets \npas the property that all the labels in the tree are equal. We show that formula (0 C p)(a[true]), corresponding \nto the weakest precondition of deleting a subtree with root label a, is not express\u00adible in BL. Intuitively, \nthe result holds since CL can remove a sub\u00adtree at an arbitrary position, while BL can only split trees \nat the top level using .or under a .xed number of edges using \u00b5. Theorem 44 (Parametric Inexpressivity). \nLet A be an in.nite al\u00adphabet. Then BLTreeA,{p} S CLTreeA,{p}. Proof. The structure of the proof is identical \nto that of Theorem 41. Consider the CL formula P \" (0 C p)(a[true]), which says that we can remove a \nsubtree with root a from the current tree and the result satis.es p. Intuitively, BL can remove subtrees \nfrom the top level of the current tree using ., but cannot remove them from arbitrary positions. As in \nTheorem 41 for sequences, we restrict our attention to BL-formulae with a single propositional variable \npand node labels from a .nite set A ' .A. We de.ne the interpretation as t.s(p) iff all the labels in \ntree tare equal. Let ~be the unique relation such that: t~t ' iff t.s(p) .t ' .s(p) and if t=a1[t1] then \n.a1' ,t1 ' such that ''' ' t =a1[t1] and t1 ~t1 and ''' ' a1 .A or a1 .A implies a1 = a1 and if t=t1|t2 \nthen .t1' ,t2 ' such that ''' ' ' t =t1|t2 and t1 ~t1 and t2 ~t2 It is easy to see that ~is compatible \nwith s, and we will show that it is a BL-bisimulation. Let b,c be distinct labels not in A ' .{a}, and \nde.ne t1 \" b[a[0]|b[0]] and t2 \" b[a[0]|c[0]].We have t1 ~t2 and s,t1 |= P but s,t2 |= P, hence the result. \nWe must show that ~is a bisimulation for all the modalities of BLTreeA ' ,{p}. The modalities 0,.,\u00b5 are \nimmediate from the de.nition of ~. Modalities - ,bofollow from the fact that ~is a \u00b5,bcongruence: that \nis, if t ~t ' then c(t) ~c(t ' ) for all tree contexts c.For the omodality, we need to show that, if \nc(t1) =tand t~t ' , ''''' ' then there exist c ,t1 such that t =c (t1) and t1 ~t1. The proof is straightforward, \nby induction on the size of c.  6. Concluding Remarks We have shown how to present CL and BL as ML, \ninterpreting the structural connectives as modalities satisfying a set of well-behaved ML-axioms. We \nhave given two applications of the general theory of ML: we have proved completeness results for CL and \nBL using a general theorem about ML due to Sahlqvist, and inexpressivity results using the standard ML-bisimulation \ntechnique. Our parametric inexpressivity results for arbitrary formulae contrast with Lozes expressivity \nresults on closed formulae. We prove that SL is parametrically more expressive than PL for heaps, whereas \nLozes shows that these logics have the same expressivity on closed formulae. We also prove that CL for \ntrees is parametri\u00adcally more expressive than AL, whereas Lozes shows that they have the same expressivity \non closed formulae. Our de.nition of para\u00admetric expressivity corresponds to that studied in the ML-literature, \nand corroborates our intuition that the structural connectives of CL and BL are essential for our local \nHoare reasoning. Lozes style of expressivity result is not typically explored in the ML-literature. It \nis interesting for our application of structured data: for example, we have shown that CL for sequences \ncorresponds to the *-free regu\u00adlar languages on closed formulae. The structural connectives of CL and \nBL give rise to several examples of logics which are paramet\u00adrically more expressive, but which have \nthe same expressivity on closed formulae. We currently do not know of other examples of ML where this \nis the case, except for simple examples such as S4 and S5 where all closed formulae correspond to either \ntrue or false. We are only at the beginning of studying expressivity results for CL: for example, two \nnatural extensions involve higher-order quanti.cation and .rst-order quanti.cation. The parametric expres\u00adsivity \nresults in this paper are based on formulae with propositional variables. Our results say nothing about \nthe expressivity of higher\u00adorder SL over higher-order logic. Also, our results compare CL and BL without \n.rst-order quanti.cation, whereas their applications to analysing trees and heaps usually involve quanti.cation \nover node labels and heap addresses. Dawar, Gardner and Ghelli (with thanks to Yang) have shown that \nadjunct-elimination in AL with quan\u00adti.cation is not possible [6], strengthening a previous result by \nLozes [9]. Despite this inexpressivity result, it still makes sense to ask for parametric inexpressivity \nresults about particular formulae, to pin down exactly why full SL seems to be more appropriate for modular \nreasoning about programs than .rst-order logic. Acknowledgments We would like to thank Peter O Hearn \nfor his insightful comments. This work was supported by EPSRC.  References [1] J. Berdine, C. Calcagno, \nand P.W. O Hearn. Smallfoot: Modular automatic assertion checking with separation logic. In Proceedings \nof FMCO 05, volume 4111 of LNCS, 2006. [2] Patrick Blackburn, Maarten de Rijke, and Yde Venema. Modal \nLogic. Cambridge University Press, 2001. [3] C. Calcagno, P. Gardner, and U. Zarfaty. Context logic and \ntree update. In POPL, 2005. [4] L. Cardelli and G. Ghelli. TQL: A query language for semistructured data \nbased on the ambient logic. To appear in MSCS. [5] L. Cardelli and A. Gordon. Anytime, anywhere: Modal \nlogics for mobile ambients. In POPL, 2000. [6] A. Dawar, P. Gardner, and G. Ghelli. Adjunct elimination \nusing Enrenfeuch s games. In FSTTCS, 2004. [7] H.Hosoya and B. Pierce. Xduce: A typed xml processing \nlanguage. ACM Transactions on Internet Technology, 3:117 148, 2003. [8] S. Ishtiaq and P. O Hearn. BI \nas an assertion language for mutable data structures. In POPL, 2001. [9] Etienne Lozes. Elimination of \nspatial connectives in static spatial logics. In TCS 330(3), 2005. [10] D. Pym, P. O Hearn, and H. Yang. \nPossible worlds and resources: The semantics of BI. Theoretical Computer Science, 315(1), 2004. [11] \nJ.C. Reynolds. Separation logic: a logic for shared mutable data structures. Invited Paper, LICS 02, \n2002. [12] H. Yang. Local Reasoning for Stateful Programs. Ph.D. thesis, University of Illinois, Urbana-Champaign, \nIllinois, USA, 2001. [13] H. Yang and P. O Hearn. A semantic basis for local reasoning. FOSSACS, 2002. \n \n\t\t\t", "proc_id": "1190216", "abstract": "Separation Logic, Ambient Logic and Context Logic are based on a similar style of reasoning about structured data. They each consist of a structural (separating) composition for reasoning about disjoint subdata, and corresponding structural adjoint(s) for reasoning hypothetically about data. We show how to interpret these structural connectives as modalities in Modal Logic and prove completeness results. The structural connectives are essential for describing properties of the underlying data, such as weakest preconditions for Hoare reasoning for Separation and Context Logic, and security properties for Ambient Logic. In fact, we introduced Context Logic to reason about tree update, precisely because the structural connectives of the Ambient Logic did not have enough expressive power. Despite these connectives being essential, first Lozes then Dawar, Gardner and Ghelli proved elimination results for Separation Logic and Ambient Logic (without quantifiers). In this paper, we solve this apparent contradiction. We study parametric inexpressivity results, which demonstrate that the structural connectives are indeed fundamental for this style of reasoning.", "authors": [{"name": "Cristiano Calcagno", "author_profile_id": "81100047402", "affiliation": "Imperial College London", "person_id": "PP31024717", "email_address": "", "orcid_id": ""}, {"name": "Philippa Gardner", "author_profile_id": "81100521527", "affiliation": "Imperial College London", "person_id": "PP39054290", "email_address": "", "orcid_id": ""}, {"name": "Uri Zarfaty", "author_profile_id": "81100525241", "affiliation": "Imperial College London", "person_id": "P707746", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190236", "year": "2007", "article_id": "1190236", "conference": "POPL", "title": "Context logic as modal logic: completeness and parametric inexpressivity", "url": "http://dl.acm.org/citation.cfm?id=1190236"}