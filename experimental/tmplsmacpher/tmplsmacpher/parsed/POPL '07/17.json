{"article_publication_date": "01-17-2007", "fulltext": "\n Lightweight Fusion by Fixed Point Promotion * Atsushi Ohori Isao Sasano Research Institute of Electrical \nCommunication Tohoku University {ohori, sasano}@riec.tohoku.ac.jp Abstract This paper proposes a lightweight \nfusion method for general recur\u00adsive function de.nitions. Compared with existing proposals, our method \nhas several signi.cant practical features: it works for gen\u00aderal recursive functions on general algebraic \ndata types; it does not produce extra runtime overhead (except for possible code size in\u00adcrease due to \nthe success of fusion); and it is readily incorporated in standard inlining optimization. This is achieved \nby extending the ordinary inlining process with a new fusion law that trans\u00adforms a term of the form \nf . (fix g..x.E) to a new .xed point term fix h..x.E. by promoting the function f through the .xed point \noperator. This is a sound syntactic transformation rule that is not sensitive to the types of f and g. \nThis property makes our method applicable to wide range of functions including those with multi-parameters \nin both curried and uncurried forms. Although this method does not guarantee any form of completeness, \nit fuses typical examples discussed in the literature and others that involve accumulating parameters, \neither in the foldl-like speci.c forms or in general recursive forms, without any additional machinery. \nIn order to substantiate our claim, we have implemented our method in a compiler. Although it is preliminary, \nit demonstrates practical feasibility of this method. Categories and Subject Descriptors D.3.4 [Programming \nLan\u00adguages]: Processors Compilers, Optimization; D.3.4 [Program\u00adming Languages]: Language Classi.cations \nApplicative (func\u00adtional) languages; F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs \nProgram and recursion schemes General Terms Languages, Theory Keywords Fusion, inlining, .xed point * \nThis research was partially supported by the Japan MEXT (Ministry of Education, Culture, Sports, Science \nand Technologies) leading project of Comprehensive Development of Foundation Software for E-Society under \nthe title dependable software development technology based on static program analysis. The second author \nwas also partially supported by Grant-in-Aid for Young Scientists (B), 16700029 from the Ministry of \nEducation, Culture, Sports, Science and Technology. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c . 2007 \nACM 1-59593-575-4/07/0001. . . $5.00 1. Introduction Fusion is a program optimization technique to combine \ntwo ad\u00adjacent computations, where one produces a result which is then processed by the other, by fusing \ntwo successive computation steps (function applications or loops) into one, yielding a more ef.cient \nprogram. In functional programming, this technique has the additional signi.cance that it suppresses \nconstruction of in\u00adtermediate data structures, such as lists and other inductively de\u00ad.ned data structures. \nBurstall and Darlington [1] were perhaps the .rst to study this optimization in functional programming \nand pre\u00adsented a general strategy for generating ef.cient recursive programs through fold/unfold transformation. \nWadler [23] observed that this optimization can be carried out systematically to eliminate inter\u00admediate \ntrees altogether and showed the deforestation theorem stating that every composition of functions in \na certain restricted form can be effectively fused into a single function. Since this sem\u00adinal observation, \na series of investigations have been done towards establishing a general method for program fusion. One \ndirection toward developing a practical fusion method is to restrict the target functions to be of speci.c \nforms. Gill, Launch\u00adbury and Peyton Jones [6] presented the short cut deforestation law stating that \nif both the producer function and the consumer function are written in a speci.c form then they are fused \ntogether. Since this rule is a simple local transformation, it is easily incorpo\u00adrated in an optimizing \ncompiler. This approach has been general\u00adized to user-de.ned recursive data types [19, 22]. One major \nlimitation of these approaches is that they do not deal with general recursive functions. While it is \ncertainly a valid claim that lucid or compositional style programming has the advan\u00adtages of clarity \nand modularity, one often has to de.ne data struc\u00adtures speci.c to the problem domain and to write specialized \nfunc\u00adtions using general recursion. In serious practical software devel\u00adopment, this tendency is predominant. \nEven in the GHC compiler for Haskell, which implements the rule for short cut fusion [17], build/cata \nstyle code appears to be minority compared with general recursive functions. Since the general idea underlying \ndeforestation is equally applicable to general recursive de.nitions, it is highly de\u00adsirable to develop \na fusion method that works directly on general recursive functions. Launchbury and Sheard [12] proposed \none solution to this prob\u00adlem by developing an algorithm to transform a recursive function de.nition \ninto a program in build/cata form. The resulting program is then fused by build/cata laws. Chitil [4] \nproposed a type based approach to obtaining build forms from general recursive de.ni\u00adtions. These approaches \nare conceptually elegant, but their practi\u00adcal feasibility is not clear. A key step in their development \nis to represent a term that constructs a data structure as a higher-order function using the technique \nof representing term algebra (induc\u00adtive types) in the second-order lambda calculus. For example, an \nef.cient and compact list term 1:2:nil (written in Haskell syn\u00adtax) is temporarily heated up to a lambda \nterm .c..n.c 1(c 2n). It is questionable whether or not these costly abstractions should all be fused \naway in an optimizing compiler for a language that involves various features over pure lambda expressions. \nAnother limitation of the short-cut fusion approach is that it is restricted to functions of single argument. \nIn practical software development, functions are often written in ef.cient tail recursive form using \naccumulating parameters, or they may take various extra parameters required by the problem domain. Unfortunately, \nshort-cut fusion [6] and its extension [22, 21] do not scale up to those functions. In order for a fusion \nmethod to become a practical optimiza\u00adtion method for an optimizing compiler, it should ideally have \nthe following features. 1 It is simple and fully automatic so that it can be easily embedded in an optimizing \ncompiler. 2 It does not introduce any extra runtime overhead. 3 It works for general recursive functions \nwith multiple parame\u00adters (including accumulating parameters and others). 4 It works for general user-de.ned \ndata types. 5 It fuses all fusable functions. Development of such a method is the ultimate goal of the \nsubject. However, if we weaken the requirement by replacing the last con\u00addition of completeness to 5 \nit works for expected typical cases, then we can indeed develop such a system. An attempt is made in \nthis paper to develop such a fusion method. Previous researches have mainly focused on algebraic (or \ncat\u00adegorical) properties of generic functions on data structures for de\u00adducing general fusion patterns. \nSome notable examples include the promotion theorem for foldr [13] and its generalizations [14, 19], \nshort-cut deforestation for foldr and build [6] and its generaliza\u00adtion in calculational form [22], destroy \nand unfold fusion [21], and more recent algebraic fusion based on monoid homomorphism [11]. Instead of \npursuing this direction, we follow the original ap\u00adproach of fold/unfold transformation [1] and develop \na method to fuse two recursive function de.nitions directly through unfolding, simpli.cation (beta-reduction), \nand folding (generating new recur\u00adsive de.nitions). The crucial step in developing a practical fusion \nmethod is to .nd deterministic and simple, yet powerful rules to control the fusion process. By analyzing \nvarious fusable recursive functions, we have dis\u00adcovered the following simple yet effective transformation \nstrategy. Let f =fix f..x.Ef and g =fix g..x.Eg be recursive function de.nitions. Under these bindings, \nwe can transform the composi\u00adtion f .g to obtain a fusion of the two as follows. 1. Inline the body of \ng to obtain f ..x.Eg, which is beta reduced to .x.f Eg. 2. Transform fEg to Eg . by distributing the \nfunction symbol f to all the tail positions of Eg. 3. Inline f once in Eg . and simplify the term to \nobtain a term Ef,g. 4. Replace the occurrences of f . g in Ef,g by a new function name fg and generate \na new binding fg =fix f g..x.Efg.  Since this process promotes the function f through the .xed point \noperator, we call it .xed point promotion. Step 2 is represented by a term transformation axiom, which \nwe call (AppDist). The entire step is represented by a transformation rule that produces a new .xed point \nterm (Step 4) by reducing the body using (AppDist) and other reduction axioms. We refer to this transformation \nrule as (FixPromote).   This remarkably simple process can fuse various general recur\u00adsive functions, \nincluding those involving accumulating parameters or tail recursive functions such as foldl without resorting \nto any heuristics. Since this process only involves two simple determin\u00adistic transformation rules, it \ncan easily be incorporated in any in\u00adlining process. Moreover, it is robust enough to scale up to practi\u00adcal \noptimizing compiler of a polymorphic functional language. We therefore claim that the resulting fusion \nalgorithm is a practical one that satis.es the desired criteria mentioned above. In order to sub\u00adstantiate \nthis claim, we have implemented the algorithm in a proto\u00adtype compiler for a full scale functional language, \nand have tested various examples. The results verify that our method fuses typical examples including \nthose with extra parameters. The implementa\u00adtion is made available through the Internet for downloading. \nSee Section 6 for the details. We should note that the implementation is a preliminary one only for testing \nthe behavior of the proposed method, and does not intend to be a part of a practical optimization phase. \nThe rest of the paper is organized as follows. Section 2 infor\u00admally presents our lightweight fusion \nmethod through examples. Section 3 de.nes a simple functional language, gives our two new fusion rules, \nand proves the soundness of the two rules. Section 4 presents the fusion algorithm. Section 5 demonstrates \nthe power of the algorithm through various examples. Section 6 descries our ex\u00adperimental implementation. \nSection 7 shows some general bench\u00admark results and their analysis. Section 8 discusses related work. \nSection 9 concludes the paper. 2. Overview of Lightweight Fusion To illustrates our method, let us .rst \nconsider the following simple example. let mapsq = fix mapsq. .L.case L of nil => nil, cons(h,t) => cons(h*h, \nmapsq t) sum = fix sum..L.case L of nil => 0, cons(h,t) => h + sum t in \u00b7\u00b7\u00b7 sum (mapsq E) \u00b7\u00b7\u00b7 end On \ndetecting an application sum (mapsq E) of a composition of two recursive functions, we attempt to generate \na new recursive de.nition starting from the composition function: .x.sum (mapsq x) where the subterms \nthat are transformed in the subsequent step are underlined. We .rst inline the lambda body of the inner \nfunction mapsq. .x.sum (case x of nil => nil, cons(h,t) => cons (h*h, mapsq t))  Inlining is not recursive, \nand hence mapsq in the body refers to the original de.nition. Next, we apply the (AppDist) rule: we distribute \nthe function name sum to all the tail positions of its argument term. .x.case x of nil => sum nil, cons(h,t) \n=> sum (cons (h*h, mapsq t))  We then inline the lambda body of sum once, and simplify the resulting \nterm. .x.case x of nil => 0, cons(h,t) => h*h + sum (mapsq t) If the resulting term contains the composition \nsum (mapsq ) that we are fusing, then we create a new recursive function name sum mapsq and substitute \nit for the composition. fix sum mapsq..x.case x of nil => 0, cons(h,t) => h*h + sum mapsq t This entire \nprocess is an application of (FixPromote). The successful application of (FixPromote) indicates that \nthe composition of the two functions is fused into a new recursive function. If this happens, then we \nput the new de.nition after the de.nitions of sum and mapsq, and replace all the occurrences of the composition \nsum . mapsq appearing in the rest of the program by sum mapsq. If there is no reference to the original \nfunctions sum and mapsq then their de.nitions are removed by dead code elimination, and the following \nprogram is obtained. let sum mapsq = fix sum mapsq. .x.case x of nil => 0, cons(h,t) => h*h + sum mapsq \nt in \u00b7\u00b7\u00b7 sum mapsq E \u00b7\u00b7\u00b7 end This process is easily extended to functions of multiple param\u00adeters. For \nexample, suppose sum is de.ned in tail recursive form as follows. let mapsq = ... sum = fix sum..L..S. \ncase L of nil => S, cons(h,t) => sum t (S + h) in \u00b7\u00b7\u00b7 sum (mapsq E)0 \u00b7\u00b7\u00b7 end We start with .x..S.sum \n(mapsq x) S and .rst inline mapsq. .x..S.sum (case x of nil => nil, cons(h,t) => cons (h*h, mapsq t)) \nS We then distribute the application context sum S to all the tail positions. .x..S.case x of nil => \nsum nil S, cons(h,t) => sum (cons (h*h, mapsq t)) S Next, we inline sum once and simplify. .x..S.case \nx of nil => S, cons(h,t) => sum (mapsq t) (S + h*h) Finally, we replace .x..S.sum (mapsq x) S with a \nnew func\u00adtion name sum mapsq and obtain the following program (after dead code elimination). let sum \nmapsq = fix sum mapsq..x..S. case x of nil => S, cons(h,t) => sum mapsq t (S + h*h) in \u00b7\u00b7\u00b7 sum mapsq \nE 0 \u00b7\u00b7\u00b7 end This transformation process also extends to uncurried multi\u00adargument functions. We note that \nthe process outlined above is simple, terminating and entirely automatic, so that it can easily be embedded \nin the standard inlining process. Moreover, it relies neither on any heuris\u00adtics nor on any special properties \nof data types or functions. It is therefore applicable to general function de.nitions manipulating user-de.ned \ndata types.  3. Fixed Point Promotion Laws and its Soundness This section presents the new fusion laws \non which our method is based, and shows their soundness. 3.1 The source language and some notations We \nconsider the following set of lambda terms. M ::= x|.x.M |fix f.M |MM | C(M,...,M) | case M of p=> M,...,p=> \nM | let x= M in M end p ::= C(x,...,x) fix f.M denotes the .xed point of the functional .f.M and repre\u00adsents \na recursive function term. C(M,...,M) is a data constructor term for algebraic (user de.ned) data types. \nWe sometimes write let x1 = M1,...,xn = Mnin M end for an abbreviation of a nested let expression. If \nM and N are terms, we write M{N/x}for the term obtained by the usual capture free substitution of N for \nxin M. In addition to this core syntax, in examples, we use terms containing primitive operations. For \nthis language, we assume the usual bound variable conven\u00adtion, i.e., the set of bound variables are pairwise \ndistinct and are different from free variables. A context, ranged over by C, is de.ned by the following \nsyntax C ::= [] |x|.x.C|fix f.C|CC | C(C,...,C) | case Cof p=> C,...,p=> C | let x= Cin C end where \n[] is a hole . If we need to identify each hole differently, we use some index i and write []i. A context \nC generated by this grammar contains zero or more holes. In what follows, we let C range only over those \ncontexts that contain one or more holes.We write C[Mi]i for the term obtained from C by .lling each hole \n[]i of C with (different) Mi, and write C[M] for the term obtained from Cby .lling all the holes of Cwith \nthe same M. We also write C{N/x}for the context obtained from the capture free substitution of N for \nx in C. In particular, C{N/x}[Mi]i denotes the term obtained by .lling each hole []i of the context C{N/x}with \nMi. A tail context, ranged over by T, is de.ned by the following syntax. T ::= [] | case M of p=> T,...,p=> \nT | let x= M in T end A tail context T is a term with holes at its all tail positions. We write T[Mi]i \nfor the term obtained by .lling each hole []i in T with Mi. 3.2 Fusion laws for single parameter functions \nWe assume the standard call by name semantics. Later in Section 6, we shall comment on applying our fusion \nmethod to strict lan\u00adguages. Our .rst fusion law is apply distribution de.ned below. (AppDist) f T[Mi]i \n=.T[fMi]i By this reduction, (static) evaluation can continue. This rule pulls out the head term of \na case expression. For this rule to be sound, it is therefore necessary for f to be strict. Note that \nthis condition is enforced in short-cut fusion. THEOREM 1. (AppDist) is sound for any strict f. Proof. \nHere we assume a standard environment-style denotational semantics [[M]]. of lambda term M under environment \n.,and show the semantic equation: [[f T[Mi]i]]. =[[T[fMi]i]]. The following argument does not depend \non speci.c property of the semantic de.nition. The proof is by simple induction on the structure of the \ntail context T. The base case is the identity. Suppose T = case M0 of \u00b7\u00b7\u00b7 ,pk => Tk, \u00b7\u00b7\u00b7.Then T[fMi]i \n= case M0 of \u00b7\u00b7\u00b7 ,pk => Tk[fMjk ]jk , \u00b7\u00b7\u00b7 Suppose [[f T[Mi]i]]. ...Since f is strict, [[T[Mi]i]]. = .. \n= .Suppose [[M0]]. = Ci(v1,...,vn) for some Ci such that pi = Ci(x1,...,xn). Then we have the following. \n[[f (case M0 of \u00b7\u00b7\u00b7 ,pi => Ti[Mji ]ji , \u00b7\u00b7\u00b7)]]. =[[f Ti[Mji ]ji .. ]]. .{x1 .v1,...,xn .vn} =[[Ti[fMji \n]ji .. ]]. .{x1 .v1,...,xn .vn} (by induction hypothesis) =[[case M0 of \u00b7\u00b7\u00b7 ,pi => Ti[fMji ]ji , \u00b7\u00b7\u00b7]]. \nThe cases other than [[M0]]. .Ci(v1,...,vn) are trivial in an = untyped semantics, or vacuous in a typed \nsemantics. The case for let x = M in T end is simpler and omitted. . Our main law for .xed point promotion \nis the following infer\u00adence rule. f .M =+.C[f .g] (FixPromote) f .fix g.M =.fix h.(C{fix g.M/g})[h] where \n=+.represents one or more applications of the transforma\u00adtion relation =.generated by our fusion laws \n(together with stan\u00addard simplifying reduction rules.) To show the soundness of this rule, we .rst show \na general equational property. We write M = M. for the \u00df equality relation with the following rule for \nfix fix g.M = M{fix g.M/g} and we write M =N for the syntactic and de.nitional equality. LEMMA 1. If \nf .M = C[f .g] then f .fix g.M is a .xed point of the functional .h.(C{fix g.M/g})[h]. Proof. Assume \nf .M = C[f .g]. We have the following. f .fix g.M = .x.f((fix g.M) x) = .x.f((M{fix g.M/g}) x) = .x.(f(Mx)){fix \ng.M/g}= (f .M){fix g.M/g} = C[f .g]{fix g.M/g}(by assumption) = C[f .fix g.M]{fix g.M/g}=C{fix g.M/g}[f \n.fix g.M] =(.h.C{fix g.M/g}[h])(f .fix g.M) . We further assume the standard denotational semantics based \non the standard domain theory, where the .xed point construct denotes the least .xed point in the continuous \nfunction space. THEOREM 2. (FixPromote) is sound for any strict f. Proof. In the following argument, \nwe implicitly identify terms with their denotations in the domain theory. Since the denotation of fix \nh.(C{fix g.M/g})[h] is the least .xed point, Lemma 1 establishes the following. f .fix g.M .fix h.(C{fix \ng.M/g})[h] To show the converse, let F = .w.C{fix g.M/g}[w], and write Fn(x) for F(F \u00b7\u00b7\u00b7(Fx) \u00b7\u00b7\u00b7). We \n.rst show the following in\u00ad | {z } n times equation for all n by induction on n. Fn(.) .f .((.g.M)n(.)) \n This holds for n =0 since f .. = .. The induction step is as follows. Fn+1(.)= C{fix g.M/g}[Fn(.)] .C{fix \ng.M/g}[f .((.g.M)n(.))] .C{(.g.M)n(.)/g}[f .((.g.M)n(.))] = C[f .g]{(.g.M)n(.)/g}=(f .M){(.g.M)n(.)/g}= \nf .((.g.M)((.g.M)n(.))) = f .((.g.M)n+1(.)) From the above inequality, we have the following. fix h.(C{fix \ng.M/g})[h]= {Fn(.) |n =0} .{f .(.g.M)n(.) |n =0}= f .{(.g.M)n(.) |n =0} (since f and .are continuous) \n= f .fix g.M This concludes the proof. . 3.3 Fusion laws for multiple parameter functions Both of (AppDist) \nand (FixPromote) extend systematically to multi-parameter functions. The case where the inner g is a \nmulti\u00adparameter function is straightforward. Here we only show the fol\u00adlowing two cases. 1. The outer \nf is a two parameter curried function whose .rst argument is the target of fusion. 2. The outer f is \na two parameter uncurried function whose .rst argument is the target of fusion.  For the curried case, \nthe law (AppDist) and (FixPromote) be\u00adcome (AppDist-c) and (FixPromote-c) as shown in Figure 1. For these \nlaws, we can show the following. THEOREM 3. (AppDist-c) is sound for any function f that is strict with \nrespect to the .rst argument, i.e. f .y = .. LEMMA 2. If f (Mx) y = C[f (gM1i) M2i]i then .x..y.f((fix \ng.M) x) y is a .xed point of .h..x..y.C[hM1 i M2i]i{fix g.M/g}. For the uncurried case, the law (AppDist) \nand (FixPromote) become (AppDist-u) and (FixPromote-u) as shown in Figure 1. In these de.nitions, we \nhave used extended lambda terms: .(x,y).M for two-parameter lambda abstraction and M(M1,M2) for two\u00adparameter \nlambda application. For these laws, we can show the following. THEOREM 4. (AppDist-u) is sound for any \nfunction f that is strict with respect to the .rst argument, i.e. f (.,y)= .. LEMMA 3. If f (Mx,y)= C[f \n(gM1i,M2i)]i then .(x,y).f ((fix g.M) x, y) is a .xed point of .h..(x, y).C[h (M1i,M2i)]i{fix g.M/g}. \n(AppDist-c) f T[Mi]i x =.T[fMi x]i f (Mx) y =.C[f (gM1i) M2i]i (FixPromote-c) .x..y.f ((fix g.M) x) \ny =.fix h..x..y.C[hM1 i M2i]i{fix g.M/g} (AppDist-u) f (T[Mi]i,x)=.T[(fMi,x)]i f (Mx,y)=.C[f (gM1i,M2i)]i \n(FixPromote-u) .(x,y).f ((fix g.M) x,y)=.fix h..(x,y).C[h (M1i,M2i)]i{fix g.M/g} Figure 1. Fusion Laws \nextended to Multi-parameter Functions Theorems 3, 4 and Lemmas 2, 3 can be proved similarly to the corresponding \nproofs of Theorem 1 and Lemma 1. We expect that semantic correctness of these generalized lows can be \nshown similarly to the proof of Theorem 2. Note that it is straightforward to generalize these results \nto the cases with functions having more than two parameters. Our fusion algorithm shown in Section 4 \nand our implementation described in Section 6 treat general multi-parameter cases.  4. The Lightweight \nFusion Algorithm We now develop a lightweight fusion algorithm by embedding the fusion mechanism explained \nabove in an inlining process. The strategy is summarized below. The algorithm recursively evaluates \nthe input term using a bind\u00ading environment.  In order to suppress repeated fusion computations, the \nalgo\u00adrithm also maintains a fusion environment that records the re\u00adsults of previous fusion attempts \nfor pairs of variables that are bound to recursive functions.  When it encounters a function composition \nf .g, the algorithm .rst checks in the binding environment whether both f and g are bound to recursive \nfunctions. If this is the case then the algorithm performs the following actions depending on the past \nhistory of the pair (f, g) recorded in the fusion environment.  If fusion for this pair has succeeded \nbefore, then it returns the new function name f g that was created by the previous fusion attempt and \nrecorded in the fusion environment.  If fusion failed before, then it returns f .g.  If fusion has \nnever been tried, then the algorithm attempts to fuse the two by applying the fusion laws explained in \nSection 3, and returns the environment extended with the result of the fusion attempt.   When it encounters \na term let h = M1 in M2 end,the al\u00adgorithm processes M1 and obtains the new terms, and then pro\u00adcesses \nM2 with the updated fusion environment. The algorithm then checks whether the fusion environment holds \nnew function de.nitions that should be inserted into this let binding accord\u00ading to the following policy. \nIf functions f and g are de.ned in this order, and f g = M is the new function de.nition created by fusing \nf and g,then f g is inserted immediately after the binding of g. In a strict language, a further special \ntreatment of bindings is necessary during the computation of the (FixPromote) rule. We shall discuss \nthis issue in Section 6.3.  For all the other terms, the algorithm performs standard inlining and simpli.cation. \n To de.ne the algorithm, we introduce some notations. We use f, g for variables bound to functions. \nWe let \u00b5 range over binding environments, which is a mapping from variables to terms. We write \u00b5{x ..M}for \nthe environment obtained from \u00b5 by adding the binding {x ..M}, and write \u00b5|x for the environment obtained \nfrom \u00b5 by deleting the entry of x.We let . range over fusion environments, which is a mapping from pairs \nof variables to one of the following results of fusion attempts.  Unde.ned : fusion has never been tried \nfor the pair.  Failed : fusion has failed for this pair.  Succeeded M: fusion has succeeded for the \npair with the fused function term M.  Inserted : fusion has succeeded and the binding has already been \ninserted as a binding in some let expression.  We write .{(f, g) . . M}for the environment obtained \nfrom . by adding the binding {(f, g) . . M}. Under the bound variable convention for terms, both a variable \nand a pair of variables are globally unique and therefore \u00b5{x .. M}and .{(f, g) .. M}are always well \nde.ned. We adopt the convention that the new fused function name for a pair f .g is fg (determined from \nf, g), and we do not record this name in a fusion environment.  The lightweight fusion algorithm is \nnow de.ned as a function F[[ ]] of the following functionality. F[[M]] .\u00b5 =(M.,..) In order to avoid \nnotational complication, we give the de.nition of F[[ ]] for one-parameter functions, and explain the \nnecessary extensions for the multi-parameter case later. The algorithm is given in Figure 2 and 3. It \nonly shows the cases relevant to fusion. The other cases are simple recursive evaluation as in ordinary \ninlining. The algorithm uses the sub\u00adalgorithms fusion and dist. The function fusion is for fusing two \nrecursive functions; fusion (f, .x.Mf )(g,.x.Mg) \u00b5. tries to fuse f and g in the expression .x.f (gx) \nunder the bindings {f .. .fix f..x.Mf ,g .fix g..x.Mg}according to the method described in Section 3. \nThe substitution {.x.Mf /f}used in the de.nition of fusion indicates that f is inlined once in F[[ ]].The \npattern C[f (gMi)]i used in case branches in fusion indicates that a term of the form f (gM) is replaced \nby fgM each time F[[ ]] encounters the successive application of f and g. These can be im\u00adplemented by \nadding some extra information in the entries of the fusion environment \u00b5. dist(f, M) distributes the \nfunction variable f to all the tail positions in M according to the de.nition given in Section 3. 4.1 \nExtensions to multiple parameter functions We describe the necessary extensions to deal with multiple \nparam\u00adeter functions. Here we only consider uncurried functions, since an intermediate language of an \noptimizing compiler often uses the un\u00adcurried representation. This is also the case in our implementation. \n   F[[M]] .\u00b5= case M of (f (gM0)) . let (M0. ,..)= F[[M0]] .\u00b5 in case ..((f,g)) of Failed . ((f (gM0. \n)),..) | Succeeded  . (f gM0. ,..) | Inserted . (f gM0. ,..) | Unde.ned . if \u00b5(g)= fix g..x.Mg and \u00b5(f)= \nfix f..x.Mf then let ... = fusion (f, .x.Mf )(g, .x.Mg) .. \u00b5|g in case ...((f,g)) of Succeeded . (f \ngM0. ,...) | Failed . (f (gM0. ),...) end else we perform ordinary inlining end | let h = M1 in M2 end \n. let (M1. ,.1)= F[[M1]] .\u00b5 (M2. ,.2)= F[[M2]] .1 \u00b5{h ..M1. } in if .2 = .. . 2{(f,g) . Succeeded M3)} \nand (f = hor g = h) then (let h = M1. in let f g = M3 in M2 . end, .2. {(f,g) . . Inserted}) else (let \nh = M1 . in M2 . end,.2) end | in all the other cases we perform ordinary inlining fusion (f,.x.Mf )(g, \n.x.Mg) .\u00b5 = let Mbody = dist(f,Mg) in case Mbody of C[f (gMi)]i . let (M1,..)= F[[C[f gMi]i{.x.Mf /f}]] \n.\u00b5|f in case M1 of C[f (gMi)]i . ..{(f,g) . . Succeeded (fix f g..x.C[f gMi]i)} | . ..{(f,g) . . Succeeded \n(fix f g..x.M1)} end | . case F[[Mbody {.x.Mf /f}]] .\u00b5|f of (C[f (gMi)]i,..) . ..{(f,g) . . Succeeded \n(fix f g..x.C[f gMi]i)} | ( ,..) . ..{(f,g) . . Failed} end Figure 2. Fusion algorithm F[[ ]] dist(f,M)= \ncase M of case M0 of p1 => M1, ..., pn => Mn . case M0 of p1 => dist(f,M1), ..., pn => dist(f,Mn) | let \nx= M1 in M2 end . let x= M1 in dist(f,M2) end | . fM Figure 3. Distribution function dist The set of \nterms is extended to include the uncurried multiple parameter functions as follows. M ::= \u00b7\u00b7\u00b7 | .(x1,...,xk).M \n| M (M,...,M) In what follows, we write M.for a sequences of terms of the form M1,...,Mk separated by \ncomma. Similar notation is used for patterns. For example, (M.1 ,...,M.n) represents a tuple term of \nthe form (M11,...,M1 ,...,M1 n,...,Mn ). k1 kn The extended algorithm FM[[ ]] processes multi-parameter \nfunctions as follows. FM[[M]] .\u00b5= case M of f (M.) . case divide(M.) of (M.l,g (M.m),M.r) . ... let \n... = fusionM (f,.(.x).Mf )(g,.(.x).Mg ) .. \u00b5|g in \u00b7\u00b7\u00b7 When the algorithm detects an application f(M.), \ndivide(M.) searches for an application term of the form g (M.m) in M.and returns (M.l,g(M.m),M.r) indicating \nthat M.are divided into three parts, the middle of which is the application term g (M.m).The matched \nterms M.l,M.m,M.r are recursively processed by FM[[ ]] and then used as part of the result as in the \nalgorithm F[[ ]].When f and g are recursive functions and they have not been tried to fuse, the extended \nfusion function fusionM is invoked and it tries to fuse f and gin the expression .(x.l,.m,.r).f ( .xm),. \nxxxl,g( .xr) under the bindings {f .x).Mf ,g . fix g..(.x).Mg}. . fix f..(..Note that we allow both the \nouter function f and the inner function g to have more than one arguments. The fusing function fusionM \nis obtained by re.ning fusion based on the rule (FixPromote-u) in Section 3. The sub-algorithm dist is \nalso re.ned to distM according to (AppDist-u) rule. distM (f,(M.l),M,(M.r)) = case M of case M0 of p1 \n=> M1, ..., pn => Mn . case M0 of p1 => distM (f,(M.l),M1,(M.r)),..., pn => distM (f,(M.l),Mn,(M.r)) \n| let x1 = M1, ..., xk = Mk in M0 end . let x1 = M1, ..., xk = Mk in distM (f,(M.l),M0,(M.r)) end | \n. f(M.l,M, M.r) The arguments f, M.l, M.r are always variables since the function distM is invoked in \nthe function fusion as follows. let Mbody = distM (f, (x.l),Mg ,(x.r)) in ... So the function distM does \nnot cause code duplication. The function fusionM tries to .nd successive function appli\u00ad cations of the \nform f (M.li,g Mi,M.ri) and replaces them with f g (M.li,Mi,Mri). By using the pattern matching notation \nas in the algorithm F[[ ]], we can write the matching part as follows: case Mbody of C[f (M.li,g Mi,Mri)]i \n. ... M.i M.i where l and r are pattern variables used to match the ar\u00adguments. When the matching succeeds, \nthe algorithm creates the term of the form C[f g(M.li,Mi,Mri)]i. This achieves the replace\u00ad ment of the \ncomposition f(M.li,g Mi,Mri) of f and gwith uncur\u00adried multi-parameters by the application f g(M.li,Mi,Mri) \nof new function f gto the multiple parameters.  5. Examples We claim that the lightweight fusion method \nwe have just presented has practical signi.cance in two ways. Firstly, it is readily imple\u00admentable in \nany optimizing compiler that performs inlining, and it does not produce extra runtime overhead (except \nfor code size increase due to the fact that both fused functions and the original functions are referenced.) \nSecondly, although it does not have any formal completeness property, it is powerful enough to fuse a \nwide range of recursively de.ned functions. As we shall report in Section 6 and Section 7, we substantiate \nthe .rst property by developing a simple inliner for a prototype compiler of a full scale functional \nlanguage and testing it with some benchmarks. The second property can only be substantiated through long-term \npractical testing. We demonstrate its feasibility through examples that have been discussed in the literature. \n 5.1 Successful examples and their performance This subsection shows typical examples that our lightweight \nfusion algorithm can deal with. All of them are successfully fused by our implementation without any \npreparation or ad-hoc modi.cation to the algorithm. We measured execution time, heap usage, and .le size \nfor the examples with or without the inlining and fusion on our abstract machine. The input data are \nlists with 105 elements and trees with 218 elements. Tables 1, 2, and 3 show the performance results. \nThe meaning of the column marks are: - is without inlining, Inline is with inlining, Fusion is with inlining \nand fusion, and F/I is the ratio of the last two. As we shall describe in Section 6, our implementation \nis in a compiler for SML#, an extension of Standard ML. So let us use Standard ML syntax in showing examples. \nAlthough fusion is done for a typed polymorphic intermediate language, in showing exam\u00adples, we omit \ntype information to avoid cluttering the programs. Sumofsquaresofalist ofintegers. This is the old friend \nof fusion, whose fusion steps have been shown in Section 2. Before fusion: let fun sum [] =0 | sum (x::xs) \n= x + sum xs fun mapsq [] = [] | mapsq (x::xs) = x*x :: mapsq xs in sum (mapsq list) end After fusion: \nlet fun sum_mapsq [] = 0 | sum_mapsq (x::xs) = x*x + sum_mapsq xs in sum_mapsq list end Sum of the integers \nfrom nto m. An integer list is produced by from and is consumed by sum. Before fusion: let fun sum [] \n=0 | sum (x::xs) = x + sum xs fun from a b=if a >b then [] else a :: from (a+1) b in sum (from 100000 \n200000) end After fusion: let fun sum_from ab= if a> bthen 0 else a + sum_from (a+1) b in sum_from 100000 \n200000 end foldl: Tail recursive sum of squares of list of integers. This is a rewrite of the previous \nexample using foldl.The tail recursive foldl is much preferred to foldr if the result is the same. There \nseems to be no practically implemented automated fusion system that can deal with this simple example. \nBefore fusion: let fun from ab =if a> bthen [] else a :: from (a+1) b fun foldl fr []= r | foldl f r \n(x::xs) = foldl f (f (x,r)) xs in foldl (op +) 0 (from 100000 200000) end After fusion: let fun foldl_from \nf r a b = if a> bthen r else foldl_from f (f (a,r)) (a+1) b in foldl_from (op +) 0 100000 200000 end \nFusion of map. A boolean function even is applied to each element in the input integer list. Then the \nfunction allTrue checks whether all the obtained values are true or not. Before fusion: let fun allTrue \n[] = true | allTrue (x::xs) = x andalso (allTrue xs) fun mapf [] =[] | mapf (x::xs) =f x:: map fxs fun \neven x= xmod 2= 0 in allTrue (map even list) end After fusion: let fun allTrue_map f [] = true | allTrue_map \nf (x::xs) = f x andalso (allTrue_map f xs) fun even x =xmod 2 =0 in allTrue_map even list end  Table \n1. Execution time for typical examples (in seconds) Table 3. Program sizes for typical examples (in byte) \nProgram - Inline Fusion F/I sum mapsq 0.27 0.27 0.21 78% sum from 0.21 0.22 0.15 68% foldl from 0.27 \n0.27 0.15 56% allTrue map 0.43 0.33 0.18 55% sumTree mapsqTree 0.77 0.76 0.51 67% Program - Inline Fusion \nF/I sum mapsq 3,567 3,371 3,459 102.6% sum from 2,278 2,126 2,174 102.3% foldl from 3,354 3,274 2,546 \n77.8% allTrue map 5,011 4,599 4,543 98.8% sumTree mapsqTree 5,420 4,556 4,596 100.9% Table 2. Heap allocation \nfor typical examples (in the number of .elds divided by one thousand) Program - Inline Fusion F/I sum \nmapsq 600.2 600.2 300.2 50.0% sum from 300.2 300.2 0.2 0.1% foldl from 500.2 500.2 200.2 40.0% allTrue \nmap 1,200.3 600.2 300.2 50.0% sumTree mapsqTree 2,621.7 2,621.7 1,310.9 50.0% In this case, the function \neven is simply passed to the next func\u00adtion call without any change. This is just an extra parameter \nbut not the so called accumulating parameter. Our fusion algorithm does not depend on whether the parameter \nis accumulating or not. Fusion of functions on trees Our fusion does not depend on lists. In fact, our \nfusion system does not even know any property of list. Our system can fuse functions on user de.ned tree-like \nstructure. Here is a simple example of fusing tree. Before fusion: let fun sumTree Empty = 0 | sumTree \n(Node (x,t1,t2)) = x + sumTree t1 + sumTree t2 fun mapsqTree Empty = Empty | mapsqTree (Node (x,t1,t2)) \n= Node (x *x, mapsqTree t1, mapsqTree t2) in sumTree (mapsqTree tree) end After fusion: let fun sumTree_mapsqTree \nt = case t of Empty => 0 | Node (x,t1,t2) => x*x + sumTree_mapsqTree t1 + sumTree_mapsqTree t2 in sumTree_mapsqTree \ntree end  5.2 Examples that cannot be fused As shown in the above, our fusion algorithm works on typical \nexamples, but of course it does not fuse all the fusable functions. We give two examples below to show \nthe limitation of our current fusion algorithm. Two successive applications of the same function. Our \nalgorithm does not fuse two successive applications of the same function like the following. let fun \nmapsq [] = [] | mapsq (x::xs) = x*x :: mapsq xs in mapsq (mapsq list) end This is because our fusion \nalgorithm performs inlining of each function only once. We .rstly inline the inner application of mapsq. \nThen we distribute the outer mapsq to the body of inner mapsq. After the distribution the fusion algorithm \ntries to inline the outer mapsq, but it fails since (the inner) mapsq has already been inlined. Mutually \nrecursive functions. Our current algorithm does not fuse mutually recursive func\u00adtions such as the following. \nlet fun f[] = [] |f(x::xs) = 2* x:: gxs and g[] = [] |g(x::xs) = 3* x:: fxs fun sum [] =0 | sum (x::xs) \n= x + sum xs in sum (f list) end This limitation is due to our simple strategy to treat a pair of functions \n(f,g) as a unit of fusion, and to inline each of the two functions only once during each fusion trial. \nWe believe it possible to re.ne this strategy to deal with mutual recursion. For example, if g is one \nof mutually recursive set of functions {g1,...,gn}, then one strategy is to try to fuse the set of pairs \n{(f,g1),...,(f,gn)} simultaneously, with the restriction that each function is inlined once for each \npair. We leave the re.nement to future work.  6. Implementation We have implemented the lightweight \nfusion algorithm given in Section 4. This section describes the overview of the implementa\u00adtion and discusses \nseveral issues we had to cope with when imple\u00admenting our algorithm. For the reader to test our implementation \nor to read the code, we have made the implementation (including the source code) avail\u00adable through the \nInternet for downloading at: http://www.pllab. riec.tohoku.ac.jp/software/fusion/index.html. 6.1 Implementation \nin a strict language The implementation is done by adding an inliner phase to a pro\u00adtotype compiler for \nSML# [20], which is an extension of Standard ML, an eager language having imperative features. The rationale \nof choosing the SML# compiler is our intention to investigate the feasibility of program fusion in a \nstrict and impure language in future. Although fusion has mainly been investigated and implemented in \nlazy languages such as Haskell, the principle of eliminating redundant intermediate data structure is \nof course equally important in strict and impure languages. The major prob\u00adlem in applying fusion to \nimperative languages is the preservation of the order of imperative effects. As we shall examine in details \nin 6.3, fusion transformation in general changes the order of evalua\u00adtion and thus its straightforward \napplication to functions with side effects is unsound. We expect that, with a proper control of interac\u00adtion \nbetween fusion and imperative features, fusion should become an important optimization for strict and \nimpure languages as well. We note that this situation is analogous to the relationship between fusion \nand non-strict functions in lazy languages. This issue is outside the scope of the present paper, and \nwe would like to investigate it elsewhere. Our current implementation does not properly deal with imperative \nfeatures. However, it is suf\u00ad.cient for the purpose of the present paper stated in the introduction section. \n 6.2 Implementing multiple argument fusion Our fusion algorithm works on functions with multiple arguments. \nWe have given the rules for curried and uncurried versions, and our method works on both versions. Among \nthem, we have only imple\u00admented the uncurried version since the SML# compiler performs uncurry optimization, \nwhich transforms multi-parameter functions in curried form into uncurried intermediate code. For example, \nthe map function is translated to the following term in the intermediate language. [ a, b. val rec map \n= (fn {f, x} => (case x of nil => nil { b} | :: y => :: { b}(f (#1 y), map {f, (#2 y)}) | _ => raise \nMatchCompBug))] where {f, x} represents the multiple parameters. Our fusion algo\u00adrithm for functions \nwith multiple parameters works on this form of terms.  6.3 Inlining bindings for function applications \nIn our implementation of the fusion algorithm, some special treat\u00adment of bindings is needed in addition \nto the usual inlining tech\u00adniques. For the fusion of two functions fand gto succeed, succes\u00adsive function \napplications f ( g ) should appear during the com\u00adputation of the (FixPromote) rule for fand g. Thisimpliesthata \nbinding of the form x= geneeds to be inlined during the fusion of fand gdespite the fact that geis not \na value. The strategy we have implemented is to inline the binding of the form x= geif the following \nconditions are met: (1) the inliner is processing the fusion for f. g,and (2) xoccurs in the context \nof fxso that the inlining this binding will induce the replacement of f.gwith f g. This means that successful \nfusion may change the order of evalua\u00adtion if there is some computation between the binding x= geand \nthe application fx. Let us describe this strategy and the related issues by tracing the fusion process \nfor a variant of sum mapsq example, where the function sum is replaced with the following. fun dsum []= \n0 | dsum (x::xs) = 2 * x + dsum xs The function mapsq is compiled to the following intermediate code. \nval rec mapsq = (fn x=> (case x of nil => nil |:: y=> bind x= #1 y inbind xs = #2 y in ::(*(x,x), mapsq \nxs) end end | _ => raise MatchCompBug)) Firstly, we create a new function name dsum_mapsq and then distribute \ndsum into the body of mapsq. In the following, we omit the raise expression. (fnx=> (case x of nil => \ndsum (nil) |::y=> bindx= #1 y in bind xs =#2 y in dsum (::(*(x,x), mapsq xs)) end end)) In the next \nstep, we apply the main function, FM[[ ]] , to the ob\u00adtained term. The case branches pi => ei are processed \none by one, from the top to the bottom. The .rst case is just inlining of dsum to the empty list, which \nresults in 0. Note that we allow inlining of recursive function once. In the next branch, we inline the \nbindings bind x= #1 y and bind xs= #2 y. At this point, the term be\u00adcomesasfollows. (fnx=> (case x of \nnil => 0 | :: y => dsum (::(*(#1 y, #1 y), mapsq (#2 y)))))  We inline the application of dsum to the \ncons list. When inlining a function applied to a term of some constructor, we make a binding for each \nargument of the constructor or put it in the inliner envi\u00adronment, depending on whether or not the argument \nis small and so on. In the usual inliner, the term at this point would become as follows. (fnx=> (case \nx of nil => 0 |:: y => bind z =*(#1 y, #1 y) in bind zs = mapsq (#2 y) in +(*(2,z), dsum zs) end end)) \n However, this does not make the successive application of dsum and mapsq. So, we allow all the function \napplications to be put into the inliner environment with the tag indicating that this should only be \ninlined when the inlining makes fusion succeed. In this case inlining zs makes the successive application, \nso we inline zs. (fnx=> (case x of nil => 0 |:: y => bind z =*(#1 y, #1 y) in +(*(2,z), dsum (mapsq (#2 \ny)) end)) Note that the evaluation order changes by the inlining of zs since a multiplication occurs \nimmediately after the squaring of the head el\u00adement. By replacing the successive applications of dsum \nand mapsq with dsum_mapsq, the evaluation order furthermore changes recur\u00adsively. (fnx=> (case x of nil \n=> 0 | :: y =>bind z=*(#1 y,#1 y) in +(*(2,z), dsum_mapsq (#2 y)) end)) This result is put into the \nfusion environment .. Our algorithm performs this sequence of steps. The following is the actual term \ngenerated by our compiler for the input term. val rec dsum_mapsq = (fn $8 => (case $8 of nil =>0 | ::$19 \n=> bind newVar = *(#1 $19, #1 $19) in +(*(2,newVar), dsum_mapsq (#2 $19)) end | _ => raise MatchCompBug)) \nNote that an application of a function to a raise expression can be reduced to the same raise expression \nwith its type appropriately changed. Let us remark a related issue concerning both strict and lazy languages. \nThe inlining of bindings for function applications may in general cause work duplication. In the above \nexample, if zs occurs more than once in the scope of the binding zs = mapsq (#2 y), work duplication \noccurs even if fusion transformation succeeds. This re.ects the fact that our fusion method is for general \nrecursive function de.nitions. There are various ways to cope with this situation under the trade off \nbetween the duplicated work and the effect of eliminating the production of data structures.  7. Benchmarks \nand Their Analysis As we have stated in the introduction section, the purpose of our implementation is \nto substantiate the following claims: Our lightweight fusion algorithm can be readily implementable \nin an inlining phase of an optimizing compiler.  It does not produce extra runtime overhead.  Our implementation \nand the performance results indeed verify these two points. Except for several special treatments described \nin the previous section, we were able to implement the algorithm in a compiler of a full scale language \nusing usual inlining techniques. As shown in Section 5, the resulting system can fuse various typical \nexamples discussed in the literature. To verify the second point, we tested several standard bench\u00admarks \nfor Standard ML. We measured execution time, heap usage, and code sizes with or without inlining and \nfusion transformation. In the measurement, we made all the other optimizations on, in\u00adcluding dead code \nelimination, uncurry optimization, constant fold\u00ading, and tail call optimization. Tables 4, 5, and 6 \nshow the bench\u00admark results. They show that our fusion transformation can be safely applied. When fusion \nhas failed, it just does usual inlining without produc\u00ading any runtime overhead. The heap usage and program \nsize are the same as the case that fusion is off and inlining is on, except for the vliw benchmark. In \nthe vliw benchmark, fusion occurs twice suc\u00adcessfully, although the elimination of intermediate data \nstructure does not affect the execution time so much. Heap usage and .le size increase a little bit in \nthe vliw benchmark when fusion option is on, since after fusing (f . g) to fg, the de.nitions of unused \nf or g may remain even after the dead code elimination. This is due to the limitation of our dead code \nelimination, which judges only direct death and does not check the transitive death. Looking at these \nbenchmark results in the perspective of the ef\u00adfectiveness of fusion method for general ML programs, \nthey would give a pessimistic impression that fusion would not be effective in practice. However, we \nshould note that the implementation and the Table 4. Execution time for benchmarks (in seconds) Benchmark \n- Inline Fusion F/I barneshut 21.0 16.7 16.7 100% boyer 1.4 1.3 1.3 100% coresml 89.6 88.6 88.4 100% \ncountgraphs 199.9 140.2 140.6 100% fft 24.7 16.1 16.1 100% knuthbendix 8.0 6.4 6.4 100% lexgen 19.0 13.2 \n13.3 101% life 2.5 2.6 2.6 100% logic 34.1 26.3 26.4 100% mandelbrot 13.7 12.3 12.3 100% mlyacc 2.6 2.3 \n2.4 100% nucleic 1.5 1.1 1.1 100% ray 16.7 14.2 14.2 100% simple 37.3 23.7 23.6 100% tsp 8.5 7.3 7.3 \n100% vliw 18.1 15.8 15.4 97%  Table 5. Heap allocation for benchmarks (in the number of .elds divided \nby one thousand) Benchmark - Inline Fusion F/I barneshut 102,515.4 94,234.4 94,234.4 100% boyer 7,138.9 \n6,874.5 6,874.5 100% coresml 0.3 0.3 0.3 100% countgraphs 1,077,263.9 976,271.8 976,271.8 100% fft 112,517.3 \n112,517.3 112,517.3 100% knuthbendix 53,258.9 42,736.9 42,736.9 100% lexgen 91,378.5 87,839.4 87,839.4 \n100% life 4,313.5 3,832.9 3,832.9 100% logic 180,964.5 119,571.6 119,571.6 100% mandelbrot 69,444.4 65,241.9 \n65,241.9 100% mlyacc 14,731.3 13,843.6 13,843.6 100% nucleic 11,818.8 3,885.4 3,885.4 100% ray 87,368.6 \n84,484.8 84,484.8 100% simple 172,191.6 130,210.3 130,210.3 100% tsp 30,313.4 19,851.9 19,851.9 100% \nvliw 112,342.8 99,979.7 99,980.4 100% Table 6. Code sizes for benchmarks (in kilo byte) Benchmark - \nInline Fusion F/I barneshut 205.4 231.7 231.7 100% boyer 227.0 227.2 227.2 100% coresml 1.7 1.5 1.5 100% \ncountgraphs 92.2 94.3 94.3 100% fft 36.6 37.7 37.7 100% knuthbendix 132.8 156.0 156.0 100% lexgen 243.3 \n295.6 295.6 100% life 51.3 62.6 62.6 100% logic 144.8 154.8 154.8 100% mandelbrot 8.4 8.3 8.3 100% mlyacc \n1436.8 1641.6 1641.6 100% nucleic 636.2 583.3 583.3 100% ray 95.6 104.4 104.4 100% simple 263.5 347.7 \n347.7 100% tsp 70.8 78.5 78.5 100% vliw 794.6 941.3 944.9 100% benchmarks reported in this section are \nquite preliminary; we per\u00adformed them only for verifying the above two points. In particular, we put \nalmost no effort to tune the fusion algorithm against the compiler and the language. As such, the preliminary \nresults should not be interpreted as a de.nite negative evidence of the effective\u00adness of our light weight \nfusion method for strict imperative lan\u00adguages. To analyze this issue, we have examined the fusion process \nof a few benchmarks and have identi.ed the following three problems that have prevented fusion from occurring \nin our current implemen\u00adtation. 1. Our current implementation only fuses functions if they appear in \na nested let expression. In particular, it cannot fuse any functions in different compilation units. \nSince functions in the basis library are always in different compilation units from that of the user \nprogram, they cannot be fused. 2. The current SML# compiler can only perform uncurrying op\u00adtimization \nfor locally de.ned functions. All the escaping func\u00adtions are in curried form. This minimizes the opportunities \nfor our multiple-parameter function fusion. 3. A function is often de.ned as a simple call to a locally \nde.ned recursive function. A typical case is a function that uses a tail recursive auxiliary function. \nSuch a locally de.ned auxiliary recursive function is not recognized as a candidate of fusion.  The \nfollowing code fragment in the simple benchmark illustrates the .rst two points. flatten (map (fn k => \n(map (fn l => f (k,l)) (from(lmin,lmax)))) (from (kmin,kmax))) The function map is de.ned in the basis \nlibrary and is in a curried form. The following code in the benchmark ray exhibits the third point. implode \n(map fromStr x) implode is de.ned in the basis library as follows. fun implode chars = let fun scan [] \naccum = accum | scan (char :: chars) accum = scan chars (accum ^ (Char_toString char)) in scan chars \n\"\" end This has a locally de.ned recursive function inside and the function implode itself is not a recursive \nfunction. The .rst problem can be solved by re.ning our environment management in such a way that the \nalgorithm maintains an envi\u00adronment that keeps the body of each recursive function beyond its compilation \nunit. The second point requires either to implement the fusion rules for curried multi-parameter fusions \nor to improve the uncurrying optimization so that it works for non local de.nitions. The third point \ncan be solved by inlining non-recursive (small) functions before fusion. Remedying these three points \nand implementing a practical fu\u00adsion algorithm are beyond the scope of the present paper. Instead, we \nhave hand-simulated the necessary extensions for the simple benchmark by manually changing the source \nprogram. The result shows that fusion succeeds .ve times and the execution time de\u00adcreases 5% compared \nwith the case where the other optimizations, including inlining, are on. From this preliminary analysis, \nwe ex\u00adpect that if we .ne tune our method against the compiler and the language, our light weight fusion \nmethod would show reasonable speed up over already optimized code.  8. Related Work In a general perspective, \nour fusion method can be regarded as a special case of the fold/unfold method of Burstall and Darlington \n[1]. A major problem of applying the general idea of fold/unfold transformation to automated program \noptimization is to control termination and to .nd a good strategy for folding (i.e. generating new recursive \nde.nitions). Due to this dif.culty, there does not seem to exist an automatic fusion method that directly \nfuses general recursive de.nitions. In the work of deforestation [23, 3], this problem was solved by \nrestricting the class of fusable expressions. However, the restric\u00adtion appears to be too strong for \nthis method to be imporporated in a practical compiler. In short-cut fusion approach [6] or its exten\u00adsions \n[7, 5], the problem was avoided by giving up fusing recursive de.nitions and instead developing a speci.c \nfusion laws for expres\u00adsions using foldr and build. Warm fusion [12] and transformation to hylomorphism \nforms [9] also avoid this problem by transform\u00ading general recursion to speci.c forms to which short-cut \nfusion laws can apply. As we mentioned in the introduction, its practical feasibility remains to be seen. \nOur method appears to be the .rst successful example that over\u00adcomes the dif.culty of generating new \nrecursive de.nition men\u00adtioned above and directly fuses general recursive de.nitions. The key insight \nof our approach is that a practical fusion system is ob\u00adtained by focusing on a speci.c fusion pattern \nof recursive function de.nition and that this process is expressed by a combination of syntactic transformation \nrules without requiring any heuristics. We share the motivation with the designers and developers of \noptimizing compilers with fusion transformation. One notable ex\u00adample is the GHC compiler s rules pragma \n[17], where the compiler is extended with a mechanism to specify general rewrite rules. This mechanism \nallows programmers, especially the designers of a basis library, to specify the short-cut fusion [6], \nits extension [7], array fusion [2], and many other useful optimizations for functions. Our system on \nthe other hand allows fully automated fusion for general recursive function de.nitions. There have been \nsome attempts to implement warm fusion, including a program transformation system Stratego [10] and an \nexperimental extension to the GHC compiler [15]. However, as reported in [15], there is some overhead \nproblem because of the introduction of lambda abstractions. In [16], the GHC compiler is extended with \nthe hylo fusion system [9]. Given that the underlying mechanism is more general than warm fusion [12] \nin the sense that it can deal with arbitrary data type, the benchmark results reported in [16] are quite \nencouraging. Considering the lack of a mechanism for functions with accumulating parameters such as tail \nrecursive functions, its practical feasibility remains to be investigated. Recent work by Katsumata and \nNishimura [11] have shown that short-cut fusion can be generalized to incorporate accumulating parameters \nusing algebraic properties of functions. This result can be used to extend automated fusion system such \nas the one [16] for wider range of recursive function de.nitions. But again, it remains to be seen whether \na practically feasible automated optimization step can be extracted from its involved mathematical development. \nCompared with those previous approaches, our method provides an alternative very light weight fusion \nmethod that can be incorpo\u00adrated to an optimizing compiler. 9. Conclusions and Future Work We have developed \na lightweight fusion method that automati\u00adcally fuses recursive function de.nitions. The method is based \non a new fusion process, called .xed point promotion, that transforms f . (fix g..x.E) to a new .xed \npoint term fix h..x.E. by pro\u00admoting the function f through the .xed point operator. We have shown that \nthis process is represented by the combination of two new transformation rules (AppDist) and (FixPromote) \nand have shown their soundness. We have then given a fusion algorithm by incorporating these rules in \nan inlining process. Since these rules are not sensitive to the types of functions being fused, our fusion \nmethod can be applicable to a wide range of functions including those with multi-parameters in both curried \nand uncurried form and also those that manipulate user-de.ned general data types. Since the two new laws \nare both simple and syntactic ones that only per\u00adform local transformation without requiring search or \nother heuris\u00adtics, our method can be readily incorporated to any standard in\u00adlining optimization. To \ndemonstrate the practical feasibility of our method, we have implemented our method in a compiler of \na full\u00adscale functional language, and have successfully tested various ex\u00adamples including those that \ncannot be dealt with in any existing real compiler. The performance result shows that our method does \nnot introduce runtime overhead for large scale benchmarks. This is our .rst step towards developing a \npractical lightweight fusion method, and a number of further issues remain to be investi\u00adgated. The most \nimportant one is the evaluation of the feasibility of our method through a serious implementation. As \nwe have noted, our current implementation is experimental and requires a num\u00adber of re.nements as discussed \nSection 7. Furthermore, our current implementation does not consider possible imperative effects and \ntherefore it may not be sound for programs with side effects. We plan to combine our fusion method with \na static effect system and include in our SML# compiler. Implementing our system in a lazy language such \nas GHC would also be a worthwhile future work. Another interesting direction of research is to investigate \nvari\u00adous formal properties of our fusion lows. We have shown the se\u00admantic soundness using denotational \nsemantics. One possible re\u00ad.nement wold be to adopt the idea of improvement theorem by David Sands [18] \nto our setting. Another important issue is the cor\u00adrectness in call-by-value semantics. Our correctness \ntheorem (The\u00adorem 2) depends on call-by-name semantics. A promising approach toward this direction would \nbe to use the axioms for recursion in call-by-value by Hasegawa and Kakutani [8].  Acknowledgments \nWe are grateful to Masahito Hasegawa for his comments on the possibility of proving the correctness of \nour fusion laws based on their axioms for recursion in call-by-value. We would like to thank anonymous \nreferees for many helpful suggestions and comments. Comments from Olaf Chitil, Philip Wadler, and Akimasa \nMorihata were useful in improving the paper. References [1] R. Burstall and J. Darlington. A transformation \nsystem for developing recursive programs. Journal of the ACM, 24(1):44 67, 1977. [2] M. Chakravarty and \nG. Keller. Functional array fusion. In Proc. ACM International Conference on Functional Programming,pages \n205 216, 2001. [3] W-N. Chin. Safe fusion on functional expression. In Proc. ACM Conference on Lisp and \nFunctional Programming, pages 11 20, 1992. [4] O. Chitil. Type inference builds a short cut to deforestation. \nIn Proc. ACM International Conference on Functional Programming,pages 249 260, 1999. [5] N. Ghani, P. \nJohann, T. Uustalu, and V. Vene. Monadic augment and generalised short cut fusion. In Proc. ACM International \nConference on Functional Programming, pages 294 305, 2005. [6] A. Gill, J. Launchbury, and S. Peyton \nJones. A short cut to deforestation. In Proc. International Conference on Functional Programming Languages \nand Computer Architecture, pages 223 232, 1993. [7] A. Gill. Cheap Deforestation for Non-strict Functional \nLanguages. Ph.D thesis, University of Glasgow, 1996. [8] M. Hasegawa and Y. Kakutani. Axioms for recursion \nin call-by-value. Higher-Order and Symbolic Computation, 15(2-3):235 264, 2002. [9] Z. Hu, H. Iwasaki, \nand M. Takeichi. Deriving structural hylomor\u00adphisms from recursive de.nitions. In Proc. ACM International \nConference on Functional Programming, pages 73 82, 1996. [10] P. Johann and E. Visser. Warm fusion in \nStratego: A case study in generation of program transformation systems. Annals of Mathematics and Arti.cial \nIntelligence, 29(1-4):1 34, 2000. [11] S. Katsumata and S. Nishimura. Algebraic fusion of functions \nwith an accumulating parameter and its improvement. In Proc. ACM International Conference on Functional \nProgramming, pages 227 238, 2006. [12] J. Launchbury and T. Sheard. Warm fusion: Deriving build-catas \nfrom recursive de.nitions. In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, \npages 314 323, 1995. [13] G. Malcolm. Homomorphism and promotability. In Proc. Mathemat\u00adics of Program \nConstruction, pages 335 347, 1989. [14] E. Meijer, M. Fokkinga, and R. Paterson. Functional programming \nwith bananas, lenses, envelopes and barbed wire. In Proc. Inter\u00adnational Conference on Functional Programming \nLanguages and Computer Architecture (FPCA 91), Lecture Notes in Computer Sci\u00adence 523, pages 124 144, \n1991. [15] L. Nemeth and S. Peyton Jones. A design for warm fusion. In Proc. International Workshop on \nImplementation of Functional Languages, pages 381 393, 1998. [16] Y. Onoue, Z. Hu, H. Iwasaki, and M. \nTakeichi. Veri.cation of practical effectiveness of program fusion (in Japanese). Computer Software, \n17(3):81 85, 2000. [17] S. Peyton Jones, A. Tolmach, and T. Hoare. Playing by the rules: rewriting as \na practical optimisation technique in GHC. In Proc. ACM Haskell workshop, 2001. [18] D. Sands. Proving \nthe correctness of recursion-based automatic program transformations. Theoretical Computer Science, 167(1\u00ad2):193 \n233, 1996. [19] T. Sheard and L. Fegaras. A fold for all seasons. In Proc. Functional Programming Languages \nand Computer Architecture, pages 233 242, 1993. [20] SML# home page. http://www.riec.tohoku.ac.jp/smlsharp/, \n2006. [21] J. Svenningsson. Shortcut fusion for accumulating parameters &#38; zip\u00adlike functions. In \nProc. ACM International Conference on Functional Programming, pages 124 132, 2002. [22] A. Takano and \nE. Meijer. Shortcut deforestation in calculational form. In Proc. ACM/IFIP Conference on Functional Programming \nLanguages and Computer Architecture, pages 306 313, 1995. [23] P. Wadler. Deforestation: transforming \nprograms to eliminate trees. Theoretical Computer Science, 73:231 248, 1990. Special issue of selected \npapers from 2 nd European Symposium on Programming.  \n\t\t\t", "proc_id": "1190216", "abstract": "This paper proposes a lightweight fusion method for general recursive function definitions. Compared with existing proposals, our method has several significant practical features: it works for general recursive functions on general algebraic data types; it does not produce extra runtime overhea (except for possible code size increase due to the success of fusion); and it is readily incorporated in standard inlining optimization. This is achieved by extending the ordinary inlining process with a new fusion law that transforms a term of the form <i>f</i> o (fix<i>g</i>&#955;x.<i>E</i>) to a new fixed point term fix<i>h</i>&#955;x.<i>E</i>&#8242; by promoting the function <i>f</i> through the fixed point operator. This is a sound syntactic transformation rule that is not sensitive to the types of <i>f</i> and <i>g</i>. This property makes our method applicable to wide range of functions including those with multi-parameters in both curried and uncurried forms. Although this method does not guarantee any form of completeness, it fuses typical examples discussed in the literature and others that involve accumulating parameters, either in the tt foldl-like specific forms or in general recursive forms, without any additional machinery. In order to substantiate our claim, we have implemented our method in a compiler. Although it is preliminary, it demonstrates practical feasibility of this method.", "authors": [{"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "Tohoku University", "person_id": "PP39061033", "email_address": "", "orcid_id": ""}, {"name": "Isao Sasano", "author_profile_id": "81100091875", "affiliation": "Tohoku University", "person_id": "PP31056633", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190241", "year": "2007", "article_id": "1190241", "conference": "POPL", "title": "Lightweight fusion by fixed point promotion", "url": "http://dl.acm.org/citation.cfm?id=1190241"}