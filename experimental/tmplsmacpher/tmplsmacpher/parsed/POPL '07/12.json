{"article_publication_date": "01-17-2007", "fulltext": "\n Types, Bytes, and Separation Logic Harvey Tuch Gerwin Klein Michael Norrish Sydney Research Lab., National \nICT Australia * , Canberra Research Lab., National ICT Australia, Australia Australia School of Computer \nScience and Engineering, UNSW, michael.norrish@nicta.com.au Sydney, Australia {harvey.tuch|gerwin.klein}@nicta.com.au \nAbstract We present a formal model of memory that both captures the low\u00adlevel features of C s pointers \nand memory, and that forms the basis for an expressive implementation of separation logic. At the low \nlevel, we do not commit common oversimpli.cations, but correctly deal with C s model of programming language \nvalues and the heap. At the level of separation logic, we are still able to reason abstractly and ef.ciently. \nWe implement this framework in the theorem prover Isabelle/HOL and demonstrate it on two case studies. \nWe show that the divide between detailed and abstract does not impose undue veri.cation overhead, and \nthat simple programs remain easy to verify. We also show that the framework is applicable to real, security-and \nsafety-critical code by formally verifying the memory allocator of the L4 microkernel. Categories and \nSubject Descriptors F.3.1 [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning \nabout Programs Mechanical veri.cation General Terms Languages, Theory, Veri.cation Keywords Separation \nLogic, C, Interactive Theorem Proving 1. Introduction Nearly All Binary Searches and Mergesorts are Broken. \nThis was the title of a short, widely read article by Joshua Bloch on Google s research blog [6]. Bloch \nhad discovered a problem in his imple\u00admentation of binary search in an array in the standard Java library. \nThe problem had remained unnoticed for nine years of widespread deployment in the Java platform, and \nBloch argues that it is in fact about 50 years old as it can be found in most standard text-books. What \nis remarkable about this error is that many of the text-book and lecture implementations have been formally \nproven correct. The problem is that the usual text-book view of state and values in programming language \nsemantics is an oversimpli.cation. The bug described by Bloch is a simple value over.ow that occurs in \n* National ICT Australia is funded through the Australian Government s Backing Australia s Ability initiative, \nin part through the Australian Re\u00adsearch Council. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; \n2007 ACM 1-59593-575-4/07/0001. . . $5.00. the computation of the average of two values: int mid = (low \n+ high) / 2. For suf.ciently large values of low and high this statement is wrong. One version that works \nfor all values is mid = low + ((high -low) / 2). Even in the light of industrially deployed programs \nfailing be\u00adcause of this error, one is tempted to say that they are not really wrong; that they work \nas long as int behaves like the integers of mathematics, and that people should not be using values that \nare too large. If the speci.cation of binary search did have this pre\u00adcondition explicitly stated, then \nthis view would be defensible. Of course it does not, because we would rather not think about the messy \nworld of .nite values, .nite memory, unsafe pointer oper\u00adations, pointer alignment, and other low level \nconstraints of real programming languages when we are focusing on the interesting parts of verifying \na program. This view is not just wishful thinking: it was, and in part still is, also widely believed \nthat dealing with all this detail in program veri.cation is intractable, and that it obscures the algorithmic \npart where errors are most likely. Nonetheless, it is our thesis and contribution that we can indeed \nverify real programs in real programming languages with their real semantics, and pro\u00advide the hard correctness \nguarantees of formal software veri.ca\u00adtion, without sacri.cing soundness and without drowning in detail. \nOur veri.cation methodology for programs in languages like C is to use Hoare logic together with an automated \nveri.cation con\u00addition generator. Additionally, for pointer programs, we would like to use separation \nlogic [16, 25], which promises to be an ef.cient and scalable method. However, existing implementations \nof sepa\u00adration logic [31, 18] use simpli.cations that while convenient are not directly suitable for \nC. For instance, they model the heap as a function from integers to integers, or treat values on the \nheap as atomic. In contrast, we model the values and heap of the C programming language in the theorem \nprover precisely. For over.ow problems we use the correct mathematical structure (e.g. .nite integers). \nFor pointers, correct models are more complex. C s view of memory is that of an array of bytes coupled \nwith various access restrictions. Further, pointers have to be aligned, dereferencing the null pointer \nis unde.ned, etc. Using such a model directly is intractable for verifying real programs. Our contribution \nis to reconcile this model with con\u00advenient, abstract notation and reasoning. Our framework supports \nboth, normal Hoare logic and a sound separation logic, by instanti\u00adating Schirmer s Hoare logic environment \n[27]. Schirmer provides a generic imperative language with operational semantics, Hoare logic, and generic \nstate in Isabelle/HOL. We instantiate this to C on the one side, and provide optional separation logic \nnotation for assertions on the other side. At the heart of our work stands the observation that although \nlanguages like C are not type-safe, and although many programs do not always use pointers in a type-safe \nFigure 1. The C veri.cation process. User-supplied components indicated with shading. way, the majority \nof pointer operations in any given program are well-behaved and can be treated in the abstract text-book \nway. In previous work [28], we showed that the low-level view of the heap as an array of bytes can be \nsoundly uni.ed with a view of multiple abstract heaps of abstract values. We provided an im\u00adplementation \nof this uni.ed memory model in Isabelle/HOL and applied it to the veri.cation of page tables in the L4 \nmicrokernel. In this paper, we extend this work by making it more concrete and more .rmly grounded in \nreality on the one side, and more abstract and better suited for high-level veri.cation on the other \nside: We harden our implementation so that it accurately re.ects the real semantics of a signi.cant, \nstrict subset of the C program\u00adming language. C programs as accepted by standard C com\u00adpilers can be \nread directly into the theorem prover. We also show how to add a number of low-level semantic restrictions \nlike pointer alignment and automatic NULL-dereference guards without incurring undue veri.cation overhead. \n We extend and generalise the memory model to support separa\u00adtion logic constructs, and we implement \na shallow embedding of separation logic with the frame rule on top of this model in Isabelle/HOL. This \nconstitutes the .rst sound implementation of separation logic for a mainstream programming language. \n We show two case studies in this setting: a simple list reversal, and a full formal veri.cation of \nthe L4 kernel memory allocator. We use the list reversal example to demonstrate the model and to show \nthat easy programs remain easy to verify. The memory allocator study shows the applicability of the model \nand veri.cation of real, security critical programs. It also gives an example of a program that cannot \nbe veri.ed formally in the traditional setting without losing soundness.  Finally, we use the two case \nstudies to evaluate separation logic against traditional Hoare logic. To our knowledge this is the .rst \nsuch evaluation of separation logic in one uni.ed setting.  Fig. 1 shows the process of verifying a \nC program in our set\u00adting. The user (the program veri.er) provides a normal C pro\u00adgram that contains \ninvariant and pre/post annotations in comments. Optionally, the user may also provide an Isabelle/HOL \nspeci.ca\u00adtion with de.nitions used in these annotations. Building on our model of memory, separation \nlogic, and the semantics of C, the pro\u00adgram is then translated into an imperative program in Isabelle/HOL. \nSchirmer s VCG generates the proof obligations. Proving these is where most of the user-work happens \nand the process will usually result in changes to the annotations and/or program until a proof is found. \nThe soundness of this setup depends on translating C pro\u00adgrams correctly to their Isabelle counterparts, \non the correctness of the memory model (both of which we present here), and on the VCG (which Schirmer \nhas proved sound in Isabelle [27]). Our work is motivated by a project to formally verify the func\u00adtional \ncorrectness of the L4 microkernel [17]. While we concen\u00adtrate on operating-system-level code and Isabelle/HOL \nin our case studies and implementation, we believe that this work is widely applicable. The basic technique \ngeneralises to other low-level lan\u00adguages and is orthogonal to developing an operational semantics for \nthe statements of the language. We concentrate on a precise model of state, values, and memory. The implementation \nin the theorem prover uses features speci.c to Isabelle (e.g. type classes) to opti\u00admise proof productivity, \nbut the model should be implementable in different provers like PVS using slightly different mechanisms. \n2. Notation Our meta-language Isabelle/HOL conforms largely to everyday mathematical notation. This section \nintroduces further non-stan\u00addard notation and in particular a few basic data types along with their primitive \noperations. The space of total functions is denoted by .. Type variables are written 'a, 'b, etc. The \nnotation t :: t means that HOL term t has HOL type t . The option type datatype 'a option = None | Some \n'a adjoins a new element None to a type 'a. We use 'a option to model partial functions, writing LaJ \ninstead of Some a and 'a -'b instead of 'a . 'b option. The Some constructor has an underspeci.ed inverse \ncalled the, satisfying the LxJ = x. Function update is '' written f (x := y) where f :: a . 'b, x :: \na and y :: 'b and f (x. y) stands for f (x := Some y).Weuse '{ .} for updating whole sets. Domain restriction \nis fiA where f ::a -'b and (f iA) x =(if x . A then fx else None). Finite integers are represented by \nthe type 'a word where 'a determines the word length. For succinctness, we use abbreviations like word8 \nand word32. The functions unat and of-nat convert to and from natural numbers (with u for unsigned). \nThe notation {w..+n} stands for the interval starting at the word w with n::nat elements, possibly wrapping \naround to zero. Hoare triples are written {|P|} c {|Q|} where P and Q are asser\u00adtions and c a program. \nIn assertions, we use the syntax \u00b4x to refer to the program variable x in the current state, while sx \nmeans x in state s. Program states can be bound in assertions by {|s. P|}. Isabelle supports axiomatic \ntype classes [32] similar to, but more restrictive than Haskell s. The notation 'a::ring restricts the \ntype variable 'a to those types that support the axioms of class ring. Type classes can be reasoned about \nabstractly, with recourse just to the de.ning axioms. Further, a type t can be shown to belong to a type \nclass given a proof that the class s axioms hold in t. All abstract consequences of the class s axioms \nthen follow for t. Isabelle theories can be augmented with LATEX text which may contain references to \nIsabelle theorems (by name see chapter 4 of [23]). We use this presentation mechanism to generate the \ntext for most of the de.nitions and all of the theorems in this paper, taking them directly from the \nIsabelle proofs. 3. Translation of C In our domain, C programs are happy to exploit C s low-level features. \nWe cannot pretend that we are verifying a pseudo-Pascal inti=0, a[2] = {0,0}; int f(void) { i++; return \ni; } /* will return either 0 or 1 */ int main(void) { a[i] = f(); return a[0]; } Figure 2. A non-deterministic \nC program with integer values of in.nite range. In this section, we brie.y describe the C dialect that \nwe require, and how our translation of this dialect handles many of C s low-level complications. A number \nof memory speci.c details are further discussed in Sect. 4. Syntactically, our C dialect is a C subset. \nWe must be able to pass implemented C source code to standard compilers (on whose correctness we implicitly \nrely), but we do also impose some syn\u00adtactic restrictions on developers. For example, we make some sim\u00adpli.cations \nthat have no deep semantic impact, such as requiring all struct declarations to occur at the top-level \nof a translation unit. Rather more signi.cantly, we prohibit side effects in almost all expressions. \nAssignments become statement-forms, and func\u00adtions that return values may be called only as the right-hand \nside of an assignment. Semantically, we make a number of assumptions about the na\u00adture of the environment \nin which our C code will be executing. These move the C we are verifying away from the standard s ideal \nof strict conformance. When writing applications, such assump\u00adtions are often a sign of programmer laziness, \nand a harbinger of pain when code is ported. At the systems level, these assump\u00adtions are unavoidable. \nWe categorise them using the standard s terms for describing varying (and illegal) program behaviours: \nimplementation-de.ned, unspeci.ed, and unde.ned. Implementation-de.ned behaviours are the easiest to \ntreat. These behaviours are those on which the standard places broad re\u00adstrictions, but where it also \nrequires that the implementation make a particular (and documented) choice of behaviour. For example, \nan implementation must choose the size of its character type (typically 8 bits), the size of other integral \ntypes in terms of bytes (int values are now typically four bytes), the en\u00addianness of integral types, \nhow negative numbers are represented (typically two s-complement), and how integer division behaves with \nnegative arguments. Most of the time, compilers choose to re.ect the decisions made by the underlying \nhardware architecture. As we know the nature of the architecture for which we are de\u00adveloping our code, \nwe add these decisions as extra assumptions to the veri.cation process. This does mean that the same \nsource\u00adcode does need to be veri.ed anew for each underlying architecture where it is to be deployed. \nDepending on the program this could amount to merely re-running the proof. Unspeci.ed behaviours occur \nwhen the standard permits an im\u00adplementation to vary its behaviour, but does not require any docu\u00admentation \nof this variation. Indeed, an implementation is not re\u00adquired to make a particular choice consistently. \nThis allows optimi\u00adsation to drive the choice of behaviour. The most signi.cant place where behaviour \nis unspeci.ed is in order of evaluation, of argu\u00adments to assignments, of arguments of binary operators \nsuch as + and /, and of arguments to function calls. Most C expressions that appear to induce different \nbehaviours because of this under-speci.cation are actually examples of unde\u00ad.ned or illegal behaviour. \nThis is because of the strong restrictions on the way in which programs are allowed to read and write \nmem\u00adory. Nonetheless, it is possible to write legal, non-deterministic C programs. One such appears in \nFig. 2. By making all expressions side-effect free, and making assign\u00adments and function calls statement \nforms, we eliminate a whole class of unde.ned behaviours. By further requiring that functions may only \nbe called in contexts where their return value is ignored, or where it is assigned to a single variable \n(which restriction the program in Fig. 2 violates), we ensure that all code must have only one possible \nbehaviour, unless we choose to work from deliber\u00adate underspeci.cations, as might happen with an implementation \nof malloc.1 For other unspeci.ed behaviours, such as the values of possi\u00adble padding bits in integer \nrepresentations, our knowledge of the underlying architecture means we know how the machine will be\u00adhave, \nand our veri.cation can exploit this. Unde.ned behaviours occur when a program attempts to do something \nillegal, such as dereferencing a null pointer, or doing an integer division by zero. It is part of the \ndevil s pact that program\u00admers make when they program in C that implementations are not required to trap \nsuch events. Instead, implementations are free to do anything at all, and again, there is no requirement \nthat their un\u00adde.ned behaviours be documented. This feature of C makes testing dif.cult, but when veri.cation \nis performed we can explicitly make sure that unde.ned behaviours can not occur. One approach to this \nveri.cation task is to use explicit guards. Guards are extra program annotations, similar to assertions \nusers can provide with the standard assert function. In order to be ver\u00adi.ed with respect to any speci.cation, \na program must have all of its guards shown to hold when they are encountered. For every pos\u00adsible unde.ned \nbehaviour, we generate guards that are suf.cient to ensure that the unde.ned behaviour cannot occur. \nIf done manu\u00adally, this process of annotating programs with guards might lead to guards being omitted, \nbut by generating guards mechanically we can ensure that all those we wish to treat are indeed generated. \nGuards that we include prevent division by zero, dereferencing the null pointer, and dereferencing an \nimproperly aligned pointer. One further guard is the test that all memory-writes are to allocated memory. \nWe use this guard to show a form of memory safety in Sect. 5.3 as a proof convenience but it may be omitted \nfrom the semantics when considering systems code at the veri.er s discre\u00adtion. A stricter semantics for \napplication veri.cation would require such a guard always. This .exibility in choosing our code s envi\u00adronment \nis another reason in favour of the guards-based approach: it is straightforward to enable different sorts \nof guards depending on circumstances. For example, in some kernel veri.cations, deref\u00aderencing the null \npointer might be a valid way of accessing the .rst element of the machine s exception vector. If this \nwas the case, the null pointer guard would need to be disabled. In this way, we can give de.nition to \na variety of behaviours that the standard leaves unde.ned. Our systems code will not be strictly conforming, \nbut in\u00addeed this line was crossed when our code relied on implementation\u00adde.ned aspects of the programming \nenvironment. Finally, generating guards is straightforward: as expressions are translated into the veri.cation \nenvironment, forms that may cause dif.culties are recorded. When the translation of the enclosing statement \nhas .nished, it can be preceded by the appropriate checks on the given expressions. Because of our syntactic \nrestrictions preventing side effects, the repeated evaluation (as guard, and in the original expression) \nof these sub-expressions is sure to be safe. Our aim is to make veri.cation part of the engineering process. \nCrucially, the engineering process does not produce source code in one phase and then stop, with veri.cation \ntaking over from imple\u00admentation. Rather, implementation continues at the same time. In 1 Our restriction \non the use of function calls may appear draconian. It for\u00adbids not only f(x) + g(y), but also x + f(y). \nTwo unexplored options are possible. We might annotate some function calls as side-effect free, and then \nallow these functions to be called within expressions. Alternatively, rather than have the programmer \ndo so by hand, we might compile such ex\u00adpressions into a linearised form that forced a particular order \nof evaluation. order to tie veri.cation effort to the source code that is veri.ed, we annotate source \ncode with Isabelle invariants and speci.cations. 4. A Uni.ed Memory Model for Pointers When verifying \nC programs that may break many of the com\u00admonly employed abstractions described in the introduction we \nface a dilemma. Since convenient simpli.cations must be discarded we require detailed and cumbersome \nlow-level models. This may in\u00adcrease the dif.culty of the veri.cation task, in particular when us\u00ading \nan interactive theorem prover, where this detail is exposed to the program veri.er. We take soundness \nto be non-negotiable, yet some abstraction is also required for tractability. In this and the next section \nwe focus on resolving this dif.culty for the C memory model. We describe both a low-level semantic model \nbased on .nite byte-addressable memory and connections to two high-level proof abstractions multiple \ntyped heaps and separation logic. The latter can safely be used when programs remain inside a type-safe \nfragment. Since most code remains in this fragment in practice, even in the systems domain, we gain soundness \nwhile alleviating the additional burden on the program veri.er in the common case. 4.1 Semantic model \nIt is common in language semantics to treat the heap or memory as a partial function int -lang-val, where \nint is the type of addresses and lang-val the type of all language values. While greatly simpli\u00adfying \nthe formalisation, this makes several assumptions that are not valid in our setting: Addresses range \nover an in.nite integer type. In C addresses are constrained by a .nite addressable memory, which affects \nthe semantics of pointer arithmetic and memory allocation, e.g. *(x+1) = y may in fact be a null pointer \ndereference.  Values representations are atomic. C language types have rep\u00adresentations spanning multiple \nlocations, and it is possible to have value updates at one location affect values in other cells. This \ncalls for a semantic model that both captures values stor\u00adage sizes, and re.ects these update semantics \naccurately. E.g. *x = 0xdeadbeef affects not only the byte at location x,but also the bytes at locations \nx+1, x+2, and x+3. An ad\u00additional complication is alignment: per-type restrictions on ad\u00address validity. \nFor example, 16-bit short values may be forced to be stored at even addresses. Expressing alignment conditions \nin dereferencing and update semantics requires having a con\u00adstant byte granularity for addressing.  \nHeap partiality. Heap partiality is often used in the heap deref\u00aderencing semantics in memory or type-safety \nchecks. Much weaker variants of these properties hold for C programs and it is not always necessary to \nintroduce them in the dereference semantics. This is particularly important in making it possible to \nverify low-level code that manages details such as the lay\u00adout of its own address space or implements \nthe functionality of malloc.  Earlier work [28] solved a similar problem, where the aim was to reconcile \nthe low-level C memory model and the abstraction of multiple typed heaps. We present that semantic model \nhere, to\u00adgether with a signi.cant extension of the heap abstraction. In partic\u00adular, we remove the well-formedness \ninvariant previously required, add general support for guards that protect against unde.ned be\u00adhaviours, \nand in Sect. 5 employ it as the basis of a separation logic embedding. In our model, heap memory state \nis described as a total function from addresses, represented by a wordn type corresponding to the machine \naddress type, to bytes, also a wordn type. Arithmetic operations on wordn values are modulo 2n . For \nexample, on a machine with 32-bit addresses and 8-bit bytes the heap memory state will be: addr = word32 \nbyte = word8 heap-mem = addr . byte Each language type is assigned a unique type in the theorem prover \ns logic. This allows for both an intuitive de.nition of lan\u00adguage operators as functions in HOL, and \nthe harnessing of the theorem prover s type inferencing mechanism to avoid unnecessary type annotations \nin assertions and proofs. All such types belong to an axiomatic type class ' a::c-type in Isabelle, which \nintroduces con\u00adstants that connect the low-level byte representation and the HOL values: to-bytes :: \n' a::c-type . byte list from-bytes :: byte list -' a::c-type typ-tag :: ' a::c-type itself . typ-tag \ntyp-info :: ' a::c-type itself . typ-info The functions to-bytes and from-bytes convert between Isabelle \nvalues and lists of bytes suitable for writing to or reading from the raw heap state. The function typ-tag \nassociates a unique type tag with each ' a::c-type, providing a means of treating language types as .rst-class \nvalues in HOL. Finally, typ-info provides enough structure to allow size and alignment information for \nthe type to be calculated. We can then use this to de.ne functions size-of :: ' a::c-type itself . nat \nand align-of :: ' a::c-type itself . nat respectively. The following conditions, captured in the axiomatic \ntype class ' a::mem-type, must hold for any ' a::c-type we want to use in our heap abstraction below: \nfrom-bytes (to-bytes v)= lvJ '' |to-bytes (x:: a)| = size-of TYPE( a) 0 < size-of TYPE( ' a) size-of \nTYPE( ' a) < addr-card ' align-of TYPE( a) dvd addr-card These conditions follow mostly from requirements \nin the C stan\u00addard, e.g. .xed size representations, with the exception of the .nal alignment constraint \nwhich we add to make pointer arithmetic bet\u00adter behaved, and which holds on all the C implementations \nwe are aware of. The constant addr-card represents the size of the address space, e.g. 232 . Finally, \nwe introduce a distinct Isabelle pointer type for each Isabelle type, used to model C pointer types: \ndatatype ' a ptr = Ptr addr The additional ' a on the left-hand side can now be used to associate the \npointer type information with pointer values in Isabelle s type system. Since the type variable does \nnot appear on the right-hand side it is a phantom type. Nonetheless, the type information is used to \nconstrain the action of various pointer operators by making use of the type tag information associated \nwith ' a. The destructor ptr-val retrieves the address from a pointer value. The pointer types ' a::c-type \nptr can be shown to be to be instances of ' a::mem-type. An example of the use of the phantom type variable \ncomes in the de.nition of pointer addition, adding a word n to a pointer p:: ' a ptr: ' p +p n = Ptr \n(ptr-val p + n * of-nat (size-of TYPE( a))) Another example of the utility of such polymorphic de.nitions \nis the pointer alignment guard from Sect. 3: ptr-aligned (p:: ' a ptr) = align-of TYPE( ' a) dvd unat \n(ptr-val p) size_of TYPE(int) heap_mem Figure 3. int heap representation In this work we deal primarily \nwith C s base and pointer types but it is possible to extend this to compound types. Array indexing, \naccess, and update semantics can be expressed in terms of the cor\u00adresponding pointer semantics. C s struct \ntypes can be translated to Isabelle record types, however the models in this paper require extending \nwhen .elds have their address taken2 or padding is in\u00advolved. Similarly, union types can be treated as \ndatatypes when a tag .eld can be identi.ed, and otherwise translated to type-casts. Low-level heap access \nand update Heap dereferences in expres\u00adsions, e.g. *p +1are given a semantics by .rst lifting the raw \nheap state with the polymorphic lift function, e.g. lift sp +1where s is the current state. The de.nition \nof lift is presented below, together with that of heap-update, providing semantics for heap updates. \nFor example, *p =*q +5is translated to the state transformer .s. heap-update p (lift sq +5)s. Fig. 3 \nillustrates the value transfor\u00admations involved. heap-list :: heap-mem . nat . addr . byte list heap-list \nh 0 p =[] heap-list h (Suc n) p = hp\u00b7heap-list hn (p +1) h-val :: heap-mem . ' a::c-type ptr . ' a ' \nh-val hp = from-bytes (heap-list h (size-of TYPE( a)) (ptr-val p)) '' lift :: heap-mem . a::c-type ptr \n. a lift h = .p. the (h-val hp) heap-update-list p [] h = h heap-update-list p (x\u00b7xs) h = heap-update-list \n(p +1) xs (h(p := x)) heap-update pvh = heap-update-list (ptr-val p)(to-bytes v) h 4.2 Typed heaps While \nit is possible to do proofs about programs directly with this semantics, it is rather complicated to \ndo so. Problems quickly arise when the potential for overlapping value representations on the heap and \naliasing between lifted typed heaps complicate heap up\u00addate post-conditions. This is an example of the \naliasing [8] prob\u00adlem inherent in pointer program proofs being further compounded by the low-level semantic \nmodel utilised. We call this represen\u00adtation overlap problem inter-type aliasing for the purpose of this \npaper; see Fig. 4 for an example of this. In this section we present an abstraction from our semantic \nmodel, together with appropriate 2 We also have not required supporting the &#38; operator for local \nvariables yet. These could be modelled explicitly in the heap-mem. Figure 4. Inter-type aliasing rewrite \nrules connecting the models, that avoids reasoning about this kind of aliasing when programs remain in \nthe type-safe frag\u00adment of C. In this type-safe fragment, a convenient model for a type-safe language \nwould be based on explicit multiple typed heaps, one for each language type, e.g. addr -char, addr -short. \nWhile this avoids the problem of inter-type aliasing and greatly simpli.es proofs, it does not allow \nus to escape the type-safe world. The lift function provides a view of multiple typed heaps, but values \nin a lifted ' a heap change when the heap is updated through a ' b ptr. However, inside the type-safe \nfragment, there is an implicit mapping between memory locations and types, and heap derefer\u00adences respect \nthis mapping. We introduce this mapping as an addi\u00adtional state component, and refer to it as the heap \ntype description. heap-typ-desc =addr -typ-tag option The heap type description is a history variable, \nand as such does not affect the semantics of our programs. Since in C this mapping cannot be extracted \nfrom the source code, the program veri.er adds proof annotations that update the heap type description. \nThe overhead of these annotations is very low relative to the proof effort because the intended type \nfor a region of memory changes infrequently mainly for alloc and free. The heap type description is partial, \nsince it only maps memory actually used by the program. Each value representation has the typ-tag corresponding \nto its type stored at the base address. The rest of the heap footprint of the value is also mapped, but \nwith a None value padding instead of a tag, making heap validity, as de.ned below, monotonic, a useful \nproperty in the development of the separation logic embedding. Without padding we would also have the \nadditional requirement of a well-formedness invariant [28] on the heap type description. We write d,g \n|= t p to mean that the pointer p is valid in heap type description d with guard g. The de.nition is \nstraightforward: valid-footprint dxtn = dx = lltJJ . (. y. y .{x +1..+n - 1}-. dy = lNoneJ) ' d,g |= \nt p = valid-footprint d (ptr-val p)(typ-tag TYPE( a)) (size-of TYPE( ' a)) . gp The guard g strengthens \nthe assertion to restrict validity based on the language s pointer dereferencing rules. For example, \nalignment heap_mem heap_typ_desc align_of TYPE(int) align_of TYPE(char)  align_of TYPE(char) size_of \nTYPE(int) align_of TYPE(char)  align_of TYPE(char)  align_of TYPE(int) align_of TYPE(char)  align_of \nTYPE(char)  size_of TYPE(char) align_of TYPE(char) align_of TYPE(char) size_of TYPE(int) align_of \nTYPE(int) align_of TYPE(char)  align_of TYPE(char)  align_of TYPE(char)  align_of TYPE(char)  Figure \n5. Example heap state can be captured with d,ptr-aligned |= t p. In the interests of conci\u00adsion, we occasionally \nomit g hereafter. An example heap memory and type description state is given in Fig. 5. Here htd,ptr-aligned \n|= t a and htd,ptr-aligned |= t c,but \u00ac htd,ptr-aligned |= t b and \u00ac htd,ptr-aligned |= t d. The pointer \nb::char ptr is not valid because the correct heap footprint is missing from the heap type description, \nand d::int ptr is not valid because it is not aligned. The ptr-tag function updates a heap type description \nso that it encompasses a pointer, i.e. gp =. ptr-tag pd,g |= t p: ptr-clear pnd =d({ptr-val p +1..+n \n-1}{ .}None) ptr-set ptd =d(ptr-val p .ltyp-tag tJ) ptr-tag (p:: ' a::c-type ptr) = '' ptr-set p TYPE( \na::c-type) .ptr-clear p (size-of TYPE( a::c-type)) Heap type description update annotations are written \nin C com\u00adments. The syntax AUXUPD takes a guard and a heap type de\u00adscription state transformer as a parameter. \nE.g. to indicate that the location at p now is the value of a valid pointer of type addr ptr,we write \n/** AUXUPD:(g, ptr-tag (\u00b4p::addr ptr)) */. The following two-stage lifting process provides an abstract \nheap view for proofs: 1. The .rst stage results in an intermediate heap-state: heap-state = addr -typ-tag \noption \u00d7 byte The function lift-state .lters out locations that are None in the heap type description, \nremoving values that should not affect the .nal lifted typed heaps. Equality between lifted heaps is \nthen modulo the heap type description domain. lift-state =.(h, d) x. case dx of None .None |ltJ.l(t, \nhx)J Lifted validity and heap-list are expressed on heap-states with d,g |= s p and heap-list-s respectively \nin the obvious way. 2. The second lifting stage results in typed lifted heaps again. The lift-typ-heap \nfunction restricts the heap domain so that the only values affecting the resultant heap are inside the \nheap footprint of valid pointer values. Equality is now modulo pointer validity. lift-typ-heap gs =(from-bytes \n.heap-list-s s (size-of TYPE( ' a)) . ptr-val)f{p |s,g |= s p} Note that it is not suf.cient to just \nrestrict the domain to addresses possessing the alignment of the lifted heap s type in order to avoid \noverlapping value representations, since the alignment of a type can be smaller than its footprint size: \nin our semantics the relationship between alignment and size is given by align-of t dvd size-of t. Figure \n6. Two-stage lifting The two stages, shown in Fig. 6, are combined with liftt : liftt g =lift-typ-heap \ng .lift-state Like lift, liftt is polymorphic and returns a heap abstraction of type ' a typ-heap = ' \naptr -' a. The program text itself can continue to use the functions lift and heap-update, while pre/post \nconditions and invariants use the stronger liftt to make more precise state\u00adments. The following conditional \nrewrite connects the two levels: liftt g (h, d) p = lvJ=.lift hp = v We have proved two further signi.cant \nrewrite rules that support reasoning about the effects of heap updates on liftt . The .rst rule states \nhow an ' a ptr update affects an ' a typ-heap, the second rule shows that an ' a ptr update does not \naffect a ' b typ-heap if ' a is different from 'b: d,g |= t p = .liftt g (heap-update pvh, d)= liftt \ng (h, d)(p.v) [[d,g ' |= t p; typ-tag TYPE( ' a)= typ-tag TYPE( 'b)]] =.liftt g (heap-update pvh, d)= \nliftt g (h, d) These, added to the default simpli.cation set with other heap\u00adrelated lemmas, do not require \nmanual application. The typ-tag TYPE( ' a)= typ-tag TYPE( ' b) condition can be resolved auto\u00admatically, \nas long as the type tag de.nitions for language types are also in the simpli.cation set. For any program \nthat respects the heap type description, we can thus automatically simplify away the fact that the heap \nis shared and pretend to work on multiple typed heaps. At the same time, we can still capture the semantics \nof type-unsafe operations. In the unsafe case, things are no longer automatic, and we require new rules \nto be proven in terms of the underlying lift and heap-update, as was previously required anyway. 5. Separation \nLogic The previous section presents a proof technique that tames inter\u00adtype aliasing. However, the problem \nof intra-type aliasing remains, where two valid same-typed pointers may have identical values. Dealing \nwith this often requires explicit anti-aliasing invariants on typed heaps, a problem that has been recognised \nin the litera\u00adture [8]. Separation logic [16, 25] provides an approach in which anti-aliasing information \nmay be expressed implicitly in assertions, potentially simplifying speci.cations and proofs. In this \nsection we present a development of separation logic based on the preceding memory model. 5.1 Shallow \nembedding Below we describe a shallow embedding for separation assertions, where the semantic constructs \nof assertions are translated to HOL, as opposed to a deep embedding where the syntax of assertions would \nbe considered a distinct type in the logic. There is a tradeoff involved in the choice of embedding approach \nshallow embed\u00addings are often more pragmatic and expressive, while deep embed\u00addings allow for language \nmetatheory reasoning and proof optimi\u00adsations [33]. We opt for the former since our focus here is on \nthe veri.cation task. We model separation assertions as predicates on heap-states, applied in assertions \nof the veri.cation environment to the result of the .rst lifting stage of Sect. 4.2. For example, a loop \ninvari\u00adant with the separation assertion P and heap memory and type description state in the variables \nh and d respectively is written {| P (lift-state (\u00b4h,\u00b4d)) |}, which we abbreviate as {|Psep|}. As in \nthe development of Reynolds we have an empty heap predicate: D =(.s. s = empty) The de.nition of the \nsingleton heap assertion is more involved in our embedding, and is provided below. p .g v asserts that \nthe heap contains exactly one mapping matching the guard g, at the location given by pointer p to value \nv. p .g v = .s. lift-typ-heap gsp = lvJ. dom s = {ptr-val p..+size-of TYPE( ' a)} The guard is an addition \nto the usual p . v and serves the same purpose as in Sect. 4.2, i.e. strengthening the assertion to aid \nin discharging guard proof obligations. There are two signi.cant separation connectives, conjunction \nand implication: s0 .s1 = dom s0 ndom s1 = \u00d8 s0 ++ s1 = .x. case s1 x of None .s0 x |lyJ.lyJ P .* Q = \n.s. .s0 s1. s0 .s1 .s = s1 ++ s0 .Ps0 .Qs1 ' P -.* Q = .s. .s . s .s ' .Ps ' -.Q (s ++ s ' ) The de.nitions \nare standard, with the intuition behind separation conjunction that (P . * Q) s asserts that s can be \npartitioned into two subheaps such that P holds on one subheap and Q on the other. This allows for predicates \non the heap to be written that conveniently include anti-aliasing information. Some additional mapping \nassertions are useful: sep-true = .s. True p .g - = .s. .v. (p .g v) s p g v = p .* sep-true .g v .p \n.g - = . .s. .x. (p g x) s The standard commutative, associative, and distributive properties apply to \nthe connectives, and we have formalised pure, intuitionis\u00adtic, domain, and strictly exact assertions \nand their properties [25]. We require a stronger de.nition of the singleton heap assertion for it to \nbe strictly exact. Some of these properties are routinely used in proofs and have been grouped in simpli.cation \nsets and/or added to the default simpli.cation set. Since this is a shallow embedding, standard HOL connectives \nand quanti.ers can be freely mixed with the separation connectives, e.g. .s. Ps . (Q . * R) s. A key \nfeature of this embedding is that it avoids the problem of skewed sharing [25]. This is essentially the \nproblem of inter\u00adtype aliasing in separation logic. An approach like ours, where a history variable is \nintroduced, was suggested as a future direction for separation logic by Reynolds. We have developed this, \nhave a machine-checked formalisation and have deployed it in real-world veri.cation examples (see Sect. \n6). Another notable gain from our development is the harnessing of Isabelle s type inference to avoid \nexplicit type annotations in assertions. Since language types are assigned Isabelle types and pointer \ntypes are derived from these, asserting that p . v, where p is a program variable automatically constrains \nthe type of v. 5.2 Lifting proof obligations Our veri.cation condition generator applies weakest precondition \nrules to transform Hoare triples to HOL goals that can then be solved by applying theorem prover tactics. \nIn Sect. 4.2, rewrites were given that could automatically lift the raw heap component of these proof \nobligations, and in this section we provide rules that allow the low-level applications of lift and heap-update \nto be expressed in terms of separation assertions. This is desirable as reasoning can then use the derived \nrules for these assertions at the separation logic level, whereas the alternative of unfolding the de.nitions \nproduces a massively more complex goal and proof. The approach taken here is quite different to the usual \nsepara\u00adtion Hoare logic proof technique employed in the literature, where a new Hoare logic is developed \nbased on separation logic and indi\u00advidual rules are applied at the Hoare logic level. The advantage of \nour approach is two-fold: we avoid having to manually apply Hoare rules, a task easily automated, and \ncan take advantage of an existing veri.cation framework and condition generator. On the other hand, applying \nthe rules in this section requires the program veri.er to understand the relationship between components \nof the HOL goals and the original program since this structure is lost during veri.ca\u00adtion condition \ngeneration. The following rule connects lift and separation mapping asser\u00adtions: (p '.g v)(lift-state \n(h, d)) lift hp = v An example of how this may be used is the Hoare triple {|(p . x .* Q)sep|}a = *p \n+ *p {|a =2 *x|}. The resulting proof obligation (p * Q)(lift-state (h, d)) =.2 *lift hp =2 *x . x .requires \nthe value of x in terms of lift hp or vice versa. By deriving from the assumption of the goal that (p \n'. x)(lift-state (h, d)) using normal rules of separation logic, the above rule can be applied to solve \nthe goal. Heap update dereferences produce proof goals of the form P (lift-state (h, d)) =. Q (lift-state \n(heap-update p0 v0 (heap-update p1 v1 (heap-update p\u00b7\u00b7\u00b7 v\u00b7\u00b7\u00b7 (heap-update pn vn h))),d)) To reduce heap-updates \nto a separation assertion on the original state we .rst require a new separation predicate g hs p: g \nCs p =.s. s,g |= s p .dom s = {ptr-val p..+size-of TYPE( ' a)} This is related to the idea of the singleton \nheap predicate p .g -, but the implication only works in one direction, (p .g v) s =. (g hs p) s, since \nit is possible to have both liftt sgp = None and a valid footprint at p. The following rules allow for \nthe reduction of heap-updates: (g hs p . * (p .g v -. * P)) (lift-state (h, d)) P (lift-state (heap-update \npvh, d)) (g hs p . * P)(lift-state (h, d)) (p .g v . * P)(lift-state (heap-update pvh, d)) These rules \nare analogous to the backwards and global reasoning Hoare logic mutation rules [25]. The .rst rule provides \na weakest precondition style rule that will match any separation assertion, while the second rule may \nbe used on goal assertions that can be manipulated into the matching form. When the heap type description \nis modi.ed with ptr-tag the resulting goal needs to be reduced in a similar manner. We provide a rule \nfor this that establishes separation validity from sep-cut, another additional separation predicate. \nsep-cut simply asserts that the locations in the heap-state domain are the supplied interval. sep-cut \nxy = .s. dom s = {x..+y} ' (sep-cut (ptr-val p)(size-of TYPE( a)) . * P)(lift-state (h, d)) gp (g Cs \np . * P)(lift-state (h, ptr-tag pd)) The shallow embedding gives us the .exibility to add separation \npredicates that express information about a region of memory at different levels of abstraction, from \np .g v to sep-cut. Once the above reduction rules are applied the reasoning can continue using the standard \nrules of separation logic without requiring additional proof goals or side-conditions. In deriving these \nrules we have primarily been concerned with soundness, which we are forced to show prior to Isabelle \nadmitting the rules. Our focus on real-world veri.cation examples has caused us to pay rather less attention \nto the completeness of our system, particularly as we know that we can always drop down to the lower \nmore concrete levels if required. However, completeness results have been explored elsewhere in the literature \n[16, 34]. 5.3 Frame rule The separation frame rule [34] is often seen as important to scal\u00adability. \nIt allows for deriving a global speci.cation from a local speci.cation of a program s behaviour, with \nan arbitrary conjoined separation assertion on a part of the heap preserved by the program. In our embedding, \nthis rule would have the form: {|Psep|} c {|Qsep |} sepsep {|(P . * R)|} c {|(Q . * R)|} Unfortunately, \nsuch a general rule cannot be expressed in a shallow embedding since (i) the state-space type is program \ndependent and (ii) c is an arbitrary program in the underlying veri.cation framework for which this rule \nmay not be true. It is however possible to prove this rule for speci.c programs and state-spaces, and \nin our development of the frame rule we automate and make generic this process for our C subset. We make \nfurther use of type classes to de.ne ' a::heap-state-typ, which provides access and update functions \nfor the heap state and heap type description. A concrete program s state-space is instanti\u00adated as a \nmember of this type class using automatic Isabelle/HOL tactics. The frame rule can then be expressed \non programs c with a state-space in ' a::heap-state-typ as: {|Psep|} c {|Qsep |} mem-safe c sepsep {|(P \n. * R)|} c {|(Q . * R)|} The mem-safe c assumption is required as the second problem arises from the \ndependence of this rule on a form of memory safety. In order to prove soundness it is helpful that a \nprogram generates a guard failure if it either (i) modi.es the heap state or heap type description outside \nof the initial domain of the heap type description or (ii) depends on the heap type description outside \nthis domain in any expression. This is not the case for the normal output of the C translation stage, \nsince guards are only generated to prevent unde.ned behaviour as our C semantics understands it. To show \nmem-safe c we insert additional guards for memory safety, e.g. for a heap update dereference asserting \nthat the lvalue s heap footprint is contained entirely in the heap type description s word_t reverse(word_t \n*i) { word_tj=0; while (i) { word_t *k = (word_t*)*i; *i=j; j = (word_t)i; i=k; } return j; } Figure \n7. In-place list reversal domain. It should be noted that we do not require type safety, nor do we require \nthis form of memory safety for most expressions as only heap type description updates may depend on the \nheap type description, i.e. the output of the C translation stage does not feature heap type description \naccesses except in such updates. With the generated guards in place, Isabelle discharges the mem-safe \nc proof obligation automatically. The additional mem\u00adory safety proof obligations obtained from the veri.cation \ncondi\u00adtion generator can be discharged with the aid of of a strengthened precondition asserting that \nthe required locations are a subset of the heap type description s domain. The above presentation of \nthe frame rule is somewhat simpli.ed in that P, Q and R are not functions of the local variable state. \nWe have also derived the more general rule where they are and R does not depend on variables modi.ed \nby c. 6. Case Studies This section presents two case studies that demonstrate the sup\u00adport of abstract \nand low-level reasoning in our setting. Since we have formalised both classical Burstall/Bornat-style \npointer rea\u00adsoning and separation logic in the same framework, we can give a meaningful comparison of \ntheir applicability. While our results support the folklore view that separation logic is well suited \nfor speci.cation, but less convenient for veri.cation, we .nd that the difference becomes smaller for \nthe larger, more realistic case study. Since proofs can be checked, but speci.cations need to be under\u00adstood, \nthis advocates the use of separation logic for more complex veri.cation tasks. 6.1 List reversal This \nsubsection shows a small example program in-place reversal of a list with simple, abstract reasoning. \nThe list is somewhat unusual in that it has no content but the pointer values themselves. Lists like \nthese are used in OS code for instance, where they are loosely part of larger data structures. Mehta \nand Nipkow [19] use the same example in their more abstract setting. We achieve the same style of reasoning \nand speci.cation with almost the same degree of automation. Fig. 7 shows the code (where word t is unsigned \nint). Even though the program is very simple, it already makes use of unsafe pointer operations. Classical \nsetting The pre/post speci.cation of this program in a classical setting (without separation logic) is: \n. zs. {|list (liftt H) zs \u00b4i|} \u00b4reverse-ret :== PROC reverse(\u00b4i) {|list (liftt H)(rev zs)(Ptr \u00b4reverse-ret)|} \nThe idiom \u00b4reverse-ret :== PROC reverse(\u00b4i) is the standard form for procedure speci.cation in Schirmer \ns environment. The variable reverse-ret is automatically generated and makes the return value of function \nreverse available to the postcondition. We write H =(\u00b4h, \u00b4d)for the heap and type description in the \ncurrent state. The predicate list relates the heap pointer structure to abstract lists. It takes a heap \nof word32values, a list of word32values, and the start pointer of the list as arguments. Our de.nition \nis analogous to the one in Mehta and Nipkow [19] (we additionally deal with heap partiality): list h \n[] i = i = NULL list h (x\u00b7xs) i = . j. ptr-val i = x . x =0 . hi = ljJ. list hxs (Ptr j) The loop invariant \nagain is almost the same as in Mehta and Nipkow. We use distinct to say that the list zs does not contain \nduplicate addresses and rev to reverse the abstract HOL list: {|. xs ys. list (liftt H) xs \u00b4i . list \n(liftt H) ys (Ptr \u00b4j) . rev zs = rev xs @ ys . distinct (rev zs)|} As mentioned above, the proof of the \n3 veri.cation conditions generated for this program is almost completely automatic (5 lines of proof \nscript). However, this has to be viewed in the context of a careful setup of automated simpli.cation \nrules for the abstrac\u00adtion predicate list that again we share with Mehta and Nipkow. It consists of 13 \nlemmas, 12 of which are proven automatically. All low-level guards were discharged automatically as well; \nthey did not play any role in the veri.cation of this example. Separation logic The speci.cation of the \nsame program in separation logic is sim\u00adilar on the pre/post level, but the abstraction predicate is \nde.ned differently. . zs. {|(list zs \u00b4i)sep|} \u00b4reverse-ret :== PROC reverse(\u00b4i) {|(list (rev zs)(Ptr \n\u00b4reverse-ret))sep|} list [] i = .s. i = NULL . D s list (x\u00b7xs) i = .s. i = Ptr x . x =0 . (. j. (i . \nj .* list xs (Ptr j)) s) The invariant is a bit shorter, because the separating conjunction takes care \nof distinctness: {|. xs ys. (list xs \u00b4i .* list ys (Ptr \u00b4j))sep . rev zs = rev xs @ ys|} The proof remains \neasy, but is not automatic any more and re\u00adquires some manual application of rules for separating conjunction. \nThis is not surprising, since separating conjunction is an existential statement which usually leads \nto manual intervention. The proof of the 3 veri.cation conditions comes to a total of 32 lines, which \nwe might be able to improve with specialised tactics for separation logic connectives. For example, one \nof the low-level guards was not solved automatically, because the required precondition was under a separating \nconjunction and had to be extracted manually. After this, the proof was automatic. In the separation \nlogic case, there was no speci.c automation setup for the list data structure apart from the lemma list \nxs NULL =(.s. xs =[]. . s)which brings the total proof effort for this example to 62 lines, as opposed \nto 89 lines in the classical setting. Most of these 89 lines could be reused for programs on the same \ndata structure, though, which is not the case for the separation logic proof. 6.2 The L4 kernel memory \nallocator The case study presented in this section concerns the veri.cation of the kernel memory allocator \nof the L4 microkernel with and without separation logic in Isabelle/HOL. At the OS kernel level, C library \nfunctions like malloc and free are not available yet, but have to be provided internally. Since this \ncode is run in the KMC kfree_list  Figure 8. Management data structure of the L4 chunk allocator privileged \nmode of the hardware, it is directly security critical. It is also the component that makes most critical \nuse of unsafe C operations (although other tricks like xor of pointers are used elsewhere in L4). Three \nfunctions de.ne the interface of this kernel memory allocator: void init(void *start, void *end) void \nfree(void *address, word t size), and void *alloc(word t size). We have veri.ed alloc and free, but only \nhave space to show alloc; init consists of a call to free. The full proof document for this case, including \ncode and invariants is available online [29]. The functions are not very large, but the fact that the \noriginals contain more than 50% tracing and debugging code indicates that they were not easy to get right. \nWe did not .nd any clear bugs in the code during veri.cation which is encouraging for a system with several \nyears of deployment. We did .nd two preconditions to free that are not immediately obvious: the address \nmust be word-aligned (because it is used as a word pointer), and the sum of the address and the size \nmust not over.ow. If free is only used with values produced by alloc, and init is used with values as \nin L4, these conditions will hold. Currently, L4 is distributed in C++, although no essential use of \nC++ features is made apart from using classes to structure the code. For a number of reasons (not only \nveri.cation), we are port\u00ading L4 to C. The source code that is veri.ed is taken from the L4Ka::Pistachio \ndistribution, ported, con.gured for the x86 archi\u00adtecture, and preprocessed. The manual porting is not \nsoundness critical as it is the result of the translation that will eventually run together with the \nrest of the C port, neither is the con.gure nor pre\u00adprocessing part. If they are merely deterministic, \nwe verify exactly what the compiler sees as input. Fig. 8 shows the internal data structure that is used \nto manage memory. It is a NULL terminated, singly linked list of chunks of memory of a .xed size KMC \n(1024 bytes in this case) starting with the global variable word t *kfree list. The .rst 4 bytes of each \nfree memory block are used to point to the next one. The blocks are often, but not always, adjacent in \nmemory. The implementation of alloc .rst searches for a contiguous block of memory of the right size \nthat is correctly aligned. It then removes this block from the free list, zeroes out the memory region, \nand returns a pointer to it. If no such block is found, the kernel has run out of memory and alloc returns \nNULL. Fig. 9 shows the input to the theorem prover with the invariant annotations removed and formatting \nadjusted for the presentation. Classical setting The data abstraction predicate is very similar to the \nsimple list of Sect. 6.1: k-list hse [] = s = e s = Ptr p . k-list hse (p\u00b7ps)= ' s = e . (. s . hs = \nls ' J. k-list h (Ptr s ' ) eps) For the speci.cation of alloc we .rst need to de.ne what this operation \ndoes in the abstract. For this, we are not interested in the list structure itself, but just in the set \nof free memory chunks: void * alloc(word_t size) { word_t* prev, curr, tmp; word_t i; size = size >= \n1024 ? size : 1024; for (prev = (word_t*) &#38;kfree_list, curr = kfree_list; curr; prev = curr, curr \n= (word_t*) *curr) { if (!((word_t) curr &#38; (size -1))) { tmp = (word_t*) *curr; for (i = 1; tmp \n&#38;&#38; (i < size / 1024); i++) { if ((word_t) tmp != ((word_t) curr + 1024*i)) { tmp =0; break; }; \ntmp = (word_t*) *tmp; } if (tmp) { *prev = (word_t) tmp; for (i = 0; i < (size / sizeof(word_t)); i++) \n{ /** AUXUPD: (ptr-safe (\u00b4curr +p \u00b4i) \u00b4d, ptr-tag (\u00b4curr +p \u00b4i) \u00b4d) */ curr[i] = 0; } return curr; } \n} } return 0; } Figure 9. alloc after con.gure and preprocessing. free-set hpseF = . ps. k-list hpseps \n. distinct ps . F = set ps alloc plF = F - chunks p (ptr-val p +(l - KMC)) The function chunks p q in \nthe de.nition above refers to a set of locations starting with pointer p, ending with address q, that \nconsists of adjacent memory chunks only. With this, the pre/post speci.cation of alloc is: . F s. {|s. \nfree-set (liftt H)(ptr-coerce kfree-list-addr) NULL F . aligned F . KMC |u \u00b4size|} \u00b4alloc-ret :== PROC \nalloc(\u00b4size) {|(\u00b4alloc-ret = NULL -. free-set (liftt H)(ptr-coerce kfree-list-addr) NULL (alloc \u00b4alloc-ret \n(max ssize KMC) F)) . (\u00b4alloc-ret = NULL -. H = sH)|} The precondition requires that kfree-list-addr \ndescribe some set of free memory chunks F and that all addresses in F as well as the requested size be \naligned with KMC. The post.x -addr refers to the fact that the code takes the address of the global variable \nkfree-list; kfree-list itself can be accessed by a heap lookup at kfree-list-addr. That means, kfree-list-addr \nis of type word32 ptr ptr. Since k-list expects a word32 ptr, we use the function ptr-coerce to cast \nit (as does the C code). Alignment is expressed using the non\u00adover.owing version of divisibility on .nite \nintegers with x |u y =(unat x dvd unat y) and aligned F =(. p.F. KMC |u p). The postcondition refers \nto the pre-state s for size and the heap. The aligned predicate could be made part of k-list.Wehave not \ndone so here, because free does not require this condition (although free preserves it if the base address \nis aligned with KMC). It is interesting to note that the code, while it tests the size alignment with \nan assertion (removed by the preprocessor here), does not check base address alignment. The postcondition \nhas two cases: either some memory was returned (\u00b4alloc-ret = NULL) or the kernel ran out of memory (\u00b4alloc-ret \n= NULL). In the latter case, we claim that nothing changes in the heap, including the global variable \nkfree-list.Inthe former case, we say that the new set of free memory chunks is the same that you would \nget by evaluating the abstract alloc. This speci.cation is not completely satisfying. In the success \ncase, we would ideally like to know that nothing else in the heap changes. This nothing else is hard \nto nail down formally. The set F as used in the speci.cation above is too loose, it would miss the heap \nchanges caused by zeroing out the freshly allocated memory. Separation logic will handle this more naturally \nbelow. The proof of the veri.cation conditions for alloc takes about 350 lines of proof script with 130 \nlines of speci.c supporting lemmas and a further 1400 lines of lemmas shared between and alloc and free \nin classical and separation logic setting. Separation logic The separation logic version of the abstraction \npredicate is the following. k-lists se [] = .h. s = e . D h .h. (s = Ptr p . s = e) . k-lists se (p\u00b7ps)= \n'' (. s . (block ss ' .* k-lists s eps) h) .h. KMC |u ptr-val s . ' block ss =(s . ptr-val s ' ) h . \nsep-cut (ptr-val s) KMC h fsets seF = .h. . ps. k-lists sepsh . F = set ps free-sets seF = .h. . x. (ptr-coerce \ns . ptr-val x .* fsets xeF) h The separation logic speci.cation of alloc is then: . F s. {|s. (free-sets \nkfree-list-addr NULL F)sep . KMC |u \u00b4size|} \u00b4sep-alloc-ret :== PROC sep-alloc(\u00b4size) {|(\u00b4sep-alloc-ret \n= NULL -. (free-sets kfree-list-addr NULL (alloc \u00b4sep-alloc-ret (max ssize KMC) F) .* zero \u00b4sep-alloc-ret \n(max ssize KMC))sep) . (\u00b4sep-alloc-ret = NULL -. (free-sets kfree-list-addr NULL F)sep)|} The precondition \nhere is simpler than in the classical setting. Since alignment is built into fsets using block, we only \nneed data abstraction and that the requested size is aligned to KMC. The postcondition has the same two \ncases that occur in the clas\u00adsical setting. If we have run out of memory (\u00b4alloc-ret = NULL), we now \nonly say that F does not change (and, by frame rule, noth\u00ading else in the heap changes either). In the \nsuccess case (\u00b4alloc-ret = NULL), we still state that the new set of free memory chunks is the same that \nyou would get by evaluating the abstract function alloc. Additionally, we now explicitly say that the \nmemory returned is a separate, contiguous block of the right size, .lled with zero. zero pn = zero-block \n(ptr-coerce p)(unat (n div 4)) zero-block p 0= D zero-block p (Suc n)=(p +p of-nat n) . 0 .* zero-block \npn This zero-block is the sub-formula that can directly be used by client code it describes the freshly \nallocated memory. The post\u00adcondition is stronger than the one in the classical case. The proof of the \nveri.cation conditions induced by this speci.\u00adcation takes about 650 lines of proof script with 750 lines \nof sup\u00adporting lemmas (plus the 1400 lines shared with the other parts of the veri.cation). This corresponds \nto 136 lines of code in the orig\u00adinal and 30 lines of code after con.gure and preprocessing. The effort \nfor the separation logic case was higher than in the classi\u00adcal setting, but not signi.cantly so, and \nwe have acquired a much stronger postcondition that was dif.cult to state before. In the sep\u00adaration \nlogic case, we see potential for improvement in automation. Much of the additional proof text was verbose, \nbut not hard. It should be noted that we chose alloc because it constitutes the worst possible case for \nthis framework: almost every pointer access is unsafe and needs to be reasoned about. In other frameworks \nthis is impossible or leads to unsoundness if applied na\u00a8ively, here it is merely more work than usual. \nOnce done, client code does not need to go to the same level of detail to use the pre/post conditions \nprovided. The complexity is hidden by the framework. 7. Related Work The directly relevant work in the \nliterature arises from efforts to verify properties of pointer programs. There are two directions that \nare taken Hoare logic oriented veri.cation in which partial/total correctness and completeness is the \nprimary goal, with decidability or the existence of an ef.cient algorithmic procedure considered less \nimportant, and the opposite approach that strives for automa\u00adtion, at the expense of only being able \nto cope with limited language fragments or properties, the domain of software model checking, shape analysis, \nand separation logic decision procedures. The idea to use separate heaps for separate pointer types and \nstructure .elds in Hoare logic goes back to Burstall [9]. On the ab\u00adstract level, our multiple typed \nheaps formalisation is most closely related to Bornat [8] and Mehta and Nipkow s [19] work in Is\u00adabelle, \nalthough we exploit Isabelle s type inference in a different way. We ground this abstract and ef.cient \nreasoning in a detailed C semantics that is directly applicable to concrete programs. Our use of HOL \ntypes is similar to that of Blume s [7] encoding of the C type system in ML that utilises phantom typing \nto express pointer types and operators for the purpose of a foreign-function interface. The Caduceus \ntool [12] supports Hoare logic veri.ca\u00adtion of C programs, including the type-safe part of pointer arith\u00admetic \nat this level. We increase the applicability of program veri.\u00adcation drastically by supporting the unsafe \npart as well. Separation logic [16, 25] has been mechanised in theorem proving systems previously [31, \n18]. Again, we provide soundness for program ver\u00adi.cation by grounding these abstract, idealised models \nin a concrete semantics. We are able to support abstract separation logic notation and unsafe, low-level \npointer manipulations at the same time. On the concrete level, Norrish [24] presents a very thorough \nand detailed memory model of C. Our formalisation has similarities to exploratory work on C++ in the \nVFiasco project [15]. The latter two provide a more precise machine model, while the abstractions of \nthe previous paragraph allow for more convenient and ef.cient reasoning. Our model provides a uni.ed \nview of both. The SLAM [2] and BLAST [14] software model checkers ap\u00adply predicate abstraction and counter-example \ndriven re.nement to check some safety properties of C programs automatically, such as correct API usage \nin device drivers. This is not as useful when veri\u00adfying fundamental system abstractions, such as memory \nallocation, that do not rely on other interfaces that can be factored out or that feature inductively \nde.ned data structures with complex invariants. It may be possible to tackle some of the guard proof \nobligations we encounter such as the absence of null pointer dereferences [5] with this technique, and \nefforts exist that seek to integrate software model checking with proof-based veri.cation [11]. Cook \net al [10] extend the automatic theorem prover in software model checkers to support the pointer operations \nand bit-level arithmetic described in this paper by translating C to propositional logic. Our translation \nis substantially different, taking advantage of HOL s expressiveness and type system, intended to better \nsupport interactive proof. Shape analysis [20, 26] and separation logic decision proce\u00addures [3] can \nshow some structural invariants, such as the absence of loops in linked lists. At this point in time \nthey tend to be spe\u00adcialised for limited language fragments or data structures that ei\u00adther do not meet \nour needs or do not provide suf.cient bene.t to offset the implementation effort, but there are promising \ndevelop\u00adments that may improve this situation [1]. The Hob [35] framework takes the re.nement view of \nveri.cation and allows some of these analyses to be used on independent modules or at higher-levels of \nabstraction, where when applied directly they may fail. Type-safe C variants like CCured [21] take a \ndual approach to memory type-safety, by statically detecting safe pointer usage and adding runtime checks \nfor those cases where this cannot be veri.ed. These variants have not gained popularity in real-world \nsystems implementations, due to a combination of runtime overheads and the restrictions imposed. Our \nlonger-term goal is a veri.ed kernel and earlier work on theorem proving based OS veri.cation includes \nPSOS [22] and UCLA Secure Unix [30]. A lack of mature mechanised theorem proving technology meant that \nwhile designs could be formalised, full implementation proofs were not achieved. Later, KIT [4], part \nof the CLI stack, describes veri.cation of process isolation proper\u00adties down to object code level, but \nfor an idealised kernel with far simpler and less general abstractions than modern microkernels. The \nVeriSoft project [13] is attempting to verify a whole system stack, including hardware, compiler, applications, \nand a simpli.ed microkernel called VAMOS that is inspired by, but not very close to, L4. Most closely \nrelated to our case study is the successful ver\u00adi.cation of the kernel memory allocator from the teaching-based \nTopsy operating system by Marti et al [18] in Coq. The major dif\u00adference is the heavy use of pointer \narithmetic and casting in L4 s memory allocator that we are able to handle con.dently and conve\u00adniently \ndue to our more detailed semantic model and type encoding. Marti et al model C memory as nat . int and \ntranslate the code manually into their tool. Although our model is more detailed, our proofs are signi.cantly \nshorter. 8. Future Work and Conclusion Apart from supporting more language features which is underway, \nwe see the main directions for future work as automation and in\u00adtegration. Combining automatic techniques \nsuch as decision proce\u00addures for separation logic and bit vector arithmetic with interactive proof, as \nexempli.ed by Hob [35], should lead to improved pro\u00adductivity and reusability without sacri.cing the \nrange of programs or properties we consider. We have presented a uni.ed, formal framework for the veri.\u00adcation \nof real C programs in an interactive proof assistant without oversimpli.cations or strong restrictions \non the language. Our work is a novel combination of concepts that so far have only been well understood \nin isolation: Hoare logic veri.cation, separation logic, interactive theorem proving, detailed dynamic \nand memory models for the C programming language, and low-level pointer operations. We have demonstrated \nwith two case studies that reasoning on both the abstract and the detailed level is well supported. Our \nresults indicate that while separation logic might not provide the amount of direct automation that we \nare used to, this difference becomes smaller for larger veri.cation examples. By grounding separation \nlogic in our memory model, we make veri.cation of systems level code practical: proof obligations relat\u00ading \nto issues such as inter-type aliasing disappear when the code to be veri.ed is working within type-safe \nbounds. When the source code is not so well-behaved, the framework allows veri.ers to drop to the lower \nlevel of multi-byte values and their encodings. This contrasts with methodologies that would reject such \nlow-level be\u00adhaviour as ill-formed, making veri.cation impossible. By importing C code directly into \nour veri.cation environment, and by tying our logical annotations to the C source, we keep a close connection \nbetween the veri.cation and development activ\u00adities. In particular, we aim to avoid the scenario where \nthe devel\u00adoping code loses its connection with the veri.cation. There is no point in verifying code that \nis not going to be deployed. We hope our still-nascent methodology, which has veri.ers and developers \ntouching the same source .les, will make the timely production of veri.ed software possible. Acknowledgements \nWe thank Kai Engelhardt, Carroll Morgan, Manuel Chakravarty, and Rob van Glabbeek for discussions and \nfor reading drafts of this paper. We are also grateful to David Tsai who started our work on the memory \nallocator. References [1] Beyond reachability: Shape abstraction in the presence of pointer arithmetic. \nIn 13th International Symposium on Static Analysis (SAS 2006), volume 4134 of Lecture Notes in Computer \nScience, pages 182 203. Springer, 2006. [2] T. Ball and S. K. Rajamani. Automatically validating temporal \nsafety properties of interfaces. In SPIN 01, Workshop on Model Checking of Software, volume 2057 of Lecture \nNotes in Computer Science, pages 103 122, 2001. [3] J. Berdine, C. Calcagno, and P. O Hearn. A decidable \nfragment of separation logic. In FSTTCS 2004: Foundations of Software Technology and Theoretical Computer \nScience, 24th International Conference, Chennai, India, December 16 18, 2004, 2004. [4] W. R. Bevier. \nKit: A study in operating system veri.cation. IEEE Transactions on Software Engineering, 15(11):1382 \n1396, 1989. [5] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar. Checking memory safety with Blast. \nIn Proceedings of the International Conference on Fundamental Approaches to Software Engineering (FASE), \nvolume 3442 of Lecture Notes in Computer Science, pages 2 18. Springer, 2005. [6] J. Bloch. Nearly all \nbinary searches and mergesorts are bro\u00adken. http://googleresearch.blogspot.com/2006/06/ extra-extra-read-all-about-it-nearly.html, \nJune 2006. [7] M. Blume. No-longer-foreign: Teaching an ML compiler to speak C natively . Electronic \nNotes in Theoretical Computer Science, 59(1), 2001. [8] R. Bornat. Proving pointer programs in Hoare \nLogic. In R. Backhouse and J. Oliveira, editors, Mathematics of Program Construction (MPC 2000), volume \n1837 of LNCS, pages 102 126. Springer, 2000. [9] R. Burstall. Some techniques for proving correctness \nof programs which alter data structures. In B. Meltzer and D. Michie, editors, Machine Intelligence 7, \npages 23 50. Edinburgh University Press, 1972. [10] B. Cook, D. Kroening, and N. Sharygina. Cogent: Accurate \ntheorem proving for program veri.cation. In K. Etessami and S. K. Rajamani, editors, Proceedings of CAV \n2005, volume 3576 of Lecture Notes in Computer Science, pages 296 300. Springer Verlag, 2005. [11] M. \nDaum, S. Maus, N. Schirmer, and M. N. Seghir. Integration of a software model checker into Isabelle. \nIn G. Sutcliffe and A. Voronkov, editors, Logic for Programming, Arti.cial Intelligence, and Reasoning: \n12th International Conference, LPAR 2005, volume 3835 of Lecture Notes in Arti.cial Intelligence, pages \n381 395, Montego Bay, Jamaica, October 2005. Springer. [12] J.-C. Filli atre and C. March\u00b4e. Multi-prover \nveri.cation of C programs. In Formal Methods and Software Engineering, 6th International Conference on \nFormal Engineering Methods, ICFEM 2004, Seattle, USA, volume 3308 of LNCS, pages 15 29. Springer, 2004. \n[13] M. Gargano, M. Hillebrand, D. Leinenbach, and W. Paul. On the cor\u00adrectness of operating system kernels. \nIn Proc. 18th International Con\u00adference on Theorem Proving in Higher Order Logics (TPHOLs 05), pages \n1 16, Oxford, UK, 2005. [14] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Software veri.cation \nwith Blast. In SPIN 03, Workshop on Model Checking Software, 2003. [15] M. Hohmuth, H. Tews, and S. G. \nStephens. Applying source-code veri.cation to a microkernel the VFiasco project. Technical Report TUD-FI02-03-M\u00a8arz, \nTU Dresden, 2002. [16] S. S. Ishtiaq and P. W. O Hearn. BI as an assertion language for mutable data \nstructures. In POPL 01: Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on Principles of programming \nlanguages, pages 14 26, New York, NY, USA, 2001. ACM Press. [17] L4Ka Team. L4 eXperimental Kernel Reference \nManual Version X.2. University of Karlsruhe, Oct. 2001. http://l4ka.org/projects/ version4/l4-x2.pdf. \n[18] N. Marti, R. Affeldt, and A. Yonezawa. Veri.cation of the heap manager of an operating system using \nseparation logic. In Third workshop on Semantics, Program Analysis, and Computing Environments For Memory \nManagement (SPACE 2006), pages 61 72, Jan. 2006. [19] F. Mehta and T. Nipkow. Proving pointer programs \nin higher-order logic. Information and Computation, 2005. To appear. [20] A. M\u00f8ller and M. I. Schwartzbach. \nThe pointer assertion logic engine. In Proc. ACM SIGPLAN Conference on Programming Language Design and \nImplementation, PLDI 01, June 2001. [21] G. Necula, J. Condit, M. Harren, S. McPeak, and W. Weimer. CCured: \ntype-safe retro.tting of legacy software. ACM Trans. Prog. Lang. Syst., 27(3):477 526, 2005. [22] P. \nG. Neumann, R. S. Boyer, R. J. Feiertag, K. N. Levitt, and L. Robinson. A provably secure operating system: \nThe system, its applications, and proofs. Technical Report CSL-116, SRI International, 1980. [23] T. \nNipkow, L. Paulson, and M. Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order Logic, volume 2283 \nof LNCS. Springer, 2002. [24] M. Norrish. C formalised in HOL. PhD thesis, Computer Laboratory, University \nof Cambridge, 1998. [25] J. C. Reynolds. Separation logic: A logic for shared mutable data structures. \nIn Proc. 17th IEEE Symposium on Logic in Computer Science, pages 55 74, 2002. [26] M. Sagiv, T. Reps, \nand R. Wilhelm. Parametric shape analysis via 3\u00advalued logic. In POPL 99: Proceedings of the 26th ACM \nSIGPLAN-SIGACT symposium on Principles of programming languages, pages 105 118. ACM Press, 1999. [27] \nN. Schirmer. Veri.cation of Sequential Imperative Programs in Isabelle/HOL. PhD thesis, Technische Universit\u00a8at \nM\u00a8unchen, 2006. [28] H. Tuch and G. Klein. A uni.ed memory model for pointers. In G. Sutcliffe and A. \nVoronkov, editors, 12th International Conference on Logic for Programming Arti.cial Intelligence and \nReasoning (LPAR-12), volume 3835 of LNCS, pages 474 488, 2005. [29] H. Tuch, G. Klein, and M. Norrish. \nVeri.cation of the L4 kernel memory allocator. Formal proof document. http://www.cse. unsw.edu.au/~kleing/papers/kmalloc.html, \nJuly 2006. [30] B. Walker, R. Kemmerer, and G. Popek. Speci.cation and veri.cation of the UCLA Unix security \nkernel. CACM, 23(2):118 131, 1980. [31] T. Weber. Towards mechanized program veri.cation with separation \nlogic. In J. Marcinkowski and A. Tarlecki, editors, Computer Science Logic 18th International Workshop, \nCSL 2004, volume 3210 of Lecture Notes in Computer Science, pages 250 264. Springer, 2004. [32] M. Wenzel. \nType classes and overloading in higher-order logic. In E. L. Gunter and A. Felty, editors, Theorem Proving \nin Higher Order Logics 97, volume 1275 of LNCS, pages 307 322. Springer, 1997. [33] M. Wildmoser and \nT. Nipkow. Certifying machine code safety: Shallow versus deep embedding. In K. Slind, A. Bunker, and \nG. Gopalakrishnan, editors, Theorem Proving in Higher Order Logics 2004, volume 3223 of LNCS, pages 305 \n320. Springer, 2004. [34] H. Yang and P. W. O Hearn. A semantic basis for local reasoning. In Foundations \nof Software Science and Computation Structure, pages 402 416, 2002. [35] K. Zee, P. Lam, V. Kuncak, and \nM. Rinard. Combining theorem proving with static analysis for data structure consistency. In Int. Workshop \non Software Veri.cation and Validation, 2004.   \n\t\t\t", "proc_id": "1190216", "abstract": "We present a formal model of memory that both captures the low-level features of C's pointers and memory, and that forms the basis for an expressive implementation of separation logic. At the low level, we do not commit common oversimplifications, but correctly deal with C's model of programming language values and the heap. At the level of separation logic, we are still able to reason abstractly and efficiently. We implement this framework in the theorem prover Isabelle/HOL and demonstrate it on two case studies. We show that the divide between detailed and abstract does not impose undue verification overhead, and that simple programs remain easy to verify. We also show that the framework is applicable to real, security- and safety-critical code by formally verifying the memory allocator of the L4 microkernel.", "authors": [{"name": "Harvey Tuch", "author_profile_id": "81363600892", "affiliation": "National ICT Australia, Australia and UNSW, Sydney, Australia", "person_id": "PP29032971", "email_address": "", "orcid_id": ""}, {"name": "Gerwin Klein", "author_profile_id": "81100142186", "affiliation": "National ICT Australia, Australia and UNSW, Sydney, Australia", "person_id": "PP39060571", "email_address": "", "orcid_id": ""}, {"name": "Michael Norrish", "author_profile_id": "81100614629", "affiliation": "National ICT Australia, Australia", "person_id": "PP24045687", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190234", "year": "2007", "article_id": "1190234", "conference": "POPL", "title": "Types, bytes, and separation logic", "url": "http://dl.acm.org/citation.cfm?id=1190234"}