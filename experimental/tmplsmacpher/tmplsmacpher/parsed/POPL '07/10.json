{"article_publication_date": "01-17-2007", "fulltext": "\n PADS/ML: A Functional Data Description Language Yitzhak Mandelbaum*, Kathleen Fisher , David Walker*, \nMary Fernandez , Artem Gleyzer* *Princeton University AT&#38;T Labs Research yitzhakm,dpw,agleyzer@CS.Princeton.EDU \nkfisher,mff@research.att.com Abstract Massive amounts of useful data are stored and processed in ad \nhoc formats for which common tools like parsers, printers, query en\u00adgines and format converters are not \nreadily available. In this paper, we explain the design and implementation of PADS/ML,a new lan\u00adguage \nand system that facilitates the generation of data processing tools for ad hoc formats. The PADS/ML design \nincludes features such as dependent, polymorphic and recursive datatypes, which al\u00adlow programmers to \ndescribe the syntax and semantics of ad hoc data in a concise, easy-to-read notation. The PADS/ML implemen\u00adtation \ncompiles these descriptions into ML structures and functors that include types for parsed data, functions \nfor parsing and print\u00ading, and auxiliary support for user-speci.ed, format-dependent and format-independent \ntool generation. Categories and Subject Descriptors D.3.2 [Language Classi.ca\u00adtions]: Applicative (functional) \nlanguages General Terms Languages Keywords Data description languages, domain-speci.c languages, functional \nprogramming, dependent types, ML, modules, parsing, printing  1. Introduction An ad hoc data format \nis any semi-structured data format for which parsing, querying, analysis, or transformation tools are \nnot read\u00adily available. Despite the existence of standard formats like XML, ad hoc data sources are ubiquitous, \narising in industries as diverse as .nance, health care, transportation, and telecommunications as well \nas in scienti.c domains, such as computational biology and physics. Figure 1 summarizes a variety of \nsuch formats, including ASCII, binary, and Cobol encodings, with both .xed and variable\u00adwidth records \narranged in linear sequences and in tree-shaped hi\u00aderarchies. Snippets of some of these data formats \nappear in Fig\u00adure 2. Note that even a single format can exhibit a great deal of syntactic variability. \nFor example, Figure 2(c) contains two records from a network-monitoring application. Each record has \na differ\u00adent number of .elds (delimited by | ) and individual .elds contain structured values (e.g., \nattribute-value pairs separated by = and delimited by ; ). Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. \nCopyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001. . . $5.00.  Name: Use Representation  Gene \nOntology (GO): Variable-width Gene Product Information ASCII records SDSS/Reglens Data: Floating point \nnumbers, Weak gravitational lensing analysis among others Web server logs (CLF): Fixed-column Measuring \nweb workloads ASCII records AT&#38;T Call detail data: Fixed-width Phone call fraud detection binary \nrecords AT&#38;T billing data: Cobol Monitoring billing process Newick: Fixed-width ASCII records Immune \nsystem response simulation in tree-shaped hierarchy OPRA: Mixed binary &#38; ASCII records Options-market \ntransactions with data-dependent unions Palm PDA: Mixed binary &#38; character Device synchronization \nwith data-dependent constraints Figure 1. Selected ad hoc data sources. Common characteristics of ad \nhoc data make it dif.cult to per\u00adform even basic data-processing tasks. To start, data analysts typ\u00adically \nhave little control over the format of the data; it arrives as is, and the analysts can only thank the \nsupplier, not request a more convenient format. The documentation accompanying ad hoc data is often incomplete, \ninaccurate, or missing entirely, which makes understanding the data format more dif.cult. Managing the \ner\u00adrors that frequently occur poses another challenge. Common er\u00adrors include undocumented .elds, corrupted \nor missing data, and multiple representations for missing values. Sources of errors in\u00adclude malfunctioning \nequipment, race conditions on log entry, the presence of non-standard values to indicate no data available, \nand human error when entering data. How to respond to errors is highly application-speci.c: Some need \nto halt processing and alert a human operator; others can repair errors by consulting auxil\u00adiary sources; \nstill others simply .lter out erroneous values. In some cases, erroneous data is more important than \nerror-free data; for example, it may signal where two systems are failing to communi\u00adcate. Unfortunately, \nwriting code that reliably handles both error\u00adfree and erroneous data is dif.cult and tedious. 1.1 PADS/ML \nPADS/ML is a domain-speci.c language designed to improve the productivity of data analysts, be they computational \nbiologists, physicists, network administrators, healthcare providers or .nan\u00adcial analysts. To use the \nsystem, analysts describe their data in the PADS/ML language, capturing both the physical format of the \ndata and any expected semantic constraints. In return for this invest\u00adment, analysts reap substantial \nrewards. First of all, the description serves as clear, compact, and formally-speci.ed documentation \nof the data s structure and properties. In addition, the PADS/ML com\u00adpiler can convert the description \ninto a suite of robust, end-to-end data processing tools and libraries specialized to the format. As \nthe 2:3004092508||5001|dns1=abc.com;dns2=xyz.com|c=slow link;w=lost packets|INTERNATIONAL 3:|3004097201|5074|dns1=bob.com;dns2=alice.com|src_addr=192.168.0.10; \n\\ dst_addr=192.168.23.10;start_time=1234567890;end_time=1234568000;cycle_time=17412|SPECIAL (a) Simpli.ed \nRegulus network-monitoring data. 0|1005022800 9153|9153|1|0|0|0|0||152268|LOC_6|0|FRDW1|DUO|LOC_CRTE|1001476800|LOC_OS_10|1001649601 \n9152|9151|1|9735551212|0||9085551212|07988|no_ii152272|EDTF_6|0|APRL1|DUO|10|1000295291 (b) Sirius data \nused to monitor billing in telecommunications industry. (((erHomoC:0.28006,erCaelC:0.22089):0.40998, \n(erHomoA:0.32304,(erpCaelC:0.58815,((erHomoB: \\ 0.5807,erCaelB:0.23569):0.03586,erCaelA: 0.38272):0.06516):0.03492):0.14265):0.63594, \n\\ (TRXHomo:0.65866,TRXSacch:0.38791):0.32147, TRXEcoli:0.57336) (c) Newick data used to study immune \nsystem responses. Figure 2. Snippets of a variety of ad hoc data formats. Each \\ denotes a newline we \ninserted to improve readability. analysts data sources evolve over time, they can simply update the high-level \ndescriptions and recompile to produce updated tools. The type structure of modern functional programming \nlan\u00adguages inspired the design of the PADS/ML language. Speci.cally, PADS/ML provides dependent, polymorphic \nrecursive datatypes, layered on top of a rich collection of base types, to specify the syntactic structure \nand semantic properties of data formats. To\u00adgether, these features enable analysts to write concise, \ncomplete, and reusable descriptions of their data. We describe the PADS/ML language using examples from \nseveral domains in Section 2. We have implemented PADS/ML by compiling descriptions into O CAML code. \nWe use a types as modules implementation strat\u00adegy in which each PADS/ML type becomes a module and each \nPADS/ML type constructor becomes a functor. We chose ML as the host language because we believe that \nfunctional languages lend themselves to data processing tasks more readily than imperative languages \nsuch as C or JAVA. In particular, constructs such as pat\u00adtern matching and higher-order functions make \nexpressing data transformations particularly convenient. Section 3 describes our types as modules strategy \nand shows how PADS/ML-generated modules together with functional O CAML code can concisely ex\u00adpress common \ndata-processing tasks such as .ltering errors and for\u00admat transformation. A key bene.t of our approach \nis the high return-on-investment that analysts can derive from describing their data in PADS/ML.In particular, \nPADS/ML makes it possible to produce automatically a collection of data analysis and processing tools \nfrom each descrip\u00adtion. As a start, the PADS/ML compiler generates from each descrip\u00adtion a parser and \na printer for the associated data source. The parser maps raw data into two data structures: a canonical \nrepresentation of the parsed data and a parse descriptor, a meta-data object detail\u00ading properties of \nthe corresponding data representation. Parse de\u00adscriptors provide applications with programmatic access \nto errors detected during parsing. The printer inverts the process, mapping internal data structures \nand their corresponding parse descriptors back into raw data. In addition to generating parsers and printers, \nour framework permits developers to add format-independent tools without modi\u00adfying the PADS/ML compiler \nby specifying tool generators.Such generators need only match a generic interface, speci.ed as an ML \nsignature. Correspondingly, for each PADS/ML description, the PADS/ML compiler generates a meta-tool \n(a functor) that takes a tool generator and specializes it for use with the particular descrip\u00adtion. \nSection 4 describes the tool framework and gives examples of three format-independent tools that we have \nimplemented: a data printer useful for description debugging, an accumulator that keeps track of error \ninformation for each type in a data source, and a for\u00admatter that maps data into XML. To de.ne the semantics \nof PADS/ML, we extended our earlier work on the Data Description Calculus (DDC) [3] to account for PADS/ML \ns polymorphic types. In the process, we simpli.ed the original presentation of the parser semantics substantially, \npartic\u00adularly for recursive types. In addition, we extended the theory to give a printing semantics. \nWe used this new semantics to guide the PADS/ML implementation of printing. We also proved a canoni\u00adcal \nforms theorem, which states that the generated parsers produce well-typed, well-behaved canonical results, \nand, conversely, that printers operate correctly on the appropriate canonical inputs. A full treatment \nof the extended calculus appears in Mandelbaum s Ph.D. thesis [4], while an overview of the calculus \nand printing se\u00admantics, as well as the associated metatheory, can be found in our companion technical \nreport [5]. PADS/ML has evolved from previous work on PADS/C 1 [2], but PADS/ML differs from PADS/C in \nthree signi.cant ways. First, it is targeted at the ML family of languages. Using ML as the host language \nsimpli.es many data processing tasks, such as .ltering and normalization, which bene.t from ML s pattern \nmatching con\u00adstructs and high level of abstraction. Second, unlike PADS/C types, PADS/ML types may be \nparameterized by other types, resulting in more concise and elegant descriptions through code reuse. \nML\u00adstyle datatypes and anonymous nested tuples also help improve readability by making descriptions more \ncompact. Third, PADS/ML provides signi.cantly better support for the development of new tool generators. \nIn particular, PADS/ML provides a generic inter\u00adface against which tool generators can be written. In \nPADS/C,the compiler itself generates all tools, and, therefore, developing a new tool generator requires \nunderstanding and modifying the compiler. Mandelbaum s Ph.D. thesis [4] contains a full discussion of \nrelated work. In summary, this research makes the following contributions: We have designed and implemented \nPADS/ML, a novel data\u00addescription language that includes dependent, polymorphic, re\u00adcursive datatypes. \nThis design allows data analysts to express the syntactic structure and semantic properties of data formats \nfrom numerous application domains in a concise, elegant, and easy-to-read notation.  Our PADS/ML implementation \nemploys an effective and general types as modules compilation strategy that produces robust parser and \nprinter functions as well as auxiliary support for user-speci.ed tool generation. Our implementation \nis available at http://www.padsproj.org/padsml/.  1 We henceforth call the original PADS language PADS/C. \n  2. Describing Data in PADS/ML A PADS/ML description speci.es the physical layout and semantic properties \nof an ad hoc data source. These descriptions are com\u00adposed of types: base types describe atomic data, \nwhile structured types describe compound data built from simpler pieces. Exam\u00adples of base types include \nASCII-encoded, 8-bit unsigned integers (Puint8) and 32-bit signed integers (Pint32), binary 32-bit in\u00adtegers \n(Pbint32), dates (Pdate), strings (Pstring), zip codes (Pzip), phone numbers (Pphone), and IP addresses \n(Pip). Se\u00admantic conditions for such base types include checking that the re\u00adsulting number .ts in the \nindicated space, i.e., 16-bits for Pint16. Base types may be parameterized by ML values. This mecha\u00adnism \nreduces the number of built-in base types and permits base types to depend on values in the parsed data. \nFor example, the base type Puint16_FW(3) speci.es an unsigned two byte in\u00adteger physically represented \nby exactly three characters, and the base type Pstring takes an argument indicating the terminator character, \ni.e., the character in the source that follows the string. To describe more complex data, PADS/ML provides \na collection of type constructors derived from the type structure of functional programming languages \nlike Haskell and ML. We explain these structured types in the following subsections using examples drawn \nfrom data sources we have encountered in practice. 2.1 Simple Structured Types The bread and butter of \na PADS/ML description are the simple struc\u00adtured types: tuples and records for specifying ordered data, \nlists for specifying homogeneous sequences of data, sum types for speci\u00adfying alternatives, and singletons \nfor specifying the occurrence of literal characters in the data. We describe each of these constructs \nas applied to the Sirius data presented in Figure 2(b). Sirius data summarizes orders for phone service \nplaced with AT&#38;T. Each Sirius data .le starts with a timestamp followed by one record per phone service \norder. Each order consists of a header and a sequence of events. The header has 13 pipe separated .elds: \nthe order number, AT&#38;T s internal order number, the order version, four different telephone numbers \nassociated with the order, the zip code of the order, a billing identi.er, the order type, a measure \nof the complexity of the order, an unused .eld, and the source of the order data. Many of these .elds \nare optional, in which case nothing appears between the pipe characters. The billing identi.er may not \nbe available at the time of processing, in which case the system generates a unique identi.er, and pre.xes \nthis value with the string no ii to indicate that the number was generated. The event sequence represents \nthe various states a service order goes through; it is represented as a newline-terminated, pipe-separated \nlist of state, timestamp pairs. There are over 400 distinct states that an order may go through during \nprovisioning. The sequence is sorted in order of increasing timestamps. Clearly English is a poor language \nfor describing data formats! Figure 3 contains the PADS/ML description for the Sirius data format. The \ndescription is a sequence of type de.nitions. Type de.nitions precede uses, therefore the description \nshould be read bottom up. The type Source describes a complete Sirius data .le and denotes an ordered \ntuple containing a Summary_header value followed by an Orders value. The type Orders uses the list type \nconstructor Plist to describe a homogenous sequence of values in a data source. The Plist constructor \ntakes three parameters: on the left, the type of elements in the list; on the right, a literal separator \nthat separates elements in the list and a literal terminator that marks the end of the list. In this \nexample, the type Orders is a list of Order elements, separated by a newline, and terminated by peof, \na special literal that describes the end-of-.le marker. Similarly, the Events type ptype Summary_header \n= \"0|\" * Ptimestamp * \\n pdatatype Dib_ramp = Ramp of Pint | GenRamp of \"no_ii\" * Pint ptype Order_header \n= { order_num : Pint; | ; att_order_num : [i:Pint | i < order_num]; | ; ord_version : Pint; | ; service_tn \n: Pphone Popt; | ; billing_tn : Pphone Popt; | ; nlp_service_tn : Pphone Popt; | ; nlp_billing_tn \n: Pphone Popt; | ; zip_code : Pzip Popt; | ; ramp : Dib_ramp; | ; order_sort : Pstring( | ); | ; \norder_details : Pint; | ; unused : Pstring( | ); | ; stream : Pstring( | ); | } ptype Event = Pstring( \n| ) * | * Ptimestamp ptype Events = Event Plist( | , \\n ) ptype Order = Order_header * Events ptype \nOrders = Order Plist( \\n , peof) ptype Source = Summary_header * Orders Figure 3. PADS/ML description \nfor Sirius provisioning data. denotes a sequence of Event values separated by vertical bars and terminated \nby a newline. String, character, and integer literals can be embedded in a description and are interpreted \nas singleton types. For example, the Event type is a string terminated by a vertical bar, followed by \na vertical bar, followed by a timestamp. The singleton type | means that the data source must contain \nthe character | at this point in the input stream. Correspondingly, the generated parser reads | and \nthe generated printer writes | . These literals do not appear in the generated data representations. \nThe type Order_header is a record type, i.e., a tuple type in which each .eld may have an associated \nname. The named .eld att_order_num illustrates two other features of PADS/ML: dependencies and constraints. \nHere, att_order_num depends on the previous .eld order_num and is constrained to be less than that value. \nIn practice, constraints may be complex, have multiple dependencies, and can specify, for example, the \nsorted order of records in a sequence. Constrained types have the form [x:T | e] where e is an arbitrary \npure boolean expression. Data satis.es this description if it satis.es T and e evaluates to true when \nthe parsed representation of the data is substituted for x.If the boolean expression evaluates to false, \nthe data contains a semantic error. The datatype Dib_ramp speci.es two alternatives for a data fragment: \neither one integer or the .xed string \"no_ii\" followed by one integer. The order of alternatives is signi.cant, \nthat is, the parser attempts to parse the .rst alternative and only if it fails, it at\u00adtempts to parse \nthe second alternative. This semantics differs from similar constructs in regular expressions and context-free \ngram\u00admars, which non-deterministically choose between alternatives. 2.2 Recursive Types PADS/ML can \ndescribe data sources with recursive structure. An example of such data is the Newick Standard format, \na .at repre\u00adsentation of trees used by biologists [6]. Example Newick Standard data provided by Steven \nKleinstein appears in Figure 2(c). The for\u00admat uses properly nested parentheses to specify a tree hierarchy. \nA leaf node is a string label followed by a colon and a number. An interior node contains a sequence \nof children nodes, delimited by parentheses, followed by a colon and a number. The numbers rep\u00adresent \nthe distance that separates a child node from its parent. In this example, the string labels are gene \nnames and the distances de\u00adnotes the number of mutations that occur in the antibody receptor genes of \nB lymphocytes. The following PADS/ML code describes this format: ptype Entry = {name: Pstring( : ); : \n; dist: Pfloat32} pdatatype Tree = Interior of ( * Tree Plist( ; , ) ) * ) | Leaf of Entry  2.3 Polymorphic \nTypes and Advanced Datatypes Polymorphic types enable more concise descriptions and allow pro\u00adgrammers \nto de.ne convenient libraries of reusable descriptions. The description in Figure 4 illustrates types \nparameterized by both types and values. It speci.es the format of alarm data recorded by a network-link \nmonitor used in the Regulus project at AT&#38;T. Fig\u00adure 2(a) contains corresponding example data. We \ndescribe the for\u00admat in tandem with describing its PADS/ML description. This data format has several \nvariants of name-value pairs. The PADS/C description of this format [5] must de.ne a different type for \neach variant. In contrast, the polymorphic types of PADS/ML al\u00adlow us to de.ne the type Pnvp, which takes \nboth type and value parameters to encode all the variants. As is customary in ML, type parameters appear \nto the left of the type name, while value param\u00adeters and their ML types appear to the right. The type \nPnvp has one type parameter named Alpha and one value parameter named p. Informally, Alpha Pnvp(p) is \na name-value pair where the value is described by Alpha and the name must satisfy the predi\u00adcate p. The \nNvp type reuses the Pnvp type to de.ne a name-value pair whose name must match the argument string name \nbut whose value can have any type. The Nvp_a type also uses the type Pnvp.It de.nes a name-value pair \nthat permits any name, but requires the value to have type SVString (a string terminated by a semicolon \nor vertical bar). Later in the description, the type parameter to Nvp is instantiated with IP addresses, \ntimestamps, and integers. The Regulus description also illustrates the use of switched datatypes. A switched \ndatatype selects a variant based on the value of a user-speci.ed O CAML expression, which typically ref\u00aderences \nparsed data from earlier in the data source. For example, the switched datatype Info chooses a variant \nbased on the value of its alarm_code parameter. More speci.cally, if the alarm code is 5074, the format \nspeci.cation given by the Details constructor will be used to parse the current data. Otherwise, the \nformat given by the Generic constructor will be used.  3. From PADS/ML to O CAML The PADS/ML compiler \ntakes descriptions and generates O CAML modules that can be used by any O CAML program. In this section, \nwe describe the generated modules and illustrate their use. 3.1 Types as Modules We use the O CAML module \nsystem to structure the libraries gen\u00aderated by the PADS/ML compiler. Each PADS/ML base type is im\u00adplemented \nas an O CAML module. For each PADS/ML type in a description, the PADS/ML compiler generates an O CAML \nmodule containing the types, functions, and nested modules that implement (* Pstring terminated by ; \nor | . *) ptype SVString = Pstring_SE(\"/;|\\\\|/\") (* Generic name value pair. Accepts predicate to validate \nname as argument. *) ptype (Alpha) Pnvp(p : string -> bool) = { name : [name : Pstring( = ) | p name]; \n= ; value : Alpha } (* Name value pair with name specified. *) ptype (Alpha) Nvp(name:string) = Alpha \nPnvp(fun s -> s = name) (* Name value pair with any name. *) ptype Nvp_a = SVString Pnvp(fun _ -> true) \n ptype Details = { source : Pip Nvp(\"src_addr\"); ; ; dest : Pip Nvp(\"dest_addr\"); ; ; start_time : Ptimestamp \nNvp(\"start_time\"); ; ; end_time : Ptimestamp Nvp(\"end_time\"); ; ; cycle_time : Puint32 Nvp(\"cycle_time\") \n} pdatatype Info(alarm_code : int) = match alarm_code with 5074 -> Details of Details | _ -> Generic \nof Nvp_a Plist( ; , | ) pdatatype Service = DOMESTIC of \"DOMESTIC\" | INTERNATIONAL of \"INTERNATIONAL\" \n| SPECIAL of \"SPECIAL\" ptype Alarm = { alarm :[i :Puint32|i=2ori= 3]; : ; start : Ptimestamp Popt; \n| ; clear : Ptimestamp Popt; | ; code : Puint32; | ; src_dns : SVString Nvp(\"dns1\"); ; ; dest_dns : SVString \nNvp(\"dns2\"); | ; info : Info(code); | ; service : Service } ptype Source = Alarm Plist( \\n ,peof) \nFigure 4. Description of Regulus data. the PADS/ML type. All the generated modules are grouped into one \nmodule that implements the complete description. For example, a PADS/ML description named sirius.pml, \nwhich contains three named types, will result in the O CAML .le sirius.ml de.ning the module Sirius, \nwhich will contain three submodules, each corresponding to one named type. Namespace management alone \nis suf.cient motivation to em\u00adploy a types as modules approach, but the power of the ML mod\u00adule system \nprovides substantially more. We implement polymor\u00adphic PADS/ML types as functors from (type) modules \nto (type) mod\u00adules. Ideally, we would like to map recursive PADS/ML types into recursive modules. Unfortunately, \nthis approach currently is not possible, because O CAML prohibits the use of functors within re\u00adcursive \nmodules, and the output of the PADS/ML compiler includes a functor for each type. Instead, we implement \nrecursive types as modules containing recursive datatypes and functions. As there is no theoretical reason \nto prevent recursive modules from containing functors [1], we pose our system as a challenge to implementers \nof module systems. The module generated for any monomorphic PADS/ML type matches the signature S: module \ntype S= sig type rep type pd_body type pd = Pads.pd_header * pd_body val parse : Pads.handle -> rep \n* pd val print : rep -> pd -> Pads.handle -> unit (* Functor for tool generator ... *) module Traverse \n... end The representation (rep) type describes the in-memory representa\u00adtion of parsed data, while \nthe parse-descriptor (pd) type describes meta-data collected during parsing. The parsing function converts \nthe raw data into an in-memory representation and parse descrip\u00adtor for the representation. The printing \nfunction performs the re\u00adverse operation. The module also contains a generic tool genera\u00adtor implemented \nas a functor; we defer a description of this func\u00adtor to Section 4. The module Pads contains the built-in \ntypes and functions that occur in base-type and generated modules. The type Pads.pd_header is the type \nof all parse-descriptor head\u00aders and Pads.handle is an abstract type containing the private data structures \nPADS/ML uses to manage data sources. The structure of the representation and parse-descriptor types resembles \nthe structure of the corresponding PADS/ML type, mak\u00ading it easy to see the correspondence between parsed \ndata, its inter\u00adnal representation, and the corresponding meta-data. For example, given the PADS/ML type \nPair describing a character and integer separated by a vertical bar: ptype Pair = Pchar * | * Pint the \ncompiler generates a module with the signature: module type Pair_sig = sig type rep = Pchar.rep * Pint.rep \n type pd_body = Pchar.pd * Pint.pd type pd = Pads.pd_header * pd_body val parse : Pads.handle -> rep \n* pd val print : rep -> pd -> Pads.handle -> unit ... end The parse-descriptor header reports on \nthe parsing process that pro\u00adduced the corresponding representation. It includes the location of the \ndata in the source, an error code describing the .rst error en\u00adcountered, and the number of subcomponents \nwith errors. The body contains the parse descriptors for subcomponents. Parse descriptors for base types \nhave a body of type unit. The signature for a polymorphic PADS/ML type uses the signa\u00adture S for monomorphic \ntypes, de.ned above. Given the polymor\u00adphic PADS/ML type ABPair: ptype (Alpha,Beta) ABPair = Alpha * \n| * Beta the compiler generates a module with the signature: module type ABPair_sig (Alpha : S) (Beta \n: S) = sig type rep = Alpha.rep * Beta.rep type pd_body = Alpha.pd * Beta.pd type pd = Pads.pd_header \n* pd_body val parse : Pads.handle -> rep * pd val print : rep -> pd -> Pads.handle -> unit ... end \n  3.2 Using the Generated Libraries Common data management tasks like .ltering and normalization are \neasy to express in O CAML. In the remainder of this section, we illustrate this point by giving O CAML \nprograms to compute properties of ad hoc data, to .lter it, and to transform it. 3.2.1 Example: Computing \nProperties Given the PADS/ML type: open Pads  let classify_order order (pd_hdr, pd_body) (good, bad)= \nmatch pd_hdr with {error_code = Good} -> (order::good, bad) | _ -> (good, order::bad) let split_orders \norders (orders_pd_hdr,order_pds) = List.fold_right2 classify_order orders order_pds ([],[]) let ((header, \norders),(header_pd, orders_pd)) = parse_source Sirius.parse \"input.txt\" let (good,bad) = split_orders \norders orders_pd Figure 5. Error .ltering of Sirius data ptype IntTriple = Pint * | * Pint * | * Pint \n the following O CAML expression computes the average of the three integers in the .le input.data: let \n((i1,i2,i3), (pd_hdr, pd_body)) = Pads.parse_source IntTriple.parse \"input.data\" in match pd_hdr with \n{error_code = Pads.Good} -> (i1 + i2 + i3)/3 |_-> raise Pads.Bad_file The parse_source function takes \na parsing function and a .le name, applies the parsing function to the data in the speci.ed .le, and \nreturns the resulting representation and parse descriptor. To ensure the data is valid, the program examines \nthe error code in the parse-descriptor header. The error code Good indicates that the data is syntactically \nand semantically valid. Other error codes in\u00adclude Nest, indicating an error in a subcomponent, Syn, \nindicat\u00ading that a syntactic error occurred during parsing, and Sem, indi\u00adcating that the data violates \na semantic constraint. The expression above raises an exception if it encounters any of these error codes. \nChecking the top-level parse descriptor for errors is suf.cient to guarantee that there are no errors \nin any of the subcomponents. This property holds for all representations and corresponding parse descriptors. \nThis design supports a pay-as-you-go approach to error handling. The parse descriptor for valid data \nneed only be consulted once, no matter the size of the corresponding data. User code only needs to traverse \nnested parse descriptors if information about an error is required.  3.2.2 Example: Filtering Data analysts \noften need to clean their data (i.e., remove or repair data containing errors) before loading the data \ninto a database or other application. O CAML s pattern matching and higher-order functions can simplify \nthese tasks. For example, the expression in Figure 5 partitions Sirius data into valid orders and invalid \norders. 3.2.3 Example: Transformation Once a data source has been parsed and cleaned, a common task \nis to transform the data into formats required by other tools, like a relational database or a statistical \nanalysis package. Transfor\u00admations include removing extraneous literals, inserting delimiters, dropping \nor reordering .elds, and normalizing the values of .elds (e.g., converting all times into a speci.ed \ntime zone). Because rela\u00adtional databases typically cannot store unions directly, one common transformation \nis to convert data with variants (i.e., datatypes) into a form that such systems can handle. One option \nis to partition or shred the data into several relational tables, one for each variant. A second option \nis to create an universal table, with one column for each .eld in any variant. If a given .eld does not \noccur in a particular variant, its value is marked as missing. Figure 6 shows a partial listing of RegulusNormal.pml, \na normalized version of the Regulus description from Section 2. ... ptype Header = { alarm : [ a : Puint32 \n| a = 2 or a = 3]; : ; start : Ptimestamp Popt; | ; clear : Ptimestamp Popt; | ; code : Puint32; | ; \nsrc_dns : Nvp(\"dns1\"); ; ; dest_dns : Nvp(\"dns2\"); | ; service : Service } ptype D_alarm = { header \n: Header; | ; info : Details } ptype G_alarm = { header : Header; | ; info : Nvp_a Plist( ; , | ) } \n Figure 6. Listing of RegulusNormal.pml, a normalized for\u00admat for Regulus data. All named types not explicitly \nincluded in this .gure are unchanged from the original Regulus description. open Regulus open RegulusNormal \nmodule A = Alarm module DA = D_alarm module GA = G_alarm module Header = H type ( a, b) Sum = Left of \na | Right of b let split_alarm ra = let h= {H.alarm=ra.A.alarm; H.start=ra.A.start; H.clear=ra.A.clear; \nH.code=ra.A.code; H.src_dns=ra.A.src_dns; H.dest_dns=ra.A.dest_dns; H.service=ra.A.service} in match \nra with {info=Details(d)} -> Left {DA.header = h; DA.info = d} | {info=Generic(g)} -> Right {GA.header \n= h; GA.info = g} let split_alarm_pd pd = ... (* mirrors split_alarm *) let process_alarm pads [pads_D; \npads_G] = let a,a_pd = Alarm.parse pads in match (split_alarm a, split_alarm_pd a_pd) with (Left da, \nLeft da_p) -> DA.print da da_p pads_D |(Right ga, Right ga_p) -> GA.print ga ga_p pads_G | _ -> ... (* \nBug! *) let _ = process_source process_alarm \"input.data\" [\"d_out.data\";\"g_out.data\"] Figure 7. Shredding \nRegulus data based on the info .eld. In this shredded version, Alarm has been split into two top-level \ntypes D_alarm and G_alarm. The type D_alarm contains all the information concerning alarms with the detailed \npayload, while G_alarm contains the information for generic payloads. In the original description, the \ninfo .eld identi.ed the type of its pay\u00adload. In the shredded version, the two different types of records \nap\u00adpear in two different data .les. Since neither of these formats con\u00adtains a union, they can be easily \nloaded into a relational database. The code fragment in Figure 7 shreds Regulus data in the for\u00admat described \nby Regulus.pml into the formats described in RegulusNormal.pml.It uses the info .eld of Alarm records \nto partition the data. Notice that the code invokes the print func\u00adtions generated for the G_alarm and \nD_alarm types to output the shredded data.   4. The Generic Tool Framework An essential bene.t of PADS/ML \nis that it can provide users with a high return-on-investment for describing their data. While the generated \nparser and printer alone are enough to justify the user s effort, we aim to increase the return by enabling \nusers to easily construct data analysis tools. To this end, we provide a simple framework for others \nto develop format-independent tools. The techniques of type-directed programming, known variously as \ngeneric or polytypic programming, provide a convenient concep\u00adtual starting point in designing a tool \nframework. In essence, any format-independent tool is a function from a description to a con\u00adcrete realization \nof that tool. As PADS/ML descriptions are (depen\u00addent) types, a format-independent tool is a type-directed \nfunction. Some modern functional programming languages, Generic Haskell [?], in particular, have many \nfeatures that support type\u00addirected programming, and hence would support development of format-independenttoolsquitenicely. \nO CAML,however,lacksany speci.c, built-in generic programming facility. Fortunately, we can still achieve \nmany of the bene.ts of generic programming idioms by having the PADS/ML compiler generate well-designed, \nformat\u00adspeci.c libraries at compile time and then linking those libraries to format-independent routines. \nTo be speci.c, for each format description, PADS/ML generates a format-dependent traversal mechanism \nthat implements a gen\u00aderalized fold over the representations and parse descriptors that correspond to \nthe description. Independently, tool developers write format-independent routines that specify the behaviour \nof a tool over each PADS/ML type constructor. When users need a speci.c tool for a speci.c format, they \nlink the format-dependent traversal to the format-independent routines via functor application. In principle, \ndifferent tools might require different sorts of traversals. However, many of the tools we have encountered \nin practice so far, both in implementing PADS/ML and PADS, perform their computations in a single pass \nover the representation and cor\u00adresponding parse descriptor, visiting each value in the data with a left-to-right, \npre-, post-, or in-order traversal. This paradigm arises naturally as it scales to very large data sets. \nHence, the PADS/ML compiler generates an implementation of a such traversal for each data description. \n 4.1 The Generic-Tool Interface The interface between format-speci.c traversals and generic tools is \nspeci.ed as an O CAML signature. For every type constructor in PADS/ML, the signature describes a sub-module \nthat implements the generic tool for that type constructor. In addition, it speci.es an (abstract) type \nfor auxiliary state that is threaded through the traver\u00adsal. Figure 8 contains an excerpt of the signature \nthat includes the signatures of the Record and Datatype modules. The signa\u00adtures of other modules are \nquite similar. The Record module includes a type partial_state that allows tools to represent intermediate \nstate in a different form than the general state. The init function forms the state of the record from \nthe state of its .elds. The start function receives the PD header for the data element being traversed \nand begins processing the element. Function project takes a record s state and the name of a .eld and \nreturns that .eld s state. Function process_field updates the intermediate state of the record based \non the name and state of a .eld, and finish converts the .nished intermediate state into general tool \nstate. Note that any of these functions could have side effects. Although the Datatype module is similar \nto the Record module, there are some important differences. The Datatype init function does not start \nwith the state of all the variants. Instead, a variant s state is added during processing so that only \nvariants that have been encountered will have corresponding state. module type S= sig type state ... \nmodule Record : sig type partial_state val init : (string * state) list -> state val start : state -> \nPads.pd_header -> partial_state val project : state -> string -> state val process_field : partial_state \n-> string -> state -> partial_state val finish : partial_state -> state end module Datatype : sig type \npartial_state val init : unit -> state val start : state -> Pads.pd_header  -> partial_state val project \n: state -> string -> state option val process_variant : partial_state -> string -> state -> partial_state \nval finish : partial_state -> state end ... end Figure 8. Excerpt of generic-tool interface Generic \ntool.S. For this reason, project returns a state option,rather than a state. This design is essential \nfor supporting recursive datatypes as trying to initialize the state for all possible variants of the \ndatatype would cause the init function to loop in.nitely. The following code snippet gives the signature \nof the traversal functor as it would appear in the signature S from Section 3. module Traverse (Tool \n: Generic_tool.S) : sig val init : unit -> Tool.state val traverse : rep -> pd -> Tool.state -> Tool.state \n end The functor takes a generic tool generator and produces a format\u00adspeci.c tool with two functions: \ninit, to create the initial state for the tool, and traverse, which traverses the representation and \nparse descriptor for the type and updates the given tool state.  4.2 Example Tools We have used this \nframework to implement a variety of tools useful for processing ad hoc data, including an XML formatter, \nan accumulator tool for generating statistical overviews of the data, and a data printer for debugging. \nWe brie.y describe these tools to illustrate the .exibility of the framework. The XML formatter converts \nany data with a PADS/ML descrip\u00adtion into a canonical XML format. This conversion is useful because it \nallows analysts to exploit the many useful tools that exist for ma\u00adnipulating data in XML. The accumulator \ntool provides a statistical summary of data. Such summaries are useful for developing a quick understanding \nof data quality. In particular, after receiving a new batch of data, an\u00adalysts might want to know the \nfrequency of errors, or which .elds are the most corrupted. The accumulator tool tracks the distribu\u00adtion \nof the top n distinct legal values and the percentage of errors. It operates over data sources whose \nbasic structure is a series of records of the same type, providing a summary based on viewing many records \nin the data source. More complex accumulator pro\u00adgrams and a number of other statistical algorithms can \neasily be implemented using the tool generation infrastructure. Finally, as an aid in debugging PADS/ML \ndescriptions, we have implemented a simple printing tool. In contrast to the printer gener\u00adated by the \nPADS/ML compiler, the output of this tool corresponds to the in-memory representation of the data rather \nthan its original format, which may have delimiters or literals that are not present in the representation. \nThis format is often more readable than the raw data.  5. Conclusions PADS/ML is a high-level, domain-speci.c \nlanguage and system de\u00adsigned to help improve the productivity of the legions of data an\u00adalysts who work \nwith ad hoc data on a regular basis. Inspired by the type structure of functional programming languages, \nPADS/ML uses dependent, polymorphic and recursive data types to describe the syntax and the semantic \nproperties of ad hoc data sources. The language is compact and expressive, capable of describing data \nfrom diverse domains including networking, computational biol\u00adogy, .nance, and physics. The PADS/ML compiler \nuses a types as modules compilation strategy in which every PADS/ML type def\u00adinition is compiled into \nan O CAML module containing types for data representations and functions for data processing. Functional \nprogrammers can use the generated modules to write clear and con\u00adcise format-dependent data processing \nprograms. Furthermore, our system design allows external tool developers to write new format\u00adindependent \ntools simply by supplying a module that matches the appropriate generic signature. The latest release \nof our implementa\u00adtion is available at http://www.padsproj.org/padsml/. The next step in our long-term \nagenda is to build a new gener\u00adation of format-independent data analysis tools. While our current tools \nperform some simple syntactic analysis and transformation, we intend our next generation toolkit to perform \ndeeper semantic analysis and more sophisticated transformations. For example, we may explore speci.cation-driven, \ncontent-based search, clustering, test data generation, machine learning, security, and data visualiza\u00adtion. \nWe believe that if we can automatically generate stand-alone, end-to-end tools that perform these functions \nover arbitrary data, we can have a substantial impact on the productivity of researchers in a broad array \nof scienti.c .elds ranging from computational bi\u00adology through computer science to cosmology and beyond. \nAcknowledgments. We would like to thank Derek Dreyer for dis\u00adcussions and advice on advanced module systems. \nSome of this material is based upon work supported by NSF awards 0615062 and 0612147. Any opinions, .ndings, \nand conclusions or recom\u00admendations expressed in the material are those of the authors and do not necessarily \nre.ect the views of the NSF. References [1] D. Dreyer. Understanding and Evolving the ML Module System.PhD \nthesis, CMU, May 2005. [2] K. Fisher and R. Gruber. PADS: A domain speci.c language for processing ad \nhoc data. In ACM Conference on Programming Language Design and Implementation, pages 295 304. ACM Press, \nJune 2005. [3] K. Fisher, Y. Mandelbaum, and D. Walker. The next 700 data description languages. In ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 2 15, Jan. 2006. [4] Y. Mandelbaum. \nThe Theory and Practice of Data Description.PhD thesis, Princeton University, September 2006. [5] Y. \nMandelbaum, K. Fisher, D. Walker, M. Fernandez, and A. Gleyzer. PADS/ML: A functional data description \nlanguage. Technical Report TR-761-06, Princeton University, July 2006. [6] Tree formats. Workshop on \nmolecular evolution. http:// workshop.molecularevolution.org/resources/ fileformats/tree formats.php. \n  \n\t\t\t", "proc_id": "1190216", "abstract": "Massive amounts of useful data are stored and processed in <i>ad hoc</i> formats for which common tools like parsers, printers, query engines and format converters are not readily available. In this paper, we explain the design and implementation of <sc>PADS/ML</sc> , a new language and system that facilitates the generation of data processing tools for ad hoc formats. The <sc>PADS/ML</sc> design includes features such as dependent, polymorphic and recursive datatypes, which allow programmers to describe the syntax and semantics of ad hoc data in a concise, easy-to-read notation. The <sc>PADS/ML</sc> implementation compiles these descriptions into <sc>ml</sc> structures and functors that include types for parsed data, functions for parsing and printing, and auxiliary support for user-specified, format-dependent and format-independent tool generation.", "authors": [{"name": "Yitzhak Mandelbaum", "author_profile_id": "81100175667", "affiliation": "Princeton University", "person_id": "PP14071519", "email_address": "", "orcid_id": ""}, {"name": "Kathleen Fisher", "author_profile_id": "81331492634", "affiliation": "AT&T Labs Research", "person_id": "PP39056629", "email_address": "", "orcid_id": ""}, {"name": "David Walker", "author_profile_id": "81100426485", "affiliation": "Princeton University", "person_id": "PP39042257", "email_address": "", "orcid_id": ""}, {"name": "Mary Fernandez", "author_profile_id": "81100384253", "affiliation": "AT&T Labs Research", "person_id": "PP31055763", "email_address": "", "orcid_id": ""}, {"name": "Artem Gleyzer", "author_profile_id": "81322494528", "affiliation": "Princeton University", "person_id": "P831274", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190231", "year": "2007", "article_id": "1190231", "conference": "POPL", "title": "PADS/ML: a functional data description language", "url": "http://dl.acm.org/citation.cfm?id=1190231"}