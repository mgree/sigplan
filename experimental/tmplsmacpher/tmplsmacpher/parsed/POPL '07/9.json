{"article_publication_date": "01-17-2007", "fulltext": "\n First-Class Nonstandard Interpretations by Opening Closures Jeffrey Mark Siskind Barak A. Pearlmutter \nSchool of Electrical and Computer Engineering Hamilton Institute Purdue University, USA NUI Maynooth, \nIreland qobi@purdue.edu barak@cs.nuim.ie Abstract We motivate and discuss a novel functional programming \nconstruct that allows convenient modular run-time nonstandard interpretation via re.ection on closure \nenvironments. This map-closure con\u00adstruct encompasses both the ability to examine the contents of a closure \nenvironment and to construct a new closure with a modi\u00ad.ed environment. From the user s perspective, \nmap-closure is a powerful and useful construct that supports such tasks as tracing, security logging, \nsandboxing, error checking, pro.ling, code in\u00adstrumentation and metering, run-time code patching, and \nresource monitoring. From the implementor s perspective, map-closure is analogous to call/cc.Justas call/cc \nis a non-referentially\u00adtransparent mechanism that rei.es the continuations that are only implicit in \nprograms written in direct style, map-closure is a non\u00adreferentially-transparent mechanism that rei.es \nthe closure envi\u00adronments that are only implicit in higher-order programs. Just as CPS conversion is \na non-local but purely syntactic transforma\u00adtion that can eliminate references to call/cc, closure conversion \nis a non-local but purely syntactic transformation that can elimi\u00adnate references to map-closure. We \nshow how the combination of map-closure and call/cc can be used to implement set! as a procedure de.nition \nand a local macro transformation. Categories and Subject Descriptors D.3.2 [Language Classi.ca\u00adtions]: \nApplicative (functional) languages; D.3.3 [Language con\u00adstructs and features]: Procedures, functions, \nand subroutines General Terms Design, Languages Keywords Referential transparency, Lambda lifting 1. \nMotivation Nonstandard interpretation is a powerful tool, with a wide variety of important applications. \nTypical techniques for performing non\u00adstandard interpretation are compile-time only, require modi.cation \nof global resources, or require rewriting of code to abstract over portions subject to nonstandard semantics. \nThis paper proposes a construct to support modular run-time nonstandard interpretation. For expository \npurposes, let us consider a very simple exam\u00adple of nonstandard interpretation. Suppose one wished to \nadd com\u00adplex numbers and complex arithmetic to a programming-language implementation that supports only \nreal arithmetic. One might rep- Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; 2007 \nACM 1-59593-575-4/07/0001...$5.00 resent the complex number a +biasanArgandpair (a, b).Ex\u00adtending the \nprogramming language to support complex arithmetic can be viewed as a nonstandard interpretation where \nreal num\u00adbers r are lifted to complex numbers (r, 0), and operations such as +:R \u00d7 R . R are lifted to \n+:C \u00d7 C . C. (a1,b1) +(a2,b2) =(a1 +a2,b1 +b2) One can accomplish this in SCHEME by rede.ning the arith\u00admetic \nprimitives, such as +, to operate on combinations of native SCHEME reals and Argand pairs (a, b) represented \nas SCHEME pairs (a . b). For expository simplicity, we ignore the fact that many of SCHEME s numeric \nprimitives can accept a variable num\u00adber of arguments. We de.ne a new procedure lift-+ which we use to \nrede.ne + at the top level. (define (lift-+ +) (lambda (x y) (let ((x (if (pair? x) x (cons x 0))) (y \n(if (pair? y) y (cons y 0)))) (cons (+ (car x) (car y)) (+ (cdr x) (cdr y)))))) (define + (lift-+ +)) \nThis raises an important modularity issue. With the above de.\u00adnition, one can take a procedure f de.ned \nas (define (f x) (+ x x)) and correctly evaluate (f (2 .3)) to (4.6).One caneven take a procedure g de.ned \nas (define g (let ((y 10)) (lambda (x) (+ x y)))) and correctly evaluate (g (1 .2)) to (11.2).These exam\u00adples \nwork correctly irrespective of whether f and g are de.ned be\u00adfore or after + is rede.ned. In contrast, \nconsider (define h (let ((p +)) (lambda (x) (p x 5)))) The expression (h (1 . 2)) will evaluate correctly \nto (6.2) only if h was de.ned after + has been rede.ned. This is not the only modularity issue raised \nby this common technique: for in\u00adstance, one might wish to con.ne the nonstandard interpretation to a \nlimited context; one might wish to perform different nonstan\u00addard interpretations, either singly or cascaded; \nand one might wish to avoid manipulation of global resources. The remainder of this paper discusses a \nnovel mechanism, map-closure, which allows such nonstandard interpretation in code written in a functional \nstyle, and which avoids these modular\u00adity issues. As discussed in section 5, map-closure is a powerful \nand useful construct that supports such tasks as tracing, security logging, sandboxing, error checking, \npro.ling, code instrumenta\u00adtion and metering, run-time patching, and resource monitoring. 2. The MAP-CLOSURE \nConstruct The inherent dif.culty in the above example is that while f and g access the addition procedure \nusing the global variable +,which has been overloaded, h is closed over its own local variable p.In most \nhigher-order programming languages, closures are opaque: there is no way to examine or modify closure \nenvironments. To ad\u00address the above modularity issue we introduce a re.ection operator, map-closure, \nwhich can examine the contents of a closure envi\u00adronment and construct a new closure with a modi.ed environment. \nWe adopt a simple model for closures in which they are rep\u00adresented as pairs containing an environment \nand a code pointer. The environment in turn is represented as a mapping of free vari\u00adable names to values, \n{x1 n. vn}. The behavior of . v1,...,x map-closure is simple: it takes two procedure arguments f and \ng, and returns a procedure h whose code is identical to that of g but whose environment is {x1 n. f(xn,vn)}. \n. f(x1,v1),...,x We also allow map-closure to apply to primitive procedures, tak\u00ading their environments \nto be empty. Note that map-closure is not referentially transparent. More\u00adover, the above formulation \nof map-closure is appropriate only for dynamically-typed languages, since it uses a single f to trans\u00adform \nall of the closed-over values in gand these may be of different types. Incorporating map-closure into \na statically typed language would be an interesting topic for future research, as would be the formulation \nof a referentially-transparent construct for .rst-class nonstandard interpretation. Given map-closure, \nwe can de.ne a procedure that substi\u00adtutes xfor yin z. (define (substitute x y z) (cond ((equal? y z) \nx) ((pair? z) (cons (substitute x y (car z)) (substitute x y (cdr z)))) ((procedure? z) (map-closure \n(lambda (n z) (substitutexyz)) z)) (else z))) With this, we can overload the arithmetic operators inside \nclosures. (define (with-complex thunk) ((substitute (lift-+ +) + thunk))) If our implementation represents \nconstants as free variables, we can alternatively lift not only the arithmetic operators but also numeric \nvalues. (define (lift-+ +) (lambda (x y) (cons (+ (car x) (car y)) (+ (cdr x) (cdr y))))) (define (lift-r->c \nx) (cond ((real? x) (cons x 0)) ((pair? x) (cons (lift-r->c (car x)) (lift-r->c (cdr x)))) ((procedure? \nx) (map-closure (lambda (n x) (lift-r->c x)) x)) (else x))) (define (with-complex thunk) ((substitute \n(lift-+ +) + (lift-r->c thunk)))) Note that this removes the dispatches at every call to + in the pre\u00advious \nversion, a sort of dynamic typing, and instead lifts all real values into complex numbers once, at re.ection \ntime: a sort of run\u00adtime static typing. However, just as call/cc [1] complicates cer\u00adtain compiler optimizations, \nthe presence of map-closure forces compilers wishing to perform certain types of optimization, such as \nconstant folding, to do additional static analysis. It is important to emphasize the power that map-closure \naf\u00adfords as illustrated by with-complex in the above example. Sup\u00adpose a user obtains some library code \nthat uses addition. As writ\u00adten, the library code only performs real arithmetic since it uses the built \nin addition primitive. The user can extend that library code to apply to complex arithmetic without access \nto or modi.cation of the source code. The user does not need to wrap either the def\u00adinition of addition \nnor the procedures in the library with calls to with-complex. All the user need do is wrap call sites \nto the li\u00adbrary with calls to with-complex. In fact, the user need not do even this: wrapping the top-level \nmain program with a single call to with-complex suf.ces. The key contribution here is that map-closure \nis a general\u00adpurpose programming construct that allows nonstandard interpre\u00adtation of library code without \nprogrammer access to and modi.ca\u00adtion of said library code. Moreover, if primitives are not (prema\u00adturely) \ninlined, map-closure allows such nonstandard interpreta\u00adtion without compiler access to or modi.cation \nof source code. For purposes of exposition we have motivated map-closure using the well-known concept \nof complex arithmetic. Our interest in this mechanism arose in a slightly different context: an attempt \nto integrate a .rst-class derivative-taking operator into SCHEME using the method of forward-mode automatic \ndifferentiation [2], which ' performs arithmetic on dual numbers x+ xein a fashion roughly analogous \nto that used for complex numbers [3]. There is an interesting analogy between map-closure and call/cc.Justas \ncall/cc rei.es the continuations that are only implicit in a program written in direct style, map-closure \nrei\u00ad.es the closure environments that are only implicit in a higher\u00adorder program. It is well known that \nCPS conversion [4, 5] eliminates call/cc. Similarly, closure conversion [6] eliminates map-closure. We \nillustrate this using a simple dialect of SCHEME de.ned in the next section. This implementation is available \nat http://www.bcl.hamilton.ie/~qobi/map-closure/. With both of the above implementations of with-complex \nthe scope of the lifting is limited to the dynamic extent of the invocation of the thunk argument. However, \nit is tempting to try to implement complex arithmetic in a form where the lifting is permanent. This \ncan be accomplished by invoking (call/cc with-complex),as\u00adsuming that the implementation does not impose \nany arbitrary re\u00adstrictions on the arguments to map-closure. Note that this ap\u00adplies to both the past \nand the future. It modi.es all bindings, both past and future, via recursive descent into the continuation. \nThe mechanics and consequences of allowing map-closure to be ap\u00adplied to continuations are discussed \nbelow. The next section de\u00adscribes a simple functional language which facilitates exploration of the \nconstructs under consideration. We then review the pro\u00adcess of closure conversion, show how closure conversion \nelimi\u00adnates map-closure, and discuss how map-closure in combina\u00adtion with call/cc allows set! to be implemented \nas a de.ned procedure and a local macro transformation. 3. A Functional Subset of SCHEME We formulate \nthese ideas using a simple functional language that resembles SCHEME [7], differing in the following \nrespects: The only data types supported are Booleans, reals, pairs, and procedures. Only a subset of \nthe builtin SCHEME procedures and syntax are supported.  Rest arguments are not supported.  The constructs \ncons and list are macros: (cons e1 e2) . ((cons-procedure e1) e2)  (list) . () (list e1 e2 ...) . (cons \ne1 (list e2 ...)) Procedure parameters p can be variables, () to indicate an argument that is ignored, \nor (cons p1 p2) to indicate the appropriate destructuring.  All procedures take exactly one argument \nand return exactly one result. This is accomplished in part by the basis, in part by the following transformations: \n (e1) . (e1 ()) (e1 e2 e3 e4 ...) . (e1 (cons* e2 e3 e4 ...)) (lambda () e) . (lambda ((cons*)) e) \n(lambda (p1 p2 p3 ...) e) . (lambda ((cons* p1 p2 p3 ...)) e) together with a cons* macro (cons*) . () \n(cons* e1) . e1 (cons* e1 e2 e3 ...) . (cons e1 (cons* e2 e3 ...)) and by allowing list and cons* as \nparameters. The above, together with the standard SCHEME macro expansions, a macro for if (if e1 e2 e3) \n. ((if-procedure e1 (lambda () e2) (lambda () e3))) and a transformation of letrec into the Y-combinator \nsuf.ce to transform any program into the following core language: e::= (quote v) | x | (e1 e2) | (lambda \n(x) e) 4. Closure Conversion The essence of closure conversion is to reify environments that con\u00adtain \nthe values of free variables in procedures by replacing pro\u00adcedures with pairs of environments and a \ntransformed procedure. These transformed procedures have no free variables, and instead access the values \nof free variables from the rei.ed environment passed as an argument. This can be implemented as a purely \nsyn\u00adtactic source-to-source transformation, as shown in .gure 1. We omit a number of bookkeeping details \ntangential to the is\u00adsues we wish to explore. However, one bookkeeping issue relevant to our purpose \ndoes arise. We would like our new re.ective mech\u00adanism to be invariant to choice of variable names. We \ntherefore introduce a new data type, name, to key environments. The inter\u00adface for names consists of \nthe procedures name? and name=?,and the syntax (name x) which returns a unique name associated with the \n(potentially alpha-renamed) variable x. Given this transformation, map-closure can be transformed to \n(lambda (c (cons (cons f fc) (cons g gc))) (cons g (map (lambda (gn gv) (cons gn (f fc gn gv))) gc))) \nThe techniques described in this section and shown in .gure 1 suf\u00ad.ce to implement the examples of section \n2. While the simple im\u00adplementation in .gure 1 represents rei.ed closure environments as alists and transformed \nprocedures as pairs, map-closure does not expose this structure. An alternate implementation could thus \nuse an alternate representation with suitable replacements for lookup, map, and the locations in the \ntransformation where closures are con\u00adstructed. Such an implementation might represent names as offsets \ninto environment tuples.  5. The Utility of MAP-CLOSURE Both alone and in combination with call/cc, \nmap-closure is a powerful and general-purpose construct that can solve important software-engineering \ntasks. It is a portable mechanism for perform\u00ading run-time dynamic nonstandard interpretation, a technique \nof in\u00adcreasing importance that arises in many guises ranging from secu\u00adrity and debugging to web applications \n(mechanisms like AJAX that overload I/O operations to use HTTP/HTML). Consider the follow\u00ading examples \nas an indication of its myriad potential uses. Programmers often desire the ability to examine an execution \ntrace. Figure 2 contains a trace procedure that traces all procedure entrances and exits during the invocation \nof thunk. Such a facility can easily be adapted to perform security logging. Virtual machines are often \nable to execute code in a sandbox so as to constrain the allowed actions and arguments. Figure 2 contains \na sandbox procedure that invokes thunk in a context where all procedure invocations must satisfy the \nallowed? predicate or else the raise-exception procedure is called. Such a facility is useful both for \nsecurity and error checking. Many programming-language implementations contain a facil\u00adity to pro.le \ncode. Figure 2 contains a profile procedure that constructs a table of the invocation counts of all procedures \nin\u00advoked during the invocation of thunk. Such a facility can easily be adapted to instrument and meter \ncode in other ways. One of the hallmarks of classical LISP implementations is the ability to patch code \nin a running system by changing the function bindings of symbols. The designers of COMMON LISP were aware \nthat this mechanism could not be used to patch code referenced in closure slots. They addressed this \nwith a kludge: treating a funcall to a symbol as a funcall to its function binding. Figure 2 contains \na more principled approach to this problem. The procedure patch replaces all live instances of old with \nnew. Finally, many programming-language implementations contain a facility to determine the amount of \nlive storage. Figure 2 contains a room procedure that returns a list of the number of live pairs and \nthe number of live closure slots. Facilities such as the above are normally implemented as sys\u00adtem internals. \nFigure 2 shows that many such facilities can be im\u00adplemented as user code with map-closure.1 6. MAP-CLOSURE \n+ CALL/CC = SET! It is interesting to consider the application of map-closure to a continuation made \nexplicit by call/cc. The source-to-source transformation of closure conversion described in section 4 \ndoes not allow this, because it does not closure-convert continuations. However, we could convert the \nprogram to continuation-passing style (CPS) .rst and then apply closure conversion, thus exposing all \ncontinuations to closure conversion as ordinary procedures. Fig\u00adure 3 describes this process. The transformations \nshown are stan\u00addard, with one exception: the map-closure procedure itself needs to be handled specially, \nas (prior to closure conversion) it cannot be expressed as a user-de.ned procedure, and must be treated \nas a primitive. However, it is unique among primitives in that it in\u00advokes a procedural argument. Since \nthis procedural argument will 1 The examples in .gure 2 use a number of constructs not (yet) provided \nby our prototype implementation, namely (implicit) begin, write, newline, eq?, memq, and named let. It \nis straightforward to add such constructs. (C c (quote v)) . (quote v) (C c (name x)) . (name x) (C \ncx) . (lookup (name x) c) (C c (lambda (x) e)) . (cons (lambda (c1 x) (let ((c2 (cons (cons (name x) \nx) c1))) (C c2 e))) (list (cons (name x1)(C cx1)) ...)) where x1 ...are free in (lambda (x) e) (C c (e1 \ne2)) . (let ((x (C ce1))) ((car x) (cdr x)(C ce2))) e0 . (let ((x1 (cons (lambda (c x) (x1 x)) ())) \n... (cons-procedure (cons (lambda (c1 x1) (cons (lambda (c2 x2) (cons x1 x2)) ())) ())) (map-closure \n(cons (lambda (c (cons (cons f fc) (cons g gc))) (cons g (map (lambda (gn gv) (cons gn (f fc gn gv))) \ngc))) ())) (pair? (cons (lambda (c x) (and (pair? x) (not (procedure? (car x))))) ())) (procedure? (cons \n(lambda (c x) (and (pair? x) (procedure? (car x)))) ()))) (let ((x (list (cons (name x1) x1) ... (cons \n(name cons-procedure) cons-procedure) (cons (name map-closure) map-closure) (cons (name pair?) pair?) \n(cons (name procedure?) procedure?)))) (C xe0)))where x1 ...are free in e0 except cons-procedure, map-closure, \npair?,and procedure?.This assumes that x1 ...are bound to procedures that do not internally invoke procedural \narguments. Figure 1. Closure-conversion algorithm that applies to the top-level expression e0. be in \nCPS after conversion, the CPS version of map-closure must invoke this argument with an appropriate continuation. \nThe combination of map-closure and call/cc is very power\u00adful: it can be used to implement set! as a procedure \nde.nition in a language that does not have any built-in mutation operations. The intuition behind this \nis that set! changes the value of a variable for the remainder of the computation; call/cc exposes the \nremain\u00adder of the computation as a rei.ed continuation; map-closure can make a new continuation just \nlike the old one except that one par\u00adticular variable has a new value; and thus invoking this new contin\u00aduation \ninstead of the old continuation has precisely the same result as set!. The simple de.nition shown in \n.gure 4 accomplishes this intuition. There is, however, one minor complication: the recursion in set-in \nis necessary because the target variable might be present in closures nested in the environments of other \nclosures. As a result, unlike most SCHEME implementations, where set! takes constant time, the implementation \nin .gure 4 must traverse the continuation to potentially perform substitution in multiple environments \nthat close over the mutated variable. While the ability to implement set! as a procedure de.nition combined \nwith a local macro transformation is surprising and in\u00adtriguing, it might be reasonable to consider this \nto be something of a curiosity. The combination of map-closure and call/cc is extremely powerful, and \nthus potentially dif.cult to implement ef\u00ad.ciently. However map-closure in the absence of call/cc is \nstill a useful construct for implementing nonstandard interpretation, and seems amenable to more ef.cient \nimplementation. Thus, imple\u00admentations supporting map-closure might not in general be ex\u00adpected to allow \nits application to continuations. Of the examples in .gure 2, only patch and room rely on this ability. \n 7. Discussion Functor-based module systems [8], overloading mechanisms such as aspect-oriented programming \n[9], and map-closure are related, in that all three support nonstandard interpretation. The difference \nis in the scope of that nonstandard interpretation. In a functor-based module system, the scope is lexical. \nWith overloading, the scope is global. With map-closure, the scope is dynamic. The dynamic scope of map-closure \naffords interesting control over modularity. One can apply a nonstandard interpretation to only part \nof a program. Or, different nonstandard interpretations to dif\u00adferent parts of a program. Or, to different \ninvocations of the same part of a program. One can compose multiple nonstandard interpre\u00adtations, controlling \nthe composition order when they do not com\u00admute. For example, composing complex arithmetic with logging \narithmetic in different orders would allow one to control whether one logged the calls to complex arithmetic \nor the calls to the oper\u00adations used to implement complex arithmetic. With map-closure, nonstandard interpretations \nbecome .rst-class entities. If all aggregate data structures are Church-encoded as closures, CPS conversion \nfollowed by closure conversion subsumes store conversion: it explicitly threads a store, represented \nas an environ\u00adment, through the program. However, compilers that perform both CPS conversion and closure \nconversion generally do so in the op\u00adposite order. Just as call/cc affords one the power of explicit \ncon\u00adtinuations while allowing one to write in direct style, map-closure affords one the power of explicit \nclosure environments while allow\u00ading one to write in higher-order style. The combination of call/cc and \nmap-closure affords the power of explicit store threading while allowing one to write in a direct higher-order \nstyle. In the implementation of set! in .gure 4, the original continu\u00adation is not mutated but discarded. \nInstead of discarding this orig\u00adinal continuation, it can be preserved and invoked later in order to \nimplement such control structures as fluid-let [5] and amb [10] with associated side effects that are \nundone upon backtrack\u00ading [11]. Side effects that can be undone can be used to implement PROLOG-style \nlogic variables and uni.cation [12]. All this can be implemented as de.ned procedures and local macro \ntransforma\u00adtions in a language that has no explicit mutation operations, but that supports call/cc and \nmap-closure, allowing map-closure to apply to continuations. Like other powerful constructs, map-closure \nmay seem dif\u00ad.cult to implement ef.ciently. However, the same was said of constructs like recursion, \ndynamic typing, garbage collection, and (define (trace thunk) ((let wrap ((x thunk)) (cond ((pair? x) \n(cons (wrap (car x)) (wrap (cdr x)))) ((procedure? x) (lambda (arguments) (write (list +1 procedure arguments)) \n(newline) (let ((result ((map-closure (lambda (n x) (wrap x)) x) arguments))) (write (list -1 procedure \nresult)) (newline) result))) (else x))))) (define (sandbox allowed? raise-exception thunk) ((let wrap \n((x thunk)) (cond ((pair? x) (cons (wrap (car x)) (wrap (cdr x)))) ((procedure? x) (lambda (arguments) \n(if (allowed? x arguments) ((map-closure (lambda (n x) (wrap x)) x) arguments) (raise-exception)))) (else \nx))))) (define (profile thunk) (let* ((table ()) (result ((let wrap ((x thunk)) (cond ((pair? x) (cons \n(wrap (car x)) (wrap (cdr x)))) ((procedure? x) (lambda (arguments) (set! table (let increment ((table \ntable)) (cond ((null? table) (list (cons x 1))) ((eq? (car (car table)) x) (cons (cons (car (car table)) \n(+ (cdr (car table)) 1)) (cdr table))) (else (cons (car table) (increment (cdr table))))))) ((map-closure \n(lambda (n x) (wrap x)) x) arguments))) (else x)))))) (write table) (newline) result)) (define (patch \nold new) (call/cc (lambda (c) ((let wrap ((x c)) (cond ((eq? x old) new) ((pair? x) (cons (wrap (car \nx)) (wrap (cdr x)))) ((procedure? x) (map-closure (lambda (n x) (wrap x)) x)) (else x))) #f)))) (define \n(room) (let ((pairs 0) (slots 0) (objects ())) (call/cc (lambda (c) (let walk ((x c)) (cond ((memq x \nobjects) #f) (else (set! objects (cons x objects)) (cond ((pair? x) (set! pairs (+ pairs 1)) (walk (car \nx)) (walk (cdr x))) ((procedure? x) (map-closure (lambda (n x) (set! slots (+ slots 1)) (walk x)) x)))))))) \n(list pairs slots))) Figure 2. Typical LISP and SCHEME system functionality implemented as user code \nwith map-closure. (C c (quote v)) . (c (quote v)) (C c (name x)) . (c (name x)) (C cx) . (cx) (C c (lambda \n(x) e)) . (c (lambda (c1 x)(C c1 e))) (C c (e1 e2)) . (C (lambda (x1) (C (lambda (x2)(x1 cx2)) e1)) e2) \ne0 . (let ((x1 (lambda (c x) (c (x1 x)))) ... (call/cc (lambda (c x1) (x1 c (lambda (c2 x2) (c x2))))) \n(cons-procedure (lambda (c1 x1) (c1 (lambda (c2 x2) (c2 (cons x1 x2)))))) (map-closure (lambda (c (cons \nf g)) (c (map-closure (lambda (x) (f (lambda (x) x) x)) g))))) (C (lambda (x) x) e0))where x1 ... are \nfree in e0 except call/cc, cons-procedure,and map-closure. This assumes that x1 ...are bound to procedures \nthat do not internally invoke procedural arguments. Figure 3. CPS-conversion algorithm that applies to \nthe top-level expression e0. (define (set-innvc) (cond ((procedure? c) (map-closure (lambda (n1 v1) \n(if (name=? n n1) v (set-in n v v1))) c)) ((pair? c) (cons (set-in n v (car c)) (set-in n v (cdr c)))) \n(else c))) (define (set n v) (call/cc (lambda (c) ((set-innvc) #f)))) (define-syntax set! (syntax-rules \n() ((set! x e) (set (name x) e)))) Figure 4. An implementation of set! using map-closure and call/cc. \ncall/cc when .rst introduced. Of particular concern is that it may appear that map-closure precludes \ncompiler optimizations such as inlining, especially of primitive procedures. Well known techniques (e.g., \ndeclarations, module systems, and .ow analy\u00adsis) allow SCHEME compilers to perform inlining despite the \nfact that the language allows rede.nition of (primitive) procedures. These techniques can be extended \nand applied to allow inlining in the presence of map-closure. Even without such techniques, map-closure \ndoes not preclude inlining: a compiler can generate whatever code it wishes, so long as the run-time \nsystem can re\u00adconstruct the closure-slot information that map-closure passes to its .rst argument, and \nany information needed to construct the re\u00adsult closure. Each invocation of map-closure might even perform \nrun-time compilation, including optimizations such as inlining. The history of programming-language research \nis replete with examples of powerful constructs that were initially eschewed for performance reasons \nbut later became widely adopted as their power was appreciated and performance issues were addressed. \nWe hope that this will also be the case for map-closure. Note that, by design, map-closure does not expose \nthe internal representation of closures and environments to the user. This design also preserves hygiene: \nthe lexical hierarchy of variable scoping. Since map-closure does not allow one to add, remove, or rename \nvariables, it is not possible to create unbound variable references or change the lexical scoping of \nvariables through shadowing or unshadowing at run time. An alternate, more traditional way to provide \nthe functionality of map-closure would be to provide an interface to access the environment and code \ncomponents of closures and construct new closures out of such environment and code components, along \nwith an interface to access environment components and construct new environments. However, such an alternate \ninterface would expose the internal representation of closures and environments to the user, perhaps \nvia interfaces and data types that differ in detail between implementations, and might well break hygiene. \nOn the other hand, map-closure exposes only one new data type: names as passed as the .rst argument to \nthe .rst argument of map-closure.The values passed as the second argument to the .rst argument of map-closure \nand the values returned by the .rst argument of map-closure are ordinary SCHEME values. Also note that \nnames are opaque. They are created by new syn\u00adtax to allow implementations to treat them as variables \nin every sense. They can only be compared via identity, so an implemen\u00adtation is free to represent names \nin the same way as variable ad\u00addresses: stack offsets, absolute global addresses, etc. In fact, just \nas implementations can have different representations of variable ad\u00addresses for variables of different \ntypes and lifetimes, implementa\u00adtions can have similarly different representations of names. More\u00adover \nnames can be avoided entirely by using a weaker variant of map-closure that only exposes closure-slot \nvalues. Such a weaker variant suf.ces for many applications, including all examples here except for the \nimplementation of set!. Closure conversion is not the only implementation strategy for map-closure. For \ninstance, a native implementation could oper\u00adate directly on higher-order code. Such an implementation \nwould only need a mechanism for accessing slots of existing closures and creating closures with speci.ed \nvalues for their slots. These mech\u00adanisms already exist in any implementation of a higher-order lan\u00adguage, \nand must simply be repackaged as part of the implementa\u00adtion of a map-closure primitive. Furthermore, \nnative implemen\u00adtations of map-closure are possible in systems that use alternate closure representations, \nsuch as linked or display closures, unlike the .at-closure representation used here. While the implementation \nof map-closure for different representations of closures and en\u00advironments would be different, programs \nthat use map-closure would be portable across all such implementations. This is not the case with the \naforementioned alternate interface. Nonstandard interpretation is ubiquitous in programming lan\u00adguage \ntheory, manifesting itself in many contexts. It could be rea\u00adsonably suggested that the lack of a simple \nway to easily perform a nonstandard interpretation may have held back the application of this powerful \nidea, and resulted in a great deal of implementation effort building systems that each perform some speci.c \nnonstan\u00addard interpretation. For this reason map-closure, or some other construct that provides .rst-class \ndynamic nonstandard interpreta\u00adtion, may prove a surprisingly handy tool. In fact, the authors have already \nfound it quite useful in the implementation of automatic differentiation in a functional programming \nlanguage.  Acknowledgments This work was supported, in part, by NSF grant CCF-0438806, Science Foundation \nIreland grant 00/PI.1/C067, and a grant from the Higher Education Authority of Ireland. Any opinions, \n.ndings, and conclusions or recommendations expressed in this material are those of the author(s) and \ndo not necessarily re.ect the views of the National Science Foundation. References [1] W. Clinger, D. \nP. Friedman, and M. Wand, A scheme for a higher-level semantic algebra, in Algebraic Methods in Semantics, \nJ. Reynolds and M. Nivat, Eds. Cambridge University Press, 1985, pp. 237 250. [2] R. E. Wengert, A simple \nautomatic derivative evaluation pro\u00adgram, Comm. of the ACM, vol. 7, no. 8, pp. 463 4, 1964. [3] W. K. \nClifford, Preliminary sketch of bi-quaternions, Pro\u00adceedings of the London Mathematical Society, vol. \n4, pp. 381 395, 1873. [4] J. C. Reynolds, De.nitional interpreters for higher-order pro\u00adgramming languages, \nin Proceedings of the 25th ACM Na\u00adtional Conference, 1972, reprinted in Higher Order and Sym\u00adbolic Computing, \n11(4):363 397, 1998. [5] G. L. Steele, Jr. and G. J. Sussman, Lambda, the ultimate im\u00adperative, MIT Arti.cial \nIntelligence Laboratory, A. I. Memo 353, Mar. 1976. [6] T. Johnsson, Lambda lifting: Transforming programs \nto re\u00adcursive equations, in Functional Programming Languages and Computer Architecture. Nancy, France: \nSpringer-Verlag, Sept. 1985. [7] W. Clinger and J. Rees, Revised4 Report on the Algorithmic Language \nSCHEME, Nov. 1991. [8] D. MacQueen, Modules for Standard ML, in Proceedings of the 1984 ACM Symposium \non LISP and Functional Program\u00adming, Austin, TX, 1984, pp. 198 207. [9] G. Kiczales, J. Lamping, A. Menhdhekar, \nC. Maeda, C. Lopes, J.-M. Loingtier, and J. Irwin, Aspect-oriented program\u00adming, in Proceedings of the \nEuropean Conference on Object-Oriented Programming, 1997, pp. 220 242. [10] J. McCarthy, A basis for \na mathematical theory of computa\u00adtion, in Computer Programing and Formal Systems,P.Braf\u00adfort and D. Hirschberg, \nEds. Amsterdam: Elsevier North-Holland, 1963. [11] J. M. Siskind and D. A. McAllester, SCREAMER: A portable \nef.cient implementation of nondeterministic COMMON LISP, University of Pennsylvania Institute for Re\u00adsearch \nin Cognitive Science, tech. report IRCS-93-03, 1993. [12] , Nondeterministic LISP as a substrate for \nconstraint logic programming, in Proceedings of the Eleventh National Conference on Arti.cial Intelligence, \nJuly 1993, pp. 133 8.  \n\t\t\t", "proc_id": "1190216", "abstract": "We motivate and discuss a novel functional programming construct that allows convenient modular run-time nonstandard interpretation via reflection on closure environments. This map-closure construct encompasses both the ability to examine the contents of a closure environment and to construct a new closure with a modified environment. From the user's perspective, map-closure is a powerful and useful construct that supports such tasks as tracing, security logging, sandboxing, error checking, profiling, code instrumentation and metering, run-time code patching, and resource monitoring. From the implementor's perspective, map-closure is analogous to call/cc. Just as call/cc is a non-referentially-transparent mechanism that reifies the continuations that are only implicit in programs written in direct style, map-closure is a non-referentially-transparent mechanism that reifies the closure environments that are only implicit in higher-order programs. Just as CPS conversion is a non-local but purely syntactic transformation that can eliminate references to call/cc, closure conversion is a non-local but purely syntactic transformation that can eliminate references to map-closure. We show how the combination of map-closure and call/cc can be used to implement set! as a procedure definition and a local macro transformation.", "authors": [{"name": "Jeffrey Mark Siskind", "author_profile_id": "81100602369", "affiliation": "Purdue University", "person_id": "P137999", "email_address": "", "orcid_id": ""}, {"name": "Barak A. Pearlmutter", "author_profile_id": "81100103003", "affiliation": "Hamilton Institute, NUI Maynooth, Ireland", "person_id": "PP14045810", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190230", "year": "2007", "article_id": "1190230", "conference": "POPL", "title": "First-class nonstandard interpretations by opening closures", "url": "http://dl.acm.org/citation.cfm?id=1190230"}