{"article_publication_date": "01-17-2007", "fulltext": "\n Secure Implementations of Typed Channel Abstractions (Extended Abstract) Michele Bugliesi Marco Giunti \nDipartimento di Informatica Dipartimento di Informatica Universit`a Ca Foscari, Venezia, Italy Universit`a \nCa Foscari, Venezia, Italy michele@dsi.unive.it giunti@dsi.unive.it Abstract The challenges hidden in \nthe implementation of high-level process calculi into low-level environments are well understood [3]. \nThis paper develops a secure implementation of a typed pi calculus, in which capability types are employed \nto realize the policies for the access to communication channels. Our implementation compiles high-level \nprocesses of the pi-calculus into low-level principals of a cryptographic process calculus based on the \napplied-pi calculus [1]. In this translation, the high-level type capabilities are implemented as term \ncapabilities protected by encryption keys only known to the intended receivers. As such, the implementation \nis effective even when the compiled, low-level principals are deployed in open con\u00adtexts for which no \nassumption on trust and behavior may be made. Our technique and results draw on, and extend, previous \nwork on secure implementation of channel abstractions in a dialect of the join calculus [2]. In particular, \nour translation preserves the forward secrecy of communications in a calculus that includes matching \nand supports the dynamic exchange of write and read access-rights among processes. We establish the adequacy \nand full abstraction of the implementation by contrasting the untyped equivalences of the low-level cryptographic \ncalculus, with the typed equivalences of the high-level source calculus. Categories and Subject Descriptors \nF.3.1 [Logics and Mean\u00ading of Programs]: Specifying and Verifying and Reasoning about Programs; F.3.3 \n[Studies of Program Constructs]: Type struc\u00adture; D.1.3 [Programming Techniques]: Concurrent Program\u00adming; \nK.6.5 [Management of Computing and Information Sys\u00adtems]: Security and Protection General Terms Security, \nLanguages, Veri.cation Keywords Typed Behavioral Theories, Language Encodings, Full Abstraction 1. Introduction \nThe use of types for resource access control is a long established technique in the literature on process \ncalculi [17], and so is the application of typed equivalences to reason on the behavior of typed processes \n[14, 18]. Resource control is achieved by predicating Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c . 2007 \nACM 1-59593-575-4/07/0001. . . $5.00 the access to communication channels on the possession of certain \ntype capabilities, and by having a static typing system ensure that the resulting policies are complied \nwith by well-typed processes. Typed equational techniques, in turn, draw on judgments of the ~ form I \n|= P = Q stating the indistinguishability (hence the equivalence) of two processes, P and Q, in enclosing \ncontexts that have access to the names in the type environment I via the type capabilities assigned to \nthem by I. Typed equations of this kind are very effective whenever we have control on the structure \nof the contexts observing our processes, i.e., whenever may assume that such contexts are well-typed. \nThe question we address in this paper is whether the same kind of rea\u00adsoning can still be relied upon \nwhen we extend the class of observ\u00ading contexts to arbitrary, potentially ill-typed contexts. Stated \nmore explicitly: can we deploy our typed processes as low-level agents to run in distributed environments, \nin a fully abstract manner, i.e. preserving the typed behavioral congruences we have established? This \nappears to be an important question, as it constitutes a funda\u00admental prerequisite to the use of typed \nprocess calculi as an abstract speci.cation tool for concurrent computations in distributed, open systems. \nIn [10] we argue that the desired correspondence may hardly be achieved for high-level process calculi \nthat rely on static typing alone. The solution we envision in that paper is based on a new typing discipline \nthat combines static and dynamic typing. Specif\u00adically, we introduce a typed variant of the pi-calculus \nin which the output construct, noted a.v@T ., uses type coercion to enforce the delivery of v at the \ntype T , regardless of the type of the commu\u00adnication channel a. A static typing system guarantees that \nv may indeed be assigned the coercion type T , while a mechanism of dy\u00adnamically typed synchronization \nguarantees that v is received only at supertypes of T , so as to guarantee type soundness of each ex\u00adchange. \nBy breaking the dependency between the types of the transmission channels and the types of the names \ntransmitted, distinctive of the approaches to typing in the pi calculus tradition [17, 14], we can safely \nreduce the capability types to the simplest, .at structure that only exhibits the read/write access rights \non channels, regardless of the types of the values transmitted. Furthermore, and more inter\u00adestingly \nfor our present concerns, the combination of type coercion and dynamically typed synchronization allows \nus to gain further control on the interactions among processes as well as between processes and their \nenclosing context. Based on that, we are able to recover fully abstract implementations of the high-level \nspeci.\u00adcations, i.e. implementations that preserve the typed congruences established for the speci.cations. \nThe basic idea is rather simple, and suggested by the very structure of the types. Brie.y, we repre\u00adsent \na channel with a pair of asymmetric keys, an encryption key to transmit and a decryption key to receive \ndata on n noted n + and n - respectively. Then, we establish the following correspondence between the \ncryptographic keys and the type-level capabilities at\u00adtached to each name: [[ n@w ]] = n + and [[ n@r \n]] = n -. Based on this representation, we may implement a communication over a channel as an exchange \nover the network, as follows1: [[ n.m@A.]] = net.{[[ m@A]] }+ . n [[ n(x).P ]] = net(y).decrypt y as \n{x}+ with n - in [[ P ]] n While this idea is appealing in its simplicity, it suffers from a number of \nshortcomings, .rst made explicit by Abadi in [3]. In subsequent work, Abadi, Fournet and Gonthier have \nshown how to counter these problems and recover a fully abstract implementation for the join calculus \n[2]. The fundamental obstacle against using the solution of [2] for our present purposes is related to \nthe so called problem of forward secrecy. To illustrate, consider the following example which we adapt \nfrom [3]. Let P and Qbe the two processes de.ned as follows (we omit the type coercions whenever irrelevant): \nP =(new n)(n.m.|n(x).p.n@r.) Q =(new n)(n.m ..|n(x).p.n@r.) It is not dif.cult to be convinced that P \nand Q are behaviorally equivalent (essentially under any typing assumption), as m and m . are sent over \na secret channel and no high-level context may recover the contents of messages sent. On the other hand, \na low\u00adlevel context may tell [[ P ]] from [[ Q]] by buffering the message sent on nand then deciphering \nit when n - is published. In [2], this problem is avoided altogether, as the join calculus does not allow \nnames to be communicated with read capabilities, a feature that instead constitutes one of the fundamental \ningredients of our typed calculus. To recover forward secrecy, one needs a more structured represen\u00adtation \nof type capabilities to make sure that distributing a read capa\u00adbility does not correspond to leaking \nany decryption key. The solu\u00adtion we envision in the present paper is based on the representation of \na channel as a process that serves input and output requests, so that each message exchange is the result \nof two separate protocols with writer and reader clients. All channels are associated with two separate \nkey-pairs. The decryption keys are always stored securely at the channel, and never leaked; the encryption \nkeys, in turn, are available to the clients that have read and/or write access to the channel. In the \nwrite protocol, the client sends data and the channel buffers it on a private queue; in the read protocol, \nthe client sends a session key and the server returns data encrypted with that key. As a result, publishing \na read (write) capability on a channel cor\u00adresponds to publishing the read (write) encryption keys associated \nwith the channel: decryption keys are never leaked, as desired. Under appropriate, mostly standard, hypothesis \non the properties of the underlying network, we show that a translation based on these ideas is sound. \nFull abstraction, instead, is harder to achieve as one needs to build safeguards against attacks that \nexploit malformed data or rely on malicious channels that intentionally leak their associated decryption \nkeys. To account for that, we complement the translation with a proxy-service mechanism to ensure that \nall communication protocols take place via system generated (hence secure) channels. We prove that the \nresulting implementation is fully abstract by showing that the untyped equivalences of the 1 Here net \nis a public channel representing the network. Now, since all exchanges are assumed to occur over net, \nthe input process should also be instrumented with a recovery mechanism to handle all those cases in \nwhich it picks up wrong packets . We omit this and other details at this stage, for ease of readability. \nlow-level cryptographic calculus coincide, via the translation, with the typed equivalences of the high-level \ncalculus. As a byproduct, since our high-level process calculus is a conservative extension of the untyped \npi calculus, we also have a direct fully abstract implementation of the pi calculus. Finally, we devise \na distributed implementation of the proxy service for a variant of our high\u00adlevel process calculus in \nwhich processes are assigned to different domains, each one providing a local proxy. We extend the full \nabstraction result to this enhanced, more realistic model. Plan of the paper. Section 2 reviews the typed \npi calculus of [10], that we employ as the high-level language. Section 3 introduces the dialect of the \napplied-pi calculus that we use as the implementation language. Section 4 formalizes the low-level model \nof the network that underpins our implementation. Sections 5 to 7 detail the trans\u00adlations we have outlined \nand establishes the main results. Section 8 concludes with .nal remarks.  2. A pi calculus with dynamic \ntyping Given its intended use as a speci.cation language for distributed systems, our pi-calculus is \nasynchronous. We remark, however, that the same technique and results would apply, mutatis mutandis, \nto the synchronous case. We presuppose countable sets of names and variables, ranged over by a n and \nx,y,... respectively. We use u,v to range over names and variables, when the distinction does not matter. \nWe denote tuples of values and types with u and A , respectively. The syntax of processes is given below. \nA,B ::= ch(rw) | ch(r) | ch(w) |.P,Q ::= 0 inaction | P |Q composition | (new n : A)P restriction | ! \nP replication | [u= v] P; Q matching | u.v @A . type-coerced output | u( x@A ).P typed input The .rst \nfour constructs are standard from the pi-calculus. The matching process [u = v] P; Q is a conditional \nthat proceeds as P if u = v,and as Qotherwise. In the input and output forms, the notation v @A (respectively \nx @A ) is short for v1@A1,...,vn@An (resp. x1@A1,...,xn@An). Restrictions and input pre.xes bind names \nand variables, respectively. The notions of free and bound names/variables arise as expected. The types \nch(\u00b7) are the types of channels, built around the ca\u00adpabilities r, w and rw which provide read, write \nand full .edged access to the channel, respectively. To ease the notation, we hence\u00adforth denote channel \ntypes by only mentioning the associated capa\u00adbilities. .is the type of all values and may be used to \nexport a name without providing any capability for synchronization or exchange. The subtyping relation \n<: is the lattice de.ned as follows (with A any type): rw <: r, rw <: w,A<: ., with a meet operation \narising as expected, namely: rw .r . rw rw .w . rw w .r = rw A... A Type environments, ranged over by \nG,., are .nite mappings from names and variables, to types. Following [14], we extend type environments \nby using the meet operator: G .u : A =G,u : A if u .. dom(G),otherwise G .u : A =G. with G. differing \nfrom G only at u: G.(u)=G(u) . A. Subtyping is extended to type environments as expected: G <:. whenever \ndom(G) = dom(.) and for all a :dom(G) we have G(a) <:.(a).If G(n) <: r, we say that Gr(n) is de.ned, \nwritten Gr(n) .. Gr(n) . indicates that G(n) is unde.ned or G(n) .r. Corresponding notation is <: employed \nfor the write capability. Typing rules The typing rules for name and variable projection, and for the \nprocess forms of parallel composition, replication, restriction and nil are entirely standard cf. [17, \n19]). The remaining rules are given below. (T-Match) (T-Out@) (T-In@) G . Q G(u)= A G(v)= B G . u : B \n. v : A . P Gw(u) . G . v : B Gr(u) . G,x : A . P G . [u = v] P; Q G . u. v @B . G . u( x@A ).P Labelled \nTransitions The transitions for parallel composition, restriction and replication are standard. The remaining \ntransitions are givenbelow. Inrule (PI-CLOSE@),wetacitlyassumethatthetuples B and B<: B. have the same \narity, and the notation B. is short for the subtyping judgments on the components types. (PI-MATCH) (PI-MISMATCH) \n(PI-OUTPUT@) (PI-INPUT@) aa P --. P. a .Q . = b --. Q a . a . a.v @B . a( v@B ) [a = a] P; Q --. P[a \n= b] P; Q --. Q a. v @B . -----. 0 a( x@B ).P -----. P{ x} v/ (PI-OPEN@) (PI-CLOSE@) ( c)a.v @B . ( \nc)a.v @B . a( v@B ) = a, b . fn( P -------. P. b .v) P -------. P. Q -----. Q. B<: B. c n fn(Q)= \u00d8 (b, \nc ) a.v @B . t .. (new b)P ---------. P. P | Q --. (new c )(P| Q) Typing System. The typing rules, in \nTable 1, are largely standard, but with important speci.cities. The typing of matching is inherited directly \nfrom [14]: as in that case it allows a more liberal typing of the then branch of the conditional, based \non the knowledge that the two values tested are indeed the same. To illustrate, as a result of that rule, \nthe following judgment is derivable: x : r,y : w . [x = y] x.. ; 0. The rules for input and output are \ndistinctive of our typing system. In (T-Out@) the tuple v , output at channel u, is tagged with a type \nB with the intention to force its delivery at the type B (or at a supertype). As we show below, a dynamic \ntypecheck performed upon synchronization ensures that values delivered at a given type will only be received \nat the same or higher types. Operational Semantics. The dynamics of the calculus is de.ned in terms of \na labelled transition system built around the actions a .{ t, u( v@A ), ( c) u. v @A .}. The output transition \n( c) u. v @A . carries a type tag along with the output value: it represents the output of (a tuple, \npossibly including fresh) values v at the types A ; dually, the input action u( v@A ) represents input \nof v at the types A .The t-transition represents internal synchronization, as usual. The novelty, with \nrespect to companion process calculi is that it is dynamically typed: complementary labels synchronize \nonly when they agree on the type of the value exchanged. As proved in [10, 13], the dynamic check ensures \nthat well-typing is preserved by reduction. Observational Equivalence. The notion of observational equiva\u00adlence, \nbased on weak bisimulation, is inherited almost directly from [14]. As usual in typed equivalences, we \nobserve the behavior of processes by means of contexts that have a certain knowledge of the processes, \nrepresented by a set of type assumptions contained in a type environment. However, following [14], we \ntake the view that the typing information available to the context may be differ\u00adent (less informative) \nthan the information available to the system. Thus, while the system processes may perform certain actions \nbe\u00adcause they possess the required (type) capabilities, the same may not be true of the context. We formalize \nthese intuitions below, fol\u00adlowing [14]. Given two type environments G and I, we say that G is compatible \nwith I if and only if dom(G) = dom(I) and G <:I.Furthermore, we say that a type environment is closed \nif it has only names (not variables) in its domain. De.nition 1. A type-indexed relation R is a family \nof binary relations between processes indexed by closed type environments. We write I |= PRQ to mean \nthat (i) P and Q are related by R at I and (ii) there exist G and . compatible with I such that G . P \nand . . Q. We often write I |= PRQ as P RI Q. De.nition 2 (Contextuality). A type-indexed relation R \nis con\u00adtextual whenever (i) I . PRQ and a .. dom(I) implies I,a : A . PRQ, (ii) I . PRQ and I . R imply \nI . (P | R)R(Q| R), and (iii) I,a : A . PRQ implies I . ((new a:A)P)R((new a:A)Q). Given a type environment \nI and a closed process P,we de.ne the barb predicate relative to the environment I as follows. First \nde.ne ( c)a. b@B . P . a. . P. such that P -------. P. and P . a iff . P. such that P ==. P. . P. . a,where \n=. is the re.exive and transitive t closure of -. . Then we de.ne the desired predicate as follows: I \n. P . a . I(a)r .. P . a,and I . P . a . I(a)r .. P . a. De.nition 3 (Typed behavioral equivalence). \nTyped behavioral equivalence, noted ~p, is the largest symmetric and contextual = type-indexed equivalence \nrelation R such I |= PRQ implies (i) t if I . P . n then I . Q . n, and (ii) if P -. P. then Q =. Q. \nand I |= P.RQ. for some Q. . A fundamental difference between our notion of equivalence and that of [14] \narises as a consequence of the different typing disci\u00adplines in the two systems. In our system, the rule \nfor synchroniza\u00adtion guarantees that any name emitted on a public channel is re\u00adceived by the context \nat the static coercion type used upon output. Conversely, in [14], the type at which the context acquires \nthe new name is determined by the typing assumptions available to the con\u00adtext on the channel used for \noutput. To illustrate, under the typing2 n : r.r.T .., a context interacting with the process n.m. will \nac\u00adquire m as a channel of type r.T ., regardless of the actual type of m, hence even though m was sent \non n as a fully-.edged channel. Clearly, this kind of behavior presupposes that the context plays by \nthe rules and will not try to acquire from the value emitted more than allowed by the read type of the \ntransmission channel. As a consequence, reasoning on access control policies in system like [14] can \nhardly be carried out without assuming that the context is well-typed, with the same type system. In \nour solution, instead, an appropriate use of coercion may be put in place to prevent the con\u00adtext from \nacquiring, upon output by the system, more information than it was intended to. In fact, we may code \nthe system s output simply as n.m@r. and have the synchronization rule ensure that the context will not \nhave more than the intended capabilities on m. Interestingly, a corresponding mechanism can be realized \nin terms of a low-level construction in the applied pi-calculus to provide such guarantees even in the \npresence of hostile contexts.  3. The applied pi calculus The applied pi-calculus we use is an asynchronous \nversion of the original calculus of [1], in which we assume that destructors are only used in let-expressions \nand may not occur in arbitrary terms. This is becoming common practice in the presentations of the applied \npi-calculus [6, 7, 5]. As for the high-level calculus, we presuppose countable sets of names and variables, \nunder the same notational conventions. In ad\u00addition the calculus is characterized by a .nite set of function \nsym\u00adbols S from which terms may be formed. As in [7], we distinguish constructors and destructors, and \nuse the former to build terms and the latter to take terms apart. Constructors are typically ranged over \nby f, destructors by d. Terms are built around variables and con\u00adstructors, expressions correspond to \ndestructor application: M, N ::= a, b, ... channel names x, y, ... variables f(M1, ..., Mn) constructor \napplication E ::= d( M) expression A value is a term without variables. We always assume that con\u00adstructors \nare applied consistently with their arity. Processes are de\u00ad.ned as follows: P, Q, ::= 0 | M.N .| M( \nx).P | P | Q | (new n)P | ! P | let x = E in P else Q Input pre.xing, let, and restriction are binders: \nM(x).P and let x = E in P else Q bind the variable x in P , (new n)P binds the name n in P . The notions \nof free and bound names/variables arise as expected. The process let x = E in P else Q tries to eval\u00aduate \nE; if that succeeds x is bound to the resulting term and the process continues as P (with the substitution \nin place). Otherwise the process reduces to Q. The evaluation of E is governed by a set of de.nitions \nwhich give semantics to the destructor. Each def\u00ad . inition has the form d(M ) = N where the terms M \nand N have no free names and fv(N) . fv(M ).Then d(M ) is de.ned only . if there is a de.nition d(M .)= \nN and a substitution s such that M = M .s, in which case d(M ) evaluates to the term Ns = N * , noted \nd(M ) . N *. Conversely, we note d( . M). whenever there is no M .s = M with a de.ning equation. We say \nthat a construc\u00adtor is one-way if no destructor application ever returns any of the constructor s arguments. \n2 Here r.r.T .. indicates the type of a read-only channel carrying values that are themselves read-only \nchannels with payload of type T . We always omit trailing 0 processes and write let x = E in P instead \nof let x = E in P else 0. We also combine multiple let\u00adbindings in a single let instead of writing the \ncorresponding nested de.nitions. Finally, we de.ne: rec X.P . (new a)(a.. | !a().P {a../X}) a ..fn(P \n) Our applied pi-calculus includes destructors to project the elements of tuples (noted pi), as well \nas two constructors for lists, :: (cons) and \u00d8 (nil), together with the the standard destructors hd and \ntl: .. hd(x :: y)= x tl(x :: y)= y In addition, we introduce the one-way constructors hash, ek, dk, sk, \npub, priv that we employ as the basic building blocks of the cryptosystem used by the implementation. \nThe constructor hash generates a hash from the seed M, and we assume that the hash function is collision-free: \nhash(M)= hash(N) implies M = N. The two unary constructors ek and dk generate encryption and decryption \nkeys ek(M) and dk(M) from a seed M;asin [1] we essentially view M as a generator of unguessable seeds. \nWe often abbreviate ek(M) to M+ and dk(M) to M-. Finally, sk generates ashared key sk(M) from the seed \nM, while pub and priv generate a pair of public/private keys pub(M) and priv(M) associated with the seed \nM. We often abbreviate pub(M) with MID. We may now de.ne our cryptosystem in terms of two fur\u00adther constructors, \nsign,and cipher, and the destructors decipher , verify, de.ned by the following equations: decipher(cipher(x, \nek(y)), dk(y)) . = x decipher(cipher(x, sk(y)), sk(y)) . = x verify(sign(x, priv(y)), pub(y)) . = x \nSignatures are built using the binary constructor sign and checked by using the destructor verify [6, \n7]; encrypted packets, in turn, are formed around the binary constructor cipher, and taken apart by using \nthe destructor decipher . In the implementation, we use two further constructors, rd and wr, to construct \ndifferent sets of keys associated with the same seed (cf. Section 4). We often use the conventional spi-calculus \nnotation {M }N for the encrypted packet cipher( M,N). Following [7], we de.ne an if - then - else con\u00adstruct \nin terms of let as shown below: if M = N then P else Q . let x = equals(M, N) in P else Q Here we assume \nx .. fv(P, Q),and equals is a further destructor . with de.ning equation equals(x, x)= x. Finally, we \nintroduce an explicit form of decryption to bind multiple variables as in the original spi-calculus (again, \nwe assume x fresh in P and Q) decrypt M as {y }N in P else Q . let x = decipher (M, N) in let y1 = p1(x),...,yn \n= pn(x) in P else Q Operational semantics. The dynamics of the calculus is de.ned by means of a labelled \ntransition system. Following an increasingly common practice [7, 5], the transitions do not use the active \nsubsti\u00adtutions introduced in the original formulation of [1]. The core of the LTS is given in In Table \n2: we omit the re\u00admaining transitions (for parallel composition, replication and re\u00adstriction) which \nare entirely standard. For simplicity, we require that all synchronizations occur on channel names, rather \nthen ar\u00adbitrary terms. The treatment of let is taken from [7]. The tran\u00adsitions are only de.ned over \nclosed processes (with no free vari\u00adables). Given and such process P ,we de.ne: P .a if and only if ( \nn)a. M. .P . such that P -----. P . , P .a if and only if .P . such that P ==. P . . P . .a. Behavioral \nequivalence. As in Section 2, we rely on a notion of behavioral equivalence based on weak bisimulation, \nand relative (OPEN) (OUT) (IN) ( b) a. M. P -----. P . c . M) = a, c . fn( a. a( M. M) ( b,c) a. a. \na( ---. P { M. M. ---. 0 x).P M/x } (new c)P -------. P . (CLOSE) (LET) (LET-ELSE) P ( b) a. M. -----. \nP . Q a( M) ---. Q. b . . fn(Q) d( M) . NP { N/x} a --. P . d( M) .. Q a --. Q. P | Q t --. (new b)(P \n. | Q.) let x = d( M) in P else Q a-. P . let x = d( M) in P else Q a-. Q. to contexts with a certain \nknowledge about names and terms. The formal de.nitions are mostly based on the work of Boreale, De Nicola \nand Pugliese in [8]. A term environment . is a .nite substitution from variables to values. We write \nfn(.) to mean fn(Range(.)). Substitutions may only be extended with new bindings for fresh variables: \n., M/x indicates the extension of . with x .. dom(.). Given a term environment .,we let A (.) be the \nanalysis of .,thatis, the environment obtained by extending . with new bindings for the terms resulting \nfrom the application of destructors to the range of .. Formally: De.nition 4. The analysis A (.) of . \nis the smallest substitution s extending . that is closed by the following rule: . d(N ) = N . s. . . \nNs. . Range(s)(z . dom(s)) Ns./z . s Abusing the notation we often write N . A (.) to mean N . Range(A \n(.)). Given a process P we say that . de.nes P , written . . P ,if fv(P ) . dom(.) and fn(P ) n fn(.)= \n\u00d8 .We use the same convention and notation for terms. De.nition 5 (Term-indexed relation). A term-indexed \nrelation R is a family of binary relations between closed processes indexed by term environments. We \nwrite . |= P RQ (or equivalently P R. Q) to mean that P and Q are related by R at . and that fn(P, Q) \n. fn(.). We have a notion of contextuality corresponding to that given in Def. 2. We note . \\ n the term \nenvironment resulting from erasing from . all bindings M/x such that n . fn(M). De.nition 6 (Contextuality). \nA term-indexed relation R is con\u00adtextual whenever . |= P RQ implies (i) if .. R then .|=(P | R.) R(Q \n| R.), (ii) ., n/x |= P RQ with n .. fn(.), and (iii) . \\ n |= ((new n)P )R((new n)Q). The barb predicate \nis de.ned relative to a term-environment, as expected: . |= P . a . a . A (.) . P . a,and . |= P . a \n. a . A (.) . P . a. De.nition 7 (Behavioral equivalence). Behavioral equivalence, noted ~Ap, is the \nlargest symmetric and contextual term-indexed = relation R such that . |= P RQ implies (i) if . |= P \n. n then t . |= Q . n, and (ii) if P -. P . then . Q. . Q =. Q. and . |= P .RQ. .  4. The implementation \nframework As anticipated, our implementation is based on a compilation of the high-level processes of \nthe pi-calculus into corresponding pro\u00adcesses of the spi-calculus representing low-level principals running \nin an open network. 4.1 Network model Our assumptions about the low-level communication infrastructure \nof such network are the same as those of [2]. In particular, we pre\u00adsuppose a Needham-Schroeder model, \nin which an intruder can in\u00adterpose a computer in all communication paths and thus alter or copy parts \nof messages, replay messages or forge new ones. On the other hand, we assume that the intruder cannot \ngain control of the whole network, and intercept all messages: consequently, message delivery may always \nbe achieved with an adequate degree of redun\u00addancy. To model such eavesdropper we assume that principals \nmay only send and receive messages through a public network interface consisting of a communication channel \nnet (typically all the ex\u00adchanges over this channel are encrypted). On the other hand, each principal \nhas a secure environment in which to compute and store private data. 4.2 Data structures for names The \ndesign of the implementation is centered around the choice of an appropriate data structure to represent \nthe names and the capa\u00adbility types of the high-level calculus. As we mentioned at the out\u00adset, the idea \nis to represent the capability types with corresponding term capabilities, implemented as encryption \nkeys. Speci.cally, the representation of the name n as a fully .edged channel includes the name identity \nand two encryption keys corresponding to the read and write capabilities: (pub(n), ek(wr(n)), ek(rd(n))).The \nap\u00adplication of the one-way constructors rd and wr provides a way to construct the read and write seeds \nassociated with the key-pairs that implement the capability types attached to n. The representation of \na name is now obtained by introducing self\u00adsigned certi.cates [6, 4] of the form: Cert(n) . { pub(n), \nhash(ek(wr(n))), hash(ek(rd(n)))} priv(n) The certi.cates help determine the type of the names they are \nattached to. To illustrate, suppose we receive a tuple formed as (M0,M1,M2,Cert(n)), with Mi arbitrary \nterms. One may .rst ensure that the certi.cate corresponds to the correct identity by us\u00ading the public \nkey pub(n) to verify the certi.cate, and then match M0 with the public key. As this stage, one may decide \nwhether or not M1 and M2 are valid capabilities for the identity M0 by cal\u00adculating hash(M1) and hash(M2) \nand by checking whether they match the two values hash(ek(wr(n))) and hash(ek(rd(n))) re\u00adspectively: \nin the former case we certify a write capability, in the latter a read capability. n =(pub(n), ek(wr(n)), \nek(rd(n)), Cert(n)). All the low-level protocols that implement the synchronization steps in the high-level \ncalculus exchange and manipulate quadru\u00adples and expect the components of such tuples to adhere to the \nfor\u00admat above. For uniformity, we write x to note a quadruple of vari\u00adables used to store name representations. \nFurther, we introduce the following mnemonic notation for the components of 4-tuple terms: M+ MID = p1(M) \nw = p2(M) Mr + = p3(M) MCERT = p4(M) Notice that we make no assumption on the format of the 4-tuple: \nhence, only when M = n for some name n the projections select the identity, the keys and the certi.cate \nassociated with n.Abusing the notation, we often write n/x (and more generally M/x,when M is a 4-tuple) \nto indicate the substitution of the components of n (or M) for the corresponding variables composing \nx. Given this representation of names, the effect of casting a name at a higher type in the high-level \ncalculus is realized, in the im\u00adplementation, with a mechanism that masks away the encryp\u00adtion keys corresponding \nto the type capabilities lost in the type cast. This is accomplished by introducing four unary destructors \n.r, .w, .rw, ..corresponding to the four possible type coercions of the source calculus. We use post.x \nnotation in the de.ning equations below, and in the rest of the presentation, writing M.T instead of \n.T(M). . (x,y,z,w) .rw =(x,y,z, w) . (x,y,z,w) .r =(x,.,z,w) . (x,y,z, w) .w =(x,y,.,w) . (x,y,z,w) .. \n=(x,., .,w) When applied to the representation of a name n, the application n.T implements the coercion \nof run-time type of n correspond\u00ading to the type-coercion n@T: in the implementation, the coercion simply \namounts to erasing the appropriate encryption keys. In the translation, we will .nd it useful to compute, \nand manip\u00adulate the run-time type of terms. We give a low-level representa\u00adtion of the high-level types \nby simply treating the latter as nullary constructors: thus the terms rw, r, w, .in the implementation \nrep\u00adresent the corresponding high-level types ch(rw), ch(r), ch(w), .. Following the convention adopted \nfor names, we write T for the representation of the type T in the low-level calculus. Also, we sometime \nwrite S<: T when S<: T. Next, we introduce nota\u00adtion to express a number of useful operations on the \nrepresentation of names and their (run-time) types. Speci.cally, we note: if WF (M, T) then P else Q \na process that tests whether M is certi.ed and has type S,for some S<: T;  let x = Cast(M, T) in P a \nprocess that casts the type of M to T and binds the resulting term and the certi.cate to x in P (this \nis the dynamic counterpart of the .T destructors);  let x = Meet{M1,...,Mn} in P a process that computes \na new tuple representing the result of merging the capabilities of the Mi s and binds such tuple to x \n: the result of the meet is de.ned only if Mi = Mj for all i, j .[1..n];  CERT CERT let x = Typeof(M) \nin P a process that veri.es that M represents capabilities certi.ed by MCERT , determines the type of \nM, and binds that type to x; in such case we informally say that M has such type. Again the operation \nis unde.ned if M fails to be certi.ed. All the operations above can be encoded by means of nested ap\u00adplications \nof the projection, equality, verify and cast destructors: we omit all details and refer the reader to \n[13]. Instead, for future reference, we note that such operations will be invoked in our im\u00adplementation \nonly in the presence of precise invariants that guar\u00adantee that they (the operations) are well-de.ned. \nMore precisely, the communication protocols guarantee the following conditions: (i) whenever we activate \nthe process let x = Cast(M, T) in P, MCERT is indeed a certi.cate that certi.es the remaining compo\u00adnents \nof M, and the type of M is S<: T, (ii) whenever we evaluate let x = Meet{M1,...,Mn} in P, Mi and Mj are \nthe same certi.cate which certi.es the remaining components of Mi and Mj at their respective types for \nall i, j .[1..n]. CERT CERT A further important remark is in order on the nature of the cer\u00adti.cates \nand the guarantees they convey. On the one hand, as we argued, the certi.cates help extract the capabilities \nfrom the repre\u00adsentation of names. On the other hand, being self-signed, a certi.\u00adcate does not by itself \nensure that the capabilities extracted from aterm (MID ,M+,M+,MCert ) are valid encryption keys. That \nww is indeed the case for names generated by our implementation, but a term with this structure received \nfrom an arbitrary context may well be validated at type T without being the representa\u00adtion of any name \nat any type. To illustrate, the (fake) certi.cate C = {pub(n), hash(M), hash(N)}priv(n) will certify \na write ca\u00adpability in (pub(n),M, .,C) regardless of the structure of M, which can be any term. Fortunately, \none can build more structure in the implementation so as to protect against such threats and give guarantees \nthat any term used as a key is indeed a valid key. We show how that can be accomplished in Section 6. \n 4.3 Message .ltering and emission As in [2], all the communication protocols underlying our imple\u00admentation \nrun on the public channel net, and hence require the ability for all protocol participants to .lter messages, \nbased on dif\u00adferent mechanisms. A .rst mechanism allows processes to .lter replays of messages, based \non nonces. We write if M .. Setn then P, for a process that adds M to the list carried on channel n and \ncontinues as P whenever M does not occur in the list. if M ..Setn then P . n(y).(if M ..y then n.M :: \ny.|P else n.y.) The testing process if M .. N then P else Q can be implemented by nested applications \nof head, tail and equal destructors: we omit all details and refer again to [13]. The input of a message \nuses two .ltering protocols. The .rst picks a packet from the net and proceeds with the continuation \nonly if the message is successfully decrypted; otherwise it re-emits the message and retries: .lter y \nwith N in P . rec X.net(x).decrypt x as {y }N in P else (net.x.|X) The second protocol .lters messages \nbased on their types, and up\u00adcasts them at those types. .lter x@t from c in P . rec X.c(y).if WF(y,t) \nthen (let x = Cast(y,t) in P) else (c.x.|X) The output of a message M on a network is realized by emitting \nM on the net channel, typically encrypted. To ensure delivery, the emission is replicated, and packaged \nwith a fresh nonce, n,to protect against replay attacks. The nonce also acts as a confounder emit({M}k) \n. (new n)! net.{M, n}k.  5. A First Implementation We are ready to give a formal de.nition of the two \ncomplemen\u00adtary components of the implementation: the channel infrastructure for communication, and the \ncompilation of high-level processes. As anticipated, the idea is to set up appropriate channel servers \nto support write and read requests for synchronization and value exchange; the high-level processes of \nthe pi calculus, in turn, are represented as clients running corresponding protocols with the servers. \n5.1 Channels and communication protocols Each channel server is associated with two pairs of asymmetric \nkeys employed in the protocols for reading and for writing, respec\u00adtively. The encryption keys are circulated \namong clients as compo\u00adnents of the tuples that represent the high-level names; the decryp\u00adtion keys, \nin turn, are stored securely at the channel servers. Write protocol. On the client side, writing on a \nchannel is accom\u00adplished by emitting a packet encrypted under the channel s write encryption key. The \nmessage is replicated to ensure delivery, and packaged with a nonce to protect against replay attacks. \nThe server, in turn, uses the write decryption key to receive the message, uses the nonce to .lter multiple \ncopies of the message (hardly realistic, of course: indeed, the solution from [2], based on a challenge \nre\u00adsponse mechanisms, would work just as well here), and stores them into a private queue. It also .lters \nbased on the format of the mes\u00adsages received, requiring that they match the format expected of the encoding \nof names. Read Protocol. On the client side, the reader process uses the chan\u00adnel s read encryption key \nto send a request to the server. The request takes the form of pair including a symmetric key that will \nbe used as a session key to exchange the message with the server, and (the representation of) a type \nat which the client expects its input value. The client then waits for a message from the server encrypted \nun\u00adder the session key: upon receiving the packet, it proceeds with its continuation. The server, in \nturn, uses the channel s read decryption key to receive a request from the client. To protect against \nreplays, the server keeps track of the nonces received on a private channel. After checking the freshness \nof the request, the server uses the type to select one of the message from its private queue and then \npack\u00adages the message with the key. The nonce can be spared on the actual message sent by the server \nas the key expires at the comple\u00adtion of the protocol (the server may easily .lter out replays of the \nsession key). The de.nition of the channel servers is reported in Table 3. We use the notation n - and \nn - to refer to dk(rd(n)) and dk(wr(n)) rw respectively. The two private names n . and n * hold, respectively, \nthe message queue and the nonce set associated with n. The de.\u00adnitions, as given, are adequate for monadic \nexchanges only, but the extension to the polyadic case is relatively straightforward, as one may rely \non corresponding polyadic exchanges in the implementa\u00adtion language. Indeed, we could simply associate \nan arity with each channel, and parameterize the de.nition of the .lters (on the server and client sides) \non that arity. 5.2 Compilation of high-level processes The translation of high-level processes is given \nby induction on the typing judgments of the pi-calculus, and is only de.ned for derivable judgments. \nWe remark, however, that the output of the translation only depends on the structure of the processes, \nas the latter contain enough information to guide the generation of the low-level code. On the other \nhand, the typing information is useful in stating and proving the properties of the translation, whenever \nwe need to draw precise connections between the static capability types of the high-level processes and \nthe dynamic term capabilities of the low-level principals. The compilation function takes an extra argument, \nnoted \u00b5,that collects information on the equalities corresponding to the match\u00ading pre.xes encountered \nin the traversal of the process being com\u00adpiled. This information is expressed as a set of bindings u \n. v, with u and v syntactically different (if u and v are syntactically identical, the binding conveys \nno information). We note \u00b5[u.v] the extension of \u00b5 with a new binding. Also, we write \u00b5 . u.v to indicate \nthat u.v is derivable from the equational theory gener\u00adated by \u00b5 (notice that \u00b5 . u.v is decidable for \n.nite \u00b5. s). The information conveyed by the argument \u00b5 is exploited by the compiler to generate code \nthat reconstructs the run-time type of a name, gathering the encryption keys corresponding to the capability \ntypes available in the source calculus. More precisely, the term formed by the compiler-generated code \nrepresents the run\u00adtime counterpart of the meet taken on the types of all the names (or variables) that \noccur in an match enclosing the process being compiled. In Table 3, we express this calculation using \nthe notation let x = [[ u ]] \u00b5 in P, which may be de.ned formally as the process let x = Meet {w | \u00b5 \n. u . w} in P, that computes the expected meet and binds it to the fresh tuple of variables x. Notice \nthat the set {w | \u00b5 . u . w} is always non-empty (even for an empty \u00b5) as \u00b5 . u.u may be derived by re.exivity, \nfor all \u00b5 and u. We are now ready to illustrate the clauses of the translation. An output in the source \ncalculus is compiled into a corresponding emission: before that, however, the compiled code computes \nthe appropriate representation for the term to be output and collects the cryptographic key required \nto form the packet emitted on the public network. Likewise, an input process is compiled into code that \nruns the read protocol after having collected the appropriate key. A high\u00adlevel match is compiled into \nthe corresponding conditional low\u00adlevel process: the name-equality test in the pi-calculus is realized \nas a corresponding test on the public keys associated with the names involved. In addition, in case the \ntest is successful, the continuation process is given access, via \u00b5, to the new set of capabilities that \ncorresponds to the meet of the two types associated with the names equated in the pi-process. As for \nrestriction, the translation of a high-level restriction generates a corresponding restriction together \nwith a new channel to be associated with the newly generated name. The remaining clauses are de.ned homeomorphically. \nThe de.nition of the translation function is completed by a clause that introduces the top-level compilation \nmap [[ \u00b7 ]] .  5.3 Properties of the implementation The format of the communication servers and the \nstructure of the client code resulting from the translation ensure the following properties: (i) each \nmessage output by a writer will reach at most one reader, and dually, (ii) a legitimate reader client \nwill complete the protocol provided that a type-compatible message on the same channel has been output \nby a writer. Thus, if appropriate channels are allocated for the free names of the high-level processes, \none can prove that any pi-calculus synchronization on a name is simulated by a corresponding reduction \nsequence in the implementation, and conversely that the synchronizations on the channel queues in the \nimplementation re.ect the t-reductions of the source calculus. Given the relative complexity of the implementation, \nthe proof of operational correspondence is elaborate. As a .rst, basic step, one needs a proof that the \nrun-time .ow and management of the cryptographic keys representing the high-level type capabilities \n  Channels WSn . ! .lter (x,z) with n - in if z.. Setn * then n .. x. w - RSn . ! .lter (y,t,z) with \nnr in if z.. Setn * then .lter x@tfrom n . in ! net.{ x} y. Chann . (new n * ,n .) n * .\u00d8. | RSn | WSn \nClients The remaining clauses are de.ned homeomorphically: [[ G .P| Q]] = [[ G .P]] | [[ G .Q]] , [[ \nG .! P]] = ![[ G .P]] . \u00b5 \u00b5\u00b5\u00b5 \u00b5 [[ G .u. v@T. ]] . let u = [[ u]] \u00b5,v = [[ v]] in emit({ v . T} + ) \n\u00b5 \u00b5u w [[ G .u(x@T).P]] . (new k)(let u = [[ u]] in emit({ sk(k),T} + )) | .lter xwith sk(k) in [[ G,x:T.P]] \n\u00b5 \u00b5u \u00b5 r [[ G .[u= v] P; Q]] . if uthen [[ G. v:G(u). u:G(v) .P]] else [[ G .Q]] \u00b5 ID = vID \u00b5[u.v] \u00b5 \n[[ G .(new n: A)P]] . (new n)(Chann | [[ G,n: A.P]] ) \u00b5\u00b5 [[ G .0]] \u00b5 . 0 Top - level translation [ G \n.P]] . [[ G .P]] \u00d8 provides the compiled code with enough capabilities to simulate all of the synchronizations \nof the well-typed source processes. That can be proved by showing that the translation is closed by substitution, \nin the sense made precise below. Given a type environment I, de.ne the term environment corre\u00adsponding \nto I, noted {| I |} , as follows: {| \u00d8 |} = { net/xo} , {| I,a: A|} = {| I |} ,a. A/x where xo is a distinguished \n(arbitrary) variable and x.. dom({| I |} ). Now we can state the desired closure properties for the translation. \nLemma 1 (Substitution Closure). Let G be a closed type environ\u00adment such that G . v: A. Then: [[ G,x:A.P]] \n{ (v. A)/x}~{| G |} [[ G .P{ v/x = Ap } ]] Proof. (Outline) We prove a much stronger closure property, \nshow\u00ading that the treatment of matching ensures the expected correspon\u00addence between static and dynamic \ntype capabilities: [[ G,x:A.P]] \u00b5{ (v. A)/x}= {| G |} [[ G .P{ v/x} ]] \u00b5{v/x} (* ) Here = {| G |} denotes \na congruence relation that relates translated pi-processes that are structurally congruent up to type \nconsistent substitutions of the form: { vi. Ti/xi | G(vi) <: Ti <:G(xi)} . The congruence (* ) may be \nproved by induction on the structure of the compiled process. Then the lemma follows by observing that \n= {| G |} is .ner than ~= Ap,i.e. [[ G .P]] = {| G |} [[ G .Q]] implies = Ap [[ G .P]] ~{| G |} [[ G \n.Q]] . To show the main result of operational correspondence, as in [2], we must rely on the presence \nof noise to prevent traf.c analysis. Given the simple network interface we have assumed, injecting noise \ninto the network is simply accomplished by the process W . ! (new n)! net.{ n} n. which generates in.nitely \nmany copies of in.nitely many secret packets. Now, we complete the de.nition of the computing environ\u00adment \nfor the compiler-generated principals by including a general interface to the network, the noise-generating \nprocess and channel support for the free names shared between the processes and the environment. Y EI[- \n]= -| W | Chann n.dom(I) We have .nally all we need to establish the result of operational correspondence. \nTheorem 2 (Operational Correspondence). Let G and I be two closed type environments such that G <:I. \nThen: ~Ap If P ==. P. then EI[[[ G .P]] ]==. = {| I |} EI[[[ G .P. ]] ]. Conversely, if EI[[[ G .P]] \n]==. K then there exists P. s.t. = Ap P ==. P. and K ~{| I |} EI[[[ G .P. ]] ]. Proof. (Outline). The \nproof of this result, especially the re.ection direction in the second item, is subtle, because the translation \nis not prompt [16]. In fact, one easily sees that it takes several steps for EI[[[ G .P]] ] to be ready \nfor the commit synchronization on the channel queue that corresponds to the high-level synchronization \non the channel. As it turns out, however, these steps are not observ\u00adable and can be factored out in \nthe proof by resorting to a suitable notion of (term-indexed) administrative equivalence, noted A and \nincluded in ~Ap. The de.nition of A draws on a classi.cation of = the reductions of the compiled processes \ninto commitment steps, corresponding to synchronizations on the channel queues, and ad\u00administrative reductions, \ncorresponding to the steps that precede and follow the commitment steps. Then two processes are equated \nby A only if they are behaviorally equivalent and, in addition, they can simulate each other s commitment \ntransitions in a strong way. The relation A can be used to prove the following strong variant of operational \ncorrespondence: t If P -. P. then EI[[[ G .P]] ]=. A {| I |} EI[[[ G .P. ]] ]. t Conversely, assume H \n A {| I |} EI[[[ G .P]] ] and H -. K. t Then either H A {| I |} K, or there exists P. s.t. P -. P. and \nK A {| I |} EI[[[ G .P. ]] ]. Here, the proof of the .rst item (i.e. the preservation direction of the \nresult) follows from Lemma 1 3. For the second item, the 3 More precisely, from a variant of Lemma 1 \nstated in terms of A rather Ap than ~. = The proof of the theorem derives from this intermediate result \nand the fact that A is .ner than ~= Ap .. Theorem 3 (Soundness). Let G,.and Ibe closed type environ\u00adments \ns.t. G,.<:I.If {| I|} |=EI[[[ G.P ]] ]~Ap EI[[[ ..Q]] ], = then I|=P ~p Q. = Proof. This follows by a \nstandard argument from Theorem 2 (cf. [9]). The converse direction of Theorem 3 does not hold. In fact, \nas we noted, the communication protocols presuppose a certain structure associated with names. Indeed, \nfor the names that are statically shared with the context, this structure is easily enforced by allo\u00adcating \nthe corresponding channels as part of the initial computing environment. However, the context may dynamically \ngenerate new names that do not satisfy the expected invariants. Notice, for in\u00adstance, that the client \nof a reader protocol presupposes a legitimate channel on the other end of the protocol and is not protected \nagainst malformed messages received by illegitimate channels: given that, it is easy to .nd a counter-example \nto full abstraction. For instance, in the source calculus we have: a:w |=a(y@rw).y(x@rw).y. x@= p a(y@rw) \nrw.~ This is an instance of the well-known asynchronous pi calculus law ~ a(x).a. x. = 0 , and holds \nin our pi calculus for similar reasons. On the other hand, one easily sees that for I:> Gwe have + aw \n/z .|= EI[[[ G .a(y@rw).y(x@rw).y.x@rw. ]] ] ~Ap EI[[[ G .a(y@rw) ]] ] = In fact, a context may create \nthe legitimate representation of a full\u00ad.edged name b and exchange it over a; the subsequent request \nemit({ sk(k),rw} + ) made by the left process can now be de\u00ad br crypted by the context, which possesses \nthe decryption key b- r ,and thus the left reduct EI[[[ G,b :rw .b(x@rw).b. x@rw. ]] ] can be distinguished \nfrom the null process EI[0 ](i.e., the process environ\u00adment G,b :rw is not compatible with the context \nenvironment I).  6. Enhancing the design full abstraction To recover full abstraction, one must shield \nthe client processes from such undesired interactions. That may be achieved by set\u00adting up the synchronization \nprotocols so as to ensure that all the exchanges occur over system-generated, hence trusted, channels \nwhose decryption keys remain secret. The new implementation in\u00adtroduces a separation between client names, \nused syntactically by context processes and by translated processes to communicate, and corresponding \nserver names generated within the system and asso\u00adciated with system generated channels to be employed \nin the actual protocols for communication. A proxy server maintains an association map between client \nand server names so as to preserve the expected interactions among clients. The map is implemented as \na list of entries of the form (M,m), whose intended invariant is that m is the server counter\u00adpart of \nthe client term M (if the client is a compiled process M will be a name identity such as pub(n), but \nthis may not hold for context generated terms). We call M the index of the entry, and m the target. The \nproxy map is set up to ensure that each index has exactly one target. We represent the public keys used \nby the proxy service by letting k+ . ek(k)and kp - . dk(k), with k a seed not P known to the environment. \nThe read/write protocols follow the same rationale as in the previ\u00adous implementation, with the difference \nthat now the clients must .rst obtain access to the system channel by contacting the proxy server. The \ninteraction between clients and proxy is as follows: the client presents a term to the proxy and the \nproxy replies with the corresponding server name cast at the type of the term received. In case that \nterm is new, the proxy returns a fresh server name for which it also allocates a system channel. On the \nclient side, the protocol is implemented as shown below: link (M,y)in P . (new h)emit({ sk(h),M} + )| \n.lter ywith sk(h)in P k p For the proxy side, the de.nition is found in Table 4. There, we write let \ny =?(x,z)in P else Q for the process that extracts the target t associated with x in z and continues \nas P{ y} ;if x has t/ no target in z, the process continues as Q. The only subtlety in the de.nition \nof the proxy is that upon re\u00adceiving a term that does not occur in the association map, the proxy allocates \ntwo indexes for the same target: one index is the term re\u00adceived from the client, the other is the public \nkey of the target itself. This second association is needed to make linking idempotent, so that linking \na server name always returns the same name. One may wonder how a client could possibly end up requesting \na link for a server name, given that server names (i) originate from the proxy, and (ii) are never passed \non any exchange by the clients. Notice however, that this invariant is only true of the clients that \narise from the translation, not for arbitrary low-level processes of the context. Having given the intuitions, \nthe de.nitions in Table 4 should be easily understood. Notice that the clause for restriction is de.ned \nhomeomorphically in the new implementation, as the creation of the channel is delegated entirely to the \nproxy server. For the case of matching, the translation would look more uniform had we tested equality \non linked names rather than on client names. While this choice has no consequences in the present translation, \nit does create a problem in the distributed implementation we discuss later on in the paper, as in that \ncase names are known at different proxies, under different linked names (see Section 7). We may now strengthen \nthe result of Theorem 3 as desired, pro\u00advided that we plug our processes in the appropriate computing \nen\u00advironment. We .rst de.ne CE[- ]= -| W | Proxy and let the low-level term environments corresponding \nto the high\u00adlevel type environment be extended with a new binding expressing the knowledge of the public \nproxy encryption key k+ needed to P interact with the proxy. Then we have: Theorem 4. Let G,.and Ibe \nclosed type environment such that G,.<:I. Then: I|=P~p= Ap = Qi. {| I|} ,k+/y|=CE[. G.P. ]~CE[. ..Q. \n] P Proof. (Outline). The if direction of the theorem is proved as Theorem 3. The only if direction is \nmore elaborate. We .rst de.ne a (term-indexed) relation R containing pairs of the form (C[. G.P. ],C[. \n..Q. ])where C is a context that results from the interaction of any applied-pi process built around \nthe substi\u00adtution {| I|} ,k+/y, and the computing environment CE.Thenwe P show that R is term-indexed \nbehavioral equivalence by a case anal\u00adysis of the possible interactions between the context Cand the \ncom\u00adpiled code . G.P. and . ..Q. .  7. A distributed implementation While the use of the proxy server \nto protect against misbehaved channels is effective in achieving full abstraction, it is clear that a \nProxy server Pt . ! .lter (k,x,y) with kp - in if y ..Sett * then let s= Typeof (x) in t(z).let y =?(xID \n,z) in t.z.| let z = Cast( y,s) in !net.{z }k. else (new n)Chann | t.z.(xID ; n).(nID ; n).| let z = \nCast(n,s) in !net.{z }k. Proxy . (new t,t * ) Pt | t.\u00d8. | t * .\u00d8. Channels sameasinTable 3 Clients The \nclauses for composition and replication are de.ned homeomorphically . G .u.v@T... \u00b5 . let u = [[ u]]\u00b5,v \n= [[ v]]in link ( u.w,x) in emit({v . T}+ ) \u00b5 w . G . u(x@T).P. \u00b5 . (let u = [[ u]]in link ( u.r,y) \nin (new k) emit({sk(k),T} + )) | .lter xwith sk(k) in . G,x : T.P. \u00b5 \u00b5y r . [u= v] P; Q. \u00b5 . same as \nin Table 3 with [[ \u00b7 ]] replaced by . .\u00b7. . . G .(new n: A)P. \u00b5 . (new n). G,n : A.P. \u00b5 Top-level translation \n. G .P. . . G .P. \u00d8 centralized implementation as the one we just described is hardly realistic. In \nthis section, we discuss a new implementation that distributes the proxy services among different servers. \nThe new solution is based on the idea of partitioning the network in domains each of which administrated \nby a proxy server. To model this partitioning of the network, we extend our high level calculus with \nthe syntactic category of nets, representing compositions of processes labelled by domains labels, and \nde.ned by the following productions: S,T ::= d{P}| S| T | (new n)S | stop Domain labels, ranged over \nby dare drawn from a denumerable set disjoint from the set of names and the set of variables. We let \nfd(S) be the set of domain labels in S. We emphasize that domain labels are not names, and are never \nexchanged over channels, nor are they created dynamically by a restriction. The typing and dynamics of \nnets arise in the simples possible way from the corresponding notions de.ned for processes. The two core \nrules are as follows: (TYPING) (DYNAMICS) G . P P a-. Q G . d{P} d{P} a-. d{Q} As a result, domains \nhave no impact on the dynamics and/or the typing of the high-level calculus: indeed, they serve a different \npur\u00adpose, namely to help devise the association of processes to proxies in the implementation. Notice, \nin particular, that the same (chan\u00adnel) name may be known at different domains: in the implementa\u00adtion, \nthis will correspond to the name being represented by differ\u00adent channels, located at the different domains \nat which the name is known. In the syntax of nets we tacitly assume that each domain label occurs at \nmost once. This involves no loss of generality, as the dynamics of the net d{P1}| d{P2} is just the same \nas that of the net d{P1 | P2}. Similarly, (new n)d{P} is the same as d{(new n)P}. Observational Equivalence \nThe de.nition of observational equiv\u00adalence for nets is inherited from that of processes. There is an \nim\u00adportant difference, however, in the notion of contextuality, in that a context may not include new \ndomains, but only processes be\u00adlonging to existing domains. This is ensured by the side condition fd(U) \n. fd(S,T) in the de.nition below, and constitutes the key assumption for our distributed implementation: \nnamely, we do not trust domains and proxy servers generated by the environment. While this is a somewhat \nstrong assumption, on the other hand it appears to be realistic: notice, in fact, that the procedure \nof adding a domain to a network in real-world scenarios requires physical authentication, rather than \nnetwork protocols. De.nition 8 (Contextuality for Nets). A type-indexed relation R over nets is contextual \nwhenever I . SRT and I . U and fd(U) . fd(S,T) implies I . (S| U)R(T | U)  I . SRT implies I,a : A. \nSRT  I,a : A. SRT implies I . ((new a: A)S)R((new a: A)T)  The de.nition of behavioral equivalence \nfor nets, noted again ~p , = arises now as expected, as the largest type-indexed equivalence relation \nwhich is contextual (in the sense above), barb preserving and reduction closed. The new implementation \nEach domain of a high-level net corre\u00adsponds to a domain manager, which manages the channels it has created \nand acts as a proxy for the processes of the domain. The processes of a domain, in turn, are instructed \nto send their requests to the proxy associated with their domain. Since different proxies may have different \nentries for the same client name (remember that a name is possibly known in more domains), more channels \nservers may correspond to the same pi-calculus name. The domain man\u00adagers must therefore mask the presence \nof multiple queues located at the distributed channels associated to the same client name: that, in turn, \nis based on a further service provided by domain managers to to gain access to fellow proxies. We represent \nthe public keys used to support the proxy service in each domain manager by means of a one-way constructor \np,and de.ne dp + . ek(p(d)) and dp - . dk(p(n)); these keys corre\u00adsponds to the keys k+,k- utilized in \nthe centralized translation. PP Further, we use an one-way constructor q to represent the public keys \nused by the queue service for a domain d: dq + . ek(q(d)) and dq - . dk(q(d)) We assume that domain managers \nare con\u00adnected via secure links, represented by a shared key sk(kD) gener\u00adated from the private name \nkD. Finally, we introduce the following two bits of new notation: Proxy Service Pd q,t . ! .lter (k,x,y)with \ndp - in if y .. Sett * then let s= Typeof (x)in t(z).let y =?(xID ,y)in t.z.| let z = Cast( y,s)in !net.{z \n}k. else (new n)Chann[q(X).(q.X.| .kd.X ! n .(w).emit({xID ,w}kd ))] | t.z.(xID ;n).(nID ;n).| let z \n= Cast(n,s)in !net.{z }k. Queue Service Qd . ! .lter (x,s,y)with d- in if y .. Setq * then t(z).(t.z.| \nq,t q let y =?(x,z)in emit({s} + )else y w q(X).(q.X.| Choosekd.X in emit({x,s}kd )) Domain Service \nDd . emit({d+}sk(kD))| ! .lter (x,c)with sk(kD)in if c.. Setl* then q(y).q.y :: x. q,l q Domain Manager \n* ** M d . (new t,t ,q,q ,l )Pd | Dd q,t | Qq,t d q,l | t.\u00d8. | t * .\u00d8. | q.\u00d8. | q * .\u00d8. | l * .\u00d8. Translation \nof nets the clauses for parallel composition and restriction are homeomorphic (= . G.P. d (G.d{P} ) \n\u00b5 Md |.\u00b5 Channels asin Table 3 Clients as in Table 4, with all de.nitions now parametrized on d. Top-level \ntranslation ((G.S) \u00d8 (G.S) . ( Chann[P] indicates the process (new n * ,n .) n * .\u00d8. | RSn | WSn | P,that \nis Chann augmented with a further process P  we adapt the notation for links is extended as expected, \nwith a parameter corresponding to the assigned proxy:  linkd (M,y)in P . (new k)emit({sk(k),M}+ )| .lter \nywith sk(k)in P d p The new implementation is given in Table 5. For each domain d, the domain manager \nconsists of three threads Pd q,t, Dd q,t, Qd q,l responsible for the proxy, queue and domain services, \nrespectively. The three threads share a channel q collecting the public keys that grant access to fellow \nproxies. The domain service Dd q,l is responsible for updating this queue with newly acquired domain \nidentities, and for publishing the public queue key of the proxy associated to the domain d. The proxy \nand the queue service also share the table of binding client and server names stored on the private channel \nt. The new de.nition of the proxy service extends the one given in Table 4, by including a collection \nof forwarders. Each of the forwarders, tries to extract a message from the channel queue n . and sends \nit off to one of the domain managers known at the time the channel n was created. The queue service Qd \nwaits for the packets sent q,t by the forwarders and by other domain managers. The server re\u00adtrieves \nthe name index and checks whether the entry is associated to a channel. If it is, the message is sent \nto the queue of the associated channel. Otherwise both the name index and the message are non\u00addeterministically \nsent to some of the known domain managers. The non-deterministic choice Choosek.X in P may be implemented \nin the standard way, namely in terms of a non-deterministic synchro\u00adnization on a private name: (new \nn)n.. | .k.Xn().P. The translation of nets is compositional, and does not rely on any pre-existing infrastructure \nfor communications, as now the domain managers are dynamically generated within the translation; as in \nprevious implementations we assume the presence of noise on the communication interface. We extend the \nlow-level term environment with the public encryption keys of the proxy managers corresponding to the \nhigh-level free domains: {| d1,...,dn |} . ++ {d1p /x,...,dn /z}. We .nally obtain: p Theorem 5. Let \nG,. and I be closed type environment such that G,. <:I. Then: I|== p= S~T if and only if {| I|},{| fd(S,T)|} \n|W | (new kD)((G.S) ~Ap W | (new kD)( = (..T ) .  8. Conclusion We have developed a secure implementation \nof a typed pi calcu\u00adlus, in which the access to communication channels is regulated by capability types. \nThe implementation draws on a representation of the typed capabilities in the high-level calculus as \nterm capabilities protected by encryption keys only known to the intended receivers. The implementation \nrelies on a proxy service to protect against malformed messages from the environment. This is achieved \nby generating certi.ed names (and associated channels) to represent the context-generated names within \nthe system. We have also de\u00adveloped a distributed implementation in which the certi.cation ser\u00advice is \nimplemented by a set of distributed proxies. Being fully compositional, the distributed implementation \nappears to be ade\u00adquate for open-ended networks. The only limitation in this respect is represented by \nour current assumption that all proxies that par\u00adticipate in the synchronization protocols be fully trusted. \nWhile a certain degree of trust appears necessary to achieve a secure imple\u00admentation, it would be desirable \nto have some form of guarantees also in the presence of malicious proxies. Achieving that seems fea\u00adOur \ntranslation has several analogies with previous attempts in the literature [2, 12]. In [2], the authors \nprovide a fully abstract imple\u00admentation of the join calculus into a dialect of the calculus equipped \nwith cryptographic primitives. The located nature of channels in the join calculus makes it possible \nto rely on a very compact represen\u00adtation in which a communication channel a is associated with a low-level \nkey name a +, and to protect communications using an asymmetric cryptosystem. In [12] a fully abstract \nimplementation of the pi-calculus without matching into the join calculus is given; like ours, their \ntranslation relies both on the presence of proxy pairs of internal and external names, and on relays \namong the pairs com\u00adponents. By composing the encodings [12] and [2] one can securely implement the untyped \npi-calculus without matching in a join cal\u00adculus equipped with cryptographic primitives. However, it \nis not clear how to implement matching in a join calculus extended with a name-matching construct [11] \nfollowing this approach. In fact, as noted in [19], the ability of test syntactic equality on names inval\u00adidates \nthe semantic equalities on names provided by the equators [15] used in [12] to merge internal and external \nnames.  Acknowledgments The name representation based on self-signed certi.cates was sug\u00adgested to us \nby Cedric Fournet. We would like to thank him for his insightful comments and constructive criticism \non a previous draft of the paper. This work has been partially supported by M.I.U.R. (Italian Min\u00adistry \nof Education, University and Research) under contract n. 2005015785. References [1] M. Abadi and C. \nFournet. Mobile values, new names, and secure communication. In Proc. of the 28th ACM Symposium on Principles \nof Programming Languages (POPL 01), pages 104 115. ACM Press, 2001. [2] M. Abadi, C. Fournet, and G. \nGonthier. Secure implementation of channel abstractions. Information and Computation, 174(1):37 83, April \n2002. [3] Mart\u00b4in Abadi. Protection in programming-language translations. In Proc. of ICALP 98, pages \n868 883, 1998. [4] Mart\u00b4in Abadi and Bruno Blanchet. Analyzing security protocols with secrecy types \nand logic programs. J. ACM, 52(1):102 146, 2005. [5] Michael Baldamus, Joachim Parrow, and Bj\u00a8orn Victor. \nA fully abstract encoding of the p-calculus with data terms. In Proc. of ICALP 05, pages 1202 1213, 2005. \n[6] Bruno Blanchet. From Secrecy to Authenticity in Security Protocols. In Manuel Hermenegildo and Germ\u00b4an \nPuebla, editors, 9th International Static Analysis Symposium (SAS 02), volume 2477 of Lecture Notes on \nComputer Science, pages 342 359, Madrid, Spain, September 2002. Springer Verlag. [7] Bruno Blanchet. \nAutomatic Proof of Strong Secrecy for Security Protocols. In IEEE Symposium on Security and Privacy, \npages 86 100, Oakland, California, May 2004. [8] M. Boreale, R. De Nicola, and R. Pugliese. Proof techniques \nfor cryptographic processes. SIAM Journal on Computing, 31(3):947 986, 2001. [9] Michele Boreale. On \nthe expressiveness of internal mobility in name\u00adpassing calculi. Theor. Comput. Sci., 195(2):205 226, \n1998. [10] M. Bugliesi and M. Giunti. Typed processes in untyped contexts. In Rocco Nicola and Davide \nSangiorgi, editors, Proc. of TGC 2005, Symposium on Trustworthy Global Computing, volume 3705 of Lecture \nNotes on Computer Science, pages 19 32. Springer-Verlag, 2005. [11] C\u00b4edric Fournet and Cosimo Laneve. \nBisimulations in the join\u00adcalculus. Theor. Comput. Sci., 266(1-2):569 603, 2001. [12] C\u00b4edric Fournet. \nThe Join-Calculus: a Calculus for Distributed Mobile Programming. PhD thesis, Ecole Polytechnique, Palaiseau., \nNovember 1998. Also published by INRIA, TU-0556. [13] Marco Giunti. Secure Implementation of Typed Channel \nAbstractions. PhD thesis, Universit`a di Venezia, 2007. Forthcoming. [14] M. Hennessy and J. Rathke. \nTyped behavioral equivalences for processes in the presence of subtyping. Mathematical Structures in \nComputer Science, 14(5):651 684, 2003. [15] Kohei Honda and Nobuko Yoshida. On reduction-based process \nsemantics. Theor. Comput. Sci., 151(2):437 486, 1995. [16] Uwe Nestmann and Benjamin C. Pierce. Decoding \nchoice encodings. Inf. Comput., 163(1):1 59, 2000. [17] B. Pierce and D. Sangiorgi. Typing and subtyping \nfor mobile processes. Mathematical Structures in Computer Science, 6(5), 1996. [18] Benjamin C. Pierce \nand Davide Sangiorgi. Behavioral equivalence in the polymorphic pi-calculus. J. ACM, 47(3):531 584, 2000. \n[19] D. Sangiorgi and D. Walker. The p-calculus A theory of mobile processes. Cambridge, 2001.  \n\t\t\t", "proc_id": "1190216", "abstract": "The challenges hidden in the implementation of high-level process calculi into low-level environments are well understood [3]. This paper develops a secure implementation of a typed pi calculus, in which capability types are employed to realize the policies for the access to communication channels. Our implementation compiles high-level processes of the pi-calculus into low-level principals of a cryptographic process calculus based on the applied-pi calculus [1]. In this translation, the high-level type capabilities are implemented as term capabilities protected by encryption keys only known to the intended receivers. As such, the implementation is effective even when the compiled, low-level principals are deployed in open contexts for which no assumption on trust and behavior may be made. Our technique and results draw on, and extend, previous work on secure implementation of channel abstractions in a dialect of the join calculus [2]. In particular, our translation preserves the forward secrecy of communications in a calculus that includes matching and supports the dynamic exchange of write <i>and</i> read access-rights among processes. We establish the adequacy and full abstraction of the implementation by contrasting the untyped equivalences of the low-level cryptographic calculus, with the typed equivalences of the high-level source calculus.", "authors": [{"name": "Michele Bugliesi", "author_profile_id": "81100363070", "affiliation": "Universit&#224; Ca Foscari, Venezia, Italy", "person_id": "PP14129639", "email_address": "", "orcid_id": ""}, {"name": "Marco Giunti", "author_profile_id": "81100219430", "affiliation": "Universit&#224; Ca Foscari, Venezia, Italy", "person_id": "PP24042847", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190253", "year": "2007", "article_id": "1190253", "conference": "POPL", "title": "Secure implementations of typed channel abstractions", "url": "http://dl.acm.org/citation.cfm?id=1190253"}