{"article_publication_date": "01-17-2007", "fulltext": "\n Semantics of Static Pointcuts in AspectJ Pavel Avgustinov Elnar Hajiyev Neil Ongkingco Oege de Moor \nDamien Sereni Julian Tibble Mathieu Verbaere Programming Tools Group, Oxford University Computing Laboratory, \nWolfson Building, Parks Road, Oxford OX1 3QD, UK {pavel.avgustinov,elnar.hajiyev,neil.ongkingco,oege.de.moor,damien.sereni,julian.tibble,mathieu.verbaere}@comlab.ox.ac.uk \nAbstract In aspect-oriented programming, one can intercept events by writ\u00ading patterns called pointcuts. \nThe pointcut language of the most popular aspect-oriented programming language, AspectJ, allows the expression \nof highly complex properties of the static program structure. We present the .rst rigorous semantics \nof the AspectJ point\u00adcut language, by translating static patterns into safe (i.e. range\u00adrestricted and \nstrati.ed) Datalog queries. Safe Datalog is a logic language like Prolog, but it does not have data structures; \ncon\u00adsequently it has a straightforward least .xpoint semantics and all queries terminate. The translation \nfrom pointcuts to safe Datalog consists of a set of simple conditional rewrite rules, implemented using \nthe Stratego system. The resulting queries are themselves executable with the CodeQuest system. We present \nexperiments indicating that direct execution of our semantics is not prohibitively expensive. Categories \nand Subject Descriptors F.3 [Logics and Meanings of Programs]: Semantics of Programming Languages General \nTerms Design, Experimentation, Languages Keywords Aspect-oriented programming, pointcuts, logic pro\u00adgramming, \nDatalog, term rewriting 1. Introduction Aspect-oriented programming enables one to intercept events at \nruntime by writing patterns called pointcuts. The intercepted events are named joinpoints. Whenever a \npointcut matches a joinpoint, extra code (called advice) is run. The most popular language that embodies \nthese ideas is AspectJ, an extension of Java [28]; there is also a modern aspect-oriented version of \nC#, named Eos-U [36]. Typical applications include runtime veri.cation of system-wide invariants, the \nimplementation of authentication and authorisation mechanisms, as well as various caching and pooling \nstrategies [30]. With the growing popularity of aspect-orientation, numerous researchers have started \nto investigate the semantics of aspect\u00adoriented languages (e.g. [2, 3, 10, 13, 14, 24, 26, 27, 32, 40, \n43, 45 47]). All such studies have focused on the operational semantics of advice, taking a very simple \npointcut language. For instance, in [43], the core language identi.es program points for instrumenta\u00adtion \nthrough explicit labels, and pointcuts are sets of such labels. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. \nCopyright c . 2007 ACM 1-59593-575-4/07/0001. . . $5.00. Yet in AspectJ itself, the pointcut language \nis very complex, allowing the programmer to capture intricate properties related to the static structure \nof the program. This complexity is a continuing source of serious bugs in AspectJ compilers (cf. the \ndiscussion in Section 6). Nevertheless the AspectJ user community continues to make requests for a yet \nmore expressive pattern language, only exacerbating the problem. In this paper, we bridge the gap between \nexisting operational semantics of advice and current practice, by giving a complete semantics of the \nstatic matching of AspectJ 1.2.1 pointcuts. In particular, our semantics can be used to reduce complex \npointcuts to sets of labels that refer to source locations, and then the dynamic part of the story is \ntold by an operational semantics in the style of [43]. Our semantics consists of a translation from AspectJ \npointcuts into Datalog queries over relations de.ned in the object program. Datalog is a logic query \nlanguage that originated in the theoretical database community [17]. We restrict ourselves to the safe \nfrag\u00adment that has a straightforward least-.xpoint semantics; further\u00admore all safe Datalog queries terminate. \nThe translation from point\u00adcuts to Datalog takes the form of about 90 conditional rewrite rules. The \nfull de.nition is thus quite short and elegant. It is available for download as an accompanying technical \nreport [6]. This semantics is put to work in three ways. First, it serves as a crisp de.nition to discuss \ntricky points in the language design, and has enabled us to lay bare several long-standing bugs in As\u00adpectJ \nimplementations. Second, the semantics is executable, and we present comparative experiments with an \nindustrial-strength com\u00adpiler to show the costs of directly executing the semantics are not prohibitive. \nFinally, our semantics provides a framework for the de\u00adsign and discussion of further language extensions \nthat the AspectJ user community is clamouring for [7, 8, 11, 23]. It is not possible to prove a correspondence \nresult with previous semantics, as the only existing de.nition of AspectJ is an informal description \non the web [4]. However, our testing with respect to the standard implementation, and subsequent discussion \nof discrepan\u00adcies with the AspectJ designers, provide ample con.dence that our formal semantics captures \nthe intended meaning. Many previous works have suggested the use of logic program\u00adming for writing pointcuts \nin aspect-oriented programming, but in\u00advariably they use Prolog [16, 20, 29]. In the present setting, \nthat would be inappropriate because the semantics of Prolog itself is quite complex, even with tabled \nresolution to give better termina\u00adtion behaviour. Furthermore, we tried to run our experiments with (a \ntabled variant of) Prolog, but found that execution times prohibit its application in practice. In summary, \nthis paper makes the following contributions: The identi.cation of safe Datalog as a suitable intermediate \nform for pointcuts in aspect-oriented programming. The use of term rewriting to reduce complex pattern-based \npointcuts to Datalog queries.  The .rst rigorous semantics of the AspectJ 1.2.1 pointcut lan\u00adguage. \n Experimental evidence that it is feasible to directly execute our semantics, on AspectJ programs of \nup to 100KSLOC.  The structure of the paper is as follows. In Section 2, we pro\u00advide a brief introduction \nto AspectJ, focussing on the pointcut language. We then proceed to discuss existing semantics for the \naspect-oriented paradigm in Section 3. In particular, we enunci\u00adate the difference between static and \ndynamic pointcuts. Dynamic pointcuts refer to runtime properties such as the call stack they are matched \nat runtime, and their semantics is by now well un\u00adderstood (e.g. [43, 45]). By contrast, static pointcuts \nare matched against the static structure of the program, and they are the focus of the present paper. \nNext, we provide a brief introduction to safe Dat\u00adalog in Section 4. We then explain informally how static \npointcuts can be mapped to Datalog queries in Section 5. The heart of the paper is Section 6, which shows \nhow a simple set of rewrite rules suf.ces to translate AspectJ s static pointcuts into Datalog. Rather \nthan presenting a shallow overview of the complete semantics, we detail the most complex issues in AspectJ \ns design where a rigorous approach is indispensable. In Section 7 it is demonstrated that this semantics \ndirectly leads to a viable implementation strategy. We then brie.y speculate on the use of Datalog to \ndirectly express new forms of pointcut in Section 8. A brief roadmap of related work is provided in Section \n9 before concluding in Section 10.  2. AspectJ pointcuts AspectJ is a variant of Java, extended with \naspect-oriented features [28]. These features allow a programmer to write a single piece of code that \nconsistently affects the behaviour of multiple modules in a program. The novel contribution of aspect-oriented \nlanguages, which was not present in previous work on class composition (e.g. [39]), is known as pointcut \nand advice . A pointcut is a predicate over events that occur during the execution of a program. These \nevents (called joinpoints) are composite they have duration and may be nested. A piece of advice is \na block of code that is executed when a pointcut matches a joinpoint. Advice can be run before the matched \njoinpoint, after it, or instead of it. We will introduce the pointcut notation of AspectJ with the aid \nof an example, taken from the textbook by Laddad [30]. The task in hand is to automatically enforce the \nfollowing requirement of the Swing GUI library: Once a component is visible, the event-dispatching thread \n(sometimes called the AWT thread) is the only thread that can safely access or update the state of the \nrealized com\u00adponent. The rule exempts certain methods, allowing them to be safely called from any thread. \n[30] Laddad s solution works by intercepting calls to methods that would update the state of a component \nfrom the wrong thread, and then queueing them for execution in the event-dispatching thread. The pointcut \nroutedMethods, shown in Figure 1, matches calls to just those methods that would violate the invariant. \nIt relies on .ve other programmer-de.ned named pointcuts each one is de.ned in terms of pointcut primitives, \nusing the Boolean connectives and (&#38;&#38;), or (||), and not (!). Three built-in primitives are also \nused: if takes a boolean-valued Java expression as an argument; it matches a joinpoint if the expression \nevaluates to true before (or after, depending on the kind of advice) the joinpoint occurs. 1 pointcut \nviewMethodCalls() : 2 call(* javax..JComponent+.*(..)); 3 4 pointcut modelMethodCalls() : 5 call(* javax..*Model+.*(..)) \n6 || call(* javax.swing.text.Document+.*(..)); 7 8 pointcut uiMethodCalls() : 9 viewMethodCalls() || \nmodelMethodCalls(); 10 11 pointcut threadSafeCalls() : 12 call(void JComponent.revalidate()) 13 || call(void \nJComponent.repaint(..)) 14 || call(void add*Listener(EventListener)) 15 || call(void remove*Listener(EventListener)); \n16 17 pointcut excludedJoinpoints() : 18 threadSafeCalls() 19 || within(SwingThreadSafetyAspect) 20 || \nif(EventQueue.isDispatchThread()); 21 22 pointcut routedMethods() : 23 uiMethodCalls() &#38;&#38; !excludedJoinpoints(); \nFigure 1. Pointcuts for Swing thread-safety enforcement within takes a pattern ranging over types as \nan argument; it matches any joinpoint that was caused by executing code lexi\u00ad cally within a type that \nmatches the pattern. call also takes a pattern as an argument, which ranges over method or constructor \nsignatures; it matches any call-joinpoint to a method or constructor that has a signature matching the \npattern. There are several wildcards used in AspectJ patterns. The .rst is *: it matches any series of \ncharacters that can appear in a Java identi.er (not . ). So, for example, Line 14 of Figure 1 matches \ncall-joinpoints to any method with a name that starts with add , ends with Listener , and takes a single \nargument of type EventListener. A + wildcard can only appear in a pattern that ranges over types. It \nmeans match any subtype . It appears in Line 2 of Figure 1, which matches any call to a method on a type \nmatching the pattern javax..JComponent or any subtype of such a type. The wildcard .. matches any sequence \nof full-stops and Java identi.ers that begins and ends with a full-stop. For example, javax..*Model matches \njavax.swing.AbstractListModel , but it would not if the pattern were javax..Model. Note that the .. wildcard \nhas a special meaning when used in the formal parameter list of a method pattern, as seen at the end \nof Line 2 in that case it matches an arbitrary number of parameters of arbitrary type.  3. Existing \nAOP semantics There is a large amount of work on the semantics of aspect-oriented programming, e.g. [2, \n3, 10, 13, 14, 24, 26, 27, 32, 40, 43, 45 47]. None of these works involve a pointcut language that approaches \nthe complexity of the pointcut language of AspectJ. We contend, however, that it is possible to understand \nthe semantics of AspectJ by following the framework introduced in [43]. A key idea of [43] is to make \nthe semantics a two-step process, involving a surface language and a core language. The surface lan\u00adguage \nin our case is AspectJ. It has the rich notation for pointcuts that allows programmers to alter the behaviour \nof the mainline pro\u00adgram without modifying the program text directly. That property is sometimes called \nobliviousness in the literature on aspect-oriented programming. The core language, by contrast, augments \nthe main\u00adline program with explicit labelled instrumentation points. Point\u00ad 1 public class X { 2 void \nf1(int n) {} 3 void f2(int n) {f1(n); } 4 void f3(int n) {f2(n); } 5 6 public static void main(String[] \nargs) { 7 Xx= new X(); 8 x.f3(0); 9 x.f2(1); 10 } 11 } 12 13 aspect A { 14 pointcut a(int n) : 15 call(*f*(..)) \n16 &#38;&#38; args(n) 17 &#38;&#38; c.owbelow(execution(*f3(..))); 18 19 before(int n) : a(n) { 20 System.out.println(thisJoinPoint \n+ : n= +n); 21 } 22 } Figure 2. Example AspectJ program. cuts refer directly to sets of such instrumentation \npoints. The op\u00aderational semantics of the core language observes the execution of labelled instrumentation \npoints and executes advice where labels in pointcuts match labels at runtime. In most of the papers that \nhave built on [43], the translation from surface to core is quite simple [13, 14]. Wang et al. consider \na slightly more complex translation, which involves doing more of the instrumentation at compile-time \n[46, 47]. The current paper continues that trend by offering a translation from the AspectJ surface language \nto a suitable core language, replacing the rich pointcuts by labelled instrumentation points. We do not \noffer an operational semantics with it, as that would require augmenting a complete operational semantics \nof Java. In the literature on compiling aspect-oriented programs [22, 33], instrumentation points in \nthe static program are called shadows, whereas their runtime counterparts are named joinpoints.We shall \nfollow that terminology below. To illustrate, consider the AspectJ program in Figure 2. It con\u00adtains \na pointcut de.nition (Lines 14 17), and a piece of advice (ex\u00adtra code) that is triggered by that pointcut \n(Lines 19 21). The point\u00adcut a(n) makes use of the c.owbelow(p) primitive: conceptually this matches \nif a joinpoint is properly nested inside any joinpoint that matches p. Pointcut primitives such as c.owbelow \nare inherently dy\u00adnamic, and in general they cannot be resolved by static matching of shadows (in the \nexample, the call to f1 from f2 is advised or not depending on whether f2 was called from f3). The same \nholds true for args, which exposes the actual value of an argument at runtime. Apart from these two primitives, \nthe pointcuts are entirely static and could thus be replaced by sets of shadows in the program. This \nis illustrated in the translated program in Figure 3. Here the main\u00adline program has been augmented with \nexplicit labels for shadows (there are actually more shadows than shown here, for instance for class \ninitialisation). Accordingly, the static pointcuts have been re\u00adplaced by sets of labels. The purpose \nof the remainder of the paper is to pin down the process by which AspectJ pointcuts are reduced to this \nform. We shall show how each static pointcut is de.ned in terms of a relational query; by running those \nqueries on a mainline program, one obtains the sets of labels as in Figure 3. 1 public class X { 2 void \nf1(int n) {L1 : {}} 3 void f2(int n) {L2 : {L3 : {f1(n);}}} 4 void f3(int n) {L4 : {L5 : {f2(n);}}} 5 \n 6 public static void main(String[] args) { 7 L6: {Xx =(L7 : {new X()}); 8 L8: {x.f3(0)}; 9 L9: {x.f2(1)}; \n} 10 } 11 } 12 13 aspect A { 14 pointcut a(int n) : 15 label(L3,L5,L8,L9) 16 &#38;&#38; args(n) 17 &#38;&#38; \nc.owbelow(label(L4)); 18 19 before(int n) : a(n) { 20 System.out.println(thisJoinPoint + : n= +n); 21 \n} 22 } Figure 3. Translated program.  4. Datalog We shall use the Datalog query language to express \nthe semantics of AspectJ pointcuts. Datalog is similar to Prolog, and syntactically is a subset of Prolog, \nbut excludes the ability to construct new data type values such as lists. While we give a brief introduction \nto Datalog, we refer to the reader to [17] for more details. A Datalog program is a set of clauses (backward \nimplications) of the form: p(X1,...,Xn) .q1(Y1,...,Ym1 ),...,qk(Y1,...,Ymk ). where each Xi is a variable, \nand each Yj is either a variable or a constant. Each qj is a positive or negated occurrence of either \na predicate or a test such as X<Y. A variable occurs positively in a clause if it occurs in a positive \npredicate on the right-hand side of the clause, but not if it only occurs in a test. Intuitively, a test \nsuch as X<Y cannot be used to generate values of X and Y making the test true, unlike a predicate p(X,Y). \nThe semantics of Datalog programs, at least in the absence of negation, are straightforward. Each predicate \np(X1,...,Xn) de.nes an n-ary relation, and clauses are interpreted as inclusions between relations. The \nmeaning of the program is then the least solution of this set of inclusions. For instance, the Datalog \nprogram p(X) . p(X), while non-terminating as a Prolog program, is a bona .de de.nition of the empty \nrelation in Datalog. 4.1 Safe Datalog The use of negation in Datalog programs is more problematic, as \nnegation is not a monotonic operator, and so the .xpoint need not exist. Concretely, a program such as \np(X) .\u00acp(X) does not de.ne a relation p, and indeed p(X) is neither true nor false for any X. Safe Datalog \nis a subset of Datalog that provides a suf.cient (but not necessary) condition that guarantees that every \nprogram can be evaluated to a set of relations. Safe Datalog imposes two conditions: range restriction \nand strati.cation. Range Restriction In a range-restricted Datalog program, each variable in the head \n(i.e. left-hand side) of a clause must appear positively on the right-hand side. Furthermore, each variable \non the right-hand side must appear positively at least once. This restric\u00adtion rules out programs such \nas p(X,Y) . q(X),as Y is left unconstrained. Programs such as: r(X) .\u00acq(X),regexpmatch( a.* ,X). where \nregexpmatch(P,X) is a regular expression pattern match\u00ading test, are likewise disallowed. Both the above \nqueries are un\u00addesirable as the relations de.ned cannot directly be computed: the p(X,Y) relation may \nbe in.nite (any value of Y can be used), while evaluating the r(X) relation may require evaluating in.nitely \nmany regular expression matches. Strati.cation Furthermore, in a strati.ed Datalog program, nega\u00adtion \nmay not be used in recursive cycles. A program is strati.ed if there is some strict partial order < on \npredicates such that when\u00adever pdepends negatively on q,then p>q. That is, a predicate may never depend \nnegatively on itself. This prohibits such programs as p(X) . q(X),\u00acp(X). Any safe Datalog program de.nes \na set of relations as the least .xpoint of the recursive inclusions in the program. Furthermore, this \nsolution may be effectively computed, and ef.cient algorithms are known for evaluating safe Datalog programs. \nFinally, all re\u00adlations evaluated are .nite, provided the primitive predicates (un\u00adde.ned predicates \nproviding access to the database) denote .nite relations. These properties of safe Datalog are highly \ndesirable in our setting. First, Datalog has a clear and straightforward semantics, unlike Prolog, in \nwhich the operational and declarative semantics do not coincide. This guarantees that de.ning the semantics \nof AspectJ pointcuts by translation to Datalog is valid. Beyond pure semantics, the ef.ciency of Datalog \nallows our translated AspectJ pointcuts to be evaluated leading to a directly implementable semantics. \n 4.2 Extensions For convenience, we shall make use of a number of extensions to pure Datalog. These are \njust syntactic sugar, and may be eliminated in a translation back to pure Datalog (which we omit for \nspace reasons). We use a variant of Datalog in which each variable is annotated with a type. In any clause, \nthe type of the variables de.ned in the head are given explicitly, as follows: p(X1 : p1,...,Xn : pn) \n. E. where the pi are predicates and E is any Datalog expression. This is equivalent to the untyped clause: \np(X1,...,Xn) . p1(X1),...,pn(Xn),E. Furthermore, we insist that any free variable appearing on the right-hand \nside be introduced by an existential quanti.er, again giving its type. We use the syntax X: p E to represent \nthe existential quanti.cation .X(p(X) . E). A typed Datalog program is necessarily range-restricted. \n Datalog expressions can use negation arbitrarily, so that not(E) is an expression whenever E is.  We \nallow the use of disjunction, represented by a semicolon.   5. Pointcuts are queries We now aim to \nshow how pointcuts in AspectJ can be regarded as Datalog queries over a relational representation of \nthe program. The correspondence presented here is informal, and it is only intended to help the reader \nbuild an intuition before diving into the formal details in the next section. Consider the example translation \nfrom Figure 2 to Figure 3. The program of Figure 2 is stored as a set of primitive relations. That set \nincludes, for example, a relation for recording method declarations: methodDecl(MethodId,Name,Sig,DeclaringType,ReturnType). \nThe .rst .eld is the identi.er: this can be thought of as the identity of the corresponding node in the \nabstract syntax tree. The primitive relations also record shadows in the program: these are the labels \nshown in Figure 3. For instance, we have a relation callShadow(ShadowId,Method,RecvType) This relates \nthe identity of a shadow (labelled instrumentation points like L1, L2 in Figure 3) to a method called \nat that shadow, and the static type of the receiver. Furthermore, there is an extensional relation that \nrecords method bodies, as these are also joinpoints in AspectJ: executionShadow(ShadowId,Method) We are \nnow ready to express the static pointcuts of Figure 2 as Datalog predicates. We .rst consider call(* \nf*(..)) This pointcut corresponds to the following Datalog predicate: pc1(S : shadow) :- M : method N \n: name callShadow(S,M, ), methodDecl(M,N, , , ), regexpmatch( f.* ,N) . Evaluating pc1 will yield the \nfollowing set of solutions for S: {L3,L5,L8,L9 } precisely the translation in Figure 3. The other static \npointcut in Figure 2 is execution(* f3(..)) It is easytogiveana\u00a8ive translation into Datalog, namely \npc2(S : shadow) :- M : method N : name executionShadow(S,M), methodDecl(M,N, , , ), regexpmatch( f3 ,N) \n. This time evaluation yields only one solution, namely S: { L4 }. In order to extend this intuitive \ncorrespondence to a full for\u00admal semantics, we need to decide exactly on the set of primitive relations. \nFurthermore, the above translation is na\u00a8ive, because in fact we need to take into account where a pointcut \nis declared, as the context determines how names in the pointcut are resolved. For that reason, in the \nformal semantics, pc1 and pc2 would need to take an additional parameter.  6. Semantics of static pointcuts \n 6.1 Overall structure As described above, our goal is to determine, for each static point\u00adcut, which \nset of labelled instrumentation points it denotes, as this will pin down its semantics. We achieve this \nby giving a set of rewrite rules that translate the static pointcuts in AspectJ to Dat\u00adalog predicates. \nThe resulting predicate corresponding to a given pointcut has two free variables the .rst denotes the \nJava type in which the pointcut is being evaluated (this parameter is used to handle name lookup), and \nthe second ranges over shadow labels; the values of that variable making the predicate true are precisely \nthose labels which the pointcut denotes. The rewriting rules are split up into contexts such as point\u00adcuts, \nmethod patterns and name patterns. For each such context we introduce a different term constructor (aj2dl \nfor pointcuts, methconstrpat2dl for method patterns, etc.), and the purpose of the rewriting process \nis to eliminate these constructors. When they have all been eliminated, the translation process is complete. \nIn our rules we adopt the conventions that both left-and right\u00adhand side of the rewrite rule are enclosed \nin brackets ([ ..] )to make reading easier. Identi.ers shown in bold font are term constructors, [ aj2dl( \npc1 &#38;&#38; pc2,C, S) ] . [ ( aj2dl(pc1,C, S), aj2dl( pc2,C, S)) ] [ aj2dl( pc1 || pc2,C, S) ] . [ \n( aj2dl(pc1, C, S)); ( aj2dl( pc2,C, S)) ] [ aj2dl(! pc,C, S) ] . [ not(aj2dl( pc,C, S)) ] Figure 4. \nRewrite rules for Boolean combinations of pointcuts identi.ers in italics are metavariables that capture \nsubexpressions of the current term. The aj2dl constructor is used to rewrite an AspectJ pointcut to Datalog. \nMore precisely, aj2dl( pc,C, S) should be interpreted as a Datalog expression with free variables C and \nS, such that the expression is true iff S is a shadow (instrumentation label) in the denotation of pc,and \nC is the class in which the pointcut pc is located. The context information provided by the class parameter \nC is necessary, as the class in which a pointcut is located affects its semantics (through the use of \nJava name lookup in pointcuts). An expression of the form aj2dl( pc,C, S) is rewritten to a pure Datalog \nexpression, in a syntax-directed fashion. The rules in Fig\u00adure 4 show how logical operators may be eliminated \nfrom pointcuts, and converted into the equivalent Datalog logical operators.  6.2 Primitive predicates \nIn order to express pointcuts in Datalog, a set of primitive pred\u00adicates (also referred to as extensional \npredicates in the deductive databases literature) must be supplied to query the structure of the program. \nThe set of primitive predicates must at least encode as much of that structure as is required to evaluate \nAspectJ pointcuts. An extreme viewpoint would be to just store the abstract syntax tree of the mainline \nprogram, and write queries over that structure. However, we shall need quite complex derived notions, \nsuch as the type hierarchy (represented by a relation hasSubtype). While this information could be de.ned \npurely in terms of the syntax of the program, it would clutter our semantics of pointcuts to do so. We \ntherefore abstract away from this irrelevant detail, and use the set of primitive predicates in Figure \n5. This set captures just enough information about the structure of the program to evaluate AspectJ pointcuts. \nWhile the use of Datalog usually allows a simple and direct ex\u00adpression of queries, our treatment of \nmethod parameters shows that an encoding may sometimes be necessary. The methodParamTypes predicate is \nused to obtain, for each method, the list of types of formal parameters. As Datalog does not allow the \nuse of data struc\u00adtures such as lists, or indeed arithmetic, this cannot be expressed directly. Instead, \nwe de.ne a relation: methodParamTypes(Method, Type, Pos, NextPos) that holds if the formal parameter \nof Method at position Pos has type Type.The NextPos .eld records the position of the next parameter of \nM(i.e. Pos + 1),or 0 if there is no next parameter. This .eld is needed because arbitrary arithmetic \nis not available in Datalog, and is used to iterate over parameter types. In addition to the primitive \ndatabase predicates describing the structure of the program, we include predicates listing the shadows \nin the program. Shadows represent the static instrumentation points recognised by the AspectJ language; \nas such, pointcuts denote sets of shadows. Again, because our focus is on the matching behaviour of pointcuts, \nwe have chosen to represent shadows directly as prim\u00aditive predicates. In the terms of Section 3, this \namounts to abstract\u00ading from the details of inserting labels at every instrumentation point of the mainline \nprogram. Figure 6 lists the relevant primitive predicates. Each of these corresponds to a kind of shadow \nde.ned by the AspectJ language for instance, the callShadow predicate describes method or constructor \ncall shadows. The type stored for each call shadow should be interpreted as the receiver type for vir\u00adtual \nmethod calls, while for static method calls and constructor calls this is just the declaring type of \nthe callee. It is worth noting that no part of the matching semantics is preempted by these predicates. \nPicking out all call shadows, for example, is a simple mechanical task that can be achieved by case analysis \non the program AST: we just have to collect all method calls. We are concerned with the matching of pointcuts, \ni.e. the process by which the set of all method calls is constrained to just those which are matched \nby a given pointcut. We can think of the predicates in Figure 6 simply as a way of bounding the domain \nof the Datalog variable S. 6.3 Pre-de.ned derived predicates Below we shall make use of some pre-de.ned \nderived predicates (also called intensional predicates in the deductive databases liter\u00adature), as a \nconvenient shorthand in de.ning the semantics of point\u00adcuts. The simplest examples are those predicates \nthat are used as types, such as constructor, method, .eld, type. Most of these are self\u00adexplanatory, \nbut there are some exceptions: callable (M) holds when M is a method or a constructor; similarly packageOrType(T) \nis the union of the package and type predicates. Other pre-de.ned predicates include hasName(X,N),which \nis true when X is an entity (method, type, package, ...) that has name N. All of these are obtained via \nsimple projections of the primitive relations. A more complex class of pre-de.ned predicates are those \nused for traversing hierarchical data. A typical example is the re.exive transitive closure of the immediate \nhasSubtype relation: hasSubtypeStar(T: type,T: type). hasSubtypeStar(T : type, S : type) . U: type ( \nhasSubtype(T,U), hasSubtypeStar(U,S) ). The .nal category of pre-de.ned predicates concerns the lookup \nof type names in Java. The most important of these is predicate simpleTypeLookup(C,N,T). It relates a \ntype C,a name N and a type T precisely when inside C, looking up a type by name N would result in T according \nto the Java Language Speci.cation. Furthermore N is assumed to be a simple name, not containing dots. \nFor space reasons, we do not include a list of the pre-de.ned derived predicates in this paper. The companion \ntechnical report contains the details of these predicates.  6.4 Rewrite rules As explained above, we \naim to give a semantics to the AspectJ pointcut language by rewriting it to Datalog in a term-based, \npurely syntactic fashion. The complete set of rewrite rules for doing that consists of about 90 rules. \nWhile it is pleasing that so few rules suf\u00ad.ce to pin down the whole pointcut language, space forbids \na thor\u00adough description of all rules in this paper (full details can be found in the companion report \n[6]). Rather than give a cursory overview of all rules, we present an in-depth discussion of two particular \nfea\u00adtures of the AspectJ pointcut language. The speci.c choice of con\u00adstructs we describe is signi.cant, \nas we focus on language features that have been a source both of confusion among AspectJ users and implementation \nbugs. This illustrates the necessity for a precise se\u00admantics to clarify the pointcut language. Predicate \nDescription packageDecl(P, N) P denotes a package with name N. typeDecl(T, N, IsInt, P) T denotes a type \nwith name N, declared in package P. IsInt is true if T is an interface. primitiveDecl(T, N) T denotes \na primitive type with name N. arrayDecl(T, ET, N) T denotes an array type with element type ET and name \nN. methodDecl(M, N, S, DT, RT) M denotes a method with name N, signature S, return type RT and declared \nin type DT. constructorDecl(C, S, Cls) C denotes a constructor with signature S for class Cls. .eldDecl(F, \nDT, T, N) F denotes a .eld with name N, of type T, declared in type DT. compilationUnit(CU, P) CU denotes \na compilation unit in package P. singleImportDecl(I, N) I denotes an import declaration, importing the \ntype with name N. onDemandImportDecl(I, N) I is an on-demand import declaration, for all types in the \ntype or package with name N. methodModi.ers(M, Mod) Method M has the modi.er Mod. .eldModi.ers(F, Mod) \nField F has the modi.er Mod. modi.ers(Mod, N) Modi.er Mod has string representation N. methodThrows(M, \nT) Method M declares throwing exception T methodParamTypes(M, T, Pos, Next) Method M has a parameter \nof type T at position Pos. Next is the next position after Pos. hasChild(A, B) Syntactic element B is \na directly lexically enclosed by A. hasSubtype(T1, T2) T2 is a direct subtype of T1. Figure 5. Primitive \nPredicates: Program Structure Predicate Description callShadow(S, M, Recv) Call to a method or constructor \nM with receiver type Recv. executionShadow(S, M) Execution of a method M. initializationShadow(S, C) \nInitialisation of an object (body of C after parent constructor calls). preinitializationShadow(S, C) \nPre-initialisation of an object (body of C before parent constructor calls). staticinitializationShadow(S, \nT) Initialisation of the static members of a class T. getShadow(S, F, Recv) Read access to a .eld F, \non an object of static type Recv. setShadow(S, F, Recv) Write access to a .eld F, on an object of static \ntype Recv. handlerShadow(S, Exn) Execution of a handler for exception Exn. adviceexecutionShadow(S) Execution \nof advice. isWithinClass(S, Cls) Shadow S is contained in class Cls. isWithinShadow(S1, S2) Shadow S1 \nis contained within shadow S2. Figure 6. Primitive Predicates: Shadows In developing our semantics, \nwe felt it was important that the rewrite rules are directly executable, so they can be easily tested \non tricky examples. At .rst we developed the rules by directly rewrit\u00ading abstract syntax trees that \nrepresent pointcuts, but in this form the rules quickly became unreadable. We therefore implemented them \nusing the Stratego system of Visser et al.; its main attraction is that rewrite rules can be speci.ed \nin a concrete syntax [41] in our case, concrete AspectJ pattern syntax on the left-hand side of rules, \nand concrete Datalog syntax on the right-hand side. Fur\u00adthermore, Bravenboer et al. have developed a \ngrammar for AspectJ that we adopted for this project [9]. The rules shown in this paper are slight typographical \nmodi.cations of their implementation in Stratego. 6.4.1 Call and execution pointcuts AspectJ offers two \nways to intercept method invocations: one for intercepting at the call site, and another for intercepting \nthe execu\u00adtion of a method body in the de.ning class. For the .rst alternative, one uses the call pointcut, \nand for the second execution. The seem\u00adingly different matching behaviours of call and execution have \nled to considerable confusion, and a comprehensive discussion can be found in [7] (although it is now \nsomewhat dated, since it deals with AspectJ 1.1.1 and the language semantics has evolved). To illus\u00adtrate \nthe difference between call and execution, consider the follow\u00ading type hierarchy: class A { void m() \n{} } class B extends A {} class C extends B { void m() {} } along with the pointcuts pointcut c() : \ncall (* B.m(..)); pointcut e() : execution(* B.m(..)); and the sequence of calls ( new A()).m(); ( new \nB()). m(); ( new C()). m(); The call pointcut c() will match the latter two calls, whereas the execution \npointcut e() only matches the de.nition of m() in C.The situation is further complicated in the presence \nof static methods: if both de.nitions of m() are declared static in the above example, c() only matches \nthe second call, and e() does not match at all. This potentially surprising matching behaviour is caused \nby the difference between call and execution shadows. Any call statement gives rise to a call shadow, \nirrespective of where the called method is actually declared. An execution shadow, on the other hand, \nspans an entire method body, and as such by de.nition can only be present in those classes that contain \na (re-)de.nition of the method. In the example above, the different behaviour is caused by B having no \nde.nition of m(), not any difference in the interpretation of the pattern. The precise semantics is easily \nbrought out by writing both pointcuts c() and e() as Datalog queries. We shall .rst do that by hand, \nto give the reader a sense of what needs to be generated; once the goal is clear, we shall present the \nrewrite rules to achieve it. Consider .rst the call pointcut c(): c(Context : type, Shadow : shadow) \n. M : method Recv : type M Real : method ( matchpat(Context, M,Recv) , overrides ( M Real,M) , callShadow(Shadow,M \nReal,Recv) ). matchpat(Context : type, M : method, Recv : type) . T: type MD:type ( simpleTypeLookup(Context, \nB ,T), hasSubtypeStar (T,Recv), methodDecl(M, m , ,MD, ), ( ( hasStrModi.er (M,static ), equals(MD,T) \n) ; ( not(hasStrModi.er (M,static )), hasSubtypeStar ( MD,T) ) ) ) . In words, this query consists of \ntwo parts: one that matches the method pattern to .nd a candidate method M with a matching signature, \nand another that picks out an appropriate call shadow Shadow. The subsidiary predicate matchpat .rst \n.nds the de.nition T of a type named B , as well as a method M named m that is declared in some type \nMD. In order to correctly combine these two results, matchpat must ensure that T has an implementation \nof M. According to the AspectJ rules, has an implementation of means declares, overrides, or inherits \nfor virtual methods; for static methods it just means declares . Therefore, if the method is static, \nMD and T must be equal; if the method is not static, T can also be a subtype of MD. Note that this picks \nout all more general methods m of B.m() and their declaring classes MD they are our representation of \nthe set of signatures that the method pattern matches. The parameter Recv of matchpat is intended to \nbind the static receiver type of the shadow that is, the static type of the receiver for virtual calls, \nand the declaring type for static calls. At this stage, the only requirement is that Recv is T or a subtype \nof T, the type mentioned in the pointcut. The second part of the query is simple in comparison: We .nd \nall methods M Real overriding the more general de.nition M that we retrieved in matchpat, and pick out \nany call shadows that refer to M Real and have a suitable static receiver type Recv.It is worth stressing \nthat the overrides () predicate we use is re.exive, as a method could be its own most general de.nition. \nNow contrast the above query c with the Datalog de.nition of the execution pointcut: e(Context : type, \nShadow : shadow) . M : method Recv : type M Real : method ( matchpat(Context, M,Recv), overrides ( \nM Real,M), hasChild(Recv,M Real), // crucial difference executionShadow(Shadow,M Real) ) . It is remarkably \nsimilar to our earlier pointcut for execution:Again, we .nd overriding methods M Real for the result \nof matchpat,but now we also assert that the receiver type of the shadow (which, for execution pointcuts, \nis just the type containing the method body) contains a de.nition of M Real; if it didn t, there would \nbe no execution shadow. Finally, we pick out all shadows for M Real as matched by the pointcut. We can \nnow conclude that the seemingly different matching be\u00adhaviour is based purely on the difference between \ncall and exe\u00adcution shadows; the method pattern in either case is matched in exactly the same way, but \nexecution shadows only arise if a class declares a method, whereas for a call shadow it is suf.cient \nto sim\u00adply inherit it.        We are ready, therefore, to present the rewrite rules that give \nthe semantics of call and execution in full generality. The rules (Fig\u00adure 7) follow the argument above: \none rule picks out a callShadow, and the other an executionShadow (with the side condition that there \nneeds to be an actual declaration of the method in the receiver), but the method or constructor pattern \nis treated uniformly. That pattern is further rewritten using the methconstrpat2dl term constructor. \nRewrite rules are given in Figure 8 (those shown are for method patterns constructor patterns are very \nsimilar). We see that the method pattern is further broken down into its constituent parts: a modi.er \npattern, a type pattern for the return type, a pattern matching class members, and a formals-pattern \n(i.e. a pattern over the method s formal parameters), as well as an optional pattern on the throws clause \nof the method. Each of these is rewritten to Datalog using the appropriate term constructor, and the \nresulting Datalog expressions are conjoined in the natural way. We refrain from listing all the auxiliary \nterm constructor rewrite rules here, the interested reader may .nd our full set of rules in our technical \nreport [6]. For now, we just note that out of the addi\u00adtional constructors, mmodpat2dl and formals2dl \nare implemented in the natural fashion, i.e. they de.ne a set of predicates asserting that the method \nhas a certain modi.er (or a certain formal parameter), recursively working through the list of modi.er \n(or formal param\u00adeter) patterns. typepat2dl and methmembpat2dl ultimately rely on name patterns, and \nthe implementation of those proved unexpect\u00adedly challenging. We discuss it in Section 6.4.2. Thus, the \nlast remaining term constructor is throws2dl,and there is a subtlety that can easily be missed when perusing \nthe AspectJ documentation, but which appears clearly in our semantics. The rewrite rules are given in \nFigure 9. They are an illustration of the kind of recursive rewriting that is also employed with mmodpat2dl \nand formals2dl. An empty exception pattern is rewritten to a dummy predicate that is later eliminated. \nIn the remaining two clauses, when rewriting exception patterns we differentiate between the case when \nthe .rst character of the pattern is a ! , and when it is not. According to the AspectJ documentation, \nin the former case the pattern matches if none of the declared exceptions of a method match the rest \nof the pattern, and in the latter case we match if there is some exception in the throws clause that \nmatches the pattern. So !Ex is an exception pattern that starts with a ! , whereas ! in the (! Ex) pattern \nis a part of the class name pattern and not of the exception pattern and therefore the third clause of \nthe throws2dl rule will be applied. While the authors are of the opinion that it is bad language design \nto put substantial meaning into parentheses (the throws pattern !Ex has a different meaning from (! Ex), \nas shown above), it poses no problems for our method of pinning down the semantics. We hope that by giving \na crisp semantics, issues such as these will become easier to discuss and rectify.  6.4.2 Type name \npatterns Type name patterns in AspectJ pointcuts allow sets of types to be concisely denoted, and are \ninvaluable in expressing many commonly-used pointcuts. However, the semantics of type name patterns is \nsurprisingly subtle, and as such it is useful to examine it more closely. Type patterns allow the use \nof wildcards to denote sets of types. Examples of type patterns include: Foo, a*..B (read: any name start\u00ading \nwith a, followed by a dot-separated list of identi.ers, followed by B)and *. While it is quite clear \nwhat set of strings is represented by a name pattern, the subtlety lies in the interpretation of these \nas [ aj2dl(call (methconstrpat ), C,S) ] . [ X : callable Y : callable R : type (methconstrpat2dl(methconstrpat,C, \nR, X), overrides (Y, X), callShadow(S,Y,R)) ] [ aj2dl(execution ( methconstrpat ), C,S) ] . [ X : callable \n Y : callable R : type ( methconstrpat2dl(methconstrpat,C, R, X), overrides (Y, X), hasChild(R, Y), \nexecutionShadow(S,Y)) ] Figure 7. Top-level rewrite rules for call and execution pointcuts [ methconstrpat2dl(mmodpat \ntypepat membpat(formalspat),C, R, X) ]  . [ T : type ( mmodpat2dl([mmodpat], X), typepat2dl(typepat,C, \nT), methmembpat2dl(membpat,C, R,X), formals2dl([formalspat], C, X, 1), returns (X, T)) ] [ methconstrpat2dl(mmodpat \ntypepat membpat(formalspat)throws throwspat , C,R,X) ] . [ methconstrpat2dl(mmodpat typepat membpat(formalspat),C, \nR, X), throws2dl(throwspat,C, X) ] Figure 8. Rewriting for method patterns constructor patterns are \nsimilar [ throws2dl([], C, M) ] . [ true (M) ]  [ throws2dl([! classnamepat, throwspat ], C,M) ] . [ \nnot(E: type ( classnamepat2dl(classnamepat, C, E), throwsException(M, E))), throws2dl(throwspat,C, M) \n] [ throws2dl([classnamepat, throwspat ], C,M) ] . [ E : type ( classnamepat2dl(classnamepat, C, E), \nthrowsException(M, E)), throws2dl(throwspat,C, M) ] Figure 9. Rewrite rules for throws2dl names. This \nhas been a source of confusion in the AspectJ commu\u00adnity, and indeed the ajc [4] and abc [1] compilers \nfor AspectJ do not implement the same rules. Furthermore, this is the cause of a substantial bug in the \nreference AspectJ implementation [25]. To see how this issue arises, consider a name pattern, for def\u00adiniteness \nsay a*..B. There are two possible interpretations of this pattern. The .rst possibility is that this \nshould range over fully qual\u00adi.ed names. In this case, classes a.B and aa.c.B would be matched, but not \nd.a.B (we use the convention that lowercase identi.ers de\u00adnote packages). Alternatively, the name pattern \nmight denote any class that can be referred to by a name of the form a*..B from the aspect.That is, in \nthis view the normal Java name lookup rules are used to interpret names. This matches any type matched \nin the previous way (any type can be referred to by its fully quali.ed name), but may match more types. \nFor instance, the simple pattern B would match any class B in the same package as the aspect. In fact, \nthe semantics of AspectJ use either form of matching, depending on context. The key is the presence or \nabsence of the wildcards * and .. in the pattern. If a wildcard appears anywhere in the pattern, then \nthe pattern should be interpreted as ranging over fully quali.ed names, and no name lookup is performed. \nHowever, if there are no wildcards in the pattern, then it is interpreted as a Java name, and denotes \nwhichever types (if any) can be referred to by the given name from the context of the aspect. Finally, \nthe name pattern * (a single asterisk) is treated as a special case. This matches any type, including \nanonymous types such as anonymous inner classes, which otherwise would be matched by no name pattern. \nWe shall now give the semantics of type name patterns in more detail. Type patterns in AspectJ are built \nup from the following. A simple name pattern, representing an identi.er, is just a literal possibly containing \nthe wildcard *. A general name pattern is a sequence of simple name patterns, separated by either . or \n..,where the latter is a wildcard denoting any sequence of Java identi.ers and full-stops beginning and \nending with a full-stop. Given any name pattern pat, both pat and pat + (representing any subtype of \npat)are type name patterns, and type name patterns are closed under logical connectives. Finally, given \na type name pattern tpat, tpat [] is a type name pattern representing an array with element type matching \ntpat. Type name patterns are translated using the typepat2dl term constructor. The top-level rules (excluding \nlogical connectives) are shown in Figure 10. The name pattern is translated via the namepat2dl, and the \nappropriate type (exact match, subtype or ar\u00adray type) is selected. The namepat2dl rewrite context de.nes \nthe semantics of name patterns. As discussed above, the AspectJ semantics separates out the cases of \nname patterns containing wildcards from exact name patterns. This is achieved in namepat2dl (Figure 11) \nusing an auxil\u00adiary test contains-wildcard that checks the presence of wildcards in a pattern. Note that \nthe namepat2dl predicates match by name only, and in particular can match either packages or types. The \nend result is constrained to a type in typepat2dl. The semantics of simple name patterns and wildcard \nname patterns are de.ned in Figure 12. Such a name pattern is matched (including wildcards) to the fully \nquali.ed name of an element. Finally, the rules for wildcard-free name patterns are shown in Figure 13. \nThese are rather more involved, re.ecting the com\u00adplexity of name lookup in Java. Two predicates are \nde.ned: exactnamepat2dl matches a name pattern against type or package names, while pnamepat2dl matches \npackage names only. In ac\u00adcordance with the Java speci.cation, when a name is looked up in a context \nwhere it is unknown whether a package or type is denoted, the name should be interpreted as a type whenever \npos\u00adsible, and only interpreted as a package if no type of that name exists. Finally, name lookup for \nsimple names is performed by the simpleTypeLookup predicate discussed earlier.   7. Experimental results \nThe Datalog queries we produce in the semantics are executable, and so it is natural to ask whether that \nsemantics can be used [ typepat2dl(namepat,C, T) ] . [ namepat2dl(namepat,C,T), type(T) ] [ typepat2dl(namepat+,C, \nT) ] . [ T1: type ( namepat2dl(namepat, C, T1), hasSubtypeStar ( T1, T)) ] [ typepat2dl(typepat [], C, \nT) ] . [ T1: type ( typepat2dl(typepat , C, T1), arrayDecl(T, T1, )) ]  Figure 10. Type Patterns: \nSubtypes and Array Types [ namepat2dl(*,C, T) ] . [ true (T) ] [ namepat2dl(namepat,C, T) ] . [ wcnamepat2dl(namepat,T) \n] where contains-wildcard(namepat) ; fqname(namepat) = * [ namepat2dl(namepat,C, T) ] . [ exactnamepat2dl(namepat,C,T) \n] where not(contains-wildcard(namepat)); fqname(namepat) = * Figure 11. Name Patterns: Testing for Wildcards \n[ snamepat2dl(*,S) ] . [ true (S) ]  [ snamepat2dl(snamepat,S) ] . [ N : name (hasName(S, N), regexpmatch(snamepat,N)) \n] where snamepat = * [ wcnamepat2dl(snamepat,T) ] . [ P : package (defaultPackage (P), hasChild(P, T), \nsnamepat2dl(snamepat,T)) ] [ wcnamepat2dl(namepat.snamepat, T) ] . [ E : packageOrType (wcnamepat2dl(namepat, \nE), hasChild(E, T), snamepat2dl(snamepat,T)) ] [ wcnamepat2dl(namepat..snamepat, T) ] . [ E : packageOrType \n(wcnamepat2dl(namepat, E), hasChildPlus(E, T), snamepat2dl(snamepat,T)) ] Figure 12. Name Patterns: \nSimple Name Patterns and Wildcards [ exactnamepat2dl(snamepat,C,T) ] . [ (simpleTypeLookup(C, snamepat, \nT)); ( not(T1 : type ( simpleTypeLookup(C, str, T1))), pnamepat2dl(snamepat,T)) ] [ exactnamepat2dl(namepat.snamepat, \nC, T) ] . [ Pot : packageOrType ((exactnamepat2dl(namepat, C, Pot), type(T), hasChild(Pot, T), hasName(T, \nsnamepat)) ; ( not(T1 : type ( exactnamepat2dl(namepat, C, Pot), hasChild(Pot, T1), hasName(T1, snamepat))), \npnamepat2dl(namepat.snamepat, T))) ] [ pnamepat2dl(snamepat,P) ] . [ package(P), hasName(P, snamepat), \ntopLevelPackage(P) ] [ pnamepat2dl(namepat.snamepat, P) ] . [ P1 : package ( pnamepat2dl(namepat, P1), \nhasChild(P1,P), package(P), hasName(P, snamepat)) ] directly as the basis of an AspectJ implementation. \nIn this section, we seek to determine whether that is at all feasible in practice, by running queries \nthat correspond to some realistic pointcuts on sizable mainline programs. There are a number of options \nfor executing Datalog queries. Perhaps the most obvious one is to capitalise on the fact that Dat\u00adalog \nis a subset of Prolog, so we could just use a Prolog inter\u00adpreter. However, to stay true to the declarative \nsemantics of Dat\u00adalog, such an interpreter must use tabled resolution, because oth\u00aderwise non-termination \nmight occur. That consideration suggests the use of XSB, the leading optimising, tabled implementation \nof Prolog [38]. However, in a few preliminary experiments we found that the queries corresponding to \npointcuts can take several hours to complete. Moreover, it took a considerable amount of optimisation \ndone by hand to reduce XSB run times to such a level. Clearly the point of directly executing the semantics \nis lost if hand optimisation is required. We therefore decided to use CodeQuest [21], our own imple\u00admentation \nof Datalog based on a relational database system. Code-Quest .rst optimises Datalog rules to reduce the \nnumber of unnec\u00adessary computations (applying a specialised version of the well\u00adknown magic sets transformation). \nIt then translates the optimised Datalog queries into SQL to take the advantage of several decades Figure \n14. Experimental Setup of research on RDBMS optimisations. For the measurements re- For each of the experiments, \na customised version of the abc [5] ported below, we used Microsoft SQL Server Express 2005 as the compiler \ncollects the facts implied by the program s structure,RDBMS backend of the CodeQuest system. which are \nused to populate CodeQuest s primitive relations. The database is then indexed in a straightforward manner, \nnamely by creating a separate index on each .eld of every table. The abc com\u00adpiler also collects information \non the shadows in the program that are matched by pointcuts, which is used to verify the correctness \nof the result of CodeQuest s evaluation of the Datalog pointcuts. The overall architecture is shown in \nFigure 14.  Pointcut CodeQuest WEKA1 4.68 s WEKA2 5.91 s WEKA3 5.24 s JHOTDRAW1 11.36 s JHOTDRAW2 7.83 \ns JHOTDRAW3 7.53 s REWEAVE1 9.61 s REWEAVE2 9.62 s REWEAVE3 13.29 s REWEAVE4 17.45 s REWEAVE5 7.50 s \nJIGSAW1 36.93 s JIGSAW2 31.34 s JIGSAW3 31.03 s Figure 16. Pointcut matching times with CodeQuest  Project \nAJC populate + index (PI) aggregate query (AQ) Ratio WEKA 5.49 s 7.79 s 9.15 s 4.09 JHOTDRAW 5.05 s 7.73 \ns 12.15 s 4.94 REWEAVE 19.89 s 9.94 s 26.58 s 2.84 JIGSAW 32.25 s 14.93 s 43.50 s 2.81 Figure 17. Comparison \nwith ajc  The experiments themselves are run on four AspectJ software projects of various sizes. WEKA \n[49] is a data mining tool written in Java, consisting about 10KSLOC. It is instrumented with an as\u00adpect \nthat checks for changes to an object s hash code while it is in a hash set. JHOTDRAW [18] is a popular \nopen source Java drawing program, with approximately 21KSLOC. It has been instrumented with an aspect \nthat checks for the safe use of Java enumerations, similar to concurrent modi.cation exception checks \nin Java collec\u00adtions. REWEAVE is a set of diagnostic aspects applied to the abc compiler itself, which \nhas 51KSLOC. Finally, JIGSAW [42] is the w3c s leading-edge webserver, with approximately 101KSLOC, and \nhas been instrumented by an aspect that checks for the proper sequence of resource locks. Figure 15 details \nthe pointcuts in each of the projects above that were used in the experiments. These are representative \nof typical AspectJ usage. Figure 16 summarises the results of the experiments, with the matching time \nin CodeQuest for each of the pointcuts. It is inter\u00adesting to observe that the performance scales well \nwith the project size: from one project to the next, the size roughly doubles, and that is re.ected in \nquery execution times. We should stress at this point that CodeQuest is a research prototype, and it \nis easy to envisage many optimisations that will improve performance. Now that we have established that \nthe pointcut matching times are acceptable, it is natural to ask what penalty must be paid for storing \nthe program structure and the shadows in a relational database, and for building indices on those primitive \nrelations. We compare the performance of matching in CodeQuest with that of the industrial AspectJ compiler \najc. CodeQuest matching times are composed of two parts: the time it takes to populate and index the \nfacts into the database (PI), and the time to execute the aggregate query for the project (AQ). The aggregate \nquery for a each project is the disjoint union of the Datalog equivalents of all of its point\u00adcuts. This \nis then compared to the total compile time for the project in ajc. Figure 17 shows the results of this \ncomparison. The evaluation times of the aggregate queries are much lower than the simple total of the \nindividual pointcuts that comprise it due to the large number of common terms in the Datalog equivalents \nof those pointcuts. CodeQuest takes advantage of this during query evaluation by computing the result \nof common terms only once. The table also shows a ratio comparing ajc s total compile time with that \nof a hypothetical ajc compiler that uses Datalog for pointcut matching. The ratio itself is given by \nAJC + PI + AQ AJC We compare the query evaluation time to the total compilation time in ajc as it is \ndif.cult to separate pointcut matching times in an AspectJ compiler (as an example, name patterns can \nbe evaluated prior to matching pointcuts to shadows). The intent of this table is to compare Datalog \nmatching times with an actual industrial\u00adstrength AspectJ compiler, and to show that the performance \ndegra\u00addation will not be prohibitive if pointcut matching in ajc were to be replaced with Datalog in \nCodeQuest. The results show that the matching times for Datalog queries in CodeQuest compare favourably \nwith the total compile time of the ajc compiler: they do not exceed the ajc compiler s compilation times \nby more than a factor of .ve. For a comparison, abc,which is a research-oriented AspectJ compiler designed \nmore for extensibil\u00adity than speed, can be up to 30 times slower than ajc.Furthermore, the gap does seem \nto narrow as the size of the project increases. The times for loading the database are admittedly quite \nhigh. An important property, however, is that this only needs to be done for each compilation unit separately, \nand thus when recompilation occurs, we can incrementally update the relevant database facts. In particular, \nlibrary code would only be loaded once in the database. Details of this process are described in [21]. \nIn summary, the above experiments show that directly using our semantics as a basis for an AspectJ compiler \nis feasible.Whether it is also possible to make it competitive with existing implemen\u00adtations remains \nto be seen. We believe that some penalty in com\u00adpile time may be acceptable: .rstly, a direct implementation \nis eas\u00adily kept in one-to-one correspondence with the semantics; but also, Datalog is more expressive \nthan the AspectJ pointcut language facilitating useful pointcuts that cannot be expressed in AspectJ. \nWe expound the latter point in the next section.  8. Directly expressing pointcuts in Datalog Datalog, \ntogether with the primitive predicates described above, is a richer language than the AspectJ pointcut \nlanguage. It is possible to write recursive pointcuts; bind types, members, and shadows; and directly \nquery the type and lexical hierarchies of a program. As a result, it can be bene.cial to write pointcuts \ndirectly in Datalog. The richness of the language is useful because it allows a programmer to express \npointcuts in terms of semantic, rather than syntactic, criteria AspectJ pointcuts tend to fall into \nthe second category. The problems with syntactic criteria, and the uses of logic languages in alleviating \nthem, have been discussed in the literature before [16, 20, 29]. However, they suggest using a computationally \ncomplete logic language. Related work has established the bene.ts of logic languages for expressing pointcuts \n(cf. Section 9). In this section, we aim to demonstrate that despite the restrictions of safe Datalog \nto enable strong termination guarantees, many interesting examples can still be expressed. Name Pointcut \nWEKA1 ! within(RealHashtableNativeAspect) &#38;&#38; call(* Map.put(..)) WEKA2 ! within(RealHashtableNativeAspect) \n&#38;&#38; (call (* Map.get(..)) || call (* Map.remove(..)) || call (* Map.containsKey(..))) WEKA3 ! \nwithin(RealHashtableNativeAspect) &#38;&#38; call(* Map.remove(Object)) JHOTDRAW1 call (* Vector . add*(..)) \n|| call (* Vector . clear ()) || call (* Vector . insertElementAt (..)) ||call (* Vector. remove*(..)) \n|| call (* Vector . retainAll (..)) || call (* Vector. set *(..)) JHOTDRAW2 call (Object Enumeration.nextElement()) \nJHOTDRAW3 call (Enumeration+.new(..)) REWEAVE1 set (**)&#38;&#38; !(within(Aspect) || within(IdentityPair \n) ||within(org. aspectj ..*) || within(org. aspectbench ..*)) REWEAVE2 get(**)&#38;&#38; !(within(Aspect) \n|| within(IdentityPair ) ||within(org. aspectj ..*) || within(org. aspectbench ..*)) REWEAVE3 execution(* \nabc. weaving.weaver.Weaver.resetForReweaving()) REWEAVE4 execution(* abc. weaving.weaver.Weaver.weaveAdvice()) \n&#38;&#38; !( within(Aspect) || within(IdentityPair ) ||within(org. aspectj ..*) || within(org. aspectbench \n..*)) REWEAVE5 adviceexecution() &#38;&#38; within(Aspect) || within(IdentityPair ) ||within(org. aspectj \n..*) || within(org. aspectbench ..*) JIGSAW1 execution(**(..)) &#38;&#38; !within(C.owDepth || LockUpdater \n|| LockChecker) JIGSAW2 call (* org. w3c.tools . resources . ResourceReference+.lock()) JIGSAW3 call \n(* org. w3c.tools . resources . ResourceReference+.unlock()) Figure 15. Pointcuts used in experiments \n 1 aspect DisplayUpdating { 2 pointcut move(): 3 call ( void FigureElement.moveBy(int,int)) || 4 call \n( void Point . setX(int )) || 5 call ( void Point . setY(int )) || 6 call ( void Line. setP1(Point )) \n|| 7 call ( void Line. setP2(Point )); 8 9 after () returning: move() &#38;&#38; !c.owbelow(move()) \n{10 Display. needsRepaint(); 11 }12 } Figure 18. A famous aspect for decoupling model and view Figure \n18 shows a well-known aspect for updating the view of an application structured using the Model-View-Controller \nmodu\u00adlarisation. The move pointcut de.ned on Lines 2 7 is syntactic in nature: it enumerates all the \nmethods that update the state of an el\u00adement in the application-model. A more direct way of expressing \nthe intended set of methods is: All methods that may write to a .eld that could then be read in the repainting \nroutine Display. repaint (). Translating this straight into Datalog yields: 1 needsDisplayUpdate(M) \n. 2 typeDecl(DC, Display , , ), 3 methodDecl(Repaint, repaint , DC, , ), 4 mayRead(Repaint,F), 5 mayWrite(M,F). \nOf course, we must now de.ne exactly what we mean by mayRead and mayWrite. It is not enough to just consider \nwhat .elds are read (or written) in one particular method we must also consider any method that could \nbe called transitively from it. When computing this, we shall also keep in mind the fact that methods \ncan be over\u00adridden. The predicate mayCall, which contains caller-callee pairs and takes into account \noverriding, is de.ned as follows. 1 mayCall(M,M2) . 2 containsShadow(M,Call), 3 callShadow(Call , M3), \n4 overrides (M2,M3). 1 containsShadow(M,S) . 2 executionShadow(S2,M), 3 isWithinShadow(S,S2). We are \nnow able to de.ne mayRead and mayWrite in terms of mayCallStar. 1 mayRead(M,F) . 2 mayCallStar(M,M2), \n3 containsShadow(M2,S), 4 getShadow(S,F, ). 5 6 mayWrite(M,F) . 7 mayCallStar(M,M2), 8 containsShadow(M2,S), \n9 setShadow(S,F, ). Just as in examples in previous sections, we use the convention that, for any predicate \npred, we write predStar to denote its re.exive transitive closure. Finally, it only remains to specify \nthe overrides predicate. It is well-known how to do that in a logic language, as demonstrated for instance \nin JQuery [35]. These de.nitions carry over to Datalog almost unchanged. A common complaint about aspects \nis the lack of clear in\u00adterfaces between modules. To a large extent this is a language\u00adindependent issue, \nand more a matter of software design [19]. It appears, however, that using semantic pointcuts such as \nthose sug\u00adgested above helps to decouple aspects from changeable implemen\u00adtation details. 9. Related \nWork We have already made comprehensive references to previous work, so this section provides just a \nroadmap of the main highlights. The related work for this paper falls into four main categories: AOP \nsemantics, logic pointcuts, logic languages for static analysis, and code queries. AOP semantics In this \npaper, we have taken our cue from the approach of Walker et al [43]. The distinguishing characteristic \nof that semantics is the use of a core language with labelled instrumentation points. Arguably the semantics \nof Wand et al. [45] is more in line with the spirit of aspect-orientation, as all matching of events \nhappens at runtime, thus foregoing that intermediate level. The connection between the two styles of \nsemantics is given by partial evaluation: partially evaluating Wand s de.nitional interpreter yields \na compiler in the style of Walker [34]. It would have been possible for us to make [45] our starting \npoint, but as our focus are queries over the static program structure, it would have been a detour. Logic \npointcuts There is a large amount of previous works, in\u00adcluding implemented systems, that propose a logic \npointcut lan\u00adguage in lieu of the patterns in AspectJ, notably [20]. In our opinion, the use of a Turing \ncomplete pointcut language has all the pitfalls associated with undisciplined meta-programming, for instance \nthe potential of non-termination at compile time. Furthermore just using a logic language is syntactically \nvery cumbersome for simple pointcuts that merely refer to method signatures. Finally, our experiments \nshow that the use of Prolog is simply too inef.cient in practice. Static analysis Researchers in static \nanalysis have long acknowl\u00adedged that logic programming in general, and Datalog in par\u00adticular, is a \nsuitable notation for expressing static analyses; the work by Reps [37] is an early example. More recently \nDawson et al revived that line of work, in [15]. Monica Lam and her stu\u00addents have continued that tradition, \nadding the new twist of an implementation via binary decision diagrams [31, 48]. We feel much is to be \ngained from combining those insights (mostly di\u00adrected at traditional applications of static analysis), \nand re-using them in the context of aspect-oriented programming. Code queries There is a rich and vast \nliterature on code queries in the software maintenance community, which makes connec\u00adtions to logic programming. \nIt is in that context that the idea of storing a program in relational form originated. It would take \nus too far astray to review this .eld here; the interested reader is referred to a companion paper [21] \nfor a comprehensive discus\u00adsion of how that work in.uenced the design and implementation of our CodeQuest \nsystem. 10. Conclusions We have presented the .rst rigorous semantics of a practical point\u00adcut language, \nbuilding on the pioneering work of Walker et al. [43]. In doing so, we have sorted out numerous subtle \nissues in the se\u00admantics of AspectJ, in particular regarding the matching of name patterns. Of independent \ninterest is the framework that we chose for this semantics, namely a translation to safe Datalog. Safe \nDatalog is a pure logic programming language, and it is not Turing complete as all queries are guaranteed \nto terminate. At the outset of this project it was not clear to us that the whole AspectJ pointcut language \ncan be expressed in safe Datalog. The fact that this is indeed possible provides strong evidence that \nsafe Datalog is a suitable intermediate form for pointcuts in aspect-oriented programming. The translation \ntook a pleasingly simple form, namely that of conditional rewrite rules. We believe that this makes our \nsemantics accessible to a wide audience, including working AspectJ develop\u00aders, as it requires no exotic \nmathematical machinery. The semantics are executable, and our experiments provide strong evidence that \na direct implementation is feasible. At present that still entails a considerable increase in compile \ntime over an industrial-strength AspectJ compiler, but bearing in mind that we used a straightforward \nresearch prototype to evaluate the Datalog queries, we believe substantial further improvements are within \nreach. The additional expressive power that Datalog affords, plus the fact that the semantics is the \nimplementation, may well be worth paying a penalty in compile time. Finally, we have shown through an \nexample that it is very useful for developers to have the option of writing pointcuts directly in Datalog. \nClearly one would not wish to write all pointcuts in Datalog, as often AspectJ patterns are elegant and \nconcise. Our semantics as a simple set of rewrite rules offers the possibility of a hybrid approach, \nwhere the two notations can be freely mixed as desired. Indeed, it is easy to envisage a system where \nadvanced users can de.ne new pointcuts of their own, via a set of rewrite rules that reduce them to existing \nprimitives, much in the style of other extensible query languages [12]. Dean Wampler and Ron Bodkin have \nargued for a long form of pointcuts in AspectJ, and our semantics provides precisely that [8, 44]. Acknowledgements \nWe would like to thank all members of the abc team, in particular Eric Bodden, Laurie Hendren, Ond.rej \nLhot\u00b4ak and Ganesh Sittampalam for many interesting discussions on this paper, and also for our very \nenjoyable joint work on the abc compiler that made the present paper possible. Martin Bravenboer helped \na lot with the use of Stratego. He also patiently incorporated numerous bug .xes and change requests \ninto the AspectJ grammar in Stratego. Gregor Kiczales, Luke Ong and Sam Sanjabi provided helpful feedback \non a draft of this paper.   References [1] abc. The AspectBench Compiler. Home page with downloads, \nFAQ, documentation, support mailing lists, and bug database. http://aspectbench.org. [2] Jonathan Aldrich. \nOpen Modules: modular reasoning about advice. In Andrew P. Black, editor, Proceedings of ECOOP 2005, \nvolume 3586 of Lecture Notes in Computer Science, pages 144 168. Springer, 2005. [3] James H. Andrews. \nProcess-algebraic foundations of aspect-oriented programming. In Akinori Yonezawa and Satoshi Matsuoka, \neditors, REFLECTION, volume 2192 of Lecture Notes in Computer Science, pages 187 209. Springer, 2001. \n[4] AspectJ Eclipse home page. http://eclipse.org/aspectj/, 2003. [5] Pavel Avgustinov, Aske Simon Christensen, \nLaurie Hendren, Sascha Kuzins, Jennifer Lhot\u00b4ak, Ond.rej Lhot\u00b4ak, OegedeMoor, Damien Sereni, Ganesh Sittampalam, \nand Julian Tibble. abc: An extensible AspectJ compiler. In Proceedings of AOSD, pages 87 98. ACM Press, \n2005. [6] Pavel Avgustinov, Elnar Hajiyev, Neil Ongkingco, Oege de Moor, Damien Sereni, Julian Tibble, \nand Mathieu Verbaere. Datalog Semantics of Static Pointcuts in AspectJ 1.2.1. Technical Report abc-2006-2, \nAspectBench Compiler Project, 2006. http:// aspectbench.org/techreports#abc-2006-2. [7] Ohad Barzilay, \nYishai A. Feldman, Shmuel Tyszberowicz, and Amiram Yehudai. Call and execution semantics in AspectJ. \nIn Curtis Clifton, Ralf L\u00a8ammel, and Gary T. Leavens, editors, FOAL, pages 19 24, 2004. Technical report \nTR #04-04, Department of Computer Science, Iowa State University. [8] Ron Bodkin. Pointcuts need a long \nform. http://dev.eclipse. org/mhonarc/lists/aspectj-users/msg05971.html, 2006. [9] Martin Bravenboer, \nEric Tanter, and Eelco Visser. Declarative, formal, and extensible syntax de.nition for AspectJ a case \nfor scannerless generalized-LR parsing. In William Cook, editor, Proceedings of OOPSLA, page to appear. \nACM Press, 2006. [10] Glenn Bruns, Radha Jagadeesan, Alan Jeffrey, and James Riely. \u00b5ABC: a minimal aspect \ncalculus. In Philippa Gardner and Nobuko Yoshida, editors, Proceedings of CONCUR, volume 3170 of Lecture \nNotes in Computer Science, pages 209 224. Springer, 2004. [11] Bill Burke. has and has.eld pointcut expressions. \nhttp://aosd. net/pipermail/discuss_aosd.net/2004-May/000958.html, 2004. [12] Luca Cardelli, Florian Matthes, \nand Mart\u00b4in Abadi. Extensible gram\u00admars for language specialization. In Catriel Beeri, Atsushi Ohori, \nand Dennis Shasha, editors, Database Programming Languages, pages 11 31. Springer, 1993. [13] Daniel \nS. Dantas and David Walker. Harmless advice. In Conference record of POPL, pages 383 396. ACM Press, \n2006. [14] Daniel S. Dantas, David Walker, Geoffrey Washburn, and Stephanie Weirich. PolyAML: a polymorphic \naspect-oriented functional programming language. In Benjamin Pierce, editor, Proceedings of ICFP, pages \n306 319. ACM Press, 2005. [15] Stephen Dawson, C. R. Ramakrishnan, and David Scott Warren. Practical \nprogram analysis using general purpose logic programming systems. In Kathryn S. McKinley, editor, Proceedings \nof PLDI, pages 117 126. ACM Press, 1996. [16] Kris de Volder. Aspect-oriented logic meta-programming. \nIn Pierre Cointe, editor, REFLECTION, volume 1616 of Lecture Notes in Computer Science, pages 250 272. \nSpringer, 1999. [17] Herv\u00b4e Gallaire and Jack Minker. Logic and Databases. Plenum Press, New York, 1978. \n[18] Erich Gamma. JHotDraw. Available from http://sourceforge. net/projects/jhotdraw, 2004. [19] William \nG. Griswold, Kevin Sullivan, Yuanyuan Song, Macneil Shonle, Nishit Tewari, Yuanfang Cai, and Hridesh \nRajan. Modular software design with crosscutting interfaces. IEEE Software, 23(1):51 60, 2006. [20] Kris \nGybels and Johan Brichau. Arranging language features for more robust pattern-based crosscuts. In Proceedings \nof AOSD, pages 60 69. ACM Press, 2003. [21] Elnar Hajiyev, Mathieu Verbaere, and Oege de Moor. CodeQuest: \nscalable source code queries with Datalog. In Dave Thomas, editor, Proceedings of ECOOP, volume 4067 \nof Lecture Notes in Computer Science, pages 2 27. Springer, 2006. [22] Erik Hilsdale and Jim Hugunin. \nAdvice weaving in AspectJ. In Karl Lieberherr, editor, Proceedings of AOSD, pages 26 35. ACM Press, 2004. \n[23] Jim Hugunin. Support for modi.ers in typepatterns. http://dev. eclipse.org/mhonarc/lists/aspectj-users/msg01578. \nhtml, 2003. [24] Peter Hui and James Riely. Temporal aspects as security automata. In Curtis Clifton, \nRalf L\u00a8ammel, and Gary T. Leavens, editors, FOAL workshop at AOSD, Technical Report #06-01, pages 19 \n28. Iowa State University, 2006. [25] Wes Isberg. Type patterns shouldn t match arbitrary suf.xes. Bug \nreport: https://bugs.eclipse.org/bugs/show_bug.cgi?id= 141133, 2006. [26] Radha Jagadeesan, Alan Jeffrey, \nand James Riely. A calculus of untyped aspect-oriented programs. In Luca Cardelli, editor, Proceedings \nof ECOOP, volume 2743 of Lecture Notes in Computer Science, pages 54 73. Springer, 2003. [27] Radha Jagadeesan, \nAlan Jeffrey, and James Riely. Typed parametric polymorphism for aspects. Science of Computer Programming,To \nappear, 2006. [28] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm, and William \nG. Griswold. An overview of AspectJ. In J. Lindskov Knudsen, editor, Proceedings of ECOOP, volume 2072 \nof Lecture Notes in Computer Science, pages 327 353. Springer, 2001.  [29] G\u00a8unter Kniesel, Tobias Rho, \nand Stefan Hanenberg. Evolvable pattern implementations need generic aspects. In ECOOP Workshop on Re.ection, \nAOP and Meta-Data for Software Evolution, pages 116 126. 2004. [30] Ramnivas Laddad. AspectJ in Action. \nManning, 2003. [31] Monica S. Lam, John Whaley, V. Benjamin Livshits, Michael C. Martin, Dzintars Avots, \nMichael Carbin, and Christopher Unkel. Context-sensitive program analysis as database queries. In Proceed\u00adings \nof PODS, pages 1 12. ACM Press, 2005. [32] Ralf L\u00a8ammel. A semantical approach to method-call interception. \nIn Proceedings of AOSD, pages 41 55. ACM Press, 2002. [33] Hidehiko Masuhara and Kazunori Kawauchi. Data.ow \npointcut in aspect-oriented programming. In Atsushi Ohori, editor, Proceedings of APLAS, volume 2895 \nof Lecture Notes in Computer Science, pages 105 121. Springer, 2003. [34] Hidehiko Masuhara, Gregor Kiczales, \nand Chris Dutchyn. A compilation and optimization model for aspect-oriented programs. In G\u00a8orel Hedin, \neditor, Compiler Construction, volume 2622 of Lecture Notes in Computer Science, pages 46 60. Springer, \n2003. [35] Edward McCormick and Kris De Volder. JQuery: .nding your way through tangled code. In Companion \nto OOPSLA, pages 9 10. ACM Press, 2004. [36] Hridesh Rajan and Kevin J. Sullivan. Classpects: unifying \naspect\u00adand object-oriented language design. In Proceedings of ICSE, pages 59 68. ACM Press, 2005. [37] \nThomas W. Reps. Demand interprocedural program analysis using logic databases. In Raghu Ramakrishnan, \neditor, Applications of Logic Databases, volume 296 of International Series in Engineering and Computer \nScience, pages 163 196. Kluwer, 1995. [38] Konstantinos Sagonas, Terrance Swift, and David S. Warren. \nXSB as an ef.cient deductive database engine. In Richard Thomas Snodgrass and Marianne Winslett, editors, \nSIGMOD, pages 442 453. ACM Press, 1994. [39] Peri L. Tarr, Harold Ossher, and Stanley M. Sutton. Hyper/J: \nmulti\u00addimensional separation of concerns for Java. In Proceedings of ICSE, pages 689 690. ACM Press, \n2002. [40] David B. Tucker and Shriram Krishnamurthi. Pointcuts and advice in higher-order languages. \nIn Mehmet Aks\u00b8it, editor, Proceedings of AOSD, pages 158 167. ACM Press, 2003. [41] Eelco Visser. Meta-programming \nwith concrete object syntax. In Don S. Batory, Charles Consel, and Walid Taha, editors, Proceedings of \nGPCE, volume 2487 of Lecture Notes in Computer Science, pages 299 315. Springer, 2002. [42] w3c. Jigsaw. \nhttp://www.w3.org/Jigsaw/, 2006. [43] David Walker, Steve Zdancewic, and Jay Ligatti. A theory of aspects. \nIn Colin Runciman and Olin Shivers, editors, Proceedings of ICFP, pages 127 139. ACM Press, 2003. [44] \nDean Wampler. Humane pointcut languages. http://blog. aspectprogramming.com/articles/2006/04/21/, 2006. \n[45] Mitchell Wand, Gregor Kiczales, and Christopher Dutchyn. A semantics for advice and dynamic join \npoints in aspect-oriented programming. ACM Trans. Program. Lang. Syst., 26(5):890 910, 2004. [46] Meng \nWang, Kung Chen, and Siau-Cheng Khoo. On the pursuit of static and coherent weaving. In Curtis Clifton, \nRalf L\u00a8ammel, and Gary T. Leavens, editors, FOAL, number TR #06-01 in Technical Report, pages 43 52, \n2006. [47] Meng Wang, Kung Chen, and Siau-Cheng Khoo. Type-directed weaving of aspects for higher-order \nfunctional languages. In John Hatcliff and Frank Tip, editors, Proceedings of PEPM, pages 78 87. ACM \nPress, 2006. [48] John Whaley, Dzintars Avots, Michael Carbin, and Monica S. Lam. Using datalog and binary \ndecision diagrams for program analysis. In Kwangkeun Yi, editor, Proceedings of APLAS, volume 3780 of \nLecture Notes in Computer Science, pages 97 118. Springer, 2005. [49] Ian H. Witten and Eibe Frank. Data \nMining: Practical Machine Learning Tools and Techniques with Java implementations. Morgan Kaufmann Publishers, \n2000. \n\t\t\t", "proc_id": "1190216", "abstract": "In aspect-oriented programming, one can intercept events by writing patterns called <i>pointcuts</i>. The pointcut language of the most popular aspect-oriented programming language, AspectJ, allows the expression of highly complex properties of the static program structure.We present the first rigorous semantics of the AspectJ pointcut language, by translating static patterns into safe (<i> i.e.</i> range-restricted and stratified) Datalog queries. Safe Datalog is a logic language like Prolog, but it does not have data structures; consequently it has a straightforward least fixpoint semantics and all queries terminate.The translation from pointcuts to safe Datalog consists of a set of simple conditional rewrite rules, implemented using the Stratego system. The resulting queries are themselves executable with the CodeQuest system. We present experiments indicating that direct execution of our semantics is not prohibitively expensive.", "authors": [{"name": "Pavel Avgustinov", "author_profile_id": "81100580373", "affiliation": "Oxford University, Oxford, UK", "person_id": "PP14200390", "email_address": "", "orcid_id": ""}, {"name": "Elnar Hajiyev", "author_profile_id": "81100605371", "affiliation": "Oxford University, Oxford, UK", "person_id": "P753356", "email_address": "", "orcid_id": ""}, {"name": "Neil Ongkingco", "author_profile_id": "81310500141", "affiliation": "Oxford University, Oxford, UK", "person_id": "P774572", "email_address": "", "orcid_id": ""}, {"name": "Oege de Moor", "author_profile_id": "81100198102", "affiliation": "Oxford University, Oxford, UK", "person_id": "PP14078760", "email_address": "", "orcid_id": ""}, {"name": "Damien Sereni", "author_profile_id": "81100584039", "affiliation": "Oxford University, Oxford, UK", "person_id": "P439237", "email_address": "", "orcid_id": ""}, {"name": "Julian Tibble", "author_profile_id": "81100521744", "affiliation": "Oxford University, Oxford, UK", "person_id": "PP39046745", "email_address": "", "orcid_id": ""}, {"name": "Mathieu Verbaere", "author_profile_id": "81100564974", "affiliation": "Oxford University, Oxford, UK", "person_id": "P662422", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190221", "year": "2007", "article_id": "1190221", "conference": "POPL", "title": "Semantics of static pointcuts in aspectJ", "url": "http://dl.acm.org/citation.cfm?id=1190221"}