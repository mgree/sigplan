{"article_publication_date": "01-17-2007", "fulltext": "\n A Very Modal Model of a Modern, Major, General Type System AndrewW. Appel * Paul-Andr\u00b4e Melli`es Princeton \nUniversity CNRS INRIA Rocquencourt Universit\u00b4eParis7 appel@princeton.edu mellies@pps.jussieu.fr Abstract \nWe present a model of recursive and impredicatively quan\u00adti.ed types with mutable references. We interpret \nin this model all of the type constructors needed for typed inter\u00admediate languages and typed assembly \nlanguages used for object-oriented and functional languages. We establish in this purely semanticfashiona \nsoundness proofof the typing systems underlying these TILs andTALs ensuring thatev\u00adery well-typed program \nis safe. The technique is generic, and applies to anysmall-step semantics including .-calculus, la\u00adbeled \ntransition systems, and von Neumann machines. It is also simple, and reduces mainly to de.ninga Kripke \nseman\u00adticsoftheG\u00a8odel-L\u00a8oblogicofprovability.Wehave mechan\u00adically veri.ed in Coq the soundness of our \ntype system as applied to a von Neumann machine. Categories and Subject Descriptors F.3.3 [Logics and \nMeanings of Programs]: Studies of Program Constructs Type structure; F.3.2[Logics and Meanings of Programs]: \nSemantics of Programming Languages; F.3.1[Logics and Meanings of Programs]: Specifying andVerifying and \nRea\u00adsoning about Programs Mechanical veri.cation; F.4.1 [Mathematical Logic and Formal Languages]: Mathemat\u00adical \nLogic Modal logic GeneralTerms Languages, Theory Keywords Recursive types, impredicative polymorphism, \nmutable references, Kripke models 1. Introduction We wish to compile languages such as ML and Java into \ntyped intermediate languages and typed assembly languages. These TILs and TALs are particularly dif.cult \nto design, * Supported in part by NSF grants CCF-0540914 and CNS-0627650. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. \nCopyright c . 2007ACM 1-59593-575-4/07/0001... $5.00. Christopher D. Richards* J\u00b4er ome Vouillon Princeton \nUniversity CNRS Universit\u00b4e Paris 7 richards@cs.princeton.edu vouillon@pps.jussieu.fr because in order \nto describe the program transformations appliedinthe courseof compilation,theyrequireavery rich and expressive \ntype system, including intersection and union types;  types for address arithmetic;  types for mutable \nreferences, since the source languages have mutable references (or object .elds);  recursive types, \nin order to describe data structures loaded in memory such as lists and trees;  type quanti.cation, \nwhich is used to describe object and function-closure representations.  Not only that: type quanti.cation \nshould be impredica\u00adtive, because the types which may be abstracted (i.e., put in private .elds of objects \nor in function-closure environments) can be themselves object or function-closure (i.e., quanti\u00ad.ed) \ntypes. In particular, it is not possible to stratify the type system into levels k such that a quanti.cation \n.ka.t is al\u00adways instantiated at level <k. Putting all these type ingredients together in a low-level \nlanguageis an intricateexercise.A formal proofof sound\u00adness anywell-typed program does not go wrong is \nthus recommended for anytype system for such TILs andTALs. Contributions. In this paper we will establish \nthe sound\u00adnessofatype system includingallthe ingredients mentioned earlier, and more. Our semantics of \nimpredicative references is an improvement over previous work because it removes a cumbersome restriction \nfrom the typing rules for quanti.ers (see Section 13.1). Our approach is also novel in that we have decomposed \nthe semantic types in such a way that the principles of safety, inductionover the future, type preserva\u00adtion, \nand so on are each identi.able as a speci.c operator of the type system. Standard concepts such as (function) \ncode pointers, subtyping, contractiveness, mutable and immutable references are constructed from these \nnew primitives. Overview. Although our type system could be proved sound syntactically using progress \nand preservation we will not use progress and preservation. Hence we do not need to formally list all \nour type constructors and typing rules because we never do induction over them but the reader may examine \nTables 1 and 2 and Figures 4 7. We willproceedinapurely semanticfashion,fortwo reasonsat least. First, \nwe .nd intuition easier to come by in this way: once types are interpreted in a relevant and felicitous \nway, it becomes much easier to combine or decompose them than if they remained ciphers rendered meaningful \nonly by the typing rules. Second, we enjoy the modularity and genericity of the semantic methods.We demonstrate \nthisinthe paper, witha nicely modularized proof of soundness which is applicable in principletoanycalculuswitha \nsmall-step semantics.We discuss here von Neumann machines and the call-by-value .-calculus with references; \nour methods should also work well for labeled transition systems used in the intermediate representations \nof compilers. To establish our soundness result, we construct a model of recursive and impredicatively \nquanti.ed types with mu\u00adtable references. We start from the idea of approximation which pervades all \nthe semantic research in the area. If we type-check v : t in order to guarantee safety of just the next \nk computation steps, we need only a k-approximation of the typing-judgment v : t .We express this idea \nhere us\u00ading a Kripke semantics whose possible-worlds accessibility relation R is well-founded: every \npath from a world w into the future must terminate. In this work, worlds characterize abstract computation \nstates, giving an upper bound on the number of future computations steps and constraining the contents \nof memory. (We de.ne the set of worlds precisely in Section 6.)We write w . v : t to mean that the value \nv has type t inworld w. This leads us toinvestigatea modallogic adaptedtothisKripke semantics (Section2).Ajudgment \ns . t in this logic means thatevery value v of type s at any world w has also type t at that world w. \nThen (Section 4) a modal operator . (pronounced later ) quanti.es over all worlds (all times) strictly \nin the future. The strictness of . turns out to be a key technical insight, if we compare it to previous \nwork [Ahm04] which used instead a construction analogous to the modal operator necessity . quantifying \nover worlds now and in the future. Indeed, the combination of a well-founded R with a strict modal operator \n. providesa clean induction principle to the logic, called the L\u00a8ob rule, . t . t , . t where . t can \nbe read as asserting the safety of the program described by t. (Equation 16 gives a precise de.nition.) \nThe resultingG\u00a8odel-L\u00a8ob logic is ideal for computations that can tgo on forever, and where information \ngets less and less precise as the computation goes on. Suppose that we want to type-check a program written \nfor a von Neumann machine with arbitrary control .ow (Section 11). Let t give the typesofallthe labels \nappearinginthe program.Wewant to show that t is an inductionhypothesis for the safety of the program,at \nleastasfarastheendoftheworlds.We .rst assume . t ;that is, to a weaker, or later approximation, the type \nt holds for any exit label to which we might jump in (at least) one step. Then we analyze each basic \nblock in the program to show that the type t (that is, the stronger approximation, without .)describes \neach entry label. From thiswewouldliketo concludebyinductionthat t absolutely describes the program, \nwith nohypothesis; this is precisely what theL \u00a8 ob rule enables. Of course, some computations should \ngo on forever. But the proof scheme above works for any .nite pre.x of the computation so the program \nis safe for an arbitrary number of steps. We obtain in this way (Section 12) a proof of soundnessofthetype \nsystemforavon Neumann machine of which we have machine-checked proofs1 in Coq, using a straightforward \nshallow embedding of our model. Related work. Our model uni.es and generalizes several previous threads \nof research: the indexed model [AM01, AAV02, Ahm04], the orthogonality model [MV05], and the approximation \nmodality [Nak01].We will discuss some of these in Section 13. 2. Kripke semantics Kripke models [Kri63] \noriginated as models of modal log\u00ad ics; subsequentlytheyhave beenshown usefulforgivingthe semantics of \ntype systems [MM91]. The main idea behind Kripke models is that truth (respectively, membership in a \ntype) is not absolutebut relative to some appropriate notion of world, or state, and that these states \ncan be related pre\u00adcisely to each other. In this section we will interpret worlds as characterizing abstract \nproperties of the current state of computation. In particular, in a system with mutable references, each \nworld contains a memory typing (Section 6); but the model can be more general than that, so we will start \nwith an abstract characterization. Models. A model is a triple (W, R, .), where W is a nonempty set of \nworlds w; an accessibility relation R . W \u00d7 W describes when it is possible to move from one world to \nanother; and . assigns truth values to typing judg\u00adments with respect to a given world, that is, w . \nv : t. (1) Here w . W is a world, v . V is a value of our operational calculus, and t . Type is a type. \nWe apply our Kripke models to small-step operational semanticswitha memoryor store indexedby locations \nLoc; but there are still many.avors of such semantics: 1Available athttp://www.pps.jussieu.fr/~vouillon/smot/ \n Notation Eqn. Description top 2 Top type bot 3 Bottom type t . s 4 Intersection type t . s 5 Untaggedunion \ntype t . s 6 Implication type .x:A.t 7 Universal type .x:A.t 8 Existential type !t 9 Con.gs where all \nvalues have t ?t 10 Con.gs where some value has t just u 13 Singleton type slot(j, t ) 15 Von Neumann \nvector element type . t 18 Later modality rec F 24 Recursive type l .. t 26 Con.gs where .(l) = t plus(i, \nj, k) 57 Asserts i + j = k greater(i, j) 58 Asserts i > j safemem(m) 65 Type of con.gs safe for memorym \nunit 70 Unit type Figure 1. Primitive types, operators In .-calculus with mutable references, a state \nis a pair (e, m) where e is an expression and m is a store,a mapping from Loc to V . States evolve by \na small-step relation (e, m) . (e,m.);if there is no such (e,m.) then either e is a value v or (e, m) \nis stuck.A world w characterizes the store m.  On a von Neumann machine, the state is a pair (v, m), \nwhere v . V is a vector of Loc representing pointers in registers, including the program counter. The \nmemory m is a mapping from Loc to Loc containing program and data. The small-step relation is (v, m) \n. (v,m.).A world w characterizes the contents of memory.  In a labeled transition system such as is \nused in .ow analysis, w characterizes the store and v contains both the local variables and the control-.ow \nstate.  Clearly, the same value v may or may not have type t depending on the world w, that is, depending \non the data structures in memory that v points to. Accordingly, we call a pair (w, v) a con.guration \n(abbreviated con.g ): Con.g = W \u00d7 V, and de.ne a type t . Type as a set of con.gurations. Then, (w, v) \n. t and w . v : t are two alternative notations expressing the same fact. We will show how our semantics \nconnects the relation R be\u00adtween worlds and the relation . between states. 3. Primitive type constructors \nOur approach to the modeling of a type system is to de.ne a few primitive type constructors a type is \njust any set of Figure 2. Synthesized types, operators Notation Eqn. Description t .. s 11 Type of con.gs \nint iffin s teq(t, s) 12 Asserts t equal to s u . . t 14 Asserts u has t in current world . t validmem(m) \n19 27 Necessity modality Asserts m valid ref t 32 Mutable reference type o.set(n, t) 59 Pointer arithmetic \ntype pair(s, t) 60 Pair type list t 61 Listtype iref t 62 Immutable reference type safe 66 Type of safe \ncon.gs t . s 71 Function type codeptr(t) 72 Code pointer (continuation) type .p 75 Program code type \nGp 79 Program invariants type boundary l 88 Asserts memory > l unallocated  con.gurations and then use \nthese primitives to synthesize all the constructors needed for type-checking programs. We can start with \nintersection types, union types, and their identities, as well as an implication type: prim top = {(w, \nv) | True} (2) prim bot = {} (3) prim t . s = t n s (4) prim t . s = t . s (5) prim s . t = {(w, v) | \n(w, v) . s . (w, v) . t} (6) prim We write c(t )= ...t ... to indicate that the primitive type-constructor \nc is de.ned by the mathematical expres\u00adsion .t. ...t ... in the underlying logic.For our machine\u00adchecked \nproofs in Coq [B+98], the underlying logic is the Calculus of Inductive Constructions [PM93]. Quanti.cation. \nQuanti.cation over types is needed for polymorphism, data abstraction, and representation of clo\u00adsures. \nBesides, we are interested here in a .-calculus or von Neumann machine equipped with a store (memory) \nof mu\u00adtable references with address arithmetic. To reason about data.ow and addressability in such programs, \nour type sys\u00adtem should also be able to quantify over locations l . Loc and memories m . Mem. Our quanti.ers \nare thus, .x:A.t prim= t[a/x] (7) a.A .x:A.t prim= t[a/x] (8) a.A where A is either Type, Loc, or Mem. \nQuanti.cation over values in a world. Another kind of We can de.ne .l:Loc. just l . t (l) , the type \nof locations l quanti.cation is over values in the current2 world: which satisfy some property t(l) (where \nt(l) is a world primtype). !t = {(w, v) |.v. (w, v .) . t} (9) The type slot(j, t) characterizes values \nv such that (in\u00ad prim ?t = {(w, v) |.v. (w, v .) . t} (10) formally) the jth slot has type t. The type \n!t ( everywhere t ) means that every value in the slot(j, t) prim = {(w, v) | w . v(j) current world \nhas type t; and ?t ( somewhere t ) means .. t } (15) that some value in the current world has type t \n. One strength of our approach is that we can de.ne just a few primitive type constructors, and from \nthose we can synthesize many more constructors of interest.We will use syn the notation c(t )= ...t ... \nto mean that the constructor c is synthesized from a combination ...t ... of our type constructors, without \ndipping into the underlying logic. syn t .. s = t . s . s . t (11) syn teq(t, s) =!(t .. s) (12) The \njudgment w . v : t .. s means that (in world w) v has type t iffit has type s. In contrast, w . v : teq(t, \ns) means that every value in world w has type t iffit has type s;that is,teq is our notion of type equality. \nIn each world, the type teq(t, s) is equal to either top or bot;we call such types world types because \nthey depend only on the world, not on the value. Henceforth if t is a world type we will write w . t \nto mean w . v : t for an arbitrary v. Vector values. As we have said, our type system applies to several \ncomputational models (e.g., .-calculus, von Neu\u00admann) and in some of these we need to type several kinds \nof values.We have locations l : Loc that index a mutable store m;storable values u : SV that are the \nrange of m (contents of memory cells); and values v : V .We assume Loc . SV . On a von Neumann machine, \nSV = Loc and v is a vector of locations one could think of a register-bank indexed by a natural number \nj. That is, if v is a value then v(j) is a Loc. In order to type locations, we choose . an injective \nfunction -\u00b7 from storable values to values, for . def instance -u = .j.u. This way the same set of types \ncan be used for all kinds of values. In .-calculus, SV = V is the usual set of values in .\u00adcalculus, \nwe have Loc . SV by syntactic inclusion, and we . def take -u = u. Singletons and slots. The singleton \ntype just u is the type of the single storable value u. Since Loc . SV we can also write just l for a \nlocation l. prim - . just u = {(w, v) | v = u } (13) The construction !(just u . t ) asserts that the \nstorable\u00ad valueu has type t in the currentworld, which we write u .. t . To say that register2has thevalue3we \nwriteslot(2, just 3). 4. Necessity and the modal operator . In this section we will explain an operator \nthat encapsulates the notion of induction; then we will demonstrate its appli\u00adcation to recursive types \n(Section 5), recursive data struc\u00ad tures (Sections6,8)and recursivefunctions and control-.ow (Section \n11). Judgments. We introduce a notion of judgment and its semantic interpretation. Given two types s \nand t , we write s . t (16) when the type s is a subset of the type t , or equivalently, when for every \nworld w and for every value v, w . v : s implies w . v : t. More generally, we write s1, \u00b7\u00b7\u00b7 ,sn . t \nto mean s1 .\u00b7 \u00b7\u00b7. sn . t. We write. t to mean top . t. Itis possibleto reason about these judgmentsusingarich \nset of inference rules. This rules can be used to derive a larger number of type properties without having \nto expand the de.nition of type constructors and reason in the underly\u00ading logic. Some of these rules \nare given in Figures 4 7. The later operator .. In any model (W, R, .) we re\u00adquire the accessibility \nrelation R to be transitive and well\u00adfounded: def R well-founded = from anyworld w (17) there is no in.nite \npath wRw. Rw.. R... Intuitively, wRw. means that the world wcomes at a strictly later stage than the \nworld w. This leads us to de\u00ad.ne the later operator: prim . t = {(w, v) |.w .. wRw. . (w ,v) . t} (18) \n That is, w . v : . t precisely when w. v : t for any world w. coming strictly later than the world w. \nThe following properties follow easily. u .. synLemma 4.1. t = !(just u . t ) (14) 1. . is monotone: \nif s . t , then . s . . t . 2In the context of a de.nition that depends on a formal parameter w . W , \n.. 2. . distributes over intersection: . ti = . ti. we refer to w as the current world. The necessity \noperator .. There is a related operator ., pronounced necessarily , which means nowand later and is de.ned \njust that way: syn = t . . t (19) . t The next proposition shows that the operator . is a closure operator \non types, or what is called a comonad in category theory3 although in this paper we will not use the \ntoolkit of category theory. Lemma 4.2. 1. . is monotone: if s . t, then . s . . t. 2.For any type t , \n. t . t. 3. If . s . t , then . s . . t . 4. . distributes over intersection: . ti = . ti.  Necessary \ntypes. We are interested in types t such that, once a value v has type t in some world w, it has type \nt in every future world. Such types are called necessary types: def t necessary = t . . t (20) Not all \nof our types are necessary. In particular, since the mutable store evolves from one world to the next, \nit will be possible to construct types (sets of con.gurations) such that t . . t does not hold. In practice, \nour datatypes (types for references, code pointers, ...), are necessary. However, some logical constructions \non types do not preserve necessity: for instance, thefact that two types t and t. are necessary does \nnot imply that the type t . t. is necessary. Since necessary types are much easier to reason about, we \nwant a convenient way to construct them. This is precisely what the modal operators . and . achieve for \nus: they transform arbitrary types into necessary types. Let us state formally a few properties relating \nnecessity to these two modal operators: Lemma 4.3. 1.Forevery type t , the types . t and . t are necessary, \n2.Atype t is necessary iff t = . t, that is, . teq(t, . t). 3. The intersection of necessary types is \nnecessary. TheL\u00a8Our hypothesis that the accessibility rela\u00ad ob rule. tion R is well-foundedis re.ectedin \nour modal logicby the following induction principle: Theorem 4.4 (L\u00a8For every typet, ob Rule). . t . \nt (21) . t 3 In fact, the . operator is the free comonad of the . operator, both understood as functors \nin the category of types ordered by inclusion. This fact may be proved directly, or deduced from our \nde.nition 20 of necessary types, and Section 9.4of Barr andWells [BW83]. Proof. As R is well-founded, \nit satis.es the following induc\u00adtion principle: .P.(.w.(.w .. wRw. . P (w .)) . P (w)) ..w.P (w). By \ntaking P (w)=(w, v) . t, we get: .v.(.w.(.w.. wRw. . (w,v) . t) . (w, v) . t) . .w.(w, v) . t. Finally, \nby distributing the quanti.cation over v, we have: (.w. v.(.w.. wRw. . (w,v) . t) . (w, v) . t) . .w. \nv.(w, v) . t. This is exactly what the rule 21 means. Corollary 4.5 (GeneralizedL\u00a8ob Rule). s, . t . \nts necessary s . t Proof. By a short logical derivation: s, . t . t s, .(s . (s . t)) . t s, (. s) . \n.(s . t ) . t s . . s, .(s . t) . t s necessary s, .(s . t ) . t .(s . t ) . s . t Theorem 4.4 . s . \nt s . t 5. Recursive types Given a type operator F . Type . Type, we can con\u00adstruct the recursive type \nrec F . As in most models of recur\u00adsive types, if F is contractive then rec F is a .xed point of F . \nInformally, a contractive function is one such that if t is approximately equal to s, then Ft is more \naccurately equal to Fs.We can express contractiveness using the primitives of our type system infact, \ncontractiveness and nonexpan\u00ad siveness4 have very concise, intuitive de.nitions. F contractive def = \n. teq(t, s) . teq(F t, F s) (22) F nonexpansive def = . teq(t, s) . teq(F t, F s) (23) Thehypothesis \n. teq(t, s) meansthat(inthe currentworld) t is perhaps not yet equal to s,but in every future world it \nwill be. What is it about the future worlds that makes them accept t = s? The answer is that the world-accessibility \nrelation R is well founded, which informally means that in the current world there is a .nite number \nk of computation 4In a way now standard in type theory [MPS86], nonexpansive type con\u00ad structors may \nbe composed with contractive constructors to make contrac\u00adtive constructors. steps remaining. Perhaps \nwe can call a function that, given an argument of type t would get stuck on the kth step,but given an \nargument of type s executes safely for k steps; in this case w . . v : teq(t, s). But (by the well-foundedness \nof R), the next world has <k steps of computation remaining to it, so it is less able to distinguish \nt from s. So F con\u00adtractive means that if t is indistinguishable from s in every future world, then F \n(t) is indistinguishable from F (s) in this world. On the other hand, F nonexpansive means that if t \nis in\u00addistinguishable from s in this world and every future world, then F (t ) is indistinguishable from \nF (s) in thisworld.For example, we will later introduce the constructor ref which is contractive, and \no.set which is nonexpansive. Given a type operator F , we de.ne by induction on worlds the .xpoint candidate \nrec F . prim rec F = the unique set s such that (w, v) . s iff (24) (w, v) . F ({(w,v) | wRw. . (w,v) \n. s}). By the well-foundedness of R, this is de.ned for all type operators F in order to .nd out whether \n(w, v) . rec F .l:Loc..t:Type.l .. t . .(m(l) memory locations l . Loc to types. However, we will have \nto be extremely careful, and restrict ourselves to only some of these functions. Indeed, the mutually \nrecursive equations in W and Type below have no solution (by a cardinality ar\u00adgument): W = N\u00d7 (Loc . \nType) (25) Type = P (W \u00d7 V ) . The signi.cance of .. Let us carry on our analysis. Infor\u00admally, a memory \nm . Mem is well typed with respect to a store typing . if for all locations l in the domain of ., the \nvalue m(l) has type .(l). Let us think ahead and imagine that the set of worlds W is already constructed. \nOne could then de.ne the world type l .. t which characterizes the worlds (n, .) in which the memory-typing \nfor l is type t: prim l .. t = {((n, .),v) | .(l)= t} (26) Then, we may declare that a memory m is well-typed \nwhen the following assertion holds: syn validmem(m)= (27) t) .. one only needs to consider con.gurations \n(w,v.) . rec F where wRw.. This .xpoint candidate is easily de.ned as a In this de.nition we write .(m(l) \n .. t). There is some value structural Fixpoint function in Coq. u in memory at address l, and we guarantee \nto every future Lemma 5.1. When F is contractive, the type rec F is a world that u .. t. We don t need \nto guarantee u .. t in the current world because it takes one step just to dereference .xpoint of F \n, that is, m(l), and in that step we move to a future world. rec F . F (rec F ) (unfolding)  F (rec \nF ) . rec F (folding)  These two properties can also be phrased as a single asser\u00adtion: . teq(rec F, \nF (rec F )). Lemma 5.2. The .xpoint of a contractive operator F is unique: if . teq(t, F (t)) and . teq(s, \nF (s)), then . teq(t, s). 6. A Kripke semantics of stores One advantage of our semantic approach is that \nwe did not need to fully specify our Kripke model in order to interpret the logical part of our typing \nsystem (intersection and union types, quanti.cation, necessity, recursive types). But since we are particularly \ninterested here in languages with mutable references we would like to include a notion of reference type \nin our system this requires us to explain what Kripke model of worlds w and accessibility relation wRw. \nsuitable for mutable references we have in mind. Recall that, intuitively, the current world w shall \nbe used for two purposes: (1) to ensure that the accessibility rela\u00adtion R is well founded, and (2) to \nconstrain what values may be contained in memory locations. That is, a world w =(n, .) will be a pair \nof an index n . N (which counts down as time advances) anda store typing .. As one should expect, this \nstore typing . will be a partial function from This use of the . operator rather than the . operator \nis crucial in order to solve the cardinality issue. Indeed, for a con.guration ((n, .),v), only the con.gurations \nof index strictly less than n are then relevant in the type .(l). The Kripke semantics. This informal \ndiscussion enables us to stratify our de.nition of worlds and types, and to start by de.ning .nitely \nstrati.ed worlds and types of rank n by mutual induction: def Wn = {n}\u00d7 (Loc . Type) n . (28) def . Type= \nP Wk \u00d7 V n k<n The set of worlds is then de.ned as the union of .nitely strati.ed worlds:  def W = \nWn. n.N Finally, the set of types is de.ned5 according to the princi\u00adples of Kripke semantics presented \nin Section 2: def Type = P (W \u00d7 V ) . Q 5 Remark. The set Type is isomorphic to the set n.N P (Wn \u00d7 \nV ) obtained as projective limit of the sequence of .nitely strati.ed types Q ~ {Type}n.N, where Type= \nP (Wk \u00d7 V ) . nn k<n We have the inclusions Type0 . ... . Type. ... . Type n andafamilyof approximation \nfunctions ..n : Type . Type n de.ned thus: def .t .n = {((k, .),v) . t | k<n}. (29) These approximation \nfunctions are lifted pointwise to store typings . such that dom...n = dom ., (30) ...n(l)= ..(l).n. Finally, \nthe accessibility relation between worlds is de.ned as follows: def (n, .) R (n, ..)= (31) n>n. ..l . \ndom .. ..(l)= ..(l).n Intuitively, when moving to a future world, at least one step must be taken; the \ntypes of allocated locations must be ap\u00adproximately preserved; and new locations may be allocated. This \ncompletes our de.nition of a Kripke model for mu\u00adtable references. The two types l .. t and validmem(m) \nwhich were used for earlier discussion, are then de.ned as in equations 26 and 27. Reference types. We \nare ready now to de.ne reference types. Intuitively, a reference of type t is a pointer to a location \nl of type t . Because of the inherent strati.cation of store typing, thisis actually too stronga requirement.We \nneedto replaceitbythe weakerbutsuf.cient requirement that the type t. of the location l coincides with \nthe type t in the future. Hence the following de.nition of reference types: syn ref t = .l:Loc. just \nl ..t.:Type.(l .. t . . . teq(t, t .)) (32) Note that this de.nition is given solely in terms of type \ncon\u00adstructors already de.ned.Wehave been arguing for the use\u00adfulness of a modal approach to type semantics, \nas well as a .ner-grained decomposition of such semantics; de.nition 32 exempli.es bothof these ideasina \nniceway.To underscore the .exibility of this decomposition, we speculate that one could synthesize, without \ndipping back into the underlying logic, a replacement for l .. t . that would yield a region\u00adenabled \nde.nition of the ref constructor, and thereby permit deallocation. 7. Type preservation Suppose v : t \nin some state, and then a memory location is updated either to initialize a new reference or to update \nan old one. One of the usual dif.culties in a semantics of references is to ensure that v : t in the \nnew state. For example, if t = list(ref s) (with list de.ned in equation 61, below) how can we ensure \nthat the store to memory has not modi.ed one of the list cells or one of the references? In our framework \nthe solution is (1) use R to constrain the evolutionofworlds;(2)makesurethatt is necessary,that is, t \nis preserved as we change worlds; and (3) use validmem() to constrain the machine states to follow the \nevolution of worlds. Concretely, we demonstrate that, with our choice of accessibility relation, reference \ntypes are necessary and all interesting store operations (memory access, allocation and update) are permitted. \n We use the following technical lemma several times. Lemma 7.1 (Approximation and Equality). A type \nand its approximation can be related as follows. (k, .) .. teq(t, .t .k) We show that an allocated memory \nlocation remains allo\u00adcated forever and that its type is preserved. Lemma 7.2 (StoreTyping Preservation). \nl .. t . . .s:Type.l .. s (33) l .. t . . .s:Type.l .. s . . teq(t, s) (34) Proof. We assume (k, .) \n. l .. t, that is, .(l)= t . Let (k. , ..) be a world such that (k, .)R(k. , ..). By de.nition 31, we \nhave dom . . dom .., and there\u00adfore, for some type s, we have ..(l)= s, that is, (k. , ..) . l .. s. \nThis proves the .rst assertion. Now, let s be a type such that (k. , ..) . l .. s, that is, ..(l)= s. \nBy de.nition 31, s = .t .k. . Hence, by lemma 7.1, (k. , ..) .. teq(t, s) as required to prove the second \nassertion. In particular, if a storable value u can be stored at loca\u00adtion l now, it can still be stored \nat this location in the future: l .. t . .(u .. s). . t ) . . .s:Type.l .. s . .(u . (35) Another direct \ncorollary of the lemma is that reference types are necessary. We now show that the expected store operations \nare per\u00admitted. For instance, if the location l has type ref t , the storable-value u has type t and \nthe current memory m is valid, we should be able to store u at location l;that is, the memory m[l := \nu] shouldbevalidin someworld one step after the current world. Lemma 7.3 (Unchanged memory). If we have \n(k + 1, .) . validmem(m) (36) then there exists a store typing .. suchthat (k + 1, .)R(k, ..) (k, ..) \n. validmem(m) dom .. = dom . (37) (38) (39) Proof. We take .. = ...k.We clearly have assertions 37 Lemma \n7.6 (Memory access). If and 39.We now prove assertion 38 using de.nition 27. Let w . (l l be a location \nand t be a type such that (k, ..) . l .. t . .. ref t) (53) By de.nition 26, as dom .. = dom ., there \nexists t. such w . validmem(m) (54) that (k +1, .) . l .. t.. Furthermore, by assertion 36, wRw. (55) \n(k+1, .) ..(m(l) t.). Hence,byassertion35, (k, ..) . .. .(m(l) .. t ) as wanted. then w . . (m(l) .. \nt) (56) Lemma 7.4 (Memory update). If the type t is necessary and Proof. From assumption 53 there exists \na type t . such that (k +1, .) . validmem(m) (40) w . l .. t . and w .. teq(t, t .). Using assumption \n54 we ref t ) (41) get w .. m(l) .. t. and then w .. m(l) (k +1, .) . (l .. t . Finally, by .. de.nition \nof ., w. . (m(l) .. t), as wanted. (k +1, .) . (u t) (42) .. then there exists a store typing .. suchthat \n(k +1, .)R(k, ..) (43) (k, ..) . validmem(m[l := u]) (44) dom .. = dom . (45) Proof. We take.. = ...k \nas for the previous lemma 7.3. This ensures that (k +1, .)R(k, ..) and dom .. = dom .. We now prove assertion \n44 using de.nition 27. Let l. be a location and t . be a type such that (k, ..) . l. .. t.. If l. . = \nl,we can conclude as in lemma7.3. So, we suppose that l. = l.From assumption41andby de.nition32, thereexists \na type t.. such that (k +1, .) . l .. t .. and (k +1, .) . . teq(t, t..). From assumption 42, using thefact \nthat t is necessary, we therefore get (k +1, .) ..(u .. t..). Hence, by assertion 35, (k, ..) ..(u .. \nt .) as wanted. With these lemmas, we can prove soundness of rules for type-checking store instructions \nfor initializing new refer\u00adences or updating old ones (Appendix A). 8. Data structures To describe the \nmemory layout of data structures and of the stored program, we need address arithmetic on locations (Loc).Inthispaperwewill \nidentifyLoc with the integers.To reason about address arithmetic on Loc, we have arithmetic operators \nin the type system: plus(i, j, k) prim= {(w, v) | i + j = k} (57) greater(i, j) prim= {(w, v) | i>j} \n(58) From these we can construct the o.set type constructor, such that l .. o.set(n, t ) iff l + n .. \nt . This is useful for record Lemma 7.5 (Memory allocation). If the type t is necessary, .elds and program \nlabels. and syn (k +1, .) . validmem(m) (46) o.set(n, t)= .l:Loc. just l . (59) (k +1, .) . (u .. t) \n(47) .l.:Loc. plus(l, n, l.) . l. .. t l .. dom . (48) Now records are just intersections of .elds, \nand disjoint then there exists a store typing .. suchthat union types such as lists are easy to construct. \nsyn (k +1, .)R(k, ..) (49) pair(s, t )= o.set(0, ref s) . o.set(1, ref t) (60) (k, ..) . validmem(m[l \n:= u]) (50) syn list t = rec a. just 0 . (61) (k, ..) . (l ref t) (51) .l:Loc. just l . greater(l, 0) \n(52) . pair(t, a) .. dom .. = dom . .{l} Proof. We take .. = ...k .{l .. .t.k}. This is well\u00adde.ned as \nl .. dom ... Clearly, we have (k +1, .)R(k, ..) and dom .. = dom . .{l}. We now prove assertion 50 using \nde.nition 27. Let l. be a location and t. be a type such that (k, ..) . l. .. t .. If l. .= l, we can \ncon\u00adclude as in lemma 7.3. So, we suppose that l. = l. From assumption 47, using the fact that t is necessary, \nwe get That is, nil of a list is zero; the cons cell of a list must be at an address l, such that l> \n0, and also must be a pair of an element t and a list a. Immutable references. An immutable reference \nto type t can be modeled as a mutable reference to a singleton l, such that (in this world) l has type \nt: (k, ..) ..(u .. syn t ). Usinglemma 7.1, thisgives (k, ..) . iref t = .l:Loc. ref(just l) . l .. \nt (62) .(u .. .t.k). Thus, using thefact that t. =..(l)= .t.k,we have (k, ..) ..(u .. t .) aswanted. \nFinally,by lemma7.1, HenryFordsoldModelTsinanycolorthe customerwanted, (k, ..) .. teq(t, .t.k), and by \nde.nition of .. , (k, ..) . so long as it was black. An immutable ref is a mutable ref l .. .t .k. Therefore, \nwe have assertion 51 by de.nition 32. into which the customer can store any value he wants, so long as \nit s the value that s already there. 9. Safe states in safe worlds We wish to reason about function values \nand function ap-plication.Afunction of type t . s (or, on a von Neumann machine,a code pointerof type \ncodeptr(t))isavalue thatis safe to apply to arguments of type t.To synthesize function or code-pointer \ntypes, we must .rst model safety in our type system. Our notion of safe for k steps is independent of \nour choice of calculus. It requires only that the calculus comes equipped with a small-step relation \n. . State \u00d7 State. def safe0(s) = True (63) def safek+1(s)=(.s .s . s .) ..s .s . s . . safek s (64) \nFor a calculus of mutable references, we assume that State = V \u00d7 Mem, that is, the state (v, m) on a \nvon Neumann machine has register-bank v and memory m, or in a .-calculus has expression v and store m. \nThe type safemem(m) expresses the set of con.gurations (w, v) in which it is safe to run forward from \nstate (v, m). Note that theworld w contains an expiration date n telling how many steps forward we may \nattempt to take. After n steps we declare victory, that is, we do not care whether the small-step relation \nmight get stuck after the nth step. safemem(m) prim{((n, .),v) | safen(65) =(v, m)} syn safe = .m:Mem.validmem(m) \n. safemem(m) (66) The judgment w . v : safe is an important one. A memory m is in a world w whenever \nw . validmem(m). Avaluev is safe in w when, for all m in w,the state(v, m) is safe for all the steps \nremaining in w. It is on the primitive constructor safe that we willbuild(in Section11) the notion of \ncodeptr, that is, continuation-pointer. 10. .-calculus The reader may skip this section without loss \nof compre\u00adhension of later sections. The main point of departure here is Ahmed s thesis [Ahm04], especially \nSection 3.3.5, which gives constructions used in de.ning the type constructor for arrow types. Our type \nsystem works well to classify the terms of sys\u00adtems of .-calculus, suchasthe onegiven below.Infact,all \nof our previous de.nitions apply without modi.cation; recall . def that for .-calculus we have SV = V \nand -u = u. e ::= () | x | l | .x. e | (e1e2) | new e | ! e | e1 := e2 (67) u, v ::= () | l | .x. e (68) \nThis is a .-calculus extended with mutable references. It s a contribution of our system that even in \nthe presence of such T-VAR T-ABS T-UNIT G(x)= t G[x := s] |= e : t G |= () : unit G |= x : t G |=(.x. \ne): s . t T-APP T-NEW G |= e1 : s . t G |= e2 : s G |= e : t G |=(e1e2): t G |=(new e): ref t T-DEREF \nT-ASSIGN G |= e : ref t G |= e1 : ref t G |= e2 : t G |= (! e): t G |=(e1 := e2): unit Figure 3. Typing \nrules speci.c to.-calculus references, impredicative type abstraction and type applica\u00adtion (and so \nforth) are coercions with no operational signi.\u00adcance;in particular, termsof quanti.edtypehavenoexplicit \nintroduction or eliminationforms, such as pack and un\u00adpack . Section 13.1 discusses how we achieve this. \nBecause we de.ne our types semantically, we decline to give an inductive de.nition for type expressions. \nMoreover we treat .-calculus ` a la Curry and omit type decorations from our terms.Weuse the standard \nsmall-step call-by-value operational semantics, and omit the rules for same. De.nitions of the primitive \ntype constructors, and those for quanti.ed, recursive, and reference types remain un\u00adchanged. It therefore \nremains to give semantics to the unit and arrow types; the typing judgments for closed terms, sub\u00adstitutions, \nand open terms; and to prove the typing lem\u00admas (which would be rules in a syntactic progress-and\u00adpreservation \nproof) for abstraction and application. First the typing judgment for closed terms. def e :(k,.)t = .j \n< k,m,m.,e. (69) (k, .) . validmem(m) . (m, e) .j (m,e.) . irred(m,e.) .... . (k, .)R=(k - j, ..) . (k \n- j, ..) . validmem(m.) . (k - j, ..) . e. : t The state (m, e) may step to (m,e.) which is irreducible \n(either a value or stuck);but since . e. : t only when e. is a value, then a well-typed term e cannot \nget stuck within k steps. There are two new type constructors of interest, prim unit = {(w, ()) | True}, \nand (70) syn t . s = .(t .. s), where (71) prim t .. s = {(w, .x. e) |.w, v.(w, v) . t . e[v/x]:w s}. \nFinally we de.ne the general typing judgment |= in terms of ground substitutions .: def . :w G= .x . \ndom G..(x):w G(x) def G |= e : t = .w, .. . :w G . .(e):w t The expected typing rules (Figure 3) can \nbe proved as lem\u00ad mas from the model. One of our major semantic innovations is the decomposi\u00adtion of \nfunction typesinto primitive notions such as safety. Equation 69 does not show this, because so far we \nhave worked out this more modular decomposition only in the von Neumann setting. Therefore the next section \nexplains this decomposition in terms of code pointers. 11. Machine instructions Sections 2 9 apply to \nmodels of computation ranging from .-calculus to von Neumann machines. Now we will dis\u00adcussvon Neumann \nmachines speci.cally.Alocationof type codeptr(t ) isthe addressofa continuationto whichit s safe to jump, \nproviding one passes an argument of type t . That is, if l . . codeptr(t ) then one can safely set the \nprogram counter to l, as long as the registers satisfy t . syn codeptr(t)= (72) .l:Loc. just l . .!(slot(pc, \njust l) . t . safe) At anytime strictly in the future, whenever it is the case that the program counter \n= l and the (other) registers satisfy t , then the state must be safe.6 A machine-instruction . is a \nrelation on machine states, . . State \u00d7State. If the program counter in state s1 points toa memory location \ncontaininga number n that codes for ., then the machine will step to a state s2 such that .(s1,s2). An \nexample of such an instruction is r3 . m(r2 + 9), which we can write as LOAD(3, 2, 9) = {((v1,m1), (v2,m2)) \n|v2(pc)= v1(pc)+1 . v2(3) = m1(v1(2) + 9). .i .. {3, pc}.v2(i)= v1(i) . m1 = m2} Anumbern codes for an \ninstruction . just when def n encodes . = .v1,m1,v2,m2. (73) m1(v1(pc)) = n . (v1,m1) . (v2,m2) . .((v1,m1), \n(v2,m2)) Programs. A von Neumann program p is a sequence of integers p(0),...,p(n - 1) such that each \np(i) encodes some instruction .i.For example, perhaps on some machine 6 Why strictly in the future whynot \nright now? The codeptr does not require . instead of . for two reasons: on the one hand, then it would \nnot be contractive; and on the other hand, executing a jump to location l takes at least one step, so \nwe don tneed the stronger . condition. Contrac\u00adtiveness is a useful property for codeptr, since it allows \nthe recursive type rec a. codeptr(a). 7320 encodes LOAD(3, 2, 0), we might have a program p = (7320, \n4231, 6007): Machine inst. . Pseudocode (74) 7320 LOAD(3, 2, 0) r3 . m(r2 + 0) 4231 ADDIMM(2, 3, 1) r2 \n. r3+1 6007 JUMP(7) pc . r7 Program-code types. For anyprogramp, de.ne syn .p = o.set(i, ref(just p(i))) \n(75) i.dom p (The domain of p is .nite; the .i.dom p is meta-notation for an expression with |dom p| \nconjuncts.)Forexample, our sample program p (equation 74) has, .0 = o.set(0, ref(just 7320)) .1 = o.set(1, \nref(just 4231)) .2 = o.set(2, ref(just 6007)) .p =.0 . .1 . .2 Type-checking the example program p. \nSuppose that on entry to location l, register r2 is a ref int and that register r7 isa codeptr(slot(2, \nint)), that is,a continuation that requires an integer in register 2. Then the program dereferences the \nref, adds 1, and continues by jumping to the address in r7. We can explain this asl :G where G= codeptr(slot(2, \nref int) . slot(7, codeptr(slot(2, int)))) Now we wish to prove that, in any world where this program \nis loaded at address l, then l is also a continuation as described by G.We write this claim as, .p . \nG Tan[TA06,Tan05]givesa compositional logic for con\u00ad trol .ow in which such statements can be proved. \nHe proves soundness of this logic using the indexed model. Our primi\u00adtives canexpressTan s semanticsina \nclean and simpleway. The form of an instruction-typing rule is ., . G . G. where . describes an instruction \nin memory at location l, G describes the type of the continuation at location l +1, and the conclusion \nG. claims the type of the continuation at l. Consider a LOAD(i, j, k) at location l.Asoundbut naive typing \nrule is, n encodes LOAD(i, j, k) i .= pc t necessary (76) ref(just n), . o.set(1, codeptr(slot(i, t ))) \n. codeptr(slot(j, o.set(k, ref t ))) That is, if the load instruction is at address l, and it s safe \nto continue at l +1 provided that register i has a value of type t, then it s also safe to continue at \nl provided that rj + k has a value of type ref t. This is insuf.ciently general: it neglects the fact \nthat all the registers other than i are not changed by the load instruction. Suppose we have a type f \nthat characterizes the typeof several registersbut leaves i unrestricted.We say, i is not in the domain \nof f, that is, def notindom(i, f)= (77) .w, v, u.(w, v) . f . (w, v[i:=u]) . f Astronger load rule is, \nn encodes LOAD(i, j, k) i =.pc t necessary f necessary notindom(i, f) notindom(pc,f) (78) ref(just n), \n. o.set(1, codeptr(f . slot(i, t ))) . codeptr(f . slot(j, o.set(k, ref t ))) With respect to our sample \nprogram p (equation 74) we can write the invariants for locations l +0 through l +2 as, G0 = o.set(0, \ncodeptr(f . slot(2, ref int))) G1 = o.set(1, codeptr(f . slot(3, int))) G2 = o.set(2, codeptr(f . slot(2, \nint))) (79) Gp =G0 . G1 . G2 where f = slot(7, codeptr(slot(2, int))) Then we can use rules for LOAD, \nADDIMM, and JUMP to show, .0, . G1 . G0 .1, . G2 . G1 (80) .2 . G2 The initial entry point. Let us assume \nthat the beginning of the program is at offset 0 in a complete program, and suppose thehypothesis foroffset \n0 is codeptr(top),meaning that it is (claimed) safe to jump to the beginning of the program regardless \nof the contents of the registers. Then by the rules of type intersection we have Gp . codeptr(top). Consequently \n(by equation 82) we have .p . codeptr(top). (83) Now we will show that this implies the program is safe. \n12. Soundness A von Neumann program is loaded at l in a machine-state (r, m) if r(pc)= l and for each \ni . dom p,m(l + i)= p(i). Lemma 12.1. If program p is loaded at l in machine-state (v, m), then for any \nnatural number k one can construct a world (k, .) suchthat, (k, .) .validmem(m) (84) (k, .) .v : slot(pc, \n.p) (85) Proof. The type constructors used in .p are very simple: just intersection, ref,andjust. Therefore \nwe can useasimple construction of .: .= {(l + i) .. .just p(i).k | i . dom p} We .rst check equation \n84, that is, by equation 27, if (k, .) . l. .. t, then (k, .) ..(m(l.) .. t ). By de.ni\u00ad tion 26, when \nthehypothesis holds, thereexists i . dom p such that l. = l + i and t = .just (p(i)).k. The conclu\u00ad 11.1 \nWhole-program typing The example program is not recursive and does not loop, so in our example, the proof \nfor each instruction i needs only . Gi+1. However, our type system is applicable to programs sion then \nbecomes (k, .) ..(m(l + i) .. .just (p(i)).k), that is, (k, .) ..(just (p(i)) ..just (p(i)).k). This \nis a with loops and recursion. Suppose i is a conditional branch consequence of lemma 7.1. to location \nj, then we need, We now consider equation 85. Leti . dom p and v. be a value.We have .i, .(Gj . Gi+1) \n. Gi. (k, .) . l + i .. .just p(i).k The general case is .i, . Gp . Gi. (k, .) .. teq(just p(i), .just \np(i).k). Tan s calculus for control .ow[TA06,Tan05] manages by de.nition 26 and lemma 7.1. Therefore, \nby equation 32, such proofs in a modular way. Given proofs of this form for (k, .) . l + i .. ref (just \np(i)). Hence, by equation 59, each i,we can combine them using rules fortype intersection (k, .) . l \n.. o.set(i, ref (just p(i))) for all i . dom p. By into, intersection, we get (k, .) . l .. .p.We conclude \nby equa\u00ad.p, . Gp . Gp (81) tion 15. So,in general,wehaveaprogram p and its associated .p. An oracle \n(perhaps a type-preserving compiler) provides a hypothesis Gp giving a codeptr type for each address. \nAn automatic type-checker uses our rules or syntax-directed specializationsof our rules,as describedbyWu[Wu05] \nto prove .p, . Gp . Gp. All ref types are necessary, and ne\u00adcessity is preserved by o.set and intersection, \ntherefore .p is necessary. Using the generalizedL\u00a8 ob rule (Corollary 4.5), we deduce that .p . Gp (82) \nThis means, in any world where the program code de\u00adscribed by .p is loaded, the loop-invariants Gp hold. \n Theorem 12.2 (Soundness). If program p is loaded at l in machine-state (v, m), and .p . codeptr(top), \nthen state (v, m) is safe (for any number of steps k). Proof. ByLemma 12.1, construct theworldw =(k +1, \n.). By Lemma 7.3, there exists a world w=(k, ..) such that wRw. and w. validmem(m). We have w . v : slot(pc, \n.p), and thus w . v : slot(pc, codeptr(top)). As the program is loaded at l, we also have w. v : slot(pc, \njust l). By equation 72 we get w. . v : safe, so by equation 66 we have w. . v : safemem(m).Byequation \n65, this means safek(v, m). We have established that our syntactic system is sound in the sense that \nevery well typed program is safe. This follows from thefact that each individual typing ruleis semantically \nvalid in our model (from the de.nition of ., equation 16). Even after we have proved Theorem 12.2 we \nmay add more typing rules, as long as we derive them semantically. 13. Related work 13.1 Impredicative \npolymorphism with references Here s a type isomorphism that one would expect to hold, in a system with \ncontinuation types and polymorphism: codeptr(.a. F (a)) ~(86) = .a. codeptr(F (a)). Let s consider in \nparticular a special case of the above, codeptr(.a:Type.a \u00d7 A \u00d7 codeptr(B)) ~ = .a:Type.codeptr(a \u00d7 A \n\u00d7 codeptr(B)) (87) where the left and right-hand sides are (de Morgan) dual ways of writing the CPS-and \nclosure-converted type of a function f : A . B.We re happy to say that the isomor\u00adphisms 86 and 87 hold \nin our system.We re also happy to say that in our system, none of the operations on values of quanti.ed \ntype existential pack and unpack, type abstrac\u00adtionand application requiretakingastepinthe operational \nsemantics. (As types are not manifest at runtime in a stati\u00adcally checked system, such steps would be \neffective no-ops, and thereforea nuisance.)Tohave bothof these properties simultaneously is a technical \nadvance over previous work [Ahm04], which presented two alternative models of quanti\u00ad .ers,eachofwhich \npossessedone propertybutnottheother. We believe Ahmed s set-theoretic model can be adjusted (by simplifying \nthe model of quanti.ed types) to eliminate this nuisance. However, it is not obvious how to directly \nfor\u00admalize such a repaired model or equally, the mathematics of Section 6 in a logic without dependent \ntypes, in par\u00ad ticular Church s higher-order logic (HOL). To our knowl\u00adedge, no previous attempt to express \nequation 28 in HOL coulddo better than the solutionless 25.Toavoid circular\u00ad ity in the HOL representation, \nAhmed chooses the range of (HOL-encoded) . to be a set of rei.ed syntactic type ex\u00adpressions. This causes \nthefailureof equation 87 in partic\u00ad ular, the left side (codeptr(.a. . . .)) has no useful seman\u00adtics, \nwhile the right side (.a.codeptr(...)) has the expected semantics. The Princeton FPCC compiler [CWAF03] \nworks around this problem by carefully using only the .codeptr formulation of function-closures.  13.2 \nApproximation modality The approximation modality is due to Nakano, who devel\u00adoped the idea in two papers. \nThe .rst paper [Nak00] intro\u00ad duces a type system with recursive types and an approxi\u00admation modality \n (to which our . is directly analogous), which for example allows the derivation . Y :( X . X) . X, \n where Y is the .xed-point combinator. The approximation modality allows, even in the presence of recursive \ntypes, a strongly normalizing calculus that may be sensibly used as a logic. The second paper [Nak01] \ngeneralizes the .rst, and makes precise the relationship to the intuitionistic version of theG\u00a8odel-L\u00a8ob \nlogicof provability. Our work builds on and departs from Nakano s in two principal ways. First, we use \nthe approximation modality in calculi that arebydesign capableof nontermination. Second, our main contribution \nis to show how the approximation modality is not just a modality for recursion, but also a modality for \nmutable references, and in general a modality for realizing inductive properties of small-step programs. \n 13.3 XCAP Shao et al. s Certi.ed Assembly Programming [YHS03, NS06] is based directly on the calculus \nof inductive con\u00adstructions. Like our system, CAP/XCAP supports separate veri.cation of code modules, \npermits impredicative quan\u00adti.cation and (with extensions) mutable references, and is expressive enough \nto specify invariants for assembly code. Theyachieve impredicativity by means of a syntactic speci\u00ad.cationofvalidity \nrulesfor impredicative propositions. This method does not permit elimination rules for the quanti.ers, \nbut they show how to work around the lack of elimination rules when existentials appear at top level \nin Hoare rules, whichis good enough foraTAL. 14. Conclusion Previous work broke functions and data structures \ninto sim\u00adpler constructs thatis,existential quanti.ers, address arith\u00admetic, unions, intersections, all \nappliedto .rst-order contin\u00aduations and immutable or mutable references. But here we have shown (equations \n32, 62, 72) that .rst-order continua\u00ad tions(codeptr)and references(iref, ref)can themselves be broken \ndown into simpler concepts, each of which is a type operator: safe models program safety, . models induction \nover future steps, . models type preservation, ! constructs logical statements about the current world. \nThis decomposi\u00adtion allows simpler and .ner reasoning about the interaction of instructions with types, \nand allows the easier construction of new types. Our semantic model is powerful: it is the .rst model \nof references with impredicativity in which all the expected identities hold. It is versatile: it can \nexpress in a natural way all the types needed for typed assembly languages. It is modular: the vast majority \nof our de.nitions and lemmas apply equally to .-calculus, von Neumann machines, and other useful abstract \nmachines. It is compositional: there are a few simple primitives, from which everything else is constructed. \nIt is sound: we have machine-checked proofs CUT INTERSECTION-R ID t1 . t2 t2 . t3 s . t1 s . t2 t . t \nt1 . t3 s . t1 . t2 INTERSECTION-L-1 INTERSECTION-L-2 t1 . t2 . t1 t1 . t2 . t2 UNION-L UNION-R-1 UNION-R-2 \nt1 . st2 . s t1 . t1 . t2 t2 . t1 . t2 t1 . t2 . s IMPLIES-I IMPLIES-E TOP-R BOT-L s . t1 . t2 s . t1 \n. t2 t . top bot . t s . t1 . t2 s . t1 . t2 LATER-LIFT LATER-FIX LATER-REP s . t . t . t . t . .. t \n. s . . t top . t LATER-INTERSECTION LATER-TOP . s . . t . .(s . t) top . . top Figure 4. G\u00a8ob logic \nodel-L\u00a8 LATER-SLOT JUST-UNIQUE just l . just l. . t [l] . t[l.] LATER-JUST just l . . just l LATER-JUST-2 \njust l . . t . .(just l . t) SOMEWHERE-JUST top .? just l SLOT-LIFT s . t slot(j, . t) . . slot(j, t)slot(j, \ns) . slot(j, t ) Figure 5. Just and slot forthevon Neumannversion.Itis operational:the statement of the \nsoundness theorem guarantees directly an untyped notion of safety. Finally,it is semantic: the modal \noperator . later explains the essence of approximation over the remaining steps of computation, in a \nway that allows us to better understand old types and better invent new ones. Future work. Using this \nconcise and easily representable model, we expect that machine-checked soundness proofs of usableTALs \nwill be substantially smaller than those at\u00adtempted to date [Cra03, App01]. Acknowledgments We thank \nJames Leifer, Amal Ahmed, and Zhong Shao for comments on earlier drafts of the paper. FORALL-R t . s \nt . x not free in t .x:A.s FORALL-L a . A .x:A.t . t[a/x] EXISTS-L s . t .x: x not free in t A.s . t \nEXISTS-R a . A t [a/x] . .x:A.t LATER-FORALL .x:A. . t . . .x:A.t Figure 6. Quanti.cation EVERYWHERE-LIFT \n?s .!t s . t !s .!t EVERYWHERE-REP !t .!!t EVERYWHERE-L EVERYWHERE-INTERSECTION !t . t !s.!t .!(s . t) \nEVERYWHERE-TOP LATER-EVERYWHERE top .!top ! . t . .!t EVERYWHERE-LATER EVERYWHERE-IMPLIES .!t .! . t \n!(s . t) .?s .?t SOMEWHERE-L s .!t EVERYWHERE-SOMEWHERE ?t .!?t LATER-SOMEWHERE ? . t . .?t Figure 7. \nQuanti.cation over values in a world References [AAV02] Amal Ahmed, AndrewW. Appel, and RobertoVirga. \nAstrati.ed semantics of general references embeddable in higher-order logic. In 17th Annual IEEE Symp. \non Logic in Computer Science, pp. 75 86, June 2002. [AF00] AndrewW.AppelandAmyP.Felty.Asemanticmodelof \ntypes and machine instructions for proof-carrying code. In POPL 00: 27th ACM SIGPLAN-SIGACT Symp. on \nPrinciples of Programming Languages, pp. 243 253, Jan. 2000. [Ahm04] Amal J. Ahmed. Semantics ofTypes \nfor Mutable State. PhD thesis, Princeton University, Princeton, NJ, Nov. 2004. Tech Report TR-713-04. \n[AM01] AndrewW. Appel and David McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. ACMTrans.onProgrammingLanguagesand Systems, 23(5):657 683, Sept. 2001. [App01] AndrewW. Appel. \nFoundational proof-carrying code. In Symp. on Logic in Computer Science (LICS 01), pp. 247 258. IEEE, \n2001. [B+98] Bruno Barras et al. The Coq Proof Assistant reference manual. Technical report, INRIA, 1998. \n[BW83] Michael Barr and CharlesWells. Toposes,Triples and Theories. Grundlehren der math.Wissenschaften. \nSpringer Verlag, 1983. Reprint 12 in Theory and Applications of Category, //www.emis.de/journals/TAC/. \n[Cra03] Karl Crary. Toward a foundational typed assembly language. In POPL 03: 30thACM Symp. on Principles \nof Programming Languages, pp. 198 212, 2003. [CWAF03] Juan Chen, DinghaoWu, AndrewW. Appel, and Hai Fang. \nAprovably soundTAL for back-end optimization. In PLDI 03: Proc. 2003ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pp. 208 219, June 2003. [Kri63] Saul A. Kripke. Semantical considerations \non modal logic. In Proceedingsofa Colloquium: ModalandManyValued Logics, vol. 16, pp. 83 94, 1963. [MM91] \nJohn C. Mitchell and Eugenio Moggi. Kripke-style models for typed lambda calculus. Annals of Pure and \nApplied Logic, 1991. [MPS86] David MacQueen, Gordon Plotkin, and Ravi Sethi. An ideal model for recursive \npolymophic types. Information and Computation, 71(1/2):95 130, 1986. [MV05] Paul-Andre Melli\u00b4es and J`\u00b4ome \nVouillon. er Recursive polymorphic types and parametricity in an operational framework. In IEEE Symp. \non Logic in Computer Science (LICS 05), 2005. [Nak00] Hiroshi Nakano. Amodality for recursion. In LICS \n00: 15th Annual IEEE Symp. on Logic in Computer Science, pp. 255 266.I EEE Computer Society Press, 2000. \n[Nak01] Hiroshi Nakano. Fixed-point logic withthe approxima\u00adtion modality and its Kripke completeness. \nIn Theoretical Aspects of Computer Software, vol. 2215 of LNCS, pp. 165 182. Springer, 2001. [NS06] Zhaozhong \nNi and Zhong Shao. Certi.ed assembly programming with embedded code pointers. In 33rdACM Symp. on Principles \nof Programming Languages, pp. 320 333.ACM Press, Jan. 2006. [PM93] ChristinePaulin-Mohring. Inductive \nde.nitions in the system Coq; rules and properties. In M. Bezem and J.F. Groote, editors, Proc. International \nConference onTyped Lambda Calculi and Applications, vol. 664, pp. 328 345. SpringerVerlag Lecture Notesin \nComputer Science, 1993. [TA06] GangTan and AndrewW. Appel.Acompositional logic for control .ow. In 7th \nInternational Conference on Veri.cation, Model Checking and Abstract Interpretation (VMCAI 06), pp. 80 \n94, Jan. 2006. [Tan05] GangTan. ACompositional Logic for Control Flow and its ApplicationtoFoundationalProof-Carrying \nCode. PhD thesis, PrincetonUniversity,Princeton,NJ,Aug. 2005.Tech Report CS-TR-731-05. [Wu05] DinghaoWu. \nInterfacing Compilers, Proof Checkers, and Proofs forFoundationalProof-Carrying Code. PhD thesis, Princeton \nUniversity, Aug. 2005. [YHS03] Dachuan Yu, Nadeem A. Hamid, and Zhong Shao. Building certi.ed libraries \nfor PCC: Dynamic storage allocation. In Proc. 2003 European Symp. on Programming (ESOP 03), April 2003. \nA. Allocation and initialization Our type system can express the invariants of data structures that managearegion \ncalculus(atyped malloc/free system, or agarbage collector). Such type systems are not new [AF00, CWAF03, \nAhm04, Wu05]. Here we brie.y illustrate how our new type system can express the necessary invariants \njust using the primitives we have already de.ned. The simplest possible such data structure is an integer \nvariable that de.nes the boundary between allocated and unallocated memory. We de.ne boundary(l) to mean \nthat every address = l is unallocated, i.e. not in the domain of .: syn boundary l = .l.:Loc..t:Type.l. \n.. t . greater(l, l.) (88) Nowwegivea rule for type-checking STORE(i, 0,j) (i.e., m(r(i) + 0) . r(j))when \nit serves to initialize a new reference: n encodes STORE(i, 0,j) t necessary f necessary notindom(pc,f) \nP = f ..l:Loc.boundary l . slot(i, just l) . slot(j, t ) Q = f ..l:Loc.boundary(l + 1) . slot(i, just \nl . ref t) ref(just n), . o.set(1, codeptr(Q)) . codeptr(P ) (89) Before the instruction, register \ni points at the boundary. The instruction does not modify i,but does modify the boundary, in that the \ndomain of . in the new world has moved. The same store instruction, when it is used for the differ\u00adent \npurpose of updating an existing ref, has this typing rule: n encodes STORE(i, 0,j) B = boundary l t necessary \nf necessary notindom(pc,f) P = B . f . slot(i, ref t) . slot(j, t) ref(just n), . o.set(1, codeptr(B \n. f)) . codeptr(P ) (90) Of course, both of these rules for STORE must be proved as derived lemmas from \nthe de.nition in our model. By provingevery typing rule asa derived lemma, we thus prove soundness of \nthe rules.  \n\t\t\t", "proc_id": "1190216", "abstract": "We present a model of recursive and impredicatively quantified types with mutable references. We interpret in this model all of the type constructors needed for typed intermediate languages and typed assembly languages used for object-oriented and functional languages. We establish in this purely semantic fashion a soundness proof of the typing systems underlying these TILs and TALs---ensuring that every well-typed program is safe. The technique is generic, and applies to any small-step semantics including &#955;-calculus, labeled transition systems, and von Neumann machines. It is also simple, and reduces mainly to defining a Kripke semantics of the G&#246;del-L&#246;b logic of provability. We have mechanically verified in Coq the soundness of our type system as applied to a von Neumann machine.", "authors": [{"name": "Andrew W. Appel", "author_profile_id": "81100498630", "affiliation": "Princeton University, INRIA Rocquencourt", "person_id": "PP14174176", "email_address": "", "orcid_id": ""}, {"name": "Paul-Andr&#233; Melli&#232;s", "author_profile_id": "81100411479", "affiliation": "CNRS Universit&#233; Paris 7", "person_id": "P523724", "email_address": "", "orcid_id": ""}, {"name": "Christopher D. Richards", "author_profile_id": "81100451830", "affiliation": "Princeton University", "person_id": "P831280", "email_address": "", "orcid_id": ""}, {"name": "J&#233;r&#244;me Vouillon", "author_profile_id": "81100141421", "affiliation": "CNRS Universit&#233; Paris 7", "person_id": "PP31029138", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190235", "year": "2007", "article_id": "1190235", "conference": "POPL", "title": "A very modal model of a modern, major, general type system", "url": "http://dl.acm.org/citation.cfm?id=1190235"}