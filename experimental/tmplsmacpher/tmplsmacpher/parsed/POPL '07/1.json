{"article_publication_date": "01-17-2007", "fulltext": "\n Operational Semantics for Multi-Language Programs Jacob Matthews Robert Bruce Findler University of \nChicago {jacobm, robby}@cs.uchicago.edu Abstract Inter-language interoperability is big business, as \nthe success of Mi\u00adcrosoft s .NET and COM and Sun s JVM show. Programming lan\u00adguage designers are designing \nprogramming languages that re.ect that fact SML#, Mondrian, and Scala, to name just a few ex\u00adamples, \nall treat interoperability with other languages as a central design feature. Still, current multi-language \nresearch tends not to focus on the semantics of interoperation features, but only on how to implement \nthem ef.ciently. In this paper, we take .rst steps to\u00adward higher-level models of interoperating systems. \nOur technique abstracts away the low-level details of interoperability like garbage collection and representation \ncoherence, and lets us focus on se\u00admantic properties like type-safety and observable equivalence. Beyond \ngiving simple expressive models that are natural com\u00adpositions of single-language models, our studies \nhave uncovered several interesting facts about interoperability. For example, higher\u00adorder contracts \nnaturally emerge as the glue to ensure that inter\u00adoperating languages respect each other s type systems. \nWhile we present our results in an abstract setting, they shed light on real multi-language systems and \ntools such as the JNI, SWIG, and Haskell s stable pointers. Categories and Subject Descriptors D.3.1 \n[Programming Lan\u00adguages]: Formal De.nitions and Theory Semantics General Terms Languages, theory Keywords \nInteroperability, multi-language systems, operational semantics 1. Introduction A modern large-scale \nsoftware system is likely written in a vari\u00adety of languages: its core might be written in Java, while \nit has specialized system interaction routines written in C and a web\u00adbased user interface written in \nPHP. And even academic languages have caught multi-language programming fever, perhaps due to temptingly \nlarge numbers of pre-existing libraries written in other languages. This has prompted language implementors \nto target COM[18,41], Java VirtualMachine bytecode [7,27,34],and most recently Microsoft s Common Language \nRuntime [8, 32, 36]. Fur\u00adthermore, where foreign function interfaces have historically been used in practice \nto allow high-level safe languages to call libraries written in low-level unsafe languages like C (as \nwas the motivation Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001. \n. . $5.00. for the popular wrapper generator SWIG [5]), these new foreign function interfaces are built \nto allow high-level, safe languages to interoperate with other high-level, safe languages, such as Python \nwith Scheme [33] and Lua with OCaml [39]. Since these embeddings are driven by practical concerns, the \nresearch that accompanies them rightly focuses on the bits and bytes of interoperability how to represent \ndata in memory, how to call a foreign function ef.ciently, and so on. But an important theoretical problem \narises, independent of these implementation\u00adlevel concerns: how can we reason formally about multi-language \nprograms? This is a particularly important question for systems that involve typed languages, because \nwe have to show that the embeddings respect their constituents type systems. In this paper we present \na simple method for giving operational semantics to multi-language systems. Our models are rich enough \nto support a wide variety of multi-language embedding strategies, and powerful enough that we have been \nable to use them for type soundness and contextual equivalence proofs. Our technique is based on simple \nconstructs we call boundaries, cross-language casts that regulate both control .ow and value conversion \nbetween languages. We introduce boundaries through series of operational semantics in which we combine \na simple ML-like language with a simple Scheme-like language. In section 2, we introduce those two constituent \nlanguages for\u00admally and connect them using a primitive embedding where values in one language are opaque \nto the other. In section 3, we enrich that embedding so that boundaries use type information to convert \none language s values into their counterparts in the other, and we show that this embedding naturally \nleads to higher-order contracts. Section 4 shows a surprising relationship between the expressive power \nof these two embeddings, and section 5 shows how the sys\u00adtem scales beyond purely type-directed conversion. \n 2. The lump embedding To begin, we pick two languages, give them formal models, and then tie those formal \nmodels together. In the interest of focusing on interoperation rather than the special features of particular \nlan\u00adguages, we have chosen two simple calculi: an extended model of the untyped call-by-value lambda \ncalculus, which we use as a stand-in for Scheme, and an extended model of the simply-typed lambda calculus, \nwhich we use as a stand-in for ML (though it more closely resembles Plotkin s PCF without .xpoint operators \n[37]). Figure 1 presents these languages in an abstract manner that we in\u00adstantiate multiple ways to \nmodel different forms of interoperability. One goal of this section is to explain that .gure s peculiarities, \nbut for now notice that aside from unusual subscripts and font choices, the two language models look \npretty much as they would in a nor\u00admal Felleisen-and-Hieb-style presentation [15]. To make the preparation \nmore concrete, as we explain our pre\u00adsentation of the core models we also simultaneously develop our \n.rst interoperation model, which we call the lump embedding. In the lump embedding, ML values can appear \nin Scheme and e = x |v |(ee) |(op ee) |(if0 eee) v =(. x : t . e) |n op = + |- t = .|t .t x = ML variables \n(distinct from Scheme variables) E = []M |(Ee) |(vE) |(op Ee) |(op vE) |(if0 Eee) G, x : t1 fM e : t2 \nG, x : t fM x : t G fM (. x : t1 . e): t1 .t2 G fM n : . G fM e1 : t1 .t2 G fM e2 : t1 G fM e1 : . G \nfM e2 : . G fM (e1 e2): t2 G fM (op e1 e2): . G fM e1 : . G fM e2 : t G fM e3 : t G fM (if0 e1 e2 e3): \nt E[((. x : t . e) v)]M .E[e[x / v]] E[(+ n1 n2)]M .E[n1 + n2] E[(-n1 n2)]M .E[max(n1 -n2, 0)] E[(if0 \n0 e1 e2)]M .E[e1] E[(if0 n e1 e2)]M . E[e2](where n=0) e = x|v|(ee) |(op ee) |(if0 eee) |(pr e) |(wrong \nstr) v =(. x. e) |n op = + |- pr = proc? |nat? x = Scheme variables (distinct from ML variables) E = \n[]S |(Ee) |(vE) |(op Ee) |(op vE) |(if0 Eee) |(pr E) G, x: TST fS e: TST \u00b7\u00b7\u00b7 G, x: TST fS x: TST G fS \n(. x. e): TST E[((. x. e) v)]S E[v1 v2]S E[(+ n1 n2)]S E[(-n1 n2)]S E[(op v1 v2)]S E[(if0 0 e1 e2)]S \nE[(if0 ve1 e2)]S E[(proc? (. x. e))]S E[(proc? v)]S E[(nat? n)]S E[(nat? v)]S E[(wrong str)]S . E[e[x/ \nv]] . E[wrong non-proc ] (v1 = .x.e) . E[n1 + n2] . E[max(n1 -n2, 0)] . E[wrong non-num ] (v1 = n or \nv2 = n) . E[e1] . E[e2](v = 0) . E[0] . E[1](v =(.x.e)) . E[0] . E[1](v = n) . Error: str Figure 1. \nModels of ML (left) and Scheme (right), primed for interoperability Scheme values can appear in ML. However, \nML treats Scheme val\u00adues as opaque lumps that cannot be used directly, only returned to Scheme; likewise \nML values are opaque lumps to Scheme. For in\u00adstance, we allow ML to pass a function to Scheme and then \nuse it again as a function if Scheme returns it; but we do not allow Scheme to use that same value as \na function directly or vice versa. The lump embedding is a conveniently simple example, but it is worth \nattention for other reasons as well. First, it represents a par\u00adticularly easy-to-implement useful multi-language \nsystem, achiev\u00adable more or less automatically for any pair of programming lan\u00adguages so long as both \nlanguages have some notion of expressions that yield values. Second, it corresponds to real multi-language \nsys\u00adtems that can be found in the wild : many foreign function inter\u00adfaces give C programs access to \nnative values only as pointers that C can only use by returning to the host language. For instance this \nis how stable pointers in the Haskell foreign function interface be\u00adhave [12]. Where possible, we have \ntypeset the nonterminals of our ML language using a bold font with serifs, and those of our Scheme language \nwith a light sans-serif font. For instance, e means the ML expression nonterminal and e means the Scheme \nexpression nonterminal. These distinctions are meaningful. Occasionally we use a subscript instead of \na font distinction in cases where the font difference would be too subtle. 2.1 Syntax The syntaxes of \nthe two languages we use as our starting point are shown in .gure 1. On the ML side, we have taken the \nexplicitly\u00adtyped lambda calculus syntax and added numbers (where n indi\u00adcates the syntactic term representing \nthe number n) and a few built\u00adin primitives including an if0 form. On the Scheme side, we have taken \nan untyped lambda calculus syntax and added the same ex\u00adtensions plus some useful predicates and a wrong \nform that takes a literal error message string. To extend that base syntax with the ability to interoperate, \nwe introduce syntactic boundaries between ML and Scheme, a kind of cross-language cast that indicate \na switch of languages. The extension is shown in .gure 2. e = \u00b7\u00b7\u00b7|(tMS e) v = \u00b7\u00b7\u00b7|(LMS v) t = \u00b7\u00b7\u00b7|L E \n= \u00b7\u00b7\u00b7|(tMS E) E G fS e: TST G fM (tMS e): t e = \u00b7\u00b7\u00b7|(SM t e) v = \u00b7\u00b7\u00b7|(SM t v) where t = L E = \u00b7\u00b7\u00b7|(SM \nt E) = E G fM e : t G fS (SM t e): TST E[(tMS(SM t v))]M .E[v] E[tMS v]M .E[(tMS (wrong Bad value ))] \nif v v) and t= L =(SM t E[(SM L (LMS v))]S .E[v] Figure 2. Extensions to .gure 1 to form the lump embedding \n Concretely we add boundaries as a new kind of expression in each language. In ML, we extend e to also \nproduce (tMS e) (think of MS as ML-outside, Scheme-inside ) and we extend Scheme s eto also produce (SM \nt e) ( Scheme outside, ML inside ) where the t on the ML side of each boundary indicates the type ML \nwill consider the expression on its side of the boundary to be. 2.2 Typing rules In .gure 1, ML has \na standard type system with the typing judg\u00adment fM where numbers have type . and functions have arrow \ntypes. Scheme has a type system with the judgment fS that gives all closed terms the type TST ( the Scheme \ntype ). We have omitted several typing rules from the Scheme side; every Scheme expres\u00adsion has a rule \nthat gives it type TST if its subparts have type TST. In our lump embedding extension, we add a new type \nL (for lump ) to ML and we add two new typing rules, one for each new syntactic form. The new Scheme \njudgment says that an (SM t e) boundary is well-typed if ML s type system proves e has type t that is, \na Scheme program type-checks if it is closed and all its ML subterms have the types the program claims \nthey have. The new ML judgment says that (tMS e) has type t if etype-checks under Scheme s typing system. \nIn both cases, t can be any type, not just L as one might expect. If t = L we are sending a native Scheme \nvalue across the boundary (which will be a lump in ML); if t = L we are sending an ML value across the \nboundary (which will be a lump in Scheme). In these typing judgments, Scheme rules use the same type \nenvironment that ML does. We do that to allow ML expressions to refer to variables bound by ML (or vice \nversa) even if they are separated by a sequence of boundaries. This is necessary to give types to functions \nthat use foreign arguments, as we shall see.  2.3 Operational semantics We use Felleisen and Hieb-style \nreduction semantics to specify op\u00aderational semantics for our systems. In .gure 1, we de.ne an eval\u00aduation \ncontext for ML (E) and one for Scheme (E), and weuse a third, unspeci.ed evaluation context (E) to represent \nthe top-level context. In examples in this paper, we will assume E = E and thus that the top-level program \nis written in ML; we could set E = E to reverse that assumption. To allow Scheme expressions to evaluate \ninside ML expressions and vice versa, we de.ne evaluation con\u00adtexts mutually recursively at boundaries: \nE produces (tMS E) and E produces (SM t E). The reduction rules in the core model are all reasonably \nstan\u00addard, with a few peculiarities. On the ML side, we allow subtraction of two numbers but .oor all \nresults at zero. The Scheme side has a bit more going on dynamically. Since Scheme s type system does \nnot protect it, we add dynamic checks to every appropriate form that reduce to wrong if they receive \nan illegal value. The reduction rule for wrong itself discards the entire program context and aborts \nthe program with an error message. To combine the languages, we might hope to just merge their sets of \nreductions together. That does not quite work. For instance, the ML term ((.x : ..x)(1 1)) would reduce \nto (wrong Non-procedure ), rather than getting stuck, since Scheme s reduction for a non-procedure application \nwould apply to (1 1). To remedy this, we extend Felleisen and Hieb s context-sensitive rewriting framework \nby differentiating []M holes generated by ML evaluation contexts from []S holes generated by Scheme evalu\u00adation \ncontexts. Scheme s rewriting rules only apply to evaluation contexts with []S holes, (and similarly for \nML); we indicate that restriction by writing an S (or M) subscript next to the bracket on each evaluation \ncontext on the left-hand side of Scheme s (or ML s) rewriting rules.1 With this extension, the example \nabove decomposes into the context ((.x : ..x)[ ]M ) but not ((.x : ..x)[ ]S ). Because the hole is named \n[]M and the Scheme application rule only applies to holes named []S , the term remains stuck. However, \nif instead we had written ((.x : ..x)(.MS (1 1))) it would decompose into an ML context with a Scheme \nhole: ((.x : ..x)(.MS []S )) with the erroneous application (1 1) inside. Since that redex is in a Scheme \nhole it would reduce to an error. To .nish the lump embedding, all that remains is to specify the reduction \nrules and values for the boundaries between languages. If an MS boundary of type L has a Scheme value \ninside, then the boundary is an ML value. Similarly, when an SM boundary of a non-lump type has an ML \nvalue inside, then it is a Scheme value. However, MS boundaries with a non-lump type that contain Scheme \nvalues and SM boundaries of type L that contain ML values should reduce, since they represent foreign \nvalues returning 1 We could also have introduced two different notations for Scheme and ML application, \nbut we .nd it inelegant; it suggests that a multi-language implementation would decide how to evaluate \neach term by inspecting it, when real systems decide how to evaluate a term based on the language in \nwhich the term is being evaluated i.e., its context. Also, this is the same extension we made in earlier \nwork to model Scheme s multiple values [30]. to a native context. We do that by cancelling matching \nboundaries, as the reduction rules in .gure 2 show. ML s typing rules guarantee that values that appear \ninside (SM Lv) expressions will in fact be lump values, so the SM L reduction can safely restrict its \nattention to values of the correct form. Scheme offers no such guarantee, so the rule for eliminating \nan tMS boundary must apply whenever the Scheme expression is a value at all. These additions give us \na precise account of the behavior for lump embedding we described at the beginning of this section. To \nget a sense of how the calculus works, consider this example: ((. fa : L. L. L.((fa (LMS (. x .(+ x 1)))) \n(LMS 3))) (. f : L. . x : L.(LMS ((SM Lf)(SM Lx))))) . 2 (LMS ((SM L(LMS (.x.(+ x 1)))(SM L (LMS 3))))) \n . 2 (LMS ((.x.(+ x 1)) 3)) .2 (LMS 4)  In the initial term of this reduction sequence, we use a left-left\u00adlambda \nencoding of let to bind the name fa (for foreign-apply ) to a curried ML function that takes two foreign \nvalues, applies the .rst to the second, and returns the result as another foreign value. The program \nuses fa to apply a Scheme add-one function to the Scheme number 3. In two computation steps, we plug \nin the Scheme function and its argument into the body of fa.In that term there are two instances of (SM \nL (LMS v)) subterms, both of which are cancelled in the next two computation steps. After those cancellations, \nthe term is just a Scheme application of the add-one function to 3, which reduces to the Scheme value \n4. If we try to apply the ML add-one function to the Scheme number 3 instead (and adjust fa s type to \nmake that possible), we will end up with an intermediate term like this: (.MS ((SM ...(.x : ..(+ x 1))) \n3)) .2 Error: non-procedure Here, Scheme tries to apply the ML function directly, which leads to a runtime \nerror since it is illegal for Scheme to apply ML functions. We cannot make the analogous mistake and \ntry to apply a Scheme function in ML, since terms like ((LMS (.x.(+ x 1))) 3) are ill-typed. The formulation \nof the lump embedding in .gure 2 allows us to prove type soundness in the standard way, by establishing \npreserva\u00adtion and progress lemmas. Notice that because of the way we have combined the two languages, \ntype soundness entails that both lan\u00adguages are type-sound with respect to their own type systems in \nother words, that both single-language type soundness proofs are special cases of the soundness theorem \nfor the entire system. Theorem 1 (Lump type soundness). If G fM e : t , then either e . * v, e . * Error:str, \nor e diverges. Proof. (Sketch) A mutually-recursive variation on the standard preservation and progress \nlemmas. Proofs of this and the other theorems in this paper are available in this paper s companion technical \nreport, University of Chicago CS TR-2006-10.  3. The natural embedding The lump embedding is a useful \nstarting point, but many multi\u00adlanguage systems offer richer cross-language communication prim\u00aditives. \nA more natural way to pass values between our Scheme and ML models, suggested many times in the literature \n(e.g., [6,35,39]) is to use a type-directed strategy to convert ML numbers to equiva\u00adlent Scheme numbers \nand ML functions to equivalent Scheme func\u00adtions (for some suitable notion of equivalence) and vice versa. \nWe call this the natural embedding. We can quickly get at the essence of this strategy by extending the \ncore calculi from .gure 1, just as we did before to form the lump embedding. Again, we add new syntax \nand reduction rules to .gure 1. In this section we will add tMSN and SM t boundaries, N adding the subscript \nN (for natural ) to distinguish these new boundaries from lump boundaries from section 2. We will assume \nwe can translate numbers from one language to the other, and give reduction rules for boundary-crossing \nnumbers based on that assumption: E[(SM . N n)]S .E[n] E[(.MSN n)]M .E[n] In some multi-language settings, \ndiffering byte representations might complicate this task. Worse, some languages may have more expansive \nnotions of numbers than others for instance, the actual Scheme language treats many different kinds \nof numbers uniformly (e.g., integers, .oating-point numbers, arbitrary precision rationals, and complex \nnumbers are all operated on by the same operators), whereas the actual ML language imposes much more \nstructure on its number representations. More sophisticated versions of the above rules would address \nthese problems straightforwardly. We must be more careful with procedures, though. We can\u00adnot get away \nwith just moving the text of a Scheme procedure into ML or vice versa; aside from the obvious problem \nthat their grammars generate different sets of terms, ML does not even have a reasonable equivalent for \nevery Scheme procedure. Instead, for this embedding we represent a foreign procedure with a proxy. We \nrepresent a Scheme procedure in ML at type t1 .t2 by a new pro\u00adcedure that takes an argument of type \nt1, converts it to a Scheme equivalent, runs the original Scheme procedure on that value, and then converts \nthe result back to ML at type t2. For example, the scheme function f becomes (.x : t1.(t2MSN (f (SM t1 \nx)))) N when embedded in ML. Since function arguments .ow in the op\u00adposite direction from function results, \nthe boundary that converts the argument to the Scheme function must be an SM t1 boundary, N not an t1MSN \nboundary. This would complete the natural embedding, but for one im\u00adportant problem: the system has stuck \nstates, since a boundary might receive a value of an inappropriate shape. Stuck states violate type-soundness, \nand in an implementation they might correspond to segmentation faults or other undesirable behavior. \nAs it turns out, higher-order contracts [16,17] arise naturally as the checks re\u00adquired to protect against \nthese stuck states. We show that in the next three sections: .rst we add dynamic guards directly to boundaries \nto provide a baseline, then show how to separate them, and .nally observe that these separated guards \nare precisely contracts between ML and Scheme, and that since ML statically guarantees that it always \nlives up to its contracts, we can eliminate their associated dynamic checks. 3.1 A simple method for \nadding error transitions In the lump embedding, we can always make a single, immediate check that would \ntell us if the value Scheme provided to ML was consistent with the type ML ascribed to it. This is no \nlonger pos\u00adsible, since we cannot know if a Scheme function always produces a value that can be converted \nto the appropriate type. Still, we can perform an optimistic check that preserves ML s type safety: when \na Scheme value crosses a boundary, we only check its .rst-order qualities i.e., whether it is a number \nor a procedure. If it has the appropriate .rst-order behavior, we assume the type ascription is correct \nand perform the conversion, distributing into domain and range conversions as before. If it does not, \nwe immediately signal an error. This method works to catch all errors that would lead to stuck states. \nAlthough it only checks .rst-order properties, the pro\u00ad   gram can only reach a stuck state if a value \nis used in such a way that it does not have the appropriate .rst-order properties anyway. To model this \nmethod, rather than adding the SM t and tMSN N constructs to our core languages from .gure 1, we instead \nadd guarded versions GSM t and MSGt shown in .gure 3. These rules translate values in the same way that \nSM t and tdid N MSN before, but also detect concrete, .rst-order witnesses to an invalid type ascription \n(i.e., numbers for procedures or procedures for num\u00adbers) and abort the program if one is found. We call \nthe language formed by these rules the simple natural embedding. We give its rules in .gure 3, but it \nmay be easier to understand how it works by reconsidering the examples we gave at the end of section \n2. Each of those examples, modi.ed to use the natural embedding rather than the lump embedding, successfully \nevaluates to the ML num\u00adber 4. Here is the reduction sequence produced by the last of those examples, \nwhich was ill-typed before: ((MSG... (.x.(+ x 1))) 3) . ((.x. : ..(MSG. ((.x.(+ x 1)) (GSM . x')))) \n3)  . (MSG. ((.x.(+ x 1)) (GSM . 3)))  . (MSG. ((.x.(+ x 1)) 3))  .2 (MSG. 4) .4  ML converts the \nScheme add-one function to an ML function with type . .. by replacing it with a function that converts \nits argument to a Scheme number, feeds that number to the original Scheme function, and then converts \nthe result back to an ML number. Then it applies this new function to the ML number 3,which gets converted \nto the Scheme number 3, run through the Scheme function, and .nally converted back to the ML number 4,which \nis the program s .nal answer.   The method works at higher-order types because it applies type conversions \nrecursively. Consider this expression: (...).. (MSN (.f. (if0 (f 1) 2 f)))) Depending on the behavior \nof its arguments, the Scheme procedure may or may not always produce numbers. ML treats it as though \nit de.nitely had type (. ..) .., and wraps it to the ML value ... .x : . ...(.MSN ((.f.if0 (f 1) 2 f)(SMN \nx))) Whenever this value is applied to a function, that function is converted to a Scheme value at type \n. .. and the result is con\u00adverted from Scheme to ML at type .. Thus, intuitively, conversion in either \ndirection works at a given type if it works in both direc\u00adtions at all smaller types. Theorem 2. If fM \ne : t , then either e . * v, e . * Error:str, or e diverges. 3.2 A re.nement: guards Adding dynamic \nchecks to boundaries themselves is an expedient way to ensure type soundness, but we .nd it a little \ntroublesome. For one thing, boundaries are necessarily the core of any multi\u00adlanguage system, so they \nshould be as small and simple as possible. For another, coupling the task of value conversion with the \nconcep\u00adtually unrelated task of detecting and signalling errors means that changing the method of signalling \nerrors requires modifying the internals of value conversion. To decouple error-handling from value conversion, \nwe separate the guarded boundaries of the previous subsection into their con\u00adstituent parts: boundaries \nand guards. These separated boundaries have the semantics of the tMSN and SM t boundaries we intro- N \n duced at the beginning of this section. Guards will be new expres\u00adsions of the form (Gt e) that perform \nall dynamic checks necessary to ensure that their arguments behave as t in the sense of the pre\u00advious \nsubsection. In all initial terms, we will wrap every boundary e = \u00b7\u00b7\u00b7|(MSGt e) f G e : TST e = \u00b7\u00b7\u00b7|(GSM \nt e)G fS (MSGt e): t M E = \u00b7\u00b7\u00b7|(MSGt E)G fM e : t E = \u00b7\u00b7\u00b7|(GSM t E)G fS (GSM t e): TST E[MSG. n]M .E[n] \nE[MSG. v]M .E[MSG. (wrong Non-number )] v = n E[MSGt1.t2 .x.e]M .E[.x : t1.MSGt2 ((.x.e)(GSM t1 x))] \nx not free in e E[MSGt1.t2 v]M .E[MSGt1.t2 wrong Non-procedure ] v = .x.e E[(GSM . n)]S .E[n] E[(GSM \nt1.t2 v)]S .E[(.x. (GSM t2 (v (MSGt1 x))))] Figure 3. Extensions to .gure 1 to form the simple natural \nembed\u00adding e = \u00b7\u00b7\u00b7|(tMSN e) e = t e) |(SM t \u00b7\u00b7\u00b7|(GN e) E = \u00b7\u00b7\u00b7|(tMSN E) E = t E) |(SM t \u00b7\u00b7\u00b7|(GN E) G \nfS e : TST G fS e : TST G fM e : t G fS (Gt e): TST G fM MSN e): t G fSN e): t (t(SM t E[.MSN n]M .E[n] \nE[SM . .E[n] N n]S E[t1.t2MSN .x.e]M .E[.x : t1.SM t2 ((.x.e)(SM t1 x))] NN E[(SM t1.t2 v)]S .E[(.x.(SM \nt2 (v (t1MSN x))))] NN E[(G. n)]S .E[n] E[(G. v)]S .E[wrong Non-number ](v = n) 't1 ' E[(Gt1.t2 (.x.e))]S \n.E[(.x.(Gt2 ((.x.e)(Gx))))] t1.t2 E[(Gv)]S .E[wrong Non-procedure ](v = .x.e) Figure 4. Extensions to \n.gure 1 to form the separated-guards natural embedding with an appropriate guard: (tMSN (Gt e)) instead \nof (MSGt e) and (Gt (SM t e)) instead of (GSM t e). Figure 4 shows the rules for guards. An . guard applied \nto a number reduces to that number, and the same guard applied to a procedure aborts the program. A t1 \n. t2 guard aborts the program if given a number, and if given a procedure reduces to a new procedure \nthat applies a t1 guard to its input, runs the original procedure on that value, and then applies a t2 \nguard to the original procedure s result. This is just like the strategy we use to convert functions \nin the .rst place, but it doesn t perform any foreign-language translation by itself; it just distributes \nthe guards in preparation for conversion later on. The guard distribution rules for functions can move \na guard arbitrarily far away from the boundary it protects; if this motion ever gave a value the opportunity \nto get to a boundary without .rst being blessed by the appropriate guard, the system would get stuck. \nWe can prove this never happens by de.ning a combined language that has both guarded boundaries GSM t \nand MSGt and unguarded boundaries with separated guards tMSN , SM tt ; N ,and G i.e. the language formed \nby combining .gure 1 with .gures 3 and 4. In this combined language, an argument by induction shows that \nguarded boundaries are observably equivalent to guards combined with unguarded boundaries. Theorem 3. \nFor all Scheme expressions e and ML expressions e, the following propositions hold: (tt (1) (MSGt e) \nMSN (Ge)) (2) (GSM t e) (Gt (SM t  N e)) where is observable equivalence in the combined language. \nIn other words, we can replace any or all MSGt and GSM t boundaries with their separated versions without \naffecting the program, and therefore a program with only MSGt and GSM t boundaries is equivalent to the \nsame program with only separated guards and unchecked boundaries; and therefore the language of .gure \n3 is the same as the language of .gure 4. 3.3 A further re.nement: contracts While the guard strategy \nof the last subsection works, an imple\u00admentation based on it would perform many unnecessary dynamic checks. \nFor instance, the term (...MSN (G... (.x.(x)))) is equiv\u00adalent to .. .. (.x : ..(MSN (G((.x.x)(G(SMN \nx)))))) The check performed by the leftmost guard is necessary, but the check performed by the rightmost \nguard could be omitted since the value is coming directly from ML, ML s type system guarantees that \nthe conversion will succeed. We can re.ne our guarding strategy to eliminate those unnec\u00adessary checks. \nWe split guards into two varieties: positive guards, t written G+, that apply to values going from Scheme \nto ML, and t negative guards, written G-, that apply to values going from ML to Scheme. Their reduction \nrules are: . E[(G+ n)]S .E[n] . E[(G+v)]S .E[(wrong Non-number )] (v = n) t1.t2 t2 t1 E[(Gv)]S .E[(G(v \n(Gx)))] (v = .x.e) ++ - t1.t2 E[(G+ v)]S .E[(wrong Non-function )] (v = .x.e) . E[(G-v)]S .E[v] t1.t2 \nt2 t1 E[(Gv)]S .E[(.x.(G(v(Gx))))] -- + The function cases are the interesting rules here. Since functions \nthat result from positive guards are bound for ML, we check the inputs that ML will supply them using \na negative guard; since the result of those functions will be Scheme values going to ML, they must be \nguarded with positive guards. Negative guards never directly signal an error; they exist only to protect \nML functions from erroneous Scheme inputs. They put positive guards on the arguments to ML functions \nbut use negative guards on their results because those values will have come from ML. This new system \neliminates half of the .rst-order checks asso\u00adciated with the .rst separated-guard system, but maintains \nequiva\u00adlence with the simple natural embedding system. Theorem 4. For all ML expressions e and Scheme \nexpressions e in the language that combines simple natural boundaries and positive and negative guards, \nboth of the following propositions hold: t (1) (MSGt e) (tMSN (G+ e)) (2) (GSM t e) (G- (SM t  tN e)) \ntt As it happens, we do not need to add Gand G- as extensions, + because they can be implemented directly \nin the core Scheme language of .gure 1. In fact, they are exactly contracts, or more speci.cally pairs \nof projections in exactly the sense of Findler and Blume [16] where the two parties are + (Scheme) and \n-(ML). Since ML s type system guarantees that -never breaks its contract, only + will ever be blamed \nfor a violation. Practically, this means we can safely use contracts to protect type invariants in foreign \nfunction def T t1.t2 = .x : L..y : t1.(T t2 (LMSL((SMLLx)T t1 (SM t1 y)))) M MSL T t1.t2 def = .x..y.T \nt2 (SM t2 ((t1.t2MSLx)(T t1 (LMSLy))))) SSL M def T . = (. x : L. .MSL M (Y (. f . . n . (if0 n (SML. \n0) (SML. (+1 (.MSL (f (- n 1))))))) (SML Lx))) def TS. = (. x . (Y (. f . . n .(SML L (if0 (.MSL n) (LMSL \n0) (LMSL (+1 (f (SML. (- (.MSL n) 1)))))))) x)) Figure 5. Translation functions for lump values interfaces. \nThis adds to our con.dence in Gray et al s .ne-grained interoperability scheme [23], for example. More \ntheoretically, it means we can use the simple system of section 3.1 for our models and be more con.dent \nthat our soundness results apply to actual multi-language embeddings that we write with contracts. From \nthe contract perspective, it also shows one way of using mechanized reasoning to statically eliminate \ndynamic assertions from annotated programs. In this light it can be seen as a hybrid type system [20]. \n  4. What have we gained? The natural embedding .ts our intuitive notion of what a useful interoperability \nsystem ought to look like much more than the lump embedding does, so it seems like it should give us \nthe power to write more programs. However, that is not the case: tMSN and SM t N boundaries are macro-expressible \nin the lump embedding (in the sense of Felleisen [14]), meaning that any natural-embedding program can \nbe translated using local transformations into a lump\u00adembedding program. To show that, we de.ne two type-indexed \nfunctions, TSt and T t M , that can be written in the lump embedding. These functions translate values \nwhose ML type is t from Scheme to ML and from ML to Scheme, respectively; they are shown in .gure 5. \n(for clarity, in that .gure and below we use the notation tMSL and SMLt rather than tMS and SM t to refer \nto the lump embedding s boundaries.) The translation functions for higher-order types use essentially \nthe same method we presented in section 3 for converting a procedure value they translate a procedure \nby left-and right-composing appropriate translators for its input and output types. That leaves us with \nnothing but the base types, in our case numbers. Those require more work. The key insight is that we \ncan use a two-language equivalent of Church-encoded numbers to send a number across a boundary, and both \ntranslators do that the same way: the receiver gives the sender the opaque number to be trans\u00adlated, \na zero value, and a successor function. The sender then per\u00adforms a foreign application of the successor \nfunction to the zero value n times where n is the number to be sent. The result of that operation is \na foreign value representing the native number that was to be sent. (The two translators are super.cially \ndifferent from each other, but only because we restrict the Y .xed-point combinator to Scheme, where \nit can be written directly.) Theorem 5. In the language formed by extending the language of .gure 1 with \nboth .gure 2 and the language of section 3.3, both of the following propositions hold: (GtN e)) - (TSt \n(SMLt e))) - (SM t (Gt (t+e)) (T t MSL (Gt MSN (GtM (t+ e))) In other words, we can run any natural-embedding \nprogram in the lump embedding by converting all of its natural-embedding boundaries into lump boundaries \nwrapped in the appropriate guard and conversion functions. Since each translation in .gure 5 can be applied \nindependently, since each one is a local transformation, and since guards are expressible in the core \nScheme language, it follows that the SM t and tboundaries are macro-expressible in the N MSN lump embedding. \nBased on these translation rules, we were able to implement a program that communicated numbers between \nPLT Scheme and C using PLT Scheme s foreign interface [3] but maintaining a strict lump discipline. While \nthe translations of .gure 5 suf.ce for our purposes here, is worth mentioning that they could be made \nfaster. Rather than having the sender transmit add-one and stop signals, the re\u00adceiver could give the \nsender representations of 0 and 1 and let the sender send successive bits of the number to be converted. \nThis ap\u00adproach would run in time proportional to the log of the converted number, assuming ef.cient bit-shift \noperations. This is likely to be linear in the size of the representation of integers, though this is \nstill suboptimal since such conversions are likely to be either simple bit operations or even noops at \nthe level of the underlying machine. 5. From type-directed to type-mapped conversion In the previous \nsections, we have gotten double duty out of the type annotations on boundaries: statically, they have \nindicated the type of each boundary, and dynamically they have indicated how to convert any value that \nappears at the boundary. That overloading is .ne (even desirable) for some multi-language systems, but \nit is insuf.cient for others. For instance, since C does not have an ex\u00adception mechanism, many C functions \n(e.g., malloc, fopen, sqrt) return a normal value on success and a sentinel value on error. A foreign \nfunction interface might automatically convert error indi\u00adcators from such functions into exceptions, \nwhile converting non\u00aderrors as normal. To model such a conversion, we must generalize boundaries so that \ninstead of containing a type, they contain a con\u00adversion strategy from which a type can be derived. In \nthe numbers-for-errors example, we can consider a variant of our earlier multi-language systems in which \nwe expect ML to use the zero for error convention for some functions, and Scheme has a very simple exception \nmechanism in which (wrong str)raisesan exception, and (handle e1 e2) tries to evaluate e2 unless it raises \nan exception, in which case it abandons e2 and instead evaluates the handler expression e1. If a Scheme \nexception reaches ML, it aborts the program unless the ML boundary it reaches expects a value following \nthe zero-for-error convention, in which case it becomes 0. Similarly if 0 .ows from ML to Scheme in a \ncontext where the zero-for-error convention is in place, it becomes a Scheme exception. We give a model \nof this system in .gure 6. The Scheme con\u00adtexts identify two different layers: those in which no boundary \nor exception handler appears (H), and those in which boundaries and handlers may appear (E). This layering \nis a simpli.ed variant of the exception model presented by Wright and Felleisen [43]. The core of the \nsystem is a conversion strategy . that replaces the type on all boundaries, and an associated L\u00b7J metafunction \nfrom . to t that takes a conversion strategy down to a type. We use the conversion strategy to add a \nsingle conversion, .!, indicating places where 0 indicates an error. Typing judgments are as before, \nexcept that boundary rules must apply the L\u00b7J function as necessary. Re\u00adducing a boundary is also as \nbefore, with additions corresponding e = \u00b7\u00b7\u00b7|(MSG. e) e = \u00b7\u00b7\u00b7|(handle ee) |(GSM . e) |(handle ee) . = \n. |.! |. ..  E = \u00b7\u00b7\u00b7|E[(MSG. E)]M H =[]S |(He) |(vH) |(op He) |(op vH) |(if0 Hee) |(pr H) E = H|H[(GSM \n. E)]S |H[(handle eE)]S G fS e: TST G fM e : L.J G fM (MSG. e): L.J G fS (GSM . e): TST L.J = . L.!J \n= . L.1 ..2J = L.1J.L.2J E[(MSG.! n)]M .E[n] E[(MSG.! H[wrong str])]M .E[0] E[(MSG. H[wrong str])]M . \nError: str (if . = .!) E[(GSM .! 0)]S .E[(wrong zero )] E[(GSM .! n)]S .E[n](if n =0) E[(handle e1 H[(wrong \nstr)])]S .E[e1] Figure 6. Extensions to .gure 3 for mapped embedding to the ML-to-Scheme and Scheme-to-ML \nconversions for values at .! boundaries. Theorem 6. The language of .gure 6 is type-sound. This example \ndemonstrates a larger point: although we have used a boundary s type as its conversion strategy for most \nof the systems in this paper, they are separate ideas. Decoupling them has a number of pleasant effects: \n.rst, it allows us to use non-type\u00addirected conversions, as we have shown. Second, it illustrates that \nboundaries depend on conversion strategies, not type information per se, which suggests that type erasure \n(but not conversion strategy erasure) remains possible in our framework. Finally, the separation makes \nit easier to understand the connection between these formal systems and tools like SWIG, in particular \nSWIG s type-map fea\u00adture [4]: from this perspective, SWIG is a tool that automatically generates boundaries \nthat pull C++ values into Python (or another high-level language), and type-maps allow the user to write \na new conversion strategy and specify the circumstances under which it should be used.  6. Related work \nThe work most directly related to ours is Benton s Embedded In\u00adterpreters [6], which lays out a method \nfor embedding interpreters into statically typed languages using type-indexed embeddings and projections \n(the same method was also discovered independently by Ramsey [39]). His work considers only the asymmetric \ncase where a typed host language embeds an untyped language, and fo\u00adcuses on implementation rather than \nformal techniques. Still, read\u00aders will .nd that the .avor of his work is quite similar to this work. \nZdancewic, Grossman, and Morrisett s work [44] is also similar to ours in that it introduces two-agent \ncalculi and boundaries; their work, however, focuses on information-hiding properties and does not allow \ndifferent languages to interoperate. Other work on the semantics of interoperability tends to fo\u00adcus \non the properties of multi-language runtime systems. This in\u00adcludes a pair of formalisms for the semantics \nof COM, the .rst by Ibrahim and Szyperski [26] and the second by Pucella [38] and also Gordon and Syme \ns formalization of a type-safe intermediate lan\u00adguage designed speci.cally for multi-language interoperation \n[22]. Kennedy [28] pointed out that in multi-language systems, obser\u00advations in one language can break \nequations in the other and that this is a practical problem. Our system is one way to reason about these \nproblems precisely. Trifonov and Shao have developed an ab\u00adstract intermediate language for multi-language \nprograms that aids reasoning about interactions between effects in the two source lan\u00adguages [42]. While \nour framework can also addresses effects, it does not address their implementation. Instead our work \nfocuses on their semantics as seen by the source languages, a topic Trifonov and Shao do not discuss. \nFinally, Furr and Foster have built a sys\u00adtem for verifying certain safety properties of the OCaml foreign\u00adfunction \ninterface by analyzing C code for problematic uses of OCaml values [21]. On the issue of combining typed \nand untyped code, Henglein and Rehof [24,25] have done work on translating Scheme into ML, inserting \nML equivalents of our guards to simulate Scheme s dy\u00adnamic checks. Some languages have introduced ways \nof mixing typed and untyped code using a dynamic type [1], similar to our boundaries and lumps; for instance \nCardelli s Amber [10], Cham\u00adbers et al s Cecil [13] or Gray, Findler and Flatt s ProfessorJ [23]. There \nhas been far too much implementation work connecting high-level languages to list it all here. In addition \nto the projects we have already mentioned, there are dozens of compilers that target the JVM, the .NET \nCLR, or COM. There have also been more exotic embeddings; two somewhat recent examples are an embedding \nof Alice (an SML extension) into the Oz programming language [29] and the LazyScheme educational embedding \nof a lazy variant of Scheme into strict-evaluation-order Scheme [2]. There has been even more work on \nconnecting high-level languages to low-level languages; in addition to the venerable SWIG [5] there are \nmany more systems that try to sanitize the task [3,9,11,19,40]. 7. Conclusion We have shown how to give \noperational semantics to multi\u00adlanguage systems and still use the same formal techniques that apply to \nsingle languages. This work has focused on two points in the design space for interoperating languages: \nthe lump and natu\u00adral embeddings. We see aspects of these two points in many real foreign function interfaces: \nfor instance, SML.NET translates .at values and .NET objects, but forces lump-like behavior for higher\u00adorder \nML functions. The Java Native Interface provides all foreign values as lumps, but provides a large set \nof constant functions for manipulating them, similar to our fa ( foreign-apply ) function from section \n2. The lump embedding s ease of implementation and natural embedding s ease of use both pull on language \ndesign, and most real multi-language systems lie in between. Furthermore, we have talked mostly about \nforeign function in\u00adterfaces in this paper, but our technique scales to other kinds of multi-language \nsystems. Any situation in which two logically dif\u00adferent languages interact is a candidate for this treatment \n e.g. embedded domain-speci.c languages, some uses of metaprogram\u00adming, and even contract systems, viewing \neach party to the con\u00adtract as a separate language. By treating these uniformly as multi\u00adlanguage systems, \nwe might be able to connect them in fruitful ways. Even with the limited scope considered in this paper, \nwe have discovered connections between contracts, foreign function interfaces, and hybrid type systems \n(as discussed in section 3.3). Widening the net to include a broader interpretation of interoperat\u00ading \nsystems suggests that this work barely scratches the surface. Acknowledgments The authors would like \nto thank Cormac Flanagan for his suggestion of the phrase cross-language cast ; to Matthias Felleisen, \nDave MacQueen, and the anonymous re\u00adviewers for their comments on earlier versions of this paper; and \nto David Walker, for shepherding this paper from its original twelve\u00adpage form to the eight-page version \npresented here. This work was funded in part by the National Science Foundation.  References [1] M. \nAbadi, L. Cardelli, B. Pierce, and G. Plotkin. Dynamic typing in a statically typed language. ACM Transactions \non Programming Languages and Systems, 13(2):237 268, April 1991. [2] E. Barzilay and J. Clements. Laziness \nwithout all the hard work. In Workshop on Functional and Declarative Programming in Education (FDPE), \n2005. [3] E. Barzilay and D. Orlovsky. Foreign interface for PLT Scheme. In Workshop on Scheme and Functional \nProgramming, 2004. [4] D. Beazley. Pointers, constraints, and typemaps. In SWIG 1.1 Users Manual. Available \nonline: http://www.swig.org/Doc1.1/HTML/ Typemaps.html. [5] D. Beazley. SWIG: An easy to use tool for \nintegrating scripting languages with C and C++. In 4th Tcl/Tk Workshop, pages 129 139, 1996. Available \nonline: http://www.swig.org/papers/Tcl96/ tcl96.html. [6] N. Benton. Embedded interpreters. Journal of \nFunctional Program\u00adming, 15:503 542, July 2005. [7] N. Benton and A. Kennedy. Interlanguage working without \ntears: Blending SML with Java. In ACM SIGPLAN International Conference on Functional Programming (ICFP), \npages 126 137, 1999. [8] N. Benton, A. Kennedy, and C. V. Russo. Adventures in interoperabil\u00adity: the \nSML.NET experience. In Proceedings of the 6th International ACM SIGPLAN Conference on Principles and \nPractice of Declarative Programming (PPDP), pages 215 226, 2004. [9] M. Blume. No-longer-foreign: Teaching \nan ML compiler to speak C natively . In Workshop on Multi-Language Infrastructure and Interoperability \n(BABEL), 2001. [10] L. Cardelli. Amber. In G. Cousineau, P.-L. Curien, and B. Robinet, editors, Combinators \nand functional programming languages, volume 242. Springer-Verlag, 1986. [11] M. M. T. Chakravarty. C.HASKELL, \nor yet another interfacing tool. In International Workshop on Implementation of Functional Languages \n(IFL), 1999. [12] M. M. T. Chakravarty. The Haskell 98 foreign function interface 1.0, 2002. Available \nonline: http://www.cse.unsw.edu.au/~chak/ haskell/ffi/. [13] C. Chambers and The Cecil Group. The Cecil \nlanguage: Speci.cation and rationale, version 3.2. Technical report, Department of Computer Science and \nEngineering, University of Washington, February 2004. Available online: http://www.cs.washington.edu/research/ \nprojects/cecil/pubs/cecil-spec.html. [14] M. Felleisen. On the expressive power of programming languages. \nScience of Computer Programming, 17:35 75, 1991. [15] M. Felleisen and R. Hieb. The revised report on \nthe syntactic theories of sequential control and state. Theoretical Computer Science, 102:235 271, 1992. \nOriginal version in: Technical Report 89-100, Rice University, June 1989. [16] R. B. Findler and M. Blume. \nContracts as pairs of projections. In International Symposium on Functional and Logic Programming (FLOPS), \n2006. [17] R. B. Findler and M. Felleisen. Contracts for higher-order functions. In ACM SIGPLAN International \nConference on Functional Program\u00adming (ICFP), 2002. [18] S. Finne, D. Leijen, E. Meijer, and S. Peyton \nJones. Calling Hell from Heaven and Heaven from Hell. In ACM SIGPLAN International Conference on Functional \nProgramming (ICFP), pages 114 125, 1999. [19] K. Fisher, R. Pucella, and J. Reppy. A framework for interoperability. \nIn Workshop on Multi-Language Infrastructure and Interoperability (BABEL), 2001. [20] C. Flanagan. Hybrid \ntype checking. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL), 2006. [21] \nM. Furr and J. S. Foster. Checking type safety of foreign function calls. In ACM SIGPLAN Conference on \nProgramming Language Design and Implementation (PLDI), pages 62 72, 2005. [22] A. D. Gordon and D. Syme. \nTyping a multi-language intermediate code. In ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages (POPL), pages 248 260, 2001. [23] K. E. Gray, R. B. Findler, and M. Flatt. Fine grained interoperability \nthrough mirrors and contracts. In Conference on Object-Oriented Programming: Systems, Languages, and \nApplications (OOPSLA), 2005. [24] F. Henglein. Dynamic typing: Syntax and proof theory. Science of Computer \nProgramming, 22(3):197 230, 1994. [25] F. Henglein and J. Rehof. Safe polymorphic type inference for \na dynamically typed language: translating Scheme to ML. In Proceedings of the Conference on Functional \nProgramming Languages and Computer Architecture (FPCA), 1995. [26] R. Ibrahim and C. Szyperski. The \nCOMEL language. Technical Report FIT-TR-97-06, Faculty of Information Technology, Queensland University \nof Technology, Brisbane, Australia, 1997. [27] Jython. http://www.jython.org/. [28] A. Kennedy. Securing \nthe .NET programming model. Theoretical Computer Science, To appear. http://research.microsoft.com/ ~akenn/sec/. \n[29] L. Kornstaedt. Alice in the land of Oz -an interoperability-based implementation of a functional \nlanguage on top of a relational language. In Workshop on Multi-Language Infrastructure and Interoperability \n(BABEL), 2001. [30] J. Matthews and R. B. Findler. An operational semantics for R5RS Scheme. In Workshop \non Scheme and Functional Programming, 2005. [31] J. Matthews, R. B. Findler, M. Flatt, and M. Felleisen. \nA visual en\u00advironment for developing context-sensitive term rewriting systems. In Proceedings of the \nInternational Conference on Rewriting Techniques and Applications (RTA), 2004. [32] E. Meijer, N. Perry, \nand A. van Yzendoorn. Scripting .NET using Mondrian. In European Conference on Object-Oriented Programming \n(ECOOP), pages 150 164, London, UK, 2001. Springer-Verlag. [33] P. Meunier and D. Silva. From Python \nto PLT Scheme. In Proceedings of the Fourth Workshop on Scheme and Functional Programming, pages 24 29, \n2003. [34] M. Odersky, P. Altherr, V. Cremet, B. Emir, S. Micheloud, N. Mihaylov, M. Schinz, E. Stenman, \nand M. Zenger. An Introduction to Scala. http://scala.epfl.ch/docu/files/ScalaIntro.pdf, 2005. [35] A. \nOhori and K. Kato. Semantics for communication primitives in an polymorphic language. In ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages (POPL), pages 99 112, 1993. [36] P. Pinto. Dot-Scheme: \nA PLT Scheme FFI for the .NET framework. In Workshop on Scheme and Functional Programming, November 2003. \n[37] G. D. Plotkin. LCF considered as a programming language. Theoretical Computer Science, pages 223 \n255, 1977. [38] R. Pucella. Towards a formalization for COM, part I: The primitive calculus. In Conference \non Object-Oriented Programming: Systems, Languages, and Applications (OOPSLA), 2002. [39] N. Ramsey. \nEmbedding an interpreted language using higher-order functions and types. In Interpreters, Virtual Machines \nand Emulators (IVME 03), pages 6 14, 2003. [40] J. Reppy and C. Song. Application-speci.c foreign-interface \ngeneration. In International Conference on Generative Programming and Component Engineering (GPCE), 2006. \n[41] P. Steckler. MysterX: A Scheme toolkit for building interactive applications with COM. In Technology \nof Object-Oriented Languages and Systems (TOOL), pages 364 373, 1999. Available online: citeseer.ist.psu.edu/steckler99mysterx.html. \n[42] V. Trifonov and Z. Shao. Safe and principled language interoperation. In European Symposium on Programming \n(ESOP), pages 128 146, 1999. [43] A. Wright and M. Felleisen. A syntactic approach to type soundness. \nInformation and Computation, pages 38 94, 1994. First appeared as Technical Report TR160, Rice University, \n1991. [44] S. Zdancewic, D. Grossman, and G. Morrisett. Principals in programming languages. In ACM SIGPLAN \nInternational Conference on Functional Programming (ICFP), 1999. PLT Redex [31] implementations of all \nthe formal systems pre\u00adsented here and the companion technical report in both color and black and white \nare available online at http://www.cs. uchicago.edu/~jacobm/papers/multilang/. \n\t\t\t", "proc_id": "1190216", "abstract": "Inter-language interoperability is big business, as the success of Microsoft's .NET and COM and Sun's JVM show. Programming language designers are designing programming languages that reflect that fact --- SML#, Mondrian, and Scala, to name just a few examples, all treat interoperability with other languages as a central design feature. Still, current multi-language research tends not to focus on the semantics of interoperation features, but only on how to implement them efficiently. In this paper, we take first steps toward higher-level models of interoperating systems. Our technique abstracts away the low-level details of interoperability like garbage collection and representation coherence, and lets us focus on semantic properties like type-safety and observable equivalence.Beyond giving simple expressive models that are natural compositions of single-language models, our studies have uncovered several interesting facts about interoperability. For example, higher-order contracts naturally emerge as the glue to ensure that interoperating languages respect each other's type systems. While we present our results in an abstract setting, they shed light on real multi-language systems and tools such as the JNI, SWIG, and Haskell's stable pointers.", "authors": [{"name": "Jacob Matthews", "author_profile_id": "81100545942", "affiliation": "University of Chicago", "person_id": "P686508", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "University of Chicago", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190220", "year": "2007", "article_id": "1190220", "conference": "POPL", "title": "Operational semantics for multi-language programs", "url": "http://dl.acm.org/citation.cfm?id=1190220"}