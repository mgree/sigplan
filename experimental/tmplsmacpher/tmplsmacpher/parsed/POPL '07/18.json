{"article_publication_date": "01-17-2007", "fulltext": "\n Lazy Multivariate Higher-Order Forward-Mode AD Barak A. Pearlmutter Jeffrey Mark Siskind Hamilton Institute \nSchool of Electrical and Computer Engineering NUI Maynooth, Ireland Purdue University, USA barak@cs.nuim.ie \nqobi@purdue.edu Abstract A method is presented for computing all higher-order partial derivatives of \na multivariate function Rn . R. This method works by evaluating the function under a nonstandard interpretation, \nlift\u00ading reals to multivariate power series. Multivariate power series, with potentially an in.nite number \nof terms with nonzero coef\u00ad.cients, are represented using a lazy data structure constructed out of linear \nterms. A complete implementation of this method in SCHEME is presented, along with a straightforward \nexposition, based on Taylor expansions, of the method s correctness. Categories and Subject Descriptors \nG.1.4 [Quadrature and Nu\u00admerical Differentiation]: Automatic differentiation; D.3.2 [Lan\u00adguage Classi.cations]: \nApplicative (functional) languages General Terms Algorithms, Languages Keywords Power series, Nonstandard \ninterpretation 1. Introduction Forward-Mode Automatic Differentiation, or forward AD, [1] is a method \nfor adapting a program that computes a function to yield one that computes its derivatives. Karczmarczuk \n[2 5] presented an implementation of forward AD in HASKELL. This implementa\u00adtion had a novel characteristic: \nit adapted a program that computed a univariate function f : R . R to yield one that produced an in\u00ad.nite \nstream of higher-order derivatives (f(x),f' (x),f'' (x),...). However, Karczmarczuk provided the details \nfor his method only for univariate functions. Karczmarczuk [4] hinted at a generaliza\u00adtion to multivariate \nfunctions but did not provide the details. Here, we present the details of a novel generalization of \nKarczmarczuk s method to the multivariate case. In part, we use methods previously developed for implementing \nnestable .rst-order forward AD in a functional framework [6]. The crucial additional insight here, both \nfor developing the extension and for demonstrating its correctness, involves reformulating Karczmarczuk \ns method using Taylor ex\u00adpansions instead of the chain rule. This requires dealing with the requisite \nfactorial factors. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001...$5.00 \n 2. Univariate First-Order Forward AD The Taylor expansion [7] of f(c+ e) with respect to eis 8 . X di. \n1 f(x) i . f(c+ e)= e . i!dxi x=c i=0 This implies that one can compute the i-th derivative of a univariate \nfunction f at a scalar point cby evaluating by evaluating f(c+ e) under a nonstandard interpretation \nreplacing real numbers with uni\u00advariate power series in e, extracting the coef.cient of ei in the re\u00adsult, \nand multiplying this by i!. Traditional forward AD [1] trun\u00adcates the Taylor expansions at i> 1, thus \ncomputing a representa\u00adtion that contains only the .rst derivative. Such truncated Taylor expansions \nare dual numbers [8]. We de\u00adnote a dual number p as x + x' e, by analogy with the standard notation a+ \nbi for complex numbers. Just as arithmetic on com\u00adplex numbers a+ bi can be de.ned by taking i2 = -1, \narithmetic ' on dual numbers x + xe canbede.nedbytaking e2 =0 but e =0. Furthermore, just as implementations \nof complex arithmetic typically represent complex numbers a+ bi as Argand pairs (a,b), implementations \nof forward AD typically represent dual numbers ' x+xeas tangent-bundle pairs (x,x' ). Finally, just as \nimplementa\u00adtions of complex arithmetic typically overload the arithmetic prim\u00aditives to manipulate complex \nnumbers, implementations of forward AD typically overload the arithmetic primitives to manipulate dual \nnumbers. We use E epto denote the coef.cient of ein the dual number p '/' E e(x+ xe)= x (1) and D fcto \ndenote the value of the .rst derivative of a univariate function f at a scalar point c. Forward AD computes \nD fc by evaluating f (c+ e) under a nonstandard interpretation replacing real numbers with dual numbers \nand extracting the coef.cient of e in the result. / D fc= E e (f (c+ e)) (2) The es introduced by nested \ninvocations of D must be distinct [6]. To see how this works, let us manually apply the mechanism to \na simple example: computing the .rst derivative of f(x)= x 4 +2x 3 at x=3.Todothis, we .rst evaluate \nf(3 + e). f(3 + e)=(3+ e)4 +2(3 + e)3 = (81 + 108e) + 2(27 + 27e) = 135 + 162e From this we can extract \nthe derivative: E e(135 + 162e) = 162. . .. df(x) 32 .. =4x +6x = 162 = E e(f (3 + e)) . x=3 dx x=3 Note \nthat the above makes use of the restriction that e2 =0 when evaluating (3+e)3 =27+27eand (3+e)4 = 81+108e, \ndropping the e2 , e3,and e4 terms. This is the essence of traditional forward AD when limited to the \ncase of univariate derivatives. 3. Univariate Higher-Order Forward AD While the above nominally computes \nonly .rst derivatives, straight\u00adforward repeated application of D allows computation of higher\u00adorder \nderivatives. We use D f to denote partial application of D, i.e., .c . (D fc),and Di fc to denote the \nvalue of the i-th derivative of a univariate function f at a scalar point c. / D0 f = f (3) / Di Di-1 \nf =(D f) when i>0 (4) We refer to the above method for computing higher-order deriva\u00adtivesasthe repetition \nmethod. Karczmarczuk [2 5] presented an alternate method for comput\u00ading higher-order univariate derivatives. \nHis method can be viewed as computing non-truncated Taylor expansions,1 removing the re\u00adstriction that \ne2 =0, and generalizing dual numbers to univariate power series in e. To accomplish this, we .rst extend \nthe de.nition of E from (1) so that E ei pyields i! times the coef.cient of ei in the power series p. \n/ E e0 p = Rep (5) / ii-1 E ep = i\u00d7E e(Qep) when i>0 (6) In the above and throughout this paper, Q epand \nR epdestruc\u00adture a power series: p =(R ep)+(Q ep)e. Given the above, Karczmarczuk s method can be viewed \nas computing Di fc by evaluating f (c+ e) under a nonstandard interpretation replacing real numbers with \nunivariate power series in e, extracting the coef\u00ad.cient of ei in the result, and multiplying this by \ni!. / Di = E ei fc (f (c+ e)) (7) To see how this works, let us manually apply the mechanism to a simple \nexample: computing all of the higher-order derivatives of f(x)= x 4 +2x 3 at x =3. To do this, we .rst \nevaluate f(3 + e). f(3 + e)=(3+ e)4 +2(3 + e)3 = (81 + 108e+54e2 +12e3 + e4) +2(27+27e+9e2 + e3) = 135 \n+ 162e+72e2 +14e3 + e4 From this we can extract all of the higher-order derivatives. .. .. f(x). = x \n4 +2x 3 . = 135 = 0! \u00d7135 = E e0 (f (3 + e)) .. x=3 x=3 .. .. df(x) 32 .. =4x +6x = 162 = 1! \u00d7162 = E \ne1 (f (3 + e)) .. dx x=3 x=3 . . . .. d4f(x) .. .. = E e4 = 24 =24= 4! \u00d71(f (3 + e)) .. dx4 x=3 x=3 \n4. Lazy Univariate Higher-Order Forward AD The input to the nonstandard interpretation will always be \na poly\u00adnomial c+ e, an entity with a .nite number of terms with nonzero coef.cients. In the above example, \nthe output of the nonstandard interpretation was also a polynomial. However, some functions, 1 As discussed \nin section 7, this is a reformulation of Karczmarczuk s method which was originally formulated using \nthe chain rule. such as sin, yield a result entity with an in.nite number of terms with nonzero coef.cients, \ni.e., a power series, even when applied to an input polynomial. Karczmarczuk addressed this by representing \nunivariate power series as lazy unidimensional streams. We refer to this as a tower method. Karczmarczuk \npresented the details of his tower method only for univariate functions. The remainder of this paper \npresents the details of a novel tower method that generalizes to the multivariate case. 5. Multivariate \nHigher-Order Forward AD We use D(i1,...,in) f (c1,...,cn) to denote the value of . . .i1+\u00b7\u00b7\u00b7+in f(x1,...,xn) \n. i1 in . .x1 \u00b7\u00b7\u00b7.xn x1=c1,...,xn =cn i.e., the value of a higher-order partial derivative of a multivariate \nfunction f at a multidimensional point (c1,...,cn).One cangen\u00aderalize the repetition method to the multivariate \ncase. D(0,...,0) / f = f (8) D(i1,...,in) / f = (9) D(i1,...,ie-1,ie-1,ie+1,...,in) .(c1,...,cn) . D \n(.u.f (c1,...,ce-1,u,ce+1,...,cn)) ce when ie >0 Again, each nested invocation of Dmust use a distinct \ne[6]. One can formulate a multivariate tower method by generaliz\u00ading univariate power series to multivariate \npower series. To accom\u00adplish this, we .rst note that the multivariate Taylor expansion of f((c1 + e1),...,(cn \n+ en)) with respect to (e1,...,en) is 88 . XX . 1 .i1+\u00b7\u00b7\u00b7+in f(x1,...,xn) . ei1 \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7ein i1 in . 1 \nn i1! \u00b7\u00b7\u00b7in! .x1 \u00b7\u00b7\u00b7.xn x1=c1,...,xn i1=0 in=0 =cn We therefore extend the de.nition of E from (5 6) \nto the multi\u00ad i1 in variate case so that E e1 \u00b7\u00b7\u00b7en p yields i1! \u00b7\u00b7\u00b7in! times the coef.cient of ei1 \u00b7\u00b7\u00b7ein \nin the power series p. 1 n / E 1 p = p (10) / i1 in i2 in i1 E e1 \u00b7\u00b7\u00b7en p = E e2 \u00b7\u00b7\u00b7en (E e1 p) (11) \nGiven the above, one can compute D(i1,...,in) f (c1,...,cn) by evaluating f ((c1 + e1),...,(cn + en)) \nunder a nonstandard in\u00adterpretation replacing real numbers with multivariate power series i1 in in distinct \ne1,...,en, extracting the coef.cient of e1 \u00b7\u00b7\u00b7en in the result, and multiplying this by i1! \u00b7\u00b7\u00b7in!. D(i1,...,in) \n/ f (c1,...,cn)= (12) i1 in E e1 \u00b7\u00b7\u00b7en (f ((c1 + e1),...,(cn + en))) In the above, the ee must be distinct \nfrom each other and from any other eused by nested invocations of any form of D[6]. To see how this works, \nlet us manually apply the mechanism to a simple example: computing all of the higher-order partial do \nthis, we .rst evaluate g((2+ex), (3+ey)). g((2+ex), (3+ey)) =(2+ex)3(3+ey)+(2+ex)2(3+ey)2 =(8+12ex +6e2 \nx +e3 x)(3+ey) +(4+4ex +e2 x)(9+6ey +e2 y) =(24+36ex +8ey +18e2 x +12exey +3e3 x +6e2 xey +e3 xey) +(36+36ex \n+24ey +9e2 x +24exey +4ey 2 +6ex2 ey +4exey 2 +ex2 ey2 ) =(60+72ex +32ey +27e2 x +36exey +4e2 y +3e3 \nx +12ex2 ey +4exey 2 +ex3 ey +ex2 ey2 ) From this we can extract all of the higher-order partial derivatives. \n.. .. . 3 22 . g(x, y)= xy +xy =60=0!\u00d70!\u00d760 .. x=2,y=3 x=2,y=3 = E ex0 ey 0 (g ((2+ex),(3+ey))) .. .. \n.g(x, y) . =3x 2 y +2xy 2 . =72=1!\u00d70!\u00d772 .. .x x=2,y=3 x=2,y=3 = E e1 xe0 y (g ((2+ex),(3+ey))) . . . \n.. .4 .. g(x, y) .. = 6 =6=3!\u00d71!\u00d71 .. .x3.y x=2,y=3 x=2,y=3 = E e3 xe1 y (g ((2+ex),(3+ey))) .. .4 g(x, \ny).. .. = 4 =4=2!\u00d72!\u00d71 .. .x2.y2 x=2,y=3 x=2,y=3 = E e2 xey 2 (g ((2+ex),(3+ey))) Two dif.culties arise \nwhen attempting to implement the above. First, there is the need to maintain the distinction between \nthe different es, addressed in previous work [6]. Second, there is a need to generalize lazy unidimensional \nstreams to the multidimensional case to represent multivariate power series. We address this in the next \nsection.  6. Lazy Multivariate Higher-Order Forward AD A univariate polynomial x0 +x1e+x2e2 +\u00b7\u00b7\u00b7+xn-1en-1 \n+xnen can be evaluated using Horner s method [9] as x0 +(x1 +(x2 +\u00b7\u00b7\u00b7+(xn-1 +xne)e \u00b7\u00b7\u00b7)e)e This indicates \nthat univariate polynomials can be represented as nested dual numbers. Multivariate polynomials can be \nrepresented as nested tagged dual numbers, i.e., triples of the form (e, x, x ' ), with potentially distinct \nes, to represent x +x ' e. We assume that there is a total order . over the es and refer to such tagged \ndual numbers as linear terms. Power series can be represented as binary trees whose nodes are linear \nterms with a lazy x ' slot. As illustrated in the code accompanying this paper, we constrain such represen\u00adtations \nto maintain the following invariants: I-1 In any linear term x +x ' e,the x slot is either real, or a \nlinear term over e ' where e ' .e. I-2 In any linear term x +x ' e,the x ' slot is either real, a linear \nterm over e ' where e ' .e, or a linear term over e. These ensure that the coef.cient of each term in \na multivariate series is stored in at most one leaf. They also simplify proofs of termination of the \nderivative-taking code and lower the time bound on access to a multivariate power series. Figure 1 contains \na SCHEME implementation of an API for manipulating multivariate power series represented as lazy linear \nterms. Central to this API are mechanisms Q ep and R ep for computing the quotient and remainder when \ndividing the power series p by the variable e. / Rer = r when r .R (13) /'' ''' Re (x +xe )= x +xe when \ne .e (14) / Re (x +x ' e)= x (15) ' e '' )e ' e ' / Re (x +x )=(Rex)+(Rex when e =(16) / Qer =0 when \nr .R (17) /'' ' Qe (x +xe )=0 when e .e (18) ' /' Qe (x +xe)= x (19) /'' ''' Qe (x +xe )=(Qex)+(Qex )e \nwhen e =e (20) Cases (14) and (18) and the simpli.cations in cases (15) and (19) are valid because of \nthe invariants. Note that, unlike an analogous earlier API [6], the above correctly handles linear terms \nx +x ' e where x ' may itself be a linear term in the same e. Also note that, because of laziness, unlike \nthat earlier API, there is no easy way to implement the simpli.cation rule x +0e . x. To perform the \nnonstandard interpretation, we need to extend the numeric primitives to apply to power series. For simplicity, \nwe do this only for univariate and bivariate primitives. We can assume that the power series arguments \nto such primitives take the form of a linear term x +x ' e. The extension of a univariate primitive f \napplied to a linear term x +x ' e can be derived via a univariate Taylor expansion about x in terms of \nx ' e. 8 X f(i) ' (x) ' i f(x +xe)= (xe) i! i=0 X 8 f(i)'i (x)x i = f(x)+ e i! i=1 8'i-1 \u00ab X f(i) (x)x \ni-1 ' = f(x)+exe i! i=1 8'i \u00ab X f(i+1) (x)xei ' = f(x)+xe (21) (i +1)! i=0 In the above, f(i) denotes \nthe i-th derivative of f. Note that 8 X f(i+1)'i '' (x)x i f (x +xe)= e(22) i! i=0 Also note that the \nright hand side of (22) is similar to the coef.cient of x ' e in (21), differing only in that the derivatives \nin the power series are divided by (i +1)! instead of i!. The coef.cient of x ' e in (21) can be derived \nfrom the right hand side of (22) by postulating an operator Ce0 to adjust the coef.cients. 88 X f(i+1)'i \nX f(i+1)'i (x)x (x)x ei ei =Ce0 (23) (i +1)! i! i=0 i=0 R e (As a formal power series operator, Ce0 f(e)= \n1 e 0 f(e)de.) This operator can be de.ned as follows: /r Cei r = when r .R (24) i +1 / Cei (x +x ' e)=(Cei \nx)+(Cei+1 x ' )e (25) / (define <_e <) (define =_e =) (define linear-term? (let ((pair? pair?)) (lambda \n(p) (and (pair? p) (eq? (car p) linear-term))))) (define-syntax linear-term (syntax-rules () ((linear-termexx-prime) \n(list linear-term e x (delay x-prime))))) (define epsilon cadr) (define (r e p) (cond ;; Equation (13) \n((not (linear-term? p)) p) ;; Equation (14) ((<_e (epsilon p) e) p) ;; Equation (15) ((=_e (epsilon p) \ne) (caddr p)) ;; Equation (16) (else (linear-term (epsilon p) (r e (caddr p)) (r e (force (cadddr p))))))) \n(define (q e p) (cond ;; Equation (17) ((not (linear-term? p)) 0) ;; Equation (18) ((<_e (epsilon p) \ne) 0) ;; Equation (19) ((=_e (epsilon p) e) (force (cadddr p))) ;; Equation (20) (else (linear-term \n(epsilon p) (q e (caddr p)) (q e (force (cadddr p))))))) (define generate-epsilon (let ((e 0)) (lambda \n() (set! e (+ e 1)) e))) (define (univariate-eeip) (cond ;; Equation (5) ((zero? i) (r e p)) ;; Equation \n(6) (else (* i (univariate-e e (-i 1) (q e p)))))) (define (multivariate-eeip) (cond ;; Equation (10) \n((null? i) p) ;; Equation (11) (else (multivariate-e (cdr e) (cdr i) (univariate-e (car e) (car i) p))))) \nFigure 1. ASCHEME implementation of an API for manipulating multivariate power series represented as \nlazy linear terms. Note that to support nested invocation of D,the \u00d7 in (6) must be the lifted variant \nthat works on power-series arguments. Note that generated esnever escape any equations in which they \nare generated, i.e., (2, 7, 12, 31 34). Thus one can improve upon the above implementation by allocating \nand reclaiming es in a LIFO fashion. Note that x ' in (23) can contain e. This is a problem because Cei \noperates by counting instances of e, and has no way to distinguish the esin x ' that should not be counted. \nWe solve this by renaming e to a fresh e ' prior to calling Cei and renaming e ' back to e in the result. \nFor the cases that arise in this paper,2 such renaming can be accomplished with the following: / p[e \n= p (27) . e] / r[e1 = when r . R (28) . e2] r /'' ''' (x + xe )[e1 = x + xe when e . e1 . e2] (29) / \n(x + x ' e1)[e1. e2]= (30) (R e2 x)+((Q e2 x)+ x ' [e1. e2])e2 This yields the following method for extending \nunivariate primi\u00adtives: / f (x + x ' e)= (31) ''''' (fx)+((Ce0 (f (x + xe)[e. e ]))[e )e . e] \u00d7 x This \nrequires supplying f ' , the .rst derivative of each univariate primitive f. Bivariate primitives can \nbe extended when the .rst argument is a linear term over e and the second argument is either a real or \na linear term over e ' where e ' . e by performing a univariate Taylor 2 Renaming is only applied in \nequations (31 34) and therein only in cases where e . e ' for any existing e. Furthermore, (29) is valid \nonly because of the invariants. expansion around the .rst argument. / f ((x + x ' e),y)= (32) '''' (f \n(x, y)) + ((Ce0 (f1 ((x + xe)[e ],y)))[e . e] \u00d7 x )e . e Analogously, bivariate primitives can be extended \nwhen the second argument is a linear term over e and the .rst argument is either a real or a linear term \nover e ' where e ' . e by performing a univariate Taylor expansion around the second argument. / f (x, \n(y + y ' e)) = (33) '''' (f (x, y)) + ((Ce0 (f2 (x, (y + ye)[e ])))[e . e] \u00d7 y )e . e This requires supplying \nf1 and f2, the partial .rst derivatives of each bivariate primitive f with respect to its .rst and second \nargu\u00adments respectively. To handle the case when both arguments are linear terms over the same e we rename \nthe e in one argument to a fresh e ' , reducing this case to either (32) or (33), and then rename e ' \nback to e in the result. / f ((x + x ' e), (y + y ' e)) = (34) ' ''' (f ((x + xe), (y + ye)[e ]))[e . \ne] . e These techniques are implemented in .gure 2 and used to over\u00adload some SCHEME primitives in .gure \n3. Figure 4 completes the implementation. Note that the computational ef.ciency of this im\u00adplementationreliesonthefactthatstandard \nSCHEMEmemoizesthe results of forcing promises. The code from .gures 1 4 is available from http://www.bcl.hamilton.ie/~qobi/tower/. \n(define (ceip) (cond ;; Equation (24) ((not (linear-term? p)) (/ p (+ i 1))) ;; Equation (25) ((=_e \n(epsilon p) e) (linear-term (epsilon p) (c e i (r (epsilon p) p)) (c e (+ i 1) (q (epsilon p) p)))) ;; \nEquation (26) (else (linear-term (epsilon p) (cei(r (epsilon p) p)) (cei(q(epsilon p) p)))))) (define \n(rename e1 e2 p) (cond ;; Equation (27) ((=_e e1 e2) p) ;; Equation (28) ((not (linear-term? p)) p) ;; \nEquation (29) ((<_e (epsilon p) e1) p) ;; Equation (30) ((=_e (epsilon p) e1) (linear-term e2 (r e2 \n(r e1 p)) (+ (q e2 (r e1 p)) (rename e1 e2 (q e1 p))))) (else (error \"This case should never occur in \nthis program.\")))) (define (lift-real->real f df/dx) (letrec ((self (lambda (p) (cond ;; Equation (31) \n((linear-term? p) (let ((e (epsilon p))) (linear-term e (self (r e p)) (* (let ((e-prime (generate-epsilon))) \n(rename e-prime e (c e-prime 0 (df/dx (linear-term e-prime (r e p) (q e p)))))) (q e p))))) (else (f \np)))))) self)) (define (lift-real*real->real f df/dx1 df/dx2) (letrec ((self (lambda (p1 p2) (cond ;; \nEquation (32) ((and (linear-term? p1) (or (not (linear-term? p2)) (<_e (epsilon p2) (epsilon p1)))) \n(let ((e1 (epsilon p1))) (linear-term e1 (self (r e1 p1) p2) (* (let ((e-prime (generate-epsilon))) \n(rename e-prime e1 (c e-prime 0 (df/dx1 (linear-term e-prime (r e1 p1) (q e1 p1)) p2)))) (q e1 p1))))) \n;; Equation (33) ((and (linear-term? p2) (or (not (linear-term? p1)) (<_e (epsilon p1) (epsilon p2)))) \n(let ((e2 (epsilon p2))) (linear-term e2 (self p1 (r e2 p2)) (* (let ((e-prime (generate-epsilon))) \n(rename e-prime e2 (c e-prime 0 (df/dx2 p1 (linear-term e-prime (r e2 p2) (q e2 p2)))))) (q e2 p2))))) \n;; Equation (34) ((and (linear-term? p1) (linear-term? p2) (=_e (epsilon p1) (epsilon p2))) (let ((e \n(epsilon p1)) (e-prime (generate-epsilon))) (rename e-prime e (self p1 (rename e e-prime p2))))) (else \n(f p1 p2)))))) self)) (define (r* p) (if (linear-term? p) (r* (r (epsilon p) p)) p)) (define (lift-real\\symbol{94}n->boolean \nf) (lambda ps (apply f (map r* ps)))) Figure 2. A mechanism for extending SCHEME procedures of type R \n. R, R \u00d7 R . R,and Rn . boolean to support multivariate power series. Note that the + in (30) and the \n\u00d7 in (31 33) must be the lifted variant that works on power-series arguments. Furthermore, f ' in (31), \nf1 in (32), and f2 in (33) must internally use the lifted variants of operations that work on power-series \narguments. (define pair? (let ((pair? pair?)) (lambda (x) (and (pair? x) (not (linear-term? x)))))) (define \n+ (lift-real*real->real + (lambda (x1 x2) 1) (lambda (x1 x2) 1))) (define -(lift-real*real->real -(lambda \n(x1 x2) 1) (lambda (x1 x2) -1))) (define * (lift-real*real->real * (lambda (x1 x2) x2) (lambda (x1 x2) \nx1))) (define / (lift-real*real->real / (lambda (x1 x2) (/ 1 x2)) (lambda (x1 x2) (-0 (/ x1 (* x2 x2)))))) \n(define sqrt (lift-real->real sqrt (lambda (x) (/ 1 (* 2 (sqrt x)))))) (define exp (lift-real->real exp \n(lambda (x) (exp x)))) (define log (lift-real->real log (lambda (x) (/ 1 x)))) (define sin (lift-real->real \nsin (lambda (x) (cos x)))) (define cos (lift-real->real cos (lambda (x) (-0 (sin x))))) (define atan \n(lift-real*real->real atan (lambda (x1 x2) (/ (-0 x2) (+ (* x1 x1) (* x2 x2)))) (lambda (x1 x2) (/ x1 \n(+ (* x1 x1) (* x2 x2)))))) (define = (lift-real^n->boolean =)) (define < (lift-real^n->boolean <)) (define \n> (lift-real^n->boolean >)) (define <= (lift-real^n->boolean <=)) (define >= (lift-real^n->boolean >=)) \n(define zero? (lift-real^n->boolean zero?)) (define positive? (lift-real^n->boolean positive?)) (define \nnegative? (lift-real^n->boolean negative?)) (define real? (lift-real^n->boolean real?)) Figure 3. Overloading \nsome SCHEME procedures that operate on reals with extensions that support multivariate power series. \nNote that the overloaded +, -, *, /,and atan procedures are restricted to accept precisely two arguments. \n;;; Equation (2) (define (derivative f) (lambda (c) (let ((e (generate-epsilon))) (univariate-ee1(f(linear-term \ne c 1)))))) (define (ith-derivative-by-repetition i f)  (cond ;; Equation (3) ((zero? i) f) ;; Equation \n(4) (else (ith-derivative-by-repetition (-i 1) (derivative f))))) ;;; Equation (7) (define (ith-derivative-by-tower \ni f) (lambda (c) (let ((e (generate-epsilon))) (univariate-e e i (f (linear-term e c 1)))))) (define \n(position-of-nonzero i) (cond ((null? i) #f) ((zero? (car i)) (let ((position (position-of-nonzero (cdr \ni)))) (if position (+ position 1) #f))) (else 0))) (define (decrement-lth i l) (if (zero? l) (cons (-(car \ni) 1) (cdr i)) (cons (car i) (decrement-lth (cdr i) (-l 1))))) (define (list-replace-lth c l u) (if (zero? \nl) (cons u (cdr c)) (cons (car c) (list-replace-lth (cdr c) (-l 1) u)))) (define (partial-derivative-by-repetition \ni f) (let ((l (position-of-nonzero i))) (cond ;; Equation (8) ((not l) f) ;; Equation (9) (else (partial-derivative-by-repetition \n (decrement-lth i l) (lambda (c) ((derivative (lambda (u) (f (list-replace-lth c l u)))) (list-ref c \nl)))))))) ;;; Equation (12) (define (partial-derivative-by-tower i f) (lambda (c) (let ((e (map (lambda \n(cl) (generate-epsilon)) c))) (multivariate-eei(f(map (lambda (el cl) (linear-term el cl 1)) e c)))))) \nFigure 4. ASCHEME implementation of D, the repetition and tower methods for Di, and the repetition and \ntower methods for D(i1,...,in). 7. Discussion Forward AD is typically formulated using very different \nmachin\u00adery than that used above. The univariate .rst-order case is usually formulated as a transformation \nof a program whose program points compute values f(x) of the program input x to one whose pro\u00adgram points \ncompute values (f(x),f ' (x)). Since the program is a composition of primitives, the program transformation, \nas well as the transformation of the primitives, are formulated as applications of the chain rule. Karczmarczuk \nformulated the univariate higher\u00adorder case as a similar transformation to a program whose pro\u00adgram points \ncompute stream values (f(x),f ' (x),f '' (x),...) via the chain rule, though he did not present a derivation \nof the trans\u00adformations of the primitives. The streams we have used are instead of the form ' '' (i) \n(f(x)/0!,f (x)/1!,f (x)/2!,...,f(x)/i!,...) These Taylor series streams simplify some bookkeeping, in \nparticu\u00adlar allowing the use of Taylor expansions instead of the chain rule in the derivations. This \nmakes the multivariate higher-order case more straightforward to derive and justify. However, since each \nrepresen\u00adtation can be converted to the other (using operators that are similar to C) we do not consider \nthis a fundamental difference. Karczmarczuk [4] hinted at a formulation of the multivariate higher-order \ncase using the chain rule, where lazy unidimensional streams are replaced with lazy trees, but did not \npresent a derivation or justi.cation of the method s correctness. That method redun\u00addantly represents \nidentical cross derivatives, i.e., .2f/.xi.xj = .2f/.xj .xi. Our method avoids that inef.ciency. Moreover, \nal\u00adthough nesting is not our topic, the code presented does allow the derivative-taking constructs to \nnest correctly. Laziness is particularly useful when representing and manipu\u00adlating power series, in \ncontexts beyond those considered here [10]. For instance it can be used to de.ne a power series with \na recur\u00adrence relation. Such power series arise naturally in related con\u00adtexts, such as differential \nequations that cannot be solved in closed form. Formulating nestable multivariate higher-order forward \nAD in terms of lazy power-series representations can allow forward AD to inter-operate with such other \napplications of power series.  Acknowledgments This work was supported, in part, by NSF grant CCF-0438806, \nScience Foundation Ireland grant 00/PI.1/C067, and a grant from the Higher Education Authority of Ireland. \nAny opinions, .ndings, and conclusions or recommendations expressed in this material are those of the \nauthor(s) and do not necessarily re.ect the views of the National Science Foundation. References [1] \nR. E. Wengert, A simple automatic derivative evaluation pro\u00adgram, Comm. of the ACM, vol. 7, no. 8, pp. \n463 4, 1964. [2] J. Karczmarczuk, Functional differentiation of computer pro\u00adgrams, in Proceedings of \nthe III ACM SIGPLAN Interna\u00adtional Conference on Functional Programming, Baltimore, MD, Sept. 1998, pp. \n195 203. [3] , Lazy differential algebra and its applications, in Work\u00adshop, III International Summer \nSchool on Advanced Func\u00adtional Programming, Braga, Portugal, Sept. 1998. [4] , Functional coding of \ndifferential forms, in Scottish Workshop on FP, Sept. 1999. [5] , Functional differentiation of computer \nprograms, Journal of Higher-Order and Symbolic Computation, vol. 14, pp. 35 57, 2001. [6] J. M. Siskind \nand B. A. Pearlmutter, Nesting forward-mode AD in a functional framework, to appear. [7] B. Taylor, Methodus \nIncrementorum Directa et Inversa. Lon\u00addon, 1715. [8] W. K. Clifford, Preliminary sketch of bi-quaternions, \nPro\u00adceedings of the London Mathematical Society, vol. 4, pp. 381 395, 1873. [9] W. G. Horner, A new method \nof solving numerical equations of all orders, by continuous approximation, Philos. Trans. Roy. Soc. London, \nvol. 109, pp. 308 335, July 1819. [10] J. Karczmarczuk, Generating power of lazy semantics, The\u00adoretical \nComputer Science, vol. 187, 1997.  \n\t\t\t", "proc_id": "1190216", "abstract": "A method is presented for computing all higher-order partial derivatives of a multivariate function R <i><sup>n</sup></i> &#8594; R. This method works by evaluating the function under a nonstandard interpretation, lifting reals to multivariate power series. Multivariate power series, with potentially an infinite number of terms with nonzero coefficients, are represented using a lazy data structure constructed out of linear terms. A complete implementation of this method in <sc>Scheme</sc> is presented, along with a straightforward exposition, based on Taylor expansions, of the method's correctness.", "authors": [{"name": "Barak A. Pearlmutter", "author_profile_id": "81100103003", "affiliation": "Hamilton Institute, NUI Maynooth, Ireland", "person_id": "PP14045810", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey Mark Siskind", "author_profile_id": "81100602369", "affiliation": "Purdue University", "person_id": "P137999", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190242", "year": "2007", "article_id": "1190242", "conference": "POPL", "title": "Lazy multivariate higher-order forward-mode AD", "url": "http://dl.acm.org/citation.cfm?id=1190242"}