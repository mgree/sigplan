{"article_publication_date": "01-17-2007", "fulltext": "\n Generative Unbinding of Names Andrew M. Pitts * Mark R. Shinwell University of Cambridge Computer Laboratory \nCodeSourcery, Ltd Andrew.Pitts@cl.cam.ac.uk shinwell@codesourcery.com Abstract This paper is concerned \nwith a programming language construct for typed name binding that enforces a-equivalence. It proves a \nnew result about what operations on names can co-exist with this construct. The particular form of typed \nname binding studied is that used by the FreshML family of languages. Its characteris\u00adtic feature is \nthat a name binding is represented by an abstract (name,value)-pair that may only be deconstructed via \nthe genera\u00adtion of fresh bound names. In FreshML the only observation one can make of names is to test \nwhether or not they are equal. This restricted amount of observation was thought necessary to ensure \nthat there is no observable difference between a-equivalent name binders. Yet from an algorithmic point \nof view it would be desir\u00adable to allow other operations and relations on names, such as a total ordering. \nThis paper shows that, contrary to expectations, one may add not just ordering, but almost any relation \nor numerical function on names without disturbing the fundamental correctness result about this form \nof typed name binding (that object-level a\u00adequivalence precisely corresponds to contextual equivalence \nat the programming meta-level), so long as one takes the state of dynam\u00adically created names into account. \nCategories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; D.3.3 \n[Programming Languages]: Language Constructs and Features Abstract data types; F.3.2 [Logics and Meanings \nof Programs]: Semantics of Programming Languages Operational semantics General Terms Languages, Theory \nKeywords Abstract syntax, binders, alpha-conversion, meta-pro\u00adgramming 1. Introduction FreshML and the \nlanguage systems that it has inspired provide some user friendly facilities within the context of strongly \ntyped functional programming for computing with syntactical data struc\u00adtures involving names and name \nbinding. The underlying theory was presented in [20, 26] and has been realised in the Fresh patch of \nObjective Caml [24]. FreshML has also inspired Pottier s Caml tool [21] for Objective Caml and Cheney \ns FreshLib library [3] * Research supported by UK EPSRC grant EP/D000459/1 Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. \nCopyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001...$5.00. type atm type a bnd val fresh : unit . \natm val bind : atm * a . a bnd val unbind : a bnd . atm * a val (=) : atm . atm . bool Figure 1. A signature \nfor name binding. for Haskell. The approach taken to binding in all these works is nominal in that the \nuser is given access to the names of bound entities and can write syntax manipulating programs that follow \nthe informal practice of referring to a-equivalence classes of terms via representatives. However, in \nFreshML the means of access to bound names is carefully controlled by the type system. It has been shown \n[23, 25] that its static and dynamic properties combine to guarantee a certain correctness of representation \nproperty: data structures representing a-equivalent syntactical terms (that is, ones differing only in \nthe names of bound entities) always behave the same in any program. So even though programs can name \nnames, as it were, a-equivalence of name bindings is taken care of auto\u00admatically by the programming \nlanguage design. Of course such a correctness of representation property depends rather delicately upon \nwhich operations on bound names are al\u00adlowed. At the heart of this approach to binding is an operation \nthat we call generative unbinding. To explain what it involves, consider a simpli.ed version of Fresh \nObjective Caml with a single type atm of bindable names and a parametric family of types a bnd classify\u00ading \nabstractions of single names over values of type a. To explain: both atm and a bnd are abstract types \nthat come with the signa\u00adture of operations shown in Figure 1. The closed values of type atm are drawn \nfrom a countably in.nite set A of symbols that we call atoms. Programs only get access to atoms by evaluating \nthe ex\u00adpression fresh() to get a fresh one; and hence program execution depends upon a state recording \nthe atoms that have been created so far. Given a type t , closed values of type t bnd are called atom \nbindings andare givenbypairs ((a))v consisting of an atom a : atm and a closed value v : t. Atom bindings \nare constructed by evalu\u00adating bind(a,v). Fresh Objective Caml provides a very convenient form of generative \npattern matching for deconstructing atom bind\u00adings. To keep things simple, here we will consider an equivalent \nmechanism for deconstructing atom binding via an unbind func\u00adtion carrying out generative unbinding: \nunbind ((a))v evaluates by .rst evaluating fresh() to obtain a fresh atom a' and then return\u00ading the \npair (a' ,v{a'/a}), where in general v{a'/a} denotes the ' value obtained from v by renaming all occurrences \nof a to be a. The instance of renaming that arises when evaluating unbind ((a))v is special: the fresh \natom a' does not occur in v and so v{a'/a} is equivalent to the result of applying to v the semantically \nbetter be\u00adhaved operation of swapping a and a'. Implementing such an atom swapping operation on all types \nof values is the main extension that the Fresh patch makes to Objective Caml. A language extension is \nnot needed if users de.ne atom swapping themselves, on a case\u00adby-case basis; this more limited approach \nis quite workable in the presence of Haskell-style type classes see [3]. The type a bnd is used in data \ntype declarations in the argument type of value constructors representing binders. To take a familiar \nexample, the terms of the untyped .-calculus (all terms, whether open or closed, with variables given \nby atoms a .A) t ::= a |.a.t |tt can be represented by closed values of the type term given by the | \ndeclaration type term = Vof atm (1) | L of term bnd Aof term *term . The value 't': term representing \na .-term t is de.ned by 'a' V a '.a.t' L ((a))'t' (2) 't1 t2' A('t1', 't2') and satis.es: Correctness \nof Representation: two .-terms are a-equi\u00advalent, t1 =a t2,iff 't1'and 't2'are contextually equiva\u00adlent \nclosed values of type term, i.e. can be used interchange\u00adably in any well-typed Fresh Objective Caml \nprogram with\u00adout affecting the observable results of program execution. Since it is also the case that \nevery closed value of type term is of the form 't'for some .-term t, it follows that there is a bijection \nbe\u00adtween a-equivalence classes of .-terms and contextual equivalence classes of closed values of type \nterm. The Correctness property is not easy to prove because of the nature of contextual equivalence, \nwith its quanti.cation over all possible program contexts. It was established in [23, 25] using denotational \nmethods that take permu\u00adtations of atoms into account. The same methods can be used to generalise from \nthe example of .-terms to terms over any nominal signature in the sense of [29]. Contribution of this \npaper. For the signature in Figure 1, the only operation on atoms apart from bind is a test for equality: \na = a ' evaluates to true if a and a ' are the same atom and to false otherwise. Adding extra operations \nand relations for atoms may well change which program phrases are contextually equivalent. Is it possible \nto have some relations or operations on atoms in addition to equality without invalidating the above \nCorrectness property? For example it would be very useful to have a linear order (<): atm .atm .bool, \nso that values of type atm could be used as keys in ef.cient data structures for .nite maps and the like. \nWe show that this is possible, and more. This is a rather unexpected result, for the following reason. \nThe proof of the Correctness property given in [23, 25] relies upon equivariant properties of the semantics, \nin other words ones whose truth is invariant under permuting atoms. Atom equality is equivariant: since \na permutation is in particular bijective, it pre\u00adserves and re.ects the value of a = a ' . At .rst it \nseems that a linear order on atoms cannot be equivariant, since if a<a ' is true, then applying the permutation \nswapping a and a ' we get a ' <a,which is false. However, equivariance is a global property: when consid\u00adering \ninvariance of the truth of a property under permutations, it is crucial to take into account all the \nparameters upon which the prop\u00aderty depends. Here there is a hidden parameter: the current state of dynamically \ncreated atoms. So we should permute the atoms in this state as well as the arguments of the relation. \nWe shall see that it Variables f, x .V countably in.nite set (.xed) Atoms a .A countably in.nite set \n(.xed) Data types d .D .nite set (variable) Constructors C .C .nite set (variable) Observations obs .O \n.nite set (variable) Values v .Val ::= variable x unit () pair (v, v) recursive function fun(fx = e) \ndata construction C v atom a atom binding ((v))v Expressions e .Exp ::= value v sequencing let x = e \nin e .rst projection fst v second projection snd v function application vv data deconstruction match \nv with (C x .e |\u00b7\u00b7\u00b7) fresh atom fresh() generative unbinding unbind v atom observation obs v \u00b7\u00b7\u00b7v Frame \nstacks S .Stk ::= empty Id non-empty S .(x.e) States aa .State .nite lists of distinct atoms Machine \ncon.gurations (aa, S, e) Types t .Typ ::= unit unit pairs t *t functions t .t data type d atoms atm atom \nbindings t bnd .n Typing environments G .V .Typ Typing judgements expressions &#38; values G fe : t frame \nstacks G fS : t .t ' Initial basis natural numbers nat .D zero (Zero : unit .nat) .C successor (Succ \n: nat .nat) .C atom equality eq .O (arity =2) Figure 2. Language syntax. is perfectly possible to have \na state-dependent equivariant order\u00ading for the type atm without invalidating the Correctness property. \nIndeed we prove that one can add any n-ary function from atm to numbers (or to booleans, for that matter) \nwhose semantics is reasonable,1 without invalidating the Correctness property for any nominal signature. \nWe have to work quite hard to get this result, which generalises the one announced in [26] (with a .awed \nproof sketch) and .nally proved in [25, 23]; but whereas those works use denotational tech\u00adniques, here \nwe use an arguably more direct approach based on the operational semantics of the language. Along the \nway to the main result (Theorem 14) we prove a Mason-Talcott-style CIU [12] characterisation of contextual \nequivalence for our language (The\u00ad 1 We explain what is reasonable in Section 3. orem 10). This is proved \nusing Howe s method [10] applied to a formulation of the operational semantics with Felleisen-style eval\u00aduation \ncontexts [4], via an abstract machine with frame stacks [16]. We also prove extensionality laws for the \natom binding type con\u00adstruction abnd (Propositions 16 and 19). The proof technique un\u00adderlying our work \nis rule based induction, but with the novel twist that we exploit semantic properties of freshness of \nnames that are based on the use of name permutations and that were introduced in [6] and developed in \n[17, 28, 19]. 2. Generative Unbinding We use a version of FreshML that provides the signature in Figure \n1 in the presence of higher order recursively de.ned functions on user declared data structures. Its \nsyntax is given in Figure 2. As usual, fun(fx=-) let x=ein - match vwith (C x.-|\u00b7\u00b7\u00b7) S.(x.-) are all \nvariable-binding constructs and we identify expressions and frame stacks up to renaming of bound variables. \nAs well as vari\u00adables (standing for unknown values), the language s expressions and frame stacks may \ncontain atoms drawn from a .xed, count\u00adably in.nite set A. As discussed in the introduction, atoms are \nused in FreshML to represent names in object-level languages. Note that even though there are variable-binding \nconstructs in FreshML, none of the language constructs in Figure 1 involve binding atoms. So we do not \nidentify expressions up to renaming atoms; for exam\u00adple, if a ' ,then ((a))(C a)and ((a ' ))(C a ' )are \ndifferent expres\u00ad =a sions (that turn out to be contextually equivalent). We write atom(e) (3) for the \n.nite set of atoms that occur anywhere in the expression e. The same notation atom(-)is used for the \n.nite set of atoms in a frame stack and, more generally, in a .nite list of expressions, frame stacks, \natoms, and so on. The language de.ned in Figure 1 is parameterised by the choice of a .nite set O of \nfunction symbols (that we call observations on atoms and whose role is discussed below), by a .nite set \nDof data type symbols, and by a .nite set C of constructor symbols. Each constructor C .C is assumed \nto come with a type, C : t . d, where t . Typ and d .D. The choice of D, C and this typing information \nconstitutes an ML-style top-level declaration of some (possibly mutually recursive) data types: type \nd1 =C1,1 of t1,1 |\u00b7\u00b7\u00b7|C1,n1 of t1,n1 . . (4) . and dm =Cm,1 of tm,1 |\u00b7\u00b7\u00b7|Cm,nm of tm,nm . Here di (for \ni=1..m) are the distinct elements of the set Dof data type symbols and Ci,j (for i =1..mand j =1..ni) \nare the distinct elements of the set Cof constructor symbols. The above declaration just records the \ntyping information C :t .dthat comes with each constructor, grouped by result types: di appears as the \nresult type of precisely the constructors Ci,1,...,Ci,ni and their argument types are ti,1,...,ti,ni \n. For the moment we place no restriction on these types ti,j : they can be any element of the set Typ \nwhose grammar is given in Figure 2. However, when we consider representation of object-level languages \nup to a-equivalence in Section 5, we will restrict attention to top-level data type declarations where \nthe types ti,j do not involve function types. We consider observations on atoms that return natural num\u00adbers.2 \nSo we assume D always contains a distinguished data type 2 The effect of admitting some other types of \noperation on atoms is dis\u00adcussed in Section 6.2. G(x)=t Gfv1 :t1 Gfv2 :t2 Gfx :t Gf():unit Gf(v1 ,v2):t1 \n*t2 G,f :t .t ' ,x:t fe:t ' C :t .d Gfv :t Gffun(fx=e):t .t ' GfC v :d a.A Gfv1 :atm Gfv2 :t Gfa:atm \nGf((v1))v2 :tbnd Gfe :t G,x:t fe ' :t ' Gfv :t1 *t2 Gflet x=e in e ' :t ' Gffst v :t1 Gfv :t1 *t2 Gfv1 \n:t .t ' Gfv2 :t Gfsnd v :t2 Gfv1 v2 :t ' d=C1 of t1 |\u00b7\u00b7\u00b7|Cn of tn Gfv :d G,x1 :t1 fe1 :t \u00b7\u00b7\u00b7 G,xn :tn \nfen :t Gfmatch vwith (C1 x1 .e1 |\u00b7\u00b7\u00b7|Cn xn .en):t Gfv :tbnd Gffresh():atm Gfunbind v :atm *t arity(obs)=k \nGfv1 :atm \u00b7\u00b7\u00b7 Gfvk :atm Gfobs v1 ...vk :nat ' ''' G,x:t fe :t GfS :t .t GfId :t .t GfS.(x.e):t .t '' \nNotation: G,x :t indicates the typing environment obtained by extending the .nite partial function Gby \nmapping a variable xto the type t (we always assume that x/.dom(G)).  In the typing rule for match-expressions, \nthe hypothesis d = C1 of t1 | \u00b7\u00b7\u00b7 | Cn of tn refers to the top-level data type declaration (4); in other \nwords, the only constructors whose result type is d are C1,...,Cn and ti is the argument type of Ci (for \ni=1..n).  Figure 3. Typing relation. nat for the type of natural numbers and that correspondingly Ccon\u00adtains \nconstructors Zero : unit . nat and Succ : nat . nat for zero and successor. Each obs .Odenotes a numerical \nfunction on atoms. We assume it comes with an arity, specifying the number of arguments it takes: so \nif arity(obs)= k and (v1,...,vk)is a k-tuple of values of type atm,then obs v1 ...vk is an expression \nof type nat. The typing of the language s values, expressions and frame stacks takes place in the presence \nof typing environments, G, each assigning types to .nitely many variables. The rules in Fig\u00adure 3 for \nthe inductively de.ned typing relation are entirely stan\u00addard, given that we are following the signature \nin Fig 1. As well as an arity, we assume that each obs .Ocomes with a speci.ed interpretation: the form \nthis takes is discussed in the next section. The expressions of the language are given in a reduced (or \nA\u00adnormal [5]) form in which the order of evaluation is made explicit through let-expressions. Hence there \nis a single form of frame on the evaluation stack S in con.gurations (aa,S,e) of the abstract machine \nthat we use for de.ning the language s dynamics. The other two components of machine con.gurations are \nthe state a , (aa, S, e)-.(a ' ,S ' ,e ' ) (aa, S, e).n (aa, S, e). 1. (aa, S .(x.e),v)-.(aa, S, e[v/x]) \n 2. (aa, S, let x =e1 in e2)-.(aa, S .(x.e2),e1) 3. (aa, S, match C v with(\u00b7\u00b7\u00b7|C x.e |\u00b7\u00b7\u00b7))-.(aa, S, \ne[v/x]) 4. (aa, S, fst(v1 ,v2))-.(aa, S, v1) 5. (aa, S, snd(v1 ,v2))-.(aa, S, v2) 6. (aa, S, v1 v2)-.(aa, \nS, e[v1,v2/f, x])if v1 =fun(fx =e) 7. (aa, S, fresh())-.(a &#38;#169; a ' ,S,a ' )if a ' ./atom(a ) \n 8. (aa, S, unbind ((a))v)-.(a &#38;#169; a ' ,S, (a ' ,v{a ' /a}))if a ' ./atom(a ) 9. (aa, S, obs \na1 ...ak)-.(aa, S, 'm') if arity(obs)= k, (a1,...,ak).atom(a )k and [obs]a (a1,...,ak)=m  Notation: \n e[v, .../x,...]is the simultaneous, capture avoiding substitu\u00adtion of values v, ... for all free occurrences \nof the correspond\u00ading variables x,... in the expression e;  v{a ' /a}is the result of replacing all \noccurrences of an atom a by an atom a ' in the value v; a &#38;#169; a ' is the state obtained by appending \nan atom a ' not in atom(a )to the right of the .nite list of distinct atoms a ;  'm' is the the closed \nvalue of type nat corresponding to m . N: '0' Zero()and 'm +1' Succ 'm';  [obs] is the meaning of obs: \nsee Section 3.  Figure 4. Transition relation. consisting of the .nite list of distinct atoms that have \nbeen allocated so far, and the expression e to be evaluated. The use of reduced form is a common device \nto ease development of properties of the language s dynamics. Those dynamics are given by the transition \nrelation in Figure 4. The .rst six types of transition are all quite standard. Transition 7 de.nes the \ndynamic allocation of a fresh atom and transition 8 de.nes generative unbinding using a freshly created \natom; we discuss transition 9 for observations on atoms in the next section. For the atom a ' in7toreally \nbe fresh,weneed to know that it does not occur in S; similarly, in 8 we need to know that a ' does not \noccur in (S, a, v). These requirements are met if con.gurations (aa, S, e)satisfy that all the atoms \noccurring in the frame stack S or the expression e occur in the list a .Using the notation atom(-) mentioned \nabove (3), we can write this condition as atom(S, e).atom(a ). Theorem 2 shows that this property of \ncon.gurations is invariant under transitions, as is well-typedness. Before stating this theorem we introduce \nsome useful terminology. De.nition 1 (Worlds). A(possible) world w is just a .nite subset of the the \n.xed set A of atoms. We write World forthe setofall worlds. In what follows we will index various relations \nassociated with the language we are considering by worlds w .World that make explicit the atoms involved \nin the relation. Sometimes (as in the following theorem) this is a merely a matter of notational con\u00advenience; \nworld-indexing will be more crucial when we consider program equivalence: see Remark 12 below. ''' ''' \n(aa, S, e)-.(a ,S ,e )(a ,S ,e ).n (aa, Id,v).0 (aa, S, e).n+1 (aa, S, e).n (aa, S, e). Figure 5. Termination \nrelations. Theorem 2 (Type Safety). Write fw (aa, S, e): t to mean that atom(S, e).atom(a )=w and that \nthere is some type t ' with \u00d8fS :t ' .t and \u00d8fe :t ' . The type system has the following properties. \nPreservation: if fw (aa, S, e): t and (aa, S, e)-.(a ' ,S ' ,e ' ), '' ''' with atom(a )=w say, then \nw .w and fwl (a ,S ,e ' ): t . Progress: if fw (aa, S, e):t,theneither S =Id and e .Val,or '' '' (aa, \nS, e)-.(a ,S ,e ' )holds for some a , S ' and e . 3. Observations on Atoms The language we are considering \nis parameterised by a choice of a .nite set Oof numerical functions on atoms. We assume that each obs \n.Ocomes with a speci.ed meaning [obs]. As mentioned in the introduction, we should allow these meanings \nto be dependent on the current state (the list of distinct atoms that have been created so far). So if \narity(obs)=k, for each a .State we assume given a function [obs]a : atom(a )k . N mapping k-tuples of \natoms occurring in the state a to natural numbers. These functions are used in the transitions of type \n9 in Figure 4. Not every such family ([obs]aa |a .State)of functions is acceptable as an observation \non atoms: we require that the family be equivariant. To explain what this means we need the following \nde.nition. De.nition 3 (Permutations). A .nite permutation of atoms is a bijection p from the set A of \natoms onto itself such that supp(p) {a .A | p(a)= a}is a .nite set. We write P for the set of all such \npermutations. If p .P and a .State,then p \u00b7 a denotes the .nite list of distinct atoms obtained by mapping \np over the list a ;if e is an expression, then p\u00b7e denotes the expression obtained from it by applying \np to the atoms in e; and similarly for other syntactical structures involving .nitely many atoms, such \nas values and frame stacks. We require the functions ([obs]a |a .State)associated with each obs .Oto \nsatisfy an equivariance property: for all p .P, a .State and (a1,...,ak).atom(a )k (where k is the arity \nof obs) [obs]aa(a1,...,ak)=[obs]p\u00b7aa(p(a1),...,p(ak)). (5) We impose condition (5) for the following \nreason. In Figure 4, the side conditions on transitions of types 7 and 8 do not specify which of the \nin.nitely many atoms in A -atom(a ) should be chosen as the fresh atom a ' . Any particular implementation \nof the language will make such choices in some speci.c way, for example by implementing atoms as numbers \nand incrementing a global counter to get the next fresh atom. We wish to work at a level of abstraction \nthat is independent of such implementation details. We can do so by ensuring that we only use properties \nof machine con.gurations (aa, S, e) that depend on the relative positions of atoms in the list a , rather \nthan upon their identities. In other words, properties should respect a-equivalence of con.gurations \nwhen the state component is regarded as binding atoms in the stack Equality, eq (arity =2): ( ' 0 if \na =a ' , [eq]a (a, a ) 1 otherwise. Linear order, lt (arity =2): ( ' 0 if a occurs to the left of a ' \nin the list a , [lt]a (a, a ) 1 otherwise. Ordinal, ord (arity =1): [ord]a (a) n,if a is the nth element \nof the list a . State size, card (arity =0): [card]a () length of the list a . Figure 6. Examples of \nobservations on atoms. and expression components. For the reasons given in the previous section we only \nuse con.gurations that are closed in the sense of satisfying atom(S, e) . atom(a ) (cf. Theorem 2); and \na\u00adequivalence for such con.gurations relates (aa, S, e)with (p \u00b7aa, p \u00b7 S, p \u00b7 e) for any p . P. So properties \nof con.gurations should be equivariant: if (aa, S, e) has the property, then so should (p \u00b7 aa, p \u00b7 S, \np \u00b7 e). The main property of con.gurations we need is termination, de.ned in Figure 5, since as we see \nin the next section this determines contextual equivalence of expressions. With condition (5) we have: \nLemma 4. If (aa, S, e).n,then (p \u00b7aa, p \u00b7 S, p \u00b7e).n for any p .P. Proof. In view of the de.nition of \ntermination in Figure 5, it suf\u00ad.ces to show that the transition relation is equivariant: ' '' (aa, S, \ne)-.(a ,S ,e ). ' '' (p \u00b7 aa, p \u00b7 S, p \u00b7 e)-.(p \u00b7 a ,p \u00b7 S ,p \u00b7 e ). This can be proved by cases from \nthe de.nition of -. in Fig 4. Cases 1 8 follow from general properties of the action of permu\u00adtations \non syntactical structures (such as the fact that p \u00b7 (e[v/x]) equals (p \u00b7 e)[p \u00b7 v/x]); case 9 uses property \n(5). As a corollary we .nd that termination is indeed independent of the choice of fresh atom in transitions \nof the form 7 or 8. Corollary 5. If (aa, S, fresh).n+1 with atom(S).atom(a ),then for all a ' ./atom(a \n), it is the case that (a &#38;#169; a ' ,S,a ' ).n. Simi\u00adlarly, if (aa, S, unbind ((a))v).n+1 with atom(S, \na, v).atom(a ), ' '' then for all a ./atom(a ), it is the case that (a &#38;#169; a ,S, (a, v{a ' /a})).n. \nThere are observations on atoms that are not equivariant, that is, whose value on some atoms in a particular \nstate does not depend just upon the relative position of those atoms in the state. For example, if we \n.x some enumeration of the set of atoms, a :N ~ = A, it is easy to see that the unary observation given \nby [obs]a (a)= a-1 (a)fails to satisfy (5). Nevertheless, there is a wide range of functions that do \nhave this property. Figure 6 gives some examples. The .rst one, eq, combined with the usual arithmetic \noperations for nat that are already de.nable in the language, gives us the effect of the function (=) \n: atm . atm . bool from the signature in Figure 1; so we assume that the set O of observations on atoms \nalways contains eq. G(x)=t Gfw x Ebx :t Gfw ()Eb():unit Gfw v1 E v1 ' :t1 Gfw v2 E v2 ' :t2 Gfw (v1 ,v2)Eb(v1 \n' ,v2' ):t1 *t2 ' '' G,f :t .t ,x :t fw e E e :t Gfw fun(fx =e)Ebfun(fx =e ' ):t .t ' C :t .d Gfw v E \nv ' :ta .w b' b Gfw C v E C v :d Gfw a E a :atm Gfw v1 E v1 ' :atm Gfw v2 E v2 ' :t b'' Gfw ((v1))v2 \nE((v1))v2 :t bnd ' '' Gfw e1 E e1 :t G,x :t fw e2 E e2 :t ' '' b Gfw let x =e1 in e2 E let x =e1 in e2 \n:t Gfw v E v ' :t1 *t2 Gfw v E v ' :t1 *t2 b' b' Gfw fst v E fst v :t1 Gfw snd v E snd v :t2 '' ' Gfw \nv1 E v1 :t .t Gfw v2 E v2 :t '' ' b Gfw v1 v2 E v1 v2 :t d =C1 of t1 |\u00b7\u00b7\u00b7|Cn of tn Gfw v E v ' :d G,x1 \n:t1 fw e1 E e1 ' :t \u00b7\u00b7\u00b7 G,xn :tn fw en E en ' :t Gfw match v with (C1 x1 .e1 |\u00b7\u00b7\u00b7|Cn xn .en)Eb '' ' \nmatch v with (C1 x1 .e1 |\u00b7\u00b7\u00b7|Cn xn .en):t Gfw fresh()Ebfresh():atm Gfw v E v ' :t bnd b' Gfw unbind v \nE unbind v :atm *t arity(obs)=k Gfw v1 E v1 ' :atm \u00b7\u00b7\u00b7 Gfw vk E vk ' :atm Gfw obs v1 ...vk Ebobs v1 \n' ...vk ' :nat Gfw Id EbId :t .t '' '''' G,x :t fw e E e :t Gfw S EbS :t .t '' '' Gfw S .(x.e)EbS .(x.e \n):t .t Figure 7. Compatible re.nement Ebof an expression relation E. Remark 6 (Fresh Atoms Largest). \nNote that in the operational se\u00admantics of Figure 4 we have chosen to make fresh atoms largest , in the \nsense that the fresh atom a ' in transitions 7 and 8 is added to the right-hand end of the list a representing \nthe current state. In the presence of observations on atoms other than equality, such a choice may well \naffect the properties of the notion of program equivalence that we explore in the next section. Other \nchoices are possible, but to insist that program equivalence is independent of any such choice would \nrule out many useful observations on atoms (such as lt or ord in Figure 6). 4. Contextual Equivalence \nWe wish to prove that the language we have described satis.es Correctness of Representation properties \nof the kind mentioned in the introduction. To do so, we .rst have to be more precise about what it means \nfor two expressions to be contextually equivalent, that is, to be interchangeable in any program without \naffecting the observable results of executing that program. What is a program, what does it mean to execute \nit, and what results of execution do we observe? The answers we take to these questions are: programs \nare closed well-typed expressions; execution means carrying out a sequence of transitions of the abstract \nmachine from an initial machine con.guration consisting of a state (that is, a list of atoms containing \nthose mentioned in the program), the empty frame stack and the program; and we observe whether execution \nreaches a ter\u00adminal con.guration, that is, one of the form (aa, Id,v).Weneed only observe termination \nbecause of the language s strict evaluation strategy: observing any (reasonable) properties of the .nal \nvalue v results in the same notion of contextual equivalence. Also, it is tech\u00adnically convenient to \nbe a bit more liberal about what constitutes an initial con.guration by allowing the starting frame stack \nto be non\u00adempty: this does not change the notion of contextual equivalence because of the correspondence \nbetween frame stacks and evalua\u00adtion contexts see the remarks after De.nition 11 below. So we can say \nthat e and e ' are contextually equivalent if for all program contexts C[-], the programs C[e]and C[e \n' ]are operationally equiv\u00adalent in the following sense. De.nition 7 (Operational Equivalence of Closed \nExpressions). ~' fw e =e :t is de.ned to hold if atom(e, e ' ).w;  \u00d8fe :t and \u00d8fe ' :t;and for all \na , S and t ' with w .atom(S).atom(a )and \u00d8fS : t .t ' ,itisthe case that (aa, S, e). . (aa, S, e ' ).. \n However, for the reasons given in [18, Section 7.5], we pre\u00adfer not to phrase the formal de.nition \nof contextual equivalence in terms of the inconveniently concrete operation of possibly cap\u00adturing substitution \nof open expressions for the hole - inpro\u00adgram contexts C[-]. Instead we take the more abstract relational \nap\u00adproach originally advocated by Gordon [7] and Lassen [11] which focuses upon the key features of contextual \nequivalence, namely that it is the largest congruence relation for well-typed expres\u00adsions that contains \nthe relation of operational equivalence of De.\u00adnition 7. A congruence relation is an expression relation \nthat is both an equivalence and compatible, in the following sense. De.nition 8 (Expression Relations). \nAn expression relation E is a set of tuples (G,w,e,e ' ,t)(made up of a typing context, a world, two \nexpressions and a type) satisfying atom(e, e ' ) . w, Gfe :t and Gfe ' :t. We write Gfw e Ee ' :t to \nindicate that (G,w,e,e ' ,t)is a member of E. We use the following terminology in connection with expression \nrelations. Eis an equivalence if it is re.exive (atom(e) . w . G f e : t . Gfw e Ee :t), symmetric (Gfw \ne Ee ' :t . Gfw ' ' ''' e Ee :t) and transitive (Gfw e Ee :t . Gfw e Ee : t . Gfw e Ee '' :t). Eis compatible \nif bEis the compatible re.nement of E.E,where b E, de.ned in Figure 7. ' '' Eis substitutive if Gfw \nv Ev :t .G,x :t fw e Ee :t . Gfw e[v/x]Ee ' [v ' /x]:t ' . Eis equivariant if Gfw e Ee ' :t . Gfp\u00b7w p \n\u00b7 e Ep \u00b7 e ' :t. Eis adequate if fe ~' :t .\u00d8fe Ee ' :t. w =e w We extend operational equivalence (De.nition \n7) to an expres\u00ad ~.' sion relation, Gfw e = e :t, by instantiating free variables with closed values: \nDe.nition 9 (~.). Supposing G= {: t1,...,xn },we = x1 : tn ~.' de.ne Gfw e = e :t to hold if atom(e, \ne ' ).w;  Gfe :t and Gfe ' :t;and  for all w ' .w and all closed values vi with atom(vi) . w '  and \n\u00d8fvi :ti (for i =1..n), it is the case that fl e[av/ax]~e ' [av/ax]:t. w= Note that for closed expressions, \nthat is, in the case that G=\u00d8,the relation ~. agrees with ~: == ~.' ~' \u00d8fw e = e :t .fw e =e :t. (6) \nTheorem 10 (CIU). Operational equivalence of possibly open expressions, ~., is a compatible adequate \nequivalence. It is the = largest such expression relation. It is also substitutive and equiv\u00adariant. \nProof. The fact that ~. is equivariant follows from Lemma 4; and = the fact that it is an equivalence \nand adequate is immediate from its de.nition. So the main dif.culty is to show that it is compat\u00adible \nand substitutive. One can do this by adapting a construction due to Howe [10], as follows. Let the expression \nrelation ~* be = inductively de.ned from ~. by the rule = ' ' .'' e ~c* ~ Gfw = e :t Gfw e = e :t . (7) \n~ Gfw e = * e '' :t (In making this inductive de.nition, we are implicitly relying upon the easily proved \nfact that compatible re.nement, E.E,isa . bmonotone operation on expression relations, that is, E1 .E2 \n. Eb1 .Eb2.) It is not hard to show that ~= * is compatible and substitutive and contains ~.. So the \ncompatibility and substitutivity = * .~ of ~. follow once one proves ~= . and hence that these two == \nexpression relations coincide. This can be deduced by proving the ~* following two properties, (8) and \n(9). In (8), =cis extended to a relation between frame stacks using the last two rules in Figure 7; and \nin (9), (~= * )+ denotes the transitive closure of ~* = . '' *' ~~ \u00d8fw S =c* S :t .t .\u00d8fw e = e :t . \natom(a )=w .(aa, S, e).n .(aa, S ' ,e ' ). (8) *' '* + ~(~ Gfw e = e :t . Gfw e =)e :t. (9) If we have \nthese two properties, then from the .rst one (using the ~ fact that =c. is closed under weakening from \na world w to a larger one w ' .w)weget *' ' ~ \u00d8fw e = e :t ..aa,S,t .w .atom(S).atom(a ). \u00d8fS :t .t ' \n.(aa, S, e). . (aa, S, e ' ).. Since the right-hand side of this implication is a transitive relation \nbetween e and e ' , it follows that ~*+ '' \u00d8fw e = e : t ..aa,S,t .w.atom(S) .atom(a ) . \u00d8fS : t .t ' \n.(aa, S, e). . (aa, S, e ' ). and hence by property (9) that *' ' ~ \u00d8fw e = e : t ..aa,S,t .w .atom(S) \n.atom(a ) . \u00d8fS : t .t ' .(aa, S, e ' ). . (aa, S, e). . Therefore by de.nition of ~= (De.nition 7) we \nhave ~*' ~' \u00d8fw e = e : t .fw e = e : t. (10) Since the open extension ~= . of ~ = is easily seen to \nbe substitutive and re.exive, (10) implies that ~= ., as required. * .~ = So to complete the proof, one \njust has to establish properties (8) and (9). The second is easy to prove, but property (8) requires \na tricky induction on the derivation of (aa, S, e).n from the rules in Figure 5. The induction step corresponding \nto transitions of type 8 in Figure 4, that is, to generative unbinding, is quite delicate. It relies \nupon the fact that when a ' ./atom(v), a renamed value v{a ' /a}is the same as a permuted value (aa ' \n) \u00b7 v (where (aa ' ) denotes the permutation swapping a and a ' ). This allows one to use the equivariance \nof the termination relation, Lemma 4, to prove the induction step the details appear in the full version \nof this paper. Of course, the validity of Lemma 4 depends crucially upon the equivariance condition (5) \nthat we require of observations on atoms. De.nition 11 (Contextual Equivalence). In view of the discus\u00adsion \nat the beginning of this section, Theorem 10 tells us that ~. = coincides with a conventional notion \nof contextual equivalence de\u00ad.ned using program contexts: so from now on we refer to ~. as = contextual \nequivalence. We labelled the above theorem CIU because it is analogous to a theorem of that name due \nto Mason and Talcott [12]. CIU, af\u00adter permutation, stands for Uses of Closed Instantiations ; and the \ntheorem tells us that to test open expressions for contextual equiv\u00adalence it suf.ces to .rst close them \nby substituting closed values for free variables and then test the resulting closed expressions for termination \nwhen they are used in any evaluation context [4]. This follows from the de.nition of ~. and the fact \nthat termination in = evaluation contexts corresponds to termination of machine con.g\u00adurations via the \neasily veri.ed property (aa, S, e). . (aa, Id,S[e]). (11) where the expression S[e] is de.ned by recursion \non the length of the stack S by: Id[e] e (12) S .(x.e ' )[e] S[let x = e in e ' ] . Theorem 10 serves \nto establish some basic properties of contex\u00adtual equivalence, such as the fact that the state-independent \ntransi\u00adtions in Figure 4 (types 1 6 and 9) give rise to contextual equiva\u00ad ~ lences. For example, G fw \nlet x = v in e = . e[v/x]: t ' holds if G fw v : t and G,x : t fw e : t ' .However,wehavetoworka bit \nharder to understand the consequences of transitions of types 7 and 8 for contextual equivalence at atom \nbinding types, t bnd.We address this in the next section. Remark 12 (Possible Worlds). It is immediate \nfrom the de.nition of ~. that it satis.es a weakening property: = .'' .' ~~ G fw e = e : t . w .w . G \nfwl e = e : t. (13) If it also satis.ed a strengthening property .' '' ~ G fwl e = e : t . atom(e, e \n) .w .w ~.' . G fw e = e : t (14) then we could make the indexing of contextual equivalence by possible \nworlds w implicit by taking w = atom(e, e ' ).When O just contains eq, property (14) does hold; this \nis why there is no need for indexing by possible worlds in [23, 25]. However, it is not hard to see that \nthe presence of some observations on atoms, such as the function card in Figure 6, can cause (14) to \nfail. It is for this reason that we have built indexing by possible worlds into expression relations \n(De.nition 8).  5. Correctness of Representation Recall from Section 2 that the language we are considering \nis pa\u00adrameterised by a top-level declaration of some (possibly mutually recursive) data types: type d1 \n= C1,1 of t1,1 |\u00b7\u00b7\u00b7|C1,n1 of t1,n1 . . (15) . and dm = Cm,1 of tm,1 |\u00b7\u00b7\u00b7|Cm,nm of tm,nm . If we restrict \nattention to declarations in which the argument types ti,j of the constructors Ci,j are just .nite products \nof the declared data types d1 ...,dm, then the above declaration corresponds to a many-sorted algebraic \nsignature; furthermore, in this case the lan\u00adguage s values at each data type are just the abstract syntax \ntrees of terms of the corresponding sort in the signature. By allowing atoms and atom bindings in addition \nto products in the argument types ti,j , one arrives at the notion of nominal signature , intro\u00adduced \nin [29] and more fully developed in [19]. It extends the no\u00adtion of many-sorted algebraic signature with \nnames (of possibly many kinds) and information about name binding in constructors. Here, for simplicity, \nwe are restricting to a single kind of name, represented by the type atm of atoms; but our results extend \neasily to the case of many kinds of name. De.nition 13 (Nominal Signatures). The subset Arity .Typ is \ngiven by the grammar s .Arity ::= unit |s *s |d |atm |s bnd (16) where d ranges over the .nite set D \nof data type symbols. (In other words Arity consists of those types of our language that do not involve \nany use of the function type construction, ..) The elements of the set Arity are called nominal arities.3 \nA nominal signature (with a single sort of atoms, atm)isspeci.edbya data type declaration (15) in which \nthe argument types ti,j of the constructors Ci,j are all nominal arities. For each s .Arity, the closed \nvalues of that type, \u00d8fw v : s, correspond precisely to the ground terms (with arity s and atoms in w) \nover the nominal signature, as de.ned in [29]. For example, the declaration (1) corresponds to the nominal \nsignature for .\u00adcalculus; and closed values of type term correspond as in (2) to the abstract syntax \ntrees for .-terms (open or closed ones, with variables represented by atoms). For other examples of nominal \nsignatures, with more complicated patterns of binding, see [19, Section 2.2]. The occurrences of s bnd \nin a nominal signature (15) indicate arguments with bound atoms. In particular, we can associate with \neach such signature a notion of a-equivalence, =a, that identi.es values up to renaming bound atoms. \nThe inductive de.nition of =a is given in Figure 8. It generalises to an arbitrary nominal signature \n3 The notation ((atm))s is used in [29, 19] for what we here write as s bnd. f w () =a () : unit f w \nv1 = a v1 ' : s1 f w v2 = a v2 ' : s2 f w (v1 ,v2)=a (v1 ' ,v2' ): s1 * s2 C : s . d f w v = a v ' : \nsa . w f w C v =a C v ' : d f w a =a a : atm '' '' a ./w . atom(a,v,a ,v ) '' '''' f w.{all} v{ a /a} \n= a v { a /a } : s f w (( a)) v =a (( a ' )) v ' : s bnd Figure 8. a-Equivalence. the syntax-directed \ncharacterisation of a-equivalence of .-terms given in [9, p. 36]. The de.nition in Figure 8 is essentially \nthat given in [19], except that we have included an indexing by possible worlds w, to chime with our \nform of judgement for contextual equivalence; without that indexing, the condition a '' ./w . atom(a, \nv, a ' ,v ' ) in the rule for a-equivalence of values of atom '' '' binding type would be replaced by \na ./atom(a,v,a ,v ) . We can now state the main result of this paper. Recall from Def\u00ad initions 9 and \n11 that for closed expressions contextual equivalence is the same as the relation of operational equivalence \ngiven in Def\u00ad inition 7. Theorem 14 (Correctness of Representation). Suppose that all the observations \non atoms obs in O satisfy the equivariance prop\u00aderty (5). For each nominal signature, two closed values \nv, v ' of the same nominal arity s (with atoms contained in the .nite set w,say) are a-equivalent if \nand only if they are contextually equivalent: ' ~' f w v =a v : s .f w v = v : s. (17) The rest of this \nsection is devoted to the proof of this theo\u00adrem. Proving the left-to-right implication in (17) is not \ntoo hard, given the simple nature of a-equivalence as de.ned in Figure 8. The right-to-left implication \nis much harder: see the discussion af\u00adter Proposition 16. We get it as a corollary of a property of ~at \n= atom binding arities s bnd that mirrors the .fth rule in Figure 8. In fact we will prove this property \nof atom binding (the combination of Propositions 16 and 19) for all types t bnd, that is, not just for \nnominal arities but also for types t possibly involving the function type construct. We can only do so \nunder a restriction on observa\u00adtions on atoms over and above the equivariance property (5) that we always \nassume they possess. This is the af.neness property given in De.nition 17 below. The equality test eq \n(Figure 6) is af.ne and we will see that this fact is enough to prove Theorem 14 as stated, that is, \nwithout any restriction on the observations present other than equivariance. Proposition 15. (i) f w \n= () : unit. () ~ (ii) For all types t1,t2 . Typ, f w =(v1 ' ,v2' ): t1 * t2 (v1 ,v2) ~ ~'' ~ iff f \nw v1 = v1 : t1 and f w v2 = v2 : t2. ~ (iii) For each data type di in the declaration (15), f w Ci,j \nv = '' ~' Ci,jl v : di iff j = j and f w v = v : ti,j . ~'' (iv) f w a = a : atm iff a = a . w. Proof. \nPart (i) and the if directions of (ii) (iv) are consequences of the fact (Theorem 10) that ~. is a compatible \nequivalence. For = the only if directions of (ii) and (iii) we apply suitably chosen destructors. Thus \nfor part (ii) we use the operational equivalences f w fst(v1 ,v2) ~snd(v1 ,v2) ~ = v1 : t1 and f w = \nv2 : t2 that are consequences of the de.nitions of ~ = and the termination relation. Similarly, part \n(iii) follows from the easily established operational (in)equivalences f w diverge ~ = v : t f w proji,j \n(Ci,j v) ~ = v : ti,j f w proji,j = diverge : ti,j if j = j ' (Ci,jl v) ~ which make use of the following \nexpressions diverge fun(fx = fx)() proji,j v match v with (Ci,1x1 . dj,1 | \u00b7\u00b7\u00b7 | Ci,ni xni . dj,ni ) \n( xj if j = j ' , where dj,jl diverge if j = j ' . Finally, for the only if direction of part (iv) we \nmake use of the fact that O always contains the atom equality function eq from Figure 6. Consider the \nframe stack Sa Id . (x. let y = eq xa in match y with (Zero . () | Succ z . diverge)) . If a = a ' are \ndistinct elements of w, then choosing some a . State with atom(a )= w, it is not hard to see that (aa, \nSa,a). holds ~' whereas (aa, Sa,a ' ). does not hold. So if f w a = a : atm it cannot be the case that \na = a ' . This proposition tells us that ~ = has properties mirroring those of a-equivalence given by \nthe .rst four rules in Figure 8. To complete the proof of the correctness theorem, we need to prove a \nproperty of ~ = at atom binding arities s bnd that mirrors the .fth rule in that .gure. We split this \ninto two parts, Propositions 16 and 19. Proposition 16. For any type t . Typ, suppose we are given closed, \nwell-typed atom binding values \u00d8f w (( a)) v : t bnd and \u00d8fw (( a ' )) v ' : t bnd. If for some atom \na '' ./w we have '' '''' f w.{all} v{ a /a}~{ a } : t (18) = v /a then ~ f w (( a)) v = (( a ' )) v ' \n: t bnd . (19) Proof. Unlike the previous proposition, this result is not just a simple consequence of \nthe congruence properties of operational equivalence. We establish it via a property analogous to (8) \nin the proof of Theorem 10, once again using an induction over the rules de.ning termination. Let E be \nthe closure under compatible re.nement (Figure 7) of the pairs of closed atom binding values that we \nwish to show are operationally equivalent. In other words E is the expression relation inductively de.ned \nby the following two rules. '' '' a ./w . atom(a,v,a ,v ) '' '''' ' b f w.{all} v{ a = v { a /a } : t \nG f w e E e : t /a}~. '' ' \u00d8f w (( a)) v E(( a )) v : t bnd G f w e E e : t The analogue of property \n(8), with E replacing ~*, holds by in\u00ad = duction on the derivation of (aa, S, e). n from the rules in \nFig\u00adure 5; the details of the induction can be found in the full ver\u00adsion of this paper. If (18) holds, \nthen by de.nition of E we have \u00d8f w (( a)) v E(( a ' )) v ' : t bnd;and \u00d8f w S EbS : t . t ' always holds, \nby de.nition of the extension of E to a relation be\u00adtween frame stacks. So by the analogue of (8) for \nE we get (aa, S, (( a)) v). . (aa, S, (( a ' )) v ' ). for any a with atom(a ) . w and any suitably typed \nframe stack S. A symmetrical argument shows that the converse implication holds. Thus (18) implies that \n((a))v and ((a ' ))v ' are operationally equivalent, as required. Next we need to prove the converse \nof the above proposition, namely that (19) implies (18) for any a '' ./w. The dif.culty is that in verifying \n(18) we have to consider the termination behaviour of v{a '' /a} and v ' {a '' /a ' } in all states a \nwith atom(a ) . w.{a '' }. The atom a '' may occur at any position in a and not necessarily at its right-hand \nend; whereas in assuming (19), all we appear to know about the termination behaviour of v{a '' /a} and \nv ' {a '' /a ' } is what happens when a fresh atom a '' is placed at the end of the state via generative \nunbinding (cf. Remark 6). In fact we are able to combine bind and unbind operations to rearrange atoms \nsuf.ciently to prove the result we want, but only in the presence of observations on atoms that are insensitive \nto atoms being added at the left-hand (that is, least) end of the state. The following de.nition makes \nthis property of observations precise. It uses the notation a ' &#38;#169; a for the state obtained from \na . State by appending an atom a ' not in atom(a ) to the left of the .nite list of distinct atoms a \n(cf. a &#38;#169; a ' de.ned in Figure 4). De.nition 17 (Af.ne Observations). An observation on atoms, \nobs .O,is af.ne if it is equivariant (5) and satis.es: for all a . State,all a ' ./atom(a ) and all (a1,...,ak) \n. atom(a )k (where kis the arity of obs) [obs]al.a (a1,...,ak)= [obs]a (a1,...,ak) . (20) For example, \nof the observations de.ned in Figure 6, eq and lt are af.ne, whereas ord and card are not. The following \nproperty of termination follows from its de.ni\u00adtion in Figures 4 and 5, using Corollary 5. Lemma 18. \nGiven a frame stack S and an expression e, suppose that only af.ne observations on atoms occur in them. \nThen for all a with atom(S,e) . atom(a ) and all a ' ./atom(a ), (a &#38;#169; aa,S,e).n .(aa,S,e).n. \nProposition 19. Suppose that O only contains af.ne observations. Then for any type t, (19) implies that \n(18) holds for any a '' ./w. Proof. Suppose (19) holds and that a '' ./w.Wehavetoshowfor ' '' any w . \nWorld, a . State and t . Typ with atom(a )= w . w.{a '' } and \u00d8fwl S : t . t ' that '' '''' (aa,S,v{a \n/a}). . (aa,S,v {a /a }). . (21) Since a '' . atom(a ),wehave a = a ' &#38;#169; a '' &#38;#169; a0 &#38;#169; \n\u00b7\u00b7\u00b7 &#38;#169; an-1 (22) for some state a ' and atoms a0,...,an-1 (n= 0). Choose distinct atoms b0,...,bn-1 \nnot occurring in w ' and consider the frame stack S ' given by Id . (z.unbind zas (x,y0) in unbind ((b0))y0 \nas (x0 ,y1) in . . (23) . unbind ((bn-1))yn-1 as (xn-1 ,yn) in S{x,x0,...,xn-1/a '' ,a0 ...,an-1}[yn]) \nwhere z,x,x0,...,xn-1,y0,...,yn are distinct variables not oc\u00adcurring in S. Here we have used the notation \nunbind vas (x1 ,x2) in e let y= unbind v in let x1 = fst y in let x2 = snd y in e (where y does not occur \nin (v,x1,x2,e)); (23) also uses the nota\u00adtion S[e] from (12); and it uses the operation (-){x/a} of re\u00adplacing \nan atom aby a variable x. Using Corollary 5 and property (11), a somewhat intricate calculation of transitions \n(given in more detail in the full version of this paper) yields '' '' (ab,S ,p\u00b7 ((a))v). . (ab,S,v{a \n/a}). (24) '' '' '''' and (ab,S ,p\u00b7 ((a ))v ). . (ab,S,v {a /a }). (25) a where ab b0 &#38;#169; \u00b7\u00b7\u00b7 \n&#38;#169; bn-1 &#38;#169; a , b ' b0 &#38;#169; \u00b7\u00b7\u00b7 &#38;#169; bn-1 &#38;#169; a ' and p . P is the \npermutation swapping each ai with bi (for i=0..n-1). We noted in Theorem 10 that operational equivalence \n~ is equivariant. So from (19) we have f p \u00b7 ((a))v = atom(abl) p \u00b7 ((a ' ))v ' : tbnd.Since \u00d8fS ' : \nt bnd . t ' ,this atom(abl) operational equivalence gives '' '''' (ab,S ,p\u00b7 ((a))v). . (ab,S ,p\u00b7 ((a \n))v ). . Combining this with (24) and (25) yields '' '''' (ab,S,v{a /a}). . (ab,S,v {a /a }). . (26) \nRecall that ab = b0 &#38;#169; \u00b7\u00b7\u00b7 &#38;#169; bn-1 &#38;#169; a and b0,...,bn-1 ./w ' = atom(a ) . atom(S,a \n'' ,v,v ' ).Sosince O only contains af.ne observations, we can now apply Lemma 18 to (26) to get (21), \nas required. Example 20. We conjecture that Proposition 19 fails to hold if we drop the requirement that \nobservations are af.ne (but still require them to be equivariant). For example consider the equivariant \nbut non-af.ne observation ord in Figure 6 and the values v fun(fx= fx) v ' fun(fx= let y= ord ain match \nywith (Zero . () | Succ y ' . v())) where ais some atom. We claim that ~ f{a} ((a))v = ((a))v ' :(unit \n. unit)bnd (27) but that for any a ' = a ' '' f{a,al} v{a = v /a}~{a /a} : unit . unit . (28) The operational \ninequivalence (28) is witnessed by the state a [a ' ,a] and the frame stack S Id . (x.xunit), for which \none has (aa,S,v ' {a ' /a})., but not (aa,S,v{a ' /a}).. At the moment we lack a formal proof of the \noperational equivalence (27), but the intuitive justi.cation for it is as follows. For any state a containing \na and any frame stack S, we claim that in any sequence of transi\u00adtions from (aa,S,((a))v ' ) the occurrence \nof ord ain v ' can only be renamed to ord a ' for atoms a ' at positions strictly greater than 0 in the \ncurrent state; and hence (aa,S,((a))v ' ) has the same termination properties as (aa,S,((a))v). Proof \nof Theorem 14. One proves that fw v =a v ' : s implies ~ fw v = v ' : s by induction on the the rules \nde.ning a\u00adequivalence in Figure 8, using Propositions 15 and 16. To prove the converse implication, .rst \nnote that if \u00d8f v : s, then v contains no instances of observations obs .O (proof by induction on the \nstructure of the nominal arity s).4 It follows from the de.nition of operational equivalence in De.nition \n7 that if ~' fw v = v : s holds for a language with observation set O,it also holds for the sub-language \nwith minimal observation set {eq}. ~' Thus it suf.ces to prove the implication fw v = v : s .fw v = a \nv ' : s for this minimal sub-language; and this can be done by induction on the structure of susing Propositions \n15 and 19 (the latter applies because eq is af.ne). 4 The only way observations on atoms can appear in \nvalues of the language is via function values, fun(fx= e), and the de.nition of nominal arity excludes \nfunction types.  6. Related and Further Work 6.1 Correctness of Representation It is instructive to \ncompare the Correctness of Representation prop\u00aderty of FreshML (Theorem 14) with adequacy results for \ntype\u00adtheoretic logical frameworks [15]. Both are concerned with the representation of expressions of \nsome object-language in a meta\u00adlanguage. For logical frameworks the main issue is surjectivity: one wants \nevery expression at the meta-level to be convertible to a normal form and for every normal form at certain \ntypes to be the representation of some object-level expression. The fact that a\u00adequivalence of object-level \nexpressions is preserved and re.ected by the representation is a simple matter, because equivalence in \nthe logical framework is taken to be a\u00df.-conversion, which spe\u00adcialises on normal forms to just a-equivalence. \nContrast this with the situation for FreshML where surjectivity of the representation is straightforward, \nbecause values of the relevant FreshML data types are just .rst order abstract syntax trees; whereas \nthe fact that a\u00adequivalence of object-level expressions is preserved and re.ected by the representation \nin FreshML is a non-trivial property. This is because we take equivalence of FreshML expressions to be \ncontex\u00adtual equivalence. This is the natural notion of equivalence from a programming point of view, \nbut its properties are hard won. One aspect of adequacy results for logical frameworks high\u00adlighted in \n[15] is compositionality of representations. Although im\u00adportant, this issue is somewhat orthogonal to \nour concerns here. It refers to the question of whether substitution of expressions for variables at \nthe object-level is represented by \u00df-conversion at the meta-level. From the point of view of nominal \nsignatures [19], variables are just one kind of name. Properties of a-conversion of all kinds of names \nare treated by the theory; but if one wants notions of substitution and \u00df-conversion for a particular \nkind of name, one has to give a de.nition (an a-structural recursive def\u00adinition [19]). For example in \nFreshML, using the data type (1) for .-terms one can give an appealingly simple declaration for a func\u00adtion \nsubst : term .atm .term .term for capture avoiding substitution; see [26, p. 264]. Compositionality of \nthe representa\u00adtion t .'t' given in the introduction then becomes the contextual . ' ~ equivalence fw \n't1[t2/a]=subst 't2 ' a 't1 ' :term.The CIU theorem (Theorem 10) provides the basis for proving such \ncontex\u00adtual equivalences.5 6.2 Concrete Semantics We have explored some of the consequences of adding \ninteger\u00advalued observations on atoms to FreshML over and above the usual test for equality. Such functions \nmay allow more ef.cient data structures to be used for algorithms involving atoms as keys. For example, \nbinary search trees making use of the comparison function lt from Figure 6 could be used instead of association \nlists. What about adding functions from numbers to atoms? An im\u00adplementation of the language may well \nrepresent atoms by num\u00adbers, via some .xed enumeration of the set of atoms, a : N ~A. = Can we give the \nprogrammer access to this bijection? Less radi\u00adcally, can we allow operations on atoms that make use \nof arith\u00admetic properties of the underlying representation? Not without breaking the invariant atom(S, \ne) .atom(a ) of con.gurations (aa, S, e) the property of our operational semantics that ensures that \nan atom s freshness with respect to the current state really does mean that it is different from all \nother atoms in the current con\u00adtext. For example, suppose we add to the language an operation suc :atm.atm \nwhose meaning is successor function on atoms , with transitions (aa, S, suc a)-.(aa, S, a ' )whenever \na = a(n) 5 We believe this particular equivalence is valid when O = {eq, lt}, but not when O = {eq, card}; \ncf. Section 7. and a ' =a(n +1)for some n .N. Then it may well be the case that a ' ./atom(a )even though \na .atom(a ). So exposing the numerical representation of atoms involves giv\u00ading up the invariant properties \nof the abstract semantics we have used here. One motivation for studying this extension of the lan\u00adguage \nis the fact that some algorithms make use of concrete numer\u00adical representations of keys, for example \nones using hash tables or Patricia trees [14]. It may still be the case that the Correctness of Representation \nproperty holds for this extension, even though our equivariant proof techniques are no longer applicable. \nHowever, contextual equivalence for this language probably satis.es few use\u00adful laws. Perhaps a more \ninteresting alternative to actually exposing numerical representations of atoms would be to prove contextual \nequivalence of ef.cient and naive implementations of the abstract semantics extended with types of .nite \nmaps on atoms. Such ab\u00adstract types form an addition to the signature in Figure 1 different from the \nkind we have considered here, but certainly one worthy of investigation. 6.3 Mechanising Meta-Theory \nThe techniques we used here to prove the Correctness of Repre\u00adsentation property are operationally based, \nin contrast to the de\u00adnotational techniques used in [23, 25]. The advantage of working directly with \nthe syntax and operational semantics of the language is that there are lower mathematical overheads various \nkinds of induction being the main techniques involved. The disadvantage is that to deploy such inductive \ntechniques often involves great in\u00adgenuity choosing inductive hypotheses and much error prone te\u00addium \nchecking induction steps. Furthermore, with these methods it seems harder to predict the effect that \na slight change in lan\u00adguage or formalisation may have on a proof. Although ingenuity in choosing inductive \nhypotheses may always be the preserve of hu\u00admans, machine assistance of the kind envisaged by the POPLmark \nchallenge [1] seems a very good idea for the other aspects of the operationally based approach. The main \nresults presented here are still a challenging target for fully formalised and machine checked proofs. \nWe have taken some care with the formalisation (using a relational approach to contextual equivalence, \nfor example); but results concerning coinductive equivalences, like the CIU the\u00adorem (Theorem 10), are \nquite complex logically speaking, com\u00adpared with the kind of type safety results (like Theorem 2) that \nPOPLMark has focused on so far. Systems like Isabelle/HOL [13] that develop proofs in full classical \nhigher order logic seem appro\u00adpriate to the task, in principle. But there is a gap between what is possible \nin principle for an expert of any particular system and what is currently practicable for a casual user. \nUrban and Berghofer [27] are developing a Nominal Data Type Package for Isabelle/HOL that may be very \nuseful for narrowing this gap. The fact that FreshML and the Urban-Berghofer package both have to do \nwith the same mathematical universe of nominal sets [19] is perhaps slightly confusing: their Nominal \nData Type Package is useful for fully for\u00admalising proofs about names and name-binding in operational \nse\u00admantics whether or not those proofs have to do with the particular mechanism of generative unbinding \nthat is the focus of this paper.  7. Conclusion The FreshML [26, 24] approach to functional programming \nwith binders combines abstract types for names and name binding with an unbinding operation that involves \ngeneration of fresh names. In this paper we have studied the theoretical properties of this de\u00adsign. \nWe showed that the addition of integer valued observations on names does not break FreshML s fundamental \nCorrectness of Rep\u00adresentation property that a-equivalence classes of abstract syntax trees (for any \nnominal signature) coincide with contextual equiva\u00adlence classes of user declared data values. In particular, \nit is pos\u00adsible to give programmers access to a linear order on names with\u00adout breaking the up to a-equivalence \nrepresentation of syntax. The simple insight behind this possibly surprising result has to do with the \nfact that FreshML is impure program execution mutates the state of dynamically created names.6 If the \nstate is taken into account when giving the meaning of observations on names, then the permutation invariance \nproperties that underly the correctness property can be retained. The only restriction we placed on observations \nis that, as func\u00adtions of both the state and the names they operate upon, they should be invariant under \npermuting names. The Correctness of Repre\u00adsentation property (Theorem 14) remains valid in the presence \nof any such observation. However, some observations are better be\u00adhaved than others and we are not advocating \nthat arbitrary equivari\u00adant observations be added to FreshML. Some forms of observation may radically \naffect the general programming laws that contextual equivalence satis.es. We saw one example of this \nhere: only for af.ne observations (which are insensitive to how many names have been created before the \narguments to which they are applied) were we able to combine Propositions 16 and 19 to get an exten\u00adsionality \nresult explaining contextual equivalence at type t bnd in terms of contextual equivalence at t, for arbitrary \nhigher types t . The techniques we used to establish these results are of inde\u00adpendent interest. They \ncombine the usual engine of structural oper\u00adational semantics namely syntax-directed, rule based induction \nwith the approach to freshness of names based on name permuta\u00adtions that was introduced in [6] and developed \nin [17, 28, 19].  References [1] B. E. Aydemir, A. Bohannon, M. Fairbairn, J. N. Foster, B. C. Pierce, \nP. Sewell, D. Vytiniotis, G. Washburn, S. Weirich, and S. Zdancewic. Mechanised metatheory for the masses: \nThe POPLmark challenge. In 18th International Conference on Theorem Proving in Higher Order Logics: TPHOLs \n2005, volume 3603 of Lecture Notes in Computer Science, pages 50 65. Springer-Verlag, 2005. [2] P. N. \nBenton and X. Leroy, editors. ACM SIGPLAN Workshop on ML (ML 2005), Tallinn, Estonia, Electronic Notes \nin Theoretical Computer Science. Elsevier, 2005. [3] J. Cheney. Scrap your nameplate (functional pearl). \nIn 10th ACM SIGPLAN Int. Conference on Functional Programming (ICFP 05), Tallinn, Estonia, pages 180 \n191. ACM Press, 2005. [4] M. Felleisen and R. Hieb. The revised report on the syntactic theories of sequential \ncontrol and state. Theoretical Computer Science, 103:235 271, 1992. [5] C. Flanagan, A. Sabry, B. F. \nDuba, and M. Felleisen. The essence of compiling with continuations. In Proceedings ACM SIGPLAN Conference \non Programming Language Design and Implementation, PLDI 93, Albuquerque, NM, USA, pages 237 247. ACM \nPress, June 1993. [6] M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. \nFormal Aspects of Computing, 13:341 363, 2001. [7] A. D. Gordon. Operational equivalences for untyped \nand polymorphic object calculi. In Gordon and Pitts [8], pages 9 54. [8] A. D. Gordon and A. M. Pitts, \neditors. Higher Order Operational Techniques in Semantics. Publications of the Newton Institute. Cambridge \nUniversity Press, 1998. 6 The original version of FreshML [20] was pure by dint of the freshness inference \nincluded in its type system. Subsequent experience with the lan\u00adguage showed that the form of freshness \ninference that was used there was overly restrictive from a programming point of view. So freshness inference \nwas dropped in [26]. However, Pottier [22] has recently regained purity in a FreshML-like language through \nthe use of user-provided assertions. We have not investigated whether results like those presented in \nthis paper also apply to Pottier s language. [9] C.A.Gunter. Semantics of Programming Languages: Structures \nand Techniques. Foundations of Computing. MIT Press, 1992. [10] D. J. Howe. Proving congruence of bisimulation \nin functional programming languages. Information and Computation, 124(2):103 112, 1996. [11] S. B. Lassen. \nRelational reasoning about contexts. In Gordon and Pitts [8], pages 91 135. [12] I. A. Mason and C. L. \nTalcott. Equivalence in functional languages with effects. Journal of Functional Programming, 1:287 327, \n1991. [13] T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL A Proof Assistant for Higher-Order Logic, \nvolume 2283 of Lecture Notes in Computer Science. Springer-Verlag, 2002. [14] C. Okasaki and A. Gill. \nFast mergeable integer maps. In ACM-SIGPLAN Workshop on ML, Baltimore, Maryland, USA, pages 77 86. ACM \nPress, 1998. [15] F. Pfenning. Logical frameworks. In A. Robinson and A. Voronkov, editors, Handbook \nof Automated Reasoning, chapter 17, pages 1063 1147. Elsevier Science and MIT Press, 2001. [16] A. M. \nPitts. Operational semantics and program equivalence. In Applied Semantics, Advanced Lectures, volume \n2395 of Lecture Notes in Computer Science, Tutorial, pages 378 412. Springer-Verlag, 2002. International \nSummer School, APPSEM 2000, Caminha, Portugal, 2000. [17] A. M. Pitts. Nominal logic, a .rst order theory \nof names and binding. Information and Computation, 186:165 193, 2003. [18] A. M. Pitts. Typed operational \nreasoning. In B. C. Pierce, editor, Advanced Topics in Types and Programming Languages, chapter 7, pages \n245 289. The MIT Press, 2005. [19] A. M. Pitts. Alpha-structural recursion and induction. Journal of \nthe ACM, 53(3):459 506, 2006. [20] A. M. Pitts and M. J. Gabbay. A metalanguage for programming with \nbound names modulo renaming. In 5th Int. Conference on Mathematics of Program Construction (MPC2000), \nPonte de Lima, Portugal, volume 1837 of Lecture Notes in Computer Science, pages 230 255. Springer-Verlag, \n2000. [21] F. Pottier. An overview of Caml. In Benton and Leroy [2], pages 27 52. [22] F. Pottier. Static \nname control for FreshML. Draft, July 2006. [23] M. R. Shinwell. The Fresh Approach: Functional Programming \nwith Names and Binders. PhD thesis, University of Cambridge Computer Laboratory, 2005. Available as University \nof Cambridge Computer Laboratory Technical Report UCAM-CL-TR-618. [24] M. R. Shinwell. Fresh O Caml: \nNominal abstract syntax for the masses. In Benton and Leroy [2], pages 53 76. [25] M. R. Shinwell and \nA. M. Pitts. On a monadic semantics for freshness. Theoretical Computer Science, 342:28 55, 2005. [26] \nM. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Programming with binders made simple. In 8th \nACM SIGPLAN Int. Conference on Functional Programming (ICFP 2003), Uppsala, Sweden, pages 263 274. ACM \nPress, 2003. [27] C. Urban and S. Berghofer. A recursion combinator for nominal datatypes implemented \nin Isabelle/HOL. In 3rd International Joint Conference on Automated Reasoning (IJCAR 2006), Seattle, \nUSA, volume 4130 of Lecture Notes in Computer Science, pages 498 512. Springer-Verlag, 2006. [28] C. \nUrban and M. Norrish. A formal treatment of the Barendregt Variable Convention in rule inductions. In \n3rd ACM SIGPLAN Workshop on Mechanized Reasoning about Languages with Variable Binding (MERLIN 05), Tallinn, \nEstonia, pages 25 32. ACM Press, 2005. [29] C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal uni.cation. \nTheoretical Computer Science, 323:473 497, 2004. \n\t\t\t", "proc_id": "1190216", "abstract": "This paper is concerned with a programming language construct for typed name binding that enforces &#945;equivalence. It proves a new result about what operations on names can co-exist with this construct. The particular form of typed name binding studied is that used by the FreshML family of languages. Its characteristic feature is that a name binding is represented by an abstract (name,value)-pair that may only be deconstructed via the generation of fresh bound names. In FreshML the only observation one can make of names is to test whether or not they are equal. This restricted amount of observation was thought necessary to ensure that there is no observable difference between &#945;equivalent name binders. Yet from an algorithmic point of view it would be desirable to allow other operations and relations on names, such as a total ordering. This paper shows that, contrary to expectations, one may add not just ordering, but almost any relation or numerical function on names without disturbing the fundamental correctness result about this form of typed name binding (that object-level &#945;equivalence precisely corresponds to contextual equivalence at the programming meta-level), so long as one takes the state of dynamically created names into account.", "authors": [{"name": "Andrew M. Pitts", "author_profile_id": "81100104445", "affiliation": "University of Cambridge Computer Laboratory", "person_id": "P18268", "email_address": "", "orcid_id": ""}, {"name": "Mark R. Shinwell", "author_profile_id": "81100441095", "affiliation": "CodeSourcery, Ltd", "person_id": "PP24037377", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190232", "year": "2007", "article_id": "1190232", "conference": "POPL", "title": "Generative unbinding of names", "url": "http://dl.acm.org/citation.cfm?id=1190232"}