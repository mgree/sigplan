{"article_publication_date": "01-17-2007", "fulltext": "\n A Complete, Co-Inductive Syntactic Theory of Sequential Control and State Kristian St\u00f8vring Soren B. \nLassen BRICS, Dept. of Comp. Science, University of Aarhus Google, Inc. kss@brics.dk soren@google.com \n Abstract We present a new co-inductive syntactic theory, eager normal form bisimilarity, for the untyped \ncall-by-value lambda calculus extended with continuations and mutable references. We demonstrate that \nthe associated bisimulation proof principle is easy to use and that it is a powerful tool for proving \nequivalences between recursive imperative higher-order programs. The theory is modular in the sense that \neager normal form bisimilarity for each of the calculi extended with continuations and/or mutable references \nis a fully abstract extension of eager normal form bisimilarity for its sub-calculi. For each calculus, \nwe prove that eager normal form bisimilarity is a congruence and is sound with respect to contextual \nequivalence. Furthermore, for the calculus with both continuations and mutable references, we show that \neager normal form bisimilarity is complete: it coincides with contextual equivalence. Categories and \nSubject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Control structures; \nF.3.2 [Logics and Meanings of Programs]: Semantics of Program\u00adming Languages Operational semantics; F.4.1 \n[Mathematical Logic and Formal Languages]: Mathematical Logic Lambda cal\u00adculus and related systems General \nTerms Languages, Theory Keywords Bisimulation, Continuations, Mutable References 1. Introduction Program \nequivalence is a fundamental concept in programming language semantics, and new and better frameworks \nand techniques for reasoning about program equivalence are continually being developed. Nonetheless, \nthere are still no general and easy to use methods that capture the features and subtleties of actual \nprograms in languages that combine general recursion, higher-order functions and objects, mutable state, \nand non-local control .ow. Denotational semantics and domain theory cover many pro\u00adgramming language \nfeatures but straightforward models fail to cap\u00adture certain important aspects of program equivalence, \nespecially concerning mutable state. The solutions to these full abstraction problems, including game \nsemantics, are complex. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c . 2007 ACM 1-59593-575-4/07/0001. \n. . $5.00. Syntactic reduction calculi and equational theories are easy to use but they exclude many \nimportant program equivalences. The broadest notion of program equivalence is Morris-style contextual \nequivalence which equates two terms if they behave the same in all program contexts. The quanti.cation \nover all program contexts makes it impractical to use the de.nition directly to prove programs contextually \nequivalent. Syntactic methods based on operational semantics context lemmas, applicative bisimulation, \nand operationally-based logi\u00adcal relations generally incur modest mathematical overhead and are easy \nto use for certain classes of program equivalences. For instance, applicative bisimulation is very useful \nfor proving the equivalence of programs that output in.nite data structures. However, all these proof \nprinciples are weak for program equiva\u00adlences involving general higher-order functions because, somewhat \nlike the de.nition of contextual equivalence, they involve univer\u00adsal quanti.cations over all continuations, \nstores, and/or function arguments. For example, .xed-point combinators are higher-order func\u00adtions that \nmake essential use of higher-order arguments. What does it take to prove the equivalence of two different \n.xed-point combi\u00adnators? A proof obligation that involves a universal quanti.cation over all possible \narguments to the .xed-point combinators is about as dif.cult as proving that the .xed-point combinators \nare contex\u00adtually equivalent from .rst principles. This example is easily solved using a different class \nof syntactic theories which originate from the theories of B\u00a8ohm tree equiva\u00adlence and L\u00b4evy Longo tree \nequivalence. They can be presented as bisimulation theories, called normal form bisimulation (originally \nintroduced by Sangiorgi under the name open applicative bisim\u00adulation ), without explicit reference to \ntrees. Normal form bisim\u00adulation is based on symbolic evaluation of open terms to normal forms. It does \nnot involve any universal quanti.cation over func\u00adtion arguments and is therefore, in some respects, \na more powerful proof principle for proving equivalences between recursive higher\u00adorder functions than \nother operationally-based syntactic methods. However, normal form bisimulation has only been developed \nfor state-less .-calculi and is, in general, not fully abstract. In this article we address these shortcomings \nby extending eager normal form bisimulation, a variant of normal form bisimulation for the call-by-value \n.-calculus. We present new syntactic bisim\u00adulation theories for the untyped call-by-value .-calculus \nextended with continuations and mutable references. 1. The theories all extend eager normal form (enf) \nbisimulation for the pure call-by-value .-calculus [19]. 2. The extension with continuations, namely \nan untyped call-by\u00advalue version of Parigot s .\u00b5-calculus [26], is based on the sec\u00adond author s normal \nform bisimulation theory for the untyped .\u00b5-calculus [21].  3. The extension with mutable references, \nwhich we call the ..\u00adcalculus (essentially Felleisen and Hieb s .-calculus with state [8]; their .-application \nis a primitive in our calculus hence we name it .. ), is based on bisimulations as sets of relations. \nThis idea of relation-sets bisimulation is adapted from bisim\u00adulation theories for imperative calculi \n[13, 16] and existential types [32]. 4. Finally, we extend the theories to a combined .\u00b5.-calculus. \n The resulting bisimulation proof principle for proving semanti\u00adcal equivalences between terms inherits \nthe best properties of nor\u00admal form bisimulation and relation-sets bisimulation, namely like other kinds \nof normal form bisimulation, the enf bisimula\u00adtion proof obligations for continuations and mutable references \nrequire no universal quanti.cations over function arguments or continuations or stores, and  the relation-set \nstructure represents the possible worlds nec\u00adessary to capture the behaviour of mutable references. \n We demonstrate the power and ease of use of the resulting enf bisimulation proof principle for continuations \nand mutable refer\u00adences by proving the correctness of Friedman and Haynes s encod\u00ading of call/cc in terms \nof one-shot continuations [9]. Despite the subtlety of their encoding and the mix of higher-order functions, \n.rst-class continuations, and mutable references, the bisimulation proof is remarkably straightforward, \nas we hope the reader will ap\u00adpreciate. The enf bisimulation theories for the pure .-calculus and the \nex\u00adtensions with continuations and/or mutable references are modular: enf bisimilarity for each of the \nextended calculi is a fully abstract extension of enf bisimilarity for its sub-calculi. This is similar \nto the relationship between Felleisen and Hieb s syntactic theories for control and state [8] but contrasts \nthe situation for contextual equiv\u00adalence because each language extension makes contextual equiva\u00adlence \nmore discriminative on terms of the sub-calculi. One of the main technical contributions of the work \nbehind this article is a proof that enf bisimilarity for the calculus extended with continuations and/or \nmutable references is a congruence. As an im\u00admediate consequence of congruence, enf bisimilarity is included \nin contextual equivalence for each calculus. For the pure .-calculus as well as the two extensions with \nonly continuations and only muta\u00adble references, enf bisimilarity is strictly smaller than contextual \nequivalence, that is, enf bisimulation is a sound but incomplete method for proving contextual equivalence. \nHowever, for the full calculus with both continuations and mutable references, we prove that enf bisimilarity \nis fully abstract in the sense that it coincides with contextual equivalence. In summary, we present \na complete, co-inductive syntactic the\u00adory for a calculus with higher-order functions, continuations, \nand mutable references, and we demonstrate the power and ease-of-use of the bisimulation proof method \nfor proving equivalences between recursive programs. Our results provide further illustration of the \npromise of normal form bisimulation as a basis for syntactic theories and proof prin\u00adciples, demonstrated \nby earlier results for other pure and extended .-calculi in the literature (Sangiorgi [31] and Lassen \n[18, 20, 21]). However, we note one caveat: Although our theory for the com\u00adbined .\u00b5.-calculus captures \nkey functional and imperative aspects of the programming language Scheme, it lacks constants such as \nnil, cons, numerals, and arithmetic operators. These constants need to be encoded in our calculus, e.g., \nusing standard .-calculus en\u00adcodings [4], but such encodings are in general not faithful to the constants \nequational properties. For instance, addition of values should be commutative, up to contextual equivalence \nthat is, the representations of the Scheme terms (lambda (xy)(+ xy)) and (lambda (xy)(+ yx)) in the .\u00b5.-calculus \nshould be equivalent but this fails for encodings of arithmetic in the .\u00b5.\u00adcalculus, hence the resulting \nproof principles are only sound, not complete. There does not seem to be a satisfactory direct de.ni\u00adtion \nof normal form bisimulation (or B\u00a8ohm-tree equivalence) for untyped calculi with constants. In future \njoint work with Paul Blain Levy we plan, instead, to address this shortcoming in extensions of normal \nform bisimulation to typed calculi with recursive types. This work is related to recent game models by \nLevy [22]. 1.1 Related work There exists a large body of work on syntactic theories and seman\u00adtic models \n(domains and games) for .-calculi with continuations and mutable references. We only survey a few works \non syntactic theories most closely related to the results in this article. As mentioned in the introduction, \nour results build directly on recent work on normal form bisimulation for call-by-value [19] and the \n.\u00b5-calculus [21] and on relation-sets bisimulation for existen\u00adtial types [32] and untyped imperative \n.-calculus [13, 16]. One particular inspiration for the work presented in this article is the seminal \nresearch by Felleisen et al. on syntactic theories for sequential control and state [8]. The calculi \nin op.cit. are enriched with constants and d-reduction but otherwise the state calculus is essentially \nwhat we call the ..-calculus in this article. The control calculus differs from the .\u00b5-calculus but they \nare comparable. (Their relationship is analyzed by de Groote [12] and by Ariola and Herbelin [3]. We \nfound that it was easiest to de.ne eager reduction on open terms, enfs, and enf bisimilarity for the \n.\u00b5-calculus.) The syntactic theories of successive .-calculus extensions by Felleisen et al. [8] are \nmodular (conservative extensions), like our syntactic theories. An important difference is that the syntactic \ntheories in op.cit. are inductive in the sense that all equations are derived inductively from equational \naxioms and inference rules, whereas our bisimulation theories are co-inductive and therefore equate many \nmore programs. Another body of related work is Mason and Talcott s CIU ( closed instantiations of uses \n) characterizations of contextual equivalence for functional languages with mutable references and continuations \n[23, 33]. (The context lemmas for the .\u00b5-calculus by Bierman [5] and by David and Py [6] are essentially \nCIU character\u00adizations.) The CIU equivalences are complete syntactic theories but the resulting proof \nmethods are in many cases weaker than normal form bisimulation. Most co-inductive syntactic programming \nlanguage theories in the literature are variants and extensions of Abramsky s applica\u00adtive bisimulation \n[1]. However, there are no fully abstract applica\u00adtive bisimulation theories for general .-calculi with \ncontinuations and/or mutable references. Ritter and Pitts [30] de.ne a form of applicative bisimilarity \nfor a functional language with mutable references. It is sound but not complete. In fact, it does not \nequate many of the well-known, subtle contextual equivalences between programs with state [25]. Wand \nand Sullivan [34] de.ne a CPS language with mutable references and show that applicative bisimilarity \nis both sound and complete. They use the CPS language as a semantic meta-language and CPS translate a \nsource language with state into the CPS lan\u00adguage. But they do not give an independent characterization \nof the induced syntactic theory on source terms via the CPS transform. Koutavas and Wand s relation-sets \nbisimulation theory [13] is complete for a general direct-style imperative calculus. How\u00adever, it involves \na universal quanti.cation over closed function ar\u00adguments, unlike our normal form bisimulation theories. \nMerro and Biasi [24] present a complete bisimulation theory for a CPS calculus. It can be viewed as a \nkind of applicative bisimulation, presented as a labelled transition system in the style of Gordon [10], \nand also leads to a context lemma. Pitts and Stark [28, 29] develop syntactic theories based on operationally-based \nlogical relations that address many of the sub\u00adtleties of contextual equivalences between programs with \nmuta\u00adble references. The relation-sets bisimulation theories for mutable state, in general, are alternative \napproaches with a very different meta-theory. For logical relations the key proof obligation is exis\u00adtence, \nwhereas the key proof obligation for the bisimulation theo\u00adries is congruence. Finally, we note that \nthe modularity of the enf bisimilarity theories for control and state resembles the modularity of game \nsemantics for control and state [2, 14].  2. Eager normal form bisimulation Let us brie.y reintroduce \nthe de.nition of enf bisimulation for the pure call-by-value .-calculus [19]. Consider a variant of the \ncall-by-value .-calculus in which computations must be explicitly sequenced by means of a let-construct: \nVARIABLES x, y, z VALUES v ::= x |.x. t TERMS t ::= v |let x=t1 in t2 |v1 v2 We identify terms up to \nrenaming of bound variables. Reduction is de.ned by means of evaluation contexts: EVALUATION CONTEXTS \nE ::= [] |E[let x=[ ] in t] EAGER NORMAL FORMS (ENFS) e ::= v |E[xv] (R1) E[let x=v in t] .E[t[v/x]] \n(R2) E[(.x. t) v] .E[t[v/x]] The re.exive-transitive closure of the reduction relation .is writ\u00adten*. \nFor every term t, there are two possibilities: either t di\u00ad .verges in the sense that there is an in.nite \nreduction sequence start\u00ading from t,or else t converges in the sense that t* e for some .(unique) eager \nnormal form e. The notation t. means that t di\u00ad .verges. Eager normal forms are truly normal forms with \nrespect to reduction: they do not reduce to anything. For a syntactic phrase f,let FV(f) denote the set \nof free vari\u00adables of f (the formal de.nitions are omitted). De.nition 1. A binary relation S on terms \nis an enf bisimulation if S .B(S),where B(S)= {(t, t') |either t.. and t'.. , or t* e and t'.* e' where \n(e, e') .M(S)} . M(S)= {(v, v') |(v, v') .V (S)} .{(E[xv],E'[xv']) |(E, E') .K(S)&#38; (v, v') .V (S)}V \n(S)= {(x, x)}.{(v, v') |.y/.FV(v) .FV(v'). (v*y,v' *y) .S} K(S)= {([ ], [])}.{(E, E') |.y/.FV(E) .FV(E'). \n(E*y,E' *y) .S} with x*y = xy, (.y. t) *x = t[x/y], [] *y = y,and E[let y=[ ] in t] *x = E[t[x/y]]. The \nintuition behind enf bisimulation is that two related open terms either (1) both diverge, or (2) reduce \nto matching eager normal forms whose components are again related. As an example, de.ne the Curry call-by-value \n.xed-point combinator Yv: .[f]= .g. f (.x. let z=gg in zx) Yv = .f. .[f].[f] and the Turing call-by-value \n.xed-point combinator Tv: .= .g..f.f (.x. let z1=gg in let z2=z1 f in z2 x) Tv =... These two .xed-point \ncombinators are enf bisimilar, i.e., there exists an enf bisimulation S such that (Yv, Tv) .S [19]. We \ninvite the reader to try to prove this equivalence by constructing such an S: one starts with the singleton \n{(Yv , Tv)}and then iteratively adds pairs in order to satisfy the de.nition of an enf bisimulation above. \n(In Section 5, a similar, but more complicated, equivalence between Yv and a store-based .xed-point combinator \nis shown.) Remark. The following construction, derived from the Turing call\u00adby-value .xed-point combinator, \nis convenient for de.ning func\u00adtions by recursion: For all values v, v1,and v2,de.ne D[v1,v2]= let z1=Tv \nin let z2=z1 v1 in z2 v2 .x[v]= .x.D[v, x] Then .x[v] x* let z=v .x[v] in zx. . Contextual equivalence \nis de.ned in the standard way. Infor\u00admally, two terms t and t' are contextually equivalent if for every \nmany-holed term context C[] such that C[t] and C[t'] are closed terms, C[t] converges if and only if \nC[t'] converges. ' Theorem 2 ([19]). If (t, t) .S for some enf bisimulation S,then t and t' are contextually \nequivalent. Remark. The de.nition of an enf bisimulation is slightly different from the one in the original \npresentation [19]. In particular, the vari\u00adant de.ned here is equivalent to what is called an enf bisimulation \nup to . in the original presentation. In the sequel we omit the enf quali.er for bisimulations and instead \nqualify them by calculi. We will refer to the bisimulations for the pure .-calculus in De.nition 1 as \n.-bisimulations . 3. The .\u00b5-calculus We now extend enf bisimulation to the .\u00b5-calculus. This extension \nis new, but based on head normal form bisimulation for the .\u00b5\u00adcalculus [21]. VARIABLES x, y, z NAMES \na, b VALUES v ::= x |.x. t NAMED TERMS nt ::= [a]t TERMS t ::= v |let x=t1 in t2 |v1 v2 |\u00b5a. nt We identify \nsyntactic phrases up to renaming of bound variables and names. For a syntactic phrase f,let FN(f) denote \nthe set of free names of f. Names in the .\u00b5-calculus represent continuations. Names are not .rst-class, \nbut we will represent a name a as the .rst-class value a = .x. \u00b5b. [a]x. The familiar call/cc control \noperator can be encoded in the .\u00b5-calculus as call/cc = .f. \u00b5a. [a]f a. The operational semantics of \nthe .\u00b5-calculus is de.ned by a reduction relation on named terms: NAMED EVAL. CONTEXTS NE ::= [a][ ] \n|NE[let x=[ ] in t] NAMED ENFS ne ::= [a]v |NE[xv] .NE[t[v/x]] (R\u00b52) NE[(.x. t) v] (R\u00b51) NE[let x=v in \nt] .NE[t[v/x]] (R\u00b53) NE[\u00b5a. nt] .nt[NE/a] Here f[NE/a] denotes capture-avoiding substitution of named \neval\u00aduation contexts for names: for example, if b/.FN(NE),then (\u00b5b. [a]t)[NE/a]= \u00b5b. NE[t]. De.nition \n3. A binary relation S on named .\u00b5-terms is a .\u00b5\u00adbisimulation if S .B\u00b5(S),where '' . B\u00b5(S)= {(nt, nt \n) |either nt .. and nt ., * '*' or nt .ne and nt .ne where (ne, ne ' ) .M\u00b5(S)} M\u00b5(S)= {([a]v, [a]v ' \n) |(v, v ' ) .V\u00b5(S)} .{(NE[xv], NE ' [xv ' ]) |(NE, NE ' ) .K\u00b5(S)&#38; (v, v ' ) .V\u00b5(S)} V\u00b5(S)= {(x, \nx)} ' .{(v, v ' ) |.y/.FV(v) .FV(v ). (v*y,v ' *y) .T\u00b5(S)} K\u00b5(S)= {([a][ ], [a][ ])} .{(NE, NE ' ) |.y/.FV(NE) \n.FV(NE ' ). (NE *y, NE ' *y) .T\u00b5(S)} ' T\u00b5(S)= {(t, t ' ) |.a/.FN(t) .FN(t ). ([a]t, [a]t ' ) .S} with \n[a][ ] *y =[a]y and NE[let x=[ ] in t] *y = NE[t[y/x]]. De.nition 4. Say that t and t ' are .\u00b5-bisimilar, \nwritten t .\u00b5 t ' ,if there exists a .\u00b5-bisimulation S such that (t, t ' ) .T\u00b5(S). We show in Section \n10 that .\u00b5-bisimilar terms are contextually equivalent. Recall that a = .x. \u00b5b. [a]x. To illustrate .\u00b5-bisimilarity \nwe de.ne the term . = .x[P],where P = .f. .x. \u00b5a. [a] let y=xa in fy. The term . takes a function x as \nargument and applies x to succes\u00adsive arguments xa 1 a 2 ... until x applies one of the a i to an argument \nv, in which case v is returned as the result of .x. On the other hand, .x diverges if x never applies \nany of its arguments, e.g., if x = .y. O or x = .x[.f. .y. f]. Remark. A term with the behavior of . \ncannot be expressed in the pure call-by-value .-calculus. To see this, consider the two functions v = \n.y. let z=yy in O and v ' = .y. O. where O=(.x.x x)(.x.x x). They are contextually equivalent in the \npure call-by-value .-calculus. (This can be established using the operational extensionality property \nof the pure call-by-value .\u00adcalculus [7, 27], because the term let z=v0 v0 in O diverges if v0 is any \nclosed pure value.) But . can tell them apart: .v converges while .v ' diverges. A potential optimization \nof . is the following variant . ' which returns straight to its .nal return address when x applies an \nargument (rather than returning from all the recursive invocations of the recursive function): . ' = \n.x. \u00b5a. [a] .x[P ' ] x,where P ' = .f. .x. let y=xa in fy The optimization is correct up to enf bisimilarity, \nthat is, . .\u00b5 . ' , because S = {([a]., [a]. ' ), ([a]D[P,x], [a]\u00b5a. [a].x[P ' ] x), ([b]\u00b5b. [a]x, \u00b5b. \n[a]x), ([a].x[P] y, [a].x[P ' ] y)} is a .\u00b5-bisimulation. 4. The ..-calculus The ..-calculus is obtained \nfrom the pure call-by-value .-calculus by adding constructs for allocating a number of new reference \ncells, for storing a value in a reference cell, and for fetching the value from a reference cell. VARIABLES \nx, y, z REFERENCES i, j VALUES v ::= x |.x. t TERMS t ::= v |let x=t1 in t2 |v1 v2 |.s. t |i:=v; t |!i \nSTORES s ::= {i1:=v1,...,in:=vn}(i1,...,in are distinct) Stores are identi.ed up to reordering, and therefore \na store can be considered as a .nite map from references to values. Terms are identi.ed up to renaming \nof bound variables and references: in the term .s. t, the references in the domain of s are considered \nbound in the range of s and in t. For a syntactic phrase f,let FR(f) be the set of references occurring \nfree in f. A syntactic phrase is reference-closed if it contains no free references. Write dom(s) for \nthe domain of the store s.If s and s ' have disjoint domains, s\u00b7s ' denotes their disjoint union. If \ns = {i:=v}\u00b7s ' ,let s(i)= v and ' '' s[i:=v ]= {i:=v }\u00b7s . Reduction is de.ned on con.gurations, which \nare pairs (s, t) of stores and terms such that FR(t) .dom(s). (Con.gurations are not identi.ed up to \nrenaming of the domains of the stores, hence a con.guration (s, t) should not be thought of as a term \n.s. t.) EVALUATION CONTEXTS E ::= [] |E[let x=[ ] in t] EAGER NORMAL FORMS (ENFS) e ::= v |E[xv] (R.1) \n(s, E[let x=v in t]) .(s, E[t[v/x]]) (R.2) (s, E[(.x. t) v]) .(s, E[t[v/x]]) (R.3) (s, E[.s ' .t]) .(s\u00b7s \n' ,E[t]), if (dom(s) .FR(s) .FR(E)) ndom(s ' )= \u00d8(R.4) (s, E[i:=v; t]) .(s[i:=v],E[t]) if i .dom(s) (R.5) \n(s, E[!i]) .(s, E[s(i)]) if i .dom(s) Eager normal form bisimulation for the ..-calculus is based on \nthe relation-sets bisimulation idea [13, 16, 32]. Brie.y, instead of de.ning a bisimulation as a single \nbinary relation on terms, one de.nes a bisimulation as a set of such relations, each associated with \na world : here, a pair of stores. The requirement is that if two terms are related in a certain world, \nthen the eager normal forms (if any) of these two terms are related in a future world where the two stores \nmay have changed. Moreover, everything that was related in the old world must still be related in the \nnew world. Now for the formal de.nitions. Let X, Y, Z range over .nite sets of variables and let J range \nover .nite sets of references. We write X\u00b7Y for the disjoint union of X and Y . When the meaning is clear \nfrom the context, we write a singleton set {x}as just x.We use the same notational conventions for .nite \nsets of references. Notation X, J ff, f ' , ... means the syntactic phrases f, f ' , ... have free variables \nin X and free references in J.We omit X and/or J on the left of fif it is empty. Let R range over sets \nof triples (X|t, t ' ), more speci.cally subsets of Rel(Y, J, J ' ) for some Y , J and J ' ,where Rel(Y, \nJ, J ' )= {(X|t, t ' ) |X nY = \u00d8&#38; X\u00b7Y, J ft &#38; X\u00b7Y, J ' ft ' } We identify triples that differ \nonly up to renaming of the variables from the .rst component X: in the triple (X|t, t ' ),the variables \nin X are considered bound in t and t . A triple (\u00d8|t, t ' ) where the .rst component is empty is also \nwritten (|t, t ' ). A term relation tuple is a quadruple (X|s, s ' ,R) where X fs, s ' and R .Rel(X, \ndom(s), dom(s ' )). We identify term relation tuples that differ only up to renaming of the variables \nfrom the .rst component X and up to renaming of references. Let Q range over term relation sets, that \nis, sets of term relation tuples. De.nition 5. Q is a ..-bisimulation iff Q .B.(Q),where B.(Q)= {(X|s0,s0' \n,R0) | for all (Y |t,t ' ) .R0, either '' ) .. (s0,t) .. &#38;(s0,t , or .s1,s1' ,e,e ' ,R1 .R0,X1 .X\u00b7Y. \n'' '' (s0,t) .* (s1,e)&#38;(s0,t ) .* (s1,e )&#38; (e,e ' ) .M.(R1)&#38;(X1|s1,s1' ,R1) .Q} M.(R)= {(v, \nv ' ), (E[xv],E ' [xv ' ]) | (v, v ' ) .V.(R)&#38;(E,E ' ) .K.(R)}V.(R)= {(x,x)}.{(v, v ' ) |.y/.FV(v) \n.FV(v ' ). (y|v*y,v ' *y) .R} K.(R)= {([ ], [])} .{(E,E ' ) |.y/.FV(E) .FV(E ' ). (y|E*y,E ' *y) .R} \nDe.nition 6. Reference-closed ..-terms t and t ' are ..-bisimilar, written t . t ' ,iff there exists \na ..-bisimulation Q which contains a quadruple (X|{}, {},R) with (|t,t ' ) .R. We show in Section 9 that \n..-bisimilarity is a congruence. Therefore, as explained in Section 10, ..-bisimilar terms are con\u00adtextually \nequivalent. 5. Example: imperative .xed-point combinator It is well-known that a store that may contain \nfunctional values can be used to de.ne functions by recursion. Abbreviate .[f, i]= .x. let z1=!i in let \nz2=fz1 in z2 x and consider the term: Y. = .f..{i:=.[f, i]}.f .[f, i]. Y. can be used to de.ne functions \nby recursion in the ..-calculus. The technique of de.ning recursive functions by means of a cir\u00adcular \nstore is due to Landin [15]. We now show that the .xed-point combinator Y. is ..-bisimilar to the Curry \ncall-by-value .xed-point combinator Yv (de.ned in Section 2 above). This equivalence can be shown directly \nfrom the de.nition of a ..-bisimulation, but it is more convenient to apply the following general lemma: \nLemma 7. De.ne .s.t = .s.t for s {}, and . {}.t = t. = Assume that there exists a ..-bisimulation containing \na tuple (X|s,s ' ,R) where (|t,t ' ) .R, and let x1,...,xn .X.Then .x1....xn. .s.t . .x1....xn. .t ' \n.s ' . The lemma follows from Corollary 36 in Section 9. Proposition 8. Y.. Yv . Proof. By de.nition, \nY. = .f..{i:=.[f, i]}.f .[f, i] and Yv = .f..[f].[f]. The proof therefore consists of constructing a \n..\u00adbisimulation Q containing a tuple ({f}|{i:=.[f, i]}, {},R) where (|f .[f, i], .[f].[f]) .R, and then \nusing Lemma 7. Instead of specifying Q right away, we show how one would in practice construct Q: by \nstarting from the two con.gura\u00adtions ({i:=.[f, i]},f .[f, i]) and ({}, .[f].[f]) and iteratively adding \ntuples in order to satisfy the conditions in the de.nition of a ..-bisimulation. In that way, the main \npart of the equivalence proof consists in a number of calculations of reduction sequences. Abbreviate \nD[f]= .x. let z=.[f].[f] in zx. Now calcu\u00adlate: ({i:=.[f, i]},f .[f, i]) .* ({i:=.[f, i]},f .[f, i]) \n({}, .[f].[f]) .* ({},f D[f]). The two resulting eager normal forms are f .[f, i] and fD[f]. The variables \nin function position match (both are f), so consider the arguments, .[f, i] and D[f].Since .[f, i]= .x. \nlet z1=!i in let z2=fz1 in z2 x and D[f]= .x. let z=.[f].[f] in zx, the de.nition of a ..-bisimulation \nindicates that one should con\u00adtinue by reducing the bodies of these two .-abstractions: ({i:=.[f, i]}, \nlet z1=!i in let z2=fz1 in z2 x) .* ({i:=.[f, i]}, let z2=f .[f, i] in z2 x) and ({}, let z=.[f].[f] \nin zx) .* ({}, let z=fD[f] in zx) =({}, let z2=fD[f] in z2 x) The resulting two eager normal forms are \nlet z2=f .[f, i] in z2 x and let z2=fD[f] in z2 x. Again, the variables in function position match (both \nare f), and the evaluation contexts are identical (both are let z2=[ ] in z2 x). The function arguments, \n.[f, i] and D[f],are .-abstractions, and therefore one should continue reducing the bodies of these two \n.-abstractions. But this is exactly what was already done in the previous two reduction sequences. Using \nthe results of these calculations it is possible to construct the required bisimulation Q.First, de.ne \nR = {(|f .[f, i], .[f].[f]), (x|let z1=!i in let z2=fz1 in z2 x, let z=.[f].[f] in zx)}. Let x1, x2, \n... be distinct variables, and de.ne, for every n =0, Sn = {(z2|z2 xk,z2 xk) |1 =k =n}. Finally, de.ne \nQ as the set of all tuples ({f, x1,...,xn}|{i:=.[f, i]}, {},R .Sn) where n =0.Then Q is a ..-bisimulation, \nas can be veri.ed using the calculations above. Note that Q contains the tuple ({f}|{i:=.[f, i]}, {},R) \nwhere (|f .[f, i], .[f].[f]) .R. Therefore, Lemma 7 implies that Y.. Yv . 6. The .\u00b5.-calculus The .\u00b5.-calculus \ncombines the control aspects of the .\u00b5-calculus with the state aspects of the ..-calculus. The de.nition \nof .\u00b5.\u00adbisimilarity is a natural combination of the de.nitions of .\u00b5\u00adbisimilarity and of ..-bisimilarity. \nHowever, unlike the cases for the calculi considered previously in the article, .\u00b5.-bisimilarity is not \nonly contained in contextual equivalence, it coincides with contextual equivalence, as will be shown \nin Section 10. VARIABLES x,y,z NAMES a,b REFERENCES i, j VALUES v ::= x |.x.t NAMED TERMS nt ::= [a]t \nTERMS t ::= v |let x=t1 in t2 |v1 v2 |\u00b5a. nt | .s.t |i:=v; t |!i STORES s ::= {i1:=v1,...,in:=vn} Reduction \nis de.ned on con.gurations, which are now pairs (s,nt) of stores and named terms such that FR(nt) .dom(s). \nNAMED EVAL. CONTEXTS NE ::= [a][ ] |NE[let x=[ ] in t] NAMED ENFS ne ::= [a]v |NE[xv] (R\u00b5.1) (s, NE[let \nx=v in t]) .(s, NE[t[v/x]]) (R\u00b5.2) (s, NE[(.x. t) v]) .(s, NE[t[v/x]]) (R\u00b5.3) (s, NE[\u00b5a. nt]) .(s, nt[NE/a]) \n(R\u00b5.4) (s, NE[.s ' .t]) .(s\u00b7s ' , NE[t]), if (dom(s) .FR(s) .FR(NE)) ndom(s ' )= \u00d8(R\u00b5.5) (s, NE[i:=v; \nt]) .(s[i:=v], NE[t]) if i .dom(s) (R\u00b5.6) (s, NE[!i]) .(s, NE[s(i)]) if i .dom(s) Now X, Y, Z range over \n.nite sets of variables and names. Let NR range over sets of triples (X|nt, nt ' ), more speci.cally \nsubsets of NRel(Y, J, J ' ) for some Y , J and J ' ,where NRel(Y, J, J ' )= ' '' {(X|nt, nt ) |X nY = \n\u00d8&#38; X\u00b7Y, J fnt &#38; X\u00b7Y, J fnt } We identify triples that differ only up to renaming of the variables \nand names from the .rst component X. A named term relation tuple is a quadruple (X|s, s ' , NR) where \nX fs, s ' and NR .NRel(X, dom(s), dom(s ' )). We identify named term relation tuples that differ only \nup to renaming of the variables and names from the .rst component X and up to renaming of references. \nA named term relation set is a set of named term relation tuples. Let NQ range over named term relations \nsets. De.nition 9. NQ is a .\u00b5.-bisimulation iff NQ .B\u00b5.(NQ),where B\u00b5.(NQ)= {(X|s0,s0' , NR0) | for all \n(Y |nt, nt ' ) .NR0, either '' ) .. (s0,nt) .. &#38;(s0,nt , or .s1,s1' ,ne, ne ' , NR1 .NR0,X1 .X\u00b7Y. \n(s0,nt) .* (s1,ne)&#38; '' '' (s0,nt ) .* (s1,ne )&#38; (ne, ne ' ) .M\u00b5.(NR1)&#38; (X1|s1,s1' , NR1) \n.NQ} M\u00b5.(NR)= {([a]v, [a]v ' ), (NE[xv], NE ' [xv ' ]) |(v, v ' ) .V\u00b5.(NR)&#38;(NE, NE ' ) .K\u00b5.(NR)} \nV\u00b5.(NR)= {(x, x)} ' .{(v, v ' ) |.y/.FV(v) .FV(v ). .a/.FN(v) .FN(v ' ). (a\u00b7y|[a](v*y), [a](v ' *y)) \n.NR} K\u00b5.(NR)= {([a][ ], [a][ ])} .{(NE, NE ' ) |.y/.FV(NE) .FV(NE ' ). (y|NE *y, NE ' *y) .NR} De.nition \n10. Reference-closed named terms nt and nt ' are .\u00b5.\u00adbisimilar, written nt \u00b5. nt ' ,iff there exists \na .\u00b5.-bisimulation NQ which contains a quadruple (X|{}, {}, NR) with (|nt, nt ' ) .NR. Reference-closed \nterms t and t ' are .\u00b5.-bisimilar, written t \u00b5. t ' ,iff there exists a .\u00b5.-bisimulation NQ which contains \na quadruple (X|{}, {}, NR) with (t, t ' ) .T\u00b5.(NR),where ' '' T\u00b5.(NR)= {(t, t ) |.a/.FN(t) .FN(t ). (a|[a]t, \n[a]t ) .NR}. We show in Section 9 that .\u00b5.-bisimilarity is a congruence. 7. Example: one-shot continuations \nAs an extended example, we show the correctness of Friedman and Haynes s encoding of call/cc in terms \nof one-shot continua\u00adtions [9]. A one-shot continuation is a continuation which may be applied at most \nonce. Friedman and Haynes showed that, perhaps surpris\u00adingly, call/cc can be encoded in terms of its \nrestricted one-shot vari\u00adant. They did this by exhibiting an extraordinarily dif.cult pro\u00adgram [9, p.248] \ntogether with an informal equivalence argument. We con.rm the correctness of this program by a formal \nproof us\u00ading the enf bisimulation method. The equivalence proof below can be viewed as a formalization \nof Friedman and Haynes s informal argument. One cannot directly use the .\u00b5.-calculus to prove correctness \nof this encoding of call/cc, since the .\u00b5.-calculus does not contain one-shot continuations as a primitive. \nInstead, we de.ne one-shot continuations in terms of unrestricted continuations using another, but simpler, \nconstruction due to Friedman and Haynes. We then show the correctness of the encoding of call/cc by means \nof one\u00adshot continuations relative to this encoding of one-shot continua\u00adtions. First, we need to encode \na conditional operator in the .\u00b5.\u00adcalculus. Since the evaluation order in the .\u00b5.-calculus is call-by\u00advalue, \nthe encoding is done using thunks : T = .x. .y. x I F = .x. .y. y I if[t1,t2,t3]= let z1=t1in let z2=z1 \n(.z. t2)in z2(.z. t3) where I = .x. x,and where z1 and z2 are not free in t1, t2,or t3. Recall the de.nition \nof call/cc: call/cc = .f. \u00b5a. [a]fa where a = .x. \u00b5b. [a]x. Now de.ne the one-shot variant of call/cc: \ncall/cc1 = .f. (call/cc (.k. .{i:=T}.f (.x. if[!i, (i:=F; kx), O]))) The requirement that every captured \ncontinuation k is applied at most once is enforced by means of the local reference i. Now for the encoding \nof unrestricted continuations by means of one-shot continuations. For every reference j,de.ne Fj = .g. \n.f. let y=call/cc1 (.k. (j :=k; f (.x. let y=!j in yx))) in call/cc1 (.k ' .g (.k.k ' y)). Then de.ne \ncall/cc*= .f. .{j :=I}. .x[Fj] f. (See the original presentation of the encoding [9] for an informal \nexplanation of how it works.) The aim of this section is to show that call/cc \u00b5. call/cc*. It follows \nthat call/cc and call/cc*are contextually equivalent, and hence that call/cc*is as an encoding of call/cc \nby means of one\u00adshot continuations. As in Section 5, the equivalence could be shown directly from the \nde.nition of a bisimulation, but it is more convenient to use the following generalization of Lemma 7 \nto the .\u00b5.-calculus: Lemma 11. De.ne = {}, and .s.t .s.t for s = .{}.t = t. Assume that there exists \na .\u00b5.-bisimulation containing a tuple (X|s, s ' , NR) where (|[a]t, [a]t ' ) .NR, and let x1,...,xn .X. \nIf a .X does not occur free in any of s, s ' , t, and t ' ,then .x1....xn. .s. t \u00b5. .x1....xn. .t ' .s \n' . The lemma follows from Corollary 36 in Section 9. Proposition 12. call/cc \u00b5. call/cc*. Proof. By \nde.nition, call/cc = .f. \u00b5a. [a]fa and call/cc*= .f. .{j :=I}. .x[Fj] f. We therefore construct a bisimulation \ncon\u00adtaining a tuple (f\u00b7a|{}, {j:=I}, NR) where (|[a]\u00b5a. [a]f [a].x[Fj] f) .NR. The conclusion then a, \nfollows from Lemma 11. The main part of the proof consists in a number of calculations of reduction sequences. \nOne starts from the two con.gurations ({}, [a]\u00b5a. [a]fa ) and ({j:=I}, [a].x[Fj] f) and iteratively tries \nto add tuples in order to satisfy the conditions in the de.nition of a .\u00b5.-bisimulation. First, de.ne \nthe named evaluation context NE0 =[a] let x=[ ] in call/cc1 (.k ' . .x[Fj](.k.k ' x)) and for every reference \ni, de.ne the term C[i]= .x. if[!i, (i:=F ;(.x. \u00b5b. NE0[x]) x), O]. Now calculate, for any store s and \nany value v: (1) (s\u00b7{j:=v}, [a].x[Fj] f) .* (s\u00b7{j:=C[i],i:=T}, NE0[f (.x. let y=!j in yx)]). (2) (s\u00b7{j:=C[i],i:=T}, \n[b] let y=!j in yx)  .* (s\u00b7{j:=C[i],i:=F}, [a]call/cc1 (.k ' . .x[Fj](.k.k ' x))). (3) (s\u00b7{j:=C[i]}, \n[a]call/cc1 (.k ' . .x[Fj](.k.k ' x))) .* (s\u00b7{j:=C[i ' ],i0:=F,i ' :=T}, [a]x). These calculations dictate \nthe following construction of a .\u00b5.\u00adbisimulation: let NR0 ={(|[a]\u00b5a. [a]f a, [a].x[Fj] f), (y |[a]y, \n[a]call/cc1 (.k ' . .x[Fj](.k.k ' y))), (y\u00b7b |[b]\u00b5b.[a]y, [b] let z=!j in zy)} and let NQ consist of \nthe tuple (f\u00b7a|{}, {j:=I}, {(|[a]\u00b5a. [a]f a, [a].x[Fj] f)}) together with all named term relation tuples \nof the form (X|{},s, NR0) where {f, a}.X,where s is a store such that j .dom(s),and where there exists \nan i .dom(s) such that s(j)= C[i] and s(i)= T. Then NQ is a .\u00b5.-bisimulation, as can be veri.ed using \nthe calcu\u00adlations (1)-(3) above. By Lemma 11, call/cc \u00b5. call/cc*. 8. Enf bisimulation for terms with \nfree references So far in this article, eager normal form bisimulation has been used as a proof principle \nfor proving equivalence of reference\u00adclosed terms. In this section it is shown how to extend eager normal \nform bisimulation to terms which may contain free references. Besides allowing one to prove equivalences \nabout terms with free references, this extension is also used in the congruence proof for enf bisimilarity \nin Section 9. As a part of that proof, it must be shown that the following holds: If t \u00b5. t ' and v \u00b5. \nv ' ,then '' ' .{i:=v}.t \u00b5. .{i:=v }.t and i:=v; t \u00b5. i:=v ; t ' .Here the reference i will in general \noccur free in the terms t, t ' , v,and v ' , and, of course, in the terms i:=v; t and i:=v ' ; t ' . \nThe modi.cation needed to take free references into account can be explained as follows. Suppose that \nthe free references of the terms t and t ' are contained in J, and that one wants to prove that t and \nt ' are equivalent. According to the previous de.nition, one re\u00adquirement is that [a]t and [a]t ' should \neither both diverge, or reduce to matching named eager normal forms. But one cannot reduce [a]t and [a]t \n' without providing values for the references in J, i.e., the references which are free in t and t ' \n. The solution is to initialize the references in J with a number of fresh variables zjj.J .This initialization \ntakes care of the input aspect of the free references; the output aspect is taken care of by an extra \nrequirement: if both ({j :=zjj.J }, [a]t) and ({j :=zjj.J }, [a]t ' ) reduce to named ea\u00adger normal forms, \nthen in the two resulting stores, the references from J must contain values which are pairwise related. \nNow for the formal de.nitions. Named term relation sets are generalized as follows: let NUJ = {(X|s, \ns ' , NR) |X, J fs, s ' &#38; NR .NRel(X, J\u00b7dom(s),J\u00b7dom(s ' ))}. We identify quadruples that differ \nonly up to renaming of the vari\u00adables and names from the .rst component X and up to renaming of references \nfrom dom(s) and dom(s ' ). Notice that NU\u00d8 = NU. De.nition 13. NQ .NUJ is a J-bisimulation iff NQ .BJ \n(NQ), where BJ (NQ)= {(X|s0,s0' , NR0) .NUJ | for all distinct variables zii.J and all (Y |nt, nt ' ) \n.NR0, either ({i:=zii.J }\u00b7s0,nt) .. &#38;({i:=zii.J }\u00b7s0' ,nt ' ) .. , or '' ' i.J .ne,ne , (vi,vi)i.J \n,s1,s1, NR1 .NR0,X1 .X\u00b7Y \u00b7zi . ({i:=zii.J }\u00b7s0,nt) .* ({i:=vii.J }\u00b7s1,ne)&#38; '' 'i.J '' ({i:=zii.J \n}\u00b7s0,nt ) .* ({i:=vi }\u00b7s1,ne )&#38; (ne, ne ' ) .M\u00b5.(NR1)&#38; .i .J. (vi,vi' ) .V\u00b5.(NR1)&#38; (X1|s1,s1' \n, NR1) .NQ} Say that two terms t and t ' are J-bisimilar if there exists a J-bisimulation containing \na tuple (X|{}, {}, NR) where (t, t ' ) . T\u00b5.(NR). We now generalize the previously given de.nition of \nenf bisim\u00adilarity for reference-closed terms: De.nition 14. Let t and t ' be .\u00b5.-terms. Say that t and \nt ' are .\u00b5.\u00adbisimilar, written t \u00b5. t ' , if there exists a .nite set J of references such that t and \nt ' are J-bisimilar. Example 15. It is easytoshow that let z=!j in (j:=I; j:=z; fx) \u00b5. fx while on the \nother hand let z=!j in (j:=I; let y=fx in (j:=z; y)) \u00b5. fx. The proofs of this equivalence and this non-equivalence \nillustrate a basic sequentiality property of the calculi considered in this ar\u00adticle: in order for two \nterms to be equivalent, it is enough that the contents of the free references are equivalent at certain \nsynchro\u00adnization points , but in-between these points the contents of the free references can be modi.ed \narbitrarily. Proposition 16. Let J0 and J be .nite sets of references such that J0 .J. Any two terms \nwhich are J0-bisimilar are also J-bisimilar. 9. Congruence This section contains an outline of the proof \nthat .\u00b5.-bisimilarity is a congruence: it is an equivalence relation which is furthermore compatible. \nA binary relation S on terms and named terms of the .\u00b5.-calculus is compatible if it is closed under \nthe term formation rules of the .\u00b5.-calculus. For example, if t1 St ' 1 and t2 St ' 2, then also (let \nx=t1 in t2) S (let x=t1 ' in t2' ),and if ntS nt ' ,then \u00b5a.nt S \u00b5a.nt ' . The straightforward formal \nde.nition is omitted. Proposition 17. For every .nite set J of references, there exists a greatest J-bisimulation \nBJ . Proof. The de.nition of BJ immediately implies that the union of an arbitrary family of J-bisimulations \nis also a J-bisimulation. In particular, the union of all J-bisimulations is the greatest J-bisimulation. \nAt this point it is useful to change the de.nitions of a .\u00b5.\u00adbisimulation and of a J-bisimulation slightly: \nin those de.nitions, replace the operators V\u00b5. and K\u00b5. with V '' \u00b5. and K\u00b5.: '' V\u00b5.(NR)= {(v, v ) |.y/.FV(v) \n.FV(v ' ). .a/.FN(v) .FN(v ' ). (a\u00b7y|[a]vy, [a]v ' y) .NR}. ' K\u00b5.(NR)= {(NE, NE ' ) |.y/.FV(NE) .FV(NE \n' ). (y|NE[y], NE ' [y]) .NR}. These modi.cations do not change the relation of .\u00b5.-bisimilarity; in \nfact, the greatest J-bisimulation is unchanged. The two operators V '' \u00b5. and K\u00b5. are more convenient \nin the congruence proof below, while the other two operators are more convenient when using .\u00b5.\u00adbisimulation \nas a proof principle. We .rst show that .\u00b5.-bisimilarity is an equivalence relation. De.nition 18. Let \nNQ .NUJ . 1. NQ is closed under weakening if whenever (X0|s, s ' , NR) .NQ and X0 .X for some .nite set \nX of names and variables, also (X|s, s ' , NR) .NQ. 2. NQ is closed under context extrusion if (X|s, \ns ' , NR) .NQ and (Z1\u00b7Z2|nt, nt ' ) .NR imply that there exists NR ' .NR .{(Z2|nt, nt ' )}such that (X\u00b7Z1|s, \ns ' , NR ' ) .NQ. Lemma 19. The greatest J-bisimulation is closed under weaken\u00ading and context extrusion. \nLemma 20. .\u00b5.-bisimilarity is an equivalence relation. Proof sketch. Re.exivity and symmetry follow easily \nfrom the def\u00adinition of BJ . As for transitivity, assume that t \u00b5. t ' and that t ' \u00b5. t '' ; we must \nshow that t \u00b5. t '' (and similarly for named terms). Proposition 16 implies that there exists some J \nsuch that t ' ''' and t are J-bisimilar and t and t are J-bisimilar. Now consider a general composition \nconstruction on named term relation sets. Given NR1 .NRel(Y, J, J1) and NR2 .NRel(Y, J, J2),de.ne their \ncomposition as NR1; NR2 = {(X|nt1,nt2) |.nt.(X|nt1,nt) .NR1 &#38; (X|nt, nt2) .NR2}, and given NQ1, NQ2 \n.NUJ ,de.ne NQ1; NQ2 = {(X|s1,s2, NR1; NR2) |.s.(X|s1,s, NR1) .NQ1 &#38; (X|s, s2, NR2) .NQ2}. Then the \nfollowing property holds: if NQ1 and NQ2 are J\u00adbisimulations closed under weakening, then so is NQ1; \nNQ2. It remains to show that .\u00b5.-bisimilarity is compatible. The proof of this fact is structured as \nfollows: First, we show that a restricted variant of .\u00b5.-bisimilarity is substitutive in a sense de.ned \nbelow. (The restricted variant does not validate certain common extensionality rules for call\u00adby-value \ncalculi.)  Second, we use a syntactic translation to show that full .\u00b5.\u00adbisimilarity is substitutive. \nIt follows that .\u00b5.-bisimilarity is compatible.  9.1 Substitutions A substitution is a .nite map s with \na domain consisting of vari\u00adables and names, and such that s maps each variable in its domain to a .\u00b5.-calculus \nvalue, and each name in its domain to a .\u00b5.\u00adcalculus named evaluation context. Let s range over substitutions. \nWhen f is a syntactic phrase (store, value, term, or named term), fs denotes the result of carrying out \nthe substitution s on f (we omit the formal de.nitions). Also, de.ne NR(s, s ' )= {(Z|nts, nt ' s ' ) \n|(Z|nt, nt ' ) .NR} (where the variables and names occurring free in the ranges of s and s ' are not \nin Z). Let dom(s) denote the domain of s. Say that X fs S(NR) s ' : Y when dom(s)= dom(s ' )= Y , and: \n1. For every variable x .Y , (s(x),s ' \u00b5.(NR). (x)) .V ' ' 2. For every name a .Y , (s(a),s ' (a)) .K\u00b5.(NR). \n 3. The free variables and names in the ranges of s and s ' are contained in X.  Say that two substitutions \ns and s ' are .\u00b5.-bisimilar (notation: s \u00b5. s ' )ifthere exists a J-bisimulation containing a tuple (X \n\u00b7Y |{}, {}, NR) such that X fs S(NR) s ' : Y .In the next sections we show that .\u00b5.-bisimilarity is substitutive \nin the following sense: 1. If t \u00b5. t ' and s \u00b5. s ' ,then ts \u00b5. t ' s ' . 2. If nt \u00b5. nt ' and s \u00b5. \ns ' ,then nts \u00b5. nt ' s ' .  9.2 Non-. bisimulation In order to show that .\u00b5.-bisimilarity is substitutive, \nwe .rst show the analogous result for a certain restricted variant of .\u00b5.\u00adbisimilarity. The variation \nconsists in a change in the de.nition of the operators V and K (which are used to de.ne relations on \nvalues and named evaluation contexts, respectively). De.nition 21. Let NR be a named term relation. M \n(NR)= {([a]v, [a]v ' ), (NE[xv], NE ' [xv ' ]) |(v, v ' ) .V (NR)&#38;(NE, NE ' ) .K (NR)} V (NR)= {(x, \nx) |x is a variable} ' .{(.x.t,.x. t ' ) |.a/.FN(t) .FN(t ). (x\u00b7a|[a]t, [a]t ' ) .NR} K (NR)= {([a][ \n], [a][ ]) |a is a name} .{(NE[let x=[ ] in t], NE ' [let x=[ ] in t ' ]) | x/.FV(NE) .FV(NE ' )&#38; \n(x|NE[t], NE ' [t ' ]) .NR} De.nition 22. 1. For every named term relation set NQ .NUJ , the named term \nrelation set BJ (NQ) is de.ned in the same way as BJ (NQ), except that M and V are used instead of \nM\u00b5. and V\u00b5.. 2. NQ is a non-.J-bisimulation if NQ .BJ (NQ). 3. Two reference-closed .\u00b5.-terms t and \nt ' are non-. bisimilar (notation: t t ' ) if there exist a .nite set of references J and a non-.J-bisimulation \ncontaining a tuple (X|{}, {}, NR) such that (t, t ' ) .T\u00b5.(NR). Non-. bisimilarity of named terms is \nde.ned similarly.  Remark. The reason for the name non-. is that non-. bisimilarity does not satisfy \ntwo common extensionality rules for call-by-value calculi, namely the .v-rule and the let. -rule: .x.y \nx y and (let x=yz in x) yz. Let BJ be the greatest non-.J-bisimulation. The key to show\u00ading that non-. \nbisimilarity is substitutive is to show that BJ is closed under substitutions in the sense de.ned next. \nDe.nition 23. 1. For every NQ .NUJ ,let s ' .Y. (X\u00b7Y |s, s ' , NR) .NQ &#38; X fs S (NR) s ' : Y } F \n(NQ)= {(X|ss, s ' , NR(s, s ' )) | where S (NR) is de.ned in the same way as S(NR), except that V and \nK are used in place of V\u00b5. and K ' ' \u00b5. in the de.nition. 2. A named term relation set NQ .NUJ is closed \nunder substitu\u00adtions if F (NQ) .NQ. We now proceed to show that for every J, the greatest non-. J-bisimulation \nis closed under substitutions. De.ne the substitutive closure of NQ as )n S(NQ)=(F(NQ). n<. It is the \nleast .xed point of F containing NQ. Main Lemma. Let NQ .NUJ be a non-.J-bisimulation which is closed \nunder context extrusion. Let (X|s, s ' , NR) .(F )n(NQ) and (Z|nt, nt ' ) .NR and (vj,vj' ) .V (NR) for \nall j .J. 1. Assume that ({j:=vjj.J }\u00b7s, nt) .* ({j:=wjj.J }\u00b7s1,ne1) in ' '' j.J m or fewer steps. Then \nthere exist X1 .X\u00b7Z, s1, ne1, wj , and NR1 .NR such that 'j.J '' ' j.J '' ({j:=vj }\u00b7s ,nt ) .* ({j:=wj \n}\u00b7s1,ne 1), M (wj,wj' ) .V (NR1) for all j .J. (X1|s1,s1' , NR1) .S (NQ), (ne1,ne 1' ) .(NR1), and 2. \nConversely, assume that 'j.J '' ''' ({j:=vj }\u00b7s ,nt ) .* ({j:=wjj.J }\u00b7s1,ne 1) in m or fewer steps. Then \nthere exist X1 .X\u00b7Z, s1, ne1, wjj.J , and NR1 .NR such that j.Jj.J ({j:=vj }\u00b7s, nt) .* ({j:=wj }\u00b7s1,ne1) \netc. Proof sketch. By induction on the pairs (m, n), ordered lexico\u00adgraphically. Corollary 24. The greatest \nnon-.J-bisimulation BJ is closed under substitutions. Proof sketch. The Main Lemma implies that )n(B \n (B (F) .B(S)) JJJ for all n =0. By de.nition of S and the fact that non-. bisimulations are closed under \nunions, S (B ) .B (S (B )). J JJ This means that S (BJ ) is a non-.J-bisimulation, and there\u00adfore F \n(B ) .S (B ) .B ,since B is the largest non-. J JJJ J-bisimulation. 9.3 Non-. bisimilarity is substitutive \nIn order to show that non-. bisimilarity is substitutive, one needs the following construction for combining \nnamed term relation sets: De.nition 25. Given NQ1, NQ2 .NUJ ,de.ne NQ1 + NQ2 = {(X|s1\u00b7s2,s1 ' \u00b7s2' , \nNR1 .NR2) |(X|s1,s1' , NR1) .NQ1 &#38; (X|s2,s2' , NR2) .NQ2 &#38; dom(s1) ndom(s2)= dom(s1' ) ndom(s2' \n)= \u00d8}. Lemma 26. If NQ1 and NQ2 are non-.J-bisimulations closed under weakening, then so is NQ1 + NQ2. \nCorollary 27. The greatest non-.J-bisimulation BJ satis.es that B = B + B J JJ . Finally, non-. bisimilarity \nis substitutive: Theorem 28. ' ' 1. If tt and ss ' ,then ts ts ' . ' ' 2. If nt nt and s s ' ,then \nnts nts ' . Proof sketch. We show the second implication the .rst is com\u00ad ' pletely similar. Assume that \nnt nt and ss ' ,and let J be the set of free references in nt, nt ' , s,and s ' . Then the great\u00adest \nnon-.J-bisimulation B contains a tuple (X1|{}, {}, NR1) J such that (|nt, nt ' ) .NR1 and a tuple (X2 \n\u00b7Y |{}, {}, NR2) such that X2 fs S (NR2) s ' : Y . Then by Corollary 27, BJ also contains the tuple \n(X1 .X2 .Y |{}, {}, NR1 .NR2).Fi\u00adnally, since BJ is closed under substitutions, it also contains the \ntuple ((X1 \\Y ) .X2|{}, {}, NR1(s, s ' ) .NR2(s, s ' )) where (|nts, nts ' ) .NR1(s, s ' ). Hence nts \n nt ' . s ' 9.4 .\u00b5.-bisimilarity is substitutive The fact that .\u00b5.-bisimilarity is substitutive can \nbe derived from the analogous result for non-. bisimilarity, Theorem 28, by means of a syntactic translation \ninvolving an in.nite .-expansion com\u00adbinator H. Fix a .nite set of references J = {j1,...jn}. For every \nvalue v and every term t, de.ne the term app[v, t]= let x1=!j1 in ... let xn=!jn in let y1=vx1 in ... \nlet yn =vxn in (j1:=y1; ...jn:=yn; t) (where x1,... xn, y1,..., yn are not free in v or t). The operational \nbehavior of app[v, t] is to apply v to every reference in J and then continue according to t.Now de.ne \nH0 = .z..f..x.let y1=zx in app[z, let y2=fy1 in app[z,z y2]] H = .x[H0 ]. The combinator H originates \nfrom a generalization of a syntactic minimal invariance equation [17, 29]. Also, for every value v and \nevery named evaluation context NE, de.ne G[v]= .x. let y1=H x in app[H, let y2=vy1 in app[H, H y2]] G[NE]= \nNE[let x=[ ] in app[H, H x]]. De.nition 29. 1. For every term t,let t be the result of substituting G[x] \nfor every free variable x in t, and substituting G[[a][ ]] for every free name a in t. For every named \nterm nt,de.ne nt similarly. 2. For every term t,de.ne  t = app[H, let x=t in app[H, H x]]. 3. For \nevery named term nt =[a]t,de.ne nt =[a]t . Using the above syntactic constructs, .\u00b5.-bisimilarity can \nbe characterized in terms of non-. bisimilarity: Proposition 30. Let the free references of t, t ' , \nv, and v ' be contained in J. ' ' 1. t \u00b5. t iff tt. ' ' 2. v \u00b5. v iff G[v ] G[v ]. ' ' 3. nt \u00b5. nt \niff ntnt. If v is a value such that the free references of v are contained in J,then v \u00b5. G[v] (but in \ngeneral v G[v]). As will be shown next, a more general version of that property holds. De.nition 31. \nThe binary relation R on terms, named evaluation contexts, and named terms is de.ned inductively by means \nof the inference rules in Figure 1. vRv ' tRt ' tRt vR G[v ' ] .x.t R .x.t ' v1 Rv1 ' v2 Rv2 ' vRv ' \ntRt ' v1 v2 Rv1 ' v2 ' (i:=v; t) R (i:=v ' ; t ' ) tRt ' .j .J0.s(j) Rs ' (j) dom(s)=dom(s .)=J0, ' J0 \nn J =\u00d8 .s.t R .s ' .t nt R nt ' NE R NE ' \u00b5a.nt R \u00b5a.nt ' NE R NE NE R G[NE ' ] tRt ' NE R NE ' NE[let \nx=[ ] in t] R NE ' [let x=[ ] in t ' ] NE R NE ' tRt ' NE[t] R NE ' [t ' ] Figure 1. The relation R. \nTwo stores s and s ' are related by R if they have the same domain J0 and if s(j) Rs ' (j) for all j \n.J0. Proposition 32. Let J ' .J. The named term relation set {(X|s, s ' , NR) .NUJ. |sRs ' &#38; NR .{(Z|nt, \nnt ' ) |nt R nt ' }}is a J ' -bisimulation. In particular, taking J ' = J: Corollary 33. Let the free \nreferences of t, t ' , nt, and nt ' be contained in J. 1. tRt ' implies t \u00b5. t ' . 2. nt R nt ' implies \nnt \u00b5. nt ' . It follows that .\u00b5.-bisimilarity is substitutive:  Theorem 34. 1. If t \u00b5. t ' and s \u00b5. \ns ' ,then ts \u00b5. t ' s ' . 2. If nt \u00b5. nt ' and s \u00b5. s ' ,then nts \u00b5. nt ' s ' .  Proof sketch. As a \nsimple example, assume that t \u00b5. t ' and v \u00b5. v ' ;it mustbe shown that t[v/x] \u00b5. t ' [v ' /x]. By Corol\u00adlary \n33, t[v/x] \u00b5. t[G[G[v]]/x]. Hence by Proposition 30 and the fact that non-. bisimilarity is substitutive: \n (t[v/x])(t[G[G[v]]/x])= t [G[v ]/x] ' ' ]/x] t [G[v '' (t [v /x]). By Proposition 30 again, t[v/x] \u00b5. \nt ' [v ' /x]. 9.5 .\u00b5.-bisimilarity is a congruence Now it is shown that .\u00b5.-bisimilarity is compatible, \nusing the fact that it is substitutive. Proposition 35. BJ = BJ + BJ . Corollary 36. Let FR(nt) .FR(nt \n' ) .J, and let yjj.J be distinct variables not free in nt or nt ' . Suppose that j.Jj.J ({j:=yj },nt) \n.* ({j:=vj }\u00b7s1,ne1), j.J ''j.J '' ({j:=yj },nt ) .* ({j:=v }\u00b7s1,ne 1), j and (X1|s1,s1' , NR1) .BJ with \n(ne1,ne 1' ) .M\u00b5.(NR1) and (vj,vj' ) .V\u00b5.(NR1) for all j .J.Then nt \u00b5. nt ' . Theorem 37. .\u00b5.-bisimilarity \nis compatible. Proof sketch. The most complicated case to show is that .\u00b5.\u00adbisimilarity is closed under \n.-abstraction: if t \u00b5. t ' and also vj \u00b5. vj ' for all j .J0,then '' .{j:=vjj.J0 }.t \u00b5. .{j:=vjj.J0 }.t \n. Here one proceeds in three steps: 1. If z/.FV(t),then .s. t \u00b5. let x=.s. .z. t in x I. 2. If v \u00b5. \nv ' and vj \u00b5. vj ' for all j .J0, and if the free references of all these values are contained in J .J0,then \n j.J0 j.J0 ' ' .{j:=G[vj ]}. G[v ] \u00b5. .{j:=G[vj ] }. G[v ]. 3. If the free references of v and vjj.J0 \nare contained in J .J0, then .{j:=vjj.J0 }.v \u00b5. .{j:=G[vj ]j.J0 }. G[v ]. The third part follows from \nProposition 32 and Corollary 36. The proof of the second part uses Corollary 36 and the following con\u00adstruction: \nfor every NQ .NUJ with J0 .J,let NQ\\J0 be the subset of NUJ\\J0 de.ned by '' NQ\\J0 = {(X1|{j :=wjj.J0 \n}\u00b7s, {j :=w j.J0 }\u00b7s, NR) |(X|s, s ' , NR) .NQ &#38; X .X1 &#38; .j .J0. (wj,wj' ) .V (NR)}. j The Main \nLemma implies that B \\J0 .B . JJ\\J0 The other cases of the proof are simpler and use Theorem 34 and Corollary \n36. In summary, the main result of this section: Theorem 38. .\u00b5.-bisimilarity is a congruence: an equivalence \nrelation which is furthermore compatible. Corollary 39. Each of .-bisimilarity, .\u00b5-bisimilarity, and \n..\u00adbisimilarity is a congruence. Proof. It is easy to see that two .\u00b5-terms are .\u00b5-bisimilar if and only \nif they are .\u00b5.-bisimilar, and similarly for the other inclusions between the four calculi considered \nin this article. (Each extension is fully abstract ). The statement of the corollary immediately follows. \nSuppose for example that v1 \u00b5 v1 ' and v2 \u00b5 v2' .Then v1 \u00b5. v1 ' and v2 \u00b5. v2' . Therefore, since .\u00b5.-bisimilarity \nis '' '' a congruence, v1 v2 \u00b5. v1 v2. Finally, since v1 v2 and v1 v2 are .\u00b5-terms, v1 v2 \u00b5 v1 ' v2' \n. Remark. Non-. bisimilarity is also a congruence. The relation be\u00adtween non-. bisimilarity and .\u00b5.-bisimilarity \nis analogous to the relation between B\u00a8ohm tree equivalence and B\u00a8ohm tree equiva\u00adlence up to . for the \npure .-calculus.  10. Full abstraction In this section we show that .\u00b5.-bisimilarity coincides with \ncon\u00adtextual equivalence for the .\u00b5.-calculus. First, let us say that a variable-closed and reference-closed \nnamed term nt terminates, written nt.,iff .s,ne. ({},nt) .* (s,ne). Then we de.ne that terms tand t ' \nare contextually equiv\u00adalent, written t ~t ' ,iff for all names a and term contexts C =\u00b5. such that C[t] \nand C[t ' ] are variable-closed and reference-closed, ' [a]C[t]..[a]C[t ].. It is easy to see that ~ \n=\u00b5. is a congruence and, moreover, it is the largest congruence relation which satis.es '' that t ~implies \n[a]t..[a]t .for all names aand variable\u00ad =\u00b5. t closed and reference-closed terms tand t ' .Since .\u00b5.-bisimilarity \nis a congruence, it is immediate from its de.nition that it is included in contextual equivalence, viz. \nthat .\u00b5.-bisimilarity is sound with respect to contextual equivalence. Theorem 40 (Soundness). \u00b5. .~ \n=\u00b5.. Similarly, .-bisimilarity, .\u00b5-bisimilarity, and ..-bisimilarity are included in contextual equivalence \nfor their respective calculi. To prove the converse of Theorem 40, we will form a bisimu\u00adlation which \nrelates all contextually equivalent terms. The task is similar to the B\u00a8ohm-out proof of the separability \ntheorem in the call-by-name .-calculus. For readers familiar with the B\u00a8ohm-out proof, we brie.y compare \nour approach: The B\u00a8ohm-out proof sub\u00adstitutes, for each free variable, a function that takes many argu\u00adments. \nThis makes it possible to control the function s behaviour separately each time it is called. We need \nthe same level of con\u00adtrol over the behaviour of the functions and continuations that are substituted \nfor the free variables and names in the contextually equivalent terms we want to prove bisimilar. However, \ninstead of using functions that take many arguments, we use stateful func\u00adtions and continuations. They \nuse mutable references to execute pre-programmed strategies that specify how they will behave each time \nthey are invoked. Moreover, we use the expressive power of the .\u00b5-calculus to capture not only the argument \nwhen a function substituted for a free variable is invoked but also the continuation. The presence of \nmutable references introduces one complication, namely it requires us to store every argument and continuation \nwe see so that we can invoke them multiple times to expose stateful behaviour. We will need to accumulate \nvalues in lists and random access list entries. We encode the empty list as the identity function I and \nwe encode the list v with elements v1,...,vn appended as: (v|v1,...,vn)= .z. let x0=vz in let x1=x0 v1 \nin ... in xn-1 vn where z,x0,...,xn-1 are not free in v,v1,...,vn.When v = I, we write just (v1,...,vn). \nWe access the q th element in the list v with v#q = \u00b5a.[a]v.x1 ....xq-1.a ,where ais not free in v. We \nuse a designated reference j0 to store a list with all the arguments v and continuations NE we see along \nthe way (each NE is stored as the value .x.\u00b5a.NE[x] with x,a not free in NE). We let wrange over both \npairs of values and pairs of named evaluation contexts. Given such a pair, let w V be the pair of values \nand let w NR be the singleton named term relation de.ned as: { (v1,v2) if w =(v1,v2)w = (.x.\u00b5a.NE1[x],.x.\u00b5a.NE2[x]) \nif w =(NE1,NE2) { NR (a\u00b7x|[a](v1 *x),[a](v2 *x)) if w =(v1,v2) w = (x|NE1 *x,NE2 *x) if w =(NE1,NE2) \nwhere xand aare not free in v1,v2,NE1,NE2. For each free variable xi and name aj , we associate a reference \nii and jj, respectively. Each reference stores a strategy pwhich is a sequence of moves m, one for each \nsuccessive invocation of the variable xi or name aj, ending in success Tor failure .: STRATEGIES p ::= \nT|.|m; p MOVES m ::= move(q,p1,p2)(q =1) A move move(q,p1,p2) plays the q th value or continuation from \nthe list stored in j0 and associates the strategy p1 with a vari\u00adable, which is used as argument, and \np2 with a name, which is used as continuation. These ideas are expressed in the following encod\u00adings. \nGiven a reference i and a strategy p, we de.ne the function [[p]](i), which takes a function argument \nxand a continuation y as arguments, and for every move m, wede.ne theterm [[m]],as fol\u00adlows. [[T]](i)= \n.x..y.I [[.]](i)= .x..y.O [[m; p]](i)= .x..y. let z=!j0 in j0:=(z|x,y); i:=[ p]](i); [ m]] [[move(q,p1,p2)]] \n= let z=!j0 in let x=z#q in .{i:=[ p1]](i),j:=[ p2]](j)}.j.[x i] where iand j.denote the value and the \nevaluation context i= .x.\u00b5a.[a0] let y=!i in let z=yxin za j.= let x=[ ] in let y=!j in let z=yxin za \n0 and where a0 is a designated top-level name. These are the building blocks we use to separate terms. \nAs in [21], our separation proof is co-inductive. We de.ne: W= {(x1,...,xm,a1,...,an|s1,s2,{w1 NR ,...,wq \nNR}) |.strategies p1,...,pm,p1' ,...,pn' . .distinct references i1,...,im,j1,...,jn ./dom(s1) .dom(s2). \n.moves m. [a0].s\u00b7s1' s.[[m]]..[a0].s\u00b7s2' s.[[m]]. where s= {i1:=[ p1]](i1),...,im:=[ pm]](im), j1:=[ \np1' ]](j1),...,jn:=[ pn' ]](jn)}, s =[ i1/x1,..., im/xm,[a0].j1/a1,...,[a0].jn/an], s ' = si\u00b7{j0:=(vi1,...,viq \n)}, i (v11,v21)= w1 V ,...,(v1q ,v2q )= wq V} Lemma 41. Wis a .\u00b5.-bisimulation. Proof. By detailed analysis \nof the possible operational behaviours of the named terms in each wi NR triple. ~ Lemma 42. t1 =\u00b5. t2 \nimplies t1 \u00b5. t2 if FR(t1) .FR(t2)= \u00d8. ~ Proof. Suppose t1 and t2 are reference-closed terms, t1 =\u00b5. \nt2, and X ft1,t2. Then, by the de.nition of Wand contex\u00ad ~NR}) tual equivalence, t1 =\u00b5. t2 implies (X|{},{},{w \n.Wwhere w =(.x.t1,.x.t2) and x/.X. Observe that w NR = (a\u00b7x|[a]t1,[a]t2). We conclude t1 \u00b5. t2 by Lemmas \n41 and 19. To extend this result to general terms, we de.ne a term context LJ that translates any term \nt with FV(t) .J = {i1,...in}to the reference-closed closed term LJ [t]= .x..{i1:=I,...,in:=I}. (.x.t,get(i1),set(i1),...,get(in),set(in)) \nwhere x/.FV(t), get(ii)= .x.!ii,and set(ii)= .x.(ii:=x; I). Lemma 43. t1 \u00b5. t2 iff LJ [t1] \u00b5. LJ [t2]. \nTheorem 44 (Completeness). \u00b5. .~ =\u00b5.. Proof. Suppose J = FR(t1) .FR(t2).Then ~ ~ t1 =\u00b5. t2 .LJ [t1] ~=\u00b5. \nis a congruence =\u00b5. LJ [t2] . LJ [t1] \u00b5. LJ [t2] Lemma 42 . t1 \u00b5. t2 Lemma 43.   Acknowledgments \nWe thank Olivier Danvy and Andrzej Filinski for guidance and comments on this work. We also thank Matthias \nFelleisen and the anonymous referees for comments and suggestions, and Radha Jagadeesan, Paul Levy, and \nCorin Pitcher for discussions. The .rst author is supported by BRICS (Basic Research in Computer Science, \nfunded by the Danish National Research Foun\u00addation). References [1] S. Abramsky. The lazy lambda calculus. \nIn D. Turner, editor, Re\u00adsearch Topics in Functional Programming, pages 65 116. Addison-Wesley, 1990. \n[2] S. Abramsky, K. Honda, and G. McCusker. A fully abstract game semantics for general references. In \nProc. 13th Annual IEEE Symposium on Logic in Computer Science, pages 334 344, 1998. [3] Z. M. Ariola \nand H. Herbelin. Minimal classical logic and control operators. In ICALP, volume 2719 of Lecture Notes \nin Computer Science, pages 871 885. Springer-Verlag, 2003. [4] H. P. Barendregt. The Lambda Calculus: \nIts Syntax and Semantics. Number 103 in Studies in Logic and the Foundations of Mathematics. North-Holland, \nrevised edition, 1984. [5] G. M. Bierman. A computational interpretation of the lambda-mu calculus. In \nL. Brim, J. Gruska, and J. Zlatuska, editors, Proc. 23rd Mathematical Foundations of Computer Science, \nBrno, Czech Republic, volume 1450, pages 336 345. Springer-Verlag, 1998. [6] R.David and W.Py. .\u00b5-calculus \nand B\u00a8ohm s theorem. Journal of Symbolic Logic, 66(1):407 413, 2001. [7] L. Egidi, F. Honsell, and S. \nRonchi della Rocca. Operational, denotational and logical descriptions: a case study. Fundamenta Informaticae, \n16(2):149 169, 1992. [8] M. Felleisen and R. Hieb. The revised report on the syntactic theories of sequential \ncontrol and state. Theoretical Computer Science, 103:235 271, 1992. [9] D. P. Friedman and C. T. Haynes. \nConstraining control. In Proc. 12th ACM Symposium on Principles of Programming Languages, pages 245 254, \n1985. [10] A. D. Gordon. Bisimilarity as a theory of functional programming. Theoretical Computer Science, \n228(1 2):5 47, 1999. [11] A. D. Gordon and A. M. Pitts, editors. Higher Order Operational Techniques \nin Semantics. Publications of the Newton Institute. Cambridge University Press, 1998. [12] P. de Groote. \nOn the relation between the lambda-mu-calculus and the syntactic theory of sequential control. In LPAR \n94, volume 822 of Lecture Notes in Arti.cial Intelligence, pages 31 43. Springer-Verlag, 1994. [13] V. \nKoutavas and M. Wand. Small bisimulations for reasoning about higher-order imperative programs. In Proc. \n33rd ACM Symposium on Principles of Programming Languages, pages 141 152, 2006. [14] J. Laird. Full abstraction \nfor functional languages with control. In Proc. 12th Annual IEEE Symposium on Logic in Computer Science, \npages 58 67, 1997. [15] P. J. Landin. The mechanical evaluation of expressions. The Computer Journal, \n6(4):308 320, 1964. [16] S. B. Lassen. Bisimulation up to context for imperative lambda calculus. Unpublished \nnote. Presented at The Semantic Challenge of Object-Oriented Programming, Schloss Dagstuhl, 1998. [17] \nS. B. Lassen. Relational reasoning about contexts. In Gordon and Pitts [11], pages 91 135. [18] S. B. \nLassen. Bisimulation in untyped lambda calculus: B\u00a8ohm trees and bisimulation up to context. In MFPS \nXV, volume 20 of Electronic Notes in Theoretical Computer Science, pages 346 374. Elsevier, 1999. [19] \nS. B. Lassen. Eager normal form bisimulation. In Proc. 20th Annual IEEE Symposium on Logic in Computer \nScience, pages 345 354, 2005. [20] S. B. Lassen. Normal form simulation for McCarty s amb. In MFPS XXI, \nvolume 155 of Electronic Notes in Theoretical Computer Science, pages 445 465. Elsevier, 2005. [21] S. \nB. Lassen. Head normal form bisimulation for pairs and the .\u00b5\u00adcalculus (extended abstract). In Proc. \n21th Annual IEEE Symposium on Logic in Computer Science, 2006. [22] P. B. Levy. Game semantics using \nfunction inventories. Talk given at Geometry of Computation 2006, Marseille, 2006. [23] I. A. Mason and \nC. L. Talcott. Equivalence in functional languages with effects. Journal of Functional Programming, 1(3):297 \n327, 1991. [24] M. Merro and C. Biasi. On the observational theory of the CPS-calculus (extended abstract). \nIn Proc. 22nd Conference on Mathematical Foundations of Programming Semantics, volume 158 of Electronic \nNotes in Theoretical Computer Science, pages 307 330. Elsevier, 2006. [25] A. R. Meyer and K. Sieber. \nTowards fully abstract semantics for local variables: Preliminary report. In Proc. 15th ACM Symposium \non Principles of Programming Languages, San Diego, CA, 1988. [26] M. Parigot. .\u00b5-calculus: An algorithmic \ninterpretation of classical natural deduction. In A. Voronkov, editor, Proceedings Intl. Conf. on Logic \nProgramming and Automated Reasoning, LPAR 92, St Petersburg, volume 624 of Lecture Notes in Computer \nScience, pages 190 201. Springer-Verlag, 1992. [27] R. P. Perez. An extensional partial combinatory algebra \nbased on .-terms. In A. Tarlecki, editor, Proc. Mathematical Foundations of Computer Science, volume \n520 of Lecture Notes in Computer Science, pages 387 396. Springer-Verlag, 1991. [28] A. M. Pitts. Reasoning \nabout local variables with operationally-based logical relations. In P. W. O Hearn and R. D. Tennent, \neditors, Algol-Like Languages, volume 2, chapter 17, pages 173 193. Birkhauser, 1997. Reprinted from \nProceedings Eleventh Annual IEEE Symposium on Logic in Computer Science, 1996, pp 152 163. [29] A. M. \nPitts and I. D. B. Stark. Operational reasoning for functions with local state. In Gordon and Pitts [11], \npages 227 273. [30] E. Ritter and A. M. Pitts. A fully abstract translation between a .-calculus with \nreference types and Standard ML. In Proc. 2nd International Conference on Typed Lambda Calculus and Applications, \nEdinburgh, volume 902 of Lecture Notes in Computer Science. Springer-Verlag, 1995. [31] D. Sangiorgi. \nThe lazy lambda calculus in a concurrency scenario. Information and Computation, 111(1):120 153, 1994. \n[32] E. Sumii and B. C. Pierce. A bisimulation for type abstraction and recursion. In Proc. 32nd ACM \nSymposium on Principles of Programming Languages, pages 63 74, 2005. [33] C. Talcott. Reasoning about \nfunctions with effects. In Gordon and Pitts [11], pages 347 390. [34] M. Wand and G. T. Sullivan. Denotational \nsemantics using an operationally-based term model. In Proc. 24th ACM Symposium on Principles of Programming \nLanguages, pages 386 399, 1997.  \n\t\t\t", "proc_id": "1190216", "abstract": "We present a new co-inductive syntactic theory, <i>eager normal form bisimilarity</i>, for the untyped call-by-value lambda calculus extended with continuations and mutable references.We demonstrate that the associated bisimulation proof principle is easy to use and that it is a powerful tool for proving equivalences between recursive imperative higher-order programs.The theory is modular in the sense that eager normal form bisimilarity for each of the calculi extended with continuations and/or mutable references is a fully abstract extension of eager normal form bisimilarity for its sub-calculi. For each calculus, we prove that eager normal form bisimilarity is a congruence and is sound with respect to contextual equivalence. Furthermore, for the calculus with both continuations and mutable references, we show that eager normal form bisimilarity is complete: it coincides with contextual equivalence.", "authors": [{"name": "Kristian St&#248;vring", "author_profile_id": "81318496592", "affiliation": "University of Aarhus", "person_id": "P808408", "email_address": "", "orcid_id": ""}, {"name": "Soren B. Lassen", "author_profile_id": "81100346797", "affiliation": "Google, Inc.", "person_id": "P423418", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190244", "year": "2007", "article_id": "1190244", "conference": "POPL", "title": "A complete, co-inductive syntactic theory of sequential control and state", "url": "http://dl.acm.org/citation.cfm?id=1190244"}