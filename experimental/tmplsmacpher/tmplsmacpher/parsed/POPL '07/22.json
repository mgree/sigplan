{"article_publication_date": "01-17-2007", "fulltext": "\n Extracting Queries by Static Analysis of Transparent Persistence* Ben Wiedermann and William R. Cook \nDepartment of Computer Sciences, The University of Texas at Austin {ben,wcook}@cs.utexas.edu Abstract \nTransparent persistence promises to integrate programming lan\u00adguages and databases by allowing procedural \nprograms to access persistent data with the same ease as non-persistent data. When the data is stored \nin a relational database, however, transparent persis\u00adtence does not naturally leverage the performance \nbene.ts of rela\u00adtional query optimization. We present a program analysis that com\u00adbines the bene.ts of \nboth approaches by extracting database queries from programs with transparent access to persistent data. \nThe anal\u00adysis uses a sound abstract interpretation of the original program to approximate the data traversal \npaths in the program and the condi\u00adtions under which the paths are used. The resulting paths are then \nconverted into a query, and the program is simpli.ed by remov\u00ading redundant tests. We study an imperative \nkernel language with read-only access to persistent data and identify the conditions under which the \ntransformations can be applied. This analysis approach promises to combine the software engineering bene.ts \nof trans\u00adparent data persistence with the performance bene.ts of database query optimization. Categories \nand Subject Descriptors D.3.4 [Programming Lan\u00adguages]: Processors; H.2.3 [Database Management]: Languages \nGeneral Terms Languages, Performance Keywords Programming Languages, Databases, Static Analysis 1. Introduction \nThe effective integration of programming languages and databases is a long-standing and critical open \nproblem. From a programming language viewpoint, databases manage persistent data, which has a lifetime \nlonger than the execution of an individual program. Ideally a uni.ed programming model should be applicable \nto both persis\u00adtent and non-persistent data. This goal has been pursued for the last 30 years in numerous \nforms, including orthogonal persistence [2, 3, 4, 25, 30], object-relational mapping [16, 22, 28, 34], \nand object-oriented databases [12, 15, 27]. Despite differences in par\u00adticular details, these approaches \nall share the goal of transparent persistence a programming paradigm wherein the programmer need not \ndistinguish between persistent and non-persistent values. Transparent persistence can be added to most \nany language by extending the concepts of automatic memory management and * This work was supported by \nthe National Science Foundation under Grant No. 0448128. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright \nc . 2007 ACM 1-59593-575-4/07/0001. . . $5.00. for (Employee e : root.employees) {if (e. salary > 65000) \n{print(e.name + \": \" + e.manager.name); }} Figure 1. A program using transparent persistence. // de.ne \nan explicit query String query = from Employee e left join fetch e.manager where e. salary > 65000 ; \n// execute the query List result = executeQuery(query); for (Employee e : result . list ()) { // no test \nrequired : all elements already satisfy // the condition salary > 65000 print(e.name + \": \" + e.manager.name); \n} Figure 2. Explicit query execution using Hibernate. garbage collection to the management of persistent \ndata: by iden\u00adtifying a persistent root object, any object or value reachable from the root is also persistent \n[4]. For example, the Java program in Fig. 1 manipulates a collection of employee objects associated \nwith a root object. If root identi.es a persistent store of objects, then the employee objects may be \nloaded from that store. However, the pro\u00adgram s result is independent of whether root is persistent or \nnot. This kind of transparent persistence does not easily leverage the power of database query optimization. \nDatabase optimizations work best when records are loaded in bulk and conditions for se\u00adlecting records \nare executed in the database rather than the proce\u00addural program. The mismatch between one-at-a-time \nprocessing in procedural language and bulk data processing in query operations is called impedance mismatch \n[26]. To solve this problem, many persistence models allow programmers to execute explicit queries. For \nexample, Fig. 2 uses Hibernate, an object-relational mapping tool, and its query language HQL [22] to \nexecute an explicit query. The executeQuery method is a (unspeci.ed) helper function that hides some \nof the details of executing a query with Hibernate. The query returns only employees with salary greater \nthan $65,000; the prefetch clause left join fetch e.manager indicates that each employee s manager should \nalso be loaded. The if statement in Fig. 1 is not needed in Fig. 2 because the query s where clause ensures \nthe query only returns employees for which the test is true. Although the programs in Fig. 1 and Fig. \n2 print the same re\u00adsults, they have different performance and software engineering bene.ts. In the transparent \npersistence version, all employees will be loaded even though only those with salary greater than $65,000 \nare printed. Manager objects will be loaded individually, because the persistence layer cannot predict \nwhich ones will be needed. In the Hibernate version, the underlying relational query optimizer will likely \nuse an index to locate all employees whose salary is greater than $65,000. The optimized version runs \nin time propor\u00adtional to the size of the query result, rather than the total number of employees and \nmay be orders of magnitude faster [9]. Despite its performance bene.ts, there are some drawbacks to the \nHibernate version. Query strings are not checked at compile time for syntax or type safety, and they \nreduce modularity and in\u00adcrease the complexity of programming. Proposals to address these problems [7, \n11, 20] either reduce or do not address the trans\u00adparency of persistence. There is also a subtle dependency \nbetween the query and the code: the prefetch clause is logically redundant with the use of the employee \ns manager in the print method. This paper describes a static analysis technique that allows a programming \nlanguage with transparent persistence to leverage the power of query optimization. Our approach automatically \npartitions programs by extracting data traversals and conditions into a query, and removing them from \nthe program essentially transforming the program in Fig. 1 into the program in Fig. 2. This transfor\u00admation \nrequires that the extracted query return a structural subset of the original database. The analysis creates \nqueries written in a subset of the Object Query Language (OQL) [8] that can express these kinds of queries. \nOur analysis consists of three parts. The .rst part (Section 3) identi.es the traversals used in the \nprogram; these traversals spec\u00adify the data that must be loaded by the query. The second part (Sec\u00adtion \n4) identi.es the conditions under which data is used, so that the conditions can be included in the query. \nIn the .nal part (Sec\u00adtion 5) the individual conditions on the use of .elds are promoted to apply to \nentire records, and a query is created. This .nal step also modi.es the program to use the results of \nthe query, and eliminates redundant if statements. The primary contribution of this paper is a new approach \nto optimization of transparent persistence by extracting queries from imperative programs. This result \nis based on a sound abstract in\u00adterpretation of programs, together with techniques for converting the \nresulting abstract values into queries and simplifying the orig\u00adinal program. We have developed a prototype \nimplementation of the analysis and applied it to simple examples to demonstrate its viability. While \nthis work re-opens an important line of research, there are many topics left to future work. In particular, \nwe have not analyzed the performance of the analysis or the transformed programs although the performance \ngains from query optimiza\u00adtion are well-known. We have not applied the analysis to large programs with \nprocedures, or addressed the problem of identify\u00ading where in a large program the analysis should be \napplied. Com\u00adplex query behaviors, like aggregation, exists queries, and database mutations (creations, \nupdates, and deletions) are not considered. We expect that the current work will serve as a solid foundation \nfor ongoing work on these problems, with the goal of combining the software engineering bene.ts of transparent \npersistence and the performance bene.ts of query optimization.  2. A Kernel Language with Persistent \nData We study a simple imperative language with records and access to persistent data. The persistent \ndata is an instance of an Entity-Relationship (ER) Model [10], which provides natural mappings to both \nrelational databases [5] and class models in UML/object\u00adoriented programming [37]. A persistent value \nis a record, or la\u00adbeled product, whose .elds are either basic values or references to other records \n(these are called attributes and relationships in an ER model). A reference/relationship .eld may be \neither single\u00advalued or multi-valued. Multi-valued relationships correspond to collection objects in \nobject-oriented programming. The language expresses key concepts in practical orthogonally persistent \nobject\u00ad l .Variable f .Field e .Expression ::= l |e.f |opn(e1,...,en) op0 .Constant ::= true |false \n|number |string op1 ::= \u00ac|print op2 ::= .| . | > | < | = |= |= | = c .Command ::= skip |l := e |c; c \n| if e then c [else c] | for l in e do c Figure 3. Syntax of a persistent data kernel language. employees \n .. . manager manager manager salary name salary name salary name Figure 4. An object graph example. \n oriented languages, but it also has several restrictions. Only the structural representation of data \nis considered, not behavioral meth\u00adods, and the language contains no procedures. We do not model the \nthree-valued logic of null values that is used in SQL, but as\u00adsume that a value is de.ned for every persistent \nelement a program accesses. While the language supports imperative update of local variables, persistent \ndata is read-only. We believe these restrictions to be reasonable, as the current work is designed to \nintroduce a technique for extracting procedural queries. Section 7 discusses ex\u00adtensions to support interprocedural \nanalysis, analysis of more com\u00adplicated query idioms, and creation, update, or deletion of persis\u00adtent \ndata. 2.1 Syntax The abstract syntax of the kernel language is de.ned in Fig. 3. The traversal expression \ne.f projects a .eld f of a record e.The value of e.f can be a simple value, or references to one or more \nrecords. Persistent data is introduced through a special root variable that refers to a record representing \npersistent data [4]. Any value that is reachable from the root is also persistent. As mentioned above, \nno constructs create or modify persistent records; all records are loaded from the persistent store. \nPrimitive functions opn have a speci.ed number of arguments n. In.x notation is used where appropriate. \nThe for command allows iteration over the elements of a collec\u00adtion. For simplicity, iteration is supported \nonly for multi-valued re\u00adlationship .elds that is, collections of persistent objects. The lan\u00adguage could \neasily be extended to allow iteration of non-persistent collections or basic values. A simple static \ntype system for records is assumed for this language [32]; programs are assumed to be well typed. 2.2 \nValues A program operates over the domain: v .Value = Basic + RecordID + RecordID * (l,s).s[l] (S-VAR) \n(e,s).v (l:=e,s).[l .v]s (S-ASSIGN) (skip,s).s (S-SKIP) (e,s).r (e.f,s).Load (r,f) (S-TRAVERSE) (e,s).true \n(c1,s).s' (if ethen c1 else c2,s).s' (S-IFT) (ei,s).vi for i.{1,...,n}(opn(e1,...,en),s).fopn(v1,...,vn) \n(S-OP) (e,s).false (c2,s).s' (if ethen c1 else c2,s).s' (S-IFF) (c1,s).s' (c2,s').s'' (c1; c2,s).s'' \n(S-SEQ) (e,s).{r1,...,rn}(c,[l .ri]si).si+1 for i.{1,...,n}(for lin edo c,s1).sn+1\\l (S-FOR) Figure \n5. Operational semantics of the kernel language. where Basic is the domain of basic values (integers, \nBooleans, and strings), and RecordID is the domain of record identi.ers that reference persistent database \nvalues. When a program traverses a record identi.er, a runtime function Load :: RecordID \u00d7Field . Value \nretrieves the corresponding record s .eld value(s). A special record identi.er r0 corresponds to the \npersistent store s root, and the store s structure is the graph formed by the transitive closure of traversals \nfrom r0. Figure 4 illustrates a persistent object graph, against which the program in Fig. 1 can be evaluated. \nThe graph s solid dot denotes a collection of record identi.ers, where the target of each outgoing edge \nis a member of the collection. Each of these edges is implicitly labeled with an iterator .eld name ., \nwhich identi.es distinct elements of the collection.  2.3 Semantics Figure 5 de.nes a big-step operational \nsemantics for the kernel lan\u00adguage. A store smaps variables to values. The evaluation relations for expressions \n(e,s).v and commands (c,s). s' follow standard form. All programs begin computation with a store s0 that \nmaps the variable root to the persistent value r0. Rule S-VAR retrieves a variable s value from the store. \nFor op\u00aderations, rule S-OP evaluates the operands, then applies the opera\u00adtor s function to the result. \nThe functions ftrue,f\u00ac,f<,etc., have the standard mathematical meanings. Note that these functions are \nde.ned so that they return only primitive values, not record identi\u00ad.ers. Rules S-SKIP,S-ASSIGN,S-SEQ,S-IFTand \nS-IFFare stan\u00addard. The expression [l .v]s denotes supdated so that s[l]= v. Rule S-TRAVERSE loads persistent \ndata. If expression eevalu\u00adates to the record identi.er r, then the expression e.f evaluates to the result \nof calling Load (r,f). Rule S-FOR de.nes iteration over a collection of record iden\u00adti.ers. For each \nrecord identi.er ri in the collection, the for com\u00admand s body c is evaluated in a new store si that \nmaps the loop variable l to record identi.er ri. The result of the entire command is the .nal store produced \nsn+1. A loop variable is de.ned only in the loop s body, so the variable is removed from the .nal store. \nOne subtle difference between the semantics of object-oriented programming languages and relational databases \nis that program\u00adming languages assume that collections have an inherent order, whereas databases do not. \nFor our purposes, we assume a default order exists for every database collection and that programs iterate \nover collections in that order. Output from the print function is modeled by a special variable output;the \nprint function simply concatenates onto the end of this variable. Evaluating the example program in \nFig. 1 against the persistent data in Fig. 4 generates a .nal store with the following mappings: root \n Cathy : Cathy .r0, output.  2.4 Operational Semantics with Explicit Used-Set Our analysis summarizes \nthe set of persistent values a program uses. These values which we refer to as the program s used-set \ncan then be loaded in bulk before the program needs them. The operational semantics of the base language \nis extended in Fig. 6 to keep track of a computation s used-set. The modi.ed semantics has evaluation \nrelations (e,s).(v,.)and (c,s).(s,.)where . is the set of database values that were loaded during the \nentire computation. S-TRAVERSE is the only rule that loads database values, so the rule adds the newly \nloaded values .f to the set. All other rules are modi.ed to collect the loaded values for  any sub-computation, \nwhere.i is shorthand for.i. i.{1,...,n} Evaluating our running example with the extended semantics gen\u00aderates \nthe following set of database values: {r0,r1,50000,r2,60000,r3,70000, Cathy }  3. Analyzing Traversals \nTraversal analysis is an abstract interpretation [13] of the op\u00aderational semantics in which database \nvalues are replaced by paths. The path corresponding to a database value is the se\u00adquence of .eld names \ntraversed to load that value. Note that many database values may have the same path; for example, in \nFig. 4 the paths to record identi.ers r1, r2,and r3 are identical. Many paths may lead to the same database \nvalue; for example, the value Bob can be reached by following either employees...name or employees...manager.name. \nAbstract interpretation uses abstraction and concretization func\u00adtions to specify the relationship between \nabstract and concrete val\u00adues. Given an abstract path, its concretization is the set of database values \nthat can be reached by following the path. If the path in\u00adcludes a collection .eld, the concretized result \nincludes all the traversals of items in the collection. Thus concretization corre\u00adsponds to interpreting \nthe path as a query against the database. The analysis is conservative and sound, so that the concretiza\u00adtion \nof a path may return a larger set of database values than the concrete execution of the program actually \nloads. However, be\u00adcause a program typically operates over a small subset of a large database, the amount \nof data represented by the concretized paths should be small relative to the overall database size. Soundness \njus\u00adti.es bulk loading of data before executing the program; precision gives better performance. The \nanalysis in this section uses a loose (l,s).(s[l],\u00d8) (U-VAR) (e,s).(v,.e) (U-ASSIGN) (l:=e,s).([l .v]s,.e) \n(skip,s).(s,\u00d8) (U-SKIP) ' (e,s).(true,.e)(c1,s).(s ,.c) (e,s).(r,.e) (U-IFT) (if ethen c1 else c2,s).(s \n' ,.e ..c) .f = Load (r,f) (U-TRAVERSE) (e.f,s).(.f ,.e ..f ) (e,s).(false,.e)(c2,s).(s ' ,.c) (U-IFF) \n (ei,s).(vi,.i) for i .{1,...,n}(if ethen c1 else c2,s).(s ' ,.e ..c) (U-OP) (op(e1,...,en),s).(fop(v1,...,vn),..i) \nnn (e,s).({r1,...,rn},.1)(c,[l .ri]si).(si+1,.i+1) for i .{1,...,n} (c1,s).(s ' ,.1)(c2,s ' ).(s '' \n,.2) (U-FOR) (U-SEQ) (for lin edo c,s1).(sn+1\\l,..i)(c1; c2,s).(s '' ,.1 ..2) Figure 6. Operational semantics, \nextended to collect used-sets. (l,s ) s[l],\u00d8) .( (A-VAR) (e, .(pe,p) s) T ft .pe pf = (e, .( s) v,p) \n {p.ft |p.pe} otherwise (A-ASSIGN)(A-TRAVERSE) (l:=e, .([l . s,p) s) v] U (e.ft , .(pf ,pUpf ) s) (e, \n.(pe,p) s) (ei, .( for i.{1,...,n} s) vi,pi) (A-OP) p. = {p..l |p.pe}(opn(e1,...,es) ,( ' ,p ' )= {(do(c,l,p.))ns,\u00d8) \n|n.N } n), .(Tpi) s ( (A-FOR) (for lin edo c,s ) s ' ) .( ' \\l,pUp. Up (e, .( e) s) v,p (c1, .( (s) \ns2,p2) ' s) s1,p1) c2, .( ' ) (A-IF) (c,[l .p.] U .( ,p s) s (if ethen c1 else c2,s ) s1 U e Up1 Up2)'' \n(A-DO) .( s2,pdo(c,l,p.)( s,p)= ( s ,pUp ) Figure 7. Path-based abstract interpretation for approximating \nused-sets. approximation, but serves as a useful foundation for the more pre\u00adcise analysis in Section \n4. 3.1 Abstract Value Domain The abstract value domain is v .V where P is the powerset operator and \nPath is the set of paths a program can traverse. This version of the analysis focuses only on paths; \nall non-path values (e.g., constants) are abstracted away as T. The domain forms a potentially in.nite, \ncomplete lattice or\u00addered by the subset relation (.). To ensure that the analysis ter\u00adminates, we force \nthe lattice to be .nite by restricting Path tobe a .nite subset of the all possible sequences of .elds \nField *. One pos\u00adsible .nite subset is the set of paths in which each .eld name occurs at most once any \nother paths would be abstracted as T. With this domain, the expression root.manager.manager would be \nassigned abstract value T, even though it is a .nite path. On the other hand, in the following program \nx should be assigned value T, because it produces a path of unbounded length: Value = P(Path)+ T for \nemployee in root .employees do x := x.manager; Note that this program is not very useful because there \nis usually not a meaningful relationship between the number of employees in a list and the depth of a \nmanager traversal. To distinguish these cases, we create the domain Path by label\u00ading each .eld in the \nprogram, and considering all paths in which each labeled .eld occurs at most once. With labels, the .rst \nexpres\u00adsion root.manager1 .manager 2 has a .nite path, but x in the exam\u00adple above would still be assigned \nabstract value T. More expressive abstractions for representing in.nite paths would certainly be use\u00adful, \nfor example in the analysis of recursive procedures. Section 6 discusses a more sophisticated alternative; \nhowever, such abstrac\u00adtions are beyond the scope of the current work. 3.2 Abstract Semantics for Traversals \nThe operational semantics in Fig. 7 computes the paths a program may traverse. For brevity we omit the \nrules A-SKIP and A-SEQ, which merely collect values and paths for subcomputations. The abstract semantics \nhas evaluation relations for expressions (e, .( c, .( ' ,p),where s) v,p)and commands (s) sv is an ab\u00adstract \nvalue, s maps variables to abstract values, and pis the set of paths traversed by a computation. Rule \nA-TRAVERSE de.nes how .eld traversal extends a path. In evaluating e.ft,if e yields the set of paths \npe then the result of the traversal extends each path in pe with the labeled .eld ft . The traversal \nrule also includes a widening clause to ensure the analysis converges. If the .eld label t already appears \nin one of the paths that emay traverse, then the program traverses an invalid path in the sense described \nby Section 3.1. In this case, the analysis approximates the expression s traversals with T. Rule A-OP \ngives T as the abstract value for any operation, because the analysis ignores basic values. In Section \n4 we extend the analysis to include abstractions for basic values. Rule A-IF combines the paths traversed \nin evaluating the con\u00addition and the two command branches of an if statement. The join s 1 Us 2 of two \nmaps s 1 and s 2 is a map that includes all elements of both maps: ( s1 Us 2)[l]= s 1[l] Us 2[l] If s \ni is not de.ned for l,then s i[l]= \u00d8. Rule A-VAR retrieves a variable s abstract value from the store \nand does not generate any new paths. Rule A-ASSIGN describes how a program binds a variable to an abstract \nvalue. To ensure soundness, the store maintains a may-be\u00adbound-to relationship between variables and \nabstract values. Thus the binding operation is a join, rather than an overwrite. Rule A-FOR evaluates \nthe expression e to determine the paths pe representing the possible collections to be iterated. The \nrule generates a set of possible paths p. to which the loop variable may refer by appending to pe the \niterator .eld name .l.These loop variable paths stand for a particular element of the collection. Thus, \nif the path to the collection is f1.f2 and the collection s elements each has a .eld f3, then the path \nto one of the element s f3 .eld is f1.f2..l.f3. Each collection iteration (for loop) that appears in \na program has a unique iterator .eld name .l,where l is the corresponding loop variable. Iterator .eld \nnames are used in transforming the analysis results into a query, as discussed in Section 5. The analysis \napproximates the loop body s concrete behavior by taking the transitive closure of abstractly executing \nthe loop an arbitrary number of times. This value is the least upper bound of a function do that is specialized \nfor a given command c, loop variable l, and set of loop variable paths p.. The function takes an initial \nstore s and set of paths p and evaluates c under an updated store that maps l to p. to yield a new store \ns ' and a new set of paths p ' . The result of the function is s ' and the combined path set p Up ' . \nThe abstract evaluation of our running example generates a .nal store with the following mappings: root \n.{E}, output .T and generates the following set of paths: { E, employees, employees..e , employees..e \n.salary, employees..e .name, employees..e .manager, employees..e .manager.name }  3.3 Soundness The \nanalysis is sound if it safely approximates the values a pro\u00adgram loads. If the database stores a set \nof values V ,and if exe\u00adcuting a program causes the set of persistent values . . V to be loaded, then \nthe analysis should describe a set of values . such that . .. .V . We formalize this relation between \nconcrete and ab\u00adstract values and show that the operational semantics preserves the relation. The set \nof concrete values described by an abstract path is the set of values reachable by following that path \nfrom the root. We can formalize this description by lifting the de.nition of Load to operate on paths: \nLoad (r, E)= {r} (P-LOAD1) Load (r, f)= {r1,...,rn} (P-LOAD2) Load (r, f.p)= Load (ri,p) Load (r, .l \n.p)= Load (r, p) (P-LOAD3) Rule P-LOAD1 states that traversing an empty path from record identi.er r \nyields the set containing r.Rule P-LOAD2 loads one level of the traversal hierarchy, then recursively \nloads the remainder of the hierarchy. Rule P-LOAD3 removes an iterator .eld name from a path, essentially \nbinding the name to record identi.er r. A set of paths p safely approximates a set of values . if the \nset of values reachable by following all paths in p is a superset of .: . Rp . . .Load (r0,p) p.p For \nour running example, p.p Load (r0,p)= { r0, r1, 50000, Adam , r2, 60000, Bob , r3, 70000, Cathy } which \nsafely approximates the concrete results. The abstract domain consists of sets of paths and T, so we \nlift R to relate a concrete value v to an abstract value v as follows: {{vv v v}R = r, = p v Rv .v Rv \nv = {r1,...,rn},v = p { true v = T The .rst two cases relate record identi.ers and paths, as above. \nThe .nal case states that Talways safely approximates a basic program value. We lift R to relate stores \nas follows: s Rs ..x .Dom(s) nDom( s).s[x] Rs [x] By these de.nitions, the initial stores are compatible, \nin that the initial abstract store safely approximates the initial concrete store. We de.ne an ordering \non abstract stores as follows: s 1 .s 2 . Dom( s1) .Dom( s2) ..x .Dom( s1) nDom( s2).s 1[x] .s 2[x] \nThe abstract semantics rules must be monotone with respect to this ordering, to ensure .xpoint convergence. \nConceptually, the rules monotonicity is evident because the rules never discard a path, assign the value \nTto non-path-based expressions, and combine the results of variable assignment. A standard induction \nover the rules in Fig. 7 formalizes this argument; for brevity, we omit its details. Theorem 1 (Soundness \nof expression evaluation). For all s, s , e, (e, s).(v, .)(e, v, p) s R s).( s (v, .) R( v, p) Proof. \nThe proof is a straightforward induction on the structure of e. The only interesting case is for rule \nA-TRAVERSE,when therulegives pf = {p.ft |p . pe},where pe are the paths e traverses. In this case, the \ninduction hypothesis states that the subexpression paths pe relate to database values .e.A simple inductive \nargument on P-LOAD guarantees that the extended paths pf safely approximate the values the program loads \nby traversing .eld f for each value in .e. Theorem 2 (Soundness of command evaluation). For all s, s \n, c, (c, s).(s ' ,.)(c, s ).(s ' ,p) s Rs (s ' ,.) R( s ' ,p) Proof. By induction on the structure of \nc.Rule A-ASSIGN com\u00adputes a safe approximation of the store by joining stores. Rule A-IF computes a safe \napproximation of the program behavior by com\u00adbining the results of the statement s two branches. The \nproof of soundness for rule A-FOR makes the natural reliance on the .nite domain lattice and the monotonicity \nof the abstract semantics rules to ensure the existence of a safe .xpoint. The analysis in this section \nis quite imprecise and can there\u00adfore lead to an excessive over-approximation of the database val\u00adues \na program requires. For example, the analysis conservatively estimates that the program in Fig. 1 needs \nthe name .eld for every employee even though the program traverses the name .eld only if the employee \ns salary is greater than $65,000.  4. Analyzing Traversal Conditions The precision of the analysis \ncan be signi.cantly increased by con\u00adsidering the conditions under which a program traverses data paths. \nIf a program condition can be expressed in a query language, then the analysis can incorporate that condition \nin the traversal sum\u00admary. In this section we describe a class of program conditions expressible in our \nchosen query language, OQL. We discuss how traversals affect program data dependences, which inform the \nanal\u00adysis of persistent values the program must load. We then show how to extend the analysis to handle \nquery conditions and data depen\u00addence, and we prove the extension s soundness. 4.1 Query Conditions \nA query condition is a conditional program expression that can be expressed as part of an explicit query \nand evaluated by a database. Not all program conditions are query conditions. For example, if a program \ncondition contains an operation that the database cannot evaluate (e.g., a test for the presence of a \nlocal .le), then the program condition cannot be expressed in a query. Thus, the database must be able \nto evaluate all operations that appear in the condition. The database evaluation should produce the same \nresult as program evaluation. Databases typically only allow conditions that operate on indi\u00advidual records \nof a collection; for example, the select operator in relational algebra evaluates a condition separately \nfor each tuple in a relation. A program condition can introduce a relation between two different collection \nelements through either: 1) a loop-carried dependence [1] or 2) multiple iterations over the same collection. \nIf a program condition contains a loop-carried dependence, then that condition depends upon two values \nfrom the same collection and is therefore not a query condition. A loop-carried dependence occurs when \nthe evaluation of an expression in a loop depends upon variables assigned in previous iterations of a \nloop. Figure 8 (a) and (b) contain examples, where the notation C[l ] means that condition C can depend \nupon variable l. The condition in (a) is a query condition because x is rede.ned in each iteration of \nthe loop. The condition in (b) is not because x has a loop-carried dependence. Aggregations (counts or \nsums) necessarily involve a loop\u00adcarried dependence; however, these aggregations are typically not used \nin conditions inside the loop. Note that the current analy\u00adsis does not convert aggregations into queries, \nbut leaves them as procedural code. If a program condition depends on loop variables from different iterations \nof the same collection, then it is not a query condition. If a program condition depends only on the \nloop variable for the iteration in which the condition appears, then that condition s paths are distinct. \nBoth conditions of example (c) have distinct paths and are query conditions. Condition C2 of example \n(d) is not a query condition, because it depends on a loop variable bound in a different iteration. Note \nthat the subset of OQL the analysis employs can return only one collection for path p, so the conditions \nfrom example (b) would be merged in the query as C1.C2. The requirements that a query condition contain \ndistinct paths and be free of loop-carried dependences means that query condi\u00adtions can refer to no more \nthan one element from a given collection. These requirements are related to the requirements for parallelizing \ncode in a parallelizing compiler [1, 33]. for l 1 in p for l 1 in p x:=E[l1] x:=E[l1]+x if C[l1,x] then \nS if C[l1,x] then S (a) C is a query condition (b) C is not a query condition for l 1 in p for l 1 in \np if C1[l1]then if C1[l1]then S1 x:=e[l1]for l 2 in p for l 2 in p if C2[l2]then S2 if C2[l2,x] then \nS (c) C1,2 are query conditions (d) C2 is not a query condition for l 1 in p for l 1 in p1 for l2 in \nl1.f for l 2 in p2 if C[l1,l2]then S if C[l1,l2]thenS (e) C is a query condition (f) C is not a query \ncondition Figure 8. Examples of conditions and iterations. A query condition may contain paths that \nrefer to elements of more than one collection. However, those elements must be structurally related in \nthe database, because the analysis creates a query whose structure mirrors the database. Thus a program \ncondition that appears in a nested iteration is a query condition only if each nested loop iterates over \na path that extends the path of its outer loop(s). Example (e) is a query condition because the expression \ndepends only on paths that satisfy this requirement. Example (f) is not a query condition because the \ninner loop does not extend the path of the outer loop. Although these requirements restrict the program \nconditions that may characterize data traversals, we believe these restrictions support common programming \nidioms used in data-intensive ap\u00adplications. A more powerful query translation could support even more \ncomplex conditions. 4.2 Data Dependences A program s data dependences [1] provide information about \nwhich persistent values the program must retrieve. If a persistent value affects the contents of the \n.nal store, the program must retrieve that value. Assignment statements introduce data dependences, because \nany assigned value may affect the contents of the .nal store. Loop variables, however, do not directly \ninduce a data dependence on the .nal store, because these variables are removed from the store after \nthe loop terminates. Program conditions also do not introduce data dependence, because conditional expressions \ncannot modify the store. We extend our analysis to collect information about which paths induce data \ndependences. The query creation algorithm in Section 5 uses this information to ensure retrieval of all \nvalues represented by data-dependent paths. 4.3 Domains for Paths with Conditions A conditional path \np[k] represents a query of the database for values located at path p for which the condition k is true. \nThe condition is expressed as an operation on abstract values, including other paths. The domain of abstract \nvalues is extended to include conditions: k . Condition ::= op t n( v1,..., vn) cp . CPath v . V Value \n::= ::= p[k] | p[k]. P(CPath)+ P(Condition)+ T k, I '(e, s ) .(pe,p) e contains no loop-carried dependences \n T ft .pe k, I '(e, s ) v, pe) = .( pf {p.ft[k] |p .pe} ft .pe Distinct(Paths( v)) Trim(Paths( v)) .I \n(K-TRAVERSE) s) s1,p1) , .(pf ,p Upf )(k .\u00acv ),I '(c2, .( (k .v ),I '(c1, .( k, I '(e.ft s) s) s2,p2) \np ' = pe Up1 Up2 (K-IF1) k, I '(ei, .( for i .{1,...,n} s) vi,pi) k, I '(if e then c1 else c2,s ) s1 \nU t .( s2,p ' ) T opn .v i v = op t ( v1,..., v n) op t ./v i K-IF1 does not apply nn (K-OP) k, I '(c1,s \n) s1,p1) k, I '(opnt (e1,...,en), .( .( s) v, pi)k, I '(c2,s ) s2,p2) .( p ' k, I '(e, s ) = pe Up1 Up2 \n.(pe,p) (K-IF2) k, I '(if e then c1 else c2,s ) s1 U p. = {p..l |p .pe} .( s2,p ' ) I ' = Extend (I,p.) \n( ,p ' )= {(do(k, I ' ,c,l,p.))n( s, \u00d8) |n .N }k, I '(e, s ) v, p) s ' .( (K-FOR) (K-ASSIGN) k, I '(for \nl in e do c, s ) s ' \\l, p Up. Up ' ) .( k, I '(l:=e, s ) v] U .([l . s, p. UI|I|[k].) k, I '(c, [l .p.] \nUs ) ,p ' ) .(s ' .p1,p2 .p : Erase(p1)= Erase(p2) .p1 = p2 (K-DO)do(k, I, c, l, p.)( s, p)=( ,p Up \n' )s ' Distinct(p) l1 ln {p. |I|=0 \u00af\u00af\u00af Erase(f\u00af1... \u00b7\u00b7\u00b7 ...fn+1)= f1. \u00b7\u00b7\u00b7 .fn+1 Extend (I,p.)= I, p. \nPre.xes(I|I|,p.) ll { \u00af Trim(p)= {p..|p...f .p} I otherwise Paths(p)= p .p2 .p2 :(.p1 .p1, .p ' .Field \n* : p1.p ' = p2) Paths(opn( v1,...,v n)) = Paths( v1) U\u00b7\u00b7\u00b7UPaths( vn) Pre.xes(p1,p2) Figure 9. Abstract \ninterpretation with paths and conditions. A path marked p[k]. is involved in a data dependence. A non\u00adconditional \npath p is lifted to a conditional path p[true] signifying that the path is always traversed. The label \nt on an operator is analogous to .eld labels in Section 3.1. Conditions are restricted to include only \none occurrence of a labeled operator, allowing the domain CPath to be .nite.  4.4 Abstract Semantics \nfor Conditional Traversals Figure 9 extends the abstract semantics to include the condition under which \na program traverses a path. The evaluation relation k, I '(e, s ) v, p) now carries a context that consists \nof the .( condition k under which traversals may take place and the collec\u00adtion traversal list I. This \nlist represents the nesting structure of col\u00adlection traversals and is used to identify query conditions. \nThe .rst element of the list is the set of paths for the outermost loop variable, and the last element \nis the set of paths for the innermost (current) loop variable. If list I has length |I|,then I|I| denotes \nthe innermost loop variable paths. Initially k is set to true,and I is empty. Our discussion of the extended \nsemantics highlights the addi\u00adtions necessary to identify and attach query conditions, according to the \nrequirements described in Sections 4.1 and 4.2. These ad\u00additions generally either use or modify the context. \nWe omit rules K-VAR,K-SKIP,and K-SEQ because these rules only collect the results of subcomputation and \ndo not directly alter the context. Rule K-IF1 identi.es query conditions. The analysis .rst deter\u00admines \nthat e contains no loop-carried dependences. This determi\u00adnation is the result of a standard analysis; \nfor brevity, we omit its details. The premise Distinct(Paths( v)) ensures that all the paths in the condition \ns abstract value are distinct, in the sense that they do not traverse the same set of .elds with different \niteration .eld names. The analysis also checks that all the paths used in the expres\u00adsion are based \non lexically enclosing iteration paths. The function Trim applied to a set of paths p returns all possible \npaths for the inner-most loop variable. Thus, the premise Trim(Paths( v)) .I ensures that any iteration \npaths that appear in the condition s ab\u00adstract value are based on lexically enclosing iteration paths. \nThe lexically enclosing iterations needed by K-IF1 are created by K-FOR. The rule appends a new set of \npaths p. to the list of iteration paths I only if all paths in p. extend some path in I|I|,the list s \nmost recently added member. In this way, K-FOR maintains the constraint that I is a list of lexically \nenclosing iteration paths. Other than imposing this constraint on I,K-FOR is thesameas A-FOR (Fig. 7). \nQuery conditions are used in the true and false branches of the if command. Given the abstract value \nv of condition e, the true\u00adbranch body is evaluated under the condition k .v and the false\u00adbranch body \nunder the condition k .\u00acv . When the program makes a traversal, rule K-TRAVERSE attaches the condition \nk to the path generated by the traversal. If the condition does not satisfy the requirements of a query \ncondition, rule K-IF2 does not augment the paths with conditions. Rule K-ASSIGN performs assignments \nbut also marks all paths in the bound expression as having data dependences. p. means the marking of \nall paths in p with .,and I|I|[k]. means marking all paths in I|I| with condition k and .. The loop variable \npaths themselves are marked as a data dependence because the execution of any assignment can depend upon \nthe existence of an element in an iteration, even if no .elds of the loop variable are used. For example, \nin the program for x in p do y:= y +1,the variable x is never used, yet there is still a data dependence \nupon it because its elements must be enumerated. Rule K-OP de.nes the semantics of operations on abstract \nval\u00adues. The operands are evaluated and the operator is retained in the result. The rule also includes \na widening clause to ensure conver\u00adgence to a .xed-point. The rule is similar to the one for traversals: \nIf the syntactic use of the operator opn already occurs in some v i, then the expression evaluates to \nT. The abstract evaluation of our running example generates a .nal store with the following mappings: \nroot .{E}, output .{print(employees..e .name[k]+ employees..e .manager.name[k])} and the following set \nof paths: {E, employees, employees..e , employees..e .salary, employees..e .name[k], employees..e .manager[k], \nemployees..e .manager.name[k], employees..e[k]. , employees..e .name[k]. , employees..e .manager[k]. \n, employees..e .manager.name[k]. } where k is {employees..e .salary}> 65000. At this stage of the analysis, \nthe conditions apply to the .nal attributes loaded by a path. In Section 5 we further analyze the conditions \nand paths to avoid loading entire records.  4.5 Soundness Proceeding as before, we de.ne the load operation \nfor conditional paths and de.ne the relations between concrete and abstract do\u00admains. We then prove that \nevaluation preserves these relations. This proof relies on the previous soundness proof (Section 3.3). \nThe load operation for conditional paths is de.ned in Fig. 10. Function CLoadi loads all records reachable \nby a path p, provided the path s condition k may be true. A mapping f binds an iterator .eld name to \na speci.c record identi.er, to be referenced in the evaluation of the path s condition. CLoad1 creates \niterator .eld name bindings, and CLoad2 uses the bindings. Function eval de.nes condition evaluation. \nOperator evaluation ' calls eval on the operands and applies fopn to the results, where ' T T.{v 1,..., \nv n} fopn ( v1,..., v n)= fopn ( v1,..., v n)otherwise Note that because the underlying operators are \nmonotonic, all func\u00adtions f ' are also monotonic. Path evaluation calls CLoad2 on the path, passing bindings \nf for any iterator .eld names that appear in the path. Note that, be\u00adcause the evaluated path can appear \nonly in an operation expres\u00adsion, the result of path evaluation must be a set that contains a sin\u00adgle \nbasic value. The least upper bound operation ( ) retrieves this value from the set. Evaluating a set \nof abstract values yields the least upper bound of evaluating each value in the set. Aset p of conditional \npaths safely approximates the persistent values a program loads if it describes a superset of those values. \nWe modify the de.nitions of R to relate concrete values and conditional paths: {r} true eval(k, f) CLoadi(r, \nE[k],f)= \u00d8 otherwise CLoadi(r, f.p[k],f)= CLoadi(r ' ,p[k],f) r'.Load(r,f ) CLoad1(r, .l .p[k],f)= CLoad1(r, \np[k], [.l .r]f) CLoad2(r, .l .p[k],f)= CLoad2(f(.l),p[k],f) eval(p[k],f)=CLoad2(r0,p[k],f) ' eval(opn( \nv1 ...v n),f)= fopn (eval( vi,f),..., eval( vn,f)) eval(S, f)=eval( v, f) v .S Figure 10. Conditional \nrecord loading. . Rp . . . CLoad1(r0,p[k], \u00d8) p[k].p { {v}Rv v = r, v = p v Rv v = {r1, ..., rn},v = \np (v, s) Rv . v eval( v, fs) v .Basic,v = k { v = T otherwise s Rs ..x .Dom(s) nDom( s).(s[x],s) Rs \n[x] The relation between concrete and abstract values is de.ned only in the context of a store, because \nthe store provides a binding for any iterator .eld names that may appear in paths and conditions. When \nv is an abstract operation, evaluating v must approximate v. If L is the set of loop variables that appear \nin the entire program, fs = l.L[.l .s[l]],where s[l]= Tif s[l] is unde.ned. To prove soundness, we .rst \nshow that expression evaluation gives the same results as the analysis in Section 3.3, assuming that \nevaluating every path condition may give the value true.We then show that the analysis only constructs \nconditions that satisfy this assumption. Proof of soundness for command evaluation follows trivially. \n Lemma 1 (Subcomputation compatibility). If (.1 Rp1) and (.2 Rp2),then (.1 ..2) R(p1 Up2). Proof. If \np1 Up2 = T, then the relation trivially holds. Otherwise, by the de.nition of R, .1 . CLoad1(r0,p[k], \n\u00d8) and p[k].p1 .2 . CLoad1(r0,p[k], \u00d8). Assuming all conditions k p[k].p2 may be true, .1 ..2 . CLoad1(r0,p[k], \n\u00d8),sothe p[k].p1.p2 relation holds. Theorem 3 (Soundness of expression evaluation). For all e, s, s \n, k: (e, s).(v, .) k, I '(e, s ) v, p) .( s Rs true eval(k, fs) ((v, s),.) R( v, p) Proof. By induction \non the structure of e. Base case e =[[l]] In this case, (v, .)=(s[l], \u00d8) and ( v, p)= ( s[l], \u00d8) The \npremise s Rs gives the desired result. The induction hypothesis asserts that evaluating subexpressions \nunder condition k produces sound results. It remains to show that evaluating operators and traversals \nunder condition k produces sound results. Case e=[[op t (e1 ...en)]] If the abstract semantics gives \nv = T n for e, then this case is trivially proved. Otherwise, it must be shown that if, for each ei, \nthe concrete semantics gives (vi,.i) and the abstract semantics gives ( vi,pi), then: fopn (v1,...,vn)= \nf ' (v1,...,vn) op n eval(op( v1,...,v n),fs)= f ' (eval( vi,fs),...,eval( vn,fs)) nop n Because f ' \nis monotonic, it suf.ces to show that if (vi,s) Rv i, then vi eval( vi,fs).If vi is a basic value, then \nthe de.nition of R suf.ces. It remains to be shown that if vi is a record identi.er, {} vi CLoad2(r0,p[k],fs) \np[k].v i Because vi Rv i, there exists some paths p ' . v i such that ' '' vi . CLoad1(r0,p ,\u00d8),where \np . p . Calling CLoad1 on these paths generates of set of iterator .eld bindings F that includes fs; \ntherefore r . CLoad2(r0,p[k],fs). p[k].v Hence, the desired result that evaluating all paths in v i with \nbindings fs approximates r. Lemma 1 gives .i R pi. Case e=[[e.ft]] Rules U-TRAVERSE and K-TRAVERSE and \nthe induction hypothesis give (r,.e) R(pe,p) for the subex\u00adpression e. For the entire expression, the \nrules give .f = Load(r,f), pf = {p.ft[k] |p .pe}.If true eval(k,fs), then pf = {p.ft |p .pe}. Section \n3.3 proved soundness for this case. Lemma 1 gives (.e ..f ) R(pUpf ). Theorem 4 (Condition evaluation \napproximates true). For all s, s , conditions kproduced by the analysis: s Rs true eval(k,fs) Proof. \nBy induction on the structure of k. Base case k = true Trivial, because eval(true, )= true. The induction \nhypothesis asserts that evaluating subconditions approximates true. It remains to prove the theorem for \nany condi\u00ad tion k ' the analysis creates. Case k ' =[[k.v ]], v is a query condition In this case, the \nanaly\u00adsis attaches k ' to all paths generated by the true-branch of an if. So, it must be shown: (e,s).(true,.) \nk,I '(e, .( sRs s) v,p) true eval(k. v,fs) The induction hypothesis states true eval(k,fs),so itre\u00admains \nto show true eval( v,fs). The induction hypoth\u00adesis also enables the invocation of Theorem 3, which gives \n(true,s) Rv which is de.ned to mean true eval( v,fs). Case k ' =[[k.\u00acv ]], v is a query condition In \nthis case, the anal\u00adysis attaches k ' to all paths generated by the false-branch of an if. So, it must \nbe shown: .( (e,s).(false,.) k,I '(e,s ) v,p) sRs true eval(k.\u00ac v,fs) k={employees..e.salary} > 65000 \nFigure 11. Example query tree, with promoted conditions. Proceeding as above, Theorem 3 gives false eval( \nv,fs). Since f\u00ac' is monotonic, true .\u00aceval ( v,fs). A simple analy\u00adsis on the domain of f\u00ac' eval ( gives \n\u00acv,f)= eval(\u00acv,f),and the desired conclusion is reached. Theorem 5 (Soundness of command evaluation). \nFor all s, s , c: (c,s).(s ' ,.) k,I '(c, .( ' ,p) sRs s) s (s ' ,.) R( s ' ,p) Proof. Note that the \ntransfer functions of this extended semantics are also monotonic. Thus the proof of soundness for commands \nis similar to that of Theorem 2, with appropriate applications of Theorems 3 and 4.  5. Query Creation \nand Program Simpli.cation The results of static analysis can now be employed to partition the original \nprogram into a query and its client. The query retrieves a subset of the database on which the client \nprogram executes. In some cases, the client program may be simpli.ed by removing conditional tests that \nbecome redundant when executed on the data subset. 5.1 Query Creation Query creation proceeds as a depth-.rst \ntraversal of a program s query tree the result of combining all paths discovered by the program s query \nextraction analysis. If two paths differ only in their conditions, the combined path contains the disjunction \nof the two conditions; the disjunction represents all possible conditions under which the program could \ntraverse that path. If a data dependence marks at least one of two otherwise identical paths, the combined \npath preserves the data dependence. The preservation indicates that some program traversal of this path \ninduces a data dependence. The concretization of a query tree corresponds to running a query against \na database. In its current form, the conditions are associated with the use of individual attributes, \nyet conditionally loading an attribute is not nearly as useful as conditionally load\u00ading an entire record. \nTo avoid loading records, the conditions on individual attributes are promoted to apply to iteration \n.elds. We provide an informal argument, rather than a formal proof, for the validity of promotion. Condition \npromotion depends on the connection between individual attributes and object loading: An object does \nnot need to be loaded if none of its attributes are needed and if the object does not affect the .nal \noutcome of the program. Thus the condition for loading an object is the union (disjunction) of the conditions \nof all uses of its attributes. In this way, the conditions on attributes are promoted to be conditions \non elements of a collection. If any of the paths has the condition true, then all elements of the collection \nwill be loaded. One important point is the difference between marked and un\u00admarked paths. A marked path \np[k]. is a data dependence of the .nal state of the program store. An unmarked path for example, a path \ntraversed by a condition affects only the program s control .ow. Conditions on marked paths are promoted. \nConditions on un\u00admarked paths are ignored, because these paths do not directly affect the .nal store. \nFigure 11 contains the query tree for the running example, after condition promotion. The condition kwas \npromoted from the employee s name, manager,and manager.name .elds to be a .lter on the elements of collection \nemployees. The implicit condition true on the employee s name .eld was not promoted, because traversing \nthat .eld does not induce a data dependence. An explicit query is expressed in a variant of the Object \nQuery Language (OQL) [8]. The syntax is: q ::= struct ( f1 = q1 ,...,fn = qn) | select q from q as x \nwhere e \u00af | x.f \u00af where f names a record .eld, f is a sequence of .eld names, and x is a variable name. \nWe restrict our use of OQL to queries that return a structural subset of the original database. This \nmirrors the capabilities of commercial products like Hibernate and EJB [22, 28]. Consideration of other \nquery translations is an area for future research. Figure 12 builds an explicit query from a set of paths. \nFunction Q combines paths, promotes conditions, and outputs an explicit query. The function takes a path \npthat represents a common pre.x foraset ofsuf.x paths p; it returns a query for the elements reachable \nby following each suf.x from the given pre.x. In rule Q-PATH, the pre.x path is the query when the suf.x \npath is empty. Recall that query creation promotes conditions to be .lters on collections; thus Q-PATH \nignores conditions. The rule also ignores data dependence, because this information is used only for \nquery promotion. Rule Q-FIELDS handlesthecasewherethesuf.xesallstartwith distinct .eld names fi. The \nquery result is a struct where each .eld name is bound to a sub-query for that .eld. Each .eld name s \nquery qi is constructed by appending fi to the current pre.x. In rule Q-ITER, all suf.xes start with \nan iterator .eld name .l , and the query result selects elements of the collection to which .l refers. \nIf the suf.xes begin with different iterator .eld names, each .eld name represents a different iteration \nof the collection. In this treatment we only consider queries that mirror the structure of the database, \nso only one collection can be returned for a given multi\u00advalued .eld. Therefore the rule combines queries \nfor multiple iter\u00adations. Q-ITER promotes conditions by identifying all suf.x paths marked with a data \ndependence for which .l is the last iterator .eld name. The rule strips the conditions from these paths \nand disjoins them to create the select statement s where clause. The select statement s subquery is the \nresult of calling Qon the combined set of stripped paths and remaining paths p ' . Function T transforms \nany paths that may appear in a condition. If a path contains an iterator .eld name .l , T removes the \npre.x that appears before .l. Because this .eld name must be the last to appear in a path, it will be \nproperly scoped by the as clause of the select query. Function T also expands sets of paths that may \nappear in opera\u00adtions. Therefore T disjoins the cross-product achieved by applying the operation to each \npossible combination of operands. Q(p[k]. ,{E})=Q(p[k],{E})=p (Q-PATH) p\\E=f1.p1 .\u00b7\u00b7\u00b7.fn.pn fi distinct \nqi =Q(p.fi,pi)) (Q-FIELDS) Q(p,p)=struct (f1 =q1,...,fn =qn) p =..p ' .{.l .f\u00af1[k1].,...,.l .f\u00afn[kn].} \nf\u00af[k]. ./p ' \u00af q =Q(.l,p ' .{f\u00af1,...,fn}) c=T(k1).\u00b7\u00b7\u00b7.T(kn) Q(p,p)=select q from p as l where c (Q-ITER) \n\u00af\u00af T(p)={.l .f |p..l .f .p} . ' '' T(op(e1,...,en))= {op(e1,...,e )|ei .T(ei)} nnn Figure 12. Transforming \nconditional path sets to queries Given a set of conditional paths pextracted from a program, the query \nfor p is Q(E,p). For our running example the result is: select struct ( name = e.name, salary = e. salary \n, manager = struct (name = e.manager.name) ) from Employee as e where e. salary > 65000;  5.2 Client \nand Query Simpli.cation In the next step of the analysis, the data constraints ensured by the query are \nused to simplify the program, and consequently the data elements in the result of the query. If the program \ntests a property of the data which is guaranteed by the query, the program test can be removed. Any data \nthat is only used in such tests can then be removed from the query results. The following two rules are \nused to simplify the client program: G'v (e)G'\u00acv (e) G'(e).true G'(e).false where the context Gis a \nset of constraints on the persistent data a query returns. The constraints are obtained by taking the \ncon\u00adjunction of all the query s where clause conditions. The term v (e) refers to the abstract value \nfor eproduced by the rules of Fig. 9. If a context entails an expression s abstract value written G'v \n(e) then the expression can be re-written as true. Similarly if the con\u00adtext entails the negation of \nan expression s abstract value, the ex\u00adpression can be re-written as false. Entailment can be determined \nby a SAT solver. The rules are applied repeatedly until no more re\u00adductions are possible. Once the client \nhas been simpli.ed, a further analysis can remove trivial tests and dead code [39]. The query subsequently \ncan be simpli.ed by applying the anal\u00adysis of Fig. 9 to the new client and composing the results with \nthe original query. The composite query does not retrieve values that appear only in where clauses. The \npartition for the example pro\u00adgram in Fig. 1 is: // de.ne an explicit query String query = select struct \n( name = e.name, manager = struct (name = e.manager.name)) from Employee as e where e. salary > 65000 \n; // execute the query List result = executeQuery(query); for (Employee e : result . list ()) { // no \ntest required : all elements already satisfy // the condition print(e.name + \": \" + e.manager.name); \n} The function executeQuery queries the database and returns a new structure that contains only the data \nretrieved by the query. The query does not retrieve the employee s salary, and the program does not test \nfor that value. Instead, the query retrieves only employees whose salary is greater than $65,000.  \n6. Related Work Our path-based approach is similar to research on approximating the shape of pointer \ndata structures [17, 19, 40]. However, we limit ourselves to intraprocedural analysis and focus on the \ntraversal of read-only data structures, not mutation. Our current representation of database paths cannot \nexpress sophisticated data traversals. For example, our analysis conservatively represents as T a recursive \ntraversal of a .eld from a given root. We could use tree automata to represent paths, similar to the \nstoreless model of [14], where the database is the store. In the future, we plan to evaluate these more \nsophisticated path representations. A question open for future study is how the analysis may bene.t from \na more expressive path representation, given that few if any existing query languages can match this \nexpressivity. Vitenberg et al. describe a path-based abstract interpretation for predicting the persistent \nvalues a program may need [38]. Their ap\u00adproach supports runtime improvement of transaction lock schedul\u00ading. \nKvilekval and Singh use shape analysis to dynamically hoard (prefetch) remote data for mobile clients \n[24]. Their work reduces the effect of disconnections in mobile computing environments. Ours is a fully \nstatic approach that supports program transforma\u00adtion to bulk-load persistent data. Our analysis also \ndiffers in that it identi.es traversal conditions. Neubauer and Theimann partition a sequential program \nrun at one location into semantically equivalent, independent, distributed processes [31]. Their approach \nprovides software engineering ben\u00ade.ts similar to ours, except for multi-tier applications. A common \ntechnique for integrating programming languages and databases is to make queries .rst-class values of \na program\u00adming language. C# has been extended to incorporate relational constructs and structured data \nin middle-tier applications [7]. Willis et al. propose extensions to Java to support database-style optimiza\u00adtions \nfor operations on collections of objects [41]. Safe queries de\u00adscribe queries with classes whose instances \nare translated into a form that can be executed on a remote database [11]. Unlike our proposal, each \nof these solutions reduce persistent transparency be\u00adcause they require explicit queries to be written \nin an extended pro\u00adgramming language syntax. The DBPL language [36] and it successor Tycoon [29] explored \noptimization of search and bulk operations within the framework of orthogonal persistence. Tycoon proposed \nintegrating compiler optimization and database query optimization [18]. Queries that cross modular boundaries \nwere optimized at runtime by dynamic compilation [35]. The languages included explicit syntax for writ\u00ading \nqueries or bulk operations on either persistent or non-persistent data. Several researchers have extended \nobject persistence archi\u00adtectures to leverage traversal context access patterns, including paths to dynamically \npredict database loads and prefetch the pre\u00addicted values [6, 21, 23]. Because our work generates queries \nwhich could be used in object persistence architectures, the two tech\u00adniques could be combined to achieve \nfurther performance bene.ts.  7. Future Work While the current analysis provides a unique technique \nfor ex\u00adtracting implicit queries from imperative programs, it contains sev\u00aderal restrictions, which we \nhope to remove or diminish with future work. The imperative language we studied contains no procedures. \nWe are currently extending the analysis to analyze whole programs with behavioral methods and recursive \nprocedures. To transform complete programs, more work is needed to iden\u00adtify where the analysis should \nbe applied. Currently a new query is created each time the special variable root is used. In some cases \nit may be more ef.cient to break a query into parts, so that a result of one query becomes the root of \na nested query. Multiple queries could also be used to transform programs in which an outer loop introduces \na loop-carried dependence. The expressive power of the target query language also affects these decisions. \nOther strategies for promoting conditions may also be considered. The current work analyzes only data \nretrievals. Future work will extend this analysis to include updates to persistent data. If up\u00addates \nare performed immediately, the resulting aliasing may make it impossible to de.ne a useful transformation \nfor updates. Alter\u00adnatively, it may be possible to delay the updates until a transaction boundary, at \nwhich point all database references must be released. Employing standard static analyses (e.g., range \nanalysis) can improve the quality of the extracted queries. These analyses should also allow us to identify \nand extract aggregation and exists sub\u00adqueries. Key differences between programming languages and database \nsemantics must be overcome to successfully integrate the two do\u00admains. In this paper, we identi.ed two \nartifacts of the database domain the three-valued logic of null values and the implicit or\u00addering of \ndatabase sets that must have appropriate analogues in the programming languages domain. Finally, the \ntechnique must be applied to realistic programs to measure the performance of the analysis and effectiveness \nof the transformation. 8. Conclusion We have formalized a new approach for optimizing transparent per\u00adsistence. \nThis approach extracts a query from an imperative pro\u00adgram, then simpli.es the program to operate over \nthe bulk-load query results. This technique promises to combine the software en\u00adgineering bene.ts of \ntransparent persistence with the performance bene.ts of query optimization. We expect the current work \nto serve as a useful foundation for ongoing research into the long-standing effort to integrate programming \nlanguages and databases.  Acknowledgments We thank Jens Palsberg for advice on appropriate formalisms. \nWe thank Calvin Lin for helpful discussions. We thank David Schmidt, Kathryn McKinley, Jayadev Misra, \nMike Bond, Ben Hardekopf, Ali Ibrahim, David Kitchin, and the anonymous ICALP 2006 and POPL 2007 reviewers \nfor helpful comments on the paper. References [1] J. R. Allen and K. Kennedy. Automatic loop interchange. \nIn Proc. of the Symp. on Compiler Construction (CC), pages 233 246, 1984. [2] M. P. Atkinson. Programming \nlanguages and databases. In Proc. of the Intl. Conf. on Very Large Data Bases (VLDB), pages 408 419. \nIEEE Computer Society, 1978. [3] M. P. Atkinson, L. Dayn`es, M. J. Jordan, T. Printezis, and S. Spence. \nAn orthogonally persistent Java. SIGMOD Rec., 25(4):68 75, 1996. [4] M. P. Atkinson and R. Morrison. \nOrthogonally persistent object systems. VLDB Journal, 4(3):319 401, 1995. [5] C. Batini, S. Ceri, and \nS. B. Navathe. Conceptual Database Design -An Entity-Relationship Approach. Benjamin Cummings, 1992. \n[6] P. A.Bernstein, S.Pal,and D. Shutt. Context-based prefetch for implementing objects on relations. \nIn The VLDB Journal, pages 327 338, 1999. [7] G. M. Bierman, E. Meijer, and W. Schulte. The essence of \ndata access in c..In Proc. of the European Conference on Object-Oriented Programming (ECOOP), pages 287 \n311, 2005. [8] R.G.G.Cattell, D. K. Barry, M.Berler, J. Eastman, D. Jordan, C. Russell, O. Schadow, T. \nStanienda, and F. Velez, editors. The Object Data Standard ODMG 3.0. Morgan Kaufmann, January 2000. [9] \nS. Chaudhuri. An overview of query optimization in relational systems. In Proc. of Symp. on Principles \nof Database System (PODS), pages 34 43, 1998. [10] P. P. Chen. The entity-relationship model -toward \na uni.ed view of data. ACM Transactions on Database Systems (TODS), 1(1):9 36, 1976. [11] W. R. Cook \nand S. Rai. Safe query objects: Statically typed objects as remotely executable queries. In Proc. of \nthe Intl. Conf. on Software Engineering (ICSE), pages 97 106, 2005. [12] G. Copeland and D. Maier. Making \nsmalltalk a database system. In Proceedings of the 1984 ACM SIGMOD international conference on Management \nof data, pages 316 325. ACM Press, 1984. [13] P. Cousot and R. Cousot. Systematic design of program transforma\u00adtion \nframeworks by abstract interpretation. In Proc. of the ACM Symp. on Principles of Programming Languages \n(POPL), pages 178 190, 2002. [14] A. Deutsch. A storeless model of aliasing and its abstractions using \n.niterepresentations of right-regular equivalence relations. Computer Languages, 1992., Proceedings of \nthe 1992 International Conference on, pages 2 13, 1992. [15] O. Deux. The O2 system. Commun. ACM, 34(10):34 \n48, 1991. [16] J.-A. Dub, R. Sapir, and P. Purich. Oracle Application Server TopLink application developers \nguide, 10g (9.0.4). Oracle Corporation, 2003. [17] M. Emami, R. Ghiya, and L. J. Hendren. Context-sensitive \ninterprocedural points-to analysis in the presence of function pointers. In PLDI 94: Proceedings of the \nACM SIGPLAN 1994 conference on Programming language design and implementation, pages 242 256, New York, \nNY, USA, 1994. ACM Press. [18] A. Gawecki and F. Matthes. Integrating query and program optimization \nusing persistent CPS representations. In M. P. Atkinson and R. Welland, editors, Fully Integrated Data \nEnvironments, ESPRIT Basic Research Series, pages 496 501. Springer Verlag, 2000. [19] R. Ghiya and L. \nJ. Hendren. Is it a tree, a DAG, or a cyclic graph? a shape analysis for heap-directed pointers in C. \nIn Proc. of the ACM Symp. on Principles of Programming Languages (POPL), pages 1 15, 1996. [20] C. Gould, \nZ. Su, and P. Devanbu. Static checking of dynamically generated queries in database applications. In \nProc. of the Intl. Conf. on Software Engineering (ICSE), pages 645 654, 2004. [21] W.-S. Han, Y.-S. Moon, \nand K.-Y. Whang. PrefetchGuide: capturing navigational access patterns for prefetching in client/server \nobject\u00adoriented/object-relational dbmss. Information Sciences, 152(1):47 61, 2003. [22] Hibernate reference \ndocumentation. http://www.hibernate. org/hib_docs/v3/reference/en/html, May 2005. [23] A. Ibrahim and \nW. Cook. Automatic prefetching by traversal pro.ling in object persistence architectures. In Proc. of \nthe European Conference on Object-Oriented Programming (ECOOP), 2006. [24] K. Kvilekval and A. Singh. \nSPREE: Object prefetching for mobile computers. In Distributed Objects and Applications (DOA), Oct 2004. \n[25] B. Liskov, A. Adya, M. Castro, S. Ghemawat, R. Gruber, U. Mahesh\u00adwari, A.C.Myers,M.Day, and L. Shrira. \nSafeand ef.cient sharing of persistent objects in Thor. In Proceedings of the Intl. Conf. on Management \nof Data (SIGMOD), pages 318 329, 1996. [26] D. Maier. Representing database programs as objects. In F. \nBancilhon and P. Buneman, editors, Advances in Database Programming Languages, pages 377 386. New York, \nNY, 1990. [27] D. Maier, J. Stein, A. Otis, and A. Purdy. Developments of an object-oriented DBMS. In \nProc. of ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA), pages \n472 482, 1986. [28] V. Matena and M. Hapner. Enterprise Java Beans Speci.cation 1.0. Sun Microsystems, \n1998. [29] F. Matthes, G. Schroder, and J. Schmidt. Tycoon: A scalable and interoperable persistent system \nenvironment. In M. Atkinson, editor, Fully Integrated Data Environments. Springer-Verlag, 1995. [30] \nR. Morrison, R. C. H. Connor, G. N. C. Kirby, D. S. Munro, M. P. Atkinson, Q. I. Cutts, A. L. Brown, \nand A. Dearle. The Napier88 persistent programming language and environment. In M. P. Atkinson and R. \nWelland, editors, Fully Integrated Data Environments, pages 98 154. Springer, 1999. [31] M. Neubauer \nand P. Thiemann. From sequential programs to multi\u00adtier applications by program transformation. In Proc. \nof the ACM Symp. on Principles of Programming Languages (POPL), pages 221 232, 2005. [32] B. C. Pierce. \nTypes and Programming Languages. MIT Press, 2002. [33] T. Rus and E. Van Wyk. A formal approach to parallelizing \ncompilers. In Proc. of the SIAM Conf. on Parallel Processing for Scienti.c Computation, March 14 1997. \n[34] C. Russell. Java Data Objects (JDO) Speci.cation JSR-12. Sun Microsystems, 2003. [35] J. Schmidt, \nF. Matthes, and P. Valduriez. Building persistent applica\u00adtion systems in fully integrated data environments: \nModularization, abstraction and interoperability. In Proceedings of Euro-Arch 93 Congress. Springer Verlag, \nOct. 1993. [36] J. W. Schmidt and F. Matthes. The DBPL project: advances in modular database programming. \nInf. Syst., 19(2):121 140, 1994. [37] R. Software. Whitepaper on the UML and Data Modeling, 2000. [38] \nR. Vitenberg, K. Kvilekval, and A. K. Singh. Increasing concurrency in databases using program analysis. \nIn Proc. of the European Conference on Object-Oriented Programming (ECOOP), pages 341 363, 2004. [39] \nM. N. Wegman and F. K. Zadeck. Constant propagation with conditional branches. ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 13(2):181 210, 1991. [40] R. Wilhelm, S. Sagiv, and T. W. Reps. Shape \nanalysis. In Computational Complexity, pages 1 17, 2000. [41] D. Willis, D. J. Pearce, and J. Noble. \nEf.cient object querying in Java. In Proc. of the European Conference on Object-Oriented Programming \n(ECOOP), Nantes, France, 2006. \n\t\t\t", "proc_id": "1190216", "abstract": "Transparent persistence promises to integrate programming languages and databases by allowing procedural programs to access persistent data with the same ease as non-persistent data. When the data is stored in a relational database, however, transparent persistence does not naturally leverage the performance benefits of relational query optimization. We present a program analysis that combines the benefits of both approaches by extracting database queries from programs with transparent access to persistent data. The analysis uses a sound abstract interpretation of the original program to approximate the data traversal paths in the program and the conditions under which the paths are used. The resulting paths are then converted into a query, and the program is simplified by removing redundant tests. We study an imperative kernel language with read-only access to persistent data and identify the conditions under which the transformations can be applied. This analysis approach promises to combine the software engineering benefits of transparent data persistence with the performance benefits of database query optimization.", "authors": [{"name": "Ben Wiedermann", "author_profile_id": "81322510080", "affiliation": "The University of Texas at Austin", "person_id": "PP24047818", "email_address": "", "orcid_id": ""}, {"name": "William R. Cook", "author_profile_id": "81406596033", "affiliation": "The University of Texas at Austin", "person_id": "PP39027610", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190248", "year": "2007", "article_id": "1190248", "conference": "POPL", "title": "Extracting queries by static analysis of transparent persistence", "url": "http://dl.acm.org/citation.cfm?id=1190248"}