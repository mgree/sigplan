{"article_publication_date": "01-17-2007", "fulltext": "\n LockAll * ocation MichaelEmmi JeffreyS.Fischer RanjitJhala RupakMajumdar UCLosAngeles UCSanDiego UCLosAngeles \nmje,.scher@cs.ucla.edu jhala@cs.ucsd.edu rupak@cs.ucla.edu Abstract Weintroducelock allocation,anautomatictechniquethattakesamulti-threadedprogramannotatedwithatomic \nsections(thatmustbeexecutedatomically),andinfersalockassignmentfromglobalvariablestolocksandalockinstrumentationthatdetermineswhereeachlockshouldbeacquiredandreleasedsuchthattheresult\u00adinginstrumentedprogramisguaranteedtopreserveatomicityanddeadlockfreedom(providedallsharedstateisaccessedonlywithinatomicsections).Ouralgorithmworksinthepresenceofpointersandprocedures,andsetsupthelockallocationproblemasa0-1 \nILPwhichminimizesthecon.ictcostbetweenatomicsectionswhilesimultaneouslyminimizingthenumberoflocks.Wehaveimple\u00admentedouralgorithmforbothCwithpthreadsandJava,andhaveappliedittoinferlocksin15KlinesofAOLservercode.Ourauto\u00admaticallocationproducesthesameresultsashandannotationsformostofthiscode,whilesolvingtheoptimizationinstanceswithinasecondformostprograms. \nCategories and Subject Descriptors D3.3[rammingLa .Pogrn\u00adguages]:LanguageConstructsandFeatures.General \nTerms Languages,Algorithms.Keywords atomicity,lockinference,ILP.  1. Introduction S haredmemoryconcurrency,wheremultiplethreadsaccessshareddatastructures,isapervasiveprogrammingmodelformultiplein\u00adteractingcomputationaltasks.Accessingshareddataconcurrentlyintroducesthepossibilityofsynchronizationerrors,whichoccurwhentheinterleavedexecutionofmultiplethreadscausestheas\u00adsumptionsbyathreadonthesharedstatetobemodi.edunpre\u00addictably.Correctprogramsmustthereforeensurenon-interferenceatprogrampointsthataccesssharedstate.Thenon-interferenceas\u00adsumptionsareformalizedthroughthenotionofatomicity \n[8,7].Ifapieceofcodeisatomic,thenanyinteractionbetweenthatcodeandthestepsofallotherthreadsisguaranteednottochangetheobservablebehavioroftheprogram:foreverypossiblyinterleavedexecution,thereisanequivalentexecutionwheretheatomiccodeexecutessequentially. \n* ThisresearchwassponsoredinpartbytheresearchgrantsNSF-CCF\u00ad0427202,NSF-CNS-0541606,andNSF-CCF-0546170. \nPermissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordis \ntributedforpro.torcommercialadvantageandthatcopiesbearthisnoticeandthefullcitationonthe.rstpage.Tocopyotherwise,torepublish,topostonserversortoredistributetolists,requirespriorspeci.cpermissionand/orafee. \nPOPL 07January17 19,2007,Nice,France.Copyrightc &#38;#169; 2007ACM1-59593-575-4/07/0001...$5.00. Atomicityisanapplication-levelspeci.cation.Inpractice,theprogrammerintentofatomicityisoftenensuredthroughthemech\u00adanismofmutualexclusionmonitorsorlocks.Theprogrammerex\u00adplicitlyacquiresandreleaseslockstosynchronizeaccesstosharedstructureswhiletryingtomaintainmaximumparallelismbetweentasks.Whencorrectlyemployed,locksensureshareddataaccessesoccuratomically.However,lockingisnotoriouslydif.culttogetright \nmistakescanleadtodataracesandnon-atomicexecutions,orresultinoverconservativelockplacement,whichmaysigni.\u00adcantlydiminishthebene.tsofconcurrencyorevencausedeadlock. \nWepresentlock allocation,anautomaticalgorithmthattakesaprogramannotatedwithatomicityspeci.cations,andinfers \nasuit\u00adablesetoflockstogetherwiththeirplacementinthecodesuchthatwiththislockplacement,theresultingcodeisguaranteedtopre\u00adserveatomicityandpreventdeadlock(undertheassumptionthatallglobalvariablesaccessedwithinatomicsectionsareonlyac\u00adcessedwithinatomicsections).Thelockallocationalgorithmmustbalancethetensionbetweenensuringatomicity(forexamplebymaintainingonegloballockthatisacquiredbeforeeachatomicsectionandreleasedattheend)andmaximalconcurrency(forex\u00adamplebymaintainingadifferentlockforeachglobalvariableandacquiringlocksforallvariablesaccessedinanatomicsection)andlowcost(eachlockvariable,acquire,andreleaseoperationassumesacertaincost).Wesetuptheproblemasaconstraintoptimizationproblem.Inparticular,wedesignateabooleanvariableaij \ntobetrueiftheithglobalvariableisassignedthejthlock,andsetupconstraintstoensureeachglobalvariableisassignedsomelock.Wethenattempttominimizethecon.ictcost(ameasureofthelossofconcurrencyincurredifanatomicsectioniswaitingonalockcurrentlyheldbyanotheratomicsection)betweenatomicsec\u00adtions,andthenumberoflocksused,simultaneously.Theresult\u00adingoptimizationproblemisa0-1 \nILP,forwhichextremelyef.\u00adcientsolvers(throughreductiontobooleanSAT)areavailable[4].Thesolutionisalock \nassignment thatassignsalocktoeachglobalvariable.Aswedemonstrate,thelockallocationdecisionproblemisNP-complete,hencethereductionto0-1 \nILPisasymptoticallyoptimal,andasourexperimentsdemonstrate,practicallyef.cient.Givenalockassignment,ourplacementalgorithmissimilartoAu\u00adtolocker[14],asystemthattakesbothatomicsectionannotationsandlockassignments,andplaceslockstoensureatomicityanddeadlockfreedom.Ouroptimizationschemecanbeseenasinfer\u00adring \ntheAutolockerlockassignmentannotations. Weextendthebasiclockallocationalgorithmtodealwithpoint\u00adersandfunctions.Inthepresenceofpointers,weuseastaticallycomputedpoints-torelation,andaddadditionalconstraintstoen\u00adsurethatwhenevertwoprogramlvaluesarealiasedatruntime,theirassignedlocksmustalsoaliasatthatpointintheexecution.Further,weaddconstraintsthatensurethatforeverylvalue,itsas\u00adsignedlockisinscopewhenthelvalueisaccessed.Additionally,weuseastaticallycomputeddependency \nrelation thatplacesanedgebetweentwoabstractlocationsl1 andl2 ifthereisanatomicsectionthataccessesl1 beforel2 \nalongsomeprogramexecution. Thedependencyrelationisthenusedtoputinadditionalconstraintsthatremovecyclicdependenciesbetweenlocks(thatcanleadtodeadlocks). \nWehaveimplementedthelockallocationschemebothforCprogramsusingthepthreadsthreadlibraryandforJavaprograms.Forourexperiments,wehaveusedabout16KlinesofcodefromtheAOLserverwebserver,thatwasannotatedwithatomicsectionsbythedevelopersofAutolocker,andinferredlockassignmentsforthevariables.Ourinferredlockassignmentsare(almostalways)identicaltothemanuallockinginsertedbyAutolocker.Insomeoftheseexamples,onecanobtainbetterlockingmanuallybyrealizingcertainlvaluescannotbealiasedatruntime.Sinceweuseastatic.owinsensitivepoints-toanddependencyrelation,ouralgorithmisconservative.Increasingtheprecisionoftheanalysisisaninterest\u00adingorthogonalproblem.However,asourexperimentsdemonstrate,formanyusefulprograms,programmersusesimplelockingdisci\u00adplinesthatcanbeautomaticallyinferred. \nRelated Work. Intheprogramminglanguagescontext,[7]intro\u00adducedtypeandeffectsystemstocheckatomicityinJavaprograms.Whileweusepessimistic \norsynchronizationbasedschemestoen\u00adsureatomicity,thereisalotofworkonensuringatomicitythroughoptimisticconcurrencycontrolthatusesacombinationofloggingandrollback[8,9,12,18].Theproblemofraceanddeadlockde\u00adtectionhasreceivedalotofattentionfromstatic/dynamicanalysis[5,19,20]andmodelchecking[11]communities. \nRecentworkhasfocusedoneitherinferringatomicsectionsgivenlockassignments[6],orgivenatomicsectionsandlockas\u00adsignments,instrumentingtheprogramwithlockstoensureatomicanddeadlockfreeexecution[14].Ourworkisdualto[6]:givenatomicityspeci.cations,weinferlockingmechanismstoensureatomicity.Independently,[10]alsoconsidersthelockallocationproblem.Unlikeouroptimization-basedalgorithm,theiralgorithmconsidersthepoints-tograph,assigninglockstoabstractlocationsandunifyinglocknamesbasedonadependencyrelationonabstractlocations.Itisdif.culttoincorporatequantitative \ncostmeasures(measuringthecosttoacquire/releasealockaswellascon.ictcosts)intheirscheme.Further,theirschemeonlyproducesglobal \nlocks,whereas(asweillustratelater),ouroptimizationframeworkcanactuallyinferlockslocaltostructures(thatareinstantiatedwithadifferentlockperinstanceofthestructure)insomecases.Thus,ouralgorithmcanbemoreprecise. \n 2. Lock Optimization Weintroducethelockallocationschemeonmulti-threadedpro\u00adgramswithglobalintegervariables.Inthenextsection,weaddi\u00adtionallyhandlereferencesandaliasing. \nMulti-threaded Programs and Atomicity. Fortheremainderofthissection,we.xasetX ={x1,...,xk}ofglobalintegervari\u00adablesinamulti-threadedprogramP.WeassumethatasetofcodeblocksA={A1,...,An}ofP \nareannotatedasatomic sections bytheprogrammer.Foreachi .{1,...,n},letaccess(Ai).X bethesetofglobalvariablesaccessedinblockAi. \nTheintentisthateachatomicsectionexecutes atomically inP.Intuitively,whenablockbexecutesatomicallyinP \nitsinteractionwithotherthreadsdoesnotchangetheoverallprogrambehavior:foreveryinterleavedexecutionofP \ninwhichb isexecuted,thereisanequivalentexecutionwhereb executesuninterruptedbytheotherthreads[7,8]. Lock \nAllocation. Atomicityistypicallyensuredbyprotectingac\u00adcessestosharedvariableswithlocks.GivenasetoflocksL,alock \nassignment isamapping,. : X . L,assigningalocktoeachsharedvariable.ForanatomicsectionAi .A,thesetlocks.(Ai) \noflocksrequiredbyAi isthesetoflocksassignedtoallvariablesaccessedinAi: [ locks.(Ai)={.(x)}. (1) x.access(Ai) \nToensureatomicityofAi,P acquireseachlocke .locks.(Ai) beforethe.rstvariableprotectedbyeisaccessed,andonlyreleaseseuponexitingAi. \nTheuseoflockstoprotectsharedvariablesmayinducecon.ictsbetweenatomicsectionsacquiringthesamelock:theexecutionofanatomicsectionwillbedelayeduntilthelocksitrequiresarereleasedbytheatomicsectionsofotherthreads.ForeachpairAi,Aj \nofatomicsections,letcost(i,j)beapenaltyincurredwhenAi andAj con.ict(e.g.,anapproximationtothetimeoneproceduremustwaitfortheothertoreleasealock).Thecon.ict \ncost ofthelockassignment. isthesumofthecon.ictsoverpairsofatomicsectionssharingsomelock: X con.ict.(A)= \ncost(i,j)\u00b7d(locks.(Ai)nlocks.(Aj)) (2) 1=i=j=n whered(S)=1ifS ,andd(S)=0otherwise. =\u00d8 Thelock allocation \noptimization problem asksto.ndalockassignment. : X . L foraminimalsetoflocksL suchthatthecon.ictcostisminimized.Thesearecon.ictingrequirements:asingletonlocksetandthelockassignmentmappingeachvariabletheonlylockclearlyminimizesthenumberoflocks,butsacri.cesahighcon.ictcost,whileaone-to-onemapfromvariablestolocksalwaysachievestheoptimalcon.ictcost,butresultsinthemaximumnumberoflocks. \nFormallywemodeltheoptimizationproblemasamulti\u00adobjectiveminimizationproblem.Firstwenoticethatthenum\u00adberoflockstocanbeboundedby|X|;we.xasetoflocksL \n={e1,...,ek}.Foreachpairi,j .{1,...,k},weintroducea0-1variableaij whichtakesthevalue1ifandonlyifglobalvari\u00adablexi \nisassignedlockej.Wethenrepresentthenumberoflocksandcon.ictcostbytermsoverthesevariables.Thetotalnumberoflocksusedbyanassignmentis \nkk X_ |L|=( aij ), (3) j=1 i=1 whilethecon.ictcostcon.ict(a)foranassignmentis 23 n X ___ 45 cost(i,j)\u00b7 \nalk \u00b7 amk (4) 1=i=j=nk=1 xl.Ai xm.Aj (where.denotesbooleandisjunction).Thelockallocationopti\u00admizationproblemisthen \nmincon.ict(a) min|L| (5) Pk s.t.j=1 aij =1 foreachi .{1,...,k}. Theconstraintsmaintainthateachvariableisassignedexactlyonelock.Asolutionoftheoptimizationproblem(5)inducesalockassignment;ifaij \n=1appearsinthesolution,thenvariablexi isassignedlocklj.Sinceeachvariableisassignedonelock,theinducedassignmentisatotalfunction.ForaprogramP,weuseOpt(P)todenotealockassignmentinducedbyanoptimalsolutiontothelockallocationoptimizationproblem5. \nAsmightbeexpected,thecorrespondingdecisionproblem,whichattemptsto.ndalockallocationwithlessthanorequaltok \nlocks,withacon.ictcostlessthank,isNP-complete. PROPOSITION1.Lock allocation is NP-complete. Proof: Anondeterministicpolynomial-timealgorithmguessesalockallocationandchecksthecon.ictcostandthenumberoflocks \nglobal balance, name; atomic b1 { access(balance); } atomic b2 { access(name); } 23 a(balance, 1) . a(name, \n1) min cost(b1,b2) \u00b7. 45 a(balance, 2) . a(name, 2) s.t. a(balance, 1) + a(balance, 2) = 1 a(name, 1) \n+ a(name, 2) = 1 (a(balance, 1) . a(name, 1))+ (a(balance, 2) . a(name, 2)) = m Figure 1. (a)Sourceprogram,(b)Constraintsfori \nlocks arelessthantheinputbounds.WeshowNP-hardnessbyreductionfromgraphcoloring.GivenagraphG =(V, E)withn \nnodesandanumberofcolorsk,weproduceaprogramwithn globalvariables{xv |v .V }andn atomicsections{Av |v .V \n}suchthataccess(Av)={xv}forallv .V .Foreachedge(u, v).E,thereisacon.ictcostk +1betweenAu andAv,andforeachpair(u, \nv).E,thereisacon.ictcost0betweenAu andAv.Ifthegraphcanbek-colored,thenthereisalockallocationwithlessthanorequaltok \nlocks,suchthatthecon.ictcostislessthank.Ontheotherhand,ifthegraphcannotbek-colored,thentherearetwoatomicsectionsreceivingthesamelockandthecon.ictcostisatleastk \n+1.0 Althoughtheoptimizationproblem(5)ismulti-objectiveandnon-linear,a0-1integerlinearprogramming(ILP)isachievablewithsomemanipulation.Sincethenumberoflocksisboundedbythenumberofvariables,oneinsteadposesk \noptimizationproblems{p1,...,pk}inwhichonlycon.ict(a)isminimized,andeachpm hastheadditionalconstraint \nkk X (_ aij )=m, (6) j=1 i=1 statingthatthenumberoflocksislessthanorequaltom.Second,giventhenonlinearobjectivefunctionandthenonlinearconstraint(6),weperformthefollowinggeneraltransformation.Foreachexpressionoftheform.a.Aa \nweintroduceanewvariablea.A toreplaceit,andaddtheconstraints PP a =a.A anda =|A|\u00b7a.A. (7) a.Aa.A Q Finally,wereplaceeachmonomiala.A \na withthenewvariableaQ A,addingtheconstraints PP a =|A|\u00b7aQ A anda -aQ A =(|A|-1). a.Aa.A (8) EXAMPLE1:Figure1(a)showsaprogramlayoutwithtwoglobalvariablesbalance \nandname,andtwoatomicsectionsaccessingbalance andname respectively weassumethateachatomicsec\u00adtioncanbeexecutedbyconcurrentlyrunningthreads.Intuitively,ifasinglelockisused,bothvariablesmustshareit;ontheotherhandwhenusingtwolocksitisadvantageoustoassigneachvariableitsownlock.Figure1(b)showsprobleminstancepm \n.{p1,p2}oftheILPcorrespondingtothesourceprogramin(a).The.rsttwoconstraintsensurethevariablesbalance andname \neachreceiveexactlyonelock,whilethethirdlimitsthetotalnumberoflockstom (where,again,m canbe1or2).Thebooleandisjunctionsinthethirdconstraintareremovedbyaddingtwovariablesy1 \nandy2,replacingthethirdconstraintwithy1 +y2 = m,andaddingtheconstraints(asrequiredbyEquation7): y1 = \na(balance, 1) + a(name, 1) = 2y1 y2 = a(balance, 2) + a(name, 2) = 2y2. 0 Locking Instrumentation. Let. \nbealockassignmenttothevari\u00adablesX oftheprogramP.WeinstrumenttheprogramP withacquire andrelease statementsthattakeandreleaselocks.Weuseatwo-phase \nlockingscheme[13]thatacquiresalllocksbeforereleasinganylock.WeusethenotationP. torefertotheprogramP instrumentedwiththeacquisitionsandreleasesoflocksaccord\u00adingto..Inparticular,immediatelybeforeeachaccesstoavariablex \n.X isplacedthestatementacquire(.(x)),anduponexitofanatomicsectionareplacedthestatementsrelease(.(x)),foreachx \n. X.Thesemanticsofthesestatementsarerespectivelytoobtainthelock.(x)ifitisnotyetheldbythecurrentthread,andtorelease.(x)ifitisheldbythecurrentthread,andthecur\u00adrentlyexecutingatomicsectionistheonlyoneonthecallstack.Thisinstrumentationensuresthefollowing. \nTHEOREM1.[Soundness] Let P be a multi-threaded program over global integer variables X with atomic sections \nA, and Opt(P), an optimal solution to the lock allocation problem for P. For each A .A, the block A executes \natomically in POpt(P ).  3. Lock Allocation with Pointers Wenowextendthebasictechniquetoprogramswithpointers. \n 3.1 Lvalues and Aliasing Lvalues. Arecordtypeisasetofpairs(f, t)wheref isa.eldname,andt isthe(integerorrecord)typeoff.Recordsarerepresentedinthestandardway:arecordvalueisareferencetoaheapstructurethatstoresthevaluesofits.elds.Anlvalue \nisatermoftheformx forsomeintegerorrecord-valuedvariabledeclaredintheprogram,ora.eldaccessoftheformv.f \nwherev isanlvaluewhoserecord-typecontainsthe.eldnamef.Thesetofalllvalueswhichappearinaprogram stextisdenotedLvals. \nOuranalysisgenerateslockassignmentstoprotectaccessestorecords,individual.eldsofrecords,andglobalvariables.Theback-endofouranalysisaugmentseachrecordwithasystemlockresourcewhichisacquiredandreleasedwiththeassociatedlockingprimitives;theacquisitionandreleasingoflocksisalsoinsertedintothetargetprogramasdescribedinSection2.Alockiscalledlocal \nifitisa.eldofarecordtype,andglobally-scopedstaticlocksarecalledglobal.Locallocksprotectindividualinstancesofarecordor.eld.Ontheotherhand,ifarecordor.eldlvalueisassignedtoagloballock,allinstancesofthatrecord/.eldareprotectedbythesamelock. \nMay-and Must-Aliases. Foreverypairoflvaluesv1 andv2 ofaprogramP,wesaythatv1 andv2 aremay aliased ifthereexistssomeexecutionofP \nsuchthatv1 andv2 pointtothesameheaplocationatsomepointalongtheexecution.Wesaythatv1 andv2 aremust aliased \nifalongeveryexecutionofP,v1 andv2 pointtothesameheaplocation,wheneverboththelvaluesarede.ned.Thereareseveraltechniquesforstaticallycomputingconservativeapproximationsofthemayandmustaliasrelationsfromthetextoftheprogram[1]. \nEXAMPLE2:Dynamic Names In.gure2(a)wehaveasimpleclassSum computingaseriesofadditionswiththeexpectedvaluesth1.s1.sum \n= 300 andth1.s1.num = 100 upontheexitofmain.Thisconditionisonlyguaranteedwhenthemethodadd isexecutedatomically,asthereareotherwiseraceconditionsontheincrementsofthis.num \nandthis.sum:aninterleavingwherethreadth1 readsthevalueofthis.sum,thenthreadth2 readsandupdatesthevalue,and.nallyth1 \nupdatesthevalue,resultsinthe lostupdate symptomobservedfromth1. class Sum { int num = 0, sum =0; void \nadd(Sum s) atomic { this.num += s.num; this.sum += s.sum; return; } static class SThread extends Thread \n{ Sum s1, s2;  must public void run() { int count = 50; while (count > 0) { s1.add(s2);  count--; \n}}} static void main(String[] args) { SThread th1 = new SThread(); SThread th2 = new SThread(); th1.s1 \n= th2.s1 = new Sum();  must th1.s2 = th2.s2 = new Sum(); th1.s2.num = 1; th1.s2.sum = 3; th1.start(); \nth2.start(); }}  class Sum { int num = 0, sum =0; final Lock lock = new ReentrantLock(); void add(Sum \ns) { this.lock.lock(); this.num += s.num; this.sum += s.sum; this.lock.unlock(); return; } ... } class \nSum { ... static void main(String[] args) { SThread th1 = new SThread(); SThread th2 = new SThread(); \nth1.s1 = th2.s2 = new Sum(); th1.s2 = th2.s1 = new Sum(); th1.s1.num = th1.s1.sum = 1; th1.start(); th2.start(); \n}} Figure 2. (a)ConcurrentlyexecutingthreadsintheSum module(b)Must-aliasesofSum (c)TherewrittenSum program,protectedbylocks(d)Asimilarprogram,Sum \n,indangerofdeadlock 3.2 Constraints LetLvals ={v1,...,vk}bethesetoflvaluesofamulti-threadedprogramP.Inourframework,eachlvaluevi \nhasanassociatedlocal lock resourceei associatedwiththeruntimeobjectreferredtobyvi.Inaddition,aset{g1,...,gk}ofglobally-scoped,static,global \nlock resourcesareavailableforallocation,makingtheen\u00adtiresetoflocksLocks = {e1,...,ek}l{g1,...,gk}.Let#: \nLocks .{1,...,2k}beaone-to-onelock-numberingfunction.Inthesamespiritassection2,weintroducea0-1variableai#\u00a3 \nwhichtakesthevalue1ifandonlyifvi isassignedlocke. Asbefore,eachlvaluemustbeassignedalock,thusdemandstheconstraintforeachvi \n.Lvals: X aij =1 (9)j Inthefaceofreferencebasedlockallocation,wemaintaintheinvariantthatwhenevertwolvaluesarealiasedatruntime,theirprotectinglocksarealsoaliased.Weapproximatethisinvariantwiththefollowingconstraints.Foreverypairoflvaluesvi1 \nandvi2 whichmust bealiasedduringprogramexecution(i.e.theyarealiases,andarealwaysaliasedwhenaccessed),andeachlocke,wehavetheconstraint \nai1#\u00a3 =ai2#\u00a3. (10) Inthecasethatmay-aliasesvi1 andvi2 maynotbealiasesatsome pointofaccess,wehavetheconstraints \nai1#g =ai2#g (11) foreachgloballockg,and ai1#\u00a3 =ai2#\u00a3 =0 (12) foreachlocallocke.Constraint(12)conservativelyensurestheinvariantholdsbyprohibitinglocallockstoprotectlvalueswithinde.nitealiases. \nEXAMPLE3:[Local Locks] Sincethelvaluesthis@add ands@add of.gure2(a)haveonlymust-aliases(see.gure2(b))theycanbesafelyprotectedbylocallocks(theapplicationofcon\u00adstraint12isavoided).TheILPconstraintsduetoaliasingarethus: \nathis@add,\u00a3 =as1,\u00a3,as@add,\u00a3 =as2,\u00a3 foralle.Locks. In.gure2(c)weshowtheprogramgeneratedduetothelockingas\u00adsignmentwherethis@add \nands@add (andthusth1.s1,th2.s1 andth1.s2,th2.s2,respectively)arebothassignedtheinstancelockofthis@add.0 \nSincelockscanbeassociatedwithruntimereferences,wemustalsoensurethatanyassignedlockisaccessiblefromeveryscopeinwhichtherespectivelvalueisaccessed.Foreachlvaluevi \nandeachlocallocke whichisinaccessiblefromsomeatomicsectionAinwhichvi .access(A)wehavetheconstraint ai#\u00a3 \n=0. (13) Preferringtheassignmentofalocallocktoagloballockcor\u00adrespondstoreducingthepossibilityofatomicsectionscon.ictingduringprogramexecution.Forexample,theparallelexecutionofthesameatomicsectionispossibleifonlylocallocksareacquired,andtheaccessedinstancedataarenotaliased.Thispreferentialtreatmentcanbeachievedbygivingahighercosttogloballocksthanlocallocks,orbymakinguseofspecializedfeaturesofsolvers,suchasspecialorderedsets[3]. \nTHEOREM2.[Soundness] Let P be a multi-threaded program with atomic sections A, and Opt(P)an optimal solution \nto the lock allocation problem for P.For each A .A, the block A executes atomically in POpt(P). 3.3 \nAvoiding Deadlock Whenthesetofvariablesandlockscanbestaticallydetermined,aswasthecaseinSection2,wecanavoiddeadlockbyimposingalinearorderingonthesetoflocks.Inthepresenceofreferencesandaliasing,thesetoflocksisdetermineddynamically.Becauselockscanbeassociatedwithinstances \nofprogramvariables(asopposedtoasinglelockgoverningeveryinstanceofavariable),thetargetprogramhasthepossibilityofdeadlock,asExample3.3demonstrates.WesayaprogramP \nisdeadlock-free ifeverymulti\u00adthreadedexecutionofP avoidsdeadlock. int[] g ={ 0, 0 }; void inc(boolean \nb) atomic { if (b) g[0]++; else g[1]++; } Figure 3. Wherealias-precisioncanmakeadifference EXAMPLE4:Deadlocks \nFigure2(d)showsanotherprogramcon\u00adcurrentlyperformingadditions.Inthisexample,thethreadsth1 andth2 areaccessingthetwoSum \nobjectsinreversedroles.Thelvaluesth1.s1 andth1.s2 arealiasedtothis@add ands@add,respectively,whileth2.s1 \nandth2.s2 arealiasedtos@add andthis@add.Ifthecompetingthreadsweretoeachtakeonelock(thelockofs@add,forexample)beforeeithertookasecondlock,theprogramwoulddeadlockasneitherthreadcanacquireitssec\u00adondlock.Anysoundlockassignmentmustassignthesamelocktos@add \nandthis@add topreventthispossibility.0 Todealwithlockorderinginthissituation,weanalyzethetemporalrelationshipsbetweenprotectedaccessesoflvalues. \nAccessed-Before Relation. Theorderingonlocksisobtainedviaanaccessed before relationspecifyingdatadependenciesonlvaluesintheatomicsections.Formally,fortwolvaluesv1,v2 \n. Lvals,wesayv1 isaccessedbeforev2 ifthereexistsanatomicsectionAandacontrol-.owpathinA suchthat(1)v1 \nisaccessedonthepath, (2)v1 isthenpossiblymodi.ed(e.g.,byawritetoanlvaluethatmayaliasv1),and.nally(3)v2 \nisaccessedafterthemodi.cation.Wecancombinethealiasinginformationwithatraversalofthecontrol-.owgraphtoobtainaconservativeoverapproximationoftheaccessedbeforerelation.Iftheaccessgraphisacyclicwecanorderthelvaluesoftheprogramlinearlybyatopologicalsortoftheaccessgraph.Ifnot,wecanordertheSCCdagofthegraphlinearly. \nOrdering constraints Wecanenforcealinearordering(andhencetheabsenceofdeadlock)byaddingordering constraints \ntotheILP.LetDeps beanaccessgraphoftheprogramP.Wetakealinearorderingdeterminedbythesccdagofthedependencygraph,andaddconstraintsthatstatethatanlvalueiinanon-trivialscccannotbeassignedlocallocksforanylvalueinitsownsccorinansccsucceedingitinthelinearorder. \nTHEOREM3.Let P be a multi-threaded program with atomic sec\u00adtions A, and Opt(P) an optimal solution to \nthe lock allocation problem for P. POpt(P ) is deadlock-free. 3.4 Precision Theimprecisionoftheunderlyingalias(anddependency)analysescancauseourlockallocationschemetoinfersub-optimal,butstillsound,lockingassignments.Example5illustratesonewaythiscanhappen. \nEXAMPLE5:Theprocedureinc of.gure3simplyincrementsoneoftwocounters,dependingthevalueofitsargumentb.Analiasanalysiswhichconsiderseverycellofanarrayaliasedwouldforceourlockallocationschemetoassignthesamelocktobothcells,despitethatit \nssoundinthiscasetoassignseparatelockstoeach.Thisallocationcausesanunnecessarycon.ictbetweencallersinvokinginc(true) \nandinc(false).0 Wehavealsoassumedthatanytwoatomicsectionscanexecuteconcurrently.Furtherstaticanalysistodiscoverwhichatomicsec\u00adtionsmayactuallyexecuteinparallel[15]wouldimprovethegen\u00aderatedlockingassignments,sinceanyconstraintsarisingfromsec\u00adtionswhichcannotexecuteinparallelmaybesafelyprunedaway. \n  4. Experiments Implementation. Wehavetwoimplementationsofthelockallo\u00adcationalgorithm:jla forJavaprogramsandcla \nforCprograms.TheJavaversion,jla,iscodedinJava,usingthePolyglotcompilerframework[17].TheCversion,cla,iscodedinOcamlandusestheCIL[16]infrastructureforCprograms.BothtoolsuseMin\u00adisat+[4],apseudo-booleanoptimizationsolver,thatconvertsthe0-1 \nILPtoabooleanSATinstance.Inourexperiments,weassignedthefollowingcoststolocksandcon.icts.Eachcon.ictwasgivenacost1.Eachgloballockwasgivenacost2 \nandeachlocallockacost1.Insteadofsolvingasequenceofoptimizationproblems,weminimizedthesumofthecon.ictsandthesumofthetotallockcosts.Weexperimentedwithasetofdifferentcostheuristics,buttheabovesimpleheuristicsprovidedlockassignmentsthatweresimilartomanuallycodedlocksinmostexamples. \nNested Atomic Sections. Atomicsectionsmaytransitivelycallmethodscontainingotheratomicsections.Alockobtainedinanestedatomicsectioncannotalwaysbesafelyreleasedattheendofthatsection \nthesamelockmaybere-obtainedbyanothernestedsectionunderthesameparent,potentiallyviolatingatomicity.Toavoidthisissue,weuseatwo-phase \nlockingdiscipline[13].Locksareobtainedwhentheassociatedlvalueis.rstaccessed,butarenotreleaseduntiltheoutermostatomicsection.nishes.Thisapproachguaranteesatomicityandhasbeenusedbyotherlockingtools,suchasAutolocker[14]. \nMicrobenchmarks. WeranboththeClockallocatorandtheJavalockallocatoronsimplestringbufferandhashtableexamples.Thestringbufferexamplewasasimpli.cationofJava \nsStringBufferclass.Wefoundlocallockingassignmentsthat,togetherwithouruseoftwo-phaselocking,removedtheatomicityviolationpresentinJava \nsStringBufferclassandreportedin[7]. Thehashtableexample,liketheHashtable classprovidedbyJava scollectionframework,usesanarrayoflinked-listbuck\u00adets.However,duetomethodslikeresize \nthatcopythearray,ourallocatorassignsasinglegloballockforthehashbucketsofHashtable.Theresize methodchangesthenumberofhashbucketsbyallocatinganewbucketarrayandre-hashingallentriestothenewsetofbuckets,resultinginacyclicdependencygraph.Ahand-implementedlockassignmentwouldbebetter,assigningalockforeacharrayelement.Thisisleftasfuturework. \nAOLServer. WealsorantheClockallocationonalargerprogram thensd moduleofAOLserver[2],anopensourceweb\u00adserverinproductionuseatAOLandothercompanies.Thedevel\u00adopersofAutolockerhadannotatedtheprogramwithatomicblocks,aswellasassigned,toeachglobalvariable,auniquelockthatpro\u00adtectedit.Inourexperiments,weignoredthelockassignments,andusedtheatomicannotationstoinferalockmappingandcorre\u00adspondingplacement.Weraneach.leinthensd \nmoduleseparately.Thiswassoundbecausetheglobalvariableswerewithinthescopeoftheindividual.les.Wetesttwohypothesesaboutlockalloca\u00adtion:.rst,manyrealprogramsuseverysimplelockingdisciplinesthatshouldbeautomaticallyinferable;andsecond,ouralgorithmperformsef.cientlyinpractice. \nTheresultsoftheAOLserverexperimentaresummarizedinTable1.Theexperimentsaremoreavalidationofthescalabilityoftheapproachratherthantodemonstrateparticularlyintricatelockingbehavior.IntheAOLservermoduleconsidered,most.leshadverysimplelockassignments,allofwhichwereequivalenttotheassignmentssynthesizedbyourlockallocationalgorithm.Thissupportsourclaimthatinmanycases,asimplelockingschemeisenoughtoensureatomicityandthiscanbeautomaticallyinferred. \nInmostcases,thelockallocationalgorithmrunsinafewsec\u00adonds.Theconstraintgenerationphaseisslow:wehaveanaiveloopthatrunsintimeO(a \n2L3) wherea isthenumberofatomic FileLOC LvalsAtomic VariablesConstraints GenerateSolveTotal LocksAutolocker \n cache1571 7110 171551671068 82.640.4495.93 11 callbacks580 297 1088340860 1.190.072.56 11 dns522 102 \n 3881189 0.020.0010.53 11 driver1640 267 509918145 0.3900.13015.8 22 encoding835 151 241327 0.010.0011.02 \n11 fd311 72 218674 0.0100.0010.44 11 info734 62 157449 0.0010.0010.65 11 listen318 223 391514152 0.360.021.07 \n11 log914 101 111146 0.010.011.04 11 tclenv296 61 4357 0.0010.0010.6 11 tcl.le1292 215 733828142 1.640.0611.63 \n11 tclhttp578 124 7492528 0.050.061.71 11 tclinit1434 61 4353 0.0010.0012.62 11 tclvar1052 14411 13500075337645 \n2294.4623.732399.0 42 sockcallback559 135 13284668 0.090.021.02 11 urlspace2153 156 12914589 0.190.013.96 \n21 unix568 204 383014053 0.320.021.08 11    Table 1. Experimentsonaolserver.Filegivesthenameofthe.leinthensd \nmodule.LOCislinesofcode.Lvalsisthenumberoflvaluenamesconsideredbythelockallocation.Atomicisthenumberofatomicblocksinthecode.Variablesandconstraintsgivethetotalnumberof0-1 \nvariablesandthetotalnumberofconstraintsintheILP.GenerateistimeinsecondstogeneratetheILPfromthecode.SolveistimeinsecondstakenbyMinisat+tosolvetheILPinstance.Totalisthewallclocktimeinsecondsfortheanalysis.LocksisthenumberoflocksinferredbytheanalysisandAutolockergivesthenumberoflocksprovidedasAutolockerinstrumentation. \nblocksandL thenumberoflvalues.Notice,forexample,thatthelargestexample(tclvar)takesalmost40minutes.However,eventhoughthegeneratedILPisverylarge,theconstraintsolverisex\u00adtremelyfast,taking24sonthislargestexample,andusuallytakinglessthan1s.Thisisbecausemanyoftheaccessibilityandaliasingconstraintsseverelyrestrictthepossibleassignments(settingmanyvariablesto0)sothatbooleanconstraintpropagationintheSATsolverisveryeffectiveinpruningthesearchspace. \nThelockassignmentsweresimilartothosemanuallyspeci.edintheoriginalprogramexceptfortwocases,tclvarandurlspace.Intclvar,therearetwofunctionswithstaticvariablesthatarechangedtoglobalvariablesbyCIL.Thesevariablesareassignedlocksbyouralgorithm,butAutolockerdidnotassociatelockswiththesevariables,probablybecausethesewouldnotbemodi.edinparallel.Further,thelockallocationfortclvar.ndsaninstance-speci.clock:itassociatesalockwitheachstructureoftypeBucket \n(whichcontainsahashtablethatisprotectedbythislock).TheAutolockerannotationsdothesame. Inurlspace,therearetwoglobalvariablesurlspace \nandnextid thatareassignedthesamelockbytheannotationsinAu\u00adtolocker.Asthesevariablesareaccessedinseparateatomicblocks,ouralgorithmassignsdistinctlockstothem.However,ouralgo\u00adrithmfoundanoptimalsolutionthatassignedthelocallocknom\u00adinallyassociatedwithurlspace \ntonextid andviceversa.Thus,thelockassignmentsfoundbythesolvercanbecounter-intuitive(thoughsound). Acknowledgments. \nWethankBillMcCloskeyforforwardingtheAutolockerannotated.lestous.  References [1]L.O.Andersen. Program \nanalysis and specialization for the C programming language.PhDthesis,1994. [2]Aolserver.http://www.aolserver.com. \n[3]E.M.L. BealeandJ.A.Tomlin.Specialfacilitiesinageneralmathematicalprogrammingsystemfornon-convexproblemsusingorderedsetsofvariables.InProc. \nIntl. Conf. Oper. Res.,pages447 454,1970.Tavistock. [4]N.EenandN.Sorensson.Translatingpseudo-booleanconstraintsintoSAT.JSAT,pages1 \n26,2006. [5]C.FlanaganandS.N.Freund.Type-basedracedetectionforJava. InPLDI 00,pages219 232.ACM,2000. \n[6]C. Flanagan,S.N.Freund,andM.Lifshin.Typeinferencefor atomicity.InTLDI 05,pages47 58.ACM,2005. [7]C.FlanaganandS.Qadeer.Atypeandeffectsystemforatomicity.InPLDI \n03,pages338 349.ACM,2003. [8]J. GrayandA.Reuter.Transaction processing: Concepts and Techniques.Morgan-Kaufmann,1993. \n [9]T.HarrisandK.Fraser.Languagesupportforlightweighttransactions.InOOPSLA 03,pages388 402,2003. [10]M.Hicks,J.S.Foster,andP.Pratikakis. \nLockinferenceforatomicsections.InTRANSACT 06,2006. [11]G.Holzmann. TheSpinmodelchecker.IEEE TSE,23(5):279 \n295,1997. [12]S.JagannathanandJ.Vitek. Optimisticconcurrencysemanticsfortransactionsincoordinationlanguages.InIntl. \nConf. on Coordination Models and Languages,LNCS2949,pages183 198.Springer,2004. [13]D.B.Lomet. Processstructuring,synchronization,andrecoveryusingatomicactions.InLanguage \nDesign for Reliable Software,pages128 137,1977. [14]B.McCloskey,F. Zhou,D.Gay,andE.Brewer.Autolocker:Synchronizationinferenceforatomicsections.InPOPL \n06,pages346 358.ACM,2006. [15]G.Naumovich,G.S.Avrunin,andL.A.Clarke.Anef.cientalgorithmforcomputingMHPinformationforconcurrentJavaprograms.InFSE \n99,pages338 354.ACM,1999. [16]G.Necula,S.McPeak,S.Rahul,andW.Weimer. CIL:IntermediateLanguageandToolsforAnalysisandTransformationofCPrograms.InCC \n02,pages213 228,2002. [17]N.Nystrom,M.Clarkson,andA.Myers. Polyglot:AnExtensibleCompilerFrameworkforJava.InCC \n03,pages138 152,2003. [18]M.F.RingenburgandD.Grossman. Atomcaml:.rst-classatomicityviarollback.InICFP \n05,pages92 104.ACM,2005. [19]S.Savage,M. Burrows,C.G.Nelson,P.Sobalvarro,andT.A.Anderson.Eraser:Adynamicdataracedetectorformultithreadedprograms.ACM \nTOCS,15(4):391 411,1997. [20]N.Sterling. Warlock:astaticdataraceanalysistool.InUSENIX Technical Conference,pages97 \n106,1993. \n\t\t\t", "proc_id": "1190216", "abstract": "We introduce <i>lock allocation</i>, an automatic technique that takes a multi-threaded program annotated with <i>atomic</i> sections (that must be executed atomically), and infers a lock assignment from global variables to locks and a lock instrumentation that determines where each lock should be acquired and released such that the resulting instrumented program is guaranteed to preserve atomicity and deadlock freedom (provided all shared state is accessed only within atomic sections). Our algorithm works in the presence of pointers and procedures, and sets up the lock allocation problem as a 0-1 ILP which minimizes the conflict cost between atomic sections while simultaneously minimizing the number of locks. We have implemented our algorithm for both C with pthreads and Java, and have applied it to infer locks in 15K lines of AOLserver code. Our automatic allocation produces the same results as hand annotations for most of this code, while solving the optimization instances within a second for most programs.", "authors": [{"name": "Michael Emmi", "author_profile_id": "81333488438", "affiliation": "UC Los Angeles", "person_id": "PP35035543", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Fischer", "author_profile_id": "81452610589", "affiliation": "UC Los Angeles", "person_id": "P831283", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "UC San Diego", "person_id": "P343132", "email_address": "", "orcid_id": ""}, {"name": "Rupak Majumdar", "author_profile_id": "81100319213", "affiliation": "UC Los Angeles", "person_id": "P335105", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190260", "year": "2007", "article_id": "1190260", "conference": "POPL", "title": "Lock allocation", "url": "http://dl.acm.org/citation.cfm?id=1190260"}