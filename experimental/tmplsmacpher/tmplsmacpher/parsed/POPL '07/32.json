{"article_publication_date": "01-17-2007", "fulltext": "\n On the Analysis of Interacting Pushdown Systems Vineet Kahlon Aarti Gupta NEC Labs, Princeton, USA. \nNEC Labs, Princeton, USA. kahIon ne-Iabs.om agupta ne-Iabs.om Abstract Pushdown Systems (PDSs) have \nbecome an important paradigm for program analysis. Indeed, recent work has shown a deep con\u00adnection between \ninter-procedural data.ow analysis for sequential programs and the model checking problem for PDSs. A \nnatural extension of this framework to the concurrent domain hinges on the, somewhat less studied, problem \nof model checking Interact\u00ading Pushdown Systems. In this paper, we therefore focus on the model checking \nof Interacting Pushdown Systems synchronizing via the standard primitives -locks, rendezvous and broadcasts, \nfor rich classes of temporal properties -both linear and branching time. We formulate new algorithms \nfor model checking interacting PDSs for important fragments of LTL and the Mu-Calculus. Addition\u00adally, \nwe also delineate precisely the decidability boundary for each of the standard synchronization primitives. \nCategories and Subject Descriptors F[3]: 1 General Terms Veri.cation, Theory Keywords Concurrency, Data.ow \nAnalysis, Pushdown Systems, Model Checking, LTL, Mu-Calculus  1. Introduction In recent years, Pushdown \nSystems (PDSs) have emerged as a pow\u00aderful, unifying framework for ef.ciently encoding inter-procedural \ndata.ow analysis. Given a sequential program, abstract interpreta\u00adtion is .rst used to get a .nite representation \nof the control part of the program while recursion is modeled using a stack. Pushdown systems then provide \na natural framework to model such abstractly interpreted structures. A PDS has a .nite control part correspond\u00ading \nto the valuation of the variables of the program and a stack which provides a means to model recursion. \nData.ow analysis then exploits the fact that the model checking problem for PDSs is de\u00adcidable for very \nexpressive classes of properties -both linear and branching time (cf. [1, 17]). Not only has this powerful \nframework been useful in encoding many different data.ow analyses but has, in many cases, led to strictly \nmore expressive data.ow frameworks than those provided by classical inter-procedural data.ow analysis. \nMany variants of the basic PDS model like Weighted Pushdown System [16], Extended Weighted Pushdown System \n[11], etc., have been proposed and applied to various application domains thus Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January17 19, 2007, Nice, France. Copyright \nc &#38;#169;2007 ACM 1-59593-575-4/07/0001. . . $5.00 highlighting (i) the deep connection between data.ow \nanalysis and the model checking problem for PDSs, and (ii) the usefulness of PDSs as a natural model \nfor program analysis. However, most of this work has focused only on the analysis of sequential programs. \nAnalogous to the sequential case, inter\u00adprocedural data.ow analysis for concurrent multi-threaded pro\u00adgrams \ncan be formulated as a model checking problem for interact\u00ading PDSs on which, however, only very limited \nwork exists. Early work focused on the model checking of PDSs interacting via pair\u00adwise rendezvous. While \nfor a single PDS the model checking prob\u00adlem is ef.ciently decidable for very expressive logics, it was \nshown in [15] that even simple properties like reachability become unde\u00adcidable for systems with only \ntwo threads but where the threads synchronize using CCS-style pairwise rendezvous. In [10], unde\u00adcidability \nwas shown to hold even for PDSs communicating via locks. It was proved that the model checking problem \nfor pairwise reachability, and hence multi-indexed LTL formulae, is undecid\u00adable, in general, even for \nsystems with just two PDSs synchronizing via locks. However, the more important contribution of [10] \nwas that the problem of deciding simple pairwise reachability for the practi\u00adcally important paradigm \nof PDSs interacting via nested locks was shown to be ef.ciently decidable. In [9], the decidability result \nfor PDSs synchronizing via nested locks was further extended to single-index LTL properties. These results \ndemonstrate that there are important fragment of temporal logics and useful models of interacting PDSs \nfor which ef.cient decidability results can be ob\u00adtained. It is important that such fragments be identi.ed \nfor each of the standard synchronization primitives. Indeed, formulating ef.\u00adcient algorithms for model \nchecking interacting Pushdown Systems lies at the core of scalable data .ow analysis for concurrent pro\u00adgrams. \nFurthermore, of fundamental importance also is the need to delineate precisely the decidability/undecidability \nboundary of the model checking problem for PDSs interacting via the standard syn\u00adchronization primitives. \nIndeed, there is currently little work on un\u00adderstanding exactly where the decidability/undecidability \nboundary for the problem lies. An insight into the causes of undecidability of\u00adten plays a key role in \ndevising effective techniques to surmounting the undecidability barrier in practice. In this paper, we \nstudy the problem of model checking PDSs interacting via the standard communication primitives -locks, \npair\u00adwise and asynchronous rendezvous, and broadcasts. Locks are primitives commonly used to enforce \nmutual exclusion. Asyn\u00adchronous Rendezvous and Broadcasts model, respectively, the Waito \\Notifyo and \nWaito \\NotifyAllo constructs of Java, while Pairwise Rendezvous are inspired by the CCS process alge\u00adbra. \nMoreover, we also consider the practically important paradigm of PDSs communicating via nested locks. \nMost real-world concur\u00adrent programs use locks in a nested fashion, viz., each thread can only release \nthe lock that it acquired last and that has not yet been released. Indeed, practical programming guidelines \nused by soft\u00adware developers often require that locks be used in a nested fashion. In fact, in Java (version \n1.4) and C# locking is syntactically guar\u00adanteed to be nested. As is usual when model checking concurrent \nsystems, we con\u00adsider correctness properties expressed as multi-index temporal logic formulae, where \nin a k-index formula, the atomic proposi\u00adtions are interpreted over the local control states of kPDSs. \nIt turns out that most interesting properties about concurrent programs can be expressed as single or \ndouble-index properties. As part of previ\u00adous work [9], it has been shown that the model checking problem \nis ef.ciently decidable for single-index LTL properties for Dual-PDS systems interacting via nested locks. \nHowever, a number of inter\u00adesting properties about concurrent programs, like data races, can only be \nexpressed as double-indexed properties. In this paper, we therefore consider double-indexed LTL properties. \nFurthermore, most of the work on the model checking of concurrent programs has focused on safety and \nlinear-time properties with little work ad\u00addressing branching-time properties. Hence from the branching-time \nspectrum, we consider Alternation-free Mu-Calculus properties. It turns out that unlike single-index \nLTL properties, the de\u00adcidability scenario for double-indexed LTL properties is more in\u00adteresting. While \nthe model checking problem for single-index LTL properties is ef.ciently decidable, it is, in general, \nnot decidable for the full-blown double-index LTL, but only for certain fragments. Undecidability of \na sub-logic of double-indexed LTL hinges on whether it is expressive enough to encode the disjointness \nof the context-free languages accepted by the PDSs in the given Multi-PDS system as a model checking \nproblem. This, in turn, depends on the temporal operators allowed by the logic thereby provid\u00ading a natural \nway to characterize fragments of double-indexed LTL for which the model checking problem is decidable. \nWe F use L(OPl,...,OPk),where OPiE{X,F,U,G,F}, to denote the fragment comprised of formulae of the form \nEI,where Iis double-indexed LTL formula in positive normal form (PNF), viz., only atomic propositions \nare negated, built using the operators OPl,...,OPkand the Boolean connectives Vand 1.Here X next- F time \n, F sometimes , U, until , G always , and F in.nitely\u00adoften denote the standard temporal operators and \nEis the ex\u00adistential path quanti.er . Obviously, L(X,U,G)is the full-blown double-indexed LTL. In this \npaper, we not only formulate ef.cient procedures for fragments of double-indexed LTL for which the model \nchecking for Dual-PDS system is decidable but also delineate precisely the decidability/undecidability \nboundary for each of the standard syn\u00adchronization primitives. Speci.cally, we show the following. The \nmodel checking problems for L(F,G)and L(U),viz., for\u00admulae in PNF allowing (i) only the until Utemporal \noperator, or (ii) only the always Gand the eventual Ftemporal op\u00aderators are, in general, undecidable \neven for Dual-PDS systems wherein the PDSs do not interact at all with each other. The above results \nimply that in order to get decidability for Dual-PDS systems, interacting or not, we have to restrict \nourselves F to either the sub-logic L(X,F,F)or the sub-logic L(G,X).For these sub-logics, the decidability \nof model checking depends on the synchronization primitive used by the PDSs. For PDSs interacting via \npairwise rendezvous we get the sur\u00adprising result that model checking problem is decidable for the sub-logic \nL(X,G). In fact, we show that the decidability re\u00adsult extends to PDS interacting via asynchronous rendezvous \nF and broadcasts. Regarding the other fragment, viz., L(X,F,F), it is already known that the model checking \nproblem is unde- F cidable for both the sub-logics L(F)and L(F)(and hence for F L(X,F,F)) for PDSs interacting \nusing either non-nested locks [10] or pairwise rendezvous [15]. The undecidability result for broadcasts \nand asynchronous rendezvous, both of which are more expressive than pairwise rendezvous, then follows. \nThis settles the model checking problem for all the standard syn\u00adchronization primitives. Finally, for \nthe practically important paradigm of PDSs interact\u00ading via nested locks, we show that the model checking \nproblem F is ef.ciently decidable for both the sub-logics L(X,F,F)and L(X,G). The fact that the undecidability \nresults hold even for systems with non-interacting PDSs may seem surprising at .rst. However, we note \nthat allowing doubly-indexed properties (wherein atomic propositions are interpreted over pairs of control \nstates of the PDSs comprising the given Dual-PDS system) allows us to explore pre\u00adcisely that portion \nof the state space of the given Dual-PDS system where the PDSs are coupled tightly enough to accept the \nintersec\u00adtion of the context-free languages accepted by them, thereby yield\u00ading undecidability. This \nis the key reason why the model checking problem for single-indexed LTL properties is robustly decidable \nfor PDSs interacting via nested locks, while for doubly indexed prop\u00aderties it is decidable only for \nvery restricted fragments that do not allow this strong coupling. The procedure for single-index LTL \nproperties for PDSs syn\u00adchronizing via nested locks, given in [9], involves reducing the model checking \nproblem to the computation of Pre*-closures of regular sets of con.gurations of the given Dual-PDS system. \nFor single-index properties, this was accomplished via a Dual Pumping Lemma, which, unfortunately, does \nnot hold for the double-indexed case. In fact, the undecidability of the model checking problem for doubly \nindexed formulae shows that such a reduction cannot exist in general. Thus model checking double-indexed \nLTL properties requires a different approach. F To get a model checking procedure for L(X,F,F), given \nan au\u00adtomaton R!accepting the set of con.gurations satisfying a formula F Iof L(X,F,F), we .rst formulate \nef.cient procedures for comput\u00ading an automaton Rop!accepting the set of all con.gurations that F satisfy \nOpI,where OpE{X,F,F}is a temporal operator that F can be used in a formula of L(X,F,F). Recursively \napplying these procedures starting from the atomic propositions and proceeding outwards in the given \nformula Ithen gives us the desired model checking algorithm. F A natural question that arises is that \nif L(X,F,F)model check\u00ading is decidable then why not full-blown double-indexed LTL model checking by \nreduction to the former via the automata\u00adtheoretic paradigm. The technical reason for this is discussed \nin the paper. However, the broad intuition is that the key obstacle to decidability of the model checking \nproblem for systems com\u00adprised of two PDSs is the problem of deciding the disjointness of the context-free \nlanguages accepted by the PDSs. If the PDSs can be coupled together tightly enough to accept the intersection \nof the context free languages accepted by the PDSs, we get unde\u00adcidability of the model checking problem. \nThis tight coupling can be achieved either by making the synchronization primitive strong enough, e.g., \nbroadcasts, or the property being model checked ex\u00adpressive enough, e.g., L(U). In fact, it turns out \nthat in order to ensure decidability of the model checking problem for Dual-PDS systems, we have to restrict \nourselves to properties that encode simple reachability or those for which the model checking prob\u00adlem \ncan be reduced to such properties. Guided by the above observations, for model checking L(X,G) we reduce \nthe problem to a set of simple reachability problems. Towards that end, given a formula Iof L(X,G), we \nconsider the equivalent problem of model checking for 9 I. Then the pos\u00aditive normal form of 9is a formula \nbuilt using the temporal opera\u00adtors AXand AF,where Ais the universal path quanti.er . Since AFis a simple \nreachability property the problem is decidable, even though constructing an automaton accepting RAF!from \nthe automaton R!is more complicated due to the branching nature of the property. For the branching-time \nspectrum, we consider the model check\u00ading problem for Alternation-free Mu-Calculus formulae. For lack \nof space, we focus only on single-index properties. For such proper\u00adties, we .rst show that the model \nchecking problem for PDSs com\u00admunicating via nested locks is ef.ciently decidable. Given a Multi-PDS \nsystemPcomprised of the PDSs Pl,...,Pn, and a formula . < <i,where <iis an alternation-fee Mu Calculus \nformula interpreted over the control states of Pi, we start by constructing the product Piof Piand A\u00a2;, \nthe Alternating Automaton for <i. Each such product Piis represented as an Alternating Pushdown System \n(APDS) [1] which incorporates the branching structure of the original PDS Pi. For model checking the \nMulti-PDS programPfor <, we need to compute the Pre *-closure of regular sets of global con.gurations \nof the system comprised of all the APDSs Pl,...,Pn. The main complexity here lies in the fact that we \nhave to reason about lock interactions along all paths of tree-like mod\u00adels of APDSs Pl,...,Pneach having \npotentially in.nitely many states. This complexity is overcome by our contribution showing how to decompose \nthe computation of the Pre *-closure of a regular set of con.gurations of a Dual-PDS systemPsynchronizing \nvia nested locks to that of its constituent PDSs. This decomposition allows us to avoid the state explosion \nproblem. To achieve the de\u00adcomposition, we leverage the new concept of Lock-Constrained Al\u00adternating \nMulti-Automata Pairs (LAMAPs) whichis usedtocapture regular sets of con.gurations of a given Multi-PDS \nsystem with nested locks. An LAMAP Aaccepting a regular set of con.gura\u00adtions Cof a Dual-PDS systemPcomprised \nof PDSs Pland P2is apair A(Al,A2),where Aiis an Alternating Multi-Automata (AMA) (see [1]) accepting \nthe regular set of local con.gurations of APDS Picorresponding to thread Pioccurring in the global con\u00ad.gurations \nofPin C. The lock interaction among threads is encoded in the acceptance criterion for an LAMAP which \n.lters out those pairs of local con\u00ad.gurations of Pland P2which are not simultaneously reachable due \nto lock interaction. Indeed, for a pair of tree-like models Wl and W2for <land <2in the individual APDS \nPland P2, respec\u00adtively, to act as a witness for < <l1<2in the Dual-PDS systemP, they need to be reconcilable \nwith respect to each other. Rec\u00adoncilability means that for each path xin Wlthere must exist a path yin \nW2such that the local computations of Pland P2corre\u00adsponding to xand y, respectively, can be executed \nin an interleaved fashion inP, and vice versa. For two individual paths xand y reconcilability can be \ndecided by tracking patterns of lock acqui\u00adsition along xand y. To check reconcilability of the trees \nWland W2, however, we need to track lock acquisition patterns along all paths of Wiin APDS Pi. A key \ndif.culty here is that since the depth of the tree Wicould be unbounded, the number of local paths of \nPiin Wicould be unbounded forcing us to potentially track an unbounded number of acquisition lock acquisition \npatterns. How\u00adever, the crucial observation is that since the number of locks in the Dual-PDS systemPis \n.xed, so is the number of all possible acquisition patterns. An important consequence is that instead \nof storing the lock acquisition patterns for each path of tree Wi,we need only store the different patterns \nencountered along all paths of the tree. This ensures that the set of patterns that need be tracked is \n.nite and bounded which can therefore be carried out as part of the control state of PDS Pi. Decomposition \nis then achieved by showing that given an LAMAP A(Al,A2),if 8iis an AMA accepting the Pre *-closure of \nthe con.gurations of the individual thread Piaccepted by Ai, then, the LAMAP 8 (8l,82)ac\u00adcepts the Pre \n*-closure of the regular set of con.gurations of the Dual-PDS systemPaccepted by A. Thus, broadly speaking, \nthe decomposition results from maintaining the local con.gurations of the constituent PDSs separately \nas AMAs and computing the Pre * \u00adclosures on these AMAs individually for each PDS for which exist\u00ading \nef.cient techniques can be leveraged. This yields decidability for PDSs interacting via nested locks. \nFor PDSs communicating via rendezvous and broadcasts, we show the decidability does not hold for the \nfull-blown single-indexed Alternation-free Mu-Calculus but only for certain fragments.  2. System Model \nIn this paper, we consider multi-threaded programs wherein threads synchronize using the standard primitives \n-locks, pairwise ren\u00addezvous, asynchronous rendezvous and broadcasts. Each thread is modeled as a Pushdown \nSystem (PDS) [1]. A PDS has a .nite control part corresponding to the valuation of the variables of the \nthread it represents and a stack which models recursion. Formally, aPDS is a.ve-tuple P(Q,At,r,o,.),where \nQis a .nite set of control locations, Act is a .nite set of actions, ris a .nite stack alphabet,and . \n(Qxr)xAtx(Qxr* )is a .nite set of transition rules.If ((P,,),a,(P',W))E.then we write  (P,,) (P',W).A \ncon.guration of Pis a pair (P,W),where PEQdenotes the control location and WEr*the stack content. We \ncall othe initial con.guration of P. The set of all con.gura\u00adtions of Pis denoted by C. For each action \na, wede.nearelation  CxCas follows: if (q,,) (q',W),then (q,,v)(q',Wv) for every vEr* . LetPbe a multi-PDS \nsystem comprised of the PDSs Pl,...,Pn, where Pi(Qi,Ati,ri,i,.i). In addition to Ati, we assume that \neach Pihas special actions symbols labeling transitions imple\u00admenting synchronization primitives. These \nsynchronizing action symbols are shared commonly across all PDSs. In this paper, we consider the following \nstandard primitives: Locks: Locks are used to enforce mutual exclusion. Transitions acquiring and releasing \nlock lare labeled with aquire(l)and relea e(l), respectively.  Rendezvous (Wait-Notify): We consider \ntwo notions of ren\u00addezvous: CCS-style Pairwise Rendezvous and the more expres\u00adsive Asynchronous Rendezvous \nmotivated by the Waitoand Notifyoprimitives of Java. Pairwise send and receive ren\u00ad  dezvous are labeled \nwith a!and a?, respectively. If ll l2 and 2l 22are pairwise send and receive transitions of Pl and P2, \nrespectively, then for the rendezvous to be enabled both Pland P2have to simultaneously be in local control \nstates ll and 2l. In that case both the send and receive transitions are .red synchronously in one execution \nstep. If Plis in llbut P2is not in l2then Plcannot execute the send transition, and vice versa. Asynchronous \nRendezvous send and receive transi\u00adtions, on the other hand, are labeled with atand a,, respec\u00adtively. \nThe difference between pairwise rendezvous and asyn\u00adchronous rendezvous, is that while in the former \ncase the send transition is blocking, in the latter it is non-blocking. Thus a transition of the form \nll l2can be executed irrespective of whether a matching receive transition of the form 2l 22 is currently \nenabled or not. On the other hand, the execution of a receive transition requires a matching send transition \nto be enabled with both the sender and receiver then being executed synchronously. Broadcasts (Notify-All): \nBroadcast send and receive rendezvous, motivated by the Waitoand NotifyAlloprimitives of Java, are labeled \nwith a!!and a??, respectively. If bllbl2is a broadcast send transition and b2lb22,..., bnlbn2are the \nmatching broadcast receives, then the receive transitions block pending the enabling of the send transition. \nThe send transi\u00adtions, on the other hand, is non-blocking and can always be executed and its execution \nis carried out synchronously with all the currently enabled receive transitions labeled with a??. A concurrent \nprogram with nPDSs and mlocks ll,...,lm is formally de.ned as a tuple of the form P= (Pl,...,Pn, Ll,...,Lm), \nwhere for each i, Pi(Qi,Ati,ri,i,i)is a pushdown system (thread), and for each j, Lj{.,Pl,...,Pn} is \nthe possible set of values that lock ljcan be assigned. A global con.guration of Pis a tuple (tl,...,tn,ll,...,lm)where \ntl,...,tnare, respectively, the con.gurations of PDSs Pl,...,Pn and ll,...,lmthe values of the locks. \nIf no thread holds lock liin con.guration ,then li.,else liis the thread currently holding it. The initial \nglobal con.guration of Pis (l,...,n,.,...,.), where iis the initial con.guration of PDS Pi. Thus all \nlocks are free to start with. We extend the relation to global global con.gurations of Pin the usual \nway. The reachability relation is the re.exive and transitive clo\u00adsure of the successor relation de.ned \nabove. A sequence x xo,xl,...of global con.gurations of Pis a computation if xois the initial global \ncon.guration of Pand for each i, xixi+l, where either for some j, aEAtj,or for some k, arelea e(lk) or \naaquire(lk)or pairwise rendezvous send ab!or re\u00adceive ab?, or asynchronous rendezvous send abtor receive \nab,, or broadcast send ab!!or receive ab??.Given a thread Tiand a reachable global con.guration (l,...,n, \nll,...,lm)of P,we use Lock-Set(Ti,)to denote the set of locks held by Tiin , viz., the set {lj ljTi}. \nAlso, given a thread Tiand a reachable global con.guration (l,...,n,ll,...,lm) of P,the projection of \nonto Ti, denoted by ,Ti,is de.ned ' to be the con.guration (i,ll,...,l ')of the concurrent program m \ncomprised solely of the thread Ti,where l 'Tiif liTiand ., otherwise (locks not held by Tiare freed). \ni Multi-Automata Let P(P,At,r,o,.)be a pushdown sys\u00adtem where P{Pl,...,Pm}.A P-multi-automaton (P-MA \nfor short) is a tuple A(r,Q,\u00c6,I,F)where Qis a .nite set of states, \u00c6QxrxQis a set of transitions, I{l,...,m}Qis \na set of initial states and FQis a set of .nal states. Each initial state icorresponds to the control \nstate Piof P. * We de.ne the transition relation QxrxQas the smallest relation satisfying the following: \n if (q,,,q ' )E\u00c6then q q ' , q qfor every qEQ,and '''''' if q qand q qthen q q. A multi-automaton can \nbe thought of as a data structure that is used to succinctly represent (potentially in.nite) regular \nsets of con.gurations of a given PDS. Towards that end, we say that multi\u00ad automaton Aaccepts a con.guration \n(Pi,W)if i qfor some qEF. The set of con.gurations recognized by Ais denoted by Conf(A). A set of con.gurations \nis regular if it is recognized by some MA. Relative Expressive Power of Synchronization Primitives. In \nproving the decidability results, we will exploit the following ex\u00adpressiveness relations: Pairwise Rendezvous \n<Asynchronous Ren\u00addezvous <Broadcasts,where <stands for the relation can be sim\u00adulated by (see [7] for \ndetails). Locks:a,b, nestedo{baro{nonnestedo{ aquireoa ; releaseob ; aquireob ; aquireob ; releaseoa \n; aquireoa ; baro ; baro ; aquireo ; releaseo ; releaseo ; }}} Figure 1. NestedVs.Non-nestedIokaess \nNested Lock Access. Additionally, we also consider the practically important case of PDSs with nested \naccess to locks. Indeed, stan\u00addard programming practice guidelines typically recommend that programs \nuse locks in a nested fashion. In fact, in languages like Java (version 1.4) and C# locks are guaranteed \nto be nested. We say that a concurrent program accesses locks in a nested fashion iff along each computation \nof the program a thread can only release the last lock that it acquired along that computation and that \nhas not yet been released. As an example in .gure 1, the thread comprised of procedures nestedand baraccesses \nlocks a,b,and in a nested fashion whereas the thread comprised of procedures non nestedand bar does not. \nThis is because calling barfrom non nestedreleases lock bbefore lock aeven though lock awas the last \none to be acquired. Correctness Properties. The problem of model checking Dual-PDS systems for the full-blown \nsingle-index LTL was shown to be ef.ciently decidable in [9]. In this paper, we consider double\u00adindexed \nLinear Temporal Logic (LTL) formulae. Here atomic propositions are interpreted over pairs of control \nstates of different PDSs in the given multi-PDS system. Note that our properties do not take the stack \ncontents of PDSs into account. This is because in data.ow analysis, the data.ow facts being tracked are \nusually modi.ed only by the program statements at individual control lo\u00adcations. The stack is merely \nused to track the context, viz., the order in which functions are called in reaching the current control \nlocation. Conventionally, P Ifor a given LTL formula Iif and only if Iis satis.ed along all paths starting \nat the initial state of P. Using path quanti.ers, we may write this as P AI. Equivalently, we can model \ncheck for the dual property AI EIE9. Furthermore, we can assume that 9is in positive normal form (PNF), \nviz., the negations are pushed inwards as far as possible using DeMorgan s Laws: ((PVq))P1q, (PVq)P1q, \nFP Gq, (PUq) GqVqU(P1q). For Dual-PDS systems, it turns out that the model checking problem is not decidable \nfor the full-blown double-indexed LTL but only for certain fragments. Decidability hinges on the set \nof temporal operators that are allowed in the given property which, in turn, provides a natural way to \ncharacterize such fragments. We F use L(OPl,...,OPk),where OPiE{X,F,U,G,F}, to denote the fragment of \ndouble-indexed LTL comprised of formulae in positive normal form (where only atomic propositions are \nnegated) built using the operators OPl,...,OPkand the Boolean connectives V and 1.Here X next-time , \nF sometimes , U, until , G always , F and F in.nitely-often denote the standard temporal operators (see \n[6]). Obviously, L(X,U,G)is the full-blown double-indexed LTL.  threadoneo{threadtwoo{ la:lokop ; lb:lokoq \n; 2a:lokoq ; 2b:lokor ; 3a:unlokoq ; 3b:unlokor ; 4a:------; 4b:-------; 5a:lokor ; 5b:lokop ; 6a:unlokor \n; 6b:unlokop ; 7a:------; 7b:-------; 8a:unlokop ; 8b:unlokoq; 9a:------; 9b:-------; }} (a) (b) Figure \n2. Program Pwith threads Pl(a) and P2(b).  3. A Review of Acquisition Histories and LMAPs The core of \nour decision procedure revolves around manipulating regular sets of con.gurations of the given Dual-PDS \nsystem P. A natural way to represent regular sets of con.gurations of a Dual-PDS system with PDSs interacting \nvia nested locks is by using the concept of Lock-Constrained Multi-Automata Pairs (LMAP) introduced in \n[9] which we brie.y review next. LMAPs allow us to not only succinctly represent potentially in.nite \nsets of regular con.gurations of Pbut, in addition, enable us to decompose Pre *-closure computations \nof regular sets of a Dual-PDS system Pto its individual PDSs thereby avoiding the state explosion problem. \nThis is accomplished via a Decomposition Result that generalizes both the Forward and Backward Decomposition \nresults as presented in [9]. Essentially, the Decomposition Result enables us to reduce the problem of \ndeciding the reachability of one global con.guration of Pfrom another to reachability problems for local \ncon.gurations of the individual PDSs. Lock-Constrained Multi-Automata. The main motivation behind de.ning \na Lock-Constrained Multi-Automaton (LMAP) is to de\u00adcompose the representation of a regular set of con.gurations \nof a Dual-PDS system Pcomprised of PDSs Pland P2into a pair of regular sets of con.gurations of the individual \nPDSs Pland P2. An LMAP accepting a regular set Rof con.gurations of Pis a pair of Multi-Automata M(Ml,M2),where \nMiis a multi\u00adautomaton accepting the regular set of local con.gurations Riof Piin R. A key advantage \nof this decomposition is that performing operations on M, for instance computing the Pre *-closure of \nR reduces to performing the same operations on the individual MAs Mi. This avoids the state explosion \nproblem thereby making our procedure ef.cient. The lock interaction among the PDSs is cap\u00adtured in the \nacceptance criterion for the LMAP via the concept of Backward and Forward Acquisition Histories [9] which \nwe brie.y recall next, followed by a formulation of the Decomposition Result. Consider a concurrent program \nPcomprised of the two threads shown in .gure 2. Suppose that we are interested in decid\u00ading whether a \npair of control locations of the two threads are simul\u00adtaneously reachable. We show that reasoning about \nreachability for the concurrent program, can be reduced to reasoning about reacha\u00adbility for the individual \nthreads. Observe that PEF(4a14b) but P EF(4a17b)even though disjoint sets of locks, viz., {P} and {q},are \nheld at 4aand 7b, respectively. The key point is that the simultaneous reachability of two control locations \nof Pland P2depends not merely on the locksets held at these locations but also on patterns of lock acquisition \nalong the computation paths of Pleading to these control locations. These patterns are captured using \nthe notions of backward and forward acquisition histories. l 2 5 d (i)bah l(ll(l) l l)(l3) 6 3 4 d (ii)fah \naq(l4) aq(l)aq(l2) Figure 3. Forward vs. Backward Acquisition History Indeed, if Plexecutes .rst it \nacquires pand does not release it along any path leading to 4a. This prevents P2from acquiring p which \nit requires in order to transit from lbto 7b. Similarly if P2 executes .rst, it acquires qthereby preventing \nPlfrom transiting from lato 4awhich requires it to acquire and release lock q.This creates an unresolvable \ncyclic dependency. These dependencies can be formally captured using the notions of backward and forward \nacquisition histories. De.nition (Forward Acquisition History) For a lock lheld by Pi at a control location \ndi, the forward acquisition history of lalong a local computation xiof Pileading from ito di, denoted \nby fah(Pi,i,l,xi), is the set of locks that have been acquired (and possibly released) by Pisince the \nlast acquisition of lby Piin traversing forward along xifrom ito di.Incase lis not acquired but held \nin each state along xithen fah(Pi,i,l,xi), is simply the set of locks that have been acquired (and possibly \nreleased) by Pi along xi. Observe that along any local computations xland x2of Pl and P2leading to control \nlocations 4aand 7b, respectively, fah(Pl,4a,P,xl){q}and fah(P2,7b,q,x2){P,r}.Also, '' along any local \ncomputations xland x2of Pland P2leading to ' control locations 4aand 4b, respectively, fah(Pl,4a,P,xl){q} \n' and fah(P2,4b,q,x2){r}. The reason EF(4a17b)does not hold but EF(4a14b)does is because of the existence \nof the cyclic dependency that PEfah(P2,7b,q,x2)and qEfah(P2,4a,P,xl) whereas no such dependency exists \nfor the second case. De.nition (Backward Acquisition History). For a lock lheld by Piat a control location \ni, the backward acquisition history of lalong a local computation xiof Pileading from ito di, denoted \nby bah(Pi,i,l,xi), is the set of locks that were released (and possibly acquired) by Pisince the last \nrelease of lby Pi in traversing backwards along xifrom dito i.In case lis not released but held in each \nstate along xithen bah(Pi,i,l,xi), is simply the set of locks that have been released (and possibly acquired) \nby Pialong xi. In [9], the concepts of backward and forward acquisition histories were used to decide \nwhether given two global con.gurations and dof P,whether dis reachable from . The notion of forward acquisition \nhistory was used in the case where no locks are held in and that of backward acquisition history in the \ncase where no locks are held in d. This is illustrated in .gure 3 where we want to decide whether is \nbackward reachable from d. First, we assume that all locks are free in d(case (i) in .gure 3). In that \ncase, we track the bahof each lock. In our example, lock l, initially held at , is .rst released at 2. \nThen all locks released before the .rst release of lbelongs to the bahof l. Thus, llbelongs to the bahof \nl but l3does not. On other hand, if in all locks are free (case (ii) in .gure 3), then we track the fahof \neach lock. If a lock lheld at dis last acquired at 3then all locks acquired since the last acquisition \nof lbelong to the fahof l. Thus in our example, l2belongs to the forward acquisition history of lbut \nl4does not. When testing for backward reachability of from din P, it suf.ces to test whether there exist \nlocal paths xand yof the individual PDSs from states l,Plto dld,Pland from 2,P2to d2d,P2, respectively, \nsuch that along xand ylocks operations can be executed in a acquisition history compatible fashion as \nformulated in the Decomposition Result below. Theorem 1 (Decomposition Result). Let Pbe a Dual-PDS sys\u00adtem \ncomprised of the two PDSs Pland P2with nested locks. Then con.guration of Pis backward reachable from \ncon.guration diff con.gurations l,Plof Pland 2,P2of P2 are backward reachable from con.gurations dld,Pland \nd2d,P2, respectively, via local computation paths xand yof PDSs Pland P2, respectively, such that 1. \nLock-Set(Pl,l)nLock-Set(P2,2)0 2. Lock-Set(Pl,dl)nLock-Set(P2,d2)0 3. Locks-Acq(x) nLocks-Held(y) 0and \nLocks-Acq(y) nLocks\u00adHeld(x) 0, where for path z, Locks-Acq(z)is the setoflocks that are acquired (and \npossibly released) along zand Locks\u00adHeld(z) is the set of locks that are held in all states along z. \n 4. there do not exist locks lELock-Set(Pl,l)\\Locks-Held(x) and l ' ELock-Set(P2,2)\\Locks-Held(y) such \nthat lEbah(P2, 2,l ' ,y)and l ' Ebah(Pl,l,l,x). 5. there do not exist locks lELock-Set(Pl,dl)\\Locks-Held(x) \nand l ' ELock-Set(P2,d2)\\Locks-Held(y) such that lE fah(P2,2,l ' ,y)and l ' Efah(Pl,l,l,x).  Intuitively, \nconditions 1 and 2 ensure that the locks held by Pland P2in a global con.guration of Pmust be disjoint; \ncondition 3 ensures that if a lock held by a PDS, say Pl, is not released along the entire local computation \nx, then it cannot be acquired by the other PDS P2all along its local computation y, and vice versa; and \nconditions 4 and 5 ensure compatibility of the acquisition histories, viz., the absence of cyclic dependencies \nas discussed above. We now demonstrate that the Decomposition Result allows us to reduce the Pre *-closure \ncomputation of a regular set of con.g\u00adurations of a Dual-PDS system to that of its individual acquisition \nhistory augmented PDSs. Towards that end, we .rst need to extend existing Pre *-closure computation procedures \nfor regular sets of con.gurations of a single PDS to handle regular sets of acquisition history augmented \n(ah-augmented ) con.gurations. An acquisition history augmented con.gurations iof Piis of the form ((Pi,W), \nll,...,lm,bahl,...,bahm,fahl,...,fahm)where for each i, fahi and bahiare lock sets storing, respectively, \nthe forward and back\u00adward acquisition history of lock li. Since the procedure is similar to the ones \nfor fahand bah-augmented con.gurations given in [9], its formal description is omitted. The key result \nis the following: Theorem 2 (ah-enhanced Pre *-computation). Given a PDS P, and a regular set of ah-augmented \ncon.gurations accepted by a multi-automaton A, we can construct a multi-automaton Apre. recognizing Pre \n* (ConI(A))in time polynomial in the sizes of Aand the control states of Pand exponential in the number \nof locks of P. Acceptance Criterion for LMAPs. The absence of cyclic depen\u00addencies encoded using bahsand \nfahs are used in the acceptance criterion for LMAPs to factor in lock interaction among the PDSs that \nprevents them from simultaneously reaching certain pairs of lo\u00adcal con.gurations. Motivated by the Decomposition \nTheorem, we say that augmented con.gurations l((,W),ll,...,lm,bahl, ...,bahm,fahl,...,fahm)and 2,W ' \n),ll' ,...,m,bahl' , (( ' l ' ...,bah ' fah ' l,...,fah ' )of Pland P2, respectively, are fah\u00ad m,mcompatible \niff there do not exist locks liand ljsuch that liPl, l ' P2, liEfah 'and ljEfahi. Analogously, we say \nthat land 2are bah-compatible iff there do not exist locks liand ljsuch that liPl, lj' P2, liEbahj'and \nljEbahi. jj De.nition 3 (LMAP Acceptance Criterion). Let A(Al,A2) be an LMAP,where Aiis a multi-automaton \naccepting ah\u00adaugmented con.gurations of Pi. We say that Aaccepts global con.guration ((Pi,W),(qj,v),ll,...,lm)of \nPiff there exist ' there exist augmented local con.gurations l((Pi,W),ll,..., l ' '' l '' m,bahl,...,bahm,fahl,...,fahm)and \n2((qj,v),ll,...,m, bah ' ,...,bah ' fah ' ,...,fah ' ),where l ' if liand . lm,lmiPlPlotherwise and li'' \nP2if liP2and .otherwise, such that 1. Aiaccepts i, and 2. Lock-Set(Pl,l)nLock-Set(P2,2)0, and 3. land \n2are bah-compatible and fah-compatible.  Given an LMAP A(Al,A2),we use ConI(A)to denote the set of \ncon.gurations of Paccepted by A.Let LMAP 8(8l,82), where 8iis the MA accepting Pre * (ConI(Ai))constructed \nfrom Aiusing an ah-augmented Pre *-closure computation procedure similar to the one for bahand fah-augmented \ncon.gurations given in [9]. Then corollary 4 follows easily from the Decomposition Result which when \ncombined with theorem 2 leads to the ef.cient Pre *-closure computation result formulated in theorem \n5 below. Corollary 4 (Pre *-closure Decomposition). Pre * (ConI(A)) ConI(8). Theorem 5 (Pre *-closure \nComputation). Let Abe an LMAP. Then we can construct an LMAP accepting Pre * (ConI(A)in polynomial time \nin the size of Pand exponential time in the number of locks of P. 4. Nested Locks: The Model Checking \nProcedure 0 for L(X,F,F) We start by presenting the decision procedures for model check- F ing L(X,F,F)and \nL(X,G)for PDSs interacting via nested locks. The model checking problem for single-indexed LTL\\Xformulae \ninterpreted over .nite paths was considered in [10] and over in\u00ad.nite paths in [9]. The procedures for \nsingle-index properties in\u00advolves reducing the model checking problem to the computation of Pre *-closures \nof regular sets of con.gurations of the given Dual-PDS system. For single-index properties, this was \naccomplished via a Dual Pumping Lemma, which, unfortunately, does not hold for the double-indexed case. \nTherefore, as discussed in the introduc\u00adtion, model checking multi-indexed formulae requires a different \napproach. Given an LMAP R!accepting the set of con.gurations satisfy- F ing a formula Iof L(X,F,F), \nwe give for each temporal operator F OpE{X,F,F}, a procedure for computing an LMAP Rop!ac\u00adcepting the \nset of all con.gurations that satisfy OpI. Recursively applying these procedures starting from the atomic \npropositions and proceeding outwards in the given formula Ithen gives us the desired model checking algorithm. \nThe construction of LMAP Rop!for the case where OpF, was given in [9] as were the constructions for the \nboolean con\u00adnectives 1and V. We now show how to handle the cases where FF OpE{F,X}starting with the \ncase where OpF. Given an LMAP R!, constructing the LMAP R.accepting the set of con- F! F .gurations \nof Psatisfying FIis, in general, not possible. In\u00addeed, that would make the model checking problem for \nthe full\u00adblown doubly-indexed LTL decidable, contrary to the undecidabil\u00adity results in section 7 which \nshow that R.can be constructed F! F only for the case where Iis a L(X,F,F)formula. However, even here \nthe construction becomes intricate when Iis an arbitrary F L(X,F,F)formula. To simplify the procedure, \nwe .rst show that FF given a formula Iof L(X,F,F), we can drive down the Fopera\u00adtor so that it quanti.es \nonly over atomic propositions or negations thereof. Then it suf.ces to construct an LMAP R.only for the \nF! case where Iis a (doubly-indexed) atomic proposition or negation thereof which can be accomplished \nelegantly. Formally, we show the following. F Proposition 6 (Driving down the Foperator). For any formula \nI F ' of L(X,F,F), we can construct a formula Iwhere the temporal F operator Fquanti.es only over atomic \npropositions or negations ' thereof such that PIiff PI. F Constructing an LMAP for FI. Note that if Iis \nan atomic * proposition or negation thereof, R!accepts the set {l}xrlx * {2}xr2,where (l,2)EC!QlxQ2is \nthe .nite set of pairs of control states of Pland P2satisfying I. F We start by proving an F-Reduction \nResult that allows us to reduce the construction of an LMAP accepting R.to multiple F instances of Pre \n*-closure computations for which theorem 5 can be leveraged. Let Pbe a Dual-PDS system comprised of PDSs \nPland P2and Ian atomic proposition, or negation thereof, over the control states of Pland P2. The key \nidea is to show that a con.guration ER.iff there is a .nite path leading to a F! pumpable cycle containing \na con.guration gsatisfying I.For a .nite state system, a pumpable cycle is a .nite path starting and \nending in the same state with goccurring along it. For a PDS which has in.nitely many states due to the \npresence of an unbounded stack, the notion of pump-ability is different. We say that a PDS is pumpable \nalong a .nite path xif executing xreturns the PDS to the same control location and the same symbol on \ntop of its stack as it started with, without popping any symbol not at the top of the stack to start \nwith. This allows us to execute the sequence of transitions along xback-to-back inde.nitely. In a Dual-PDS \nsystem, since we have two stacks, the pumping sequence of the individual PDSs can be staggered with respect \nto each other. More formally, let Pbe a Dual-PDS system comprised of the PDSs Pl(Ql,Atl,rl,l,l)and P2(Q2,At2,r2,2,2) \nand Ian atomic proposition or negation thereof. Then we can show the following. F Theorem 7 ( F-Reduction \nResult) Dual-PDS system Phas a F run satisfying FIstarting from an initial con.guration if and ** only \nif there exist aErl,jEr2; uErl,vEr2; a con.gura\u00adtion 9satisfying I; con.gurations lIland lI2in which \nall locks are ' ''' free; lock values ll,...,lm,ll,...,l ' ; control states P ' ,PEPl, m '''''''''*''''''* \nq,qEP2; u,u,uErl; and v,v,vEr2satisfying the following conditions 1. ((P,au),(q ' ,v ' ),ll,...,lm) ' \n''' 2. ((P,a),(q,v ' ),l,...,l)((P ' ,u),(q,jv),l,...,l) lmlm 3. ((P ' ,u ' ),(q,j),l ' m l,...,l ' ) \nlIl9lI2 '''' ((P,au '' ),(q,v),ll,...,lm) ((P ''''''''''' ,u),(q,jv),l,...,l) lm Intuitively, PDS Plcan \nbe pumped by executing the stem, ' viz., the sequence ((P,au),(q,v ' ),ll,...,lm)followed by repeatedly \nexecuting the pumpable control cycle, viz., the lo\u00ad ' cal sequence xllof Plalong ((P,a),(q,v ' ),ll,...,lm) \n'' ((P ' ,u ' ),(q,jv),ll,...,lm)followed by the local sequence xl2 of Plalong ((P ' ,u ' ),(q,j),l \n' ,...,l ' )lI9lI lml2 '''' ) ((P,au '' ),(q,v,ll,...,lm)back-to-back inde.nitely. Note that executing \nthe transitions along xllxl2returns Plto control loca\u00adtion Pwith aat the top of its stack so that it \ncan be executed again and again. Analogously, PDS P2can be pumped by repeatedly ex\u00ad ' ),(' ecuting the \nlocal sequences x2lof P2along ((P ' ,uq,j),ll, '''' ...,m)lI9lI2((P,au '' ),(q,v), ll,...,l) l ' lm \n ((P ''''''''''' ,u),(q,jv),ll,...,lm)back-to-back. Note that executing the transitions along x2lx22returns \nP2to control location qwith jat the top of its stack so that it can be pumped. We need to en\u00adsure, however, \nthat the transitions of Plalong xllxl2can executed in an interleaved fashion with the transitions of \nP2along x2lx22. The lock-free states lIland lI2states ensure that such a schedul\u00ad ' ing exists. Finally, \nthe sequence ((P,a),(q,v ' ),ll,...,lm) ''' ((P ' ,u),(q,jv),ll,...,lm)represents the stagger between \nthe pumping sequences of the two PDSs. Why the Reduction to Pre *-closure Computations does not work \nin general. A question that arises here is why can we not reduce the model checking problem for an arbitrary \ndouble-indexed LTL formula Ito the computation of Pre *-closures as above. Indeed, using the automata \ntheoretic approach to model checking, one can .rst construct the product 8Pof Pand the B\u00a8uchi Automaton \nfor I. Then model checking for Isimply reduces to checking whether there exists a path along which a \n.nal state of F 8Poccurs in.nitely often, viz, 9F9reenholds, where green is an atomic proposition characterizing \nthe set of .nal states of F 8P. Note that 9is a formula of L(X,F,F). It turns out that for the general \ncase, the direction of the above result holds but not the direction. Indeed, in order for ( ) to hold, \nwe have to decide whether we can construct an accepting sequence of 8P by appropriately scheduling the \nlocal transitions of PDSs Pland P2occurring along the .nite sequences satisfying conditions 1,2, F and \n3 of the F-Reduction result. However, the key point is that this scheduling must respect the constraints \nimposed by the B\u00a8uchi Automaton for I. All that the Decomposition result allows us to decide is whether \na global con.guration is reachable from another global con.guration dof P, viz., whether a scheduling \nof the local transitions exists that enables Pto reach dfrom .However it does not guarantee that this \nscheduling will not violate the B\u00a8uchi constraints for I. Indeed, as was discussed in the introduction, \nit is, in general, undecidable whether a scheduling satisfying given B\u00a8uchi constraints exists. F Reduction \nto the Computation of Pre *-closures. The F-Reduction result allows us to reduce the computation of an \nLMAP accepting F FIto the computation of Pre *-closures as given by the following encoding of the conditions \nof the above theorem. Let RoPre * ({P}xar * xP2xr * x{(ll,...,lm)}) l2 Then condition 1 can be re-written \nas ERo. Similarly, if **' RlPlxrx{q}xjr2x{(l ' ,...,lm)} ll R2Pre * (Rl)n{P}x{a}xP2xr2* x{(ll,...,lm)} \nthen condition 2 can be captured as R20. Finally, let **' R3Plxrx{q}xjr2x{(l ' ,...,lm)} ll R4Pre * (R3)n{P}xar \n* xP2xr * x{(ll,...,lm)} l2 R5Pre * (R4)nPlxr * lxP2xr * 2x{(.,...,.)}, . R6Pre * (R5)nGxLlx...xLm, where \nG(9.,9.)({9l}x ** rlx{92}xr2)with (9l,92)being a control state pair of P satisfying I, R7Pre * (R6)nPlxrl* \nxP2xr * x{(.,...,.)}, 2 Pre * nxr * x{q}x{j}x{l ' ,...,l ' )}. R8(R7)Plllm Then condition 3 is equivalent \nto R80. Thus the LMAP Ron F R2nR8accepts FI. Note that we need take the union of this LMAP for each \npossible value of the tuple (a,j,ll,...,lm).As a consequence of the above encoding and the the fact that \nPre * \u00adclosures, unions and intersections of LMAPs can be computed ef.ciently (theorem 5), we have the \nfollowing. Theorem 8. Let Pbe a Dual-PDS system synchronizing via nested locks and Ia boolean combination \nof atomic propositions. Then given an LMAP R!accepting a regular set of con.gurations of P, we can construct \nan LMAP R.accepting the set of F! F con.gurations satisfying FIin polynomial time in the size control \nstates of Pand exponential time in the number of locks. Constructing an LMAP for XI. Given an LMAP R!accepting \nthe set of con.gurations satisfying I,the LMAP Rx!, due to in\u00adterleaving semantics, is the disjunction \nover iof the LMAPs Rx;!, where Rx;!, is the LMAP accepting the pre-image of ConI(R!) in PDS Pi. The construction \nof LMAP Rx;!is the same as the one carried out in each step of the Pre *-closure computation procedure \nfor an individual ah-enhanced PDS. This completes the construction of the LMAP Rp!for each of F the operators \nOpE{X,F,F}leading to the following decidability result. F Theorem 9 (L(X,F,F)-decidability). The model \nchecking prob- F lem for L(X,F,F)is decidable for PDSs interacting via nested lock in time polynomial \nin the sets of control states of the given Dual-PDS system and exponential time in the number of locks. \n 5. Nested Locks: The Model Checking Procedure for L(X,G). Let Ibe a formula of L(X,G). We formulate \na decision procedure for the equivalent problem of model checking Pfor I.Since Iis a formula of L(X,G), \nthe positive normal form of its negation Iis a formula built using the operations AF,AX,V,1and atomic \npropositions or negations thereof interpreted over the control states of the PDSs constituting the given \nDual-PDS system. Given the formula 9I, we proceed as follows: 1. For each sub-formula Pof 9that is either \nan atomic proposi\u00adtion, or negation thereof, we construct an LMAP representing the set of regular con.gurations \nsatisfying P. 2. Next, given an LMAP accepting the set of con.gurations satisfying a sub-formula hof \n9, we give procedures for computing LMAPs accepting the regular set of con.gurations satisfying AXh and \nAFh. Leveraging these procedures and the closure properties of LMAPs under 1and Vthen gives us a procedure \nto construct an LMAP M.!accepting the set of con.gurations satisfying I. 3. In the .nal step, all we \ndo is check whether the initial con.g\u00aduration of Pis accepted by M.!.  Computing the LMAP accepting \nAF9. We next present a novel way to represent regular sets of con.gurations of a Dual-PDS sys\u00adtem that \nenables us to compute the regular set of con.gurations accepting AF9. To motivate our procedure, we recall \nthe one for model checking EF9. Our over-arching goal there was to reduce global reasoning about a Dual-PDS \nsystem Pfor EF9(and other linear-time temporal properties) to local reasoning about the indi\u00advidual PDSs. \nThis was accomplished by using the machinery of acquisition histories. Here, in order to test whether \nEF9,viz., there is a global path of Pstarting at and leading to a con.g\u00aduration dsatisfying 9, it is \nsuf.cient to test, whether for each i, there exists a local path xileading from ito di, the local con\u00ad.gurations \nof and din Pi, respectively, such that xland x2are acquisition-history compatible. Towards that end, \nwe augmented the local con.guration of each individual PDS Piwith acquisition history information with \nrespect to path xiand represented regular sets of con.gurations of Pas asingleLMAP M(Ml,M2), where each \nMiaccepts only those pair of augmented con.gura\u00adtions of Pland P2that are acquisition history compatible. \nThen, the Decomposition Result allowed us to reduce the problem of de\u00adciding whether EF9, to deciding, \nwhether there existed ah\u00adaugmented con.gurations accepted by Mland M2with Pland P2in local con.gurations \nland 2, respectively, that are acquisi\u00adtion history compatible. When deciding whether AF9, our goal \nremains the same, i.e., to reduce reasoning about the given Dual-PDS system to its in\u00addividual constituent \nPDSs. In this case, however, we have to check whether all paths starting at lead to a con.guration satisfying \n9. The set of all such paths is now a tree Trooted at with all its leaves comprised of con.gurations \nsatisfying 9. Analogous to the EF9case, we consider for each i, the local tree Tiresulting from the projection \nof each global path xof Tonto the local computa\u00adtion of Pialong x. Note that due to lock interaction \nnot all paths from the root to a leaf of Tlcan be executed in an interleaved fash\u00adion with a similar \npath of T2, and vice versa. Enumerating all pairs of compatible local paths of Tland T2andexecutingthem \ninall allowed interleavings will give us back the tree T. But from the Decomposition Result, we have \nthat a pair of local paths of Tland T2can executed in an interleaved fashion if and only if they are \nac\u00adquisition history compatible. In other words, to reconstruct Tfrom Tland T2, we have to track the \nacquisition history along each path starting from the root of Tito its leaves. A key dif.culty is that \nsince the depth of tree Ticould be un\u00adbounded, the number of local paths of Pifrom iin Ticould be unbounded \nforcing us to potentially track an unbounded num\u00adber of acquisition histories. However, the crucial observation \nis that since the number of locks in the Dual-PDS system Pis .xed, viz., m, so is the number of all possible \nacquisition histo\u00adries (2m(2m+3)in fact). An important consequence is that instead of storing the acquisition \nhistory for each path of tree Ti, we need only store the different acquisition histories encountered \nalong all paths of the tree. This ensures that the set of acquisition histo\u00adries that need be tracked \nis .nite and bounded and can therefore be tracked as part of the control state of PDS Pi. Thus an aug\u00admented \ncontrol state of Piis now of the form (i,A1),where A1{ahl,...,ahk}is a set of acquisition history tuples \nand i is a control state of Pi. Each acquisition history tuple ahjis of the form (bahl,...,bahm,fahl,...,fahm),where \nbahjand fahjtrack, respectively, the backward and forward acquisition history tuples of lock lj. For \nmodel checking AFP, wemakeuse of a Pre *-closure algo\u00adrithm based on the .xpoint characterization AFIJY.IVAXY. \nNote that since the given Dual-PDS system has in.nitely many states, by naively applying the above procedure \nwe are not guar\u00adanteed to terminate. We now propose a novel way to perform Pre * \u00adclosures over regular \nsets of con.gurations augmented with ac\u00adquisition history sets. These regular sets are now represented \nas LMAPs accepting con.gurations augmented with acquisition his\u00adtory sets instead of merely acquisition \nhistories and are thus re\u00adferred to as Augmented LMAPS (A-LMAPs). Using A-LMAPs en\u00adables us to carry \nout this Pre *-closure ef.ciently. Computing AFI. Let Mo(Mol,Mo2)be an A-LMAP ac\u00adcepting the set of regular \ncon.gurations satisfying I. To start with, the fahand bahentries of each acquisition tuple are set to \n0.Start\u00ading at Mo, we construct a .nite series of A-LMAPs Mo,...,Mp resulting in the A-LMAP Mpaccepting \nthe set of con.gurations satisfying AFI. We denote by kthe transition relation of Mk. Then for every \nk?0, Mk+lis obtained from Mkby conserving the set of states and adding new transitions as follows: Let \nl (l,A1l)and 2 (2,A12)be a pair of acquisition-history compatible augmented control con.gurations of \nPland P2, respec\u00adtively. We need to check whether all enabled successors from the augmented control state \n(l,2)of Pare accepted by Mk.Let tril,..., tril; be all the local transitions of Pithat can be .red by \nPfrom (l,2). We check for each transition trij:iij, whether one of the following conditions holds if \ntrijis an internal transition of Piof the form (i,,) * (ij,u)then in Mk(Mkl,Mk2),for some WEri, the augmented \ncon.guration ((ij,A1i),uW)is accepted by Mki, viz., there is a path xof Mkistarting at (ij,A1i)and ' \nleading to a .nal state of Mkisuch that there is a pre.x xof xleading from (ij,A1i)to a state ( ' ij,A1i), \nsay, such that ' xis labeled with u. quire(l) if trijis the locking transition iij, then there is an \naccepting path in Mkistarting at (ij,A1 ' i),where A1 ' {ah ' EA1i}with ahimobtained from ah ' iimahimim \nby factoring in the acquisition of l. We remove the fahfor lock l(since in the backward step lhas now \nbeen released) and add lto the fahof every other lock. Similarly lis added to the bah of every other \nlock initially held by Piwhen starting from Mo and the bahof lis dropped if it was not held initially \nwhen starting from Mo. rele se(l) if trijis the unlocking transition i ij, then the there is an accepting \npath in Mkistarting at (ij,A1 ' i),where A1 ' {ah ' ahimEA1i}with ahimobtained from ah ' iim im by adding \nan empty FAH-entry, for l(since in the backward step lhas now been acquired). If for each i, at least \none of the above conditions holds for each of the transitions tril,...,tril;,thenin M(k+l)i, for each \ntrij,we add an internal transition from state Din Mito 'D(Dj,A1 ' D)or a transition labeled with ,to \nthe state 'D(Dj,A1D)accordingly ' as trijis a locking\\unlocking transition or an internal transition, \nrespectively. Since in constructing Mk+lfrom Mk, weadd anew transition to Mkbut conserve the state set, \nwe are guaranteed to reach a .xpoint. Then the resulting A-LMAP accepts AFI. Computing the LMAP accepting \nAXI. The construction is sim\u00adilar to the one carried out in each step of the above procedure for computing \nAFIand is therefore omitted. This completes the formulation of procedures for computing A-LMAPs accepting \nAXIand AFIleading to the following result. Theorem 10 (L(X,G)Decidability). The model checking problem \nfor Dual-PDS system Psynchronizing via nested locks is decid\u00adable for L(X,G)in polynomial time in the \nsize of the control state of Pand exponential time in the number of locks.  6. Rendezvous and Broadcasts: \nDecidability of L(X,G) In order to get decidability of L(X,G)for PDSs interacting via asynchronous rendezvous, \nwe reduce the problem to the model checking problem for non-interacting Dual-PDS systems for L(X,G)which \nby theorem 10 is decidable. Let Pbe a given Dual-PDS system comprised of PDSs Pland ' P2interacting via \nasynchronous rendezvous. Let Pbe the PDS we iget from Piby replacing each asynchronous send transition \nof the form lll2by the sequence of internal transitions ll l2. Similarly, each asynchronous receive transition \nof the form 2l22is replaced by the sequence of internal transitions ' 2l22. Note that Pihas no rendezvous \ntransitions. Let ' Pbe the Dual-PDS systems comprised of the non-interacting '' PDSs Pland P2. The key \nidea is to construct a formula IAR ' of L(X,G)such that PEIiff PE(I1IAR).The decidability of model checking \nfor L(X,G)then follows from theorem 10. In order to simulate asynchronous rendezvous, we have to en\u00ad \n''  sure that (i) whenever Pland P2are in control states lland 2l, respectively, then we execute the \ntransitions 2l , ll, 22and l2back-to-back, and (ii) ' '' whenever P2is in local state 2lbut Plis not \nin ll,PDS P2 blocks. This can be accomplished by ensuring that each state satis\u00ad ' .es IAR((2l1llX2l)1((ll1l2)X(ll1a)1 \nXX(a1a)1XXX)(221a)1XXXX(221l2)). Thus we set ' IARGIAR. The case for broadcasts can be handled similarly. \nSince pairwise rendezvous is less expressive than asynchronous rendezvous, the decidability of L(X,G)for \npairwise rendezvous follows. Theorem 11 (L(X,G)Decidability). The model checking problem for Dual-PDS \nsystem interacting via rendezvous and broadcasts are decidable for L(X,G). 7. Decidability Limits for \nModel Checking Multi-PDS Systems While it was shown in [9], that the problem of model checking Multi-PDS \nsystems interacting via nested locks for single-index LTL\\X properties is ef.ciently decidable, the problem \nis not as robustly decidable for double-index properties. In turns out that even when the PDSs in a Dual-PDS \nsystem do not interact with each other, the model checking problem for double-indexed LTL becomes undecidable. \nIn fact, we show the much stronger results that the problem is undecidable even for the following restricted \nfragments of double-indexed LTL: (i) L(G,F)and (ii) L(U). The Undecidability Results. We show both the \nundecidability results by reduction from the problem of deciding the disjointness of the context-free \nlanguages accepted by two given Pushdown Automata (PDA). Recall that the language accepted by a PDA P(P,At,r,o,.), \ndenoted by L(P),is the set of all words * WErsuch that there is a valid path of Plabeled with Wleading \nfrom the initial to a .nal control state of P. In order to encode the testing of L(Pl)nL(P2)0, as a model \nchecking problem, we need to make sure that every execution of a transition trlof Pllabeled with an action \nsymbol ais matched by an execution of a transition tr2of P2also labeled with athat immediately follows \nthe execution of trl. Then testing whether L(Pl)nL(P2)0, reduces to deciding whether there exists a reachable \nglobal con.guration of Pwith both Pland P2in .nal local states. Let Pbe the Dual-PDS system comprised \nof PDSs Pland P2. We construct a formula Iof L(G,F)such that PIiff L(Pl)n L(P2)0. Since testing the disjointness \nof the context-free languages accepted by two PDSs is undecidable, the undecidability of the model checking \nproblem for L(G,F)follows. Undecidability of Model Checking L(G,F). We construct a for\u00admula IIcomprised \nof the always operator Gsuch that Psat\u00adis.es IIonly along those paths where execution of transitions \nof the two PDSs Pland P2labeled with the same symbol acan only execute back-to-back. Towards that end, \nlet trl:ldland tr2:2d2be a pair of transitions of Pland P2, respectively, both labeled with a. In each \nPDS Pi, we introduce new local control states iland i2and the new transitions tril:iil, tri2:ili2 and \ntri3:i2di. Then to simulate the synchronization of the .ring of trland tr2, we impose the condition that \nthe transitions trl2and tr22are always .red back-to-back. This can be ensured by requiring that the formula \nII(2llVllVl2)1(ll (2V2l))1(l22lV22)1(dl 2l)is satis.ed in each global con.guration along a computation. \nThus along every path satisfying GIIthe execution of each transition of one PDS is matched by the execution \nof a transition of the other PDS labeled . with the same action. Then L(Pi)nL(P2)0iff PIIIF, where IFV(!;,!j)EF.XF.(F(Ii1Ij)), \nensures that both PDSs simultaneously reach a .nal state. This gives us the following result. Theorem \n12. The model checking problem for a system comprised of two non-interacting PDS is undecidable for the \nlogic L(G,F). Disjointness of Context-Free Languages via L(U) formulae. In this case, all we need to \nensure is that the formula IIholds only at each state along a path leading to a global con.guration with \nboth Pland P2in .nal states. Note that once Pland P2are both in .nal states, we need no longer check \nthat IIis satis.ed. These condition can be captured by the formula IIUIF. Thus, L(Pl)nL(P2)0 iff PIIUIF. \nThis gives us the following result. Theorem 13. The model checking problem for a system comprised of \ntwo non-interacting PDS is undecidable for the logic L(U).  8. Branching Time Properties While LTL is \na very expressive linear time logic, there are some critical properties like deadlockability which are \ninherently branch\u00ading time and therefore cannot be expressed in a linear-time frame\u00adwork. In this section, \nwe focus our attention on branching-time tem\u00adporal logics. Speci.cally, we consider the model checking \nproblem for Dual-PDS systems for Alternation Free Mu-Calculus formulae. For lack of space, we only consider \nsingle-index properties. For Dual-PDS systems interacting via nested locks, we show that the problem \nof model checking single-index alternation free Mu-Calculus is decidable. For PDSs interacting via rendezvous \nand broadcasts, however, it remains undecidable in general. 8.1 Single Index Branching-Time Properties \nWe begin by formulating the model checking procedure for PDSs interacting via nested locks. As for the \nlinear-time case, our goal is to reduce the model checking problem for Alternation-free Mu-Calculus properties \nfor a Dual-PDS system to its individual PDSs. In order to accomplish that we introduce the new concept \nof a Lock-Constrained Alternating Multi-Automata Pair (LAMAP) that allows us to reduce the Pre *-closure \ncomputation for a regular set of con.gurations for a Dual-PDS systems to its individual PDSs. Thus LAMAPs \nare the branching-time analogue of LMAPs used previously for model checking linear-time properties. Lock-Constrained \nAlternating Multi-Automata Pair (LAMAP). To motivate the concept of an LAMAP, we .rst re-visit the notions \nof Alternating Pushdown Systems (APDS) and Alternating Multi-Automata (AMA) used in the model checking \nof branching-time properties of individual PDSs (see [1]). Model checking branching\u00adtime temporal logics, \nin general, require us to reason about all suc\u00adcessors of a global con.guration of the given PDS. This \nbranching nature of properties is typically captured by building an alternat\u00ading multi-automaton (AMA) \nor a tableau for the given property and then taking the product of the state space of the given PDS with \nthis AMA. Such products can be modeled in a natural fash\u00adion by using the concept of an APDS [1] wherein \nby executing a transition a PDS can transit from a single con.guration to a set of con.gurations, instead \nof just a single con.guration as for the linear time case. Model Checking then reduces to computing Pre \n* \u00adclosures of regular sets of con.gurations of APDSs. Regular sets of con.gurations of APDSs can be \ncaptured succinctly using the concept of AMAs [1] which are the branching-time analogue of Multi-Automata \n(MA) the difference again being that in AMAs each transition from a state can have multiple successors. \n An LAMAP plays the same role in model checking Dual-PDS systems for branching time properties as an \nLMAP does in model checking for linear time properties by allowing us to .nitely rep\u00adresent (potentially \nin.nite) regular sets of con.gurations of the given concurrent program in a way that enables us to compute \ntheir Pre *-closures ef.ciently. Whereas, an LMAP is a pair of MAs, an LAMAP Mis a pair (Ml,M2)of AMAs \nwith AMA Mirepre\u00adsenting regular sets of con.gurations of APDS Picorresponding to PDS Pi. However, the \nkey dif.culty in extending the concept of an LMAP to that of an LAMAP lies in capturing the lock in\u00adteraction \namong the PDSs. For an LMAP, the lock interaction is captured by tracking acquisition histories along \nindividual runs of the two PDSs. For a PDS every run corresponds to a unique path of a PDS. The acquisition \nhistory of a given lock in a global state along a path is unique and can be tracked by augmenting the \ncon.g\u00adurations of each PDS. However, a run of an APDS has a tree-like structure and therefore corresponds \nto multiple paths of the PDS from which the APDS is derived via the product construction. To ensure that \ntree-like runs runland run2of Pland P2, respec\u00adtively, are reconcilable we need to check that for each \nlocal path of Plalong runlthere exists a local path yof P2along run2 such that xand ycan be .red in an \ninterleaved fashion, and vice versa. But this is precisely the same problem that we faced when building \nan LMAP for AFIin the previous section. As before, the solution is to track in each local con.guration \niof AMA Miall the different acquisition histories encountered along all paths of Witistarting at i. Thus \nan ah-augmented con.guration of Piis of the form i((i,A1i),ui). In order to check that augmented con.gurations \nl((l,A1l),ul)and 2((2,A12),u2) accepted by Mland M2, respectively, are compatible, one need merely check \nthat for each acquisition history ahEA1lthere is a compatible acquisition history ah ' EA12, and vice \nversa. In other words, we let LAMAP Aaccept (l,2)iff land 2 is accepted by Pland P2via witnesses Witland \nWit2where Witl and Wit2are reconcilable with respect to each other, i.e., for each path xin Witlthere \nmust be a path yin Wit2such that the local computations of Pland P2corresponding to xand y, respectively, \ncan be executed by Pin an interleaved fashion starting at ,and vice versa. This ensures that for each \ni, Witiis indeed a legitimate witness for Din the Dual-PDS system P. We show that the model checking \nproblem for PDSs interact\u00ading via nested locks can be reduced to the computation of Pre * \u00adclosures of \nregular sets of con.gurations accepted by LAMAPs. A key property of LAMAPs is that not only are they \nclosed under the computation of Pre *-closures but that the Pre *-closure computa\u00adtion for a given LAMAP \ncan be reduced to Pre *-closure computa\u00adtions for regular sets of con.gurations of the individual PDSs \nthus avoiding the state explosion problem. We start by formally de.ning the notion of an LAMAP. 8.1.1 \nLock Constrained Alternating Multi-Automata Pair Let Pbe a given Dual-PDS system comprised of the two \nPDSs Pl(Ql,Atl,rl,l,l)and P2(Q2,At2,r2,2, . 2),and Ia single index alternation-free Mu-Calculus iIi \nformula. A Lock-Constrained Alternating Multi-Automata Pair (LAMAP) for P, denoted by P-LAMAP, is a pair \n(Al,A2), where Ai(ri,Qi,\u00c6i,Ii,Fi)is an AMA accepting a (regular) set of con.gurations of the APDS Piobtained \nfrom Piby taking the product of Piwith the alternating automaton for Ii.Let l ((l,A1l),ul),and 2((2,A12),u2)be \nah-augmented con.gurations of Pland P2, respectively. Recall that by our con\u00adstruction, A1itracks the \nset of acquisition histories encountered along all paths of a tree-like run Wiof Pistarting at (i,ui)with \neach acquisition history tuple ahijEA1itracking the acquisition history of some path(s) of Plalong Wl. \nMotivated by the Decom\u00adposition Result, we say that acquisition history tuples ahl(Ih, bahl,...,bahm,fahl,...,fahm)and \nah2(Ih ' ,bah ' l,...,bah ' , m fah ' l,...,fah ' )are compatible iff the following conditions are satis.ed \n(i) fah-compatibility: there do not exist locks liand lj such that liPl, lj' P2, liEfah ' jand ljEfahi, \n(ii) bah\u00adcompatibility: there do not exist locks liand ljsuch that liPl, lj' P2, liEbahj' and ljEbahi, \nand (iii) Disjointness of Lock\u00adsets: IhnIh ' 0. Then for each local path of Plalong Wlstarting at lto \nbe executable in an interleaved fashion with some local path of P2starting at 2, for each ahljEA1lthere \nmust exist ah2j.EA12such that ahljand ah2j.are compatible, and vice versa, thereby leading us to the \nfollowing de.nition. m De.nition 14 (LAMAP Acceptance). Let A(Al,A2)be a P-LAMAP. We say that Aaccepts \ncon.guration ((Pl,ul),(P2, u2),ll,...,lm)of Piff there exist acquisition history tuples A1land A12, with \nthe same locksets as those held by Pland P2, respectively, in , such that the following holds 1. Aiaccepts \n((Pi,A1i),ui), and 2. A1land A12are compatible, viz., for each tuple ahlEA1l there exists a tuple ah2EA12such \nthat ahland ah2are compatible, and vice versa.  Given a P-LAMAP A,we use ConI(A)to denote the set of \ncon.gurations of Paccepted by A. Our broad goal is the reduc\u00adtion of Model Checking of a Dual-PDS system \nto its individual PDSs. This is accomplished by (i) reducing the model checking problem for single-index \nalternation free Mu-calculus formulae to the computation of Pre *-closures for LAMAPs, and (ii) reducing \nthe Pre *-closure for LAMAPs to that for the individual AMAs con\u00adstituting the LAMAPs. We .rst show how \nto compute Pre *-closure for a regular set of ah-enhanced con.gurations accepted by a given AMA. This \nwill immediately lead to a procedure for Pre *-closure computation for LAMAPs. ah-enhanced Pre *-computation. \nWe outline only the broad steps of the procedure. We start with an AMA Aaccepting a regular set Cof acquisition \nhistory augmented con.gurations of an APDS P. Corresponding to each augmented control state (j,A1)we \nhave, as in [1], an initial state (j,A1)of the multi-automaton A, and vice versa. We set AoAand construct \na .nite sequence of AMAs Ao,...,Apresulting in the AMA Apsuch that the set of ah-augmented con.gurations \naccepted by Apis the Pre *-closure of the set of AH-augmented con.gurations accepted by A.We de\u00adnote \nby ithe transition relation of Ai.For every i?0, Ai+l is obtained from Aiby conserving the sets of states \nand transi\u00adtions of Aiand adding new transitions as follows. The key differ\u00adence from the linear time \ncase is that now we need to compute a pre-image with respect to AXinstead of EX. Thus for every inter\u00adnal \ntransition (Pj,,){(Pk.,Wl),...,(Pkn,Wn)}and every set . n (k.,A1l)iQl,...,(kn,A1n)iQn,we add the new \ntransition (j,A1lU...UA1n)i+l(QlU...UQn).For every backward execution of a lock/unlock transition from \na con\u00ad.guration ((i,A1i,ui)we now need to update every acquisition history in the set A1i, instead of \nmerely one. Then we have the following result. Proposition 15. Given an APDS P, and a regular set of \nah\u00adaugmented con.gurations of Paccepted by an AMA A,we can construct an AMA Apre.recognizing Pre * (ConI(A))in \ntime polynomial in the size of the control set of Pand exponential the size of Aand the number of locks \nof P. Computing the pre*-closure of a LAMAP. Let LCbe a regular set accepted by a P-LAMAP A(Al,A2). In \nthis section, we show that we can construct a P-LAMAP 8(8l,82)accepting Pre * (LC). The Procedure. Since \nAland A2are AMAs accepting regular sets of con.gurations of the individual APDSs Pland P2,re\u00adspectively, \nwe can construct, using the technique presented above, AMAs 8land 82, accepting, respectively, the Pre \n*-closures, Pre *(ConI(Al))and Pre *(ConI(A2)). Then the following p.p.result effectively formulates \nthe decomposition of Pre *-closures for a Dual-PDS system with nested locks to its constituent PDSs. \nTheorem 16. Let Rbe a regular set of con.gurations of Pac\u00adcepted by the P-LAMAP A.If 8is the P-LAMAP \nconstructed from Aas above, then ConI(8)Pre * (R). Complexity Analysis. Note that the computation of \nan LAMAP 8(8l,82)accepting the Pre *-closure of a given LAMAP A (Al,A2)reduces to the computation of \nAMAs 8iaccepting the Pre *-closure of ConI(Ai)for each individual PDS Pi, instead of the entire system \nP. From proposition 15, 8ican be computed in polynomial time in the size of the control set of Piand \nexponential time in the size of Aiand number of locks of Pi. Thus we have the following Theorem 17. Given \na Dual-PDS system Pcomprised of PDSs Pland P2interacting via nested locks, and a P-LAMAP A (Al,A2), we \ncan construct a P-LAMAP Apre.recognizing Pre * (ConI(A))in time polynomial in the size of the control \nset of each Piexponential time in the size of Aand the number of locks of P.  8.2 The Model Checking \nProcedure We now show how to reduce the model checking of Dual-PDS systems with nested locks for single-index \nalternation-free mu\u00adcalculus formulas to it individual PDSs. Let Pbe a concurrent program comprised of \nthe PDSs Pl (Ql,Atl,rl,l,l)and P2(Q2,At2,r2,2,2)and a . labeling function Ai:Qi2r p;.Let hhi,where hi \nis an alternation-free weak J-calculus formula interpreted over the control states of thread Piand let \nVibe a valuation of the free variables in hi. As in [1], we begin by constructing an APDS Pi that represents \nthe product of Piand an alternating automaton for hi.Set <hi. We start by considering the case where \nall the O-subformulas of <are J-formulas. The product APDS \u00a2\u00a2 Pi(Qi,ri,i)of Piand the alternating automaton \nfor hi,is straightforward to de.ne and is omitted. In order to decide whether two runs of Pland P2are \nreconcilable, we need to augment each con.guration of Piwith acquisition history set information as discussed \nin section 9.1. With this in mind, let Ctibe the subset of con.gurations of Picontaining all augmented \ncon.gurations of the form ([(P,A10),7],u),  ([(P,A10),7],u),  ([(P,A10),X],u),where Xis free in <and \n(P,u)EVi(X). where A10is the (2m)-tuple {(0,...,0)}-all acquisition histories are set to the empty set \nto start with. Clearly, if Viis a regular set of con.gurations for every variable Xfree in <i,then Ctiis \nalso a regular set of con.gurations. Then using the concept of signatures for mu-calculus sentences, \nas in [1], we have. Proposition 18 ([1]) Let Pibe the APDS obtained from Piand hiusing the construction \nabove. A con.guration ((P,A1),u)of Pibelongs to [[<i] iff the con.guration ([(P,A1),<i],u)of Pi belongs \nto Pre *(Cti) p; Furthermore, as in [1], the case where all the O-subformulas of <i are v-subformulas \ncan now be tackled by (i) noting that the nega\u00ad ' tion of <iis equivalent to a formula <in positive normal \nform i whose O-subformulas are all J-subformulas (ii) applying propo\u00adsition 18, to construct an AMA which \naccepts the con.gurations ' of Pithat satisfy <i, and .nally (iii) using the fact that AMAs are closed \nunder complementation. Then the general case for the alternation-free mu calculus can be handled by recursively \napply\u00ading the procedure for the above two cases (see [1] for details) giving us the following result \nanalogous to that in [1], but for PDSs with ah-augmented control states. Theorem 19 ([1]) Let Pibe the \nAPDS corresponding to thread Pi as constructed above, and let hia formula of the alternation-free mu-calculus \ninterpreted over the local con.gurations of Pi, and let Vibe a valuation of the free variables of hi. \nWe can construct an AMA Ah; such that ConI(Ah;)[[hi] T;(Vi). The key reduction result is formulated below. \nTheorem 20 (Reduction Result) A con.guration ((Pl,ul), (P2,u2),ll,...,lm)of Pbelongs to [ h] iff there \nexists a pair of compatible acquisition history sets A1land A12such that the con.guration (([(Pl,A1l),hl],ul),([(P2,A12),h2],u2),ll, \n...,lm)is accepted by the P-LAMAP Ah(Ah.,Ah.). This reduces the model checking problem to the construction \nof the AMAs Ah;. Then using theorem 17 and the above construction we have the following. Theorem 21 (Single-index \nMu-Calculus Decidability) The model checking problem for single index alternation-free weak Mu-Calculus \nformulas for Dual-PDS systems synchronizing via nested locks is decidable in time exponential in the \nsizes of control states of the individual PDSs and the number of locks. Rendezvous and Broadcasts. For \nPDS interacting via rendezvous and broadcasts, even single-index reachability is undecidable [15] which \nimplies undecidability of the model checking problem for single-index Alternation-free Mu-Calculus. \n 9. Concluding Remarks Among prior work on the veri.cation for concurrent programs, [3] attempts to \ngeneralize the techniques given in [1] to handle push\u00addown systems communicating via CCS-style pairwise \nrendezvous. However since even reachability is undecidable for such a frame\u00adwork, the procedures are \nnot guaranteed to terminate in general but only for certain special cases, some of which the authors \nidentify. The key idea here is to restrict interaction among the threads so as to bypass the undecidability \nbarrier. Another natural way to obtain decidability is to explore the state space of the given concurrent \nmulti-threaded program for a bounded number of context switches among the threads [14]. For PDSs interacting \nvia rendezvous, over\u00adapproximation techniques to achieve termination while performing reachability are \nconsidered in [5]. Other related interesting work includes the use of tree automata [12] and logic programs \n[8] for model checking the processes al\u00adgebra PA which allows modeling of non-determinism, sequential \nand parallel composition and recursion. The reachability analysis of Constrained Dynamic Pushdown Networks \nwhich extend the PA framework by allowing PDSs that can spawn new PDSs to model fork operations, was \nconsidered in [4]. However, neither model allows communication among processes. To model interac\u00adtion \namong threads, Asynchronous Dynamic Pushdown Network has been proposed recently [2]. This model allows \ncommunica\u00adtion via shared variables which however makes the model check\u00ading problem undecidable. This \nproblem is bypassed by considering the restricted bounded model checking problem wherein only those computations \nof the given program are explored where each thread is only allowed a bounded number of updates to the \nshared vari\u00adables. Another approach that has been explored is to extend the classical procedure-summary \nbased inter-procedural data.ow anal\u00adysis for sequential programs to concurrent programs via the use of \ntransactions [13]. In this paper, we have focused on the model checking of In\u00adteracting Pushdown Systems \nsynchronizing via the standard primi\u00adtives -locks, rendezvous and broadcasts, for rich classes of tem\u00adporal \nproperties -both linear and branching time. Since inter\u00adprocedural data.ow analysis for concurrent programs \nhinges on an ef.cient model checking algorithms for interacting PDS systems, it is important we identify \ntemporal logic fragments and useful mod\u00adels of interacting PDSs for which the problem is decidable. In \nthis paper, we have accomplished precisely this. Speci.cally, we have formulated new ef.cient algorithms \nfor model checking interacting PDSs for important fragments of LTL and Mu-Calculus. Addition\u00adally, we \nalso delineate precisely the decidability boundary for each of the standard synchronization primitives. \n References [1] A. Bouajjani, J. Esparza, and O. Maler. Reachability analysis of pushdown automata: Application \nto model-checking. In CONCUR, LNCS 1243, pages 135 150, 1997. [2] A. Bouajjani, J. Esparza, S. Schwoon, \nand J. Strejcek. Reachability analysis of multithreaded software with asynchronous communica\u00adtion. In \nFSTTCS, 2005. [3] A. Bouajjani, J. Esparza, and T. Touili. A generic approach to the static analysis \nof concurrent programs with procedures. In IJFCS, volume 14(4), pages 551 , 2003. [4] A. Bouajjani, M. \nOlm, and T. Touili. Regular Symbolic Analysis of Dynamic Networks of Pushdown Systems. In CONCUR, 2005. \n[5] S. Chaki, E. Clarke, N. Kidd, T.Reps, and T.Touili. Verifying concurrent message-passing c programs \nwith recursive calls. In TACAS, 2006. [6] E. A. Emerson. Temporal and Modal Logic. In Handbook of Theoretical \nComputer Science, Volume B, pages 997 1072, 1998. [7] E.A. Emerson and V. Kahlon. Model checking guarded \nprotocols. In LICS, 2003. [8] J. Esparza and A. Podelski. Ef.cient Algorithms for pre *and post* on Interprocedural \nParallel Flow Graphs. In POPL, 2000. [9] V. Kahlon and A. Gupta. An Automata-Theoretic Approach for Model \nChecking Threads for LTL Properties. In LICS, 2006. [10] V. Kahlon, F. Ivan.ci\u00b4c, and A. Gupta. Reasoning \nabout threads communicating via locks. In CAV, 2005. [11] A. Lal, G. Balakrishnan, and T. Reps. Extended \nweighted pushdown systems. In CAV, 2005. [12] D. Lugiez and Ph. Schnoebelen. The Regular Viewpoint on \nPA-Processes. In Theor. Comput. Sci., volume 274(1-2), 2002. [13] S. Qadeer, S. K. Rajamani, and J. Rehof. \nSummarizing procedures in concurrent programs. In POPL, pages 245 255, 2004. [14] S. Qadeer and J. Rehof. \nContext-bounded model checking of concurrent software. In TACAS, 2005. [15] G. Ramalingam. Context-sensitive \nsynchronization-sensitive analysis is undecidable. In ACM Trans. Program. Lang. Syst., volume 22(2), \npages 416 430, 2000. [16] T. W. Reps, S. Schwoon, S. Jha, and D. Melski. Weighted pushdown systems and \ntheir application to interprocedural data.ow analysis. In Science of Computer Programming, volume 58(1-2), \n2005. [17] I. Walukeiwicz. Model checking ctl properties of pushdown systems. In FSTTCS, LNCS 1974, pages \n127 138, 2000.  \n\t\t\t", "proc_id": "1190216", "abstract": "Pushdown Systems (PDSs) have become an important paradigm for program analysis. Indeed, recent work has shown a deep connection between inter-procedural dataflow analysis for sequential programs and the model checking problem for PDSs. A natural extension of this framework to the concurrent domain hinges on the, somewhat less studied, problem of model checking Interacting Pushdown Systems. In this paper, we therefore focus on the model checking of Interacting Pushdown Systems synchronizing via the standard primitives - locks, rendezvous and broadcasts, for rich classes of temporal properties - both linear and branching time. We formulate new algorithms for model checking interacting PDSs for important fragments of LTL and the Mu-Calculus. Additionally, we also delineate precisely the decidability boundary for each of the standard synchronization primitives.", "authors": [{"name": "Vineet Kahlon", "author_profile_id": "81100153948", "affiliation": "NEC Labs, Princeton, NJ", "person_id": "PP39060565", "email_address": "", "orcid_id": ""}, {"name": "Aarti Gupta", "author_profile_id": "81350588778", "affiliation": "NEC Labs, Princeton, NJ", "person_id": "PP54031194", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190262", "year": "2007", "article_id": "1190262", "conference": "POPL", "title": "On the analysis of interacting pushdown systems", "url": "http://dl.acm.org/citation.cfm?id=1190262"}