{"article_publication_date": "01-17-2007", "fulltext": "\n Advanced Programming Language Design in Enterprise Software A lambda-calculus theorist wanders into \na datacenter Chet Murthy IBM Research chet@watson.ibm.com Abstract Enterprise software systems automate \nthe business processes of most nontrivial organizations in the world economy. These sys\u00adtems are immensely \ncomplex, and their function is critical to our living standards and everyday lives. Their design, implementation, \nand maintenance occupies many thousands of programmers and engineers, who work in what are aptly called \nthe COBOL dun\u00adgeons 1 of the IT sector. These systems have persisted, growing by accretion some for \ndecades; there are enterprise systems in exis\u00adtence today whose original and even subsequent authors \nare retired or deceased. Such extraordinarly old, multi-layered systems might appear to be the last place \nto apply avante-garde techniques, but in fact, they are extremely promising candidates, and for reasons \ndirectly connected to their history and structure. In this talk we take a tour of several deployed enterprise \nsoft\u00adware systems, and demonstrate that the appropriate application of methods from functional programming \ncan and does in fact yield dramatic performance improvements and thus commercial advan\u00adtage in the design \nand implementation of enterprise software. This concrete application is an instance of a general plan \nfor the ap\u00adplication of advanced programming language design and analysis methods, to the problem of \nimproving enterprise software. It is the thesis of this talk that to a great extent, it is in enterprise \nsoftware that advanced PL techniques can .nd their most advantageous ap\u00adplication. This talk literally \nbreaks no new ground in PL research: every technique discussed is nearly two decades old, and our goal \nis to introduce PL researchers to what we feel is an ideal target for their work. Categories and Subject \nDescriptors D.3.2 [PROGRAMMING LANGUAGES]: Language Classi.cations; F.4.1 [MATHEMATI-CAL LOGIC AND FORMAL \nLANGUAGES]: Lambda calculus and related systems; H.2.4 [DATABASE MANAGEMENT]: Systems General Terms Languages \nKeywords Transaction processing, enterprise software, functional languages 1 The modern version of COBOL \nis Java/C#. Copyright is held by the author/owner(s). POPL 07 January 17 19, 2007, Nice, France. ACM \n1-59593-575-4/07/0001.  1. Enterprise Systems in a Nutshell Enterprise software systems usually consist \nof a collection of in\u00addividual applications, receiving and processing requests and re\u00adturning replies. \nThe dominant communication paradigm in use for several decades has been remote procedure call, and these \nservers normally process many such requests concurrently. It is very com\u00admon that in a nontrivial application, \na front-end server will, in the course of processing a request, dispatch subsidiary requests to back-end \nservers, and this layering of servers can proceed to many tiers of servers. The processing of a request \nis loosely re\u00adferred to as a transaction , and while the term has a precise mean\u00ading in the context of \ndatabases and concurrency-control, in actual systems the term is much more liberally applied to almost \nany sort of request/response processing. The multi-tier aspect of these systems comes about for three \nreasons: (a) they are assembled out of off-the-shelf software which often cannot be linked together into \na single application; (b) they are assembled over time, and front-end servers or entire collec\u00adtions \nof servers, are often added long after the original system was deployed, in order to provide new function \nor new access, and (c) the programmers who maintain and extend these systems often do not understand \nand do not have the skills to dig into the internals of some system they must extend, preferring to add \nnew function in front of the pre-existing system. A key aspect of servers that process transactions is \nthat, aside from side-effects that are applied to some (often external) persis\u00adtent store, all side-effecting \noperations during the transaction leave behind no remnant effects. Practically, one can view the actual \ncode of the transaction as a functional program that happens to read from its persistent store, write \nback to that store, and produce some func\u00adtional data-structure. Internally, the code of a single server \ncan itself be decomposed into layers . In the business, these many layers of software are referred to \nas frameworks , and often there can be many of them in a single program. Empirically we .nd that the \nexecution of code in these layers also tends not to leave behind side-effects, except, again, by their \neffect on some store. Taken together, these two empirical observations mean that to a great extent, one \ncan both replace layers in a server with equivalent implementations, and entire server applications with \nequivalent implementations, to a greater extent than in other sorts of software. 2. ML in the Enterprise: \nreducing the overhead of framework layering As a concrete example of such replacement, the Xylem team \ntook a deployed transactional application at a major e-business company, and replaced one of its layers \nwith a completely rewritten ver\u00adsion, using ML as an intermediate language. We were able to do so without \ndisturbing the rest of the application, and achieved sig\u00adni.cant performance improvements. This application \nwent live on the Internet several years ago. What is more, we then proceeded to replace neighboring layers \nin the same code, and by application of naive versions of various program transformation techniques well\u00adknown \nto the POPL community, we were able to get further speed\u00adup. In short, we found that not only did applying \navante-garde tech\u00adnology from the PL community allow us to improve a particular component, but by applying \nit to other components in an incremen\u00adtal manner, we were able to gain further speed-up. Our ML implementation, \nXylem, is a simple polymorphically typed ML with algebraic datatypes and weak module system. We compile \nXylem to Java, .rst applying naive versions of a collection of standard techniques from the PL literature: \n partial evaluation and simple inlining  aggressive memo-ization  wide-ranging common subexpression \nelimination  deforestation  data-type specialization  view types  ML s .t with enterprise software \nis (paradoxically) extremely good because such software tends to be written without intricate side-effects \nthat are visible across layers; further, the accretive nature of the software development process in \nthis area results in systems with many, many layers, and the application of techniques such as partial \nevaluation is thus extremely effective to reduce the overhead of framework layering. View types were \nfound to be extremely effective in combination with abstract datatypes, as a way of eliminating framework \nlayering while leaving source code unaffected. Further, the wide-ranging optimizations we applied were \nsignif\u00adicantly more effective than any low-level compiler optimizations, and this is a recurring pattern: \nthe application of the high-level methods developed in the PL community over many years can have profound \neffects on the performance of these systems. Paradoxically, we can sell ML into the enterprise, not based \non its beauty, but on its speed.  3. Future Directions: Fixing the rest Improving other parts of the \napplication will require different tech\u00adniques, and it is interesting to contemplate how many of them \nare at this point old news in the PL community: lazy languages An important class of problems arises \nin the ETL (extract/transform/load) business, and these problems can be characterized as stream-processing \nproblems: creating, trans\u00adducing, joining, and consuming streams of data. We believe such processing \nis a perfect .t for lazy languages, especially since the optimization methods from that community can \nbe applied to improve the performance of what are today compu\u00adtationally intensive problems. logic programming \nThe application we described had a signi.\u00adcant data-access framework to provide a convenient interface \nto data stored in a relational database. This is very common, and these frameworks tend to be complex \nand inef.cient. In ad\u00addition, the view of data that the application would prefer to use, often does not \ncorrespond to the view that the database pro\u00advides. We believe that by applying techniques from logic \npro\u00adgramming we can push down queries written against the ap\u00adplication s data abstractions, down to the \ndatabase, where they can be executed as SQL. Such query pushdown can yield trans\u00adformative performance \nimprovements. I/O automata, reactive systems modeling Presentation frame\u00adworks are responsible for producing \nhuman-readable results, and processing input into a form internal to the application. The typical web-application \nhas lots of complex user-interaction function, and this function is often implemented using the model/view/controller \n(MVC) paradigm. We believe that meth\u00adods from the concurrent automata modeling community, used to model \nreactive and embedded systems, can be pro.tably ap\u00adplied to reduce the complexity and cost of building \npresentation layer code. First-order and Higher-order Attribute Grammars Modern web\u00adbased user-interfaces \nare characterized by signi.cant amounts of code-generation and event-based processing. It appears that \nattribute grammars, and especially higher-order attribute gram\u00admars, might be a good .t for this sort \nof functionality. 3.1 The Distributed System Heretofore we ve focused on single server nodes and the \ncode that runs on them, with the exception of database access. As more and more of these systems is written \nin functional languages, the op\u00adportunity will arise to both coalesce code (from multiple servers to \na single server) where desirable, and also to select the cut points (where a large program is distributed \nacross multiple nodes) in an automatd manner, in order to optimize, say, round-trips between browser \nand server, amount of browser-side state, disconnected op\u00aderation, or minimizing the number of places \nwhere persistent state must be managed.  4. Conclusion It is an article of faith in the functional language \nand wider programming language research community, that functional lan\u00adguages, partial evaluation, and \na host of other tools and methods, result in simpler, easier-to-understand, and easier-to-develop and \nmaintain programs. Such a value proposition, since it is dif.cult to measure, is dif.cult to sell to \nthe users of enterprise software. We have found empirically that a different value proposition, based \non pure performance is much easier to explain, and we have suc\u00adcessfully deployed an ML system into a \ncommercial transaction\u00adprocessing system in the most important application in that system on that basis. \nWe see further opportunities for such application, and we believe that enterprise software is almost \nuniquely suited for the application of such methods. 5. About the author Chet Murthy has been a Research \nStaff Member at IBM Thomas J. Watson Research Center since 1995. Previously he spent four years doing \npostdoctoral research in theorem-proving and formal meth\u00adods at Cornell University and INRIA-Rocquencourt. \nHe devotes a signi.cant part of his time to debugging critical situations at large e-business and transaction-processing \ncustomers, and the rest of his time transforming that experience into research and development initiatives. \nHe received a Ph.D. in computer science in 1990 from Cornell University, and a BSEE in 1986 from Rice \nUniversity. Acknowledgments The author would like to acknowledge the Xylem team, and specif\u00adically Dennis \nQuan and Joseph Latone, without whom these ideas would have remained merely a promising theory.  \n\t\t\t", "proc_id": "1190216", "abstract": "Enterprise software systems automate the business processes of most nontrivial organizations in the world economy. These systems are immensely complex, and their function is critical to our living standards and everyday lives. Their design, implementation, and maintenance occupies many thousands of programmers and engineers, who work in what are aptly called the \"COBOL dungeons\"<sup>1</sup> of the IT sector. These systems have persisted, growing by accretion -- some for decades; there are enterprise systems in existence today whose original and even subsequent authors are retired or deceased. Such extraordinarly old, multi-layered systems might appear to be the last place to apply <i>avante-garde</i> techniques, but in fact, they are extremely promising candidates, and for reasons directly connected to their history and structure.In this talk we take a tour of several deployed enterprise software systems, and demonstrate that the appropriate application of methods from functional programming can and does in fact yield dramatic performance improvements and thus commercial advan-tage in the design and implementation of enterprise software. This concrete application is an instance of a general plan for the application of advanced programming language design and analysis methods, to the problem of improving enterprise software. It is the thesis of this talk that to a great extent, it is in enterprise software that advanced PL techniques can find their most advantageous application. This talk literally breaks no new ground in PL research: every technique discussed is nearly two decades old, and our goal is to introduce PL researchers to what we feel is an ideal target for their work.", "authors": [{"name": "Chet Murthy", "author_profile_id": "81100580771", "affiliation": "IBM Research", "person_id": "PP31048590", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190255", "year": "2007", "article_id": "1190255", "conference": "POPL", "title": "Advanced programming language design in enterprise software: a lambda-calculus theorist wanders into a datacenter", "url": "http://dl.acm.org/citation.cfm?id=1190255"}