{"article_publication_date": "01-17-2007", "fulltext": "\n Scrap your Boilerplate with XPath-like Combinators RalfL\u00a8ammel Microsoft, Data ProgrammabilityTeam, \nUSA Abstract XML programming involves idioms for expressing structure shy\u00adness such as the descendant \naxis of XPath or the default templates ofXSLT.We initiatea discussionofthe relationshipsbetweensuch XML \nidioms and generic functional programming, while focus\u00ading on the (Haskell-based) Scrap your boilerplate \nstyle of generic programming (SYB). This workgives insight into mechanisms for traversal and selection.We \ncompare SYB and XSLT.We approx\u00adimate XPath in SYB. We make a case for SYB s programmabil\u00adity, when compared \nto XPath s .xed combinators. We allude to strengthened type checking for SYB traversals so as to reject \ncer\u00adtain, trivial behaviors. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language \nConstructs and Features; D.2.13[Software Engineer\u00ading]: Reusable Software GeneralTerms Design, Languages \nKeywords XML programming, Generic functional programming 1. Introduction Our point of departure is generic \nfunctional programming [8, 4] with its dedication to forms of polymorphism that admit function\u00adality \nto be applicable to a large class of types. Different bench\u00admark problems appear in the generic programming \nliterature, e.g., generic equality, read and show. With an eye on XML program\u00adming, we are interested \nin structure shyness : focus on the relevant data parts of richly structured data, .nd these parts and \ncompose behavior over them. The Scrap your boilerplate literature (SYB, [14]) works with the increase \nsalary benchmark (or the paradise benchmark): given a datum with the organizational structure of a company, \nincrease everyone s salary by a factor. Fig. 1 shows a company with nested departments; the salaries \nof all employees are subject to a raise. If we assume Haskell datatypes for the data in Fig. 1, then \nit is trivial to implement the paradise benchmark as a Haskell function in SYB style: paradise :: Data \na => Float -> a -> a -- Type inferrable paradise factor = everywhere (mkT (\\(S s) -> S (s*factor))) S \nis the constructor for salary terms. everywhere is a traversal scheme. mkT makes a transformation from \nthe identity function up\u00addated in a type-speci.c case; here: a lambda function that rewrites salary terms. \nThe Data a => ... constraint on the polymorphic input type of paradise expresses that the function is \napplicable to values of any traversable (say, generic-programming-enabled) type. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. \nCopyright c &#38;#169; 2007ACM 1-59593-575-4/07/0001... $5.00 <company> <dept> <!-- Top-level department \n--> <name>SYB technology</name> <manager> <person>Ralf</person> < salary>4288</salary> </manager> <subunits> \n <employee> <!-- Subordinate employee --> <person>Joost</person> < salary>4237</salary> </employee> <dept> \n<!-- Subordinate department --> <name>SYB goes XML</name> <!-- ... Rest of department ... --> </dept> \n</subunits> </dept> <!-- ... Further top-level departments ... --> </company> Figure 1. A sample company \n<xsl:stylesheet> <xsl:param name=\"factor\"/> <xsl:template match=\"salary\"> <xsl:copy> <xsl:value-of select=\". \n* $factor\"/> </xsl:copy> </xsl:template> <xsl:template match=\"@*|node()\"> <xsl:copy> <xsl:apply-templates \nselect=\"@*|node()\"/> </xsl:copy> </xsl:template> </xsl:stylesheet> Figure 2. An XSLT program for the \nparadise benchmark The .rst XSLTtemplate matches on salary nodes and multiplies the salary valueby thegivenfactor. \nThe second template applies otherwise;it models recursion into and reconstruction of nodes. static void \nParadise(double factor, XmlDocument c) { foreach (XmlElement x in c.SelectNodes( //salary )) x.InnerText \n= (Double.Parse(x.InnerText) * factor).ToString(); } Figure 3. Paradise in C# + DOM/XPath The XPath \nexpres\u00adsion //salary is evaluated by SelectNodes resulting in a node set. The foreach loop iterates over \nthe node set so that all salary nodes are updated by an assignment to InnerText. While XML programming \nand generic functional programming have emerged independently of each other, it turns out that they involve \nsimilar problems and idioms. XSLT1.0 [26, 9], a promi\u00ad nent XML programming language, handles the paradise \nbench\u00admark easily; cf. Fig. 2; likewise for (ancient) DOM-/XPath-based APIs [24, 25] for XML programming; \ncf. Fig. 3, or for modern XML programming APIs such as LINQ to XML [18]; cf. Fig. 4. Static typing is \nimportant in generic functional programming, and it is also coming along for XML programming, e.g., in \nXPath 2.0 and thereby in XQuery 1.0 and XSLT2.0 [28, 30, 27, 29]. static void Paradise(double factor, \nXElement c) { foreach (var e in c.Descendants( salary )) e.ReplaceContent((double)e * factor); } Figure \n4. Paradise in C# + LINQ to XML The invocation of the Descendants method (lazily) returns all descendants \nwith the given element name, salary. Again, the foreach loop iterates over the node set so that all salary \nnodes are updatedby ReplaceContent. Contributions of the paper We start a discussion of the relation\u00adships \nbetween problems and idioms in XML and generic functional programming. This is the .rst attempt of this \nkind. Speci.cally: We discover that the XSLTand SYB styles of programming are idiomatically similar, \nin some respects; cf. \u00a73.  We manageto approximatekeyelementsof downwardXPath as SYB-style generic function \ncombinators; cf. \u00a74.  Based on examples, we suggest that the XPath-like set of axes should be enriched \nby SYB-inspired variations; cf. \u00a75.  Inspired by XPath, we enrich the SYB setup in a way that traversed \nterms carry parental and sibling context; cf. \u00a76.  We show how to use the Haskell type system to perform \nextra sanity checks on SYB-and XPath-like traversals; cf. \u00a77.  Road-map of the paper \u00a72takes an inventory \nof DOM, SYB, XPath and XSLTidioms.  \u00a73 \u00a77develops the aforementioned contributions.  \u00a78describes related \nwork.  \u00a79concludes.  Source codeisavailableat http://www.cwi.nl/~ralf/popl07. 2. Idiomatic inventory \nXPath-like node selection XML programming setups mayfacili\u00adtateXPath[25](orXPath-like)queryaxesfornode \nselection.Typi\u00ad cal axes are these: child, parent, sibling and descendant. The code in Fig.3(DOM/XPath) \nindeeddevisesa string-encodedXPath query, to selectsalarynodesalongthe descendantaxis.ThecodeinFig.4 \n(LINQ to XML) is idiomatically equivalent, but the API at hand favorsXPath-like query combinators(say,methods)over \nstring en\u00adcoding. It should be noted that the XSLT variation on the paradise benchmark(cf.Fig.2)does \nnot carry out XPath-likenode selection. Instead, XSLT s template mechanism is put to work for achieving \ngenericity, as we will discuss shortly. Transformations vs. queries In the SYB context, there exists \nthe dichotomy transformations vs. queries.Atransformation rewrites the input data.Aquery selects and \ncollects or aggregates parts of the input data.Transformations and queries are often composed. For example, \na source-code transformation may perform desig\u00adnated analyses ( queries ) in due course. The paradise \nbenchmarkisa clear-cutexampleofa transforma\u00adtion: the global transformation of a companyboils down to \nmany local changes of salary nodes. Other transformations may be less shape-preserving ; theymay rewrite \nthe input data more arbitrar\u00adily using more profound strategies and larger scopes. Fig.5showsa clear-cutexampleofa \nquery: the sample totals all salaries in a company. The LINQ to XML code uses (again) the descendant \naxis to .nd all salary nodes; this list is then fed to an aggregation function Sum. The SYB code uses \na traversal scheme, everything, to identify allsalary nodes and aggregate them by the binary operation \n+ as the traversal walks the term (i.e., without going through an explicit list of salary nodes). Haskell+SYB \ntotal :: Data a => a -> Float -- Type inferrable total = everything (+) (0 mkQ (\\(S s) -> s)) C#+LINQ \nto XML static double Total(XElement c) { return c.Descendants( salary ) // Select nodes .Select(s => \n(double)s) // Coerce to doubles .Sum(); // Sum up doubles } Figure 5. Total over all salaries in a company \nSYB s transformations and queries The terms transformation and query are particularly meaningful in pure, \ntyped functional pro\u00adgramming; generic transformations and queries are functions that are polymorphic \nin their argument type; transformations preserve the type in the result; queries compute a result of \na .xed type. Ac\u00adcordingly, SYB provides the following two type schemes: type GenericT = forall a. Data \na => a -> a -- Transformations type GenericQ r = forall a. Data a => a -> r -- Queries Genericityisexpressedbythesetypesthroughuniversal \nquanti.ca\u00adtion witha Data bound for generic-programming-enabled datatypes. Mutable node sets When XPath \nis embedded into an imperative OO language, then transformations can be expressed by iteration over query \nresults (i.e., sets or lists of XML nodes) such that each single node may be transformed separately. \nThis was illustrated for both, DOM/XPath and LINQ to XML. Hence, in such an impure setup, generic programming \nis mainly concerned with queries as opposed to transformations. For instance, LINQ to XML queries are \nof the following type: IEnumerable<XElement> Here XElement is the OO class for mutable XML trees of LINQ \nto XML; IEnumerable denotes the .NET generics type for (potentially lazy) lists.Atypical transformationwas \nshownin Fig.4. SYB-like traversal control XPath style can be summarized as follows: queries are composed \nfrom prede.ned axes . By con\u00adtrast, SYB style essentially involves programmable traversal . One de.nes \ngeneral-purpose traversal schemes and problem-speci.c traversals as polymorphic, recursive functions \nusing a fundamental primitive for one-layer traversal, gfoldl, which is akin to the folk\u00adlore left-associative \nlist fold, except that it folds over immediate subterms ( children ) of a term, and has access to the \nconstructor. The SYB code for the paradise benchmark uses the transforma\u00adtion scheme everywhere;The SYB \ncode for the query that totals all salaries uses the query scheme everything. Let us reconstruct both \nschemes in the sequel. everywhere :: GenericT -> GenericT everywhere f = f . gmapT (everywhere f) The \ntransformation everywhere f fully recurses into a given term to apply f to all of its subterms in bottom-up \norder. The scheme everywhere uses the auxiliary gmapT combinator to transform the immediate subterms \nof a term. everything :: (r -> r -> r) -> GenericQ r -> GenericQ r everything k f x = foldl k (f x) (gmapQ \n(everything k f) x) The query everything kf fully recurses into a given term to apply f to all of its \nsubterms and aggregate the intermediate results using the binary operation k.(The result typeisa list \nor set type, or some other monoidal type that comes with an associative operation k.) The scheme everything \nuses the auxiliary gmapQ combinator to map over the immediate subterms of a term. For brevity,we skipgfoldl \nand the de.nitions of gmapT and gmapQ in terms of this primitive. One can think of gmapT and gmapQ as \nbeing de.ned as follows, when applied to a term of shape Ct1 \u00b7\u00b7\u00b7 tn (with C as constructor, and t1, ..., \ntn as children): gmapT f(Ct1 \u00b7\u00b7\u00b7 tn)= C (ft1) \u00b7\u00b7\u00b7 (ftn) gmapQ f(Ct1 \u00b7\u00b7\u00b7 tn)= [ft1,...,f tn] SYB-like \ntype dispatch SYB con.gures generic traversals by type-speci.c cases. To this end, a generic default \nis specialized in one or more speci.c types. In our examples, we either change or select salaries; cf. \nmkT vs. mkQ: paradise factor = everywhere (mkT (\\(S s) -> S (s*factor))) total = everything (+) (0 mkQ \n(\\(S s) -> s)) mkT specializes the identity function in one type; mkQ specializes a constant function \nin one type. Type-speci.c cases can also be chained by the operators extT and extQ. The following de.nitions \nderive single-case specialization from the chainable operators: mkT f =id extT f r mkQ f = const r extQ \nf These chainable forms are eventually de.ned in terms of a fun\u00addamental primitive for type cast, cast, \nwhich reports success vs. failureof cast throughaMaybe value. Hence, the chainable forms at\u00adtempt to \ncast the input term to the argument type of the type-speci.c case;the latteris appliedin caseofsuccess,andthe \ngenericdefault is applied otherwise. Thus, for ext .{extT, extQ}: (g ext s) x = case cast x of Just x \n-> sx Nothing -> g x For completeness sake, these are the relevant types: mkT :: Typeable x => (x -> \nx) -> GenericT mkQ :: Typeable x => r -> (x -> r) -> GenericQ r extT :: Typeable x => GenericT -> (x \n-> x) -> GenericT extQ :: Typeable x => GenericQ r -> (x -> r) -> GenericQ r cast :: (Typeable b, Typeable \na) => a -> Maybe b mkT and mkQ construct a generic function, while extT and extQ trans\u00adform a generic \nfunction (to incorporate another type-speci.c case). The Typeable bound enables cast;the typeclassTypeable \nis a super\u00adclass of the typeclass Data. In XML programming, the notion of speci.c type may (often) correspond \nto elements with a speci.c name such as elements for companies, departments, managers and salaries. XML \ntransforma\u00adtions and queries routinely dispatchon element names. XSLT-like recursive templates XSLTis \nbiased towards (but not restricted to) transformations as opposed to queries [10]. The XSLT style of \ntransformation is fundamentally different from DOM/X-Path. That is, the predominant form of genericity \nin XSLT pro\u00adgrams is modeled by XSLT s mechanism for (default) templates. (XPath may still be used inindividual \nXSLTtemplates for selec\u00adtion.)For clarity, we repeat the default template that is used in the XSLT code \nfor the paradise benchmark; it applies whenever the speci.c template for salaries does not match. <xsl:template \nmatch=\"@*|node()\"> <xsl:copy> <xsl:apply-templates select=\"@*|node()\"/> </xsl:copy> </xsl:template> \nXSLTstyle is purely functional [9]: a template copies the matched tree or recurses into (selected parts \nof) it. Hence, tree selection ( querying ) and processing ( transformation ) are amalgamated. Acommon \nform of recursive function application is to apply all templates ,but templates can alsobe applied more \nselectively. paradise factor = stylesheet where stylesheet :: GenericT stylesheet = applyTemplates extT \ntransformSalary transformSalary :: Salary -> Salary transformSalary = \\(S s) -> S (s*factor) applyTemplates \n:: GenericT applyTemplates = gmapT stylesheet Figure 6. Paradise in Haskell + SYB in simulated XSLT style \n3. XSLT style vs. SYB style XSLTstyle is similar to SYB style. In particular, XSLT s templates with problem-speci.c \nmatch conditions are similar to the type\u00adspeci.c casesin SYB.A template witha match condition for an \nelement name, e.g., match= salary , corresponds to an SYB-like, type-speci.c case that is universally \napplicable to the speci.ed type, say the type of salaries. In general, XSLT s match conditions may be \norganized as gen\u00aderal logical formulas over various observable axes of nodes. We contend that this style \nexposes a .avor of operating on a universal representation. In principle, SYB has access to similar, \nre.ective power,butnativeSYBstyle usestype dispatchtoorganize matches. Each type-speci.c case may narrow \ndown the match, in which case result types need to be wrapped in Maybe (or another MonadPlus)and designated \ntraversal schemes are to be chosen. XSLT s default templates are reminiscent of SYB s recursion with \nthe gmap family. The copy idiom preserves the enclosing el\u00adement just like gmapT preserves the outermost \nconstructor. The apply-templates idiom maps the templates over all children just like gmapQ mapsoverthelistof \nimmediate subterms.The separation of the two XSLTidioms would be notably hard to separate in the Haskell \ntype system without escaping to a universal type. Fig.6shows XSLT-style SYB code for the paradise benchmark. \nThisexperiment triggers additional observations. First, both the na\u00adtive SYB code and the XSLT-style \nSYB code are statically type\u00adchecked;by contrast, XSLT1.0 does not provide static type check\u00ading; XSLT \n2.0 will comprise schema-aware processing based on and enhancing the static typing notion for XPath 2.0. \nAt this point, though, template application, as in default templates, in particular, seems to rely,at \nleast in part, on runtime type checking. Second, the XSLT-style SYB code explicitlycomposes all templates \nthrough the chaining operator extT, whereas XSLT provides the convenience of juxta-positioning all templates \nin a stylesheet, while XSLTlan\u00adguage rules prioritize templates. Third, the XSLT-style SYB code clari.es \nthat an XSLTstylesheet ties up recursion in itself, whereas the native SYB code leaves it to a reusable \ntraversal scheme to tie up recursion. In other words, XSLTstyle dictates ad-hoc recursive traversal, \nwhereasSYBstyle recommendsaseparationof concerns: recursive traversal schemes vs. node processors. This \nis a heritage of term-rewriting strategies a la Stratego [23]. 4. Elements of downward XPath in SYB Let \nus approximatekey elements of downward XPath in SYB so thatwecan compareXPath-likenode selectionwithSYBstyle.(By \nno means, we claim to reconstruct downward XPath.We anyhow neglect XML-isms in the following discussion: \nattributes, text nodes, XML comments, processing instructions, whitespace.) We associate XPath axes (or \nquery patterns) withHaskell com\u00adbinators, which map a given term to a list of terms. Using the list monad \nor other combinators for list processing, one can chain up such .lters. It is important to note that \nXPath [25, 28] comprises rules that de.ne when node lists vs. node sets are used.We glance over this \n(important) detail, and admit that SYB style may be in\u00adcapable of aligning with XPath s identityfactorization \nunless we were modeling term identities in our functional setup. XPath s self axis, i.e., . , selects \nthe input. In Haskell: self :: x -> [x] self x = [x] XPath s unconstrained child axis, i.e., * or child::* \n, selects all child elements. This axis shows up in XSLTdefault rules,but not much elsewhere. It is intrinsically \nuntyped, and hence it does not occurin native SYB programming,but hereisa reconstruction: anyChild :: \nGenericQ [Any] anyChild = gmapQ Any We use a universe of all castable terms: data Any = forall x. Typeable \nx => Any x Now consider XPath s child axis, when constrained by an element name, such as in child::salary \n. In Haskell, anyChild is .ltered by type (in place of an element name). childOfType :: Typeable r => \nGenericQ [r] childOfType = typeFilter . anyChild where typeFilter :: Typeable r => [Any] -> [r] typeFilter \n= map fromJust . filter isJust . map unAny where unAny (Any x) = cast x It is straightforward to post-compose \nchildOfType with a normal (monomorphic) .lter so as to achieve the affect of an XPath predi\u00adcate p such \nas in child::salary[p] . Let us now look at XPath s descendant axis. This time, we use a recursive traversal \nscheme, everything, instead of the one-layer traversal with gmapQ in the case of the child axis. Again, \nwe show both, the unconstrained and the type-constrained descendant axis, wherethe latteronedoesnotfacilitatethe \nformeronesoastoavoid building a huge, transient list of untyped terms: anyDescendant :: GenericQ [Any] \nanyDescendant = everything (++) anyChild descendantOfType :: Typeable r => GenericQ [r] descendantOfType \n= everything (++) childOfType The type of interest is normally speci.ed by a type annotation. For instance, \ngiven a company, c, all its descendant departments (cf. datatype Dept)are obtained as follows: descendantOfType \nc :: [Dept] Two asides are worth noting. First, the aggregation of lists of de\u00adscendants in terms of \n++ is notoriously inef.cient; we could em\u00adployplain list consing by switching to a higher-order accumula\u00adtion \nscheme. Second, the above examples only cover queries. One can easily provide a similar suite for axes-controlled \ntransforma\u00adtions by a mechanical adaptation of the code for the query opera\u00adtors; both suites can even \nbe overloaded. 5. SYB-inspired enrichment of XPath XPath is a .xed domain-speci.c selector language for \nXML. The existing XPath operators may end up being inconvenient (in terms of expressivity) or computationally \nsuboptimal. The programma\u00adbility of traversal schemes in a generic programming framework allows for tailored \nschemes for queries and transformations. Imagine a salary raise should be restricted to certain depart\u00adments. \nHere are some sets of departments in the company c: top-most All top-most departments. bottom-most All \nbottom-most departments. non-top-most Allbut the top-most departments. non-bottom-most Allbut the bottom-most \ndepartments. inner All non-top-most and non-bottom-most departments. The descendant axis gives us all \ndepartments and we would need to engage in .ltering out those of interest. This is inconvenient and computationally \nexpensive. For instance, in terms of the API of LINQ to XML, one can query the top-most departments as \nfollows: c.Descendants( dept ).Where(x => ! x.Descendants( dept ).Any()) While XPath itself is a .xed \nlanguage, one can argue that an API could simply be extended to support new axes. However, a com\u00adputationally \ninexpensive de.nition requires access to a low level of traversal. The SYB-based query scheme for top-most \ndescendants uses gmapQ and ties up recursion in a designated manner: topMostOfType :: Typeable r => GenericQ \n[r] topMostOfType x = case cast x of Just x -> self x Nothing -> recurse where recurse = concat (gmapQ \ntopMostOfType x) While SYB is more .exible than XPath, the choice of a .xed DSL for selection offers \nadvantages, too. That is, an XPath processor can engage in domain-speci.c optimizations, while free-wheeling \nSYB style is only accessible to optimizations of an Haskell implemen\u00adtation. SYB style relies on higher-order \nstyle, non-trivial polymor\u00adphism and overloading thereby ruling out some optimizations. 6. XPath-inspired \nenrichment of SYB SYB is conceptually aimed at traversal, say going downward in terms. Ancestor terms \nmay be passed around actively by the programmer,e.g., on the grounds of the reader/environment monad. \nBycontrast, XPath readily provides parent and sibling axes because these are important elements of XML \nprogramming. A DOM-like representation of XML trees provides access to parent and sibling axes by maintaining \nlinks from each node to its parent.A pure functional languagelike Haskell needstogoa different route. \nIn the following, SYB is enriched in a way that traversed terms carry around context for the parent and \nsibling axes. Traversal into terms remains to be the primary idiom. (Hence, the proposed technique does \nnot aim at arbitrarily navigable or editable trees; cf. the discussion of the zipper and friends in the \nrelated work section.) The context of a term comprises its parent term (including the context of the \nparent) and the position of the term in the ordered child list of the parent: data Context = Root | Node \n{ parent :: InContext Any, position :: Int } The following datatype models terms in their context : data \nInContext a = InContext Context a contextOf (InContext ctx _) = ctx -- project to context noContext (InContext \n_ x) = x -- project to plain term SYB needs to be generalized in a systematic manner to use terms in \ncontext instead of plain terms. Most notably, the types of (generic) transformations and queries evolve \nas follows: type GenericT = forall a. Data a => InContext a -> a type GenericQ r = forall a. Data a => \nInContext a -> r The gmap family of one-layer traversal combinators also needs to be lifted to terms \nin context. These new gmap combinators place each child in its context before transforming or querying \nit. Now, the de.nition of the ancestor axis is straightforward: anyAncestor :: GenericQ [Any] anyAncestor \nx = anyAncestor (contextOf x) where anyAncestor Root = [] anyAncestor c = noContext (parent c) : anyAncestor \n(contextOf (parent c)) ancestorOfType :: Typeable r => GenericQ [r] ancestorOfType = typeFilter . anyAncestor \n Looking up siblings is equally simple. class IsReachableFrom x y instance (ReachableFrom () xs (y,()), \nIsElem x xs) => IsReachableFrom x y Determine all types ys reachable from the types xs;ps serves as an \naccumulator position. class ReachableFrom ps ys xs | ps xs -> ys instance ReachableFrom ps ps () instance \n(ChildTypes (x,xs) ns, Diff ns ps ns , Append ps ns ps , ReachableFrom ps ys ns ) => ReachableFrom ps \nys (x,xs) class ChildTypes x y | x -> y instance ChildTypes Prelude.Char () -- primitive type instance \nChildTypes Prelude.Float () -- primitive type instance ChildTypes [x] (x,([x],())) -- lists instance \nChildTypes () () -- empty product instance (ChildTypes x ys, ChildTypes xs ys , Append ys ys ys , Nub \nys ys ) => ChildTypes (x,xs) ys -- non-empty products Figure 7. Reachable types (We use folklore functions, \nAppend, Diff, IsElem and Nub,but lifted to the type level.) 7. Sanity checks for SYB traversals Normal \nHaskell type checking alone does not establish various interesting propertiesofSYBtraversals.Itis perhaps \nunsurprising that we are not prevented from de.ning non-terminating traversals. For the application of \nprede.ned traversal schemes, however, we maywantto staticallyruleout certaintrivialbehaviorssuchas(i) \na query is bound to return the empty node set; (ii) a transformation is boundtofail;(iii)a transformationis \nboundtobehavelikethe identity function. In the following, we illustrate a technique to perform corresponding \nchecks within the Haskell type system. For instance, the following query always returns an empty list: \ndescendantOfType c :: [Company] That is, terms of type Company cannot possibly occur directly or tran\u00adsitively \nunder terms of type Company (such as c). Thisfact follows from the datatype declarations for companyterms; \nthe type Company only occurs at the root of terms. Given an application of descendantOfType with input \ntype x and result type [y], the idea is now to check that y is reachable from x. This idea is very similar \nto the type-checking rules for de\u00adscendants and friends in the XPath 2.0 formal de.nition [29]. In\u00ad stead \nof engaging in an of.ine program analysis, we can use type\u00adlevel programming [3, 17, 20, 19, 12].Wekeep \nthe de.nition of descendantOfType, while we simply add a constraint to its type: descendantOfType :: \n(Data x, Typeable r, IsReachableFrom r x) => x->[r] The reachability constraint stands for the transitive \nclosure of the parent-child-type relation at the type level. Each axis or query combinator requiresa \nsimilar, designated constraint.For instance, the descendant-or-self axis requires the re.exive and transitive \nclosure of the parent-child-type relation. Fig.7shows an encoding of IsReachableFrom. (Mutually recur\u00adsive, \nregularly polymorphic datatypes are covered.) The de.nition relies on type-level access to the child \ntypes of types.To this end, we assume that user-de.ned types are rei.ed through a type-level relation, \nChildTypes, between parent type and the heterogeneous list [12] of child types (using nested, right-associative, \nexplicitly terminated, binary products).For instance: -- User-de.ned algebraic datatypes data Company \n= C [Dept] data Dept = D Name Manager [SubUnit] -- Type-level representation instance ChildTypes Company \n([Dept],()) instance ChildTypes Dept (Name,(Manager,([SubUnit],()))) The type-level representation can \nbe mechanically derived from the original types without ado, e.g., by means of program generation withTemplate \nHaskell [22]. 8. Related work HaXML s content .lters The seminal paper on HaXML [31] de\u00ad livered generic \ncombinators for content .ltering with coverage of the downward-axes of XPath including variations on \nthe descen\u00addant axis. The HaXML paper suggested that one must make a de\u00adcisionto either go for generic, \nuntyped combinators or for a type\u00adbased translation so that XML programming is eventually carried out \nas normal (i.e., non-generic) programming on datatypes. The present paper clari.es that no such draconian \nchoice is necessary. We have delivered strongly typed XPath-like query operators. XSLT-like recursion \nIt is a natural question to ask whether a proper functional language can do a better job in expressing \nXSLTtransformation scenarios than XSLTitself. Several such ef\u00adforts were carried out for Scheme [13, \n11, 21].Typically, these ef\u00ad forts focus on recursion, pattern matching and replacement; they are indeed \nidiomatically close to XSLTas opposed to HaXML-like content .lteringorXPath-like querying.Asophisticated \nprojectis SXML/SXSLT[13, 11] notjust because of its coverage of full XML,but also becauseit comes witha \npre-post-order schemefor recursion that can even accommodate local stylesheets, which are added in the \nprocess of descending into XML trees. The Zipper et al. Our technique for accessing the parent and sibling \naxes is reminiscent of the zipper technique [7], which is based on a data structure that enables navigation \nand editing on terms through pointer reversal . There also exists a variation on the zipper, the web \n[5]. Furthermore, advanced generic functional programming with type-indexed data types has been put to \nwork to derive the zipper data structure for a given data type [6]. The simplicity of our technique rests \non a deliberate restriction. That is, parent and position information provides read-only con\u00adtext along \ntraversal.Without this restriction, we were mixing purely functional SYB style with mutable updates. \nOur approach immedi\u00adately works for systems of mutually recursive datatypes;the afore\u00admentioned approaches \nhave not been described in such generality. HXML, a non-validating XML parser written in Haskell [2], \nprovides a notion of navigable trees, which however deals with the generic tree representation only, \nwhereas our development inte\u00adgrates trees in context with strongly typed generic programming. Adaptive \nprogramming There is an established generic program\u00adming notion that is closely related to our efforts: \nadaptive program\u00adming(AP,[16]).In[15],wehadalready comparedAPwith strate\u00adgic programming (SP), whichis \nsimilarto SYB,but there are some XML-speci.c issues that are worth adding. The speci.cations in APare \nsimilartoXPathinsofarthatobjecttypesarelistedthatact as milestones tobe encountered(ortobeavoided)onpathsalong \nan object traversal. These milestones can be distant from each other in a sense similar to XPath s descendant \naxis. The SYB or SP style of programming is less declarative, more operational in that it is described \nhow to descend into structures, how to search for relevant data. SYB provides .exibility,but the AP setup \nis speci.cally meant to enable powerful, meta-data-driven optimizations for shortcutting traversals over \nobject graphs. Sanity checks of traversals We do not claim anyoriginality for the overall idea of checking \non trivial behaviors of traversals. In\u00adstead, we have shown that such checks can be integrated into Haskell \ntype checking. Our ad-hoc approach to sanity checking callsforamore compositionalderivationof checkedtraversals \nfrom checked combinators. Again, adaptive programming comprises similar static checks. That is, an adaptive \nprogramming system may perform so-called compatibility checks of class graph vs. traversal speci.cation \nsuch that adaptive programs are rejected when the milestones cannot possibly be encountered in the speci.ed \norder. The XQuery 1.0 and XPath 2.0 formal semantics [27] also describes related forms of type errors. \nWe also refer to [1] for a type system for path correctness in XML query languages. 9. Conclusion Typical \nXML programmers do not care too much about generic functional programming,buttheyhave accesstoarichvarietyof \nquery axes and to simple-to-use recursion patterns. This observa\u00adtion suggests thata comparisonof generic \nfunctional programming and structure-shy XML programming may be informing and en\u00adriching for both sides. \nAs a .rst attempt at such a comparison, we carried out some experiments and analyses. First, SYB style \nand XSLTstyle turn out tobe notably related. Second,SYB can approximatekeyfragments of XPath. Third, \nSYB provides more control on traversal, when compared to XPath and XSLT. Fourth, SYB-like term traversal \ncan be vitally enhanced to provide parental and sibling context. Fifth, some known forms of trivial (unappreciated) \nbehavior of XML queries and transformations also apply to the SYB style, and Haskell s type system can \naccommodate corresponding checks. The most interesting directions for future work are these: (i) a more \ncomplete reconstruction of XPath, XSLTand XQuery (within the framework of (generic) functional programming); \n(ii) the sys\u00adtematic provision of type-driven traversal specialization for opti\u00admized (say, shortcutting) \ntraversals; (iii) the more profound analy\u00adsis of traversal properties to be checked statically. References \n[1] D. Colazzo, G. Ghelli, P. Manghi, and C. Sartiani. Types for path correctness of XML queries. In \nICFP 04, Proceedings, pages 126 137. ACM Press, 2004. [2] J. English. HXML, 2002. Web site: http://www.flightlab.com/ \n~joe/hxml/. [3] T. Hallgren. Fun with functional dependencies. In JointWinter Meeting of the Dep. of \nScience and Computer Eng.,Chalmers University of Technology and Goteborg University, Varberg, Sweden, \nJan. 2001. http://www.cs.chalmers.se/~hallgren/Papers/wm01.html. [4] R. Hinze. A new approach to generic \nfunctional programming. In POPL 00, Proceedings, pages 119 132.ACM Press, 2000. [5] R. Hinze and J. Jeuring. \nWeaving a web. Journal of Functional Programming, 11(6):681 689, 2001. [6]R. Hinze,J. Jeuring,andA.L\u00a8oh.Type-indexed \ndata types. Science of Computer Programming, 51(1 2):117 151, 2004. [7]G.P. Huet. The Zipper. Journal \nof Functional Programming, 7(5):549 554, 1997. [8] P. Jansson and J. Jeuring. PolyP a polytypic programming \nlanguage extension. In POPL 97, Proceedings, pages 470 482. ACM Press, 1997. [9] M. Kay. What kind of \nlanguage is XSLT? IBM developerWorks, 2001 2005. http://www-128.ibm.com/developerworks/xml/ library/x-xslt/?dwzone=x. \n[10] M. Kay. Comparing XSLT and XQuery. In Proceedings of XTech 2005: XML, theWeb andbeyond, 2005. http://www.idealliance. \norg/proceedings/xtech05/papers/02-03-01/. [11] O. Kiselyov and S. Krishnamurthi. SXSLT: Manipulation \nLanguage for XML. InV. Dahl andP.Wadler, editors, PADL 03, Proceedings, volume 2562 of LNCS, pages 256 \n272. Springer-Verlag, 2003. [12] O. Kiselyov, R.L\u00a8ammel, and K. Schupke. Strongly typed hetero\u00adgeneous \ncollections. In HaskellWorkshop 2004, Proceedings.ACM Press, Sept. 2004. [13] O. Kiselyovand K. Lisovsky. \nXML, XPath, XSLTimplementations as SXML, SXPath, and SXSLT, Sept. 2002. Presented at the International \nLisp Conference (2002); http://okmij.org/ftp/. [14] R.L\u00a8ammel and S. Peyton Jones. Scrap your boilerplate, \nwebsite, http://www.cs.vu.nl/boilerplate/, 2003 2006. [15] R.L\u00a8ammel, E.Visser, and J.Visser. Strategic \nprogramming meets adaptive programming. In AOSD 03, Proceedings, pages 168 177. ACM Press, 2003. [16]K.J. \nLieberherr,B.Patt-Shamir,andD. Orleans.Traversalsof object structures: Speci.cation and Ef.cient Implementation. \nACMTOPLAS, 26(2):370 412, 2004. [17]C. McBride. FakingIt (Simulating DependentTypesin Haskell). Journal \nof Functional Programming, 12(4 5):375 392, July 2002. [18]Microsoft Corp. XLinqoverview, 2005. http://msdn.microsoft. \ncom/netframework/future/linq/, Note that XLinq is now called LINQ to XML . [19] M. Neubauer, P. Thiemann, \nM. Gasbichler, and M. Sperber. A Functional Notation for Functional Dependencies. In HaskellWorkshop \n2001, Proceedings, ENTCS, pages 101 120. Elsevier, 2001. [20]M. Neubauer,P. Thiemann,M. Gasbichler,andM. \nSperber. Functional logic overloading. In POPL 02, Proceedings, pages 233 244.ACM Press, 2002. [21] K. \nNormark. XML Transformations in Scheme with LAML a Minimalistic Approach, Oct. 2003. Presented at the \nInternational Lisp Conference (2003); http://www.cs.aau.dk/~normark/laml/. [22] T. Sheard and S. Peyton \nJones. Template meta-programming for Haskell. In HaskellWorkshop 2002, Proceedings, pages 1 16.ACM Press, \n2002. [23] E.Visser,Z.el Abidine Benaissa, andA.Tolmach. Building program optimizers with rewriting strategies. \nIn ICFP 98, Proceedings, pages 13 26.ACM Press, 1998. [24] W3C. Document Object Model (DOM), 1997 2003. \nhttp: //www.w3.org/DOM/. [25]W3C. XMLPath Language(XPath),Version1.0,W3C Recommen\u00addation, 16 Nov. 1999. \nhttp://www.w3.org/TR/xpath. [26]W3C. XSLTransformations (XSLT),Version 1.0, W3C Recommen\u00addation, 16 Nov. \n1999. http://www.w3.org/TR/xslt. [27] W3C. XQuery 1.0: An XML Query Language, W3C Candidate Recommendation,3Nov. \n2005. http://www.w3.org/TR/xquery/. [28] W3C. XMLPath Language (XPath),Version 2.0, W3C Candidate Recommendation,8June \n2006. http://www.w3.org/TR/xpath20/. [29] W3C. XQuery 1.0 and XPath 2.0 Formal Semantics, W3C Can\u00addidate \nRecommendation, 8 June 2006. http://www.w3.org/TR/ xquery-semantics/. [30]W3C. XSLTransformations (XSLT)Version \n2.0, W3C Candidate Recommendation,8June 2006. http://www.w3.org/TR/xslt20/. [31]M.WallaceandC. Runciman. \nHaskellandXML: generic combinators or type-based translation? In ICFP 99, Proceedings, pages 148 159. \nACM Press, 1999. \n\t\t\t", "proc_id": "1190216", "abstract": "XML programming involves idioms for expressing 'structure shyness' such as the descendant axis of XPath or the default templates of XSLT. We initiate a discussion of the relationships between such XML idioms and generic functional programming, while focusing on the (Haskell-based) 'Scrap your boilerplate' style of generic programming (SYB). This work gives insight into mechanisms for traversal and selection. We compare SYB and XSLT. We approximate XPath in SYB. We make a case for SYB's programmability, when compared to XPath's fixed combinators. We allude to strengthened type checking for SYB traversals so as to reject certain, trivial behaviors.", "authors": [{"name": "Ralf L&#228;mmel", "author_profile_id": "81100095823", "affiliation": "Microsoft", "person_id": "PP29032133", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190240", "year": "2007", "article_id": "1190240", "conference": "POPL", "title": "Scrap your boilerplate with XPath-like combinators", "url": "http://dl.acm.org/citation.cfm?id=1190240"}