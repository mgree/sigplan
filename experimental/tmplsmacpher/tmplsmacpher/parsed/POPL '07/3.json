{"article_publication_date": "01-17-2007", "fulltext": "\n A Typed Intermediate Language for Compiling Multiple Inheritance Juan Chen Microsoft Research juanchen@microsoft.com \nAbstract Type-preserving compilation can improve software reliability by generating code that can be \nveri.ed independently of the compiler. Practical type-preserving compilation does not exist for languages \nwith multiple inheritance. This paper presents EMI, the .rst typed intermediate language to support practical \ncompilation of a pro\u00adgramming language with fully general multiple inheritance. The paper demonstrates \nthe practicality of EMI by showing that EMI can be used to faithfully model standard implementation strategies \nof multiple inheritance for C++, the most widely-used program\u00adming language with general multiple inheritance. \nCategories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Classes \nand Objects; D.3.1 [Programming Languages]: Formal De.nitions and Theory General Terms Languages Keywords \nTyped intermediate language, class and object encod\u00ading, multiple inheritance  1. Introduction Type-preserving \ncompilation can improve software reliability by generating code that can be veri.ed independently of \nthe com\u00adpiler [15, 12, 9]. Techniques for practical type-preserving compi\u00adlation, however, do not exist \nfor programming languages with mul\u00adtiple inheritance, such as C++, Eiffel, SELF, Cecil, and CLOS. This \npaper describes EMI (Encoding for Multiple Inheritance), the .rst typed intermediate language to support \npractical compila\u00adtion of a programming language with fully general multiple inheri\u00adtance. It demonstrates \nthe practicality of EMI by showing that EMI can be used to faithfully model standard implementation strategies \nof multiple inheritance for C++, the most widely-used program\u00adming language with general multiple inheritance. \nIn a language with multiple inheritance, a class may have multi\u00adple superclasses. A subclass object contains \nembedded objects for superclasses. Standard single-inheritance techniques assume that an object and its \nembedded superclass object can share the same base location within the object. With multiple inheritance, \nthis is impossible when there is more than one embedded superclass ob\u00adject. Furthermore, there are different \nways of handling multiple em- Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. POPL 07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001. \n. . $5.00.  bedded objects of the same superclass. Repeated inheritance allows multiple copies of the \nsame superclass in a subclass object. Shared inheritance (virtual inheritance in C++) has only one shared \ncopy of a superclass, even if the subclass inherits the superclass more than once. Languages may allow \nboth types of inheritance in the same subclass. With repeated inheritance, a single class name is not \nsuf.cient to distinguish embedded objects because a subclass object may have several embedded objects \nfor the same superclass, inherited via different ancestors. To handle these dif.culties, EMI introduces \npaths sequences of class names to describe the location of an embedded object. At compile time, most \nobjects have unknown runtime types and paths. EMI uses path abstractions to represent those objects. \nEMI introduces special address arithmetic expressions to model pointer adjustment that may occur during \ncasting and dynamic dispatch (so that we can adjust a pointer to a subclass object to point to an embedded \nsuperclass object, or vice versa). EMI borrows some concepts from LILC, a typed intermediate language \nfor compiling object-oriented languages with single in\u00adheritance of classes (presented in our previous \nPOPL paper [4]). Speci.cally, it preserves name-based notions such as classes and subclassing, as LILC \ndoes. EMI also borrows notions such as exact classes and subclassing-bounded quanti.cation. However, \nit differs from LILC in representing objects and inheritance. Prior work on typed compilation of languages \nwith multiple in\u00adheritance is not suitable for practical compilers. It does not address implementation \ndetails such as object layout and pointer adjust\u00adment. Some work requires non-standard semantics or implementa\u00adtion \nstrategies. More discussion is in Section 5. In the rest of the paper, Section 2 gives an informal overview \nof EMI. The next two sections explain the syntax and semantics. Section 5 discusses related work. Section \n6 concludes. A type-preserving translation from a source language to EMI, the complete semantics of EMI, \nand the proofs of properties of EMI are presented in a companion technical report [2]. 2. Overview This \nsection describes EMI informally. For simplicity, EMI fo\u00adcuses on only core features and omits non-virtual \nmethods, static members, constructors, access control, arrays, local variable as\u00adsignment, etc. We use \ncapital letters A-E to range over class names. We .rst describe a typical object layout for multiple \ninheritance. In an object of class E, the embedded objects for E s direct super\u00adclasses are listed in \ndeclaration order and followed by .elds intro\u00adduced in E. Each embedded object has a pointer to a corresponding \nvtable. A subclass object can share the vtable with the embedded object if the two objects share addresses. \nFigure 1 shows the layout of a class E that inherits both C and D. The notations f and m with a class \nname subscript mean .elds and virtual methods introduced vtableC E,C CD vtableD D mD E Figure 1. \nMultiple Inheritance by the class respectively. The embedded C object is followed by the D object and \nthen by fE. The embedded C object and the E object share a vtable that contains virtual methods introduced \nby C and E. Typically, casting a subclass object to a superclass object re\u00adquires changing the value \nof the object pointer. For example, to cast an E object to the superclass D, we need to add an offset \nto the value of the object pointer. The offset is the difference between E and D. A virtual method call \nis similar, in that an adjustment may be needed before passing the object to the virtual method. Note \nthat for an embedded object that shares the address with the subclass ob\u00adject, no adjustment is necessary. \nFor example, casting the E object to superclass C does not need to change the object pointer. With repeated \ninheritance, a subclass object may have multiple embedded objects for the same superclass. Figure 2 shows \nthat if both C and D inherit a class A,then an E object has two embedded A objects, one for C and the \nother for D.Class name A is not suf.cient to identify the two A objects. vtableC Figure 2. Repeated \nInheritance 2.1 Basic Ideas of EMI EMI, like LILC, carries class types all the way through compila\u00adtion. \nIt uses record types to represent the actual layout of an ob\u00adject. Objects and records of the corresponding \nrecord type may be coerced to each other without any runtime effect. Objects are lightweight and are \npreserved only to simplify the type system. For each class C, a record type R(C) describes the layout \nof C. R is not a type constructor in EMI, but a macro used by the type checker. The layout in Figure \n1 is represented as follows. R(E)={C :{vtable :Ptr{mC,mE},fC}, D :{vtable :Ptr{mD},fD},fE} The top-level \n.elds C and D in R(E) describe the layouts of the corresponding embedded objects. These .elds are themselves \nrecords, which are inlined into their enclosing record. Thus, the .elds in C and D (fC and fD) are at \n.xed offsets from the beginning of the E object. To represent indirection, EMI has pointer types: pointer \ntype Ptr t represents pointers to heap values of type t. These are used in this example to represent \nthe indirections to the vtables. EMI uses paths sequences of class names to uniquely iden\u00adtify embedded \nobjects. P and Q range over paths. A path P lists all intermediate classes between two classes ts and \nte (ts must be a subclass of te), represented as P :(ts,te). We say that P is from ts to te. For example, \nin Figure 2 the two A objects have paths E :: C :: A and E :: D :: A respectively. Both paths are from \nE to A and they differ only in intermediate classes. A path with a single class name C means a complete \nC object, which is not embedded in another object. EMI uses class names as labels in record type R(C), \nso that the path of an embedded object corresponds to the label sequence to fetch the object in R(C).The \nlayout of class E in Figure 2 is: R(E)={C :{A :{vtable :Ptr{mA,mC,mE},fA},fC}, D :{A :{vtable :Ptr{mA,mD},fA},fD},fE} \nFollowing the label sequence C, A in R(E) we can get the layout of the embedded A object with path E \n:: C :: A. Note that vtable access may require the use of a path. This oc\u00adcurs when an object shares \nits vtable with a superclass. In general, each object shares its vtable with its .rst non-virtual superclass \nin declaration order. One can .nd the vtable by following the chain of .rst non-virtual superclasses \nuntil one reaches a class with no non\u00advirtual superclasses. For example, the vtable of the E object can \nbe accessed with path E :: C :: A. In EMI, paths are used as types of objects. The path of an object \nstarts from the runtime type of the enclosing object and leads to the object. We need this generality \nbecause an object with source type C may be a complete C object, or an embedded C object in a subclass \nobject. In turn, using paths as object types allows us to ensure the safety of dynamic dispatch. EMI \nuses existential types with path abstraction to describe objects with statically unknown paths. An object \nwith source type C has type .a \u00ab C. .. :(a, C).. in EMI, read as there exists a type a which is a subclass \nof C and a path . which is from a to C, and the object has path . . The notation \u00ab means subclassing. \nThe type variable a identi.es the object s runtime type, which must be a subclass of C. The path variable \n. abstracts the path of the object, which is from a to C. If an object has a statically unknown runtime \ntype and path, its layout is only partially known at compile time. For example, the object might share \nthe vtable with an enclosing subclass object and thus the vtable might contain methods for the unknown \nsubclass. The record type ApproxR(P) describes the approximate layout of objects with path P :(t, C) \nwhere P can be concrete or abstract. ApproxR(P) is very similar to R(C). The two types differ in this \npointer types (Section 2.2) and embedded virtual superclass objects (Section 2.3). EMI has two expressions \nfor pointer adjustment between super\u00adclass and subclass objects. Suppose P :(t, E) and D is a direct \nnon-virtual superclass of E,that is, E s declaration lists D as one of its superclasses. If a pointer \no points to an E object with path P, expression o . D adjusts o to a pointer to the embedded D object \nwith path P :: D. At run time, the expression adds to o the offset between E and D. Adjusting to superclasses \nhigher in the class hierarchy is done by chaining such expressions. Expression o' e D adjusts back: if \no' points to an embedded D object with path P :: D, the expression adjusts o' to an E pointer with path \nP. 2.2 This Pointer Types Each virtual method has a hidden parameter this . Calling method m on an object \no is translated to calling m with the pointer to o as this . If a class C introduces a method m, the \nvtable of a C object (complete or embedded ) has an entry for m. The entry expects a C pointer as this \n. To call m on a subclass object, the compiler inserts code to adjust the subclass object to C. A challenge \nof typed intermediate languages for OO languages is to give this pointers appropriate types to guarantee \nthe safety of dynamic dispatch. Both runtime types and paths are important in this pointer types. Suppose \nin Figure 2 the class A introduces a method foo with implementation fooA and only class C overrides foo \nwith fooC.The foo method fetched from the embedded object with path E :: C :: A calls fooC, which might \naccess .elds introduced in C. Therefore, the this pointer in the method cannot point to an arbitrary \nA object: it is unsafe to use a pointer to a complete A object or to the embedded A object with path \nE :: D :: A. Multiple inheritance may require this pointer adjustment when subclasses override virtual \nmethods. In the above exam\u00adple, the implementation fooC in class C expects a C pointer. But the foo method \nin the vtable of the embedded object with path E :: C :: A expects an A pointer. One standard strategy \nis to put an adjuster thunk for foo in the vtable of the embedded Aobject. The thunk converts a pointer \nto an A object that is embedded in a C object to a C pointer, and calls fooC on the C pointer. The adjustment \ninvolves two kinds of this pointers: for method implementations and for thunks (methods in vtables). \nSub\u00adclasses can inherit method implementations in superclasses. There\u00adfore, the this pointer of a method \nimplementation in class C (e.g. fooC) is given type .a \u00ab C. .. :(a,C). Ptr .,represent\u00ading pointers to \nany C objects, complete or embedded. For a thunk in the vtable of an object with path P, the this pointer \nhas type Ptr P, representing only pointers to objects with thesamepath P. In the vtable of the object \nwith path E :: C :: A, the thunk for foo has this pointer type Ptr (E :: C :: A).No subclass objects \nare allowed because of virtual inheritance (see Section 2.3). Thunks adjust this and then call method \nimplementations. We show the three cases of thunks with the above foo example: Overriding Class C overrides \nfoo with implementation fooC. The this pointer in fooC has type .a \u00ab C. .. :(a,C). Ptr .. The thunk for \nthe embedded Aobject in C adjusts this (with path E :: C :: A)to a C pointer thisC and then passes it \n(after packing to the existential type required by fooC)to fooC: foo :(this : Ptr (E :: C :: A),...){thisC \n= this e A; fooC(pack thisC to .a \u00ab C. .. :(a,C). Ptr ., ...); } Inheriting Class D inherits fooA from \nA. The this pointer in fooA has type .a \u00ab A. .. :(a,A). Ptr .. The embedded A object in D has path E \n:: D :: A and its vtable has a thunk for foo with this pointer type Ptr (E :: D :: A). The thunk packs \nthis and calls fooA: foo :(this : Ptr (E :: D :: A),...){fooA(pack this to .a \u00ab A. .. :(a,A). Ptr ., \n...); } Same class Class A introduces method foo with implementa\u00adtion fooA. The thunk for foo in the \nvtable of a complete A object has this pointer type Ptr A. The thunk simply packs the this pointer and \ncalls fooA: foo :(this : Ptr A,...){fooA(pack this to .a \u00ab A. .. :(a,A). Ptr ., ...); } The thunks in \nthe last two cases only change this pointer types. They can share the same address with fooA to avoid \ncalls to fooA because pack is a runtime no-op. 2.3 Virtual Inheritance With virtual inheritance, a subclass \nobject has only one embedded object of a superclass if the subclass inherits the superclass multiple \ntimes. Figure 3 shows a class hierarchy with virtual inheritance. Dotted lines mean virtual inheritance. \nBoth C and D virtually inherit B.Any E object has only one embedded B object, although E inherits B from \nboth C and D. The challenge is to let the embedded C and D objects share the same B object in E.A standard \nstrategy is to put embedded objects for virtual superclasses at the end of subclass objects. As a result, \nthe offset between a C vtableC E,C  B vbptr mC mE  vtableD D CD vbptr mD vtableB B E mB Figure \n3. Virtual Inheritance object and its embedded B object depends on the runtime type. The offset in a \ncomplete C object is different from the one in a complete E object. Each C object stores the offset and \ncomputes at run time the location of its embedded B object. In EMI, each vtable has a virtual base pointer \n(vbptr), which points to a table of offsets between the object where the vtable is fetched and embedded \nvirtual superclass objects.1 In the layout of class E in Figure 3, the vtable for C (or D) contains a \nvbptr that points to a one-entry table and the entry is the offset between C (or D)and B. Virtual superclasses \nare .attened in the sense that, if class E inherits C (virtually or not), and C has a virtual superclass \nB, then E has a virtual superclass B. In Figure 3, the B object is not embedded in C, but at the same \nlevel as the C object. Paths that involve virtual superclasses use a pseudo class name VB to separate \nvirtual superclasses from non-virtual ones. In Fig\u00adure 3, the B object in E has path E :: VB :: B.If \nE also has a non-virtual superclass B,the B object with the non-virtual in\u00adheritance would have a different \npath E :: B. Because virtual su\u00adperclasses are .attened, VB must follow runtime types of objects. E :: \nC :: VB :: B is invalid. Casting a subclass object to a virtual superclass includes several steps: (1) \nget the vtable from the object; (2) get the vbptr from the vtable; (3) get the offset that corresponds \nto the target in the vbptr; (4) add the offset to the object. EMI has special expressions for address \narithmetic related to virtual inheritance. Expression disp(P1,P2) is a constant repre\u00adsenting the offset \nbetween two objects with concrete paths (and statically known runtime types). Path P1 represents a subclass \nob\u00adject. Path P2 represents a virtual superclass object and must be of format E :: VB :: B. The expression \nhas type Disp(P1,P2) . Suppose e2 has type Disp(P1,P2). Expression e1 le2 adjusts e1 with path P1 to \na virtual superclass object with path P2, by adding e2 to e1. Expression e1 ' . -e2 is the dual operation \nand it subtracts e2 from e1 ' if e1 ' points to the virtual superclass object. R(E) and ApproxR(P) for \nthe class E in Figure 3 and P : (t,E) are de.ned as follows. R(E)= {C : {vtable : Ptr{vbptr : Ptr{B : \nDisp(E :: C, E :: VB :: B)}, mC,mE},fC}, D : {vtable : Ptr{vbptr : Ptr{B : Disp(E :: D, E :: VB :: B)}, \nmD},fD},fE, VB : {B : {vtable : Ptr{mB},fB}}} ApproxR(P )= {C : {vtable : Ptr{vbptr : Ptr{B : Disp(P \n:: C, t :: VB :: B)}, mC,mE},fC}, D : {vtable : Ptr{vbptr : Ptr{B : Disp(P :: D, t :: VB :: B)}, mD},fD},fE} \n1 Microsoft Visual C++ puts the vbptr in objects (instead of in vtables) and the offsets are from the \naddress of the vbptr to the virtual superclass objects [7]. Another approach stores offsets in method \nentries of vtables [8, 14]. EMI can model both approaches easily. The two record types differ in this \npointer types and in types for the offsets in vbptr. Also ApproxR(P) does not contain the em\u00adbedded B \nobject because the location of the B object is statically unknown. The B object is accessed through offsets \nin vbptr. This pointer With virtual inheritance, this pointers are typed the same way as with repeated \ninheritance. Note that if a class E overrides a method foointroduced in a virtual superclass B with implementation \nfooE, the thunk in the vtable of the embedded B object needs to adjust a B pointer to an E pointer to \ncall fooE.This adjustment is possible only when the runtime type of the B object is statically known. \nThe B object does not contain the offset to adjust itself to E. Therefore, this pointers in thunks have \nconcrete paths, not existential types that hide runtime types and paths. The thunk in the embedded B \nobject has a this pointer type Ptr (E :: VB :: B). The thunk subtracts the offset disp(E,E :: VB :: B) \nfrom this and gets an E pointer thisE. Then it calls fooE after packing thisE: foo :(this : Ptr (E :: \nVB :: B),...){ thisE = this. -disp(E,E :: VB :: B); fooE(pack thisE to . a \u00ab E. . . :(a,E). Ptr ., ...); \n}  3. Syntax This section describes the formal syntax of EMI. Kinds and types are as follows. . ::= \nO | Oc | O1 P ::= . | C | C :: VB :: B | a :: VB :: B | P :: C fi t ::= int | P | Ptrf t |{ l: ti} n \n| (t1,...,tn) . t ii=1 | a |. . :(ts,te).t |. a \u00ab t. t ' | Disp(P1,P2) f ::= I | M A special kind Oc \nclassi.es class names and type variables that will be instantiated with class names. Well-formedness \nof types requires that certain types have kind Oc, for example, the bounds of type variables and path \nvariables. Kind O1 classi.es word-sized types to guarantee that the heap is updated one word at a time. \nOc and O1 are subkinds of O. Paths are used to type objects. A path is a path variable ., a class name \nC, a path from a class to a virtual superclass C :: VB :: B, a path from a type variable to a virtual \nsuperclass a :: VB :: B, or appending a class name to a path P :: C. A path can only be a sequence of \nclass names, or a path variable or a type variable followed by a sequence of class names. VB must appear \nbetween the runtime type of an object (a class name or a type variable) and a virtual superclass (another \nclass name). EMI has standard types such as pointer type Ptrf t , record type { lfi : i=1 , and function \ntype (t1,...,tn) . t to ti} n i represent object layout, vtable, and virtual methods. Pointers and .elds \nin record types have mutability annotations. PtrM t means the pointed-to value can be modi.ed to a new \nvalue of type t. The annotation I means immutable. Annotations on .eld labels mean mutability of the \ncorresponding .elds. In EMI, pointers to (embedded) objects, the vtable pointer, .elds in the vtable, \nand the this pointers are immutable. All other .elds and pointers are mutable. We often omit the annotation \nI. EMI uses existential types that abstract unknown types and paths to represent objects. A source type \nC is translated to an exis\u00adtential type . a \u00ab C. . . :(a,C).. in EMI. Type . a \u00ab t. t ' introduces a \ntype variable a with a subclassing bound t. Type . . :(ts,te).t introduces a path variable . from ts \nto te.Uni\u00adversal types are not needed in EMI and can be added easily. Type Disp(P1,P2) represents the \noffset between two embedded ob\u00adjects with paths P1 and P2 respectively. It is used to type offsets in \nthe virtual base table. Expressions and values are as follows. e ::= x | n | nullt | i | new[t] | e.l \n|* e |* e1 := e2 in e3 | x : t = e1 in e2 | e(e1,...,en) | C(e) | c2r(e) | (a,x)= open(e1) in e2 | (.,x)= \nopen(e1) in e2 | pack t as a \u00ab tu in (e : t ' ) | pack P as . :(ts,te) in (e : t) | e P | e. C | e G \nC | e1 l e2 | -e2 | disp(P1,P2) e1 . v ::= n | i | C(v) P | v.l | pack t as a \u00ab tu in (v : t ' ) | nullt \n| pack P as . :(ts,te) in (v : t) | disp(P1,P2) hv ::= recd | .x g(xi : ti)n : t = em i=1 recd ::= { \nli = vi | li = recdi} n i=1 EMI has standard expressions such as variable x , integer n , null pointer \nnullt , label f , record allocation new[t] , .eld fetch e.l , pointer dereference * e , assignment * \ne1 := e2 in e3 , let binding x : t = e1 in e2 , and function call e(e1,...,en) . Record allocation new[t] \nallocates a record of type t on the heap and initializes each .eld with the default value of the .eld \ntype. Expression e.l returns an interior pointer to the .eld l of a record pointed to by e. Expression \n* e1 := e2 in e3 assigns e2 as the new content of pointer e1.EMI uses * (e.l) to return the value of \nthe .eld l of e and * (e1.l):= e2 in e3 to assign the .eld. Expressions C(e) and c2r(e) are coercions \nbetween object pointers and record pointers. The former coerces a record pointer e to a C pointer and \nthe latter coerces an object pointer to a record pointer. To create a C object, we allocate a record \nof type R(C) using new[R(C)] , assign values to .elds, and coerce the record pointer to an object pointer \nusing C(e) . To fetch a .eld or to call a method, we .rst use c2r(e) to coerce the object pointer e to \na record pointer. These coercions have no runtime cost. The pack and open expressions introduce and eliminate \nexisten\u00adtial types respectively. Expressions pack t as a \u00ab tu in (e : t ' ) hides a type t bounded by \ntu with a type variable a in e.Ex\u00adpression (a,x)= open(e1) in e2 opens a package e1 and in\u00adtroduces \na for the hidden type. Both a and x are in scope in e2. Expression pack P as . :(ts,te) in (e : t) hides \npath P from ts to te with path variable . in expression e. Expression (.,x)= open(e1) in e2 opens e1 \nand introduces a path variable . for the hidden path and a value variable x for e1. Address arithmetic \nexpressions e . C , e e C , e1 l e2 , e1 -.e2 , and disp(P1,P2) are used for adjusting between super\u00adclass \nand subclass objects. The former two are for non-virtual su\u00adperclasses. The rest are for virtual superclasses. \nExpression e P represents an embedded object in e following path P. Records are allocated on the heap. \nEach .eld in a record { li = vi | li = i=1 is a word-sized value vi or an inlined record recdi} n recdi. \nFor simplicity EMI does not support stack-allocated objects. A function .x g(xi : i=1 : t = em de.nes \ng with ti)n formals x1,...,xn (of type t1,...,tn respectively), return type t and function body em. The \nbody em may call g recursively. - . Class and program declarations are as follows. The notation . means \na sequence of items in .. field ::= f : t method ::= m :(t1,...,tn) . t ----.-----.- ---. .. H ::= i \n. hv class ::= C : A,virtual B{ field,method} ---. Prog ::= (class; H; e) -----. -----. .. A class declaration \nC : A,virtual B{ field,method} de\u00ad - . clares a class C with direct non-virtual superclasses A, direct \nvir\u00ad ----. ----. .- tual superclasses B,.elds field, and methods method.A.eld declaration f : t declares \na .eld f with type t. A method decla\u00adration m :(t1,...,tn) . t declares a method m with formal types \nt1,...,tn and return type t. Method declarations do not in\u00adclude explicit this pointer types. Method \nbodies are represented as functions on the heap, not in class declarations. ---. A program declaration \n(class; H; e) declares a program with ---. class declarations class, a heap H, and the main expression \ne. The heap H maps labels to heap values. 4. Semantics This section formalizes the semantics and properties \nof EMI. 4.1 Dynamic Semantics Figure 4 shows selected evaluation rules. The programs in the .rst column \nevaluate to the ones in the second column, if the side conditions in the third column hold. Class declarations \nin programs are omitted because they do not change during evaluation. The notation [d1/d2] means replacing \nd2 with d1. The notation C(v) P represents a pointer to the object with path P in a complete C object. \nGiven P = C :: C1 :: ... :: Cn, the object pointer models the same address as an interior pointer v.C1 \n...Cn. As explained in Section 2, the label sequence C1,...,Cn leads to the part of the record that represents \nthe em\u00adbedded object with path P. The two pointers have different types. Expression new[t] allocates \na record of type t (with value defaultt) on the heap and returns a label to the record. The default value \nfor the vtable .eld in R(C) is a pointer to the vtable of C. Expression C(v) coerces the record label \nto a C pointer C(v).C . Expression c2r coerces an object pointer C(v) P to an interior pointer as described \nabove. Expression * (v.C1 ...Cn.f) fetches the value of a .eld f in the embedded object and * (v.C1 ...Cn.f):= \nv2 in e3 assigns v2 to the .eld and evaluates e3. Expression (C(v) P) . A adjusts a pointer C(v) P \nto C(v) (P :: A), which points to the embedded object for a non\u00advirtual superclass A. Expression (C(v) \n (P :: A)) e A ad\u00adjusts the A pointer back. Similarly, expression (C(v) P1) l disp(P1,P2) adjusts C(v) \n P1 to a virtual superclass pointer t :: VB :: C). The judgment T; . f t : . means that, under environments \nT and ., type t has kind .. Subclassing rules are straightforward. The subclassing judg\u00adment T; . f t1 \n\u00ab t2 means that, under environments T and ., t1 is a subclass of t2. Subclassing between class names \npreserves the class hierarchy in the source programs. Subclassing is re.exive and transitive. Subtyping \nin EMI includes standard record breadth subtyping and depth subtyping (on immutable .elds), function \nsubtyping, and pointer subtyping (on pointers to immutable values). Subtyping is re.exive and transitive. \nThe subtyping judgment T; . f t1 = t2 means that, under environments T and ., t1 is a subtype of t2. \nThe structural subtyping guarantees validity of layout approxi\u00admation. Subtyping between quanti.ed types \nis unnecessary because inheritance is represented by explicit pointer adjustments. Figure 5 shows selected \nexpression typing rules. The typing judgment T; .; S; G f e : t means that, under environments T, ., \nS,and G, expression ehas type t. A pointer to a complete C object has type Ptr C. A pointer to an object \nwith path P has type Ptr P. Coercions A record pointer of type Ptr (R(C)) can be coerced to and from \nan object pointer of type Ptr C by expressions C(e) and c2r(e) respectively. If ehas type Ptr P,thatis, \nepointers to an embedded object with path P, c2r(e) returns a pointer to a record of type ApproxR(P). \nThe de.nitions of R and ApproxR for the current layout strategy are in [2]. The compiler has the freedom \nto choose layout strategies and to use other de.nitions of R and ApproxR, although the layout information \nis part of the type system. The soundness of the type system requires only that for any path P :(C,A), \nthe real layout of objects with P be a subtype of ApproxR(P) (P may contain VB). Address arithmetic Expressions \ne. A and ee A adjust be\u00adtween an object pointer with type Ptr P and a pointer with type Ptr (P :: A). \nExpressions e1 l e2 e2 adjust between an .Expression .C() P (C() P )-vv22 disp(P1,P2) adjusts back to \nC(v) P1. Pointer-related expressions such as dereference, assignment, and address arithmetic in.nitely \nloop if the pointers are null. Future and .-e1 object pointer with type Ptr P1 and a pointer with type \nPtr P2,if e2 versions of EMI will use exceptions. 4.2 Static Semantics has type Disp(P1,P2). When both \npaths are concrete, expression disp(P1,P2) has type Disp(P1,P2) and requires that P2 lead to a virtual \nsuperclass. A program (T; H; e) is well-formed if its class declaration T is well-formed, each heap value \nhas the corresponding type in the heap environment, and the main expression eis well-typed. The type \nchecker maintains several environments. A class declara\u00adtion table T maps class names to declarations. \nA kind environment . tracks type and path variables. Each type variable has a subclass\u00ading upper bound \n(a class name or a type variable introduced previ\u00adously in .). Each path variable has a starting type \nand an ending type. A heap environment S maps labels to types. A type environ\u00adment G maps variables to \ntypes. Well-formedness rules of paths are as follows. The judgment T; . f P :(ts,te) means that, under \nenvironments T and ., P is a well-formed path from ts to te. If VB appears in the path, a virtual superclass \nmust follow immediately. Paths are continuous: a path P :(t,C) can be concatenated only with a direct \nnon-virtual superclass of C. . :(t1,t2) . . B is a virtual superclass of t T; . f . :(t1,t2) T;. f t \n:: VB :: B :(t, B) -.- . T; . f P :(t, C)T(C)= A, {} Ai . A T; . f C :(C, C) T;. f P :: Ai :(t, Ai) Well-formedness \nof types requires that the bounds for type variables and the starting and the ending types of paths be \nof kind Oc. Type Disp(P1,P2) requires that P1 and P2 start from the same type and that P2 lead to a virtual \nsuperclass (of the format  4.3 Properties of EMI EMI has the following properties. Theorem 1 (Soundness) \nIf a program is well-formed, then it will not get stuck. Theorem 2 (Decidable type checking) It is decidable \nwhether T; .; S; G f e: t holds.  5. Related Work Prior work on supporting typed compilation of multiple \ninheritance cannot describe standard implementation techniques. None sup\u00adports virtual inheritance. The \nmodel proposed by Chen et al. pre\u00adserves class names and uses paths to identify embedded objects [1]. \nIt encodes objects with functions and cannot address object layout. ML-ART uses row variables to abstract \nclass extensions and seri\u00adalizes multiple inheritance to a sequence of single inheritance [10]. Fisher \net al. proposed an untyped calculus to support inheritance from unknown base classes [6]. They use dictionary \nlookups for member access. Stone used indices (offsets) as .rst-class values to fetch members from objects \nso that classes can be extended with\u00adout full knowledge of the base classes [13]. Compagnoni and Pierce \nused intersection types to model multiple inheritance [5]. The lan\u00adguage does not preserve classes and \nsubclassing. This pointer ad\u00adjustment is hidden by intersection types and cannot be expressed. Original \nProgram New Program Side Conditions (H; new[t]) (H,i defaultt; i) i/.H (H; C(v)) (H; C(v) C) (H; c2r(C(v) \nP)) (H; v.C1.....Cn) P = C :: C1 :: ...:: Cn (H; *(i.l1.....ln)) (H; *(i.l1.....ln):= v ' in e3) (H; \nv) (H ' ; e3) H(i)= {...,l1 = {...,ln = v...},...}H ' = H except that H ' (i).l1.....ln = v ' (H;(C(v) \nP) .A) (H; C(v) (P :: A)) (H;(C(v) P) GA) (H; C(v) P ' ) P = P ' :: A (H;(C(v) P1) lv2) (H; C(v) P2) \nv2 = disp(P1,P2) (H;(C(v) P2) .-v2) (H; C(v) P1) v2 = disp(P1,P2) (H;(a,x)= open(v) in e) (H; e[t/a][v \n' /x]) v = pack t as \u00df \u00ab in (v ' : ) (H;(.,x)= open(v) in e) (H; e[P/.][v ' /x]) v = pack P as . : in \n(v ' : ) Figure 4. Selected Evaluation Rules T; .; S; G fe : Ptr(R(C)) T;.;S;G fe : Ptr C T; .; S; G \nfe: Ptr P T; . fP :(t,C) T; .; S; G fi: Ptr(S(i)) T;.;S;G fC(e): Ptr C T; .; S; G fc2r(e): Ptr(R(C)) \nT;.;S;G fc2r(e): Ptr(ApproxR(P)) ' T; .; S; G fe1 : .. :(ts,te).t ./.domain(.) ./.free(t ' ) T; .,.:(ts,te); \nS; G,x : t[./. ' ] fe2 : t ' T; . fP :(ts,te) ./.domain(.) T; .; S; G fe: t ' [P/.] T; .; S; G f(.,x)= \nopen(e1) in e2 : t ' T; .; S; G fpack P as . :(ts,te) in (e : t ' ): .. :(ts,te).t ' T; .; S; G fe1 : \nPtr P1 T; .; S; G fe1 : Ptr P2 T; .; S; G fe : Ptr C T; .; S; G fe: Ptr P T; . fP :(t,C) T; .; S; G fe2 \n: Disp(P1,P2) T;.;S;G fe2 : Disp(P1,P2) T; fP :(C,t) Ais a direct non-virtual superclass of C T; .; S; \nG fe1 le2 : Ptr P2 T; .; S; G fe1 .T; .; S; G fe P : Ptr P -e2 : Ptr P1 T; .; S; G fe.A: Ptr(P :: A) \nT; .; S; G fe : Ptr(P :: A) T; fP1 :(C,t1)T; fC :: VB :: B :(C,B) T; .; S; G feGA: Ptr P T; .; S; G fdisp(P1,C \n:: VB :: B): Disp(P1,C :: VB :: B) Figure 5. Selected Expression Typing Rules LILCI extends LILC to support \nmultiple inheritance of inter\u00adfaces as in Java and C# [3]. Interfaces do not have object layout problems \nbecause they contain no .elds. Rossie et al. [11] and Wasserrab et al. [16] formalized multiple inheritance \nin C++ at the source language level. The formalizations refer to no implementation details such as object \nlayout and vbptr.  6. Conclusion EMI is a typed intermediate language for compiling multiple in\u00adheritance, \nboth repeated and shared inheritance. It uses paths to type objects, existential types to represent path \nabstractions, and special address arithmetic to model pointer adjustment. The type system is sound. The \ntype checking is decidable. The translation from a source language to EMI preserves types. EMI can express \nstandard implementation strategies of multiple inheritance in C++, including object layout, this pointer, \npointer adjustment, and vir\u00adtual base pointer. References [1] C. Chen, R. Shi, and H. Xi. A typeful \napproach to object-oriented programming with multiple inheritance. In Proc. 6th PADL, pages 23 38, 2004. \n[2] J. Chen. A typed intermediate language for compiling multiple inher\u00aditance. Technical Report MSR-TR-2005-98, \nMicrosoft Corporation. [3] J. Chen and C. Chen. A typed intermediate language for supporting multiple \ninheritance via interfaces. Technical Report MSR-TR-2004\u00ad141, Microsoft Corporation. [4] J. Chen and \nD. Tarditi. A simple typed intermediate language for object-oriented languages. In Proc. 32nd POPL, pages \n38 49, 2005. [5] A. B. Compagnoni and B. C. Pierce. Higher-order intersection types and multiple inheritance. \nMathematical Structures in Computer Science, 6(5):469 501, 1996. [6] K. Fisher, J. H. Reppy, and J. G. \nRiecke. A calculus for compiling and linking classes. In Proc. 9th ESOP, pages 135 149, 2000. [7] J. \nGray. C++: under the hood. http://msdn.microsoft.com/archive/ default.asp? url=/archive/en-us/dnarvc/html/jangrayhood.asp. \n[8] S.B.Lippman. Inside the C++ object model. Addison Wesley Longman Publishing Co., Inc., Redwood City, \nCA, USA, 1996. [9] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System F to typed assembly language. \nACM Trans. Prog. Lang. Syst., 21(3):527 568, May 1999. [10] D. R\u00b4emy. Programming objects with ML-ART, \nan extension to ML with abstract and record types. In Proc. International Conference on Theoretical Aspects \nof Computer Software, pages 321 346, 1994. [11] J. G. Rossie and D. P. Friedman. An algebraic semantics \nof subobjects. In Proc. OOPSLA, pages 187 199, 1995. [12] Z. Shao. An overview of the FLINT/ML compiler. \nIn ACM SIGPLAN Workshop on Types in Compilation, 1997. [13] C. A. Stone. Extensible objects without labels. \nACM Trans. Prog. Lang. Syst., 26(5):805 835, 2004. [14] B. Stroustrup. Multiple inheritance for C++. \nIn Proc. of the European Unix Users Group Conference, Helsinki, 1987. [15] D. Tarditi, G. Morrisett, \nP. Cheng, C. Stone, R. Harper, and P. Lee. TIL: A type-directed optimizing compiler for ML. In ACM SIGPLAN \nConference on Programming Language Design and Implementation, pages 181 192, 1996. [16] D. Wasserrab, \nT. Nipkow, G. Snelting, and F. Tip. An operational semantics and type safety proof for multiple inheritance \nin C++. In Proc. OOPSLA, 2006.  \n\t\t\t", "proc_id": "1190216", "abstract": "Type-preserving compilation can improve software reliability by generating code that can be verified independently of the compiler. Practical type preserving compilation does not exist for languages with multiple inheritance. This paper presents E<sub>mi</sub>, the first typed intermediate language to support practical compilation of a programming language with fully general multiple inheritance. The paper demonstrates the practicality of Emi by showing that E<sub>mi</sub> can be used to faithfully model standard implementation strategies of multiple inheritance for C++, the most widely-used programming language with general multiple inheritance.", "authors": [{"name": "Juan Chen", "author_profile_id": "81100119052", "affiliation": "Microsoft Research", "person_id": "PP39060102", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190222", "year": "2007", "article_id": "1190222", "conference": "POPL", "title": "A typed intermediate language for compiling multiple inheritance", "url": "http://dl.acm.org/citation.cfm?id=1190222"}