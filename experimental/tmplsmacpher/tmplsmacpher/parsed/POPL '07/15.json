{"article_publication_date": "01-17-2007", "fulltext": "\n From Implementation To Theory in Product Synthesis Don Batory Department of Computer Sciences University \nof Texas at Austin Austin, Texas, 78712 U.S.A. batory@cs.utexas.edu ABSTRACT Future software development \nwill rely on product synthesis, i.e., the synthesis of code and non-code artifacts for a target component \nor application. Prior work on feature-based product synthesis can be understood and generalized using \nelementary ideas from cate\u00adgory theory. Doing so reveals (a) practical and previously unrecog\u00adnized properties \nthat product synthesis tools must satisfy, and (b) non-obvious generalizations of current techniques \nthat will guide future research efforts in automated product development. Categories and Subject Descriptors \nD.2.1 [Requirements/Specifi\u00adcations]: Methodologies, Tools; D.2.11 [Software Architectures]: data abstraction, \ndomain-specific architectures, information hiding, languages. D.3.3 [Language Constructs and Features]: \nframe\u00adworks, inheritance, modules, packages. General Terms: Design, Theory, Languages. Keywords: features, \nprogram synthesis, model driven design, cate\u00adgory theory, AHEAD, GenVoca, mixins, virtual classes. 1 \nIntroduction Program synthesis is not currently, but will be, a foundation of soft\u00adware development. \nToday s software design methodologies aim at repeatable craftsmanship. Transitioning from craftsmanship \nto automation will reveal new ways to think about program design and implementation; new paradigms and \nlanguages will emerge. But what might they be like? My research has focussed on this question. My earliest \nyears were spent on exploring what was necessary, what would work, and what would scale. The most recent \nwere marked by an increasing realiza\u00adtion that structure and the manipulation of structure are the core \nproblems. Program synthesis is a subproblem of product synthesis, where code is but one of many artifacts \nto be produced. All pro\u00adgram representations (code and non-code) can be and should be treated uniformly. \nMy work starts with practice, and then I try to fit practice (or practi\u00adcal experience) to abstract structures. \nMy work is distinguished from others in informal software design by my use of algebra, as algebra is \nby far the simplest way to explain the structure manipula\u00adtions that I need. The uniformity and scale \nthat algebra imposes on structures is astonishing, and is in stark contrast to ad hoc program\u00adming techniques. \nI believe that typical software designers will find Copyright is held by the author/owner(s). POPL 07 \nJanuary 17 19, 2007, Nice, France. ACM 1-59593-575-4/07/0001. simple algebraic approaches appealing in \nsoftware design and development. A long-standing challenge in Computer Science is how to imple\u00adment large \nand efficient programs from declarative specifications automatically [5][12]. Unlike classical work on \nthis problem which starts with a formal logic specification (e.g., [14]), I use techniques pioneered \nin software product lines and other engineering disci\u00adplines that use declarative descriptions of products \nbased on fea\u00adtures (i.e., increments in product functionality) [13]. The first two generations of my \nwork, GenVoca [1] and AHEAD [3], have a simple and informal algebraic description, and have been used \nto synthesize product lines for many domains, including database systems [1], extensible Java translators \n[3], network proto\u00adcols [1], and fire support simulators [2]. The newest generation is based on category \ntheory [4]. Although category theory was related to formal software development years ago [8][11][17], \nI am approaching it from practice. Few ideas from category theory are used. This may be explained, in \npart, by the fact that this work is still in its infancy. However, there is another possible explanation: \na fundamental advance was made in databases almost 40 years ago when Codd noticed the connection between \nset theory and databases [7]. Little of set theory was used, but even this small amount was extremely \nuseful. I believe there is a parallel with category theory and product synthesis. My research was strongly \ninfluenced by relational query optimiza\u00adtion [19] and parameterized programming [10], and shares common \ngoals with algebraic specifications and refinements [8][17], and work in programming languages on virtual \nclasses [15], mixins [6][16][18], and higher-order hierarchies [9]. A paper on which this presentation \nis based is [4]. Acknowledgements. This work was supported by NSF s Science of Design Project #CCF-0438786. \n 2 References [1] D. Batory and S. O'Malley. The Design and Implementation of Hierarchical Software \nSystems with Reusable Compo\u00adnents . ACM TOSEM, October 1992. [2] D. Batory, C. Johnson, B. MacDonald, \nand D. von Heeder, Achieving Extensibility Through Product-Lines and Domain-Specific Languages: A Case \nStudy , ACM TOSEM, Vol 11#2, April 2002, 191-214. [3] D. Batory, J.N. Sarvela, and A. Rauschmayer. Scaling \nStep-Wise Refinement , IEEE TSE, June 2004. [4] D. Batory, From Implementation to Theory in Product Syn\u00adthesis \n, Dept. Computer Sciences, University of Texas at Austin, TR-06-53, October 2006. [5] T. Biggerstaff \nand A. Perlis, Software Reusability Volume II: Applications and Experiences, Addison-Wesley, 1990. [6] \nG. Bracha and W. Cook. Mixin-Based Inheritance . OOP-SLA and ECOOP 1990. [7] E.F. Codd. A Relational \nModel of Data for Large Shared Data Banks , CACM 13 (6), 1970. [8] H. Ehrig and B. Mahr, Fundamentals \nof Algebraic Specifica\u00adtion 2: Module Specifications and Constraints, Springer-Ver\u00adlag, 1990. [9] E. \nErnst, Higher Order Hierarchies , ECOOP 2003. [10] J. Goguen. Principles of Parameterized Programming \nin [5]. [11] J. Goguen. A Categorical Manifesto . Mathematical Struc\u00adtures in Computer Science, 1991. \n[12] J. Gray, What Next? A Dozen Information-Technology Research Goals , Microsoft Research MSR-TR-99-50, \n1999. [13] K. Kang, et al., Feature-Oriented Domain Analysis (FODA) Feasibility Study , Tech Report CMU/SEI-90-TR-21. \n[14] K.K. Lau. Top-down Synthesis of Sorting Algorithms , The Computer Journal, 1992. [15] O.L. Madsen \nand B. M\u00f8ller-Pedersen, Virtual Classes: A Powerful Mechanism in Object-Oriented Programming , OOPSLA \n1989. [16] M. Odersky, et al. An Overview of the Scala Programming Language . September 2004, scala.epfl.ch \n[17] D. Pavlovic and D.R. Smith. Software Development by Refinement , UNU/IIST 10th Anniversary Colloquium, \nFor\u00admal Methods at the Crossroads: From Panaea to Foundational Support, Springer-Verlag LNCS 2757, 2003. \n[18] T. Reenskaug, et al. OORASS: Seamless support for the cre\u00adation and maintenance of object-oriented \nsystems . Journal of Object-Oriented Programming, October 1992. [19] P. Selinger, M.M. Astrahan, D.D. \nChamberlin, R.A. Lorie, and T.G. Price. Access Path Selection in a Relational Data\u00adbase System , ACM \nSIGMOD 1979.  \n\t\t\t", "proc_id": "1190216", "abstract": "Future software development will rely on <i>product</i> synthesis, i.e., the synthesis of code and non-code artifacts for a target component or application. Prior work on feature-based product synthesis can be understood and generalized using elementary ideas from category theory. Doing so reveals (a) practical and previously unrecognized properties that product synthesis tools must satisfy, and (b) non-obvious generalizations of current techniques that will guide future research efforts in automated product development.", "authors": [{"name": "Don Batory", "author_profile_id": "81100296626", "affiliation": "University of Texas at Austin, Austin, Texas", "person_id": "P67954", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190238", "year": "2007", "article_id": "1190238", "conference": "POPL", "title": "From implementation to theory in product synthesis", "url": "http://dl.acm.org/citation.cfm?id=1190238"}