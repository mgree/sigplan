{"article_publication_date": "01-17-2007", "fulltext": "\n Dynamic Heap Type Inference for Program Understanding and Debugging * Marina Polishchuk Ben Liblit \nChlo\u00eb W. Schulze Microsoft Corporation University of Wisconsin Madison Oracle Corporation marinapo@microsoft.com \nliblit@cs.wisc.edu chloe.schulze@oracle.com Abstract C programs can be dif.cult to debug due to lax \ntype enforcement and low-level access to memory. We present a dynamic analysis for C that checks heap \nsnapshots for consistency with program types. Our approach builds on ideas from physical subtyping and \nconservative garbage collection. We infer a program-de.ned type for each allocated storage location or \nidentify untypable blocks that reveal heap corruption or type safety violations. The analysis exploits \nsymbolic debug information if present, but requires no annotation or recompilation beyond a list of de.ned \nprogram types and allocated heap blocks. We have integrated our analysis into the GNU Debugger (gdb), \nand describe our initial experience using this tool with several small to medium-sized programs. Categories \nand Subject Descriptors D.2.5 [Software Engineer\u00ading]: Testing and Debugging Debugging aids; D.3.2 [Program\u00adming \nLanguages]: Language Classi.cations C; D.3.3 [Program\u00adming Languages]: Language Constructs and Features \nData types and structures, Dynamic storage management; F.3.3 [Logics and Meanings of Programs]: Studies \nof Program Constructs Type structure General Terms Algorithms, Human Factors, Languages, Relia\u00adbility \nKeywords dynamic type inference, constraints, debugging tools, heap visualization, physical subtyping, \nconservative garbage col\u00adlection 1. Introduction Suppose that a programmer notices an incorrect variable \nvalue dur\u00ading the execution of a C program. While debugging, the program\u00admer may try to observe values \nof the variable at various points dur\u00ading execution, either by setting a watchpoint in the debugger or \nby inserting print statements. However, both of these techniques may be inadequate. Debugger watchpoints \ncan be prohibitively slow. Adding print statements may be ineffective in cases of memory * Supported \nin part by NSF under grant CCR-0305387. Work performed while at the University of Wisconsin Madison. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n07 January 17 19, 2007, Nice, France. Copyright c &#38;#169; 2007 ACM 1-59593-575-4/07/0001. . . $5.00 \ncorruption, as the affected data structure may have no apparent re\u00adlation to the code that corrupts it. \nThe programmer may also run a static pointer analysis to check for erroneous memory accesses. However, \ntypical analyses [1, 23] do not model dependencies be\u00adtween neighboring memory blocks. In C, many bugs \nare caused by buffer overruns and pointer mismanagement, so physical proximity of memory blocks is an \nimportant factor. We have designed and implemented an automated tool to help programmers understand and \ndebug program behavior at the phys\u00adical memory level. Our tool offers the programmer a low-level, but \ntyped, view of memory. Each allocated chunk is presented either according to its inferred overall data \ntype or as untypable if no de.ned program type is compatible with its imposed constraints. A common scenario \nwhere this view is useful is in the case of a buffer overrun: rather than attempt to deduce what data \nstructure lies near the corrupted location from raw memory values or printed variables, the programmer \nuses our tool to discover that a nearby memory block is being used as an array of a particular type. \nThe mere presence of an array makes buffer overrun a good hypoth\u00adesis, and the array s type helps the \nprogrammer identify relevant code to examine for possible array bounds violations. When memory has been \ncorrupted, our tool may detect that val\u00adues stored in one or more heap blocks do not match any feasible \ntype for the block. In order to reason about the cause of the cor\u00adruption, the programmer may want to \nknow exactly when the heap .rst became corrupted. For this task, we support a binary search de\u00adbugging \nstrategy often used to .nd ill-behaving code: set a break\u00adpoint at the location where a variable was \nlast known to be correct, and another where it has the wrong value, then iteratively narrow the interval \nuntil the bad assignment is exposed. Our tool gives the programmer the ability to treat the entire heap \nas a memory value that is either in a good or bad state, and search for the time at which the heap was \n.rst corrupted using her usual dynamic debugging techniques, such as the binary search described above. \nThis paper makes the following contributions: We introduce the idea of a consistent typing for the heap \nat any given point during execution. Each block of allocated storage is assigned a type from among those \nused in the program. The type assignment satis.es a set of constraints imposed by the values stored in \nmemory, the size of each allocated block, and a type conformance relation (:) based on physical subtyping. \nAdditional constraints may be imposed by declared program variables when debugging information is available. \n We give an algorithm that .nds a consistent typing for a snap\u00adshot of the heap. When no consistent \ntyping exists, we report the locations and causes of con.icts to the user.  The remainder of this paper \nis organized as follows. We estab\u00adlish basic terms in Section 2, and de.ne the subtyping relation on \ntypes used for individual bytes in Section 3. Section 4 speci.es the constraints that must be satis.ed \nfor a set of typed memory loca\u00adtions to be considered consistent, and Section 5 gives an algorithm to \n.nd a consistent typing for the entire heap. Section 6 presents several case studies using our tool, \nSection 7 places our system in context with related work, and Section 8 concludes. 2. Preliminaries \nHere, we describe the scenario under which we solve the problem of .nding a consistent typing for the \nheap and provide key de.ni\u00adtions and notation used throughout the paper. 2.1 De.nitions A typing is a \nmap T : Store .Types from each storage location (addr .Store) to its corresponding type (t .Types). Types \nare all those de.ned or used by the program, including structures, unions, pointers, arrays, and functions. \nStorage locations include: a .xed set of addresses holding global variables; the set of locations that \nhold all local variables and function arguments on the stack at the current program point, or on multiple \nstacks for multithreaded programs; and all memory blocks dynamically allocated since the start of the \nprogram, which we refer to as heap storage. Globals, locals, and function arguments may have associated \ntype information if symbolic debug information is present. How\u00adever, memory blocks from heap storage \nnever have associated dy\u00adnamic type information. Unions are also untagged per standard C. In the manner \nof conservative garbage collectors [3], we de.ne a valid pointer as a block of memory whose value is \nin Store (i.e., is a storage location). A valid pointer may also point immediately after the end of a \nblock of storage; this is a common programming idiom that is explicitly allowed by the C standard [13]. \nA type constraint restricts the types that may reside at a given storage location. Our analysis imposes \nconstraints on the types of individual bytes of memory, termed byte types. Informally, a byte type indicates \nthat a byte holds the start of some program type or any subtype thereof. Byte types may also indicate \nthat a byte is part of the interior of a multi-byte value that starts at an earlier location. 2.2 Notation \nWe establish a concise notation for C types, derived from that used by Siff et al. [21]. An array of \nn elements of type t is written t[n], while t ptr is a pointer to t. A tuple of the form s(m1,...,mk)denotes \na struct, while u{m1,...,mk}denotes an untagged union. Each mj is a triple (t,l,i) giving the type, name, \nand starting offset of one .eld within a structure or union. Structure .elds are ordered by offset, with \nm1 starting at offset zero. Union .elds are unordered and all start at offset zero. Our subtyping relation \nis given by .and its re.exive closure :. We use type notation addr : t in place of the subtyping constraint \nT (addr) :t when the type mapping T is evident from context. In the discussion that follows, byte offsets \nwithin a memory block are represented in terms of addition: if block is the start address of some block \nof storage, block + i denotes the address of the ith byte of block, starting from zero. We abbreviate \nthe address block +0 as simply block. The predicate validPointer(addr) asserts that addr holds the start \nof a valid, non-null pointer value.  3. Byte Type Lattice Our analysis may yield multiple distinct types \nfor the same memory location. In some cases this reveals a con.ict and likely misused memory. In other \ncases the types may, in fact, be compatible. This section explains how we construct a lattice from the \nset of C program types to model type compatibility in our analysis. The data types in Figure 1 form a \nrunning example through\u00adout the paper; hereafter, we omit the explicit struct keyword. struct Point { \n struct PartNode { double x, y; struct Part *part; }; struct PartNode *next; }; struct Shape { char \n*name; struct Assembly { FILE *fptr; struct Point center; }; struct PartNode *nodes; struct Assembly \n*owner; struct Part { }; struct Point center; struct Shape *shape; struct Assembly *owner; }; Figure \n1. Example data types for assembly-building program Figure 2. Byte type lattice corresponding to the \ndata types in Figure 1 Given these types, the remainder of this section de.nes the subtyp\u00ading relation \nused to construct the byte type lattice shown in Fig\u00adure 2. For clarity, we omit .in Figure 2 and from \nthe subtyping de.nitions below. .should be assumed as the meet of any two lat\u00adtice elements for which \nno other lower bound is de.ned; it denotes that the corresponding two types may not be consistently stored \nat the same address. Treatment of function types may be found in a companion technical report [20]. 3.1 \nCompound Types A structure and its initial (offset 0) .eld have the same physical address but distinct \ntypes, as do an array and its 0th element. Therefore the immediate supertype of a structure is the type \nof its initial .eld, and the immediate supertype of an array type is the type of its elements: s((t1,l1,0),...,mk).t1 \nt[n] .t 3.2 Special and Atomic Types The four diamond-shaped nodes at the top of Figure 2 are always \npresent. Tdenotes an unconstrained memory address that may hold any type. referent describes all types \nthat can be the referent of a pointer, while interior describes the non-initial bytes of multi-byte atomic \nvalues. Pointer targets must be referent subtypes and can never be interior. For example, if v holds \nan eight-byte double, then byte v + 0 has type double but bytes v + 1 through v + 7 all have type interior \nand may not be pointed to directly. Bit.elds are also typed as interior, for their addresses cannot be \ntaken. pointer indicates that a storage location holds the 0th byte of a valid pointer, and thus is potentially \nconsistent with any pointer type. Pointers to pointers are allowed, so pointer . referent. pointer is \nnot the same as void*; the former represents all point\u00aders, while the latter is a speci.c program type. \nThe oval nodes in the lattice correspond to actual types that may be used in a C program. Notice that \nthe primitive atomic types are all sibling immediate subtypes of referent. This stipulates that two or \nmore atomic types may not be simultaneously stored at the same address. As a special case, we treat void \nas a zero-length type that is identical to referent. Although no byte should ever have type void in the \n.nal result, this convention allows transparent handling of aliases between void* and more fully typed \npointers: pointers to t and voidmay refer to the same address in our system as though voidwere a zero-length \npre.x of every referent subtype. The subtyping relation is not extended across pointers. That is, t1 \n:t2 .t1 ptr :t2 ptr. This is the standard restriction for subtyping with updatable references, and any \nprogram that requires this form of subtyping to describe its heap must necessarily have used casts or \nother measures to violate type safety. 3.3 Unions Untagged unions require special treatment, because \na union may be used as any of its .elds, but a consistent typing requires that every address be assigned \na unique type. For each untagged union type u{m1,...,mk}, we extend the type grammar to include one tagged \ncase u@mr{m1,...,mk} for each 1 =r =k. Unions and their tagged cases adhere to the following subtyping \nrelations: u{m1,...,mk}.referent u@(tr,lr,0){m1,...,mk}.u{m1,...,mk} u@(tr,lr,0){m1,...,mk}.tr These \nrelations forbid aliased pointers to differently-typed union .elds. Each union must be used in a single \nconsistent manner at any given point during execution. For example, a tagged union storing a Pointcan \nbe the target of pointers to the untagged union as well as pointers to Point and double, but could not \nbe the target of a pointer to Part. When two or more .elds of a union have a common supertype, additional \ncases can be introduced that represent a subset of possible tagged cases rather than a single case. This \npreserves uniqueness of the lattice meet operation. Note that only tagged unions and .have multiple immediate \nsupertypes. The byte type lattice without these becomes a tree. 3.4 Finite Type Space The byte type \nlattice contains an unbounded number of types, including arrays of arbitrary length and pointers of arbitrarily \ndeep nesting. In practice, we only consider the following .nite subset of types that are likely to be \nmeaningful and useful for a given program: program-declared structures, unions, and enumerations  tagged \nvariants of unions or types containing unions  arrays used by the program, e.g. int[3][5] if and only \nif at least one .eld or variable has exactly this type  pointers used by the program, e.g. int**** if \nand only if at least one .eld or variable has exactly this type  pointers to known types up to two more \nlevels of indirection  The number of tagged variants of union-containing types is potentially exponential. \nIn our experience, multi-union structures and nested unions are unusual, and therefore the number of \ntagged variants is typically linear. void main() { ... carAssm = create_assembly(); ... } Assembly \n*create_assembly() { 1 Assembly *assm = malloc(sizeof(Assembly)); 2 PartNode *node = malloc(sizeof(PartNode)); \n3 node->part = malloc(sizeof(Part)); 4 node->next = node; 5 assm->nodes = node; // build part s shape \nand set name 6 init_part(node->part, \"door\", assm); ... 7 return assm; } Figure 3. Program that builds \na simple assembly inin  in  in  Figure 4. Allocated blocks and values after init_part() call in \nFigure 3 Additional array types are synthesized as needed during the analysis to satisfy size constraints \n(Section 4.2), but only using ele\u00adment types appearing in the original program. For example, a block \nof 32 bytes may be typed as int[8] if int is a known 4-byte type. We do not consider int[2][4] unless \nthe corresponding element type (int[2]) appeared in the original program.  4. Consistency Constraints \nIn this section, we specify four kinds of constraints on storage loca\u00adtions that restrict the possible \ntypes for heap blocks. We then show how these constraints are combined to derive a consistent heap typ\u00ading \nat one point in an example program. For simplicity, we assume a 32-bit architecture with 4-byte pointers \nand 8-byte doubles. Our ideas also generalize to 64-bit or other architectures. The program excerpt in \nFigure 3 creates a part for a simple as\u00adsembly and initializes it with its shape and owner assembly. \nFig\u00adure 4 shows the heap after the call to init_part() on line 6 of Figure 3. Blocks are labeled A E \narbitrarily, with the line num\u00adber of each block s allocation given next to its label. Valid pointer \nBlock Valid Pointers Value-Consistent Types A A +0 PartNode, Shape B B +16, B +20 Part, Assembly C C \n+16 Part, Assembly D D +0, D +4 PartNode, Shape Table 1. Valid pointer value and possible value-consistent \ntypes for heap in Figure 4 values are shown in a C-style syntax, and the rest of memory is as\u00adsumed to \nbe set to zero when returned by malloc(). Bracketed numbers indicate byte ranges within each block. 4.1 \nValue Constraints Value constraints arise from concrete data values in memory at the instant the analysis \nis applied. They re.ect the fact that some data types have limited domains that are much smaller than \nthe set of all possible values that can .t in the allotted memory. The following value constraints, which \nwe divide into two categories, are useful across a wide variety of C programs: Mandatory Constraints: \nIf a value looks like a valid pointer, we require that it be typed as a pointer (Section 5.1): validPointer(addr). \nT (addr): pointer This assumes no non-pointer ever takes on a valid pointer value by chance, a strategy \nwidely employed by conservative garbage collectors [3]. Table 1 shows valid pointer value constraints \nfor the heap snap\u00adshot in Figure 4, and the types whose physical layouts are con\u00adsistent with each constraint. \nAn important detail is that, while lo\u00adcations holding zero are unconstrained, zero is consistent with \nei\u00adther a pointer type or most primitive types. In this example, both PartNode and Shape are value-consistent \nwith block A if the value at A +4 is viewed as a null pointer. Filtering Constraints: Some values may \nnot be used to infer ba\u00adsic type information directly, but may help reject a hypothesized type if the \nvalue is not part of the domain of that type. We ac\u00adcept an enum as a potential byte type only if the \nvalue starting at that byte is equal to one of the de.ned constants for the enumer\u00adated type. Similarly, \na function pointer type is consistent if its value is any word-aligned address that may contain executable \ncode. We may also employ a character constraint in programs that manipulate ASCII text: if a block is \notherwise unconstrained and ASCII char\u00adacter values are stored at every offset in the block, then the \nblock should be typed as a charor char[n]rather than any other con\u00adsistent primitive or primitive array \ntype. A more detailed discussion of the rationale for the above .ltering constraints may be found in \nour technical report [20]. Programmers may wish to de.ne additional value constraints to re.ect application-speci.c \ntypes and invariants. Our heap typing algorithm can accommodate arbitrary predicates that approve or \nre\u00adject the type proposed for a given location and value. For example, the data structure consistency \nspeci.cations of Demsky et al. [6] could be applied as additional value constraints for selected types. \n 4.2 Size Constraints The overall type for a block must .ll exactly the number of bytes allocated for \nthat block. For any address block which is the start of an allocated block, T (block)=t . sizeof (block)=sizeof \n(t) In C, dynamically allocated arrays tile multiple copies of the element type one after the other. \nA block holding a dynamic array Block Size Size-Consistent Types A 8 PartNode, Shape, char[8], ... B \n24 Part, Assembly, Shape[3], PartNode[3], float[6], ... C 24 Part, Assembly, Shape[3], PartNode[3], float[6], \n... D 8 PartNode, Shape, int[2], ... E 5 char[5] Table 2. Size constraints and possible size-consistent \ntypes for heap in Figure 4 with n elements of type t must satisfy sizeof (block)=n \u00d7 sizeof (t) for some \nwhole number of array elements n. Table 2 shows size constraints and a few illustrative size\u00adcompatible \ntypes for blocks in the example heap snapshot. 4.3 Type Constraints Type constraints relate multiple \nlocations, either between blocks (for pointers) or within a single block (for multi-byte structures): \n(i)If T (addr): pointer and *addr is within an allocated block (not one past the end), then T (*addr). \nreferent. (ii)If T (addr): t for any atomic type t, then T (addr +i)= interior for all 1 = i < sizeof \n(t). Combined with rule (i) and the incompatibility of interior and referent, this forbids pointers into \nthe interior of atomic values. (iii) For any allocated block starting at block, T (block). referent. \nWhile similar to rule (i), this rule also affects leaked blocks to which nothing points. (iv)If T (addr): \nt ptr then T (*addr): t. Pointers and pointed-to types must be compatible modulo subtyping. (v)If T (addr): \ns((t1,l1,i1),...,(tk,lk,ik)), then T (addr +in)= tn for all 1 < n = k. Structure .elds must be compatible \nwith the structure as a whole. (vi)If T (addr)=t[n], then T (addr +i \u00d7 sizeof (t))=t for all 1 = i < \nn. Array elements must be compatible with the array as a whole. Implied constraints may imply additional \nconstraints. A con\u00adsistent heap typing must satisfy all transitively implied type con\u00adstraints. Untagged \nunions induce no additional type constraints. Any tagged union type u@(t,l,0){...} is also a subtype \nof t and will pick up any appropriate constraints per the above rules. 4.4 Debug Constraints If symbolic \ndebug information is available for in-scope variables and function arguments, then this information may \nbe added to the type map in the obvious manner. Equality constraints are appropri\u00adate here: if xis known \nto be an integer variable, then its type must be int, not some int subtype. Our main algorithm (Section \n5) does not require debug information to .nd consistent typings, but takes debug constraints into account \nif present. 4.5 Example Solution We now combine value, size, and type constraints to informally derive \nthe consistent heap typing shown in Figure 5. Section 5 presents a systematic algorithm for .nding consistent \ntypings auto\u00admatically. For clarity, we consider user-de.ned types before other possible matches (such \nas arrays of primitives). Assume that debug constraints are unavailable.    4 4 Figure 5. Fully constrained \nheap and derived typing for heap in Figure 4 From valid pointer value and size constraints, block A must \nhave type Shapeor PartNode.If Shapeis considered .rst, we propagate a charconstraint to block E via rule \n(iv). Value and size constraints require that block E have type char[5]. Because char[5] : char, block \nE can have type char[5]and still be consistent with the charpointer from block A. If we had tried A : \nPartNode.rst, then a con.ict would have arisen; we discuss con.icts in detail in Section 5. From size \nand value constraints, block B must have type Part or Assembly.Ifwetry Assembly, then B + 16 : PartNode* \nvia rule (v) and so A : PartNode via rule (iv), but this con.icts with A : Shape established earlier. \nChoosing B : Part is consis\u00adtent with A : Shape, and also requires C : Assembly. This is consistent with \nvalue and size constraints on block C. Lastly, block D must have type PartNodedue to the pointer .eld \nat C + 16.  5. Heap Typing Algorithm In this section, we present an algorithm for assigning types to \nall storage locations, if a consistent typing is possible. Inputs to the algorithm consist of a snapshot \nof all values in the program s mem\u00adory; the start addresses and sizes of all allocated heap blocks; a \nlist of de.ned program types; and optional symbolic debug information giving the locations, sizes, and \ntypes of in-scope variables. The out\u00adput is a typing T giving consistent byte types for all allocated \nbytes. The byte type for the 0th byte of an allocated block gives the over\u00adall type for that block. In \nsome (but not all) cases when no globally consistent typing exists, the algorithm can identify, describe, \nand eliminate untypable blocks while still producing a partial typing for the remaining blocks. The algorithm \nbegins by assigning types to individual bytes of storage, using the values that arise in the program \n(e.g., valid pointers and their pointed-to locations) as a foremost source of byte type constraints (Section \n5.1). Next we transitively propagate byte types from variables declared in the program (for which exact \ntypes are known), reporting any type constraint violations to the user (Section 5.2). Finally, we systematically \nconsider possible overall types for each memory block until the typing map is fully de.ned or all typing \nalternatives for the blocks are exhausted (Section 5.3). 5.1 Pointer Constraint Gathering We .rst establish \nvalid pointer value constraints on individual bytes as described in Section 4.1. Type constraint rules \n(i) (iii) induce ad\u00additional constraints where appropriate. Con.icts between referent and interior may \narise during this stage. For example if blocks X and Y hold valid pointers, but Y points to byte X + \n2, then X + 2 cannot simultaneously be the referent of the pointer in Y and the interior of the pointer \nin X. In this situation, it is dif.cult to know which block is truly erroneous. We describe the con.ict \nto the user, then mark both blocks as untypable and disregard them for the re\u00admainder of the algorithm. \nAfter this phase, the typing constrains some bytes to be sub\u00adtypes of pointer, interior,or referent, \nbut many bytes remain un\u00adconstrained (T) and no program types yet appear. 5.2 Debug Constraint Gathering \nIf symbolic debug information is available, debug constraints are applied next, then propagated transitively \nacross pointers and into compound types using type constraint rules (iv) (vi). Value and size constraints \nare checked where appropriate. Note, however, that size constraints are only partially enforced: a block \nmust be at least large enough to contain the expected type, but may be larger. For example, the target \nof a double*must be at least eight bytes long, but may be longer if it is part of a larger structure, \nunion, or array. During this stage, con.icts may arise among debug constraints (e.g. int and float in \nthe same location); between debug and size constraints (e.g. int in a two-byte block); between debug \nand value constraints; or between debug and pointer, referent, or interior constraints derived in the \nprevious stage. If any such con.ict occurs, we assume that execution has deviated from type safety and \nthat the static type system therefore cannot be trusted to predict run-time types. We report the problem \nto the user and then back out all debug constraints. The remainder of the algorithm will operate using \nobserved memory values only, without considering declared variable types. A more selective approach, \nwhich we leave as future work, would be to discard only a minimal subset of problematic debug constraints \nwhile keeping the remainder. Barring con.icts, at the conclusion of this phase, the global typ\u00ading includes \nprogram types for memory addresses that are (transi\u00adtively) reached from pointers in program variables. \nHowever, these types are merely lattice upper bounds. For example, a pointer to charmay actually point \nto an array of characters or to a structure with an initial char.eld. Some bytes within reachable blocks, \nand all bytes within unreachable blocks, still carry only the pointer, referent, and interior constraints \nadded previously.  5.3 Completing the Heap Typing Given the initial byte type constraints, we next assign \nan overall type to every heap block. Fully enforced size constraints ensure that the size of a block \ns overall type is equal to the block size, so all allocated bytes are constrained when the typing is \ncompleted and the 0th byte of each block determines the block s overall type. 5.3.1 Typing Feasibility \nCheck We .rst verify that every heap block may be assigned at least one program type, given the initial \nconstraints. A block that cannot be assigned any known type may be corrupt or may have been allocated \nin a library whose internal types are unavailable. We describe the problematic block to the user, then \nmark it as untypable and disregard it in the type search phase that follows.  5.3.2 Search Algorithm \nThe main search phase considers the possible types for each block, backtracking in the event of con.icts. \nWhen a type is veri.ed as consistent with all current constraints on a particular block, we update the \nbyte types for all bytes in this block to re.ect the overall type, as well as propagate constraints one \nlevel forward across pointers in the block, and proceed to the next block. If no consistent type is found \nfor some block, we backtrack to the last block that still has remaining type alternatives, and resume \nthe search from that point. The algorithm terminates either when the last considered block is assigned \na consistent type, or when all possible types for all blocks have failed, in which case no consistent \ntyping exists. Block Type Considered Outcome Induced Constraints on Other Blocks C FILE size con.ict: \nsizeof(C) < sizeof(FILE) C Part . D + 0: Shape D Shape type con.ict at D + 0: meet(Shape,FILE)= . C Assembly \n. D + 0: PartNode D PartNode . B + 0: Part A PartNode size con.ict: sizeof(E) < sizeof(PartNode) A Shape \n. E + 0: char E char[5] . Table 3. Heap typing algorithm execution trace Na\u00efvely implemented, this search \nis geometric in the number of blocks and exponential in the number of types. However, since an entire \nblock s type must be a subtype of its 0th byte s type, the search can be restricted to the sublattice \nbelow this bound. This optimization is especially effective with debug constraints enabled, as most pointers \nrefer to the initial byte of an allocated block. If a heap has several consistent typings, we prefer \na typing that is most informative for the user. We consider larger types .rst, program-de.ned types before \nprimitives, singletons before arrays, and fewer levels of pointer indirection before more. This order \nis designed to heuristically direct our solution toward more useful typings. We do not guarantee that \nthe .nal heap typing is globally minimal or optimal with respect to this order, but we .nd that it yields \ngood results in practice.  5.4 Example: Computing the Solution We now illustrate the algorithm as applied \nto our running example, again considering the heap snapshot after the init_part()call on line 6 of Figure \n3. To illustrate con.ict handling, we modify the values shown in Figure 4 as follows: assume that bytes \nB + 16... B+19 have been corrupted, and no longer hold a valid pointer value. All other value constraints \nremain as shown in Table 1. During debug constraint collection, an inconsistency arises when a B : Partconstraint \nis propagated from variable node, be\u00adcause Part requires a valid pointer or null at bytes B + 16... B \n+ 19. Since a con.ict is found, debug constraints are discarded. The search continues using only value \nconstraints. Block B does not pass the typing feasibility check, so it is omitted from the search. Table \n3 summarizes steps taken during the backtracking search for complete types. The remaining blocks are \nconsidered in their al\u00adlocation order, and the types are ordered according to our sorting heuristic. \nThe algorithm is able to recover the types of the four re\u00admaining blocks using value and size constraints \nonly, backtracking several times throughout the search. The .nal heap typing for the four remaining blocks \nis as shown in Figure 5. 5.5 Propagation Correctness After assigning a type to a block, we update constraints \nfor the block itself and also propagate all pointer constraints forward across one dereference. We claim \nthis is suf.cient to ensure that no inconsistency between typed blocks is overlooked. Any two blocks \nX and Y , where Y is transitively reachable from X, will al\u00adways be assigned consistent types regardless \nof the order in which they are considered. The full proof of our claim is contained in our technical \nreport [20].  6. Evaluation We have implemented the above algorithm within the GNU De\u00adbugger (gdb) \n[10], a popular symbolic debugger for C. When the program is stopped at a breakpoint, the user may type \nwhatsat <expr> to perform heap type inference and then display type\u00adannotated memory beginning at the \naddress computed by <expr>. Implementing the validPointer predicate requires that the de\u00adbugger probe \nthe debuggee s current heap allocation state. We mod\u00adify the debuggee s memory management routines to \nmaintain a list of currently allocated blocks in a reserved global location known to the debugger; the \ndebugger reads this list directly from the de\u00adbuggee s address space as needed. We record the start address \nand size of each block, plus the code address from which each block allocation call originated. whatsat \nuses the latter in diagnostic messages to report the source .le, line number, and function at which each \nuntypable block was allocated. This extra allocation tracking uses standard hooks exposed by the GNU \nlibc implementation [9] and is contained within a shared library that may be preloaded into any program \none wishes to debug without recompilation or relinking. Our allocation hooks also zero-initialize newly \nallocated blocks. This is done to avoid spurious typing errors due to random data values in uninitialized \nheap memory. However, it can be useful to disable this feature in or\u00adder to verify that the program under \nstudy fully initializes all of its own heap storage under normal running conditions (Section 6.3). 6.1 \nVisualization of Typed Memory Following heap type inference, whatsat displays memory con\u00adtents augmented \nwith type information. Visualization begins at any address of the user s choosing (e.g. whatsat 0x9275008 \nor whatsat &#38;foo[3] ) and continues forward through raw memory under user control. Figure 6 shows \npart of the type-annotated memory visualization for a program used in one of our experiments (see Section \n6.2). Each line shows a capitalized hexadecimal memory address (e.g. 0X804ABC0: ), up to one word of \nraw memory content at that address ( 0x00000001 ), and an interpretation of that memory typed according \nto our algorithm ( length = (int) 1 ). In\u00addentation and .eld labels ( length = ) re.ect nesting and com\u00adpound \ntypes. Figure 6 shows .ve distinct but proximate memory blocks containing an array of structures and \nfour function pointers. The D and ? labels to the left of each address mark locations that are part of \nthe static data section or have never been allocated, respectively. Other labels (not seen in this example) \nmark the stack, typed heap locations, freed heap locations, and several other cate\u00adgories of memory. \n 6.2 Schedule2 Schedule2 is a small C application from the Siemens buggy pro\u00adgram suite [12]. Given a \nlist of jobs and their priorities as input, the application computes and prints a schedule for running \nthe jobs. Version 8 of schedule2 contains a bug that causes the program to crash inside malloc(). A stack \ntrace reveals that the crash is due to a bad pointer dereference: a function pointer, __malloc_\u00adhook, \ndoes not point to a function. whatsat con.rms that the ? 0X804ABB8: 0x00000000 ? 0X804ABBC: 0x00000000 \n(queue [4]) [0] = (queue) D 0X804ABC0: 0x00000001 length = (int) 1 D 0X804ABC4: 0x0804b0d0 head = (process \n*) 0x804b0d0 [1] = (queue) D 0X804ABC8: 0x00000001 length = (int) 1 D 0X804ABCC: 0x0804b0a8 head = (process \n*) 0x804b0a8 [2] = (queue) D 0X804ABD0: 0x00000000 length = (int) 0 D 0X804ABD4: 0x00000000 head = (process \n*) 0x0 [3] = (queue) D 0X804ABD8: 0x00000000 length = (int) 0 D 0X804ABDC: 0x00000000 head = (process \n*) 0x0 ? 0X804ABE0: 0x00000002 D 0X804ABE4: 0x0804b008 (void *(*)()) 0x804b008 D 0X804ABE8: 0x00000000 \n(void (*)()) 0 D 0X804ABEC: 0x00749380 (void *(*)()) <realloc_hook_ini> D 0X804ABF0: 0x007493d0 (void \n*(*)()) <memalign_hook_ini> ? 0X804ABF4: 0x0804b018 ? 0X804ABF8: 0x00000000 Figure 6. Schedule2 global \nvariables visualization. The types of function pointer arguments are omitted for brevity. claimed type \nfor __malloc_hook is inconsistent with its value, and therefore that debug constraints are not satis.able. \nAfter debug constraints are discarded, whatsat infers that this block actually contains a processstructure. \n__malloc_hook is assigned from old_malloc_hook, which holds the same bad process pointer instead of a \nfunction pointer. Using whatsat to explore the physical memory neigh\u00adborhood around old_malloc_hook reveals \nthat a four-element structure array precedes old_malloc_hook. Figure 6 shows whatsat s visualization \nof this area. old_malloc_hook ap\u00adpears at address 0X804ABE4; the preceding array is clearly visible starting \nat address 0X804ABC0. Observe that old_malloc_\u00adhookis perfectly positioned to receive an errant processpointer \nshould the neighboring array overrun its bounds. Thus informed, we identify the array, the code that \nwrites to it, and the missing bounds check that constitutes the true bug. All whatsat queries used in \nthis case study completed within 0.03 seconds. While a hardware watchpoint might also have been used \nto trap the bad write to old_malloc_hook, this would require rerunning the program and reproducing the \nbug. Many memory corruption bugs are dif.cult to reproduce on demand; we see here that whatsat can provide \nuseful postmortem information on the .rst instance of a bug. 6.3 Exif Exif is an open source utility \nfor manipulating JPEG image meta\u00addata [8]. It consists of 10,375 lines of C code split into a shared \nli\u00adbrary and a main driver program. We ran exif with a breakpoint set after exif_loader_get_data(), which \nbuilds an in-memory representation of a JPEG input .le. We disabled zero-initialization of heap blocks \nto test whether exif performs its own initializations properly. whatsat identi.es two untypable blocks \nallocated in exif_content_add_entry()at exif-content.c:110. The code in question performs a reallocation \nto grow an array of pointers to entry blocks: entries = realloc(entries, sizeof (ExifEntry) * (count \n+ 1)); The size calculation is incorrect. It reserves space for an array of (count + 1)ExifEntrystructures, \nbut entriesis actu\u00adally an array of pointers to ExifEntry structures. Because each ExifEntry is larger \nthan a pointer, the program does not over\u00adrun this buffer. However, the extra space at the end of the \narray is wasted and, because it contains uninitialized random data that may not look like valid pointers, \nwhatsatdetermines that arrays allo\u00adcated here are untypable. We initially identi.ed this previously unreported \nbug in release 0.6.9 and 0.6.10 of the exif driver and library. We have con.rmed that it persists in \nthe latest development snapshot as of April 15, 2006 (12,410 lines of C code). Exif developers have since \ncon\u00ad.rmed the bug and applied our suggested .x. After whatsat identi.es these untypable blocks, it ignores \nthem for the remainder of the analysis. That analysis, however, does not .nd a valid heap typing for \nexif in a timely manner. It is possible that no valid typing exists even though all individual blocks \nmatch at least one known type. It is also possible that a valid typing exists, but is pathologically \nmismatched with our heuristic search order. Improving the diagnostic capabilities of our analysis when \nunresolvable con.icts arise late in the search is an important area for future study.  7. Related Work \nChandra and Reps [5] and Siff et al. [21] introduce an alternate type system for C that allows subtyping \nbased on the physical layouts of data structures. They describe static type checking and inference rules \nthat test program conformance with this alternate type system. In contrast, our approach is dynamic: \nwe examine a frozen snapshot of a running program s heap, rather than the space of all possible program \nheaps. This allows us to use concrete memory values and allocated block sizes to re.ne our analysis. \nAs is typical for dynamic analyses, we focus on speci.c bugs triggered during a run without guaranteeing \nthat all possible bugs will be detected. The subtyping relation induced by our byte type lattice is more \nrestrictive than the Chandra/Siff physical subtyping relation. Both allow subtyping between a structure \nand its .rst .eld, but we dis\u00adallow more general structure pre.xing or the use of char arrays as storage \nplaceholders. These are merely policy choices. Our ap\u00adproach can use permissive Chandra/Siff subtyping \nor a variety of other relations with no changes to constraint collection or the core heap typing algorithm. \nHowever, not all subtyping relations are sen\u00adsible in this context. For example, Cardelli s structural \nrecord sub\u00adtyping relation [4], disregards .eld order and is therefore needlessly permissive for our \nscenario, where .eld orders are .xed. As a dynamic heap-walking tool, our system shares some qual\u00adities \nwith a garbage collector or leak detector, and a list of unreach\u00adable (leaked) memory blocks could easily \nbe extracted from our analysis. Traditional garbage collectors require data structure lay\u00adout information \nfor the root set and possibly for allocated blocks as well. Conservative garbage collectors [3] relax \nthis requirement by assuming that any location holding a valid pointer value is indeed a pointer. Our \napproach moves .exibly between these extremes. Ul\u00adtimately, the information we recover is richer than \nthat produced by garbage collectors: we .nd not only the size and embedded point\u00aders of each allocated \nblock, but also complete program types that are globally consistent both within and between all blocks. \nZimmermann and Zeller present strategies for extracting C heaps and displaying them to highlight key \nrelationships [25]. Their system depends on debugger-provided type information augmented with a few C-speci.c \nheuristics also used by whatsat, such as pointer validity testing and dynamic array size computation. \nThese heuristics consider only isolated blocks, though, and have no no\u00adtion of global consistency. Zimmermann \nand Zeller acknowledge that While such heuristics mostly make good guesses, it is safer to provide explicit \ndisambiguation rules either hand-crafted or in\u00adferred from the program. Dynamic heap type inference generalizes \nand improves upon these heuristics by de.ning a notion of global heap typing that considers not just \nlocal values within isolated blocks, but also the relationships between interlinked blocks. This lets \nwhatsat.nd globally consistent heap typings and reduces or eliminates the need for hand-crafted disambiguation \nrules. The problem of heap corruption due to pointer and cast abuse is longstanding, and has inspired \nsolutions ranging from static analy\u00adsis [7, 18] to run-time instrumentation [11, 15, 16, 17, 19, 24] \nand the design of safer language dialects [2, 14, 22]. Our approach per\u00adforms programmer-directed heap \nvalidity checks in an interactive debugging context, and does not attempt to prevent or trap errors as \nthey occur. This allows us to be signi.cantly less invasive: we require no changes to the C language; \nno recompilation or source annotation beyond a compiler-provided list of program types; no run-time instrumentation \nbeyond a list of allocated blocks; and no dynamic type tagging or other changes to data structure layouts. \nAdditionally, our analysis depends only on the instantaneous state of the program heap at a given moment \nin time: other than main\u00adtaining a list of currently allocated blocks, we do not record any trace information \nwhile the program runs. In this sense whatsat can be seen as an experiment in min\u00adimalism. Rather than \nmonitor every potentially interesting action, we ask how much information can be recovered with only \nthe bare minimum imposition at run-time. We believe that both highly in\u00advasive and minimally invasive \napproaches have bene.ts. Exploring the extremes helps illuminate potential strategies to improve debug\u00adging \ntools all along the instrumentation and analysis spectrum. 8. Conclusion Low-level programming languages \nsometimes require low-level debugging. However, one need not completely abandon the type system even \nwhen working with non-type-safe languages. A low\u00adlevel but type-annotated view of the heap can help in \ndebugging and more general program understanding tasks. We have presented an algorithm that infers program-de.ned \ntypes for memory loca\u00adtions. Solution consistency is de.ned in terms of constraints that use a novel \nblend of ideas from physical subtyping and conserva\u00adtive garbage collection. When no consistent typing \nexists due to heap corruption or pointer abuse, we offer focused diagnostic in\u00adformation to help identify \nthe cause. Our implementation works for general C programs and requires no source annotation, no re\u00adcompilation, \nno run-time instrumentation beyond heap allocation tracking, and no changes to physical data structure \nlayouts. Expe\u00adriences with the tool, while limited in scope, suggest that dynamic heap type inference \nmay be a useful addition to the programmer s toolkit.  References [1] L. O. Andersen. Program Analysis \nand Specialization for the C Programming Language. PhD thesis, DIKU, University of Copenhagen, May 1994. \n [2] T. M. Austin, S. E. Breach, and G. S. Sohi. Ef.cient detection of all pointer and array access errors. \nIn PLDI 94: Proceedings of the ACM SIGPLAN 1994 conference on Programming language design and implementation, \npages 290 301, New York, NY, USA, 1994. ACM Press. [3] H.-J. Boehm and M. Weiser. Garbage collection \nin an uncooperative environment. Software: Practice &#38; Experience, 18(9):807 820, 1988. [4] L. Cardelli. \nStructural subtyping and the notion of power type. In POPL 88: Proceedings of the 15th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 70 79, New York, NY, USA, 1988. ACM Press. [5] \nS. Chandra and T. W. Reps. Physical type checking for C. In Workshop on Program Analysis For Software \nTools and Engineering, pages 66 75, 1999. [6] B. Demsky, M. D. Ernst, P. J. Guo, S. McCamant, J. H. Perkins, \nand M. Rinard. Inference and enforcement of data structure consistency speci.cations. In ISSTA 2006, \nProceedings of the 2006 International Symposium on Software Testing and Analysis, Portland, ME, USA, \nJuly 18 20 2006. [7] D. Evans. Static detection of dynamic memory errors. In PLDI 96: Proceedings of \nthe ACM SIGPLAN 1996 conference on Programming language design and implementation, pages 44 53, New York, \nNY, USA, 1996. ACM Press. [8] EXIF tag parsing library. http://libexif.sf.net/. [9] Free Software Foundation, \nInc., Boston, MA, USA. The GNU C Library, 0.10 edition, July 6 2001. [10] J. Gilmore and S. Shebs. GDB \nInternals, Feb. 2004. [11] R. Hastings and B. Joyce. Purify: Fast detection of memory leaks and access \nerrors. In Proceedings of the USENIX Winter Conference, pages 125 138, San Francisco, CA, USA, 1992. \nUSENIX Association. [12] M. Hutchins, H. Foster, T. Goradia, and T. Ostrand. Experiments on the effectiveness \nof data.ow-and control-.ow-based test adequacy criteria. In Proceedings of the 16th International Conference \non Software Engineering, pages 191 200. IEEE Computer Society Press, May 1994. [13] International Organization \nfor Standardization. ISO/IEC 9899:1999: Programming Languages C. International Organization for Standardization, \nGeneva, Switzerland, Dec. 1999. [14] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and \nY. Wang. Cyclone: A safe dialect of C. In Proceedings of the General Track: 2002 USENIX Annual Technical \nConference, pages 275 288, Berkeley, CA, USA, 2002. USENIX Association. [15] R. W. M. Jones and P. H. \nJ. Kelly. Backwards-compatible bounds checking for arrays and pointers in C programs. In AADEBUG, pages \n13 26, 1997. [16] S. Kaufer, R. Lopez, and S. Pratap. Saber-C: An interpreter-based programming environment \nfor the C language. In Proceedings of the USENIX Summer Conference, pages 161 171, San Francisco, CA, \nUSA, June 1988. USENIX Association. [17] A. Loginov, S. H. Yong, S. Horwitz, and T. W. Reps. Debugging \nvia run-time type checking. In FASE 01: Proceedings of the 4th International Conference on Fundamental \nApproaches to Software Engineering, pages 217 232, London, UK, 2001. Springer-Verlag. [18] G. C. Necula, \nJ. Condit, M. Harren, S. McPeak, and W. Weimer. CCured: Type-safe retro.tting of legacy software. ACM \nTransactions on Programming Languages and Systems, 27(3):477 526, 2005. [19] N. Nethercote and J. Seward. \nValgrind: A program supervision framework. Electronic Notes in Theoretical Computer Science, 89(2), 2003. \n[20] M. Polishchuk, B. Liblit, and C. Schulze. WHATSAT: Dynamic heap type inference for program understanding \nand debugging. Technical Report 1583, University of Wisconsin Madison, Oct. 2006. [21] M. Siff, S. Chandra, \nT. Ball, K. Kunchithapadam, and T. W. Reps. Coping with type casts in C. In O. Nierstrasz and M. Lemoine, \neditors, ESEC / SIGSOFT FSE, volume 1687 of Lecture Notes in Computer Science, pages 180 198. Springer, \n1999. [22] G. Smith and D. Volpano. A sound polymorphic type system for a dialect of C. Science of Computer \nProgramming, 32(1-3):49 72, 1998. [23] B. Steensgaard. Points-to analysis in almost linear time. In Symposium \non Principles of Programming Languages, pages 32 41, 1996. [24] J. L. Steffen. Adding run-time checking \nto the portable C compiler. Software: Practice &#38; Experience, 22(4):305 316, 1992. [25] T. Zimmermann \nand A. Zeller. Visualizing memory graphs. In Software Visualization, International Seminar Dagstuhl Castle, \nGermany, May 20 25, 2001, Revised Lectures, volume 2269 of Lecture Notes in Computer Science, pages 191 \n204. Springer, May 2001. \n\t\t\t", "proc_id": "1190216", "abstract": "C programs can be difficult to debug due to lax type enforcement and low-level access to memory. We present a dynamic analysis for C that checks heap snapshots for consistency with program types. Our approach builds on ideas from physical subtyping and conservative garbage collection. We infer a program-defined type for each allocated storage location or identify \"untypable\" blocks that reveal heap corruption or type safety violations. The analysis exploits symbolic debug information if present, but requires no annotation or recompilation beyond a list of defined program types and allocated heap blocks. We have integrated our analysis into the GNU Debugger (gdb), and describe our initial experience using this tool with several small to medium-sized programs.", "authors": [{"name": "Marina Polishchuk", "author_profile_id": "81322503645", "affiliation": "Microsoft Corporation", "person_id": "P831285", "email_address": "", "orcid_id": ""}, {"name": "Ben Liblit", "author_profile_id": "81100555854", "affiliation": "University of Wisconsin--Madison", "person_id": "PP38025922", "email_address": "", "orcid_id": ""}, {"name": "Chlo&#235; W. Schulze", "author_profile_id": "81322505921", "affiliation": "Oracle Corporation", "person_id": "P831279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1190216.1190225", "year": "2007", "article_id": "1190225", "conference": "POPL", "title": "Dynamic heap type inference for program understanding and debugging", "url": "http://dl.acm.org/citation.cfm?id=1190225"}