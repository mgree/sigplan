{"article_publication_date": "10-01-2004", "fulltext": "\n Object-Oriented Units of Measurement Eric Allen David Chase Victor Luchangco Jan-Willem Maessen Guy \nL. Steele Jr. Sun Microsystems Laboratories Burlington MA 01803 <first>.<last>@sun.com ABSTRACT Programs \nthat manipulate physical quantities typically rep\u00adresent these quantities as raw numbers corresponding \nto the quantities measurements in particular units (e.g., a length represented as a number of meters). \nThis approach elimi\u00adnates the possibility of catching errors resulting from adding or comparing quantities \nexpressed in di.erent units (as in the Mars Climate Orbiter error [11]), and does not sup\u00adport the safe \ncomparison and addition of quantities of the same dimension. We show how to formulate dimensions and \nunits as classes in a nominally typed object-oriented lan\u00adguage through the use of statically typed metaclasses. \nOur formulation allows both parametric and inheritance poly\u00admorphism with respect to both dimension and \nunit types. It also allows for integration of encapsulated measurement systems, dynamic conversion factors, \ndeclarations of scales (including nonlinear scales) with de.ned zeros, and noncon\u00adstant exponents on \ndimension types. We also show how to encapsulate most of the magic machinery that handles the algebraic \nnature of dimensions and units in a single meta\u00adclass that allows us to treat select static types as \ngenerators of a free abelian group.  Categories and Subject Descriptors D.1.5 [Programming Techniques]: \nObject-Oriented Pro\u00adgramming; D.3.1 [Programming Languages]: Formal Def\u00adinitions and Theory; D.3.3 [Programming \nLanguages]: Language Constructs and Features  General Terms Design,Languages 1. INTRODUCTION Physical \nunits and dimensions are a commonly used com\u00adputational construct in science and engineering, but there \nis relatively little support for them in programming languages. Instead, physical quantities are typically \nrepresented as num\u00adbers that correspond to the quantities measurement in a particular unit (e.g., a length \nrepresented as a number of OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright \n2004 Sun Microsystems, Inc. All rights reserved. ACM 1-58113-831-8/04/0010. meters); the unit and dimension \nof the measurement are not represented in the program at all (except possibly in the names of variables \nused to hold these numbers). Thus, the units and dimensions cannot be used in the analysis of the program. \nIn particular, they cannot be used to detect errors resulting from mismatched quantities. While trivial, \nsuch errors are not uncommon, and can have costly reper\u00adcussions. For example, the loss of the Mars Climate \nOrbiter in September 1999 was ultimately traced to a failure in the software to convert between English \nand metric units [11]. In another example, a space shuttle rolled itself away from the Earth in response \nto an instruction to bounce a laser o. a mountain it was told was 10,000 miles high, rather than the \nintended 10,000 feet [24]. Units were not programmed as part of the input data and therefore all inputs \nwere im\u00adplicitly interpreted as measurements in miles. At least super.cially, dimensions and units bear \na strong similarity to types. However, most contemporary type sys\u00adtems, even with generic types, are \ninsu.ciently expressive to capture several properties necessary for dimension check\u00ading. For example, \ndimension checking at compile-time re\u00adquires the compiler to manipulate dimensions according to a dimensional \nalgebra (e.g., Time \u00d7 Length = Length \u00d7 Time). Most previous formulations of dimension checking in pro\u00adgramming \nlanguages have encoded dimensions as an ad hoc language feature rather than integrating them into a gen\u00aderal \ntype system. The few attempts at integrating dimen\u00adsions into more general type systems have focused \non struc\u00adtural type systems over functional and procedural languages with signi.cantly di.erent design \nconsiderations than those of mainstream object-oriented languages [20]. In this paper, we show how to \nintegrate dimensions and units with classes in a nominally typed object-oriented language (such as the \nJavaTM Programming Language or C#) in a way that supports static checking of units and dimensions, and \nwith a performance cost no greater than that of boxing primitive values.1 1Boxing is a technique that \nenables a primitive value (e.g., 0) to be used in contexts requiring a reference value by wrap\u00adping the \nprimitive in a new reference (new Integer(0)). It can negatively impact execution time because boxed \nvalues must be dereferenced when accessed. However, clever com\u00adpiler optimizations, particularly in just-in-time \ncompilers, Our formulation allows dimensions and units to be treated as ordinary class-based types, and \nallows both parametric and inheritance polymorphism with respect to both dimension and unit types. We \ndescribe the new language features re\u00adquired to support this integration in the context of the Mix-Gen \nextension [1] of the Java Programming Language, where generic types are .rst-class. MixGen allows type-dependent \noperations such as casts on arbitrary generic types, and even expression of mixins (i.e., generic classes \nparameterized by their own superclasses). First-class generic types play a crucial role in our formula\u00adtion \nof dimensions. We present our language as an extension of MixGen to ground it in a sound, statically \ntyped object\u00adoriented language that supports .rst-class generic types. A formulation in the context of \nC++ templates, in particular, would not meet this criterion. MixGen includes many sub\u00adtle features to \nhandle pathologies that do not arise in our treatment of dimensions and units for example, support for \npolymorphic recursion, hygienic method overriding, and nontrivial with clauses; we avoid discussing these \nfeatures. Therefore, we expect our formulation to be accessible to readers familiar only with C++, C#, \nor the Java Program\u00adming Language, and with the notion of encoding mixins via generic types, as can be \ndone with C++ templates. Also, because our real interest is in understanding the relation\u00adships of dimension \nand unit checking with object-oriented type systems in general, we make no attempt to maintain backward \ncompatibility when extending MixGen. Our main extension to MixGen is the addition of statically typed \nmetaclasses, which we use to model values that have associated dimensional units. We also de.ne a special \nmeta\u00adclass abelian class that provides the algebraic properties necessary to model dimensions and units \naccurately. Al\u00adthough we strive to introduce as few features as possible, the language we end up with \nis quite di.erent from the lan\u00adguage we started with; we dub our new language MetaGen. In Section 2, \nwe brie.y analyze some concepts important to dimension and unit checking, discuss design constraints \nfor a system to do this checking, and explain why existing object-oriented languages do not satisfy these \nconstraints. In Section 3, we describe several common uses of physical quantities for which we want to \nhave static checking, and the features of MetaGen that support this ability, and we describe further \nextensions in Section 4. We discuss various syntactic and performance issues in Section 5, survey related \nwork in Section 6, and conclude with future directions in Section 7.  2. ANALYSIS AND DESIGN CHALLENGES \nIn this section, we lay out the basic framework and terminol\u00adogy that we use throughout this paper. Although \nthe view we take is not the only way to understand dimensions and units, we have found it useful for \nelucidating many design issues. We also discuss several pragmatic requirements that in.uence our design. \ncan eliminate much of this overhead by specializing code with variants for unboxed values in contexts \nwhere observ\u00adable behavior is una.ected. 2.1 Basic terminology and analysis The fundamental notion in \nour formulation is that of a quan\u00adtity. Every quantity exists in a particular dimension2 (e.g., Length, \nTime). When two quantities Q and Q. exist in the same dimension, we can answer the question, how much \nof Q does it take to equal Q.? Some quantities are designated units and are denoted with special symbols \n(e.g., Meter, Second). Every quantity can be denoted by a measurement in terms of any unit U in its dimension. \nIf it takes x of U to equal Q then we denote Q with the measurement xU, and we call x the magnitude of \nthis measurement. For example, the denotation 5 Meters is a measurement for a quantity in the dimension \nLength whose magnitude in terms of the unit Meter is 5. One advantage of using units is that it allows \nus to compare two measurements of the same dimension algebraically. To express a quantity Q denoted by \na measurement M = xU in unit U as a measurement in another unit V , we need not re\u00admeasure the same quantity \nin V (which is seldom practical, and often impossible). Instead, we can measure our unit U with unit \nV , resulting in a measurement yV ; we say y is the conversion factor from U to V . Then we can form \nthe measurement M. of Q in unit V by substituting yV for U in M: M = xU = xyV =(xy)V . Two measurements \nin the same unit can be compared by comparing their magnitudes arithmetically. Magnitudes can be taken \nfrom an arbitrary algebraic .eld. For now, we assume that magnitudes are always real num\u00adbers (i.e., \ninstances of a class Real, which we intentionally leave unde.ned). Furthermore, we use the standard liter\u00adals \nand mathematical operators to denote real numbers and their methods, and we do not worry about errors \ndue to computational limitations such as imprecision and over.ow. We discuss taking magnitudes from arbitrary \n.elds in Sec\u00adtion 4.2, and implementation issues in Section 5.2. We can also combine quantities of distinct \ndimension via multiplication and division to form new quantities. Such a quantity exists in a new dimension \ndenoted by combining the respective dimensions with combinators \u00d7 and /, which satisfy certain algebraic \nproperties (e.g., Length \u00d7 Time = Time \u00d7 Length). The set of dimensions is an abelian group under \u00d7 [21]. \nWe de.ne a special dimension, called unity, to serve as the multiplicative identity for dimensions, and \nwe denote the inverse of a dimension D by D-1 . Units of combined measurements are combinations of units \nof the constituent measurements. Just as we can have sev\u00aderal units of a given primary dimension, we \ncan have several derived units for a given derived dimension. It is also possi\u00adble to de.ne new primitive \nunits of combined dimensions. 2.2 Design Constraints We want a design that accurately models our understand\u00ading \nof dimensions and units. In addition, we impose the following pragmatic design constraints: 2We adopt \nfor now the na\u00a8ive view that every quantity exists in a single, .xed, dimension. In Section 3.6, we discuss \nsome ways in which this na\u00a8ive view needs to be re.ned. 1. It should be easy to convert a measurement \nin one unit to a measurement in another unit of the same dimension. 2. Type-dependent operations on \ndimensions and units, such as casting and instanceof tests, as well as the ability to print and store \nmeasurements, should be sup\u00adported. 3. It should be possible to require that a quantity be denoted by \na measurement in a speci.c unit (e.g., a length that must be measured in meters) as an addi\u00adtional error \ncheck, to avoid unnecessary conversions, and to manage the inaccuracies inherent in .oating point calculations. \n 4. Programmers should be able to de.ne new units and dimensions and to de.ne behavior speci.c to that \ndi\u00admension (e.g., a method dilate for Time). Even if all programmers and users were willing to use the \nSI sys\u00adtem, there are contexts in which units and dimension checking can be employed (currency, information, \netc.) that are not part of this system. 5. We should allow for as much polymorphism as possible. In \nparticular, we should support type parameters for dimensions and units. 6. Unit annotations on quantities \nshould cost no more in execution time and space than boxing of primitive values. 7. We should add as \nfew features to the language as pos\u00adsible without sacri.cing conceptual coherence (i.e., as simple as \npossible, but no simpler ).  2.3 Why we need a new language Ideally, we could model systems for static \nchecking of dimen\u00adsions and units as libraries in existing object-oriented lan\u00adguages. Unfortunately, \neven with .rst-class generic types, we quickly run into obstacles when trying to do so. The fundamental \ndi.culty, which we encounter in many guises, is the need to treat a single entity as both a type and \na value. For example, dimensions must be types so that we can statically check expressions for dimensional \ncorrectness. However, there are several ways in which dimensions are more like values than types. For \nexample, we must be able to multiply dimensions together to form new dimensions, and this operation must \nobey algebraic properties such as commutativity. Even syntactically, the form of dimensions is value-like: \nthe dimension Length/Time2 syntactically con\u00adtains the value 2. There is another more subtle way in which \nunits and dimen\u00adsions behave like both types and values: a natural object\u00adoriented modeling of dimensions \nidenti.es each dimension as a class containing as instances the quantities of that dimension as well \nas an instance of a class Dimension. For example, Length is a Dimension and 5 Meters is a Length. We \nwant to de.ne a class Dimension so that we can spec\u00adify polymorphic contexts that can be instantiated \nwith any dimension, and so we can de.ne functionality common to all dimensions in a single class. For \nexample, we want to declare that for every dimension D, every quantity of D has a method inUnit that \nallows conversion to a measurement in any unit of D. We may also want to declare abstract methods such \nas shortName on dimensions, or a method devices that returns a collection of the devices used to measure \nquantities of a dimension. We cannot represent individual dimensions as subclasses of Dimension because \nthe instances of partic\u00adular dimensions naturally identi.ed as quantities in that dimension should not \nbe used in contexts requiring a di\u00admension. If we model quantities as instances of their corre\u00adsponding \ndimension class, and we model dimension classes as subclasses of Dimension, then by transitivity of subtyping, \nevery quantity would also be an instance of Dimension, which is clearly wrong: 5 Meters is not an instance \nof Dimension. We might try to break this inheritance relationship with a shallow workaround, such as \ntreating dimensions as sub\u00adclasses of Dimension and introducing a parametric class Quantity to model \nquantities of a particular dimension: abstract class Dimension {...} class Length extends Dimension {...} \nclass Time extends Dimension {...} ... class Quantity<D extends Dimension> {...} Then lengths would \nbe instances of Quantity<Length> and times would be instances of Quantity<Time>. This approach introduces \na spurious distinction between Quantity<Length> and Length; these two classes are naturally identi.ed. \nFur\u00adthermore, it prevents us from de.ning behavior speci.c to all quantities of a particular dimension. \nFor example, there is no place to de.ne methods such as dilate that are com\u00admon to all instances of Quantity<Time>: \nIf they were de.ned in class Time then they could not be accessed as methods of D from within Quantity<D>. \nIf they were de.ned in Quantity<D> then they could be accessed by all instantiations of Quantity. If \nwe instead de.ne class Quantity<D> as a mixin that extends class D, then quantities of a particular dimension \nwould again be instances of Dimension and we would be back to square one. Continuing with yet another \nworkaround, we could de.ne an ad hoc subclass for each (actual) instantiation of Quantity<D> (e.g., QuantityOfLength \nextends Quantity<Length>). Because of the limitations of contemporary generic type systems, this sort \nof workaround is quite common. But it is unsatisfac\u00adtory because it introduces critical invariants that \ncannot be statically checked (e.g., there must be exactly one ad hoc subclass of Quantity<D> for each \nsubclass of Dimension; the name of each ad hoc subclass has a precise relationship with the instantiation \nof Quantity<D> it extends; etc.). Moreover, these unchecked invariants were introduced solely to work \naround the constraints of the static type system! What we really want is a language that allows us to \nexpress the correct relationships among the concepts we are model\u00ading. We want to de.ne classes that \ncan be used as values as well as static types. The inability to de.ne such constructs is a pervasive \nbut seldom recognized problem in contempo\u00adrary object-oriented languages. Sometimes the problem is circumvented \nby de.ning unnatural class hierarchies with unenforced invariants, such as our hierarchy involving class \nQuantity<D>. Other times, the Singleton Pattern [12] is em\u00adployed. This pattern involves constructing \nunique instances of classes and storing them in static .nal .elds with the name ONLY. For example, we \ncan de.ne class Length as a Singleton, class Length extends Dimension { static final Length ONLY = new \nLength(); private Length() {} ... } creating a one-one correspondence between class Length and its sole \ninstance. We can treat the instance as a value and the class as a type while conceptually identifying \nthe two. The Singleton Pattern introduces extra machinery and ver\u00adbosity into a program, and does not \nreally address the un\u00adderlying problem. We cannot use the (conceptually unique) instance of a type in \na context requiring a value without .rst dereferencing the singleton instance ONLY, and we can\u00adnot access \nthe ONLY .eld of a Singleton type in a parametric context. Furthermore, this pattern is useless in the \ncur\u00adrent context: de.ning dimension classes as Singleton sub\u00adclasses of Dimension does not help us to \nstatically check al\u00adgebraic combinations of dimensions and it does not address the problem that instances \nof a particular dimension should not be instances of class Dimension.  3. OUR SOLUTION To properly \ncapture the dual nature of dimensions and units as both values and types, we generalize the conventional \nnotion of class inheritance. In addition to de.ning subtype relationships between classes, we also allow \nclasses to be instances of other classes. These instance classes may be used like values that are de.ned \nstatically. In this way, they obviate the need for the Singleton Pattern. But we also allow instance \nclasses themselves to contain instance classes, and we allow class extension of instance classes. These \nnew instanceof relationships are expressed by replac\u00ading the keyword class with programmer-de.ned classes \nas necessary. For example, we can de.ne the classes abstract class Dimension {...} Dimension Length {...} \nwhere class Length is an instance of class Dimension. The generalization of class relationships turns \nout to be the key language feature needed for integrating dimensions and units with object-oriented types. \nFurthermore, this gener\u00adalization has applicability beyond just dimension checking. It allows us to more \naccurately model many mathematical structures based on set membership and subsets. Metaphor\u00adically, we \ncan think of classes as sets. Class extension can be thought of as the subset relationship, and instanceof \ncan be thought of as set membership. In this view, allowing classes to contain other classes is quite \nnatural. We now describe the core of the new semantics of MetaGen, an extension of the MixGen extension \nof the Java Program\u00adming Language that allows us to express the type relation\u00adships we want. 3.1 Metaclasses \nFirst, we establish some terminology in order to describe our new semantics. A program consists of a \ncollection of class de.nitions. The class de.nition of a class C speci.es a metaclass D, of which C is \nan instance. C is also an instance of all superclasses of D. A metaclass is either a user-de.ned class \nor a special metaclass such as class, abstract class, or interface. We call D the kind of C. We also \nsay that C is an instance class of D and all of D s superclasses, and that D (and all its superclasses) \nare containing classes of C. The kind of a class C is speci.ed in its header: kind C<type params > [extends \nsuperclass ] {...} For example, we may de.ne the core classes in our dimension\u00adchecking library as follows: \nabstract class Dimension {} Dimension Length {...} Dimension Time {...} ... Classes Length and Time \nare instance classes of Dimension, and Dimension is the kind of classes Length and Time. The kind of \nDimension is abstract class. In general, there is no relationship between a class s kind and its superclasses. \nInstance classes should be viewed as special values that also denote a static type. Note that instance \nclasses (like all classes) are de.ned statically; there is no way to allocate a new instance class dynamically. \nInstance classes may also have subclasses and instances of their own. An interface may serve as the kind \nof an instance class. It is often useful to specify that type parameters are of a speci.c kind (e.g., \nthat a parameter is of kind Dimension). Thus, we extend MixGen syntax so that we can specify a type parameter \ns kind as well as its bounding superclass: kind parameter extends bound For example, we de.ne generic \nclasses for both units and measurements. Units are tied to particular dimensions; we parameterize the \nclass representing them by a type of kind Dimension. Measurements are tied to particular units; we parameterize \nthe class representing them by a unit in the appropriate dimension. class* Unit<Dimension D> extends \nD {...} class Measurement<Dimension D, Unit<D> U> extends D { private final Real _magnitude; ... } The \nspecial kind class* is introduced to designate a class whose instances are all instance classes. Unit<D> \nis de.ned to be of kind class* so we can enforce the property that every unit will be associated with \nits own type. An instantiation of D must be an instance of Dimension (and a subtype of Object). For example, \nwe can de.ne the following instance classes: Unit<Time> Minute {...} Unit<Length> Foot {...} Unit<Length> \nMile {...} ... Both Unit<D> and Measurement<D,U> extend their dimension D, allowing us to refer to the \ntype D in places we expect mea\u00adsurements of D, (e.g., we can say that a method m takes a Length and call \nm with new Measurement<Length,Mile>(5), de\u00adnoting 5 Miles). We also get a single point of control for \nspecifying functionality speci.c to a particular dimension D: the class D itself. We stipulate that a \nnaked type parameter occurring in an extends clause or as a kind of a type param\u00adeter must be instantiated \nonly with classes that contain a zeroary constructor and no abstract methods (ensuring there is a superconstructor \nto call and that a mixin will not acci\u00addentally inherit abstract methods without de.ning them).3 Because \nUnit and Measurement both have a superclass type parameter of kind Dimension, they implicitly require \nthat all instance classes of Dimension include a zeroary constructor. Because the unit of a measurement \nis a type parameter, we need not add an extra .eld to hold the unit; that is, the implementation need \nnot include an extra unit reference in each instance. As in MixGen, instantiations of type param\u00adeters \nof a generic type can be stored in a class table en\u00adtry shared by all instances of that instantiation. \nTherefore, unit support is no more expensive than boxing provided that magnitudes are represented with \nprimitive values. 3.1.1 Static members and instance members As in MixGen, a class de.nition includes \nboth static mem\u00adbers and instance members. Each member is either a .eld or a method (we leave open the \nquestion of how to integrate inner classes into our metaclass semantics). If C is an instance class of \nD then the instance members of D are static members of C (i.e., members of the class object C). C may \noverride the instance methods of D by declaring static methods with matching signatures. If D includes \nab\u00adstract methods (via either inheritance or direct de.nition), those methods must be de.ned as static \nmethods in C. For example, we add the following de.nitions to our dimension classes: abstract class Dimension \n{ ... abstract String shortName(); } Dimension Length { ... static String shortName() { return \"L\"; } \n} Dimension Time { ... static String shortName() { return \"T\"; } } The expression Time.shortName() evaluates \nto \"T\". Also, if we de.ned a method: String dimName(Dimension d) { return d.shortName(); } then the method \ncall dimName(Time) evaluates to \"T\" as well. 3Readers familiar with MixGen semantics may note that our \nrestrictions on type parameters allow us to drop the use of MixGen s with clauses on type parameters. \n In MetaGen, a class is allowed to de.ne both a static method and an instance method of the same name. \nHowever, this allowance introduces the potential for ambiguity when a method so de.ned is called from \nwithin an instance method of the class it is de.ned in. Our solution is simply to require references \nto static members from instance contexts to ex\u00adplicitly denote the receiver. The receiver of a static \nmethod call may be any legal type, including a type parameter. Static methods of C must not con.ict with \nfinal instance methods of C s kind and its superclasses. As with MixGen, static methods must not be abstract. \nThe static members of a class de.ne the members of that class when considered as a value. They are not \nmembers of a class s instances, nor are they inherited by subclasses. For example, we cannot write the \nexpression Meter.shortName(). 3.1.2 Constructors and instance classes As with instance methods, the instance \n.elds of a kind D of C are static .elds of C. Because these .elds are normally initialized with a call \nto a constructor of D, we must answer the question of how they are initialized for an instance class \nsuch as C. We allow such .elds to be initialized as follows: class C is allowed a single isolated constructor \ncall to its kind in a static block. This constructor call must occur before all other static actions \nin the class de.nition. The new keyword container is used to designate this call. For example, we de.ne \nan instance class of class Measurement<Length,Mile> that we name CircumferenceOfEarth. This class must \ncall the constructor of Measurement from a static block: Measurement<Length,Mile> CircumferenceOfEarth \n{ static { container(24889); } } Then CircumferenceOfEarth, viewed as an instance, has a single .eld \nmagnitude initialized with value 24889. Viewed as a class, it has a single static .eld magnitude with \nvalue 24889. If the immediate containing class of a class C is known to have a zeroary constructor and \nthe de.nition of C does not include a call to a containing constructor in a static block, then C acts \nas if the static block static { container(); }were inserted at the beginning of the body of C. 3.1.3 \nClasses as values Henceforth, we use variable to refer to .elds, local variables, and method parameters \n(but not type parameters). A class can be assigned to a .eld or variable and passed as an argument to \na method, provided that it is an instance class of the variable s type. In general, a variable may be \nbound to either an instance class or an ordinary (non-class) instance. Member accesses (i.e., .eld accesses \nand method calls) to a variable bound to an instance class are interpreted as accesses to static mem\u00adbers \nof the instance class. Member access to a non-class instance behaves in the usual way. A variable may \nnot be used in type contexts (e.g., the type of a method parameter or the type speci.ed in a cast opera\u00adtion), \neven if it is bound to an instance class. Also, there is no way to call a constructor of a bound instance \nclass on a variable it is bound to (we are intentionally ignoring interac\u00adtions of metaclasses with re.ection \nfacilities). For example, the constructor call in the following code is not allowed: Length measurementMaker(Measurement<Length,Mile> \nm) { return new m(); // not allowed } A type parameter of kind K can be used in all type contexts. It \ncan also be used in any context requiring a value of class K. In particular, it can be assigned to variables \nof class K and instance methods of K may be called on it, just like ground instances or other variables \nof class K. For example, we include the following method de.nition in class Unit<D>: class* Unit<Dimension \nD> extends D { ... String dimName() { return D.shortName(); } } Furthermore, Minute.dimName() evaluates \nto \"T\". With this core semantics in hand, we now discuss advanced aspects of our library de.nition, as \nwell as some peripheral language features motivated by it. Many of these additional aspects are quite \ncomplex, but this complexity results pre\u00adcisely from our intention to provide programmers with the behavior \nthey intuitively expect. It is often the case with language design that a semantics that correctly matches \npro\u00adgrammers intuitive expectations necessarily includes sub\u00adtleties that are seldom thought about or \neven noticed by most users of the language.  3.2 Unit conversion and primary units To convert between \nmeasurements in di.erent units of the same dimension, we must specify conversion factors between various \nunits of that dimension. A natural place to keep this information is in the de.nition of a unit: each \nunit speci.es how to convert measurements in that unit to measurements in any other de.ned unit (for \nthe same dimension). Al\u00adthough the number of such conversion factors is quadratic in the number of units, \nit is not necessary to maintain so many factors explicitly: if we can convert between measure\u00adments in \nunits A and B, and between measurements in units B and C, then we can convert between measurements in \nA and C via B. Thus, it is su.cient to include in the de.\u00adnition of every unit a single conversion factor \nto a primary unit of that dimension, and convert between any two com\u00admensurable units via their common \nprimary unit. class* Unit<Dimension D> extends D { final private Real _primaryConversion; Unit(Real primaryConversion) \n{ if (primaryConversion == 0) { throw new RuntimeException( \"Attempt to define a unit with a 0 conversion.\" \n); } _primaryConversion = primaryConversion; } Real getPrimaryConversion() { return _primaryConversion; \n} <Unit<D> U> Real conversionFactor() { return _primaryConversion / U.getPrimaryConversion(); } <Unit<D> \nU> Measurement<D,U> inUnit() { return new Measurement<D,U>(conversionFactor<U>()); } ... } The introduction \nof primary units also allows us to avoid cyclic dependencies in unit de.nitions. Note that the constructor \nof class Unit<D> ensures that no instances of Unit<D> will have a _primaryConversion of 0. Because this \nconstructor is called in static blocks of each instance class, we catch such violations when classes \nare loaded. We still need to reify primary units with separate classes so we can refer to them. Given \na dimension D, we want to be able to easily obtain its primary unit. We also need to ensure that each \ndimension has exactly one primary unit. We meet both of these requirements by de.ning a new class PrimaryUnit, \nparameterized by a dimension. Each instantia\u00adtion of this class with a particular dimension D is the \nprimary unit of D. We enforce that class PrimaryUnit has no subclasses or instances by introducing a \nnew modi.er, final*: final* Unit<D> PrimaryUnit<Dimension D> { static { container(1); } } The final* \nkeyword indicates that PrimaryUnit has no sub\u00adclasses or instances. Conceptually, we view final* classes \nas typed terminal values; they act like ordinary values with unique types that could be represented in \na more clumsy fashion with the Singleton Pattern. This solution gives a syntactically enforced bijection \nbe\u00adtween dimensions and primary units: the primary unit of dimension D is PrimaryUnit<D>. For convenience \nand read\u00adability, we use aliases to identify primary units with familiar units. For example, alias Meter \n= PrimaryUnit<Length>; Using the conversion factors de.ned by the units, we can easily convert between \nmeasurements in di.erent units: class Measurement<Dimension D, Unit<D> U> extends D { Real magnitude; \n... <Unit<D> V> Measurement<D,V> inUnit() { return new Measurement<D,V> ( magnitude * U.conversionFactor<V>() \n); } Measurement<D,PrimaryUnit<D>> asPrimary() { return new Measurement<D,PrimaryUnit<D>> ( magnitude \n* U.getPrimaryConversion() ); } ... } The methods inUnit and asPrimary require calling a static method \non the type parameter U. Static checking ensures that each instance class of Unit<D> de.nes conversionFactor \nand getPrimaryConversion. We can also name commonly used, algebraically formed di\u00ad mensions using type \naliases. For example, we use Area to Length refer to the dimension Length2 and Speed to refer to . Time \nWe now turn turn to the question of how to handle alge\u00adbraically formed dimensions such as these.  3.3 \nDimensional algebra Like quantities, dimensions and units can be combined via multiplication and division \noperators. We might (na\u00a8ively) try to model these operators as classes parameterized by their operands: \nDimension DimProd<Dimension D, Dimension E> {...} Dimension DimQuot<Dimension D, Dimension E> {...} This \nmodel is unsatisfactory because the algebraic structure of dimensions requires that we equate certain \nterms. For ex\u00adample, Length\u00d7Time = Time\u00d7Length. Furthermore, the units of a given dimension can be combined \nas well. Combined units obey algebraic rules, and the subtyping relationships between units and their \ndimensions should be respected dur\u00ading algebraic manipulation. Another complication is that combined \nforms of dimensions and units may contain integers. For example, consider the parameter type of a sqrt \nmethod over quantities (where we part with the Java Programming Language speci.cation by using ^ to refer \nto exponentiation rather than exclusive or): <Dimension D> D sqrt(D^2 x) { ... } Notice that the parameter \ntype contains a numeric exponent (namely 2). We want to allow combined dimensions that can be raised \nto (constant) integer exponents. 3.3.1 Abelian classes Rather than support algebraic manipulation in \nan ad hoc fashion, we introduce a more general language extension that gives us the expressiveness we \nneed: a new (special) metaclass abelian class. As with class*, a class of kind abelian class must have \nonly instance classes. The explic\u00aditly declared instance classes of an abelian class form the identity \nand basis of a free abelian group.4 Metaclass abelian class is parameterized by an identity element that \ndesig\u00adnates the instance class that serves as the identity for the 4An abelian group is a set A together \nwith an operator, often denoted + : A, A . A, that satis.es the following properties: There exists i \n. A such that a + i = a for all a . A; i is called the identity of A.  For any a . A, there exists a \n. . A such that a+a . = i; a is called the inverse of a in A.  For all a,a ,a .. . A,(a + a .)+ a = \na +(a + a ..).  For all a, a . . A, a + a . = a . + a.  group. For notational convenience, we also \nparameterize abelian class with two symbols, included in parentheses, that denote (i) the binary operator \nof the group and (ii)a repetition operator of the group, which takes an element of the abelian group \nand an integer n, and yields the result of repeated application of the binary operator to the element \nn times (where, if n is negative, application to an element n times is de.ned to denote the inverse of \nthe result of appli\u00adcation to that element |n| times). We write an instantiation of type abelian class \nas follows: abelian class (bin op,rep op )<identity > name {...} The repetition operator is given higher \nprecedence than the binary operator. Because we are modeling a multiplicative semantics in this section, \nwe use * as the binary operator and ^ as the repetition operator. For readability, we represent applications \nof ^ with superscripts. We refer to the set of explicitly de.ned instance classes of an abelian class \nG as the base types of G. The set of instances of G is the set generated by the following rules: All \nbase types of G are elements of G.  If T and U are elements of G then T *U is an element of G.  If \nT is an element of G then for all n . Z, T n is an element of G.  Additionally, generated elements \nare equated according to the following rules: T *U = U*T  T *(U*V )=(T *U)*V  T 0 = identity  T \n1 = T  mm+n T *T n = T These rules imply all of the ordinary rules for manipulating integer exponents \nthat we make use of in this paper. Now we can rede.ne class Dimension as an abelian class, with the special \ndimension Unity as its identity element: abelian class (*,^) <Unity> Dimension {...} Dimension Unity \n{...} ... Dimension Length {...} Dimension Time {...} ... Then in addition to Length, Time, etc., class \nDimension also contains Length*Time-2, etc. 3.3.2 Abelian constructors For instance classes B and C of \nan abelian class A, the class B*C includes (as static .elds) all instance .elds in the de.nition of A. \nIt does not include any of the .elds de.ned in B or C. Initialization of the .elds of B*C is de.ned by \na special constructor in A labeled by the binary operator of A. The arguments to this constructor must \nbe exactly two elements of type A, denoting the two instance classes being combined to form the new instance. \nSimilarly, initialization of Bn is de.ned by a special constructor in A labeled by the repetition operator \nof A. This constructor takes an argument of type A and a final int n, denoting the numeric argument to \nthe repetition operator. The argument n is constrained by static checking to be a constant (we discuss \na generalization to nonconstant exponents in Section 4.1). We refer to both of these constructors as \nabelian constructors. Notice that an abelian constructor is shared by all algebraically formed elements \nof A. If A is a generic class, we need to declare type parameters on the abelian constructors to denote \nthe instantiations of the type parameters for a particular instance class. For example, we revise our \nde.nition of class Unit to be an abelian class, with PrimaryUnit<Unity> as its identity element, and \nabelian constructors as follows: abelian class (*,^) <PrimaryUnit<Unity>> Unit<Dimension D> extends D \n{ final private Real _primaryConversion; <Dimension E, Dimension F> *(Unit<E> V, Unit<F> W) { this(V.getPrimaryConversion().multiply( \nW.getPrimaryConversion() )); } <Dimension E> ^(Unit<E> V, final int n) { this(V.getPrimaryConversion().power(n)); \n} ... } For generic abelian classes, we impose restrictions on the re\u00adspective instantiations of type \nparameters for the elements of a combination. The instantiations of a type parameter whose kind is not \nan abelian class must match; the type parameter of the combination is instantiated with the same type. \nThe instantiations of a type parameter whose kind is an abelian class are combined pointwise in the new \ninstan\u00adtiation. For example, because Meter is an instance class of Unit<Length> and Second is an instance \nclass of Unit<Time>, Meter*Second is an instance of Unit<Length*Time>. In general, the type Unit<E>*Unit<F> \nequals the type Unit<E*F>. Like\u00adwise, Unit<E>^n equals Unit<E^n>. The identity element of a generic abelian \nclass is also con\u00adstrained: every type parameter of an identity element whose kind is an abelian class \nmust be instantiated with the iden\u00adtity element of its kind. For example, the identity of Unit<D> must \nbe an instance of Unit<Unity> because Unity is the iden\u00adtity of Dimension. An algebraically formed instance \nof an abelian class A in\u00adcludes (as static methods) all instance methods de.ned in the de.nition of A. \nBut an abelian class may also have ab\u00adstract methods. For example, class Dimension includes the abstract \nmethod shortName. Abstract methods of an abelian class A may be de.ned for algebraically formed instance \nclasses by de.ning them in the abelian class itself. Methods de.ned this way must include de.nitions \nof behavior under combination by both the binary operator and the repeti\u00adtion operator of A, and these \nde.nitions must be pre.xed by the binary and repetition operators. The de.nition pre\u00ad.xed by the binary \noperator includes two type parameters of kind A. The de.nition pre.xed by the repetition operator includes \na type parameter of kind A and a final int param\u00adeter. For example, abstract method shortName is de.ned \nfor algebraically formed instance classes of Dimension by adding the following method de.nitions to class \nDimension: <Dimension E, Dimension F> * String shortName() { return E.shortName() + \"*\" + F.shortName(); \n} <Dimension E> ^ String shortName(final int n) { return E.shortName() + \"^\" + n; }  In the example \nabove, does Time*Length.shortName() eval\u00aduate to \"L*T\" or \"T*L\"? The answer would appear to de\u00adpend on \nthe order of the arguments. However, by the alge\u00adbraic properties of abelian classes, Time*Length is \nthe same as Length*Time. To allow methods such as shortName to be well-de.ned, we need to canonicalize \nall combined abelian types. More importantly, canonicalization is a natural way to statically determine \ntype equivalence. We discuss a pro\u00adcedure for canonicalization in the next section. Before any constructors \nare called on an algebraically formed instance of an abelian class, the instance is canonicalized. After \ncanonicalization, the terms of the canonicalized Bn product are initialized from left to right via the \nabelian con\u00adstructor pre.xed by the repetition operator. Then combi\u00adnations of these terms are initialized \nfrom left to right via the abelian constructor pre.xed by the binary operator. 3.4 Canonicalization \nof abelian type references To statically check type equivalence between members of an abelian class G, \nwe identify members of G and put them in canonical form so they can be compared directly. Ignoring for \nthe moment the complication of type parame\u00adters, elements of G can be identi.ed syntactically: they are \nsimply type expressions whose base types are all elements of G that are combined solely via the two operators \nof G. To put elements of G into canonical form, we perform the following steps: 1. Replace all occurrences \nof a base type T (no exponent) with T 1 . 2. Distribute exponents so we are left with a product of base \ntypes that are raised to various powers. 3. Eliminate all parentheses. 4. Put base types into lexicographic \norder.  5. For each occurrence of base type T , combine all tokens P T ni ni into a single token T . \n6. Eliminate all base type tokens of exponent 0. 7. Eliminate all occurrences of the identity element \nof G. 8. If nothing is left but the empty product, add a single occurrence of the identity element. \n For example, the (improbable) dimension 2 -24 -88 (Length * Time * Unity)* Length * Time is canonicalized \nas follows: 1 8 . (Length2 * Time-2 * Unity)4 * Length-8 * Time48 . (Length8 * Time-8 * Unity) * Length-8 \n* Time 8  . Length8 * Time-8 * Unity4 * Length-8 * Time 4  . Length8 * Length-8 * Time-8 * Time8 * \nUnity 4  . Length0 * Time0 * Unity . Unity  . E . Unity Once elements of G are in canonical form, \ntype equivalence can be determined via syntactic equivalence. Generalizing to allow type parameters of \nkind G is straight\u00adforward: In a lexical scope binding new type parameters, we identify type parameters \nof kind G as elements of G, just as if they were new base types of G. Elements of G can be built with \nthese type parameters just as they can with true base types. Of course, these type parameters may be \ninstantiated with elements of G that are not base types; we merely treat them syntactically as base types \nwithin the scope that binds them. Within that scope, canonicalized elements of G are equated if and only \nif they are syntactically equivalent. References to instance classes of abelian classes that are syntactically \ncontained in generic type instantiations are also canonicalized. For example, because PrimaryUnit is \npa\u00adrameterized by a dimension, our solution for algebra over Dimension automatically allows us to form \nand compare pri\u00admary units of compound dimension. Thus, PrimaryUnit<Length*Time> equals PrimaryUnit<Time*Length> \nFor abelian classes with type parameters, an additional step is necessary for canonicalization: instantiations \nof common generic abelian classes are combined pointwise. For exam\u00adple, Unit<Length>^2*Unit<Length*Time> \nis canonicalized to: Unit<Length^3*Time>  3.5 Arithmetic operations on quantities To use an arbitrary \ninstance of a dimension D in arithmetic contexts, we need to declare that instances of D de.ne arith\u00admetic \noperations; that is, all instances of D must include a set of arithmetic methods. To express such a restriction, \nwe add a new class modi.er to our language. To motivate this new modi.er, let us reconsider our metaphor \nof classes as sets. We can understand conventional class extension dec\u00adlarations class C extends D as \nan assertion of the following form: .x . C.x . D When the only relationship between classes is extension, \nthis simple form of assertion is su.cient to state the most es\u00adsential relationships. Once we generalize \nour language to include metaclasses, several new assertions suggest them\u00adselves. For example, consider \na class hierarchy for biologi\u00adcal applications with classes Species and LivingThing. We want to declare \nthat all instances of Species are subtypes of LivingThing. In general, we may want to make assertions \nof the following form, relating classes to their subclasses and instances: .x . C.x . D To express this \nnew relation, we add an optional extends* clause to the header of a class de.nition. For example, we \ncan represent the constraint we would like on instances of Species as follows: abstract class LivingThing \n{} abstract class Species extends* LivingThing {} Species Human extends LivingThing {} Species Lion extends \nLivingThing {} Then Human and Lion would be invalid class de.nitions if they did not extend LivingThing. \nWe also allow for an implements* clause that constrains instance classes to implement desig\u00adnated interfaces.5 \nAs with instances of a class of kind class*, all instances of a class that includes either an extends* \nor an implements* clause in its de.nition must be instance classes. We add an implements* clause to class \nDimension, requiring that each instance class D of class Dimension implements an interface DimensionI \nthat contains a set of arithmetic oper\u00adations. In this way, we ensure that each instance of D will de.ne \nthose methods. The signatures of the arithmetic methods of an instance of dimension D must refer to D \nitself: D add(D x); D subtract(D x); <Dimension E> D*E multiply(E x); <Dimension E> D*E^-1 divide(E x); \n<Unit<D> U> Measurement<D,U> inUnit(); The method inUnit allows us to convert an arbitrary quan\u00adtity \nof D into a measurement in a given unit U of D so we can add and subtract it to another measurement in \nU. 5Of the two remaining variations, .x . C.x . D is logically equivalent to the constraint for ordinary \nsubtyping, and we know of no motivation in practice for stipulating constraints of the form .x . C.x \n. D. How can we put these declarations in an interface in such a way that the interface has a handle \non the type of an instance class of Dimension? We need to include a type parameter on the interface to \nrepresent the type of an instance class of Dimension. The bound on this type parameter will therefore \nbe our interface instantiated with the type parameter itself: interface DimensionI<DimensionI<This> This> \n{ <Unit<This> U> Measurement<This,U> inUnit(); This add(This x); This subtract(This x); <Dimension That> \nThis*That multiply(That x); <Dimension That> This*That^-1 divide(That x); <Unit<This> U> Measurement<This,U> \ninUnit(); } We now need to rede.ne Dimension to declare that each of its instance classes implements \nan instantiation of this interface with itself. We do that as follows: abelian class (*,^) <Unity> Dimension<Dimension<This> \nThis> implements* DimensionI<This> {...} Our instance classes of Dimension now need to instantiate this \nparameter with themselves: Dimension<Length> Length {...} Dimension<Time> Time {...} The tight bound \non parameter This ensures that each in\u00adstance class of Dimension must instantiate This with itself. Therefore, \nit is straightforward to introduce syntactic sugar that implicitly includes a type parameter This on \nevery class of kind class* or abelian class and on every class that in\u00adcludes an extends* or implements* \nclause. We need only re\u00adserve the identi.er This as a new keyword. With this syntactic sugar, our class \nde.nitions revert almost to their earlier form: abelian class (*,^) <Unity> Dimension implements* DimensionI<This> \n{...} Dimension Length {...} Dimension Time {...} ...  3.6 Zero quantities When we introduced the notion \nof dimension, we said that if two quantities Q and Q. exist in the same dimension, we can answer the \nquestion, how much of Q does it take to equal Q.? If it takes x of Q to equal Q. then we write Q. = xQ. \nWe now discuss a minor complication with this na\u00a8ive view. Consider the ability of two quantities to \nbe related in this way as a relation R. Because we naturally think of dimen\u00adsions as dividing quantities \ninto disjoint sets, we might ex\u00adpect that R is an equivalence relation. Unfortunately, our expectation \nis not quite right: although R is re.exive, it is neither symmetric or transitive. The problem lies with \nzero quantities: it takes 0 of any quantity to equal a zero quantity, but no amount of a zero quantity \nequals a nonzero quantity. Furthermore, the symmetric closure of R does not satisfy transitivity. For \nexample, suppose QRQ. and Q.RQ.. . Then it may be the case that Q. =0Q and Q. =0Q.., but that QRQ.. does \nnot hold. Strictly speaking, we should de.ne the notion of dimension for nonzero quantities, and then \nadd in the notion of the zero quantity as special. Given this special status of the zero quantity, it \nis natural to ask whether there are any software engineering repercus\u00adsions as to how we treat it. In \nfact, there are [21, 27]. We would like to allow programmers to write down zero quan\u00adtities without the \ntedium of having to add dummy units. For example, we want the following code to be legal: Length x = \n<some expression> ; if (x == 0) {...} Treating the zero quantity as polymorphic in this way is harmless: \nIf we can statically determine that a quantity is zero, then no harm can come from adding it to, or multi\u00adplying \nit by, an arbitrary quantity; in the former case, the result is simply the quantity it is added to; in \nthe latter case the result is simply the zero quantity. On the other hand, if we cannot statically determine \nthat a quantity is zero, then static checking will prevent it from being used polymorphically. To include \na special zero quantity, we might consider re\u00adstricting magnitudes of measurements to be nonzero and \nthen adding a new typed element Zero of class Measurement: Measurement<D, U> Zero<Dimension D, Unit<D> \nU> {} However, we do not want a separate Zero for each dimension and unit. Rather, we want a single polymorphic \nzero quan\u00adtity that is an instance of all instantiations of Measurement. We express this relationship \nby using wildcard instantiations of type parameters of generic classes. If T<C> is a generic type, then \nwe can instantiate C with a wildcard, written T<*>. An instance of T<*> is an instance of all instantiations \nof T. Normally we cannot say such things in object-oriented languages with generic types because the \nnotions of pointwise extension of a generic type and of ex\u00adtension of all instantiations of a generic \ntype are con.ated (e.g., Zero<D,U> extends Measurement<D,U>). But it is help\u00adful to distinguish these \nnotions. Because the programmer has no handle on the type argument of a wildcard instanti\u00adation of a \nparent class, it is syntactically impossible for the de.nition of such a class to depend on those arguments. \nUsing wildcards, we de.ne the zero quantity to be a wildcard instantiation of Measurement: Measurement<*,*> \nZero {...} Although adding wildcards may seem excessive just to get a polymorphic zero quantity, wildcards \nare useful in other contexts. For example, wildcard instantiations are similar to a standard interpretation \nof many type hierarchies as they are written in a structurally typed languages such as ML and Haskell, \nwhere parametric types are erased after type checking and do not a.ect run-time behavior. For example, \nlists are typically modeled in ML as follows: a List = Empty | a Cons In this de.nition, there is one \nEmpty list shared by all instan\u00adtiations of List. In contrast, Generic Java without wildcard instantiations \nforces us to include a separate Empty for each instantiation of List [6]: class Empty<T> extends List<T> \n{...} Using wildcards, we can de.ne class Empty as: List<*> Empty {...}  4. EXTENSIONS We have presented \nour framework in the context of a general\u00adpurpose object-oriented type system, adding only metaclasses, \nabelian classes, and wildcards. With just these three ex\u00adtensions, we are able to express the most common \nuses of physical quantities in computations. In particular, we can express user-de.ned dimensions and \nunits, automatic con\u00adversion between units of a given dimension, static types cor\u00adresponding to dimensions \nand units, parametric polymor\u00adphism with respect to these types, dimensional algebra, and zero quantities \nof polymorphic dimension. Furthermore, our formulation is general and robust enough to extend easily \nin many ways to support additional static checking. In this section, we discuss some of these ways. \n4.1 Nonconstant exponents In general, we prefer that exponents on abelian classes not be limited to be \nconstants. For example, we would like to de.ne a power function over quantities: /** @precondition n \n>= 0 */ <Dimension D> D^n power(D x, int n) { if (n == 0) return 1; else return x.multiply(power(x, n-1)); \n} where the value 1 is autoboxed to a value of type Unity. Employing pure recursion is of course undesirable \nin a math library function, but the speci.c implementation is irrele\u00advant for our present purposes; what \nis relevant is that we are able to type check even recursive de.nitions. Parameterizing dimensions by \nrun-time integer values is a form of dependent typing. Because we cannot statically de\u00adtermine precisely \nwhich integer computations will result in equal values when the program is run, we must, as with all \nstatic checking, settle for a conservative approximation. One approximation that allows us to check many \npractical examples and leverage the machinery we have already de\u00adveloped is to treat the set of ints \nas an abelian class!6 The binary operator of this class is addition; the repetition op\u00aderator is multiplication. \nEach int constant is treated as a distinct type. A final int bound in a lexical scope is treated as a \ntype parameter ranging over this abelian class. Thus, the set of valid int types consists of all expressions \nof int variables and constants formed via multiplication and addition. We iden\u00adtify and canonicalize \nelements of this type in the same way as explained for general abelian classes. However, special prop\u00aderties \nof the ints allow us to equate even more terms than we 6We assume that autoboxing of primitives is built \ninto the language, as it is in the JavaTM 2 SDK1.5. can for an ordinary abelian class. Speci.cally, \nbecause the set of ints is the only abelian class with the property that the second, numeric, argument \nto the repetition operator is itself a element of the class, and the repetition operator rep\u00adresents \nmultiplication, we allow additional canonicalization for this special class.7 Automatic simpli.cation \nof arith\u00admetic expressions is well understood, and is incorporated in many production systems, including \nproof checkers such as Isabelle and symbolic math tools such as Mathematica. To support nonconstant exponents \nin type expressions in other abelian classes (e.g., Dimension), we need to add one step to the canonicalization \nprocess in Section 3.3, between steps 5 and 6: 5.5. Canonicalize all exponents. We can now type check \nour power method, provided the parameter n is declared to be final (allowing it to be used as a type): \n/** @precondition n >= 0 */ <Dimension D> D^n power(D x, final int n) { if (n == 0) return 1; else return \nx.multiply(power(x, n-1)); } 4.2 Generalizing magnitudes to arbitrary .elds Note that a magnitude need \nnot be a real number. For ex\u00adample, the magnitude of an impedance is often represented as a complex number.8 \nWe want to generalize our treatment of class Measurement so that magnitudes may be elements of various \nnumeric classes (e.g., Float, Double, Complex, etc.). We de.ne a new class AlgebraicField that contains \nclasses representing algebraic .elds. We want to be able to perform arithmetic operations on any two \nelements of an AlgebraicField. But we also want to require that elements of an AlgebraicField representing \nmagnitudes can be combined via arithmetic operations with elements of any other AlgebraicField representing \nmagni\u00adtudes (e.g., we want to allow a complex magnitude to be multiplied by a real magnitude). We also \nwant to be able to combine dimensioned quantities with arbitrary magnitudes via multiplication and division. \nWe can satisfy all of these requirements by extending class AlgebraicField with a class MagnitudeField \nand requiring every instance class of MagnitudeField to extend dimension Unity. class* MagnitudeField \nextends AlgebraicField extends* Unity {} 7Alternatively, we could de.ne another special metaclass commutative \nring and de.ne int as an instance class of that kind. But this approach requires adding additional com\u00adplexity \nto our language with little reward. Furthermore, even the notion of a commutative ring does not capture \nall of the algebraic simpli.cation possible with the integers. 8We use the term magnitude as it is employed \nin most contexts concerning dimension checking. However, this use di.ers from its typical use with regard \nto impedance, to refer to the square root of the sum of the squares of the real and imaginary parts of \nwhat we call the magnitude. Because class Unity implements DimensionI<Unity>, all in\u00adstance classes of \nMagnitudeField must implement it as well. Thus, an element of an instance class of MagnitudeField can \nbe added to or subtracted from any other element of an in\u00adstance class of MagnitudeField. It may also \nbe multiplied by and divided by any other quantity. When an element e of an instance class of MagnitudeField \nis multiplied by another ele\u00adment e . of an instance class of MagnitudeField, the dimension of the result \nis Unity * Unity = Unity. When e is divided by e ., the dimension of the result is Unity*Unity-1 = Unity. \nFor quantities of Dimension D, the dimension of a multiplication -1 -1 is Unity * D = D and of a division \nis Unity * D= D. DimensionI<Unity> also includes method inUnit, but the only unit of dimension Unity \nis PrimaryUnit<Unity>. Therefore, we de.ne this method as follows: if it is called on an instance of \nUnity and the given unit to convert to is PrimaryUnit<Unity>, then the method simply returns its receiver. \nOtherwise, it throws an exception. We rede.ne existing classes Float and Double as instance classes of \nkind MagnitudeField and provide them with ap\u00adpropriate de.nitions of the arithmetic operations required \nto satisfy the extends* constraint on MagnitudeField: MagnitudeField Float extends Unity {...} MagnitudeField \nDouble extends Unity {...} Now we need only modify .eld _magnitude in class Measurement to be of type \nUnity. In this way, we allow the magnitude of a measurement to be any dimensionless quantity. Note that \ndimensionless products of measurements are both measure\u00adments and instances of Unity. A de.nition of \na Measurement class with methods for binary operations and for unit conver\u00adsion is presented in Figure \n1. Class Measurement includes sev\u00aderal polymorphic methods with type parameters that cannot be inferred \nfrom method arguments alone. As in MixGen, polymorphic methods in MetaGen employ explicit polymor\u00adphism. \nWe can also de.ne new instance classes Complex, Rational, Real, Interval, etc. with kind MagnitudeField, \nalong with ap\u00adpropriate subclassing relationships between them. A proper encoding of these classes and \ntheir relation to one another is beyond the scope of this paper.  4.3 Discovered dimensions Sometimes \nthe combination of measurements results in di\u00admensionless quantities (i.e., quantities of dimension unity). \nFor example, we can think of an angle as being determined by measuring two lengths (an arc and a radius) \nand dividing one by the other. Similarly, a relative density is obtained by dividing one density by another. \nAlthough angle and rela\u00adtive density are both of dimension unity, it is nonsense to compare an angle \nto a relative density. Therefore, a programmer may want to view (nonzero) mea\u00adsurements as measurements \nof quantities in newly discovered primary dimensions (e.g., angle, relative density, etc.). It is often \npossible to measure such quantities directly (e.g., with a protractor). We leave the decision of when \nto treat a dimensionless quan\u00adtity in this way to the programmer. Our formulation allows a programmer \nto easily convert dimensionless quantities to dimensioned quantities when necessary. Because dimension\u00adless \nquantities are identi.ed with elements of class Unity, which are also used to represent magnitudes of \nMeasurements, a programmer wishing to treat such a quantity as having a dimension other than unity can \nsimply wrap it in a new Measurement. For example, to treat a dimensionless quotient of two Lengths l1 \nand l2 as an angle, we can write: new Measurement<Angle,Radian>(l1.divide(l2)) 4.4 Scales of measurement \nAlong with multiplicative conversions between units of the same dimension, we often want to de.ne scales \nwith explicit zeros that are based on a unit of measurement (e.g., the Cel\u00adsius, Kelvin, and Fahrenheit \nscales). Scale conversions may involve more than just multiplication by conversion factors; they can \ninvolve addition and subtraction as well (e.g., the conversion of a Celsius scale reading to a Fahrenheit \nscale reading involves multiplication by 9/5 and addition of 32 F. , . where we follow the convention \nthat n C means a Celsius scale reading of n but nC. means a distance of n degrees be\u00adtween two readings \non the scale). How are we to understand scales and scale conversions in the context of our analysis? \nIn particular, can we explain scale conversion solely in terms of manipulation of quantities? The key \nto understanding the relation between quantities and scale readings is to realize that a measurement \nof a quantity is really a measurement of the di.erence between two points in a continuum: an origin (or \nzero point) and an external point. For example, a measurement of time is really a measurement between \nan origin (e.g., the point at which a stopwatch is started) and an external point (the point at which \nthe watch is stopped). Scale readings are measurements for which the origin is .xed by the scale it\u00adself. \nThus, even when two scales are applied to the same external point, the quantities represented by the \nreadings may not be the same the scales may have di.erent origins. When we convert a reading R of external \npoint M in scale S with zero point ZS to a reading R. in another scale S. with zero point ZS. we are \nreally deducing the size of a measure\u00adment from ZS. to M given both a measurement from ZS to M and a \nmeasurement from ZS. to ZS . This deduction in\u00advolves a simple addition. Because scales may also represent \nquantities in di.erent units, unit conversions of the initial measurements may be necessary as well. \nFor example, a reading of a temperature in degrees Celsius is really a measurement of di.erence of an \nexternal tem\u00adperature point with a reference point (0.C) in unit C. . If we write the external point \nas A and 0.C as Z then we can express this di.erence with the following equation: A - Z = x C. Now suppose \nwe want to convert the measurement x C. to a measurement on the Fahrenheit scale. We represent 0.F as \nZF . Then we have: Z - ZF = 32F. We also know the conversion factor of C. to F.: 9 .. C= F 5 class Measurement<Dimension \nD, Unit<D> U> extends D { private final Unity _magnitude; Measurement(Unity magnitude) { _magnitude = \nmagnitude; } Unity getMagnitude() { return _magnitude; } Unity getPrimaryConversion() { return _magnitude.multiply(U.getPrimaryConversion()); \n} <Unit<D> V> Measurement<D,V> inUnit() { if (U == V) return this; else return new Measurement<D,V>(getMagnitude().multiply(V.conversionFactor<U>())); \n} // Arithmetic operations are overloaded for cases where more specific arguments can be statically \ndetermined. // add D add(D x) { return new Measurement<D,U>(getMagnitude().add(x.inUnit<U>().getMagnitude())); \n} Measurement<D,U> add(Measurement<D,U> x) { return new Measurement<D,U>(getMagnitude().add(x.getMagnitude())); \n} // subtract D subtract(D x) { return new Measurement<D,U>(getMagnitude().subtract(x.inUnit<U>().getMagnitude())); \n} Measurement<D,U> subtract(Measurement<D,U>) { return new Measurement<D,U>(getMagnitude().subtract(x.getMagnitude())); \n} // multiply <Dimension E> D*E multiply(E x) { return new Measurement<D*E,U*PrimaryUnit<E>>(getMagnitude().multiply(x.inUnit<PrimaryUnit<E>>().getMagnitude())); \n} <Dimension E, Unit<E> V> Measurement<D*E,U*V> multiply(Measurement<E,V> x) { return new Measurement<D*E,U*V>(getMagnitude().multiply(x.getMagnitude())); \n} <Dimension E, Unit<E> V> Measurement<D*E,U*V> multiply(V v) { return new Measurement<D*E,U*V>(getMagnitude()); \n} Zero multiply(Zero x) { return Zero; } // divide <Dimension E> D*E^-1 divide(E x) { return new Measurement<D*E^-1,U*PrimaryUnit<E^-1>>(getMagnitude().divide(x.inUnit<PrimaryUnit<E>>().getMagnitude())); \n} <Dimension E, Unit<E> V> Measurement<D*E^-1,U*V^-1> divide(Measurement<E,V> x) { return new Measurement<D*E^-1,U*V^-1>(getMagnitude().divide(x.getMagnitude())); \n} <Dimension E, Unit<E> V> Measurement<D*E^-1,U*V^-1> divide(V v) { return new Measurement<D*E^-1,U*V^-1>(getMagnitude()); \n} Unity divide(D x) { return getMagnitude().divide(x.inUnit<U>().getMagnitude()); } Unity divide(Measurement<D,U> \nx) { return getMagnitude().divide(x.getMagnitude()); } } Figure 1: Class Measurement To derive an equation \nof the form A - ZF = yF., we add the two di.erence equations and perform unit conversion: A - ZF = x \nC. + 32F. 9 .. = x F+32F 5 = (9 x + 32) F. 5 yielding the standard formula. By viewing scale readings \nas measurements from .xed reference points, we can convert between scales while manipulating only quantities. \nWe can model scales and points similarly to how we model measurements and units. Just as every dimension \nhas a pri\u00admary unit (which prevents cyclic dependencies), so too it has a primary origin. Every point \nin a given dimension is de.ned with respect to the primary origin of that dimen\u00adsion. Just as measurements \nare de.ned with respect to a particular unit, scales are de.ned with respect to a unit and origin. Therefore, \nwe de.ne a class Point as follows: class Point<Dimension D> { private final D _distanceToOrigin; Point(D \ndistanceToOrigin) { _distanceToOrigin = distanceToOrigin; } D getDistanceToOrigin() { return _distanceToOrigin; \n} D distanceTo(Point<D> p) { return _distanceToOrigin -p.distanceToOrigin(); } } Unlike Units, we do \nnot require all points to be instance classes, so we do not de.ne Point as having kind class*. We also \ndo not de.ne Point as an abelian class. As with PrimaryUnits, we de.ne an instance class PrimaryOrigin \nthat is parametric in a dimension: final* Point<D> PrimaryOrigin<Dimension D> { static { container(0); \n} } We can now de.ne classes Scale and ScaleReading that are parametric in a dimension, a unit, and a \npoint: class Scale<Dimension D, Unit<D> U, Point<D> P> { ScaleReading<D,U,P> newReading(Point<D> Q) { \nreturn new ScaleReading<D,U,P>(Q.distanceTo(P)); } } class ScaleReading<Dimension D, Unit<D> U, Point<D> \nP> { private final Measurement<D,U> _value; ScaleReading(Measurement<D,U> value) { _value = value; } \nMeasurement<D,U> getValue() { return _value; } <Unit<D> V, Point<D> Q> ScaleReading<D,V,Q> inScale() \n{ return new ScaleReading<D,V,Q> ( _value.subtract(P.distanceTo(Q)).inUnit<U>() ); } } A ScaleReading \ncan be converted to any other ScaleReading of the same dimension via method inScale. Class Scale is merely \na factory for new ScaleReadings. We may want to alias particular instantiations of Scale with their common \nnames, e.g., alias KelvinScale = Scale<Temperature,CelsiusDegrees,PrimaryOrigin<Temperature>>; final* \nPoint<Temperature> ZeroCelsius { static { container ( new Measurement<Temperature, CelsiusDegrees>(273) \n); } } alias CelsiusScale = Scale<Temperature,CelsiusDegrees, ZeroCelsius>;  4.5 Nonlinear scales More \ngenerally, zeroed scales are also de.ned in which readings are nonlinear, e.g., the bel scale, which \nis a mea\u00adsure of the logarithm of the ratio of two measurements of Power, and the Gregorian calendar, \nwhere the length of a year depends on which year we re talking about. A par\u00adticularly unusual nonlinear \nscale from science .ction is the warp scale from Star Trek: The Next Generation, 9 which is asymptotic \nat Warp 10. Although such scales appear super.cially to be distinct from linear scales such as Celsius \nand Fahrenheit, they re\u00adally are the same kind of entity. Any scale can be thought of as linear along \na particular dimension. In fact, temperature itself is equal to the reciprocal of the rate of increase \nof en\u00adtropy with respect to energy of a given system. In the case of decibels, absolute zero corresponds \nto 0dB, and it is qual\u00aditatively di.erent from other decibel readings. Di.erences can be taken between \ntwo readings in the dB scale; the result is expressed in a special unit (let us call it decibel units \n) that is not typically written down.10 Another example is the musical scale, which can be thought of \nas based on the unit halftone . High C and middle C di.er by 12 halftones. If we start from middle C, \nand then add 4 halftones, we get E, and if we add 8 more, we get high C. We can arbitrar\u00adily pick middle \nC as the 0 point, and count halftones from there. However, we can also associate a reading on the mu\u00adsical \nscale with the frequency of the note. A musical scale based on halftone is logarithmic in the frequency. \nBut we might as easily say that the frequency scale is exponential in the halftone scale. Because scale \nreadings are often logarithmic with respect to other scales of more fundamental quantities (based on \nunits that the designers of the original scale may not have been aware of), it is natural that we .nd \nreadings on many scales to be restricted to proper subintervals of a .eld (e.g., the positive reals, \nthe reals between 0 and 10, etc.). 9The warp scale from the original Star Trek series was based on a \nless interesting formula. 10Because a decibel reading is measured as the logarithm of the ratio of two \nquantities of Power, a decibel unit is like an angle in that it can be viewed either as dimensionless \nor as a unit in a discovered dimension.  5. PRAGMATICS We now consider some pragmatic aspects of our \nsystem with respect to syntax and performance. 5.1 Syntax Many of the syntactic constructs in our .nished \ndesign are long-winded. However, this is an artifact of C++-style syn\u00adtax that is easily addressed with \nsyntactic sugar. For one thing, many of the instantiations of generic types involved instantiations of \nmultiple type parameters for Measurement, Dimension, and Unit when instantiation of the Unit is all that \nis needed to infer the others. Also, we have selected long names for our classes to help communicate \nideas; in a production system, we may want to use shorter names in some cases. Finally, support for operator \noverloading in our language would allow us to specify arithmetic operations on Measurements more concisely. \nIf we had autoboxing of numeric types and we could also overload arithmetic opera\u00adtions on numeric types \nto take a unit and return a measure\u00adment in that unit, many expressions could be written more succinctly. \nFor example, we could replace expressions such as: new Measurement<Double,Length,Meter>(5) with 5 * Meter. \n 5.2 Ef.ciency of our representation Our formulation of dimensioned quantities is powerful, and it allows \nfor implementation with reasonable performance: Our representation of measurements involves only a single \n.eld for each measurement. Elements of this .eld are el\u00adements of classes associated with primitive values \nsuch as Float and Double. Because the magnitude .eld is private and final, rudimentary escape analysis \nshould allow us to inline these .eld values in many cases. Thus, run-time repre\u00adsentation of quantities \nshould require overhead about equal to that of boxing primitive values. Additionally, various reductions \nin expressive power allow for even better per\u00adformance, giving library designers the freedom to choose \nthe power/performance tradeo. for their target applications. When run-time representation of quantities \nis not required, the Measurements themselves could be represented as primi\u00adtive values. Even when run-time \nrepresentation of quantities is important, it should be possible to simply pass this infor\u00admation as \ntype parameters to methods that require it and represent the measurement values themselves as primitives. \nAll the arithmetic methods are simple nonrecursive one\u00adline methods that are easily inlined by modern \njust-in-time compilers. Through static overloading, calls to the arith\u00admetic operations are more e.cient \nwhen additional infor\u00admation can be statically inferred. For example, when the static types of the operands \nare Measurements with the same Unit, no unit conversion is necessary. Additionally, .eld _magnitude is \nfinal; a savvy just-in-time compiler could cal\u00adculate values for methods such as getPrimaryConversion \non the .rst call for a value and cache the result for subsequent calls. If performance were still unsatisfactory, \nwe could re\u00adquire all measurements to be kept in the primary unit of their dimension. Although we may \nlose precision for some programs, we would be able to reduce each of the four arith\u00admetic methods to \na single arithmetic operation.  6. RELATED WORK 6.1 Dimension and unit checking Most formulations of \ndimension checking in programming languages encode dimensions as an ad hoc language feature rather than \nintegrating them into a more general type sys\u00adtem. Also, most formulations incorporate dimension check\u00ading \ninto functional and procedural languages rather than object-oriented languages, where the design issues \nare sig\u00adni.cantly di.erent. Few formulations support parametric polymorphism over dimensions. No previous \nformulation presents dimension checking as a generalization of static checking for metaclasses. Andrew \nKennedy presents an extension of a core calculus for ML with support for dimension checking [20, 21]. \nBe\u00adcause ML is a structurally typed functional language rather than a nominally typed object-oriented \nlanguage, many of the key issues that have driven our design do not apply to this language. Units are \nnot given separate types and each dimension is associated with a single unit. Other units are encoded \nby the programmer as constant values de.ned in terms of this single unit. Because dimensions are added \nas an ad hoc language extension, the issues involved in en\u00adcoding them via metaclasses do not arise, \nnor do those in\u00advolved in general support for kinds whose elements satisfy the properties of an abelian \ngroup. Nevertheless, Kennedy s approach shares similarities with ours. Dimension exponents are constrained \nto be integers. The zero quantity is treated as having polymorphic dimension. Also, function types may \nbe polymorphic with respect to dimensions. The problem of typing functions that are polymorphic with \nrespect to a dimension exponent (such as power) is discussed but no solution is presented. A signi.cant \nportion of Kennedy s proposal involves the for\u00admulation of type inference over dimension types. In this \nre\u00adspect, it builds on the work of Wand and O Keefe [28] and Goubault [16], which present formulations \nof dimension in\u00adference for ML-like languages. Incorporating an inference mechanism over metaclasses \nand abelian classes based on these inference systems is an important direction for future work. Kennedy \nextends his own work by relating it to the para\u00admetricity result of System F [22]. By proving a dimen\u00adsional \ninvariance principle over a core calculus based on ML, Kennedy is able to establish several surprising \nprop\u00aderties of this calculus. For example, it is possible to show that functions of the type .u. num \nu 2 . u cannot return a nonzero result for any argument value, and therefore that an approximating square \nroot function with this type cannot be expressed in the language! It is not at all obvious how to relate \nthis work, which is based on F-bounded parametric polymorphism over structural types, to an object-oriented \nlanguage with typed metaclasses and nominal types. But it would be interesting to determine such a relationship. \nOther formulations of dimension checking do not support parametric polymorphism over dimensions. Formulations \nof dimensions for object-oriented languages have typically en\u00adcoded a .xed set of dimensions. A popular \nformulation of dimension checking in C++ (via the Standard Template Li\u00adbrary) is SIUnits [5], which provides \nfor the checking of quan\u00adtities in the SI system by encoding the seven dimensions ad\u00addressed by that \nsystem as integer parameters of a template class Quantity. Parametric dimensions, class relationships \nbetween units dimensions and quantities, and programmer extensions of this hardwired template are not \nsupported. In addition, the underlying type system is unsafe and does not directly represent the abstraction \nof generic types, greatly reducing the value of static checking. Fowler discusses a modeling of units \nof measurement used in the Cosmos project for the U.K. National Health Ser\u00advice [10]. In addition to \nunits and quantities, Fowler in\u00adcludes a notion of measurement that includes the notion of an observation \nand an observed patient . Dimensions of quantities and the relationships of algebraically formed units \nand dimensions are not modeled. Static checking and dimensional parametricity are not discussed. The \nformulation closest to our own is by van Delft [27], who describes a mechanism for implementing dimensions \nin Java class .les as annotated classes. As with our approach, van Delft treats the zero quantity as \nhaving polymorphic dimen\u00adsion. However, van Delft does not provide a speci.cation for the semantics of \ndimension types, does not encode dimen\u00adsions as part of a class hierarchy, does not allow for the de.nition \nof new methods speci.c to a particular dimen\u00adsion, and does not include parametric polymorphism over \ndimension types or separate types for units. As a result, the issues in object-oriented modeling that \nwe have addressed in our proposal do not arise. Van Delft does includes a con\u00adstruct dimension(exp), \nwhich evaluates to the dimension of exp. Although this feature is useful for linking dimensions of method \nparameters (the term dimension can be used to take an argument of arbitrary dimension), and provides \nsome of the bene.ts of parametric dimensions, this limited form of parametricity, combined with the restriction \nthat di\u00admension exponents be natural numbers, prevents de.nition of a polymorphic sqrt function: double \ndimension(v)^1/2 sqrt(double*dimension v) van Delft proposes the following alternative: double*dimension \nsqrt(double*dimension(return*return) v) Where return is the type of the return value. This nota\u00adtion \nprovides an ad hoc mechanism to allow for equating the return type of a method with its parameter types. \nBut this mechanism is really just a workaround for the lack of general support for parametricity, and \nit prevents expres\u00adsion of parametric dependencies between multiple method parameters, e.g., <Dimension \nD> boolean lessThan(D x, D y) Other published formulations of dimension checking have been over procedural \nlanguages. Gehani contrasts the use of derived types in Ada with the use of a facility for unit checking, \nshowing how derived types are an inadequate sub\u00adstitute for a special language feature for units [15]. \nHe also presents an extension of Pascal with support for units [13], in which he allows for polymorphic \nuse of units via a UNITS(*) declaration, and a UNITSOF operator. However, his discus\u00adsion often con.ates \nthe notion of units and dimensions: he does not include a notion of dimension in his language ex\u00adtension; \ninstead, units of a common dimension are declared to be related via a counits operator. As a result, \nunit con\u00adversion can occur along multiple paths, adding signi.cant complexity to an implementation. \nGehani s approach is criticized by House [18], who notes that units are not actually declared in Gehani \ns proposal. In\u00adstead, new units are simply used when needed by a variable declaration. As a result, it \nis possible to form pathological de.nitions where the name of a quantity is identical to the name of \na (distinct) unit. House also notes that Gehani s system is not statically checkable without severely \nrestrict\u00ading the use of the UNITS(*) operator. House goes on to cite a litany of other criticisms of \nGehani s proposal and then proposes his own extension of Pascal supporting dimension checking. In House \ns proposal, each dimension is associated with a unique primary unit. Exponents on dimensions are arbi\u00adtrary \nrational numbers to allow the de.nition of methods such as sqrt; the syntax for polymorphic dimensions \npro\u00adhibits the solution we have presented, where the input di\u00admension is de.ned to be the square of a \ndimension vari\u00adable. House also restricts exponents on dimensions to be constants.11 Generic type declarations \nare supported for records and procedures. However, procedure return types are precluded from being generic \ndimensions independent of the parameter dimensions. House proposes to solve the problem of scale conversion \nby allowing for units with dif\u00adferent zeros ; unit conversion involves both an additive and a multiplicative \nconversion. This approach fails to recog\u00adnize that scale readings have distinct properties from other \nquantities and should be modeled as separate entities. Gehani also discusses the application of units \nof measure\u00adment to databases [14]. In this context, conversion factors can change dynamically (e.g., \nbetween monetary units), sug\u00adgesting that the best way to store data is not with a stan\u00addard unit per \ndimension, but instead in the units in which the data was originally entered. In the context of database \nmanipulation, Gehani recom\u00admends the following operators: counits: speci.es that two or more units are \nof the same dimension  remove counits: removes unit relationships  ccc: changes the conversion constant \nbetween two units (useful when dealing with rates of exchange, improving precision of scienti.c constants, \netc.)  in: evaluates an expression in a given unit  unitsof: returns the units of a given value  \nIn our formulation, where dimensions of quantities are de\u00adnoted explicitly, the counits operator is unnecessary, \nand 11In fact, because Pascal syntax does not include an expo\u00adnentiation operator, compound dimensions \nare expressed via multiplication and division, which is expressively equivalent to requiring dimension \nexponents to be constant. the remove counits operator is nonsensical (remove counits is apparently motivated \nby the need to maintain possibly corrupted, persistent data in a database). In a program\u00adming language, \nunits either belong to a dimension or they do not. Programmers may introduce and correct erroneous declarations \nof unit classes in their programs, but dynam\u00adically altering the dimension of a quantity is not needed. \nThe ability to support dynamically changing conversion con\u00adstants between two units could be supported \nby making the conversion factor in class Unit mutable and allowing select classes to support a ccc method. \nThe in and unitsof oper\u00adator are easily supported as methods in class Measurement. The fact that we are \nable to easily incorporate Gehani s operators into our formulation is a demonstration of the ex\u00adtensibility \nwe have attained by unifying our formulation into a general object-oriented type system. Manner describes \na syntactic extension to Pascal and Ada in which unit declarations are supported [23]. Each dimension \nis associated with a unique primary unit and all quantities of that dimension are kept in the primary \nunit. Polymor\u00adphism over quantities is not supported. Dreiheller et al. ex\u00adpand upon Manner s syntax \nto provide a language extension and implementation (via a preprocessor) for Pascal called PHYSCAL [8]. \nPHYSCAL supports scale factors on units as well as input/output facilities for quantities. PHYSCAL is \nlimited to supporting SI units; the programmer cannot de\u00ad.ne new units or dimensions. Scales of measurement \nare not handled by PHYSCAL, nor is polymorphism over program constructs involving dimensions. Baldwin \nproposes another extension of Pascal supporting units inspired by Manner [3]: a .xed set of dimensions \nis added to Pascal as siblings of type REAL. Each dimension is associated with a unique primary unit, \nand quantities of that dimension are always kept in the primary unit. Multi\u00adplication and division of \ndimensioned quantities by dimen\u00adsionless quantities is not supported despite recognition that such support \nis needed for correctness. Hil.nger proposed an encoding of support for dimension checking in Ada in \n[17]. Hil.nger s approach shares some of the .avor of ours in that he attempts to use existing lan\u00adguage \nabstraction mechanisms to encode dimensions rather than introducing an ad hoc language feature. He relies \non the subtyping mechanism of Ada to encode dimensions as subtypes of records of constant integers. Each \n.eld in this record supertype corresponds to a primary dimension. Be\u00adcause the .elds in this record are \n.xed, the programmer cannot de.ne new dimensions. Also, quantities of a di\u00admension must be represented \nin a primary unit. Limited polymorphism is allowed because a programmer can refer to the record supertype \nof all dimensions when de.ning meth\u00adods. However, general parametric polymorphism including dependencies \nbetween the dimensions of multiple variables is not supported. Karr and Loveman discuss mechanically \nincorporating units into a procedural programming language [19]. Like us, they are concerned not with \nsimply adding unit checking to an ex\u00adisting language, but rather with understanding more general issues \nin adding unit checking to a class of languages. Karr and Loveman do not include a separate notion of \ndimension. As a result, detecting commensurability of units becomes a central aspect of their approach. \nHowever, there is an upshot to their focus on commensurability: their mechanism for manipulating unit \nrelationships is more general than ours: Rather than de.ning the magnitudes of all units for a given \ndimension in terms of a primary unit, each unit may be re\u00adlated to any other unit. Commensurability is \ndetermined by a interesting computational trick where equations relat\u00ading units are represented in logarithmic \nform, presented as matrices, and put into row echelon form. Cycles and in\u00adconsistencies in the unit relationships \ncan be determined by straightforward inspection of the reduced matrix. Because we allow for dimension \ntypes in our approach, com\u00admensurability detection is not necessary for static checking. However, intelligent \nunit conversion at run time would al\u00adlow for improved precision. For example, when converting feet to \ninches, it may be advantageous to relate them di\u00adrectly rather than to relate them each to meters and \nthen divide. An interesting direction for future work is to try to embed the row-echelon technique of \nKarr and Loveman into the de.nition of method inUnit on measurements. Ide\u00adally, the equations composing \nthis matrix would be checked statically. Parametric units are not discussed in Karr and Loveman s proposal. \nRaising quantities to a (possibly nonconstant) power is allowed, so long as the unit of the exponent \nis com\u00admensurate with 1. If the exponent is nonconstant, the units of the expression are assumed to be \n1, breaking soundness of static checking.12 Scale measurements and input/output of quantities are not \naddressed by their proposal. The earliest mention of dimension checking for programming languages that \nwe are aware of occurs in J.C. Cleaveland s discussion of pouches [7]. Pouches are described as a gen\u00aderal \nway to allow programmers to organize numeric variables into natural classes or categories. It is shown \nhow a set of pouches can be organized as the base elements of a freely generated abelian group, and therefore \nas unit annotations. No polymorphism is provided over pouches, but it is men\u00adtioned in passing that a \nnotion of hidden pouches would be useful when de.ning arithmetic functions that are naturally polymorphic. \nExponents on generated elements of pouches are restricted to be constants. No subtyping is provided over \npouches. Pouches are used to describe units rather than di\u00admensions, but no facility is provided for \nconverting between commensurable units. 6.2 Generalized class relationships in other languages The use \nof class relationships beyond simple class exten\u00adsion is essential for modeling many real-world ontologies \n[9]. Many non-statically-typed object-oriented languages, such 12Because parametric polymorphism is not \nsupported, this design decision is reasonable as long as all occurrences of these exponent expressions \nare either accompanied by a static warning or required to be annotated by the program\u00admer. Provided that \nenough information is kept to deter\u00admine the actual units of these expressions at run time and to check \ntheir use, exponents with nonconstant exponents in this proposal are akin to downcasts in the Java Program\u00adming \nLanguage. as Smalltalk, Python, and Self, allow for more .exible re\u00adlationships. In the case of Smalltalk \nand Python, classes are instances of metaclasses. Static members of a class are modeled as ordinary members \nof the corresponding meta\u00adclass. Self, on the other hand, is a prototype-based object\u00adoriented language, \nwhere there are no classes at all: object instantiation consists of cloning an existing instance. The \nmembers of the clone can be modi.ed and added to at will. Our notion of metaclass di.ers from that in \nSmalltalk, where each class has a unique metaclass that de.nes its class mem\u00adbers. Metaclasses in this \nlanguage are typically used to de.ne customized properties of select classes. In contrast, we use metaclasses \nto augment traditional static checking of properties that are typically encoded indirectly. Not all classes \nhave a distinct metaclass. When viewed as instance generators , our metaclasses are similar to prototypes \nin untyped languages such as Self. Pro\u00adtotypes generate new instances, which themselves can gen\u00aderate \nnew instances. Our language is more restrictive than prototype-based languages in the sense that all \nmetaclasses and instance classes must be declared statically (i.e., by writ\u00ading down class de.nitions). \nBut MetaGen is more expressive in the sense that we include classes and subclassing rela\u00adtionships. Also, \nunlike typical prototype-based languages, MetaGen is statically typed. Because our formulation of metaclasses \nincludes nominal generic types, we can handle certain (conceptually paramet\u00adric) metaclasses more gracefully \nthan they are handled in dynamically typed languages like Smalltalk. For example, in Smalltalk (pre Smalltalk \n80),13 the upper ontology of classes and metaclasses is as follows (using MetaGen syntax) [29]: ObjectClass \nObject{...} ClassDescriptionClass ClassDescription extends Object {...} MetaclassClass Metaclass extends \nClassDescription {...} ClassClass class extends ClassDescription {...} Metaclass ObjectClass extends \nclass {...} Metaclass classDescriptionClass extends ObjectClass {...} Metaclass MetaclassClass extends \nClassDescriptionClass {...} Metaclass ClassClass extends ClassDescriptionClass {...} User-de.ned classes \nare instances of new metaclasses. For example, class Dimension would be represented as: Metaclass DimensionClass \nextends ObjectClass {...} DimensionClass Dimension extends Object {...} The metaclasses hold the static \nmembers of their instances. Notice that in Smalltalk we are prevented from modeling the structure we \nreally want over these classes because we do not have generic types. An object-oriented generic type \nsystem with nominal subtyping such as in NextGen and MixGen [6, 2, 1] have the important property that \neach instantiation of a generic type has a distinct run-time representation (this is not the case for \na structural type system).14 We can lever\u00ad 13Smalltalk 80 includes a more complex hierarchy with soft\u00ad \nware engineering bene.ts orthogonal to the issues under dis\u00ad cussion. 14In Java 2 SDK v.1.5, generic \ntypes are erased to their upper bounds after type checking. Consequently, type-dependent operations such \nas casts and instanceof tests cannot be performed safely on generic types in that language. age this \nfact to encode a metaclass hierarchy much more concisely than can be done in Smalltalk. Instead of writing \nclasses such as ClassClass, ObjectClass, etc., we can de.ne a metaclass Class that is parameterized by \nits contained class: Class<Class<C>> Class<Class<C> C> {...} Note that the bound on type parameter C \nis itself Class<C>. This bound allows us to de.ne instance classes such as Class<Object> Object {...} \nClass<Dimension> Dimension {...} So instead of having ObjectClass and DimensionClass, we have Class<Object> \nand Class<Dimension>. If we want to in\u00adclude extra class members in the metaclass of Dimension (for instance, \nif we want to model static members of Dimension as members of the metaclass), we can subclass Class<Dimension> \nand de.ne Dimension to be a member of the subclass. The important point is that we do not need an explicit \nMetaclass class because we can represent metaclasses as instantiations of a single generic type. Likewise, \nthere is no need for a ClassDescription class, signi.cantly simplifying the class hi\u00aderarchy. Dynamically \ntyped languages such as Smalltalk, Self, and Python are inappropriate for modeling dimension checking. \nThe re.ection facility in the Java Programming Language can also be thought of as providing some of the \npower of metaclasses. For example, each class is regarded by the re\u00ad.ection facility as an instance of \nclass Class. However, use of the re.ection facility is not statically checked in the Java Programming \nLanguage, e.ectively placing it in the same category as dynamically typed languages in this respect. \nNominal subtyping is an essential property of our extended language. Many of the instance classes we \nde.ne may them\u00adselves contain no internal structure, but establishing subtype relationships that are \nindependent of structure is central to our approach. A static type inference system is provided for Smalltalk-like \nmetaclasses in Strongtalk in [4]. However, this type system is based on structural subtyping with no \nrun\u00adtime representation of types. Therefore, it is inadequate for encoding our formulation of dimensions \nand units, which relies fundamentally on .rst-class genericity and run-time representation of types. \n 7. FUTURE DIRECTIONS In this paper, we introduce a generic static-checking system over dimensions and \nunits. There are several interesting directions to extend this work. For example, our system employs \nexplicit polymorphism, which is strictly more ex\u00adpressive in a nominal generic type system with support \nfor type-dependent operations (consider, for example, a poly\u00admorphic method that takes no arguments and \nreturns an instance of a type parameter). Nevertheless, it would be natural to extend this system with \nlimited forms of implicit polymorphism where type instantiations can be inferred. Another important extension \nto our system would be to pro\u00advide support for programmers to de.ne new classes with equational constraints \nsuch as those we have built into abelian classes. A natural approach to this problem would be to transfer \nand extend results from constrained type systems such as the HM(X) extension to Hindley-Milner type infer\u00adence, \npresented in [26] and implemented in the Chameleon extension of Haskell [25], from a structural type \nsystem to a nominally typed object-oriented type system. We would also like to examine to what degree \nwe can unbox dimensioned quantities in real programs to achieve perfor\u00admance acceptable for high-performance \ncomputation. Finally, formalizing the MetaGen semantics over a core cal\u00adculus (e.g., an extension of \nCore MixGen) is an important next step in helping us to better analyze its properties and interactions \nwith other language extensions. Acknowledgements We are gratetful to Matthias Felleisen, Sam Tobin-Hochstadt, \nCheryl McCosh, Miriam Kadansky, and the anonymous ref\u00aderees for their comments on earlier drafts of this \nwork.  8. REFERENCES [1] E. Allen, J. Bannet, and R. Cartwright. A First-Class Approach to Genericity. \nIn Proceedings of the Eighteenth Annual SIGPLAN Conference on Object-Oriented Systems, Languages, and \nApplications, Anaheim CA 2003. [2] E. Allen, R. Cartwright, and B. Stoler. E.cient implementation of \nrun-time generic types for Java. In IFIP WG2.1 Working Conference on Generic Programming, 2002. [3] G. \nBaldwin. Implementation of Physical Units. SIGPLAN Notices, V. 22(8). August 1987. [4] G. Bracha, D. \nGriswold. Strongtalk: Typechecking Smalltalk in a production environment. In Proceedings of the Eighth \nAnnual SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications, pages \n215-230, 1993. [5] W. Brown. Applied Template Metaprogramming in SIUnits: the Library of Unit-Based Computation. \nIn Proceedings of the Second Workshop on C++ Template Programming, October 2001. Available at http://www.oonumerics.org/tmpw01/brown.pdf. \n[6] R. Cartwright and G. Steele. Compatible genericity with run-time types for the Java programming language. \nIn Proceedings of the Thirteenth Annual SIGPLAN Conference on Object-Oriented Systems, Languages, and \nApplications, Vancouver BC 1998. [7] J.C. Cleaveland. Redundant Speci.cation in Programming Languages \nThrough Pouches. UCLA Technical Report. 1975. [8] A. Dreiheller, M. Moerschbacher, B. Mohr. PHYSCAL: \nProgramming Pascal with Physical Units. SIGPLAN Notices, V. 21(12), December 1986. [9] D. Ferrucci, C. \nWelty. What s in an Instance? RPI Computer Science Technical Report. 1994. [10] M. Fowler. Analysis \nPatterns: Reusable Object Models. Addison-Wesley 1997. [11] D. Isbell, D. Savage. Mars Climate Orbiter \nFailure Board Releases Report, Numerous NASA Actions Underway in Response. NASA Press Release 99-134. \nhttp://nssdc.gsfc.nasa.gov/planetary/text/ mco pr 19991110.txt. Nov. 10, 1999. [12] E. Gamma, R. Helm, \nR. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, \n1995. [13] N. Gehani. Units of Measure as a Data Attribute. Computer Languages, Vol. 2. pp. 93-111. Pergamon \nPress, 1977. Printed in Great Britain. [14] N. Gehani. Databases and Units of Measure. IEEE Transactions \non Software Engineering. Vol. SE-8, No. 6, November 1982. [15] N. Gehani. Ada s Derived Types and Units \nof Measure. Software Practice and Experience, Vol. 15(6), 555-569. June 1985. [16] J. Goubault. Inference \nd unites physiques en ML. In P. Cointe, C. Queinnec, and B. Serpette, editors, Journees Francophones \ndes Langages Applicatifs, Noirmoutier, p.3-20. INRIA, Collection didactique, 1994. [17] P. Hil.nger. \nAn Ada Package for Dimensional Analysis. ACM Transactions on Programming Languages and Systems, Vol. \n10, No. 2, April 1988. p. 189-203. [18] R. T. House. A Proposal for an Extended Form of Type Checking \nof Expressions. The Computer Journal, Vol. 26, No. 4. 1983. [19] M. Karr, D. B. Loveman III. Incorporation \nof units into programming languages. Communications of the ACM, 21(5):385-391, May 1978. [20] A. Kennedy. \nDimension Types. In Proceedings of the 5th European Symposium on Programming Languages and Systems. Edinburgh, \nU.K. 1994. [21] A. Kennedy. Programming Languages and Dimensions. PhD Thesis. St. Catharine s College. \nNovember 1995. [22] A. Kennedy. Relational Parametricity and Units and Measure. In Proceedings of the \n24th Annual ACM Symposium on Principles of Programming Languages, Paris, France. January 1997. [23] R. \nManner. Strong Typing and Physical Units. SIGPLAN Notices V. 21(3), March 1986. [24] P. Neumann. Risks \nto the public from the use of computers. ACM Software Engineering Notes, 10(3) July 1985. [25] M. Sulzmann, \nThe Chameleon website. http://www.comp.nus.edu.sg/ sulzmann/chameleon/ [26] M. Sulzmann, M. Odersky, \nM. Wehr, Type Inference with Constrained Types. Theory and Practice of Object Systems, 5(1), 1999. [29] \nA. Goldberg, D. Robson. Smalltalk-80: The Language. Addison-Wesley, 1989. [27] A. van Delft. A Java Extension \nwith Support for Dimensions. Software Practice and Experience, 29(7), 605-616. 1999. [28] M. Wand, P. \nM. O Keefe. Automatic dimensional inference. In J.-L. Lassez and G. Plotkin, editors, Computational Logic: \nEssays in Honor of Alan Robinson. MIT Press, 1991.  \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Programs that manipulate physical quantities typically represent these quantities as raw numbers corresponding to the quantities' measurements in particular units (e.g., a length represented as a number of meters). This approach eliminates the possibility of catching errors resulting from adding or comparing quantities expressed in different units (as in the Mars Climate Orbiter error [11]), and does not support the safe comparison and addition of quantities of the same dimension. We show how to formulate dimensions and units as classes in a nominally typed object-oriented language through the use of statically typed metaclasses. Our formulation allows both parametric and inheritance poly-morphism with respect to both dimension and unit types. It also allows for integration of encapsulated measurement systems, dynamic conversion factors, declarations of scales (including nonlinear scales) with defined zeros, and nonconstant exponents on dimension types. We also show how to encapsulate most of the \"magic machinery\" that handles the algebraic nature of dimensions and units in a single meta-class that allows us to treat select static types as generators of a free abelian group.</p>", "authors": [{"name": "Eric Allen", "author_profile_id": "81100652164", "affiliation": "Sun Microsystems Laboratories, Burlington, MA", "person_id": "PP39052562", "email_address": "", "orcid_id": ""}, {"name": "David Chase", "author_profile_id": "81542812556", "affiliation": "Sun Microsystems Laboratories, Burlington, MA", "person_id": "PP14031639", "email_address": "", "orcid_id": ""}, {"name": "Victor Luchangco", "author_profile_id": "81100464444", "affiliation": "Sun Microsystems Laboratories, Burlington, MA", "person_id": "P290813", "email_address": "", "orcid_id": ""}, {"name": "Jan-Willem Maessen", "author_profile_id": "81100644471", "affiliation": "Sun Microsystems Laboratories, Burlington, MA", "person_id": "P134487", "email_address": "", "orcid_id": ""}, {"name": "Guy L. Steele", "author_profile_id": "81100586340", "affiliation": "Sun Microsystems Laboratories, Burlington, MA", "person_id": "P100946", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029008", "year": "2004", "article_id": "1029008", "conference": "OOPSLA", "title": "Object-oriented units of measurement", "url": "http://dl.acm.org/citation.cfm?id=1029008"}