{"article_publication_date": "10-01-2004", "fulltext": "\n Object-oriented Encapsulation for Dynamically Typed Languages Nathanael Sch\u00a8arli Andrew P. Black St\u00b4ephane \nDucasse Software Composition Group OGI School of Science &#38; Software Composition Group University \nof Bern Engineering University of Bern Bern, Switzerland Oregon Health &#38; Science Bern, Switzerland \nUniversity schaerli@iam.unibe.ch Portland, Oregon, USA ducasse@iam.unibe.ch black@cse.ogi.edu ABSTRACT \nEncapsulation in object-oriented languages has tradition\u00adally been based on static type systems. As a \nconsequence, dynamically-typed languages have only limited support for encapsulation. This is surprising, \nconsidering that encapsu\u00adlation is one of the most fundamental and important con\u00adcepts behind object-oriented \nprogramming and that it is es\u00adsential for writing programs that are maintainable and reli\u00adable, and that \nremain robust as they evolve. In this paper we describe the problems that are caused by insu.cient encapsulation \nmechanisms and then present object-oriented encapsulation, a simple and uniform approach that solves \nthese problems by bringing state of the art en\u00adcapsulation features to dynamically typed languages. We \nprovide a detailed discussion of our design rationales and compare them and their consequences to the \nencapsulation approaches used for statically typed languages. We also de\u00adscribe an implementation of \nobject-oriented encapsulation in Smalltalk. Benchmarks of this implementation show that extensive use \nof object-oriented encapsulation results in a slowdown of less than 15 percent. Categories and Subject \nDescriptors D.3.3 [Programming Languages]: Language Constructs and Features Classes and objects; Inheritance \n General Terms Languages  Keywords Dynamic typing, Encapsulation, Encapsulation Policies, In\u00adformation \nhiding, Smalltalk Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n...$5.00 1. INTRODUCTION Encapsulation is widely acknowledged as being one of the cornerstones of object-oriented \nprogramming [22]. But what does the term mean? In a classic paper, Alan Snyder de.ned encapsulation as \nfollows [28, p. 39]: Encapsulation is a technique for minimizing inter\u00addependencies among separately-written \nmodules by de.ning strict external interfaces. The external in\u00adterface of a module serves as a contract \nbetween the module and its clients, and thus between the designer of the module and other designers. \nWe have added the emphasis to point out that while this de.nition captures the essence of encapsulation \nfor modules, it does not adequately de.ne encapsulation in the context of objects. To see this, suppose \nthat we are trying to encap\u00adsulate an object that maintains an internal data structure, such as a tree. \nWe would like to protect the invariants of the tree, but clients need to traverse it. If we pass our \nusers an unrestricted reference an alias to the tree, clients might modify the tree in a way that breaks \nthe invariant. What we would like to do is to allow the encapsulating object full access to the tree, \nincluding the right to modify it, but to restrict the access that is granted to clients. Solving this \nkind of encapsulation problem requires some sort of protection based not on modules but on individual \nreferences to objects. In contrast to module encapsulation as de.ned by Snyder, the primary purpose of \nthese object en\u00adcapsulation [8] techniques is not to facilitate code evolution, but to increase code \nreliability. It does this by allowing the programmer to implement data structures whose instances are \nguaranteed to be protected from the invocation of inap\u00adpropriate operations on their subobjects. Today, \nmost statically typed object-oriented languages such as Java, C++, and C# provide relatively good support \nfor module encapsulation, and many proposals have been made for augmenting the static type systems of \nsuch languages so that they can also express object encapsulation [2, 3, 8, 9, 13, 17, 20, 21, 25]. However, \nthings are quite di.erent in dynamically typed languages. Popular dynamically typed languages such as \nSmalltalk, Self, Python, and Ruby still provide no encapsu\u00adlation at all, or support it in a very limited \nway. Proposals such as MUST for an encapsulation model for Smalltalk [30] have never been adopted, either \nin Smalltalk or in any other popular dynamically typed language. The encapsulation model [12] proposed \nby the developers of Self was rejected, and is not available in more recent versions of the Self language \n[1]. There have been proposals dating back at least as far as 1987 for extending Smalltalk with some \n(limited) features for object encapsulation [7], but 17 years later, such features are still not available \nin Smalltalk. In this paper, we propose an object-oriented encapsulation model (OOE) for dynamically \ntyped languages such as Small\u00adtalk and Ruby. It provides a uniform and expressive mech\u00adanism to address \nmost of the module and object encapsu\u00adlation problems of which we are aware. OOE is compatible with dynamic \nlanguages because it is based entirely on mes\u00adsage passing and has a simple semantics that makes it easy \nto understand and reason about. OOE supports module encapsulation using Composable En\u00adcapsulation Policies \n[27]: the degree of encapsulation is not dictated by the implementor of a module, but is selected by \nthe user subject to policies de.ned by the implementor. It also allows encapsulation policies to be associated \nwith individual references to objects, which is su.cient to solve many, although not all, object encapsulation \nproblems. The rest of this paper is structured as follows. We .rst describe the problems that are caused \nby insu.cient encap\u00adsulation, and develop a set of goals that an e.ective encap\u00adsulation mechanism should \nmeet (Section 2). After giving a brief outline of our proposal for Object-oriented Encap\u00adsulation (OOE) \nin Section 3, we describe OOE in detail in Section 4, deferring to Section 5 the discussion of why we \ntook particular design decisions, and the alternatives that we considered and rejected. In Section 6, \nwe give a detailed description of our implementation of OOE in Smalltalk and use benchmarks to evaluate \nits impact on performance. In Section 7 we evaluate OOE against our goals; Section 8 de\u00adscribes related \nwork and Section 9 concludes.  2. PROBLEMS AND GOALS In this section, we set the context for our work, \nand motivate it by describing the problems that are caused by inadequate encapsulation mechanisms. Based \non these problems, we then formulate a set of goals for an object-oriented encap\u00adsulation model for dynamically \ntyped languages. 2.1 Encapsulation in Dynamic Languages Why is it that encapsulation, which is such a \nwell-established feature of statically typed languages, is so poorly supported in dynamically typed languages? \nWe believe that there are three reasons. First, most of the proposed encapsulation models address only \na small subset of the various encapsulation problems, and so no one of them seemed to add enough value \nto justify the additional complexity. For example, the model proposed for Self [12] addresses the issue \nof how to prevent a method from being called from within another module1, but does not address other \nmodule encapsulation problems such as pre\u00adventing a method from being overridden, nor does it provide \nany help in the control of object aliasing. This model was in fact included in an experimental release \nof Self, but was soon removed because it was found to be too complex. An alternative proposal, from Noble, \nClarke and Potter [24], suggests extending languages like Self with dynamic object encapsulation using \ntechniques based on object ownership, but it does not address the fact that the base languages do not \nprovide simple module encapsulation. Secondly, many of the proposed encapsulation models are not well-suited \nto the lightweight, dynamic, and entirely message-based spirit of these languages. For example, the Smalltalk \nextension MUST [30] signi.cantly a.ects the light\u00adweight and dynamic character of the language by requiring \nthe programmer to make quite static encapsulation decisions both when declaring methods and when sending \nmessages. Other approaches, such as that of Noble, Clarke and Potter [24], are so restrictive that they \nwould prohibit several com\u00admon programming patterns such as external iterators [20] and are hard to implement \ne.ciently (see Section 8). Thirdly, language designers may have perceived that the kind of experimental \nprogramming for which dynamic lan\u00adguages were originally promoted rapid prototyping and single programmer \nexperimental projects did not need en\u00adcapsulation. This perception may have been compounded by the mismatch \nbetween available encapsulation techniques and the experimental style. Agile programming methodologies \nsuch as extreme program\u00adming [6] make a virtue out of change and expand the reach of techniques previously \nthought suitable only for experimen\u00adtal programming to include customer-driven projects under\u00adtaken by \na sizable team. The success of these methodolo\u00adgies has shown that the third reason was not well founded. \nIn particular, communal code ownership demands that pro\u00adgrammers be given a way of expressing their intent \nas to which methods are to be callable by which objects. Thus, we feel that there is a real need for \nencapsulation in dynamic languages, if only a mechanism can be found that is both ad\u00adequate and appropriate. \nIndeed, the absence of static types makes the modularity improvements and reliability guar\u00adantees that \ncome with powerful encapsulation mechanisms even more valuable in a dynamically-typed language than in \none with a static type system. 2.2 The Problem of Interdependence We agree with Snyder that one of the \nprimary purposes of encapsulation is to minimize interdependencies among separately-written modules [28]. \nAll object-oriented lan\u00adguages that are based on classes depend on the class as the fundamental unit \nof modularity. In this paper we fo\u00adcus on class-based languages: this means that our modules are classes. \nHence, module encapsulation means class en\u00adcapsulation, and we use the two terms interchangeably. 1Since \nthe prototype-based language Self has no explicit modules, the developers instead suggested to use implicit \nmodules consisting of an object together with its shared an\u00adcestors. Two fundamental operations are de.ned \non classes: inheri\u00adtance and instantiation. Consequently, there are three ways in which classes depend \non each other: (1) when they are in an inheritance relationship, (2) when one class instantiates another \nto create an instance, and (3) when that instance is eventually used. Although in many languages instantiation \nis a built-in operation of the language (for example, Java s new), in Smalltalk it is not: instantiation \nis accomplished by sending an ordinary message to the class itself. We will therefore not single-out \ninstantiation in the discussion that follows; instantiation can be controlled in Smalltalk using exactly \nthe same techniques as message send. 2.2.1 Interdependence through Inheritance Most dynamically typed \nlanguages such as Smalltalk and Ruby do not allow a programmer to hide the internal imple\u00admentation features \n(i.e., methods and instance variables) of a superclass from its subclasses. One aspect of this shortcoming \nis that the designer of a class cannot specify access restrictions that prevent some or all of its subclasses \nfrom accessing certain instance variables or calling certain methods. This has severe consequences for \ncode evolution: whenever a feature of a superclass is modi.ed, the programmer must check all its (direct \nand indirect) subclasses to ensure that the change does not break existing code. This is because any \nsubclass might use the modi.ed feature and may rely on its old meaning. Another aspect of this shortcoming \nis that the programmer cannot specify that a certain feature of a class should be statically bound, that \nis, that all local references to the fea\u00adture s name should always be bound to the local feature rather \nthan to an overriding implementation that appears in a subclass. This is perhaps unsurprising in a language \nbased on message passing and dynamic binding, but it too has serious consequences on code evolution. \nIn fact, the con\u00adsequences of this aspect are even worse. Not only must all subclasses be checked when \nan existing feature of a class is changed, but also all the subclasses and superclasses must be checked \nwhen a new feature is added [29]. To see this, imagine that a maintenance programmer detects some duplicated \ncode in an existing class C and wants to extract it into a new internal method called check. To do this \nsafely, the programmer has to make sure that the check method does not accidentally override an internal \nmethod with the same name implemented in any of C s superclasses. In addition, the programmer also needs \nto be sure that there is no method named check in any of C s subclasses, because such a method would \noverride the new implementation of check that was intended to be internal to C. This dependence on subclasses \nis particularly problematic: it is often impossible to check all the possible subclasses of a certain \nclass, for example, because the programmer of the class works for a framework vendor and the subclasses \nare implemented by (and a trade secret of) its customers. Python is one of the few dynamically typed \nlanguages of which we are aware that provides even limited support for decreasing the interdependence \nbetween classes that are re\u00adlated by inheritance. In Python, features whose names that start with two \nunderscores are private in the sense that these names are valid only from within the class in which they \nare de.ned. Outside of that class, such features are available under a di.erent name, which is derived \nfrom the original name by pre.xing the class name. Although this makes it unlikely that such an internal \nfeature will be accidentally called or overridden outside of the class, it o.ers no real protection. \nFurthermore, the approach of protecting a method based on whether its name .ts a con\u00advention is clumsy \nbecause it requires all the references to the method to be changed if the programmer decides to change \nthe status of the method from private to public . 2.2.2 Interdependence when using Instances Whereas \na class will typically be subclassed only a hand\u00adful of times, it will be instantiated many times and \nits in\u00adstances will be used from many other classes. Thus, it is even more important to protect the internal \nfeatures of an instance from inappropriate access by a client than it is to protect them from a subclass. \nUnfortunately, most dynami\u00adcally typed languages provide only very limited support for this sort of encapsulation. \nIn Smalltalk and Ruby, all instance variables are protected from direct access from outside the object \nthat contains them. In contrast, all methods are externally accessible. Python is even less restrictive: \nby default, instance vari\u00adables are fully accessible from the outside and there is no e.ective way of \nprotecting them. Even if the programmer declares them as private by using a name starting with two underscores, \nthey can still be accessed from the outside as described in Section 2.2.1. None of these languages provide \nany support for declaring internal methods that cannot be invoked from outside of the class in which \nthey are de.ned. This has severe conse\u00adquences for code evolution: for every change to an existing method \nthe programmer must check all the classes in the whole application to ensure that the change does not \nbreak existing code. This is because even if the changed method was intended to be reserved for internal \nuse, there may still be invocations of this method from any other class. Some Smalltalk dialects attempt \nto solve this problem by using a special naming convention to specify internal meth\u00adods. In the Squeak \ndialect [19], for example, methods whose names begin with pvt are e.ectively private: the compiler ensures \nthat these messages can be sent only to self. How\u00adever, this approach not only prevents accesses to such \ninter\u00adnal methods from outside of their class but also from other objects of the same class. Thus, the \npvt convention is a form of object encapsulation: in practice it is often too strict, be\u00adcause it prevents \nmany commonly used data structures and patterns from being implemented. As with Python s double underscore, \nthis approach is clumsy because changing the access attributes of a method requires renaming it. The \nutility of the pvt feature is re.ected in the Squeak image: although this feature has been available \nfor years, only 9 out of about 40 000 methods in the latest Squeak image use it.  2.3 The Problem of \nFragile Data Structures Module encapsulation, as described by Snyder and imple\u00admented in most modern \nstatically typed programming lan\u00adguages, minimizes the interdependencies between separately\u00adwritten modules. \nHowever, it is not .ne-grained enough to address the encapsulation problems related to object alias\u00ading \n[18]. Reasoning about a class in an object-oriented pro\u00adgram involves reasoning about the behavior of \nits instances, and those instances will depend for their correct operation on subobjects instantiated \nfrom other classes. If we do not have an object encapsulation mechanism that allows us to prohibit inappropriate \nmanipulations of these subobjects (e.g., through aliases), checking the correctness of a class may require \nreasoning about the whole program [8]. As an illustration, consider the class Morph, which is the root \nof the GUI framework in Squeak. Morphs have a hi\u00aderarchic structure: a Morph contains an instance variable \nnamed submorphs, which is a (possibly empty) collection of Morph objects. Morph also implements a few \nmethods such as addMorph:, removeMorph:, and moveMorphToFront:, which add and remove submorphs and change \nhow they are layered. Since a Morph is responsible for properly display\u00ading all of its contents, it must \ntake some additional actions whenever its set of submorphs is changed, and it is therefore important \nthat the Morph s clients always use these meth\u00adods to modify the submorph collection, rather than doing \nso directly. With class-based encapsulation mechanism, the only way to ensure this is to make the reference \nto the sub\u00admorphs secret and never pass it out of the parent morph. Unfortunately, this con.icts with \nthe need of some of Morph s clients to use the protocol provided in Collection to enumer\u00adate the submorphs. \nAs a consequence, the implementor of Morph has to choose between one of the following unpleasant alternatives \n[20]. Value semantics: implement the method submorphs to re\u00adturn a copy of the submorphs collection. \nBy avoiding aliases, this approach also avoids the problem of in\u00adappropriate manipulations through aliases. \nHowever, this is not a general solution to our problem because value semantics is not always appropriate \nand its use can therefore lead to subtle bugs. For example, if no special care is taken, it can happen \nthat another thread adds or removes submorphs so that the copy returned by the method submorphs is out \nof date be\u00adfore the client actually used it. Another problem is that, depending on the usage scenario, \nthis approach can require a large amount of unnecessary copying, thus incurring signi.cant time and space \npenalties. Proxies: instead of returning a reference to the submorphs collection itself, return a reference \nto a proxy [15] that serves as a protecting container for the submorphs col\u00adlection. The proxy understands \nonly a safe subset of the collections methods (e.g., the enumeration pro\u00adtocol). In addition to being \nlaborious to implement without language support, and introducing a forward\u00ading overhead on every invocation, \nproxies have several methodological drawbacks. 1. To protect the real submorphs object consistently, \nthe programmer must ensure that no reference to it is ever allowed to escape, either from Morph or from \nthe proxy class. A single inadvertently leaked reference, whether through a parameter, return value or \nexception, defeats the whole scheme. 2. Whenever relevant methods are added, removed, renamed and changed \nin the class OrderedCollec\u00adtion, the proxy class may also need to be updated to ensure that all the safe \nmessages are correctly forwarded and that unrestricted references to the submorphs object are not passed \noutside. 3. Subtle semantic problems can arise because of the di.erent identities of the submorphs object \nand its proxy object.  Fat interfaces: instead of implementing a separate proxy class, one could implement \nall the necessary enumera\u00adtion methods directly in class Morph. However, this is really just a variation \nof the proxy approach and it suf\u00adfers from similar problems. It also increases the com\u00adplexity of the \nalready overly complex Morph interface. Most importantly, the standard names of the meth\u00adods in the enumeration \nprotocol cannot, in general, be used: whereas the submorphs collection understands do:, the parent Morph \nmust instead implement meth\u00adods like submorphsDo: and boundingPathDo: The need to use di.erent message \nnames destroys the uniformity of protocol that makes it possible to write polymorphic code, which is \none of the major bene.ts of the object\u00adoriented paradigm. The implementation of Morph in Squeak currently \nuses value semantics: the method submorphs returns a copy of the submorph collection. However, to avoid \nexcessive copying, Morph also provides some of the methods that would make up a fat interface: it implements \nthe methods submorphsDo:, submorphsReverseDo:, submorphsIndexOf: and many others directly, although other \nenumeration methods such as sub\u00admorphsCollect: are missing. Morph is by no means unusual: there are many \nother well\u00addocumented examples that show the usefulness of object encapsulation for common data structures \nand patterns such as stacks and iterators [8, 23].  2.4 Goals Our goal is to develop an encapsulation \nmechanism for dy\u00adnamically typed languages that avoids the problems just de\u00adscribed. We seek a mechanism \nthat is expressive, simple, and appropriate for dynamic languages. Expressive. Our target mechanism \nmust be expres\u00adsive enough to solve the problems that we discussed in Sections 2.2 and 2.3. This means \nthat it should facili\u00adtate code evolution by minimizing the interdependen\u00adcies between di.erent classes \nand that it should allow one to implement reliable data structures by control\u00adling access to individual \nobjects through aliases.  Simple. It should add minimal complexity to dynami\u00adcally typed languages. \nThis means that the semantics of the language should remain simple and that the en\u00adcapsulation mechanism \nshould make it no harder to understand and reason about programs.  Appropriate. The absence of type \ndeclarations makes programming in dynamically typed languages more lightweight than in their static counterparts. \nIt also makes programming more experimental and incremen\u00adtal, for example, it is possible to execute \nand test a code fragment before all the type declarations are con\u00adsistent or even present. Furthermore, \nthe absence of static types allows classes to be reused in diverse and sometimes unanticipated ways. \nOur target encapsula\u00adtion mechanism should support this dynamic style of programming: it should not burden \nthe programmer with heavyweight type annotations, it should support an incremental style of programming \nand it should support .exible and unanticipated reuse.  3. OUR PROPOSAL IN A NUTSHELL Object-oriented \nEncapsulation (OOE) combines the features of class and object encapsulation mechanisms. OOE de.nes all \nvariables to be local, which means that they are com\u00adpletely hidden and inaccessible from outside of \nthe structure in which they are de.ned. The encapsulation mechanisms for methods are based on two cornerstones. \n1. OOE uses encapsulation policies [27] to specify the en\u00adcapsulation properties of classes and objects \nin a uni\u00adform way. Encapsulation policies can be shared among objects and classes. We allow di.erent \nclients to ac\u00adcess a given object or a class through di.erent encap\u00adsulation policies; this is accomplished \nby associating encapsulation policies with object references. 2. OOE de.nes encapsulation semantics \nby distinguish\u00ading between three di.erent kinds of message send. The distinction is purely syntactic \nand allows us to de.ne a simple semantics that combines class and object en\u00adcapsulation.  For self-sends \nand super-sends, distinguished by the keywords self and super, the receiver of the message is statically \nknown to be the current ob\u00adject. Thus, object encapsulation is not relevant: only the encapsulation policies \nused in the inher\u00aditance chain of the receiver s class decide whether a message send is valid and how \nit is bound.  For object-sends (that is, all messages sent to ob\u00adject references other than self or \nsuper), the en\u00adcapsulation policy that is associated with the tar\u00adget object reference is used to decide \nwhether a message send is valid. In this case the target is treated as a black-box that is accessed through \nits external interface; internal details such as how the target s class is built from other classes are \nirrelevant.   4. OBJECT-ORIENTED ENCAPSULATION In this section we explain in some detail our model \nfor ob\u00adject-oriented encapsulation in dynamically typed languages. For concreteness, we do this in the \ncontext of Smalltalk. However, since our proposal relies on only the most fun\u00addamental features of a \ndynamically typed object-oriented language based on message passing, we are convinced that it could also \nbe applied to other languages that fall into this category (e.g., Ruby and Python). For conciseness, \nthis section presents our model without much discussion of our design decisions and without any attempt \nto justify them: this material is deferred to Sec\u00adtion 5. 4.1 All Variables are Local One purpose of \nour model is to control and reduce the de\u00adpendencies between modules, which we assume to be class de.nitions. \nAs a .rst step, we determine that instance vari\u00adables are never visible outside of the class in which \nthey are declared. This means that from within a class de.nition D, one cannot access, for reading or \nwriting, any instance vari\u00adables that are de.ned in another class C, even if C and D are related by inheritance. \nAn immediate consequence of this rule is that the names of the instance variables in a class D can be \nchosen independently of the names of the instance variables in all the other classes. This provides stronger \nen\u00adcapsulation than Smalltalk-80, which allows a method in a subclass to access the instance variables \nof a superclass. As an additional restriction, we determine that each instance of a class can access \nonly its own .elds, and not those of other instances. This restriction is already present in the Smalltalk-80 \nlanguage. Besides instance variables, Smalltalk has the concept of class variables [16], which correspond \nto static .elds in Java. As with instance variables, we would like to encapsulate class variables in \nthe module in which they are declared. There\u00adfore, we determine that a class variable that is de.ned \nin a class C can be accessed only from the class side of C: it cannot be accessed from the instance side \nof C nor can it be accessed from the class side of subclasses of C. The Small\u00adtalk jargon the class side \nof C corresponds to the Java terminology the static members of C . Thus, in Java ter\u00adminology, our restriction \nsays that static .elds de.ned in a class C can be accessed only from the static methods of C, but not \nby non-static methods of C nor by static methods of subclasses of C. Note that because access to instance \nvariables and class vari\u00adables can be granted through accessor methods (i.e., get\u00adters and setters), \nthese apparently severe encapsulation con\u00adstraints for variables do not a.ect the kind of abstractions \nthat a programmer can write. However, they do allow us to keep our model uniform and simple: we can now \nfocus exclusively on the encapsulation of methods. 4.2 Using Encapsulation Policies Every encapsulation \nmodel needs a way to specify what ac\u00adcess rights should be associated with which methods. This is usually \ndone by de.ning a set of keywords such as pub\u00adlic, private, and protected, which can be used to annotate \nmethods where they are de.ned. This provides .ne-grained control over what can be accessed (individual \nmethods), but very coarse-grained control over whom can perform the ac\u00adcess (all code in one of a small \nnumber of pre-de.ned cat\u00adegories). One of the key bene.ts of our model is that we use encapsulation policies \nto specify access rights, and thus allow much more precision in controlling the whom. The concept of \nencapsulation policies has been described and formalized in a language-independent way in a previous \npaper presented at ECOOP 2004 [27]. We will not repeat this materiel here, but will focus on the aspects \nthat are relevant to Object-oriented Encapsulation. A summary of the relationship between this paper \nand the ECOOP 2004 paper can be found in Section 8. 4.2.1 What is an Encapsulation Policy? The basic \nidea behind encapsulation policies is to separate the encapsulation aspect of a class from the implementation \naspect of a class. This separation allow these two aspects to be reused independently. The separation \nis accomplished by introducing a new entity, called an encapsulation pol\u00adicy, which is essentially a \nmapping from method selectors to access rights. Encapsulation policies are composable: this means that \nnot only can new encapsulation policies be de\u00ad.ned from scratch (i.e., by explicitly specifying the access \nrights for each selector), they can also be de.ned by reusing existing policies, in a way that is independent \nof the inheri\u00adtance hierarchy. Thus, encapsulation policies have a similar .avor to Java interfaces, \nwhich can also be de.ned in terms of other interfaces, and which can be reused across the in\u00adheritance \nhierarchy. Encapsulation policies are used in two ways. 1. The designer of a class can associate an arbitrary \nnum\u00adber of encapsulation policies with the class. Each pol\u00adicy represents a set of encapsulation decisions \nthat cor\u00adrespond to a certain pattern of use. It is important to note that these policies are independent \nof a partic\u00adular mode of use (e.g., inheritance or message send). However, the designer of the class \ncan specify default policies for each mode of use; these apply if the client does not explicitly select \nanother policy. 2. The client of a class can independently decide which encapsulation policy to apply \nand in what way the class will be used, i.e., whether the class will be sub\u00adclassed or whether its instances \nwill be sent messages. The chosen policy then de.nes whether and how the methods de.ned by the class \ncan be accessed (e.g., whether they can be called or overridden). To avoid accessing the class in ways \nthat were not intended by the designer, the chosen policy must be one that is provided by the class, \nor a restriction of one that is provided.  4.2.2 Applying Policies to Individual References The encapsulation \nmodel described in this paper extends the calculus of Composeable Encapsulation Policies [27] by allowing \nencapsulation policies to be applied to individual object references. Hence, each reference to a Smalltalk \nob\u00adject has an associated encapsulation policy that de.nes the access to the object that is permitted \nthrough this reference. This changes the way that Smalltalk objects are manipu\u00adlated in several ways. \nInstantiation. Classes are always instantiated through an encapsulation policy (which may be the default \npol\u00adicy for instantiation). However, this encapsulation pol\u00adicy is associated with the returned reference \nto the object, rather than with the object itself. Message send. In Smalltalk, the only thing that can \nultimately be done with an object reference is to send it a message. It is the encapsulation policy associated \nwith the object reference that determines whether or not the message send is valid.  Assignment. When \nan object is assigned to a variable, passed as a argument or returned from a method, a new object reference \nis created. The new reference is a copy of the original and has the same encapsulation policy.  Restricting \nan object reference. A programmer can, if the encapsulation policy of an object reference allows it, \nrequest an object reference with a more restricted encapsulation policy for a certain object. This is \ndone by sending the binary restrict message | to the ob\u00adject. r | restrictingPolicy is a new reference \nto the same to which r refers; the associated encapsulation policy is the intersection of the policy \nof r and restrictingPolicy.  Obtaining object reference with a di.erent encapsula\u00adtion policy. In certain \ncases, a programmer can also request a reference with a completely di.erent encap\u00adsulation policy for \na certain object. This is possible only if (a) the designer of the object s class explicitly allowed \nthis by implementing an appropriate method, and (b) this method is accessible through the encap\u00adsulation \npolicy of the available reference.  Object Identity. The ordinary Smalltalk identity oper\u00adator == compares \nobject references without regard for the associated encapsulation policies: two object refer\u00adences are \nidentical if they refer to the same object, even if the references have di.erent encapsulation policies. \nHowever, since it is possible to retrieve the encapsula\u00adtion policy associated with an object reference, \na pro\u00adgrammer can also check whether two object references have the same encapsulation policy.  4.3 \nThe Varieties of Access Right As was mentioned in Section 4.2.1, an encapsulation pol\u00adicy maps a message \nselector to a set of access rights. In this section we consider the kinds of access rights that can meaningfully \nbe associated with a message. Recall that we must consider access rights in two di.erent circumstances: \nsending a message to an instance and inher\u00aditing from a class. The situation when using an instance is \nsimple: either a message can be sent, or the message can\u00adnot be sent. This distinction is modeled with \nthe call right c: a message m can be sent to a reference r if and only if the encapsulation policy associated \nwith r maps m to a set containing c. However, note that a message that cannot be sent to reference r \nmight still be sendable to the same target object through a di.erent reference. The situation is more \ncomplex when we consider inheri\u00adtance. The ability for a class to declare a method that is private , \ni.e., neither callable nor overridable from its sub\u00adclasses, is very important for maintainability. This \nis be\u00adcause a programmer can de.ne such a method without hav\u00ading to check whether existing subclasses \nalready de.ne it (see Section 2.2.1). What, then, does it mean if one of the exist\u00ading subclasses does \nde.ne a method with the same name? We say that this means that the method is re-implemented. It is not \noverridden, because sends of the private message in the superclass do not invoke the re-implementing \nmethod in the subclass. Instead, the subclass and the superclass each have their own method, and both \nare reachable from their own scopes. Note that the right to re-implement a method (which we denote by \nr) is orthogonal to the right to over\u00adride it (denoted by o). It may be quite appropriate for a superclass \nto make a particular method re-implementable and overridable, and to allow one of its subclasses to over\u00adride \nit while another re-implements it. Thus, we see that for each method there are three indepen\u00addent access \nrights: o, r and c, and so there are potentially 23 = 8 di.erent sets of rights. Which of these combinations \nmake sense? We determined (and discuss in Section 5.2) that in a dynamically typed language like Smalltalk, \nit is not reasonable for a superclass to prohibit re-implementation (although it may be quite reasonable \nfor a subclass to de\u00adcline the pro.ered r right). This leaves us with four sets of rights that a superclass \ncan o.er to a subclass for each of its methods: {r}, {or}, {cr} and {cor}. {r} means hidden : the method \ncan be re-implemented, but not called or overridden. {or} means overridable : the method can be re-implem\u00ad \nented or overridden at the discretion of the subclass, but not called. {cr} means callable : the method \ncan be re-implemented or called, but not overridden. {cor} means that the subclass has full access . \nNote that none of these sets of rights can be obtained in Smalltalk-80. This is because the language \ndoes not support the concept of re-implementation; a method implemented in a subclass always overrides \nthe corresponding method in the superclass. 4.4 Controlling Access to Methods Together with the access \nrights de.ned above, encapsula\u00adtion policies give the programmer considerable .exibility to specify whether \na method is callable or not, and whether it should override or reimplement a superclass method. In this \nsection, we de.ne how these encapsulation decisions a.ect the semantics of the language; i.e., we de.ne \nwhat it means for a method to be declared as not callable, and what it means to re-implement (rather \nthan override) a superclass method. Note that the exact form of these de.nitions is one of the most crucial \nissues in an encapsulation model for dynam\u00adically typed languages. Our choice is discussed and moti\u00advated \nin Section 5.1. 4.4.1 Three Kinds of Message Send Smalltalk-80 distinguishes between two kinds of message \nsend: normal sends and super-sends. Normal message sends are used to send a message to an arbitrary target \nobject; they are represented syntactically by an expression denot\u00ading the target object followed by the \nmessage. Super-sends Figure 1: A chain of subclass de.nitions showing encapsulation policies on the \ninheritance relation. di.er from normal message sends in two ways: .rst, the tar\u00adget is always the current \nobject (i.e., self), and second they cause the message lookup to start, not in the class of the receiver, \nbut in the superclass of the class that contains the super-send. Super-sends are syntactically distinguished \nby using the keyword super as the target. In our encapsulation model we partition the set of normal sends \ninto two categories with di.erent semantics regarding encapsulation: self-sends and object-sends. As \nwith super\u00adsends in Smalltalk-80, the distinction is purely syntactic:a message send is de.ned to be \na self-send if and only if the receiver of the message is the keyword self2 . Object-sends are de.ned \nto be all the message sends that are neither self\u00adsends nor super-sends. As a consequence, the expressions \nx foo and self foo have di.erent semantics, even if the current value of variable x happens to be self: \nthe .rst is always an object-send, while the second is a self-send. 4.4.2 The Semantics of Re-implementation \nIf a subclass inherits from its superclass using an encapsu\u00adlation policy that does not allow it to override \na method inherited from a superclass, the subclass is nevertheless al\u00adlowed to re-implement the method. \nIn other words, it is allowed to de.ne what is conceptually a new method that happens to have the same \nname. This must necessarily af\u00adfect the meaning of method lookup, but does so di.erently for the three \ndi.erent kinds of message send. 2If Smalltalk s cascade construct [16] is used to send multiple messages \nto the keyword self, all of the messages are self\u00adsends. We can now de.ne the semantics of method lookup \nand re\u00adimplementation. Consider subclasses C0,C1,...,Cn, where C0 is the root of the class hierarchy \nand Ci is a subclass of Ci-1, using the encapsulation policy Pi, for all 1 = i = n (see Figure 1). Consider \na message m that is sent from an object of class Cn by executing a method that is de.ned in class Ck, \nfor some k = n. We de.ne the method lookup for the three di.erent kinds of send in terms of the ordinary \nSmalltalk message lookup algorithm, parameterized by the class where the lookup starts. Object-sends. \nIf the message m is object-sent to an object o, the method lookup starts in the class of o.  Super-sends. \nIf the message m is super-sent, the method lookup starts in class Ck-1.  Self-sends. If the message \nm is self-sent, we distinguish two cases.  1. If there is a smallest index i with k<i = n such that \nPi declares the message m not to have the o right, then the method lookup starts in class Ci-1. 2. If \nno such index i exists, the method lookup starts in class Cn. This means that for both object-sends and \nsuper-sends, the method lookup is the same as in Smalltalk-80 and entirely independent of encapsulation \npolicies. Only self-sent mes\u00adsages are a.ected by the encapsulation policy. As an illustration, consider \nFigure 1 and imagine that the message bar is sent to an instance of C3, which means that n = 3 and k \n= 1. When the method bar (de.ned in C1) executes self foo, which foo method is invoked? In the .gure, \nP2 does associate the o access right with foo, whereas P3 does not. Hence i = 3 and the method lookup \nfor foo starts in class C2, where foo is indeed found and invoked. 4.4.3 Valid Message Sends We can now \nalso de.ne the encapsulation restrictions that apply to message sends. We assume that our message send \nis located in a class C, which is de.ned as a subclass using the encapsulation policy P , and we then \nde.ne valid message sends as follows. Object-send. An object-send of a message m to an object reference \nr is valid if and only if m has right c in the encapsulation policy that is associated with r.  Super-sends. \nA super-send of a message m is valid if and only if m has right c in P .  Self-sends. We partition a \nself-send of a message m into two cases. 1. If the method lookup of m yields a method that is implemented \nin C or one of its subclasses, then the send is valid. 2. If the method lookup of m yields a method \nthat is implemented in one of C s superclasses, then the send is valid if m has right c in P .   Thus, \nfor self-sends and super-sends, the only relevant en\u00adcapsulation policy is that of the class de.ning \nthe method. In contrast, for object-sends, the only relevant encapsulation policy is that associated \nwith the object reference. An at\u00adtempt to send an invalid message generates a messageInvalid error. This \nis similar to, but distinct from, a messageNotUn\u00adderstood error, and can be handled by the programmer \nin a similar way. 4.5 Examples To clarify these de.nitions, we now present some examples of how our \nencapsulation model can be used. We do this using our previous Smalltalk-based syntax and policy man\u00adagement \nproposal [27]. An encapsulation policy literal is a list of message selectors between brackets []. The \nmeaning of such a literal is that the listed message selectors are fully accessible, i.e., they are mapped \nto the set {cor}, whereas message selectors that are not listed are hidden, i.e., they are mapped to \nthe set {r}. 4.5.1 Simple Class Extension The .rst example de.nes Set as a subclass of Collection. (Collection \nsubclass: Set) instanceVariableNames: array tally ; policyAt: basicUse put: [add: addAll: remove: . . \n. ]; policyAt: basicExtend put: basicUse + [keyAt: scanFor: . . . ]. The new subclass o.ers its clients \ntwo encapsulation poli\u00adcies, named basicUse and basicExtend3 . basicUse is de.ned using a literal: it \nassociates full access with the message se\u00adlectors add:, addAll:, remove:, etc. The policy basicExtend \nis composite: it grants all the access rights de.ned in the policy basicUse, but it also associates full \naccess rights with the message selectors keyAt:, scanFor:, etc.. Note that policies associated with the \nnames basicUse and basicExtend are default policies: in the absence of an explic\u00aditly stated policy, \nbasicUse is used as the default policy for new instances and basicExtend is used as the default policy \nfor new subclasses. The default rule was used in the de.ni\u00adtion of class Set: since we did not explicitly \nspecify a policy through which Set inherited from Collection, the basicExtend policy of class Collection \nwas used. Similarly, if we create an instance of Set without explicitly specifying the encapsula\u00adtion \npolicy that should apply to the instance, the default policy basicUse de.ned in the class Set is used. \nHowever, we can also create instances with the less restrictive basicEx\u00adtend policy by sending the message \nnewWithPolicy: to the class Set. x := Set new. uses default policy basicUse x add: 1. y := Set newWithPolicy: \nbasicExtend. y add: 1. y scanFor: 1. valid message send x scanFor: 1. error! invalid message send We \ncan also use a more restricted interface to create a sub\u00adclass of Set called RandomizedSet. RandomizedSet \nde.nes a new method randomDo:, which enumerates the elements in 3Those familiar with Smalltalk syntax \nshould note that we use a distinguished font for symbols rather than a pre.x #. a random order and is \nimplemented using a helper method generate that returns a random number. OOE lets us state explicitly \nthat the class RandomizedSet is not intended to override any of the methods of the class Set. In the \ncode below, this is done by specifying that RandomizedSet should inherit from Set through the encapsulation \npolicy basicUse noOverride, which is the policy that allows the subclass to call all the methods in the \npolicy basicUse o.ered by Set but disallows the overriding of any of them. (Set subclass: RandomizedSet \nwithPolicy: basicUse noOverride) instanceVariableNames: seed ; policyAt: basicUse put: super + [randomDo:]; \npolicyAt: basicExtend put: super + [randomDo: generate] This minimizes the interdependencies between \nRandomized-Set and its superclass, and has the advantage that even if someone later adds a new internal \nmethod generate to Set, it cannot be confused with the version in RandomizedSet. However, it should be \nnoted that even though Randomized-Set uses a restricted encapsulation policy to inherit from Set, it \nis still possible for subclasses of RandomizedSet to use a more liberal encapsulation policy which will \npermit them to override methods in Set. Moreover, subclasses can inherit from RandomizedSet through any \nof the encapsula\u00adtion policies that it o.ers. In our example, these policies are basicUse and basicExtend, \nwhich both grant full access rights to their message selectors and therefore allow the cor\u00adresponding \nmethods to be overridden. Note that both these policies are de.ned using the keyword super that refers \nto the policy of the same name in the superclass. (More details are available in reference 27.) 4.5.2 \nCollection Hierarchy Example We now present a more elaborate example that shows how encapsulation policies \ncan be used to create a simpli.ed col\u00adlection hierarchy. We .rst de.ne the class Collection, which serves \nas the abstract root class of the hierarchy. This class is de.ned as a subclass of the class Object using \nits default policy for subclassing. The class Collection o.ers three en\u00adcapsulation policies enumeration, \nreadOnly, and basicEx\u00adtend which allow the class to be used in di.erent scenar\u00adios. This class does \nnot o.er a policy named basicUse be\u00adcause it is abstract and should not be instantiated. (Object subclass: \nCollection) instanceVariableNames: ; policyAt: enumeration put: PCollEnumeration; policyAt: readOnly \nput: PCollReadOnly; policyAt: basicExtend put: PAll. Unlike the Set example, the encapsulation policies \nused here are not literals but are globally named constant policies that are de.ned independently and \ncan therefore be reused in many classes. The policy PCollEnumeration grants full ac\u00adcess rights to the \nmessages in the enumeration protocol, whereas the policy PCollReadOnly is built as the compo\u00adsition of \nthe policy PCollEnumeration (which contains only observer methods) and a policy that contains some other \nread-only methods. The policy PAll is a special prede.ned policy that allows full access to all message \nselectors. Policy named: PCollEnumeration is: [do: select: detect: collect: reject: ...] Policy named: \nPCollReadOnly is: PCollEnumeration + [isEmpty notEmpty size ...] Using Collection, we now de.ne the subclass \nOrderedCollec\u00adtion (used to represent an extensible vector). Since the ele\u00adments in OrderedCollection \nare sequenced, this class imple\u00adments additional methods such as at: and .rst. To make these methods \naccessible, we add them into the encapsula\u00adtion policies enumeration and readOnly that are o.ered by \nthe class OrderedCollection. Additionally, because this class is concrete, we o.er the named policy PCollSequenced \n(the de.nition of which is not shown) as basicUse. (Collection subclass: OrderedCollection) instanceVariableNames: \narray .rstIndex lastIndex ; policyAt: enumeration put: super +[from:to:do: reverseDo: . . . ]; policyAt: \nreadOnly put: super + enumeration +[at: .rst last ... asReadOnly asEnumeration]; policyAt: basicUse \nput: PCollSequenced; policyAt: basicExtend put: PAll. These policies can now be used to create object \nreferences to instances of OrderedCollection under di.erent encapsula\u00adtion policies. This is done by \nimplementing the methods as-ReadOnly, asEnumeration, and asSequencedCollection, which use the new language \nelement selfWithPolicy: to return an object reference to the receiver of the currently executing method \n(i.e., self) through the encapsulation policy that is speci.ed by the argument. Note that, as for instantiation \nand subclassing, the argument to selfWithPolicy: must be an encapsulation policy that is o.ered by the \ncurrent class (e.g., readOnly) or a policy that is derived from such a policy using modi.ers that make \nit more restrictive [27]. OrderedCollection>>asReadOnly . selfWithPolicy: readOnly. OrderedCollection>>asEnumeration \n. selfWithPolicy: enumerate. OrderedCollection>>asSequencedCollection . selfWithPolicy: basicUse. Given \nthese de.nitions, we must prevent a user that has a readOnly or enumerate reference from sending it the \nmes\u00adsage asSequencedCollection and thus acquiring a reference with a less restrictive encapsulation policy. \nThis is done by making sure that the message asSequencedCollection is not declared to be callable in \nthe encapsulation policies read-Only and enumeration. Similarly, asReadOnly must not be declared to be \ncallable in the policy enumeration, because we intend that the access rights granted by readOnly are \na superset of the access rights granted by enumeration. Using this OrderedCollection implementation, \nwe can now implement the method submorphs in the class Morph so that it returns an object reference that \nis restricted to the enu\u00admeration policy. Morph>>submorphs . submorphs asEnumeration Figure 2: The meaning \nof method hiding. C>>foo is hidden. Which of the sends of foo from method bar: invoke which of the foo \nmethods? Similarly, we can add support for a fully protected read-only OrderedCollection by adding an \ninstance creation method readOnlyWith: to the class side of OrderedCollection. OrderedCollection class>>readOnlyWith: \naCollection | inst | inst := self new. inst addAll: aCollection. . inst asReadOnly. This method takes \na collection as an argument and then creates a new read-only collection that contains all the ele\u00adments \nin the argument. Note that the object reference re\u00adturned from this method is unique. It is the only \nreference to the newly created object, which can therefore never be mutated.  5. DESIGN DISCUSSION \nIn this section we review and discuss the main decisions in the design of OOE. First, we elaborate on \nthe decision to base the meaning of method hiding on the distinction be\u00adtween self-sends and object-sends. \nThen, we justify our de\u00adcision regarding the possible combinations of access rights, and .nally we discuss \nhow OOE .ts into Smalltalk s every\u00adthing is an object philosophy. 5.1 The Meaning of Method Hiding As \ndescribed in Section 4.3, a method with selector foo that is implemented in class C is hidden from a \nsubclass D if a policy that assigns only the re-implement right r to the selector foo is used for the \ninheritance operation. To de.ne exactly what such hiding means, we must answer the following two questions, \nwhich are illustrated in Figure 2. 1. If D also implements a method with selector foo, and a method bar: \nde.ned in C is invoked on an instance of D, which sends of foo inside bar: are locally-bound to the hidden \nmethod C>>foo rather than using the ordinary method lookup? 2. Which sends to the hidden method C>>foo \nare valid?  In statically typed languages, these questions are usually answered based on static types. \nHowever, in a dynamically typed language, no static types are available, and so OOE answers these questions \nby using a di.erent semantics for object-sends on the one hand, and self-and super-sends on the other. \nThis was one of the key design decision in OOE, and the reasons for this choice are not immediately obvious. \nIn fact, we could have answered these questions based on three di.erent kinds of information: the dynamic \ntype (i.e., the class) of the receiver,  the identity of the receiver, and  the di.erent kinds of message \nsend.  We now elaborate on the advantages and disadvantages of these three options. Because dynamically \ntyped languages do not usually allow one to hide methods, we will .rst see how hiding is accomplished \nin statically typed languages such as Java, C++, and C#. 5.1.1 Based on Static Types For concreteness, \nassume that the following Java methods are implemented in the classes C and D, and that c1 and c2 are \ntwo di.erent instances of C, while d1 and d2 are two di.erent instances of D. class C { private int foo() \n{ return 1; } public void bar(C arg) { C t; int i, j, k, l; t = this; i = this.foo(); j = t.foo(); k \n= arg.foo(); l = new D().foo(); } } class D extends C { public int foo() { return 2; } } In this \ncode, the method C>>foo4 is hidden by labeling its declaration with the keyword private. According to \nthe Java semantics, this means: 1. A message send obj.foo is locally-bound to the hidden method C>>foo \nif the static type of obj is C. 2. A send to the hidden method C>>foo is valid only if it occurs within \nthe de.nition of C.  4Even though we are talking about a statically typed lan\u00adgauge such as Java, we \nwill nevertheless use the Smalltalk notation C>>foo to denote the method foo implemented in the class \nC. As a consequence, when executing c1.bar(c2), the local vari\u00adables i, j, and k get the value 1, because \nall the receivers of foo have the static type C, while the variable l gets the value 2 because the receiver \nnew D() is of static type D. Executing d1.bar(d2) has the same e.ect: i, j, and k still get the value \n1 because the three receivers this, t and arg still have the static type C, even though the objects to \nwhich they refer all have dynamic type D. Furthermore, the expression c1.foo() will not compile outside \nof the de.nition of class C, because the call to C>>foo is invalid. The advantage of this approach is \nthat it is statically ob\u00adservable which calls are locally-bound to the hidden method C>>foo and whether \nthese calls are valid. Furthermore, the programmer can always decide which method should be called by \nchoosing the right static type. However, this also means that as soon as a program contains methods that \nare declared as private, the static types are used not only to check whether a program is valid, but \nalso to determine the meaning of the program by de.ning whether a method is late-bound! In other words, \nthe types carry crucial seman\u00adtic information. 5.1.2 Based on the Class of the Receiver The above approach \ncannot be applied to dynamically typed languages because no static types are available. Instead, we considered \nde.ning the semantics of hiding based on the dy\u00adnamic type (i.e., the class) of the receiver together \nwith some static information about the class hierarchy. We answered the two questions from Section 5.1 \nas follows. 1. A send of the message foo is locally-bound to the hid\u00adden method C>>foo if it occurs in \nthe de.nition of C and the class of the receiver is C, D or a subclass of D. 2. A send to the hidden \nmethod C>>foo is valid only if it occurs within the de.nition of C.  At .rst glance, this de.nition \nseems appropriate because it guarantees that the method D>>foo is never called by a mes\u00adsage send that \noccurs in the de.nition of C in other words, it guarantees that all the sends of foo in C are hardwired \nto C>>foo, provided that the receiver is an instance of C, D or a subclass of D. Unfortunately, this \nis not always what the programmer expects. As an illustration, consider what happens if we translate \nthe example from Section 5.1.1 into Smalltalk. C>>foo . 1 C>>bar: arg | ijklt | t := self. i := self \nfoo. j := t foo. k := arg foo. l := (D new) foo C subclass: D withPolicy: [bar:]. D>>foo . 2 The problem \nis that because there are no static types, the programmer has no way of specifying whether a send of \nfoo should refer to the hidden method C>>foo or to D>>foo. Thus, it is not clear whether the programmer \nintended the expression (D new) foo on the last line of C>>bar: to refer to the method D>>foo as it does \nin the corresponding Java program or to the hidden method C>>foo. The same holds for the send of foo \nto the argument arg. The di.erence between the type-based and class-based in\u00adterpretations is re.ected \nin the e.ect of executing the code c1 bar: c2. In the Smalltalk example, the local variable l gets the \nvalue 1 because the receiver is an instance of D and the send of foo is therefore locally-bound. However, \nin Java, the variable gets the value 2 as the static type of the receiver is D. Besides the fact that \nthis may not be what the programmer intends and expects, the lack of explicit control makes it impossible \nto correct the situation. Other problems with the class-based interpretation are that it makes static \nreasoning about the code much more di.cult, and that is hard to implement e.ciently. It is in general \nimpossible to ascertain statically which sends of a hidden selector are locally-bound to the hidden method. \nConsider for example the expression arg foo in the method C>>bar:. This expression will be locally-bound \nto the hidden method if arg is of class C, D or a subclass of D. Otherwise, ordinary method lookup applies. \nImplementation costs are especially high if frequently-used selectors are hidden in a large class hierarchy. \nAs an ex\u00adample, suppose that the class RectangleMorph implements a new version of = that is incompatible \nwith the semantics of = used in its superclass, Morph. RectangleMorph therefore inherits from Morph using \na policy that hides the method =. However, this means that in all the dozens of places where = is sent \nin the classes Morph and Object (Object is the super\u00adclass of Morph), the implementation must check, \nat runtime, whether the receiver is an instance of class RectangleMorph or one of its 142 subclasses \nto know whether this send should be locally-bound to the hidden method. This interpretation also causes \nsevere semantic problems if it is applied in a language that supports multiple reuse of behavior through \nmultiple inheritance or traits [26]. A prob\u00adlematic example is illustrated in Figure 3. Here we see a \nclass C that, besides many other methods, de.nes methods foo and bar; method bar contains the expression \nself foo. Two classes D1 and D2 inherit from C and override the method foo, but do not implement any \nother methods. Now assume that new class E multiply inherits from both D1 and D2. It avoids a con.ict \nbetween the two foo methods by hiding both of them, and then re-implementing a new method foo. Clearly, \nthis causes an ambiguity in the method C>>bar be\u00adcause it is not clear which of the two hidden foo methods \nD1>>foo and D2>>foo should be called by the expression self foo. This ambiguity can be resolved by overriding \nthe mes\u00adsage bar in E. However, all the other methods in C that send the message foo to an instance of \nE or one of E s subclasses are also ambiguous and thus also need to be overridden. Worse, it is not possible \nto ascertain statically which meth\u00adods these are. As a consequence, all the methods that send Figure \n3: a semantic problem with the class-based interpretation of method hiding. the selector foo would need \nto be overridden to ensure that there are no ambiguities at runtime. This may not be practi\u00adcal because \nit requires many methods to be overridden even if, in reality, they send foo only to instances of classes \nthat are completely unrelated to E. In our example in Figure 3, we would need to override the method \nC>>check: in E because it sends the message foo to the argument arg, which may or may not be an instance \nof E or one of its subclasses. 5.1.3 Based on the Identity of the Receiver Another alternative is to \nde.ne the meaning of hiding based on the identity of the receiver. This would mean the follow\u00ading. 1. \nA send of the message foo is locally-bound to the hid\u00adden method C>>foo if it occurs within the de.nition \nof C and the receiver is identical to the object that sends the message (i.e., self). 2. A send to the \nhidden method C>>foo is valid only if it occurs within the de.nition of C and the receiver is identical \nto the object that sends the message (i.e., self).  Compared to the previous approach, this alternative \ncan be implemented somewhat more e.ciently, because checking the receiver s identity is faster than checking \nwhether the receiver s class directly or indirectly inherits from another class. Unfortunately, this \ncheck still cannot be done stati\u00adcally in most cases. As an illustration, consider again the method C>>bar:. \nClearly, the message send self foo on the third line is always sent to the current receiver object and \nso it can be optimized statically. However, for all the other sends of foo, it is not immediately clear \nwhether the message is sent to the current object. A reasonable static analysis could be used to infer \nthat t is bound to self on the second line and is not modi.ed before the message foo is sent to it on \nthe forth line. However, even using a sophisticated analysis, there will always be a large number of \nsends like arg foo on line .ve, where it is unlikely to be feasible to compute the identity of the receiver \nstatically. In addition to these implementation problems, this approach also leads to a semantics that \nmay be hard to understand. As an example, compare the subtle semantic di.erence be\u00adtween executing the \nexpressions d1 bar: d1 and d1 bar: d2. At .rst glance, one would expect these two pieces of code to have \nthe same e.ect because neither C nor D has any instance-speci.c behavior. However, this is not the case: \nin the .rst expression the value of the local variable k is 1 because arg happens to be identical to \nself, whereas in the second expression, this value is 2 because arg and self are di.erent. Things get \neven more tricky if meta-functionality is involved. As an example, assume that the class C de.nes an \ninstance variable counter with a setter method counter:, and a method C>>resetAll, which resets the value \nof counter for all the in\u00adstances of C. C>>resetAll self class allInstancesDo: [:each | each counter: \neach foo] Executing d1 resetAll leads to the quite surprising result that d1 will have its counter value \nset to 1 whereas all the others instances of class D have their values set to 2. 5.1.4 Based on Different \nMessage Sends (OOE) Last but not least, we consider the interpretation that we selected for OOE, which \nis based on distinguishing self-sends from object-sends. This allows us to answer our questions in a \nway that is purely static. 1. A send of the selector foo is locally-bound to the hid\u00adden method C>>foo \nif it is a self-send that occurs within a method de.ned in C. 2. A send to the hidden method C>>foo \nis valid only if it is a self-send that occurs within the de.nition of C.  The advantage of this approach \nis that once we know that the class D inherits from C through an encapsulation policy that hides the \nmethod foo, we immediately know which mes\u00adsage sends are locally-bound. For example, in the method C>>bar:, \nonly the message send self foo on the third line will be locally-bound to the method C>>foo; ordinary \nmessage lookup applies to all the other message sends. This means that if we execute the code d1 bar: \nd2, the local variable i will get the value 1 while all the other variables j, k, l will get the value \n2. As a consequence, this approach can be implemented more e.ciently than the alternatives that we have \npresented (see Section 6 for details about the implementation). Another advantage over the alternatives \nis its simplicity, which facil\u00aditates program understanding and reasoning about the code. Because the \nsemantics have no dependencies on the identity of objects, the code in the classes C and D has no instance\u00adspeci.c \nbehavior, and we can be sure that the expressions d1 bar: d1 and d1 bar: d2 are equivalent. Similarly, \nthe avoid\u00adance of any dependance on dynamic type greatly simpli.es things if OOE is used together with \na mechanism that allows multiple reuse of behavior. Programmers who have never programmed in a language \nwhere self-sends have a special semantics may at .rst .nd it confusing that even if self is identical \nto t (as in C>>bar:), the expression self foo is not necessarily equivalent to the ex\u00adpression t foo. \nHowever, our experience from analyzing and writing code in terms of this model has convinced us that \nthis is actually a very natural concept, especially when used in the context of our object-oriented encapsulation \nmodel. We quickly began to think of a self-send as an internal send , i.e., a send that is issued from \nwithin an encapsula\u00adtion boundary and which can therefore access hidden meth\u00adods. In contrast, an object-send \nis an external send , i.e.,a send that always accesses its receiver through the encapsula\u00adtion policy \nassociated with its reference, no matter whether the message was sent from within the receiver object \nor from within some other object that has the same class as the re\u00adceiver. Nevertheless, this approach \ndoes have some drawbacks. One of them is that treating self-sends and object-sends di.er\u00adently makes \nall message sends that have self as one of the arguments asymmetric. As an example, consider the two \nexpressions self = arg and arg = self. One might expect = to be symmetric, but because one expression \nis a self-send and the other one an object-send, this may not be the case. Of course, this problem is \nnot really new: message send is inherently asymmetric in all single-dispatch object-oriented languages, \nbecause only the receiver is taken into account when the message is dispatched. This issue is analyzed \nex\u00adtensively by Bruce and his co-authors [11]. Another issue is that even if a method C>>foo is hidden \nfrom the subclass D, the class C may still contain sends of the message foo that .nally call the method \nD>>foo. As a concrete example, assume that the method hasSameHash: is implemented in the class Integer \nand that the subclass LargeInteger re-implements the method hash. Integer>>hasSameHash: arg . self hash \n= arg hash If this method is executed with instances of LargeInteger as both the argument and the receiver, \nthe self-send self hash is locally-bound to the hidden method Integer>>hash whereas the object-send arg \nhash invokes the method in LargeInteger. Unfortunately, such situations cannot be avoided with any of \nthe alternatives considered in this paper. In fact, we would encounter the same behavior with the identity-based \napproach, while the approach based on dynamic types can lead to the opposite situation, which is that \nit calls the hid\u00adden method in cases where it should not. As we have pointed out above, this is a consequence \nof the fact that dynamically typed languages do not provide any mechanism that lets the programmer specify \nexplicitly which method he means. Being aware of this conceptual limitation, the approach of di.erentiating \nbetween self-sends and object-sends has the important advantage that the rule is extremely simple and \npurely syntactic. Thus, the semantics is clear based on in\u00adspection of the source code alone. In fact, \nonce one is used to the fact that self-sends are conceptually di.erent from object-sends, it is absolutely \nnot surprising that in the above code, the two conceptually di.erent sends of the message hash will call \ndi.erent methods if hash is hidden in a sub\u00adclass. Indeed, this is nothing more than a logical consequence \nof using Object-oriented Encapsulation: the self-send is an in\u00adternal send to the object sending the \nmessage, whereas the object-send is an external send that treats the the object reference arg as a black-box \nand hence accesses it through the encapsulation policy that is associated with it. Thus, it is clear \nthat even if the two receivers have the same class, the e.ects of the two sends may well be di.erent \nbecause one send is seeing the features of the class from the inside whereas the other is seeing it through \nan encapsulation pol\u00adicy that might hide certain internal features. On a more conceptual level, we have \nfound that program\u00adming with OOE shifts the focus of the programmer s think\u00ading away from classes, and \ntowards objects and their encap\u00adsulation polices, i.e., their interfaces. Whenever the pro\u00adgrammer is \ndealing with an object, it is not really the class of the object that matters, but the interface that \nis associ\u00adated with the reference to the object. This leads to a style of programming that emphasizes \ninterfaces, indeed, program\u00adming against interfaces (rather than classes) becomes not only a recommended \npattern but the only viable option.  5.2 Combinations of Access Rights In Section 4.3, we determined \nthat in a dynamically type language like Smalltalk, it is not reasonable to prohibit re\u00adimplementation \nof a method in a subclass. In the terminol\u00adogy of Java, this means that it is not possible to declare \na method as .nal. While this decision may look quite contro\u00adversial at .rst, it can be justi.ed by looking \nat the motiva\u00adtions for declaring a method as .nal in Java. According to Arnold and Gosling [4], there \nare two main motivations for .nal: security and performance. Declaring a method m in a class C as .nal \ncan improve security because a programmer cannot declare a subclass that re-implements or overides m. \nTherefore, one can rely on its implementation wherever m is sent to an expression with static type C \nor a subtype of C. However, since Smalltalk is not statically typed, it o.ers no such type-based guarantees \nin the .rst place. As a consequence, declaring a method as .nal to improve security is pointless because \nanother programmer can always replace an instance of C with an instance of a new class C., which does \nnot inherit from C and which can therefore provide an arbitrary method for m. The performance bene.t \nof declaring a method as .nal stems from the fact that it allows, in certain situations, the com\u00adpiler \nto inline invocations of that method. Although this bene.t applies equally to dynamically typed languages, \nwe feel that including a language mechanism solely for perfor\u00admance is inappropriate in a higher-level \nlanguage like Small\u00adtalk. Not only does it make the language more complex, but it also tempts programmers \nto sacri.ce extensibility of a class for the sake of a performance bene.t that, in practice, is often \nnegligible or irrelevant. Neither are we convinced by the argument that .nal is ap\u00adpropriate for perfect \nmethods that will never need to be rede.ned. This argument is especially unconvincing in the context \nof a dynamic language where code is often shared among multiple programmers. In our experience, it is \nhard if not impossible to know in advance how another programmer might want to use a class in the future. \n 5.3 Encapsulation Policies on the Class Side In Smalltalk, classes are ordinary objects: they are single\u00adton \ninstance of so-called metaclasses [16]. This makes the language uniform, because all the concepts that \napply to objects also apply to classes. The impact of this on encap\u00adsulation is that the same encapsulation \nmechanisms that we have de.ned for objects apply also to classes. Because both class variables and class \ninstance variables can only be accessed on the class side of the class where they are de.ned, a class \nmust de.ne accessor methods to permit its instances to access these variables. This raises the question \nof how such class-side accessor methods are encapsulated, i.e., who is allowed to call them? Again, the \nanswer is that because Smalltalk classes are objects, OOE s mechanisms for restricting access apply uniformly \nto methods de.ned on the class side. On the class side, as on the instance side, the programmer can de.ne \nencapsulation policies named basicUse and ba\u00adsicExtend, which are then used as the default policies for \ninstances and subclasses. If there is a need to use a di.er\u00adent policy, this can be achieved by using \nan extended sub\u00adclass creation message such as subclass:withPolicy:classPolicy: that allows one to explicitly \nspecify the encapsulation policy through which the implicitly created metaclass accesses its superclass. \nOne thing that is not possible is specifying a di.erent in\u00adstance creation policy for the class object \nitself: all class objects are created with the policy basicUse. This is a con\u00adsequence of the fact that \na class is a singleton object that is automatically created (using the default policy) when the class \nis de.ned. In spite of all this uniformity, encapsulation policies have one special feature on the class \nside. In addition to the poli\u00adcies basicUse and basicExtend, class objects have a third default policy \ncalled instance. This policy is used whenever an instance accesses its class using the expression self \nclass. This feature is important because it provides a way for a class to give its instances access through \na di.erent, and usually broader, encapsulation policy than that available to other objects. For example, \nthis mechanism could be used to allow the instances of the class Delay to call the acces\u00adsor methods \nof the class variable TimingSemaphore, while keeping that accessor hidden from other objects. An examination \nof the Squeak image shows that in most cases it should be su.cient to have only the default encap\u00adsulation \npolicies on the class side. Nevertheless, allowing custom encapsulation policies on the class-side is \nvaluable as it will allow system engineers to hide the large number of internal meta-methods that are \ninherited from Behavior, ClassDescription, and Class. As an example, custom class en\u00adcapsulation policies \nwould make it possible to prevent pro\u00adgrammers from inappropriately accessing the method dic\u00adtionary \nusing compiledMethodAt:.  6. IMPLEMENTATION We have extended the Squeak language [19] so that it sup\u00adports \nthe encapsulation features presented in this paper. In this section, we .rst give a schematic overview \nof our im\u00adplementation. Then, we we focus on some implementation details, and .nally, we evaluate the \ncosts of our implemen\u00adtation based on di.erent benchmarks. 6.1 Schematic Overview To implement OOE in \nSmalltalk, we needed to make sure that all message sends behave according to the semantics we have de.ned \nin Section 4.4. For self-sends and super-sends, this can be done statically, which means that that there \nis essentially no performance penalty compared to ordinary Smalltalk. For object-sends, this is not quite \nthe case: for each send to an object reference that is protected by an encapsulation policy, we must \nensure that the send is valid. 6.1.1 Changes to the Compilation Process We have modi.ed the compilation \nprocess so that it re.ects the conceptual di.erence between self-and super-sends on the one hand and \nobject-sends on the other hand. Whenever a method is compiled, we add it to the method dictionary twice, \nkeyed by both the ordinary message selector and by an internal symbol that is distinct from all valid \nmessage selectors. Whereas the ordinary message selectors are used for object\u00adsends, the internal symbols \nare used for all self-sends and super-sends. This means that all the selectors that are self\u00adsent and \nsuper-sent within a method are replaced by internal symbols. To ensure that the same internal symbol \nis used for all the occurrences of a given selector within a class, we store the mappings between the \nreal selectors and the internal symbols in a per-class translation table. The .rst time that a selector \noccurs, the internal symbol is generated and stored in the translation table; it is then looked up on \nall subsequent occurrences of the same selector in the class. Of course, self-sends and super-sends refer \nnot only to meth\u00adods that are implemented locally; they also refer to methods that are implemented in \nsuperclasses and subclasses. This means that during the compilation process, we have to make sure that \nthe translation tables of classes that are related by inheritance map the same real selectors to the \nsame inter\u00adnal symbols, unless the selector is not callable or is declared to be re-implemented by the \nencapsulation policy through which a subclass inherits from its superclass. We ensure this by making \nsure that each translation appears in the table of only the topmost class that implements or calls the \nselec\u00adtor, and by using a lookup algorithm that is similar to the normal Smalltalk method lookup to do \nthe translation. The details of this algorithm are outside of the scope of this paper, but it is worth \nnoting that it takes the access rights of the encapsulation policies used for the inheritance operation \ninto account to make sure that all the self-sends are .nally dispatched according to the semantics de.ned \nin section Section 4, and that invalid self-sends and super-sends are detected at compile-time. 6.1.2 \nChanges to the Virtual Machine The compilation process just described ensures that all the self-sends \nand super-sends have the right semantics; no mod\u00adi.cation to the virtual machine is necessary and we \ncan use the ordinary Smalltalk message lookup process. For object\u00adsends, things are a bit more complicated. \nFirst, we need to model the fact that every object reference can have its own encapsulation policy. The \nsimplest way to do this is to have each object pointer in the VM not point directly to an object but \ninstead point to an object reference. Such a reference consists of two pointers: one to the object and \nthe other to the encapsulation policy. Objects are represented as in the standard VM; encapsulation policies \nare represented as identity sets that contain all the callable selectors. Finally, we must change the \nlookup mechanism for object\u00adsends in the virtual machine. The new lookup process con\u00adsists of two steps. \nFirst, we need to check whether the send is actually valid. This means that we have to check whether \nthe selector is in the identity set that is associated with the object-reference. If it is not found, \nwe raise a messageIn\u00advalid exception. Otherwise, the ordinary Smalltalk message lookup is applied and \nwe proceed as usual: if the method is found in the method dictionary, it is executed; if not, we raise \na messageNotUnderstood exception. 6.2 Implementation Details In this section, we discuss some implementation \ndetails and point out the points in which our implementation di.ers from the schema described above. \n6.2.1 Compilation Process One di.erence between the conceptual schema described above and our actual \nimplementation is that we do not actually replace all self-sends and super-sends with inter\u00adnal symbols. \nThe reason for this is that typically only a small percentage of the methods are re-implemented in sub\u00adclasses. \nTherefore, we can save space if we duplicate only the method dictionary entries for methods that are \nactually re-implemented in a subclass. This means that when a new subclass is created and some methods \nare added, we at .rst neither replace any self-and super-sends with internal symbols nor do we associate \nthe new methods with an internal symbol in the method dic\u00adtionary. When a subclass actually re-implements \nsuch a method, we generate a new internal symbol for the original selector, add it to the translation \ntable, create the necessary entries in the method dictionaries, and perform the neces\u00adsary recompilations \nso that the self-and super-sends to the original selector refer to the newly created internal symbol \ninstead. The downside of this scheme is that it requires more work at compile time, especially if the \nprogrammer performs op\u00aderations such as changing the superclass of a class. Whether this scheme is bene.cial \ndepends on the target platform (e.g., whether memory is a critical resource) and on how frequently re-implementation \nactually occurs. Our compilation process generates a special byte-code for self-sends. This is important \nbecause in the case of self-and super-sends, the virtual machine must not check whether the sent selector \nis in the encapsulation policy associated with the receiver. Since the Smalltalk byte-code set contains \na few dozens of di.erent send byte-codes, introducing a spe\u00adcial self-send version for each of them was \nnot an option. Instead, we introduced a single new byte-code that sets a virtual machine .ag saying that \nthe next send will be a self\u00adsend, and we modi.ed the compiler so that it generates this byte-code immediately \nbefore each self-send. 6.2.2 Representing Object References With respect to the virtual machine, the \nmost important question was how to represent the object references. For simplicity, we decided to make \nobject-references instances of a new class ObjectReference that contains two instance variables to contain \nthe actual object and the relevant part of the associated encapsulation policy, which is an identity \nset containing the callable selectors. The advantage of this representation is that each object ref\u00aderence \nis an ordinary object and can therefore be kept in the object memory without changing it. In particular, \nno changes to the garbage collection algorithm were necessary. The disadvantage is that this is not the \nmost e.cient rep\u00adresentation. However, thanks to a few relatively simple op\u00adtimizations we could bypass \nthe most critical performance bottlenecks. The .rst optimization is that we made ObjectReference a compact \nclass, which means that the object header of its in\u00adstances consists of only a single 32-bit word and \ncontains the index of its class in the compact classes array. This makes object references small, and \nmore importantly, it allows the virtual machine to check whether an object is an object ref\u00aderence or \na real object by looking at the object header alone. The e.ciency of this check is especially important \nbecause we do not represent every object as an object reference. One reason for this is that there are \nobjects such as integers, .oats, points, arrays, and strings that are instantiated very frequently, but \nusually use the default policy for instantia\u00adtion (i.e., the policy associated with the name basicUse). \nOur implementation addresses this issue by allowing the pro\u00adgrammer to integrate the default encapsulation \npolicy into the method dictionary. To do this, we extended the rep\u00adresentation of classes so that each \nclass has two method dictionary pointers that by default both point to the ordi\u00adnary method dictionary. \nHowever, if the programmer tells the class to integrate the default encapsulation policy, the second \npointer points to the integrated method dictionary, which is a method dictionary that maps all the selectors \n(including superclass selectors) that are declared as callable by the default policy to the corresponding \nmethod. This has the advantage that all the instances of these fre\u00adquently used classes do not need to \nbe wrapped by an in\u00adstance of ObjectReference as long as they use the default en\u00adcapsulation policy. \nBesides the fact that this avoids the over\u00adhead for creating the wrapper, it also avoids any additional \noverhead for message sending. This is because we changed the virtual machine so that it uses the pointer \nto the inte\u00adgrated dictionary for all the object-sends to unwrapped ob\u00adjects, whereas it uses the pointer \nto the ordinary dictionary for all the self-and super-sends as well as for object-sends to wrapped objects. \nSince classes by default associate both of these pointers with the ordinary dictionary, this change to \nthe virtual machine does not a.ect classes that do not integrate their default policy. The downside of \nthis optimization is that integrating all the callable selectors into a method dictionary uses more mem\u00adory \nand requires additional care to keep the dictionary en\u00adtries consistent when the default policy and the \nclass are modi.ed. However, as our current implementation uses this optimization for only a dozen or \nso classes (less than 1% of all the classes in the Squeak 3.7 image), the additional memory consumption \nis negligible. 6.2.3 Method Lookup and Execution As we have explained above, our implementation creates \nvir\u00adtually no overhead to the message lookup in case of self-and super-sends. The same holds for object-sends \nthat are sent to instances that use the integrated default policy. However, in case of object-sends to \nobjects with an arbitrary encapsu\u00adlation policy, the virtual machine has to perform a lookup in both \nthe identity set representing the encapsulation policy and in the method dictionary. To reduce the overhead \nassociated with these two lookups, we extended the method lookup cache so that it takes into account \nnot only the selector and the class of the receiver, but also the encapsulation policy. If an entry is \nfound that matches all three of these parameters, we are done and can immediately execute the associated \nmethod without per\u00adforming a real lookup at all. If the found entry matches only two parameters, we have \nto do a lookup in either the identity set representing the encapsulation policy or in the method dictionary. \nOnly in the worst case when there is no match at all do we actually perform both lookups. If the method \nlookup yields an ordinary (non-primitive) method, we can switch context and execute the method as usual, \nno matter whether the receiver and the arguments on the stack are object references or real objects. \nHowever, in the case of primitives, we need to be more careful. This is because it may or may not be \nnecessary to unwrap the re\u00adceiver and the argument before proceeding. The same holds for byte-codes. \nAs an example, consider the primitive at:put:, which is used to insert an object into an array at a certain \nindex. When this primitive is executed, the receiver, the index and the Benchmark Orig. image OOE image \nTiny benchmark (byte-codes) 13.0 13.0 Tiny benchmark (sends) 10.0 15.0 STones80 (low-level) 12.6 12.9 \nSTones80 (medium-level) 12.7 17.7 Collection benchmark 13.0 17.3 Squeak MacroBenchmark 10.4 13.7 Average \n12.0 14.9 Table 1: Performance overhead (in percent) of the modi.ed Squeak virtual machine running an \noriginal image and an image that extensively uses OOE. object to be inserted are on the stack. Since \nthe primitive expects the receiver to have the format of an array, it needs to be unwrapped. The same \nholds for the index, which needs to be converted into a C-integer. However, the object to be inserted \nmust not be unwrapped. Instead, it must be inserted as a wrapped object reference to ensure that the \nreal object does not leak out when the programmer retrieves the reference from the array. 6.3 Costs \nIn this section we evaluate the costs of our implementation in terms of execution speed and memory consumption. \n6.3.1 Execution Speed To evaluate the runtime overhead of our implementation, we have compared the performance \nof the modi.ed Squeak vir\u00adtual machine with the original virtual machine by means of 6 benchmarks5 . \nAs a reference, we .rst executed the bench\u00admarks in a Squeak 3.7 image on top of a copy of the original \nSqueak virtual machine (version 3.6.2), which we compiled using gcc 2.95.2. Then, we executed the same \nbenchmark in the same image using our modi.ed virtual machine, which had been compiled under identical \nconditions. Finally, we modi.ed the image so that it made extensive use of encap\u00adsulation policies, and \nthen again executed the benchmarks on top of the modi.ed virtual machine. Table 1 shows the results of \nthis comparison. The num\u00adbers in the second column show the slowdown (as a percent\u00adage) that we encountered \nwhen we ran the benchmarks in the original Squeak image on our modi.ed virtual machine. Since this image \ndoes not associate encapsulation policies with any instances (so wrapper objects are used), these val\u00adues \nare a good indication of the performance penalty that is caused by our virtual machine modi.cations. \nIn contrast, the numbers in the third column show the slowdown that we encountered when we ran the benchmarks \nin an image that applies an encapsulation policy to virtually all the objects involved in the benchmarks. \nThis means that the overhead includes the time that is necessary to create all the neces\u00adsary ObjectReference \ninstances, to wrap and unwrap the real objects, and to check whether the object-sends are actually valid. \nThe .rst two rows show the results of two micro-benchmarks that are used to get a raw idea of how many \nbytecodes 5All the benchmarks were executed under Windows XP on a notebook equipped with a 1.2 GHz Pentium-III \nMobile Processor and 512 MB RAM. and message sends the virtual machine can execute per sec\u00adond6 . STones80 \nis a benchmark that is available for many Smalltalk-80 dialects. Whereas the low-level version mainly \ninvolves arithmetic operations, array operations, block op\u00aderations and object creation operations, the \nmedium-level version also performs recursive calls, collection and stream operations. The collection \nbenchmark is speci.cally written for the purpose of evaluating the performance of the OOE virtual machine, \nand it makes heavy use of nested collec\u00adtions. The result in the third column was measured in an image \nwhere every collection instance is wrapped. The only exception are instances of the class Array, which \nintegrates the default encapsulation policy (see Section 6.2.2). The last benchmark is a Squeak macro-benchmark \nthat mea\u00adsures the time for opening, moving, resizing, and closing Smalltalk browsers on the screen. \nThe result in the third col\u00adumn was measured in an image where most of the involved objects such as every \nmorph (the GUI objects of Squeak), every collection, and every browser is wrapped. Again, we used the \nintegrated default policies for basic classes such as Integer, Strings, Array, Point, and Rectangle. \nAs an overall result, these benchmarks show that the total performance overhead for extensive use of \nOOE in Squeak is about 15%. Given that we implemented our prototype from scratch in just a few days, \nthat we have not yet done any performance tuning, and that we did not have any previous experience with \nthe Squeak virtual machine (or with any other Smalltalk VM), this seems to be an acceptable result. Nevertheless, \nwe believe that there is still a large potential for improvements. One indication for this is the fact \nthat the performance penalty of our modi.ed virtual machine is about 12% even if we do not use any encapsulation \npolicies and wrapper objects at all. This means that the majority of the overhead is caused by checking \nwhether an object is wrapped and maintaining the extended method lookup cache, whereas only a small amount \nof the time actually goes into the additional method lookup, the creation of the reference objects and \nthe wrapping/unwrapping. 6.3.2 Memory Consumption Although our implementation strategy does not require \nthe duplication of any source code or byte code, it does increase memory consumption for the following \nreasons. For each re-implemented method, an internal symbol has to be maintained in the translation \ntable, and an additional association objects is inserted into the method dictionaries.  Each class has \nan additional .eld to contain the in\u00adtegrated method dictionary. However, less than 1% of the classes \nactually maintain such a method dictio\u00adnary; in the vast majority of classes this .eld points to the \nordinary method dictionary.  An identity dictionary containing all the callable se\u00adlectors needs to \nbe maintained for each encapsulation policy that is associated with an object-reference.  6The reference \nvalues measured using the original Squeak virtual machine are 87 252 897 byte-codes/sec and 2 465 693 \nsends/sec. At runtime, an instance of ObjectReference is used whenever a (non-integrated) encapsulation \npolicy is applied to an object. Note that our implementation ensures that ObjectReferences are never \nnested. We are also experimenting with a cache that stores Ob\u00adjectReferences so that they can be reused \nif the same encapsulation policy is applied to a particular object more than once. The overall increase \nin memory due to OOE depends on how encapsulation policies are used. Since we have not yet .nished a \nconsistent refactoring of the Squeak image using OOE, we are not yet in a position to quantify it.  \n7. EVALUATION In Section 2.4, we indicated that our goal was to de.ne an encapsulation mechanism that \nwas expressive, simple, and appropriate for dynamic languages. In this section we ex\u00adamine how well OOE \nmeets these goals. By way of assessment, we will look again at the problems from Section 2. If the problem \ncan be solved at all, we can conclude that OOE is adequately expressive. Determining if the solution \nis simple and appropriate is more subjective, and here is it possible that the reader may reach di.erent \nconclusions from the authors. 7.1 The Problem of Interdependence Class interdependence caused by inheritance \nand instanti\u00adation can be controlled using OOE to the exact degree re\u00adquired. Returning to the example \nof the check method (see Section 2.2.1), recall that we wished to introduce an internal method check \ninto a class C for the purposes of refactoring. OOE allows us to make sure that this internal method \nis not accidentally overridden and called in any clients, whether they are subclasses or users of instances \nof C. This is done by making sure that the new method check is not included in any of the existing encapsulation \npolicies that are o.ered by the class C. Note that although this completely hides check from all existing \nclients, OOE still allows us to make this method available to future clients by o.ering a new encap\u00adsulation \npolicy, for example fullExtend, that grants access to the method check. Furthermore, if the override \nright o is explicitly removed from the policy that C uses to inherit from its superclass B, then C does \nnot accidentally override a method with the same name even if it is introduced into B (and declared as \noverridable) at a later date. Is this solution simple, and is it appropriate for a dynamic language? \nOn the surface, it certainly does not seem simple when compared to an ad hoc solution such as labeling \ncheck as private. However, such an annotation does not seem to .t into the semantics of a dynamic language. \nGiven the variety of di.erent scenarios in which a class can be used, it indeed seems that to give it \na systematic semantics, one would need to invent a way of de.ning multiple interfaces for a single class \n in other words, we would need to invent a model containing something very like encapsulation policies! \nThus, we argue that we have in fact achieved conceptual sim\u00adplicity. OOE uses a conceptually simple and \nuniform way to specify access rights, and it gives them a simple and stati\u00adcally observable semantics \nthat makes it easy to understand and reason about the code. Following the Smalltalk practice of integrating \nrich tool support into the programming envi\u00adronment, it is now a matter of designing appropriate tools \nto improve the practicality of our approach. For instance, we could provide usability similar to that \nof keyword-based techniques if an improved browser displayed each method to\u00adgether with the corresponding \nencapsulation attributes and allowed the programmer to change these attributes directly in this display. \nOOE speci.cally addresses the needs of incremental devel\u00adopment where requirements are changing and cannot \nalways be narrowed down in advance. This is because it allows the class that provides some behaviour \nto o.er its future clients a range of encapsulation policies from which to choose. Thus, an appropriate \npolicy can be chosen at the time that the be\u00adhavior is reused, not at the time that it is de.ned. In \nother words, encapsulation decisions are late-bound, which we feel is entirely appropriate for a dynamic \nlanguage. 7.2 The Problem of Fragile Data Structures The problem of fragile data structures can also \nbe solved using encapsulation policies, as we have already shown in Section 4.5.2 for the submorphs example. \nIs the solution simple and appropriate? We have added a single language element to Smalltalk, selfWithPolicy:, \nwhich returns a refer\u00adence to self with a di.erent set of access rights. This is the only way in which \naccess rights can be ampli.ed, and be\u00adcause it gives rights only to self, it can be fully encapsulated. \nOur approach also seems appropriate for the dynamic and lightweight character of the language because \nit does not require type annotations; instead, changing the interface of an object reference is performed \nby sending a message like asReadonly. It is true that this approach places on the programmer the burden \nof de.ning the necessary interface ampli.cation or restriction methods methods like asReadOnly and asEnu\u00admeration. \nMore seriously, the programmer must also en\u00adsure that the rights granted by the various methods and the \nmethods included in the various policies correspond. For ex\u00adample, if the enumeration policy were to \naccidentally con\u00adtain the right to call asReadOnly, the distinction between readOnly and enumeration \nwould be e.ectively lost, since any user possessing the enumeration right could also acquire the readOnly \nright. Without ignoring the dangers of such accidents, we believe that they indicate a need for tool \nsupport rather than a con\u00adceptual shortcoming. It is easy to imagine a tool that would detect when a \nrestrictive policy contained a method that gave access to a more liberal policy. More generally, a tool \nthat lets the programmer de.ne a lattice of encapsulation policies, either by writing constraints or \nby drawing a dia\u00adgram, could construct the appropriate policy de.nitions and conversion operations and \nensure that they correspond. We see a similarity here with the various tools that automati\u00adcally generate \ninstance variable access methods. Because in both cases the underlying semantics is simple (rights associ\u00adated \nwith references in the one case, and the fully protected nature of instance variables in the other), \nthe programmer soon becomes accustomed to de.ning the appropriate meth\u00adods, and does not feel the need \nto extend the language with features such as public instance variables.  8. RELATED WORK The concept \nof Composable Encapsulation Policies as a .ex\u00adible way of specifying and managing the access rights of \nmethods was introduced by Sch\u00a8arli et al. at ECOOP 2004 using a set-theoretic and programming language-independent \nmodel [27]. The ECOOP paper focuses on the limitations of keyword based approaches and shows how they \nare over\u00adcome by encapsulation policies. Furthermore, although it contains a proposal for specifying \nand managing encapsu\u00adlation policies in Smalltalk, it does not discuss how using such encapsulation policies \ncould or should a.ect the mean\u00ading of a Smalltalk program. Speci.cally, the prior work does not address \nthe meaning of the di.erent access rights in a dynamically typed language, nor does it suggest that en\u00adcapsulation \npolicies could be used to solve common object encapsulation problems by associating encapsulation poli\u00adcies \nwith object references rather than with objects. MUST [30] is another encapsulation model that has been \nproposed for the language Smalltalk. The main di.erence from our model is that it is only concerned with \nmodule en\u00adcapsulation and that it is much more static. Unlike OOE, MUST does not allow encapsulation \ndecisions to be late bound , that is, postponed until an individual client is about to use the encapsulated \nstructure. Instead, it requires all clients in a prede.ned category (i.e., superclasses, subclasses, \nunrelated classes) to access the class through the same in\u00adterface. Furthermore, it requires the implementor \nto decide between di.erent forms of self-sends (e.g., locally-bound self\u00adsend and regular self-send) \nwhen a class is written. In con\u00adtrast, OOE has only one form of self-send and allows each client of a \nclass to decide how they should be bound by selecting an appropriate encapsulation policy. The developers \nof Self also proposed an encapsulation model that addressed module encapsulation problems [12]. Al\u00adthough \nSelf is a prototype-based language, the Self proposal is similar to the approach based on the dynamic \ntype of the receiver discussed in Section 5.1.2. As a consequence, it is hard to implement e.ciently. \nAnother major di.erence from OOE is that the Self encapsulation proposal deals only with the question \nof which method can be called from where, and not the harder problem of choosing between re-implementing \nand overriding. The Jigsaw modularity framework, developed by Bracha in his doctoral dissertation [10], \nde.nes a variety of mod\u00adule composition operators that control how attributes of a module are encapsulated. \nThese operators give a program\u00admer .ne-grained control over module encapsulation, and al\u00adlow the client \nto customize the access rights. However, the semantics of static binding and re-implementation is not \nbased on the distinction between self-sends and object\u00adsends. Furthermore, there is no support for addressing \nob\u00adject-encapsulation problems. Hogg et al. note that object aliasing has been recognized as a problem \nin both practical programming and formal veri\u00ad.cation for many years [18]. They also explain why many \nexisting solutions to the aliasing problem tend to be too conservative to be useful in practice. Subsequently, \nthere has been a lot of work on new and more .exible solutions to aliasing problems. Some of these solutions \nuse various forms of type annotations on pointer variables. An early form of this concept is the C++ \nkeyword const, which prevents a reference from being changed. Other, more sophisticated, models provide \nannotations to declare a reference as unique (i.e., it is the only reference to the object) and borrowed \n(i.e., it is a reference that may not be stored into an object s in\u00adstance variables) [3, 9, 17, 20]. \nBoyland gives an excellent overview and a comparison of the di.erent annotation-based proposals [9], \nand suggests that annotations should not be considered individually but as a part of a general capability \nsystem for pointers. Although these proposals are, like OOE, based on de.ning access rights to object \non the granularity of references, there are many di.erences. One of the most signi.cant di.erences is \nthat they are based on annotating pointer variables with a .xed set of prede.ned access rights, such \nas read, write, and exclusiveRead. In contrast, OOE controls which messages can be passed to an object \nreference, allowing us to obtain object references with an unlimited set of customized access rights, \nwhich we represent as encapsulation policies. While this di.erence makes reasoning about capabilities \neas\u00adier and allows them to model certain properties (e.g., unique\u00adness) that cannot be modeled using \nencapsulation policies, they are fundamentally not object-oriented unless one s universe of objects \nunderstand only two messages, read and write. OOE is integrated into the message-based character and \nsemantics of dynamically typed languages like Small\u00adtalk, and it avoids type annotations, which do not \nfeature in dynamic languages. Furthermore, OOE addresses both ob\u00adject and module encapsulation problems \nin a uniform way, while capabilities address object encapsulation only. Ownership types are another approach \nto the aliasing prob\u00adlem [8, 13, 25]. Unlike capabilities and OOE, the basic con\u00adcept of this approach \nis to prevent aliases rather than con\u00adtrolling what can be done through them. On the one hand, this has \nthe advantage that one can state that a certain object should be owned by an aggregate and is therefore \nautomatically protected (by a sophisticated type system) from being passed outside. This avoids the problem \nthat one might accidentally pass out an unprotected reference, and makes the approach easy to reason \nabout. On the other hand, these same safety guarantees make these approaches more restrictive, and even \nrecent suggestions for .exible alias protection still do not allow one to implement many com\u00admonly used \ndata structures [20]. Barnett and Naumann tackle some of these limitations by using friendship systems \nthat allow state dependence across ownership boundaries [5]. Noble et al. proposed an encapsulation model \nbased on ob\u00adject ownership for Self [24]. In comparison to OOE, this model does not provide help for \nmodule encapsulation prob\u00adlems and is too restrictive to express some commonly-used programming patterns \nsuch as external iterators. Where it can be applied, it gives the programmer more guarantees, but one \nhas to expect a relatively high runtime overhead, particularly for the argument rule. The delegation-based \nprogramming language E [14] features facets, which restrict the methods that can be sent to a cer\u00adtain \nobject. Although facets and encapsulation policies have a similar purpose, there are several di.erences. \nFacets are written as wrapper objects that simply delegate the valid method calls to the real object. \nThis means that in con\u00adtrast to encapsulation policies, facets contain actual code. Furthermore, facets \nonly control whether a method can be called, but not whether it can be re-implemented or overrid\u00adden. \nThis is related to the fact that E is based on delegation and simulates traditional inheritance by parameterizing \nthe object constructor with an argument to contain self. 9. SUMMARY AND FUTURE WORK We have introduced \nan encapsulation model for dynami\u00adcally typed languages that addresses both module encap\u00adsulation problems \n(i.e., interdependencies between di.er\u00adent classes) and object encapsulation problems (i.e., frag\u00adile \ndata-structures) in a uniform way. Our model is based on two cornerstones. First, we use encapsulation \npolicies to capture all of the encapsulation aspects of both classes and objects, which makes our model \nuniform and conceptually simple. Second, we de.ne the meaning of message passing in the presence of encapsulated \nobjects by introducing the dis\u00adtinction between two conceptually di.erent kinds of message send: internal \nsends , which are used for sending a message to oneself without crossing the encapsulation boundary, \nand external sends , which are used for sending a message to another object through the associated encapsulation \npolicy. In combination, these two cornerstones make our model par\u00adticularly appropriate for dynamically \ntyped languages. This is because of its conceptual simplicity and uniformity, and the absence of type \nannotations. Instead, it relies on sending messages to objects both for de.ning and for controlling the \noperations that can be accessed through individual object references. We have presented our model in \nterms of the language Small\u00adtalk and illustrated it with various examples. We believe that it is equally \napplicable to other dynamic object-oriented languages such as Ruby. We have given a detailed discussion \nof the motivation for our design decisions, in particular with regard to static understandability of \nthe program code, and we have given a detailed description of our implementation in Squeak Smalltalk. \nWe also presented di.erent bench\u00admarks that show that the performance penalty imposed by our model is \nmoderate. We are about to refactor more Squeak code using OOE. This will serve as the basis for a more \ndetailed evaluation of the practicality of our approach. We also want to experiment with applying our \nmodel to traits [26]. This looks like a very promising combination because our encapsulation model has \nbeen designed to be well-suited to non-standard composition mechanisms, and in particular to multiple \ncomposition of be\u00adhavior. Furthermore, as mentioned in Section 7, we plan to provide tool support for \nconstructing and manipulation of encapsulating encapsulation policies, for expressing recur\u00adring encapsulation \npatterns more easily, and for automatic detection of possible encapsulation holes . Acknowledgments The \nwork described in this paper has been partially sup\u00adported by the Swiss National Foundation under the \nproject Tools and Techniques for Decomposing and Composing Software (SNF Project No. 2000-067855.02, \nOct. 2002 -Sept. 2004), and by the National Science Foundation of the United States under awards CCR-0098323 \nand CCR\u00ad0313401. We are grateful to our colleagues at SCG and OGI for valuable discussions, and in particular \nto Phil Quitslund for drawing the diagrams. 10. REFERENCES [1] O. Agesen, L. Bak, C. Chambers, B.-W. \nChan, U. H\u00a8olzle, J. Maloney, R. B. Smith, D. Ungar, and M. Wolczko. The SELF 4.0 Programmer s Reference \nManual. Sun Microsystems, 1995. [2] J. Aldrich, V. Kostadinov, and C. Chambers. Alias annotations for \nprogram understanding. In Proceedings OOPSLA 2002, pages 311 330. ACM Press, Nov. 2002. [3] P. S. Almeida. \nBalloon types: Controlling sharing of state in data types. In Proceedings ECOOP 97, pages 32 59. Springer \nVerlag, June 1997. [4] K. Arnold and J. Gosling. The Java Programming Language. Addison Wesley, 1996. \n [5] M. Barnett and D. A. Naumann. Friends need a bit more: Maintaining invariants over shared state. \nIn Proceedings MPC 2004, July 2004. To appear. [6] K. Beck. Extreme Programming Explained: Embrace Change. \nAddison Wesley, 2000. [7] E. Blake and S. Cook. On including part hierarchies in object-oriented languages, \nwith an implementation in Smalltalk. In Proceedings ECOOP 87, pages 41 50. Springer-Verlag, June 1987. \n[8] C. Boyapati, B. Liskov, and L. Shrira. Ownership types for object encapsulation. In Proceedings POPL \n03, pages 213 223. ACM Press, 2003. [9] J. Boyland, J. Noble, and W. Retert. Capabilities for aliasing: \nA generalisation of uniqueness and read-only. In Proceesings ECOOP 2001, pages 2 27. Springer Verlag, \nJune 2001. [10] G. Bracha. The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. \nPh.D. thesis, Dept. of Computer Science, University of Utah, Mar. 1992. [11] K. B. Bruce, L. Cardelli, \nG. Castagna, T. H. O. Group, G. T. Leavens, and B. Pierce. On binary methods. Theory and Practice of \nObject Systems, 1(3):221 242, 1995. [12] C. Chambers, D. Ungar, B.-W. Chang, and U. H\u00a8olzle. Parents \nare shared parts of objects: Inheritance and encapsulation in self. Lisp and Symbolic Computation, 4(3):207 \n222, July 1991. [13] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. \nIn Proceedings OOPSLA 98, pages 48 64. ACM Press, 1998. [14] The E Language. http://www.erights.org/. \n[15] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented \nSoftware. Addison Wesley, Reading, Mass., 1995. [16] A. Goldberg and D. Robson. Smalltalk 80: the Language \nand its Implementation. Addison Wesley, Reading, Mass., May 1983. [17] J. Hogg. Islands: Aliasing protection \nin object-oriented languages. In Proceedings OOPSLA 91, volume 26, pages 271 285. ACM Press, Nov. 1991. \n[18] J. Hogg, D. Lea, A. Wills, D. deChampeaux, and R. Holt. The Geneva convention on the treatment of \nobject aliasing. SIGPLAN OOPS Mess., 3(2):11 16, 1992. [19] D. Ingalls, T. Kaehler, J. Maloney, S. Wallace, \nand A. Kay. Back to the future: The story of Squeak, A practical Smalltalk written in itself. In Proceedings \nOOPSLA 97, pages 318 326. ACM Press, Nov. 1997. [20] G. Kniesel and D. Theisen. JAC -access right based \nencapsulation for Java. Software -Practice and Experience, 31(6):555 576, May 2001. [21] P. M\u00a8uller and \nA. Poetzsch-He.ter. Universes: A type system for alias and dependency control. Technical Report 279, \nFernuniversit\u00a8at Hagen, 2001. [22] O. Nierstrasz. A survey of object-oriented concepts. In W. Kim and \nF. Lochovsky, editors, Object-Oriented Concepts, Databases and Applications, pages 3 21. ACM Press and \nAddison Wesley, Reading, Mass., 1989. [23] J. Noble. Iterators and encapsulation. In Proceedings of TOOLS \n00, page 431., June 2000. [24] J. Noble, D. Clarke, and J. Potter. Object ownership for dynamic alias \nprotection. In Proceedings TOOLS 99, Nov. 1999. [25] J. Noble, J. Potter, and J. Vitek. Flexible alias \nprotection. In E. Jul, editor, Proceedings ECOOP 98, Brussels, Belgium, July 1998. Springer Verlag. [26] \nN. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and A. Black. Traits: Composable units of behavior. In Proceedings \nECOOP 2003, pages 248 274. Springer Verlag, July 2003. [27] N. Sch\u00a8arli, S. Ducasse, O. Nierstrasz, and \nR. Wuyts. Composable encapsulation policies. In Proceedings ECOOP 2004. Springer Verlag, June 2004. To \nappear. [28] A. Snyder. Encapsulation and inheritance in object-oriented programming languages. In Proceedings \nOOPSLA 86, pages 38 45. ACM Press, Nov. 1986. [29] P. Steyaert, C. Lucas, K. Mens, and T. D Hondt. Reuse \ncontracts: Managing the evolution of reusable assets. In Proceedings OOPSLA 96, pages 268 285. ACM Press, \n1996. [30] M. Wolczko. Encapsulation, delegation and inheritance in object-oriented languages. IEEE Software \nEngineering Journal, 7(2):95 102, Mar. 1992.   \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Encapsulation in object-oriented languages has traditionally been based on static type systems. As a consequence, dynamically-typed languages have only limited support for encapsulation. This is surprising, considering that encapsulation is one of the most fundamental and important concepts behind object-oriented programming and that it is essential for writing programs that are maintainable and reliable, and that remain robust as they evolve.</p> <p>In this paper we describe the problems that are caused by insufficient encapsulation mechanisms and then present object-oriented encapsulation, a simple and uniform approach that solves these problems by bringing state of the art encapsulation features to dynamically typed languages. We provide a detailed discussion of our design rationales and compare them and their consequences to the encapsulation approaches used for statically typed languages. We also describe an implementation of object-oriented encapsulation in Smalltalk. Benchmarks of this implementation show that extensive use of object-oriented encapsulation results in a slowdown of less than 15 percent.</p>", "authors": [{"name": "Nathanael Sch&#228;rli", "author_profile_id": "81414619373", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "PP79025916", "email_address": "", "orcid_id": ""}, {"name": "Andrew P. Black", "author_profile_id": "81452592387", "affiliation": "Oregon Health & Science University, Portland, OR", "person_id": "PP77027537", "email_address": "", "orcid_id": ""}, {"name": "St&#233;phane Ducasse", "author_profile_id": "81100625020", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "P396541", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028988", "year": "2004", "article_id": "1028988", "conference": "OOPSLA", "title": "Object-oriented encapsulation for dynamically typed languages", "url": "http://dl.acm.org/citation.cfm?id=1028988"}