{"article_publication_date": "10-01-2004", "fulltext": "\n Super and Inner Together at Last! David S. Goldberg Robert Bruce Findler Matthew Flatt School of Computing \nDept. of Computer Science School of Computing University of Utah University of Chicago University of \nUtah Salt Lake City, UT 84112 Chicago, IL 60637 Salt Lake City, UT 84112 goldberg@cs.utah.edu robby@cs.uchicago.edu \nm.att@cs.utah.edu Abstract In an object-oriented language, a derived class may declare a method with \nthe same signature as a method in the base class. The meaning of the re-declaration depends on the language. \nMost commonly, the new declaration overrides the base declaration, per\u00adhaps completely replacing it, \nor perhaps using super to invoke the old implementation. Another possibility is that the base class al\u00adways \ncontrols the method implementation, and the new declaration merely augments the method in the case that \nthe base method calls inner. Each possibility has advantages and disadvantages. In this paper, we explain \nwhy programmers need both kinds of method re\u00addeclaration, and we present a language that integrates them. \nWe also present a formal semantics for the new language, and we de\u00adscribe an implementation for MzScheme. \nCategories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures \ninheritance General Terms Languages Keywords super, inner, inheritance, override, augment  1 Introduction \n In a Java-like language, each method is overrideable by default, so a subclass can replace the functionality \nof a method with ar\u00adbitrarily different functionality. A super form (or its equivalent) allows a subclass \nimplementor to reuse a superclass s method, in\u00adstead of replacing the method entirely. The choice, in \nany case, be\u00adlongs to the subclass implementor. Correspondingly, as illustrated in Figure 1, method dispatch \nfor an object begins at the bottom of the class hierarchy. Java-style overriding encourages the reuse \nof class implementations, since subclass implementors are relatively unconstrained in re-shaping the \nsubclass. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00 \n Figure 2. Beta-style Method Extension In a Beta-like language, a method may be augmented, but the \nmethod cannot be replaced arbitrarily. A class enables method augmentation by calling inner, but it may \nperform work before and after the inner call, and it may skip the inner call altogether. The choice, \nin any case, belongs to the superclass implementor. Correspondingly, as illustrated in Figure 2, method \ndispatch for an object begins at the top of the class hierarchy. Controlled method extension encourages \n(though does not guarantee) subclasses that are behavioral subtypes [1, 21, 22] of the base class, since \nsubclass implementors are relatively constrained. Although programmers can simulate each form of method \nexten\u00adsion using the other, simulation patterns are clumsy. The patterns require that a programmer invent \nextra methods and give them dis\u00adtinct names, and the protocol for using and overriding or augment\u00ading \nmethods becomes a part of the documentation, rather than the declared structure of the code. Furthermore, \nchanging an existing method from one form of extension to the other requires modi.ca\u00adtions to existing \ncode. Some researchers, including Cook [7] and Clark [6], have observed the dual roles of super and inner, \nand they have developed uni.ed object models with constructs that encompass both. We have taken a more \ndirect approach, adding Beta-style methods and inner to an existing Java-style language. Implementing \nour combination of super and inner requires only modest changes to a typical compiler and run-time system. \nIn particular, the compilation of method and super dispatching is unchanged, and the implementation of \ninner is an adaptation of method dispatch (using an auxiliary dispatch table). Furthermore, our system \ndoes not constrain a method permanently to either Java\u00adstyle or Beta-style re.nement. That is, a derived \nclass may use a different style of method overriding from its super class. Since Beta-style method overriding \nis designed to help enforce in\u00advariants in the code, it trumps Java-style method overriding in our design. \nThat is, a Java-style method extension only replaces the behavior of the method up to the nearest Beta \nmethod. In contrast, a Beta-style method controls the behavior of all of its subclasses. Consider the \nchain of method extensions in Figure 3. Three sub\u00adchains of Java-style method extensions appear as three \ndistinct sets of upward arrows in the .gure. Each beta method, meanwhile, introduces a point of control \nover all later subclasses. This control appears in the .gure as long-jumping arrows that delineate the \nthree sets. The number to the right of each method shows its position in the overall order of execution. \nWe have implemented this combination of super and inner in MzScheme [12], and our design was motivated \nby problems building the DrScheme programming environment [11] using MzScheme s object system. In general, \nwe .nd that most uses of the object system favor .exible reuse over behavioral control, which supports \nour decision to start with a Java-style object sys\u00adtem. We have noted many exceptions, however, where \nour code is made more complex or less reliable by the possibility of uncon\u00adstrained method overriding. \nWe believe that our code will become cleaner and more reliable by using both kinds of methods, and the \nearly results are promising. Section 2 presents a programming task that can be implemented with only \nJava-style methods or only Beta-style methods, but it is best implemented with a combination. Section \n3 describes in detail our method-dispatch algorithm to support both kinds of methods in a single class \nderivation. Section 4 de.nes a formal model of our language. Section 5 describes our implementation in \nMzScheme and initial experience. 2 The Case for Combining Super and Inner Consider building a library \nof GUI widgets, including basic win\u00addows, bordered panels, and clickable buttons. All widgets corre\u00adspond \nto areas on the screen, and they all react in various ways to mouse and keyboard actions. Furthermore, \nas the widget set grows, new widgets tend to resemble existing widgets, but with extra be\u00adhavior. For \nall of these reasons, a class-based, object-oriented lan\u00adguage is an excellent choice for implementing \nthe widget library. One possible class hierarchy for widgets is shown in Figure 4: The generic Window \nclass includes a paint method to draw the content of the window. Subclasses of Window re.ne the paint \nmethod to draw speci.c kinds of widgets. Figure 3. BETAJAVA Method Re.nement  Many widgets require \na border, so BorderWindow re.nes Window s paint to draw a border around the window. Sub\u00adclasses of BorderWindow \nare expected to re.ne paint further to draw inside the border, but they are not expected to replace paint \nentirely, which would omit the border.  The Button class of BorderWindow implements a clickable widget. \nIt adds the onClick method, which is called when the user clicks inside the widget s border. The Button \nclass also re.nes paint to provide a default button look, but subclasses may de.ne an entirely different \nlook for the button, as long as the border is intact.  The ImageButton class re.nes the paint method \nof Button to draw a speci.c image for the button, supplanting the default button look (except for the \nborder).  Figure 4. Class hierarchy for GUI classes The HighlightButton class, in contrast, builds \non the default button look, but adds a dark blue background behind the label and a translucent texture \nover the label. Implementing this class hierarchy in either Java (with super) or Beta (with inner) is \nstraightforward, and yet the results are not entirely satisfactory. We consider each possibility in the \nfollow\u00ading two sub-sections, and then show how super and inner together provide a more satisfactory implementation \nof the hierarchy. 2.1 Widgets in Java To implement Figure 4 in Java, we start with a Window class whose \npaint method merely erases the background by painting it white, and a BorderWindow class that re.nes \nthe paint method of Window to draw a border around the window: class Window { ... void paint() {. . . \n; // paint the background } } class BorderWindow extends Window { ... void paint() {super.paint(); // \npaint background . . . ; // draw a border } }  The paint method in BorderWindow overrides the method \nin Win\u00addow, which means that when paint is called on an instance of Bor\u00adderWindow, control jumps to the \npaint method in BorderWindow, as opposed to Window. The super call in BorderWindow then ex\u00adplicitly dispatches \nto paint in Window to paint the background. The next class is Button, which further re.nes paint: class \nButton extends BorderWindow { ... void paint() {super.paint(); // paint background, border . . . ; // \ndraw a button label } }  Here, again, the new paint in Button uses super to paint at .rst like BorderWindow. \nIn the BorderWindow case, however, this super call was optional; we could instead have chosen to paint \nBorder-Window backgrounds differently. A subclass of BorderWindow is always supposed to call BorderWindow \ns paint to ensure that the window has a border. This constraint is merely part of the docu\u00admentation \nfor BorderWindow; it cannot be enforced by Java. This problem becomes somewhat worse as we move to the \nImage-Button class: class ImageButton extends Button { ... void paint() {super.paint(); // paints background, \nborder and label! . . . ; // draw image, somehow blotting out the label } } Since ImageButton is a \nsubclass of BorderWindow, it is supposed to call super to ensure that a border is drawn. But calling \nsuper also draws a button label, and ImageButton intends to replace the label with an image. C++ [25] \noffers a solution to the immediate problem in Image-Button. Instead of using super.paint(), ImageButton \ncould re\u00adfer directly to BorderWindow::paint(). The other problem re\u00admains, i.e., nothing forces paint \nin ImageButton to call BorderWin\u00addow::paint(). A more general solution is to simulate Beta-style methods \nin Java. A programmer can designate paint as .nal in BorderWindow and have it call a new method, paintInside. \nSubclass authors cannot override paint, ensuring that the border is always drawn, but they can override \npaintInside to rede.ne the interior painting. Unfor\u00adtunately, this solution forces programmers to deal \nwith different names for the same functionality in different parts of the class hi\u00aderarchy: subclasses \nof Window are expected to override the paint method to add functionality, but subclasses of BorderWindow \nare expected to override the paintInside method. Besides increasing the burden on the programmer, these \ndifferent names limit the ways in which mixins [3, 5, 14] can be applied, since mixin composition typically \nrelies on matching method names. Furthermore, if paint is split into a .nal paint and a paintInside method \nafter many classes have been derived, then names must be changed throughout the hi\u00aderarchy below BorderWindow \nto accommodate the split. Assuming that we split paintInside from paint, we can .nish our widget set \nin Java as follows: class ImageButton extends Button { ... void paintInside() {. . . ; // draw image \n(don t call super for label) } } class HighlightButton extends Button { ... void paintInside() {. . \n. ; // replace the background with dark blue super.paintInside(); // draws the label . . . ; // draw \nlight blue shading on top of the label } }  The HighlightButton class calls super to paint the default \nbutton label, but this class exploits its control over the timing of the super call. In particular, it \ndraws the new background, then calls super to draw text on the new background. Reversing the order clearly \nwould not work. This last example, in particular, illustrates the overall philosophy of class extension \nin Java-like languages: subclass implementors know better. Methods are overrideable by default, so they \ncan be replaced completely in a subclass, which tends to maximize the reuse of a class hierarchy. The \nonly way that a superclass can in\u00adsist on speci.c behavior, preventing subclasses from re.ning it, is \nto declare a method .nal. The idiom of a .nal method that calls a regular method (like our paint/paintInside \nexample) appears com\u00admonly used in C++ and Java programs, inspiring design patterns such as the Template \nMethod [15]. As we demonstrate in the next section, Beta-style method extension can more directly express \na programmer s intent in such cases. 2.2 Widgets in Beta In Beta, the pattern is the sole abstraction \nmechanism, and patterns are used to express types, classes, and methods. We are mainly interested in \npatterns as a class mechanism, so for our examples, we use a Java-like syntax with a Beta-like semantics. \nThe essential difference of Beta is the absence of super and the presence of inner. In our .rst two classes, \nWindow explicitly al\u00adlows subclasses to add functionality to paint by using inner: class Window { ... \nvoid paint() {. . . ; // paint the background inner.paint(); } } class BorderWindow extends Window { \n... void paint() {. . . ; // draw a border } }  When the paint method is called on an instance of BorderWindow, \ncontrol jumps to the implementation of paint in Window. At the point where Window s paint uses inner, \ncontrol jumps to paint in BorderWindow. If an instance of Window is created, the inner in paint has no \neffect. This implementation of Window is not quite the same as our im\u00adplementation in Java, because the \nBeta Window always paints the background, but the painting was optional in the Java Window class. To \n.x this, we can simulate Java-style methods in Beta, just as we could simulate Beta-style methods in \nJava. In this particular case, we create a paintBackground method and only call it directly in Window \ns paint when inner would do nothing. To accommodate such code, we introduce a new variant of inner that \nhas an else statement, which is executed only if the inner has no target. class Window { ... void paintBackground() \n{ . . . ; // paint the background } void paint() {inner.paint() else paintBackground(); } } class BorderWindow \nextends Window { ... void paint() {paintBackground(); . . . ; // draw a border inner.paint(); } }  When \npaint is called for an instance of Window, the inner call has no target (i.e., no subclass), so paintBackground() \nis executed. When paint is called for an instance of BorderWindow, inner in Window jumps to paint in \nBorderWindow, which elects to paint the background by calling paintBackground(). The new BorderWindow \nalso contains its own inner call in paint, so that the content of the window can be painted by subclasses. \nThus, Button is implemented as follows: class Button extends BorderWindow { ... void paintLabel() {. \n. . ; // draw a button label } void paint() {inner.paint() else paintLabel(); } }  Since the BorderWindow \nclass does not give Button the option to skip border painting, the implementor of Button cannot acciden\u00adtally \nomit the border by forgetting to call super.paint(). Meanwhile, Button uses the same inner programming \npattern as Window to make label painting optional in subclasses. Much like introducing paintInside in \nJava to give the superclass control, in\u00adtroducing paintLabel in Beta gives subclasses control. Also, \nas in Java, this programming pattern proliferates method names, so it is similarly unfriendly to programmers \nand mixins. More signi.\u00adcantly, this programming pattern must be used whenever a subclass should be able \nto completely replace the functionality of a method, and our experience suggests that such methods are \nthe rule rather than the exception. With paintLabel split from paint, we can .nish our widget set in \nBeta as follows: class ImageButton extends Button { ... void paint() { . . . ; // draw image (don t call \npaintLabel) } } class HighlightButton extends Button { ... void paint() {. . . ; // replace the background \nwith dark blue paintLabel(); // draws the label . . . ; // draw light blue shading on top of the label \n} }  The HighlightButton class calls paintLabel to paint the default but\u00adton label, again exploiting \nits control over the timing of the paint-Label call. As written, these methods do not allow re.nement \nin further subclasses, which would require the introduction of more paintLabel-like methods. The necessity \nof methods like paintLabel highlights the overall phi\u00adlosophy of class extension in Beta-like languages: \nsuperclass im\u00adplementors know better. Methods are not overrideable by default, so they cannot be replaced \ncompletely by subclasses, which tends to maximize the reliability of a class hierarchy. The only way \nthat a superclass can release its control over behavior is to use inner with the default work in a new \nmethod. As we demonstrated in the pre\u00advious section, Java-style method extension more directly express \na programmer s intent in such cases. 2.3 Widgets in a Beta/Java Combination In a suf.ciently large \nprogram, the Java philosophy is right at times, and the Beta philosophy is right at other times; sometimes \nthe subclass implementor knows better, and sometimes it is the su\u00adperclass implementor. By including \nboth Java-style and Beta-style method re.nement in a programming language, we can support dif\u00adferent \nphilosophies for different parts of the program. Indeed, these philosophies can be mixed at a .ne granularity \nby allowing a pro\u00adgrammer to annote individual method implementations as java or beta.1 The resulting \nsystem is consistent and, we believe, concep\u00adtually simple. Since the initial Window class was more cleanly \nimplemented in Java, we begin our widget implementation with a java implemen\u00adtation of paint: 1We expect \nthat any realistic language will have better keywords than java and beta, of course.  Figure 5. Hierarchy \nwith both Java-and Beta-style methods class Window { ... java void paint() {. . . ; // paint the background \n} }  The java annotation indicates that a subclass can override this method. If the overriding method \nwants to use the original method, it can use super. The BorderWindow class overrides paint, but its own \nimplemen\u00adtation should never be overridden completely in later subclasses. That is, Beta more neatly \nimplements the paint method for Bor\u00adderWindow, so we annotate the implementation with beta and use inner \nin the body: class BorderWindow extends Window { ... beta void paint() {super.paint(); // paint background \n. . . ; // draw a border inner.paint(); } }  The beta annotation indicates that this implementation \nof paint cannot be overridden. Operationally, when the paint method is called on an instance of BorderWindow \nor any subclass of Border-Window, control jumps to BorderWindow s implementation. This implementation, \nin turn, invokes the implementation in Window, then paints the border, and then allows control to jump \nto a sub\u00adclass implementation. The Button class, for one, accepts that control: class Button extends \nBorderWindow { ... java void paint() {. . . ; // draw a button label } }  Thus, when paint is called \non an instance of Button, control initially jumps to paint in BorderWindow, but ultimately it arrives \nat paint in Button. The method in Button is declared java, however, so that a subclass can completely \nreplace the button part of the method. The ImageButton class completely replaces paint in Button, forcing \nany subclasses to draw an image. HighlightButton uses super to extend button painting, rather than replacing \nit entirely: class ImageButton extends Button { ... java void paint() {. . . ; // draw image (don t call \nsuper for label) inner.paint(); } } class HighlightButton extends Button { ... beta void paint() {. \n. . ; // replace the background with dark blue super.paint(); // draws the label . . . ; // draw light \nblue shading on top of the label } }  When paint is called on an ImageButton instance, control jumps \nto BorderWindow, then to Window, then back through BorderWin\u00addow to ImageButton. When paint is called \non a HighlightButton instance, control jumps to BorderWindow, then to Window, then back through BorderWindow \nto HighlightButton, then temporarily to Button, and .nally back to HighlightButton. At every point in \nthis class derivation, a programmer speci.es ex\u00adactly the intent for re.nement in subclasses. While the \noverall .ow of control through methods can be complex, it is locally apparent what results will be achieved. \nIn our example, it is clear that a Bor\u00adderWindow subclass always uses BorderWindow s paint, whereas a \nButton subclass has the option to replace paint. The widget example shows how beta may be used any number \nof times. The implementor of ImageButton decided that drawing the images is mandatory, implementing this \nintent by annotating the method with beta. Because of this annotation, when paint is called for a subclass \nof ImageButton, control .rst jumps to BorderWin\u00addow (as required by the BorderWindow implementor), but \nalways to ImageButton before any subclass of ImageButton. As shown earlier, it is possible to simulate \none form of method extension in a language that has the other form. The simulation is awkward compared \nto directly expressing the intended mode of method re.nement. Furthermore, after a method has been writ\u00adten \nwithout the simulation pattern, converting it to use a simulation pattern requires extensive modi.cation \nto descendant classes (since they must use the new method name introduced by the simulation). In contrast, \nchanging a beta annotation to java (or vice-versa) requires modifying only classes that directly re.ne \nthe changed method, and not the decedents of those classes. With java and beta annotations, .nal is no \nlonger necessary; a .\u00adnal method is simply a beta method that contains no calls to inner. In the same \nway that a Java compiler rejects overriding of a .nal, a compiler could statically reject declaration \nof a method in a sub\u00adclass when a superclass has previously declared the method beta with no inner call. \n 3 From Java to a Beta/Java Combination Syntactically, the difference between Java and our extension \nis the addition of java and beta keywords for methods in classes, plus the addition of an inner expression \nform: Expression = inner . Identi.er (Expression,... Expression) else Statement An inner expression can \nappear only if the enclosing class contains a beta declaration for Identi.er, or if such a declaration \nis inherited and the enclosing class contains no java declaration of Identi.er. (Using inner.m outside \nof method beta m would be unusual, much like using super.m outside of a method m.) If a method has neither \na beta nor java annotation, java is assumed. 3.1 Method Dispatch Dynamically, the difference between \nJava and our extension to Java is in method dispatch, including support for inner. If a program contains \nno beta annotations (and therefore no inner expressions), then method dispatch proceeds exactly as in \nJava: A method call (of the form expr.methodName) uses the class of the method s object to determine \nthe target method imple\u00admentation. The target is the implementation in the superclass that is closest \nto the instantiated class.  Each super call is resolved statically to a method implemen\u00adtation in the \nclosest superclass.  If every method of a program is annotated beta, then method dis\u00adpatching proceeds \nas in Beta: A method call uses the .rst implementation of a method in the class derivation, starting \nfrom the root class. This target can be resolved statically, assuming that the object expression s type \nis a class (as opposed to an interface).  An inner call, in contrast, must use the class of this to \n.nd the target method. The target is the implementation in the subclass closest to the class that contains \nthe inner call. If no target exists, then the default expression is evaluated.  Figure 6 shows one chain \nin our example GUI widget class hierar\u00adchy. The extra classes ImagePopup and GrayImagePopup illustrate \nfurther uses of beta and java. Arrows on the left side of the .gure show how inner calls for paint jump \nfrom one class to another (the numbers will be explained in section 3.2), ending at an arrowhead, and \narrows on the right show how super paint calls jump: A super call (arrow on the right) behaves exactly \nas in Java, always jumping to a statically determined implementation in a superclass. We disallow super \ncalls to beta declarations, because they are not useful in our experience, and because they tend to produce \nin.nite loops that are dif.cult to debug.  An inner call (arrow on the left) is slightly different than \nin Beta, because the target is not always in the closest sub\u00adclass. Instead, the target is the closest \nsubclass that declares the method beta, or the farthest subclass if no subclass con\u00adtains a beta declaration \nof the method.  A method call in a mixed environment behaves much like an inner call, where the target \nof the initial call is the .rst beta implementation of the method if one exists, and the last java implementation \notherwise.  External dispatch and inner go to the highest beta implementation of a method, because the \nprogrammer s intent in using beta is to  Figure 6. Method dispatch example, with arrows for inner and \nsuper calls inside the paint method ensure that the code in that method will get called, no matter how \nsubclasses re.ne the method. Ultimately, declaring a method beta should trump any future attempts to \noverride it, because the en\u00adforced behavior may be necessary for the program to behave cor\u00adrectly. An \ninner or external dispatch skips java methods, because the pro\u00adgrammer s intent when using java is to \nallow overriding. The skipped java implementations are used only if the inner target chooses to call \nsuper. 3.2 Compiling Method Dispatch Typically, dynamic method dispatch in Java uses a virtual method \ntable, where a target method implementation is obtained by extract\u00ading it from a particular slot in the \ntable. This strategy still works with beta methods, and the only change is in the construction of the \ntable. Instead of installing the last java implementation of a method into the table, the .rst beta method \n(if any) should be installed. The relevant beta method resides in a superclass, so incremental com\u00adpilation \nof classes in a hierarchy is the same as in Java. An inner call also needs a dynamic dispatch table, \nbut the inner table is slightly more complex. The target of an inner call is deter\u00ad paint 0 BorderWindow \ns 1 ImageButton s 2 ImagePopup s onClick 0 ImagePopup s Figure 7. Dispatch table for ImageButton in \nFigure 6 paint 0 BorderWindow s 1 ImageButton s 2 GrayImagePopup s onClick 0 GrayImagePopup s 1 null \n Figure 8. Dispatch table for GrayImageButton in Figure 6 mined by both the class of the object on which \nthe inner is called and the class declaration in which the inner call appears. Thus, the inner dispatch \ntable is not simply linear in the number of beta methods. In fact, for each method, the table contains \nan array of target methods. An inner call can be mapped statically to an index for the method s array, \nwhere the index is the total number of beta declarations of the method in the inner call s class and \nits super\u00adclasses. Meanwhile, index 0 corresponds to the target for external method calls. For example, \nwhen the paint method is called for an instance of GrayImagePopup, the numbers in Figure 6 correspond \nto the in\u00addices. An external call always starts with index 0, at BorderWin\u00addow. An inner call in BorderWindow \njumps to the method at index 1, because the BorderWindow introduces the .rst beta declaration of paint. \nAn inner call in ImageButton jumps to the method at in\u00addex 2, because ImageButton introduces the second \nbeta declaration of paint. In general, for a particular method, class, and inner array index, the dispatch \ntable contains one of three values: It contains null if no further re.nements of the method are declared \nbelow inner calls that use the index.  It contains the .rst beta declaration of the method below the \ninner call, if any such declaration exists.  It contains the last java declaration of the method below \nthe inner call, if any such delectation exists, and if no beta dec\u00adlaration is available.  Figure 7 \nshows the complete method dispatch table for Image-Popup, and Figure 8 shows the dispatch table for GrayImagePopup. \nIn both cases, index 0 contains BorderWindow s method for paint, and index 1 contains ImageButton s method. \nAt index 2, the Image-Popup table contains the implementation from ImagePopup, but it is replaced by \nGrayImagePopup s implementation in the table for GrayImagePopup. Similarly, index 0 for onClick contains \nImage\u00adPopup s implementation in ImagePopup s table, but it is overridden with GrayImagePopup s implementation \nin GrayImagePopup s ta\u00adble. Finally, index 1 for onClick in GrayImagePopup contains null, because no \nmethod re.nes the beta declaration of onClick in Gray-ImagePopup. To explain table construction another \nway, a beta method occupies an index permanently, in all subclasses, and increases the size of the method \ns array, whereas a java method occupies an index only until it is replaced by a subclass implementation. \nIf no methods are declared beta (either in the whole program or for a particular method), then this algorithm \ndegenerates to the usual Java-style al\u00adgorithm (either for the whole table or for an individual row). \nFor an instance of ImagePopup, all declarations of onClick are java, so the onClick row in Figure 7 has \na single slot, just as in a Java dispatch table. In the case of paint for ImagePopup, every inner call \nhas a target method, since the last paint method in the chain is declared java. The last onClick method \nof GrayImagePopup, however, is declared beta. If the GrayImagePopup contains an inner call for onClick, \nthere is no target method, which means that the inner s else expres\u00adsion is used at run time. This lack \nof a target is re.ected by a null pointer for index 1 in the onClick row of the dispatch table. Thus, \nan inner call at run time .rst checks whether the relevant table slot is null; if so, it uses the else \nexpression, otherwise it jumps to the table-indicated method. A Java-style dispatch table always has \nsize O(m) for m distinct methods in the class, but the size of a dispatch table with inner de\u00adpends on \nboth the number of methods in the class and the number of beta implementations of the method. A two-dimensional \narray for the inner table would thus require O(m \u00d7 n) space for m meth\u00adods and a maximum beta depth of \nn. Our implementation uses an array of arrays, instead (as suggested by Figure 7 and Figure 8), so that \nthe size is O(m + p) for p total beta declarations, which tends to be much smaller than O(m \u00d7 n). 3.3 \nInterfaces The beta and java keywords apply only to method implementa\u00adtions in a class. Because interfaces \nre.ect subtyping and not be\u00adhavior, these keywords are not needed in an interface declaration. A method \ncall through an interface behaves the same as an external method call using the object s type. In compilation \nterms, interface dispatch needs only the implementation that is stored in a virtual method table, so \ninterface-based method calls are effectively un\u00adchanged compared to Java. 3.4 Differences from Beta \n Technically, even for a program that contains only beta methods, our language differs from Beta in two \nrespects that are unrelated to method dispatch: Our inner form contains explicit arguments, instead \nof im\u00adplicitly using the enclosing method s arguments (or, more pre\u00adcisely, the current values of the \nargument variables, in the case that the variables have been assigned). This form of inner call more \nclosely parallels super, allows the values passed to in\u00adner to be changed non-imperatively, and allows \nan inner call for a particular method to appear in any other method (again, like super).  Our inner \nform includes a default expression to evaluate when no subclass implementation is available, whereas \nBeta defaults to a null operation. We include a default expression to make the language more value oriented. \n P = defn ... defn e defn = class c extends c { meth ... meth }meth = kindt m(t var,...t var){ e }kind \n= beta | java c = a class name or Object md = a method name var = a variable name or this t = c e = \nvar | null | new c | e.md(e,...e) | super var:c.md(e,... e) | inner var:c.md(e,...e) else e e.= e |. \nc.= c |. c = c |. Figure 9. Syntax of BETAJAVA  4 BetaJava Model To demonstrate type soundness of \nour combination of Beta-style and Java-style methods, we de.ne a complete formal model for BETAJAVA in \nthe style of CLASSICJAVA [14]. The model simpli.es Java considerably, eliminating constructs that are \nirrelevant to method dispatch. For example, the model does not include local variables, if statements, \nor exceptions. Unlike CLAS-SICJAVA, the BETAJAVA model further omits .elds, but we have preserved enough \nCLASSICJAVA structure in our BETAJAVA model to ensure that .elds could be added back to the model, exactly \nas they appear in CLASSICJAVA. We also omit interfaces from BETA-JAVA, because beta and java play no \nrole in interface declarations. Figure 9 contains the syntax of BETAJAVA programs in our model. A program \nP consists of a sequence of class declarations followed by a single expression. The expression plays \nthe role of main to start the program. Each class declaration contains a sequence of method declarations, \nand each method is annotated with either beta or java. A method body consists of a single expression, \nwhich is either a variable (i.e., a reference to a method argument or this), the null keyword, an object \ncreation new c, or a method call. Each method call has one of three shapes: A method call of the form \ne.md(e1,...en) is a normal call to the method md in the object produced by e.  A method call super var:c.md(e1,...en) \nmust appear only within a method (as enforced by the type system). The var part of the call is intended \nto be this, which is implicit in Java. An explicit target simpli.es our evaluation rules, but this could \nbe inserted automatically by an elaboration step, as in CLASSICJAVA. Similarly, the class c named in \na super call must be the name of the containing class s immediate su\u00adperclass. Again, c could be inserted \nby elaboration, and our type system ensures that the correct c is named.  A method call inner var:c.md(e1,...en) \nelse e must appear only within a method (again, as enforced by the type system). As with super calls, \nvar is intended to be this, and a class  c is named for the convenience of our evaluation rules. For \n4.2 BetaJava Evaluation inner, the given c must be the class containing the inner call, The relations \n. j P and . b P capture the essence of beta-sensitive as opposed its superclass, and the type system \nensures this correlation. The extra else e at the end of an inner call pro\u00ad vides the expression to evaluate \nif, at run time, no extending P and .P relations .nd a java or beta method only between classes c\" and \nc\"\" in a chain of b j method dispatch (see Figure 12). The . method is provided by var (in a subclass \nof c). \" class extensions. These relations also accept a default expression eto use if no method can \nbe found. (These pieces are assembled as The non-terminals .e,.c, and c in Figure 9 are for auxiliary \nrelations [c\" ,c\"\" ](e\" ) to the right of . j P or .P.) The two relations implement a two-phase search \nfor a method. The b in the evaluation rules, and they are not part of the concrete syntax. b P relation \n.rst attempts to .nd a beta method, and if the search fails, it delegates to .P to .nd a java method. \nThe .P relation uses j b . 4.1 BetaJava Type Checking max= P to .nd the highest beta method in a class \nderivation (i.e., j closest to the root class), while .P uses min= P of CLASSICJAVA, building on a number \nof simple predicates method (i.e., closest to the instantiated class). and relations that are de.ned \nin Figure 10. For example, the CLASSESONCE(P) predicate checks that each class name is de-Since it implements \nthe Java-like part of method search, . to .nd the lowestThe type-checking rules for BETAJAVA closely \nresemble those .ned only once. The -P relation associates each class in the pro\u00adgram P with the class \nthat it extends, and . P captures the method declarations of P. The = P relation .lls out the subclass \nrelationship as the transitive closure of -P. (The extension to T and . is used in the eval\u00aduation rules.) \nTwo additional predicates check global properties: CLASSESDEFINED(P) ensures that the class hierarchy \nof P forms a tree, and EXTENSIONSCONSISTENT(P) ensures that every dec\u00ad j P relation is similar to . \nP, except that it takes into account an upper bound c\"\" and a default expression. The upper bound corresponds \nto a class with an inner call, where a legal target method must appear in a subclass. If no method is \nfound and the default expression is used, then arbitrary method arguments are selected by the rela\u00adtion, \nwith the constraint that the argument variables do not appear in the expression. The . j b b P relation \nsearches primarily for a beta method below the up\u00ad laration of a method in a class derivation uses the \nsame signature. per bound c\"\" . If no beta method is found, .P uses .P to search for a java method, instead. \nMeanwhile, the default expression passed j to .P corresponds to the default expression for an inner \ncall, in case neither kind of method is found. Using these two relations, the operational semantics for \nBETAJAVA is de.ned as a contextual rewriting system on pairs of expressions and stores. As in CLASSICJAVA, \na store S is a mapping from gener-Finally, the . P relation combines the methods that a class declares \nwith the methods that it inherits from its superclasses. The . P re\u00ad lation can be interpreted as a function \nfrom classes to method-tuple sets, or as a function from class method combinations to method implementations. \nSpeci.cally, for a class c and method name md, . P locates the most speci.c implementation of md, which \nis the one declared closest to c in the class hierarchy. This relation is the same as in CLASSICJAVA, \nexcept that the method implementation s kind is included on the left-hand side of the relation. ated \nvars to class-tagged records. Since the BETAJAVA model does not include .elds or .eld assignments, the \nstore is technically un\u00ad b necessary, but we preserve it for consistency with CLASSICJAVA. Complete \ntype-checking rules for BETAJAVA appear in Figure 11. The complete evaluation rules are in Figure 13. \nNormal method The rules include the following judgments: P with Object as the upper bound, which .nds \neither calls use . the .rst beta method or the last java method. An inner call also f p P program P \nis well-typed b P , but with the class named in the call as an exclusive upper P f d defn class defn \nin program P has well-typed methods bound for .nding a method. A super call merely uses . P, as in P,c \nf m meth method meth in class c has a well-typed body CLASSICJAVA, re.ecting that super dispatch behaves \nas in Java. P, G f e e : t expression e has type t in environment G uses . G fP : te,s the type of e \nis a subtype of t in environment G The static and dynamic nature of method calls is apparent in the model \ns relations. For example, the use of . P for super calls relies on no dynamic information, so it can \nbe computed statically. Sim\u00ad b P for a method call can be precomputed if the type of the object expression \nincludes a beta method; at run-time, ilarly, the result of .To summarize the type rules, a program is \nwell-typed if its class de.nitions are well-typed and its .nal expression is well-typed in the class \nwill be a subtype of the static type, but the subtype cannot an empty environment. A class de.nition \nis well-typed when its methods are well-typed. A method is well-typed when its body is b P in an inner \ncall cannot be pre-computed from just the object expression s type. override the beta method. In contrast, \nthe result for . well-typed in an environment that includes the method s arguments. For expressions, \na null or new c expression is always well-typed, and var is well-typed if it is bound in the environment. \nA call to a method md is well-typed if the . P relation .nds a consis\u00adtent declaration of md in a particular \nclass. In the case of a normal method call, the class is determined by the type of the target object. \nIn the case of a super call, the class is named in the call, and it must be the superclass of the type \nof this (where the type of this effectively names the class where the super call appears). In the case \nof an inner call, the class c is named in the call, c must be the type of this, and the most-speci.c \nmd for c must have kind beta. 4.3 BetaJava Soundness For a well-typed program, evaluation can either \nproduce a value, loop inde.nitely, or get stuck attempting to call a method of null. The last possibility \nwould correspond to a run-time error in a Java implementation. These type rules preclude a method not \nunder\u00adstood run-time error, however, which is the essence of soundness for an object-oriented language. \n\"\" CLASSESONCE(P) iff (class c \u00b7\u00b7\u00b7 class c is in P) implies c= c OBJECTBUILTIN(P) iff class Object is \nnot in P METHODSONCEPERCLASS(P) iff \" (class c extends c {\u00b7\u00b7\u00b7 t1 md1 \u00b7\u00b7\u00b7 t2 md2 \u00b7\u00b7\u00b7} is in P) implies \nmd1= md2 CLASSESDEFINED(P) iff (c is in P) implies c = Object or (class c is in P) \"\" c -Pc iff class \nc extends c is in P (m,kind,(t1 ... tn . t0),(var1,...varn),e). Pc iff \" class c extends c {\u00b7\u00b7\u00b7 kind \nt0 md(t1 var1,...tn varn){ e } \u00b7\u00b7\u00b7} is in P =P = transitive re.exive closure of -P plus c =P T and .=Pc \n<P = irre.exive restriction of =P WELLFOUNDEDCLASSES(P) iff =P is antisymmetric EXTENSIONSCONSISTENT(P) \niff ((m, kind,(t1 ... tn . t0),(var1,...varn),e). Pc1) \"\" and ((m,kind \" ,(t1 \" ... t \". t0\" ),(var1,...var \n), e \"). Pc2) nnimplies (c1 =Pc2 or (t1 ... tn . t0)=(t1 \" ... t \". t0\" )) n (m,kind,(t1 ... tn . t0),(var1,...varn),e).Pc \niff \"\" c = min=P ({c | c \"=Pc and (m,kind,(t1 \" ... t \". t0\" ),(var1,...var ),e \"\"). Pc}) nn and (m,kind,(t1 \n... tn . t0),(var1,...varn), e). Pc Figure 10. Predicates and relations for BETAJAVA P fd defn1 ... \nP fd defnn P,0/ fe e : t fp P where P = defn1 ... defnn e, CLASSESONCE(P), OBJECTBUILTIN(P), METHODSONCEPERCLASS(P), \nCLASSESDEFINED(P), WELLFOUNDEDCLASSES(P), and EXTENSIONSCONSISTENT(P) P,this:c, var1:t1,...varn:tn fs \ne : t0 \" P, G fe e : c P,c fm kind t0 md(t1 var1,...tn varn){ e } P,G fs e : c where c \"=Pc P,G fe new \nc : cP,G fe null : cP,G fe var : t where G(var)= t P,G fe e : cP, G fs e1: t1 ... P,G fs en : tn P,G \nfe e.md(e1,... en) : t0 where (md,kind, (t1 ... tn . t0),(var1,... varn),e0).Pc P,G fs e1: t1 ... P, \nG fs en : tn \"\" where G(var)= c , c -Pc P, G fe super var:c.md(e1,...en) : t0 and (md,kind,(t1 ... \ntn . t0),(var1,...varn),e).Pc P,G fs e1: t1 ... P, G fs en : tn P,G fs e0: t0 where G(var)= c P, G fe \ninner var:c.md(e1,... en) else e0: t0 and (md, beta, (t1 ... tn . t0),(var1,... varn),e).Pc  Figure \n11. Type-checking rules for BETAJAVA j \" (m,var1,...varn, e.).P [c ,c \"\"](e.\") iff \"\"\" \"\" c = min=P \n({T}.{c | c \"=Pc and c <Pc and (m,kind, (t1 ... t \". t0\" ),(var1,... var ),e \"\"). Pc}) and ((m,kind,(t1 \n... tn . t0), (var1,...varn),e.). Pc nn \" or (c = T,e.= e., and var1,... varn not in e)) \" (m,var1,...varn, \ne.).b P [c ,c \"\"](e.\") iff \"\" \"\" c.= max=P ({.}.{c | c \"=Pc and c <Pc and (m,beta,(t1 \" ... t \". t0\" \n),(var1,...var ),e \"\")..Pc}) nn and ((m,beta,(t1 ... tn . t0), (var1,...varn),e.). Pc. j \" or (c.= . \nand (m,var1,... varn,e.).P [c ,c \"\"](e.\"))) Figure 12. Relations for BETAJAVA evaluation v = null E = \n[] | var | E.md(e,...e) | v.md(v,... v,E,e,...e) | super v:c.md(v,...v,E,e,...e) | inner v:c.md(v,...v, \nE, e,...e) else e P f(E[new c],S) .-.bj (E[var],S[var .(c)]) where var . dom(S) P f(E[var.md(v1,...vn)],S) \n.-.bj (E[e[varn . vn] ... [var1 . v1][this . var]], S) where S(var)= (c) and (md,var1,... varn,e).b P \n[c,Object](.) P f(E[super var:c.md(v1,...vn)], S) .-.bj (E[e[varn . vn]...[var1 . v1][this . var]],S) \nwhere (md, java,(t1 ... tn . t0),(var1,...varn),e).Pc P f(E[inner var:c.md(v1,...vn) else e \"],S) .-.bj \n(E[e[varn . vn]...[var1 . v1][this . var]], S)where S(var)= (c0) and (md,var1,...varn, e).b P [c0,c](e \n\") Figure 13. Evaluation rules for BETAJAVA Theorem 1 (Type Soundness): If fp P where P = defn1 ... defnn \ne, then either P f(e, 0/) .-..bj (v,S) for some v and S; \" P f(e,0/) .-..bj (e , S) implies \" \"\" \"\" P \nf(e , S) .-.bj (e ,S\") for some e and S\" ; or P f(e, 0/) .-..bj (E[null.md(v1,...vn)],S) for some E, \nmd, v1,...vn, and S. The main lemma in support of this theorem states that each step taken in the evaluation \npreserves the type correctness of the expression-store pair (relative to the program) [26]. Speci.cally, \nfor a con.guration on the left-hand side of an evaluation step, there exists a type environment that \nestablishes the expression s type as some t. This environment must be consistent with the store. The \nsoundness proof for CLASSICJAVA [13] is easily adapted to BETAJAVA. The super rule is unchanged, so the \nthe proof that a method is found is also unchanged. The normal-and inner\u00adcall forms use the new method-.nding \nrelation .b P, but .b P .nds a method anytime that .P .nds one, and if different implementa\u00adtions are \nfound, then EXTENSIONSCONSISTENT(P) ensures that the types are consistent.  5 Implementation and Experience \n MzScheme is the base language for the PLT Scheme programming suite, which includes DrScheme [11]. MzScheme \nextends the stan\u00addard Scheme language [19] with numerous constructs, including a Java-like object system.2 \nThe object system is used primarily to implement DrScheme s graphical interface. 5.1 Base Implementation \nClasses and objects in MzScheme are dynamically typed, which means that a method call from outside an \nobject typically requires a dynamic method-name lookup. Self and super calls within an object, however, \nare always resolved at class-construction time. A self call uses a virtual method table indirection, \nand a super call is a direct function call. In short, these calls are implemented as in a statically \ntyped object-oriented language, such as Java. Classes are values in MzScheme, and the superclass position \nin a class declaration can be an arbitrary expression. Consequently, a mixin can be de.ned by placing \na class expression within a proce\u00addure that accepts a superclass argument. DrScheme uses this form of \nmixin extensively. For example, the autosave behavior for a text editor is implemented as a mixin, so \nthat autosaving can be added to any class that implements the text-editor interface. Add\u00adon tools for \nDrScheme introduce new mixins to extend DrScheme s behavior. The autosave mixin must extend the editor \ns on-close method, which is called when the editor s window is closed, so that the au\u00adtosave timer is \ndisabled. In previous versions of DrScheme, only Java-style methods were available, so a mixin that overrides \non\u00adclose was obligated to call the superclass method. Failing to call the superclass method in a tool-introduced \nextension would create a 2Technically, the object system is an external library. allow override allow \naugment new method public pubment override existing override overment augment existing augride augment \n Figure 14. Method keywords in MzScheme bug or resource leak in DrScheme s core, and such a leak appeared \nin practice. Fixing the bug was trivial, but discovering the bug was dif.cult, because the mixin implementor \nnaturally concentrated on testing the mixin s own on-close behavior. Many other on-... meth\u00adods in DrScheme \nhave the same protocol, with the same danger of errors.  5.2 Adding Inner An inner method call is implemented \nin MzScheme using an aux\u00adillary method table, as described in Section 3.2. Overall, to im\u00adplement a prototype \ncombination of beta and inner, we added or changed roughly 100 lines of Scheme macro code in the 2800-line \nimplementation of MzScheme s object system. Our production ver\u00adsion added another 150 lines of code. \nBefore adding inner to MzScheme, each method was declared as either public or override.A public declaration \nindicates that the method is new in the class, whereas override indicates that the method should be declared \nalready in the superclass (in which case super can be used). This distinction is statically apparent \nin Java, but not in MzScheme, due to MzScheme s form of classes as val\u00adues. After adding inner to MzScheme, \na method declaration must de\u00adclare whether the method is new, overriding, or augmenting, and also whether \nsubclasses are allowed to override or augment the method. We de.ned a different keyword for each combination, \nas shown in Figure 14. For example, the pubment keyword means new public method, allow augment only. \nWe are converting many of DrScheme s on-... methods from public to pubment, thus eliminating the potential \nfor bugs in DrScheme s core due to a missing call to a superclass method in an add-on tool. We expect \nalso to simplify the set of methods in our classes, much as beta methods eliminated the need for a paintInner \nmethod in the example of Section 2.  6 Related Work Smalltalk [16] was the .rst language to popularize \nextension as overriding behavior. This branch of extension has inspired many languages, including C++ \n[25] and Java [17]. Although many of these languages added additional features such as multiple inheri\u00adtance \nand mixins, they all maintained overriding as the only form of method re.nement. CLOS [18] is another \nlanguage on the Smalltalk branch of method extension, but it supports an inner-like call through an :around \nquali.er and call-next-method. Normally, call-next-method acts like super in Java. In the case where \ncall-next-method is used in the least speci.c :around method, the most speci.c method with\u00adout a quali.er \nwill be called. This pattern simulates a single inner call, but there is no way to simulate multiple \ninner calls that move down a class hierarchy, nor is there a way to use call-next-method as a super-like \ncall and an inner-like call in the same method. Beta [20] inspired gbeta [9]. In gbeta, methods are treated \nas a sequence of method bodies (which gbeta calls mixins); an inner statement goes from the current method \nbody to the next one in the sequence. By default, the methods are ordered from the .rst dec\u00adlaration \nof the method to the last augmentation, but a programmer can control the order through speci.c merging \noperators [10]. For example, the programmer can name an individual method body and later add a new body \nimmediately before or after the named one. A programmer can also place a newly declared body at the beginning \nof the method s sequence. Clearly, our beta and inner declarations cannot emulate such general merging \noperations, but gbeta s merg\u00ading operations also cannot implement our semantics. In particular, gbeta \noffers no way to ensure that a behavior is never overridden (as guaranteed by our beta). As far we know, \nno one has created a simple extension to a Beta\u00adlike language that allows method overriding and super \nwithout al\u00adlowing Beta method to be overridden. We also have found no work adding a simple inner extension \nto a Java-like language. Cook, in his Ph.D. thesis [7], develops a semantic model of inheri\u00adtance and \nuses it in the analysis of various programming languages, including Smalltalk and Beta. He observes that \nthe underlying in\u00adheritance mechanisms of Beta and Smalltalk are the same. The dif\u00adference is in the \ncombination of inherited structure with local def\u00adinitions: Smalltalk and Beta have inverted inheritance \nhierarchies, with Beta s superpatterns acting as subclasses and subpatterns as superclasses. Cook s model \ncan express method re.nement as ei\u00adther overriding and augmenting, but not both behaviors combined. Clark \n[6] describes a functional language with primitives for object\u00adoriented programming. In his language, \nan extension of a class is a function of the shadowed de.nitions available in super plus the shadowing \nde.nitions available to the superclass in inner. He brie.y addresses the issue of whether a subclass \nde.nition should shadow a superclass de.nition or vice versa, but only to de.ne the choice as one or \nthe other. Bracha and Cook [5] propose mixins as a method of combin\u00ading the inheritance mechanisms of \nJava and Beta. By choosing the correct composition of mixins, a programmer can achieve ei\u00adther Java-like \nor Beta-like behavior from methods. Ancona and Zucca [3, 2] similarly demonstrate formally how overriding \nop\u00aderators can be expressed in a mixin-based framework, but these systems do not allow both accessing \nbehavior from a previously composed mixin s method and accessing behavior from a succes\u00adsively composed \nmixin s method; the mixin composition operator determines which will occur. Furthermore, a tedious programming \npattern is required to simulate Java-style and Beta-style extension, which is only a slight improvement \nover the programming pattern required in Java to achieve Beta-style re.nement. Duggan [8] describes a \nlanguage with mixins that includes super and inner constructs, but the inner construct does not correspond \ndirectly to Beta s inner. Duggan s system includes an operation to combine two mixins, and in the case \nthat the mixins both de.ne a particular method, one de.nition will override the other. The inner keyword \nallows the overriding de.nition to make use of the over\u00adridden one. Thus, inner provides access to a \nmethod of a combined mixin, rather than a method of a subclass. (The super construct, meanwhile, has \nthe traditional meaning, referring to the base mixin from which a mixin inherits.) Bettini et al. [4] \npresent an extension to Java based on the deco\u00adrator design pattern. By relying explicitly on a delegation-style \nof method re.nement instead of a more speci.c method-re.nement construct, a class can retain primary \ncontrol of a method. Their sys\u00adtem is not a simple extension of Java, but rather requires a program\u00admer \nto adopt a drastically different way of thinking about classes in order to use their extension. Also, \nit is unclear how their extension would work for methods whose return type is not void. The GNU EDMA \nsystem [24] supports object-oriented design through a C library of functions to mimic class and object \ncon\u00adstruction. The library provides speci.c functions to simulate both Java-style and Beta-style method \nre.nement, and no doubt a com\u00adbination can be implemented. It appears that no such combination has been \nworked out to date. 7 Conclusion and Future Work Programmers bene.t by having both Java-style method \noverriding and Beta-style method augmentation within a single programming language. We have shown why \nsuch a combination is bene.cial, we have demonstrated that our formulation of the combination is sound, \nand we have shown that it can be implemented with rela\u00adtively minor changes to an existing Java-like \nlanguage. Although we have mainly considered the combination in the con\u00adtext of class-based languages, \nwe have also noted that mixins mag\u00adnify our interest in the combination. From a mixin perspective, a \ndefault expression for super may be as useful as a default ex\u00adpression for inner, allowing a programmer \nto apply a mixin to a class without a base method for a super call. We see no immedi\u00adate uses for this \ngeneralization, but we intend to watch for places in DrScheme s implementation that could bene.t from \nsuper de\u00adfaults. The MzScheme changes described in Section 5 are included in ver\u00adsion 299.10 and later. \nAn implementation of Section 4 s model of BETAJAVA (using the PLT reduction semantics tool [23]) is avail\u00adable \nat the following web site: http://www.cs.utah.edu/plt/super+inner/ Acknowledgments We would like to \nthank Yang Liu for work on a prototype combina\u00adtion of beta and java dispatching, Richard Cobbe for his \nCLASSIC-JAVA reduction semantics, Erik Ernst for comments and compar\u00adisons to gbeta s merging operators, \nand the anonymous reviewers for their suggestions. 8 References [1] P. America. Designing an object-oriented \nprogramming lan\u00adguage with behavioural subtyping. In Proc. ACM Inter\u00adnational Workshop on Foundations \nof Object-Oriented Lan\u00adguages, volume 489 of Lecture Notes in Computer Science, pages 60 90. Springer-Verlag, \n1991. [2] D. Ancona and E. Zucca. Overriding operators in a mixin\u00adbased framework. In Proc. Symposium \non Programming Lan\u00adguage Implementation and Logic Programming, pages 47 61, 1997. [3] D. Ancona and E. \nZucca. A theory of mixin modules: Basic and derived operators. Mathematical Structures in Computer Science, \n8(4):401 446, 1998. [4] L. Bettini, S. Capecchi, and B. Venneri. Extending Java to dynamic object behaviors. \nIn Proc. Workshop on Object-Oriented Developments, volume 82. Elsevier, 2003. [5] G. Bracha and W. Cook. \nMixin-based inheritance. In Proc. Joint ACM Conf. on Object-Oriented Programming, Systems, Languages \nand Applications and the European Conference on Object-Oriented Programming, Oct. 1990. [6] A. Clark. \nA layered object-oriented programming language. GEC Journal of Research, 11(2):173 180, 1994. [7] W. \nR. Cook. A Denotational Semantics of Inheritance. Ph.D. thesis, Department of Computer Science, Brown \nUniversity, Providence, RI, May 1989. [8] D. Duggan. A mixin-based, semantics-based approach to reusing \ndomain-speci.c programming languages. In Proc. European Conference on Object-Oriented Programming, vol\u00adume \n1850 of LNCS, pages 179 200, Berlin Heidelberg, 2000. Springer-Verlag. [9] E. Ernst. gbeta a Language \nwith Virtual Attributes, Block Structure, and Propagating, Dynamic Inheritance. PhD the\u00adsis, Department \nof Computer Science, University of Aarhus, \u00b0 Arhus, Denmark, 1999. [10] E. Ernst. Propagating class \nand method combination. In Proc. European Conference on Object-Oriented Program\u00adming, LNCS 1628, pages \n67 91. Springer-Verlag, June 1999. [11] R. B. Findler, C. Flanagan, M. Flatt, S. Krishnamurthi, and M. \nFelleisen. DrScheme: A pedagogic programming environ\u00adment for Scheme. In Proc. Symposium on Programming \nLan\u00adguage Implementation and Logic Programming, pages 369 388, Sept. 1997. [12] M. Flatt. PLT MzScheme: \nLanguage manual. Technical Re\u00adport TR97-280, Rice University, 1997. [13] M. Flatt. Programming Languages \nfor Reusable Software Components. PhD thesis, Rice University, 1999. [14] M. Flatt, S. Krishnamurthi, \nand M. Felleisen. Classes and mixins. In Proc. ACM Symposium on Principles of Program\u00adming Languages, \npages 171 183, Jan. 1998. [15] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements \nof Reusable Object-Oriented Software. Addison Wesley, Massachusetts, 1994. [16] A. Goldberg and D. Robson. \nSmalltalk 80: The Language. Addison-Wesley, Reading, 1989. [17] J. Gosling, B. Joy, and G. Steele. The \nJava Language Spec\u00adi.cation. The Java Series. Addison-Wesley, Reading, MA, USA, June 1996. [18] S. E. \nKeene. Object-Oriented Programming in Common LISP, a Programmer s Guide to CLOS. Addison-Wesley, 1988. \n[19] R. Kelsey, W. Clinger, and J. Rees (Eds.). The revised5 re\u00adport on the algorithmic language Scheme. \nACM SIGPLAN Notices, 33(9), Sept. 1998. [20] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and K. Nygaard. \nObject-oriented programming in the BETA programming lan\u00adguage. ACM Press/Addison-Wesley, 1993. [21] B. \nH. Liskov and J. Wing. Behavioral subtyping using in\u00advariants and constraints. Technical Report CMU CS-99-156, \nSchool of Computer Science, Carnegie Mellon University, July 1999. [22] B. H. Liskov and J. M. Wing. \nA behavioral notion of subtyp\u00ad ing. ACM Transactions on Computing Systems, November 1994. [23] J. Matthews, \nR. B. Findler, M. Flatt, and M. Felleisen. A visual environment for developing context-sensitive term \nrewriting systems. In Proc. International Conference on Rewriting Techniques and Applications, June 2004. \n[24] D. M. Oliveira. GNU EDMA. http://www.gnu.org/software/edma/edma.html. [25] B. Stroustrup. The C++ \nProgramming Language. Addison-Wesley, third edition, 2000. [26] A. Wright and M. Felleisen. A syntactic \napproach to type soundness. Technical Report 160, Rice University, 1991. In\u00adformation and Computation, \nvolume 115(1), 1994, pp. 38 94. \n\t\t\t", "proc_id": "1028976", "abstract": "<p>In an object-oriented language, a derived class may declare a method with the same signature as a method in the base class. The meaning of the re-declaration depends on the language. Most commonly, the new declaration overrides the base declaration, perhaps completely replacing it, or perhaps using &#60;b>super&#60;/b> to invoke the old implementation. Another possibility is that the base class always controls the method implementation, and the new declaration merely augments the method in the case that the base method calls &#60;b>inner&#60;/b>. Each possibility has advantages and disadvantages. In this paper, we explain why programmers need both kinds of method redeclaration, and we present a language that integrates them. We also present a formal semantics for the new language, and we describe an implementation for MzScheme.</p>", "authors": [{"name": "David S. Goldberg", "author_profile_id": "81100492384", "affiliation": "University of Utah, Salt Lake City, UT", "person_id": "P698414", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "University of Chicago, Chicago, IL", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah, Salt Lake City, UT", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028987", "year": "2004", "article_id": "1028987", "conference": "OOPSLA", "title": "Super and inner: together at last!", "url": "http://dl.acm.org/citation.cfm?id=1028987"}