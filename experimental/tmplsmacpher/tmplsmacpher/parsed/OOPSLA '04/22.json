{"article_publication_date": "10-01-2004", "fulltext": "\n Concrete Syntax for Objects Domain-Speci.c Language Embedding and Assimilation without Restrictions \nMartin Bravenboer Eelco Visser Institute of Information and Computing Sciences Institute of Information \nand Computing Sciences Universiteit Utrecht, P.O. Box 80089 Universiteit Utrecht, P.O. Box 80089 3508 \nTB Utrecht, The Netherlands 3508 TB Utrecht, The Netherlands  martin@cs.uu.nl visser@acm.org ABSTRACT \nApplication programmer s interfaces give access to domain knowledge encapsulated in class libraries without \nproviding the appropriate notation for expressing domain composition. Since object-oriented languages \nare designed for extensibil\u00adity and reuse, the language constructs are often su.cient for expressing \ndomain abstractions at the semantic level. However, they do not provide the right abstractions at the \nsyntactic level. In this paper we describe MetaBorg,a method for providing concrete syntax for domain \nabstrac\u00adtions to application programmers. The method consists of embedding domain-speci.c languages in \na general pur\u00adpose host language and assimilating the embedded domain code into the surrounding host \ncode. Instead of extending the implementation of the host language, the assimilation phase implements \ndomain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, Meta-Borg \ncan be considered a method for promoting APIs to the language level. The method is supported by proven \nand available technology, i.e. the syntax de.nition formalism SDF and the program transformation language \nand toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, \nXML generation, and user-interface construction. Categories and Subject Descriptors D.1.5 [Programming \nTechniques]: Object-oriented Pro\u00adgramming; D.2.3 [Software Engineering]: Coding Tools and Techniques; \nD.2.3 [Programming Languages]: Pro\u00adcessors General Terms: Languages, Design Keywords: MetaBorg, Stratego, \nSDF, Embedded Lan\u00adguages, Syntax Extension, Extensible Syntax, Domain-Spe\u00adcific Languages, Rewriting, \nMeta Programming, Concrete Object Syntax Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to  1. INTRODUCTION Class libraries encapsulate knowledge about the domain \nfor which the library is written. The application program\u00admer s interface to a library is the means for \nprogrammers to access that knowledge. However, the generic language of method invocation provided by \nobject-oriented languages does often not provide the right notation for expressing domain-speci.c composition. \nGeneral purpose languages, particularly object-oriented languages, are designed for ex\u00adtensibility and \nreuse. That is, language concepts such as objects, interfaces, inheritance, and polymorphism support \nthe construction of class hierarchies with reusable implemen\u00adtations that can easily be extended with \nvariants. Thus, OO languages provide the .exibility to develop and evolve APIs according to growing insight \ninto a domain. Although these facilities are often su.cient for express\u00ading domain abstractions at the \nsemantic level, they do not provide the right abstractions at the syntactic level. This is obvious when \nconsidering the domain of arithmetic or logical operations. Most modern languages provide in.x operators \nusing the well known notation from mathematics. Program\u00admers complain when they have to program in a \nlanguage where arithmetic operations are made available in the same syntax as other procedures. Consider \nwriting e1 +e2 as add(e1, e2) or even x := e1; x.add(e2). However, when programming in other domains \nsuch as code generation, doc\u00adument processing, or graphical user-interface construction, programmers \nare forced to express their designs using the generic notation of method invocation rather than a more \nappropriate domain notation. Thus programmers have to write code such as JPanel panel = new JPanel(new \nBorderLayout(12,12)); panel.setBorder( BorderFactory.createEmptyBorder(15,15,15,15)); in order to construct \na user-interface, rather than using a more compositional syntax re.ecting the nice hierarchical structure \nof user-interface components in the Swing library. Building in syntactic support for such domains in \na gen\u00aderal purpose language is not feasible, however, because of the di.erent speeds at which languages \nand domain abstrac\u00adtions develop. A language should strive for stability, while libraries can be more \nvolatile. republish, to post on servers or to redistribute to lists, requires prior speci.c In this paper \nwe describe MetaBorg,a method for pro\u00ad permission and/or a fee. viding concrete syntax for domain abstractions \nto appli- OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n...$5.00. cation programmers. The method consists of embedding domain-speci.c languages in a general \npurpose host lan\u00adguage and assimilating the embedded domain code into the surrounding host code1 . Instead \nof extending the implemen\u00adtation of the host language, the assimilation phase imple\u00adments domain abstractions \nin terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a \nmethod for promoting APIs to the language level [33]. For example, to improve the construction of user-interfaces \nin Java, we have designed a little Swing User-interface Lan\u00adguage (Swul) that makes the compositional \nstructure of the Swing components visible in application programs. Us\u00ading our method we have embedded \nthis language in Java, such that it is directly available to application programmers. They can now write \nwithin their Java programs expressions such as JPanel panel = panel of border layout { north = label \n\"Welcome\" center = scrollpane of input : textarea { rows = 20 columns = 40 } south = panel of border \nlayout { east = button for ExitAction } }; in order to implement a user-interface consisting of a panel \nwith border layout, containing a label, a text area, and an\u00adother panel with a button. Such a program \nis assimilated into the surrounding Java code by translating it to the se\u00adquence of Swing method calls \nthat one would write by hand. Our work stands in a long line of approaches to add syn\u00adtactic extensibility \nto programming languages [30, 50, 13, 39, 2, 6, 3]. Although our work has many commonalities with other \napproaches, it is distinguished by its generality, i.e. the lack of restrictions on either the syntax \nor the semantics of embedding and assimilation. In addition, implementa\u00adtion of embeddings is high-level \nand concise; de.nition and embedding of Swul required only 100 lines of syntax de.\u00adnition and 170 lines \nof assimilation rules. Our method has the following characteristics: Syntactic Embedded code fragments \nare checked syntac\u00adtically at compile-time. This is in contrast with ap\u00adproaches to compose program fragments \nusing string literals. No restrictions on syntax de.nition Our maxim is that it should be possible to \ndesign a notation that is .tting for the domain without placing arti.cial restrictions on the syntax \nto be used. This means that both lexical and context-free syntax should be de.nable. Further\u00admore, all \naspects of the embedding, including quota\u00adtion symbols, if any, should be adaptable. Only the full class \nof context-free grammars allows such natu\u00adral syntax de.nition. This is in contrast to languages 1MetaBorg \nprovides generic technology for allowing a host lan\u00adguage (collective) to incorporate and assimilate \nexternal domains (cultures) in order to strengthen itself. The ease of implementing embeddings makes \nresistance futile. with user-de.nable operators [23], overloading of (a .xed set of) operators, syntax \nmacros [30], or gram\u00admar formalisms supporting only a subset, such as LL or LALR, of the context-free \ngrammars [13, 2]. The only proviso we make is that host and embedded lan\u00adguage have a context-free syntax. \n Not restricted to a single host language The method is not speci.c to a particular host language [2], \nbut can be used to embed any language in any host language. Interaction with host language Embedded code \nfrag\u00adments should be able to refer to artifacts in the host program and vice versa. This is in contrast \nto ap\u00adproaches based on a separate domain-speci.c language from which code is generated [40, 33]. Combination \nof extensions It should be possible to com\u00adbine multiple domain notations. This in contrast to hard-wired \nlanguage extensions. No restrictions on assimilation The translation of em\u00adbedded fragments to the host \nlanguage should not be limited to a simple homomorphism or other .xed trans\u00adlation order [6], but should \nallow use of context-sensitive information, global analysis, and multi-stage transfor\u00admations. As a consequence \nof these characteristics we do not re\u00adquire that language extensions are implemented within pro\u00adgrams \nin the host language itself [13], since such approaches lead to restrictions in many of the areas mentioned \nabove. We also do not expect language design and implementation skills from the average application programmer. \nInstead we opt for a separation of roles between the meta-programmer de.ning the language embedding and \nassimilation, and the application programmer using a domain notation. However, our techniques are su.ciently \nhigh-level that a knowledge\u00adable programmer can use them to create new embeddings. That is, the method \nis based on SDF2 [10, 44, 45], a syntax de.nition formalism used to de.ne embeddings, and Strat\u00adego/XT \n[26, 47] a language and toolset for program trans\u00adformation used to implement assimilation. These tools \nare mature and freely available from [38] and [41], respectively. The applications of MetaBorg developed \nin this paper are available at http://www.metaborg.org. We proceed as follows. In Section 2 we examine \nthe practice of object-oriented programming in three domains: code generation, document generation, and \ngraphical user\u00adinterface construction. For each of these domains we show how the readability of programs \nimproves dramatically by employing domain-speci.c concrete syntax. In particular, we show how to generate \nJava programs and XML docu\u00adments in Java. Furthermore, we describe the domain-speci.c Swing User-interface \nLanguage (Swul), which provides a nice compositional language for user-interface composition in Java. \nIn Section 3 we explain how concrete syntax em\u00adbeddings and the corresponding assimilations are realized \nusing the MetaBorg method and illustrate this by the im\u00adplementation of embeddings for the three applications \nfrom Section 2. In Section 4 we give an overview of the syntax de.nition formalism SDF2. In Section 5.2 \nwe discuss the re\u00adlation with competing approaches such as user-de.nable op\u00aderators, syntax macros, application \ngenerators, and domain\u00adspeci.c languages. We discuss future work in Section 5.3, and conclude in Section \n6. 2. CONCRETE SYNTAX FOR OBJECTS In this section we examine three application domains that su.er from \nthe misalignment between language notation and the domain: code generation, XML document generation, \nand graphical user-interface construction. For each of these domains we discuss the methods that are \nused for program\u00adming in these domains using an object-oriented language and we show how our concrete \nsyntax method dramatically improves the readability and writability of applications in these domains. \nFor all examples in this paper we use Java as the host language, but the techniques are equally well \napplicable to other languages. 2.1 Code Generation A code generator automates the production of boilerplate \ncode by translating a compact high-level speci.cation of a problem into full blown code. Typical applications \ninclude the generation of data-types for the representation of ab\u00adstract syntax trees, the generation \nof XML data binding [5] code for converting XML to a speci.c data-type, and the generation of object-relational \nbinding code for connecting an object-oriented program to a database system. Numer\u00adous tools are available \nfor these purposes; LLBLGen [4] is an object-relational binding generator; ApiGen [16] and JTB [42] are \nabstract syntax tree generators, JAXB [25] and Castor [14] are XML data binding tools, to name but a \nfew. The implementation of a code generator requires an in\u00adternal representation of program code and \nan interface for accessing this representation in order to compose and trans\u00adform code fragments. Ideally, \ngenerators use a structured representation of programs, i.e. a data-structure to repre\u00adsent abstract \nsyntax trees. Such a representation makes it easy to compose, analyze, and transform fragments. For example, \nthe XML data binding tool JAXB uses a full ab\u00adstract syntax tree in its code generator. However, in prac\u00adtice, \nmany generators are string-based, meaning that code is generated by directly printing strings to a .le, \nor by rep\u00adresenting fragments as strings and composing those. For example and ironically, the abstract \nsyntax tree generators ApiGen [16] and JTB [42] are text-based code generators. Castor [14] is an example \nof a hybrid approach which uses a combination of an abstract syntax tree for the global struc\u00adture and \ntext for method bodies. Neither implementation using a data-structure, nor using string literals is satisfactory. \nThe advantage of using string literals or text templates is that one can use concrete syn\u00adtax, i.e. the \nfragments are readable as program code, and it is trivial to implement. The approach is illustrated by \nthe Castor example in Figure 1, which builds up a string representation of a program fragment. However, \nthe dis\u00adadvantages far outweigh the advantages. Escaping to the host language to insert a fragment of \ncode computed else\u00adwhere is cumbersome. The syntax of the generated code is not checked. No further manipulation \nof the code is possi\u00adble. And runtime overhead is incurred for parsing, analysis, compilation or interpretation \nif code is to be executed. The advantage of using a data-structure is that the gener\u00adated code is structured \nand is amenable to further process\u00ading. Type correctness of the generator often entails syntactic correctness \nof the generated program. It is also easy to im\u00adplement in a general purpose object-oriented language. \nThe approach requires the creation of a class hierarchy which can be substantial for a real language. \nCode generators such as String x = \"propertyChangeListeners\"; jsc.add(\"if (\"); jsc.append(x); jsc.append(\" \n== null) return;\"); jsc.add(\"PropertyChangeEvent event = new \"); jsc.append(\"PropertyChangeEvent\"); jsc.append(\"(this, \nf, v1, v2);\"); jsc.add(\"\"); jsc.add(\"for (int i = 0; i < \"); jsc.append(x); jsc.append(\".size(); i++) \n{\"); jsc.indent(); jsc.add(\"((PropertyChangeListener) \"); jsc.append(x); jsc.append(\".elementAt(i)).\"); \njsc.append(\"propertyChange(event);\"); jsc.unindent(); jsc.add(\"}\"); Figure 1: Code generation in Castor. \nATerm x = id |[ propertyChangeListeners ]|; ATerm stm = bstm |[{ if(x == null) return; PropertyChangeEvent \nevent = new PropertyChangeEvent(this, f, v1, v1); for(int c=0; c < x.size(); c++) { ((...)x.elementAt(c)).propertyChange(event); \n} } ]|; Figure 2: Code generation with concrete syntax. ApiGen andJTB canbe usedfor that purpose. However, \ncomposition of code fragments is done via calls to the code API, leading to very verbose meta-programs. \nIt is usually hard to understand the structure of the generated code when inspecting such meta-programs. \nThe MetaBorg method combines the best of both worlds. Code fragments are written using the concrete syntax \nof the programming language, but the implementation is based on an API for code representation. This \nis illustrated in Fig\u00adure 2 with a fragment of a Java program generating a Java program, corresponding \nto the example in Figure 1. The generator uses ATerms [8] for the representation of gener\u00adated code. \nInstead of using constructors from the ATerm class hierarchy to create a code fragment, it is written \nas a regular piece of Java code. The code fragments are dis\u00adtinguished from the surrounding code by the \ndelimiters |[ and ]|. The delimiters are not .xed in MetaBorg and can even be left out when appropriate. \nThe bstm and id tags are used to indicate that the fragments are of syntactic cate\u00adgory statement and \nidenti.er respectively. A fragment does not need to be closed, but can incorporate code fragments generated \nelsewhere. For example, in Figure 2 the identi.er assigned to variable x is used in the fragment assigned \nto the variable stm. Meta-programs with embedded object-program fragments are translated to pure Java \nprograms in which code con\u00adstruction is expressed directly in terms of calls to the code out.startDocument(); \nout.startElement(\"\", \"html\", \"html\", noAttrs); out.startElement(\"\", \"body\", \"body\", noAttrs); out.startElement(\"\", \n\"p\", \"p\", noAttrs); out.characters(text.toCharArray(), 0, text.length()); out.endElement(\"\", \"p\", \"p\"); \nout.endElement(\"\", \"body\", \"body\"); out.endElement(\"\", \"html\", \"html\"); out.endDocument(); Figure 3: \nComposition of an XML document in Co\u00adcoon. out.write document %> <html> <body> <p><% text :: cdata %></p> \n</body> </html> <%; Figure 4: Composition of an XML document with concrete syntax with underlying SAX \nCon\u00adtentHandler invocations. representation API. This tool also guarantees that the code fragments are \nsyntactically correct. The type system of the host language and a properly de.ned underlying API will \nthen guarantee that compositions are syntactically correct as well. Note that MetaBorg is not restricted \nto Java in Java. The same method can be used to embed other languages in Java (e.g. to generate C# code), \nor to use a di.erent host language (e.g. to generate Java code with a C# program). The realization of \nthese embeddings will be discussed in Sec\u00adtion 3.  2.2 XML Document Generation XML is used on a large \nscale for the exchange of data be\u00adtween programs. This requires programs to read and write XML documents \nand to convert internal data to XML and back. Applications that generate XML documents by .lling in templates \nsu.er from the lack of support for XML syn\u00adtax in general purpose programming languages. The prob\u00adlems \nare similar to that in code generation. Text-based solu\u00adtions cannot guarantee that the produced text \nis well-formed XML. Typical examples are server-side scripting languages such as JSP and ASP .NET, which \nsupport the embedding of a programming language in XML or HTML. Further ma\u00adnipulation of the document \nafter generation is impossible. A typical example of post generation transformation is the ad\u00addition \nof statistics to a generated web page. Many web page generators just put this information outside the \nHTML tags, which is of course invalid, but is accepted by web browsers if the page does not claim to \nbe well-formed XML. Other solutions are based on data structures. In libraries such as W3C DOM, JDOM, \nand XOM, documents are rep\u00adresented by instances of classes corresponding to the generic structure of \nXML, e.g. Document, Element,and Attribute. Thus document construction is achieved with the construc\u00adtors \nof these classes. Alternatively, construction can be achieved with events emitted to a SAX ContentHandler, \n Figure 5: A program with embedded concrete syn\u00adtax (e.g., for XML) is translated to a pure Java pro\u00adgram. \nwhich can be an XML serializer or a DOM constructor, as illustrated in Figure 3 with a code fragment \nfrom Cocoon [15]. By using these APIs the code is guaranteed to produce well-formed XML as long as the \nlibrary does its job prop\u00aderly. However, these solutions result in sequences of method invocations that \nare hard to read. The MetaBorg solution is the same as in the case of code generation. There is a good \nnotation for this domain, i.e., XML itself. With the MetaBorg method we make this no\u00adtation available \nto the application programmer, while keep\u00ading the properties of APIs for structured representation of \ndocuments. Figure 4 shows a statement in a Java program with an embedded XML document. The symbols %> \nand <% are used to delimit the embedded XML from the surround\u00ading code. Within the document is a reference \nto a document fragment de.ned earlier in the program, using the <% and %> antiquotation delimiters. The \nassimilation process (Fig\u00adure 5) transforms a Java program with embedded XML to apure Javaprogram with \ncalls toaSAX ContentHandler. The big di.erence between the embedding of XML and the embedding of a programming \nlanguage is that the lexical structure of XML is completely di.erent from that of, say, Java. This makes \nthe parsing problem more complicated. 2.3 Graphical User-Interface Construction In the cases of code \nand XML generation a domain nota\u00adtion is readily available to improve the readability of appli\u00adcation \nprograms. However, there are many other domains with APIs representing a language in the sense of a coher\u00adent \nset of concepts and composition facilities, but without a concrete notation. Programming in these domains \ncan also be improved by employing domain-speci.c notation, which should then .rst be designed. Consider \nfor example the con\u00adstruction of graphical user-interfaces in Java. Graphical user-interfaces can be \ngenerated with a visual tool or can be written by hand. A handwritten user-interface typically instantiates \nGUI components such as buttons and text.elds and arranges these components in panels by using .xed positioning \nor a layout manager that allows the user\u00adinterface to adapt itself to changes in the size of the window. \nDespite catalogs of design patterns for developing graphical user-interfaces, this code is still one \nof the most unwieldy parts of a program (Figure 6; left). A handwritten user\u00adinterface takes quite a \nfew lines of code and the resulting code is di.cult to understand and maintain. There are a few proposals \nfor languages speci.cally geared towards user-interfaces, e.g. Mozilla s XUL, W3C s XForms and Microsoft \ns XAML, but these solutions do not integrate JTextArea text = new JTextArea(20,40); JPanel panel = new \nJPanel(new BorderLayout(12,12)); panel.setBorder( BorderFactory.createEmptyBorder(15, 15, 15, 15) ); \npanel.add(BorderLayout.NORTH, new JLabel(\"Please enter your message\")); panel.add(BorderLayout.CENTER, \nnew JScrollPane(text)); JPanel south = new JPanel(new BorderLayout(12,12)); JPanel buttons = new JPanel(new \nGridLayout(1, 2, 12, 12)); buttons.add(new JButton(\"Ok\")); buttons.add(new JButton(\"Cancel\")); south.add(BorderLayout.EAST, \nbuttons); panel.add(BorderLayout.SOUTH, south); Figure 6: Sequence of statements for composing a user-interface \nwith Swing API methods (left) and Swul implementation for composing the same user-interface (right). \nJPanel panel = panel of border layout { hgap =12 vgap =12 north = label \"Please enter your message\" center \n= scrollpane of textarea { rows = 20 columns = 40 } south = panel of border layout { east = panel of \ngrid layout { hgap =12 vgap =12 row={ button \"Ok\" button \"Cancel\" } } } }; well with the host language. \nThey abstract from a GUI toolkit, which is not always an advantage, and restrict the way the GUI can \ninteract with the host language. XUL clones for Java, such as SwiXml and Luxor, use re.ection and a convention \nfor the location of methods (or Action .elds) to invoke code in the host language. Although this works \nreasonably well, it limits the way the host language is able to interact with the GUI code. For example, \na model\u00adview-controller design, where the GUI components are di\u00adrectly updated from their (Swing) models, \nis not possible in these toolkits. Furthermore, the XML formatted GUI spec\u00adi.cations are interpreted, \nnot checked statically for internal consistency or correct interaction with code in the host lan\u00adguage. \nUsing the MetaBorg method we have developed a solu\u00adtion that provides domain-speci.c notation for the \nconstruc\u00adtion of user-interfaces and integrates well with the rest of the program written in the host \nlanguage. Expressions in the Swing User-interface Language (Swul) correspond to com\u00adponents of a Swing \nuser-interface. The language encourages the compositional construction of complex components, in contrast \nto the assembly language spaghetti style used with direct calls to Swing. Thus, subcomponents are subexpres\u00adsions, \nand are not added afterwards. Attributes of compo\u00adnents are named, avoiding the need to continuously \nlooking up the order of method parameters. The declaration of the layout style is combined with the instantiation \nof the sub\u00adcomponents. Embedded in Java the Swul language can be used directly to program user-interfaces. \nSwul expressions can refer to elements such as variables and methods from other parts of the program. \nFor example, in order to set the value of a layout attribute or to pass an event-handler. The example \nin Figure 6 (right) illustrates the use of Swul, creating in a single Java assignment (be it multiline), \nthe same user-interface implemented directly using Swing methods on the left. Although the Swul solution \nuses more lines, the di.erence in number of non-space characters (507 vs 243) indicates that the Swul \nsolution is signi.cantly more concise.  2.4 Other Applications We have discussed three application domains \nin which concrete domain notation improves programs. The same approach can be applied to many other domains, \nincluding embedded query languages such as XPath and SQL. Unfor\u00adtunately, queries in these languages \nare usually embedded in string literals. They are often even composed at runtime by concatenating strings. \nIn this case the SQL statements and XPath queries cannot be checked syntactically at compile time. This \nmight result in runtime errors or, even worse, security problems. If a value from the host language is \nem\u00adbedded in an SQL query by string concatenation, then there is no guarantee that the string actually \nis of the syntactic category expected at this point in the SQL statement. This results in a security \nissue that is rather easy to exploit by entering SQL constructs where plain strings are expected. To \nprevent this, the embedded string has to be escaped. A missing escape will immediately pose a security \nthreat. This is a general problem of runtime composition of code fragments by string concatenation. XML \napplications that use string concatenation might be a security risk as well. In such applications proper \nescaping is required at many dif\u00adferent places in the code. This task can be automated by applying our \nlanguage embedding tools. Another example of a little language that is often embed\u00added in string literals \nis the language of regular expressions used for pattern matching of character sequences. A regular expression \nis encoded in a string literal which is interpreted or compiled at runtime to a matcher. The clarity \nof a reg\u00adular expression is reduced by requiring special characters to be escaped. C# reduces the number \nof characters that have to be escaped by adding verbatim strings to the language, where only double quotes \nhave to be escaped. Just as in all string literal based embeddings the regular expression is not checked \nsyntactically at compile-time. The di.erence with the other examples is that the libraries operating \non these languages usually only accept textual input. This makes a structured representation of the query \nmore annoying than advantageous. Yet, the MetaBorg method can still be used by assimilating the embedded \ncode fragments to the corresponding string operations. This will make the embedding of meta values safer \nand easier, and the embedding will guarantee the syntactic correctness of the embedded expressions. To \nthis end the MetaBorg tools support the representation of embedded fragments in a full parse tree, which \ncan be yielded to a string. Figure 7: Architecture of embedding and assimila\u00adtion framework. REALIZING \nCONCRETE SYNTAX Introducing domain-speci.c notation in a host language module Java-Tuple imports Generic-Java \nexports context-free syntax \"(\" Expr \",\" Expr \")\" -> Expr {cons(\"NewTuple\")} \"(\" Type \",\" Type \")\" -> \nType {cons(\"TupleType\")} Figure 8: Syntax de.nition of Java with tuples. module Java-Tuple-Assimilate \nimports Generic-Java rules AssimilateTuple : expr |[(e1 , e2 )]|-> expr |[ Tuple.construct(e1 , e2 )]| \nAssimilateTuple : type |[(t1 , t2 )]|-> type |[ Tuple<t1 , t2 >]| 3. requires (1) an embedding of the \ndomain-speci.c language in the host language and (2) assimilation of the embedded domain fragments into \nthe surrounding host code. In this section we describe the method of embedding and assimila\u00adtion from \nthe point of view of the meta-programmer creat\u00ading the embedding. We illustrate the method with several \nexamples. In the next sections the technology behind the method will be discussed.  3.1 Embedding and \nAssimilation The architecture of the MetaBorg method is illustrated by the diagram in Figure 7. The embedding \nof domain no\u00adtation in a host language requires a syntax de.nition for the host language, a syntax de.nition \nfor the embedded lan\u00adguage, and a syntax de.nition for the combination of the two languages, embedding \nthe latter in the former. A parser then uses this combined syntax de.nition to parse programs in the \nextended language. Next, an assimilator applies a set of rules to assimilate the embedded domain fragments, \nreducing the program to the pure host language. The diagram also illustrates the roles of programmer, \nmeta\u00adprogrammer, and MetaBorg tooling. An application pro\u00adgrammer using the domain extension uses the \ncombination of parser and assimilator for the extension as a single tool, which could even be integrated \nwith the compiler. Thus, programming in the extended language is no di.erent than programming in the \nhost language, except for the additional expressivity that is available. The meta-programmer imple\u00admenting \na domain extension needs to provide the syntax de.nitions for host and domain language, the syntax for \nthe embedding and the assimilation rules. Generally, the syntax de.nition for the host language can be \nreused from a library of syntax de.nitions. The syntax de.nition of the domain language can be reused \nas well, if the domain language is an existing language that is already used on its own. If the host \nAPI is a shared target between several domain nota\u00adtions, then a set of generic assimilation rules can \nbe used. This is typically the case for meta-programming domains where a standard API for abstract syntax \ntrees is used. Fi\u00adnally, syntax de.nitions and assimilation rules are processed by the generic tools \nprovided in the Stratego/XT toolset [41, Figure 9: Rewrite rules for assimilation of tuples in Java \n47]; MetaBorg can be considered as a particular pattern of usage of these tools. To make these concepts \nmore concrete we will illustrate the method with several examples. Before diving into the interesting \naspects, we look at a very simple example, i.e. the extension of Java 1.5 with concrete syntax for tuples. \nTuples are instances of a class Tuple<A, B>, which is pa\u00adrameterized with the type of the .rst and second \nitem of the tuple. We de.ne an extension of Java providing the notation (x,y) for the construction and \ndeclaration of tuples. Thus, (Integer, String) is a type expression and corresponds to the type Tuple<Integer, \nString>. The expression (1, \"foo\") is an instance of Tuple<Integer, String>,where the .rst item in the \ntuple is the integer 1 and the second is the String \"foo\". To realize this extension all we need is the \nsyntax def\u00adinition in Figure 8 and the assimilation rules in Figure 9. The syntax de.nition in Figure \n8 de.nes the language Java-Tuple, which extends Java with syntax for tuple expressions and tuple types. \nThe extension of the Java language is achieved by a simple import of the syntax de.nition of Java. Thus, \nit is not necessary to create a copy of that syntax def\u00adinition and add the rules for tuples to it. The \nJava-Tuple syntax module is written in SDF, which is the syntax de.\u00adnition formalism employed by MetaBorg. \nA syntax de.ni\u00adtion mainly consists of productions of the form s1 ... sn -> s0 {cons(\"c\")}, declaring \nthat a phrase of type s0 can be formed by concatenating phrases of types s0 ... sn.The constructor c \nis a name for the production that is used in the construction of abstract syntax trees. The features \nof SDF that enable concise modular syntax de.nition will be explained in Section 4. Assimilation of the \nlanguage extension is achieved by trans\u00adlating the new language constructs to the base language. For \nexample, the Java-Tuple declaration (Integer, String) t = (1, \"Hello world!\"); is translated into the \nJava declaration Tuple<Integer , String> t = Tuple.construct(1 , \"Hello world!\"); This translation is \nachieved by the rewrite rules in Figure 9. The assimilation into the host language is implemented in \nthe Stratego program transformation language. Rewrite rules play a central role in Stratego. A labeled \nrewrite rule L: p1 -> p2 rewrites a program fragment matching the pattern p1 to the program fragment \np2,where the meta\u00advariables in p2 are instantiated with the corresponding frag\u00adments found when matching \np1. In the .rst rewrite rule of Figure 9, e1 and e2 are meta-variables denoting Java expressions. In \nthe second, t1 and t2 are meta-variables denoting Java types. Thus, the .rst rule replaces a tuple expression \n(e1, e2 ) with acalltothe construct method of the Tuple class, passing the expressions e1 and e2 . Note \nthat the Stratego rewrite rules use concrete syntax as well. That is, the rules are transformations on \nJava pro\u00adgrams and thus use the syntax of Java to indicate code frag\u00adments. However, the rules are implemented \nas transforma\u00adtions on abstract syntax trees. This is achieved by the same method as applied to Java \nprograms [46].  3.2 Java with Swul Next we examine a serious example, i.e. the embedding of Swul,the \nSwing User-interface Language, into Java. Plain Java code using the Swing API is a kind of assembly lan\u00adguage \nin which intermediate results are bound to variables to be used elsewhere. This is illustrated in Figure \n6. We have custom designed Swul in order to provide a compo\u00adsitional syntax for the construction of user-interfaces \nwith Swing in Java. Swul is just a more attractive notation for the same code. The assimilation of embedded \nSwul pro\u00adduces the sequence of statements that one would normally write by hand. 3.2.1 Embedding Swul \nis de.ned as a separate language with its own syn\u00adtax de.nition in SDF module Swul, introducing productions \nsuch as \"panel\" \"of\" Layout -> Component {cons(\"Panel\")} \"border\" \"layout\" \"{\" LayoutProp* \"}\" -> Layout \n{cons(\"BorderLayout\")} to de.ne syntax for Swing concepts such as panels and layout schemes. The embedding \nof the language in Java is achieved by creating a new SDF module Java-Swul (Figure 10) that im\u00adports \nthe syntax of Java and the syntax of Swul. The actual imported modules are pre.xed wrappers of the real \nsyntax de.nition, a feature of SDF further explained below. Combining the two syntax de.nitions by importing \nthem in a new module does not actually achieve the embedding of the syntax of Swul into Java. The languages \nare strictly separated from each other since the productions of Java do not refer to non-terminals of \nSwul and vice versa. The em\u00adbedding of Swul in Java is achieved by adding productions to the combined \nsyntax de.nition that allow Swul expres\u00adsions to be used as Java expressions and vice versa. These productions \njust connect the languages at the desired loca\u00adtion. Note that the embedding of the language is completely \nuser-de.nable with an ordinary SDF module. module Java-Swul imports Java-Prefixed Swul-Prefixed exports \ncontext-free syntax SwulComponent -> JavaExpr {cons(\"ToExpr\")} SwulLayout -> JavaExpr {cons(\"ToExpr\")} \nJavaExpr -> SwulBorder {cons(\"FromExpr\")} JavaExpr -> SwulComponent {cons(\"FromExpr\")} Figure 10: Syntax \nde.nition of Java with Swul; concrete syntax for user-interface construction with Swing Swulc-Component \n: swul |[ scrollpane of c ]|-> expr |[ new JScrollPane(e )]| where <Swulc-Component> c => e Swulc-Component \n: swul |[ textarea {ps* }]|-> expr |[ {|JTextArea x = new JTextArea(); bstm* |x |} ]| where new => x \n; <map(Swulc-SetProp(|x ))> ps* => bstm* Swulc-AddComponent(|x ): swul |[ north = c ]|-> bstm |[ x.add(BorderLayout.NORTH, \ne ); ]| where <Swulc-Component> c => e Swulc-Layout : swul |[ grid layout {ps* }]|-> expr |[ new GridLayout(i \n,j )]| where <nr-of-rows> ps* => i ; <nr-of-columns> ps* => j Swulc-SetProp(|x ): swul |[ border = b \n]|-> bstm |[ x.setBorder(e ); ]| where <Swulc-Border> b => e Swulc-Component : swul |[ x : c ]| -> expr \n|[{| tx = e ;| x |} ]| where <java-type-of> c => t ; <Swulc-Component> c => e Figure 11: Some of the \nrewrite rules for assimilation of GUI abstractions using Swing API. module Java-Prefixed imports Java \n[ ImportDec => JavaImportDec CompilationUnit => JavaCompilationUnit TypeDec => JavaTypeDec .... Expr \n=> JavaExpr ]  Figure 12: Syntax de.nition that pre.xes all Java non-terminals with the name of the \nlanguage. The kind of connection between the languages is indicated by speci.c constructor names. Productions \nthat allow Swul constructs to be used as Java expressions use the constructor ToExpr. Similarly, productions \nthat allow Java expressions to be used in Swul use the constructor FromExpr.Thus, in the embedding de.ned \nabove, the ToExpr productions de\u00adclare that Swul component and layout expressions can be used as Java \nexpressions. The FromExpr productions declare that Java expressions can be used as Swul border or com\u00adponent \nexpressions. Note that no special quotation symbols are needed to inject Swul expressions into Java expressions \nor vice versa. Another point to note about the embedding is the import of the modules Java-Prefixed and \nSwul-Prefixed instead of Java and Swul.The -Prefixed SDF modules are (gen\u00aderated) SDF modules that import \nthe actual syntax and rename all non-terminals in this imported de.nition by pre\u00ad.xing them with the \nname of the language. An example of such a module is shown in Figure 12. Note that these renamings do \nnot require an actual copy of the de.nitions, but rather an import with a set of renamings applied. These \nrenamings are necessary to keep the two languages strictly separated, except for the explicitly de.ned \nconnec\u00adtions. For example, both languages might de.ne an Id or Expr non-terminal. If these syntax de.nitions \nare just imported directly, then there will be just one Id or Expr non-terminal. Productions using these \nnon-terminals will then refer to the productions for these non-terminals from both languages. This embedding \nis not explicit and should therefore be prevented. By making the non-terminal names unique for both languages, \nundesired embedding is avoided.  3.2.2 Assimilation Assimilation is again achieved via rewrite rules \nimple\u00admented in Stratego. The rewrite rules transform Swul ex\u00adpressions to Java expressions. These rules \nexpress the knowl\u00adedge of the Swing API captured in the language by trans\u00adlating each Swul construct \nto the appropriate sequence of Swing method calls. Figure 11 illustrates this for some of the Swul constructs. \nNote again that although these examples are all written in concrete syntax, the actual representation \nthat is being transformed is a structured abstract syntax tree. The Swul and Java code fragments are \nall syntacti\u00adcally checked when compiling the generator. Most of the rewrite rules have a where clause. \nThe Strat\u00adego construct <s> t => p applies the rewriting s to the ex\u00adpression t and matches the result \nof applying s to t to the pattern p. In the examples the patterns are simple variables. In this case, \n<s> t => x is comparable to an ordinary assign\u00adment of s applied to t to the variable x. The rewrite \nrules use meta-variables in the code fragments. That is, ps* , c , x , e and bstm* are Stratego variables, \nused directly in the Java code fragment. These variables are bound to abstract syntax trees and are not \nmatched literally as Java variables. The Stratego primitive new (usedinthe where clauses) gen\u00aderates \na new unique identi.er. Most rewrite rules in Figure 11 are straightforward trans\u00adlations from Swul constructs \nto corresponding Swing API invocations. For example, the rewrite rule for a scrollpane directly translates \ninto a constructor call of the JScrollPane class. Some constructs in Swul provide even more abstrac\u00adtion \nthan an alternative syntax. For example, the rewrite rule for the grid layout calculates the number of \nrows and columns. The rewrite rule for the Swul construct x : c , the last rule in the .gure, shows another \nabstraction; if pos\u00adsible, it determines the type of the component and declares avariable x of this type \nwith the initial value c . This in\u00adline declaration is very useful since Swul does not cover the full \nSwing API, but just the most common constructs. If unusual things have to be con.gured for a component, \nthen this can be done later without ruining the compositional de.nition of the user-interface. The transformation \nmakes use of a convenience exten\u00adsion of Java with expression blocks, which are removed by a separate \ntransformation. In fact the compositional na\u00adture of Swul (and other extensions) is based on this exten\u00adsion. \nConstructing Java objects is composable in Java itself as long as all required operations can be performed \nby in\u00advoking a single method or constructor. As soon as further method calls are required there is a \nproblem in composing objects without binding them to intermediate variables. The extension of Java with \nexpression blocks solves this prob\u00adlem introducing two expression: {| bstm* | e |} and {| e | bstm* |}. \nAn expression block is thus a list of block\u00adlevel statements followed by an expression or the other way \naround. The expression is the value of the expression block. In the .rst case the statements are lifted \nto the block-level statements before the context expression. In the second case they will be lifted to \nblock-level statements after the context expression. The syntax of this extension is de.ned by two SDF \nproduction rules and the constructs are translated into ordinary Java by a small Stratego program. The \nexpression block extension makes the de.nition of assimilation, and code generators in general, much \nsimpler. For example, the declaration of a textarea{ps* } is trans\u00adlated to a declaration of a new variable \nx of type JTextArea, which is instantiated to a new JTextArea. The instantiation of the properties of \nthe textarea is achieved with additional statements, which are executed after creating the textarea. \nThe context in which the textarea was placed receives as value the variable x . Thus a linear sequence \nof statements building the components of the user-interface is realized.  3.3 Java with XML Our next \nexample is the embedding of XML in Java. The application of this embedding was illustrated in Figure \n4. 3.3.1 Embedding Some of the production rules of the syntax embedding are shown in Figure 13. These \nproduction rules are somewhat di.erent from usual embeddings, since the embedded XML syntax is translated \nto the SAX API. XML construction in SAX is not done using expressions and objects, but by invok\u00ading methods \nof the ContentHandler interface. Typically, the methods of a ContentHandler are invoked to report pars\u00ading \nevents of an XML parser as callbacks to an application. However, any code can use the ContentHandler \ninterface to report the content of an XML document. The embedding extends Java with syntax for writing \nXML content to a ContentHandler.The ContentHandler instance is speci.ed by a Java identi.er. The ToStm \nand Write con\u00adstructors are used to represent the switch from Java to XML. The Write constructor has \ntwo arguments: a Java identi.er of the ContentHandler and the XML content to write to it. In addition \nto the embedding of XML in Java, we also de\u00ad.ne production rules for escaping from XML back to Java. \ncontext-free syntax ObjectStm -> JavaStm {cons(\"ToStm\")} JavaId \".\" \"write\" \"%>\" Content \"<%\" \";\" -> \nObjectStm {cons(\"Write\")} JavaId \".\" \"write\" \"document\" \"%>\" Document \"<%\" \";\" -> ObjectStm {cons(\"Write\")} \n\"<%\" JavaStm \"%>\" -> Content {cons(\"FromStm\")} \"<%\" JavaExpr \"%>\" -> DoubleQuotedPart {cons(\"FromExpr\")} \n\"<%\" JavaExpr \"::\" \"cdata\" \"%>\" -> Content {cons(\"TextFromExpr\")} Figure 13: Syntax de.nition of Java \nwith XML explode-write : ToStm(Write(Id(x ), c )) ->bstm |[{ bstm* }]| where <content-to-stm(|x )> c \n=> bstm* content-to-stm(|x ): Document(c )-> bstm* |[ x.startDocument(); bstm1* x.endDocument(); ]| \nwhere <content-to-stms(|x )> c => bstm1* content-to-stm(|x ): Element(Name(None(), n ), atts , kids \n)-> bstm* |[ org.xml.sax.helpers.AttributesImpl y = new org.xml.sax.helpers.AttributesImpl(); bstm1* \nx.startElement(\"\", \"~n \", \"~n \", y ); bstm2* x.endElement(\"\", \"~n \", \"~n \"); ]| where <map(content-to-stms(|x \n))> kids => bstm2* ; new => y ; <map(attr-to-stm(|y ))> atts => bstm1* content-to-stm(|x ): TextFromExpr(e \n)-> bstm |[ x.characters({| String y = e ;| y.toCharArray() |}, 0, y.length()); ]| where new => y content-to-stm(|x \n): Text(s )-> bstm* |[ x.characters(new char[]{e* }, 0, i ); ]| where <explode-string> s => cs ; <length; \nint-to-string> cs => i ; <map(escape-char)> cs => e* Figure 14: Rewrite rules for assimilation of XML \nto SAX ContentHandler invocations. First, the escape from XML content to Java is represented by the \nFromStm constructor. This escape consists of a Java statement, which might be surprising, since an escape \nto the host language usually is an expression. However, the SAX ContentHandler produces XML content by \nstatements, not by expressions. Second, the embedding de.nes an escape from XML attribute values (DoubleQuotedPart)to \nJava. Third, the embedding de.nes a more speci.c anti-quotation for character data, using the constructor \nTextFromExpr.The result of the Java expression must be a String, which is emit\u00adted to the ContentHandler. \n 3.3.2 Assimilation Most of the Stratego rewrite rules for the assimilation of the embedded XML fragments \ninto Java are shown in Fig\u00adure 14. For a single XML construct the resulting code frag\u00adments are now larger \nthan in the previous examples. Hence, the XML syntax of this embedding is a major abstraction from the \nAPI interface provided by SAX. In this assimila\u00adtion, the left-hand side of the rewrite rules are not \nwritten in concrete XML syntax, but rather in abstract syntax. The left-hand side patterns are so small \nthat using concrete syn\u00adtax would only be confusing. This illustrates that programs using concrete syntax \ncan fall-back to the assimilated nota\u00adtion in the host language (in this case abstract syntax for XML) \nwhen this is more appropriate. Figure 14 shows the rewrite rules for XML documents, elements, text and \ncharacter data escapes to Java. The translation of Document and Text is straightforward. The translation \nof an Element is somewhat more involved, since the list of attributes has to be assimilated into an instance \nof the AttributesImpl class. Character data escapes to Java are translated using the expression blocks, \nas discussed be\u00adfore. This translation to an expression block is necessary because we need the value \nat multiple locations; for calcu\u00adlating the length of the string and for translating it into a character \narray that is passed to the ContentHandler.Note that the rules use several meta-variables: x , y , bstm1* \n, bstm2* ,and e* . Also, the translation of an XML element uses a special construct inside a string literal: \n\"~n \".The ~ construct denotes an escape to the host language, which is Stratego in this case. Anti-quotation \nand meta-variables inside such lexical constructs are a unique feature of SDF and SGLR. This is possible \nby preserving the structure of lexemes, which will be discussed in more detail in Section 4.  3.4 Java \nwith Java Lastly, we return to our .rst example in Section 2: Java embedded in Java. This combined language \nis called Java-Java. JavaJava is a language for Java meta-programming, context-free syntax \"|[\" Expr \n\"]|\" -> JavaExpr {cons(\"ToExpr\")} \"expr\" \"|[\" Expr \"]|\" -> JavaExpr {...} \"type\" \"|[\" Type \"]|\" -> JavaExpr \n{...} \"bstm*\" \"|[\" BlockStm* \"]|\" -> JavaExpr {...} \"~\" JavaExpr -> Expr {cons(\"FromExpr\")} \"~*\" JavaExpr \n-> {Expr \",\"}* {...} \"~*\" JavaExpr -> {VarInit \",\"}* {...} \"~*\" JavaExpr -> {FormalParam \",\"}* {...} \n\"~*\" JavaExpr -> ClassBodyDec* {...} variables \"e\" [0-9]* -> Expr {prefer} \"t\" [0-9]* -> Type {prefer} \n\"e\" [0-9]* \"*\" -> {Expr \",\"}* {prefer} \"e\" [0-9]* \"*\" -> {VarInit \",\"}* {prefer} \"bstm\" [0-9]* \"*\" -> \nBlockStm* {prefer} [ij] [0-9]* -> DeciLiteral {prefer} [xyz] [0-9]* -> Id {prefer} Figure 15: Syntax \nde.nition of Java with Java i.e. Java programs that generate or manipulate Java pro\u00adgrams. The embedding \nand assimilation of JavaJava are de.ned with the MetaBorg method. The implementation involves the de.nition \nof an embedding of Java in Java, and an assimilation of the embedded Java fragments into the host language. \n 3.4.1 Embedding A selected number of productions from the embedding of Java in Java are shown in Figure \n15. The complete embed\u00adding is much larger, since the Java syntax de.nition contains many non-terminals. \nFor each non-terminal that is to be quoted or anti-quoted in JavaJava, productions have to be de.ned \nin the combined syntax de.nition. The JavaJava syntax de.nition applies some of the more advanced features \nin SDF for combining the syntax of the embedded language and the host language. The .rst two productions \nshow that the declaration of non-terminals of concrete syntax fragments is optional. To this end, there \nis a production rule for embedding Java ex\u00adpressions using just the quotation symbols |[ and ]| and there \nis a production with an explicit declaration expr of the non\u00adterminal. The embedding of BlockStm* shows \nthat lists of non-terminals, in this case BlockStm, can be embedded as well. The escapes to the meta \nlevel use the ~ symbol in this em\u00adbedding. That is, meta Java expressions can be included by using only \na ~ before the meta expression. The ~* escape can be used to escape to a Java expression that produces \na list of a certain non-terminal, even if they are separated by tokens. The ~* escape is de.ned by an \nSDF produc\u00adtion rule that produces a list non-terminal (the right-hand side of the production rules). \nFor example, the escape for {Expr \",\"}* is used in method invocations, which take a number of expressions \nseparated by commas. In the ar\u00adgument list of a method in concrete syntax it is possible to escape to \nthe meta level using foo(~*args ), but even foo(\"bar\",~arg,~*args ) and foo(~*args1,~*args2 ) are allowed. \nAll these escape are de.ned by a single production rule in the embedding of Java in Java. No additional \nSDF productions are required, since productions that produce list symbols are desugared to a set of more \nbasic productions that are su.cient to handle all these combinations. JavaJava also provides meta-variables, \nwhich is an even more compact method for embedding variables from the meta language in embedded code \nfragments. The SDF syn\u00adtax de.nition formalism has been designed for application in meta-programming \nand therefore it has the built-in notion of meta-variables. Meta-variables are de.ned in a variables \nsection. This section consists of SDF productions that de\u00ad.ne a special meaning for certain identi.ers. \nFor example, the .rst production in the variables section of Figure 15 de.nes that the identi.er e is \na meta-variable denoting a Java expression. Some other meta-variables in JavaJava are e* for lists of \nexpressions separated by commas and x , y ,and z for identi.ers. 3.4.2 Assimilation The MetaBorg examples \nof Java with Swul and Java with XML apply assimilations that are speci.c to the host language and the \nembedded language. The assimilation can\u00adnot be reused for di.erent embedded languages since the as\u00adsimilator \nrewrites speci.c constructs of the embedded lan\u00adguage to the host language. Such a speci.c assimilator \ncan incorporate domain-speci.c knowledge, which adds a level of abstraction to the syntactic embedding. \nFor example, the Swul assimilator calculates the number of rows and columns of a GridLayout. However, \nfor some applications it is possible to implement a generic assimilation of an arbitrary embedded language \nto an API in the host language. Hence, the assimilation can be reused for the embedding of any language \nin the host language. For instance, generic assimilation is possible for assimilating embedded languages \nin meta-programming. Meta-programming frameworks often follow a certain stan\u00addard procedure for representing \na subject program in a class hierarchy. Examples of such frameworks are JJForester [28], ApiGen [16], \nJava Tree Builder [42] with JavaCC [24], and SableCC [20]. For a speci.c meta-programming framework the \nmapping from a language de.nition to a class structure is .xed or at least reproducible. This .xed translation \nscheme can be used for the implementation of a generic assimilator. Similarly, a generic assimilator \nis also possible if the target API itself is generic. This is the case if the embedded lan\u00adguage is to \nbe represented using a generic class hierarchy for trees, such as ATerms [8] or XML. The generic assimilation \nfrom an embedded language to the construction of a generic tree representation can be im\u00adplemented particularly \nwell in a language that supports ge\u00adneric programming. To illustrate the implementation of a generic \nassimilation we have implemented an assimila\u00adtion from the embedded Java code in the JavaJava lan\u00adguage \nto the ATerm library. A generic assimilation requires generic programming. Stratego allows generic term \ncon\u00adstruction and deconstruction using the # operator. A term foo(bar(), fred()) can be deconstructed \ninto the con\u00adstructor of the term, foo, and a list of children to which the construct is applied, bar() \nand fred(). The pattern fun #([t* ]) binds the constructor name to the variable fun and the list of children \nto the variable t* . AssimilateAppl(x) : fun #([t* ]){} -> |[ _factory.makeAppl(e , e* )]| where <AssimilateAFun> \n(fun , <length> t* )=> e ; <map(x)> t* => e* AssimilateAFun : (fun , arity )-> |[ _factory.makeAFun(\"~fun \n\", i , false) ]| where <int-to-string> arity => i AssimilateMetaVar(x) : meta-var(x ) -> expr |[ x ]| \nAssimilateInt(x) : i -> expr |[ _factory.makeInt(j )]| where <int-to-string> i => j AssimilateString(x) \n: s -> expr |[ _factory.makeAppl( _factory.makeAFun(\"~s \", 0, true) ) ]| where <is-string> s Figure \n16: Generic assimilation of abstract syntax trees in Java with ATerms The generic assimilation of ATerms \nto Java is implemented by the Stratego rewrite rules shown in Figure 16. The rewrite rules AssimilateAppl \nand AssimilateAFun handle ATerm constructor applications and use generic term decon\u00adstruction. The right \nhand sides of the rewrite rules are Java expressions. For the construction of ATerms in the resulting \nJava code, methods de.ned in the ATermFactory interface of the ATerm library are invoked. The rules AssimilateInt \nand AssimilateString handle the ATerm integer and string constructs. The AssimilateMetaVar rule rewrites \nmeta\u00advariables torealJavavariables. This generic assimilation can be applied to all embedded languages \nin the host language Java. Hence, an embedding of a di.erent subject language only needs to de.ne the \ncom\u00adbined syntax de.nition. API speci.c assimilations for the same JavaJava lan\u00adguage can be implemented \nas well. For example, an as\u00adsimilator could target the class hierarchy for Java abstract syntax trees \nin Eclipse.   4. SYNTAX DEFINITION The embedding of languages poses some challenges on syntax de.nition \nand parser technique. MetaBorg employs the Syntax De.nition Formalism SDF [45] and SGLR [44, 10], a Scannerless \nGeneralized LR parser. In the previous section we described several MetaBorg embeddings. So far, we have \nnot revealed how these com\u00adbined language are actually parsed and what the features of the syntax de.nition \nformalism SDF are. Full insight in why SDF is the appropriate syntax de.nition formalism for de.n\u00ading \nlanguage embeddings requires more detailed knowledge of SDF. In this section, the SDF syntax de.nition \nformalism is introduced and we show how it is applied to achieve con\u00adcrete syntax for objects. Several \nfeatures of the syntax de.\u00adnition formalism allow the concise de.nition of the syntax of embeddings. \nTwo features of this parsing technology are es\u00adsential for de.ning the syntax of language embeddings: \nthe GLR algorithm [43, 36] and scannerless parsing [37]. These features are combined in SGLR [44, 10]. \n 4.1 SDF Overview The SDF syntax de.nition formalism supports concise and natural expression of the syntax \nof context-free lan\u00adguages. SDF integrates lexical and context-free syntax in a single formalism. The \ncomplete syntax of a language is thus de.ned in a single de.nition. SDF supports the en\u00adtire class of \ncontext-free grammars. SDF does therefore not restrict the grammars to a subclass of the context-free \ngram\u00admars, such as LL or LALR. SDF syntax de.nitions can be split into modules, and SDF modules can be \nreused in di.er\u00adent syntax de.nitions. Disambiguation of grammars is not done by grammar hacking, but \nby applying special purpose disambiguation facilities in SDF, such as priorities, reject productions, \nand follow restrictions. To illustrate the key features we explain a syntax de.nition of expressions. \nFor more documentation and examples we refer to [38, 45]. 4.1.1 Context-Free and Lexical Syntax Syntax \nis de.ned in syntax sections, which are either con\u00ad text-free or lexical. The di.erence between these \ntwo kinds of syntax sections is that in lexical syntax no layout is al\u00adlowed between symbols. In context-free \nsyntax sections lay\u00adout is allowed between the symbols of a production. The term context-free syntax \nshould not be confused with the expressiveness of the production rules. The expressiveness of the lexical \nand context-free syntax sections is not di.er\u00adent: lexical syntax is not restricted to a regular grammar. \nIn fact lexical and context-free syntax is even translated into a single core syntax de.nition formalism \n[45]. Lexical syntax sections are used to de.ne constructs such as identi.ers, layout and literals. Layout \nis a special non\u00adterminal in SDF named LAYOUT. Optional layout is inserted between the symbols of productions \nin a context-free syntax section to allow layout between the symbols there. The fol\u00adlowing lexical syntax \nsection de.nes layout (LAYOUT), iden\u00adti.ers (Id), and integer constants (IntConst). lexical syntax [A-Za-z][A-Za-z0-9]* \n-> Id [0-9]+ -> IntConst [\\r\\n\\t\\ ] -> LAYOUT  These lexical sorts can be used in a context-free syntax \nsection to de.ne the more complex constructs of a language. The context-free syntax of the example language \nconsists of variables, integer literals, arithmetic operations, method in\u00advocations and conditional expressions. \nNote that the de.\u00adnition of expressions is concise, without the hurdles of in\u00adtroducing additional non-terminals \nto handle priority and associativity of operators. context-free syntax Id -> Exp {cons(\"Var\")} IntConst \n-> Exp {cons(\"Int\")} Exp \"+\" Exp -> Exp {cons(\"Plus\")} Exp \"-\" Exp -> Exp {cons(\"Min\")} Exp \"*\" Exp -> \nExp {cons(\"Mul\")} Exp \"/\" Exp -> Exp {cons(\"Div\")} Exp \".\" Id \"(\" {Exp \",\"}* \")\" -> Exp {cons(\"Call\")} \n\"if\" Exp \"then\" Exp \"else\" Exp -> Exp {cons(\"If\")} The productions are annotated with a constructor name \n(cons(\"...\")). These constructor names are used to con\u00adstruct an abstract syntax tree from the parse \ntree that re\u00adsults from parsing an input text. We use the ATerm for\u00admat [8] for the representation of \nparse and abstract syn\u00adtax trees. The ATerm format is somewhat comparable to XML, but is more structured. \nIt supports lists, tuples, inte\u00adgers, string literals, and of course constructor applications. For example, \nthe input 4 + l.get(5) is represented by the ATerm: Plus(Int(\"4\"), Call(Var(\"l\"), \"get\", [Int(\"5\")])) \n 4.1.2 Disambiguation SDF supports the full class of context-free grammars, in\u00adcluding ambiguous grammars. \nThe implementation of SGLR is able to produce a parse forest of all possible parse trees, but obviously \nwe would like to de.ne what parse trees are preferred over others. For the purpose of disambiguation \nSDF allows separate disambiguation .lters instead of hack\u00ading the syntax de.nition itself into a non-ambiguous \nform. Separate priority de.nitions, follow restrictions, reject, avoid, and prefer .lters can be used \nto disambiguate a syntax def\u00adinition [10]. The syntax de.nition above is highly ambiguous for sev\u00aderal \nreasons. First of all there is an associativity problem for the binary operators. The input 1+2+3 can \nbe parsed as either Plus(_, Plus(_, _)) or Plus(Plus(_, _), _) Since there is more than one possible \ninterpretation, pars\u00ading the input will result in a parse forest. The ambiguous phrases are represented \nby amb nodes in the parse tree. Pro\u00adduction rules in SDF can be annotated with right, left, assoc or \nnon-assoc to de.ne the associativity of an opera\u00adtor. In this case the + operator is left associative, \ntherefore the new production rule is: Exp \"+\" Exp -> Exp {left, cons(\"Plus\")} Another problem is the \npriority of operators. The input 1+2*3 canbe parsedas Plus(_, Mul(_,_)) or Mul(Plus(_,_), _) A related \nproblem is the input 4 + x.get(). Although it might seem apparent that the method get must be invoked \non the variable x, this is not the only possible parse. The input can be parsed as Plus(_, Call(_,_,_)) \nor Call(Plus(_, _),_,_) These ambiguities can be solved by de.ning priorities of pro\u00adduction rules. Priorities \nin SDF are de.ned relatively and not by de.ning priority levels. The priority of * is usually higher \nthen the priority of + and the priority of the method call is higher than all operators in our example \nlanguage. Since such priorities are not properties of a single produc\u00adtion, there is a separate section \nin an SDF module for de.n\u00ading priorities. Production rules in priority de.nitions can also be grouped, \nwhich means that their priority is equal. In this case the associativity of such a group should be de\u00ad.ned. \nIf -and + are in the same priority group, then the associativity of the group determines how for example \nthe input 1-2+3 is parsed. The resulting priority de.nition is: context-free priorities Exp \".\" Id \"(\" \n{Exp \",\"}* \")\" -> Exp > {left: Exp \"/\" Exp -> Exp Exp \"*\" Exp -> Exp } > {left: Exp \"+\" Exp -> Exp Exp \n\"-\" Exp -> Exp } These priorities solve all ambiguity problems in the exam\u00adple. There is still one problem \nleft, but it is not an ambiguity problem in this example. The syntax de.nition is too lib\u00aderal: identi.ers \nare not recognized in a greedy way, which means that the input if 1 then aelse b is valid. Also, the \nsyntax de.nition does not forbid if 1 thena else b, since the restriction that keywords cannot be immediately \nfollowed by an identi.er character has not been expressed. The syntax de.nition must exclude these two \ninput texts by recognizing identi.ers and integer literals in a greedy way and by disallowing a keyword \nto be followed by an identi\u00ad.er character. The longest match policy is implicit in most parser generators, \nespecially in those with a separate scan\u00adner. In SDF a longest match restriction can be de.ned in the \nsyntax de.nition itself by using a follow restriction.A follow restriction A -/-CC forbids that the non-terminal \nA is followed by a character from the character class CC . lexical restrictions Id -/-[A-Za-z0-9] IntConst \n-/-[0-9] \"if\" \"then\" \"else\" -/-[A-Za-z0-9]   4.2 The Importance of Modularity Modularity is essential \nfor the de.nition of the syntax of language embeddings. To make the embedding of the syntax of a language \nA in a host language B concise and maintain\u00adable, it must be possible to develop the syntax de.nitions \nof language A and B independently from each other. Mod\u00adularity in the de.nition of language embeddings \nbecomes even more important if more than one language needs to be embedded. For example, XML and SQL, \nXPath and XML, Java and XML. De.ning these embeddings in a single syntax de.nition is unacceptable from \nthe point of view of clarity, maintenance, and reusability. Most syntax de.nition techniques that are \nused in prac\u00adtice are limited to some subset of the context-free grammars, since they target a parser \ngenerator that applies a certain restricted parsing algorithm. This is illustrated by the fact that most \nsyntax de.nition languages are coupled with a parser generator implementation. Depending on the parsing \nalgorithm that the generated parser is using, the syntax def\u00adinition is restricted to a certain subclass \nof the context-free grammars, such as LALR for YACC, CUP and SableCC, or LL for ANTLR and JavaCC. Restricting \nsyntax de.nitions to some proper subclass of context-free grammars is to a certain extent acceptable \nfor generating parsers from mono\u00adlithic syntax de.nitions of single programming languages, but it is \nnot for combining programming languages, for ex\u00adample in the embedding of languages in host languages. \nAn interesting formal result is that there is no proper subclass of the context-free grammars that is \nclosed under union. As a consequence, grammar languages that are re\u00adstricted to some proper subset of \nthe context-free languages cannot be modular since the combination of two, for exam\u00adple LR, syntax de.nitions \nis not guaranteed to be in this subset. Therefore, SDF supports the full class of context\u00adfree grammars. \nSupporting the full class of context-free grammars in a syntax de.nition formalism introduces some challenges \nto the applied parsing technology. Parsers and parser genera\u00adtors that allow the full class of context-free \ngrammars ap\u00adply Generalized LR (GLR) [43, 36] or Earley [18] parsing. The GLR parsing algorithm maintains \nmultiple LR parsing states in parallel. At phrases where the parser cannot choose from multiple production \nrules to apply, it forks the current parser. The forked parsers meet again if a token in the input is \nto be parsed with the same non-terminal. The modularity features of SDF are comprehensive. Since using \nmodular syntax de.nition in SDF introduces not a single awkwardness, de.ning syntax de.nitions in a modular \nway is even encouraged. Renamings make the combination and isolation of syntax de.nitions very .exible \nas explained in Section 3.2.1. SDF is modular to the core.  4.3 The Importance of Scannerless Parsing \nMost parsers apply a separate scanner for lexical analy\u00adsis. The purpose of this lexical analysis phase \nis to break up the input into tokens, such as identi.ers, numbers, lay\u00adout, and speci.c keywords (e.g. \nif, switch, try, catch). That is, the lexical analysis phase decides what kind of to\u00adken a lexeme is. \nA separate lexical analysis phase allows the parser to operate on the list of lexemes, ignoring their \nactual contents. The lexical syntax of a language is usually speci.ed by regular expressions. The scanner \napplies .nite automata to recognize the tokens speci.ed by these regular expressions. 4.3.1 Context \nof Tokens Scanners that do not interact with the parser cannot con\u00adsider the context of a sequence of \ncharacters in the decision which token a sequence represents. This is essentially the reason for having \nreserved keywords, which cannot be used as identi.ers in the language. The separate lexical analyzer \nis also the reason for not allowing nested block comments ( /*/* */ */) and for disallowing a--b to be \nparsed as a -(-b). Thus, the lexical analyzer decides what token a list of characters represents, without \nconsidering the context of the tokens in the input stream. This maybe reasonable for parsing inputs written \nin a single language, in particular since this language can be designed with these restrictions in mind. \nYet, it is more problematic when the input consists of a combination of languages. By not considering \nthe context of a sequence of characters in the input stream, it is impossible to assign it di.erent tokens, \nsince this ultimately depends on the context of the lexeme. As regards embedded languages, the scanner \ncan not assign di.erent token types to the same lexeme in embedded code and in host code. This is a serious \nproblem if the lexical syntax of the embedded language is entirely di.erent from the lexical syntax of \nthe host language. It is not a problem if the embedded language is the same lan\u00adguage as the host language \n(for example Java embedded in Java), since the lexical syntax is in this case not di.erent in the embedded \ncode fragments. However, embedding XML in Java is more challenging, since the lexical syntax of XML is \ncompletely di.erent from Java. In this case the lexical an\u00adalyzer must consider the context of a sequence \nof characters before deciding what kind of token it is.  4.3.2 Preserve Structure of Lexemes A scanner \nusually passes lexemes as an unstructured atomic value to the parser. The internal structure of the tokens \nis thus not preserved. This is a pity since tokens such as .oating point and String literals can have \nquite a complex structure. The string literal \"Hello\\r\\n world!\" will typ\u00adically result in the token \n\"\\\"Hello\\\\r\\\\n world!\\\"\".The semantic tools that operates on parse (or abstract syntax) trees must analyze \nthe structure of the tokens again to de\u00adtermine its meaning. However, preservation of the structure of \na lexeme is essential if it must be possible to escape to the meta language inside a token. We have already \nseen such escapes in our examples, namely the escape in XML attribute values and Java string literals \n(see Section 3.3.2). Parsing with a separate scanner does not support such struc\u00adtured lexemes, since \nlexemes are passed as a plain sequence of characters to the parser. In scannerless parsing the struc\u00adture \nof lexemes can be preserved. For example, in our Java tools the string literal above is represented as: \nString( [ Chars(\"Hello\") , NamedEscape(114) , NamedEscape(110) , Chars(\" world!\") ] ) The preservation \nof lexical structure is mostly a matter of convenience if parsing inputs of single programming lan\u00adguages. \nHowever, for the embedding of a language in a host language, the preservation of lexical structure is \nextremely useful, if not a requirement. For example, the following XML attribute contains an escape to \nthe meta level inside an XML attribute: <a href=\"http://www.<% s %>.org\">Stratego/XT</a> In scannerless \nparsing the structure of the attribute value can be preserved. In the embedding of XML in Java, the attribute \nis represented as: Attribute( QName(None, \"href\") , DoubleQuoted([ Literal(\"http://www.\") , Literal(FromExpr(ExprName(Id(\"s\")))) \n, Literal(\".org\") ]) ) Note that preserving the structure of lexical syntax is re\u00adlated to the context \nof tokens. The content of a string literal is in a sense an embedded language. Scanning string literals \ncould result in separate tokens of the lexical syntax of this language. This requires the scanner to \nknow about the con\u00adtext of a sequence of characters. After all, the lexical syntax of this embedded string \nliteral language is completely dif\u00adferent from the lexical syntax of the host language. 4.3.3 Solutions \nOf course these problems can all be solved in hand-written scanners. Such a scanner can interact with \nthe parser in arbitrary ways. However, writing e.cient parsers and scan\u00adners by hand that can handle \nambiguous input streams is very di.cult. Writing scanners and parsers by hand is in general not an option \nif languages need to be combined. The solution is to discard the separate lexical analysis phase completely. \nThe parser directly operates on the char\u00adacters of the input. In syntax de.nitions for scannerless parsers \nthe lexical syntax and context-free syntax can be speci.ed in a single syntax de.nition formalism. Hence, \nthe full syntax of a language is speci.ed in a single de.nition. All information regarding the disambiguation \ncan be in the same syntax de.nition and there are no implicit disambiguation rules based on the parser \ntechnology that is applied. Since the parser operates on individual characters the context-free analysis \nof the parser can be used to determine the types of individual characters. Thus, the context of the character \nis taken into account. If a certain token is not expected at a certain location in the input, then it \nwill not be considered. Parsing without a separate scanner is called scannerless, a term that was coined \nin [37]. This solution combined with the GLR algorithm is known as Scannerless Generalized LR parsing \n[44]. The parser generator for SDF (pgen) generates a parse table for a Scannerless Generalized LR parser \n(sglr). The implementation is available at [34, 38].  5. DISCUSSION In this section we discuss previous, \nrelated, and future work. 5.1 Previous Work SDF [21] was originally designed for use as a general syn\u00adtax \nde.nition formalism. However, through its implementa\u00adtion it was closely tied to the algebraic speci.cation \nformal\u00adism ASF+SDF [17], which is supported by the ASF+SDF Meta-Environment [9]. Redesign and reimplementation \nas SDF2 [45, 10] has made the language available for use out\u00adside the Meta-Environment. SDF2 is also \ndistributed as part of the XT bundle of program transformation tools [26]. Syn\u00adtax de.nition in SDF2 \nis limited to context-free grammars. This is a limitation for languages with context-sensitive syn\u00adtax \nsuch as that of Haskell (o.side rule). However, in the setting of embedded concrete syntax, in which \nsmall frag\u00adments are used and not all context is always available, any parsing technique will have a \nhard time. The combination of SDF with ASF was the .rst to use SDF for the de.nition of embedded syntax. \nStratego [48, 47, 41] is a language for the implementa\u00adtion of program transformation based on rewrite \nrules under control of programmable rewriting strategies. Rewrite rules transform .rst-order terms. In \n[46] an extension of Stratego with concrete syntax for the program fragments manipu\u00adlated by its rewrite \nrules is introduced. The paper presents asingle generic assimilation transformation, mapping term representations \nof abstract syntax trees into Stratego terms, similar to the assimilation of Java programs to ATerms \nin Section 3.4. The paper also gives an outline of a general ar\u00adchitecture for extension of an arbitrary \nhost language with concrete syntax. In [19] the approach is extended to Prolog as a meta\u00adlanguage, mainly \nto provide concrete syntax for the schemas of the AutoBayes program synthesis engine. Since Prolog is \nalso a term-based language the assimilation is de.ned in a similar generic way. The contributions of \nthis paper are the extension of the approach to an object-oriented host language, the targeting of speci.c \nAPIs by the assimilation transformation, and the speci.c extensions of Java for code generation, XML \ngener\u00adation, and user-interface construction. The design of Swul and its embedding in Java is a nice \nbyproduct of this project. 5.2 Related Work There have been many other approaches to make pro\u00adgramming \nlanguages syntactically extensible. We give an overview of such approaches and discuss their relation \nto MetaBorg. 5.2.1 Extensible Syntax The extensible syntax [13] applied in the implementation of F<: \n[12] was the .rst step into incremental syntax de.ni\u00adtion by extending and restricting a small core language. \nThe de.nition of syntax extensions and the assimilation into the host language are in the source code \nof the host language. Syntax extensions can be local (syntax ... in ... end) or de.ned at toplevel. The \nsyntax can be de.ned incremen\u00adtally by updating, extending, or adding production rules to an existing \ngrammar. The syntax extensions include a rewriting to the host language by constructor applications or \naction de.nitions that rewrite the syntax directly to the target language. The implementation of extensible \nsyntax is based on LL parsing, which makes the syntax de.nition cumbersome and not modular, since the \nclass of LL grammars is not closed under union and concatenation. It would be interesting to develop \na comparable inline extensible syntax mechanism based on the more powerful parsing technique of scannerless \ngeneralized LR parsing, which was not mature enough when extensible syntax was developed. Although the \nimplementation of user-de.nable syntax in this work is very .exible (despite the LL parsing), we do not \nbelieve that there is a need for de.ning ad-hoc syntax extensions so powerful. Rather, in practice syntax \nexten\u00adsions are carefully designed in a separate role. Developing appropriate domain-speci.c syntax extensions \nof a host lan\u00adguage is thus a separate role and does not necessarily need to be performed in the host \nlanguage. The implementation can be provided in separate tools. The additional advan\u00adtage of these separate \ntools is that the meta-programmer can choose the most appropriate programming language for implementing \nan assimilation. The MetaBorg method aids the implementation of these tools by providing powerful and \ngeneric tools for parsing and assimilation into the host lan\u00adguage. 5.2.2 Harmonia s Blender Blender \n[3], developed in the Harmonia project, targets parsing inputs that cannot be designed to be non-ambiguous. \nBegel and Graham [3] thoroughly analyze the problems in handling ambiguous inputs, especially embedded \nlanguages. Blender generates from Flex-and Bison-like de.nitions a lexical analyzer, parse tables and \nclass de.nitions for repre\u00adsenting abstract syntax trees in C++. Blender applies GLR parsing with an \nincremental lexical analyzer that is forked together with the LR parsers in the GLR algorithm. The scanner \nis thus not completely sep\u00adarate from the parser, but parsing is not scannerless. If multiple lexical \ntypes can be assigned to a token, then the scanner reports all possible interpretations to the parser. \nFor each interpretation of a token a parser and scanner is forked. This approach was also used by the \nimplementation of SDF before the introduction of scannerless parsing [21]. The approach was abandoned \nbecause of huge numbers of forks and the increased complexity of the algorithm when trying to reduce \nthe number of forks. In addition, the use of context-free grammars instead of regular grammars greatly \nincreases expressivity, allowing nested comments and anti\u00adquotation within lexical syntax, for example. \nGLR parsing where the scanner is forked together with LR parsers should solve most issues with using \na separate scan\u00adner. We have not been able to investigate whether or not this is really a performance \nimprovement over Scannerless Generalized LR parsing, since no benchmarks are provided and Blender is \nnot available for download. The main ar\u00adgument for not using scannerless parsing in the Harmonia project \nis to facilitate interactive environments using incre\u00admental parsing. In our view parse trees of scannerless \npars\u00ading can be persisted as well and be reused to reparse just the edited parts. Begel and Graham suggest \nthis as well and remark that the size of the parse trees might be a problem. However, the e.cient ATerm \nformat [8] has already proven to be successful in reducing the size of parse trees through maximal sharing. \nSyntax de.nitions of Blender are modular, thus languages can be developed and maintained independently. \nUnfor\u00adtunately, the syntax de.nition formalism used in Blender is much less concise than SDF. The lexical \nanalyzer ap\u00adplies longest match and order-based matching. Although this is appropriate for most programming \nlanguages, we be\u00adlieve that implicit disambiguation by the parser should be avoided. Order-based selection \nis especially problematic if the lexical syntax is de.ned in several modules, as is typi\u00adcally the case \nwhen de.ning the syntax of an embedded lan\u00adguage. The built-in preference for the longest match and to\u00adkens \nde.ned .rst, requires insight in the algorithms applied by the lexical analyzer generator. This makes \ndebugging of the syntax de.nition more complex and requires studying traces of the parser. The declarative \ndisambiguation meth\u00adods of SDF allow the complete de.nition of the syntax of a language, independent \nfrom the tools applied to it.  5.2.3 Jakarta Tool Suite (JTS) The Jakarta Tool Suite (JTS) [2] is a \nset of tools for ex\u00adtending Java with domain speci.c constructs. The main tools of JTS are Jak, which \nallows meta programming for Java in Java using the Java concrete syntax, and Bali, a frontend of JavaCC \n[24]. JTS targets the implementation of component-based generators, called GenVoca generators. The Jak \nlanguage of JTS supports the generation of Java programs by using the concrete syntax of Java in Java. \nCode fragments are embedded in tree constructors (for example exp{...}exp). From these fragments it is \npossible to es\u00adcape to the meta language by an escape such as $exp(...). The Jak language is comparable \nto our JavaJava language, but since our embedding is entirely user-de.nable and easy to extend, JavaJava \nsupports a wider range of quotations (tree constructors) and anti-quotations (escapes). In Java-Java \nthe explicit declaration of non-terminals in tree con\u00adstructorsand escapesisnot required if the non-terminal \nof code fragments can be determined by the parser. This makes code fragments much more concise. We would \nlike to remove even more non-terminal declarations by disam\u00adbiguating the code fragments in an extended \ntype checker for Java. This future work is discussed later. In addition to anti-quotations, JavaJava \nalso supports meta-variables which is a very compact embedding of variables from the meta language in \nthe generated code fragments. Both solu\u00adtions guarantee the syntactical correctness of the code frag\u00adments \nand construct an abstract syntax tree representation of the generated code. Jak also features a matching \nfacility. We have not im\u00adplemented this yet in JavaJava, because there is no easy mapping of match statements \nto existing APIs or language constructs in Java. The Tom pattern matching compiler [35] could be used \nto implement support for patterns in concrete syntax. JTS Bali is a tool for generating tools for extensions \nof Java. Bali is a front-end of JavaCC. Bali generates abstract syntax tree de.nitions and a parser by \npassing a grammar to JavaCC. Relying on JavaCC parsing technology introduces a lot of problems. Syntax \nde.nitions are much less concise compared to SDF and even to other available parser tools. JavaCC is \nan LL(k) parser generator, which implies that grammars are not composable and have to be manipulated \nto solve ambiguities. This parsing technology is appropriate for parsing languages that are designed \nnot to be ambiguous, but in a toolkit for de.ning language extensions it is a major issue, as has been \ndiscussed in Section 4. Bali composes grammars by combining the lexical and grammar rules. This merging \nis not guaranteed to succeed since LL(k) grammars are not composable. Bali uses heuris\u00adtics to combine \nlexical rules such that the best results are produced in the common cases. Lexical scanners prefer the \nlongest match and select rules that apply by order. There\u00adfore, keyword rules are put before the more \ngeneral rules, such as for identi.ers. This implies that keywords for the embedded language may cancel \nuse of those keywords as identi.ers in the host language. The syntax de.nition and parsing techniques \nof SDF are much easier to use and can be applied for arbitrary embeddings. Because of the parser technology \nwhich Bali relies on, Bali will not be able to handle syntactic extensions that have an entirely di.erent \nlexical syntax. SDF has no problem such embeddings, as discussed in Section 4. 5.2.4 Syntax Macros Syntax \nmacros [30] de.ne syntactic abstractions over code fragments. Syntax macros usually operate on abstract \nsyn\u00adtax tree representations of programs. A syntax macro ac\u00adcepts abstract syntax tree arguments and \ngenerates a new abstract syntax tree that replaces the syntax macro invoca\u00adtion. To ensure the production \nof syntactically correct pro\u00adgrams, the resulting abstract syntax tree of a syntax macro invocation must \nbe of the same type as the macro invoca\u00adtion. In all implementations of syntax macros, a macro invo\u00adcation \nmust start with a unique macro delimiter, which is usually an identi.er consisting of letters. This identi.er \nin\u00addicates the syntax macro that is invoked. Such a macro delimiter is required since the syntax of macro \ninvocations is de.ned in the input .le itself. Some syntax macro imple\u00admentations allow overloading of \nthese identi.ers to refer to di.erent syntax macro de.nitions using the same identi.er. The .xed syntax \nfor a macro invocation is in many cases acceptable. The .xed syntax for invocations can even result in \nattractive, data-like, programs (called a Very Domain-Speci.c Language, VDSL, in [6]). However, the .xed \ninvocation syntax of syntax macros is a limited extension of the syntax of the host language. The embedding \nof a domain-speci.c language in MetaBorg can be an arbitrary context-free language. The expressivity \nof our extensions is illustrated by the embedding of Java, XML, a tuple syntax, and Swul. MetaBorg also \nallows an embedded language to use an entirely di.erent lexical syntax, which is not the case for syntax \nmacros, where lexical analysis of the macros is performed by the scanner of the base language. In particular, \nthis feature of MetaBorg is illustrated by the embedding of XML in Java. The main di.erence between syntax \nmacro systems is the expressiveness of argument de.nitions. The most limited systems only allow a .xed \nnumber of arguments, usually with a syntax comparable to procedure calls. The most expressive systems \nare MS2 [50], which allows regular lan\u00adguages, and Dylan [39] and Metamorphic Syntax Macros [6], which \nallow context-free languages. The non-terminals ap\u00adpearing in actual arguments of macros in Dylan, are \nnot represented as abstract syntax trees, but as a list of tokens. In [6] the user-de.ned non-terminals \nare represented as an abstract syntax tree. These user-de.ned non-terminals are however required to have \na .xed associated non-terminal in the host language. The MetaBorg method releases this re\u00adstriction by \ncompletely separating the assimilation into the host language from the syntax de.nition of language exten\u00adsions. \nImplementations of syntax macros also di.er in the ex\u00adpressivity of the rewriting to the base language \nin the syntax macro de.nitions, called assimilation in MetaBorg.Usu\u00adally a syntax macro de.nition consists \nof the de.nition of the invocation syntax, which is some language over termi\u00adnals and non-terminals of \nthe host language. The arguments of the syntax macro can be used in the de.nition of code to be produced \nby a macro invocation. In [30] conditional syn\u00adtax macros were already proposed, which increases the \nex\u00adpressivity of the rewriting language. In the programmable syntax macros of MS2 [50] the macro language \nis a small extension of the host programming language. This exten\u00adsion is targeted at rewriting syntactic \nextensions to the base language. C++ templates are well-known to be Turing com\u00adplete, but this expressivity \nis not based on rewriting trees, but on constant folding. The Java Syntactic Extender (JSE) [1] macro \nsystem is mainly inspired by Dylan. The expressiveness of the syntax that can be introduced is limited. \nAs in most macro systems, a macro identi.er is required in invocations and the parser used by JSE is \nnot extensible. Rather, a source .le is parsed by a .xed parser to a skeleton syntax tree (SST). The \nSST is a lexical representation of a Java source .le, but it is somewhat more structured than a plain \nsequence of tokens. JSE macros are implemented in Java and operate on the SST, i.e. lexical syntax. Hence, \nthe source code fragments that are manipulated by JSE are not syntactically struc\u00adtured and JSE does \nnot guarantee that the fragments are syntactically correct. Processing of the input arguments is done \nby pattern matching, or by arbitrary procedural code. Therefore, JSE supports any syntax extensions \nthat can be represented in the SST, but it is not possible to introduce syntax that does not conform \nto the lexical syntax of Java. To improve error reporting, JSE tries to maintain the origi\u00adnal source \ncode location in the generated code. The source location will be lost if arbitrary manipulations of the \nSST are performed. For a more extensive survey of the properties of various systems supporting syntax \nmacros, see [6]. 5.2.5 Metafront Metafront [7] was designed as a more general solution to the parsing \nissues experienced in metamorphic syntax macros [6]. Metafront applies a novel parsing algorithm: speci.city \nparsing. Metafront extends the formalism of context\u00adfree grammars with a separate set of regular terminal \nlan\u00adguages. The lexical syntax of a language is thus still de.ned separately from the context-free syntax, \nbut there is not a separate scanner and parser tool. However, Metafront is not a scannerless parser in \nthe sense of not tokenizing the input stream at all. It uses a separate scanner for tokenizing the input \n.le. If at a certain point in the input stream multiple options out of the set of terminal languages \nare available, then the most speci.c one is chosen. Speci.city parsing thus has a built-in preference \nfor the longest token. Speci\u00ad.city parsing in Metafront does not return to a choicepoint in the input \nstream; it immediately commits the choice for a certain token. Left recursion is not allowed in syntax \ndef\u00adinitions to ensure termination. Metafront adds a form of lookahead called attractors to solve ambiguities \nif there is not a most speci.c token. An attractor speci.es after how many successful tokens for a certain \nproduction this alter\u00adnative must be chosen. Attractors are also used to reject certain alternatives. \nBecause of the attractor disambiguation construct, syntax de.nitions in Metafront are less concise then \nsyntax de.ni\u00adtions in SDF2. Left recursion has to be removed, which is unfortunate. However, Metafront \nsyntax de.nitions are in\u00addeed modular, unlike other parser generators that do not use Earley or GLR. \nThe main goal of Metafront is not to sacri\u00ad.ce performance when there is a need for extensible syntax \nde.nitions. Since the current implementation is a prototype that interprets language de.nitions, it is \ndi.cult to deter\u00admine whether speci.city parsing will in practice have signi.\u00adcantly better performance \nthan Scannerless Generalized LR parsing. Metafront also features a transformation language. Meta\u00adfront \ntransformations are guaranteed to terminate and will transform syntactically correct input to syntactically \ncor\u00adrect output. It is unclear to us why termination guarantees are important in this context. Guaranteeing \ntermination sacri.ces the expressivity and abstraction facilities of the transformation language and \nwe prefer a more expressive language over termination guarantees. In the Stratego/XT project we have \ndeveloped many complex transformations, in particular program optimizations. Testing transforma\u00adtions \nhas in practice proven to be su.cient to see whether a transformation terminates or not. It would be \ninteresting to separate Metafront in a parsing and transformation com\u00adponent and experiment with the \nperformance of speci.city parsing.  5.3 Future Work 5.3.1 Application Domains There are many opportunities \nfor applying MetaBorg to create domain-speci.c extensions of Java and other host languages. We summarize \nsome of our ideas to give more insight into the scope of concrete syntax for objects. In linguistic re.ection \na program can generate new pro\u00adgrams at runtime and execute these generated programs as part of its own \nexecution [27]. Linguistic re.ective programs are program generators and as such the generator is con\u00adcerned \nwith the syntactical and semantical correctness of the generated programs. In [27] programs are generated \nby constructing a textual representation in strings, which is unclear and error-prone. The authors suggest \nas further work to generate code using an abstract syntax and place the challenge to have the generator \ncode look as the gener\u00adated language would normally be written. Our solution for embedding languages \nusing MetaBorg makes this possible by embedding a concrete syntax for the abstract syntax of a programming \nlanguage. Linguistic re.ection tools targeting a speci.c platform might even target standardized abstract \nsyntax trees such as the CodeDOM of .NET. These abstract syntax trees can then be accepted directly by \na compiler or interpreter, which makes an expensive and error-prone intermediate textual form unnecessary. \nIt might even be possible to directly com\u00adpile embedded fragments to Java Byte code or .NET .IL, for \nexample by de.ning a concrete syntax for the objects used by a byte code construction library, such as \nthe Byte Code Engineering Library (BCEL) [11]. JJTraveler [49] is a visitor combinator framework for \nJava. Visitor combinators can be used to compose tree traversals from basic visitor combinators. The \nset of basic combinators of JJTraveler is inspired by the strategy prim\u00aditives of Stratego, a strategic \nprogram transformation lan\u00adguage where rewriting rules are applied according to user\u00adde.nable rewriting \nstrategies. However, JJTraveler visitor construction is somewhat verbose compared to the concise notation \nfor strategies in Stratego. In essence JJTraveler provides classes for all strategy operators of Stratego. \nThe embedding of concrete syntax for these strategy operators would be an interesting application of \nMetaBorg. Doug Lea s java.util.concurrent library introduces use\u00adful abstractions for concurrent programming. \nThis library provides utility classes developed in [29]. Other program\u00adming languages already have these \nconcurrency abstractions over the low-level facilities as built-in constructs. Domain\u00adspeci.c notations \nfor these abstractions can be developed with MetaBorg as an extension of the Java language. XQuery is \na query language developed by the W3C. It enjoys wide support by researchers and the industry. JSR 225 \naims at standardizing an API for evaluating XQuery operations. XQueries are however even less attractive \nfor inclusion in String literals then XPath and SQL statements since the queries tend to be larger and \nspan multiple lines. Obviously this language needs to be embedded in Java to make static syntactical \nveri.cation possible and embedding of values from the host language easier and more secure.  5.3.2 Open \nCompilers Open Compilers can improve the integration of Meta-Borg based embedded languages in the compilation \nprocess. Assimilators can be arbitrarily complex and in some cases they will need to have more detailed \nsemantic information on the input program than a structured representation of the input program in an \nabstract syntax tree provides. We already experience some problems where assimilators needed to know \nthe type of expressions. Improved integration of the assimilators in the compiler will provide the required \ninformation to the assimilator and will improve the analysis that can be performed on programs with a \nreasonable amount of work. Application of assimi\u00adlators in di.erent phases of an open compiler (e.g. \nparsing, semantic analysis, and translation to intermediate code) will improve error reporting since \nthe aspects of assimilation into the host language can be implemented separately for each phase by extending \ncomponents of the open compiler. A useful experiment of extending the components of an open compiler \nis delayed disambiguation in the input pro\u00adgrams. In many cases the embedding of a language requires \ndisambiguation because the fragments of the embedded lan\u00adguage can be parsed as more than one non-terminal. \nIn the embedding of Java in Java this disambiguation is performed by optionally pre.xing the fragments \nwith exp and bstm to indicate the non-terminal of the fragment. In the embedding of XML in Java the non-terminal \nof anti-quotations has to be de.ned since the anti-quotation might refer to character data as well as \ncontent. When this explicit disambiguation is required is not always clear and excessive use of disam\u00adbiguations \nmakes the code less concise. An interesting solution to this problem is to solve the am\u00adbiguities by \nmeans of interaction with a type checker. From a fragment such as Expr e =expr |[1 +2]| it is easy to \nsee that there is unnecessary duplication of type decla\u00adrations. If the type checker of the host language \ncan be extended, then during type-checking the appropriate alter\u00adnative from a set of ambiguous abstract \nsyntax trees can be chosen. By preserving the ambiguities until the type check\u00ading phase they can be \nhandled at this point. This requires the parser to be able to report all possible parses, which SGLR \nsupports. We plan to develop tools for this kind of disambiguation of embedded languages in Java.  \n6. CONCLUSIONS Programming language design these days often is about selecting candidates for tasteful \ninclusion in the core lan\u00adguage. Design patterns and application libraries are among the candidates for \nassimilation into the host language. Ex\u00adtending existing programming languages with new features that \nused to be provided by libraries has several advantages. The core language can provide an attractive \nsyntax for these features, and tools such as type-checkers, refactoring tools, IDEs and debuggers will \n(need to) have built-in knowledge of the extensions. C. (.rst called Xen [32, 31]) lifts the area of \ndata-access to the language level. To this end, it makes the type system of the host language more general \nand extends the language of object literals with an alternative XML syntax. C. pro\u00advides languages features \nfor iterating, collecting, .ltering, and applying functions over data structures. The Xtatic language \n[51], a follow-up of XDuce [22], extends an exist\u00ading programming language with XML speci.c support as \nwell, but uses a translation into the host language, which is C#. However, the growth of a language with \nmore domain spe\u00adci.c constructs is limited by the general application area of the language. Extensions \nof the language can potentially be applied in all code written in this language. Therefore very domain \nspeci.c notation will never be accepted to the core language itself. The kitchen sink is only interesting \nfor kitchen related applications. Hence, language extensions tend to abstract over control .ow rather \nthan over data. A domain-speci.c concrete syntax for objects will usually not be lifted to the host language, \nsince objects are much more application speci.c than routines. Syntax macros take domain-speci.c extension \nto the other extreme by allowing the programmer to extend the host lan\u00adguage within the program itself. \nThis is a very lightweight extension of the language, but is restricted by a host of tech\u00adnical problems. \nOur MetaBorg method is somewhere in between designing a new language and ad-hoc extensions with syntax \nmacros. Since extensions need to be de.ned carefully by a domain expert, domain-speci.c notations are \nintroduced in a separate role. To conclude, MetaBorg is more .exible than C. in that it does not target \na speci.c domain and MetaBorg allows arbitrary extensions, as op\u00adposed to syntax macros. We expect that \nextensions will be implemented in MetaBorg or similar toolkits before they are assimilated into the host \nlanguage for good. For those extensions that will never make it there, MetaBorg pro\u00advides the way to \nstill make them available to application programmers. Acknowledgments Many people have contributed to \nthe development of Strat\u00adego/XT. Merijn de Jonge developed the pretty-printing tools of Stratego/XT. \nNiels Janssen, Rob Vermaas and Jonne van Wijngaarden contributed to the development of XML sup\u00adport. \nSDF is maintained and further developed at CWI by Mark van den Brand and Jurgen Vinju. Finally, we would \nlike to thank Eelco Dolstra, Je. Gray, Merijn de Jonge, Mar\u00adtijn Vermaat and the anonymous reviewers \nof OOPSLA for providing useful feedback on an earlier version of this paper.  7. REFERENCES [1] J. Bachrach \nand K. Playford. The Java syntactic extender (JSE). In Proceedings of the 16th ACM SIGPLAN Conference \non Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 01), pages 31 42. ACM Press, \n2001. See also http://jse.sourceforge.net/. [2] D. Batory, B. Lofaso, and Y. Smaragdakis. JTS: tools \nfor implementing domain-speci.c languages. In Proceedings Fifth International Conference on Software \nReuse (ICSR 98), pages 143 153. IEEE Computer Society, June 1998. See also http://www. cs.utexas.edu/users/schwartz/software.html. \n[3] A. Begel and S. L. Graham. Language analysis and tools for input stream ambiguities. In Proceedings \nof the Fourth Workshop on Language Descriptions, Tools and Applications (LDTA 04), Electronic Notes in \nTheoretical Computer Science, Barcelona, Spain, April 2004. Elsevier. [4] F. Bouma. LLBLGen Pro, the \nn-tier generator and O/R mapper for .NET. http://www.llblgen.com. [5] R. Bourret. XML data binding resources. \nhttp: //www.rpbourret.com/xml/XMLDataBinding.htm. [6] C. Brabrand and M. I. Schwartzbach. Growing languages \nwith metamorphic syntax macros. In Proceedings of the 2002 ACM SIGPLAN Workshop on Partial Evaluation \nand Semantics-based Program Manipulation (PEPM 02), pages 31 40. ACM Press, 2002. [7] C. Brabrand, M. \nI. Schwartzbach, and M. Vanggaard. The Metafront system: Extensible parsing and transformation. In Proceedings \nof the Third Workshop on Language Descriptions, Tools and Applications (LDTA 03),volume 82 of Electronic \nNotes in Theoretical Computer Science. Elsevier, December 2003. See also http://www.brics.dk/metafront/. \n[8] M. G. J. van den Brand, H. de Jong, P. Klint, and P. Olivier. E.cient annotated terms. Software, \nPractice &#38; Experience, 30(3):259 291, 2000. [9] M. G. J. van den Brand, J. Heering, H. de Jong, M. \nde Jonge, T. Kuipers, P. Klint, L. Moonen, P. Olivier, J. Scheerder, J. Vinju, E. Visser, and J. Visser. \nThe Asf+Sdf Meta-Environment: a component-based language laboratory. In R. Wilhelm, editor, Compiler \nConstruction (CC 01), volume 2027 of Lecture Notes in Computer Science, pages 365 368, Genova, Italy, \nApril 2001. Springer-Verlag. [10] M. G. J. van den Brand, J. Scheerder, J. Vinju, and E. Visser. Disambiguation \n.lters for scannerless generalized LR parsers. In N. Horspool, editor, Compiler Construction (CC 02), \nvolume 2304 of Lecture Notes in Computer Science, pages 143 158, Grenoble, France, April 2002. Springer-Verlag. \n [11] Byte code engineering library (BCEL). http://jakarta.apache.org/bcel/. [12] L. Cardelli. An implementation \nof F<:.SRC Research Report 97, Digital Equipment Corporation, Systems Research Center, February 1993. \n[13] L. Cardelli, F. Matthes, and M. Abadi. Extensible syntax with lexical scoping. SRC Research Report \n121, Digital Equipment Corporation, Systems Research Center, February 1994. [14] Castor databinding framework \nfor java. http://www.castor.org. [15] The Apache Cocoon project. http://cocoon.apache.org/. [16] H. de \nJong and P. Olivier. Generation of abstract programming interfaces from syntax de.nitions. Journal of \nLogic and Algebraic Programming, 59(1-2):35 61, April-May 2004. See also http://www. cwi.nl/htbin/sen1/twiki/bin/view/SEN1/ApiGen. \n[17] A. van Deursen, J. Heering, and P. Klint, editors. Language Prototyping. An Algebraic Speci.cation \nApproach, volume 5 of AMAST Series in Computing. World Scienti.c, Singapore, September 1996. [18] J. \nEarley. An e.cient context-free parsing algorithm. Communications of the ACM, 13(2):94 102, 1970. [19] \nB. Fischer and E. Visser. Retro.tting the AutoBayes program synthesis system with concrete object syntax. \nIn C. Lengauer et al., editors, Domain-Speci.c Program Generation, volume 3016 of Lecture Notes in Computer \nScience, pages 239 253. Spinger-Verlag, 2004. [20] E. M. Gagnon and L. J. Hendren. SableCC, an object-oriented \ncompiler framework. In Proceedings of the Technology of Object-Oriented Languages and Systems (TOOLS \n98), pages 140 154. IEEE Computer Society, 1998. See also http://www.sablecc.org. [21] J. Heering, P. \nR. H. Hendriks, P. Klint, and J. Rekers. The syntax de.nition formalism SDF reference manual. SIGPLAN \nNotices, 24(11):43 75, 1989. [22] H. Hosoya and B. C. Pierce. XDuce: A typed XML processing language. \nIn The World Wide Web and Databases, Third International Workshop WebDB 2000, Selected Papers, volume \n1997 of Lecture Notes in Computer Science, pages 226 244. Springer-Verlag, 2000. [23] P. Hudak. Building \ndomain-speci.c embedded languages. ACM Computing Surveys, 28(4es), December 1996. [24] Java Compiler \nCompiler (JavaCC). https://javacc.dev.java.net/. [25] Java architecture for XML binding JAXB. http://java.sun.com/xml/jaxb/. \n[26] M. de Jonge, E. Visser, and J. Visser. XT: A bundle of program transformation tools. In M. G. J. \nvan den Brand and D. Perigot, editors, Workshop on Language Descriptions, Tools and Applications (LDTA \n01), volume 44 of Electronic Notes in Theoretical Computer Science. Elsevier Science Publishers, April \n2001. [27] G. Kirby, R. Morrison, and D. Stemple. Linguistic re.ectioninJava. Software -Practice &#38; \nExperience, 28(10):1045 1077, 1998. [28] T. Kuipers and J. Visser. Object-oriented tree traversal with \nJJForester. In M. G. J. van den Brand and D. Perigot, editors, Proceedings of Workshop on Language Descriptions, \nTools and Applications (LDTA 01),volume 44of Electronic Notes in Theoretical Computer Science. Elsevier \nScience Publishers, 2001. [29] D. Lea. Concurrent Programming in Java, Second Edition, Design Principles \nand Patterns. Addison Wesley Longman Publishing Co., Inc., 2000. [30] B. M. Leavenworth. Syntax macros \nand extended translation. Communications of the ACM, 9(11):790 793, November 1966. [31] E. Meijer and \nW. Schulte. Programming with rectangles, triangles, and circles. In Proceedings of XML Conference &#38; \nExposition 2003 (XML 2003). IDEAlliance, December 2003. [32] E. Meijer and W. Schulte. Unifying tables, \nobjects, and documents. In Proceedings of the Workshop on Declarative Programming in the Context of Object-Oriented \nLanguages (DP-COOL 03), August 2003. [33] M. Mernik, J. Heering, and A. M. Sloane. When and how to develop \ndomain-speci.c languages. Submitted to ACM Computing Surveys, 2003. [34] ASF+SDF MetaEnvironment website. \nhttp://www.cwi.nl/projects/MetaEnv/. [35] P.-E. Moreau, C. Ringeissen, and M. Vittek. A pattern matching \ncompiler for multiple target languages. In G. Hedin, editor, 12th Conference on Compiler Construction \n(CC 03), volume 2622, pages 61 76, Warsaw, Poland, 2003. Springer-Verlag. See also http://tom.loria.fr. \n [36] J. Rekers. Parser Generation for Interactive Environments. PhD thesis, University of Amsterdam, \n1992. [37] D. J. Salomon and G. V. Cormack. Scannerless NSLR(1) parsing of programming languages. ACM \nSIGPLAN Notices, 24(7):170 178, 1989. Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language \nDesign and Implementation (PLDI 89). [38] http://www.syntax-definition.org. [39] A. Shalit. The Dylan \nreference manual: the de.nitive guide to the new object-oriented dynamic language. Addison Wesley Longman \nPublishing Co., Inc., 1996. [40] Y. Smaragdakis and D. Batory. Application generators. Encyclopedia of \nElectrical and Electronics Engineering, 2000. J.G. Webster (ed.), John Wiley and Sons. [41] http://www.stratego-language.org. \n[42] K. Tao, W. Wang, and J. Palsberg. Java Tree Builder (JTB). http://www.cs.purdue.edu/jtb/. [43] M. \nTomita. E.cient Parsing for Natural Languages. A Fast Algorithm for Practical Systems.Kluwer Academic \nPublishers, 1985. [44] E. Visser. Scannerless generalized-LR parsing. Technical Report P9707, Programming \nResearch Group, University of Amsterdam, July 1997. [45] E. Visser. Syntax De.nition for Language Prototyping. \nPhD thesis, University of Amsterdam, September 1997. [46] E. Visser. Meta-programming with concrete object \nsyntax. In D. Batory, C. Consel, and W. Taha, editors, Generative Programming and Component Engineering \n(GPCE 02), volume 2487 of Lecture Notes in Computer Science, pages 299 315, Pittsburgh, PA, USA, October \n2002. Springer-Verlag. [47] E. Visser. Program transformation with Stratego/XT: Rules, strategies, tools, \nand systems in StrategoXT-0.9. In C. Lengauer et al., editors, Domain-Speci.c Program Generation, volume \n3016 of Lecture Notes in Computer Science, pages 216 238. Spinger-Verlag, June 2004. [48] E. Visser, \nZ.-e.-A. Benaissa, and A. Tolmach. Building program optimizers with rewriting strategies. In Proceedings \nof the third ACM SIGPLAN International Conference on Functional Programming (ICFP 98), pages 13 26. ACM \nPress, September 1998. [49] J. Visser. Visitor combination and traversal control. In Proceedings of the \n16th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA \n01), pages 270 282. ACM Press, 2001. [50] D. Weise and R. Crew. Programmable syntax macros. In Proceedings \nof the ACM SIGPLAN 1993 conference on Programming language design and implementation (PLDI 93), pages \n156 165. ACM Press, 1993. [51] The Xtatic project: Native XML processing for C#. http://www.cis.upenn.edu/~bcpierce/xtatic/. \n \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Application programmer's interfaces give access to domain knowledge encapsulated in class libraries without providing the appropriate notation for expressing domain composition. Since object-oriented languages are designed for extensibility and reuse, the language constructs are often sufficient for expressing domain abstractions at the semantic level. However, they do not provide the right abstractions at the syntactic level. In this paper we describe MetaBorg, a method for providing &#60;i>concrete syntax&#60;/i> for domain abstractions to application programmers. The method consists of &#60;i>embedding&#60;/i> domain-specific languages in a general purpose host language and &#60;i>assimilating&#60;/i> the embedded domain code into the surrounding host code. Instead of extending the implementation of the host language, the assimilation phase implements domain abstractions in terms of existing APIs leaving the host language undisturbed. Indeed, MetaBorg can be considered a method for promoting APIs to the language level. The method is supported by proven and available technology, i.e. the syntax definition formalism SDF and the program transformation language and toolset Stratego/XT. We illustrate the method with applications in three domains: code generation, XML generation, and user-interface construction.</p>", "authors": [{"name": "Martin Bravenboer", "author_profile_id": "81100378172", "affiliation": "Universiteit Utrecht, Utrecht, The Netherlands", "person_id": "PP18001442", "email_address": "", "orcid_id": ""}, {"name": "Eelco Visser", "author_profile_id": "81100561215", "affiliation": "Universiteit Utrecht, Utrecht, The Netherlands", "person_id": "PP43121329", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029007", "year": "2004", "article_id": "1029007", "conference": "OOPSLA", "title": "Concrete syntax for objects: domain-specific language embedding and assimilation without restrictions", "url": "http://dl.acm.org/citation.cfm?id=1029007"}